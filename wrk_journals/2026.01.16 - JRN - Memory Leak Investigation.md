# Memory Leak Investigation - mdmdview

**Date**: 2026-01-16
**Issue**: Potential memory leak when viewing documents with Mermaid diagrams for extended periods
**Symptom**: Application using 32GB+ RAM

## Investigation Plan

1. **Mermaid Rendering System** - Primary suspect
   - QuickJS runtime lifecycle
   - Mermaid texture caching
   - Repeated diagram renders on frame redraws

2. **Texture/Image Caching**
   - Image cache growth patterns
   - Texture memory management
   - Cache invalidation logic

3. **Element Tracking**
   - `element_rects` HashMap growth
   - Navigation history unbounded growth
   - Search state accumulation

4. **General Memory Patterns**
   - Parsed content caching
   - UI state accumulation
   - egui texture management

---

## Investigation Log

### Entry 1 - 2026-01-16 - Initial Assessment

Starting comprehensive investigation. Launching parallel code reviews of:
- Mermaid rendering (`markdown_renderer.rs` - Mermaid sections)
- Texture caching system
- QuickJS runtime management
- Collection growth patterns

**Status**: COMPLETED

---

### Entry 2 - 2026-01-16 - CRITICAL FINDINGS

After comprehensive parallel investigation of all memory-related code paths, I've identified **multiple critical memory leak issues** that together explain the 32GB+ RAM consumption.

## CRITICAL ISSUE #1: emoji_textures HashMap - UNBOUNDED GROWTH

**Location**: `c:\language\mdmdview\src\markdown_renderer.rs:371`

```rust
emoji_textures: RefCell<HashMap<String, egui::TextureHandle>>,
```

**Problem**:
- Plain `HashMap<String, egui::TextureHandle>` with **NO capacity limit**
- **NEVER cleared** - not even when switching files
- Every unique emoji encountered creates a permanent texture entry
- On file load (line 752), only `clear_table_layout_cache()` is called, NOT emoji clearing

**Evidence**:
- Line 3047-3049: `emoji_textures.borrow_mut().insert(emoji.to_string(), handle.clone())`
- No `.clear()` call for `emoji_textures` anywhere in the codebase

**Memory Impact**:
- Each 64x64 RGBA emoji texture = ~16KB raw + egui overhead = ~50-100KB
- 1000 unique emojis = 50-100MB
- Heavy emoji usage across many files = unbounded growth

**Severity**: ðŸ”´ CRITICAL

---

## CRITICAL ISSUE #2: image_failures HashMap - UNBOUNDED GROWTH

**Location**: `c:\language\mdmdview\src\markdown_renderer.rs:374`

```rust
image_failures: RefCell<HashMap<String, ImageFailure>>,
```

**Problem**:
- Plain HashMap with **NO capacity limit**
- Entries removed only on successful retry (line 4986)
- Failed images stay indefinitely
- Never cleared on file change

**Memory Impact**: Lower than emoji_textures but still unbounded

**Severity**: ðŸŸ  HIGH

---

## ISSUE #3: egui Texture Manager Accumulation

**Problem**: When textures are evicted from LRU caches (Mermaid, images), the `TextureHandle` is dropped from the local HashMap, but:
- **No `forget_image()` or similar egui API calls** to explicitly release textures
- egui's internal texture manager may retain references
- Searched codebase: no `forget_image`, `forget_texture`, `free_texture` calls found

**Evidence**:
- Mermaid LRU cache evict_oldest (lines 371-378) only removes from HashMap
- Image cache eviction similarly just removes from local storage
- No egui texture cleanup calls anywhere

**Severity**: ðŸŸ  HIGH (potential GPU memory leak)

---

## ISSUE #4: mermaid_pending HashSet - Potentially Unbounded

**Location**: `c:\language\mdmdview\src\mermaid_renderer.rs:446`

```rust
mermaid_pending: RefCell<HashSet<String>>,
```

**Mitigating Factors**:
- Entries ARE removed when results come back (line 906)
- Job queue is bounded (MAX_MERMAID_JOBS * 4 = 16)

**Risk**: LOW - Self-limiting in practice

---

## ISSUE #5: QuickJS Memory Limits

**Location**: `c:\language\mdmdview\src\mermaid_renderer.rs:1450-1451`

```rust
const MEMORY_LIMIT_BYTES: usize = 2 * 1024 * 1024 * 1024;  // 2GB per worker!
```

**Problem**:
- 2GB limit per worker Ã— N workers (default = CPU count, up to 16)
- Could allow 16GB+ of QuickJS allocations
- JavaScript `__mdmdview_text_cache` global grows unbounded within worker

**Severity**: ðŸŸ¡ MODERATE

---

## PROPERLY BOUNDED (No Issues Found)

| Component | Location | Capacity | Status |
|-----------|----------|----------|--------|
| `image_textures` (ImageCache) | markdown_renderer.rs:372 | 256 | âœ… LRU eviction |
| `mermaid_textures` | mermaid_renderer.rs:444 | 128 | âœ… LRU eviction |
| `mermaid_svg_cache` | mermaid_renderer.rs:450 | 64 | âœ… LRU eviction |
| `mermaid_errors` | mermaid_renderer.rs:452 | 64 | âœ… LRU eviction |
| `mermaid_texture_errors` | mermaid_renderer.rs:454 | 64 | âœ… LRU eviction |
| `header_rects` | markdown_renderer.rs:378 | Per-doc | âœ… Cleared per frame |
| `element_rects` | markdown_renderer.rs:386 | Per-doc | âœ… Cleared per frame |
| Navigation history | app.rs:342 | 50 entries | âœ… Bounded |
| `pending_files` | app.rs:351 | 50 files | âœ… Bounded |
| `table_layout_cache` | markdown_renderer.rs:393 | 512 | âœ… LRU eviction |

---

## ROOT CAUSE ANALYSIS

The 32GB memory leak is most likely caused by **compound accumulation**:

1. **Primary**: `emoji_textures` unbounded HashMap accumulating textures across all opened files
2. **Secondary**: `image_failures` accumulating entries for missing images
3. **Tertiary**: Potential egui texture manager accumulation from evicted textures
4. **Amplifier**: Large QuickJS memory limits allowing substantial allocations

**Reproduction scenario**:
1. Open file with 20 emojis â†’ 20 textures cached (~10MB)
2. Open another file with 15 different emojis â†’ 35 total (~17MB)
3. Open 100+ files with varying emojis â†’ 500+ textures (~50-100MB)
4. Scroll/zoom Mermaid diagrams â†’ texture variants accumulate
5. Over extended period â†’ 32GB reached

---

## RECOMMENDED FIXES

### Fix #1: Add Bounded LRU Cache for emoji_textures (CRITICAL)

```rust
// Replace:
emoji_textures: RefCell<HashMap<String, egui::TextureHandle>>,

// With:
emoji_textures: RefCell<LruCache<String, egui::TextureHandle>>,
const EMOJI_TEXTURE_CACHE_CAPACITY: usize = 512;
```

### Fix #2: Add Bounded Cache for image_failures (HIGH)

```rust
const IMAGE_FAILURE_CACHE_CAPACITY: usize = 256;

// In should_retry_image() or load_content():
if self.image_failures.borrow().len() >= IMAGE_FAILURE_CACHE_CAPACITY {
    // Prune oldest failures
}
```

### Fix #3: Clear Texture Caches on File Load (HIGH)

```rust
// In app.rs load_content() after line 752:
self.renderer.clear_emoji_cache();
self.renderer.clear_image_failure_cache();
```

### Fix #4: Consider Explicit egui Texture Cleanup (MODERATE)

Research if egui provides `forget_image()` or similar API to explicitly release textures when evicting from caches.

### Fix #5: Reduce QuickJS Memory Limit (LOW)

```rust
// Change from 2GB to 256MB or 512MB:
const MEMORY_LIMIT_BYTES: usize = 256 * 1024 * 1024;
```

---

## VERIFICATION STEPS

1. Add logging to track cache sizes:
   ```rust
   eprintln!("emoji_textures: {}", self.emoji_textures.borrow().len());
   ```

2. Monitor RSS while opening many files:
   ```bash
   watch -n 1 'tasklist /FI "IMAGENAME eq mdmdview.exe" /FO LIST | findstr "Mem"'
   ```

3. Test with emoji-heavy and Mermaid-heavy documents

---

## EGUI TEXTURE LIFECYCLE CLARIFICATION

Using egui 0.27.2. Key behavior:
- `ctx.load_texture(name, ...)` creates a texture with that name
- `TextureHandle` uses reference counting - when all handles dropped, texture is freed
- Since `emoji_textures` HashMap holds handles indefinitely, those textures are NEVER freed

**Mermaid textures**: The LRU eviction (capacity 128) SHOULD properly free textures when handles are dropped, assuming no other references exist. The concern about egui texture manager accumulation is likely unfounded for Mermaid.

**Emoji textures**: CONFIRMED LEAK - handles held forever in unbounded HashMap.

---

## CONCLUSION

**Root Cause Identified**: The primary leak is the unbounded `emoji_textures` HashMap which holds TextureHandles forever, preventing egui from freeing the textures. Secondary issue is `image_failures` HashMap growing unboundedly.

**Confidence**: HIGH - Code analysis definitively shows unbounded growth in `emoji_textures` (never cleared, no capacity limit).

**Priority**:
1. CRITICAL: Convert `emoji_textures` to bounded LRU cache
2. HIGH: Add capacity limit to `image_failures`
3. MODERATE: Reduce QuickJS per-worker memory limit from 2GB

**Investigation Status**: COMPLETE


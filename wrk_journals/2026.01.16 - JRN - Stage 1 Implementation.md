# Stage 1 Implementation Journal - Generic LRU Cache

**Date**: 2026-01-16
**Task**: Implement Stage 1 of Memory Leak Fix Plan
**Approach**: Test-Driven Development (TDD)

---

## Goal

Create a reusable generic `LruCache<K, V>` struct that can be used for:
- `emoji_textures` (Stage 2)
- `image_failures` (Stage 3)

## Plan

1. Write unit tests first (TDD - Red phase)
2. Implement `LruCache<K, V>` to make tests pass (Green phase)
3. Refactor if needed (Refactor phase)
4. Add capacity constants

---

## Implementation Log

### Entry 1 - Starting Implementation

**Time**: Starting now

**First step**: Read current markdown_renderer.rs to understand:
- Where to add the LruCache
- Existing similar implementations to reference (ImageCache, CellLayoutCache)
- Test patterns used in the file

**Status**: COMPLETED

---

### Entry 2 - Implementation Complete

**Location**: `c:\language\mdmdview\src\markdown_renderer.rs:162-253`

**Added Constants**:
```rust
const EMOJI_TEXTURE_CACHE_CAPACITY: usize = 512;
const IMAGE_FAILURE_CACHE_CAPACITY: usize = 256;
```

**Added Generic LruCache**:
```rust
struct LruCache<K, V> {
    entries: HashMap<K, V>,
    order: VecDeque<K>,
    capacity: usize,
}

impl<K, V> LruCache<K, V>
where
    K: Eq + std::hash::Hash + Clone,
    V: Clone,
{
    fn new(capacity: usize) -> Self
    fn get(&self, key: &K) -> Option<V>
    fn contains_key(&self, key: &K) -> bool
    fn insert(&mut self, key: K, value: V)
    fn remove(&mut self, key: &K)
    fn clear(&mut self)
    fn len(&self) -> usize
    fn touch(&mut self, key: &K)
}
```

**Unit Tests Added** (9 tests at lines 5684-5820):
1. `test_lru_cache_basic_insert_and_get` - Basic operations
2. `test_lru_cache_evicts_oldest_entry` - LRU eviction when at capacity
3. `test_lru_cache_touch_updates_order` - touch() moves entry to back
4. `test_lru_cache_insert_existing_updates_value_and_order` - Re-insert updates value and order
5. `test_lru_cache_remove` - Remove entries by key
6. `test_lru_cache_clear` - Clear all entries
7. `test_lru_cache_capacity_enforcement` - Capacity never exceeded
8. `test_lru_cache_touch_nonexistent_key` - touch() on missing key is no-op
9. `test_lru_cache_zero_capacity` - Zero capacity stores nothing

**Test Results**:
- All 811 tests pass (including 9 new LruCache tests + 12 existing mermaid LruCache tests)
- Release build succeeds
- Expected warnings about unused code (will be used in Stages 2 and 3)

**TDD Process Followed**:
1. ✅ Red: Wrote failing tests first (tests needed struct to compile)
2. ✅ Green: Implemented LruCache to make tests pass
3. ✅ Fixed edge case: Zero capacity insert was incorrectly storing (fixed)
4. ✅ All tests pass

**Status**: STAGE 1 COMPLETE

---

### Entry 3 - Stage 2 Complete: emoji_textures Converted

**Changes**:
- `c:\language\mdmdview\src\markdown_renderer.rs:464` - Changed type to `LruCache<String, egui::TextureHandle>`
- `c:\language\mdmdview\src\markdown_renderer.rs:846` - Changed initialization to `LruCache::new(EMOJI_TEXTURE_CACHE_CAPACITY)`
- `c:\language\mdmdview\src\markdown_renderer.rs:3097-3141` - Updated `get_or_make_emoji_texture` to use LruCache API

**Test Results**: All 811 tests pass (2 flaky timeouts on individual run, pass when run separately)

**Status**: STAGE 2 COMPLETE

---

### Entry 4 - Stage 3 Complete: image_failures Converted

**Changes**:
- `c:\language\mdmdview\src\markdown_renderer.rs:433` - Added `#[derive(Clone)]` to `ImageFailure`
- `c:\language\mdmdview\src\markdown_renderer.rs:468` - Changed type to `LruCache<String, ImageFailure>`
- `c:\language\mdmdview\src\markdown_renderer.rs:850` - Changed initialization to `LruCache::new(IMAGE_FAILURE_CACHE_CAPACITY)`
- `c:\language\mdmdview\src\markdown_renderer.rs:5103-5112` - Updated `should_retry_image` for LruCache API
- `c:\language\mdmdview\src\markdown_renderer.rs:9579, 10167` - Updated test assertions for `contains_key(&String)`

**Test Results**: All related tests pass, release build succeeds

**Status**: STAGE 3 COMPLETE

---

## Summary - Stages 1-3 Complete

Both critical unbounded HashMaps have been converted to bounded LruCache:

| Cache | Old Type | New Type | Capacity |
|-------|----------|----------|----------|
| `emoji_textures` | `HashMap<String, TextureHandle>` | `LruCache<String, TextureHandle>` | 512 |
| `image_failures` | `HashMap<String, ImageFailure>` | `LruCache<String, ImageFailure>` | 256 |

**Memory Impact**:
- `emoji_textures`: Now bounded at 512 entries (~25-50MB max vs unbounded)
- `image_failures`: Now bounded at 256 entries (minimal memory, prevents list growth)

**Remaining Stages** (from implementation plan):
- Stage 4: QuickJS memory limit reduction
- Stage 5: JavaScript text cache clearing
- Stage 6: Cache clearing on file load
- Stage 7: egui texture cleanup research
- Stage 8: Logging infrastructure
- Stage 9: SVG cache size-based eviction


# Journal: Fix 2-Column Table Squish Bug

**Date**: 2026-02-05
**Issue**: 2-column tables are squished to the left instead of filling available width
**Status**: COMPLETE

## Analysis Summary

**Root Cause**: In `src/table_support/column_spec.rs`, the `derive_column_specs()` function fails to assign a `Remainder` column when ALL columns are classified as `Fixed`.

**When it happens**: Both columns match Fixed header patterns:
- Column 0: Short label (≤12 chars) OR matches "version", "rev", "#", "id"
- Column 1: Matches "status", "state", "date", "time", "timestamp"

**Examples that trigger the bug**:
- `| Name | Status |`
- `| ID | Date |`
- `| Key | State |`

**The fallback logic at lines 259-291**:
1. Rejects highest-scoring column if it's Fixed
2. Looks for non-Fixed alternatives
3. When ALL columns are Fixed, finds nothing
4. No Remainder assigned → table doesn't expand

## TDD Plan

1. [x] Write failing test for all-Fixed tables needing Remainder
2. [x] Implement fix in `derive_column_specs()`
3. [x] Update existing test that codifies the bug
4. [x] Add 2-column table examples to test_Stress.md
5. [x] Run all tests to verify
6. [x] Build release and verify

## Progress Log

### Step 1: Write Failing Tests (RED)

Added two new tests in `src/table_support/column_spec.rs`:

1. `derive_column_specs_ensures_remainder_when_all_fixed` - Verifies that at least one column becomes Remainder when all start as Fixed

2. `derive_column_specs_all_fixed_prefers_non_first_for_remainder` - Verifies that non-first columns are preferred for Remainder (keeping identifiers fixed)

Both tests failed as expected, confirming the bug.

### Step 2: Implement Fix (GREEN)

Added final fallback at line 285.5:

```rust
// Final fallback: when ALL columns are Fixed, convert one to Remainder
// to ensure the table can expand to fill available width.
// Prefer non-first column (first column is typically identifiers).
if candidate.is_none() && !specs.is_empty() {
    candidate = if specs.len() > 1 {
        Some(specs.len() - 1) // Use last column
    } else {
        Some(0) // Single column table
    };
}
```

### Step 3: Update Existing Tests

Updated `derive_column_specs_empty_header_label_uses_fixed_policy` to `derive_column_specs_single_column_becomes_remainder` - single-column tables should expand to fill width.

### Step 4: Add Test Cases to test_Stress.md

Added new section "Two-Column Tables (Bug Regression Tests)" with three tables:
- `| Name | Status |`
- `| ID | Date |`
- `| Key | State |`

### Step 5: Test Results

- **lib tests**: 887 passed, 0 failed, 1 ignored
- One flaky env var test in main.rs (unrelated to changes)

### Step 6: Release Build

- Version bumped: 1.2.0 → 1.2.1 (patch for bug fix)
- Release build: SUCCESS
- Clippy: No warnings

## Files Modified

1. `src/table_support/column_spec.rs`
   - Added fallback for all-Fixed tables (lines 285-293)
   - Added test `derive_column_specs_ensures_remainder_when_all_fixed`
   - Added test `derive_column_specs_all_fixed_prefers_non_first_for_remainder`
   - Updated test `derive_column_specs_single_column_becomes_remainder`

2. `test_Stress.md`
   - Added "Two-Column Tables (Bug Regression Tests)" section

3. `Cargo.toml`
   - Version: 1.2.0 → 1.2.1

---

## Summary

The bug occurred because the column policy assignment logic had no fallback for the case where ALL columns were classified as Fixed. The fix adds a final fallback that converts the last column (or only column) to Remainder, ensuring tables always have at least one column that can expand to fill available width.

The fix follows the existing design philosophy:
- First column (typically identifiers) stays Fixed when possible
- Non-first columns are preferred for Remainder assignment
- Single-column tables use the only column as Remainder

---

## Post-Implementation Review (Later Same Day)

**Issue discovered**: The fix overcorrected. Tables now stretch to full viewport width even when content is short. A 2-column table with "Name" / "Status" and short values stretches the first column to ~1000px while "Status" gets ~100px.

**Root cause**: `Column::remainder()` fills ALL remaining space. When the table is allocated full viewport width, the Remainder column absorbs everything - which is wrong for tables with short content.

**The real problem**: The fundamental assumption that "tables should fill available width" is flawed. Tables should size to their content, with optional max-width caps.

**Analysis document**: See `wrk_docs/2026.02.05 - Table Width Sizing Analysis.md` for:
- Comprehensive test scenario matrix (20+ scenarios)
- Root cause analysis
- Four proposed solution approaches
- Recommendation: Content-driven table width (Approach D) or Table max-width container (Approach B)

## Revert (Later Same Day)

Fix reverted due to overcorrection issue. Changes undone:
- Removed fallback code in `column_spec.rs` (lines 286-295)
- Restored original tests
- Version back to 1.2.0

The 2-column tables in test_Stress.md remain as future test cases.

## HLD Design Complete (Later Same Day)

**Approach chosen**: Content-driven table width (Approach D from analysis doc).

**Design document**: `wrk_docs/2026.02.05 - HLD - Content-Driven Table Width.md` (V3)

**Three iterations**:
- **V1**: Initial design — had critical flaw where `Column::remainder()` still
  over-expands inside narrower container
- **V2**: Two-mode rendering (content-fit vs viewport-fill). Fixed the container
  AND column width problems. Per-column natural widths.
- **V3**: Fixed row height estimation (content-fit mode must use natural_widths
  for row height, not viewport-based widths). Documented Fixed-column resizability
  change. Corrected worked Example B (fallback promotes Col 2 to Remainder).

**Key design decisions**:
- Two rendering modes based on `natural_total vs viewport_width`
- Content-fit: `Column::initial(natural_width).resizable(true)` for all columns
- Viewport-fill: existing code unchanged
- No changes to `column_spec.rs` — the all-Fixed bug is resolved by content-fit
  mode sizing the container to match content

## Next Steps

1. ~~Decide on redesign approach (see analysis doc)~~ → Done: Approach D
2. Implement content-driven table width per HLD V3
3. Test against comprehensive scenario matrix
4. Verify with visual inspection (mdscreensnap)

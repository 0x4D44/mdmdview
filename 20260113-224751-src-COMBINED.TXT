File: src\app.rs

/// Main application logic for the markdown viewer
///
/// This module contains the primary app state, UI logic, and event handling
/// for the markdown viewer application built with egui.
use crate::{MarkdownElement, MarkdownRenderer, SampleFile, WindowState, SAMPLE_FILES};
use anyhow::{bail, Result};
use crossbeam_channel::{unbounded, Receiver, Sender};
use egui::text::LayoutJob;
use egui::text::TextFormat;
use egui::{menu, CentralPanel, Color32, Context, RichText, TopBottomPanel};
use egui::{TextEdit, TextStyle};
use image::{imageops, RgbaImage};
#[cfg(not(test))]
use rfd::FileDialog;
#[cfg(test)]
use std::cell::RefCell;
#[cfg(test)]
use std::collections::HashSet;
use std::collections::VecDeque;
use std::io::ErrorKind;
use std::path::{Path, PathBuf};
#[cfg(test)]
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::{Duration, Instant};
use unicode_casefold::UnicodeCaseFold;
use unicode_normalization::UnicodeNormalization;

/// Prefix used for application/window titles.
pub const APP_TITLE_PREFIX: &str = "mdmdview";
const BUILD_VERSION: &str = env!("CARGO_PKG_VERSION");
const BUILD_TIMESTAMP: &str = env!("MDMDVIEW_BUILD_TIMESTAMP");
const ASYNC_LOAD_THRESHOLD_BYTES: u64 = 2 * 1024 * 1024;

#[cfg(test)]
thread_local! {
    static FORCED_APP_ACTIONS: RefCell<HashSet<&'static str>> = RefCell::new(HashSet::new());
    static FORCED_OPEN_PATH: RefCell<Option<PathBuf>> = const { RefCell::new(None) };
    static FORCED_SAVE_PATH: RefCell<Option<PathBuf>> = const { RefCell::new(None) };
    static FORCED_LOAD_ERROR: RefCell<bool> = const { RefCell::new(false) };
    static FORCED_SCAN_ERROR: RefCell<bool> = const { RefCell::new(false) };
    static FORCED_SCAN_ENTRY_ERROR: RefCell<bool> = const { RefCell::new(false) };
    static FORCED_READ_LOSSY_ERROR: RefCell<bool> = const { RefCell::new(false) };
}

#[cfg(test)]
static FORCE_THREAD_SPAWN_ERROR: AtomicBool = AtomicBool::new(false);

#[cfg(test)]
fn app_action_triggered(triggered: bool, action: &'static str) -> bool {
    triggered || FORCED_APP_ACTIONS.with(|actions| actions.borrow().contains(action))
}

#[cfg(not(test))]
fn app_action_triggered(triggered: bool, _action: &'static str) -> bool {
    triggered
}

#[cfg(test)]
fn take_forced_open_path() -> Option<PathBuf> {
    FORCED_OPEN_PATH.with(|slot| slot.borrow_mut().take())
}

#[cfg(test)]
fn take_forced_save_path() -> Option<PathBuf> {
    FORCED_SAVE_PATH.with(|slot| slot.borrow_mut().take())
}

#[cfg(test)]
fn take_forced_load_error() -> bool {
    FORCED_LOAD_ERROR.with(|flag| flag.replace(false))
}

#[cfg(test)]
fn take_forced_scan_error() -> bool {
    FORCED_SCAN_ERROR.with(|flag| flag.replace(false))
}

#[cfg(test)]
fn take_forced_scan_entry_error() -> bool {
    FORCED_SCAN_ENTRY_ERROR.with(|flag| flag.replace(false))
}

#[cfg(test)]
fn take_forced_read_lossy_error() -> bool {
    FORCED_READ_LOSSY_ERROR.with(|flag| flag.replace(false))
}

/// Entry in navigation history for back/forward navigation
#[derive(Clone, Debug)]
struct HistoryEntry {
    file_path: Option<PathBuf>,
    title: String,
    content: String,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ScreenshotTheme {
    Light,
    Dark,
}

impl ScreenshotTheme {
    fn as_str(self) -> &'static str {
        match self {
            ScreenshotTheme::Light => "light",
            ScreenshotTheme::Dark => "dark",
        }
    }
}

#[derive(Clone, Debug)]
pub struct ScreenshotConfig {
    pub output_path: PathBuf,
    pub viewport_width: f32,
    pub viewport_height: f32,
    pub content_only: bool,
    pub scroll_ratio: Option<f32>,
    pub wait_ms: u64,
    pub settle_frames: u32,
    pub zoom: f32,
    pub theme: ScreenshotTheme,
    pub font_source: Option<String>,
}

impl ScreenshotConfig {
    fn metadata_path(&self) -> PathBuf {
        self.output_path.with_extension("json")
    }
}

#[derive(Clone, Copy, Debug)]
struct ScrollSnapshot {
    content_size: egui::Vec2,
    inner_rect: egui::Rect,
    offset_y: f32,
}

#[derive(Debug, Clone, Copy)]
struct WindowAdjustment {
    pos: Option<egui::Pos2>,
    size: Option<egui::Vec2>,
}

struct FileLoadRequest {
    id: u64,
    path: PathBuf,
}

struct FileLoadResult {
    id: u64,
    content: Result<(String, bool), String>,
}

#[derive(Clone)]
struct PendingFileLoad {
    id: u64,
    path: PathBuf,
}

#[derive(Debug)]
struct ScreenshotState {
    config: ScreenshotConfig,
    started: Instant,
    stable_frames: u32,
    last_layout_hash: Option<u64>,
    last_scroll_offset: Option<f32>,
    scroll_offset: Option<f32>,
    content_rect: Option<egui::Rect>,
    last_content_size: Option<egui::Vec2>,
    last_inner_rect: Option<egui::Rect>,
    pixels_per_point: f32,
    viewport_adjusted: bool,
    requested: bool,
    done: bool,
    timed_out: bool,
    pending_renders: bool,
}

#[derive(Clone, Debug)]
struct ScreenshotSnapshot {
    config: ScreenshotConfig,
    content_rect: Option<egui::Rect>,
    pixels_per_point: f32,
    stable_frames: u32,
    timed_out: bool,
    pending_renders: bool,
    last_scroll_offset: Option<f32>,
    started: Instant,
}

impl ScreenshotState {
    fn new(config: ScreenshotConfig) -> Self {
        Self {
            config,
            started: Instant::now(),
            stable_frames: 0,
            last_layout_hash: None,
            last_scroll_offset: None,
            scroll_offset: None,
            content_rect: None,
            last_content_size: None,
            last_inner_rect: None,
            pixels_per_point: 1.0,
            viewport_adjusted: false,
            requested: false,
            done: false,
            timed_out: false,
            pending_renders: false,
        }
    }

    fn record_scroll(&mut self, snapshot: ScrollSnapshot) -> bool {
        self.last_content_size = Some(snapshot.content_size);
        self.last_inner_rect = Some(snapshot.inner_rect);
        self.last_scroll_offset = Some(snapshot.offset_y);

        if self.scroll_offset.is_none() {
            if let Some(ratio) = self.config.scroll_ratio {
                let max_scroll = (snapshot.content_size.y - snapshot.inner_rect.height()).max(0.0);
                self.scroll_offset = Some((max_scroll * ratio).round());
                return true;
            }
        }
        false
    }

    fn scroll_ready(&self) -> bool {
        match (
            self.config.scroll_ratio,
            self.scroll_offset,
            self.last_scroll_offset,
        ) {
            (None, _, _) => true,
            (Some(_), Some(target), Some(actual)) => (actual - target).abs() <= 0.5,
            _ => false,
        }
    }

    fn update_stability(&mut self, layout_hash: Option<u64>, scroll_offset: Option<f32>) {
        let mut changed = false;
        if let Some(hash) = layout_hash {
            if self.last_layout_hash != Some(hash) {
                changed = true;
            }
            self.last_layout_hash = Some(hash);
        } else {
            changed = true;
        }

        if let (Some(prev), Some(current)) = (self.last_scroll_offset, scroll_offset) {
            if (prev - current).abs() > 0.5 {
                changed = true;
            }
        }

        if changed {
            self.stable_frames = 0;
        } else {
            self.stable_frames = self.stable_frames.saturating_add(1);
        }
    }
}

impl From<&ScreenshotState> for ScreenshotSnapshot {
    fn from(state: &ScreenshotState) -> Self {
        Self {
            config: state.config.clone(),
            content_rect: state.content_rect,
            pixels_per_point: state.pixels_per_point,
            stable_frames: state.stable_frames,
            timed_out: state.timed_out,
            pending_renders: state.pending_renders,
            last_scroll_offset: state.last_scroll_offset,
            started: state.started,
        }
    }
}

/// Main application state and logic
pub struct MarkdownViewerApp {
    /// Markdown renderer instance
    renderer: MarkdownRenderer,
    /// Currently loaded file path
    current_file: Option<PathBuf>,
    /// Current markdown content as string
    current_content: String,
    /// Buffer for raw view (read-only for now)
    raw_buffer: String,
    /// Parsed markdown elements ready for rendering
    parsed_elements: Vec<MarkdownElement>,
    /// Application title for window
    title: String,
    /// Error message to display if any
    error_message: Option<String>,
    /// Navigation request for keyboard shortcuts
    nav_request: Option<NavigationRequest>,
    /// Scroll area ID for state management
    scroll_area_id: egui::Id,
    /// Flag to request fullscreen toggle
    toggle_fullscreen: bool,
    /// Current view mode
    view_mode: ViewMode,
    /// Wrap long lines in raw view
    wrap_raw: bool,
    /// Write mode: allow editing in Raw view
    write_enabled: bool,
    /// Remember caret position in raw editor (byte index)
    raw_cursor: Option<usize>,
    /// Request focus for raw editor on next render
    raw_focus_requested: bool,
    /// Flag to request reload of current file (handled outside input context)
    reload_requested: bool,
    /// Defer toggling view mode to outside input context
    view_toggle_requested: bool,
    /// Defer toggling write mode to outside input context
    write_toggle_requested: bool,
    /// Last known window position (for persistence)
    last_window_pos: Option<[f32; 2]>,
    /// Last known window size (for persistence)
    last_window_size: Option<[f32; 2]>,
    /// Last known maximized state
    last_window_maximized: bool,
    /// Last persisted window snapshot to avoid redundant disk writes
    last_persisted_state: Option<WindowState>,
    /// Throttle saving window state
    last_persist_instant: std::time::Instant,
    file_load_tx: Sender<FileLoadRequest>,
    file_load_rx: Receiver<FileLoadResult>,
    pending_file_load: Option<PendingFileLoad>,
    next_file_load_id: u64,
    // Search state
    show_search: bool,
    search_query: String,
    last_query: String,
    last_match_index: Option<usize>,
    pending_scroll_to_element: Option<usize>,
    search_focus_requested: bool,
    /// Deferred caret movement (in lines) for raw editor
    pending_raw_cursor_line_move: Option<i32>,
    // Navigation history
    /// History of visited files and samples for back/forward navigation
    history: Vec<HistoryEntry>,
    /// Current position in history
    history_index: usize,
    /// Maximum history entries to keep
    max_history: usize,
    // Drag and drop state
    /// Visual state: file is being dragged over window
    drag_hover: bool,
    /// Queue of files waiting to be opened (from multi-file drop)
    pending_files: VecDeque<PathBuf>,
    screenshot: Option<ScreenshotState>,
}

/// Navigation request for keyboard-triggered scrolling
#[derive(Debug, Clone)]
enum NavigationRequest {
    Top,
    Bottom,
    PageUp,
    PageDown,
    ScrollUp,   // Arrow up - fine scrolling
    ScrollDown, // Arrow down - fine scrolling
}

/// Which view the user is in
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ViewMode {
    Rendered,
    Raw,
}

impl MarkdownViewerApp {
    fn toggle_write_mode(&mut self, ctx: &Context) {
        if self.write_enabled {
            // About to disable; capture current cursor if in Raw view
            if matches!(self.view_mode, ViewMode::Raw) {
                let editor_id = egui::Id::new("raw_editor");
                if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
                    if let Some(range) = state.cursor.char_range() {
                        self.raw_cursor = Some(range.primary.index);
                    }
                }
            }
            self.write_enabled = false;
        } else {
            // Enabling write mode: ensure the raw editor will gain focus
            self.write_enabled = true;
            if matches!(self.view_mode, ViewMode::Raw) {
                self.raw_focus_requested = true;
            }
        }
    }

    fn move_raw_cursor_lines(&mut self, ctx: &Context, delta_lines: i32) {
        if !matches!(self.view_mode, ViewMode::Raw) || !self.write_enabled {
            return;
        }
        let editor_id = egui::Id::new("raw_editor");
        if let Some(mut state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
            let mut idx = state
                .cursor
                .char_range()
                .map(|r| r.primary.index)
                .unwrap_or_else(|| self.raw_cursor.unwrap_or(0))
                .min(self.raw_buffer.len());

            let s = self.raw_buffer.as_str();
            match delta_lines.cmp(&0) {
                std::cmp::Ordering::Less => {
                    let mut lines = -delta_lines;
                    // Move to start of current line
                    idx = s[..idx].rfind('\n').map(|p| p + 1).unwrap_or(0);
                    while lines > 0 && idx > 0 {
                        if let Some(prev_nl) = s[..idx.saturating_sub(1)].rfind('\n') {
                            idx = prev_nl + 1;
                        } else {
                            idx = 0;
                        }
                        lines -= 1;
                    }
                }
                std::cmp::Ordering::Greater => {
                    let mut lines = delta_lines;
                    // Move to start of next line
                    if let Some(nl) = s[idx..].find('\n') {
                        idx = (idx + nl + 1).min(s.len());
                        lines -= 1;
                    }
                    while lines > 0 && idx < s.len() {
                        if let Some(nl) = s[idx..].find('\n') {
                            idx = (idx + nl + 1).min(s.len());
                        } else {
                            idx = s.len();
                        }
                        lines -= 1;
                    }
                }
                std::cmp::Ordering::Equal => {}
            }
            let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(idx));
            state.cursor.set_char_range(Some(cr));
            state.store(ctx, editor_id);
            self.raw_cursor = Some(idx);
            self.raw_focus_requested = true; // keep focus and make caret visible
        }
    }
    fn clear_search_state(&mut self) {
        self.search_query.clear();
        self.last_query.clear();
        self.last_match_index = None;
        self.pending_scroll_to_element = None;
        self.renderer.set_highlight_phrase(None);
    }
    fn find_next(&mut self) {
        if self.search_query.is_empty() && self.last_query.is_empty() {
            return;
        }
        let needle = if !self.search_query.is_empty() {
            self.last_query = self.search_query.clone();
            Self::fold_for_search(&self.search_query)
        } else {
            Self::fold_for_search(&self.last_query)
        };
        let mut start = self.last_match_index.unwrap_or(usize::MAX);
        if start == usize::MAX {
            start = 0;
        } else {
            start = start.saturating_add(1);
        }
        // Wrap-around search forward
        let total = self.parsed_elements.len();
        for pass in 0..2 {
            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
                Box::new(start..total)
            } else {
                Box::new(0..start.min(total))
            };
            for idx in range {
                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
                    &self.parsed_elements[idx],
                );
                if Self::fold_for_search(&text).contains(&needle) {
                    self.last_match_index = Some(idx);
                    self.pending_scroll_to_element = Some(idx);
                    return;
                }
            }
        }
    }

    fn find_previous(&mut self) {
        if self.search_query.is_empty() && self.last_query.is_empty() {
            return;
        }
        let needle = if !self.search_query.is_empty() {
            self.last_query = self.search_query.clone();
            Self::fold_for_search(&self.search_query)
        } else {
            Self::fold_for_search(&self.last_query)
        };
        let total = self.parsed_elements.len();
        let mut start = self.last_match_index.unwrap_or(0);
        if start == 0 {
            start = total.saturating_sub(1);
        } else {
            start = start.saturating_sub(1);
        }
        // Wrap-around search backward
        for pass in 0..2 {
            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
                Box::new((0..=start).rev())
            } else {
                Box::new(((start + 1)..total).rev())
            };
            for idx in range {
                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
                    &self.parsed_elements[idx],
                );
                if Self::fold_for_search(&text).contains(&needle) {
                    self.last_match_index = Some(idx);
                    self.pending_scroll_to_element = Some(idx);
                    return;
                }
            }
        }
    }
    /// Create a new application instance
    pub fn new() -> Self {
        let (file_load_tx, file_load_rx) = Self::spawn_file_loader();
        let mut app = Self {
            renderer: MarkdownRenderer::new(),
            current_file: None,
            current_content: String::new(),
            raw_buffer: String::new(),
            parsed_elements: Vec::new(),
            title: APP_TITLE_PREFIX.to_string(),
            error_message: None,
            nav_request: None,
            scroll_area_id: egui::Id::new("main_scroll_area"),
            toggle_fullscreen: false,
            view_mode: ViewMode::Rendered,
            wrap_raw: false,
            write_enabled: false,
            raw_cursor: None,
            raw_focus_requested: false,
            reload_requested: false,
            view_toggle_requested: false,
            write_toggle_requested: false,
            last_window_pos: None,
            last_window_size: None,
            last_window_maximized: false,
            last_persisted_state: None,
            last_persist_instant: std::time::Instant::now(),
            file_load_tx,
            file_load_rx,
            pending_file_load: None,
            next_file_load_id: 0,
            show_search: false,
            search_query: String::new(),
            last_query: String::new(),
            last_match_index: None,
            pending_scroll_to_element: None,
            search_focus_requested: false,
            pending_raw_cursor_line_move: None,
            history: Vec::new(),
            history_index: 0,
            max_history: 50,
            drag_hover: false,
            pending_files: VecDeque::new(),
            screenshot: None,
        };
        // Load welcome content by default
        app.load_welcome_from_samples(SAMPLE_FILES, false);

        app
    }

    pub fn set_zoom_scale(&mut self, scale: f32) {
        self.renderer.set_zoom_scale(scale);
    }

    pub fn set_screenshot_mode(&mut self, config: ScreenshotConfig) {
        self.screenshot = Some(ScreenshotState::new(config));
        self.view_mode = ViewMode::Rendered;
        self.write_enabled = false;
        self.show_search = false;
        self.search_focus_requested = false;
        self.nav_request = None;
    }

    /// Check if file has valid markdown extension
    fn is_valid_markdown_file(&self, path: &Path) -> bool {
        if let Some(ext) = path.extension() {
            let ext = ext.to_string_lossy().to_lowercase();
            matches!(ext.as_str(), "md" | "markdown" | "mdown" | "mkd" | "txt")
        } else {
            false
        }
    }

    /// Handle dropped files from drag-and-drop operation
    fn handle_file_drop(&mut self, paths: Vec<PathBuf>) {
        if paths.is_empty() {
            return;
        }

        let mut valid_files = Vec::new();
        let mut errors = Vec::new();

        // Validate all dropped files
        for path in paths {
            if !path.exists() {
                errors.push(format!("File not found: {}", path.display()));
                continue;
            }

            if path.is_dir() {
                // Handle directory by scanning for markdown files
                match self.scan_directory(&path) {
                    Ok(dir_files) => {
                        if dir_files.is_empty() {
                            errors.push(format!(
                                "No markdown files in directory: {}",
                                path.display()
                            ));
                        } else {
                            valid_files.extend(dir_files);
                        }
                    }
                    Err(e) => {
                        errors.push(format!("Cannot read directory {}: {}", path.display(), e));
                    }
                }
                continue;
            }

            if !self.is_valid_markdown_file(&path) {
                errors.push(format!(
                    "Not a markdown file: {}",
                    path.file_name().unwrap_or_default().to_string_lossy()
                ));
                continue;
            }

            valid_files.push(path);
        }

        // Limit to prevent memory issues
        const MAX_FILES: usize = 50;
        if valid_files.len() > MAX_FILES {
            self.error_message = Some(format!(
                "Too many files ({}). Maximum is {}.\n\
                 Please drop files in smaller batches.",
                valid_files.len(),
                MAX_FILES
            ));
            return;
        }

        // Handle valid files
        if !valid_files.is_empty() {
            // Open first file immediately
            let first_file = valid_files.remove(0);
            if let Err(e) = self.load_file(first_file, true) {
                self.error_message = Some(format!("Failed to load file: {}", e));
                return;
            }

            // Queue remaining files
            self.pending_files.extend(valid_files.iter().cloned());

            // Show info message if multiple files
            if !self.pending_files.is_empty() {
                eprintln!(
                    "Queued {} files. Use Alt+Right to navigate to the next file.",
                    self.pending_files.len()
                );
            }
        }

        // Show errors if any
        if !errors.is_empty() {
            let valid_count = if valid_files.is_empty() {
                0
            } else {
                valid_files.len() + 1
            };
            let error_msg = if errors.len() == 1 && valid_count == 0 {
                errors[0].clone()
            } else if valid_count == 0 {
                // All files failed
                format!("No valid files:\n{}", errors.join("\n"))
            } else {
                // Some succeeded, some failed
                format!(
                    "Opened {} files. Skipped {}:\n{}",
                    valid_count,
                    errors.len(),
                    errors.join("\n")
                )
            };
            self.error_message = Some(error_msg);
        }
    }

    /// Resolve a directory entry result, allowing test hooks to force failures.
    fn resolve_scan_entry(entry: std::io::Result<std::fs::DirEntry>) -> Result<std::fs::DirEntry> {
        #[cfg(test)]
        if take_forced_scan_entry_error() {
            bail!("Forced scan entry error");
        }
        Ok(entry?)
    }

    /// Scan directory for markdown files (non-recursive)
    fn scan_directory(&self, dir: &Path) -> Result<Vec<PathBuf>> {
        #[cfg(test)]
        if take_forced_scan_error() {
            bail!("Forced scan error");
        }

        let mut files = Vec::new();

        let entries = std::fs::read_dir(dir)?;

        for entry in entries {
            let entry = Self::resolve_scan_entry(entry)?;
            let path = entry.path();

            // Only include files (not subdirectories)
            if path.is_file() && self.is_valid_markdown_file(&path) {
                files.push(path);
            }
        }

        // Sort alphabetically for predictable order
        files.sort();

        Ok(files)
    }

    /// Load markdown content from a string
    pub fn load_content(&mut self, content: &str, title: Option<String>) {
        self.pending_file_load = None;
        self.current_content = content.to_string();
        self.raw_buffer = self.current_content.clone();
        self.error_message = None;
        self.nav_request = None; // Reset any pending navigation
                                 // Ensure scroll resets to top on new content
        self.pending_scroll_to_element = Some(0);
        self.renderer.clear_table_layout_cache();

        match self.renderer.parse(content) {
            Ok(elements) => {
                self.parsed_elements = elements;
                if let Some(title) = title {
                    self.title = format!("{APP_TITLE_PREFIX} - {}", title);
                }
            }
            Err(e) => {
                self.error_message = Some(format!("Failed to parse markdown: {}", e));
                self.parsed_elements.clear();
            }
        }
    }

    /// Load markdown content from a file path
    pub fn load_file(&mut self, path: PathBuf, record_history: bool) -> Result<()> {
        #[cfg(test)]
        if take_forced_load_error() {
            bail!("Forced load error");
        }

        // Push current state to history before loading new file
        if record_history && !self.current_content.is_empty() {
            self.push_history();
        }

        let file_size = std::fs::metadata(&path).ok().map(|m| m.len());
        let use_async = self.screenshot.is_none()
            && file_size.is_some_and(|size| size >= ASYNC_LOAD_THRESHOLD_BYTES);
        if use_async {
            let load_id = self.next_file_load_id;
            self.next_file_load_id = self.next_file_load_id.wrapping_add(1);
            let request = FileLoadRequest {
                id: load_id,
                path: path.clone(),
            };
            if self.file_load_tx.send(request).is_ok() {
                self.pending_file_load = Some(PendingFileLoad { id: load_id, path });
                return Ok(());
            }
        }

        let (content, lossy) = Self::read_file_lossy(&path)?;
        let filename = path
            .file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("Unknown")
            .to_string();

        let base = path.parent().map(|p| p.to_path_buf());
        self.renderer.set_base_dir(base.as_deref());
        self.current_file = Some(path);
        self.load_content(&content, Some(filename));
        if lossy {
            eprintln!("Loaded file with invalid UTF-8; replaced invalid sequences.");
        }
        Ok(())
    }

    /// Normalize all line endings to Unix style (\n)
    /// Handles Windows (\r\n), Unix (\n), and old Mac (\r) formats
    fn normalize_line_endings(s: &str) -> String {
        // Order matters: replace \r\n first (Windows), then remaining \r (old Mac)
        let normalized = s.replace("\r\n", "\n").replace('\r', "\n");
        if let Some(stripped) = normalized.strip_prefix('\u{FEFF}') {
            stripped.to_string()
        } else {
            normalized
        }
    }

    fn read_lossy_bytes(path: &Path) -> std::io::Result<Vec<u8>> {
        #[cfg(test)]
        if take_forced_read_lossy_error() {
            return Err(std::io::Error::other("forced lossy read failure"));
        }
        std::fs::read(path)
    }

    fn read_file_lossy(path: &Path) -> Result<(String, bool)> {
        match std::fs::read_to_string(path) {
            Ok(s) => Ok((Self::normalize_line_endings(&s), false)),
            Err(e) if e.kind() == ErrorKind::InvalidData => {
                let bytes = Self::read_lossy_bytes(path)?;
                let s = String::from_utf8_lossy(&bytes).into_owned();
                Ok((Self::normalize_line_endings(&s), true))
            }
            Err(e) => Err(e.into()),
        }
    }

    fn spawn_named_thread(
        name: &str,
        f: impl FnOnce() + Send + 'static,
    ) -> std::io::Result<std::thread::JoinHandle<()>> {
        #[cfg(test)]
        if FORCE_THREAD_SPAWN_ERROR.swap(false, Ordering::Relaxed) {
            return Err(std::io::Error::other("forced thread spawn failure"));
        }
        std::thread::Builder::new().name(name.to_string()).spawn(f)
    }

    #[cfg(test)]
    fn force_thread_spawn_error_for_test() {
        FORCE_THREAD_SPAWN_ERROR.store(true, Ordering::Relaxed);
    }

    fn spawn_file_loader() -> (Sender<FileLoadRequest>, Receiver<FileLoadResult>) {
        let (request_tx, request_rx) = unbounded::<FileLoadRequest>();
        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
        if let Err(err) = Self::spawn_named_thread("mdmdview-file-loader", move || {
            for request in request_rx.iter() {
                let content = MarkdownViewerApp::read_file_lossy(&request.path)
                    .map_err(|err| err.to_string());
                let _ = result_tx.send(FileLoadResult {
                    id: request.id,
                    content,
                });
            }
        }) {
            eprintln!("Failed to start file loader thread: {err}");
        }
        (request_tx, result_rx)
    }

    fn poll_file_loads(&mut self) {
        while let Ok(result) = self.file_load_rx.try_recv() {
            let pending = match &self.pending_file_load {
                Some(pending) if pending.id == result.id => pending.clone(),
                _ => continue,
            };
            self.pending_file_load = None;
            match result.content {
                Ok((content, lossy)) => {
                    let filename = pending
                        .path
                        .file_name()
                        .and_then(|n| n.to_str())
                        .unwrap_or("Unknown")
                        .to_string();
                    let base = pending.path.parent().map(|p| p.to_path_buf());
                    self.renderer.set_base_dir(base.as_deref());
                    self.current_file = Some(pending.path);
                    self.load_content(&content, Some(filename));
                    if lossy {
                        eprintln!("Loaded file with invalid UTF-8; replaced invalid sequences.");
                    }
                }
                Err(err) => {
                    self.error_message = Some(format!("Failed to load file: {err}"));
                }
            }
        }
    }

    fn current_window_state(&self) -> Option<WindowState> {
        let pos = self.last_window_pos?;
        let size = self.last_window_size?;
        Some(WindowState {
            pos,
            size,
            maximized: self.last_window_maximized,
        })
    }

    fn compute_window_adjustment(
        outer_rect: Option<egui::Rect>,
        inner_rect: Option<egui::Rect>,
        monitor_size: Option<egui::Vec2>,
    ) -> Option<WindowAdjustment> {
        let outer = outer_rect?;
        let inner = inner_rect.unwrap_or(outer);
        let monitor = monitor_size?;

        if monitor.x <= 0.0 || monitor.y <= 0.0 {
            return None;
        }

        const MIN_WIDTH: f32 = 600.0;
        const MIN_HEIGHT: f32 = 400.0;
        const OFFSCREEN_TOLERANCE: f32 = 32.0;

        let mut pos = outer.min;
        let mut size = inner.size();
        let mut pos_adjusted = false;
        let mut size_adjusted = false;

        if !pos.x.is_finite() || !pos.y.is_finite() {
            pos = egui::pos2(0.0, 0.0);
            pos_adjusted = true;
        }
        if !size.x.is_finite() || !size.y.is_finite() {
            size = egui::vec2(MIN_WIDTH, MIN_HEIGHT);
            size_adjusted = true;
        }

        let outer_size = outer.size();
        let inner_size = inner.size();
        let frame = egui::vec2(
            (outer_size.x - inner_size.x).max(0.0),
            (outer_size.y - inner_size.y).max(0.0),
        );

        let available_width = (monitor.x - frame.x).max(MIN_WIDTH);
        let available_height = (monitor.y - frame.y).max(MIN_HEIGHT);

        if size.x < MIN_WIDTH {
            size.x = MIN_WIDTH.min(available_width);
            size_adjusted = true;
        }
        if size.y < MIN_HEIGHT {
            size.y = MIN_HEIGHT.min(available_height);
            size_adjusted = true;
        }
        if size.x > available_width {
            size.x = available_width;
            size_adjusted = true;
        }
        if size.y > available_height {
            size.y = available_height;
            size_adjusted = true;
        }

        let outer_size_for_bounds = size + frame;
        let max_pos = egui::pos2(
            (monitor.x - outer_size_for_bounds.x).max(0.0),
            (monitor.y - outer_size_for_bounds.y).max(0.0),
        );

        if pos.x <= -0.25 * outer_size_for_bounds.x {
            pos.x = 0.0;
            pos_adjusted = true;
        }
        if pos.y <= -0.25 * outer_size_for_bounds.y {
            pos.y = 0.0;
            pos_adjusted = true;
        }
        if pos.x > max_pos.x + OFFSCREEN_TOLERANCE {
            pos.x = max_pos.x;
            pos_adjusted = true;
        }
        if pos.y > max_pos.y + OFFSCREEN_TOLERANCE {
            pos.y = max_pos.y;
            pos_adjusted = true;
        }

        if pos_adjusted || size_adjusted {
            size.x = size.x.max(MIN_WIDTH.min(available_width));
            size.y = size.y.max(MIN_HEIGHT.min(available_height));
            Some(WindowAdjustment {
                pos: pos_adjusted.then_some(pos),
                size: size_adjusted.then_some(size),
            })
        } else {
            None
        }
    }

    fn window_state_changed(&self, new_state: &WindowState) -> bool {
        match &self.last_persisted_state {
            Some(prev) => {
                let pos_changed = (prev.pos[0] - new_state.pos[0]).abs() > 0.5
                    || (prev.pos[1] - new_state.pos[1]).abs() > 0.5;
                let size_changed = (prev.size[0] - new_state.size[0]).abs() > 0.5
                    || (prev.size[1] - new_state.size[1]).abs() > 0.5;
                let maximized_changed = prev.maximized != new_state.maximized;
                pos_changed || size_changed || maximized_changed
            }
            None => true,
        }
    }

    fn fold_for_search(input: &str) -> String {
        input.case_fold().nfkc().collect()
    }

    /// Push current state to navigation history
    fn push_history(&mut self) {
        // Truncate forward history if we're not at the end
        if self.history_index < self.history.len() {
            self.history.truncate(self.history_index);
        }

        // Create entry for current state
        let entry = HistoryEntry {
            file_path: self.current_file.clone(),
            title: self.title.clone(),
            content: self.current_content.clone(),
        };

        self.history.push(entry);

        // Limit history size
        if self.history.len() > self.max_history {
            self.history.remove(0);
        } else {
            self.history_index = self.history.len();
        }
    }

    /// Navigate back in history
    fn navigate_back(&mut self) -> bool {
        if self.history_index > 0 {
            self.history_index -= 1;
            self.restore_from_history();
            true
        } else {
            false
        }
    }

    /// Navigate forward in history
    fn navigate_forward(&mut self) -> bool {
        // First try pending files queue
        if let Some(next_file) = self.pending_files.pop_front() {
            // Load next file from queue
            if let Err(e) = self.load_file(next_file, true) {
                self.error_message = Some(format!("Failed to load file: {}", e));
            }
            return true;
        }

        // Otherwise use history navigation (existing code)
        if self.history_index < self.history.len().saturating_sub(1) {
            self.history_index += 1;
            self.restore_from_history();
            true
        } else {
            false
        }
    }

    /// Restore state from history at current index
    fn restore_from_history(&mut self) {
        if let Some(entry) = self.history.get(self.history_index) {
            self.current_file = entry.file_path.clone();
            self.title = entry.title.clone();
            self.current_content = entry.content.clone();
            self.raw_buffer = self.current_content.clone();

            // Re-parse content
            match self.renderer.parse(&self.current_content) {
                Ok(elements) => {
                    self.parsed_elements = elements;
                    self.error_message = None;
                }
                Err(e) => {
                    self.error_message = Some(format!("Failed to parse: {}", e));
                }
            }

            // Set base dir for images
            if let Some(ref path) = self.current_file {
                self.renderer.set_base_dir(path.parent());
            } else {
                self.renderer.set_base_dir(None);
            }

            // Scroll to top
            self.pending_scroll_to_element = Some(0);
        }
    }

    /// Check if we can navigate back
    fn can_navigate_back(&self) -> bool {
        self.history_index > 0
    }

    /// Check if we can navigate forward
    fn can_navigate_forward(&self) -> bool {
        !self.pending_files.is_empty() || self.history_index < self.history.len().saturating_sub(1)
    }

    /// Request a reload of the current file (processed outside of input context)
    fn request_reload(&mut self) {
        if self.current_file.is_some() {
            self.reload_requested = true;
        } else {
            self.error_message = Some("No file loaded to reload".to_string());
        }
    }

    /// Reload the currently opened file from disk
    pub fn reload_current_file(&mut self) -> Result<()> {
        let path = if let Some(p) = self.current_file.clone() {
            p
        } else {
            bail!("No file loaded to reload");
        };
        self.load_file(path, false)
    }

    /// Load a sample file by name
    pub fn load_sample(&mut self, sample: &SampleFile) {
        // Push current state to history before loading sample
        if !self.current_content.is_empty() {
            self.push_history();
        }

        self.current_file = None;
        // Samples have no file base-dir
        self.renderer.set_base_dir(None);
        self.load_content(sample.content, Some(sample.title.to_string()));
        // Scroll to top for new sample
        self.pending_scroll_to_element = Some(0);
    }

    fn load_sample_by_name(&mut self, samples: &[SampleFile], name: &str) -> bool {
        if let Some(sample) = samples.iter().find(|sample| sample.name == name) {
            self.load_sample(sample);
            return true;
        }
        false
    }

    fn load_welcome_from_samples(&mut self, samples: &[SampleFile], scroll_to_top: bool) {
        if let Some(welcome) = samples.iter().find(|sample| sample.name == "welcome.md") {
            self.load_content(welcome.content, Some("Welcome".to_string()));
            if scroll_to_top {
                self.pending_scroll_to_element = Some(0);
            }
        } else {
            // Fallback if welcome file is missing
            self.current_content.clear();
            self.parsed_elements.clear();
            self.title = APP_TITLE_PREFIX.to_string();
            self.error_message = None;
        }
    }

    /// Close the current file and return to welcome screen
    pub fn close_current_file(&mut self) {
        self.current_file = None;
        self.renderer.set_base_dir(None);
        self.load_welcome_from_samples(SAMPLE_FILES, true);
    }

    #[cfg(not(test))]
    fn request_close(&self, ctx: &Context) {
        ctx.send_viewport_cmd(egui::ViewportCommand::Close);
    }

    #[cfg(test)]
    fn request_close(&self, _ctx: &Context) {}

    #[cfg(not(test))]
    fn pick_open_path(&self) -> Option<PathBuf> {
        FileDialog::new()
            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
            .add_filter("All files", &["*"])
            .set_title("Open Markdown File")
            .pick_file()
    }

    #[cfg(test)]
    fn pick_open_path(&self) -> Option<PathBuf> {
        take_forced_open_path()
    }

    #[cfg(not(test))]
    fn pick_save_path(&self) -> Option<PathBuf> {
        FileDialog::new()
            .set_title("Save Markdown File")
            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
            .save_file()
    }

    #[cfg(test)]
    fn pick_save_path(&self) -> Option<PathBuf> {
        take_forced_save_path()
    }

    /// Open file dialog to select a markdown file
    fn open_file_dialog(&mut self) {
        if let Some(path) = self.pick_open_path() {
            if let Err(e) = self.load_file(path, true) {
                self.error_message = Some(format!("Failed to open file: {}", e));
            }
        }
    }

    /// Toggle between Rendered and Raw view
    fn toggle_view_mode(&mut self, ctx: &Context) {
        // If leaving Raw view while editing, capture cursor before switching
        if matches!(self.view_mode, ViewMode::Raw) && self.write_enabled {
            let editor_id = egui::Id::new("raw_editor");
            if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
                if let Some(range) = state.cursor.char_range() {
                    self.raw_cursor = Some(range.primary.index);
                }
            }
        }
        self.view_mode = match self.view_mode {
            ViewMode::Rendered => {
                self.raw_focus_requested = true;
                ViewMode::Raw
            }
            ViewMode::Raw => ViewMode::Rendered,
        };
    }

    /// Handle keyboard shortcuts
    fn handle_shortcuts(&mut self, ctx: &Context) {
        ctx.input_mut(|i| {
            let in_raw_edit = matches!(self.view_mode, ViewMode::Raw) && self.write_enabled;
            // Ctrl+O - Open file
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::CTRL,
                egui::Key::O,
            )) {
                self.open_file_dialog();
            }

            // Alt-based accelerators for common actions (mnemonics)
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::ALT,
                egui::Key::O,
            )) {
                self.open_file_dialog();
            }
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::ALT,
                egui::Key::W,
            )) {
                self.close_current_file();
            }
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::ALT,
                egui::Key::Q,
            )) {
                self.request_close(ctx);
            }

            // Ctrl+Q - Quit application
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::CTRL,
                egui::Key::Q,
            )) {
                self.request_close(ctx);
            }

            // Ctrl+W - Close current file
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::CTRL,
                egui::Key::W,
            )) {
                self.close_current_file();
            }

            // Ctrl+F - Open search dialog
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::CTRL,
                egui::Key::F,
            )) {
                self.show_search = true;
                if self.last_match_index.is_none() {
                    self.last_match_index = Some(0);
                }
                self.search_focus_requested = true;
            }

            // F3 navigation: next / previous
            let prev_shift = i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::SHIFT,
                egui::Key::F3,
            ));
            let prev_alt = i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::ALT,
                egui::Key::F3,
            ));
            if prev_shift || prev_alt {
                self.find_previous();
            } else if i.consume_key(egui::Modifiers::NONE, egui::Key::F3) {
                self.find_next();
            }

            // Ctrl+Plus - Zoom in
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::CTRL,
                egui::Key::Plus,
            )) {
                self.renderer.zoom_in();
            }

            // Ctrl+Minus - Zoom out
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::CTRL,
                egui::Key::Minus,
            )) {
                self.renderer.zoom_out();
            }

            // Ctrl+0 - Reset zoom
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::CTRL,
                egui::Key::Num0,
            )) {
                self.renderer.reset_zoom();
            }

            // Alt+Left - Navigate back
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::ALT,
                egui::Key::ArrowLeft,
            )) {
                self.navigate_back();
            }

            // Alt+Right - Navigate forward
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::ALT,
                egui::Key::ArrowRight,
            )) {
                self.navigate_forward();
            }

            // Ctrl + Mouse Wheel - Zoom
            if i.modifiers.ctrl {
                let mut total = 0.0f32;
                for ev in &i.events {
                    if let egui::Event::MouseWheel { delta, .. } = ev {
                        total += delta.y;
                    }
                }
                if total.abs() > 0.0 {
                    if total > 0.0 {
                        self.renderer.zoom_in();
                    } else {
                        self.renderer.zoom_out();
                    }
                }
            }

            // Ctrl+R - Toggle raw view
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::CTRL,
                egui::Key::R,
            )) {
                // Defer to avoid acting inside input context
                self.view_toggle_requested = true;
            }
            // Ctrl+E - Toggle write mode (deferred)
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::CTRL,
                egui::Key::E,
            )) {
                self.write_toggle_requested = true;
            }
            // Ctrl+S - Save document
            if i.consume_shortcut(&egui::KeyboardShortcut::new(
                egui::Modifiers::CTRL,
                egui::Key::S,
            )) {
                if let Err(e) = self.save_current_document() {
                    self.error_message = Some(format!("Failed to save: {}", e));
                }
            }
            // Note: No global Alt+R to avoid conflict (File > Reload vs View > Raw)

            // F11 - Toggle fullscreen (set flag to handle outside input context)
            if i.consume_key(egui::Modifiers::NONE, egui::Key::F11) {
                self.toggle_fullscreen = true;
            }

            // F5 - Reload current file (set flag; actual IO handled outside input context)
            if i.consume_key(egui::Modifiers::NONE, egui::Key::F5) {
                self.request_reload();
            }

            // Esc - dismiss search dialog if visible
            if self.show_search && i.consume_key(egui::Modifiers::NONE, egui::Key::Escape) {
                self.clear_search_state();
                self.show_search = false;
            }

            // Only consume navigation keys when not editing in raw view
            if !in_raw_edit {
                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
                    self.nav_request = Some(NavigationRequest::PageUp);
                }
                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
                    self.nav_request = Some(NavigationRequest::PageDown);
                }
                // Home - Go to top of document
                if i.consume_key(egui::Modifiers::NONE, egui::Key::Home) {
                    self.nav_request = Some(NavigationRequest::Top);
                }

                // End - Go to bottom of document
                if i.consume_key(egui::Modifiers::NONE, egui::Key::End) {
                    self.nav_request = Some(NavigationRequest::Bottom);
                }

                // Arrow Up - Fine scroll up
                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowUp) {
                    self.nav_request = Some(NavigationRequest::ScrollUp);
                }

                // Arrow Down - Fine scroll down
                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowDown) {
                    self.nav_request = Some(NavigationRequest::ScrollDown);
                }
            } else {
                // In raw edit mode: implement PageUp/PageDown by moving caret by ~a page of lines
                const PAGE_LINES: i32 = 24; // match desired_rows for the editor
                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
                    self.pending_raw_cursor_line_move = Some(-PAGE_LINES);
                    self.raw_focus_requested = true;
                }
                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
                    self.pending_raw_cursor_line_move = Some(PAGE_LINES);
                    self.raw_focus_requested = true;
                }
            }
        });
    }

    fn render_file_menu_contents(
        &mut self,
        ui: &mut egui::Ui,
        alt_pressed: bool,
        menu_text_color: Color32,
    ) {
        ui.horizontal(|ui| {
            let clicked = ui
                .add(egui::Button::new(Self::menu_text_with_mnemonic(
                    None,
                    "Open...",
                    'O',
                    alt_pressed,
                    menu_text_color,
                )))
                .clicked();
            if app_action_triggered(clicked, "menu_open") {
                self.open_file_dialog();
                ui.close_menu();
            }
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(RichText::new("Ctrl+O").color(menu_text_color));
            });
        });

        ui.horizontal(|ui| {
            let enabled = !self.current_content.is_empty();
            let button = ui.add_enabled(
                enabled,
                egui::Button::new(Self::menu_text_with_mnemonic(
                    None,
                    "Save",
                    'S',
                    alt_pressed,
                    menu_text_color,
                )),
            );
            if app_action_triggered(button.clicked(), "menu_save") {
                if let Err(e) = self.save_current_document() {
                    self.error_message = Some(format!("Failed to save: {}", e));
                }
                ui.close_menu();
            }
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(RichText::new("Ctrl+S").color(menu_text_color));
            });
        });

        ui.horizontal(|ui| {
            let clicked = ui
                .add(egui::Button::new(Self::menu_text_with_mnemonic(
                    None,
                    "Close",
                    'C',
                    alt_pressed,
                    menu_text_color,
                )))
                .clicked();
            if app_action_triggered(clicked, "menu_close") {
                self.close_current_file();
                ui.close_menu();
            }
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(RichText::new("Ctrl+W").color(menu_text_color));
            });
        });

        ui.horizontal(|ui| {
            let enabled = self.current_file.is_some();
            let button = ui.add_enabled(
                enabled,
                egui::Button::new(Self::menu_text_with_mnemonic(
                    None,
                    "Reload",
                    'R',
                    alt_pressed,
                    menu_text_color,
                )),
            );
            if app_action_triggered(button.clicked(), "menu_reload") {
                self.request_reload();
                ui.close_menu();
            }
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(RichText::new("F5").color(menu_text_color));
            });
        });

        ui.horizontal(|ui| {
            let clicked = ui
                .add(egui::Button::new(Self::menu_text_with_mnemonic(
                    None,
                    "Find...",
                    'F',
                    alt_pressed,
                    menu_text_color,
                )))
                .clicked();
            if app_action_triggered(clicked, "menu_find") {
                self.show_search = true;
                self.search_focus_requested = true;
                ui.close_menu();
            }
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(RichText::new("Ctrl+F").color(menu_text_color));
            });
        });

        ui.separator();

        #[cfg(not(test))]
        ui.menu_button(
            Self::menu_text_with_mnemonic(None, "Samples", 'S', alt_pressed, menu_text_color),
            |ui| {
                self.render_samples_menu_contents(ui);
            },
        );
        #[cfg(test)]
        self.render_samples_menu_contents(ui);
        if app_action_triggered(false, "menu_samples") {
            self.render_samples_menu_contents(ui);
        }
    }

    fn render_samples_menu_contents(&mut self, ui: &mut egui::Ui) {
        for sample in SAMPLE_FILES {
            if app_action_triggered(ui.button(sample.title).clicked(), sample.name) {
                self.load_sample(sample);
                ui.close_menu();
            }
        }
    }

    fn render_view_menu_contents(
        &mut self,
        ui: &mut egui::Ui,
        ctx: &Context,
        alt_pressed: bool,
        menu_text_color: Color32,
    ) {
        ui.horizontal(|ui| {
            let enabled = self.can_navigate_back();
            let clicked = ui
                .add_enabled(enabled, egui::Button::new("<- Back"))
                .clicked();
            if app_action_triggered(clicked, "menu_back") {
                self.navigate_back();
                ui.close_menu();
            }
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(RichText::new("Alt+Left").color(menu_text_color));
            });
        });

        ui.horizontal(|ui| {
            let enabled = self.can_navigate_forward();
            let clicked = ui
                .add_enabled(enabled, egui::Button::new("Forward ->"))
                .clicked();
            if app_action_triggered(clicked, "menu_forward") {
                self.navigate_forward();
                ui.close_menu();
            }
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(RichText::new("Alt+Right").color(menu_text_color));
            });
        });

        ui.separator();

        ui.horizontal(|ui| {
            let selected = matches!(self.view_mode, ViewMode::Raw);
            let clicked = ui
                .add(egui::SelectableLabel::new(
                    selected,
                    Self::menu_text_with_mnemonic(
                        None,
                        "Raw Markdown",
                        'R',
                        alt_pressed,
                        menu_text_color,
                    ),
                ))
                .clicked();
            if app_action_triggered(clicked, "menu_raw") {
                self.toggle_view_mode(ctx);
                ui.close_menu();
            }
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(RichText::new("Ctrl+R").color(menu_text_color));
            });
        });

        ui.horizontal(|ui| {
            let selected = self.write_enabled;
            let clicked = ui
                .add(egui::SelectableLabel::new(
                    selected,
                    Self::menu_text_with_mnemonic(
                        None,
                        "Write Mode",
                        'W',
                        alt_pressed,
                        menu_text_color,
                    ),
                ))
                .clicked();
            if app_action_triggered(clicked, "menu_write") {
                self.toggle_write_mode(ctx);
                ui.close_menu();
            }
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(RichText::new("Ctrl+E").color(menu_text_color));
            });
        });

        ui.horizontal(|ui| {
            let clicked = ui
                .add(egui::SelectableLabel::new(
                    self.wrap_raw,
                    Self::menu_text_with_mnemonic(
                        None,
                        "Wrap Raw Lines",
                        'L',
                        alt_pressed,
                        menu_text_color,
                    ),
                ))
                .clicked();
            if app_action_triggered(clicked, "menu_wrap_raw") {
                self.wrap_raw = !self.wrap_raw;
            }
        });

        ui.horizontal(|ui| {
            let clicked = ui
                .add(egui::Button::new(Self::menu_text_with_mnemonic(
                    None,
                    "Zoom In",
                    'I',
                    alt_pressed,
                    menu_text_color,
                )))
                .clicked();
            if app_action_triggered(clicked, "menu_zoom_in") {
                self.renderer.zoom_in();
                ui.close_menu();
            }
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(RichText::new("Ctrl++").color(menu_text_color));
            });
        });

        ui.horizontal(|ui| {
            let clicked = ui
                .add(egui::Button::new(Self::menu_text_with_mnemonic(
                    None,
                    "Zoom Out",
                    'O',
                    alt_pressed,
                    menu_text_color,
                )))
                .clicked();
            if app_action_triggered(clicked, "menu_zoom_out") {
                self.renderer.zoom_out();
                ui.close_menu();
            }
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(RichText::new("Ctrl+-").color(menu_text_color));
            });
        });

        ui.horizontal(|ui| {
            let clicked = ui
                .add(egui::Button::new(Self::menu_text_with_mnemonic(
                    None,
                    "Reset Zoom",
                    'Z',
                    alt_pressed,
                    menu_text_color,
                )))
                .clicked();
            if app_action_triggered(clicked, "menu_zoom_reset") {
                self.renderer.reset_zoom();
                ui.close_menu();
            }
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(RichText::new("Ctrl+0").color(menu_text_color));
            });
        });

        ui.separator();

        ui.horizontal(|ui| {
            let clicked = ui
                .add(egui::Button::new(Self::menu_text_with_mnemonic(
                    None,
                    "Toggle Fullscreen",
                    'T',
                    alt_pressed,
                    menu_text_color,
                )))
                .clicked();
            if app_action_triggered(clicked, "menu_fullscreen") {
                let is_fullscreen = ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
                ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(!is_fullscreen));
                ui.close_menu();
            }
            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                ui.label(RichText::new("F11").color(menu_text_color));
            });
        });
    }

    fn render_help_menu_contents(
        &mut self,
        ui: &mut egui::Ui,
        alt_pressed: bool,
        menu_text_color: Color32,
    ) {
        ui.horizontal(|ui| {
            let clicked = ui
                .add(egui::Button::new(Self::menu_text_with_mnemonic(
                    None,
                    "Usage Instructions",
                    'U',
                    alt_pressed,
                    menu_text_color,
                )))
                .clicked();
            if app_action_triggered(clicked, "menu_help_usage") {
                let _ = self.load_sample_by_name(SAMPLE_FILES, "usage.md");
                ui.close_menu();
            }
        });

        ui.horizontal(|ui| {
            let clicked = ui
                .add(egui::Button::new(Self::menu_text_with_mnemonic(
                    None,
                    "About",
                    'A',
                    alt_pressed,
                    menu_text_color,
                )))
                .clicked();
            if app_action_triggered(clicked, "menu_help_about") {
                let _ = self.load_sample_by_name(SAMPLE_FILES, "welcome.md");
                ui.close_menu();
            }
        });
    }

    /// Render the menu bar
    fn render_menu_bar(&mut self, ctx: &Context) {
        TopBottomPanel::top("menu_bar").show(ctx, |ui| {
            let alt_pressed = ui.input(|i| i.modifiers.alt);
            let menu_text_color = if ui.visuals().dark_mode {
                Color32::WHITE
            } else {
                Color32::BLACK
            };
            menu::bar(ui, |ui| {
                // File menu (Alt+F mnemonic visual)
                #[cfg(not(test))]
                ui.menu_button(
                    Self::menu_text_with_mnemonic(None, "File", 'F', alt_pressed, menu_text_color),
                    |ui| {
                        self.render_file_menu_contents(ui, alt_pressed, menu_text_color);
                    },
                );
                #[cfg(test)]
                self.render_file_menu_contents(ui, alt_pressed, menu_text_color);
                if app_action_triggered(false, "menu_bar_file") {
                    self.render_file_menu_contents(ui, alt_pressed, menu_text_color);
                }

                // View menu
                #[cfg(not(test))]
                ui.menu_button(
                    Self::menu_text_with_mnemonic(None, "View", 'V', alt_pressed, menu_text_color),
                    |ui| {
                        self.render_view_menu_contents(ui, ctx, alt_pressed, menu_text_color);
                    },
                );
                #[cfg(test)]
                self.render_view_menu_contents(ui, ctx, alt_pressed, menu_text_color);
                if app_action_triggered(false, "menu_bar_view") {
                    self.render_view_menu_contents(ui, ctx, alt_pressed, menu_text_color);
                }

                #[cfg(not(test))]
                ui.menu_button(
                    Self::menu_text_with_mnemonic(None, "Help", 'H', alt_pressed, menu_text_color),
                    |ui| {
                        self.render_help_menu_contents(ui, alt_pressed, menu_text_color);
                    },
                );
                #[cfg(test)]
                self.render_help_menu_contents(ui, alt_pressed, menu_text_color);
                if app_action_triggered(false, "menu_bar_help") {
                    self.render_help_menu_contents(ui, alt_pressed, menu_text_color);
                }
            });
        });

        // No programmatic overlay menus; rely on pointer to open egui menus.
    }

    fn render_main_context_menu(&mut self, ui: &mut egui::Ui) {
        ui.label("Select text, then use Ctrl+C to copy");
        ui.separator();

        // Copy All Text option
        if app_action_triggered(ui.button("Copy All Text").clicked(), "ctx_copy_all") {
            let all_text = MarkdownRenderer::elements_to_plain_text(&self.parsed_elements);
            ui.ctx().copy_text(all_text);
            ui.close_menu();
        }

        // Copy as Markdown (Raw) option
        if app_action_triggered(ui.button("Copy as Markdown").clicked(), "ctx_copy_markdown") {
            ui.ctx().copy_text(self.current_content.clone());
            ui.close_menu();
        }

        ui.separator();

        // Navigation shortcuts
        if app_action_triggered(ui.button("Go to Top").clicked(), "ctx_nav_top") {
            self.nav_request = Some(NavigationRequest::Top);
            ui.close_menu();
        }

        if app_action_triggered(ui.button("Go to Bottom").clicked(), "ctx_nav_bottom") {
            self.nav_request = Some(NavigationRequest::Bottom);
            ui.close_menu();
        }
    }
    /// Render the status bar
    fn render_status_bar(&self, ctx: &Context) {
        TopBottomPanel::bottom("status_bar").show(ctx, |ui| {
            ui.horizontal(|ui| {
                // Current file info
                if let Some(path) = &self.current_file {
                    ui.label(format!("File: {}", path.display()));
                } else if !self.parsed_elements.is_empty() {
                    ui.label("Sample file");
                } else {
                    ui.label("No file loaded");
                }

                if let Some(pending) = &self.pending_file_load {
                    ui.separator();
                    ui.label(
                        RichText::new(format!("Loading {}", pending.path.display()))
                            .color(Color32::from_rgb(120, 200, 255)),
                    );
                }

                // Show pending file count if files are queued
                if !self.pending_files.is_empty() {
                    ui.separator();
                    ui.label(
                        RichText::new(format!("{} files in queue", self.pending_files.len()))
                            .color(egui::Color32::from_rgb(100, 150, 255)),
                    );

                    ui.label(
                        RichText::new("(Alt+Right for next)")
                            .color(egui::Color32::GRAY)
                            .italics(),
                    );
                }

                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    // Document stats
                    let element_count = self.parsed_elements.len();
                    let char_count = self.current_content.len();
                    let mode = match self.view_mode {
                        ViewMode::Rendered => "Rendered",
                        ViewMode::Raw => "Raw",
                    };
                    let status = format!(
                        "Mode: {} | Elements: {} | Characters: {}",
                        mode, element_count, char_count
                    );
                    #[cfg(test)]
                    {
                        ui.label(status);
                        self.render_status_tooltip(ui);
                    }
                    #[cfg(not(test))]
                    {
                        ui.label(status)
                            .on_hover_ui(|ui| self.render_status_tooltip(ui));
                    }
                    if app_action_triggered(false, "status_hover") {
                        self.render_status_tooltip(ui);
                    }
                });
            });
        });
    }

    fn render_status_tooltip(&self, ui: &mut egui::Ui) {
        ui.label(format!("Version: {}", BUILD_VERSION));
        ui.label(format!("Built: {}", BUILD_TIMESTAMP));
    }
    /// Handle drag-drop events from egui
    fn handle_drag_drop_events(&mut self, ctx: &Context) {
        ctx.input(|i| {
            // Check if files are being hovered
            self.drag_hover = !i.raw.hovered_files.is_empty();

            // Check if files were dropped
            if !i.raw.dropped_files.is_empty() {
                let paths: Vec<PathBuf> = i
                    .raw
                    .dropped_files
                    .iter()
                    .filter_map(|f| f.path.clone())
                    .collect();

                self.handle_file_drop(paths);
            }
        });
    }

    /// Render drag-and-drop overlay when files are hovered
    fn render_drag_overlay(&self, ctx: &Context) {
        if !self.drag_hover {
            return;
        }

        // Full-screen overlay
        egui::Area::new(egui::Id::new("drag_overlay"))
            .fixed_pos(egui::pos2(0.0, 0.0))
            .order(egui::Order::Foreground)
            .show(ctx, |ui| {
                let screen_rect = ctx.screen_rect();

                // Semi-transparent dark background
                ui.painter()
                    .rect_filled(screen_rect, 0.0, egui::Color32::from_black_alpha(180));

                // Dashed border effect using rounded rect with stroke
                let border_rect = screen_rect.shrink(20.0);
                let border_color = egui::Color32::from_rgb(100, 150, 255);

                // Draw border
                ui.painter()
                    .rect_stroke(border_rect, 8.0, egui::Stroke::new(4.0, border_color));

                // Center text
                ui.allocate_ui_at_rect(screen_rect, |ui| {
                    ui.vertical_centered(|ui| {
                        ui.add_space(screen_rect.height() / 2.0 - 80.0);

                        // Main message
                        ui.label(
                            RichText::new("Drop files to open")
                                .size(36.0)
                                .color(egui::Color32::WHITE)
                                .strong(),
                        );

                        ui.add_space(20.0);

                        // Supported formats
                        ui.label(
                            RichText::new("Supported: .md, .markdown, .mdown, .mkd, .txt")
                                .size(18.0)
                                .color(egui::Color32::LIGHT_GRAY),
                        );

                        ui.add_space(10.0);

                        // Additional hint
                        ui.label(
                            RichText::new("Drop multiple files to open them in sequence")
                                .size(14.0)
                                .color(egui::Color32::from_rgb(150, 150, 150))
                                .italics(),
                        );
                    });
                });
            });
    }

    fn update_impl(&mut self, ctx: &Context) {
        self.handle_screenshot_events(ctx);
        self.poll_file_loads();
        if self.screenshot.as_ref().is_some_and(|state| state.done) {
            return;
        }

        let screenshot_active = self.screenshot.is_some();
        let hide_chrome = screenshot_active;

        // Handle drag-drop events
        if !screenshot_active {
            self.handle_drag_drop_events(ctx);
        }

        // Handle keyboard shortcuts
        if !screenshot_active {
            self.handle_shortcuts(ctx);
        }

        // Keep native window title in sync with the current document
        ctx.send_viewport_cmd(egui::ViewportCommand::Title(self.title.clone()));

        let (monitor_size, outer_rect, inner_rect, is_fullscreen, is_maximized) = ctx.input(|i| {
            let vp = i.viewport();
            (
                vp.monitor_size,
                vp.outer_rect,
                vp.inner_rect,
                vp.fullscreen.unwrap_or(false),
                vp.maximized.unwrap_or(false),
            )
        });

        let mut pos_adjusted = false;
        let mut size_adjusted = false;
        if !is_fullscreen {
            if let Some(adjustment) =
                Self::compute_window_adjustment(outer_rect, inner_rect, monitor_size)
            {
                if let Some(pos) = adjustment.pos {
                    pos_adjusted = true;
                    ctx.send_viewport_cmd(egui::ViewportCommand::OuterPosition(pos));
                    self.last_window_pos = Some([pos.x, pos.y]);
                }
                if let Some(size) = adjustment.size {
                    size_adjusted = true;
                    ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(size));
                    self.last_window_size = Some([size.x, size.y]);
                }
            }
        }

        if !pos_adjusted {
            if let Some(outer) = outer_rect {
                self.last_window_pos = Some([outer.left(), outer.top()]);
            }
        }
        if !size_adjusted && !is_fullscreen {
            if let Some(inner) = inner_rect {
                self.last_window_size = Some([inner.width(), inner.height()]);
            }
        }
        self.last_window_maximized = is_maximized;

        // Opportunistically persist window state if it changed, throttled to once per second
        if self.should_persist_window_state() {
            self.persist_window_state();
            self.last_persist_instant = std::time::Instant::now();
        }

        // Handle fullscreen toggle outside input context to avoid deadlocks
        if self.toggle_fullscreen {
            self.toggle_fullscreen = false;
            let current_fullscreen = ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
            ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(!current_fullscreen));
        }

        // Handle deferred view toggle outside of input context
        if self.view_toggle_requested {
            self.view_toggle_requested = false;
            self.toggle_view_mode(ctx);
        }

        // Handle deferred write toggle outside of input context
        if self.write_toggle_requested {
            self.write_toggle_requested = false;
            self.toggle_write_mode(ctx);
        }

        // Handle deferred caret movement for raw editor
        if let Some(delta) = self.pending_raw_cursor_line_move.take() {
            self.move_raw_cursor_lines(ctx, delta);
        }

        // Handle reload request outside input context to avoid blocking within input handling
        if self.reload_requested {
            self.reload_requested = false;
            if let Err(e) = self.reload_current_file() {
                self.error_message = Some(format!("Failed to reload file: {}", e));
            }
        }

        // Render chrome panels before the central area so they reserve space.
        if !hide_chrome {
            self.render_menu_bar(ctx);
            self.render_status_bar(ctx);
        }

        let mut layout_signature: Option<u64> = None;
        let mut scroll_snapshot: Option<ScrollSnapshot> = None;
        let screenshot_scroll_offset = self
            .screenshot
            .as_ref()
            .and_then(|state| state.scroll_offset);

        // Main content area
        let central_response = CentralPanel::default().show(ctx, |ui| {
            // Show error message if any
            if let Some(ref error) = self.error_message {
                ui.colored_label(Color32::RED, format!("Error: {}", error));
                ui.separator();
            }

            // Render markdown content in a scrollable area
            let scroll_delta = if let Some(nav) = self.nav_request.take() {
                match nav {
                    NavigationRequest::Top => {
                        // Scroll to top: use a large POSITIVE delta to reach the beginning
                        egui::Vec2::new(0.0, 100000.0)
                    }
                    NavigationRequest::Bottom => {
                        // Scroll to bottom: use a large NEGATIVE delta to reach the end
                        egui::Vec2::new(0.0, -100000.0)
                    }
                    NavigationRequest::PageUp => {
                        let viewport_height = ui.available_height();
                        let page_size = viewport_height * 0.8;
                        egui::Vec2::new(0.0, page_size) // Positive = scroll up (show earlier content)
                    }
                    NavigationRequest::PageDown => {
                        let viewport_height = ui.available_height();
                        let page_size = viewport_height * 0.8;
                        egui::Vec2::new(0.0, -page_size) // Negative = scroll down (show later content)
                    }
                    NavigationRequest::ScrollUp => {
                        egui::Vec2::new(0.0, 40.0) // Positive = fine scroll up
                    }
                    NavigationRequest::ScrollDown => {
                        egui::Vec2::new(0.0, -40.0) // Negative = fine scroll down
                    }
                }
            } else {
                egui::Vec2::ZERO
            };

            // Use AlwaysVisible to prevent scrollbar appearance/disappearance from
            // changing the available width, which would cause Mermaid diagrams to
            // re-render at different widths and create layout oscillation/flickering.
            let mut scroll_area = egui::ScrollArea::vertical()
                .id_source(self.scroll_area_id)
                .auto_shrink([false, false])
                .scroll_bar_visibility(egui::scroll_area::ScrollBarVisibility::AlwaysVisible);
            if let Some(offset) = screenshot_scroll_offset {
                scroll_area = scroll_area.vertical_scroll_offset(offset);
            }
            if screenshot_active {
                scroll_area = scroll_area.enable_scrolling(false);
            }
            let scroll_output = scroll_area.show(ui, |ui| {
                // Apply scroll delta if we have navigation
                if scroll_delta != egui::Vec2::ZERO {
                    ui.scroll_with_delta(scroll_delta);
                }

                ui.spacing_mut().item_spacing.y = 8.0;

                if self.parsed_elements.is_empty() && self.error_message.is_none() {
                    ui.vertical_centered(|ui| {
                        ui.add_space(50.0);
                        ui.label(RichText::new("Welcome to MarkdownView").size(24.0).strong());
                        ui.add_space(20.0);
                        ui.label("Open a markdown file or select a sample to get started.");
                        ui.add_space(20.0);

                        if app_action_triggered(ui.button("Open File").clicked(), "welcome_open") {
                            self.open_file_dialog();
                        }
                    });
                } else {
                    match self.view_mode {
                        ViewMode::Rendered => {
                            // Update highlight phrase: prefer live input, else last executed
                            if self.show_search && !self.search_query.is_empty() {
                                self.renderer.set_highlight_phrase(Some(&self.search_query));
                            } else if !self.last_query.is_empty() {
                                self.renderer.set_highlight_phrase(Some(&self.last_query));
                            } else {
                                self.renderer.set_highlight_phrase(None);
                            }

                            self.renderer.render_to_ui(ui, &self.parsed_elements);
                            // If a header anchor was clicked, scroll to it
                            if let Some(anchor) = self.renderer.take_pending_anchor() {
                                if let Some(rect) = self.renderer.header_rect_for(&anchor) {
                                    // Align target header to the top of the visible area
                                    ui.scroll_to_rect(rect, Some(egui::Align::Min));
                                }
                            }
                            // If a search requested a scroll, align to top of visible area
                            if let Some(idx) = self.pending_scroll_to_element.take() {
                                if let Some(rect) = self.renderer.element_rect_at(idx) {
                                    ui.scroll_to_rect(rect, Some(egui::Align::Min));
                                }
                            }
                            layout_signature = Some(self.renderer.layout_signature());
                        }
                        ViewMode::Raw => {
                            // Raw markdown view; editable when write mode is enabled
                            if self.write_enabled {
                                let editor_id = egui::Id::new("raw_editor");
                                // If we have a remembered cursor, restore it (clamped)
                                if let Some(mut idx) = self.raw_cursor.take() {
                                    idx = idx.min(self.raw_buffer.len());
                                    if let Some(mut state) =
                                        egui::text_edit::TextEditState::load(ui.ctx(), editor_id)
                                    {
                                        let cr = egui::text::CCursorRange::one(
                                            egui::text::CCursor::new(idx),
                                        );
                                        state.cursor.set_char_range(Some(cr));
                                        state.store(ui.ctx(), editor_id);
                                    } else {
                                        let mut state = egui::text_edit::TextEditState::default();
                                        let cr = egui::text::CCursorRange::one(
                                            egui::text::CCursor::new(idx),
                                        );
                                        state.cursor.set_char_range(Some(cr));
                                        state.store(ui.ctx(), editor_id);
                                    }
                                }
                                let before = self.raw_buffer.clone();
                                let resp = ui.add(
                                    TextEdit::multiline(&mut self.raw_buffer)
                                        .font(TextStyle::Monospace)
                                        .code_editor()
                                        .lock_focus(false)
                                        .interactive(true)
                                        .desired_width(f32::INFINITY)
                                        .desired_rows(24)
                                        .id_source(editor_id),
                                );
                                if self.raw_focus_requested {
                                    resp.request_focus();
                                    self.raw_focus_requested = false;
                                }
                                // Remember cursor position for next time
                                if let Some(state) =
                                    egui::text_edit::TextEditState::load(ui.ctx(), editor_id)
                                {
                                    if let Some(range) = state.cursor.char_range() {
                                        let idx = range.primary.index;
                                        self.raw_cursor = Some(idx);
                                    }
                                }
                                if self.raw_buffer != before {
                                    self.current_content = self.raw_buffer.clone();
                                    match self.renderer.parse(&self.current_content) {
                                        Ok(elements) => {
                                            self.parsed_elements = elements;
                                            self.error_message = None;
                                        }
                                        Err(e) => {
                                            self.error_message =
                                                Some(format!("Failed to parse markdown: {}", e));
                                        }
                                    }
                                }
                            } else {
                                // Read-only
                                let mut tmp = self.raw_buffer.clone();
                                ui.add(
                                    TextEdit::multiline(&mut tmp)
                                        .font(TextStyle::Monospace)
                                        .code_editor()
                                        .lock_focus(false)
                                        .interactive(false)
                                        .desired_width(f32::INFINITY)
                                        .desired_rows(24),
                                );
                            }
                        }
                    }
                }
            });
            scroll_snapshot = Some(ScrollSnapshot {
                content_size: scroll_output.content_size,
                inner_rect: scroll_output.inner_rect,
                offset_y: scroll_output.state.offset.y,
            });
        });

        // Add context menu for the main panel
        #[cfg(not(test))]
        central_response
            .response
            .context_menu(|ui| self.render_main_context_menu(ui));

        if let Some(state) = self.screenshot.as_mut() {
            state.content_rect = Some(central_response.response.rect);
        }
        self.update_screenshot_state(ctx, layout_signature, scroll_snapshot);

        if !hide_chrome {
            // Render floating search dialog (non-modal, always on top)
            self.render_search_dialog(ctx);

            // Render drag-and-drop overlay (must be last to appear on top)
            self.render_drag_overlay(ctx);
        }
    }
}

impl eframe::App for MarkdownViewerApp {
    /// Update function called every frame
    fn update(&mut self, ctx: &Context, _frame: &mut eframe::Frame) {
        self.update_impl(ctx);
    }

    fn auto_save_interval(&self) -> std::time::Duration {
        std::time::Duration::from_secs(30)
    }

    fn save(&mut self, _storage: &mut dyn eframe::Storage) {
        // Persist window position and size on app save/exit
        if self.screenshot.is_none() {
            self.persist_window_state();
        }
    }
}

impl MarkdownViewerApp {
    // Build a rich-text label with only the mnemonic character underlined (visual cue only).
    fn menu_text_with_mnemonic(
        prefix: Option<&str>,
        label: &str,
        mnemonic: char,
        underline: bool,
        text_color: Color32,
    ) -> LayoutJob {
        let mut job = LayoutJob::default();
        let default_fmt = TextFormat {
            color: text_color,
            ..TextFormat::default()
        };
        if let Some(p) = prefix {
            job.append(p, 0.0, default_fmt.clone());
        }
        let m = mnemonic.to_ascii_lowercase();
        let mut applied = false;
        for c in label.chars() {
            let mut fmt = default_fmt.clone();
            if underline && !applied && c.to_ascii_lowercase() == m {
                // Use a subtle underline color; white works well on dark theme
                fmt.underline = egui::Stroke::new(1.0, text_color);
                applied = true;
            }
            let s = c.to_string();
            job.append(&s, 0.0, fmt);
        }
        job
    }
    fn persist_window_state(&mut self) {
        if let Some(state) = self.current_window_state() {
            if !self.window_state_changed(&state) {
                return;
            }
            if crate::save_window_state(&state).is_ok() {
                self.last_persist_instant = std::time::Instant::now();
                self.last_persisted_state = Some(state);
            }
        }
    }

    fn should_persist_window_state(&self) -> bool {
        if self.screenshot.is_some() {
            return false;
        }
        if self.last_persist_instant.elapsed() < std::time::Duration::from_secs(1) {
            return false;
        }
        if let Some(state) = self.current_window_state() {
            self.window_state_changed(&state)
        } else {
            false
        }
    }

    /// Save current document. If no file is associated, prompts for a path.
    fn save_current_document(&mut self) -> Result<()> {
        if let Some(path) = self.current_file.clone() {
            std::fs::write(&path, &self.current_content)?;
            let parent = path.parent();
            self.renderer.set_base_dir(parent);
            Ok(())
        } else if let Some(path) = self.pick_save_path() {
            std::fs::write(&path, &self.current_content)?;
            let filename = path
                .file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("Unknown")
                .to_string();
            self.current_file = Some(path);
            let parent = self.current_file.as_ref().and_then(|p| p.parent());
            self.renderer.set_base_dir(parent);
            self.title = format!("{APP_TITLE_PREFIX} - {}", filename);
            Ok(())
        } else {
            Ok(())
        }
    }

    /// Render the floating non-modal search dialog
    fn render_search_dialog(&mut self, ctx: &Context) {
        if !self.show_search {
            return;
        }
        let mut open = self.show_search;
        let prev_query = self.search_query.clone();
        egui::Window::new("Find")
            .collapsible(false)
            .resizable(false)
            .default_pos(egui::pos2(80.0, 80.0))
            .open(&mut open)
            .show(ctx, |ui| {
                let mut submitted_next = false;
                ui.horizontal(|ui| {
                    let text_edit = egui::TextEdit::singleline(&mut self.search_query)
                        .hint_text("Search text...")
                        .desired_width(240.0);
                    let resp = ui.add(text_edit);
                    if self.search_focus_requested {
                        resp.request_focus();
                        self.search_focus_requested = false;
                    }
                    if Self::should_submit_search(
                        resp.lost_focus(),
                        ui.input(|i| i.key_pressed(egui::Key::Enter)),
                    ) {
                        submitted_next = true;
                    }
                    let next_clicked = ui.button("Next (F3)").clicked();
                    if app_action_triggered(next_clicked, "search_next") || submitted_next {
                        self.find_next();
                    }
                    let prev_clicked = ui.button("Prev (Shift+F3)").clicked();
                    if app_action_triggered(prev_clicked, "search_prev") {
                        self.find_previous();
                    }
                });
            });
        if app_action_triggered(false, "search_close") {
            open = false;
        }
        self.update_search_results(&prev_query);
        // If dialog closed via close button, clear before hiding
        if !open {
            self.clear_search_state();
        }
        self.show_search = open;
    }

    fn should_submit_search(lost_focus: bool, enter_pressed: bool) -> bool {
        lost_focus && enter_pressed
    }

    fn update_search_results(&mut self, prev_query: &str) {
        if self.search_query == prev_query {
            return;
        }
        if self.search_query.is_empty() {
            self.last_query.clear();
            self.renderer.set_highlight_phrase(None);
            return;
        }
        self.last_query = self.search_query.clone();
        // Use current last match as baseline if set, else start of doc
        let baseline = self.last_match_index.unwrap_or(0);
        let needle = Self::fold_for_search(&self.search_query);
        let total = self.parsed_elements.len();
        let mut found: Option<usize> = None;
        for pass in 0..2 {
            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
                Box::new(baseline..total)
            } else {
                Box::new(0..baseline.min(total))
            };
            for idx in range {
                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
                    &self.parsed_elements[idx],
                );
                if Self::fold_for_search(&text).contains(&needle) {
                    found = Some(idx);
                    break;
                }
            }
            if found.is_some() {
                break;
            }
        }
        if let Some(idx) = found {
            self.last_match_index = Some(idx);
            self.pending_scroll_to_element = Some(idx);
        }
    }

    fn handle_screenshot_events(&mut self, ctx: &Context) {
        let screenshot = ctx.input(|i| {
            i.events.iter().find_map(|event| {
                if let egui::Event::Screenshot { image, .. } = event {
                    Some(std::sync::Arc::clone(image))
                } else {
                    None
                }
            })
        });
        let Some(image) = screenshot else {
            return;
        };
        let snapshot = {
            let Some(state) = self.screenshot.as_ref() else {
                return;
            };
            if state.done {
                return;
            }
            ScreenshotSnapshot::from(state)
        };
        if let Err(err) = Self::save_screenshot_image(&image, &snapshot) {
            eprintln!("Failed to save screenshot: {err}");
        }
        let state = self.screenshot.as_mut().expect("screenshot state");
        state.done = true;
        ctx.send_viewport_cmd(egui::ViewportCommand::Close);
    }

    fn update_screenshot_state(
        &mut self,
        ctx: &Context,
        layout_signature: Option<u64>,
        scroll_snapshot: Option<ScrollSnapshot>,
    ) {
        let Some(state) = self.screenshot.as_mut() else {
            return;
        };
        let native_ppp = ctx
            .input(|i| i.viewport().native_pixels_per_point)
            .unwrap_or(1.0);
        ctx.set_pixels_per_point(1.0);
        state.pixels_per_point = ctx.input(|i| i.pixels_per_point);

        if !state.viewport_adjusted {
            let width_points = (state.config.viewport_width / native_ppp).max(1.0);
            let height_points = (state.config.viewport_height / native_ppp).max(1.0);
            ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(egui::vec2(
                width_points,
                height_points,
            )));
            state.viewport_adjusted = true;
            ctx.request_repaint();
        }

        let mut scroll_offset = None;
        let mut scroll_changed = false;
        if let Some(snapshot) = scroll_snapshot {
            scroll_offset = Some(snapshot.offset_y);
            scroll_changed = state.record_scroll(snapshot);
        }

        state.update_stability(layout_signature, scroll_offset);

        let pending = self.renderer.has_pending_renders();
        state.pending_renders = pending;
        let elapsed = state.started.elapsed();
        let timed_out = elapsed >= Duration::from_millis(state.config.wait_ms);
        let stable = Self::screenshot_is_stable(
            state.scroll_ready(),
            state.stable_frames,
            state.config.settle_frames,
            pending,
        );

        if stable || timed_out {
            if timed_out && !stable {
                state.timed_out = true;
            }
            if !state.requested {
                ctx.send_viewport_cmd(egui::ViewportCommand::Screenshot);
                state.requested = true;
            }
        } else {
            ctx.request_repaint_after(Duration::from_millis(16));
        }

        if scroll_changed {
            ctx.request_repaint();
        }
        if state.requested && !state.done {
            ctx.request_repaint();
        }
    }

    fn screenshot_is_stable(
        scroll_ready: bool,
        stable_frames: u32,
        settle_frames: u32,
        pending: bool,
    ) -> bool {
        scroll_ready && stable_frames >= settle_frames && !pending
    }

    fn save_screenshot_image(image: &egui::ColorImage, state: &ScreenshotSnapshot) -> Result<()> {
        let full_width = image.size[0] as u32;
        let full_height = image.size[1] as u32;
        let mut rgba = Self::color_image_to_rgba(image);

        let mut crop_x = 0u32;
        let mut crop_y = 0u32;
        let mut crop_w = full_width;
        let mut crop_h = full_height;

        if state.config.content_only {
            if let Some(rect) = state.content_rect {
                let pixels_per_point = state.pixels_per_point.max(0.1);
                let min_x = (rect.min.x * pixels_per_point).round() as i32;
                let min_y = (rect.min.y * pixels_per_point).round() as i32;
                let max_x = (rect.max.x * pixels_per_point).round() as i32;
                let max_y = (rect.max.y * pixels_per_point).round() as i32;

                let min_x = min_x.clamp(0, full_width as i32);
                let min_y = min_y.clamp(0, full_height as i32);
                let max_x = max_x.clamp(min_x, full_width as i32);
                let max_y = max_y.clamp(min_y, full_height as i32);

                let width = (max_x - min_x) as u32;
                let height = (max_y - min_y) as u32;
                if width > 0 && height > 0 {
                    crop_x = min_x as u32;
                    crop_y = min_y as u32;
                    crop_w = width;
                    crop_h = height;
                }
            }
        }

        if crop_x != 0 || crop_y != 0 || crop_w != full_width || crop_h != full_height {
            rgba = imageops::crop_imm(&rgba, crop_x, crop_y, crop_w, crop_h).to_image();
        }

        if let Some(parent) = state.config.output_path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        rgba.save(&state.config.output_path)?;

        let metadata = Self::screenshot_metadata(state, full_width, full_height, crop_w, crop_h);
        std::fs::write(state.config.metadata_path(), metadata)?;
        Ok(())
    }

    fn screenshot_metadata(
        state: &ScreenshotSnapshot,
        full_width: u32,
        full_height: u32,
        crop_width: u32,
        crop_height: u32,
    ) -> String {
        let output_path = Self::json_escape(&state.config.output_path.to_string_lossy());
        let font_source = state
            .config
            .font_source
            .as_ref()
            .map(|value| format!("\"{}\"", Self::json_escape(value)))
            .unwrap_or_else(|| "null".to_string());
        let scroll_ratio = Self::json_opt_f32(state.config.scroll_ratio);
        let scroll_offset = Self::json_opt_f32(state.last_scroll_offset);
        let elapsed_ms = state.started.elapsed().as_millis();

        format!(
            "{{\n  \"version\": \"{}\",\n  \"build_timestamp\": \"{}\",\n  \"output\": \"{}\",\n  \"theme\": \"{}\",\n  \"zoom\": {:.3},\n  \"content_only\": {},\n  \"scroll_ratio\": {},\n  \"scroll_offset\": {},\n  \"viewport_px\": {{\"width\": {}, \"height\": {}}},\n  \"content_px\": {{\"width\": {}, \"height\": {}}},\n  \"pixels_per_point\": {:.3},\n  \"wait_ms\": {},\n  \"settle_frames\": {},\n  \"stable_frames\": {},\n  \"timed_out\": {},\n  \"pending_renders\": {},\n  \"font_source\": {},\n  \"elapsed_ms\": {}\n}}\n",
            BUILD_VERSION,
            BUILD_TIMESTAMP,
            output_path,
            state.config.theme.as_str(),
            state.config.zoom,
            state.config.content_only,
            scroll_ratio,
            scroll_offset,
            full_width,
            full_height,
            crop_width,
            crop_height,
            state.pixels_per_point,
            state.config.wait_ms,
            state.config.settle_frames,
            state.stable_frames,
            state.timed_out,
            state.pending_renders,
            font_source,
            elapsed_ms
        )
    }

    fn color_image_to_rgba(image: &egui::ColorImage) -> RgbaImage {
        let width = image.size[0] as u32;
        let height = image.size[1] as u32;
        let mut data = Vec::with_capacity(image.pixels.len() * 4);
        for pixel in &image.pixels {
            data.extend_from_slice(&[pixel.r(), pixel.g(), pixel.b(), pixel.a()]);
        }
        RgbaImage::from_raw(width, height, data).unwrap_or_else(|| RgbaImage::new(width, height))
    }

    fn json_escape(value: &str) -> String {
        let mut out = String::with_capacity(value.len() + 8);
        for ch in value.chars() {
            match ch {
                '\\' => out.push_str("\\\\"),
                '"' => out.push_str("\\\""),
                '\n' => out.push_str("\\n"),
                '\r' => out.push_str("\\r"),
                '\t' => out.push_str("\\t"),
                _ => out.push(ch),
            }
        }
        out
    }

    fn json_opt_f32(value: Option<f32>) -> String {
        value
            .map(|v| format!("{v:.3}"))
            .unwrap_or_else(|| "null".to_string())
    }

    // No overlay menu helpers; we only render egui's built-in menus.
}

impl Default for MarkdownViewerApp {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;
    use crate::markdown_renderer::InlineSpan;
    use eframe::{App, Storage};
    use std::io::Write;
    use std::sync::{Arc, Mutex, OnceLock};
    use tempfile::{NamedTempFile, TempDir};

    fn run_app_frame(app: &mut MarkdownViewerApp, ctx: &egui::Context, input: egui::RawInput) {
        let _ = ctx.run(input, |ctx| {
            app.update_impl(ctx);
        });
    }

    fn default_input() -> egui::RawInput {
        egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(960.0, 640.0),
            )),
            ..Default::default()
        }
    }

    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
        ENV_LOCK
            .get_or_init(|| Mutex::new(()))
            .lock()
            .expect("env lock")
    }

    struct EnvGuard {
        key: &'static str,
        original: Option<String>,
    }

    impl EnvGuard {
        fn set(key: &'static str, value: &str) -> Self {
            let original = std::env::var(key).ok();
            std::env::set_var(key, value);
            Self { key, original }
        }
    }

    impl Drop for EnvGuard {
        fn drop(&mut self) {
            if let Some(value) = &self.original {
                std::env::set_var(self.key, value);
            } else {
                std::env::remove_var(self.key);
            }
        }
    }

    #[derive(Default)]
    struct DummyStorage;

    impl eframe::Storage for DummyStorage {
        fn get_string(&self, _key: &str) -> Option<String> {
            None
        }

        fn set_string(&mut self, _key: &str, _value: String) {}

        fn flush(&mut self) {}
    }

    #[test]
    fn test_dummy_storage_methods_cover_noops() {
        let mut storage = DummyStorage;
        assert!(storage.get_string("missing").is_none());
        storage.set_string("key", "value".to_string());
        storage.flush();
    }

    #[test]
    fn test_app_auto_save_interval_is_30_seconds() {
        let app = MarkdownViewerApp::new();
        assert_eq!(app.auto_save_interval(), std::time::Duration::from_secs(30));
    }

    #[test]
    fn test_app_update_calls_update_impl() {
        let mut app = MarkdownViewerApp::new();
        let ctx = egui::Context::default();
        let _ = ctx.run(default_input(), |_| {});
        // SAFETY: eframe::Frame is unused by update(), so a dummy value is sufficient here.
        let mut frame = std::mem::MaybeUninit::<eframe::Frame>::zeroed();
        let frame = unsafe { frame.assume_init_mut() };
        app.update(&ctx, frame);
    }

    struct ForcedAppActions {
        actions: Vec<&'static str>,
    }

    impl ForcedAppActions {
        fn new(actions: &[&'static str]) -> Self {
            FORCED_APP_ACTIONS.with(|set| {
                let mut set = set.borrow_mut();
                for action in actions {
                    set.insert(*action);
                }
            });
            Self {
                actions: actions.to_vec(),
            }
        }
    }

    impl Drop for ForcedAppActions {
        fn drop(&mut self) {
            FORCED_APP_ACTIONS.with(|set| {
                let mut set = set.borrow_mut();
                for action in &self.actions {
                    set.remove(action);
                }
            });
        }
    }

    struct ForcedDialogPaths;

    impl ForcedDialogPaths {
        fn new(open: Option<PathBuf>, save: Option<PathBuf>) -> Self {
            FORCED_OPEN_PATH.with(|slot| {
                *slot.borrow_mut() = open;
            });
            FORCED_SAVE_PATH.with(|slot| {
                *slot.borrow_mut() = save;
            });
            Self
        }
    }

    impl Drop for ForcedDialogPaths {
        fn drop(&mut self) {
            FORCED_OPEN_PATH.with(|slot| {
                slot.borrow_mut().take();
            });
            FORCED_SAVE_PATH.with(|slot| {
                slot.borrow_mut().take();
            });
        }
    }

    struct ForcedLoadError;

    impl ForcedLoadError {
        fn new() -> Self {
            FORCED_LOAD_ERROR.with(|flag| {
                *flag.borrow_mut() = true;
            });
            Self
        }
    }

    impl Drop for ForcedLoadError {
        fn drop(&mut self) {
            FORCED_LOAD_ERROR.with(|flag| {
                *flag.borrow_mut() = false;
            });
        }
    }

    struct ForcedScanError;

    impl ForcedScanError {
        fn new() -> Self {
            FORCED_SCAN_ERROR.with(|flag| {
                *flag.borrow_mut() = true;
            });
            Self
        }
    }

    impl Drop for ForcedScanError {
        fn drop(&mut self) {
            FORCED_SCAN_ERROR.with(|flag| {
                *flag.borrow_mut() = false;
            });
        }
    }

    struct ForcedScanEntryError;

    impl ForcedScanEntryError {
        fn new() -> Self {
            FORCED_SCAN_ENTRY_ERROR.with(|flag| {
                *flag.borrow_mut() = true;
            });
            Self
        }
    }

    impl Drop for ForcedScanEntryError {
        fn drop(&mut self) {
            FORCED_SCAN_ENTRY_ERROR.with(|flag| {
                *flag.borrow_mut() = false;
            });
        }
    }

    struct ForcedLossyReadError;

    impl ForcedLossyReadError {
        fn new() -> Self {
            FORCED_READ_LOSSY_ERROR.with(|flag| {
                *flag.borrow_mut() = true;
            });
            Self
        }
    }

    impl Drop for ForcedLossyReadError {
        fn drop(&mut self) {
            FORCED_READ_LOSSY_ERROR.with(|flag| {
                *flag.borrow_mut() = false;
            });
        }
    }

    #[test]
    fn test_app_action_triggered_with_forced_action() {
        let _guard = ForcedAppActions::new(&["menu_open"]);
        assert!(app_action_triggered(false, "menu_open"));
        assert!(app_action_triggered(true, "menu_open"));
    }

    #[test]
    fn test_normalize_line_endings() {
        // Windows style (\r\n)
        assert_eq!(
            MarkdownViewerApp::normalize_line_endings("Hello\r\nWorld"),
            "Hello\nWorld"
        );

        // Unix style (\n) - no change
        assert_eq!(
            MarkdownViewerApp::normalize_line_endings("Hello\nWorld"),
            "Hello\nWorld"
        );

        // Old Mac style (\r)
        assert_eq!(
            MarkdownViewerApp::normalize_line_endings("Hello\rWorld"),
            "Hello\nWorld"
        );

        // Mixed line endings
        assert_eq!(
            MarkdownViewerApp::normalize_line_endings("A\r\nB\nC\rD"),
            "A\nB\nC\nD"
        );

        // Multiple blank lines with Windows endings
        assert_eq!(
            MarkdownViewerApp::normalize_line_endings("A\r\n\r\nB"),
            "A\n\nB"
        );

        // Empty string
        assert_eq!(MarkdownViewerApp::normalize_line_endings(""), "");

        // No line endings
        assert_eq!(
            MarkdownViewerApp::normalize_line_endings("Single line"),
            "Single line"
        );
    }

    #[test]
    fn test_load_file_with_windows_line_endings() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let mut temp_file = NamedTempFile::new()?;

        // Write content with explicit Windows line endings
        temp_file.write_all(b"Line 1\r\nLine 2\r\n\r\nParagraph text")?;
        temp_file.flush()?;

        app.load_file(temp_file.path().to_path_buf(), true)?;

        // Should not contain any \r characters after normalization
        assert!(!app.current_content.contains('\r'));
        assert!(app.current_content.contains("Line 1\nLine 2"));
        assert!(app.current_content.contains("\n\nParagraph"));
        Ok(())
    }

    #[test]
    fn test_load_file_with_mixed_line_endings() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let mut temp_file = NamedTempFile::new()?;

        // Mix of \r\n (Windows), \n (Unix), and \r (old Mac)
        temp_file.write_all(b"Line 1\r\nLine 2\nLine 3\rLine 4")?;
        temp_file.flush()?;

        app.load_file(temp_file.path().to_path_buf(), true)?;

        // All should be normalized to \n
        assert!(!app.current_content.contains('\r'));
        assert_eq!(app.current_content.lines().count(), 4);
        let lines: Vec<&str> = app.current_content.lines().collect();
        assert_eq!(lines[0], "Line 1");
        assert_eq!(lines[1], "Line 2");
        assert_eq!(lines[2], "Line 3");
        assert_eq!(lines[3], "Line 4");
        Ok(())
    }

    #[test]
    fn test_load_file_strips_bom() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let mut temp_file = NamedTempFile::new()?;

        temp_file.write_all(b"\xEF\xBB\xBF# Heading\nContent")?;
        temp_file.flush()?;

        app.load_file(temp_file.path().to_path_buf(), true)?;

        assert!(!app.current_content.starts_with('\u{FEFF}'));
        assert!(app.current_content.starts_with("# Heading"));
        Ok(())
    }

    #[test]
    fn test_app_creation() {
        let app = MarkdownViewerApp::new();
        assert!(!app.parsed_elements.is_empty()); // Should load welcome content
        assert!(app.title.contains(APP_TITLE_PREFIX));
        assert!(app.error_message.is_none());
        assert!(matches!(app.view_mode, ViewMode::Rendered));
    }

    #[test]
    fn test_load_content() {
        let mut app = MarkdownViewerApp::new();
        let content = "# Test Header\n\nThis is test content.";

        app.load_content(content, Some("Test".to_string()));

        assert_eq!(app.current_content, content);
        assert_eq!(app.raw_buffer, content);
        assert!(app.title.contains("Test"));
        assert!(!app.parsed_elements.is_empty());
        assert!(app.error_message.is_none());
    }

    #[test]
    fn test_toggle_view_mode() {
        let mut app = MarkdownViewerApp::new();
        let ctx = egui::Context::default();
        assert!(matches!(app.view_mode, ViewMode::Rendered));
        app.toggle_view_mode(&ctx);
        assert!(matches!(app.view_mode, ViewMode::Raw));
        app.toggle_view_mode(&ctx);
        assert!(matches!(app.view_mode, ViewMode::Rendered));
    }

    #[test]
    fn test_toggle_view_mode_without_text_state() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        let ctx = egui::Context::default();
        app.toggle_view_mode(&ctx);
        assert!(matches!(app.view_mode, ViewMode::Rendered));
        assert!(app.raw_cursor.is_none());
    }

    #[test]
    fn test_toggle_view_mode_with_state_without_cursor_range() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        let ctx = egui::Context::default();
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        state.cursor.set_char_range(None);
        state.store(&ctx, editor_id);

        app.toggle_view_mode(&ctx);

        assert!(matches!(app.view_mode, ViewMode::Rendered));
        assert!(app.raw_cursor.is_none());
    }

    #[test]
    fn test_load_sample() {
        let mut app = MarkdownViewerApp::new();
        let sample = &SAMPLE_FILES[0]; // First sample file

        app.load_sample(sample);

        assert_eq!(app.current_content, sample.content);
        assert!(app.title.contains(sample.title));
        assert!(!app.parsed_elements.is_empty());
        assert!(app.current_file.is_none()); // Sample files don't set file path
    }

    #[test]
    fn test_load_sample_by_name_reports_missing() {
        let mut app = MarkdownViewerApp::new();
        app.current_content = "keep".to_string();

        let loaded = app.load_sample_by_name(&[], "missing.md");

        assert!(!loaded);
        assert_eq!(app.current_content, "keep");
    }

    #[test]
    fn test_load_sample_by_name_loads_content() {
        let mut app = MarkdownViewerApp::new();
        let sample = SAMPLE_FILES
            .iter()
            .find(|sample| sample.name == "welcome.md")
            .expect("welcome sample");

        let loaded = app.load_sample_by_name(SAMPLE_FILES, "welcome.md");

        assert!(loaded);
        assert_eq!(app.current_content, sample.content);
        assert_eq!(app.pending_scroll_to_element, Some(0));
    }

    #[test]
    fn test_load_welcome_from_samples_missing_clears_state() {
        let mut app = MarkdownViewerApp::new();
        app.current_content = "content".to_string();
        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
            "content".to_string(),
        )])];
        app.title = "Custom".to_string();
        app.error_message = Some("error".to_string());

        app.load_welcome_from_samples(&[], false);

        assert!(app.current_content.is_empty());
        assert!(app.parsed_elements.is_empty());
        assert_eq!(app.title, APP_TITLE_PREFIX);
        assert!(app.error_message.is_none());
    }

    #[test]
    fn test_load_welcome_from_samples_sets_scroll_when_requested() {
        let mut app = MarkdownViewerApp::new();
        app.pending_scroll_to_element = None;

        app.load_welcome_from_samples(SAMPLE_FILES, true);

        assert_eq!(app.pending_scroll_to_element, Some(0));
    }

    #[test]
    fn test_spawn_file_loader_handles_error_path() {
        MarkdownViewerApp::force_thread_spawn_error_for_test();
        let _ = MarkdownViewerApp::spawn_file_loader();
    }

    #[test]
    fn test_spawn_file_loader_processes_request() -> Result<()> {
        let temp = NamedTempFile::new()?;
        writeln!(&temp, "hello")?;

        let (request_tx, result_rx) = MarkdownViewerApp::spawn_file_loader();
        request_tx
            .send(FileLoadRequest {
                id: 99,
                path: temp.path().to_path_buf(),
            })
            .expect("send");
        let result = result_rx
            .recv_timeout(std::time::Duration::from_secs(1))
            .expect("result");
        let (content, lossy) = result.content.expect("content");
        assert!(content.contains("hello"));
        assert!(!lossy);
        drop(request_tx);
        Ok(())
    }

    #[test]
    fn test_spawn_file_loader_reports_missing_file() {
        let temp_dir = TempDir::new().expect("temp dir");
        let missing_path = temp_dir.path().join("missing.md");

        let (request_tx, result_rx) = MarkdownViewerApp::spawn_file_loader();
        request_tx
            .send(FileLoadRequest {
                id: 101,
                path: missing_path,
            })
            .expect("send");
        let result = result_rx
            .recv_timeout(std::time::Duration::from_secs(1))
            .expect("result");
        assert!(result.content.is_err());
        drop(request_tx);
    }

    #[test]
    fn test_load_sample_without_existing_content_skips_history() {
        let mut app = MarkdownViewerApp::new();
        app.current_content.clear();
        app.raw_buffer.clear();
        app.history.clear();
        app.history_index = 0;
        let sample = &SAMPLE_FILES[0];

        app.load_sample(sample);

        assert!(app.history.is_empty());
    }

    #[test]
    fn test_load_file() -> Result<()> {
        let mut app = MarkdownViewerApp::new();

        // Create a temporary markdown file
        let mut temp_file = NamedTempFile::new()?;
        let content = "# Temporary File\n\nThis is a test markdown file.";
        temp_file.write_all(content.as_bytes())?;
        temp_file.flush()?;

        let path = temp_file.path().to_path_buf();
        app.load_file(path.clone(), true)?;

        assert_eq!(app.current_content, content);
        assert_eq!(app.current_file, Some(path));
        assert!(!app.parsed_elements.is_empty());
        assert!(app.error_message.is_none());

        Ok(())
    }

    #[test]
    fn test_load_file_async_sends_request() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let mut temp_file = NamedTempFile::new()?;
        let payload = vec![b'a'; ASYNC_LOAD_THRESHOLD_BYTES as usize];
        temp_file.write_all(&payload)?;
        temp_file.flush()?;

        let path = temp_file.path().to_path_buf();
        app.load_file(path.clone(), false)?;
        assert!(app.pending_file_load.is_some());
        assert_eq!(app.pending_file_load.as_ref().expect("pending").path, path);
        Ok(())
    }

    #[test]
    fn test_load_file_skips_async_when_screenshot_active() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let mut temp_file = NamedTempFile::new()?;
        let payload = vec![b'a'; ASYNC_LOAD_THRESHOLD_BYTES as usize];
        temp_file.write_all(&payload)?;
        temp_file.flush()?;

        let config = ScreenshotConfig {
            output_path: temp_file.path().with_extension("png"),
            viewport_width: 120.0,
            viewport_height: 80.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        app.screenshot = Some(ScreenshotState::new(config));

        let path = temp_file.path().to_path_buf();
        app.load_file(path.clone(), false)?;

        assert!(app.pending_file_load.is_none());
        assert_eq!(app.current_file, Some(path));
        Ok(())
    }

    #[test]
    fn test_load_file_async_falls_back_when_channel_closed() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let (tx, rx) = unbounded::<FileLoadRequest>();
        drop(rx);
        app.file_load_tx = tx;

        let mut temp_file = NamedTempFile::new()?;
        let payload = vec![b'a'; ASYNC_LOAD_THRESHOLD_BYTES as usize];
        temp_file.write_all(&payload)?;
        temp_file.flush()?;

        let path = temp_file.path().to_path_buf();
        app.load_file(path.clone(), false)?;
        assert_eq!(app.current_file, Some(path));
        assert!(app.pending_file_load.is_none());
        Ok(())
    }

    #[test]
    fn test_poll_file_loads_handles_mismatch_and_lossy() {
        let mut app = MarkdownViewerApp::new();
        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
        app.file_load_rx = result_rx;

        let temp = NamedTempFile::new().expect("temp");
        let path = temp.path().to_path_buf();
        app.pending_file_load = Some(PendingFileLoad {
            id: 1,
            path: path.clone(),
        });

        result_tx
            .send(FileLoadResult {
                id: 2,
                content: Ok(("ignored".to_string(), false)),
            })
            .expect("send mismatch");
        app.poll_file_loads();
        assert!(app.pending_file_load.is_some());

        result_tx
            .send(FileLoadResult {
                id: 1,
                content: Ok(("loaded".to_string(), true)),
            })
            .expect("send match");
        app.poll_file_loads();
        assert!(app.pending_file_load.is_none());
        assert_eq!(app.current_file, Some(path));
    }

    #[test]
    fn test_poll_file_loads_handles_match_non_lossy() {
        let mut app = MarkdownViewerApp::new();
        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
        app.file_load_rx = result_rx;

        let temp = NamedTempFile::new().expect("temp");
        let path = temp.path().to_path_buf();
        app.pending_file_load = Some(PendingFileLoad {
            id: 1,
            path: path.clone(),
        });

        result_tx
            .send(FileLoadResult {
                id: 1,
                content: Ok(("loaded".to_string(), false)),
            })
            .expect("send match");
        app.poll_file_loads();
        assert!(app.pending_file_load.is_none());
        assert_eq!(app.current_file, Some(path));
    }

    #[test]
    fn test_poll_file_loads_sets_error_on_failure() {
        let mut app = MarkdownViewerApp::new();
        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
        app.file_load_rx = result_rx;

        let temp = NamedTempFile::new().expect("temp");
        let path = temp.path().to_path_buf();
        app.pending_file_load = Some(PendingFileLoad { id: 1, path });

        result_tx
            .send(FileLoadResult {
                id: 1,
                content: Err("boom".to_string()),
            })
            .expect("send match");
        app.poll_file_loads();
        assert!(app.pending_file_load.is_none());
        assert!(app.error_message.as_deref().unwrap_or("").contains("boom"));
    }

    #[test]
    fn test_load_invalid_markdown() {
        let mut app = MarkdownViewerApp::new();
        // Even "invalid" markdown should parse successfully with pulldown-cmark
        // as it's very permissive
        let content = "This is just plain text with some <invalid> HTML tags";

        app.load_content(content, Some("Invalid".to_string()));

        // Should still work - pulldown-cmark is very permissive
        assert_eq!(app.current_content, content);
        assert!(app.error_message.is_none());
    }

    #[test]
    fn test_load_content_parse_error_sets_message() {
        let mut app = MarkdownViewerApp::new();
        crate::markdown_renderer::force_parse_error_once();

        app.load_content("# Bad Parse", Some("Bad".to_string()));

        assert!(app
            .error_message
            .as_ref()
            .is_some_and(|msg| msg.contains("Failed to parse markdown")));
        assert!(app.parsed_elements.is_empty());
    }

    #[test]
    fn test_load_empty_content() {
        let mut app = MarkdownViewerApp::new();
        app.load_content("", Some("Empty".to_string()));

        assert_eq!(app.current_content, "");
        assert!(app.title.contains("Empty"));
        assert!(app.error_message.is_none());
    }

    #[test]
    fn test_load_nonexistent_file() {
        let mut app = MarkdownViewerApp::new();
        let fake_path = PathBuf::from("/nonexistent/file.md");

        let result = app.load_file(fake_path, true);
        assert!(result.is_err());
    }

    #[test]
    fn test_reload_current_file() -> Result<()> {
        let mut app = MarkdownViewerApp::new();

        // Create a temporary markdown file
        let mut temp_file = NamedTempFile::new()?;
        let content1 = "# Title\n\nVersion 1";
        temp_file.write_all(content1.as_bytes())?;
        temp_file.flush()?;

        let path = temp_file.path().to_path_buf();
        app.load_file(path.clone(), true)?;
        assert!(app.current_content.contains("Version 1"));

        // Update file content
        let content2 = "# Title\n\nVersion 2";
        temp_file.as_file_mut().set_len(0)?; // clear
        temp_file.write_all(content2.as_bytes())?;
        temp_file.flush()?;

        // Reload and verify
        app.reload_current_file()?;
        assert!(app.current_content.contains("Version 2"));
        Ok(())
    }

    #[test]
    fn test_load_file_with_invalid_utf8() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let mut temp_file = NamedTempFile::new()?;
        let bytes = b"Hello\xFFWorld";
        temp_file.write_all(bytes)?;
        temp_file.flush()?;

        app.load_file(temp_file.path().to_path_buf(), true)?;

        assert!(app.current_content.contains('\u{FFFD}'));
        assert!(!app.parsed_elements.is_empty());
        assert!(app.error_message.is_none());
        Ok(())
    }

    #[test]
    fn test_read_file_lossy_invalid_utf8_returns_lossy() -> Result<()> {
        let temp_file = NamedTempFile::new()?;
        std::fs::write(temp_file.path(), b"Hello\xFFWorld")?;

        let (content, lossy) = MarkdownViewerApp::read_file_lossy(temp_file.path())?;
        assert!(lossy);
        assert!(content.contains("Hello"));
        assert!(content.contains("World"));
        Ok(())
    }

    #[test]
    fn test_read_file_lossy_forced_read_error() -> Result<()> {
        let temp_file = NamedTempFile::new()?;
        std::fs::write(temp_file.path(), b"Hello\xFFWorld")?;

        let _guard = ForcedLossyReadError::new();
        assert!(MarkdownViewerApp::read_file_lossy(temp_file.path()).is_err());
        Ok(())
    }

    #[test]
    fn test_reload_without_file() {
        let mut app = MarkdownViewerApp::new();
        assert!(app.current_file.is_none());
        let result = app.reload_current_file();
        assert!(result.is_err());
    }

    #[test]
    fn test_window_state_change_detection() {
        let mut app = MarkdownViewerApp::new();
        app.last_window_pos = Some([10.0, 10.0]);
        app.last_window_size = Some([800.0, 600.0]);
        app.last_window_maximized = false;

        let state = app.current_window_state().expect("state");
        assert!(app.window_state_changed(&state));
        app.last_persisted_state = Some(state);
        assert!(!app.window_state_changed(&state));

        let mut moved = state;
        moved.pos = [12.0, 10.0];
        assert!(app.window_state_changed(&moved));

        let mut resized = state;
        resized.size = [820.0, 610.0];
        assert!(app.window_state_changed(&resized));

        let mut maximized = state;
        maximized.maximized = true;
        assert!(app.window_state_changed(&maximized));
    }

    #[test]
    fn test_current_window_state_requires_size() {
        let mut app = MarkdownViewerApp::new();
        app.last_window_pos = Some([10.0, 10.0]);
        app.last_window_size = None;
        assert!(app.current_window_state().is_none());
    }

    #[test]
    fn test_fold_for_search_handles_case_and_accents() {
        assert_eq!(
            MarkdownViewerApp::fold_for_search("\u{00C4}\u{00DF}"),
            MarkdownViewerApp::fold_for_search("\u{00E4}SS")
        );
        assert_eq!(
            MarkdownViewerApp::fold_for_search("To\u{0301}m"),
            MarkdownViewerApp::fold_for_search("T\u{00D3}m")
        );
    }

    #[test]
    fn test_title_updates() {
        let mut app = MarkdownViewerApp::new();

        // Test with custom title
        app.load_content("# Test", Some("Custom Title".to_string()));
        assert!(app.title.contains("Custom Title"));

        // Test with no title (should keep existing)
        let old_title = app.title.clone();
        app.load_content("# Another Test", None);
        assert_eq!(app.title, old_title); // Should remain unchanged
    }

    #[test]
    fn test_complex_markdown_loading() {
        let mut app = MarkdownViewerApp::new();
        let complex_content = r#"# Complex Document

## With Multiple Sections

This has **bold** and *italic* text.

```rust
fn main() {
    println!("Hello, world!");
}
```

- List item 1
- List item 2

> A blockquote

[A link](https://example.com)

---

The end.
"#;

        app.load_content(complex_content, Some("Complex".to_string()));

        assert_eq!(app.current_content, complex_content);
        assert!(app.title.contains("Complex"));
        assert!(!app.parsed_elements.is_empty());
        assert!(app.error_message.is_none());

        // Should have parsed various element types
        assert!(app.parsed_elements.len() > 5); // Complex document should have many elements
    }

    #[test]
    fn test_error_handling() {
        let app = MarkdownViewerApp::new();

        // Test that app starts without errors
        assert!(app.error_message.is_none());

        // Even with the welcome content loaded, should be error-free
        assert!(!app.parsed_elements.is_empty());
    }

    #[test]
    fn test_default_state() {
        let app = MarkdownViewerApp::default();

        // Default should be same as new()
        assert!(!app.parsed_elements.is_empty());
        assert!(app.title.contains(APP_TITLE_PREFIX));
        assert!(app.error_message.is_none());
        assert!(app.current_file.is_none());
    }

    #[test]
    fn test_sample_files_integration() {
        let mut app = MarkdownViewerApp::new();

        // Test loading each sample file
        for sample in SAMPLE_FILES {
            app.load_sample(sample);

            assert_eq!(app.current_content, sample.content);
            assert!(app.title.contains(sample.title));
            assert!(app.current_file.is_none());
            assert!(app.error_message.is_none());
        }
    }

    #[test]
    fn test_close_current_file() {
        let mut app = MarkdownViewerApp::new();

        // Load some content first
        app.load_content("# Test Content", Some("Test File".to_string()));
        assert!(app.title.contains("Test File"));

        // Close the file
        app.close_current_file();

        // Should return to welcome screen
        assert!(app.title.contains("Welcome"));
        assert!(app.current_file.is_none());
        assert!(!app.parsed_elements.is_empty()); // Should have welcome content
        assert!(app.error_message.is_none());
    }

    #[test]
    fn test_navigation_request_enum() {
        // Test that the enum values exist and are correct
        let _top = NavigationRequest::Top;
        let _bottom = NavigationRequest::Bottom;
        let _page_up = NavigationRequest::PageUp;
        let _page_down = NavigationRequest::PageDown;
        let _scroll_up = NavigationRequest::ScrollUp;
        let _scroll_down = NavigationRequest::ScrollDown;

        // Ensure it's cloneable and debuggable
        let nav = NavigationRequest::Top;
        let _cloned = nav.clone();
        let _debug = format!("{:?}", nav);

        // Basic compilation test performed by using the enum and Debug/Clone
    }

    #[test]
    fn test_navigation_state_initialization() {
        let app = MarkdownViewerApp::new();
        // Test that nav_request is initialized to None
        assert!(app.nav_request.is_none());
        // Test that fullscreen toggle flag is initialized to false
        assert!(!app.toggle_fullscreen);
    }

    #[test]
    fn test_fullscreen_toggle_flag() {
        let mut app = MarkdownViewerApp::new();

        // Initially should be false
        assert!(!app.toggle_fullscreen);

        // Simulate F11 key press (this would be set in handle_shortcuts)
        app.toggle_fullscreen = true;
        assert!(app.toggle_fullscreen);

        // After handling, it should be reset to false
        app.toggle_fullscreen = false;
        assert!(!app.toggle_fullscreen);
    }

    #[test]
    fn test_navigation_state_reset_on_load() {
        let mut app = MarkdownViewerApp::new();

        // Set a navigation request
        app.nav_request = Some(NavigationRequest::Top);
        assert!(app.nav_request.is_some());

        // Load content should reset navigation state
        app.load_content("# Test Content", Some("Test".to_string()));
        assert!(app.nav_request.is_none());
    }

    #[test]
    fn test_page_navigation_calculations() {
        // Test the page size calculation logic used in navigation
        let viewport_height = 800.0f32;
        let page_size = viewport_height * 0.8;
        assert_eq!(page_size, 640.0);

        // Test boundary conditions for Page Up
        let current_offset = 100.0f32;
        let new_offset_up = (current_offset - page_size).max(0.0);
        assert_eq!(new_offset_up, 0.0); // Should clamp to 0

        // Test Page Down calculation
        let new_offset_down = current_offset + page_size;
        assert_eq!(new_offset_down, 740.0);

        // Test that Page Up from near top goes to 0
        let near_top = 300.0f32;
        let from_near_top = (near_top - page_size).max(0.0);
        assert_eq!(from_near_top, 0.0);
    }

    #[test]
    fn test_compute_window_adjustment_clamps_offscreen_window() {
        let outer = egui::Rect::from_min_size(egui::pos2(1200.0, 900.0), egui::vec2(800.0, 600.0));
        let monitor = egui::vec2(1024.0, 768.0);
        let adjustment =
            MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), Some(monitor))
                .expect("should adjust window geometry");
        let pos = adjustment.pos.expect("expected position adjustment");
        let size = adjustment.size.unwrap_or_else(|| outer.size());
        assert!(pos.x <= monitor.x - size.x + 1.0);
        assert!(pos.y <= monitor.y - size.y + 1.0);
        assert!(adjustment.size.is_none());
    }

    #[test]
    fn test_compute_window_adjustment_respects_min_size() {
        let outer = egui::Rect::from_min_size(egui::pos2(-200.0, -100.0), egui::vec2(200.0, 100.0));
        let monitor = egui::vec2(1920.0, 1080.0);
        let adjustment =
            MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), Some(monitor))
                .expect("should enforce minimum window size");
        let pos = adjustment.pos.unwrap_or(outer.min);
        let size = adjustment.size.expect("expected size adjustment");
        assert!(size.x >= 600.0);
        assert!(size.y >= 400.0);
        assert!(pos.x >= 0.0);
        assert!(pos.y >= 0.0);
    }

    #[test]
    fn test_is_valid_markdown_file() {
        let app = MarkdownViewerApp::new();

        // Valid markdown extensions
        assert!(app.is_valid_markdown_file(Path::new("test.md")));
        assert!(app.is_valid_markdown_file(Path::new("test.markdown")));
        assert!(app.is_valid_markdown_file(Path::new("test.mdown")));
        assert!(app.is_valid_markdown_file(Path::new("test.mkd")));
        assert!(app.is_valid_markdown_file(Path::new("test.txt")));

        // Case insensitive
        assert!(app.is_valid_markdown_file(Path::new("test.MD")));
        assert!(app.is_valid_markdown_file(Path::new("test.Markdown")));

        // Invalid extensions
        assert!(!app.is_valid_markdown_file(Path::new("test.pdf")));
        assert!(!app.is_valid_markdown_file(Path::new("test.docx")));
        assert!(!app.is_valid_markdown_file(Path::new("test.html")));

        // No extension
        assert!(!app.is_valid_markdown_file(Path::new("test")));
    }

    #[test]
    fn test_scan_directory() -> Result<()> {
        let temp_dir = tempfile::TempDir::new()?;
        let dir_path = temp_dir.path();

        // Create test files
        std::fs::write(dir_path.join("zebra.md"), "# Z")?;
        std::fs::write(dir_path.join("alpha.md"), "# A")?;
        std::fs::write(dir_path.join("image.png"), "fake")?;
        std::fs::write(dir_path.join("beta.markdown"), "# B")?;

        // Create subdirectory (should be ignored)
        std::fs::create_dir(dir_path.join("subdir"))?;
        std::fs::write(dir_path.join("subdir/nested.md"), "# N")?;

        let app = MarkdownViewerApp::new();
        let files = app.scan_directory(dir_path)?;

        // Should find 3 markdown files (alpha, beta, zebra)
        // Should NOT find image.png or nested.md
        assert_eq!(files.len(), 3);

        // Should be sorted alphabetically
        assert!(files[0].ends_with("alpha.md"));
        assert!(files[1].ends_with("beta.markdown"));
        assert!(files[2].ends_with("zebra.md"));

        Ok(())
    }

    #[test]
    fn test_scan_empty_directory() -> Result<()> {
        let temp_dir = tempfile::TempDir::new()?;
        let app = MarkdownViewerApp::new();
        let files = app.scan_directory(temp_dir.path())?;

        assert_eq!(files.len(), 0);
        Ok(())
    }

    #[test]
    fn test_scan_directory_missing_dir_returns_error() -> Result<()> {
        let temp_dir = tempfile::TempDir::new()?;
        let missing = temp_dir.path().join("missing");
        let app = MarkdownViewerApp::new();
        assert!(app.scan_directory(&missing).is_err());
        Ok(())
    }

    #[test]
    fn test_scan_directory_entry_error() -> Result<()> {
        let temp_dir = tempfile::TempDir::new()?;
        std::fs::write(temp_dir.path().join("doc.md"), "# Doc")?;
        let _guard = ForcedScanEntryError::new();
        let app = MarkdownViewerApp::new();
        assert!(app.scan_directory(temp_dir.path()).is_err());
        Ok(())
    }

    #[test]
    fn test_resolve_scan_entry_propagates_error() {
        let err = std::io::Error::other("forced entry error");
        let result = MarkdownViewerApp::resolve_scan_entry(Err(err));
        assert!(result.is_err());
    }

    #[test]
    fn test_single_file_drop() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;
        let file = temp_dir.path().join("test.md");
        std::fs::write(&file, "# Test")?;

        app.handle_file_drop(vec![file.clone()]);

        assert_eq!(app.current_file, Some(file));
        assert!(app.pending_files.is_empty());
        assert!(app.error_message.is_none());
        Ok(())
    }

    #[test]
    fn test_multiple_files_drop() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;

        let files: Vec<PathBuf> = (0..5)
            .map(|i| {
                let path = temp_dir.path().join(format!("file{}.md", i));
                std::fs::write(&path, format!("# File {}", i)).unwrap();
                path
            })
            .collect();

        app.handle_file_drop(files.clone());

        assert_eq!(app.current_file, Some(files[0].clone()));
        assert_eq!(app.pending_files.len(), 4);
        Ok(())
    }

    #[test]
    fn test_directory_drop() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;

        // Create files in directory
        std::fs::write(temp_dir.path().join("a.md"), "# A")?;
        std::fs::write(temp_dir.path().join("b.md"), "# B")?;
        std::fs::write(temp_dir.path().join("c.md"), "# C")?;

        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);

        assert!(app.current_file.is_some());
        assert_eq!(app.pending_files.len(), 2);
        Ok(())
    }

    #[test]
    fn test_invalid_file_drop() {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new().unwrap();
        let file = temp_dir.path().join("test.pdf");
        std::fs::write(&file, "fake pdf").unwrap();

        app.handle_file_drop(vec![file]);

        // Current file should remain None (or welcome sample)
        assert!(app.error_message.is_some());
        assert!(app
            .error_message
            .as_ref()
            .unwrap()
            .contains("Not a markdown file"));
    }

    #[test]
    fn test_too_many_files() {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new().unwrap();

        let files: Vec<PathBuf> = (0..60)
            .map(|i| {
                let path = temp_dir.path().join(format!("file{}.md", i));
                std::fs::write(&path, format!("# File {}", i)).unwrap();
                path
            })
            .collect();

        app.handle_file_drop(files);

        assert!(app.error_message.is_some());
        assert!(app
            .error_message
            .as_ref()
            .unwrap()
            .contains("Too many files"));
    }

    #[test]
    fn test_queue_navigation() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;

        let file1 = temp_dir.path().join("file1.md");
        let file2 = temp_dir.path().join("file2.md");

        std::fs::write(&file1, "# File 1")?;
        std::fs::write(&file2, "# File 2")?;

        // Load first file and queue second
        app.load_file(file1.clone(), true)?;
        app.pending_files.push_back(file2.clone());

        assert!(app.can_navigate_forward());
        app.navigate_forward();
        assert_eq!(app.current_file, Some(file2));
        assert!(app.pending_files.is_empty());

        Ok(())
    }

    #[test]
    fn test_mixed_valid_invalid_files() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;

        let md_file = temp_dir.path().join("test.md");
        let pdf_file = temp_dir.path().join("test.pdf");

        std::fs::write(&md_file, "# Test")?;
        std::fs::write(&pdf_file, "fake pdf")?;

        app.handle_file_drop(vec![md_file.clone(), pdf_file]);

        // Should open the valid markdown file
        assert_eq!(app.current_file, Some(md_file));
        // Should show error about the invalid file
        assert!(app.error_message.is_some());
        Ok(())
    }

    #[test]
    fn test_empty_directory_drop() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;

        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);

        assert!(app.error_message.is_some());
        assert!(app
            .error_message
            .as_ref()
            .unwrap()
            .contains("No markdown files"));
        Ok(())
    }

    #[test]
    fn test_toggle_write_mode_tracks_cursor_and_focus() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = false;
        app.raw_focus_requested = false;

        let ctx = egui::Context::default();
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(3));
        state.cursor.set_char_range(Some(cr));
        state.store(&ctx, editor_id);

        app.toggle_write_mode(&ctx);
        assert!(app.write_enabled);
        assert!(app.raw_focus_requested);

        app.toggle_write_mode(&ctx);
        assert!(!app.write_enabled);
        assert_eq!(app.raw_cursor, Some(3));
    }

    #[test]
    fn test_toggle_write_mode_rendered_does_not_request_focus() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Rendered;
        app.write_enabled = false;
        app.raw_focus_requested = false;

        let ctx = egui::Context::default();
        app.toggle_write_mode(&ctx);

        assert!(app.write_enabled);
        assert!(!app.raw_focus_requested);
    }

    #[test]
    fn test_find_next_and_previous_wraps() {
        let mut app = MarkdownViewerApp::new();
        app.load_content("Alpha\n\nBeta\n\nGamma", Some("Search".to_string()));
        app.search_query = "beta".to_string();

        app.find_next();
        assert_eq!(app.last_match_index, Some(1));
        assert_eq!(app.pending_scroll_to_element, Some(1));

        app.find_next();
        assert_eq!(app.last_match_index, Some(1));

        app.find_previous();
        assert_eq!(app.last_match_index, Some(1));
    }

    #[test]
    fn test_update_impl_rendered_view_runs() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        app.nav_request = Some(NavigationRequest::PageDown);
        app.toggle_fullscreen = true;

        let mut temp_file = tempfile::Builder::new().suffix(".md").tempfile()?;
        temp_file.write_all(b"# Dropped\nContent")?;
        temp_file.flush()?;

        let ctx = egui::Context::default();
        let mut input = default_input();
        let vp = input
            .viewports
            .get_mut(&egui::ViewportId::ROOT)
            .expect("root viewport");
        vp.monitor_size = Some(egui::vec2(1024.0, 768.0));
        vp.outer_rect = Some(egui::Rect::from_min_size(
            egui::pos2(1200.0, 900.0),
            egui::vec2(800.0, 600.0),
        ));
        vp.inner_rect = Some(egui::Rect::from_min_size(
            egui::pos2(0.0, 0.0),
            egui::vec2(800.0, 600.0),
        ));
        vp.fullscreen = Some(false);
        vp.maximized = Some(false);
        input.hovered_files.push(egui::HoveredFile {
            path: Some(temp_file.path().to_path_buf()),
            ..Default::default()
        });
        input.dropped_files.push(egui::DroppedFile {
            path: Some(temp_file.path().to_path_buf()),
            ..Default::default()
        });

        run_app_frame(&mut app, &ctx, input);

        assert!(app.drag_hover);
        assert!(app.current_file.is_some());
        assert!(app.last_window_pos.is_some());
        assert!(app.last_window_size.is_some());
        Ok(())
    }

    #[test]
    fn test_update_impl_applies_size_adjustment() {
        let mut app = MarkdownViewerApp::new();
        let ctx = egui::Context::default();
        let mut input = default_input();
        let vp = input
            .viewports
            .get_mut(&egui::ViewportId::ROOT)
            .expect("root viewport");
        vp.monitor_size = Some(egui::vec2(800.0, 600.0));
        vp.outer_rect = Some(egui::Rect::from_min_size(
            egui::pos2(10.0, 10.0),
            egui::vec2(800.0, 600.0),
        ));
        vp.inner_rect = Some(egui::Rect::from_min_size(
            egui::pos2(0.0, 0.0),
            egui::vec2(200.0, 100.0),
        ));
        vp.fullscreen = Some(false);
        vp.maximized = Some(false);

        run_app_frame(&mut app, &ctx, input);

        assert!(app.last_window_size.is_some());
        assert!(app.last_window_pos.is_some());
    }

    #[test]
    fn test_update_impl_applies_deferred_toggles() {
        let mut app = MarkdownViewerApp::new();
        app.view_toggle_requested = true;
        app.write_toggle_requested = true;

        let ctx = egui::Context::default();
        run_app_frame(&mut app, &ctx, default_input());

        assert_eq!(app.view_mode, ViewMode::Raw);
        assert!(app.write_enabled);
    }

    #[test]
    fn test_update_impl_reload_without_file_sets_error() {
        let mut app = MarkdownViewerApp::new();
        app.reload_requested = true;

        let ctx = egui::Context::default();
        let input = default_input();
        run_app_frame(&mut app, &ctx, input);

        assert!(app.error_message.is_some());
    }

    #[test]
    fn test_update_impl_raw_read_only_renders() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = false;
        app.raw_buffer = "Line 1\nLine 2".to_string();
        app.current_content = app.raw_buffer.clone();

        let ctx = egui::Context::default();
        let input = default_input();
        run_app_frame(&mut app, &ctx, input);

        assert_eq!(app.raw_buffer, "Line 1\nLine 2");
    }

    #[test]
    fn test_update_impl_moves_raw_cursor() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        app.raw_buffer = "Line 1\nLine 2\nLine 3".to_string();
        app.current_content = app.raw_buffer.clone();
        app.pending_raw_cursor_line_move = Some(1);

        let ctx = egui::Context::default();
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
        state.cursor.set_char_range(Some(cr));
        state.store(&ctx, editor_id);

        let input = default_input();
        run_app_frame(&mut app, &ctx, input);

        assert!(app.raw_cursor.unwrap_or(0) > 0);
    }

    #[test]
    fn test_json_helpers_escape_and_opt() {
        assert_eq!(
            MarkdownViewerApp::json_escape("a\"b\\c\n\t\r"),
            "a\\\"b\\\\c\\n\\t\\r"
        );
        assert_eq!(MarkdownViewerApp::json_opt_f32(Some(1.23456)), "1.235");
        assert_eq!(MarkdownViewerApp::json_opt_f32(None), "null");
    }

    #[test]
    fn test_color_image_to_rgba_falls_back_on_invalid_buffer() {
        let image = egui::ColorImage {
            size: [1, 1],
            pixels: Vec::new(),
        };
        let rgba = MarkdownViewerApp::color_image_to_rgba(&image);
        assert_eq!(rgba.width(), 1);
        assert_eq!(rgba.height(), 1);
    }

    #[test]
    fn test_save_screenshot_image_crops_and_writes_metadata() -> Result<()> {
        let temp_dir = tempfile::TempDir::new()?;
        let output_path = temp_dir.path().join("shot.png");
        let config = ScreenshotConfig {
            output_path: output_path.clone(),
            viewport_width: 80.0,
            viewport_height: 60.0,
            content_only: true,
            scroll_ratio: Some(0.5),
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: Some("TestFont".to_string()),
        };
        let snapshot = ScreenshotSnapshot {
            config,
            content_rect: Some(egui::Rect::from_min_size(
                egui::pos2(10.0, 5.0),
                egui::vec2(20.0, 10.0),
            )),
            pixels_per_point: 1.0,
            stable_frames: 3,
            timed_out: false,
            pending_renders: false,
            last_scroll_offset: Some(12.0),
            started: Instant::now(),
        };

        let mut image = egui::ColorImage::new([80, 60], Color32::BLACK);
        image.pixels[0] = Color32::from_rgb(10, 20, 30);

        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;

        let saved = image::open(&output_path)?;
        assert_eq!(saved.width(), 20);
        assert_eq!(saved.height(), 10);

        let metadata = std::fs::read_to_string(output_path.with_extension("json"))?;
        assert!(metadata.contains("\"content_only\": true"));
        assert!(metadata.contains("\"font_source\": \"TestFont\""));
        Ok(())
    }

    #[test]
    fn test_update_screenshot_state_requests_and_scrolls() {
        let temp_dir = tempfile::TempDir::new().expect("temp dir");
        let config = ScreenshotConfig {
            output_path: temp_dir.path().join("shot.png"),
            viewport_width: 100.0,
            viewport_height: 80.0,
            content_only: false,
            scroll_ratio: Some(0.5),
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Dark,
            font_source: None,
        };

        let mut app = MarkdownViewerApp::new();
        app.set_screenshot_mode(config);

        let ctx = egui::Context::default();
        let snapshot = ScrollSnapshot {
            content_size: egui::vec2(100.0, 200.0),
            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(100.0, 100.0)),
            offset_y: 0.0,
        };
        app.update_screenshot_state(&ctx, Some(1), Some(snapshot));

        let target_offset = app
            .screenshot
            .as_ref()
            .and_then(|state| state.scroll_offset)
            .unwrap_or(0.0);
        let snapshot_ready = ScrollSnapshot {
            content_size: egui::vec2(100.0, 200.0),
            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(100.0, 100.0)),
            offset_y: target_offset,
        };
        app.update_screenshot_state(&ctx, Some(1), Some(snapshot_ready));

        let state = app.screenshot.as_ref().expect("screenshot state");
        assert!(state.viewport_adjusted);
        assert!(state.requested);
        assert!(state.scroll_ready());
    }

    #[test]
    fn test_update_screenshot_state_stable_without_timeout() {
        let temp_dir = tempfile::TempDir::new().expect("temp dir");
        let config = ScreenshotConfig {
            output_path: temp_dir.path().join("shot.png"),
            viewport_width: 120.0,
            viewport_height: 80.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 10_000,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let mut app = MarkdownViewerApp::new();
        app.screenshot = Some(ScreenshotState::new(config));

        let ctx = egui::Context::default();
        app.update_screenshot_state(&ctx, Some(1), None);

        let state = app.screenshot.as_ref().expect("screenshot state");
        assert!(state.requested);
        assert!(!state.timed_out);
    }

    #[test]
    fn test_update_screenshot_state_times_out_before_stable() {
        let temp_dir = tempfile::TempDir::new().expect("temp dir");
        let config = ScreenshotConfig {
            output_path: temp_dir.path().join("shot.png"),
            viewport_width: 120.0,
            viewport_height: 80.0,
            content_only: false,
            scroll_ratio: Some(0.5),
            wait_ms: 0,
            settle_frames: 5,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let mut app = MarkdownViewerApp::new();
        app.screenshot = Some(ScreenshotState::new(config));

        let ctx = egui::Context::default();
        app.update_screenshot_state(&ctx, None, None);

        let state = app.screenshot.as_ref().expect("screenshot state");
        assert!(state.timed_out);
    }

    #[test]
    fn test_save_persists_window_state_when_no_screenshot() {
        let _lock = env_lock();
        let temp_dir = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());

        let mut app = MarkdownViewerApp::new();
        app.last_window_pos = Some([10.0, 20.0]);
        app.last_window_size = Some([800.0, 600.0]);
        let mut storage = DummyStorage;
        app.save(&mut storage);

        let path = temp_dir
            .path()
            .join("MarkdownView")
            .join("window_state.txt");
        assert!(path.exists());
    }

    #[test]
    fn test_save_skips_persist_when_screenshot_active() {
        let _lock = env_lock();
        let temp_dir = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());

        let mut app = MarkdownViewerApp::new();
        let config = ScreenshotConfig {
            output_path: temp_dir.path().join("shot.png"),
            viewport_width: 10.0,
            viewport_height: 10.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        app.set_screenshot_mode(config);
        let mut storage = DummyStorage;
        app.save(&mut storage);

        let path = temp_dir
            .path()
            .join("MarkdownView")
            .join("window_state.txt");
        assert!(!path.exists());
    }

    #[test]
    fn test_save_screenshot_image_crops_content_rect() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let output_path = temp_dir.path().join("shot.png");
        let config = ScreenshotConfig {
            output_path: output_path.clone(),
            viewport_width: 100.0,
            viewport_height: 80.0,
            content_only: true,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Dark,
            font_source: None,
        };
        let snapshot = ScreenshotSnapshot {
            config,
            content_rect: Some(egui::Rect::from_min_max(
                egui::pos2(2.0, 2.0),
                egui::pos2(8.0, 8.0),
            )),
            pixels_per_point: 1.0,
            stable_frames: 0,
            timed_out: false,
            pending_renders: false,
            last_scroll_offset: None,
            started: std::time::Instant::now(),
        };
        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
        assert!(output_path.exists());
        assert!(output_path.with_extension("json").exists());
        Ok(())
    }

    #[test]
    fn test_save_screenshot_image_no_crop() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let output_path = temp_dir.path().join("shot.png");
        let config = ScreenshotConfig {
            output_path: output_path.clone(),
            viewport_width: 100.0,
            viewport_height: 80.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let snapshot = ScreenshotSnapshot {
            config,
            content_rect: None,
            pixels_per_point: 1.0,
            stable_frames: 0,
            timed_out: false,
            pending_renders: false,
            last_scroll_offset: None,
            started: std::time::Instant::now(),
        };
        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
        assert!(output_path.exists());
        Ok(())
    }

    #[test]
    fn test_save_screenshot_image_zero_content_rect_ignored() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let output_path = temp_dir.path().join("shot.png");
        let config = ScreenshotConfig {
            output_path: output_path.clone(),
            viewport_width: 100.0,
            viewport_height: 80.0,
            content_only: true,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Dark,
            font_source: None,
        };
        let snapshot = ScreenshotSnapshot {
            config,
            content_rect: Some(egui::Rect::from_min_max(
                egui::pos2(5.0, 5.0),
                egui::pos2(5.0, 5.0),
            )),
            pixels_per_point: 1.0,
            stable_frames: 0,
            timed_out: false,
            pending_renders: false,
            last_scroll_offset: None,
            started: std::time::Instant::now(),
        };
        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
        let saved = image::open(&output_path)?;
        assert_eq!(saved.width(), 10);
        assert_eq!(saved.height(), 10);
        Ok(())
    }

    #[test]
    fn test_save_screenshot_image_content_only_without_rect() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let output_path = temp_dir.path().join("shot.png");
        let config = ScreenshotConfig {
            output_path: output_path.clone(),
            viewport_width: 100.0,
            viewport_height: 80.0,
            content_only: true,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let snapshot = ScreenshotSnapshot {
            config,
            content_rect: None,
            pixels_per_point: 1.0,
            stable_frames: 0,
            timed_out: false,
            pending_renders: false,
            last_scroll_offset: None,
            started: std::time::Instant::now(),
        };
        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
        assert!(output_path.exists());
        Ok(())
    }

    #[test]
    fn test_save_screenshot_image_height_zero_skips_crop() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let output_path = temp_dir.path().join("shot.png");
        let config = ScreenshotConfig {
            output_path: output_path.clone(),
            viewport_width: 100.0,
            viewport_height: 80.0,
            content_only: true,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let snapshot = ScreenshotSnapshot {
            config,
            content_rect: Some(egui::Rect::from_min_max(
                egui::pos2(2.0, 2.0),
                egui::pos2(8.0, 2.0),
            )),
            pixels_per_point: 1.0,
            stable_frames: 0,
            timed_out: false,
            pending_renders: false,
            last_scroll_offset: None,
            started: std::time::Instant::now(),
        };
        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
        let saved = image::open(&output_path)?;
        assert_eq!(saved.width(), 10);
        assert_eq!(saved.height(), 10);
        Ok(())
    }

    #[test]
    fn test_save_screenshot_image_empty_output_path_errors() {
        let config = ScreenshotConfig {
            output_path: PathBuf::new(),
            viewport_width: 100.0,
            viewport_height: 80.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let snapshot = ScreenshotSnapshot {
            config,
            content_rect: None,
            pixels_per_point: 1.0,
            stable_frames: 0,
            timed_out: false,
            pending_renders: false,
            last_scroll_offset: None,
            started: std::time::Instant::now(),
        };
        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
        assert!(MarkdownViewerApp::save_screenshot_image(&image, &snapshot).is_err());
    }

    #[test]
    fn test_save_screenshot_image_crop_condition_variants() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));

        let make_config = |name: &str| ScreenshotConfig {
            output_path: temp_dir.path().join(name),
            viewport_width: 100.0,
            viewport_height: 80.0,
            content_only: true,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };

        let snapshot_y = ScreenshotSnapshot {
            config: make_config("shot_y.png"),
            content_rect: Some(egui::Rect::from_min_max(
                egui::pos2(0.0, 2.0),
                egui::pos2(10.0, 9.0),
            )),
            pixels_per_point: 1.0,
            stable_frames: 0,
            timed_out: false,
            pending_renders: false,
            last_scroll_offset: None,
            started: std::time::Instant::now(),
        };
        MarkdownViewerApp::save_screenshot_image(&image, &snapshot_y)?;

        let snapshot_w = ScreenshotSnapshot {
            config: make_config("shot_w.png"),
            content_rect: Some(egui::Rect::from_min_max(
                egui::pos2(0.0, 0.0),
                egui::pos2(6.0, 10.0),
            )),
            pixels_per_point: 1.0,
            stable_frames: 0,
            timed_out: false,
            pending_renders: false,
            last_scroll_offset: None,
            started: std::time::Instant::now(),
        };
        MarkdownViewerApp::save_screenshot_image(&image, &snapshot_w)?;

        let snapshot_h = ScreenshotSnapshot {
            config: make_config("shot_h.png"),
            content_rect: Some(egui::Rect::from_min_max(
                egui::pos2(0.0, 0.0),
                egui::pos2(10.0, 6.0),
            )),
            pixels_per_point: 1.0,
            stable_frames: 0,
            timed_out: false,
            pending_renders: false,
            last_scroll_offset: None,
            started: std::time::Instant::now(),
        };
        MarkdownViewerApp::save_screenshot_image(&image, &snapshot_h)?;

        assert!(temp_dir.path().join("shot_y.png").exists());
        assert!(temp_dir.path().join("shot_w.png").exists());
        assert!(temp_dir.path().join("shot_h.png").exists());
        Ok(())
    }

    #[test]
    fn test_handle_screenshot_event_saves_file() -> Result<()> {
        let temp_dir = tempfile::TempDir::new()?;
        let output_path = temp_dir.path().join("shot.png");
        let config = ScreenshotConfig {
            output_path: output_path.clone(),
            viewport_width: 40.0,
            viewport_height: 30.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };

        let mut app = MarkdownViewerApp::new();
        app.set_screenshot_mode(config);

        let mut input = default_input();
        let image = egui::ColorImage::new([40, 30], Color32::WHITE);
        input.events.push(egui::Event::Screenshot {
            viewport_id: egui::ViewportId::ROOT,
            image: Arc::new(image),
        });

        let ctx = egui::Context::default();
        run_app_frame(&mut app, &ctx, input);

        assert!(output_path.exists());
        assert!(output_path.with_extension("json").exists());
        assert!(app.screenshot.as_ref().is_some_and(|state| state.done));
        Ok(())
    }

    #[test]
    fn test_handle_shortcuts_sets_flags() {
        let mut app = MarkdownViewerApp::new();
        app.load_content("Alpha\n\nBeta\n\nGamma", Some("Search".to_string()));
        app.search_query = "beta".to_string();
        app.current_file = Some(PathBuf::from("dummy.md"));

        let mut input = default_input();
        input.events.extend([
            egui::Event::Key {
                key: egui::Key::F,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::CTRL,
            },
            egui::Event::Key {
                key: egui::Key::R,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::CTRL,
            },
            egui::Event::Key {
                key: egui::Key::E,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::CTRL,
            },
            egui::Event::Key {
                key: egui::Key::Plus,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::CTRL,
            },
            egui::Event::Key {
                key: egui::Key::Minus,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::CTRL,
            },
            egui::Event::Key {
                key: egui::Key::Num0,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::CTRL,
            },
            egui::Event::Key {
                key: egui::Key::ArrowLeft,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::ALT,
            },
            egui::Event::Key {
                key: egui::Key::ArrowRight,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::ALT,
            },
            egui::Event::Key {
                key: egui::Key::F3,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::NONE,
            },
            egui::Event::Key {
                key: egui::Key::F3,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::SHIFT,
            },
            egui::Event::Key {
                key: egui::Key::F11,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::NONE,
            },
            egui::Event::Key {
                key: egui::Key::F5,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::NONE,
            },
        ]);

        let ctx = egui::Context::default();
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });

        assert!(app.show_search);
        assert!(app.search_focus_requested);
        assert!(app.view_toggle_requested);
        assert!(app.write_toggle_requested);
        assert!(app.toggle_fullscreen);
        assert!(app.reload_requested);
        assert!(app.last_match_index.is_some());
    }

    #[test]
    fn test_handle_shortcuts_navigation_keys() {
        let mut app = MarkdownViewerApp::new();
        let ctx = egui::Context::default();

        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::PageUp,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::NONE,
        });
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });
        assert!(matches!(app.nav_request, Some(NavigationRequest::PageUp)));

        app.nav_request = None;
        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::PageDown,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::NONE,
        });
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });
        assert!(matches!(app.nav_request, Some(NavigationRequest::PageDown)));

        app.nav_request = None;
        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::Home,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::NONE,
        });
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });
        assert!(matches!(app.nav_request, Some(NavigationRequest::Top)));

        app.nav_request = None;
        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::End,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::NONE,
        });
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });
        assert!(matches!(app.nav_request, Some(NavigationRequest::Bottom)));

        app.nav_request = None;
        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::ArrowUp,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::NONE,
        });
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });
        assert!(matches!(app.nav_request, Some(NavigationRequest::ScrollUp)));

        app.nav_request = None;
        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::ArrowDown,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::NONE,
        });
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });
        assert!(matches!(
            app.nav_request,
            Some(NavigationRequest::ScrollDown)
        ));
    }

    #[test]
    fn test_handle_shortcuts_escape_clears_search() {
        let mut app = MarkdownViewerApp::new();
        app.show_search = true;
        app.search_query = "alpha".to_string();
        app.last_query = "alpha".to_string();
        app.last_match_index = Some(0);
        app.pending_scroll_to_element = Some(1);

        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::Escape,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::NONE,
        });

        let ctx = egui::Context::default();
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });

        assert!(!app.show_search);
        assert!(app.search_query.is_empty());
        assert!(app.last_query.is_empty());
        assert!(app.last_match_index.is_none());
        assert!(app.pending_scroll_to_element.is_none());
    }

    #[test]
    fn test_update_search_results_updates_matches() {
        let mut app = MarkdownViewerApp::new();
        app.load_content("Alpha\n\nBeta\n\nGamma", Some("Search".to_string()));

        app.search_query = "beta".to_string();
        app.update_search_results("");
        assert_eq!(app.last_query, "beta");
        assert_eq!(app.last_match_index, Some(1));
        assert_eq!(app.pending_scroll_to_element, Some(1));

        app.search_query.clear();
        app.update_search_results("beta");
        assert!(app.last_query.is_empty());
    }

    #[test]
    fn test_update_search_results_no_match_leaves_index_clear() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
            "Alpha".to_string(),
        )])];
        app.search_query = "Beta".to_string();
        app.pending_scroll_to_element = None;

        app.update_search_results("");

        assert!(app.last_match_index.is_none());
        assert!(app.pending_scroll_to_element.is_none());
    }

    #[test]
    fn test_handle_shortcuts_ctrl_mouse_wheel_zoom() {
        let mut app = MarkdownViewerApp::new();
        let ctx = egui::Context::default();
        for delta in [20.0, -20.0] {
            let mut input = default_input();
            input.modifiers = egui::Modifiers::CTRL;
            input.events.push(egui::Event::MouseWheel {
                unit: egui::MouseWheelUnit::Point,
                delta: egui::vec2(0.0, delta),
                modifiers: egui::Modifiers::CTRL,
            });
            let _ = ctx.run(input, |ctx| {
                app.handle_shortcuts(ctx);
            });
        }
    }

    #[test]
    fn test_handle_shortcuts_ctrl_mouse_wheel_no_wheel_events() {
        let mut app = MarkdownViewerApp::new();
        let mut input = default_input();
        input.modifiers = egui::Modifiers::CTRL;
        input.events.push(egui::Event::Key {
            key: egui::Key::A,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::CTRL,
        });

        let ctx = egui::Context::default();
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });
    }

    #[test]
    fn test_handle_shortcuts_raw_page_moves() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;

        let mut input = default_input();
        input.events.extend([
            egui::Event::Key {
                key: egui::Key::PageUp,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::NONE,
            },
            egui::Event::Key {
                key: egui::Key::PageDown,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::NONE,
            },
        ]);

        let ctx = egui::Context::default();
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });

        assert!(app.pending_raw_cursor_line_move.is_some());
        assert!(app.raw_focus_requested);
    }

    #[test]
    fn test_render_helpers_cover_ui_paths() {
        let mut app = MarkdownViewerApp::new();
        app.current_content = "Hello".to_string();
        app.pending_files.push_back(PathBuf::from("queued.md"));
        app.drag_hover = true;
        app.show_search = true;
        app.search_query = "welcome".to_string();

        let ctx = egui::Context::default();
        let _ = ctx.run(default_input(), |ctx| {
            CentralPanel::default().show(ctx, |ui| {
                app.render_file_menu_contents(ui, false, Color32::WHITE);
                app.render_view_menu_contents(ui, ctx, false, Color32::WHITE);
                app.render_help_menu_contents(ui, false, Color32::WHITE);
            });
            app.render_status_bar(ctx);
            app.render_search_dialog(ctx);
            app.render_drag_overlay(ctx);
        });

        assert!(app.show_search);
    }

    #[test]
    fn test_screenshot_config_helpers() {
        let temp_dir = tempfile::TempDir::new().expect("temp dir");
        let output_path = temp_dir.path().join("shot.png");
        let config = ScreenshotConfig {
            output_path: output_path.clone(),
            viewport_width: 100.0,
            viewport_height: 80.0,
            content_only: true,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };

        assert_eq!(config.metadata_path(), output_path.with_extension("json"));
        assert_eq!(config.theme.as_str(), "light");
        assert_eq!(ScreenshotTheme::Dark.as_str(), "dark");
    }

    #[test]
    fn test_open_file_dialog_forced_path() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;
        let file_path = temp_dir.path().join("open.md");
        std::fs::write(&file_path, "# Open")?;
        let _forced = ForcedDialogPaths::new(Some(file_path.clone()), None);

        app.open_file_dialog();

        assert_eq!(app.current_file, Some(file_path));
        assert!(app.error_message.is_none());
        Ok(())
    }

    #[test]
    fn test_save_current_document_existing_path() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;
        let file_path = temp_dir.path().join("save.md");
        app.current_file = Some(file_path.clone());
        app.current_content = "Saved content".to_string();

        app.save_current_document()?;

        let saved = std::fs::read_to_string(&file_path)?;
        assert_eq!(saved, "Saved content");
        Ok(())
    }

    #[test]
    fn test_save_current_document_forced_path() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;
        let file_path = temp_dir.path().join("save_forced.md");
        let _forced = ForcedDialogPaths::new(None, Some(file_path.clone()));
        app.current_content = "Forced save".to_string();

        app.save_current_document()?;

        assert_eq!(app.current_file, Some(file_path.clone()));
        assert!(app.title.contains("save_forced.md"));
        let saved = std::fs::read_to_string(&file_path)?;
        assert_eq!(saved, "Forced save");
        Ok(())
    }

    #[test]
    fn test_save_current_document_forced_path_write_error() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;
        let save_dir = temp_dir.path().join("save_dir");
        std::fs::create_dir_all(&save_dir)?;
        let _forced = ForcedDialogPaths::new(None, Some(save_dir));
        app.current_content = "Data".to_string();

        assert!(app.save_current_document().is_err());
        assert!(app.current_file.is_none());
        Ok(())
    }

    #[test]
    fn test_save_current_document_no_path_no_dialog() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let _forced = ForcedDialogPaths::new(None, None);
        app.current_content = "No save".to_string();

        app.save_current_document()?;

        assert!(app.current_file.is_none());
        Ok(())
    }

    #[test]
    fn test_restore_from_history_sets_state() {
        let mut app = MarkdownViewerApp::new();
        app.current_content = "first".to_string();
        app.current_file = Some(PathBuf::from("first.md"));
        app.title = "mdmdview - first".to_string();
        app.push_history();

        app.current_content = "second".to_string();
        app.current_file = None;
        app.title = "mdmdview - second".to_string();
        app.push_history();

        app.history_index = 0;
        app.restore_from_history();

        assert_eq!(app.current_file, Some(PathBuf::from("first.md")));
        assert_eq!(app.current_content, "first");
        assert_eq!(app.pending_scroll_to_element, Some(0));
    }

    #[test]
    fn test_restore_from_history_out_of_range_no_change() {
        let mut app = MarkdownViewerApp::new();
        app.current_content = "current".to_string();
        app.history_index = 3;

        app.restore_from_history();

        assert_eq!(app.current_content, "current");
        assert!(app.current_file.is_none());
    }

    #[test]
    fn test_handle_file_drop_mixed_files() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;
        let good1 = temp_dir.path().join("good1.md");
        let good2 = temp_dir.path().join("good2.md");
        let bad = temp_dir.path().join("bad.pdf");
        std::fs::write(&good1, "# Good1")?;
        std::fs::write(&good2, "# Good2")?;
        std::fs::write(&bad, "nope")?;

        app.handle_file_drop(vec![bad, good1.clone(), good2.clone()]);

        assert_eq!(app.current_file, Some(good1));
        assert!(app.pending_files.contains(&good2));
        assert!(app.error_message.is_some());
        Ok(())
    }

    #[test]
    fn test_handle_file_drop_directory_no_markdown() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;
        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
        assert!(app.error_message.is_some());
        Ok(())
    }

    #[test]
    fn test_handle_file_drop_too_many_files() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;
        let mut files = Vec::new();
        for idx in 0..51 {
            let path = temp_dir.path().join(format!("file{}.md", idx));
            std::fs::write(&path, "# Test")?;
            files.push(path);
        }

        app.handle_file_drop(files);

        assert!(app.error_message.is_some());
        Ok(())
    }

    #[test]
    fn test_move_raw_cursor_lines_up_and_down() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        app.raw_buffer = "Line 1\nLine 2\nLine 3".to_string();
        app.current_content = app.raw_buffer.clone();

        let ctx = egui::Context::default();
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
        state.cursor.set_char_range(Some(cr));
        state.store(&ctx, editor_id);

        app.move_raw_cursor_lines(&ctx, 1);
        let down_idx = app.raw_cursor.unwrap_or(0);
        assert!(down_idx > 0);

        app.move_raw_cursor_lines(&ctx, -1);
        let up_idx = app.raw_cursor.unwrap_or(0);
        assert!(up_idx <= down_idx);
    }

    #[test]
    fn test_move_raw_cursor_lines_early_return_when_not_raw() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Rendered;
        app.write_enabled = true;
        app.raw_cursor = Some(2);

        let ctx = egui::Context::default();
        app.move_raw_cursor_lines(&ctx, 1);

        assert_eq!(app.raw_cursor, Some(2));
    }

    #[test]
    fn test_move_raw_cursor_lines_write_disabled_returns() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = false;
        app.raw_cursor = Some(1);

        let ctx = egui::Context::default();
        app.move_raw_cursor_lines(&ctx, 1);

        assert_eq!(app.raw_cursor, Some(1));
    }

    #[test]
    fn test_move_raw_cursor_lines_without_text_state() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        app.raw_buffer = "Line".to_string();
        app.current_content = app.raw_buffer.clone();

        let ctx = egui::Context::default();
        app.move_raw_cursor_lines(&ctx, 1);

        assert!(app.raw_cursor.is_none());
    }

    #[test]
    fn test_move_raw_cursor_lines_uses_raw_cursor_when_char_range_missing() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        app.raw_buffer = "Line 1\nLine 2\nLine 3".to_string();
        app.current_content = app.raw_buffer.clone();
        app.raw_cursor = Some(7);

        let ctx = egui::Context::default();
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        state.cursor.set_char_range(None);
        state.store(&ctx, editor_id);

        app.move_raw_cursor_lines(&ctx, 1);

        assert_eq!(app.raw_cursor, Some(14));
    }

    #[test]
    fn test_move_raw_cursor_lines_negative_at_start_no_loop() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        app.raw_buffer = "Line 1\nLine 2".to_string();
        app.current_content = app.raw_buffer.clone();

        let ctx = egui::Context::default();
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
        state.cursor.set_char_range(Some(cr));
        state.store(&ctx, editor_id);

        app.move_raw_cursor_lines(&ctx, -1);
        assert_eq!(app.raw_cursor, Some(0));
    }

    #[test]
    fn test_move_raw_cursor_lines_down_without_newline() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        app.raw_buffer = "Line".to_string();
        app.current_content = app.raw_buffer.clone();

        let ctx = egui::Context::default();
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
        state.cursor.set_char_range(Some(cr));
        state.store(&ctx, editor_id);

        app.move_raw_cursor_lines(&ctx, 1);
        assert_eq!(app.raw_cursor, Some(app.raw_buffer.len()));
    }

    #[test]
    fn test_move_raw_cursor_lines_down_at_end_no_loop() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        app.raw_buffer = "Line 1\nLine 2".to_string();
        app.current_content = app.raw_buffer.clone();

        let ctx = egui::Context::default();
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(app.raw_buffer.len()));
        state.cursor.set_char_range(Some(cr));
        state.store(&ctx, editor_id);

        app.move_raw_cursor_lines(&ctx, 1);
        assert_eq!(app.raw_cursor, Some(app.raw_buffer.len()));
    }

    #[test]
    fn test_handle_shortcuts_open_accelerators() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;
        let open_path = temp_dir.path().join("open.md");
        std::fs::write(&open_path, "# Open")?;
        let _forced = ForcedDialogPaths::new(Some(open_path.clone()), None);

        let mut input = default_input();
        input.events.extend([
            egui::Event::Key {
                key: egui::Key::O,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::CTRL,
            },
            egui::Event::Key {
                key: egui::Key::O,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::ALT,
            },
        ]);

        let ctx = egui::Context::default();
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });

        assert_eq!(app.current_file, Some(open_path));
        Ok(())
    }

    #[test]
    fn test_handle_shortcuts_close_accelerators() {
        let mut app = MarkdownViewerApp::new();
        app.current_file = Some(PathBuf::from("dummy.md"));
        app.current_content = "# Dummy".to_string();

        let mut input = default_input();
        input.events.extend([
            egui::Event::Key {
                key: egui::Key::W,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::ALT,
            },
            egui::Event::Key {
                key: egui::Key::W,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::CTRL,
            },
            egui::Event::Key {
                key: egui::Key::Q,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::ALT,
            },
            egui::Event::Key {
                key: egui::Key::Q,
                physical_key: None,
                pressed: true,
                repeat: false,
                modifiers: egui::Modifiers::CTRL,
            },
        ]);

        let ctx = egui::Context::default();
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });

        assert!(app.current_file.is_none());
    }

    #[test]
    fn test_handle_shortcuts_ctrl_save() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;
        let file_path = temp_dir.path().join("save.md");
        app.current_file = Some(file_path.clone());
        app.current_content = "Saved".to_string();

        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::S,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::CTRL,
        });

        let ctx = egui::Context::default();
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });

        let saved = std::fs::read_to_string(&file_path)?;
        assert_eq!(saved, "Saved");
        Ok(())
    }

    #[test]
    fn test_compute_window_adjustment_clamps() {
        let outer = egui::Rect::from_min_size(egui::pos2(-100.0, -100.0), egui::vec2(200.0, 100.0));
        let monitor = egui::vec2(800.0, 600.0);
        let adjusted =
            MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), Some(monitor));
        assert!(adjusted.is_some());

        let outer_ok = egui::Rect::from_min_size(egui::pos2(10.0, 10.0), egui::vec2(800.0, 600.0));
        let unchanged = MarkdownViewerApp::compute_window_adjustment(
            Some(outer_ok),
            Some(outer_ok),
            Some(monitor),
        );
        assert!(unchanged.is_none());
    }

    #[test]
    fn test_persist_window_state_updates_cache() {
        let _lock = env_lock();
        let temp_dir = tempfile::TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());
        let mut app = MarkdownViewerApp::new();
        app.last_window_pos = Some([10.0, 20.0]);
        app.last_window_size = Some([800.0, 600.0]);
        app.last_window_maximized = true;

        app.persist_window_state();

        assert!(app.last_persisted_state.is_some());
    }

    #[test]
    fn test_render_actions_trigger_menu_and_context() {
        let mut app = MarkdownViewerApp::new();
        app.current_content = "Hello".to_string();
        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
            "Hello".to_string(),
        )])];
        let temp_dir = tempfile::TempDir::new().expect("temp dir");
        let open_path = temp_dir.path().join("open.md");
        std::fs::write(&open_path, "# Open").expect("write");
        let save_path = temp_dir.path().join("save.md");
        let _forced = ForcedDialogPaths::new(Some(open_path), Some(save_path));
        let _actions = ForcedAppActions::new(&[
            "menu_open",
            "menu_save",
            "menu_close",
            "menu_reload",
            "menu_find",
            "menu_samples",
            "menu_bar_file",
            "menu_bar_view",
            "menu_bar_help",
            "menu_help_usage",
            "menu_help_about",
            "menu_back",
            "menu_forward",
            "menu_raw",
            "menu_write",
            "menu_wrap_raw",
            "menu_zoom_in",
            "menu_zoom_out",
            "menu_zoom_reset",
            "menu_fullscreen",
            "ctx_copy_all",
            "ctx_copy_markdown",
            "ctx_nav_top",
            "ctx_nav_bottom",
            "search_next",
            "search_prev",
            "search_close",
            "status_hover",
            "welcome_open",
            "welcome.md",
            "usage.md",
        ]);

        let ctx = egui::Context::default();
        let _ = ctx.run(default_input(), |ctx| {
            CentralPanel::default().show(ctx, |ui| {
                app.render_file_menu_contents(ui, false, Color32::WHITE);
                app.render_view_menu_contents(ui, ctx, false, Color32::WHITE);
                app.render_help_menu_contents(ui, false, Color32::WHITE);
                app.render_main_context_menu(ui);
            });
            app.show_search = true;
            app.render_search_dialog(ctx);
            app.render_menu_bar(ctx);
            app.render_status_bar(ctx);
        });
    }

    #[test]
    fn test_render_search_dialog_stays_open() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
            "Alpha".to_string(),
        )])];
        app.show_search = true;
        app.search_query = "Alpha".to_string();

        let ctx = egui::Context::default();
        let _ = ctx.run(default_input(), |ctx| {
            app.render_search_dialog(ctx);
        });

        assert!(app.show_search);
        assert_eq!(app.search_query, "Alpha");
    }

    #[test]
    fn test_render_search_dialog_close_clears_state() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
            "Alpha".to_string(),
        )])];
        app.show_search = true;
        app.search_query = "Alpha".to_string();
        app.last_query = "Alpha".to_string();
        app.last_match_index = Some(0);
        app.pending_scroll_to_element = Some(1);
        let _actions = ForcedAppActions::new(&["search_close"]);

        let ctx = egui::Context::default();
        let _ = ctx.run(default_input(), |ctx| {
            app.render_search_dialog(ctx);
        });

        assert!(!app.show_search);
        assert!(app.search_query.is_empty());
        assert!(app.last_query.is_empty());
        assert!(app.last_match_index.is_none());
        assert!(app.pending_scroll_to_element.is_none());
    }

    #[test]
    fn test_render_search_dialog_submitted_next_on_enter() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
            "Alpha".to_string(),
        )])];
        app.show_search = true;
        app.search_query = "Alpha".to_string();
        app.search_focus_requested = true;

        let ctx = egui::Context::default();
        let _ = ctx.run(default_input(), |ctx| {
            app.render_search_dialog(ctx);
        });

        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::Enter,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::NONE,
        });
        let _ = ctx.run(input, |ctx| {
            app.render_search_dialog(ctx);
        });

        assert!(app.last_match_index.is_some());
    }

    #[test]
    fn test_should_submit_search_requires_focus_and_enter() {
        assert!(MarkdownViewerApp::should_submit_search(true, true));
        assert!(!MarkdownViewerApp::should_submit_search(false, true));
        assert!(!MarkdownViewerApp::should_submit_search(true, false));
    }

    #[test]
    fn test_render_main_context_menu_no_actions() {
        let mut app = MarkdownViewerApp::new();
        app.current_content = "Hello".to_string();
        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
            "Hello".to_string(),
        )])];

        let ctx = egui::Context::default();
        let _ = ctx.run(default_input(), |ctx| {
            CentralPanel::default().show(ctx, |ui| {
                app.render_main_context_menu(ui);
            });
        });

        assert!(app.nav_request.is_none());
    }

    #[test]
    fn test_render_menu_bar_light_mode() {
        let mut app = MarkdownViewerApp::new();
        let ctx = egui::Context::default();
        ctx.set_visuals(egui::Visuals::light());

        let _ = ctx.run(default_input(), |ctx| {
            app.render_menu_bar(ctx);
        });
    }

    #[test]
    fn test_handle_file_drop_empty_and_missing() {
        let mut app = MarkdownViewerApp::new();
        app.handle_file_drop(Vec::new());

        app.handle_file_drop(vec![PathBuf::from("missing.md")]);
        assert!(app
            .error_message
            .as_ref()
            .is_some_and(|msg| msg.contains("File not found")));
    }

    #[test]
    fn test_handle_file_drop_scan_error() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;
        let _forced = ForcedScanError::new();

        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);

        assert!(app.error_message.is_some());
        Ok(())
    }

    #[test]
    fn test_handle_file_drop_load_failure() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;
        let file_path = temp_dir.path().join("fail.md");
        std::fs::write(&file_path, "# Fail")?;
        let _forced = ForcedLoadError::new();

        app.handle_file_drop(vec![file_path]);

        assert!(app
            .error_message
            .as_ref()
            .is_some_and(|msg| msg.contains("Failed to load file")));
        Ok(())
    }

    #[test]
    fn test_handle_shortcuts_ctrl_f_sets_match_index() {
        let mut app = MarkdownViewerApp::new();
        app.last_match_index = None;

        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::F,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::CTRL,
        });

        let ctx = egui::Context::default();
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });

        assert_eq!(app.last_match_index, Some(0));
    }

    #[test]
    fn test_handle_shortcuts_ctrl_f_preserves_match_index() {
        let mut app = MarkdownViewerApp::new();
        app.last_match_index = Some(2);

        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::F,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::CTRL,
        });

        let ctx = egui::Context::default();
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });

        assert_eq!(app.last_match_index, Some(2));
    }

    #[test]
    fn test_handle_shortcuts_ctrl_mouse_wheel_zoom_directions() {
        let mut app = MarkdownViewerApp::new();
        let ctx = egui::Context::default();

        let mut input = default_input();
        input.modifiers = egui::Modifiers::CTRL;
        input.events.push(egui::Event::MouseWheel {
            unit: egui::MouseWheelUnit::Point,
            delta: egui::vec2(0.0, 20.0),
            modifiers: egui::Modifiers::CTRL,
        });
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });

        let mut input = default_input();
        input.modifiers = egui::Modifiers::CTRL;
        input.events.push(egui::Event::MouseWheel {
            unit: egui::MouseWheelUnit::Point,
            delta: egui::vec2(0.0, -20.0),
            modifiers: egui::Modifiers::CTRL,
        });
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });
    }

    #[test]
    fn test_handle_shortcuts_ctrl_mouse_wheel_without_events() {
        let mut app = MarkdownViewerApp::new();
        let ctx = egui::Context::default();
        let mut input = default_input();
        input.modifiers = egui::Modifiers::CTRL;
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });
    }

    #[test]
    fn test_handle_shortcuts_ctrl_save_error() {
        let mut app = MarkdownViewerApp::new();
        app.current_file = Some(PathBuf::from("missing_dir\\save.md"));
        app.current_content = "Data".to_string();

        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::S,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::CTRL,
        });

        let ctx = egui::Context::default();
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });

        assert!(app.error_message.is_some());
    }

    #[test]
    fn test_move_raw_cursor_lines_edge_cases() {
        let mut app = MarkdownViewerApp::new();
        app.raw_buffer = "Line 1\nLine 2\nLine 3\nLine 4".to_string();
        app.current_content = app.raw_buffer.clone();

        let ctx = egui::Context::default();
        app.move_raw_cursor_lines(&ctx, 1);

        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(3));
        state.cursor.set_char_range(Some(cr));
        state.store(&ctx, editor_id);

        app.move_raw_cursor_lines(&ctx, 0);
        app.move_raw_cursor_lines(&ctx, 2);
        app.move_raw_cursor_lines(&ctx, -2);
    }

    #[test]
    fn test_render_status_bar_no_file_and_tooltip() {
        let mut app = MarkdownViewerApp::new();
        app.current_file = None;
        app.parsed_elements.clear();

        let _actions = ForcedAppActions::new(&["status_hover"]);
        let ctx = egui::Context::default();
        let _ = ctx.run(default_input(), |ctx| {
            app.render_status_bar(ctx);
        });
    }

    #[test]
    fn test_render_status_bar_table_stats() {
        let mut app = MarkdownViewerApp::new();
        app.current_file = None;
        app.parsed_elements = vec![MarkdownElement::Table {
            headers: vec![vec![InlineSpan::Text("H".to_string())]],
            rows: vec![vec![vec![InlineSpan::Text("C".to_string())]]],
            alignments: vec![pulldown_cmark::Alignment::Left],
        }];

        let ctx = egui::Context::default();
        let _ = ctx.run(default_input(), |ctx| {
            CentralPanel::default().show(ctx, |ui| {
                app.renderer.render_to_ui(ui, &app.parsed_elements);
            });
            app.render_status_bar(ctx);
        });
    }

    #[test]
    fn test_render_status_bar_pending_load_and_queue() {
        let mut app = MarkdownViewerApp::new();
        app.pending_file_load = Some(PendingFileLoad {
            id: 1,
            path: PathBuf::from("pending.md"),
        });
        app.pending_files.push_back(PathBuf::from("queued.md"));

        let ctx = egui::Context::default();
        let _ = ctx.run(default_input(), |ctx| {
            app.render_status_bar(ctx);
        });
    }

    #[test]
    fn test_update_impl_welcome_open_button() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements.clear();
        app.current_content.clear();
        app.error_message = None;

        let temp_dir = tempfile::TempDir::new()?;
        let file_path = temp_dir.path().join("welcome.md");
        std::fs::write(&file_path, "# Welcome")?;
        let _forced = ForcedDialogPaths::new(Some(file_path.clone()), None);
        let _actions = ForcedAppActions::new(&["welcome_open"]);

        let ctx = egui::Context::default();
        run_app_frame(&mut app, &ctx, default_input());

        assert_eq!(app.current_file, Some(file_path));
        Ok(())
    }

    #[test]
    fn test_update_impl_welcome_screen_no_open() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements.clear();
        app.current_content.clear();
        app.error_message = None;

        let ctx = egui::Context::default();
        run_app_frame(&mut app, &ctx, default_input());

        assert!(app.current_file.is_none());
    }

    #[test]
    fn test_update_impl_welcome_screen_with_error_message() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements.clear();
        app.current_content.clear();
        app.error_message = Some("Load failed".to_string());

        let ctx = egui::Context::default();
        run_app_frame(&mut app, &ctx, default_input());

        assert!(app.error_message.is_some());
    }

    #[test]
    fn test_update_impl_navigation_requests() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
            "Nav".to_string(),
        )])];
        let ctx = egui::Context::default();
        let input = default_input();
        let navs = [
            NavigationRequest::Top,
            NavigationRequest::Bottom,
            NavigationRequest::PageUp,
            NavigationRequest::PageDown,
            NavigationRequest::ScrollUp,
            NavigationRequest::ScrollDown,
        ];
        for nav in navs {
            app.nav_request = Some(nav);
            run_app_frame(&mut app, &ctx, input.clone());
        }
    }

    #[test]
    fn test_update_impl_anchor_and_search_highlight() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![MarkdownElement::Header {
            level: 1,
            spans: vec![InlineSpan::Text("Section".to_string())],
            id: "section".to_string(),
        }];
        app.current_content = "# Section".to_string();
        app.show_search = true;
        app.search_query = "Section".to_string();
        app.pending_scroll_to_element = Some(0);
        app.renderer.trigger_link("#section");

        let ctx = egui::Context::default();
        run_app_frame(&mut app, &ctx, default_input());

        app.show_search = false;
        app.search_query.clear();
        app.last_query = "Section".to_string();
        run_app_frame(&mut app, &ctx, default_input());
    }

    #[test]
    fn test_update_impl_search_highlight_empty_query_prefers_last() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
            "Find me".to_string(),
        )])];
        app.current_content = "Find me".to_string();
        app.show_search = true;
        app.search_query.clear();
        app.last_query = "Find".to_string();

        let ctx = egui::Context::default();
        run_app_frame(&mut app, &ctx, default_input());
    }

    #[test]
    fn test_update_impl_missing_anchor_and_scroll_target() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![MarkdownElement::Header {
            level: 1,
            spans: vec![InlineSpan::Text("Known".to_string())],
            id: "known".to_string(),
        }];
        app.current_content = "# Known".to_string();
        app.renderer.trigger_link("#missing");
        app.pending_scroll_to_element = Some(99);

        let ctx = egui::Context::default();
        run_app_frame(&mut app, &ctx, default_input());

        assert!(app.pending_scroll_to_element.is_none());
    }

    #[test]
    fn test_update_impl_raw_cursor_restore_without_state() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        app.raw_buffer = "Line 1\nLine 2".to_string();
        app.current_content = app.raw_buffer.clone();
        app.raw_cursor = Some(3);

        let ctx = egui::Context::default();
        run_app_frame(&mut app, &ctx, default_input());
    }

    #[test]
    fn test_update_impl_raw_cursor_without_char_range() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        app.raw_buffer = "Line".to_string();
        app.current_content = app.raw_buffer.clone();

        let ctx = egui::Context::default();
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        state.cursor.set_char_range(None);
        state.store(&ctx, editor_id);

        run_app_frame(&mut app, &ctx, default_input());

        assert!(app.raw_cursor.is_none());
    }

    #[test]
    fn test_update_impl_raw_edit_updates_content() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        app.raw_focus_requested = true;
        app.raw_buffer = "Line".to_string();
        app.current_content = app.raw_buffer.clone();

        let ctx = egui::Context::default();
        let mut input = default_input();
        input.focused = true;
        run_app_frame(&mut app, &ctx, input);

        let mut input = default_input();
        input.focused = true;
        input.events.push(egui::Event::Text("X".to_string()));
        run_app_frame(&mut app, &ctx, input);

        assert!(app.current_content.contains('X'));
    }

    #[test]
    fn test_update_impl_raw_edit_parse_error_sets_message() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        app.raw_focus_requested = true;
        app.raw_buffer = "Line".to_string();
        app.current_content = app.raw_buffer.clone();
        crate::markdown_renderer::force_parse_error_once();

        let ctx = egui::Context::default();
        let mut input = default_input();
        input.focused = true;
        run_app_frame(&mut app, &ctx, input);

        let mut input = default_input();
        input.focused = true;
        input.events.push(egui::Event::Text("X".to_string()));
        run_app_frame(&mut app, &ctx, input);

        assert!(app.error_message.is_some());
    }

    #[test]
    fn test_update_impl_screenshot_scroll_offset() {
        let temp_dir = tempfile::TempDir::new().expect("temp dir");
        let config = ScreenshotConfig {
            output_path: temp_dir.path().join("shot.png"),
            viewport_width: 80.0,
            viewport_height: 60.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let mut app = MarkdownViewerApp::new();
        app.screenshot = Some(ScreenshotState::new(config));
        let state = app.screenshot.as_mut().expect("screenshot state");
        state.scroll_offset = Some(10.0);

        let ctx = egui::Context::default();
        run_app_frame(&mut app, &ctx, default_input());
    }

    #[test]
    fn test_save_screenshot_image_creates_parent_dir() -> Result<()> {
        let temp_dir = tempfile::TempDir::new()?;
        let nested = temp_dir.path().join("nested").join("shot.png");
        let config = ScreenshotConfig {
            output_path: nested.clone(),
            viewport_width: 40.0,
            viewport_height: 30.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let snapshot = ScreenshotSnapshot {
            config,
            content_rect: None,
            pixels_per_point: 1.0,
            stable_frames: 0,
            timed_out: false,
            pending_renders: false,
            last_scroll_offset: None,
            started: Instant::now(),
        };
        let image = egui::ColorImage::new([40, 30], Color32::WHITE);
        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
        assert!(nested.exists());
        assert!(nested.with_extension("json").exists());
        Ok(())
    }

    #[test]
    fn test_save_screenshot_image_parent_dir_error() -> Result<()> {
        let temp_dir = tempfile::TempDir::new()?;
        let parent_file = temp_dir.path().join("parent_file");
        std::fs::write(&parent_file, "data")?;
        let output_path = parent_file.join("shot.png");
        let config = ScreenshotConfig {
            output_path,
            viewport_width: 40.0,
            viewport_height: 30.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let snapshot = ScreenshotSnapshot {
            config,
            content_rect: None,
            pixels_per_point: 1.0,
            stable_frames: 0,
            timed_out: false,
            pending_renders: false,
            last_scroll_offset: None,
            started: Instant::now(),
        };
        let image = egui::ColorImage::new([40, 30], Color32::WHITE);
        assert!(MarkdownViewerApp::save_screenshot_image(&image, &snapshot).is_err());
        Ok(())
    }

    #[test]
    fn test_save_screenshot_image_metadata_write_error() -> Result<()> {
        let temp_dir = tempfile::TempDir::new()?;
        let output_path = temp_dir.path().join("shot.png");
        std::fs::create_dir(output_path.with_extension("json"))?;
        let config = ScreenshotConfig {
            output_path: output_path.clone(),
            viewport_width: 40.0,
            viewport_height: 30.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let snapshot = ScreenshotSnapshot {
            config,
            content_rect: None,
            pixels_per_point: 1.0,
            stable_frames: 0,
            timed_out: false,
            pending_renders: false,
            last_scroll_offset: None,
            started: Instant::now(),
        };
        let image = egui::ColorImage::new([40, 30], Color32::WHITE);
        assert!(MarkdownViewerApp::save_screenshot_image(&image, &snapshot).is_err());
        assert!(output_path.exists());
        Ok(())
    }

    #[test]
    fn test_handle_screenshot_events_branches() {
        let mut app = MarkdownViewerApp::new();
        let ctx = egui::Context::default();

        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::A,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::NONE,
        });
        let _ = ctx.run(input, |ctx| {
            app.handle_screenshot_events(ctx);
        });

        let image = egui::ColorImage::new([10, 10], Color32::WHITE);
        let mut input = default_input();
        input.events.push(egui::Event::Screenshot {
            viewport_id: egui::ViewportId::ROOT,
            image: std::sync::Arc::new(image),
        });
        let _ = ctx.run(input, |ctx| {
            app.handle_screenshot_events(ctx);
        });

        let temp_dir = tempfile::TempDir::new().expect("temp dir");
        let config = ScreenshotConfig {
            output_path: temp_dir.path().to_path_buf(),
            viewport_width: 40.0,
            viewport_height: 30.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        app.screenshot = Some(ScreenshotState::new(config));
        let state = app.screenshot.as_mut().expect("screenshot state");
        state.done = true;
        let image = egui::ColorImage::new([10, 10], Color32::WHITE);
        let mut input = default_input();
        input.events.push(egui::Event::Screenshot {
            viewport_id: egui::ViewportId::ROOT,
            image: std::sync::Arc::new(image),
        });
        let _ = ctx.run(input, |ctx| {
            app.handle_screenshot_events(ctx);
        });
    }

    #[test]
    fn test_screenshot_state_helpers() {
        let config = ScreenshotConfig {
            output_path: PathBuf::from("dummy.png"),
            viewport_width: 120.0,
            viewport_height: 80.0,
            content_only: false,
            scroll_ratio: Some(0.5),
            wait_ms: 500,
            settle_frames: 2,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let mut state = ScreenshotState::new(config);
        assert!(!state.scroll_ready());

        let snapshot = ScrollSnapshot {
            content_size: egui::vec2(200.0, 400.0),
            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 200.0)),
            offset_y: 0.0,
        };
        assert!(state.record_scroll(snapshot));
        assert!(!state.record_scroll(snapshot));

        state.update_stability(None, None);
        state.last_scroll_offset = Some(0.0);
        state.update_stability(Some(1), Some(10.0));
    }

    #[test]
    fn test_screenshot_is_stable_requires_no_pending() {
        assert!(MarkdownViewerApp::screenshot_is_stable(true, 2, 2, false));
        assert!(!MarkdownViewerApp::screenshot_is_stable(true, 2, 2, true));
        assert!(!MarkdownViewerApp::screenshot_is_stable(false, 2, 2, false));
        assert!(!MarkdownViewerApp::screenshot_is_stable(true, 1, 2, false));
    }

    #[test]
    fn test_record_scroll_without_ratio_returns_false() {
        let config = ScreenshotConfig {
            output_path: PathBuf::from("dummy.png"),
            viewport_width: 120.0,
            viewport_height: 80.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 500,
            settle_frames: 2,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let mut state = ScreenshotState::new(config);
        let snapshot = ScrollSnapshot {
            content_size: egui::vec2(200.0, 400.0),
            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 200.0)),
            offset_y: 0.0,
        };
        assert!(!state.record_scroll(snapshot));
        assert!(state.scroll_offset.is_none());
    }

    #[test]
    fn test_toggle_write_mode_captures_cursor() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;

        let ctx = egui::Context::default();
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(2));
        state.cursor.set_char_range(Some(cr));
        state.store(&ctx, editor_id);

        app.toggle_write_mode(&ctx);
        assert!(!app.write_enabled);
        assert_eq!(app.raw_cursor, Some(2));
    }

    #[test]
    fn test_toggle_write_mode_without_text_state() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;

        let ctx = egui::Context::default();
        app.toggle_write_mode(&ctx);
        assert!(!app.write_enabled);
        assert!(app.raw_cursor.is_none());
    }

    #[test]
    fn test_toggle_write_mode_without_cursor_range() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;

        let ctx = egui::Context::default();
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        state.cursor.set_char_range(None);
        state.store(&ctx, editor_id);

        app.toggle_write_mode(&ctx);
        assert!(!app.write_enabled);
        assert!(app.raw_cursor.is_none());
    }

    #[test]
    fn test_move_raw_cursor_lines_moves_to_end() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;
        app.raw_buffer = "Line 1\nLine 2".to_string();
        app.current_content = app.raw_buffer.clone();

        let ctx = egui::Context::default();
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
        state.cursor.set_char_range(Some(cr));
        state.store(&ctx, editor_id);

        app.move_raw_cursor_lines(&ctx, 2);
        assert_eq!(app.raw_cursor, Some(app.raw_buffer.len()));
    }

    #[test]
    fn test_find_next_uses_last_query() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
            "Hello".to_string(),
        )])];
        app.search_query.clear();
        app.last_query = "Hello".to_string();

        app.find_next();
        assert_eq!(app.last_match_index, Some(0));
    }

    #[test]
    fn test_find_previous_wraps_from_start() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![
            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
            MarkdownElement::Paragraph(vec![InlineSpan::Text("Other".to_string())]),
        ];
        app.search_query.clear();
        app.last_query = "Match".to_string();
        app.last_match_index = Some(0);

        app.find_previous();
        assert_eq!(app.last_match_index, Some(0));
    }

    #[test]
    fn test_set_zoom_scale_on_app() {
        let mut app = MarkdownViewerApp::new();
        let before = app.renderer.font_sizes().body;
        app.set_zoom_scale(1.5);
        assert_ne!(app.renderer.font_sizes().body, before);
    }

    #[test]
    fn test_handle_file_drop_no_valid_files() {
        let mut app = MarkdownViewerApp::new();
        app.handle_file_drop(vec![
            PathBuf::from("missing1.md"),
            PathBuf::from("missing2.md"),
        ]);
        assert!(app
            .error_message
            .as_ref()
            .is_some_and(|msg| msg.contains("No valid files")));
    }

    #[test]
    fn test_compute_window_adjustment_missing_monitor_returns_none() {
        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 100.0));
        let adjusted = MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), None);
        assert!(adjusted.is_none());
    }

    #[test]
    fn test_compute_window_adjustment_invalid_monitor_returns_none() {
        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 100.0));
        let adjusted = MarkdownViewerApp::compute_window_adjustment(
            Some(outer),
            Some(outer),
            Some(egui::vec2(0.0, 0.0)),
        );
        assert!(adjusted.is_none());
    }

    #[test]
    fn test_compute_window_adjustment_invalid_monitor_height_returns_none() {
        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 100.0));
        let adjusted = MarkdownViewerApp::compute_window_adjustment(
            Some(outer),
            Some(outer),
            Some(egui::vec2(800.0, 0.0)),
        );
        assert!(adjusted.is_none());
    }

    #[test]
    fn test_compute_window_adjustment_handles_nan_and_clamps() {
        let outer = egui::Rect::from_min_size(
            egui::pos2(f32::NAN, f32::NAN),
            egui::vec2(f32::NAN, f32::NAN),
        );
        let adjusted = MarkdownViewerApp::compute_window_adjustment(
            Some(outer),
            Some(outer),
            Some(egui::vec2(800.0, 600.0)),
        );
        assert!(adjusted.is_some());

        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(5000.0, 4000.0));
        let adjusted = MarkdownViewerApp::compute_window_adjustment(
            Some(outer),
            Some(outer),
            Some(egui::vec2(800.0, 600.0)),
        );
        assert!(adjusted.is_some());
    }

    #[test]
    fn test_compute_window_adjustment_invalid_pos_only() {
        let outer = egui::Rect::from_min_size(egui::pos2(f32::NAN, 0.0), egui::vec2(800.0, 600.0));
        let inner = egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(800.0, 600.0));
        let adjusted = MarkdownViewerApp::compute_window_adjustment(
            Some(outer),
            Some(inner),
            Some(egui::vec2(1200.0, 900.0)),
        )
        .expect("adjustment");
        assert!(adjusted.pos.is_some());
        assert!(adjusted.size.is_none());
    }

    #[test]
    fn test_compute_window_adjustment_invalid_pos_y_only() {
        let outer = egui::Rect::from_min_size(egui::pos2(0.0, f32::NAN), egui::vec2(800.0, 600.0));
        let inner = egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(800.0, 600.0));
        let adjusted = MarkdownViewerApp::compute_window_adjustment(
            Some(outer),
            Some(inner),
            Some(egui::vec2(1200.0, 900.0)),
        )
        .expect("adjustment");
        assert!(adjusted.pos.is_some());
        assert!(adjusted.size.is_none());
    }

    #[test]
    fn test_compute_window_adjustment_invalid_size_only() {
        let outer = egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(800.0, f32::NAN));
        let adjusted = MarkdownViewerApp::compute_window_adjustment(
            Some(outer),
            Some(outer),
            Some(egui::vec2(1200.0, 900.0)),
        )
        .expect("adjustment");
        assert!(adjusted.pos.is_none());
        assert!(adjusted.size.is_some());
    }

    #[test]
    fn test_push_history_caps_max() {
        let mut app = MarkdownViewerApp::new();
        app.max_history = 1;
        app.current_content = "First".to_string();
        app.title = "First".to_string();
        app.push_history();

        app.current_content = "Second".to_string();
        app.title = "Second".to_string();
        app.push_history();

        assert_eq!(app.history.len(), 1);
        assert_eq!(app.history[0].content, "Second");
    }

    #[test]
    fn test_navigate_forward_pending_error() {
        let mut app = MarkdownViewerApp::new();
        let _forced = ForcedLoadError::new();
        app.pending_files.push_back(PathBuf::from("missing.md"));

        assert!(app.navigate_forward());
        assert!(app.error_message.is_some());
    }

    #[test]
    fn test_navigate_forward_history() {
        let mut app = MarkdownViewerApp::new();
        app.history = vec![
            HistoryEntry {
                file_path: None,
                title: "One".to_string(),
                content: "One".to_string(),
            },
            HistoryEntry {
                file_path: None,
                title: "Two".to_string(),
                content: "Two".to_string(),
            },
        ];
        app.history_index = 0;

        assert!(app.navigate_forward());
        assert_eq!(app.history_index, 1);
        assert_eq!(app.current_content, "Two");
    }

    #[test]
    fn test_restore_from_history_parse_error() {
        let mut app = MarkdownViewerApp::new();
        app.history = vec![HistoryEntry {
            file_path: None,
            title: "Bad".to_string(),
            content: "Bad".to_string(),
        }];
        app.history_index = 0;
        crate::markdown_renderer::force_parse_error_once();

        app.restore_from_history();
        assert!(app.error_message.is_some());
    }

    #[test]
    fn test_open_file_dialog_load_error() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = tempfile::TempDir::new()?;
        let open_path = temp_dir.path().join("open.md");
        std::fs::write(&open_path, "# Open")?;
        let _forced_path = ForcedDialogPaths::new(Some(open_path), None);
        let _forced_load = ForcedLoadError::new();

        app.open_file_dialog();
        assert!(app
            .error_message
            .as_ref()
            .is_some_and(|msg| msg.contains("Failed to open file")));
        Ok(())
    }

    #[test]
    fn test_toggle_view_mode_captures_cursor() {
        let mut app = MarkdownViewerApp::new();
        app.view_mode = ViewMode::Raw;
        app.write_enabled = true;

        let ctx = egui::Context::default();
        let editor_id = egui::Id::new("raw_editor");
        let mut state = egui::text_edit::TextEditState::default();
        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(4));
        state.cursor.set_char_range(Some(cr));
        state.store(&ctx, editor_id);

        app.toggle_view_mode(&ctx);
        assert_eq!(app.raw_cursor, Some(4));
        assert_eq!(app.view_mode, ViewMode::Rendered);
    }

    #[test]
    fn test_handle_shortcuts_shift_f3_triggers_previous() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
            "Nav".to_string(),
        )])];
        app.search_query = "Nav".to_string();

        let mut input = default_input();
        input.modifiers = egui::Modifiers::SHIFT;
        input.events.push(egui::Event::Key {
            key: egui::Key::F3,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::SHIFT,
        });

        let ctx = egui::Context::default();
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });

        assert_eq!(app.last_match_index, Some(0));
    }

    #[test]
    fn test_handle_shortcuts_f3_triggers_next() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
            "Nav".to_string(),
        )])];
        app.search_query = "Nav".to_string();

        let mut input = default_input();
        input.events.push(egui::Event::Key {
            key: egui::Key::F3,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::NONE,
        });

        let ctx = egui::Context::default();
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });

        assert_eq!(app.last_match_index, Some(0));
    }

    #[test]
    fn test_handle_shortcuts_alt_f3_triggers_previous() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![
            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
        ];
        app.search_query = "Match".to_string();
        app.last_match_index = Some(1);
        app.pending_scroll_to_element = None;

        let mut input = default_input();
        input.modifiers = egui::Modifiers::ALT;
        input.events.push(egui::Event::Key {
            key: egui::Key::F3,
            physical_key: None,
            pressed: true,
            repeat: false,
            modifiers: egui::Modifiers::ALT,
        });

        let ctx = egui::Context::default();
        let _ = ctx.run(input, |ctx| {
            app.handle_shortcuts(ctx);
        });

        assert_eq!(app.last_match_index, Some(0));
        assert_eq!(app.pending_scroll_to_element, Some(0));
    }

    #[test]
    fn test_render_file_menu_save_error_sets_message() {
        let mut app = MarkdownViewerApp::new();
        app.current_file = Some(PathBuf::from("missing_dir\\save.md"));
        app.current_content = "Data".to_string();
        let _actions = ForcedAppActions::new(&["menu_save"]);

        let ctx = egui::Context::default();
        let _ = ctx.run(default_input(), |ctx| {
            egui::CentralPanel::default().show(ctx, |ui| {
                app.render_file_menu_contents(ui, false, Color32::WHITE);
            });
        });

        assert!(app.error_message.is_some());
    }

    #[test]
    fn test_menu_text_with_mnemonic_prefix_and_underline() {
        let job = MarkdownViewerApp::menu_text_with_mnemonic(
            Some("Alt+"),
            "Open",
            'O',
            true,
            Color32::WHITE,
        );
        assert!(!job.sections.is_empty());
    }

    #[test]
    fn test_menu_text_with_mnemonic_no_underline() {
        let job =
            MarkdownViewerApp::menu_text_with_mnemonic(None, "Save", 'S', false, Color32::WHITE);
        assert!(!job.sections.is_empty());
    }

    #[test]
    fn test_menu_text_with_mnemonic_missing_character() {
        let job =
            MarkdownViewerApp::menu_text_with_mnemonic(None, "Save", 'Z', true, Color32::WHITE);
        assert!(!job.sections.is_empty());
    }

    #[test]
    fn test_persist_window_state_no_change_returns_early() {
        let mut app = MarkdownViewerApp::new();
        app.last_window_pos = Some([10.0, 10.0]);
        app.last_window_size = Some([800.0, 600.0]);
        app.last_window_maximized = false;
        app.last_persisted_state = Some(WindowState {
            pos: [10.0, 10.0],
            size: [800.0, 600.0],
            maximized: false,
        });

        app.persist_window_state();
        assert!(app.last_persisted_state.is_some());
    }

    #[test]
    fn test_persist_window_state_without_window_state() {
        let mut app = MarkdownViewerApp::new();
        app.last_window_pos = None;
        app.last_window_size = None;

        app.persist_window_state();
        assert!(app.last_persisted_state.is_none());
    }

    #[test]
    fn test_persist_window_state_save_failure() {
        let _lock = env_lock();
        let temp_file = NamedTempFile::new().expect("temp file");
        let _guard = EnvGuard::set("APPDATA", temp_file.path().to_string_lossy().as_ref());

        let mut app = MarkdownViewerApp::new();
        app.last_window_pos = Some([10.0, 10.0]);
        app.last_window_size = Some([800.0, 600.0]);
        app.last_window_maximized = false;

        app.persist_window_state();
        assert!(app.last_persisted_state.is_none());
    }

    #[test]
    fn test_should_persist_window_state_screenshot_blocks() {
        let temp_dir = tempfile::TempDir::new().expect("temp dir");
        let config = ScreenshotConfig {
            output_path: temp_dir.path().join("shot.png"),
            viewport_width: 80.0,
            viewport_height: 60.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let mut app = MarkdownViewerApp::new();
        app.screenshot = Some(ScreenshotState::new(config));
        assert!(!app.should_persist_window_state());
    }

    #[test]
    fn test_should_persist_window_state_recently_persisted() {
        let mut app = MarkdownViewerApp::new();
        app.last_window_pos = Some([10.0, 10.0]);
        app.last_window_size = Some([800.0, 600.0]);
        app.last_persist_instant = std::time::Instant::now();
        assert!(!app.should_persist_window_state());
    }

    #[test]
    fn test_should_persist_window_state_without_window_state() {
        let mut app = MarkdownViewerApp::new();
        app.last_persist_instant = std::time::Instant::now() - std::time::Duration::from_secs(2);
        assert!(!app.should_persist_window_state());
    }

    #[test]
    fn test_should_persist_window_state_when_changed() {
        let mut app = MarkdownViewerApp::new();
        app.last_window_pos = Some([10.0, 10.0]);
        app.last_window_size = Some([800.0, 600.0]);
        app.last_persist_instant = std::time::Instant::now() - std::time::Duration::from_secs(2);

        assert!(app.should_persist_window_state());
    }

    #[test]
    fn test_update_impl_persists_window_state_when_due() {
        let _lock = env_lock();
        let temp_dir = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());

        let mut app = MarkdownViewerApp::new();
        app.last_persist_instant = std::time::Instant::now() - std::time::Duration::from_secs(2);

        let ctx = egui::Context::default();
        let mut input = default_input();
        let vp = input
            .viewports
            .get_mut(&egui::ViewportId::ROOT)
            .expect("root viewport");
        vp.monitor_size = Some(egui::vec2(1024.0, 768.0));
        vp.outer_rect = Some(egui::Rect::from_min_size(
            egui::pos2(10.0, 10.0),
            egui::vec2(800.0, 600.0),
        ));
        vp.inner_rect = Some(egui::Rect::from_min_size(
            egui::pos2(20.0, 20.0),
            egui::vec2(780.0, 580.0),
        ));
        vp.fullscreen = Some(false);
        vp.maximized = Some(false);

        run_app_frame(&mut app, &ctx, input);

        let path = temp_dir
            .path()
            .join("MarkdownView")
            .join("window_state.txt");
        assert!(path.exists());
        assert!(app.last_persisted_state.is_some());
    }

    #[test]
    fn test_update_impl_fullscreen_skips_size_persist() {
        let mut app = MarkdownViewerApp::new();
        app.last_window_size = None;

        let ctx = egui::Context::default();
        let mut input = default_input();
        let vp = input
            .viewports
            .get_mut(&egui::ViewportId::ROOT)
            .expect("root viewport");
        vp.monitor_size = Some(egui::vec2(1024.0, 768.0));
        vp.outer_rect = Some(egui::Rect::from_min_size(
            egui::pos2(10.0, 10.0),
            egui::vec2(800.0, 600.0),
        ));
        vp.inner_rect = Some(egui::Rect::from_min_size(
            egui::pos2(20.0, 20.0),
            egui::vec2(780.0, 580.0),
        ));
        vp.fullscreen = Some(true);
        vp.maximized = Some(false);

        run_app_frame(&mut app, &ctx, input);

        assert!(app.last_window_size.is_none());
    }

    #[test]
    fn test_update_impl_reload_with_file_succeeds() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let mut temp_file = tempfile::Builder::new().suffix(".md").tempfile()?;
        temp_file.write_all(b"# Reloaded")?;
        temp_file.flush()?;
        app.current_file = Some(temp_file.path().to_path_buf());
        app.reload_requested = true;

        let ctx = egui::Context::default();
        let input = default_input();
        run_app_frame(&mut app, &ctx, input);

        assert!(app.error_message.is_none());
        Ok(())
    }

    #[test]
    fn test_save_current_document_parentless_path() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        app.current_content = "Saved".to_string();
        let filename = format!("save_parentless_{}.md", std::process::id());
        let _forced = ForcedDialogPaths::new(None, Some(PathBuf::from(&filename)));

        app.save_current_document()?;
        assert_eq!(app.current_file, Some(PathBuf::from(&filename)));
        std::fs::remove_file(&filename)?;
        Ok(())
    }

    #[test]
    fn test_update_search_results_wraps() {
        let mut app = MarkdownViewerApp::new();
        app.parsed_elements = vec![
            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
            MarkdownElement::Paragraph(vec![InlineSpan::Text("Other".to_string())]),
        ];
        app.search_query = "Match".to_string();
        app.last_match_index = Some(1);

        app.update_search_results("");
        assert_eq!(app.last_match_index, Some(0));
    }

    #[test]
    fn test_handle_screenshot_events_save_error() {
        let mut app = MarkdownViewerApp::new();
        let ctx = egui::Context::default();
        let temp_dir = tempfile::TempDir::new().expect("temp dir");
        let config = ScreenshotConfig {
            output_path: temp_dir.path().to_path_buf(),
            viewport_width: 40.0,
            viewport_height: 30.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 0,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        app.screenshot = Some(ScreenshotState::new(config));

        let image = egui::ColorImage::new([10, 10], Color32::WHITE);
        let mut input = default_input();
        input.events.push(egui::Event::Screenshot {
            viewport_id: egui::ViewportId::ROOT,
            image: std::sync::Arc::new(image),
        });
        let _ = ctx.run(input, |ctx| {
            app.handle_screenshot_events(ctx);
        });

        assert!(app.screenshot.as_ref().is_some_and(|state| state.done));
    }

    #[test]
    fn test_update_screenshot_state_requests_repaint() {
        let temp_dir = tempfile::TempDir::new().expect("temp dir");
        let config = ScreenshotConfig {
            output_path: temp_dir.path().join("shot.png"),
            viewport_width: 200.0,
            viewport_height: 100.0,
            content_only: false,
            scroll_ratio: Some(0.5),
            wait_ms: 1000,
            settle_frames: 5,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let mut app = MarkdownViewerApp::new();
        app.screenshot = Some(ScreenshotState::new(config));

        let ctx = egui::Context::default();
        app.update_screenshot_state(&ctx, None, None);
    }

    #[test]
    fn test_update_screenshot_state_requested_done_skips_repaint() {
        let temp_dir = tempfile::TempDir::new().expect("temp dir");
        let config = ScreenshotConfig {
            output_path: temp_dir.path().join("shot.png"),
            viewport_width: 200.0,
            viewport_height: 100.0,
            content_only: false,
            scroll_ratio: None,
            wait_ms: 1000,
            settle_frames: 0,
            zoom: 1.0,
            theme: ScreenshotTheme::Light,
            font_source: None,
        };
        let mut state = ScreenshotState::new(config);
        state.requested = true;
        state.done = true;

        let mut app = MarkdownViewerApp::new();
        app.screenshot = Some(state);

        let ctx = egui::Context::default();
        app.update_screenshot_state(&ctx, None, None);

        let state = app.screenshot.as_ref().expect("screenshot state");
        assert!(state.requested);
        assert!(state.done);
    }

    #[test]
    fn test_env_guard_removes_unset_key() {
        let _lock = env_lock();
        std::env::remove_var("MDMDVIEW_TMP_ENV");
        {
            let _guard = EnvGuard::set("MDMDVIEW_TMP_ENV", "value");
        }
        assert!(std::env::var("MDMDVIEW_TMP_ENV").is_err());
    }
}


----------------------------------------

File: src\emoji_assets.rs

use egui::Color32 as C;

// Draw simple vector fallback icons for a subset of emoji.
pub fn make_image(emoji: &str, size: usize) -> Option<egui::ColorImage> {
    let mut img = egui::ColorImage::new([size, size], C::TRANSPARENT);
    match emoji {
        "\u{2705}" => {
            draw_circle(&mut img, size, C::from_rgb(34, 139, 34));
            draw_check(&mut img, size, C::WHITE);
            Some(img)
        }
        "\u{1f389}" => {
            draw_circle(&mut img, size, C::from_rgb(255, 215, 0));
            confetti(&mut img, size);
            Some(img)
        }
        "\u{1f680}" => {
            draw_circle(&mut img, size, C::from_rgb(60, 60, 170));
            rocket(
                &mut img,
                size,
                C::from_rgb(230, 230, 230),
                C::from_rgb(255, 110, 60),
            );
            Some(img)
        }
        "\u{2764}" | "\u{1f496}" => {
            heart(&mut img, size, C::from_rgb(220, 20, 60));
            Some(img)
        }
        "\u{2b50}" => {
            star(&mut img, size, C::from_rgb(255, 215, 0));
            Some(img)
        }
        "\u{1f525}" => {
            flame(&mut img, size);
            Some(img)
        }
        _ => None,
    }
}

fn draw_circle(img: &mut egui::ColorImage, size: usize, color: C) {
    let cx = (size as i32) / 2;
    let cy = cx;
    let r = (size as i32) / 2 - 2;
    for y in 0..size as i32 {
        for x in 0..size as i32 {
            let dx = x - cx;
            let dy = y - cy;
            if dx * dx + dy * dy <= r * r {
                img[(x as usize, y as usize)] = color;
            }
        }
    }
}

fn draw_check(img: &mut egui::ColorImage, size: usize, color: C) {
    let s = size as i32;
    let mut plot = |x: i32, y: i32| {
        img[(x as usize, y as usize)] = color;
    };
    // simple check mark
    for i in 0..s / 3 {
        plot(s / 3 - i, s * 2 / 3 + i);
        plot(s / 3 - i + 1, s * 2 / 3 + i);
    }
    for i in 0..s / 2 {
        plot(s / 3 + i, s * 2 / 3 - i);
        plot(s / 3 + i + 1, s * 2 / 3 - i);
    }
}

fn confetti(img: &mut egui::ColorImage, size: usize) {
    let dots = [
        C::from_rgb(255, 80, 80),
        C::from_rgb(80, 180, 255),
        C::from_rgb(120, 220, 120),
        C::from_rgb(220, 120, 220),
    ];
    let s = size as i32;
    for (i, col) in dots.iter().enumerate() {
        let x = (s / 4) * ((i as i32) + 1);
        let y = (s / 5) * ((i as i32) + 1);
        if x < s {
            img[(x as usize, y as usize)] = *col;
        }
    }
}

fn rocket(img: &mut egui::ColorImage, size: usize, body: C, flame: C) {
    let s = size as i32;
    // body
    for y in s / 4..s * 3 / 4 {
        for x in s / 3..s * 2 / 3 {
            img[(x as usize, y as usize)] = body;
        }
    }
    // nose
    for i in 0..s / 6 {
        for x in s / 2 - i..=s / 2 + i {
            let y = s / 4 - i;
            img[(x as usize, y as usize)] = body;
        }
    }
    // flame
    for i in 0..s / 6 {
        for x in s / 2 - i..=s / 2 + i {
            let y = s * 3 / 4 + i;
            img[(x as usize, y as usize)] = flame;
        }
    }
}

fn heart(img: &mut egui::ColorImage, size: usize, color: C) {
    let s = size as i32;
    for y in 0..s {
        for x in 0..s {
            let dx = x - s / 2;
            let dy = y - s / 3;
            let a = (dx * dx + dy * dy - s * s / 16) < 0;
            let b = x > s / 4 && x < 3 * s / 4 && y > s / 3 && y < s * 3 / 4;
            if a || b {
                img[(x as usize, y as usize)] = color;
            }
        }
    }
}

fn star(img: &mut egui::ColorImage, size: usize, color: C) {
    let s = size as i32;
    for i in 0..s {
        let y = i;
        let x1 = s / 2;
        let x2 = s / 2 - i / 2;
        let x3 = s / 2 + i / 2;
        img[(x2 as usize, y as usize)] = color;
        img[(x1 as usize, y as usize)] = color;
        img[(x3 as usize, y as usize)] = color;
    }
}

fn flame(img: &mut egui::ColorImage, size: usize) {
    let s = size as i32;
    let base = C::from_rgb(255, 140, 0);
    let tip = C::from_rgb(255, 220, 120);
    for y in 0..s {
        for x in 0..s {
            let dx = (x - s / 2) as f32 / (s as f32 / 3.5);
            let dy = (y - s) as f32 / (s as f32 / 1.5);
            let v = (dx * dx + dy * dy).sqrt();
            if v < 1.0 {
                let t = 1.0 - v;
                img[(x as usize, y as usize)] = C::from_rgb(
                    (base.r() as f32 * t + tip.r() as f32 * (1.0 - t)) as u8,
                    (base.g() as f32 * t + tip.g() as f32 * (1.0 - t)) as u8,
                    (base.b() as f32 * t + tip.b() as f32 * (1.0 - t)) as u8,
                );
            }
        }
    }
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;

    fn has_non_transparent_pixel(img: &egui::ColorImage) -> bool {
        img.pixels.iter().any(|p| p.a() != 0)
    }

    #[test]
    fn test_make_image_known_emojis_produce_pixels() {
        let emojis = [
            "\u{2705}",
            "\u{1f389}",
            "\u{1f680}",
            "\u{2764}",
            "\u{1f496}",
            "\u{2b50}",
            "\u{1f525}",
        ];

        for emoji in emojis {
            let img = make_image(emoji, 24).expect("expected fallback image");
            assert!(has_non_transparent_pixel(&img));
        }
    }

    #[test]
    fn test_make_image_unknown_returns_none() {
        assert!(make_image("\u{1f47d}", 24).is_none());
    }
}


----------------------------------------

File: src\emoji_catalog.rs

use std::collections::HashMap;

// Return embedded emoji sprites keyed by real Unicode emoji characters.
pub fn image_bytes_for(emoji: &str) -> Option<&'static [u8]> {
    match emoji {
        "\u{1f389}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f389.png"
        ))),
        "\u{2705}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/2705.png"
        ))),
        "\u{1f680}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f680.png"
        ))),
        "\u{1f642}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f642.png"
        ))),
        "\u{1f600}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f600.png"
        ))),
        "\u{1f609}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f609.png"
        ))),
        "\u{2b50}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/2b50.png"
        ))),
        "\u{1f525}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f525.png"
        ))),
        "\u{1f44d}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f44d.png"
        ))),
        "\u{1f44e}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f44e.png"
        ))),
        "\u{1f4a1}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f4a1.png"
        ))),
        "\u{2753}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/2753.png"
        ))),
        "\u{2757}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/2757.png"
        ))),
        "\u{1f4dd}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f4dd.png"
        ))),
        "\u{1f9e0}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f9e0.png"
        ))),
        "\u{1f9ea}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f9ea.png"
        ))),
        "\u{1f4e6}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f4e6.png"
        ))),
        "\u{1f527}" => Some(include_bytes!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/assets/emoji/1f527.png"
        ))),
        _ => None,
    }
}

pub fn shortcode_map() -> &'static HashMap<&'static str, &'static str> {
    use std::sync::OnceLock;
    static MAP: OnceLock<HashMap<&'static str, &'static str>> = OnceLock::new();
    MAP.get_or_init(|| {
        HashMap::from([
            (":tada:", "\u{1f389}"),
            (":white_check_mark:", "\u{2705}"),
            (":check_mark:", "\u{2705}"),
            (":rocket:", "\u{1f680}"),
            (":slightly_smiling_face:", "\u{1f642}"),
            (":grinning:", "\u{1f600}"),
            (":wink:", "\u{1f609}"),
            (":star:", "\u{2b50}"),
            (":fire:", "\u{1f525}"),
            (":thumbsup:", "\u{1f44d}"),
            (":thumbsdown:", "\u{1f44e}"),
            (":bulb:", "\u{1f4a1}"),
            (":question:", "\u{2753}"),
            (":exclamation:", "\u{2757}"),
            (":memo:", "\u{1f4dd}"),
            (":brain:", "\u{1f9e0}"),
            (":test_tube:", "\u{1f9ea}"),
            (":package:", "\u{1f4e6}"),
            (":wrench:", "\u{1f527}"),
        ])
    })
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;

    #[test]
    fn test_image_bytes_for_known_emojis() {
        let emojis = [
            "\u{1f389}",
            "\u{2705}",
            "\u{1f680}",
            "\u{1f642}",
            "\u{1f600}",
            "\u{1f609}",
            "\u{2b50}",
            "\u{1f525}",
            "\u{1f44d}",
            "\u{1f44e}",
            "\u{1f4a1}",
            "\u{2753}",
            "\u{2757}",
            "\u{1f4dd}",
            "\u{1f9e0}",
            "\u{1f9ea}",
            "\u{1f4e6}",
            "\u{1f527}",
        ];

        for emoji in emojis {
            let bytes = image_bytes_for(emoji).expect("expected embedded emoji bytes");
            assert!(!bytes.is_empty());
        }
    }

    #[test]
    fn test_image_bytes_for_unknown_emoji() {
        assert!(image_bytes_for("\u{1f47d}").is_none());
    }

    #[test]
    fn test_shortcode_map_contains_expected_entries() {
        let map = shortcode_map();
        assert_eq!(map.get(":tada:"), Some(&"\u{1f389}"));
        assert_eq!(map.get(":white_check_mark:"), Some(&"\u{2705}"));
        assert_eq!(map.get(":rocket:"), Some(&"\u{1f680}"));
        assert_eq!(map.get(":fire:"), Some(&"\u{1f525}"));
        assert_eq!(map.get(":wrench:"), Some(&"\u{1f527}"));
        assert!(map.get(":does_not_exist:").is_none());
    }
}


----------------------------------------

File: src\image_decode.rs

use egui::ColorImage;
#[cfg(test)]
use std::cell::RefCell;
use std::io::Cursor;

#[cfg(test)]
thread_local! {
    static FORCED_ZERO_SVG_DIMENSIONS: RefCell<bool> = const { RefCell::new(false) };
    static FORCED_RASTER_DIMENSIONS: RefCell<Option<(u32, u32)>> = const { RefCell::new(None) };
    static FORCED_SVG_DIMENSIONS: RefCell<Option<(u32, u32)>> = const { RefCell::new(None) };
    static FORCED_PIXMAP_ALLOC_FAIL: RefCell<bool> = const { RefCell::new(false) };
    static FORCED_GUESS_FORMAT_ERROR: RefCell<bool> = const { RefCell::new(false) };
}

#[cfg(test)]
fn take_forced_zero_svg_dimensions() -> bool {
    FORCED_ZERO_SVG_DIMENSIONS.with(|flag| flag.replace(false))
}

#[cfg(test)]
fn take_forced_raster_dimensions() -> Option<(u32, u32)> {
    FORCED_RASTER_DIMENSIONS.with(|dims| dims.borrow_mut().take())
}

#[cfg(test)]
fn take_forced_svg_dimensions() -> Option<(u32, u32)> {
    FORCED_SVG_DIMENSIONS.with(|dims| dims.borrow_mut().take())
}

#[cfg(test)]
fn take_forced_pixmap_alloc_fail() -> bool {
    FORCED_PIXMAP_ALLOC_FAIL.with(|flag| flag.replace(false))
}

#[cfg(test)]
fn take_forced_guess_format_error() -> bool {
    FORCED_GUESS_FORMAT_ERROR.with(|flag| flag.replace(false))
}

const MAX_IMAGE_SIDE: u32 = 4096;
const MAX_IMAGE_PIXELS: u64 = MAX_IMAGE_SIDE as u64 * MAX_IMAGE_SIDE as u64;
const MAX_IMAGE_BYTES: usize = 64 * 1024 * 1024;

#[cfg(test)]
pub(crate) fn svg_bytes_to_color_image(bytes: &[u8]) -> Option<(ColorImage, u32, u32)> {
    svg_bytes_to_color_image_with_bg(bytes, None)
}

fn guessed_format_for_test(bytes: &[u8]) -> std::io::Result<image::io::Reader<Cursor<&[u8]>>> {
    #[cfg(test)]
    if take_forced_guess_format_error() {
        return Err(std::io::Error::other("forced guess format error"));
    }
    image::io::Reader::new(Cursor::new(bytes)).with_guessed_format()
}

fn raster_dimensions(bytes: &[u8]) -> Option<(u32, u32)> {
    let reader = guessed_format_for_test(bytes).ok()?;
    reader.into_dimensions().ok()
}

fn raster_exceeds_limits(w: u32, h: u32) -> bool {
    if w == 0 || h == 0 {
        return true;
    }
    if w > MAX_IMAGE_SIDE || h > MAX_IMAGE_SIDE {
        return true;
    }
    let pixels = (w as u64).saturating_mul(h as u64);
    pixels > MAX_IMAGE_PIXELS
}

fn pixmap_new_for_test(w: u32, h: u32) -> Option<tiny_skia::Pixmap> {
    #[cfg(test)]
    if take_forced_pixmap_alloc_fail() {
        return None;
    }
    tiny_skia::Pixmap::new(w, h)
}

pub(crate) fn raster_bytes_to_color_image_with_bg(
    bytes: &[u8],
    bg: Option<[u8; 4]>,
) -> Option<(ColorImage, u32, u32)> {
    if bytes.len() > MAX_IMAGE_BYTES {
        return None;
    }
    if let Some((w, h)) = raster_dimensions(bytes) {
        if raster_exceeds_limits(w, h) {
            return None;
        }
    }
    let img = image::load_from_memory(bytes).ok()?;
    let rgba = img.to_rgba8();
    let (w, h) = rgba.dimensions();
    #[cfg(test)]
    let (w, h) = if let Some((forced_w, forced_h)) = take_forced_raster_dimensions() {
        (forced_w, forced_h)
    } else {
        (w, h)
    };
    if raster_exceeds_limits(w, h) {
        return None;
    }
    let mut ci = ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &rgba);
    if let Some([br, bgc, bb, ba]) = bg {
        for p in ci.pixels.iter_mut() {
            let a = p[3] as f32 / 255.0;
            let inv = 1.0 - a;
            p[0] = (a * p[0] as f32 + inv * br as f32) as u8;
            p[1] = (a * p[1] as f32 + inv * bgc as f32) as u8;
            p[2] = (a * p[2] as f32 + inv * bb as f32) as u8;
            p[3] = ba;
        }
    }
    Some((ci, w, h))
}

pub(crate) fn svg_bytes_to_color_image_with_bg(
    bytes: &[u8],
    bg: Option<[u8; 4]>,
) -> Option<(ColorImage, u32, u32)> {
    let mut opt = usvg::Options::default();
    let mut db = usvg::fontdb::Database::new();
    db.load_system_fonts();
    opt.fontdb = std::sync::Arc::new(db);
    let tree = usvg::Tree::from_data(bytes, &opt).ok()?;
    let sz = tree.size();
    let pix = sz.to_int_size();
    let (mut w, mut h) = (pix.width(), pix.height());
    #[cfg(test)]
    if take_forced_zero_svg_dimensions() {
        w = 0;
        h = 0;
    }
    #[cfg(test)]
    if let Some((forced_w, forced_h)) = take_forced_svg_dimensions() {
        w = forced_w;
        h = forced_h;
    }
    if w == 0 || h == 0 {
        w = 256;
        h = 256;
    }
    let max_side: u32 = MAX_IMAGE_SIDE;
    if w > max_side || h > max_side {
        let scale = (max_side as f32 / w as f32).min(max_side as f32 / h as f32);
        w = (w as f32 * scale) as u32;
        h = (h as f32 * scale) as u32;
    }
    let mut pixmap = pixmap_new_for_test(w, h)?;
    if let Some([r, g, b, a]) = bg {
        let color = tiny_skia::Color::from_rgba8(r, g, b, a);
        pixmap.fill(color);
    }
    let mut pmut = pixmap.as_mut();
    resvg::render(&tree, tiny_skia::Transform::identity(), &mut pmut);
    let data = pixmap.data();
    let img = ColorImage::from_rgba_unmultiplied([w as usize, h as usize], data);
    Some((img, w, h))
}

pub(crate) fn bytes_to_color_image_guess(
    bytes: &[u8],
    bg: Option<[u8; 4]>,
) -> Option<(ColorImage, u32, u32)> {
    if let Some(img) = raster_bytes_to_color_image_with_bg(bytes, bg) {
        return Some(img);
    }
    svg_bytes_to_color_image_with_bg(bytes, bg)
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;
    use image::{ImageOutputFormat, RgbaImage};
    use std::io::Cursor;

    struct ForcedZeroSvgDimensions;

    impl ForcedZeroSvgDimensions {
        fn new() -> Self {
            FORCED_ZERO_SVG_DIMENSIONS.with(|flag| flag.replace(true));
            Self
        }
    }

    struct ForcedRasterDimensions;

    impl ForcedRasterDimensions {
        fn new(w: u32, h: u32) -> Self {
            FORCED_RASTER_DIMENSIONS.with(|dims| {
                *dims.borrow_mut() = Some((w, h));
            });
            Self
        }
    }

    impl Drop for ForcedRasterDimensions {
        fn drop(&mut self) {
            FORCED_RASTER_DIMENSIONS.with(|dims| {
                dims.borrow_mut().take();
            });
        }
    }

    struct ForcedSvgDimensions;

    impl ForcedSvgDimensions {
        fn new(w: u32, h: u32) -> Self {
            FORCED_SVG_DIMENSIONS.with(|dims| {
                *dims.borrow_mut() = Some((w, h));
            });
            Self
        }
    }

    impl Drop for ForcedSvgDimensions {
        fn drop(&mut self) {
            FORCED_SVG_DIMENSIONS.with(|dims| {
                dims.borrow_mut().take();
            });
        }
    }

    struct ForcedPixmapAllocFail;

    impl ForcedPixmapAllocFail {
        fn new() -> Self {
            FORCED_PIXMAP_ALLOC_FAIL.with(|flag| flag.replace(true));
            Self
        }
    }

    impl Drop for ForcedPixmapAllocFail {
        fn drop(&mut self) {
            FORCED_PIXMAP_ALLOC_FAIL.with(|flag| flag.replace(false));
        }
    }

    struct ForcedGuessFormatError;

    impl ForcedGuessFormatError {
        fn new() -> Self {
            FORCED_GUESS_FORMAT_ERROR.with(|flag| flag.replace(true));
            Self
        }
    }

    impl Drop for ForcedGuessFormatError {
        fn drop(&mut self) {
            FORCED_GUESS_FORMAT_ERROR.with(|flag| flag.replace(false));
        }
    }

    fn encode_png(rgba: &RgbaImage) -> Vec<u8> {
        let mut bytes = Vec::new();
        let mut cursor = Cursor::new(&mut bytes);
        image::DynamicImage::ImageRgba8(rgba.clone())
            .write_to(&mut cursor, ImageOutputFormat::Png)
            .expect("encode png");
        bytes
    }

    #[test]
    fn test_raster_dimensions_invalid_bytes_returns_none() {
        assert!(raster_dimensions(&[]).is_none());
    }

    #[test]
    fn test_raster_dimensions_valid_png_returns_some() {
        let mut rgba = RgbaImage::new(2, 1);
        rgba.put_pixel(0, 0, image::Rgba([0, 0, 0, 255]));
        rgba.put_pixel(1, 0, image::Rgba([255, 255, 255, 255]));
        let bytes = encode_png(&rgba);
        assert_eq!(raster_dimensions(&bytes), Some((2, 1)));
    }

    #[test]
    fn test_raster_dimensions_forced_guess_error_returns_none() {
        let _guard = ForcedGuessFormatError::new();
        let mut rgba = RgbaImage::new(1, 1);
        rgba.put_pixel(0, 0, image::Rgba([0, 0, 0, 255]));
        let bytes = encode_png(&rgba);
        assert!(raster_dimensions(&bytes).is_none());
    }

    #[test]
    fn test_bytes_to_color_image_guess_png_blends_background() {
        let mut rgba = RgbaImage::new(1, 1);
        rgba.put_pixel(0, 0, image::Rgba([255, 0, 0, 255]));
        let bytes = encode_png(&rgba);

        let bg = [0, 0, 255, 200];
        let (img, w, h) = bytes_to_color_image_guess(&bytes, Some(bg)).expect("png decode");
        assert_eq!((w, h), (1, 1));

        let px = img.pixels[0];
        assert_eq!(px[0], 255);
        assert_eq!(px[1], 0);
        assert_eq!(px[2], 0);
        assert_eq!(px[3], bg[3]);
    }

    #[test]
    fn test_svg_bytes_to_color_image_scales_and_fills_bg() {
        let svg = r#"<svg width="5000" height="3000" xmlns="http://www.w3.org/2000/svg">
 <rect width="5000" height="3000" fill="red"/>
 </svg>"#;
        let bg = Some([1, 2, 3, 255]);
        let (_img, w, h) =
            svg_bytes_to_color_image_with_bg(svg.as_bytes(), bg).expect("svg decode");
        assert!(w > 0);
        assert!(h > 0);
        assert!(w <= 4096);
        assert!(h <= 4096);
    }

    #[test]
    fn test_svg_bytes_to_color_image_forced_pixmap_fail_returns_none() {
        let _guard = ForcedPixmapAllocFail::new();
        let svg = r#"<svg width="10" height="10" xmlns="http://www.w3.org/2000/svg">
 <rect width="10" height="10" fill="red"/>
</svg>"#;
        assert!(svg_bytes_to_color_image_with_bg(svg.as_bytes(), None).is_none());
    }

    #[test]
    fn test_svg_bytes_to_color_image_invalid_returns_none() {
        assert!(svg_bytes_to_color_image(b"not svg").is_none());
    }

    #[test]
    fn test_raster_bytes_rejects_large_dimensions() {
        let mut rgba = RgbaImage::new(5000, 1);
        rgba.put_pixel(0, 0, image::Rgba([0, 0, 0, 255]));
        let bytes = encode_png(&rgba);
        assert!(raster_bytes_to_color_image_with_bg(&bytes, None).is_none());
    }

    #[test]
    fn test_raster_bytes_rejects_forced_post_decode_limits() {
        let mut rgba = RgbaImage::new(1, 1);
        rgba.put_pixel(0, 0, image::Rgba([0, 0, 0, 255]));
        let bytes = encode_png(&rgba);
        let _forced = ForcedRasterDimensions::new(MAX_IMAGE_SIDE + 1, 1);
        assert!(raster_bytes_to_color_image_with_bg(&bytes, None).is_none());
    }

    #[test]
    fn test_bytes_to_color_image_guess_svg_fallback() {
        let svg = r#"<svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">
<circle cx="32" cy="32" r="20" fill="blue"/>
</svg>"#;
        let (_img, w, h) = bytes_to_color_image_guess(svg.as_bytes(), None).expect("svg fallback");
        assert_eq!((w, h), (64, 64));
    }

    #[test]
    fn test_raster_exceeds_limits_zero_dimensions() {
        assert!(raster_exceeds_limits(0, 10));
        assert!(raster_exceeds_limits(10, 0));
    }

    #[test]
    fn test_raster_exceeds_limits_large_sides() {
        assert!(raster_exceeds_limits(MAX_IMAGE_SIDE + 1, 1));
        assert!(raster_exceeds_limits(1, MAX_IMAGE_SIDE + 1));
    }

    #[test]
    fn test_raster_exceeds_limits_within_bounds() {
        assert!(!raster_exceeds_limits(MAX_IMAGE_SIDE, MAX_IMAGE_SIDE));
    }

    #[test]
    fn test_raster_bytes_rejects_large_buffer() {
        let bytes = vec![0u8; MAX_IMAGE_BYTES + 1];
        assert!(raster_bytes_to_color_image_with_bg(&bytes, None).is_none());
    }

    #[test]
    fn test_svg_zero_dimensions_defaults_to_256() {
        let _forced = ForcedZeroSvgDimensions::new();
        let svg = r#"<svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">
<rect width="64" height="64" fill="red"/>
</svg>"#;
        let (_img, w, h) =
            svg_bytes_to_color_image_with_bg(svg.as_bytes(), None).expect("svg decode");
        assert_eq!((w, h), (256, 256));
    }

    #[test]
    fn test_svg_zero_height_defaults_to_256() {
        let _forced = ForcedSvgDimensions::new(64, 0);
        let svg = r#"<svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">
<rect width="64" height="64" fill="red"/>
</svg>"#;
        let (_img, w, h) =
            svg_bytes_to_color_image_with_bg(svg.as_bytes(), None).expect("svg decode");
        assert_eq!((w, h), (256, 256));
    }

    #[test]
    fn test_svg_bytes_to_color_image_scales_large_dimensions() {
        let svg = r#"<svg width="8192" height="8192" xmlns="http://www.w3.org/2000/svg">
<rect width="8192" height="8192" fill="red"/>
</svg>"#;
        let (_img, w, h) =
            svg_bytes_to_color_image_with_bg(svg.as_bytes(), None).expect("svg decode");
        assert!(w <= 4096);
        assert!(h <= 4096);
        assert!(w > 0);
        assert!(h > 0);
    }

    #[test]
    fn test_svg_bytes_to_color_image_scales_tall_dimensions() {
        let svg = r#"<svg width="64" height="8192" xmlns="http://www.w3.org/2000/svg">
<rect width="64" height="8192" fill="red"/>
</svg>"#;
        let (_img, w, h) =
            svg_bytes_to_color_image_with_bg(svg.as_bytes(), None).expect("svg decode");
        assert!(w <= 4096);
        assert!(h <= 4096);
        assert!(w > 0);
        assert!(h > 0);
    }
}


----------------------------------------

File: src\lib.rs

#![cfg_attr(coverage_nightly, feature(coverage_attribute))]

pub mod app;
pub mod emoji_assets;
pub mod emoji_catalog;
pub(crate) mod image_decode;
/// A simple markdown viewer built with egui
///
/// This library provides markdown parsing and rendering functionality
/// that can be embedded in GUI applications.
pub mod markdown_renderer;
pub(crate) mod mermaid_renderer;
pub mod sample_files;
pub mod table_support;
pub mod window_state;

pub use app::{MarkdownViewerApp, APP_TITLE_PREFIX};
pub use markdown_renderer::{MarkdownElement, MarkdownRenderer};
pub use sample_files::{SampleFile, SAMPLE_FILES};
pub use window_state::{load_window_state, sanitize_window_state, save_window_state, WindowState};


----------------------------------------

File: src\main.rs

#![cfg_attr(coverage_nightly, feature(coverage_attribute))]
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")] // Hide console in release mode

#[cfg(not(test))]
use mdmdview::app::{ScreenshotConfig, ScreenshotTheme};
/// Main entry point for the MarkdownView application
///
/// A simple, standalone markdown viewer for Windows built with Rust and egui.
/// This application provides a clean interface for viewing markdown files with
/// syntax highlighting, embedded samples, and essential viewing features.
#[cfg(not(test))]
use mdmdview::{load_window_state, sanitize_window_state, MarkdownViewerApp, APP_TITLE_PREFIX};
#[cfg(not(test))]
use std::path::Path;
use std::path::PathBuf;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum ThemeChoice {
    Light,
    Dark,
}

#[derive(Default)]
struct CliOptions {
    initial_file: Option<PathBuf>,
    screenshot: bool,
    screenshot_output: Option<PathBuf>,
    width: Option<f32>,
    height: Option<f32>,
    theme: Option<ThemeChoice>,
    zoom: Option<f32>,
    content_only: bool,
    scroll: Option<f32>,
    wait_ms: Option<u64>,
    settle_frames: Option<u32>,
    test_fonts: Option<PathBuf>,
}

#[cfg(not(test))]
fn parse_cli_args() -> Result<CliOptions, String> {
    parse_cli_from(std::env::args().skip(1))
}

fn parse_cli_from<I>(args: I) -> Result<CliOptions, String>
where
    I: IntoIterator<Item = String>,
{
    let mut opts = CliOptions::default();
    let mut iter = args.into_iter();

    while let Some(arg) = iter.next() {
        match arg.as_str() {
            "--screenshot" => {
                opts.screenshot = true;
                let value = next_value(&mut iter, "--screenshot")?;
                opts.initial_file = Some(PathBuf::from(value));
            }
            "--output" => {
                let value = next_value(&mut iter, "--output")?;
                opts.screenshot_output = Some(PathBuf::from(value));
            }
            "--width" => {
                let value = next_value(&mut iter, "--width")?;
                opts.width = Some(parse_f32("--width", &value)?);
            }
            "--height" => {
                let value = next_value(&mut iter, "--height")?;
                opts.height = Some(parse_f32("--height", &value)?);
            }
            "--theme" => {
                let value = next_value(&mut iter, "--theme")?;
                opts.theme = Some(parse_theme(&value)?);
            }
            "--zoom" => {
                let value = next_value(&mut iter, "--zoom")?;
                opts.zoom = Some(parse_f32("--zoom", &value)?);
            }
            "--content-only" => opts.content_only = true,
            "--scroll" => {
                let value = next_value(&mut iter, "--scroll")?;
                let ratio = parse_f32("--scroll", &value)?.clamp(0.0, 1.0);
                opts.scroll = Some(ratio);
            }
            "--wait-ms" => {
                let value = next_value(&mut iter, "--wait-ms")?;
                opts.wait_ms = Some(parse_u64("--wait-ms", &value)?);
            }
            "--settle-frames" => {
                let value = next_value(&mut iter, "--settle-frames")?;
                opts.settle_frames = Some(parse_u32("--settle-frames", &value)?);
            }
            "--test-fonts" => {
                let value = next_value(&mut iter, "--test-fonts")?;
                opts.test_fonts = Some(PathBuf::from(value));
            }
            _ if opts.initial_file.is_none() => opts.initial_file = Some(PathBuf::from(arg)),
            _ => {}
        }
    }

    if opts.screenshot && opts.screenshot_output.is_none() {
        return Err("Missing --output for screenshot mode".to_string());
    }

    Ok(opts)
}

fn next_value<I>(iter: &mut I, flag: &str) -> Result<String, String>
where
    I: Iterator<Item = String>,
{
    iter.next()
        .ok_or_else(|| format!("{flag} requires a value"))
}

fn parse_theme(value: &str) -> Result<ThemeChoice, String> {
    match value.trim().to_ascii_lowercase().as_str() {
        "light" => Ok(ThemeChoice::Light),
        "dark" => Ok(ThemeChoice::Dark),
        _ => Err(format!("Unsupported theme: {value}")),
    }
}

fn parse_hex_color32(value: &str) -> Option<egui::Color32> {
    let hex = value.trim().trim_start_matches('#');
    if hex.len() != 6 {
        return None;
    }
    let r = u8::from_str_radix(&hex[0..2], 16).ok()?;
    let g = u8::from_str_radix(&hex[2..4], 16).ok()?;
    let b = u8::from_str_radix(&hex[4..6], 16).ok()?;
    Some(egui::Color32::from_rgb(r, g, b))
}

fn screenshot_background_color() -> egui::Color32 {
    if let Ok(hex) = std::env::var("MDMDVIEW_MERMAID_MAIN_BKG") {
        if let Some(color) = parse_hex_color32(&hex) {
            return color;
        }
    }
    egui::Color32::from_rgb(255, 248, 219)
}

fn parse_f32(flag: &str, value: &str) -> Result<f32, String> {
    value
        .parse::<f32>()
        .map_err(|_| format!("Invalid {flag} value: {value}"))
}

fn parse_u32(flag: &str, value: &str) -> Result<u32, String> {
    value
        .parse::<u32>()
        .map_err(|_| format!("Invalid {flag} value: {value}"))
}

fn parse_u64(flag: &str, value: &str) -> Result<u64, String> {
    value
        .parse::<u64>()
        .map_err(|_| format!("Invalid {flag} value: {value}"))
}

#[cfg(not(test))]
fn load_fonts_from_dir(ctx: &egui::Context, dir: &Path) -> Result<(), String> {
    let mut font_paths: Vec<PathBuf> = std::fs::read_dir(dir)
        .map_err(|e| format!("Failed to read font dir {dir:?}: {e}"))?
        .filter_map(|entry| entry.ok().map(|e| e.path()))
        .filter(|path| {
            path.extension()
                .and_then(|ext| ext.to_str())
                .map(|ext| matches!(ext.to_ascii_lowercase().as_str(), "ttf" | "otf"))
                .unwrap_or(false)
        })
        .collect();

    if font_paths.is_empty() {
        return Err(format!("No font files found in {dir:?}"));
    }

    font_paths.sort_by(|a, b| a.to_string_lossy().cmp(&b.to_string_lossy()));

    let mut fonts = egui::FontDefinitions::default();
    let mut prop_names = Vec::new();
    let mut mono_names = Vec::new();
    let mut used_names = std::collections::HashSet::new();

    for path in font_paths {
        let bytes =
            std::fs::read(&path).map_err(|e| format!("Failed to read font {path:?}: {e}"))?;
        let name = path
            .file_stem()
            .and_then(|stem| stem.to_str())
            .map(|stem| stem.to_string())
            .unwrap_or_else(|| format!("font-{}", prop_names.len() + mono_names.len()));
        let base = format!("test-{name}");
        let mut name = base.clone();
        let mut counter = 1usize;
        while used_names.contains(&name) {
            name = format!("{base}-{counter}");
            counter += 1;
        }
        used_names.insert(name.clone());

        fonts
            .font_data
            .insert(name.clone(), egui::FontData::from_owned(bytes));

        let lower = name.to_ascii_lowercase();
        if lower.contains("mono") || lower.contains("code") {
            mono_names.push(name);
        } else {
            prop_names.push(name);
        }
    }

    if prop_names.is_empty() {
        prop_names = mono_names.clone();
    }
    if mono_names.is_empty() {
        mono_names = prop_names.clone();
    }

    if let Some(family) = fonts.families.get_mut(&egui::FontFamily::Proportional) {
        for name in prop_names.iter().rev() {
            family.insert(0, name.clone());
        }
    }
    if let Some(family) = fonts.families.get_mut(&egui::FontFamily::Monospace) {
        for name in mono_names.iter().rev() {
            family.insert(0, name.clone());
        }
    }

    ctx.set_fonts(fonts);
    Ok(())
}

/// Application entry point
#[cfg(not(test))]
fn main() -> Result<(), eframe::Error> {
    // Configure logging for debugging (only in debug builds)
    #[cfg(debug_assertions)]
    env_logger::init();

    let cli = match parse_cli_args() {
        Ok(opts) => opts,
        Err(err) => {
            eprintln!("{err}");
            return Ok(());
        }
    };

    let screenshot_enabled = cli.screenshot;
    let resolved_theme = if screenshot_enabled {
        Some(cli.theme.unwrap_or(ThemeChoice::Light))
    } else {
        cli.theme
    };
    let screenshot_zoom = cli.zoom.unwrap_or(1.0);

    let default_width = if screenshot_enabled { 1280.0 } else { 1000.0 };
    let default_height = if screenshot_enabled { 720.0 } else { 700.0 };
    let window_width = cli.width.unwrap_or(default_width);
    let window_height = cli.height.unwrap_or(default_height);

    // Set up eframe options for the native window
    let mut viewport = egui::ViewportBuilder::default()
        .with_title(format!("{APP_TITLE_PREFIX} - A Simple Markdown Viewer"))
        .with_inner_size(egui::Vec2::new(window_width, window_height))
        .with_min_inner_size(egui::Vec2::new(
            if screenshot_enabled { 100.0 } else { 600.0 },
            if screenshot_enabled { 100.0 } else { 400.0 },
        ))
        .with_icon(create_app_icon())
        .with_resizable(!screenshot_enabled)
        .with_maximize_button(!screenshot_enabled)
        .with_minimize_button(!screenshot_enabled)
        .with_drag_and_drop(!screenshot_enabled);

    // Restore previous window position/size if available
    if !screenshot_enabled {
        if let Some(ws) = load_window_state() {
            if let Some(ws) = sanitize_window_state(ws) {
                viewport = viewport
                    .with_inner_size(egui::Vec2::new(ws.size[0], ws.size[1]))
                    .with_position(egui::pos2(ws.pos[0], ws.pos[1]))
                    .with_maximized(ws.maximized);
            }
        }
    }

    let native_options = eframe::NativeOptions {
        viewport,
        // Disable eframe's built-in window persistence - we handle it ourselves via
        // load_window_state/save_window_state to avoid conflicts
        persist_window: false,
        ..Default::default()
    };

    let initial_file = cli.initial_file.clone();
    let test_fonts = cli.test_fonts.clone();
    let screenshot_config = if screenshot_enabled {
        let theme = match resolved_theme.unwrap_or(ThemeChoice::Light) {
            ThemeChoice::Light => ScreenshotTheme::Light,
            ThemeChoice::Dark => ScreenshotTheme::Dark,
        };
        Some(ScreenshotConfig {
            output_path: cli
                .screenshot_output
                .clone()
                .expect("screenshot output required"),
            viewport_width: window_width,
            viewport_height: window_height,
            content_only: cli.content_only,
            scroll_ratio: cli.scroll,
            wait_ms: cli.wait_ms.unwrap_or(2000),
            settle_frames: cli.settle_frames.unwrap_or(3),
            zoom: screenshot_zoom,
            theme,
            font_source: test_fonts
                .as_ref()
                .map(|path| path.to_string_lossy().to_string()),
        })
    } else {
        None
    };

    // Launch the application
    eframe::run_native(
        APP_TITLE_PREFIX,
        native_options,
        Box::new(move |cc| {
            if let Some(theme) = resolved_theme {
                let mut visuals = match theme {
                    ThemeChoice::Light => egui::Visuals::light(),
                    ThemeChoice::Dark => egui::Visuals::dark(),
                };
                if screenshot_enabled {
                    let bg = screenshot_background_color();
                    visuals.panel_fill = bg;
                    visuals.window_fill = bg;
                    visuals.extreme_bg_color = bg;
                    visuals.faint_bg_color = bg;
                }
                cc.egui_ctx.set_visuals(visuals);
            }

            // Configure egui styling for better markdown display
            configure_egui_style(&cc.egui_ctx);
            if let Some(font_dir) = test_fonts.as_ref() {
                if let Err(err) = load_fonts_from_dir(&cc.egui_ctx, font_dir) {
                    eprintln!("{err}");
                }
            }

            let mut app = MarkdownViewerApp::new();
            if screenshot_zoom != 1.0 {
                app.set_zoom_scale(screenshot_zoom);
            }
            if let Some(config) = screenshot_config {
                app.set_screenshot_mode(config);
            }

            // Load initial file if provided via command line
            if let Some(file_path) = initial_file {
                if file_path.exists() && file_path.is_file() {
                    if let Err(e) = app.load_file(file_path, true) {
                        eprintln!("Failed to load file: {}", e);
                        // Continue with default welcome screen
                    }
                } else {
                    eprintln!("File not found: {}", file_path.display());
                    // Continue with default welcome screen
                }
            }

            Box::new(app)
        }),
    )
}

#[cfg(test)]
fn main() {}

/// Create an application icon from embedded data
fn create_app_icon() -> egui::IconData {
    // Create a 32x32 markdown-style document icon
    let size = 32;
    let mut rgba_data = Vec::with_capacity(size * size * 4);

    for y in 0..size {
        for x in 0..size {
            let (r, g, b, a) = if x == 0 || x == size - 1 || y == 0 || y == size - 1 {
                // Border
                (60, 60, 60, 255)
            } else if x == 1 || x == size - 2 || y == 1 || y == size - 2 {
                // Inner border for depth
                (80, 80, 80, 255)
            } else if (4..=8).contains(&y) && (4..=28).contains(&x) {
                // Header area (title bar)
                if (6..=12).contains(&x) {
                    (100, 150, 255, 255) // Blue for # header
                } else if (14..=26).contains(&x) {
                    (200, 200, 200, 255) // Light text
                } else {
                    (250, 250, 250, 255) // Background
                }
            } else if (11..=13).contains(&y) && (4..=28).contains(&x) {
                // Text line 1
                if (6..=8).contains(&x) {
                    (150, 150, 150, 255) // Bullet point
                } else if (10..=24).contains(&x) {
                    (180, 180, 180, 255) // Text
                } else {
                    (250, 250, 250, 255) // Background
                }
            } else if (15..=17).contains(&y) && (4..=28).contains(&x) {
                // Text line 2
                if (6..=8).contains(&x) {
                    (150, 150, 150, 255) // Bullet point
                } else if (10..=22).contains(&x) {
                    (180, 180, 180, 255) // Text
                } else {
                    (250, 250, 250, 255) // Background
                }
            } else if (20..=22).contains(&y) && (6..=26).contains(&x) {
                // Code block area
                if (8..=24).contains(&x) {
                    (100, 255, 100, 255) // Green code text
                } else {
                    (40, 40, 40, 255) // Dark background
                }
            } else if (25..=27).contains(&y) && (4..=28).contains(&x) {
                // Text line 3
                if (6..=20).contains(&x) {
                    (180, 180, 180, 255) // Text
                } else {
                    (250, 250, 250, 255) // Background
                }
            } else {
                // Document background
                (250, 250, 250, 255)
            };

            rgba_data.extend_from_slice(&[r, g, b, a]);
        }
    }

    egui::IconData {
        rgba: rgba_data,
        width: size as u32,
        height: size as u32,
    }
}

/// Configure egui styling for optimal markdown display
fn configure_egui_style(ctx: &egui::Context) {
    let mut style = (*ctx.style()).clone();

    // Configure spacing for better readability
    style.spacing.item_spacing = egui::Vec2::new(8.0, 8.0);
    style.spacing.window_margin = egui::Margin::same(8.0);
    style.spacing.menu_margin = egui::Margin::same(6.0);

    // Configure interaction settings
    style.interaction.resize_grab_radius_side = 8.0;
    style.interaction.resize_grab_radius_corner = 12.0;

    // Configure visuals for better contrast with black background
    style.visuals.window_rounding = egui::Rounding::same(4.0);
    style.visuals.menu_rounding = egui::Rounding::same(4.0);

    // Set to true black background for maximum contrast
    if style.visuals.dark_mode {
        style.visuals.window_fill = egui::Color32::BLACK;
        style.visuals.panel_fill = egui::Color32::BLACK;
        style.visuals.faint_bg_color = egui::Color32::from_gray(20);
        style.visuals.extreme_bg_color = egui::Color32::BLACK;
        // The text color will be handled by egui's theme system
    }

    ctx.set_style(style);

    // Use default fonts - egui has good built-in font support
    // Custom fonts could be added here if needed
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;
    use std::sync::{Mutex, OnceLock};

    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
        ENV_LOCK
            .get_or_init(|| Mutex::new(()))
            .lock()
            .expect("env lock")
    }

    struct EnvGuard {
        key: &'static str,
        original: Option<String>,
        _lock: std::sync::MutexGuard<'static, ()>,
    }

    impl EnvGuard {
        fn set(key: &'static str, value: &str) -> Self {
            let lock = env_lock();
            let original = std::env::var(key).ok();
            std::env::set_var(key, value);
            Self {
                key,
                original,
                _lock: lock,
            }
        }

        fn unset(key: &'static str) -> Self {
            let lock = env_lock();
            let original = std::env::var(key).ok();
            std::env::remove_var(key);
            Self {
                key,
                original,
                _lock: lock,
            }
        }
    }

    impl Drop for EnvGuard {
        fn drop(&mut self) {
            if let Some(prev) = &self.original {
                std::env::set_var(self.key, prev);
            } else {
                std::env::remove_var(self.key);
            }
        }
    }

    #[test]
    fn test_app_icon_creation() {
        let icon = create_app_icon();
        assert_eq!(icon.width, 32);
        assert_eq!(icon.height, 32);
        assert_eq!(icon.rgba.len(), 32 * 32 * 4); // RGBA format
    }

    #[test]
    fn test_main_function_setup() {
        // Test that the main function components work
        // This is a basic smoke test
        let icon = create_app_icon();
        assert!(!icon.rgba.is_empty());
    }

    #[test]
    fn test_configure_egui_style_dark_mode() {
        let ctx = egui::Context::default();
        let mut style = (*ctx.style()).clone();
        style.visuals.dark_mode = true;
        ctx.set_style(style);

        configure_egui_style(&ctx);

        let style = ctx.style();
        assert_eq!(style.spacing.item_spacing, egui::Vec2::new(8.0, 8.0));
        assert_eq!(style.spacing.window_margin, egui::Margin::same(8.0));
        assert_eq!(style.spacing.menu_margin, egui::Margin::same(6.0));
        assert_eq!(style.visuals.window_rounding, egui::Rounding::same(4.0));
        assert_eq!(style.visuals.menu_rounding, egui::Rounding::same(4.0));
        assert_eq!(style.visuals.window_fill, egui::Color32::BLACK);
        assert_eq!(style.visuals.panel_fill, egui::Color32::BLACK);
        assert_eq!(style.visuals.faint_bg_color, egui::Color32::from_gray(20));
        assert_eq!(style.visuals.extreme_bg_color, egui::Color32::BLACK);
    }

    #[test]
    fn test_configure_egui_style_light_mode() {
        let ctx = egui::Context::default();
        let mut style = (*ctx.style()).clone();
        style.visuals.dark_mode = false;
        style.visuals.window_fill = egui::Color32::from_rgb(1, 2, 3);
        style.visuals.panel_fill = egui::Color32::from_rgb(4, 5, 6);
        style.visuals.faint_bg_color = egui::Color32::from_rgb(7, 8, 9);
        style.visuals.extreme_bg_color = egui::Color32::from_rgb(10, 11, 12);
        ctx.set_style(style);

        configure_egui_style(&ctx);

        let style = ctx.style();
        assert_eq!(style.spacing.item_spacing, egui::Vec2::new(8.0, 8.0));
        assert_eq!(style.spacing.window_margin, egui::Margin::same(8.0));
        assert_eq!(style.spacing.menu_margin, egui::Margin::same(6.0));
        assert_eq!(style.visuals.window_rounding, egui::Rounding::same(4.0));
        assert_eq!(style.visuals.menu_rounding, egui::Rounding::same(4.0));
        assert_eq!(style.visuals.window_fill, egui::Color32::from_rgb(1, 2, 3));
        assert_eq!(style.visuals.panel_fill, egui::Color32::from_rgb(4, 5, 6));
        assert_eq!(
            style.visuals.faint_bg_color,
            egui::Color32::from_rgb(7, 8, 9)
        );
        assert_eq!(
            style.visuals.extreme_bg_color,
            egui::Color32::from_rgb(10, 11, 12)
        );
    }

    #[test]
    fn test_parse_cli_sets_initial_file_from_arg() {
        let opts = parse_cli_from(vec!["readme.md".to_string()]).expect("parse");
        assert_eq!(opts.initial_file, Some(PathBuf::from("readme.md")));
    }

    #[test]
    fn test_parse_cli_screenshot_args() {
        let args = vec![
            "--screenshot".to_string(),
            "doc.md".to_string(),
            "--output".to_string(),
            "out.png".to_string(),
            "--width".to_string(),
            "800".to_string(),
            "--height".to_string(),
            "600".to_string(),
            "--theme".to_string(),
            "dark".to_string(),
            "--scroll".to_string(),
            "0.5".to_string(),
        ];
        let opts = parse_cli_from(args).expect("parse");
        assert!(opts.screenshot);
        assert_eq!(opts.initial_file, Some(PathBuf::from("doc.md")));
        assert_eq!(opts.screenshot_output, Some(PathBuf::from("out.png")));
        assert_eq!(opts.width, Some(800.0));
        assert_eq!(opts.height, Some(600.0));
        assert_eq!(opts.theme, Some(ThemeChoice::Dark));
        assert_eq!(opts.scroll, Some(0.5));
    }

    #[test]
    fn test_parse_cli_missing_screenshot_input() {
        let args = vec!["--screenshot".to_string()];
        let err = parse_cli_from(args)
            .err()
            .expect("expected missing screenshot input error");
        assert!(err.contains("--screenshot requires a value"));
    }

    #[test]
    fn test_parse_cli_missing_screenshot_output() {
        let args = vec!["--screenshot".to_string(), "doc.md".to_string()];
        let err = parse_cli_from(args)
            .err()
            .expect("expected missing output error");
        assert!(err.contains("Missing --output"));
    }

    #[test]
    fn test_parse_cli_invalid_values() {
        let args = vec!["--width".to_string(), "nope".to_string()];
        let err = parse_cli_from(args)
            .err()
            .expect("expected invalid width error");
        assert!(err.contains("Invalid --width"));

        let args = vec!["--height".to_string(), "nope".to_string()];
        let err = parse_cli_from(args)
            .err()
            .expect("expected invalid height error");
        assert!(err.contains("Invalid --height"));

        let args = vec!["--zoom".to_string(), "nope".to_string()];
        let err = parse_cli_from(args)
            .err()
            .expect("expected invalid zoom error");
        assert!(err.contains("Invalid --zoom"));

        let args = vec!["--scroll".to_string(), "nope".to_string()];
        let err = parse_cli_from(args)
            .err()
            .expect("expected invalid scroll error");
        assert!(err.contains("Invalid --scroll"));

        let args = vec!["--wait-ms".to_string(), "nope".to_string()];
        let err = parse_cli_from(args)
            .err()
            .expect("expected invalid wait-ms error");
        assert!(err.contains("Invalid --wait-ms"));

        let args = vec!["--settle-frames".to_string(), "nope".to_string()];
        let err = parse_cli_from(args)
            .err()
            .expect("expected invalid settle-frames error");
        assert!(err.contains("Invalid --settle-frames"));

        let args = vec!["--theme".to_string(), "blue".to_string()];
        let err = parse_cli_from(args)
            .err()
            .expect("expected invalid theme error");
        assert!(err.contains("Unsupported theme"));
    }

    #[test]
    fn test_parse_cli_missing_flag_values() {
        let flags = [
            "--output",
            "--width",
            "--height",
            "--theme",
            "--zoom",
            "--scroll",
            "--wait-ms",
            "--settle-frames",
            "--test-fonts",
        ];
        for flag in flags {
            let err = parse_cli_from(vec![flag.to_string()])
                .err()
                .expect("expected missing flag value error");
            assert!(err.contains(&format!("{flag} requires a value")));
        }
    }

    #[test]
    fn test_parse_cli_scroll_clamps() {
        let args = vec![
            "--scroll".to_string(),
            "2.5".to_string(),
            "doc.md".to_string(),
        ];
        let opts = parse_cli_from(args).expect("parse");
        assert_eq!(opts.scroll, Some(1.0));
        assert_eq!(opts.initial_file, Some(PathBuf::from("doc.md")));
    }

    #[test]
    fn test_parse_cli_additional_flags() {
        let args = vec![
            "--screenshot".to_string(),
            "doc.md".to_string(),
            "--output".to_string(),
            "out.png".to_string(),
            "--content-only".to_string(),
            "--wait-ms".to_string(),
            "1200".to_string(),
            "--settle-frames".to_string(),
            "3".to_string(),
            "--zoom".to_string(),
            "1.5".to_string(),
            "--theme".to_string(),
            "light".to_string(),
            "--test-fonts".to_string(),
            "fonts".to_string(),
        ];
        let opts = parse_cli_from(args).expect("parse");
        assert!(opts.screenshot);
        assert!(opts.content_only);
        assert_eq!(opts.wait_ms, Some(1200));
        assert_eq!(opts.settle_frames, Some(3));
        assert_eq!(opts.zoom, Some(1.5));
        assert_eq!(opts.theme, Some(ThemeChoice::Light));
        assert_eq!(opts.test_fonts, Some(PathBuf::from("fonts")));
    }

    #[test]
    fn test_parse_cli_ignores_extra_args() {
        let args = vec!["doc.md".to_string(), "extra.md".to_string()];
        let opts = parse_cli_from(args).expect("parse");
        assert_eq!(opts.initial_file, Some(PathBuf::from("doc.md")));
    }

    #[test]
    fn test_parse_hex_color32() {
        let color = parse_hex_color32("#FFF8DB").expect("color");
        assert_eq!(color, egui::Color32::from_rgb(255, 248, 219));
        assert!(parse_hex_color32("#XYZ").is_none());
        assert!(parse_hex_color32("#GG0000").is_none());
        assert!(parse_hex_color32("#00GG00").is_none());
        assert!(parse_hex_color32("#0000GG").is_none());
    }

    #[test]
    fn test_parse_unsigned_helpers() {
        assert_eq!(parse_u32("--width", "12").expect("u32"), 12);
        assert!(parse_u32("--width", "nope").is_err());
        assert_eq!(parse_u64("--timeout", "42").expect("u64"), 42);
        assert!(parse_u64("--timeout", "-1").is_err());
    }

    #[test]
    fn test_screenshot_background_color_env() {
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "#112233");
            let color = screenshot_background_color();
            assert_eq!(color, egui::Color32::from_rgb(17, 34, 51));
        }
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "bad");
            let color = screenshot_background_color();
            assert_eq!(color, egui::Color32::from_rgb(255, 248, 219));
        }
    }

    #[test]
    fn test_screenshot_background_color_default_when_unset() {
        let _guard = EnvGuard::unset("MDMDVIEW_MERMAID_MAIN_BKG");
        let color = screenshot_background_color();
        assert_eq!(color, egui::Color32::from_rgb(255, 248, 219));
    }

    #[test]
    fn test_env_guard_restores_previous_value() {
        let key = "MDMDVIEW_MERMAID_MAIN_BKG";
        let _lock = env_lock();
        std::env::set_var(key, "preexisting");
        let previous = std::env::var(key).ok();
        {
            std::env::set_var(key, "orig");
            let guard = EnvGuard {
                key,
                original: Some("orig".to_string()),
                _lock,
            };
            std::env::set_var(key, "new");
            drop(guard);
        }
        assert_eq!(std::env::var(key).ok().as_deref(), Some("orig"));
        let _lock = env_lock();
        for previous in [previous, None] {
            match previous {
                Some(value) => std::env::set_var(key, value),
                None => std::env::remove_var(key),
            }
        }
        let missing_key = "MDMDVIEW_MERMAID_MAIN_BKG_MISSING";
        std::env::remove_var(missing_key);
        let previous = std::env::var(missing_key).ok();
        for previous in [previous, Some("temp".to_string())] {
            match previous {
                Some(value) => std::env::set_var(missing_key, value),
                None => std::env::remove_var(missing_key),
            }
        }
    }

    #[test]
    fn test_env_guard_drop_removes_unset_key() {
        let key = "MDMDVIEW_MERMAID_MAIN_BKG";
        std::env::remove_var(key);
        {
            let _guard = EnvGuard::unset(key);
            std::env::set_var(key, "temp");
        }
        assert!(std::env::var(key).is_err());
    }

    #[test]
    fn test_main_stub_executes() {
        super::main();
    }
}


----------------------------------------

File: src\markdown_renderer.rs

use crate::image_decode;
use crate::mermaid_renderer::MermaidRenderer;
use crate::table_support::{
    compute_column_stats, derive_column_specs, ColumnPolicy, ColumnSpec, ColumnStat,
    TableColumnContext, TableMetrics, WidthChange,
};
use crate::{emoji_assets, emoji_catalog};
use anyhow::Result;
use crossbeam_channel::{bounded, Receiver, Sender, TrySendError};
use egui::{
    text::{Galley, LayoutJob, TextWrapping},
    Align, Color32, Context, FontSelection, Painter, RichText, Stroke, Vec2, Visuals,
};
use egui_extras::{Column, TableBuilder};
use pulldown_cmark::{Alignment, Event, LinkType, Options, Parser, Tag};
use std::cell::{Cell, RefCell};
use std::collections::{hash_map::DefaultHasher, HashMap, HashSet, VecDeque};
use std::hash::{Hash, Hasher};
use std::ops::Range;
use std::path::{Path, PathBuf};
#[cfg(test)]
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant, SystemTime};
use syntect::easy::HighlightLines;
use syntect::highlighting::ThemeSet;
use syntect::parsing::SyntaxSet;
use syntect::util::LinesWithEndings;
use unicode_casefold::UnicodeCaseFold;
use unicode_normalization::UnicodeNormalization;
use unicode_segmentation::UnicodeSegmentation;

#[derive(Clone, Copy, Default)]
struct InlineStyle {
    strong: bool,
    italics: bool,
    strike: bool,
    color: Option<Color32>,
}

#[cfg(test)]
thread_local! {
    static FORCED_RENDER_ACTIONS: RefCell<HashSet<&'static str>> = RefCell::new(HashSet::new());
    static FORCED_TABLE_POLICIES: RefCell<Option<Vec<ColumnPolicy>>> = const { RefCell::new(None) };
    static FORCED_PARSE_ERROR: RefCell<bool> = const { RefCell::new(false) };
}

#[cfg(test)]
static FORCE_THREAD_SPAWN_ERROR: AtomicBool = AtomicBool::new(false);

#[cfg(test)]
static FORCE_EMOJI_DECODE_ERROR: AtomicBool = AtomicBool::new(false);

#[cfg(test)]
fn render_action_triggered(triggered: bool, action: &'static str) -> bool {
    triggered || FORCED_RENDER_ACTIONS.with(|actions| actions.borrow().contains(action))
}

#[cfg(not(test))]
fn render_action_triggered(triggered: bool, _action: &'static str) -> bool {
    triggered
}

#[cfg(test)]
fn take_forced_table_policies() -> Option<Vec<ColumnPolicy>> {
    FORCED_TABLE_POLICIES.with(|policies| policies.borrow_mut().take())
}

#[cfg(test)]
pub(crate) fn force_parse_error_once() {
    FORCED_PARSE_ERROR.with(|flag| flag.replace(true));
}

#[cfg(test)]
fn force_emoji_decode_error_once() {
    FORCE_EMOJI_DECODE_ERROR.store(true, Ordering::Relaxed);
}

#[cfg(test)]
fn take_forced_parse_error() -> bool {
    FORCED_PARSE_ERROR.with(|flag| flag.replace(false))
}

/// Font size configuration
#[derive(Debug, Clone)]
pub struct FontSizes {
    pub body: f32,
    pub h1: f32,
    pub h2: f32,
    pub h3: f32,
    pub h4: f32,
    pub h5: f32,
    pub h6: f32,
    pub code: f32,
}

impl Default for FontSizes {
    fn default() -> Self {
        Self {
            body: 14.0,
            h1: 28.0,
            h2: 24.0,
            h3: 20.0,
            h4: 18.0,
            h5: 16.0,
            h6: 14.0,
            code: 12.0,
        }
    }
}

/// Represents an inline text span with formatting
#[derive(Debug, Clone)]
pub enum InlineSpan {
    Text(String),
    Code(String),
    Strong(String),
    Emphasis(String),
    Strikethrough(String),
    Link {
        text: String,
        url: String,
    },
    Image {
        src: String,
        alt: String,
        title: Option<String>,
    },
}

#[cfg_attr(not(test), allow(dead_code))]
#[derive(Debug, Clone)]
enum CellFragment<'a> {
    Text(&'a [InlineSpan]),
    Emoji(String),
    Image(&'a InlineSpan),
}

#[cfg_attr(not(test), allow(dead_code))]
#[derive(Debug, Clone)]
struct LayoutJobBuild {
    job: LayoutJob,
    #[allow(dead_code)]
    plain_text: String,
    #[cfg_attr(not(test), allow(dead_code))]
    link_ranges: Vec<LinkRange>,
}

#[cfg_attr(not(test), allow(dead_code))]
#[derive(Debug, Clone)]
struct LinkRange {
    char_range: Range<usize>,
    url: String,
}

const TABLE_LAYOUT_CACHE_CAPACITY: usize = 512;
const COLUMN_STATS_SAMPLE_ROWS: usize = 128;
const PIPE_SENTINEL: char = '\u{1F}';
const IMAGE_TEXTURE_CACHE_CAPACITY: usize = 256;
const IMAGE_MAX_PENDING: usize = 64;
const IMAGE_FAILURE_BACKOFF: Duration = Duration::from_secs(5);

#[derive(Debug, Clone, Hash, PartialEq, Eq)]
struct CellLayoutKey {
    row: Option<usize>,
    col: usize,
    width: u32,
    align: u8,
    strong: bool,
    text_color: [u8; 4],
    highlight_hash: u64,
    content_hash: u64,
}

struct CellLayoutCache {
    entries: HashMap<CellLayoutKey, LayoutJobBuild>,
    order: VecDeque<CellLayoutKey>,
    hits: u64,
    misses: u64,
    capacity: usize,
}

#[derive(Clone)]
struct ColumnStatsCacheEntry {
    content_hash: u64,
    stats: Vec<ColumnStat>,
}

impl CellLayoutCache {
    fn new(capacity: usize) -> Self {
        Self {
            entries: HashMap::new(),
            order: VecDeque::new(),
            hits: 0,
            misses: 0,
            capacity,
        }
    }

    fn get(&mut self, key: &CellLayoutKey) -> Option<LayoutJobBuild> {
        if let Some(build) = self.entries.get(key) {
            self.hits += 1;
            Some(build.clone())
        } else {
            self.misses += 1;
            None
        }
    }

    fn insert(&mut self, key: CellLayoutKey, build: LayoutJobBuild) {
        if self.entries.len() >= self.capacity && !self.entries.contains_key(&key) {
            while self.entries.len() >= self.capacity {
                if let Some(old) = self.order.pop_front() {
                    self.entries.remove(&old);
                } else {
                    break;
                }
            }
        }
        self.order.retain(|existing| existing != &key);
        self.order.push_back(key.clone());
        self.entries.insert(key, build);
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.order.clear();
        self.hits = 0;
        self.misses = 0;
    }

    fn stats(&self) -> (u64, u64) {
        (self.hits, self.misses)
    }
}

#[derive(Debug, Clone)]
pub struct ListItem {
    pub blocks: Vec<MarkdownElement>,
}

/// Represents a rendered markdown element
#[derive(Debug, Clone)]
pub enum MarkdownElement {
    Paragraph(Vec<InlineSpan>),
    Header {
        level: u8,
        spans: Vec<InlineSpan>,
        id: String,
    },
    CodeBlock {
        language: Option<String>,
        text: String,
    },
    List {
        ordered: bool,
        items: Vec<ListItem>,
    }, // List items can contain block elements
    Quote {
        depth: u8,
        blocks: Vec<MarkdownElement>,
    },
    HorizontalRule,
    Table {
        headers: Vec<Vec<InlineSpan>>,   // header cells as inline spans
        rows: Vec<Vec<Vec<InlineSpan>>>, // rows -> cells -> spans
        alignments: Vec<Alignment>,
    },
}

/// Type alias for table parsing result
type TableParseResult = (Vec<Vec<InlineSpan>>, Vec<Vec<Vec<InlineSpan>>>, usize);

/// Type alias for quote blocks (nested markdown elements)
type QuoteBlocks = Vec<MarkdownElement>;

#[derive(Clone)]
struct ImageCacheEntry {
    texture: egui::TextureHandle,
    size: [u32; 2],
    modified: Option<SystemTime>,
}

struct ImageCache {
    entries: HashMap<String, ImageCacheEntry>,
    order: VecDeque<String>,
    capacity: usize,
}

impl ImageCache {
    fn new(capacity: usize) -> Self {
        Self {
            entries: HashMap::new(),
            order: VecDeque::new(),
            capacity: capacity.max(1),
        }
    }

    fn get(&mut self, key: &str) -> Option<ImageCacheEntry> {
        let entry = self.entries.get(key).cloned();
        if entry.is_some() {
            self.touch(key);
        }
        entry
    }

    fn insert(&mut self, key: String, entry: ImageCacheEntry) {
        if self.entries.contains_key(&key) {
            self.entries.insert(key.clone(), entry);
            self.touch(&key);
            return;
        }
        while self.entries.len() >= self.capacity {
            if let Some(old) = self.order.pop_front() {
                self.entries.remove(&old);
            } else {
                break;
            }
        }
        self.order.push_back(key.clone());
        self.entries.insert(key, entry);
    }

    fn remove(&mut self, key: &str) {
        self.entries.remove(key);
        self.order.retain(|entry| entry != key);
    }

    #[cfg(test)]
    fn contains_key(&self, key: &str) -> bool {
        self.entries.contains_key(key)
    }

    fn touch(&mut self, key: &str) {
        self.order.retain(|entry| entry != key);
        self.order.push_back(key.to_string());
    }
}

struct ImageFailure {
    last_attempt: Instant,
}

enum ImageLoadSource {
    Embedded(&'static [u8]),
    File(PathBuf),
}

struct ImageLoadRequest {
    key: String,
    source: ImageLoadSource,
}

enum ImageLoadResult {
    Loaded {
        key: String,
        image: egui::ColorImage,
        size: [u32; 2],
        modified: Option<SystemTime>,
    },
    Failed {
        key: String,
    },
}

/// Markdown renderer with proper inline element handling
pub struct MarkdownRenderer {
    font_sizes: FontSizes,
    syntax_set: SyntaxSet,
    theme_set: ThemeSet,
    emoji_textures: RefCell<HashMap<String, egui::TextureHandle>>,
    image_textures: RefCell<ImageCache>,
    image_pending: RefCell<HashSet<String>>,
    image_failures: RefCell<HashMap<String, ImageFailure>>,
    image_job_tx: Sender<ImageLoadRequest>,
    image_result_rx: Receiver<ImageLoadResult>,
    // Mapping of header id -> last rendered rect (for in-document navigation)
    header_rects: RefCell<HashMap<String, egui::Rect>>,
    // Last clicked internal anchor (e.g., "getting-started") for the app to consume
    pending_anchor: RefCell<Option<String>>,
    // Unique counter to avoid egui Id collisions for repeated links
    link_counter: RefCell<u64>,
    // Per-frame table counter to build stable table ids in render order
    table_counter: RefCell<u64>,
    // Per-frame rect for each top-level element in render order
    element_rects: RefCell<Vec<egui::Rect>>,
    // Optional highlight phrase (lowercased) for in-text highlighting
    highlight_phrase: RefCell<Option<String>>,
    // Cache for image/diagram textures
    // Base directory used to resolve relative image paths
    base_dir: RefCell<Option<PathBuf>>,
    mermaid: MermaidRenderer,
    table_layout_cache: RefCell<CellLayoutCache>,
    table_metrics: RefCell<TableMetrics>,
    column_stats_cache: RefCell<HashMap<u64, ColumnStatsCacheEntry>>,
}

impl Default for MarkdownRenderer {
    fn default() -> Self {
        Self::new()
    }
}

impl MarkdownRenderer {
    #[cfg_attr(not(test), allow(dead_code))]
    fn cell_fragments<'a>(&'a self, spans: &'a [InlineSpan]) -> Vec<CellFragment<'a>> {
        if let Some(emoji) = self.cell_single_emoji(spans) {
            return vec![CellFragment::Emoji(emoji)];
        }
        let mut fragments = Vec::new();
        let mut run_start: Option<usize> = None;
        let flush_run =
            |start: &mut Option<usize>, end: usize, fragments: &mut Vec<CellFragment<'a>>| {
                if let Some(run_begin) = start.take() {
                    fragments.push(CellFragment::Text(&spans[run_begin..end]));
                }
            };

        for (idx, span) in spans.iter().enumerate() {
            if matches!(span, InlineSpan::Image { .. }) {
                flush_run(&mut run_start, idx, &mut fragments);
                fragments.push(CellFragment::Image(span));
                continue;
            }

            if run_start.is_none() {
                run_start = Some(idx);
            }
        }

        if let Some(start) = run_start {
            fragments.push(CellFragment::Text(&spans[start..]));
        }

        fragments
    }

    fn cell_single_emoji(&self, spans: &[InlineSpan]) -> Option<String> {
        let mut text = String::new();
        for span in spans {
            match span {
                InlineSpan::Text(t)
                | InlineSpan::Strong(t)
                | InlineSpan::Emphasis(t)
                | InlineSpan::Strikethrough(t) => text.push_str(t),
                InlineSpan::Code(_) | InlineSpan::Link { .. } | InlineSpan::Image { .. } => {
                    return None;
                }
            }
        }

        let trimmed = text.trim();
        let mut graphemes = trimmed.graphemes(true);
        let first = graphemes.next()?;
        if graphemes.next().is_some() {
            return None;
        }
        self.emoji_key_for_grapheme(first)
    }

    fn highlight_segments(&self, text: &str, highlight: Option<&str>) -> Vec<(Range<usize>, bool)> {
        if text.is_empty() {
            return Vec::new();
        }
        let Some(needle) = highlight.filter(|h| !h.is_empty()) else {
            return vec![(0..text.len(), false)];
        };

        let mut folded = String::new();
        let mut folded_to_char: Vec<usize> = Vec::new();
        let mut char_ranges: Vec<(usize, usize)> = Vec::new();
        for (char_idx, (byte_idx, ch)) in text.char_indices().enumerate() {
            let folded_piece: String = ch.to_string().case_fold().nfkc().collect();
            let before = folded.len();
            folded.push_str(&folded_piece);
            let after = folded.len();
            for _ in before..after {
                folded_to_char.push(char_idx);
            }
            char_ranges.push((byte_idx, byte_idx + ch.len_utf8()));
        }

        let mut segments = Vec::new();
        let mut rendered_until = 0usize;
        let mut search_at = 0usize;
        while let Some(pos) = folded[search_at..].find(needle) {
            let abs = search_at + pos;
            let start_char_idx = folded_to_char[abs];
            let (start_byte, _) = char_ranges[start_char_idx];
            if start_byte > rendered_until {
                segments.push((rendered_until..start_byte, false));
            }
            let match_end = abs + needle.len();
            let end_char_idx = folded_to_char[match_end.saturating_sub(1)];
            let (_, end_byte) = char_ranges[end_char_idx];
            segments.push((start_byte..end_byte, true));
            rendered_until = end_byte;
            search_at = match_end;
        }

        if rendered_until < text.len() {
            segments.push((rendered_until..text.len(), false));
        }

        segments
    }

    #[cfg_attr(not(test), allow(dead_code))]
    fn build_layout_job(
        &self,
        style: &egui::Style,
        spans: &[InlineSpan],
        wrap_width: f32,
        strong_override: bool,
        halign: Align,
    ) -> LayoutJobBuild {
        let mut job = LayoutJob {
            wrap: TextWrapping {
                max_width: wrap_width.max(1.0),
                ..Default::default()
            },
            break_on_newline: true,
            halign,
            ..Default::default()
        };

        let highlight = self
            .highlight_phrase
            .borrow()
            .clone()
            .filter(|s| !s.is_empty());

        let mut plain_text = String::new();
        let mut link_ranges = Vec::new();
        let mut job_char_offset = 0usize;

        for span in spans {
            match span {
                InlineSpan::Image { .. } => {}
                InlineSpan::Code(code) => {
                    job_char_offset +=
                        self.append_code_span(style, &mut job, &mut plain_text, code);
                }
                InlineSpan::Link { text, url } => {
                    let inline_style = InlineStyle {
                        strong: strong_override,
                        color: Some(if Self::is_external_url(url) {
                            Color32::from_rgb(120, 190, 255)
                        } else {
                            Color32::LIGHT_BLUE
                        }),
                        ..Default::default()
                    };
                    let mut normalized = self.fix_unicode_chars(text);
                    normalized = Self::expand_shortcodes(&normalized);
                    normalized = Self::expand_superscripts(&normalized);
                    let appended = self.append_text_sections(
                        style,
                        &mut job,
                        &mut plain_text,
                        &normalized,
                        self.font_sizes.body,
                        inline_style,
                        highlight.as_deref(),
                    );
                    if appended > 0 {
                        let start_char = job_char_offset;
                        job_char_offset += appended;
                        link_ranges.push(LinkRange {
                            char_range: start_char..job_char_offset,
                            url: url.clone(),
                        });
                    }
                }
                InlineSpan::Strong(text) => {
                    job_char_offset += self.append_plain_span(
                        style,
                        &mut job,
                        &mut plain_text,
                        text,
                        InlineStyle {
                            strong: true,
                            ..Default::default()
                        },
                        highlight.as_deref(),
                    );
                }
                InlineSpan::Emphasis(text) => {
                    job_char_offset += self.append_plain_span(
                        style,
                        &mut job,
                        &mut plain_text,
                        text,
                        InlineStyle {
                            italics: true,
                            strong: strong_override,
                            ..Default::default()
                        },
                        highlight.as_deref(),
                    );
                }
                InlineSpan::Strikethrough(text) => {
                    job_char_offset += self.append_plain_span(
                        style,
                        &mut job,
                        &mut plain_text,
                        text,
                        InlineStyle {
                            strike: true,
                            strong: strong_override,
                            ..Default::default()
                        },
                        highlight.as_deref(),
                    );
                }
                InlineSpan::Text(text) => {
                    job_char_offset += self.append_plain_span(
                        style,
                        &mut job,
                        &mut plain_text,
                        text,
                        InlineStyle {
                            strong: strong_override,
                            ..Default::default()
                        },
                        highlight.as_deref(),
                    );
                }
            }
        }

        LayoutJobBuild {
            job,
            plain_text,
            link_ranges,
        }
    }

    fn append_plain_span(
        &self,
        style: &egui::Style,
        job: &mut LayoutJob,
        plain_text: &mut String,
        text: &str,
        inline_style: InlineStyle,
        highlight: Option<&str>,
    ) -> usize {
        if text.is_empty() {
            return 0;
        }
        let mut normalized = self.fix_unicode_chars(text);
        normalized = Self::expand_shortcodes(&normalized);
        normalized = Self::expand_superscripts(&normalized);
        self.append_text_sections(
            style,
            job,
            plain_text,
            &normalized,
            self.font_sizes.body,
            inline_style,
            highlight,
        )
    }

    fn append_code_span(
        &self,
        style: &egui::Style,
        job: &mut LayoutJob,
        plain_text: &mut String,
        code: &str,
    ) -> usize {
        if code.is_empty() {
            return 0;
        }
        plain_text.push_str(code);
        let visuals = &style.visuals;
        let (bg, fg) = if visuals.dark_mode {
            (
                Color32::from_rgb(30, 30, 30),
                Color32::from_rgb(180, 255, 180),
            )
        } else {
            (Color32::WHITE, Color32::from_rgb(60, 80, 150))
        };
        let rich = RichText::new(code.to_string())
            .size(self.font_sizes.code)
            .monospace()
            .background_color(bg)
            .color(fg);
        rich.append_to(job, style, FontSelection::Default, Align::LEFT);
        code.chars().count()
    }

    #[allow(clippy::too_many_arguments)]
    fn append_text_sections(
        &self,
        style: &egui::Style,
        job: &mut LayoutJob,
        plain_text: &mut String,
        text: &str,
        font_size: f32,
        inline_style: InlineStyle,
        highlight: Option<&str>,
    ) -> usize {
        if text.is_empty() {
            return 0;
        }
        plain_text.push_str(text);
        let char_count = text.chars().count();
        let visuals = &style.visuals;
        let segments = self.highlight_segments(text, highlight);
        for (range, highlighted) in segments {
            let slice = &text[range];
            let mut rich = RichText::new(slice.to_string()).size(font_size);
            if inline_style.strong {
                rich = rich.strong();
            }
            if inline_style.italics {
                rich = rich.italics();
            }
            if inline_style.strike {
                rich = rich.strikethrough();
            }
            let mut text_color = inline_style.color;
            if highlighted {
                rich = rich.background_color(visuals.selection.bg_fill);
                if text_color.is_none() {
                    text_color = Some(visuals.selection.stroke.color);
                }
            } else if text_color.is_none() && inline_style.strong {
                if let Some(override_color) = visuals.override_text_color {
                    text_color = Some(override_color);
                }
            }
            if let Some(color) = text_color {
                rich = rich.color(color);
            }
            rich.append_to(job, style, FontSelection::Default, Align::LEFT);
        }
        char_count
    }

    /// Create a new markdown renderer
    pub fn new() -> Self {
        let mermaid = MermaidRenderer::new();
        let (image_job_tx, image_job_rx) = bounded(IMAGE_MAX_PENDING.max(1));
        let (image_result_tx, image_result_rx) = bounded(IMAGE_MAX_PENDING.max(1) * 2);
        Self::spawn_image_loader(image_job_rx, image_result_tx);
        Self {
            font_sizes: FontSizes::default(),
            syntax_set: SyntaxSet::load_defaults_newlines(),
            theme_set: ThemeSet::load_defaults(),
            emoji_textures: RefCell::new(HashMap::new()),
            image_textures: RefCell::new(ImageCache::new(IMAGE_TEXTURE_CACHE_CAPACITY)),
            image_pending: RefCell::new(HashSet::new()),
            image_failures: RefCell::new(HashMap::new()),
            image_job_tx,
            image_result_rx,
            header_rects: RefCell::new(HashMap::new()),
            pending_anchor: RefCell::new(None),
            link_counter: RefCell::new(0),
            table_counter: RefCell::new(0),
            element_rects: RefCell::new(Vec::new()),
            highlight_phrase: RefCell::new(None),
            base_dir: RefCell::new(None),
            mermaid,
            table_layout_cache: RefCell::new(CellLayoutCache::new(TABLE_LAYOUT_CACHE_CAPACITY)),
            table_metrics: RefCell::new(TableMetrics::default()),
            column_stats_cache: RefCell::new(HashMap::new()),
        }
    }

    fn spawn_image_loader(job_rx: Receiver<ImageLoadRequest>, result_tx: Sender<ImageLoadResult>) {
        if let Err(err) = Self::spawn_named_thread("mdmdview-image-loader", move || {
            for request in job_rx.iter() {
                let ImageLoadRequest { key, source } = request;
                let result = match source {
                    ImageLoadSource::Embedded(bytes) => {
                        match image_decode::bytes_to_color_image_guess(bytes, None) {
                            Some((image, w, h)) => ImageLoadResult::Loaded {
                                key,
                                image,
                                size: [w, h],
                                modified: None,
                            },
                            None => ImageLoadResult::Failed { key },
                        }
                    }
                    ImageLoadSource::File(path) => {
                        if !path.exists() {
                            ImageLoadResult::Failed { key }
                        } else {
                            match std::fs::read(&path) {
                                Ok(bytes) => {
                                    let modified = Self::disk_image_timestamp(&path);
                                    match image_decode::bytes_to_color_image_guess(&bytes, None) {
                                        Some((image, w, h)) => ImageLoadResult::Loaded {
                                            key,
                                            image,
                                            size: [w, h],
                                            modified,
                                        },
                                        None => ImageLoadResult::Failed { key },
                                    }
                                }
                                Err(_) => ImageLoadResult::Failed { key },
                            }
                        }
                    }
                };
                let _ = result_tx.send(result);
            }
        }) {
            eprintln!("Failed to start image loader thread: {err}");
        }
    }

    fn spawn_named_thread(
        name: &str,
        f: impl FnOnce() + Send + 'static,
    ) -> std::io::Result<std::thread::JoinHandle<()>> {
        #[cfg(test)]
        if FORCE_THREAD_SPAWN_ERROR.swap(false, Ordering::Relaxed) {
            return Err(std::io::Error::other("forced thread spawn failure"));
        }
        std::thread::Builder::new().name(name.to_string()).spawn(f)
    }

    #[cfg(test)]
    fn force_thread_spawn_error_for_test() {
        FORCE_THREAD_SPAWN_ERROR.store(true, Ordering::Relaxed);
    }

    /// UI scale factor derived from body font size relative to default.
    /// Used to scale non-text elements (e.g., images) consistently with zoom.
    fn ui_scale(&self) -> f32 {
        let default_body = FontSizes::default().body;
        (self.font_sizes.body / default_body).clamp(0.5, 4.0)
    }

    /// Get current font sizes
    pub fn font_sizes(&self) -> &FontSizes {
        &self.font_sizes
    }

    fn escape_table_pipes_in_inline_code(markdown: &str) -> String {
        let mut out = String::with_capacity(markdown.len());
        let mut in_table = false;
        let mut table_blockquote_level: Option<usize> = None;
        let mut table_list_indent: Option<usize> = None;
        let mut in_fenced_block = false;
        let mut fence_char = '\0';
        let mut fence_len = 0usize;
        let mut fence_blockquote_level: Option<usize> = None;

        let lines: Vec<&str> = markdown.split_inclusive('\n').collect();
        let mut i = 0;
        while i < lines.len() {
            let line = lines[i];
            let (blockquote_level, rest) = Self::table_line_info(line);
            let list_info = Self::list_marker_info(rest);
            let mut list_indent = list_info.map(|(_, _, content_indent)| content_indent);
            let mut list_stripped = list_info.map(|(content, _, _)| content).unwrap_or(rest);
            let mut list_marker_present = list_info.is_some();
            if !list_marker_present && i > 0 {
                let parent_list_indent =
                    Self::parent_list_indent_for_line(&lines, i, blockquote_level, rest);
                if let Some(parent_indent) = parent_list_indent {
                    if let Some((content, _indent_after, content_indent, leading_spaces)) =
                        Self::list_marker_info_any_indent(rest)
                    {
                        if leading_spaces < parent_indent + 4 {
                            list_marker_present = true;
                            list_indent = Some(content_indent);
                            list_stripped = content;
                        }
                    }
                    if list_indent.is_none() {
                        let code_strip = Self::strip_indent_columns(rest, parent_indent + 4);
                        if code_strip.is_none() {
                            list_indent = Some(parent_indent);
                        }
                    }
                }
            }
            let (fence_line_level, fence_line_rest) = if list_marker_present {
                let (nested_level, nested_rest) = Self::table_line_info(list_stripped);
                (blockquote_level + nested_level, nested_rest)
            } else {
                Self::table_line_info_with_list(line, list_indent)
            };
            let trimmed_fence = fence_line_rest.trim_start();

            if in_fenced_block {
                let fence_end = fence_blockquote_level == Some(fence_line_level)
                    && Self::is_fence_end(trimmed_fence, fence_char, fence_len);
                if fence_end {
                    in_fenced_block = false;
                    fence_char = '\0';
                    fence_len = 0;
                    fence_blockquote_level = None;
                }
                out.push_str(line);
                i += 1;
                continue;
            }

            if let Some((ch, len)) = Self::fence_start(trimmed_fence) {
                in_fenced_block = true;
                fence_char = ch;
                fence_len = len;
                fence_blockquote_level = Some(fence_line_level);
                out.push_str(line);
                i += 1;
                continue;
            }

            if in_table {
                if let Some((level, rest)) = Self::table_line_info_in_list(line, table_list_indent)
                {
                    if table_blockquote_level == Some(level) {
                        let candidate = Some(rest);
                        if candidate.is_some_and(Self::is_table_row_candidate) {
                            out.push_str(&Self::escape_pipes_in_inline_code_line(line));
                            i += 1;
                            continue;
                        }
                    }
                }
                in_table = false;
                table_blockquote_level = None;
                table_list_indent = None;
                out.push_str(line);
                i += 1;
                continue;
            }

            if i + 1 < lines.len() {
                let header_from_list_marker = list_marker_present;
                let (level, rest) = if list_marker_present {
                    let (nested_level, nested_rest) = Self::table_line_info(list_stripped);
                    (blockquote_level + nested_level, nested_rest)
                } else {
                    Self::table_line_info_with_list(line, list_indent)
                };
                let next_info = if list_indent.is_some() {
                    Self::table_line_info_in_list(lines[i + 1], list_indent)
                } else {
                    Some(Self::table_line_info(lines[i + 1]))
                };
                let header_line = if header_from_list_marker {
                    let (_, stripped) = Self::table_line_info(list_stripped);
                    stripped
                } else {
                    rest
                };

                if let Some((next_level, next_rest)) = next_info {
                    if level == next_level && Self::is_table_row_candidate(header_line) {
                        let delimiter_line = Some(next_rest);
                        if delimiter_line.is_some_and(Self::is_table_delimiter_line) {
                            if !header_from_list_marker && i > 0 {
                                // Add blank line separator when the previous line has content
                                // at the same level, to help CommonMark parsers recognize tables.
                                // Skip this for plain list items (no blockquote) where the
                                // indentation alone is sufficient.
                                let in_blockquote = level > 0;
                                let (prev_level, prev_rest) =
                                    Self::table_line_info_with_list(lines[i - 1], list_indent);
                                if prev_level == level
                                    && !prev_rest.trim().is_empty()
                                    && (list_indent.is_none() || in_blockquote)
                                {
                                    let prefix_len = line.len().saturating_sub(rest.len());
                                    out.push_str(&line[..prefix_len]);
                                    let newline =
                                        if line.ends_with("\r\n") { "\r\n" } else { "\n" };
                                    out.push_str(newline);
                                }
                            }
                            out.push_str(&Self::escape_pipes_in_inline_code_line(line));
                            out.push_str(lines[i + 1]);
                            in_table = true;
                            table_blockquote_level = Some(level);
                            table_list_indent = list_indent;
                            i += 2;
                            continue;
                        }
                    }
                }
            }

            out.push_str(line);
            i += 1;
        }

        out
    }

    fn escape_pipes_in_inline_code_line(line: &str) -> String {
        if !line.contains('|') || !line.contains('`') {
            return line.to_string();
        }
        let mut out: Vec<char> = Vec::with_capacity(line.len());
        let mut in_code = false;
        let mut delimiter_len = 0usize;
        let mut pending_pipes: Vec<usize> = Vec::new();
        let mut backslash_run = 0usize;
        let mut chars = line.chars().peekable();

        while let Some(ch) = chars.next() {
            if ch == '\\' {
                backslash_run += 1;
                out.push(ch);
                continue;
            }

            let escaped = !in_code && backslash_run % 2 == 1;
            backslash_run = 0;

            if ch == '`' {
                if escaped {
                    out.push('`');
                    continue;
                }
                let mut run_len = 1usize;
                while matches!(chars.peek(), Some('`')) {
                    chars.next();
                    run_len += 1;
                }
                if in_code {
                    if run_len == delimiter_len {
                        in_code = false;
                        delimiter_len = 0;
                        pending_pipes.clear();
                    }
                } else {
                    in_code = true;
                    delimiter_len = run_len;
                    pending_pipes.clear();
                }
                out.extend(std::iter::repeat_n('`', run_len));
                continue;
            }

            if in_code && ch == '|' {
                pending_pipes.push(out.len());
                out.push(PIPE_SENTINEL);
            } else {
                out.push(ch);
            }
        }

        if in_code {
            for idx in pending_pipes {
                out[idx] = '|';
            }
        }

        out.into_iter().collect()
    }

    fn is_html_line_break(html: &str) -> bool {
        let trimmed = html.trim();
        if trimmed.len() < 4 {
            return false;
        }
        let normalized = trimmed.to_ascii_lowercase();
        if !normalized.starts_with("<br") || !normalized.ends_with('>') {
            return false;
        }
        let rest = &normalized[3..];
        let first = rest.chars().next();
        match first {
            Some('>') => true,
            Some('/') => rest[1..].trim_start().starts_with('>'),
            Some(ch) if ch.is_whitespace() => true,
            _ => false,
        }
    }

    fn tab_advance(col: usize) -> usize {
        let rem = col % 4;
        if rem == 0 {
            4
        } else {
            4 - rem
        }
    }

    fn is_indented_code_line(line: &str) -> bool {
        let mut col = 0usize;
        for ch in line.chars() {
            match ch {
                ' ' => {
                    col += 1;
                    if col >= 4 {
                        return true;
                    }
                }
                '\t' => {
                    col += Self::tab_advance(col);
                    return col >= 4;
                }
                _ => break,
            }
        }
        col >= 4
    }

    fn table_line_info(line: &str) -> (usize, &str) {
        let mut rest = line;
        let mut level = 0usize;
        loop {
            let bytes = rest.as_bytes();
            let mut idx = 0usize;
            while idx < bytes.len() && idx < 3 && bytes[idx] == b' ' {
                idx += 1;
            }
            if idx < bytes.len() && bytes[idx] == b'>' {
                idx += 1;
                if idx < bytes.len() && (bytes[idx] == b' ' || bytes[idx] == b'\t') {
                    idx += 1;
                }
                level += 1;
                rest = &rest[idx..];
                continue;
            }
            break;
        }
        (level, rest)
    }

    fn table_line_info_with_list(line: &str, list_indent: Option<usize>) -> (usize, &str) {
        let (level, rest) = Self::table_line_info(line);
        if let Some(indent) = list_indent {
            if let Some(stripped) = Self::strip_indent_columns(rest, indent) {
                let (nested_level, nested_rest) = Self::table_line_info(stripped);
                return (level + nested_level, nested_rest);
            }
            if let Some(stripped) = Self::strip_indent_columns(line, indent) {
                return Self::table_line_info(stripped);
            }
        }
        (level, rest)
    }

    fn table_line_info_in_list(line: &str, list_indent: Option<usize>) -> Option<(usize, &str)> {
        let (level, rest) = Self::table_line_info(line);
        if let Some(indent) = list_indent {
            if let Some(stripped) = Self::strip_indent_columns(rest, indent) {
                let (nested_level, nested_rest) = Self::table_line_info(stripped);
                return Some((level + nested_level, nested_rest));
            }
            let stripped = Self::strip_indent_columns(line, indent)?;
            return Some(Self::table_line_info(stripped));
        }
        Some((level, rest))
    }

    fn list_marker_info(line: &str) -> Option<(&str, usize, usize)> {
        let bytes = line.as_bytes();
        let mut idx = 0usize;
        let mut spaces = 0usize;
        while idx < bytes.len() && spaces < 3 && bytes[idx] == b' ' {
            idx += 1;
            spaces += 1;
        }
        if idx < bytes.len() && bytes[idx] == b'\t' {
            return None;
        }
        if idx >= bytes.len() {
            return None;
        }
        let marker_start = idx;
        match bytes[idx] {
            b'-' | b'+' | b'*' => {
                idx += 1;
            }
            b'0'..=b'9' => {
                while idx < bytes.len() && bytes[idx].is_ascii_digit() {
                    idx += 1;
                }
                if idx < bytes.len() && (bytes[idx] == b'.' || bytes[idx] == b')') {
                    idx += 1;
                } else {
                    return None;
                }
            }
            _ => return None,
        }
        let marker_width = idx.saturating_sub(marker_start);
        let mut indent = 0usize;
        let mut has_ws = false;
        let mut col = spaces + marker_width;
        while idx < bytes.len() {
            match bytes[idx] {
                b' ' => {
                    indent += 1;
                    col += 1;
                    idx += 1;
                    has_ws = true;
                }
                b'\t' => {
                    let advance = Self::tab_advance(col);
                    indent += advance;
                    col += advance;
                    idx += 1;
                    has_ws = true;
                }
                _ => break,
            }
        }
        if !has_ws {
            return None;
        }
        let content_indent = col;
        Some((&line[idx..], indent, content_indent))
    }

    fn list_marker_info_any_indent(line: &str) -> Option<(&str, usize, usize, usize)> {
        let bytes = line.as_bytes();
        let mut idx = 0usize;
        let mut leading_cols = 0usize;
        while idx < bytes.len() {
            match bytes[idx] {
                b' ' => {
                    idx += 1;
                    leading_cols += 1;
                }
                b'\t' => {
                    let advance = Self::tab_advance(leading_cols);
                    idx += 1;
                    leading_cols += advance;
                }
                _ => break,
            }
        }
        if idx >= bytes.len() {
            return None;
        }
        let marker_start = idx;
        match bytes[idx] {
            b'-' | b'+' | b'*' => {
                idx += 1;
            }
            b'0'..=b'9' => {
                while idx < bytes.len() && bytes[idx].is_ascii_digit() {
                    idx += 1;
                }
                if idx < bytes.len() && (bytes[idx] == b'.' || bytes[idx] == b')') {
                    idx += 1;
                } else {
                    return None;
                }
            }
            _ => return None,
        }
        let marker_width = idx.saturating_sub(marker_start);
        let mut indent = 0usize;
        let mut has_ws = false;
        let mut col = leading_cols + marker_width;
        while idx < bytes.len() {
            match bytes[idx] {
                b' ' => {
                    indent += 1;
                    col += 1;
                    idx += 1;
                    has_ws = true;
                }
                b'\t' => {
                    let advance = Self::tab_advance(col);
                    indent += advance;
                    col += advance;
                    idx += 1;
                    has_ws = true;
                }
                _ => break,
            }
        }
        if !has_ws {
            return None;
        }
        let content_indent = col;
        Some((&line[idx..], indent, content_indent, leading_cols))
    }

    fn parent_list_indent_for_line(
        lines: &[&str],
        idx: usize,
        level: usize,
        line_rest: &str,
    ) -> Option<usize> {
        if idx == 0 {
            return None;
        }
        for back_idx in (0..idx).rev() {
            let (prev_level, prev_rest) = Self::table_line_info(lines[back_idx]);
            if prev_level < level {
                break;
            }
            if prev_level > level {
                continue;
            }
            if prev_rest.trim().is_empty() {
                continue;
            }
            if let Some((_, _, content_indent)) = Self::list_marker_info(prev_rest) {
                if Self::strip_indent_columns(line_rest, content_indent).is_some() {
                    return Some(content_indent);
                }
            } else if let Some((_, _, content_indent, _)) =
                Self::list_marker_info_any_indent(prev_rest)
            {
                if Self::strip_indent_columns(line_rest, content_indent).is_some() {
                    return Some(content_indent);
                }
            } else if !prev_rest.starts_with(' ') && !prev_rest.starts_with('\t') {
                break;
            }
        }
        None
    }

    fn strip_indent_columns(line: &str, indent: usize) -> Option<&str> {
        if indent == 0 {
            return Some(line);
        }
        let mut col = 0usize;
        let mut cut = 0usize;
        for (idx, ch) in line.char_indices() {
            if col >= indent {
                break;
            }
            match ch {
                ' ' => {
                    col += 1;
                    cut = idx + ch.len_utf8();
                }
                '\t' => {
                    col += Self::tab_advance(col);
                    cut = idx + ch.len_utf8();
                }
                _ => return None,
            }
        }
        if col >= indent {
            Some(&line[cut..])
        } else {
            None
        }
    }

    fn has_pipe_outside_inline_code(line: &str) -> bool {
        if !line.contains('|') {
            return false;
        }
        let mut in_code = false;
        let mut delimiter_len = 0usize;
        let mut backslash_run = 0usize;
        let mut chars = line.chars().peekable();

        while let Some(ch) = chars.next() {
            if ch == '\\' {
                backslash_run += 1;
                continue;
            }

            let escaped = !in_code && backslash_run % 2 == 1;
            backslash_run = 0;

            if ch == '`' {
                if escaped {
                    continue;
                }
                let mut run_len = 1usize;
                while matches!(chars.peek(), Some('`')) {
                    chars.next();
                    run_len += 1;
                }
                if in_code {
                    if run_len == delimiter_len {
                        in_code = false;
                        delimiter_len = 0;
                    }
                } else {
                    in_code = true;
                    delimiter_len = run_len;
                }
                continue;
            }

            if ch == '|' && !in_code && !escaped {
                return true;
            }
        }

        false
    }

    fn is_table_row_candidate(line: &str) -> bool {
        if Self::is_indented_code_line(line) {
            return false;
        }
        let trimmed_line = line.trim_end_matches(['\r', '\n']);
        if trimmed_line.trim().is_empty() {
            return false;
        }
        Self::has_pipe_outside_inline_code(trimmed_line)
    }

    fn is_table_delimiter_line(line: &str) -> bool {
        if Self::is_indented_code_line(line) {
            return false;
        }
        let trimmed = line.trim_end_matches(['\r', '\n']).trim();
        if trimmed.is_empty() {
            return false;
        }
        let mut has_dash = false;
        let mut has_pipe = false;
        for ch in trimmed.chars() {
            match ch {
                '-' => has_dash = true,
                '|' => has_pipe = true,
                ':' | ' ' | '\t' => {}
                _ => return false,
            }
        }
        has_dash && has_pipe
    }

    fn fence_start(line: &str) -> Option<(char, usize)> {
        let trimmed = line.trim_start();
        let mut chars = trimmed.chars();
        let first = chars.next()?;
        if first != '`' && first != '~' {
            return None;
        }
        let mut count = 1usize;
        for ch in chars {
            if ch == first {
                count += 1;
            } else {
                break;
            }
        }
        if count >= 3 {
            Some((first, count))
        } else {
            None
        }
    }

    fn is_fence_end(line: &str, fence_char: char, fence_len: usize) -> bool {
        let trimmed = line.trim_start();
        let mut count = 0usize;
        for ch in trimmed.chars() {
            if ch == fence_char {
                count += 1;
            } else {
                break;
            }
        }
        count >= fence_len
    }

    fn restore_pipe_sentinel(text: &str) -> String {
        if text.contains(PIPE_SENTINEL) {
            text.chars()
                .map(|ch| if ch == PIPE_SENTINEL { '|' } else { ch })
                .collect()
        } else {
            text.to_string()
        }
    }

    /// Parse markdown content into elements with proper inline handling
    pub fn parse(&self, markdown: &str) -> Result<Vec<MarkdownElement>, anyhow::Error> {
        #[cfg(test)]
        if take_forced_parse_error() {
            return Err(anyhow::anyhow!("forced parse error"));
        }

        let mut options = Options::empty();
        options.insert(Options::ENABLE_STRIKETHROUGH);
        options.insert(Options::ENABLE_TABLES);
        options.insert(Options::ENABLE_TASKLISTS);

        let prepared = Self::escape_table_pipes_in_inline_code(markdown);
        let parser = Parser::new_ext(&prepared, options);
        let mut elements = Vec::new();
        let events = parser.collect::<Vec<_>>();

        let mut i = 0;
        // Track header slug occurrences for stable de-duplication
        let mut slug_counts: HashMap<String, usize> = HashMap::new();
        while i < events.len() {
            i = self.parse_element(&events, i, &mut elements, &mut slug_counts);
        }

        Ok(elements)
    }

    /// Parse a single element from the event stream
    fn parse_element(
        &self,
        events: &[Event],
        start: usize,
        elements: &mut Vec<MarkdownElement>,
        slug_counts: &mut HashMap<String, usize>,
    ) -> usize {
        match &events[start] {
            Event::Start(Tag::Paragraph) => {
                // Always preserve line breaks in paragraphs (consistent with blockquotes)
                // This allows poetry, lyrics, and structured content to render correctly
                let (spans, next_idx) =
                    self.parse_inline_spans_with_breaks(events, start + 1, Tag::Paragraph, true);
                if !spans.is_empty() {
                    elements.push(MarkdownElement::Paragraph(spans));
                }
                next_idx
            }
            // Images encountered outside paragraphs: treat as a single paragraph with an inline image
            Event::Start(Tag::Image(_, url, title)) => {
                let (alt, next_idx) = self.collect_until_tag_end(
                    events,
                    start + 1,
                    Tag::Image(LinkType::Inline, "".into(), "".into()),
                    false,
                );
                let mut spans: Vec<InlineSpan> = Vec::new();
                spans.push(InlineSpan::Image {
                    src: url.to_string(),
                    alt,
                    title: if title.is_empty() {
                        None
                    } else {
                        Some(title.to_string())
                    },
                });
                elements.push(MarkdownElement::Paragraph(spans));
                next_idx
            }
            Event::Start(Tag::Heading(level, _, _)) => {
                let (spans, next_idx) =
                    self.parse_inline_spans(events, start + 1, Tag::Heading(*level, None, vec![]));
                let title_text = Self::spans_plain_text(&spans);
                let base = Self::slugify(&title_text);
                let count = slug_counts.entry(base.clone()).or_insert(0);
                let id = if *count == 0 {
                    base.clone()
                } else {
                    format!("{}-{}", base, *count)
                };
                *count += 1;
                elements.push(MarkdownElement::Header {
                    level: *level as u8,
                    spans,
                    id,
                });
                next_idx
            }
            Event::Start(Tag::CodeBlock(_)) => {
                let (code_text, language, next_idx) = self.parse_code_block(events, start);
                elements.push(MarkdownElement::CodeBlock {
                    language,
                    text: code_text,
                });
                next_idx
            }
            Event::Start(Tag::List(first_item)) => {
                let (items, next_idx) = self.parse_list(events, start + 1, slug_counts);
                elements.push(MarkdownElement::List {
                    ordered: first_item.is_some(),
                    items,
                });
                next_idx
            }
            Event::Rule => {
                elements.push(MarkdownElement::HorizontalRule);
                start + 1
            }
            Event::Start(Tag::BlockQuote) => {
                let (quotes, next_idx) =
                    self.collect_blockquotes(events, start + 1, 1, slug_counts);
                for (depth, blocks) in quotes {
                    elements.push(MarkdownElement::Quote { depth, blocks });
                }
                next_idx
            }
            Event::Start(Tag::Table(alignments)) => {
                let (headers, rows, next_idx) = self.parse_table(events, start + 1);
                elements.push(MarkdownElement::Table {
                    headers,
                    rows,
                    alignments: alignments.to_vec(),
                });
                next_idx
            }
            _ => {
                // Skip other events
                start + 1
            }
        }
    }

    // Build a slug from text similar to GitHub: lowercase, spaces->dashes, strip punctuation
    fn slugify(text: &str) -> String {
        let mut out = String::with_capacity(text.len());
        let mut last_dash = false;
        for ch in text.chars() {
            let c = ch.to_ascii_lowercase();
            if c.is_ascii_alphanumeric() {
                out.push(c);
                last_dash = false;
            } else if c.is_whitespace() || c == '-' {
                if !last_dash && !out.is_empty() {
                    out.push('-');
                    last_dash = true;
                }
            } else {
                // drop punctuation/symbols
            }
        }
        // Trim trailing dash if any
        if out.ends_with('-') {
            out.pop();
        }
        out
    }

    fn spans_plain_text(spans: &[InlineSpan]) -> String {
        let mut s = String::new();
        for span in spans {
            match span {
                InlineSpan::Text(t)
                | InlineSpan::Strong(t)
                | InlineSpan::Emphasis(t)
                | InlineSpan::Strikethrough(t) => s.push_str(t),
                InlineSpan::Code(t) => s.push_str(t),
                InlineSpan::Link { text, .. } => s.push_str(text),
                InlineSpan::Image { alt, title, .. } => {
                    if !alt.is_empty() {
                        s.push_str(alt);
                    }
                    if let Some(t) = title {
                        if !t.is_empty() {
                            if !s.is_empty() {
                                s.push(' ');
                            }
                            s.push_str(t);
                        }
                    }
                }
            }
        }
        s
    }

    /// Extract plain text from all markdown elements
    pub fn elements_to_plain_text(elements: &[MarkdownElement]) -> String {
        let mut result = String::new();
        for element in elements.iter() {
            match element {
                MarkdownElement::Paragraph(spans) | MarkdownElement::Header { spans, .. } => {
                    if !result.is_empty() {
                        result.push('\n');
                    }
                    result.push_str(&Self::spans_plain_text(spans));
                }
                MarkdownElement::CodeBlock { text, .. } => {
                    if !result.is_empty() {
                        result.push('\n');
                    }
                    result.push_str(text);
                }
                MarkdownElement::List { items, .. } => {
                    for item in items {
                        for block in &item.blocks {
                            if !result.is_empty() {
                                result.push('\n');
                            }
                            result.push_str(&Self::element_plain_text(block));
                        }
                    }
                }
                MarkdownElement::Quote { blocks, .. } => {
                    for block in blocks {
                        if !result.is_empty() {
                            result.push('\n');
                        }
                        result.push_str(&Self::element_plain_text(block));
                    }
                }
                MarkdownElement::Table {
                    headers,
                    rows,
                    alignments: _,
                } => {
                    // Headers
                    for header in headers {
                        if !result.is_empty() {
                            result.push('\n');
                        }
                        result.push_str(&Self::spans_plain_text(header));
                    }
                    // Rows
                    for row in rows {
                        for cell in row {
                            if !result.is_empty() {
                                result.push('\n');
                            }
                            result.push_str(&Self::spans_plain_text(cell));
                        }
                    }
                }
                MarkdownElement::HorizontalRule => {
                    if !result.is_empty() {
                        result.push_str("\n---\n");
                    }
                }
            }
        }
        result
    }

    /// Collect blockquotes into (depth, blocks) entries; supports nesting and block elements.
    fn collect_blockquotes(
        &self,
        events: &[Event],
        start: usize,
        depth: u8,
        slug_counts: &mut HashMap<String, usize>,
    ) -> (Vec<(u8, QuoteBlocks)>, usize) {
        let mut i = start;
        let mut result: Vec<(u8, QuoteBlocks)> = Vec::new();
        let mut blocks: QuoteBlocks = Vec::new();
        let mut spans: Vec<InlineSpan> = Vec::new();

        let flush_inline = |blocks: &mut QuoteBlocks, spans: &mut Vec<InlineSpan>| {
            if !spans.is_empty() {
                blocks.push(MarkdownElement::Paragraph(std::mem::take(spans)));
            }
        };

        while i < events.len() {
            match &events[i] {
                Event::Start(Tag::Paragraph) => {
                    flush_inline(&mut blocks, &mut spans);
                    let (ps, next) =
                        self.parse_inline_spans_with_breaks(events, i + 1, Tag::Paragraph, true);
                    if !ps.is_empty() {
                        blocks.push(MarkdownElement::Paragraph(ps));
                    }
                    i = next;
                }
                Event::Start(Tag::Heading(level, _, _)) => {
                    flush_inline(&mut blocks, &mut spans);
                    let (ps, next) =
                        self.parse_inline_spans(events, i + 1, Tag::Heading(*level, None, vec![]));
                    let title_text = Self::spans_plain_text(&ps);
                    let base = Self::slugify(&title_text);
                    let count = slug_counts.entry(base.clone()).or_insert(0);
                    let id = if *count == 0 {
                        base.clone()
                    } else {
                        format!("{}-{}", base, *count)
                    };
                    *count += 1;
                    blocks.push(MarkdownElement::Header {
                        level: *level as u8,
                        spans: ps,
                        id,
                    });
                    i = next;
                }
                Event::Start(Tag::Table(alignments)) => {
                    flush_inline(&mut blocks, &mut spans);
                    let (headers, rows, next_idx) = self.parse_table(events, i + 1);
                    blocks.push(MarkdownElement::Table {
                        headers,
                        rows,
                        alignments: alignments.to_vec(),
                    });
                    i = next_idx;
                }
                Event::Start(Tag::List(first_item)) => {
                    flush_inline(&mut blocks, &mut spans);
                    let (items, next_idx) = self.parse_list(events, i + 1, slug_counts);
                    blocks.push(MarkdownElement::List {
                        ordered: first_item.is_some(),
                        items,
                    });
                    i = next_idx;
                }
                Event::Start(Tag::CodeBlock(_)) => {
                    flush_inline(&mut blocks, &mut spans);
                    let (code_text, language, next_idx) = self.parse_code_block(events, i);
                    blocks.push(MarkdownElement::CodeBlock {
                        language,
                        text: code_text,
                    });
                    i = next_idx;
                }
                Event::Rule => {
                    flush_inline(&mut blocks, &mut spans);
                    blocks.push(MarkdownElement::HorizontalRule);
                    i += 1;
                }
                Event::Start(Tag::BlockQuote) => {
                    flush_inline(&mut blocks, &mut spans);
                    if !blocks.is_empty() {
                        result.push((depth, std::mem::take(&mut blocks)));
                    }
                    let (nested, next) =
                        self.collect_blockquotes(events, i + 1, depth + 1, slug_counts);
                    result.extend(nested);
                    i = next;
                }
                Event::End(Tag::BlockQuote) => {
                    flush_inline(&mut blocks, &mut spans);
                    if !blocks.is_empty() {
                        result.push((depth, blocks));
                    }
                    return (result, i + 1);
                }
                Event::Text(t) => {
                    spans.push(InlineSpan::Text(Self::restore_pipe_sentinel(t)));
                    i += 1;
                }
                Event::Code(code) => {
                    spans.push(InlineSpan::Code(Self::restore_pipe_sentinel(code)));
                    i += 1;
                }
                Event::Start(Tag::Emphasis) => {
                    let (inner_text, next) =
                        self.collect_until_tag_end(events, i + 1, Tag::Emphasis, true);
                    spans.push(InlineSpan::Emphasis(inner_text));
                    i = next;
                }
                Event::Start(Tag::Strong) => {
                    let (inner_text, next) =
                        self.collect_until_tag_end(events, i + 1, Tag::Strong, true);
                    spans.push(InlineSpan::Strong(inner_text));
                    i = next;
                }
                Event::Start(Tag::Strikethrough) => {
                    let (inner_text, next) =
                        self.collect_until_tag_end(events, i + 1, Tag::Strikethrough, true);
                    spans.push(InlineSpan::Strikethrough(inner_text));
                    i = next;
                }
                Event::Start(Tag::Link(_, url, _)) => {
                    let url_str = url.to_string();
                    let (link_text, next) = self.collect_until_tag_end(
                        events,
                        i + 1,
                        Tag::Link(LinkType::Inline, "".into(), "".into()),
                        true,
                    );
                    spans.push(InlineSpan::Link {
                        text: link_text,
                        url: url_str,
                    });
                    i = next;
                }
                Event::Start(Tag::Image(_, url, title)) => {
                    let url_str = url.to_string();
                    let (alt_text, next) = self.collect_until_tag_end(
                        events,
                        i + 1,
                        Tag::Image(LinkType::Inline, "".into(), "".into()),
                        true,
                    );
                    spans.push(InlineSpan::Image {
                        src: url_str,
                        alt: alt_text,
                        title: if title.is_empty() {
                            None
                        } else {
                            Some(title.to_string())
                        },
                    });
                    i = next;
                }
                Event::SoftBreak | Event::HardBreak => {
                    spans.push(InlineSpan::Text("\n".to_string()));
                    i += 1;
                }
                Event::Html(html) => {
                    if Self::is_html_line_break(html) {
                        spans.push(InlineSpan::Text("\n".to_string()));
                    }
                    i += 1;
                }
                _ => {
                    i += 1;
                }
            }
        }

        flush_inline(&mut blocks, &mut spans);
        if !blocks.is_empty() {
            result.push((depth, blocks));
        }
        (result, i)
    }

    /// Parse inline spans until reaching the end tag
    fn parse_inline_spans_with_breaks(
        &self,
        events: &[Event],
        start: usize,
        end_tag: Tag,
        keep_breaks: bool,
    ) -> (Vec<InlineSpan>, usize) {
        let mut spans = Vec::new();
        let mut i = start;
        let mut text_buffer = String::new();

        while i < events.len() {
            match &events[i] {
                Event::End(tag)
                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
                {
                    if !text_buffer.is_empty() {
                        spans.push(InlineSpan::Text(text_buffer.clone()));
                        text_buffer.clear();
                    }
                    return (spans, i + 1);
                }
                Event::Text(text) => {
                    let restored = Self::restore_pipe_sentinel(text);
                    text_buffer.push_str(&restored);
                    i += 1;
                }
                Event::SoftBreak | Event::HardBreak => {
                    if keep_breaks {
                        if !text_buffer.is_empty() {
                            spans.push(InlineSpan::Text(text_buffer.clone()));
                            text_buffer.clear();
                        }
                        spans.push(InlineSpan::Text("\n".to_string()));
                    } else {
                        text_buffer.push(' ');
                    }
                    i += 1;
                }
                Event::Code(code) => {
                    if !text_buffer.is_empty() {
                        spans.push(InlineSpan::Text(text_buffer.clone()));
                        text_buffer.clear();
                    }
                    spans.push(InlineSpan::Code(Self::restore_pipe_sentinel(code)));
                    i += 1;
                }
                Event::Html(html) => {
                    if Self::is_html_line_break(html) {
                        if keep_breaks {
                            if !text_buffer.is_empty() {
                                spans.push(InlineSpan::Text(text_buffer.clone()));
                                text_buffer.clear();
                            }
                            spans.push(InlineSpan::Text("\n".to_string()));
                        } else {
                            text_buffer.push(' ');
                        }
                    }
                    i += 1;
                }
                Event::Start(Tag::Strong) => {
                    if !text_buffer.is_empty() {
                        spans.push(InlineSpan::Text(text_buffer.clone()));
                        text_buffer.clear();
                    }
                    let (inner_text, next_i) =
                        self.collect_until_tag_end(events, i + 1, Tag::Strong, keep_breaks);
                    spans.push(InlineSpan::Strong(inner_text));
                    i = next_i;
                }
                Event::Start(Tag::Emphasis) => {
                    if !text_buffer.is_empty() {
                        spans.push(InlineSpan::Text(text_buffer.clone()));
                        text_buffer.clear();
                    }
                    let (inner_text, next_i) =
                        self.collect_until_tag_end(events, i + 1, Tag::Emphasis, keep_breaks);
                    spans.push(InlineSpan::Emphasis(inner_text));
                    i = next_i;
                }
                Event::Start(Tag::Strikethrough) => {
                    if !text_buffer.is_empty() {
                        spans.push(InlineSpan::Text(text_buffer.clone()));
                        text_buffer.clear();
                    }
                    let (inner_text, next_i) =
                        self.collect_until_tag_end(events, i + 1, Tag::Strikethrough, keep_breaks);
                    spans.push(InlineSpan::Strikethrough(inner_text));
                    i = next_i;
                }
                Event::Start(Tag::Link(_, url, _)) => {
                    if !text_buffer.is_empty() {
                        spans.push(InlineSpan::Text(text_buffer.clone()));
                        text_buffer.clear();
                    }
                    let url_str = url.to_string();
                    let (link_text, next_i) = self.collect_until_tag_end(
                        events,
                        i + 1,
                        Tag::Link(LinkType::Inline, "".into(), "".into()),
                        keep_breaks,
                    );
                    spans.push(InlineSpan::Link {
                        text: link_text,
                        url: url_str,
                    });
                    i = next_i;
                }
                Event::Start(Tag::Image(_, url, title)) => {
                    if !text_buffer.is_empty() {
                        spans.push(InlineSpan::Text(text_buffer.clone()));
                        text_buffer.clear();
                    }
                    let url_str = url.to_string();
                    let (alt_text, next_i) = self.collect_until_tag_end(
                        events,
                        i + 1,
                        Tag::Image(LinkType::Inline, "".into(), "".into()),
                        keep_breaks,
                    );
                    spans.push(InlineSpan::Image {
                        src: url_str,
                        alt: alt_text,
                        title: if title.is_empty() {
                            None
                        } else {
                            Some(title.to_string())
                        },
                    });
                    i = next_i;
                }
                _ => {
                    i += 1;
                }
            }
        }

        if !text_buffer.is_empty() {
            spans.push(InlineSpan::Text(text_buffer));
        }

        (spans, i)
    }

    /// Default inline parsing without preserving explicit line breaks
    fn parse_inline_spans(
        &self,
        events: &[Event],
        start: usize,
        end_tag: Tag,
    ) -> (Vec<InlineSpan>, usize) {
        self.parse_inline_spans_with_breaks(events, start, end_tag, false)
    }

    /// Collect text until a specific end tag
    fn collect_until_tag_end(
        &self,
        events: &[Event],
        start: usize,
        end_tag: Tag,
        keep_breaks: bool,
    ) -> (String, usize) {
        let mut text = String::new();
        let mut i = start;

        while i < events.len() {
            match &events[i] {
                Event::End(tag)
                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
                {
                    return (text, i + 1);
                }
                Event::Text(t) => {
                    let restored = Self::restore_pipe_sentinel(t);
                    text.push_str(&restored);
                }
                Event::Code(code) => {
                    let restored = Self::restore_pipe_sentinel(code);
                    text.push_str(&restored);
                }
                Event::SoftBreak | Event::HardBreak => {
                    if keep_breaks {
                        text.push('\n');
                    } else {
                        text.push(' ');
                    }
                }
                Event::Html(html) => {
                    if Self::is_html_line_break(html) {
                        if keep_breaks {
                            text.push('\n');
                        } else {
                            text.push(' ');
                        }
                    }
                }
                _ => {}
            }
            i += 1;
        }

        (text, i)
    }

    /// Parse a code block
    fn parse_code_block(&self, events: &[Event], start: usize) -> (String, Option<String>, usize) {
        let mut language = None;
        let mut code_text = String::new();
        let mut i = start;

        // Extract language from the start tag
        if let Event::Start(Tag::CodeBlock(kind)) = &events[start] {
            if let pulldown_cmark::CodeBlockKind::Fenced(lang) = kind {
                if !lang.is_empty() {
                    language = Some(lang.to_string());
                }
            }
            i += 1;
        }

        while i < events.len() {
            match &events[i] {
                Event::End(Tag::CodeBlock(_)) => {
                    return (code_text, language, i + 1);
                }
                Event::Text(text) => {
                    code_text.push_str(text);
                }
                _ => {}
            }
            i += 1;
        }

        (code_text, language, i)
    }

    /// Parse a list item into block-level markdown elements.
    fn parse_list(
        &self,
        events: &[Event],
        start: usize,
        slug_counts: &mut HashMap<String, usize>,
    ) -> (Vec<ListItem>, usize) {
        let mut items: Vec<ListItem> = Vec::new();
        let mut i = start;

        while i < events.len() {
            match &events[i] {
                Event::End(Tag::List(_)) => return (items, i + 1),
                Event::Start(Tag::Item) => {
                    i += 1;
                    let mut blocks: Vec<MarkdownElement> = Vec::new();
                    let mut spans: Vec<InlineSpan> = Vec::new();
                    let flush_inline =
                        |blocks: &mut Vec<MarkdownElement>, spans: &mut Vec<InlineSpan>| {
                            if !spans.is_empty() {
                                blocks.push(MarkdownElement::Paragraph(std::mem::take(spans)));
                            }
                        };

                    loop {
                        if i >= events.len() {
                            break;
                        }
                        match &events[i] {
                            Event::End(Tag::Item) => {
                                i += 1;
                                break;
                            }
                            Event::Start(Tag::Paragraph) => {
                                flush_inline(&mut blocks, &mut spans);
                                let (ps, next) =
                                    self.parse_inline_spans(events, i + 1, Tag::Paragraph);
                                if !ps.is_empty() {
                                    blocks.push(MarkdownElement::Paragraph(ps));
                                }
                                i = next;
                            }
                            Event::Start(Tag::Heading(level, _, _)) => {
                                flush_inline(&mut blocks, &mut spans);
                                let (ps, next) = self.parse_inline_spans(
                                    events,
                                    i + 1,
                                    Tag::Heading(*level, None, vec![]),
                                );
                                let title_text = Self::spans_plain_text(&ps);
                                let base = Self::slugify(&title_text);
                                let count = slug_counts.entry(base.clone()).or_insert(0);
                                let id = if *count == 0 {
                                    base.clone()
                                } else {
                                    format!("{}-{}", base, *count)
                                };
                                *count += 1;
                                blocks.push(MarkdownElement::Header {
                                    level: *level as u8,
                                    spans: ps,
                                    id,
                                });
                                i = next;
                            }
                            Event::Start(Tag::Table(alignments)) => {
                                flush_inline(&mut blocks, &mut spans);
                                let (headers, rows, next_idx) = self.parse_table(events, i + 1);
                                blocks.push(MarkdownElement::Table {
                                    headers,
                                    rows,
                                    alignments: alignments.to_vec(),
                                });
                                i = next_idx;
                            }
                            Event::Start(Tag::CodeBlock(_)) => {
                                flush_inline(&mut blocks, &mut spans);
                                let (code_text, language, next_idx) =
                                    self.parse_code_block(events, i);
                                blocks.push(MarkdownElement::CodeBlock {
                                    language,
                                    text: code_text,
                                });
                                i = next_idx;
                            }
                            Event::Start(Tag::BlockQuote) => {
                                flush_inline(&mut blocks, &mut spans);
                                let (quotes, next_idx) =
                                    self.collect_blockquotes(events, i + 1, 1, slug_counts);
                                for (depth, quote_blocks) in quotes {
                                    blocks.push(MarkdownElement::Quote {
                                        depth,
                                        blocks: quote_blocks,
                                    });
                                }
                                i = next_idx;
                            }
                            Event::Start(Tag::List(child_first)) => {
                                flush_inline(&mut blocks, &mut spans);
                                let (child_items, next) =
                                    self.parse_list(events, i + 1, slug_counts);
                                blocks.push(MarkdownElement::List {
                                    ordered: child_first.is_some(),
                                    items: child_items,
                                });
                                i = next;
                            }
                            Event::Rule => {
                                flush_inline(&mut blocks, &mut spans);
                                blocks.push(MarkdownElement::HorizontalRule);
                                i += 1;
                            }
                            Event::Code(code) => {
                                spans.push(InlineSpan::Code(code.to_string()));
                                i += 1;
                            }
                            Event::Start(Tag::Emphasis) => {
                                let (inner_text, next) =
                                    self.collect_until_tag_end(events, i + 1, Tag::Emphasis, false);
                                spans.push(InlineSpan::Emphasis(inner_text));
                                i = next;
                            }
                            Event::Start(Tag::Strong) => {
                                let (inner_text, next) =
                                    self.collect_until_tag_end(events, i + 1, Tag::Strong, false);
                                spans.push(InlineSpan::Strong(inner_text));
                                i = next;
                            }
                            Event::Start(Tag::Strikethrough) => {
                                let (inner_text, next) = self.collect_until_tag_end(
                                    events,
                                    i + 1,
                                    Tag::Strikethrough,
                                    false,
                                );
                                spans.push(InlineSpan::Strikethrough(inner_text));
                                i = next;
                            }
                            Event::Start(Tag::Link(_, url, _)) => {
                                let url_str = url.to_string();
                                let (link_text, next) = self.collect_until_tag_end(
                                    events,
                                    i + 1,
                                    Tag::Link(LinkType::Inline, "".into(), "".into()),
                                    false,
                                );
                                spans.push(InlineSpan::Link {
                                    text: link_text,
                                    url: url_str,
                                });
                                i = next;
                            }
                            Event::Start(Tag::Image(_, url, title)) => {
                                let url_str = url.to_string();
                                let (alt_text, next) = self.collect_until_tag_end(
                                    events,
                                    i + 1,
                                    Tag::Image(LinkType::Inline, "".into(), "".into()),
                                    false,
                                );
                                spans.push(InlineSpan::Image {
                                    src: url_str,
                                    alt: alt_text,
                                    title: if title.is_empty() {
                                        None
                                    } else {
                                        Some(title.to_string())
                                    },
                                });
                                i = next;
                            }
                            Event::Text(t) => {
                                spans.push(InlineSpan::Text(t.to_string()));
                                i += 1;
                            }
                            Event::SoftBreak | Event::HardBreak => {
                                spans.push(InlineSpan::Text(" ".into()));
                                i += 1;
                            }
                            _ => {
                                i += 1;
                            }
                        }
                    }

                    flush_inline(&mut blocks, &mut spans);
                    items.push(ListItem { blocks });
                }
                _ => i += 1,
            }
        }

        (items, i)
    }

    /// Parse a table with headers and rows
    fn parse_table(&self, events: &[Event], start: usize) -> TableParseResult {
        let mut headers: Vec<Vec<InlineSpan>> = Vec::new();
        let mut rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
        let mut i = start;

        while i < events.len() {
            match &events[i] {
                Event::Start(Tag::TableHead) => {
                    i += 1;
                    while i < events.len() {
                        match &events[i] {
                            Event::Start(Tag::TableCell) => {
                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
                                    events,
                                    i + 1,
                                    Tag::TableCell,
                                    true,
                                );
                                headers.push(spans);
                                i = next_idx;
                            }
                            Event::End(Tag::TableHead) => {
                                i += 1;
                                break;
                            }
                            _ => i += 1,
                        }
                    }
                }
                Event::Start(Tag::TableRow) => {
                    i += 1;
                    let mut row: Vec<Vec<InlineSpan>> = Vec::new();
                    while i < events.len() {
                        match &events[i] {
                            Event::Start(Tag::TableCell) => {
                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
                                    events,
                                    i + 1,
                                    Tag::TableCell,
                                    true,
                                );
                                row.push(spans);
                                i = next_idx;
                            }
                            Event::End(Tag::TableRow) => {
                                i += 1;
                                if !row.is_empty() {
                                    rows.push(row);
                                }
                                break;
                            }
                            _ => i += 1,
                        }
                    }
                }
                Event::End(Tag::Table(_)) => return (headers, rows, i + 1),
                _ => i += 1,
            }
        }
        (headers, rows, i)
    }

    fn render_element_body(&self, ui: &mut egui::Ui, element: &MarkdownElement) {
        match element {
            MarkdownElement::Paragraph(spans) => {
                self.render_inline_spans(ui, spans);
                ui.add_space(4.0);
            }
            MarkdownElement::Quote { depth, blocks } => {
                ui.add_space(4.0);
                let bar_width = 3.0;
                let bar_gap = 6.0;
                let left_pad = 10.0 + (*depth as f32) * (bar_width + bar_gap);
                // Substack-like styling: dark grey block with orange accent bars and white text
                let bg = Color32::from_rgb(24, 24, 24);

                let resp = egui::Frame::none()
                    .fill(bg)
                    .stroke(Stroke::new(1.0, Color32::from_rgb(40, 40, 40)))
                    .rounding(egui::Rounding::same(6.0))
                    .inner_margin(egui::Margin {
                        left: left_pad,
                        right: 10.0,
                        top: 8.0,
                        bottom: 8.0,
                    })
                    .show(ui, |ui| {
                        let prev_override = ui.style().visuals.override_text_color;
                        // White text for quote content
                        ui.style_mut().visuals.override_text_color = Some(Color32::WHITE);
                        for block in blocks {
                            self.render_element_body(ui, block);
                        }
                        ui.style_mut().visuals.override_text_color = prev_override;
                    });

                // Draw vertical orange quote bars on the left of the frame
                let rect = resp.response.rect;
                let top = rect.top() + 6.0;
                let bottom = rect.bottom() - 6.0;
                let bar_color = Color32::from_rgb(255, 103, 25); // Substack-like orange
                for d in 0..*depth {
                    let x = rect.left() + 6.0 + (d as f32) * (bar_width + bar_gap);
                    let bar_rect = egui::Rect::from_min_max(
                        egui::pos2(x, top),
                        egui::pos2(x + bar_width, bottom),
                    );
                    ui.painter().rect_filled(bar_rect, 2.0, bar_color);
                }

                ui.add_space(6.0);
            }
            MarkdownElement::Header { level, spans, id } => {
                let font_size = match level {
                    1 => self.font_sizes.h1,
                    2 => self.font_sizes.h2,
                    3 => self.font_sizes.h3,
                    4 => self.font_sizes.h4,
                    5 => self.font_sizes.h5,
                    6 => self.font_sizes.h6,
                    _ => self.font_sizes.body,
                };

                ui.add_space(8.0);
                let resp = ui.horizontal_wrapped(|ui| {
                    // Avoid artificial gaps between header fragments
                    ui.spacing_mut().item_spacing.x = 0.0;
                    for span in spans {
                        self.render_inline_span(ui, span, Some(font_size), Some(true));
                    }
                });
                // Record the header rect for in-document navigation
                self.header_rects
                    .borrow_mut()
                    .insert(id.clone(), resp.response.rect);
                ui.add_space(6.0);
            }
            MarkdownElement::CodeBlock { language, text } => {
                self.render_code_block(ui, language.as_deref(), text);
            }
            MarkdownElement::List { ordered, items } => {
                self.render_list(ui, *ordered, items);
            }
            MarkdownElement::HorizontalRule => {
                ui.add_space(8.0);
                ui.separator();
                ui.add_space(8.0);
            }
            MarkdownElement::Table {
                headers,
                rows,
                alignments,
            } => {
                self.render_table(ui, headers, rows, alignments);
            }
        }
    }

    /// Render parsed markdown elements to egui UI
    pub fn render_to_ui(&self, ui: &mut egui::Ui, elements: &[MarkdownElement]) {
        self.poll_image_results(ui.ctx());
        self.mermaid.begin_frame();
        // Clear header rects before rendering a new frame
        self.header_rects.borrow_mut().clear();
        // Reset per-frame link counter to ensure link IDs are stable across frames
        *self.link_counter.borrow_mut() = 0;
        // Reset per-frame table counter
        *self.table_counter.borrow_mut() = 0;
        // Reset per-frame element rects
        self.element_rects.borrow_mut().clear();
        for element in elements.iter() {
            // Wrap each element in a no-op frame to capture its rect
            let ir = egui::Frame::none().show(ui, |ui| {
                self.render_element_body(ui, element);
            });
            self.element_rects.borrow_mut().push(ir.response.rect);
        }
        // Add a little extra breathing room at the end so
        // the final line doesn't sit flush under the status bar.
        ui.add_space(16.0);
    }

    /// Render inline spans in a wrapped horizontal layout
    fn render_inline_spans(&self, ui: &mut egui::Ui, spans: &[InlineSpan]) {
        ui.horizontal_wrapped(|ui| {
            // Avoid adding UI spacing between inline fragments
            ui.spacing_mut().item_spacing.x = 0.0;
            for span in spans {
                self.render_inline_span(ui, span, None, None);
            }
        });
    }

    /// Fix Unicode characters that may not render properly in the default font
    fn fix_unicode_chars(&self, text: &str) -> String {
        let normalized: String = text.nfc().collect();
        if !normalized.chars().any(|c| {
            matches!(
                c,
                '\u{2011}'
                    | '\u{00AD}'
                    | '\u{2010}'
                    | '\u{2212}'
                    | '\u{2013}'
                    | '\u{2014}'
                    | '\u{00A0}'
                    | '\u{202F}'
                    | '\u{2190}'
                    | '\u{2192}'
                    | '\u{2191}'
                    | '\u{2193}'
            )
        }) {
            return normalized;
        }

        let mut out = String::with_capacity(normalized.len());
        for ch in normalized.chars() {
            match ch {
                '\u{2011}' | '\u{00AD}' | '\u{2010}' | '\u{2212}' | '\u{2013}' | '\u{2014}' => {
                    out.push('-')
                }
                '\u{00A0}' | '\u{202F}' => out.push(' '),
                '\u{2190}' => {
                    out.push('<');
                    out.push('-');
                }
                '\u{2192}' => {
                    out.push('-');
                    out.push('>');
                }
                '\u{2191}' => {
                    out.push('^');
                }
                '\u{2193}' => {
                    out.push('v');
                }
                _ => out.push(ch),
            }
        }
        out
    }

    #[cfg(test)]
    pub(crate) fn normalize_text_for_test(&self, text: &str) -> String {
        self.fix_unicode_chars(text)
    }

    /// Render a single inline span    /// Render a single inline span
    fn render_inline_span(
        &self,
        ui: &mut egui::Ui,
        span: &InlineSpan,
        font_size: Option<f32>,
        strong: Option<bool>,
    ) {
        let size = font_size.unwrap_or(self.font_sizes.body);
        let is_strong = strong.unwrap_or(false);

        match span {
            InlineSpan::Text(text) => {
                let fixed_text = self.fix_unicode_chars(text);
                let style = InlineStyle {
                    strong: is_strong,
                    ..Default::default()
                };
                self.render_text_with_emojis(ui, &fixed_text, size, style);
            }
            InlineSpan::Code(code) => {
                // Inline code: adapt style to theme (light vs dark)
                ui.spacing_mut().item_spacing.x = 0.0;
                let is_dark = ui.visuals().dark_mode;
                let (bg, fg) = if is_dark {
                    (
                        Color32::from_rgb(30, 30, 30),
                        Color32::from_rgb(180, 255, 180),
                    )
                } else {
                    // Light theme: white background with readable code color
                    (Color32::WHITE, Color32::from_rgb(60, 80, 150))
                };
                let response = ui.add(
                    egui::Label::new(
                        RichText::new(code.clone())
                            .size(self.font_sizes.code)
                            .family(egui::FontFamily::Monospace)
                            .background_color(bg)
                            .color(fg),
                    )
                    .wrap(true),
                );

                // Add context menu for code
                #[cfg(test)]
                {
                    let _ = &response;
                    self.render_inline_code_context_menu(ui, code);
                }
                #[cfg(not(test))]
                response.context_menu(|ui| {
                    self.render_inline_code_context_menu(ui, code);
                });
            }
            InlineSpan::Strong(text) => {
                let fixed_text = self.fix_unicode_chars(text);
                let style = InlineStyle {
                    strong: true,
                    ..Default::default()
                };
                self.render_text_with_emojis(ui, &fixed_text, size, style);
            }
            InlineSpan::Emphasis(text) => {
                let fixed_text = self.fix_unicode_chars(text);
                let style = InlineStyle {
                    italics: true,
                    strong: is_strong,
                    ..Default::default()
                };
                self.render_text_with_emojis(ui, &fixed_text, size, style);
            }
            InlineSpan::Strikethrough(text) => {
                let fixed_text = self.fix_unicode_chars(text);
                let style = InlineStyle {
                    strike: true,
                    strong: is_strong,
                    ..Default::default()
                };
                self.render_text_with_emojis(ui, &fixed_text, size, style);
            }
            InlineSpan::Link { text, url } => {
                let fixed_text = self.fix_unicode_chars(text);
                let group = ui.horizontal_wrapped(|ui| {
                    // Render link-like styled text with emoji expansion
                    let color = if Self::is_external_url(url) {
                        // Slightly different color to indicate external website links
                        Color32::from_rgb(120, 190, 255)
                    } else {
                        Color32::LIGHT_BLUE
                    };
                    let style = InlineStyle {
                        strong: is_strong,
                        color: Some(color),
                        ..Default::default()
                    };
                    self.render_text_with_emojis(ui, &fixed_text, size, style);
                });
                // Use a unique id per link occurrence to avoid collisions when the same URL appears multiple times
                let mut counter = self.link_counter.borrow_mut();
                let id = egui::Id::new(format!("link:{}:{}", *counter, url));
                *counter += 1;
                let r = ui.interact(group.response.rect, id, egui::Sense::click());
                if render_action_triggered(r.hovered(), "link_hover") {
                    ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
                }
                if render_action_triggered(r.clicked(), "link_click") {
                    self.trigger_link(url);
                }

                // Add context menu for links
                #[cfg(test)]
                self.render_link_context_menu(ui, text, url);
                #[cfg(not(test))]
                r.context_menu(|ui| {
                    self.render_link_context_menu(ui, text, url);
                });
            }
            InlineSpan::Image { src, alt, title } => {
                // Resolve path
                let resolved = self.resolve_image_path(src);
                let available_w = ui.available_width().max(1.0);
                // Try to get or load texture
                if let Some((tex, w, h)) = self.get_or_load_image_texture(ui, &resolved) {
                    let (tw, th) = (w as f32, h as f32);
                    // Scale logic:
                    // - Start at UI scale (e.g., 1.0 for 100%, 1.1 for 110%).
                    // - Only downscale further if it would exceed available width.
                    let base_scale = self.ui_scale();
                    let scaled_w = tw * base_scale;
                    let scale = if scaled_w > available_w {
                        (available_w / tw).clamp(0.01, 4.0)
                    } else {
                        base_scale
                    };
                    let size = egui::vec2((tw * scale).round(), (th * scale).round());
                    let image = egui::Image::new(&tex).fit_to_exact_size(size);
                    let resp = ui.add(image);
                    if let Some(t) = title {
                        if !t.is_empty() {
                            if render_action_triggered(resp.hovered(), "image_hover") {
                                resp.on_hover_text(t.clone());
                            }
                            // Subtle caption below image
                            ui.add_space(2.0);
                            ui.label(
                                RichText::new(t.clone())
                                    .size(self.font_sizes.body - 2.0)
                                    .color(Color32::from_rgb(140, 140, 140)),
                            );
                        }
                    }
                    ui.add_space(6.0);
                } else {
                    // Placeholder with alt and error info
                    egui::Frame::none()
                        .fill(Color32::from_rgb(30, 30, 30))
                        .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
                        .inner_margin(8.0)
                        .show(ui, |ui| {
                            let pending = self.image_pending.borrow().contains(&resolved);
                            let msg = if pending {
                                "Loading image..."
                            } else if src.starts_with("http://") || src.starts_with("https://") {
                                "Remote images are disabled"
                            } else {
                                "Image not found or unsupported"
                            };
                            let label = if alt.is_empty() {
                                src.as_str()
                            } else {
                                alt.as_str()
                            };
                            ui.label(
                                RichText::new(format!("{}\n{}", label, msg))
                                    .size(self.font_sizes.body),
                            );
                        });
                    ui.add_space(6.0);
                }
            }
        }
    }

    fn extract_fragment(url: &str) -> Option<String> {
        if let Some(stripped) = url.strip_prefix('#') {
            // Already a fragment within current document
            return Some(stripped.to_ascii_lowercase());
        }
        None
    }

    fn is_external_url(url: &str) -> bool {
        let lower = url.to_ascii_lowercase();
        lower.starts_with("http://")
            || lower.starts_with("https://")
            || lower.starts_with("mailto:")
            || lower.starts_with("www.")
    }

    fn render_text_with_emojis(
        &self,
        ui: &mut egui::Ui,
        text: &str,
        size: f32,
        style: InlineStyle,
    ) {
        let mut buffer = String::new();
        for g in text.graphemes(true) {
            if let Some(key) = self.emoji_key_for_grapheme(g) {
                // Flush buffered text first (with highlighting if active)
                if !buffer.is_empty() {
                    self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
                    buffer.clear();
                }
                let handle = self.get_or_make_emoji_texture(ui, &key);
                let sz = size * 1.2;
                ui.add(egui::Image::new(&handle).max_width(sz).max_height(sz));
            } else {
                buffer.push_str(g);
            }
        }
        if !buffer.is_empty() {
            self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
        }
    }

    fn render_text_segment_with_optional_highlight(
        &self,
        ui: &mut egui::Ui,
        segment: &str,
        size: f32,
        style: InlineStyle,
    ) {
        // First expand emoji shortcodes, then superscript ^...^ notation
        let expanded = Self::expand_shortcodes(segment);
        let expanded = Self::expand_superscripts(&expanded);
        if let Some(h) = self
            .highlight_phrase
            .borrow()
            .as_ref()
            .filter(|s| !s.is_empty())
        {
            for (range, highlighted) in self.highlight_segments(&expanded, Some(h)) {
                let slice = &expanded[range];
                if highlighted {
                    self.render_highlighted_segment(ui, slice, size, style);
                } else {
                    self.render_plain_segment(ui, slice, size, style);
                }
            }
            return;
        }
        self.render_plain_segment(ui, &expanded, size, style);
    }

    fn render_plain_segment(&self, ui: &mut egui::Ui, text: &str, size: f32, style: InlineStyle) {
        if text.is_empty() {
            return;
        }
        let mut rich = RichText::new(text).size(size);
        if style.strong {
            rich = rich.strong();
        }
        if style.italics {
            rich = rich.italics();
        }
        if style.strike {
            rich = rich.strikethrough();
        }
        let mut text_color = style.color;
        if text_color.is_none() && style.strong {
            if let Some(override_color) = ui.visuals().override_text_color {
                text_color = Some(override_color);
            }
        }
        if let Some(color) = text_color {
            rich = rich.color(color);
        }
        let response = ui.add(egui::Label::new(rich).wrap(true));

        // Add context menu for text
        // Note: Due to egui limitations, selection is cleared on right-click
        // As a workaround, we provide "Copy Text" for the segment
        #[cfg(test)]
        {
            let _ = &response;
            self.render_text_context_menu(ui, text);
        }
        #[cfg(not(test))]
        response.context_menu(|ui| {
            self.render_text_context_menu(ui, text);
        });
    }

    fn render_highlighted_segment(
        &self,
        ui: &mut egui::Ui,
        text: &str,
        size: f32,
        style: InlineStyle,
    ) {
        if text.is_empty() {
            return;
        }
        let visuals = ui.visuals();
        let bg = visuals.selection.bg_fill;
        let fallback_color = visuals.selection.stroke.color;
        let text_color = style.color.unwrap_or(fallback_color);

        let mut rich = RichText::new(text)
            .size(size)
            .background_color(bg)
            .color(text_color);
        if style.strong {
            rich = rich.strong();
        }
        if style.italics {
            rich = rich.italics();
        }
        if style.strike {
            rich = rich.strikethrough();
        }
        let response = ui.add(egui::Label::new(rich).wrap(true));

        // Add context menu for highlighted text
        #[cfg(test)]
        {
            let _ = &response;
            self.render_text_context_menu(ui, text);
        }
        #[cfg(not(test))]
        response.context_menu(|ui| {
            self.render_text_context_menu(ui, text);
        });
    }

    fn render_text_context_menu(&self, ui: &mut egui::Ui, text: &str) {
        if render_action_triggered(ui.button("Copy Text").clicked(), "copy_text") {
            self.copy_text_and_close(ui, text);
        }
        ui.label("Tip: Use Ctrl+C to copy selected text");
    }

    fn render_inline_code_context_menu(&self, ui: &mut egui::Ui, code: &str) {
        if render_action_triggered(ui.button("Copy Code").clicked(), "copy_inline_code") {
            self.copy_text_and_close(ui, code);
        }
    }

    fn render_code_block_context_menu(
        &self,
        ui: &mut egui::Ui,
        code: &str,
        language: Option<&str>,
    ) {
        if render_action_triggered(ui.button("Copy Code").clicked(), "copy_code_block") {
            self.copy_text_and_close(ui, code);
        }
        if let Some(lang) = language {
            if render_action_triggered(
                ui.button(format!("Copy as {}", lang)).clicked(),
                "copy_code_block_lang",
            ) {
                self.copy_text_and_close(ui, &format!("```{}\n{}\n```", lang, code));
            }
        }
    }

    fn render_link_context_menu(&self, ui: &mut egui::Ui, text: &str, url: &str) {
        if render_action_triggered(ui.button("Open Link").clicked(), "open_link") {
            self.trigger_link(url);
            ui.close_menu();
        }
        ui.separator();
        if render_action_triggered(ui.button("Copy Link Text").clicked(), "copy_link_text") {
            self.copy_text_and_close(ui, text);
        }
        if render_action_triggered(ui.button("Copy Link URL").clicked(), "copy_link_url") {
            self.copy_text_and_close(ui, url);
        }
    }

    fn render_cell_context_menu(&self, ui: &mut egui::Ui, text: &str) {
        if render_action_triggered(ui.button("Copy Cell Text").clicked(), "copy_cell_text") {
            self.copy_text_and_close(ui, text);
        }
    }

    fn copy_text_and_close(&self, ui: &mut egui::Ui, text: &str) {
        ui.ctx().copy_text(text.to_string());
        ui.close_menu();
    }

    /// Map a grapheme cluster to an emoji image key if available.
    fn emoji_key_for_grapheme(&self, g: &str) -> Option<String> {
        if crate::emoji_catalog::image_bytes_for(g).is_some() {
            return Some(g.to_string());
        }
        let stripped: String = g.chars().filter(|&c| c != '\u{FE0F}').collect();
        if stripped != g && crate::emoji_catalog::image_bytes_for(&stripped).is_some() {
            return Some(stripped);
        }
        // If the grapheme explicitly requests emoji presentation (contains VS16),
        // treat it as an emoji even if we don't have a sprite; fall back to a
        // generated placeholder via emoji_assets to avoid stray tofu.
        if g.chars().any(|c| c == '\u{FE0F}') {
            return Some(stripped); // prefer stripped as the texture key
        }
        None
    }

    fn get_or_make_emoji_texture(&self, ui: &mut egui::Ui, emoji: &str) -> egui::TextureHandle {
        if let Some(tex) = self.emoji_textures.borrow().get(emoji) {
            return tex.clone();
        }

        let img = if let Some(bytes) = emoji_catalog::image_bytes_for(emoji) {
            let bytes = {
                #[cfg(test)]
                {
                    if FORCE_EMOJI_DECODE_ERROR.swap(false, Ordering::Relaxed) {
                        b"mdmdview"
                    } else {
                        bytes
                    }
                }
                #[cfg(not(test))]
                {
                    bytes
                }
            };
            match image::load_from_memory(bytes) {
                Ok(dyn_img) => {
                    let rgba = dyn_img.to_rgba8();
                    let (w, h) = rgba.dimensions();
                    let pixels = rgba.into_vec();
                    egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &pixels)
                }
                Err(_) => match emoji_assets::make_image(emoji, 64) {
                    Some(img) => img,
                    None => self.generate_emoji_image(emoji, 64),
                },
            }
        } else {
            match emoji_assets::make_image(emoji, 64) {
                Some(img) => img,
                None => self.generate_emoji_image(emoji, 64),
            }
        };
        let handle = ui.ctx().load_texture(
            format!("emoji:{}", emoji),
            img,
            egui::TextureOptions::LINEAR,
        );
        self.emoji_textures
            .borrow_mut()
            .insert(emoji.to_string(), handle.clone());
        handle
    }

    #[cfg(test)]
    // Rough width measurement for inline spans without wrapping
    fn measure_inline_spans(&self, ui: &egui::Ui, spans: &[InlineSpan]) -> f32 {
        let mut max_line_width = 0.0f32;
        let mut current_line_width = 0.0f32;
        ui.fonts(|fonts| {
            let body = egui::FontId::proportional(self.font_sizes.body);
            let mono = egui::FontId::monospace(self.font_sizes.code);
            for span in spans {
                match span {
                    InlineSpan::Text(t)
                    | InlineSpan::Strong(t)
                    | InlineSpan::Emphasis(t)
                    | InlineSpan::Strikethrough(t)
                    | InlineSpan::Link { text: t, .. } => {
                        // Normalize to match render path before measuring.
                        let mut normalized = self.fix_unicode_chars(t);
                        normalized = Self::expand_shortcodes(&normalized);
                        normalized = Self::expand_superscripts(&normalized);
                        for (line_idx, line) in normalized.split('\n').enumerate() {
                            if line_idx > 0 {
                                max_line_width = max_line_width.max(current_line_width);
                                current_line_width = 0.0;
                            }
                            if line.is_empty() {
                                continue;
                            }
                            let galley = fonts.layout_no_wrap(
                                line.to_string(),
                                body.clone(),
                                Color32::WHITE,
                            );
                            let mut line_width = galley.size().x;
                            // Add a small extra width for emoji images (drawn larger than text).
                            let emoji_extra =
                                line.chars().filter(|c| Self::is_known_emoji(*c)).count() as f32
                                    * (self.font_sizes.body * 0.2);
                            line_width += emoji_extra;
                            if current_line_width > 0.0 {
                                current_line_width += 4.0;
                            }
                            current_line_width += line_width;
                        }
                    }
                    InlineSpan::Code(code) => {
                        for (line_idx, line) in code.split('\n').enumerate() {
                            if line_idx > 0 {
                                max_line_width = max_line_width.max(current_line_width);
                                current_line_width = 0.0;
                            }
                            if line.is_empty() {
                                continue;
                            }
                            let galley = fonts.layout_no_wrap(
                                line.to_string(),
                                mono.clone(),
                                Color32::WHITE,
                            );
                            let line_width = galley.size().x + 6.0; // padding for code background
                            if current_line_width > 0.0 {
                                current_line_width += 4.0;
                            }
                            current_line_width += line_width;
                        }
                    }
                    InlineSpan::Image { src, .. } => {
                        // Use cached texture size if available; otherwise a conservative thumbnail.
                        let cap = (ui.available_width() * 0.6).max(48.0);
                        let cached = self
                            .image_textures
                            .borrow_mut()
                            .get(src)
                            .map(|entry| entry.size[0] as f32 * self.ui_scale());
                        let approx = cached.unwrap_or(self.font_sizes.body * 12.0);
                        let line_width = approx.min(cap);
                        if current_line_width > 0.0 {
                            current_line_width += 4.0;
                        }
                        current_line_width += line_width;
                    }
                }
            }
        });
        max_line_width.max(current_line_width)
    }

    #[cfg(test)]
    fn is_known_emoji(c: char) -> bool {
        matches!(
            c,
            '\u{1f389}' // 
                | '\u{2705}' // 
                | '\u{1f680}' // 
                | '\u{1f642}' // 
                | '\u{1f600}' // 
                | '\u{1f609}' // 
                | '\u{2b50}'  // 
                | '\u{1f525}' // 
                | '\u{1f44d}' // 
                | '\u{1f44e}' // 
                | '\u{1f4a1}' // 
                | '\u{2753}'  // 
                | '\u{2757}'  // 
                | '\u{1f4dd}' // 
                | '\u{1f9e0}' // 
                | '\u{1f9ea}' // 
                | '\u{1f4e6}' // 
                | '\u{1f527}' // 
        )
    }

    fn expand_shortcodes(s: &str) -> String {
        use crate::emoji_catalog::shortcode_map;
        if !s.contains(':') {
            return s.to_string();
        }
        let mut out = String::new();
        let map = shortcode_map();
        let mut i = 0;
        let bytes = s.as_bytes();
        while i < s.len() {
            if bytes[i] == b':' {
                if let Some(end_rel) = bytes[i + 1..].iter().position(|&b| b == b':') {
                    let end = i + 1 + end_rel;
                    let code = &s[i..=end];
                    if let Some(&emoji) = map.get(code) {
                        out.push_str(emoji);
                        i = end + 1;
                        continue;
                    }
                }
            }
            // advance by one UTF-8 character
            let ch = s[i..].chars().next().unwrap();
            out.push(ch);
            i += ch.len_utf8();
        }
        out
    }

    // Expand ^...^ segments into Unicode superscript characters when available.
    // Example: "5^th^" -> "5??"
    fn expand_superscripts(s: &str) -> String {
        if !s.contains('^') {
            return s.to_string();
        }
        let mut out = String::new();
        let mut chars = s.chars().peekable();
        while let Some(c) = chars.next() {
            if c == '^' {
                // Look ahead to see if there's a matching closing caret within reasonable bounds
                let mut buf = String::new();
                let mut found_closing = false;
                let mut temp_chars = chars.clone();
                let mut char_count = 0;

                while let Some(&nc) = temp_chars.peek() {
                    if nc == '^' {
                        found_closing = true;
                        break;
                    }
                    if !nc.is_alphanumeric() && !matches!(nc, '+' | '-' | '=' | '(' | ')') {
                        break;
                    }
                    if char_count >= 10 {
                        break;
                    }
                    temp_chars.next();
                    char_count += 1;
                }

                if found_closing && char_count > 0 {
                    for nc in chars.by_ref().take(char_count) {
                        buf.push(nc);
                    }
                    // Skip the closing caret
                    chars.next();
                    out.push_str(&Self::to_superscript(&buf));
                } else {
                    out.push('^');
                }
            } else {
                out.push(c);
            }
        }
        out
    }

    fn to_superscript(s: &str) -> String {
        s.chars()
            .map(|c| match c {
                '0' => '\u{2070}',
                '1' => '\u{00b9}',
                '2' => '\u{00b2}',
                '3' => '\u{00b3}',
                '4' => '\u{2074}',
                '5' => '\u{2075}',
                '6' => '\u{2076}',
                '7' => '\u{2077}',
                '8' => '\u{2078}',
                '9' => '\u{2079}',
                '+' => '\u{207a}',
                '-' => '\u{207b}',
                '=' => '\u{207c}',
                '(' => '\u{207d}',
                ')' => '\u{207e}',
                'a' | 'A' => '\u{1d43}',
                'b' | 'B' => '\u{1d47}',
                'c' | 'C' => '\u{1d9c}',
                'd' | 'D' => '\u{1d48}',
                'e' | 'E' => '\u{1d49}',
                'f' | 'F' => '\u{1da0}',
                'g' | 'G' => '\u{1d4d}',
                'h' | 'H' => '\u{02b0}',
                'i' | 'I' => '\u{2071}',
                'j' | 'J' => '\u{02b2}',
                'k' | 'K' => '\u{1d4f}',
                'l' | 'L' => '\u{02e1}',
                'm' | 'M' => '\u{1d50}',
                'n' | 'N' => '\u{207f}',
                'o' | 'O' => '\u{1d52}',
                'p' | 'P' => '\u{1d56}',
                'q' | 'Q' => '\u{1d56}',
                'r' | 'R' => '\u{02b3}',
                's' | 'S' => '\u{02e2}',
                't' | 'T' => '\u{1d57}',
                'u' | 'U' => '\u{1d58}',
                'v' | 'V' => '\u{1d5b}',
                'w' | 'W' => '\u{02b7}',
                'x' | 'X' => '\u{02e3}',
                'y' | 'Y' => '\u{02b8}',
                'z' | 'Z' => '\u{1dbb}',
                other => other,
            })
            .collect()
    }

    fn generate_emoji_image(&self, emoji: &str, size: usize) -> egui::ColorImage {
        // Simple procedural placeholder icons to keep binary small and avoid external assets
        use egui::Color32 as C;
        let mut img = egui::ColorImage::new([size, size], C::TRANSPARENT);
        let cx = (size as i32) / 2;
        let cy = cx;
        let r = (size as i32) / 2 - 2;

        let (base, accent) = match emoji {
            "\u{1f389}" => (C::from_rgb(255, 215, 0), C::from_rgb(255, 80, 80)),
            "\u{2705}" => (C::from_rgb(30, 150, 30), C::WHITE),
            "\u{1f680}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 100, 100)),
            "\u{1f642}" | "\u{1f600}" | "\u{1f609}" => {
                (C::from_rgb(255, 205, 64), C::from_rgb(90, 60, 10))
            }
            "\u{2b50}" => (C::from_rgb(255, 215, 0), C::WHITE),
            "\u{1f525}" => (C::from_rgb(255, 120, 50), C::from_rgb(255, 200, 120)),
            "\u{1f44d}" | "\u{1f44e}" => (C::from_rgb(200, 200, 200), C::from_rgb(80, 80, 80)),
            "\u{1f4a1}" => (C::from_rgb(255, 240, 120), C::from_rgb(255, 255, 255)),
            "\u{2753}" | "\u{2757}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 255, 255)),
            "\u{1f4dd}" => (C::from_rgb(240, 240, 200), C::from_rgb(140, 140, 140)),
            "\u{1f9e0}" => (C::from_rgb(220, 160, 200), C::from_rgb(255, 255, 255)),
            "\u{1f9ea}" => (C::from_rgb(180, 220, 255), C::from_rgb(120, 160, 240)),
            "\u{1f4e6}" => (C::from_rgb(205, 170, 125), C::from_rgb(150, 110, 70)),
            "\u{1f527}" => (C::from_rgb(160, 170, 180), C::from_rgb(220, 220, 220)),
            _ => (C::from_rgb(180, 180, 180), C::WHITE),
        };

        // draw filled circle
        for y in 0..size as i32 {
            for x in 0..size as i32 {
                let dx = x - cx;
                let dy = y - cy;
                if dx * dx + dy * dy <= r * r {
                    img[(x as usize, y as usize)] = base;
                }
            }
        }

        // add a simple accent (diagonal highlight)
        for t in 0..size {
            let x = t as i32;
            let y = (t as i32) / 2;
            let xx = (x / 2 + 6).clamp(0, size as i32 - 1) as usize;
            let yy = (y + 6).clamp(0, size as i32 - 1) as usize;
            img[(xx, yy)] = accent;
        }

        img
    }

    fn render_list_paragraph(
        &self,
        ui: &mut egui::Ui,
        marker: Option<&str>,
        marker_color: Color32,
        indent_px: f32,
        spans: &[InlineSpan],
    ) {
        // Split into lines on embedded '\n'
        let mut lines: Vec<Vec<InlineSpan>> = vec![Vec::new()];
        for s in spans.iter().cloned() {
            match s {
                InlineSpan::Text(t) if t.contains('\n') => {
                    let parts: Vec<&str> = t.split('\n').collect();
                    for (pi, part) in parts.iter().enumerate() {
                        if !part.is_empty() {
                            lines
                                .last_mut()
                                .unwrap()
                                .push(InlineSpan::Text(part.to_string()));
                        }
                        if pi < parts.len() - 1 {
                            lines.push(Vec::new());
                        }
                    }
                }
                other => lines.last_mut().unwrap().push(other),
            }
        }

        for (li, mut line) in lines.into_iter().enumerate() {
            ui.horizontal_wrapped(|ui| {
                if li == 0 {
                    if let Some(marker) = marker {
                        ui.label(
                            RichText::new(format!("{} ", marker))
                                .size(self.font_sizes.body)
                                .color(marker_color),
                        );
                    } else {
                        ui.add_space(indent_px);
                    }
                } else {
                    // Determine additional indentation from leading spaces in this line
                    let mut leading_spaces = 0usize;
                    if let Some(InlineSpan::Text(t0)) = line.first_mut() {
                        leading_spaces = t0.chars().take_while(|c| *c == ' ').count();
                        if leading_spaces > 0 {
                            let trimmed = t0.trim_start_matches(' ').to_string();
                            *t0 = trimmed;
                        }
                    }
                    let indent = indent_px + (leading_spaces as f32) * 6.0;
                    ui.add_space(indent);
                }
                ui.spacing_mut().item_spacing.x = 0.0;
                for span in &line {
                    self.render_inline_span(ui, span, None, None);
                }
            });
        }
    }

    /// Render a list with proper inline formatting, including nested block content
    fn render_list(&self, ui: &mut egui::Ui, ordered: bool, items: &[ListItem]) {
        if items.is_empty() {
            return;
        }

        ui.add_space(4.0);
        let marker_color = ui.visuals().text_color();
        let indent_px = 18.0;

        for (index, item) in items.iter().enumerate() {
            let marker = if ordered {
                format!("{}.", index + 1)
            } else {
                "-".to_string()
            };

            let mut blocks = item.blocks.iter();
            if let Some(first_block) = blocks.next() {
                match first_block {
                    MarkdownElement::Paragraph(spans) => {
                        self.render_list_paragraph(
                            ui,
                            Some(&marker),
                            marker_color,
                            indent_px,
                            spans,
                        );
                    }
                    _ => {
                        ui.horizontal_wrapped(|ui| {
                            ui.label(
                                RichText::new(format!("{} ", marker))
                                    .size(self.font_sizes.body)
                                    .color(marker_color),
                            );
                        });
                        self.render_list_block(ui, first_block, indent_px, marker_color);
                    }
                }
            } else {
                ui.horizontal_wrapped(|ui| {
                    ui.label(
                        RichText::new(format!("{} ", marker))
                            .size(self.font_sizes.body)
                            .color(marker_color),
                    );
                });
            }

            for block in blocks {
                self.render_list_block(ui, block, indent_px, marker_color);
            }
        }

        ui.add_space(4.0);
    }

    fn render_list_block(
        &self,
        ui: &mut egui::Ui,
        block: &MarkdownElement,
        indent_px: f32,
        marker_color: Color32,
    ) {
        match block {
            MarkdownElement::Paragraph(spans) => {
                self.render_list_paragraph(ui, None, marker_color, indent_px, spans);
            }
            _ => {
                ui.horizontal(|ui| {
                    ui.add_space(indent_px);
                    ui.vertical(|ui| {
                        self.render_element_body(ui, block);
                    });
                });
            }
        }
    }

    /// Render a code block with syntax highlighting
    fn render_code_block(&self, ui: &mut egui::Ui, language: Option<&str>, code: &str) {
        ui.add_space(8.0);

        // Special handling for Mermaid diagrams
        if let Some(lang) = language {
            if lang.eq_ignore_ascii_case("mermaid") {
                let _ = self.render_mermaid_block(ui, code);
                ui.add_space(8.0);
                return;
            }
        }

        let frame_response = egui::Frame::none()
            .fill(Color32::from_rgb(25, 25, 25))
            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
            .inner_margin(8.0)
            .show(ui, |ui| {
                ui.with_layout(egui::Layout::top_down(egui::Align::LEFT), |ui| {
                    if let Some(lang) = language {
                        ui.label(
                            RichText::new(lang)
                                .size(self.font_sizes.code - 1.0)
                                .color(Color32::from_rgb(150, 150, 150))
                                .family(egui::FontFamily::Monospace),
                        );
                        ui.add_space(2.0);
                    }

                    // Try syntax highlighting
                    if let Some(lang) = language {
                        if let Some(syntax) = self
                            .find_syntax_for_language(lang)
                            .or_else(|| self.syntax_set.find_syntax_by_first_line(code))
                        {
                            let theme = &self.theme_set.themes["base16-ocean.dark"];
                            let mut h = HighlightLines::new(syntax, theme);

                            for line in LinesWithEndings::from(code) {
                                let ranges =
                                    h.highlight_line(line, &self.syntax_set).unwrap_or_default();

                                ui.horizontal_wrapped(|ui| {
                                    // Remove spacing between tokens to avoid visual gaps
                                    ui.spacing_mut().item_spacing.x = 0.0;
                                    for (style, text) in ranges {
                                        // Drop newline characters completely; they're handled by the outer line loop
                                        let cleaned = text.replace(['\n', '\r'], "");

                                        if cleaned.is_empty() {
                                            continue;
                                        }

                                        // Check if this token is pure whitespace (spaces or tabs only)
                                        if cleaned.chars().all(|c| c == ' ' || c == '\t') {
                                            // Render whitespace as transparent to preserve layout without visual gaps
                                            ui.label(
                                                RichText::new(cleaned)
                                                    .size(self.font_sizes.code)
                                                    .color(Color32::TRANSPARENT)
                                                    .family(egui::FontFamily::Monospace),
                                            );
                                        } else {
                                            // For non-whitespace, use normal highlighting but replace spaces with transparent ones
                                            let color = Color32::from_rgb(
                                                style.foreground.r,
                                                style.foreground.g,
                                                style.foreground.b,
                                            );

                                            // Split by spaces and handle separately
                                            let parts: Vec<&str> = cleaned.split(' ').collect();
                                            for (i, part) in parts.iter().enumerate() {
                                                if !part.is_empty() {
                                                    let mut rich_text = RichText::new(*part)
                                                        .size(self.font_sizes.code)
                                                        .color(color)
                                                        .family(egui::FontFamily::Monospace);

                                                    if style.font_style.contains(
                                                        syntect::highlighting::FontStyle::BOLD,
                                                    ) {
                                                        rich_text = rich_text.strong();
                                                    }
                                                    if style.font_style.contains(
                                                        syntect::highlighting::FontStyle::ITALIC,
                                                    ) {
                                                        rich_text = rich_text.italics();
                                                    }

                                                    ui.label(rich_text);
                                                }

                                                // Add transparent space between parts (except after last part)
                                                if i < parts.len() - 1 {
                                                    ui.label(
                                                        RichText::new(" ")
                                                            .size(self.font_sizes.code)
                                                            .color(Color32::TRANSPARENT)
                                                            .family(egui::FontFamily::Monospace),
                                                    );
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                            return; // Early return if highlighting succeeded
                        }
                    }

                    // Fallback: render as plain text
                    ui.label(
                        RichText::new(code)
                            .size(self.font_sizes.code)
                            .color(Color32::from_rgb(220, 220, 220))
                            .family(egui::FontFamily::Monospace),
                    );
                });
            });

        // Add context menu for code blocks
        #[cfg(test)]
        {
            let _ = &frame_response;
            self.render_code_block_context_menu(ui, code, language);
        }
        #[cfg(not(test))]
        frame_response.response.context_menu(|ui| {
            self.render_code_block_context_menu(ui, code, language);
        });

        ui.add_space(8.0);
    }

    /// Try to render a Mermaid diagram. Returns true if handled (rendered or placeholder drawn).
    fn render_mermaid_block(&self, ui: &mut egui::Ui, code: &str) -> bool {
        self.mermaid
            .render_block(ui, code, self.ui_scale(), self.font_sizes.code)
    }

    fn hash_str(s: &str) -> u64 {
        let mut h = DefaultHasher::new();
        s.hash(&mut h);
        h.finish()
    }

    fn hash_inline_spans(spans: &[InlineSpan]) -> u64 {
        let mut h = DefaultHasher::new();
        for span in spans {
            match span {
                InlineSpan::Text(t) => {
                    0u8.hash(&mut h);
                    t.hash(&mut h);
                }
                InlineSpan::Code(t) => {
                    1u8.hash(&mut h);
                    t.hash(&mut h);
                }
                InlineSpan::Strong(t) => {
                    2u8.hash(&mut h);
                    t.hash(&mut h);
                }
                InlineSpan::Emphasis(t) => {
                    3u8.hash(&mut h);
                    t.hash(&mut h);
                }
                InlineSpan::Strikethrough(t) => {
                    4u8.hash(&mut h);
                    t.hash(&mut h);
                }
                InlineSpan::Link { text, url } => {
                    5u8.hash(&mut h);
                    text.hash(&mut h);
                    url.hash(&mut h);
                }
                InlineSpan::Image { src, alt, title } => {
                    6u8.hash(&mut h);
                    src.hash(&mut h);
                    alt.hash(&mut h);
                    title.hash(&mut h);
                }
            }
        }
        h.finish()
    }

    fn alignment_hash(align: Alignment) -> u8 {
        match align {
            Alignment::None => 0,
            Alignment::Left => 1,
            Alignment::Center => 2,
            Alignment::Right => 3,
        }
    }

    fn alignment_to_egui(align: Alignment) -> Align {
        match align {
            Alignment::Center => Align::Center,
            Alignment::Right => Align::RIGHT,
            Alignment::Left | Alignment::None => Align::LEFT,
        }
    }

    fn alignment_for_column(alignments: &[Alignment], col_idx: usize) -> Align {
        alignments
            .get(col_idx)
            .copied()
            .map(Self::alignment_to_egui)
            .unwrap_or(Align::LEFT)
    }

    fn align_to_u8(align: Align) -> u8 {
        if align == Align::LEFT {
            0
        } else if align == Align::Center {
            1
        } else {
            2
        }
    }

    fn next_table_index(&self) -> u64 {
        let mut counter = self.table_counter.borrow_mut();
        let idx = *counter;
        *counter += 1;
        idx
    }

    fn compute_table_id(
        &self,
        headers: &[Vec<InlineSpan>],
        rows: &[Vec<Vec<InlineSpan>>],
        alignments: &[Alignment],
        table_index: u64,
    ) -> u64 {
        let mut hasher = DefaultHasher::new();
        if let Some(base) = self.base_dir.borrow().as_ref() {
            base.hash(&mut hasher);
        }
        hasher.write_u64(table_index);
        hasher.write_u64(self.compute_table_content_hash(headers, rows, alignments));
        hasher.finish()
    }

    fn compute_table_content_hash(
        &self,
        headers: &[Vec<InlineSpan>],
        rows: &[Vec<Vec<InlineSpan>>],
        alignments: &[Alignment],
    ) -> u64 {
        let mut hasher = DefaultHasher::new();
        hasher.write_usize(headers.len());
        for header in headers {
            hasher.write_u64(Self::hash_inline_spans(header));
        }
        hasher.write_usize(alignments.len());
        for align in alignments {
            hasher.write_u8(Self::alignment_hash(*align));
        }
        let mut counted = 0usize;
        for row in rows {
            for cell in row {
                hasher.write_u64(Self::hash_inline_spans(cell));
            }
            counted += 1;
            if counted >= COLUMN_STATS_SAMPLE_ROWS {
                break;
            }
        }
        hasher.finish()
    }

    fn column_stats_for_table(
        &self,
        table_id: u64,
        headers: &[Vec<InlineSpan>],
        rows: &[Vec<Vec<InlineSpan>>],
        alignments: &[Alignment],
    ) -> Vec<ColumnStat> {
        let content_hash = self.compute_table_content_hash(headers, rows, alignments);
        if let Some(entry) = self
            .column_stats_cache
            .borrow()
            .get(&table_id)
            .filter(|entry| entry.content_hash == content_hash)
        {
            return entry.stats.clone();
        }
        let stats = compute_column_stats(headers, rows, COLUMN_STATS_SAMPLE_ROWS);
        self.column_stats_cache.borrow_mut().insert(
            table_id,
            ColumnStatsCacheEntry {
                content_hash,
                stats: stats.clone(),
            },
        );
        stats
    }

    /// Render a table using an egui Grid
    fn render_table(
        &self,
        ui: &mut egui::Ui,
        headers: &[Vec<InlineSpan>],
        rows: &[Vec<Vec<InlineSpan>>],
        alignments: &[Alignment],
    ) {
        if headers.is_empty() {
            return;
        }

        let table_index = self.next_table_index();
        let table_id = self.compute_table_id(headers, rows, alignments, table_index);
        self.render_table_tablebuilder(ui, headers, rows, alignments, table_id);
        ui.add_space(8.0);
    }

    fn extend_table_rect(target: &mut Option<egui::Rect>, rect: egui::Rect) {
        if rect.min.x.is_nan() || rect.min.y.is_nan() || rect.max.x.is_nan() || rect.max.y.is_nan()
        {
            return;
        }
        if let Some(existing) = target {
            existing.min.x = existing.min.x.min(rect.min.x);
            existing.min.y = existing.min.y.min(rect.min.y);
            existing.max.x = existing.max.x.max(rect.max.x);
            existing.max.y = existing.max.y.max(rect.max.y);
        } else {
            *target = Some(rect);
        }
    }

    fn render_table_tablebuilder(
        &self,
        ui: &mut egui::Ui,
        headers: &[Vec<InlineSpan>],
        rows: &[Vec<Vec<InlineSpan>>],
        alignments: &[Alignment],
        table_id: u64,
    ) {
        let column_stats = self.column_stats_for_table(table_id, headers, rows, alignments);
        let ctx =
            TableColumnContext::new(headers, rows, &column_stats, self.font_sizes.body, table_id);
        let mut column_specs = derive_column_specs(&ctx);
        #[cfg(test)]
        if let Some(policies) = take_forced_table_policies() {
            for (spec, policy) in column_specs.iter_mut().zip(policies.into_iter()) {
                spec.set_policy(policy);
            }
        }
        self.apply_persisted_widths(table_id, &mut column_specs);
        let column_aligns: Vec<Align> = (0..column_specs.len())
            .map(|ci| Self::alignment_for_column(alignments, ci))
            .collect();

        let column_spacing = ui.spacing().item_spacing.x.max(6.0);
        let available_width = ui.available_width().max(1.0);
        let min_floor = self.table_min_column_width();
        let resolved_widths = self.resolve_table_column_widths(table_id, &column_specs, min_floor);
        let min_widths: Vec<f32> = column_specs
            .iter()
            .map(|spec| match spec.policy {
                ColumnPolicy::Fixed { width, .. } => width,
                ColumnPolicy::Resizable { min, .. } => min,
                ColumnPolicy::Remainder { .. } | ColumnPolicy::Auto => min_floor,
            })
            .collect();
        let spacing_total = column_spacing * column_specs.len().saturating_sub(1) as f32;
        let available_for_columns = available_width - spacing_total;
        let mut fixed_total = 0.0;
        let mut flexible_indices: Vec<usize> = Vec::new();
        let mut remainder_indices: Vec<usize> = Vec::new();
        for (idx, spec) in column_specs.iter().enumerate() {
            match spec.policy {
                ColumnPolicy::Fixed { width, .. } => fixed_total += width,
                ColumnPolicy::Resizable { .. } => flexible_indices.push(idx),
                ColumnPolicy::Remainder { .. } => {
                    flexible_indices.push(idx);
                    remainder_indices.push(idx);
                }
                ColumnPolicy::Auto => flexible_indices.push(idx),
            }
        }
        let min_flex_total: f32 = flexible_indices.iter().map(|idx| min_widths[*idx]).sum();
        let desired_total_width = resolved_widths.iter().sum::<f32>() + spacing_total;
        let content_width = desired_total_width.max(available_width);
        let remaining_for_flex = available_for_columns - fixed_total;
        let use_hscroll = available_for_columns <= 0.0
            || fixed_total > available_for_columns + 0.5
            || remaining_for_flex < min_flex_total - 0.5;
        let mut adjusted_widths = resolved_widths.clone();
        let mut scaled_down = false;
        if !use_hscroll {
            let remaining = remaining_for_flex.max(0.0);
            let flex_total: f32 = flexible_indices
                .iter()
                .map(|idx| resolved_widths[*idx])
                .sum();
            if flex_total > remaining + 0.5 {
                if remaining <= min_flex_total + 0.5 {
                    for idx in &flexible_indices {
                        adjusted_widths[*idx] = min_widths[*idx].max(1.0);
                    }
                } else {
                    let extra_total = flex_total - min_flex_total;
                    let extra_scale = ((remaining - min_flex_total) / extra_total).clamp(0.0, 1.0);
                    for idx in &flexible_indices {
                        let min_width = min_widths[*idx];
                        let desired = resolved_widths[*idx];
                        let extra = (desired - min_width).max(0.0);
                        adjusted_widths[*idx] = (min_width + extra * extra_scale).max(1.0);
                    }
                }
                scaled_down = true;
            }
        }
        let column_layout: Vec<Column> = if use_hscroll {
            column_specs.iter().map(|spec| spec.as_column()).collect()
        } else {
            column_specs
                .iter()
                .enumerate()
                .map(|(idx, spec)| {
                    let width = adjusted_widths
                        .get(idx)
                        .copied()
                        .unwrap_or(min_floor)
                        .max(1.0);
                    match spec.policy {
                        ColumnPolicy::Fixed { width, clip } => {
                            let mut col = Column::exact(width);
                            if clip {
                                col = col.clip(true);
                            }
                            col
                        }
                        ColumnPolicy::Resizable { min, clip, .. } => {
                            let mut col = Column::initial(width)
                                .at_least(min.min(width))
                                .resizable(true);
                            if clip {
                                col = col.clip(true);
                            }
                            col
                        }
                        ColumnPolicy::Remainder { clip } => {
                            let mut col = if scaled_down {
                                Column::initial(width).at_least(min_floor.min(width))
                            } else {
                                Column::remainder().at_least(min_floor)
                            };
                            if clip {
                                col = col.clip(true);
                            }
                            col
                        }
                        ColumnPolicy::Auto => {
                            if scaled_down {
                                Column::initial(width).at_least(min_floor.min(width))
                            } else {
                                Column::auto_with_initial_suggestion(width).at_least(min_floor)
                            }
                        }
                    }
                })
                .collect()
        };

        let render_table = |ui: &mut egui::Ui, max_width: f32| {
            let width_bucket = max_width.round() as i32;
            ui.push_id((table_id, width_bucket), |ui| {
                let layout = *ui.layout();
                ui.allocate_ui_with_layout(Vec2::new(max_width, 0.0), layout, |ui| {
                    ui.set_width(max_width);
                    let needs_estimate = {
                        let metrics = self.table_metrics.borrow();
                        metrics
                            .entry(table_id)
                            .is_none_or(|entry| entry.rows.is_empty())
                    };
                    self.begin_table_pass(table_id, rows.len());

                    let prev_spacing = ui.spacing().item_spacing;
                    if (prev_spacing.x - column_spacing).abs() > f32::EPSILON {
                        ui.spacing_mut().item_spacing.x = column_spacing;
                    }

                    let cached_header_height = self
                        .table_metrics
                        .borrow()
                        .entry(table_id)
                        .and_then(|entry| entry.header_height());
                    // Rough header height estimation using equally divided width; refines on next frame via cache.
                    let header_height = cached_header_height.unwrap_or_else(|| {
                        let mut estimate = self.row_height_fallback();
                        let column_count = column_specs.len().max(1);
                        let approx_width = (ui.available_width() / column_count as f32)
                            .max(self.font_sizes.body * 6.0)
                            .max(48.0);
                        let style = ui.style().clone();
                        estimate = headers
                            .iter()
                            .enumerate()
                            .map(|(ci, spans)| {
                                let halign = column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
                                let build = self.cached_layout_job(
                                    &style,
                                    None,
                                    ci,
                                    spans,
                                    approx_width,
                                    true,
                                    halign,
                                );
                                ui.fonts(|f| f.layout_job(build.job.clone()).size().y + 6.0)
                            })
                            .fold(estimate, |acc, h| acc.max(h));
                        estimate.min(self.row_height_fallback() * 3.0)
                    });

                    let fallback_row_height = self.row_height_fallback();
                    let mut row_heights: Vec<f32> = (0..rows.len())
                        .map(|idx| self.row_height_hint(table_id, idx))
                        .collect();
                    if needs_estimate {
                        let approx_widths = self.estimate_table_column_widths(
                            &column_specs,
                            max_width,
                            column_spacing,
                        );
                        let style = ui.style().clone();
                        for (idx, row) in rows.iter().enumerate() {
                            if self.row_needs_height_estimate(row) {
                                let estimate = self.estimate_table_row_height(
                                    ui,
                                    &style,
                                    row,
                                    &column_aligns,
                                    &approx_widths,
                                    fallback_row_height,
                                );
                                row_heights[idx] = row_heights[idx].max(estimate);
                            }
                        }
                    }

                    // Capture painter from outer UI BEFORE TableBuilder to ensure dividers
                    // paint on top of both header and body (fixes header divider visibility).
                    let outer_painter = ui.painter().clone();
                    let outer_visuals = ui.visuals().clone();
                    let outer_ctx = ui.ctx().clone();

                    let mut table = TableBuilder::new(ui).striped(true).vscroll(false);
                    for column in &column_layout {
                        table = table.column(*column);
                    }

                    // Use RefCell to allow capturing widths from body closure.
                    // BUG FIX: Previously captured ui.min_rect().width() which is the cell *content* width.
                    // Now we capture body.widths() which gives the actual *allocated* column widths.
                    // See: https://docs.rs/egui_extras/latest/egui_extras/struct.TableBody.html#method.widths
                    let column_widths: RefCell<Vec<f32>> =
                        RefCell::new(vec![0.0f32; column_specs.len()]);
                    // Track header and body rects separately for accurate table bounds calculation.
                    // The header rect captures the header row bounds, body_rect captures body row bounds.
                    // These are combined after rendering to get the full table rect.
                    let mut header_rect: Option<egui::Rect> = None;
                    let mut body_rect: Option<egui::Rect> = None;
                    // body_layout_rect captures the allocated layout region from body.max_rect(),
                    // which is more accurate than union of cell min_rects for table width.
                    let body_layout_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);
                    // Track clip rects separately for header and body, then union them.
                    // This ensures dividers respect scroll boundaries for both regions.
                    let mut header_clip_rect: Option<egui::Rect> = None;
                    let body_clip_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);

                    let mut height_change = false;
                    let header_height_actual = Cell::new(0.0f32);
                    table
                        .header(header_height, |mut header| {
                            for (ci, _) in column_specs.iter().enumerate() {
                                header.col(|ui| {
                                    let width = ui.available_width().max(1.0);
                                    let spans =
                                        headers.get(ci).map(|v| v.as_slice()).unwrap_or(&[]);
                                    let halign =
                                        column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
                                    let cell_height = self.render_overhauled_cell(
                                        ui, spans, width, true, None, ci, halign,
                                    );
                                    header_height_actual
                                        .set(header_height_actual.get().max(cell_height));
                                    // NOTE: Do NOT capture ui.min_rect().width() here - that's the content width,
                                    // not the column width. Column widths are captured from body.widths() below.
                                    // Extend header_rect (not body_rect) for accurate header bounds.
                                    Self::extend_table_rect(&mut header_rect, ui.min_rect());
                                    if header_clip_rect.is_none() {
                                        header_clip_rect = Some(ui.clip_rect());
                                    }
                                });
                            }
                        })
                        .body(|body| {
                            // Capture the actual allocated column widths from the table layout system.
                            // This MUST be done before heterogeneous_rows() consumes the body.
                            *column_widths.borrow_mut() = body.widths().to_vec();

                            // Capture body's layout rect for accurate table width calculation.
                            // This is the allocated region, not the content bounds.
                            *body_layout_rect.borrow_mut() = Some(body.max_rect());

                            let row_height_hints = row_heights.clone();
                            body.heterogeneous_rows(row_height_hints.into_iter(), |mut row| {
                                let idx = row.index();
                                let row_cells = rows.get(idx);
                                let mut row_height = fallback_row_height;
                                for (ci, _) in column_specs.iter().enumerate() {
                                    let mut cell_height = fallback_row_height;
                                    row.col(|ui| {
                                        let width = ui.available_width().max(1.0);
                                        let spans = row_cells
                                            .and_then(|cells| cells.get(ci))
                                            .map(|cell| cell.as_slice())
                                            .unwrap_or(&[]);
                                        let halign =
                                            column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
                                        cell_height = self.render_overhauled_cell(
                                            ui,
                                            spans,
                                            width,
                                            false,
                                            Some(idx),
                                            ci,
                                            halign,
                                        );
                                        // Extend body_rect (not header_rect) for accurate body bounds.
                                        Self::extend_table_rect(&mut body_rect, ui.min_rect());
                                        if body_clip_rect.borrow().is_none() {
                                            *body_clip_rect.borrow_mut() = Some(ui.clip_rect());
                                        }
                                    });
                                    row_height = row_height.max(cell_height);
                                }
                                if (row_height - row_heights[idx]).abs() > 0.5 {
                                    height_change = true;
                                }
                                self.update_row_height(table_id, idx, row_height);
                                self.note_row_rendered(table_id);
                            });
                        });

                    ui.spacing_mut().item_spacing = prev_spacing;

                    // Extract column widths from RefCell for use in divider painting
                    let widths = column_widths.into_inner();
                    let layout_rect = body_layout_rect.into_inner();
                    let body_clip = body_clip_rect.into_inner();
                    let measured_header_height = header_height_actual.get();
                    if self.update_header_height(table_id, measured_header_height) {
                        ui.ctx().request_repaint();
                    }

                    let (rect, clip_rect) = self.resolve_table_rects(
                        header_rect,
                        body_rect,
                        layout_rect,
                        header_clip_rect,
                        body_clip,
                        &widths,
                        column_spacing,
                    );
                    let frame_id = outer_ctx.frame_nr();
                    let change = self.record_resolved_widths(table_id, frame_id, &widths);
                    self.persist_resizable_widths(table_id, &column_specs, &widths);
                    self.handle_width_change(&outer_ctx, table_id, change);
                    // Use outer_painter (captured before TableBuilder) to ensure
                    // dividers paint on top of both header and body.
                    self.paint_table_dividers(
                        &outer_painter,
                        &outer_visuals,
                        rect,
                        clip_rect,
                        &widths,
                        header_height,
                        column_spacing,
                    );
                    if height_change {
                        ui.ctx().request_repaint();
                    }
                });
            });
        };

        if use_hscroll {
            egui::ScrollArea::horizontal()
                .id_source(("md_table_hscroll_overhaul", table_id))
                .auto_shrink([false, true])
                .scroll_bar_visibility(egui::scroll_area::ScrollBarVisibility::VisibleWhenNeeded)
                .show(ui, |ui| {
                    ui.set_min_width(content_width);
                    render_table(ui, content_width);
                });
        } else {
            render_table(ui, available_width);
        }
    }

    #[allow(clippy::too_many_arguments)]
    fn resolve_table_rects(
        &self,
        header_rect: Option<egui::Rect>,
        body_rect: Option<egui::Rect>,
        layout_rect: Option<egui::Rect>,
        header_clip_rect: Option<egui::Rect>,
        body_clip: Option<egui::Rect>,
        widths: &[f32],
        column_spacing: f32,
    ) -> (egui::Rect, egui::Rect) {
        // Combine header and body clip rects to ensure dividers respect scroll bounds.
        let clip_rect = match (header_clip_rect, body_clip) {
            (Some(h), Some(b)) => Some(h.union(b)),
            (Some(h), None) => Some(h),
            (None, Some(b)) => Some(b),
            (None, None) => None,
        };

        // Calculate accurate table width from column widths.
        // This is more accurate than union of cell min_rects which may be smaller
        // than the allocated column space.
        let calculated_width: f32 =
            widths.iter().sum::<f32>() + column_spacing * widths.len().saturating_sub(1) as f32;

        // Combine header/body bounds with layout bounds for accurate borders,
        // especially when the first column is centered or right-aligned.
        let left = layout_rect
            .map(|rect| rect.left())
            .or_else(|| header_rect.map(|rect| rect.left()))
            .or_else(|| body_rect.map(|rect| rect.left()));
        let right = left.map(|value| value + calculated_width);
        let top = header_rect
            .map(|rect| rect.top())
            .or_else(|| body_rect.map(|rect| rect.top()))
            .or_else(|| layout_rect.map(|rect| rect.top()));
        let bottom = body_rect
            .map(|rect| rect.bottom())
            .or_else(|| header_rect.map(|rect| rect.bottom()))
            .or_else(|| layout_rect.map(|rect| rect.bottom()));
        let table_rect = match (left, right, top, bottom) {
            (Some(left), Some(right), Some(top), Some(bottom)) => Some(egui::Rect::from_min_max(
                egui::pos2(left, top),
                egui::pos2(right, bottom),
            )),
            _ => None,
        };

        let rect = table_rect.unwrap_or_else(|| {
            layout_rect.unwrap_or_else(|| {
                egui::Rect::from_min_max(egui::pos2(0.0, 0.0), egui::pos2(0.0, 0.0))
            })
        });
        let clip_rect = clip_rect.unwrap_or(rect);
        (rect, clip_rect)
    }

    fn row_needs_height_estimate(&self, row: &[Vec<InlineSpan>]) -> bool {
        row.iter().any(|cell| {
            cell.iter().any(|span| match span {
                InlineSpan::Image { .. } => true,
                InlineSpan::Text(text)
                | InlineSpan::Code(text)
                | InlineSpan::Strong(text)
                | InlineSpan::Emphasis(text)
                | InlineSpan::Strikethrough(text)
                | InlineSpan::Link { text, .. } => text.contains('\n'),
            })
        })
    }

    fn table_min_column_width(&self) -> f32 {
        (self.font_sizes.body * 6.0).max(48.0)
    }

    fn resolve_table_column_widths(
        &self,
        table_id: u64,
        column_specs: &[ColumnSpec],
        min_floor: f32,
    ) -> Vec<f32> {
        if column_specs.is_empty() {
            return Vec::new();
        }

        let stored_widths = {
            let metrics = self.table_metrics.borrow();
            metrics
                .entry(table_id)
                .map(|entry| entry.current_widths().to_vec())
                .unwrap_or_default()
        };

        column_specs
            .iter()
            .enumerate()
            .map(|(idx, spec)| {
                let stored = stored_widths
                    .get(idx)
                    .copied()
                    .filter(|width| width.is_finite() && *width > 0.0);
                let width = match spec.policy {
                    ColumnPolicy::Fixed { width, .. } => width,
                    ColumnPolicy::Resizable { min, preferred, .. } => {
                        stored.unwrap_or(preferred.max(min)).max(min)
                    }
                    ColumnPolicy::Remainder { .. } => min_floor,
                    ColumnPolicy::Auto => stored.unwrap_or(min_floor).max(min_floor),
                };
                width.max(1.0)
            })
            .collect()
    }

    fn estimate_table_column_widths(
        &self,
        column_specs: &[ColumnSpec],
        max_width: f32,
        column_spacing: f32,
    ) -> Vec<f32> {
        let column_count = column_specs.len().max(1);
        let spacing_total = column_spacing * column_count.saturating_sub(1) as f32;
        let available = (max_width - spacing_total).max(1.0);
        let min_floor = self.table_min_column_width();
        let mut widths: Vec<f32> = column_specs
            .iter()
            .map(|spec| match spec.policy {
                ColumnPolicy::Fixed { width, .. } => width,
                ColumnPolicy::Resizable { min, .. } => min,
                ColumnPolicy::Remainder { .. } => min_floor,
                ColumnPolicy::Auto => min_floor,
            })
            .map(|width| width.max(1.0))
            .collect();

        if widths.is_empty() {
            return vec![available];
        }
        let sum: f32 = widths.iter().sum();
        if sum > available {
            let scale = available / sum;
            for width in &mut widths {
                *width = (*width * scale).max(1.0);
            }
        }
        widths
    }

    #[cfg(test)]
    fn estimate_table_total_width(
        &self,
        table_id: u64,
        column_specs: &[ColumnSpec],
        column_spacing: f32,
    ) -> f32 {
        if column_specs.is_empty() {
            return 0.0;
        }
        let min_floor = self.table_min_column_width();
        let widths = self.resolve_table_column_widths(table_id, column_specs, min_floor);
        let spacing_total = column_spacing * widths.len().saturating_sub(1) as f32;
        widths.iter().sum::<f32>() + spacing_total
    }

    fn estimate_table_row_height(
        &self,
        ui: &egui::Ui,
        style: &egui::Style,
        row: &[Vec<InlineSpan>],
        column_aligns: &[Align],
        widths: &[f32],
        fallback: f32,
    ) -> f32 {
        let mut max_height = fallback;
        let column_count = widths.len().max(row.len()).max(1);
        for ci in 0..column_count {
            let spans = row.get(ci).map(|cell| cell.as_slice()).unwrap_or(&[]);
            if spans.is_empty() {
                continue;
            }
            let width = widths
                .get(ci)
                .copied()
                .or_else(|| widths.last().copied())
                .unwrap_or(1.0);
            let halign = column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
            let height = self.estimate_table_cell_height(style, ui, spans, width, halign, fallback);
            max_height = max_height.max(height);
        }
        max_height
    }

    fn estimate_table_cell_height(
        &self,
        style: &egui::Style,
        ui: &egui::Ui,
        spans: &[InlineSpan],
        width: f32,
        halign: Align,
        fallback: f32,
    ) -> f32 {
        if spans.is_empty() {
            return fallback;
        }
        let fragments = self.cell_fragments(spans);
        let mut total = 0.0;
        for (idx, fragment) in fragments.into_iter().enumerate() {
            if idx > 0 {
                total += 2.0;
            }
            match fragment {
                CellFragment::Text(slice) => {
                    let build = self.build_layout_job(style, slice, width, false, halign);
                    let height = ui.fonts(|f| f.layout_job(build.job.clone()).size().y);
                    total += height;
                }
                CellFragment::Emoji(_) => {
                    total += self.font_sizes.body * 1.2;
                }
                CellFragment::Image(span) => {
                    total += self.estimate_table_image_height(ui, span, width);
                }
            }
        }
        total.max(fallback)
    }

    fn estimate_table_image_height(
        &self,
        ui: &egui::Ui,
        span: &InlineSpan,
        available_w: f32,
    ) -> f32 {
        let InlineSpan::Image { src, title, .. } = span else {
            return self.font_sizes.body * 1.2;
        };
        let resolved = self.resolve_image_path(src);
        let (tw, th) = self
            .get_or_load_image_texture(ui, &resolved)
            .map(|(_, w, h)| (w as f32, h as f32))
            .unwrap_or((self.font_sizes.body * 12.0, self.font_sizes.body * 8.0));
        let base_scale = self.ui_scale();
        let scaled_w = tw * base_scale;
        let scale = if scaled_w > available_w {
            (available_w / tw).clamp(0.01, 4.0)
        } else {
            base_scale
        };
        let mut height = (th * scale).round();
        if let Some(text) = title {
            if !text.is_empty() {
                height += 2.0 + (self.font_sizes.body - 2.0).max(1.0);
            }
        }
        height + 6.0
    }

    fn row_height_fallback(&self) -> f32 {
        self.font_sizes.body * 1.6
    }

    fn row_height_hint(&self, table_id: u64, idx: usize) -> f32 {
        let fallback = self.row_height_fallback();
        self.table_metrics
            .borrow()
            .entry(table_id)
            .and_then(|entry| entry.row(idx))
            .map(|m| {
                if m.max_height > 0.0 {
                    m.max_height
                } else {
                    fallback
                }
            })
            .unwrap_or(fallback)
    }

    fn update_row_height(&self, table_id: u64, idx: usize, height: f32) {
        let clamped = height.max(self.row_height_fallback());
        let mut metrics = self.table_metrics.borrow_mut();
        let entry = metrics.entry_mut(table_id);
        let row = entry.ensure_row(idx);
        row.max_height = clamped;
        row.dirty = false;
    }

    fn update_header_height(&self, table_id: u64, height: f32) -> bool {
        let mut metrics = self.table_metrics.borrow_mut();
        let entry = metrics.entry_mut(table_id);
        entry.update_header_height(height)
    }

    fn begin_table_pass(&self, table_id: u64, total_rows: usize) {
        let mut metrics = self.table_metrics.borrow_mut();
        metrics.entry_mut(table_id).begin_pass(total_rows);
    }

    fn note_row_rendered(&self, table_id: u64) {
        let mut metrics = self.table_metrics.borrow_mut();
        metrics.entry_mut(table_id).note_row_rendered();
    }

    fn apply_persisted_widths(&self, table_id: u64, specs: &mut [ColumnSpec]) {
        if specs.is_empty() {
            return;
        }
        let mut metrics = self.table_metrics.borrow_mut();
        let entry = metrics.entry_mut(table_id);
        for spec in specs.iter_mut() {
            if let Some(width) = entry.persisted_width(spec.policy_hash) {
                spec.apply_preferred_width(width);
            }
        }
    }

    fn persist_resizable_widths(&self, table_id: u64, specs: &[ColumnSpec], widths: &[f32]) {
        if specs.is_empty() || widths.is_empty() {
            return;
        }
        let mut metrics = self.table_metrics.borrow_mut();
        let entry = metrics.entry_mut(table_id);

        // Check if font size changed since last persist - if so, clear old widths
        // to prevent size mismatch after zoom changes. Skip persisting in this
        // frame so the next layout can compute fresh widths before we store them.
        if entry.check_font_size_change(self.font_sizes.body) {
            return;
        }

        for (spec, width) in specs.iter().zip(widths.iter()) {
            if let ColumnPolicy::Resizable { .. } = spec.policy {
                let stored = entry.persisted_width(spec.policy_hash).unwrap_or(-1.0);
                if stored < 0.0 || (stored - width).abs() > 0.5 {
                    entry.set_persisted_width(spec.policy_hash, *width);
                }
            }
        }
    }

    fn record_resolved_widths(&self, table_id: u64, frame_id: u64, widths: &[f32]) -> WidthChange {
        if widths.is_empty() {
            return WidthChange::None;
        }
        let mut metrics = self.table_metrics.borrow_mut();
        metrics.entry_mut(table_id).update_widths(widths, frame_id)
    }

    fn handle_width_change(&self, ctx: &Context, table_id: u64, change: WidthChange) {
        if matches!(change, WidthChange::Large) {
            let frame_id = ctx.frame_nr();
            let mut metrics = self.table_metrics.borrow_mut();
            let entry = metrics.entry_mut(table_id);
            if entry.last_discard_frame != Some(frame_id) {
                ctx.request_repaint();
                entry.last_discard_frame = Some(frame_id);
            }
        }
    }

    /// Paint vertical dividers between table columns, a horizontal header separator,
    /// and an outer border.
    ///
    /// # Arguments
    /// * `widths` - The actual allocated column widths from `TableBody::widths()`.
    ///   IMPORTANT: These must NOT be cell content widths from `ui.min_rect()`,
    ///   which would cause dividers to be misaligned.
    /// * `header_height` - The height of the header row. A horizontal separator is
    ///   drawn at this y-offset to visually separate header from body rows.
    #[allow(clippy::too_many_arguments)]
    fn paint_table_dividers(
        &self,
        painter: &Painter,
        visuals: &Visuals,
        rect: egui::Rect,
        clip_rect: egui::Rect,
        widths: &[f32],
        header_height: f32,
        column_spacing: f32,
    ) {
        if widths.is_empty() {
            return;
        }
        let separator_color = visuals
            .widgets
            .noninteractive
            .bg_stroke
            .color
            .gamma_multiply(0.9);
        let separator_stroke = Stroke::new(1.0, separator_color);
        let border_stroke = visuals.window_stroke();
        // Expand clip_rect to include the full table rect so borders aren't clipped.
        // The cell clip_rect may not include the outer border area.
        let expanded_clip = clip_rect.union(rect);
        let painter = painter.with_clip_rect(expanded_clip);

        // Draw vertical dividers between columns
        if widths.len() > 1 {
            let mut x = rect.left();
            for (idx, width) in widths
                .iter()
                .take(widths.len().saturating_sub(1))
                .enumerate()
            {
                x += *width;
                let divider_x = x + column_spacing * (idx as f32 + 0.5);
                let x_pos = (divider_x.round() + 0.5).clamp(rect.left(), rect.right());
                painter.vline(x_pos, rect.y_range(), separator_stroke);
            }
        }

        // Draw horizontal separator below header row
        if header_height > 0.0 {
            let header_y = rect.top() + header_height;
            if header_y < rect.bottom() {
                painter.hline(rect.x_range(), header_y.round() + 0.5, separator_stroke);
            }
        }

        // Draw outer border
        painter.rect_stroke(rect, 0.0, border_stroke);
    }

    #[allow(clippy::too_many_arguments)]
    fn render_overhauled_cell(
        &self,
        ui: &mut egui::Ui,
        spans: &[InlineSpan],
        width: f32,
        is_header: bool,
        row_idx: Option<usize>,
        col_idx: usize,
        halign: Align,
    ) -> f32 {
        let fallback_height = self.row_height_fallback();
        let fragments = self.cell_fragments(spans);
        let inner = ui.allocate_ui_with_layout(
            Vec2::new(width, 0.0),
            egui::Layout::top_down(halign),
            |ui| {
                ui.set_width(width);
                ui.set_max_width(width);
                ui.spacing_mut().item_spacing = egui::vec2(4.0, 2.0);
                if fragments.is_empty() {
                    ui.allocate_exact_size(
                        Vec2::new(width, self.font_sizes.body * 1.2),
                        egui::Sense::hover(),
                    );
                    return;
                }
                for fragment in fragments {
                    match fragment {
                        CellFragment::Text(slice) => {
                            let build = self.cached_layout_job(
                                ui.style(),
                                row_idx,
                                col_idx,
                                slice,
                                width,
                                is_header,
                                halign,
                            );
                            self.paint_table_text_job(ui, width, build);
                        }
                        CellFragment::Emoji(key) => {
                            self.render_table_emoji(ui, &key);
                        }
                        CellFragment::Image(span) => {
                            self.render_inline_span(ui, span, None, Some(is_header));
                        }
                    }
                }
            },
        );
        inner.response.rect.height().max(fallback_height)
    }

    fn paint_table_text_job(
        &self,
        ui: &mut egui::Ui,
        width: f32,
        build: LayoutJobBuild,
    ) -> egui::Response {
        let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
        let height = galley.size().y;
        let (rect, mut response) =
            ui.allocate_exact_size(Vec2::new(width, height), egui::Sense::click());
        let text_color = ui.visuals().text_color();
        let text_origin = Self::aligned_text_origin(rect, &galley, build.job.halign);
        ui.painter_at(rect)
            .galley(text_origin, galley.clone(), text_color);
        if galley.rows.len() > 1 || galley.size().x > width + 0.5 {
            response = response.on_hover_text(build.plain_text.clone());
        }
        #[cfg(test)]
        self.render_cell_context_menu(ui, &build.plain_text);
        #[cfg(not(test))]
        response.context_menu(|ui| {
            self.render_cell_context_menu(ui, &build.plain_text);
        });

        if let Some(link) = self.link_at_pointer(&response, &galley, &build, text_origin) {
            ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
            response = response.on_hover_text(link.url.clone());
            if response.clicked() {
                self.trigger_link(&link.url);
            }
        }

        response
    }

    #[allow(clippy::too_many_arguments)]
    fn cached_layout_job(
        &self,
        style: &egui::Style,
        row_idx: Option<usize>,
        col_idx: usize,
        spans: &[InlineSpan],
        width: f32,
        is_header: bool,
        halign: Align,
    ) -> LayoutJobBuild {
        let highlight_hash = self
            .highlight_phrase
            .borrow()
            .as_ref()
            .map(|s| Self::hash_str(s))
            .unwrap_or(0);
        let content_hash = Self::hash_inline_spans(spans);
        let text_color = style.visuals.text_color().to_array();
        let key = CellLayoutKey {
            row: row_idx,
            col: col_idx,
            width: width.round() as u32,
            align: Self::align_to_u8(halign),
            strong: is_header,
            text_color,
            highlight_hash,
            content_hash,
        };
        if let Some(build) = self.table_layout_cache.borrow_mut().get(&key) {
            return build;
        }
        let build = self.build_layout_job(style, spans, width, is_header, halign);
        self.table_layout_cache
            .borrow_mut()
            .insert(key, build.clone());
        build
    }

    fn link_at_pointer<'a>(
        &self,
        response: &egui::Response,
        galley: &Arc<Galley>,
        build: &'a LayoutJobBuild,
        text_origin: egui::Pos2,
    ) -> Option<&'a LinkRange> {
        let pointer = response.hover_pos()?;
        let text_rect = galley.rect.translate(text_origin.to_vec2());
        if !text_rect.contains(pointer) {
            return None;
        }
        let local = pointer - text_origin;
        let cursor = galley.cursor_from_pos(local);
        let idx = cursor.ccursor.index;
        build
            .link_ranges
            .iter()
            .find(|range| range.char_range.contains(&idx))
    }

    fn aligned_text_origin(rect: egui::Rect, galley: &Galley, halign: Align) -> egui::Pos2 {
        let galley_rect = galley.rect;
        let x = if halign == Align::RIGHT {
            rect.right() - galley_rect.right()
        } else if halign == Align::Center {
            rect.center().x - galley_rect.center().x
        } else {
            rect.left() - galley_rect.left()
        };
        egui::pos2(x, rect.top() - galley_rect.top())
    }

    fn render_table_emoji(&self, ui: &mut egui::Ui, emoji: &str) {
        let handle = self.get_or_make_emoji_texture(ui, emoji);
        let size = self.font_sizes.body * 1.2;
        ui.add(
            egui::Image::new(&handle)
                .max_size(Vec2::splat(size))
                .sense(egui::Sense::hover()),
        );
    }

    #[cfg(test)]
    fn resolve_table_widths(available: f32, mins: &[f32], desired: &[f32]) -> Vec<f32> {
        debug_assert_eq!(mins.len(), desired.len());
        if mins.is_empty() {
            return Vec::new();
        }
        let clamped_available = available.max(1.0);
        let desired_total: f32 = desired.iter().sum();
        let min_total: f32 = mins.iter().sum();

        let widths = if min_total >= clamped_available {
            mins.iter()
                .map(|m| m * (clamped_available / min_total))
                .collect()
        } else if desired_total <= clamped_available {
            let slack = desired_total - min_total;
            if slack <= f32::EPSILON {
                let bonus = (clamped_available - min_total) / mins.len() as f32;
                mins.iter().map(|m| m + bonus).collect()
            } else {
                desired.to_vec()
            }
        } else {
            let mut widths = mins.to_vec();
            let extra = clamped_available - min_total;
            let slack: Vec<f32> = desired
                .iter()
                .zip(mins.iter())
                .map(|(d, m)| (d - m).max(0.0))
                .collect();
            let total_slack: f32 = slack.iter().sum();
            for (w, s) in widths.iter_mut().zip(slack.iter()) {
                *w += extra * (*s / total_slack);
            }
            widths
        };

        widths
    }

    /// Open URL in default browser
    #[cfg(not(test))]
    fn open_url(&self, url: &str) {
        if let Err(e) = webbrowser::open(url) {
            eprintln!("Failed to open URL {}: {}", url, e);
        }
    }

    #[cfg(test)]
    fn open_url(&self, _url: &str) {}

    pub(crate) fn trigger_link(&self, url: &str) {
        if let Some(fragment) = Self::extract_fragment(url) {
            *self.pending_anchor.borrow_mut() = Some(fragment);
        } else if Self::is_allowed_scheme(url) {
            self.open_url(url);
        } else {
            eprintln!("Blocked link with unsupported scheme: {}", url);
        }
    }

    fn is_allowed_scheme(url: &str) -> bool {
        url.starts_with("http://") || url.starts_with("https://") || url.starts_with("mailto:")
    }

    /// Consume and return the last clicked internal anchor, if any
    pub fn take_pending_anchor(&self) -> Option<String> {
        self.pending_anchor.borrow_mut().take()
    }

    /// Lookup a header rect by its id (slug)
    pub fn header_rect_for(&self, id: &str) -> Option<egui::Rect> {
        self.header_rects.borrow().get(id).copied()
    }

    /// Lookup the rect for the n-th top-level element rendered in the last frame
    pub fn element_rect_at(&self, index: usize) -> Option<egui::Rect> {
        self.element_rects.borrow().get(index).copied()
    }

    pub fn layout_signature(&self) -> u64 {
        let rects = self.element_rects.borrow();
        let mut h = DefaultHasher::new();
        rects.len().hash(&mut h);
        for rect in rects.iter() {
            let min_x = (rect.min.x * 2.0).round() as i32;
            let min_y = (rect.min.y * 2.0).round() as i32;
            let max_x = (rect.max.x * 2.0).round() as i32;
            let max_y = (rect.max.y * 2.0).round() as i32;
            (min_x, min_y, max_x, max_y).hash(&mut h);
        }
        h.finish()
    }

    pub fn has_pending_renders(&self) -> bool {
        self.mermaid.has_pending() || !self.image_pending.borrow().is_empty()
    }

    /// Set or clear the highlight phrase (case-insensitive)
    pub fn set_highlight_phrase(&self, phrase: Option<&str>) {
        let normalized = phrase
            .map(|p| p.case_fold().nfkc().collect::<String>())
            .filter(|value| !value.is_empty());
        {
            let mut current = self.highlight_phrase.borrow_mut();
            if *current == normalized {
                return;
            }
            *current = normalized;
        }
        self.table_layout_cache.borrow_mut().clear();
    }

    pub fn clear_table_layout_cache(&self) {
        self.table_layout_cache.borrow_mut().clear();
        self.table_metrics.borrow_mut().clear();
        self.column_stats_cache.borrow_mut().clear();
    }

    pub fn table_layout_cache_stats(&self) -> (u64, u64) {
        self.table_layout_cache.borrow().stats()
    }

    pub fn table_render_stats(&self) -> (usize, usize) {
        self.table_metrics.borrow().totals()
    }

    /// Get a plain-text representation of a markdown element (for search)
    pub fn element_plain_text(element: &MarkdownElement) -> String {
        match element {
            MarkdownElement::Paragraph(spans) => Self::spans_plain_text(spans),
            MarkdownElement::Header { spans, .. } => Self::spans_plain_text(spans),
            MarkdownElement::CodeBlock { text, .. } => text.clone(),
            MarkdownElement::List { items, .. } => {
                let mut out = String::new();
                for item in items {
                    for block in &item.blocks {
                        if !out.is_empty() {
                            out.push('\n');
                        }
                        out.push_str(&Self::element_plain_text(block));
                    }
                }
                out
            }
            MarkdownElement::Quote { blocks, .. } => {
                let mut out = String::new();
                for block in blocks {
                    if !out.is_empty() {
                        out.push('\n');
                    }
                    out.push_str(&Self::element_plain_text(block));
                }
                out
            }
            MarkdownElement::HorizontalRule => String::from("---"),
            MarkdownElement::Table {
                headers,
                rows,
                alignments: _,
            } => {
                let mut out = String::new();
                for h in headers {
                    if !out.is_empty() {
                        out.push(' ');
                    }
                    out.push_str(&Self::spans_plain_text(h));
                }
                for row in rows {
                    for cell in row {
                        out.push(' ');
                        out.push_str(&Self::spans_plain_text(cell));
                    }
                }
                out
            }
        }
    }

    /// Set the base directory for resolving relative image paths
    pub fn set_base_dir(&self, dir: Option<&Path>) {
        if let Some(d) = dir {
            self.base_dir.borrow_mut().replace(d.to_path_buf());
        } else {
            self.base_dir.borrow_mut().take();
        }
    }

    fn poll_image_results(&self, ctx: &egui::Context) -> bool {
        let mut changed = false;
        while let Ok(result) = self.image_result_rx.try_recv() {
            match result {
                ImageLoadResult::Loaded {
                    key,
                    image,
                    size,
                    modified,
                } => {
                    let tex =
                        ctx.load_texture(format!("img:{key}"), image, egui::TextureOptions::LINEAR);
                    self.store_image_texture(&key, tex.clone(), size, modified);
                    self.image_failures.borrow_mut().remove(&key);
                    self.image_pending.borrow_mut().remove(&key);
                    changed = true;
                }
                ImageLoadResult::Failed { key } => {
                    self.image_pending.borrow_mut().remove(&key);
                    self.note_image_failure(&key);
                }
            }
        }
        if changed {
            ctx.request_repaint();
        }
        changed
    }

    fn enqueue_image_job(&self, request: ImageLoadRequest) -> Result<(), ()> {
        match self.image_job_tx.try_send(request) {
            Ok(()) => Ok(()),
            Err(TrySendError::Full(_)) => Err(()),
            Err(TrySendError::Disconnected(_)) => Err(()),
        }
    }

    fn should_retry_image(&self, key: &str) -> bool {
        let mut failures = self.image_failures.borrow_mut();
        if let Some(failure) = failures.get(key) {
            if failure.last_attempt.elapsed() < IMAGE_FAILURE_BACKOFF {
                return false;
            }
        }
        failures.remove(key);
        true
    }

    fn note_image_failure(&self, key: &str) {
        self.image_failures.borrow_mut().insert(
            key.to_string(),
            ImageFailure {
                last_attempt: Instant::now(),
            },
        );
    }

    fn resolve_image_path(&self, src: &str) -> String {
        if src.starts_with("http://") || src.starts_with("https://") || src.starts_with("data:") {
            // Keep as-is; we don't fetch remote or parse data URIs yet
            return src.to_string();
        }
        let p = Path::new(src);
        if p.is_absolute() {
            return src.to_string();
        }
        if let Some(base) = self.base_dir.borrow().as_ref() {
            let joined = base.join(p);
            return joined.to_string_lossy().into_owned();
        }
        src.to_string()
    }

    fn get_or_load_image_texture(
        &self,
        _ui: &egui::Ui,
        resolved_src: &str,
    ) -> Option<(egui::TextureHandle, u32, u32)> {
        // Reject remote for now
        if resolved_src.starts_with("http://") || resolved_src.starts_with("https://") {
            return None;
        }

        let path = Path::new(resolved_src);
        let embedded = Self::embedded_image_bytes(resolved_src);

        {
            let mut cache = self.image_textures.borrow_mut();
            if let Some(entry) = cache.get(resolved_src) {
                let stale = if embedded.is_some() {
                    false
                } else {
                    Self::image_source_stale(entry.modified, path)
                };
                if !stale {
                    return Some((entry.texture.clone(), entry.size[0], entry.size[1]));
                }
                cache.remove(resolved_src);
            }
        }

        if self.image_pending.borrow().contains(resolved_src) {
            return None;
        }

        if !self.should_retry_image(resolved_src) {
            return None;
        }

        let source = if let Some(bytes) = embedded {
            ImageLoadSource::Embedded(bytes)
        } else {
            if !path.exists() {
                self.note_image_failure(resolved_src);
                return None;
            }
            ImageLoadSource::File(path.to_path_buf())
        };

        let request = ImageLoadRequest {
            key: resolved_src.to_string(),
            source,
        };
        if self.enqueue_image_job(request).is_ok() {
            self.image_pending
                .borrow_mut()
                .insert(resolved_src.to_string());
        }
        None
    }

    fn disk_image_timestamp(path: &Path) -> Option<SystemTime> {
        std::fs::metadata(path).ok()?.modified().ok()
    }

    fn image_source_stale_with_timestamp(
        cached_modified: Option<SystemTime>,
        current: Option<SystemTime>,
    ) -> bool {
        match (cached_modified, current) {
            (Some(prev), Some(cur)) => prev != cur,
            (Some(_), None) => true,
            (None, Some(_)) => true,
            (None, None) => false,
        }
    }

    fn image_source_stale(cached_modified: Option<SystemTime>, path: &Path) -> bool {
        if !path.exists() {
            return cached_modified.is_some();
        }
        let current = Self::disk_image_timestamp(path);
        Self::image_source_stale_with_timestamp(cached_modified, current)
    }

    fn store_image_texture(
        &self,
        key: &str,
        texture: egui::TextureHandle,
        size: [u32; 2],
        modified: Option<SystemTime>,
    ) {
        self.image_textures.borrow_mut().insert(
            key.to_string(),
            ImageCacheEntry {
                texture,
                size,
                modified,
            },
        );
    }

    /// Return embedded image bytes for known assets used in sample files
    fn embedded_image_bytes(path: &str) -> Option<&'static [u8]> {
        match path.replace('\\', "/").as_str() {
            // Smiley PNG
            "assets/emoji/1f600.png" => Some(include_bytes!("../assets/emoji/1f600.png")),
            // SVG logo and WEBP sample used by images.md
            "assets/samples/logo.svg" => Some(include_bytes!("../assets/samples/logo.svg")),
            "assets/samples/webp_sample.webp" => {
                Some(include_bytes!("../assets/samples/webp_sample.webp"))
            }
            _ => None,
        }
    }

    /// Find syntax definition for a given language name
    /// Maps common language names to their syntax definitions
    fn find_syntax_for_language(&self, lang: &str) -> Option<&syntect::parsing::SyntaxReference> {
        // Create a mapping of common language names to their syntect equivalents
        let lang_lower = lang.to_lowercase();

        // Try direct name match first
        if let Some(syntax) = self.syntax_set.find_syntax_by_name(&lang_lower) {
            return Some(syntax);
        }

        // Try extension-based matching
        if let Some(syntax) = self.syntax_set.find_syntax_by_extension(&lang_lower) {
            return Some(syntax);
        }

        // Handle common language mappings
        let mapped_lang = match lang_lower.as_str() {
            "rust" => "rs",
            "python" => "py",
            "javascript" => "js",
            "typescript" => "ts",
            "c++" | "cpp" => "cpp",
            "c#" | "csharp" => "cs",
            "shell" | "bash" => "sh",
            "powershell" => "ps1",
            "yaml" => "yml",
            "markdown" => "md",
            "html" => "html",
            "css" => "css",
            "java" => "java",
            "go" => "go",
            "php" => "php",
            "ruby" => "rb",
            "xml" => "xml",
            "json" => "json",
            "sql" => "sql",
            "toml" => "toml",
            _ => &lang_lower,
        };

        // Try mapped extension
        self.syntax_set
            .find_syntax_by_extension(mapped_lang)
            .or_else(|| self.syntax_set.find_syntax_by_name(mapped_lang))
    }

    /// Zoom in (increase font sizes)
    pub fn zoom_in(&mut self) {
        self.font_sizes.body = (self.font_sizes.body * 1.1).min(32.0);
        self.font_sizes.h1 = (self.font_sizes.h1 * 1.1).min(48.0);
        self.font_sizes.h2 = (self.font_sizes.h2 * 1.1).min(42.0);
        self.font_sizes.h3 = (self.font_sizes.h3 * 1.1).min(36.0);
        self.font_sizes.h4 = (self.font_sizes.h4 * 1.1).min(32.0);
        self.font_sizes.h5 = (self.font_sizes.h5 * 1.1).min(28.0);
        self.font_sizes.h6 = (self.font_sizes.h6 * 1.1).min(24.0);
        self.font_sizes.code = (self.font_sizes.code * 1.1).min(20.0);
        self.clear_table_layout_cache();
    }

    /// Zoom out (decrease font sizes)
    pub fn zoom_out(&mut self) {
        self.font_sizes.body = (self.font_sizes.body * 0.9).max(8.0);
        self.font_sizes.h1 = (self.font_sizes.h1 * 0.9).max(16.0);
        self.font_sizes.h2 = (self.font_sizes.h2 * 0.9).max(14.0);
        self.font_sizes.h3 = (self.font_sizes.h3 * 0.9).max(12.0);
        self.font_sizes.h4 = (self.font_sizes.h4 * 0.9).max(11.0);
        self.font_sizes.h5 = (self.font_sizes.h5 * 0.9).max(10.0);
        self.font_sizes.h6 = (self.font_sizes.h6 * 0.9).max(9.0);
        self.font_sizes.code = (self.font_sizes.code * 0.9).max(8.0);
        self.clear_table_layout_cache();
    }

    /// Reset zoom to default
    pub fn reset_zoom(&mut self) {
        self.font_sizes = FontSizes::default();
        self.clear_table_layout_cache();
    }

    /// Set zoom scale relative to default font sizes.
    pub fn set_zoom_scale(&mut self, scale: f32) {
        let scale = scale.clamp(0.5, 4.0);
        let default = FontSizes::default();
        self.font_sizes.body = (default.body * scale).clamp(8.0, 32.0);
        self.font_sizes.h1 = (default.h1 * scale).clamp(16.0, 48.0);
        self.font_sizes.h2 = (default.h2 * scale).clamp(14.0, 42.0);
        self.font_sizes.h3 = (default.h3 * scale).clamp(12.0, 36.0);
        self.font_sizes.h4 = (default.h4 * scale).clamp(11.0, 32.0);
        self.font_sizes.h5 = (default.h5 * scale).clamp(10.0, 28.0);
        self.font_sizes.h6 = (default.h6 * scale).clamp(9.0, 24.0);
        self.font_sizes.code = (default.code * scale).clamp(8.0, 20.0);
        self.clear_table_layout_cache();
    }
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;
    use crate::SAMPLE_FILES;
    use image::codecs::png::PngEncoder;
    use image::ColorType;
    use image::ImageEncoder;
    use std::env;
    use std::fs;
    use std::str::FromStr;
    use std::sync::Mutex;
    use std::time::Duration;
    use syntect::highlighting::{Color, FontStyle, ScopeSelectors, StyleModifier, ThemeItem};
    use syntect::parsing::SyntaxDefinition;
    use tempfile::tempdir;

    static MERMAID_ENV_LOCK: Mutex<()> = Mutex::new(());

    struct EnvVarGuard {
        key: &'static str,
        previous: Option<String>,
        _lock: std::sync::MutexGuard<'static, ()>,
    }

    impl EnvVarGuard {
        fn set(key: &'static str, value: &str) -> Self {
            let lock = MERMAID_ENV_LOCK.lock().expect("lock mermaid env");
            let previous = env::var(key).ok();
            env::set_var(key, value);
            Self {
                key,
                previous,
                _lock: lock,
            }
        }
    }

    impl Drop for EnvVarGuard {
        fn drop(&mut self) {
            if let Some(prev) = &self.previous {
                env::set_var(self.key, prev);
            } else {
                env::remove_var(self.key);
            }
        }
    }

    #[test]
    fn test_spawn_image_loader_handles_error_path() {
        MarkdownRenderer::force_thread_spawn_error_for_test();
        let (_job_tx, job_rx) = crossbeam_channel::unbounded();
        let (result_tx, _result_rx) = crossbeam_channel::unbounded();
        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);
    }

    struct ForcedRenderActions {
        actions: Vec<&'static str>,
    }

    impl ForcedRenderActions {
        fn new(actions: &[&'static str]) -> Self {
            FORCED_RENDER_ACTIONS.with(|set| {
                let mut set = set.borrow_mut();
                for action in actions {
                    set.insert(*action);
                }
            });
            Self {
                actions: actions.to_vec(),
            }
        }
    }

    impl Drop for ForcedRenderActions {
        fn drop(&mut self) {
            FORCED_RENDER_ACTIONS.with(|set| {
                let mut set = set.borrow_mut();
                for action in &self.actions {
                    set.remove(action);
                }
            });
        }
    }

    struct ForcedTablePolicies;

    impl ForcedTablePolicies {
        fn new(policies: Vec<ColumnPolicy>) -> Self {
            FORCED_TABLE_POLICIES.with(|slot| {
                *slot.borrow_mut() = Some(policies);
            });
            Self
        }
    }

    impl Drop for ForcedTablePolicies {
        fn drop(&mut self) {
            FORCED_TABLE_POLICIES.with(|slot| {
                slot.borrow_mut().take();
            });
        }
    }

    fn paragraph_spans(element: &MarkdownElement) -> Option<&[InlineSpan]> {
        if let MarkdownElement::Paragraph(spans) = element {
            Some(spans)
        } else {
            None
        }
    }

    fn image_span_fields(span: &InlineSpan) -> Option<(&str, &str, Option<&str>)> {
        if let InlineSpan::Image { src, alt, title } = span {
            Some((src.as_str(), alt.as_str(), title.as_deref()))
        } else {
            None
        }
    }

    fn text_span_content(span: &InlineSpan) -> Option<&str> {
        if let InlineSpan::Text(text) = span {
            Some(text.as_str())
        } else {
            None
        }
    }

    fn emoji_fragment_key<'a>(fragment: &'a CellFragment<'a>) -> Option<&'a str> {
        if let CellFragment::Emoji(key) = fragment {
            Some(key.as_str())
        } else {
            None
        }
    }

    fn with_test_ui<F>(f: F)
    where
        F: FnOnce(&egui::Context, &mut egui::Ui),
    {
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(1024.0, 768.0),
            )),
            ..Default::default()
        };
        ctx.begin_frame(input);
        egui::CentralPanel::default().show(&ctx, |ui| {
            f(&ctx, ui);
        });
        let _ = ctx.end_frame();
    }

    fn wait_for_image(
        renderer: &MarkdownRenderer,
        ctx: &egui::Context,
        ui: &egui::Ui,
        path: &str,
    ) -> Option<(egui::TextureHandle, u32, u32)> {
        // Allow extra time for async image loading during tests (up to 10s total).
        wait_for_image_with_limit(renderer, ctx, ui, path, 200)
    }

    fn wait_for_image_with_limit(
        renderer: &MarkdownRenderer,
        ctx: &egui::Context,
        ui: &egui::Ui,
        path: &str,
        max_iters: usize,
    ) -> Option<(egui::TextureHandle, u32, u32)> {
        for _ in 0..max_iters {
            if let Some(loaded) = renderer.get_or_load_image_texture(ui, path) {
                return Some(loaded);
            }
            renderer.poll_image_results(ctx);
            std::thread::sleep(Duration::from_millis(50));
        }
        renderer.get_or_load_image_texture(ui, path)
    }

    fn run_frame_with_input<F>(ctx: &egui::Context, input: egui::RawInput, f: F)
    where
        F: FnOnce(&egui::Context, &mut egui::Ui),
    {
        ctx.begin_frame(input);
        egui::CentralPanel::default().show(ctx, |ui| {
            f(ctx, ui);
        });
        let _ = ctx.end_frame();
    }

    fn input_with_click(pos: egui::Pos2, button: egui::PointerButton) -> egui::RawInput {
        let mut input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(320.0, 240.0),
            )),
            ..Default::default()
        };
        input.events.push(egui::Event::PointerMoved(pos));
        input.events.push(egui::Event::PointerButton {
            pos,
            button,
            pressed: true,
            modifiers: egui::Modifiers::default(),
        });
        input.events.push(egui::Event::PointerButton {
            pos,
            button,
            pressed: false,
            modifiers: egui::Modifiers::default(),
        });
        input
    }

    fn tiny_png_bytes() -> Vec<u8> {
        let width = 2u32;
        let height = 2u32;
        let pixels = vec![255u8; (width * height * 4) as usize];
        let mut out = Vec::new();
        let encoder = PngEncoder::new(&mut out);
        encoder
            .write_image(&pixels, width, height, ColorType::Rgba8)
            .expect("encode png");
        out
    }

    #[test]
    fn test_image_cache_get_missing_and_insert_empty_order() {
        let mut cache = ImageCache::new(1);
        assert!(cache.get("missing").is_none());

        let mut entry_slot = None;
        with_test_ui(|ctx, _ui| {
            let tex = ctx.load_texture(
                "cache_test",
                egui::ColorImage::new([1, 1], Color32::WHITE),
                egui::TextureOptions::LINEAR,
            );
            entry_slot = Some(ImageCacheEntry {
                texture: tex,
                size: [1, 1],
                modified: None,
            });
        });
        let entry = entry_slot.expect("texture");
        cache.entries.insert(
            "a".to_string(),
            ImageCacheEntry {
                texture: entry.texture.clone(),
                size: entry.size,
                modified: entry.modified,
            },
        );
        cache.order.clear();
        cache.insert(
            "b".to_string(),
            ImageCacheEntry {
                texture: entry.texture.clone(),
                size: entry.size,
                modified: entry.modified,
            },
        );
        assert!(cache.contains_key("b"));
    }

    #[test]
    fn test_image_cache_insert_existing_key_updates_entry() {
        let mut cache = ImageCache::new(2);
        let mut entry_slot = None;
        with_test_ui(|ctx, _ui| {
            let tex = ctx.load_texture(
                "cache_update",
                egui::ColorImage::new([1, 1], Color32::WHITE),
                egui::TextureOptions::LINEAR,
            );
            entry_slot = Some(ImageCacheEntry {
                texture: tex,
                size: [1, 1],
                modified: None,
            });
        });
        let entry = entry_slot.expect("texture");
        cache.insert(
            "a".to_string(),
            ImageCacheEntry {
                texture: entry.texture.clone(),
                size: [1, 1],
                modified: entry.modified,
            },
        );
        cache.insert(
            "a".to_string(),
            ImageCacheEntry {
                texture: entry.texture.clone(),
                size: [2, 2],
                modified: entry.modified,
            },
        );
        let stored = cache.get("a").expect("stored");
        assert_eq!(stored.size, [2, 2]);
    }

    #[test]
    fn test_image_cache_evicts_oldest_entry() {
        let mut cache = ImageCache::new(1);
        let mut entry_slot = None;
        with_test_ui(|ctx, _ui| {
            let tex = ctx.load_texture(
                "cache_evict",
                egui::ColorImage::new([1, 1], Color32::WHITE),
                egui::TextureOptions::LINEAR,
            );
            entry_slot = Some(ImageCacheEntry {
                texture: tex,
                size: [1, 1],
                modified: None,
            });
        });
        let entry = entry_slot.expect("texture");
        cache.insert(
            "a".to_string(),
            ImageCacheEntry {
                texture: entry.texture.clone(),
                size: entry.size,
                modified: entry.modified,
            },
        );
        cache.insert(
            "b".to_string(),
            ImageCacheEntry {
                texture: entry.texture.clone(),
                size: entry.size,
                modified: entry.modified,
            },
        );
        assert!(cache.contains_key("b"));
        assert!(!cache.contains_key("a"));
    }

    #[test]
    fn test_list_marker_info_rejects_empty_and_bad_numeric() {
        assert!(MarkdownRenderer::list_marker_info("").is_none());
        assert!(MarkdownRenderer::list_marker_info("1 abc").is_none());
        assert!(MarkdownRenderer::list_marker_info("   ").is_none());
    }

    #[test]
    fn test_list_marker_info_rejects_tabs_and_missing_whitespace() {
        assert!(MarkdownRenderer::list_marker_info("\t- item").is_none());
        assert!(MarkdownRenderer::list_marker_info("1.item").is_none());
        assert!(MarkdownRenderer::list_marker_info("1)item").is_none());
        assert!(MarkdownRenderer::list_marker_info("-item").is_none());
    }

    #[test]
    fn test_list_marker_info_rejects_marker_only() {
        assert!(MarkdownRenderer::list_marker_info("-").is_none());
        assert!(MarkdownRenderer::list_marker_info("1.").is_none());
    }

    #[test]
    fn test_parse_image_with_title_sets_title() {
        let renderer = MarkdownRenderer::new();
        let parsed = renderer
            .parse("![alt](path/to/img.png \"Title\")")
            .expect("parse");
        let spans = paragraph_spans(&parsed[0]).expect("paragraph spans");
        let (_src, _alt, title) = image_span_fields(&spans[0]).expect("image span");
        assert_eq!(title, Some("Title"));
    }

    #[test]
    fn test_is_external_url_variants() {
        assert!(MarkdownRenderer::is_external_url("http://example.com"));
        assert!(MarkdownRenderer::is_external_url("https://example.com"));
        assert!(MarkdownRenderer::is_external_url("mailto:test@example.com"));
        assert!(MarkdownRenderer::is_external_url("www.example.com"));
        assert!(!MarkdownRenderer::is_external_url("local/path.png"));
    }

    #[test]
    fn test_resolve_image_path_keeps_remote() {
        let renderer = MarkdownRenderer::new();
        let src = "https://example.com/image.png";
        let http_src = "http://example.com/image.png";
        assert_eq!(renderer.resolve_image_path(src), src);
        assert_eq!(renderer.resolve_image_path(http_src), http_src);
        let data_src = "data:image/png;base64,AAAA";
        assert_eq!(renderer.resolve_image_path(data_src), data_src);
    }

    #[test]
    fn test_compute_table_id_includes_base_dir() {
        let renderer = MarkdownRenderer::new();
        let headers = vec![vec![InlineSpan::Text("A".to_string())]];
        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
        let alignments = vec![Alignment::Left];
        let base_id = renderer.compute_table_id(&headers, &rows, &alignments, 0);

        *renderer.base_dir.borrow_mut() = Some(PathBuf::from("C:\\tmp"));
        let with_base = renderer.compute_table_id(&headers, &rows, &alignments, 0);
        assert_ne!(base_id, with_base);
    }

    #[test]
    fn test_render_table_early_return_on_empty_headers() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            renderer.render_table(ui, &[], &[], &[]);
        });
    }

    #[test]
    fn test_extend_table_rect_handles_nan() {
        let mut target = Some(egui::Rect::from_min_size(
            egui::pos2(0.0, 0.0),
            egui::vec2(10.0, 10.0),
        ));
        let nan_rect = egui::Rect::from_min_size(egui::pos2(f32::NAN, 0.0), egui::vec2(1.0, 1.0));
        MarkdownRenderer::extend_table_rect(&mut target, nan_rect);
        let stored = target.expect("target");
        assert!(!stored.min.x.is_nan());

        let mut target_none = None;
        MarkdownRenderer::extend_table_rect(
            &mut target_none,
            egui::Rect::from_min_size(egui::pos2(5.0, 6.0), egui::vec2(2.0, 2.0)),
        );
        assert!(target_none.is_some());
    }

    #[test]
    fn test_extend_table_rect_rejects_nan_components() {
        let base = egui::Rect::from_min_size(egui::pos2(1.0, 2.0), egui::vec2(3.0, 4.0));
        let mut target = Some(base);
        let nan_min_y = egui::Rect::from_min_size(egui::pos2(0.0, f32::NAN), egui::vec2(1.0, 1.0));
        MarkdownRenderer::extend_table_rect(&mut target, nan_min_y);
        assert_eq!(target, Some(base));

        let mut target = Some(base);
        let nan_max_x = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(f32::NAN, 1.0));
        MarkdownRenderer::extend_table_rect(&mut target, nan_max_x);
        assert_eq!(target, Some(base));

        let mut target = Some(base);
        let nan_max_y = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(1.0, f32::NAN));
        MarkdownRenderer::extend_table_rect(&mut target, nan_max_y);
        assert_eq!(target, Some(base));
    }

    #[test]
    fn test_persist_resizable_widths_returns_on_empty() {
        let renderer = MarkdownRenderer::new();
        renderer.persist_resizable_widths(1, &[], &[]);
    }

    #[test]
    fn test_persist_resizable_widths_returns_on_empty_widths() {
        let renderer = MarkdownRenderer::new();
        let spec = ColumnSpec::new(
            0,
            "A",
            ColumnPolicy::Resizable {
                min: 20.0,
                preferred: 80.0,
                clip: false,
            },
            None,
        );
        let table_id = 7u64;
        renderer.persist_resizable_widths(table_id, &[spec], &[]);
        let metrics = renderer.table_metrics.borrow();
        assert!(metrics.entry(table_id).is_none());
    }

    #[test]
    fn test_link_at_pointer_outside_rect_returns_none() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Link {
            text: "Link".to_string(),
            url: "https://example.com".to_string(),
        }];
        let ctx = egui::Context::default();
        let mut input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(320.0, 240.0),
            )),
            ..Default::default()
        };
        input
            .events
            .push(egui::Event::PointerMoved(egui::pos2(200.0, 200.0)));
        ctx.begin_frame(input);
        let mut found = false;
        egui::CentralPanel::default().show(&ctx, |ui| {
            let response = ui.label("anchor");
            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, false, Align::LEFT);
            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
            found = renderer
                .link_at_pointer(&response, &galley, &build, egui::pos2(0.0, 0.0))
                .is_some();
        });
        let _ = ctx.end_frame();
        assert!(!found);
    }

    #[test]
    fn test_spawn_image_loader_missing_file_reports_failed() {
        let (job_tx, job_rx) = bounded(1);
        let (result_tx, result_rx) = bounded(1);
        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);

        let dir = tempdir().expect("temp dir");
        let path = dir.path().join("missing.png");
        job_tx
            .send(ImageLoadRequest {
                key: "missing".to_string(),
                source: ImageLoadSource::File(path),
            })
            .expect("send");
        let result = result_rx
            .recv_timeout(Duration::from_secs(3))
            .expect("result");
        assert!(matches!(
            result,
            ImageLoadResult::Failed { ref key } if key == "missing"
        ));
    }

    #[test]
    fn test_spawn_image_loader_embedded_invalid_bytes_reports_failed() {
        let (job_tx, job_rx) = bounded(1);
        let (result_tx, result_rx) = bounded(1);
        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);

        job_tx
            .send(ImageLoadRequest {
                key: "bad-embedded".to_string(),
                source: ImageLoadSource::Embedded(b"not an image"),
            })
            .expect("send");
        let result = result_rx
            .recv_timeout(Duration::from_secs(8))
            .expect("result");
        assert!(matches!(
            result,
            ImageLoadResult::Failed { ref key } if key == "bad-embedded"
        ));
    }

    #[test]
    fn test_spawn_image_loader_file_invalid_bytes_reports_failed() -> Result<()> {
        let (job_tx, job_rx) = bounded(1);
        let (result_tx, result_rx) = bounded(1);
        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);

        let dir = tempdir()?;
        let path = dir.path().join("bad.png");
        std::fs::write(&path, b"not an image")?;
        job_tx
            .send(ImageLoadRequest {
                key: "bad-file".to_string(),
                source: ImageLoadSource::File(path),
            })
            .expect("send");
        let result = result_rx
            .recv_timeout(Duration::from_secs(3))
            .expect("result");
        assert!(matches!(
            result,
            ImageLoadResult::Failed { ref key } if key == "bad-file"
        ));
        Ok(())
    }

    #[test]
    fn test_spawn_image_loader_file_read_error_reports_failed() -> Result<()> {
        let (job_tx, job_rx) = bounded(1);
        let (result_tx, result_rx) = bounded(1);
        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);

        let dir = tempdir()?;
        let bad_path = dir.path().join("read_error_dir");
        std::fs::create_dir_all(&bad_path)?;
        job_tx
            .send(ImageLoadRequest {
                key: "read-error".to_string(),
                source: ImageLoadSource::File(bad_path),
            })
            .expect("send");
        let result = result_rx
            .recv_timeout(Duration::from_secs(1))
            .expect("result");
        assert!(matches!(
            result,
            ImageLoadResult::Failed { ref key } if key == "read-error"
        ));
        Ok(())
    }

    #[test]
    fn test_env_var_guard_removes_unset_value() {
        let key = "MDMDVIEW_TEST_ENV_GUARD";
        env::remove_var(key);
        {
            let _guard = EnvVarGuard::set(key, "value");
            assert_eq!(env::var(key).ok().as_deref(), Some("value"));
        }
        assert!(env::var(key).is_err());
    }

    #[test]
    fn test_parse_forced_error_returns_err_once() {
        let renderer = MarkdownRenderer::new();
        force_parse_error_once();
        assert!(renderer.parse("hello").is_err());
        assert!(renderer.parse("hello").is_ok());
    }

    #[test]
    fn test_fence_helpers_cover_branches() {
        assert_eq!(MarkdownRenderer::fence_start("```"), Some(('`', 3)));
        assert_eq!(MarkdownRenderer::fence_start("``"), None);
        assert_eq!(MarkdownRenderer::fence_start("~~~"), Some(('~', 3)));
        assert!(MarkdownRenderer::is_fence_end("```", '`', 3));
        assert!(!MarkdownRenderer::is_fence_end("``", '`', 3));
        assert!(MarkdownRenderer::is_fence_end("   ```", '`', 3));
    }

    #[test]
    fn test_restore_pipe_sentinel_round_trip() {
        let input = format!("a{}b", PIPE_SENTINEL);
        assert_eq!(MarkdownRenderer::restore_pipe_sentinel(&input), "a|b");
        assert_eq!(MarkdownRenderer::restore_pipe_sentinel("a|b"), "a|b");
    }

    #[test]
    fn test_list_marker_info_numeric_punctuation() {
        let (content, _indent, _content_indent) =
            MarkdownRenderer::list_marker_info("1. item").expect("dot marker");
        assert_eq!(content.trim_start(), "item");
        let (content, _indent, _content_indent) =
            MarkdownRenderer::list_marker_info("2) item").expect("paren marker");
        assert_eq!(content.trim_start(), "item");
    }

    #[test]
    fn test_table_line_info_blockquote_levels() {
        let (level, rest) = MarkdownRenderer::table_line_info("  >\t| a |");
        assert_eq!(level, 1);
        assert!(rest.trim_start().starts_with('|'));

        let (level, rest) = MarkdownRenderer::table_line_info("> > | b |");
        assert_eq!(level, 2);
        assert!(rest.trim_start().starts_with('|'));
    }

    #[test]
    fn test_strip_indent_columns_indent_zero_returns_line() {
        assert_eq!(
            MarkdownRenderer::strip_indent_columns("content", 0),
            Some("content")
        );
    }

    #[test]
    fn test_parent_list_indent_for_line_zero_index_returns_none() {
        let lines = vec!["- item"];
        let (level, rest) = MarkdownRenderer::table_line_info(lines[0]);
        assert!(MarkdownRenderer::parent_list_indent_for_line(&lines, 0, level, rest).is_none());
    }

    #[test]
    fn test_should_retry_image_backoff_respected() {
        let renderer = MarkdownRenderer::new();
        renderer.image_failures.borrow_mut().insert(
            "recent".to_string(),
            ImageFailure {
                last_attempt: std::time::Instant::now(),
            },
        );
        assert!(!renderer.should_retry_image("recent"));

        renderer.image_failures.borrow_mut().insert(
            "old".to_string(),
            ImageFailure {
                last_attempt: std::time::Instant::now()
                    - IMAGE_FAILURE_BACKOFF
                    - Duration::from_millis(1),
            },
        );
        assert!(renderer.should_retry_image("old"));
    }

    #[test]
    fn test_extend_table_rect_accepts_valid_rect() {
        let mut target = None;
        let rect = egui::Rect::from_min_size(egui::pos2(1.0, 2.0), egui::vec2(3.0, 4.0));
        MarkdownRenderer::extend_table_rect(&mut target, rect);
        assert_eq!(target, Some(rect));

        let rect2 = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(10.0, 10.0));
        MarkdownRenderer::extend_table_rect(&mut target, rect2);
        let merged = target.expect("merged rect");
        assert!(merged.contains(rect.min));
        assert!(merged.contains(rect2.max));
    }

    #[test]
    fn test_render_code_block_with_none_language() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            renderer.render_code_block(ui, None, "fn main() {}");
        });
    }

    #[test]
    fn test_render_action_triggered_forced_paths() {
        let _actions = ForcedRenderActions::new(&["forced_action"]);
        assert!(render_action_triggered(false, "forced_action"));
        assert!(!render_action_triggered(false, "other_action"));
        assert!(render_action_triggered(true, "other_action"));
    }

    #[test]
    fn test_markdown_renderer_creation() {
        let renderer = MarkdownRenderer::new();
        assert_eq!(renderer.font_sizes.body, 14.0);
        assert_eq!(renderer.font_sizes.h1, 28.0);
    }

    #[test]
    fn test_markdown_renderer_default_uses_defaults() {
        let renderer = MarkdownRenderer::default();
        let defaults = FontSizes::default();
        assert_eq!(renderer.font_sizes.body, defaults.body);
        assert_eq!(renderer.font_sizes.code, defaults.code);
    }

    #[test]
    fn test_superscript_expansion_basic() {
        let s = "5^th^ and m^2^";
        let out = MarkdownRenderer::expand_superscripts(s);
        assert!(out.contains("5"));
        assert!(out.contains("m"));
    }

    #[test]
    fn test_superscript_expansion_allows_plus_symbol() {
        let out = MarkdownRenderer::expand_superscripts("x^+^");
        assert!(out.contains('\u{207a}'));
    }

    #[test]
    fn test_superscript_expansion_single_caret() {
        // Test that single carets (not paired) are left as-is
        let s = "2^32 = 4,294,967,296";
        let out = MarkdownRenderer::expand_superscripts(s);
        assert_eq!(out, "2^32 = 4,294,967,296");

        // Test the problematic line from the bug report
        let problematic = "A 32-bit address bus would provide 2^32 = 4,294,967,296 bytes (4 GB) of addressable memory.";
        let fixed = MarkdownRenderer::expand_superscripts(problematic);
        assert_eq!(fixed, problematic);

        // Test mixed cases
        let mixed = "Use 2^32 for math and 5^th^ for ordinal";
        let result = MarkdownRenderer::expand_superscripts(mixed);
        assert!(result.contains("2^32"));
        assert!(result.contains("5"));
    }

    #[test]
    fn test_superscript_expansion_rejects_invalid_sequences() {
        let s = "2^ab$^ and ^^";
        let out = MarkdownRenderer::expand_superscripts(s);
        assert_eq!(out, s);
        let no_close = "10^abc";
        let out = MarkdownRenderer::expand_superscripts(no_close);
        assert_eq!(out, no_close);
    }

    #[test]
    fn test_font_sizes_default() {
        let sizes = FontSizes::default();
        assert_eq!(sizes.body, 14.0);
        assert_eq!(sizes.h1, 28.0);
        assert_eq!(sizes.code, 12.0);
    }

    #[test]
    fn test_zoom_functionality() {
        let mut renderer = MarkdownRenderer::new();
        let original_body = renderer.font_sizes.body;

        renderer.zoom_in();
        assert!(renderer.font_sizes.body > original_body);

        renderer.zoom_out();
        assert!(renderer.font_sizes.body < original_body * 1.1);

        renderer.reset_zoom();
        assert_eq!(renderer.font_sizes.body, original_body);
    }

    #[test]
    fn test_set_zoom_scale() {
        let mut renderer = MarkdownRenderer::new();

        renderer.set_zoom_scale(1.5);
        assert!((renderer.font_sizes.body - 21.0).abs() < 0.1);

        renderer.set_zoom_scale(10.0);
        assert_eq!(renderer.font_sizes.body, 32.0);

        renderer.set_zoom_scale(0.1);
        assert_eq!(renderer.font_sizes.body, 8.0);
    }

    #[test]
    fn font_size_change_does_not_repersist_stale_widths() {
        let mut renderer = MarkdownRenderer::new();
        let table_id = 7u64;
        let specs = vec![ColumnSpec::new(
            0,
            "A",
            ColumnPolicy::Resizable {
                min: 20.0,
                preferred: 100.0,
                clip: false,
            },
            None,
        )];
        let widths = vec![100.0f32];

        // Initial persist at default font size.
        renderer.persist_resizable_widths(table_id, &specs, &widths);
        let policy_hash = specs[0].policy_hash;
        {
            let metrics = renderer.table_metrics.borrow();
            let entry = metrics.entry(table_id).expect("entry created");
            assert_eq!(entry.persisted_width(policy_hash), Some(100.0));
            assert_eq!(entry.persisted_font_size, Some(renderer.font_sizes.body));
        }

        // Simulate zoom: font size changes but widths captured are still the old ones.
        renderer.font_sizes.body = 16.0;
        renderer.persist_resizable_widths(table_id, &specs, &widths);
        {
            let metrics = renderer.table_metrics.borrow();
            let entry = metrics.entry(table_id).expect("entry exists");
            // Cleared and NOT re-saved in the same frame.
            assert_eq!(entry.persisted_width(policy_hash), None);
            assert_eq!(entry.persisted_font_size, Some(16.0));
        }

        // Next frame with new layout widths should persist again.
        let new_widths = vec![80.0f32];
        renderer.persist_resizable_widths(table_id, &specs, &new_widths);
        let metrics = renderer.table_metrics.borrow();
        let entry = metrics.entry(table_id).expect("entry exists");
        assert_eq!(entry.persisted_width(policy_hash), Some(80.0));
        assert_eq!(entry.persisted_font_size, Some(16.0));
    }

    #[test]
    fn highlight_phrase_keeps_persisted_table_widths() {
        let renderer = MarkdownRenderer::new();
        let table_id = 11u64;
        let specs = vec![ColumnSpec::new(
            0,
            "A",
            ColumnPolicy::Resizable {
                min: 20.0,
                preferred: 100.0,
                clip: false,
            },
            None,
        )];
        let widths = vec![120.0f32];
        let policy_hash = specs[0].policy_hash;

        renderer.persist_resizable_widths(table_id, &specs, &widths);
        renderer.set_highlight_phrase(Some("alpha"));
        renderer.set_highlight_phrase(Some("beta"));

        let metrics = renderer.table_metrics.borrow();
        let entry = metrics.entry(table_id).expect("entry exists");
        assert_eq!(entry.persisted_width(policy_hash), Some(120.0));
    }

    #[test]
    fn test_tight_list_inline_code_and_styles() {
        let renderer = MarkdownRenderer::new();
        let md = "Intro\n\n- Use `code` and **bold** and *italic* and ~~strike~~\n";
        let parsed = renderer.parse(md).expect("parse ok");
        let (ordered, items) = parsed
            .iter()
            .find_map(|el| {
                if let MarkdownElement::List { ordered, items } = el {
                    Some((*ordered, items))
                } else {
                    None
                }
            })
            .expect("list element");
        assert!(!ordered);
        assert_eq!(items.len(), 1);
        let mut blocks = Vec::new();
        blocks.push(MarkdownElement::HorizontalRule);
        blocks.extend(items[0].blocks.clone());
        let spans = blocks
            .iter()
            .find_map(|block| {
                if let MarkdownElement::Paragraph(spans) = block {
                    Some(spans)
                } else {
                    None
                }
            })
            .expect("paragraph block");
        let mut saw_code = false;
        let mut saw_strong = false;
        let mut saw_emphasis = false;
        let mut saw_strike = false;
        let mut saw_other = false;
        for span in spans {
            match span {
                InlineSpan::Code(_) => saw_code = true,
                InlineSpan::Strong(_) => saw_strong = true,
                InlineSpan::Emphasis(_) => saw_emphasis = true,
                InlineSpan::Strikethrough(_) => saw_strike = true,
                _ => saw_other = true,
            }
        }
        assert!(saw_code);
        assert!(saw_strong);
        assert!(saw_emphasis);
        assert!(saw_strike);
        assert!(saw_other);
    }

    #[test]
    fn test_expand_shortcodes_basic() {
        let rocket = MarkdownRenderer::expand_shortcodes(":rocket:");
        assert_ne!(rocket, ":rocket:");
        assert!(crate::emoji_catalog::image_bytes_for(&rocket).is_some());

        let tada = MarkdownRenderer::expand_shortcodes(":tada:");
        assert_ne!(tada, ":tada:");
        assert!(crate::emoji_catalog::image_bytes_for(&tada).is_some());

        assert_eq!(
            MarkdownRenderer::expand_shortcodes("Hello :tada:!"),
            format!("Hello {}!", tada)
        );
    }

    #[test]
    fn test_expand_shortcodes_unknown_code_keeps_text() {
        let input = "Unknown :notacode: stays the same.";
        let out = MarkdownRenderer::expand_shortcodes(input);
        assert_eq!(out, input);
    }

    #[test]
    fn test_fix_unicode_chars_normalizes_basic_cases() {
        let renderer = MarkdownRenderer::new();
        let input = "A\u{00A0}B\u{2013}C";
        let normalized = renderer.normalize_text_for_test(input);
        assert_eq!(normalized, "A B-C");

        let arrows = renderer.normalize_text_for_test("   ");
        assert_eq!(arrows, "<- -> ^ v");

        let untouched = renderer.normalize_text_for_test("Plain text");
        assert_eq!(untouched, "Plain text");
    }

    #[test]
    fn test_elements_to_plain_text_basic() {
        let elements = vec![
            MarkdownElement::Header {
                level: 1,
                spans: vec![InlineSpan::Text("Test Header".to_string())],
                id: "test-header".to_string(),
            },
            MarkdownElement::Paragraph(vec![
                InlineSpan::Text("This is a ".to_string()),
                InlineSpan::Strong("bold".to_string()),
                InlineSpan::Text(" paragraph.".to_string()),
            ]),
        ];

        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
        assert!(plain_text.contains("Test Header"));
        assert!(plain_text.contains("This is a bold paragraph."));
    }

    #[test]
    fn test_elements_to_plain_text_code_block() {
        let elements = vec![MarkdownElement::CodeBlock {
            language: Some("rust".to_string()),
            text: "fn main() {\n    println!(\"Hello\");\n}".to_string(),
        }];

        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
        assert_eq!(plain_text, "fn main() {\n    println!(\"Hello\");\n}");
    }

    #[test]
    fn test_elements_to_plain_text_with_links() {
        let elements = vec![MarkdownElement::Paragraph(vec![
            InlineSpan::Text("Visit ".to_string()),
            InlineSpan::Link {
                text: "GitHub".to_string(),
                url: "https://github.com".to_string(),
            },
            InlineSpan::Text(" for more.".to_string()),
        ])];

        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
        assert_eq!(plain_text, "Visit GitHub for more.");
    }

    #[test]
    fn test_elements_to_plain_text_horizontal_rule_after_text() {
        let elements = vec![
            MarkdownElement::Paragraph(vec![InlineSpan::Text("Hello".to_string())]),
            MarkdownElement::HorizontalRule,
        ];
        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
        assert_eq!(plain_text, "Hello\n---\n");
    }

    #[test]
    fn test_elements_to_plain_text_mixed_blocks_adds_newlines() {
        let elements = vec![
            MarkdownElement::Paragraph(vec![InlineSpan::Text("First".to_string())]),
            MarkdownElement::List {
                ordered: false,
                items: vec![ListItem {
                    blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
                        "List".to_string(),
                    )])],
                }],
            },
            MarkdownElement::Quote {
                depth: 1,
                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
                    "Quote".to_string(),
                )])],
            },
            MarkdownElement::Table {
                headers: vec![
                    vec![InlineSpan::Text("H1".to_string())],
                    vec![InlineSpan::Text("H2".to_string())],
                ],
                rows: vec![vec![vec![InlineSpan::Text("R1".to_string())]]],
                alignments: vec![Alignment::Left, Alignment::Left],
            },
            MarkdownElement::HorizontalRule,
        ];
        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
        assert_eq!(plain_text, "First\nList\nQuote\nH1\nH2\nR1\n---\n");
    }

    #[test]
    fn test_elements_to_plain_text_list_only_starts_without_newline() {
        let elements = vec![MarkdownElement::List {
            ordered: false,
            items: vec![ListItem {
                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
                    "Item".to_string(),
                )])],
            }],
        }];
        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
        assert_eq!(plain_text, "Item");
    }

    #[test]
    fn test_elements_to_plain_text_quote_only_starts_without_newline() {
        let elements = vec![MarkdownElement::Quote {
            depth: 1,
            blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
                "Quote".to_string(),
            )])],
        }];
        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
        assert_eq!(plain_text, "Quote");
    }

    #[test]
    fn test_elements_to_plain_text_table_headers_only_starts_without_newline() {
        let elements = vec![MarkdownElement::Table {
            headers: vec![vec![InlineSpan::Text("H".to_string())]],
            rows: Vec::new(),
            alignments: vec![Alignment::Left],
        }];
        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
        assert_eq!(plain_text, "H");
    }

    #[test]
    fn test_elements_to_plain_text_table_rows_only_starts_without_newline() {
        let elements = vec![MarkdownElement::Table {
            headers: Vec::new(),
            rows: vec![vec![vec![InlineSpan::Text("R".to_string())]]],
            alignments: vec![Alignment::Left],
        }];
        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
        assert_eq!(plain_text, "R");
    }

    #[test]
    fn test_spans_plain_text_image_title_without_alt() {
        let spans = vec![
            InlineSpan::Image {
                src: "img.png".to_string(),
                alt: "".to_string(),
                title: Some("Title".to_string()),
            },
            InlineSpan::Image {
                src: "img.png".to_string(),
                alt: "Alt".to_string(),
                title: Some("Caption".to_string()),
            },
            InlineSpan::Image {
                src: "img.png".to_string(),
                alt: "".to_string(),
                title: Some("".to_string()),
            },
        ];
        let plain_text = MarkdownRenderer::spans_plain_text(&spans);
        assert_eq!(plain_text, "TitleAlt Caption");
    }

    #[test]
    fn test_spans_plain_text_includes_strikethrough() {
        let spans = vec![
            InlineSpan::Text("alpha ".to_string()),
            InlineSpan::Strikethrough("beta".to_string()),
        ];
        let plain_text = MarkdownRenderer::spans_plain_text(&spans);
        assert_eq!(plain_text, "alpha beta");
    }

    #[test]
    fn test_image_source_stale_detects_file_changes() {
        use std::time::Duration as StdDuration;

        let dir = tempfile::tempdir().expect("temp dir");
        let file_path = dir.path().join("image.bin");
        std::fs::write(&file_path, [1u8, 2, 3, 4]).expect("write image");
        let initial = MarkdownRenderer::disk_image_timestamp(&file_path);
        assert!(!MarkdownRenderer::image_source_stale(initial, &file_path));

        std::thread::sleep(StdDuration::from_millis(5));
        std::fs::write(&file_path, [4u8, 3, 2, 1]).expect("rewrite image");

        assert!(MarkdownRenderer::image_source_stale(initial, &file_path));

        std::fs::remove_file(&file_path).expect("remove image");
        assert!(MarkdownRenderer::image_source_stale(initial, &file_path));
    }

    #[test]
    fn test_disk_image_timestamp_missing_returns_none() {
        let missing = std::path::Path::new("missing_image_timestamp.bin");
        assert!(MarkdownRenderer::disk_image_timestamp(missing).is_none());
    }

    #[test]
    fn test_image_source_stale_with_timestamp_combinations() {
        let stamp = SystemTime::UNIX_EPOCH;
        assert!(MarkdownRenderer::image_source_stale_with_timestamp(
            Some(stamp),
            None
        ));
        assert!(MarkdownRenderer::image_source_stale_with_timestamp(
            None,
            Some(stamp)
        ));
        assert!(!MarkdownRenderer::image_source_stale_with_timestamp(
            None, None
        ));
    }

    #[test]
    fn test_inline_code_preserves_whitespace() {
        let renderer = MarkdownRenderer::new();
        let md = "Start `code` end";
        let parsed = renderer.parse(md).expect("parse ok");
        let non_paragraph = MarkdownElement::HorizontalRule;
        let mut saw_paragraph = false;
        for element in [&parsed[0], &non_paragraph] {
            if let MarkdownElement::Paragraph(spans) = element {
                let code_span = spans.iter().find_map(|span| match span {
                    InlineSpan::Code(t) => Some(t),
                    _ => None,
                });
                assert_eq!(code_span, Some(&"code".to_string()));
                saw_paragraph = true;
            }
        }
        assert!(saw_paragraph);
    }

    #[test]
    fn test_footnote_markers_render_as_visible_text() {
        let renderer = MarkdownRenderer::new();
        let md = "Paragraph with footnote[^1].\n\n[^1]: footnote body.";
        let parsed = renderer.parse(md).expect("parse ok");
        assert_eq!(parsed.len(), 2);
        let first_plain = MarkdownRenderer::element_plain_text(&parsed[0]);
        assert!(first_plain.contains("footnote[^1]"));
        let second_plain = MarkdownRenderer::element_plain_text(&parsed[1]);
        assert!(second_plain.contains("[^1]: footnote body."));
    }

    #[test]
    fn test_parse_headers_assign_ids_and_dedupe() {
        let renderer = MarkdownRenderer::new();
        let md = "# Getting Started\n\nParagraph text.\n\n## Getting Started\n\n### API & Usage\n\n## API & Usage\n";
        let parsed = renderer.parse(md).expect("parse ok");

        let mut ids = vec![];
        for el in parsed {
            if let MarkdownElement::Header { id, .. } = el {
                ids.push(id);
            }
        }
        assert_eq!(ids.len(), 4);
        assert_eq!(ids[0], "getting-started");
        assert_eq!(ids[1], "getting-started-1");
        assert_eq!(ids[2], "api-usage");
        assert_eq!(ids[3], "api-usage-1");
    }

    #[test]
    fn test_formatting_sample_contains_expected_header_ids() {
        let renderer = MarkdownRenderer::new();
        let formatting = SAMPLE_FILES
            .iter()
            .find(|f| f.name == "formatting.md")
            .expect("formatting sample present");
        let parsed = renderer.parse(formatting.content).expect("parse ok");
        let ids: Vec<String> = parsed
            .into_iter()
            .filter_map(|el| match el {
                MarkdownElement::Header { id, .. } => Some(id),
                _ => None,
            })
            .collect();

        for expected in [
            "markdown-formatting-guide",
            "table-of-contents",
            "text-formatting",
            "headers",
            "lists",
            "links-and-images",
            "emojis",
            "blockquotes",
            "horizontal-rules",
            "tables",
        ] {
            assert!(ids.iter().any(|id| id == expected));
        }
    }

    #[test]
    fn test_inline_image_parsing() {
        let renderer = MarkdownRenderer::new();
        let md = "Here is an image: ![Alt text](images/pic.webp \"Title\") end.";
        let parsed = renderer.parse(md).expect("parse ok");
        assert_eq!(parsed.len(), 1);
        assert!(matches!(&parsed[0], MarkdownElement::Paragraph(_)));
        let non_paragraph = MarkdownElement::HorizontalRule;
        let mut saw_paragraph = false;
        for element in [&parsed[0], &non_paragraph] {
            if let MarkdownElement::Paragraph(spans) = element {
                let img = spans.iter().find(|s| matches!(s, InlineSpan::Image { .. }));
                assert!(img.is_some());
                let (src, alt, title) = image_span_fields(img.unwrap()).expect("image span");
                assert_eq!(src, "images/pic.webp");
                assert_eq!(alt, "Alt text");
                assert_eq!(title, Some("Title"));
                saw_paragraph = true;
            }
        }
        assert!(saw_paragraph);
        assert!(image_span_fields(&InlineSpan::Text("nope".into())).is_none());
    }

    #[test]
    fn test_image_text_in_plain_text_index() {
        let renderer = MarkdownRenderer::new();
        let md = "![Diagram](./a.png \"Flow\")";
        let parsed = renderer.parse(md).expect("parse ok");
        let text = MarkdownRenderer::element_plain_text(&parsed[0]);
        assert!(text.contains("Diagram"));
        assert!(text.contains("Flow"));
    }

    #[test]
    fn test_element_plain_text_header_and_code_block() {
        let header = MarkdownElement::Header {
            level: 2,
            spans: vec![InlineSpan::Text("Title".to_string())],
            id: "title".to_string(),
        };
        let code = MarkdownElement::CodeBlock {
            text: "fn main() {}".to_string(),
            language: Some("rust".to_string()),
        };
        assert_eq!(
            MarkdownRenderer::element_plain_text(&header),
            "Title".to_string()
        );
        assert_eq!(
            MarkdownRenderer::element_plain_text(&code),
            "fn main() {}".to_string()
        );
    }

    #[test]
    fn test_cell_fragments_split_text_and_images() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![
            InlineSpan::Text("alpha".into()),
            InlineSpan::Strong("beta".into()),
            InlineSpan::Image {
                src: "img.png".into(),
                alt: "img".into(),
                title: None,
            },
            InlineSpan::Text("gamma".into()),
        ];
        let fragments = renderer.cell_fragments(&spans);
        assert_eq!(fragments.len(), 3);
        assert!(matches!(fragments[0], CellFragment::Text(_)));
        let mut saw_first_text = false;
        for fragment in [&fragments[0], &fragments[1]] {
            if let CellFragment::Text(slice) = fragment {
                assert_eq!(slice.len(), 2);
                saw_first_text = true;
            }
        }
        assert!(saw_first_text);
        assert!(matches!(fragments[1], CellFragment::Image(_)));
        let mut saw_image = false;
        for fragment in [&fragments[1], &fragments[0]] {
            if let CellFragment::Image(span) = fragment {
                let (src, _alt, _title) = image_span_fields(span).expect("image span");
                assert_eq!(src, "img.png");
                saw_image = true;
            }
        }
        assert!(saw_image);
        assert!(matches!(fragments[2], CellFragment::Text(_)));
        let mut saw_last_text = false;
        for fragment in [&fragments[2], &fragments[1]] {
            if let CellFragment::Text(slice) = fragment {
                assert_eq!(slice.len(), 1);
                let content = text_span_content(&slice[0]).expect("text span");
                assert_eq!(content, "gamma");
                saw_last_text = true;
            }
        }
        assert!(saw_last_text);
        assert!(text_span_content(&InlineSpan::Image {
            src: "img.png".into(),
            alt: "img".into(),
            title: None,
        })
        .is_none());
    }

    #[test]
    fn test_cell_fragments_leading_image() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![
            InlineSpan::Image {
                src: "cover.png".into(),
                alt: "cover".into(),
                title: None,
            },
            InlineSpan::Text("tail".into()),
        ];
        let fragments = renderer.cell_fragments(&spans);
        assert_eq!(fragments.len(), 2);
        assert!(matches!(fragments[0], CellFragment::Image(_)));
        assert!(matches!(fragments[1], CellFragment::Text(_)));
    }

    #[test]
    fn test_cell_fragments_detect_single_emoji_cell() {
        let renderer = MarkdownRenderer::new();
        let rocket = crate::emoji_catalog::shortcode_map()
            .get(":rocket:")
            .expect("rocket shortcode");
        let spans = vec![InlineSpan::Strong((*rocket).to_string())];
        let fragments = renderer.cell_fragments(&spans);
        assert_eq!(fragments.len(), 1);
        let key = emoji_fragment_key(&fragments[0]).expect("emoji fragment");
        assert!(!key.is_empty());
        let text_spans = vec![InlineSpan::Text("plain".into())];
        let fragment = CellFragment::Text(&text_spans);
        assert!(emoji_fragment_key(&fragment).is_none());
    }

    #[test]
    fn test_cell_single_emoji_emphasis() {
        let renderer = MarkdownRenderer::new();
        let rocket = crate::emoji_catalog::shortcode_map()
            .get(":rocket:")
            .expect("rocket shortcode");
        let spans = vec![InlineSpan::Emphasis((*rocket).to_string())];
        assert!(renderer.cell_single_emoji(&spans).is_some());
    }

    #[test]
    fn test_cell_single_emoji_strikethrough() {
        let renderer = MarkdownRenderer::new();
        let rocket = crate::emoji_catalog::shortcode_map()
            .get(":rocket:")
            .expect("rocket shortcode");
        let spans = vec![InlineSpan::Strikethrough((*rocket).to_string())];
        assert!(renderer.cell_single_emoji(&spans).is_some());
    }

    #[test]
    fn test_cell_single_emoji_returns_none_for_code_and_link() {
        let renderer = MarkdownRenderer::new();
        let rocket = crate::emoji_catalog::shortcode_map()
            .get(":rocket:")
            .expect("rocket shortcode");
        let code_spans = vec![InlineSpan::Code((*rocket).to_string())];
        assert!(renderer.cell_single_emoji(&code_spans).is_none());

        let link_spans = vec![InlineSpan::Link {
            text: (*rocket).to_string(),
            url: "https://example.com".to_string(),
        }];
        assert!(renderer.cell_single_emoji(&link_spans).is_none());
    }

    #[test]
    fn test_cell_single_emoji_multiple_graphemes_returns_none() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Text("ab".to_string())];
        assert!(renderer.cell_single_emoji(&spans).is_none());
    }

    #[test]
    fn test_get_or_make_emoji_texture_falls_back_on_decode_error() {
        let renderer = MarkdownRenderer::new();
        let rocket = crate::emoji_catalog::shortcode_map()
            .get(":rocket:")
            .expect("rocket shortcode");
        force_emoji_decode_error_once();
        with_test_ui(|_, ui| {
            let _ = renderer.get_or_make_emoji_texture(ui, rocket);
        });
    }

    #[test]
    fn test_get_or_make_emoji_texture_generates_on_decode_error() {
        let renderer = MarkdownRenderer::new();
        let fallback = [
            "\u{2705}",
            "\u{1f389}",
            "\u{1f680}",
            "\u{2764}",
            "\u{1f496}",
            "\u{2b50}",
            "\u{1f525}",
        ];
        let emoji = crate::emoji_catalog::shortcode_map()
            .values()
            .find(|emoji| {
                !fallback.contains(emoji) && emoji_catalog::image_bytes_for(emoji).is_some()
            })
            .expect("emoji outside fallback");
        assert!(emoji_assets::make_image(emoji, 64).is_none());
        force_emoji_decode_error_once();
        with_test_ui(|_, ui| {
            let _ = renderer.get_or_make_emoji_texture(ui, emoji);
        });
    }

    #[test]
    fn test_cell_fragments_inline_emoji_stays_text() {
        let renderer = MarkdownRenderer::new();
        let rocket = crate::emoji_catalog::shortcode_map()
            .get(":rocket:")
            .expect("rocket shortcode");
        let spans = vec![
            InlineSpan::Text((*rocket).to_string()),
            InlineSpan::Text("tail".into()),
        ];
        let fragments = renderer.cell_fragments(&spans);
        assert_eq!(fragments.len(), 1);
        assert!(matches!(fragments[0], CellFragment::Text(_)));
        let dummy_span = InlineSpan::Image {
            src: "dummy.png".into(),
            alt: "dummy".into(),
            title: None,
        };
        let dummy_fragment = CellFragment::Image(&dummy_span);
        let mut saw_text = false;
        for fragment in [&fragments[0], &dummy_fragment] {
            if let CellFragment::Text(slice) = fragment {
                assert_eq!(slice.len(), 2);
                saw_text = true;
            }
        }
        assert!(saw_text);
    }

    #[test]
    fn test_cell_fragments_keep_link_emoji_interactive() {
        let renderer = MarkdownRenderer::new();
        let rocket = crate::emoji_catalog::shortcode_map()
            .get(":rocket:")
            .expect("rocket shortcode");
        let spans = vec![InlineSpan::Link {
            text: (*rocket).to_string(),
            url: "https://example.com".to_string(),
        }];
        let fragments = renderer.cell_fragments(&spans);
        assert_eq!(fragments.len(), 1);
        assert!(matches!(fragments[0], CellFragment::Text(_)));
        let dummy_span = InlineSpan::Image {
            src: "dummy.png".into(),
            alt: "dummy".into(),
            title: None,
        };
        let dummy_fragment = CellFragment::Image(&dummy_span);
        let mut saw_link = false;
        for fragment in [&fragments[0], &dummy_fragment] {
            if let CellFragment::Text(slice) = fragment {
                assert!(matches!(slice[0], InlineSpan::Link { .. }));
                saw_link = true;
            }
        }
        assert!(saw_link);
    }

    #[test]
    fn test_render_overhauled_cell_handles_emoji_fragment() {
        let renderer = MarkdownRenderer::new();
        let rocket = crate::emoji_catalog::shortcode_map()
            .get(":rocket:")
            .expect("rocket shortcode");
        let spans = vec![InlineSpan::Text((*rocket).to_string())];
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(240.0, 120.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, input, |_, ui| {
            let _ =
                renderer.render_overhauled_cell(ui, &spans, 120.0, false, Some(0), 0, Align::LEFT);
        });
    }

    #[test]
    fn test_layout_job_builder_respects_wrap_width() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Text(
            "A long column entry that should wrap neatly within the supplied width.".into(),
        )];
        let style = egui::Style::default();
        let build = renderer.build_layout_job(&style, &spans, 180.0, false, Align::LEFT);
        assert_eq!(build.job.wrap.max_width, 180.0);
        assert!(build.job.text.contains("column entry"));
    }

    #[test]
    fn test_layout_job_builder_highlights_matches() {
        let renderer = MarkdownRenderer::new();
        renderer.set_highlight_phrase(Some("wrap"));
        let spans = vec![InlineSpan::Text("wrap me, wrap me again".into())];
        let style = egui::Style::default();
        let build = renderer.build_layout_job(&style, &spans, 200.0, false, Align::LEFT);
        let highlight_bg = style.visuals.selection.bg_fill;
        assert!(build
            .job
            .sections
            .iter()
            .any(|s| s.format.background == highlight_bg));
    }

    #[test]
    fn test_layout_job_builder_tracks_link_ranges() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Link {
            text: "Docs".into(),
            url: "https://example.org/docs".into(),
        }];
        let style = egui::Style::default();
        let build = renderer.build_layout_job(&style, &spans, 220.0, false, Align::LEFT);
        assert_eq!(build.link_ranges.len(), 1);
        let link = &build.link_ranges[0];
        assert_eq!(link.url, "https://example.org/docs");
        let char_len = link.char_range.end - link.char_range.start;
        let linked_text: String = build
            .job
            .text
            .chars()
            .skip(link.char_range.start)
            .take(char_len)
            .collect();
        assert_eq!(linked_text, "Docs");
    }

    #[test]
    fn test_layout_job_builder_skips_empty_link_text() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Link {
            text: String::new(),
            url: "https://example.org/docs".into(),
        }];
        let style = egui::Style::default();
        let build = renderer.build_layout_job(&style, &spans, 220.0, false, Align::LEFT);
        assert!(build.link_ranges.is_empty());
    }

    #[test]
    fn test_build_layout_job_skips_images() {
        let renderer = MarkdownRenderer::new();
        let style = egui::Style::default();
        let spans = vec![InlineSpan::Image {
            src: "dummy.png".to_string(),
            alt: "alt".to_string(),
            title: None,
        }];

        let build = renderer.build_layout_job(&style, &spans, 120.0, false, Align::LEFT);
        assert!(build.plain_text.is_empty());
    }

    #[test]
    fn test_append_spans_empty_and_code_light() {
        let renderer = MarkdownRenderer::new();
        let style = egui::Style::default();
        let mut job = LayoutJob::default();
        let mut plain_text = String::new();

        assert_eq!(
            renderer.append_plain_span(
                &style,
                &mut job,
                &mut plain_text,
                "",
                InlineStyle::default(),
                None
            ),
            0
        );
        assert_eq!(
            renderer.append_code_span(&style, &mut job, &mut plain_text, ""),
            0
        );

        let mut light_style = style.clone();
        light_style.visuals.dark_mode = false;
        assert!(renderer.append_code_span(&light_style, &mut job, &mut plain_text, "code") > 0);

        let mut empty_job = LayoutJob::default();
        let mut empty_plain = String::new();
        assert_eq!(
            renderer.append_text_sections(
                &style,
                &mut empty_job,
                &mut empty_plain,
                "",
                12.0,
                InlineStyle::default(),
                None
            ),
            0
        );
    }

    #[test]
    fn test_is_html_line_break_and_indented_code_tabs() {
        assert!(!MarkdownRenderer::is_html_line_break("<b"));
        assert!(MarkdownRenderer::is_html_line_break("<br >"));
        assert!(!MarkdownRenderer::is_html_line_break("<brx>"));
        assert!(MarkdownRenderer::is_indented_code_line("\tcode"));
    }

    #[test]
    fn test_is_html_line_break_rejects_missing_bracket() {
        assert!(!MarkdownRenderer::is_html_line_break("<br"));
        assert!(!MarkdownRenderer::is_html_line_break("<br/"));
    }

    #[test]
    fn test_is_html_line_break_slash_variants() {
        assert!(MarkdownRenderer::is_html_line_break("<br/>"));
        assert!(!MarkdownRenderer::is_html_line_break("<br/ x>"));
    }

    #[test]
    fn test_escape_pipes_inline_code_multi_backticks() {
        let out = MarkdownRenderer::escape_pipes_in_inline_code_line("``code|``");
        assert!(out.contains(PIPE_SENTINEL));
    }

    #[test]
    fn test_escape_pipes_inline_code_line_branches() {
        let plain = "no pipes here";
        assert_eq!(
            MarkdownRenderer::escape_pipes_in_inline_code_line(plain),
            plain
        );

        let line = "``code`|more``";
        let escaped = MarkdownRenderer::escape_pipes_in_inline_code_line(line);
        assert!(escaped.contains(PIPE_SENTINEL));
    }

    #[test]
    fn test_escape_table_pipes_list_indent_with_tabs_and_table() {
        let input = "- Parent\n\t- Child\n  | Head | Tail |\n  | --- | --- |\n  | a | b |\n";
        let output = MarkdownRenderer::escape_table_pipes_in_inline_code(input);
        assert!(output.contains("| Head | Tail |"));
    }

    #[test]
    fn test_escape_pipes_inline_code_line_restores_pending_on_unclosed() {
        let line = "`code|tail";
        let escaped = MarkdownRenderer::escape_pipes_in_inline_code_line(line);
        assert_eq!(escaped, line);
    }

    #[test]
    fn test_table_width_solver_keeps_short_columns_readable() {
        let mins = vec![90.0, 90.0, 90.0, 90.0];
        let desired = vec![120.0, 120.0, 360.0, 160.0];
        let widths = MarkdownRenderer::resolve_table_widths(420.0, &mins, &desired);
        assert_eq!(widths.len(), 4);
        // Narrow columns should stay near their minimums even when a wide column exists
        assert!(widths[0] >= 85.0);
        assert!(widths[2] > widths[0]);
        let sum: f32 = widths.iter().sum();
        assert!((sum - 420.0).abs() < 0.5);
    }

    #[test]
    fn test_table_width_solver_handles_constrained_space() {
        let mins = vec![100.0, 100.0, 100.0, 100.0];
        let desired = vec![200.0, 240.0, 360.0, 160.0];
        let widths = MarkdownRenderer::resolve_table_widths(260.0, &mins, &desired);
        assert_eq!(widths.len(), 4);
        assert!(widths.iter().all(|w| *w > 0.0));
        let sum: f32 = widths.iter().sum();
        assert!((sum - 260.0).abs() < 0.5);
    }

    #[test]
    fn test_row_needs_height_estimate_for_emphasis_and_strike() {
        let renderer = MarkdownRenderer::new();
        let row = vec![vec![
            InlineSpan::Emphasis("alpha".to_string()),
            InlineSpan::Strikethrough("gamma\ndelta".to_string()),
        ]];
        assert!(renderer.row_needs_height_estimate(&row));
    }

    #[test]
    fn test_row_needs_height_estimate_code_and_link_without_newlines() {
        let renderer = MarkdownRenderer::new();
        let row = vec![vec![
            InlineSpan::Code("code".to_string()),
            InlineSpan::Link {
                text: "link".to_string(),
                url: "https://example.com".to_string(),
            },
        ]];
        assert!(!renderer.row_needs_height_estimate(&row));
    }

    #[test]
    fn test_resolve_table_rects_clip_rect_fallbacks() {
        let renderer = MarkdownRenderer::new();
        let widths = vec![12.0];
        let body_clip = egui::Rect::from_min_max(egui::pos2(1.0, 2.0), egui::pos2(3.0, 4.0));
        let (rect, clip) =
            renderer.resolve_table_rects(None, None, None, None, Some(body_clip), &widths, 4.0);
        assert_eq!(clip, body_clip);

        let (rect2, clip2) =
            renderer.resolve_table_rects(None, None, None, None, None, &widths, 4.0);
        assert_eq!(clip2, rect2);
        assert_eq!(rect2.min, egui::pos2(0.0, 0.0));
        assert_eq!(rect2.max, egui::pos2(0.0, 0.0));
        assert_eq!(rect.min, egui::pos2(0.0, 0.0));
    }

    #[test]
    fn test_resolve_table_rects_prefers_layout_then_header_then_body() {
        let renderer = MarkdownRenderer::new();
        let widths = vec![10.0, 20.0];
        let layout = egui::Rect::from_min_max(egui::pos2(5.0, 6.0), egui::pos2(25.0, 26.0));
        let header = egui::Rect::from_min_max(egui::pos2(1.0, 2.0), egui::pos2(9.0, 12.0));
        let body = egui::Rect::from_min_max(egui::pos2(2.0, 3.0), egui::pos2(14.0, 18.0));

        let (rect, _) = renderer.resolve_table_rects(
            Some(header),
            Some(body),
            Some(layout),
            None,
            None,
            &widths,
            4.0,
        );
        assert_eq!(rect.min.x, layout.min.x);

        let (rect, _) =
            renderer.resolve_table_rects(Some(header), None, None, None, None, &widths, 4.0);
        assert_eq!(rect.min.x, header.min.x);

        let (rect, _) =
            renderer.resolve_table_rects(None, Some(body), None, None, None, &widths, 4.0);
        assert_eq!(rect.min.x, body.min.x);
    }

    #[test]
    fn test_resolve_table_rects_layout_only_fallbacks() {
        let renderer = MarkdownRenderer::new();
        let widths = vec![12.0];
        let layout = egui::Rect::from_min_max(egui::pos2(4.0, 7.0), egui::pos2(18.0, 21.0));
        let (rect, _) =
            renderer.resolve_table_rects(None, None, Some(layout), None, None, &widths, 4.0);
        assert_eq!(rect.min.y, layout.min.y);
        assert_eq!(rect.max.y, layout.max.y);
    }

    #[test]
    fn table_cells_keep_images_and_formatting() {
        let renderer = MarkdownRenderer::new();
        let md = "\
Intro

| H1 | H2 |
| --- | --- |
| text **extra** ![Alt](img.png) | **bold** and [link](https://example.com) |";
        let elements = renderer.parse(md).expect("parse ok");
        let table = elements
            .iter()
            .find_map(|el| match el {
                MarkdownElement::Table {
                    headers: _,
                    rows,
                    alignments: _,
                } => Some(rows),
                _ => None,
            })
            .expect("table present");
        assert_eq!(table.len(), 1);
        let row = &table[0];
        let mut saw_image = false;
        let mut saw_text = false;
        for span in &row[0] {
            match span {
                InlineSpan::Image { .. } => saw_image = true,
                InlineSpan::Text(_) => saw_text = true,
                _ => {}
            }
        }
        assert!(saw_image);
        assert!(saw_text);
        let mut saw_strong = false;
        let mut saw_link = false;
        let mut saw_other = false;
        for span in &row[1] {
            match span {
                InlineSpan::Strong(_) => saw_strong = true,
                InlineSpan::Link { .. } => saw_link = true,
                _ => saw_other = true,
            }
        }
        assert!(saw_strong);
        assert!(saw_link);
        assert!(saw_other);
    }

    #[test]
    fn table_inline_code_keeps_pipes() {
        let renderer = MarkdownRenderer::new();
        let md = "\
Intro

| Col | Notes |
| --- | --- |
| code | see `a|b|c` |";
        let elements = renderer.parse(md).expect("parse ok");
        let rows = elements
            .iter()
            .find_map(|el| match el {
                MarkdownElement::Table {
                    headers: _,
                    rows,
                    alignments: _,
                } => Some(rows),
                _ => None,
            })
            .expect("table present");
        let code_text = rows[0][1]
            .iter()
            .find_map(|span| match span {
                InlineSpan::Code(text) => Some(text.as_str()),
                _ => None,
            })
            .expect("code span");
        assert_eq!(code_text, "a|b|c");
    }

    #[test]
    fn indented_code_block_table_like_preserves_pipes() {
        let md = "\
    | Col | Notes |
    | --- | --- |
    | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(prepared.contains("`a|b|c`"));
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn blockquote_table_inline_code_escapes_pipes() {
        let md = "\
> | Col | Notes |
> | --- | --- |
> | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn blockquote_tab_table_inline_code_escapes_pipes() {
        let md = ">\t| Col | Notes |\n>\t| --- | --- |\n>\t| code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn blockquote_table_after_paragraph_parses() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let md = "\
Prelude

> Intro line
> | Col | Notes |
> | --- | --- |
> | A | B |";
        let elements = renderer.parse(md)?;
        let blocks = elements
            .iter()
            .find_map(|el| match el {
                MarkdownElement::Quote { blocks, .. } => Some(blocks),
                _ => None,
            })
            .expect("quote block");
        assert!(blocks
            .iter()
            .any(|block| matches!(block, MarkdownElement::Table { .. })));
        Ok(())
    }

    #[test]
    fn blockquote_list_table_after_paragraph_parses() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let md = "\
Prelude

> Note before list
> - Item:
>   | Key | Val |
>   | --- | --- |
>   | A | 1 |";
        let elements = renderer.parse(md)?;
        let blocks = elements
            .iter()
            .find_map(|el| match el {
                MarkdownElement::Quote { blocks, .. } => Some(blocks),
                _ => None,
            })
            .expect("quote block");
        let list = blocks
            .iter()
            .find_map(|block| match block {
                MarkdownElement::List { items, .. } => Some(items),
                _ => None,
            })
            .expect("list block");
        let first = list.first().expect("list item");
        assert!(first
            .blocks
            .iter()
            .any(|block| matches!(block, MarkdownElement::Table { .. })));
        Ok(())
    }

    #[test]
    fn blockquote_indented_code_block_preserves_pipes() {
        let md = "\
>     | Col | Notes |
>     | --- | --- |
>     | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(prepared.contains("`a|b|c`"));
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn blockquote_fenced_code_block_preserves_pipes() {
        let md = "\
> ```
> | Col | Notes |
> | --- | --- |
> | code | `a|b|c` |
> ```";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(prepared.contains("`a|b|c`"));
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn list_fenced_code_block_preserves_pipes() {
        let md = "\
- ```
  | Col | Notes |
  | --- | --- |
  | code | `a|b|c` |
  ```";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(prepared.contains("`a|b|c`"));
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn list_blockquote_fenced_code_block_preserves_pipes() {
        let md = "\
- Item
    > ```
    > | Col | Notes |
    > | --- | --- |
    > | code | `a|b|c` |
    > ```";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(prepared.contains("`a|b|c`"));
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn nested_list_fenced_code_block_preserves_pipes() {
        let md = "\
- Outer
    - ```
      | Col | Notes |
      | --- | --- |
      | code | `a|b|c` |
      ```";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(prepared.contains("`a|b|c`"));
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn list_item_code_block_preserves_pipes() {
        let md = "\
- Item
      | Col | Notes |
      | --- | --- |
      | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(prepared.contains("`a|b|c`"));
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn nested_list_table_inline_code_escapes_pipes() {
        let md = "\
- Outer
  - | Col | Notes |
    | --- | --- |
    | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn nested_list_tab_table_inline_code_escapes_pipes() {
        let md = "- Outer\n\t- | Col | Notes |\n\t  | --- | --- |\n\t  | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn nested_list_four_space_table_inline_code_escapes_pipes() {
        let md = "\
- Outer
    - | Col | Notes |
      | --- | --- |
      | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn list_marker_four_space_table_inline_code_escapes_pipes() {
        let md = "\
-    | Col | Notes |
     | --- | --- |
     | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn nested_list_indented_code_block_preserves_pipes() {
        let md = "\
- Outer
      - | Col | Notes |
        | --- | --- |
        | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(prepared.contains("`a|b|c`"));
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn deeply_nested_list_table_inline_code_escapes_pipes() {
        let md = "\
- Outer
    - Inner
        - | Col | Notes |
          | --- | --- |
          | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn list_blockquote_table_inline_code_escapes_pipes() {
        let md = "\
- Item
    > | Col | Notes |
    > | --- | --- |
    > | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn list_marker_blockquote_table_inline_code_escapes_pipes() {
        let md = "\
- > | Col | Notes |
  > | --- | --- |
  > | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn list_marker_table_dedent_does_not_escape_pipes() {
        let md = "\
- | Col | `a|b|c` |
| --- | --- |
| row | ok |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(prepared.contains("`a|b|c`"));
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn blockquote_list_table_inline_code_escapes_pipes() {
        let md = "\
> - | Col | Notes |
>   | --- | --- |
>   | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn list_marker_line_table_inline_code_escapes_pipes() {
        let md = "\
10. 
    | Col | Notes |
    | --- | --- |
    | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn list_marker_tab_after_marker_uses_tab_stops() {
        let line = "-\titem";
        let (_content, indent, content_indent) =
            MarkdownRenderer::list_marker_info(line).expect("list marker");
        assert_eq!(indent, 3);
        assert_eq!(content_indent, 4);
    }

    #[test]
    fn list_marker_any_indent_tab_stops_leading_whitespace() {
        let line = " \t- item";
        let (_content, _indent, _content_indent, leading) =
            MarkdownRenderer::list_marker_info_any_indent(line).expect("list marker");
        assert_eq!(leading, 4);
    }

    #[test]
    fn table_ends_before_inline_code_paragraph() {
        let md = "\
| Col | Notes |
| --- | --- |
| code | `a|b|c` |
Paragraph with `x|y` inline.";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
        assert!(prepared.contains("`x|y`"));
    }

    #[test]
    fn table_ends_before_escaped_pipe_paragraph() {
        let md = "\
| Col | Notes |
| --- | --- |
| code | `a|b|c` |
Paragraph with escaped \\| pipe.";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
        assert!(prepared.contains("escaped \\| pipe"));
    }

    #[test]
    fn list_table_ends_on_dedent_with_pipe_paragraph() {
        let md = "\
- | Col | Notes |
  | --- | --- |
  | code | `a|b|c` |
Paragraph with `x|y` and pipe | outside.";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
        assert!(prepared.contains("`x|y`"));
    }

    #[test]
    fn nested_list_table_ends_on_dedent_with_pipe_paragraph() {
        let md = "\
- Outer
  - | Col | Notes |
    | --- | --- |
    | code | `a|b|c` |
  Paragraph with `x|y` and pipe | outside.";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
        assert!(prepared.contains("`x|y`"));
    }

    #[test]
    fn list_table_tab_dedent_keeps_inline_code_unescaped() {
        let md =
            "- Outer\n\t- | Col | Notes |\n\t  | --- | --- |\n\t  | code | `a|b|c` |\nParagraph with `x|y` and pipe | outside.";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
        assert!(prepared.contains("`x|y`"));
    }

    #[test]
    fn list_blank_line_table_inline_code_escapes_pipes() {
        let md = "\
- Item

    | Col | Notes |
    | --- | --- |
    | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn table_delimiter_requires_pipe() {
        let md = "\
`a|b` | Header
---
Not a table";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(prepared.contains("`a|b`"));
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn table_unmatched_backticks_do_not_escape_pipes() {
        let md = "\
| Col | Notes |
| --- | --- |
| code | `a|b |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn table_escaped_backticks_do_not_escape_pipes() {
        let md = "\
| Col | Notes |
| --- | --- |
| text | \\`a|b\\` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(prepared.contains("\\`a|b\\`"));
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn list_parent_indent_nested_marker_table_escapes_pipes() {
        let md = "\
- Parent
    - | Col | Notes |
      | --- | --- |
      | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn list_parent_indent_table_without_marker_escapes_pipes() {
        let md = "\
- Parent
  | Col | Notes |
  | --- | --- |
  | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn table_blockquote_level_mismatch_ends_table() {
        let md = "\
| Col | Notes |
| --- | --- |
> | code | `a|b|c` |";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(prepared.contains("`a|b|c`"));
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn table_inserts_blank_line_before_header_with_crlf() {
        let md = "Intro line\r\n| Col | Notes |\r\n| --- | --- |\r\n| code | `a|b|c` |\r\n";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
        assert!(prepared.contains("\r\n\r\n| Col | Notes |"));
        assert!(prepared.contains(&expected));
    }

    #[test]
    fn fenced_block_quote_level_mismatch_keeps_block_open() {
        let md = "\
> ```
> | Col | Notes |
```
> | --- | --- |
> | code | `a|b|c` |
> ```";
        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(prepared.contains("`a|b|c`"));
        assert!(!prepared.contains(PIPE_SENTINEL));
    }

    #[test]
    fn table_ids_are_unique_per_position() {
        let renderer = MarkdownRenderer::new();
        let md = "\
Intro

| H |
| - |
| a |

| H |
| - |
| a |";
        let elements = renderer.parse(md).expect("parse ok");
        let tables: Vec<_> = elements
            .iter()
            .enumerate()
            .filter_map(|(idx, el)| match el {
                MarkdownElement::Table {
                    headers,
                    rows,
                    alignments,
                } => Some(renderer.compute_table_id(headers, rows, alignments, idx as u64)),
                _ => None,
            })
            .collect();
        assert_eq!(tables.len(), 2);
        assert_ne!(tables[0], tables[1]);
    }

    #[test]
    fn test_render_to_ui_rich_document_populates_rects_and_table_stats() {
        let renderer = MarkdownRenderer::new();
        let md = "\
# Coverage Demo

Paragraph with :tada: emoji and **bold** text and a [link](#target).

> Quote line one
> Quote line two

- item one
- item two

---

```rust
fn main() {}
```

| Col A | Col B |
| --- | --- |
| A1 | B1 |
| A2 | B2 |

![Logo](assets/samples/logo.svg \"Logo\")
![Sample](assets/samples/webp_sample.webp \"Sample\")
![Missing](missing_test_image.png \"Missing\")
![Remote](https://example.com/image.png \"Remote\")
";

        let elements = renderer.parse(md).expect("parse ok");
        renderer.set_highlight_phrase(Some("item"));

        with_test_ui(|_, ui| {
            renderer.render_to_ui(ui, &elements);
        });

        assert!(renderer.element_rect_at(0).is_some());
        assert!(renderer.header_rect_for("coverage-demo").is_some());
        let (rendered, total) = renderer.table_render_stats();
        assert!(total > 0);
        assert!(rendered > 0);
        let (_hits, misses) = renderer.table_layout_cache_stats();
        assert!(misses > 0);
    }

    #[test]
    fn test_table_layout_cache_records_hits() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Text("alpha".to_string())];
        let style = egui::Style::default();

        let _ = renderer.cached_layout_job(&style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
        let _ = renderer.cached_layout_job(&style, Some(0), 0, &spans, 120.0, false, Align::LEFT);

        let (hits, misses) = renderer.table_layout_cache_stats();
        assert!(hits >= 1);
        assert!(misses >= 1);

        renderer.clear_table_layout_cache();
        assert_eq!(renderer.table_layout_cache_stats(), (0, 0));
    }

    #[test]
    fn test_cell_layout_cache_eviction() {
        let mut cache = CellLayoutCache::new(2);
        let build = LayoutJobBuild {
            job: LayoutJob::default(),
            plain_text: String::new(),
            link_ranges: Vec::new(),
        };
        let key = |row, col| CellLayoutKey {
            row: Some(row),
            col,
            width: 120,
            align: 0,
            strong: false,
            text_color: [0, 0, 0, 255],
            highlight_hash: 0,
            content_hash: row as u64,
        };

        let key_a = key(0, 0);
        let key_b = key(1, 0);
        let key_c = key(2, 0);

        cache.insert(key_a.clone(), build.clone());
        cache.insert(key_b.clone(), build.clone());
        cache.insert(key_c.clone(), build);

        assert!(cache.get(&key_a).is_none());
        assert!(cache.get(&key_b).is_some());
        assert!(cache.get(&key_c).is_some());
    }

    #[test]
    fn test_cell_layout_cache_handles_empty_order() {
        let mut cache = CellLayoutCache::new(1);
        let build = LayoutJobBuild {
            job: LayoutJob::default(),
            plain_text: String::new(),
            link_ranges: Vec::new(),
        };
        let key_a = CellLayoutKey {
            row: Some(0),
            col: 0,
            width: 120,
            align: 0,
            strong: false,
            text_color: [0, 0, 0, 255],
            highlight_hash: 0,
            content_hash: 1,
        };
        let key_b = CellLayoutKey {
            row: Some(1),
            col: 0,
            width: 120,
            align: 0,
            strong: false,
            text_color: [0, 0, 0, 255],
            highlight_hash: 0,
            content_hash: 2,
        };

        cache.insert(key_a, build.clone());
        cache.order.clear();
        cache.insert(key_b.clone(), build);

        assert!(cache.get(&key_b).is_some());
    }

    #[test]
    fn test_cell_layout_cache_reinsert_existing_key() {
        let mut cache = CellLayoutCache::new(1);
        let build = LayoutJobBuild {
            job: LayoutJob::default(),
            plain_text: String::new(),
            link_ranges: Vec::new(),
        };
        let key = CellLayoutKey {
            row: Some(0),
            col: 0,
            width: 120,
            align: 0,
            strong: false,
            text_color: [0, 0, 0, 255],
            highlight_hash: 0,
            content_hash: 42,
        };
        cache.insert(key.clone(), build.clone());
        cache.insert(key.clone(), build);
        assert_eq!(cache.entries.len(), 1);
        assert_eq!(cache.order.len(), 1);
    }

    #[test]
    fn test_table_layout_cache_separates_text_colors() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Text("alpha".to_string())];
        let mut light_style = egui::Style::default();
        let mut dark_style = egui::Style::default();
        light_style.visuals.override_text_color = Some(Color32::WHITE);
        dark_style.visuals.override_text_color = Some(Color32::BLACK);

        let _ =
            renderer.cached_layout_job(&light_style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
        let _ =
            renderer.cached_layout_job(&dark_style, Some(0), 0, &spans, 120.0, false, Align::LEFT);

        let (hits, misses) = renderer.table_layout_cache_stats();
        assert_eq!(hits, 0);
        assert_eq!(misses, 2);
    }

    #[test]
    fn test_table_alignment_center_single_column() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let md = "Intro\n\n| Item |\n| :---: |\n| Alpha |\n";
        let elements = renderer.parse(md)?;
        let alignments = elements
            .iter()
            .find_map(|el| match el {
                MarkdownElement::Table { alignments, .. } => Some(alignments),
                _ => None,
            })
            .expect("table element");
        assert_eq!(alignments.len(), 1);
        assert_eq!(alignments[0], Alignment::Center);
        Ok(())
    }

    #[test]
    fn test_single_column_table_parses_one_cell_per_row() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let md =
            "Intro\n\n| Item |\n| :---: |\n| Alpha |\n| line one<br>line two |\n| **bold** and `code` |\n";
        let elements = renderer.parse(md)?;
        let (headers, rows) = elements
            .iter()
            .find_map(|el| match el {
                MarkdownElement::Table { headers, rows, .. } => Some((headers, rows)),
                _ => None,
            })
            .expect("table element");
        assert_eq!(headers.len(), 1);
        assert!(rows.iter().all(|row| row.len() == 1));
        Ok(())
    }

    #[test]
    fn test_table_first_column_alignment_parses_three_columns() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let md = fs::read_to_string("tests/regression/cases/026-table-first-column-align.md")?;
        let elements = renderer.parse(&md)?;
        let tables: Vec<_> = elements
            .iter()
            .filter_map(|el| match el {
                MarkdownElement::Table {
                    headers,
                    rows,
                    alignments,
                } => Some((headers, rows, alignments)),
                _ => None,
            })
            .collect();
        assert!(tables.len() >= 3);
        let (first_headers, first_rows, first_alignments) = tables[0];
        for (headers, rows, alignments) in tables.iter() {
            assert_eq!(headers.len(), 3);
            assert_eq!(alignments.len(), 3);
            assert!(rows.iter().all(|row| row.len() == 3));
        }
        let table_id = renderer.compute_table_id(first_headers, first_rows, first_alignments, 0);
        let available = Cell::new(0.0f32);
        let spacing = Cell::new(0.0f32);
        let _estimated_before = {
            let column_stats = renderer.column_stats_for_table(
                table_id,
                first_headers,
                first_rows,
                first_alignments,
            );
            let ctx = TableColumnContext::new(
                first_headers,
                first_rows,
                &column_stats,
                renderer.font_sizes.body,
                table_id,
            );
            let column_specs = derive_column_specs(&ctx);
            let column_spacing = 6.0f32.max(egui::Style::default().spacing.item_spacing.x);
            renderer.estimate_table_total_width(table_id, &column_specs, column_spacing)
        };
        with_test_ui(|_, ui| {
            available.set(ui.available_width());
            spacing.set(ui.spacing().item_spacing.x.max(6.0));
            renderer.render_table_tablebuilder(
                ui,
                first_headers,
                first_rows,
                first_alignments,
                table_id,
            );
        });
        let widths = renderer
            .table_metrics
            .borrow()
            .entry(table_id)
            .map(|entry| entry.current_widths().to_vec())
            .unwrap_or_default();
        assert_eq!(widths.len(), 3);
        assert!(widths.iter().all(|w| *w > 8.0));
        Ok(())
    }

    #[test]
    fn test_trigger_link_handles_fragments_and_schemes() {
        let renderer = MarkdownRenderer::new();

        renderer.trigger_link("#Section-One");
        assert_eq!(
            renderer.take_pending_anchor(),
            Some("section-one".to_string())
        );
        assert!(renderer.take_pending_anchor().is_none());

        renderer.trigger_link("ftp://example.com");
        assert!(renderer.take_pending_anchor().is_none());

        renderer.trigger_link("https://example.com");
        assert!(renderer.take_pending_anchor().is_none());

        renderer.trigger_link("mailto:hello@example.com");
        assert!(renderer.take_pending_anchor().is_none());
    }

    #[test]
    fn test_resolve_image_path_with_base_dir() {
        let renderer = MarkdownRenderer::new();
        let temp = tempdir().expect("temp dir");
        renderer.set_base_dir(Some(temp.path()));

        let resolved = renderer.resolve_image_path("sample.png");
        assert!(resolved.contains("sample.png"));

        let abs = temp.path().join("abs.png");
        let abs_str = abs.to_string_lossy().into_owned();
        assert_eq!(renderer.resolve_image_path(&abs_str), abs_str);

        renderer.set_base_dir(None);
        assert_eq!(renderer.resolve_image_path("relative.png"), "relative.png");
    }

    #[test]
    fn test_disk_image_loads_and_caches() {
        let renderer = MarkdownRenderer::new();
        let temp = tempdir().expect("temp dir");
        let image_path = temp.path().join("disk.png");

        let mut img = image::RgbaImage::new(2, 2);
        for pixel in img.pixels_mut() {
            *pixel = image::Rgba([10, 20, 30, 255]);
        }
        img.save(&image_path).expect("save png");

        renderer.set_base_dir(Some(temp.path()));
        let resolved = renderer.resolve_image_path("disk.png");
        with_test_ui(|ctx, ui| {
            // Use wait_for_image to handle async image loading
            let loaded = wait_for_image(&renderer, ctx, ui, &resolved);
            assert!(loaded.is_some());
        });

        assert!(renderer.image_textures.borrow().contains_key(&resolved));
    }

    #[test]
    fn test_context_menu_helpers_execute() {
        let renderer = MarkdownRenderer::new();
        let _actions = ForcedRenderActions::new(&[
            "copy_text",
            "copy_inline_code",
            "copy_code_block",
            "copy_code_block_lang",
            "open_link",
            "copy_link_text",
            "copy_link_url",
            "copy_cell_text",
        ]);
        with_test_ui(|_, ui| {
            renderer.render_text_context_menu(ui, "text");
            renderer.render_inline_code_context_menu(ui, "code");
            renderer.render_code_block_context_menu(ui, "fn main() {}", Some("rust"));
            renderer.render_link_context_menu(ui, "label", "#anchor");
            renderer.render_cell_context_menu(ui, "cell");
            renderer.copy_text_and_close(ui, "direct-copy");
        });
    }

    #[test]
    fn test_context_menu_helpers_no_actions() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            renderer.render_text_context_menu(ui, "text");
            renderer.render_inline_code_context_menu(ui, "code");
            renderer.render_code_block_context_menu(ui, "fn main() {}", None);
            renderer.render_link_context_menu(ui, "label", "#anchor");
            renderer.render_cell_context_menu(ui, "cell");
        });
    }

    #[test]
    fn test_estimate_table_column_widths_scales_down() {
        let renderer = MarkdownRenderer::new();
        let specs = vec![
            ColumnSpec::new(
                0,
                "A",
                ColumnPolicy::Resizable {
                    min: 100.0,
                    preferred: 100.0,
                    clip: false,
                },
                None,
            ),
            ColumnSpec::new(
                1,
                "B",
                ColumnPolicy::Resizable {
                    min: 100.0,
                    preferred: 100.0,
                    clip: false,
                },
                None,
            ),
        ];

        let widths = renderer.estimate_table_column_widths(&specs, 150.0, 10.0);
        let total = widths.iter().sum::<f32>() + 10.0;
        assert!(total <= 150.5);
    }

    #[test]
    fn test_estimate_table_image_height_no_scale_or_title() {
        let renderer = MarkdownRenderer::new();
        let span = InlineSpan::Image {
            src: "missing.png".to_string(),
            alt: "Alt".to_string(),
            title: Some(String::new()),
        };
        with_test_ui(|_, ui| {
            let height = renderer.estimate_table_image_height(ui, &span, 2000.0);
            assert!(height > 0.0);
        });
    }

    #[test]
    fn test_row_height_hint_uses_fallback_for_zero_height() {
        let renderer = MarkdownRenderer::new();
        let table_id = 42u64;
        renderer
            .table_metrics
            .borrow_mut()
            .entry_mut(table_id)
            .ensure_row(0)
            .max_height = 0.0;
        let height = renderer.row_height_hint(table_id, 0);
        assert_eq!(height, renderer.row_height_fallback());
    }

    #[test]
    fn test_build_layout_job_covers_inline_styles() {
        let renderer = MarkdownRenderer::new();
        renderer.set_highlight_phrase(Some("code"));
        let spans = vec![
            InlineSpan::Text("plain".to_string()),
            InlineSpan::Strong("bold".to_string()),
            InlineSpan::Emphasis("italics".to_string()),
            InlineSpan::Strikethrough("strike".to_string()),
            InlineSpan::Code("code".to_string()),
            InlineSpan::Link {
                text: "ext".to_string(),
                url: "https://example.com".to_string(),
            },
            InlineSpan::Link {
                text: "local".to_string(),
                url: "#anchor".to_string(),
            },
        ];

        with_test_ui(|_, ui| {
            let style = ui.style().clone();
            let build = renderer.build_layout_job(&style, &spans, 200.0, false, Align::LEFT);
            assert!(build.plain_text.contains("plain"));
            assert_eq!(build.link_ranges.len(), 2);
        });
    }

    #[test]
    fn test_build_layout_job_strong_uses_override_text_color() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Text("Header".to_string())];
        let mut style = egui::Style::default();
        let override_color = Color32::from_rgb(10, 20, 30);
        style.visuals.override_text_color = Some(override_color);

        let build = renderer.build_layout_job(&style, &spans, 200.0, true, Align::LEFT);
        assert!(!build.job.sections.is_empty());
        assert_eq!(build.job.sections[0].format.color, override_color);
    }

    #[test]
    fn test_render_inline_span_variants() {
        let renderer = MarkdownRenderer::new();
        let temp = tempdir().expect("temp dir");
        let image_path = temp.path().join("image.png");
        std::fs::write(&image_path, tiny_png_bytes()).expect("write png");
        renderer.set_base_dir(Some(temp.path()));

        let image_span = InlineSpan::Image {
            src: "image.png".to_string(),
            alt: "Alt".to_string(),
            title: Some("Title".to_string()),
        };
        let missing_span = InlineSpan::Image {
            src: "missing.png".to_string(),
            alt: "".to_string(),
            title: None,
        };
        let remote_span = InlineSpan::Image {
            src: "https://example.com/image.png".to_string(),
            alt: "Remote".to_string(),
            title: None,
        };
        let remote_http_span = InlineSpan::Image {
            src: "http://example.com/image.png".to_string(),
            alt: "RemoteHttp".to_string(),
            title: None,
        };

        let _guard = ForcedRenderActions::new(&["link_hover", "link_click", "image_hover"]);
        with_test_ui(|ctx, ui| {
            ui.visuals_mut().dark_mode = false;
            renderer.render_inline_span(ui, &InlineSpan::Code("code".to_string()), None, None);

            ui.visuals_mut().dark_mode = true;
            renderer.render_inline_span(ui, &InlineSpan::Text("text".to_string()), None, None);
            renderer.render_inline_span(ui, &InlineSpan::Strong("bold".to_string()), None, None);
            renderer.render_inline_span(
                ui,
                &InlineSpan::Emphasis("italic".to_string()),
                None,
                None,
            );
            renderer.render_inline_span(
                ui,
                &InlineSpan::Strikethrough("strike".to_string()),
                None,
                None,
            );
            renderer.render_inline_span(
                ui,
                &InlineSpan::Link {
                    text: "ext".to_string(),
                    url: "https://example.com".to_string(),
                },
                None,
                None,
            );
            renderer.render_inline_span(
                ui,
                &InlineSpan::Link {
                    text: "local".to_string(),
                    url: "#anchor".to_string(),
                },
                None,
                None,
            );
            let resolved = renderer.resolve_image_path("image.png");
            let _loaded = wait_for_image(&renderer, ctx, ui, &resolved);
            renderer.render_inline_span(ui, &image_span, None, None);
            renderer.render_inline_span(ui, &missing_span, None, None);
            renderer.render_inline_span(ui, &remote_span, None, None);
            renderer.render_inline_span(ui, &remote_http_span, None, None);
        });
    }

    #[test]
    fn test_has_pending_renders_with_image_pending() {
        let renderer = MarkdownRenderer::new();
        assert!(!renderer.has_pending_renders());
        renderer
            .image_pending
            .borrow_mut()
            .insert("queued.png".to_string());
        assert!(renderer.has_pending_renders());
    }

    #[test]
    fn test_has_pending_renders_with_mermaid_pending() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            renderer.mermaid.begin_frame();
            renderer
                .mermaid
                .render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
        });
        assert!(renderer.has_pending_renders());
    }

    #[test]
    fn test_parse_lists_and_blockquotes() {
        let renderer = MarkdownRenderer::new();
        let md = "\
- Item 1
- Item 2
  - Nested

1. First
2. Second

> Quote line
> > Nested quote

---";

        let elements = renderer.parse(md).expect("parse ok");
        assert!(elements
            .iter()
            .any(|el| matches!(el, MarkdownElement::List { ordered: false, .. })));
        assert!(elements
            .iter()
            .any(|el| matches!(el, MarkdownElement::List { ordered: true, .. })));
        assert!(elements
            .iter()
            .any(|el| matches!(el, MarkdownElement::Quote { .. })));
        assert!(elements
            .iter()
            .any(|el| matches!(el, MarkdownElement::HorizontalRule)));
    }

    #[test]
    fn test_elements_to_plain_text_variants() {
        let elements = vec![
            MarkdownElement::Header {
                level: 1,
                spans: vec![InlineSpan::Text("Title".to_string())],
                id: "title".to_string(),
            },
            MarkdownElement::Paragraph(vec![
                InlineSpan::Text("Hello".to_string()),
                InlineSpan::Code("code".to_string()),
            ]),
            MarkdownElement::CodeBlock {
                language: Some("rust".to_string()),
                text: "fn main() {}".to_string(),
            },
            MarkdownElement::List {
                ordered: false,
                items: vec![ListItem {
                    blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
                        "Item".to_string(),
                    )])],
                }],
            },
            MarkdownElement::Quote {
                depth: 1,
                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
                    "Quote".to_string(),
                )])],
            },
            MarkdownElement::HorizontalRule,
            MarkdownElement::Table {
                headers: vec![vec![InlineSpan::Text("H".to_string())]],
                rows: vec![vec![vec![InlineSpan::Image {
                    src: "img.png".to_string(),
                    alt: "Alt".to_string(),
                    title: None,
                }]]],
                alignments: Vec::new(),
            },
        ];
        let text = MarkdownRenderer::elements_to_plain_text(&elements);
        assert!(text.contains("Title"));
        assert!(text.contains("Hello"));
        assert!(text.contains("fn main"));
        assert!(text.contains("Item"));
        assert!(text.contains("Quote"));
        assert!(text.contains("Alt"));
    }

    #[test]
    fn test_elements_to_plain_text_image_title_and_empty_rule() {
        let elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Image {
            src: "img.png".to_string(),
            alt: "".to_string(),
            title: Some("Diagram Title".to_string()),
        }])];
        let text = MarkdownRenderer::elements_to_plain_text(&elements);
        assert!(text.contains("Diagram Title"));

        let hr_only = vec![MarkdownElement::HorizontalRule];
        assert_eq!(MarkdownRenderer::elements_to_plain_text(&hr_only), "");
    }

    #[test]
    fn test_table_rendering_overhaul() {
        let renderer = MarkdownRenderer::new();
        let headers = vec![
            vec![InlineSpan::Text("H1".to_string())],
            vec![InlineSpan::Text("H2".to_string())],
        ];
        let rows = vec![vec![
            vec![InlineSpan::Text("Cell".to_string())],
            vec![InlineSpan::Link {
                text: "Link".to_string(),
                url: "https://example.com".to_string(),
            }],
        ]];
        let elements = vec![MarkdownElement::Table {
            headers,
            rows,
            alignments: Vec::new(),
        }];

        with_test_ui(|_, ui| {
            renderer.render_to_ui(ui, &elements);
        });
    }

    #[test]
    fn test_measure_inline_spans_and_emoji_texture() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![
            InlineSpan::Text("Hello".to_string()),
            InlineSpan::Text("".to_string()),
        ];

        with_test_ui(|_, ui| {
            let width = renderer.measure_inline_spans(ui, &spans);
            assert!(width > 0.0);
            let tex = renderer.get_or_make_emoji_texture(ui, "");
            assert!(tex.size()[0] > 0);
        });

        let img = renderer.generate_emoji_image("", 16);
        assert_eq!(img.size[0], 16);
    }

    #[test]
    fn test_measure_inline_spans_respects_line_breaks() {
        let renderer = MarkdownRenderer::new();
        let single_line = vec![InlineSpan::Text(
            "Short This is a much longer line".to_string(),
        )];
        let multi_line = vec![InlineSpan::Text(
            "Short\nThis is a much longer line".to_string(),
        )];

        with_test_ui(|_, ui| {
            let single = renderer.measure_inline_spans(ui, &single_line);
            let multi = renderer.measure_inline_spans(ui, &multi_line);
            assert!(multi < single);
        });
    }

    #[test]
    fn test_measure_inline_spans_normalizes_unicode() {
        let renderer = MarkdownRenderer::new();
        let unicode = vec![InlineSpan::Text("A\u{2192}B".to_string())];
        let ascii = vec![InlineSpan::Text("A->B".to_string())];

        with_test_ui(|_, ui| {
            let unicode_width = renderer.measure_inline_spans(ui, &unicode);
            let ascii_width = renderer.measure_inline_spans(ui, &ascii);
            assert!((unicode_width - ascii_width).abs() < 0.5);
        });
    }

    #[test]
    fn test_to_superscript_full_mapping() {
        let input = "0123456789+-=()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#";
        let out = MarkdownRenderer::to_superscript(input);
        assert_eq!(out.chars().count(), input.chars().count());
        assert!(out.contains('\u{2070}'));
        assert!(out.contains('\u{00b9}'));
        assert!(out.contains('\u{1d43}'));
        assert!(out.contains('#'));
    }

    #[test]
    fn test_element_plain_text_variants() {
        let list = MarkdownElement::List {
            ordered: false,
            items: vec![ListItem {
                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
                    "Item".to_string(),
                )])],
            }],
        };
        let quote = MarkdownElement::Quote {
            depth: 1,
            blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
                "Quote".to_string(),
            )])],
        };
        let table = MarkdownElement::Table {
            headers: vec![vec![InlineSpan::Text("Header".to_string())]],
            rows: vec![vec![vec![InlineSpan::Text("Cell".to_string())]]],
            alignments: Vec::new(),
        };

        assert!(MarkdownRenderer::element_plain_text(&list).contains("Item"));
        assert!(MarkdownRenderer::element_plain_text(&quote).contains("Quote"));
        assert_eq!(
            MarkdownRenderer::element_plain_text(&MarkdownElement::HorizontalRule),
            "---"
        );
        assert!(MarkdownRenderer::element_plain_text(&table).contains("Header"));
        assert!(MarkdownRenderer::element_plain_text(&table).contains("Cell"));
    }

    #[test]
    fn test_parse_element_image_outside_paragraph() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Image(
                LinkType::Inline,
                "img.png".into(),
                "Title".into(),
            )),
            Event::Text("Alt".into()),
            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
        ];
        let mut elements = Vec::new();
        let mut slugs = std::collections::HashMap::new();
        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs);
        assert_eq!(next, events.len());
        assert!(matches!(
            elements.first(),
            Some(MarkdownElement::Paragraph(_))
        ));
        let spans = paragraph_spans(elements.first().expect("element")).expect("paragraph spans");
        let (_src, _alt, title) = image_span_fields(&spans[0]).expect("image span");
        assert_eq!(title, Some("Title"));
        assert!(paragraph_spans(&MarkdownElement::HorizontalRule).is_none());
    }

    #[test]
    fn test_parse_element_empty_paragraph_skips() {
        let renderer = MarkdownRenderer::new();
        let events = vec![Event::Start(Tag::Paragraph), Event::End(Tag::Paragraph)];
        let mut elements = Vec::new();
        let mut slugs = HashMap::new();
        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs);
        assert_eq!(next, events.len());
        assert!(elements.is_empty());
    }

    #[test]
    fn test_parse_element_empty_blockquote_skips() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::BlockQuote),
            Event::Start(Tag::BlockQuote),
            Event::End(Tag::BlockQuote),
            Event::End(Tag::BlockQuote),
        ];
        let mut elements = Vec::new();
        let mut slugs = HashMap::new();
        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs);
        assert_eq!(next, events.len());
        assert!(elements.is_empty());
    }

    #[test]
    fn test_parse_list_event_variants() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::List(None)),
            Event::Start(Tag::Item),
            Event::Start(Tag::Emphasis),
            Event::Text("em".into()),
            Event::End(Tag::Emphasis),
            Event::Start(Tag::Strong),
            Event::Text("strong".into()),
            Event::End(Tag::Strong),
            Event::Start(Tag::Strikethrough),
            Event::Text("strike".into()),
            Event::End(Tag::Strikethrough),
            Event::Start(Tag::Link(
                LinkType::Inline,
                "https://example.com".into(),
                "".into(),
            )),
            Event::Text("link".into()),
            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
            Event::Start(Tag::Image(
                LinkType::Inline,
                "img.png".into(),
                "Title".into(),
            )),
            Event::Text("alt".into()),
            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
            Event::Code("code".into()),
            Event::Text("text".into()),
            Event::SoftBreak,
            Event::Start(Tag::List(Some(1))),
            Event::Start(Tag::Item),
            Event::Text("nested".into()),
            Event::End(Tag::Item),
            Event::End(Tag::List(Some(1))),
            Event::End(Tag::Item),
            Event::End(Tag::List(None)),
        ];

        let mut slugs = std::collections::HashMap::new();
        let (items, next) = renderer.parse_list(&events, 1, &mut slugs);
        assert_eq!(next, events.len());
        assert_eq!(items.len(), 1);
        let item = &items[0];
        let mut blocks = Vec::new();
        blocks.push(MarkdownElement::HorizontalRule);
        blocks.extend(item.blocks.clone());
        let spans = blocks
            .iter()
            .find_map(|block| match block {
                MarkdownElement::Paragraph(spans) => Some(spans),
                _ => None,
            })
            .expect("paragraph block");
        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Emphasis(_))));
        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Strong(_))));
        assert!(spans
            .iter()
            .any(|s| matches!(s, InlineSpan::Strikethrough(_))));
        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Link { .. })));
        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Image { .. })));
        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Code(_))));
        assert!(item
            .blocks
            .iter()
            .any(|block| matches!(block, MarkdownElement::List { ordered: true, .. })));
        Ok(())
    }

    #[test]
    fn test_parse_inline_spans_with_breaks_variants() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Paragraph),
            Event::Text("Hello".into()),
            Event::SoftBreak,
            Event::Code("code".into()),
            Event::Start(Tag::Strong),
            Event::Text("bold".into()),
            Event::End(Tag::Strong),
            Event::Start(Tag::Emphasis),
            Event::Text("em".into()),
            Event::End(Tag::Emphasis),
            Event::Start(Tag::Strikethrough),
            Event::Text("strike".into()),
            Event::End(Tag::Strikethrough),
            Event::Start(Tag::Link(
                LinkType::Inline,
                "https://example.com".into(),
                "".into(),
            )),
            Event::Text("link".into()),
            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
            Event::Start(Tag::Image(
                LinkType::Inline,
                "img.png".into(),
                "Title".into(),
            )),
            Event::Text("alt".into()),
            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
            Event::End(Tag::Paragraph),
        ];

        let (spans, next) =
            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true);
        assert_eq!(next, events.len());
        let mut saw_code = false;
        let mut saw_strong = false;
        let mut saw_emphasis = false;
        let mut saw_strike = false;
        let mut saw_link = false;
        let mut saw_image = false;
        let mut saw_break_text = false;
        for span in &spans {
            match span {
                InlineSpan::Code(_) => saw_code = true,
                InlineSpan::Strong(_) => saw_strong = true,
                InlineSpan::Emphasis(_) => saw_emphasis = true,
                InlineSpan::Strikethrough(_) => saw_strike = true,
                InlineSpan::Link { .. } => saw_link = true,
                InlineSpan::Image { .. } => saw_image = true,
                InlineSpan::Text(t) if t.contains('\n') => saw_break_text = true,
                _ => {}
            }
        }
        assert!(saw_code);
        assert!(saw_strong);
        assert!(saw_emphasis);
        assert!(saw_strike);
        assert!(saw_link);
        assert!(saw_image);
        assert!(saw_break_text);
    }

    #[test]
    fn test_parse_inline_spans_html_breaks() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Paragraph),
            Event::Text("one".into()),
            Event::Html("<br>".into()),
            Event::Text("two".into()),
            Event::End(Tag::Paragraph),
        ];

        let (spans, next) =
            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true);
        assert_eq!(next, events.len());
        assert!(spans
            .iter()
            .any(|s| matches!(s, InlineSpan::Text(t) if t == "\n")));

        let (spans_no_break, _) = renderer.parse_inline_spans(&events, 1, Tag::Paragraph);
        let text = MarkdownRenderer::spans_plain_text(&spans_no_break);
        assert!(text.contains("one two"));

        let attr_events = vec![
            Event::Start(Tag::Paragraph),
            Event::Text("alpha".into()),
            Event::Html("<br class=\"tight\">".into()),
            Event::Text("beta".into()),
            Event::End(Tag::Paragraph),
        ];
        let (spans, next) =
            renderer.parse_inline_spans_with_breaks(&attr_events, 1, Tag::Paragraph, true);
        assert_eq!(next, attr_events.len());
        assert!(spans
            .iter()
            .any(|s| matches!(s, InlineSpan::Text(t) if t == "\n")));

        let strong_events = vec![
            Event::Start(Tag::Paragraph),
            Event::Text("lead ".into()),
            Event::Start(Tag::Strong),
            Event::Text("alpha".into()),
            Event::Html("<br>".into()),
            Event::Text("beta".into()),
            Event::End(Tag::Strong),
            Event::End(Tag::Paragraph),
        ];
        let (_spans, next) =
            renderer.parse_inline_spans_with_breaks(&strong_events, 1, Tag::Paragraph, true);
        assert_eq!(next, strong_events.len());

        let (spans_no_break, _) = renderer.parse_inline_spans(&strong_events, 1, Tag::Paragraph);
        let mut saw_non_strong = false;
        let mut strong_text = None;
        for span in &spans_no_break {
            if let InlineSpan::Strong(text) = span {
                strong_text = Some(text.as_str());
            } else {
                saw_non_strong = true;
            }
        }
        assert!(saw_non_strong);
        let mut saw_match = false;
        let mut saw_miss = false;
        let mut saw_none = false;
        for candidate in [strong_text, Some("nope"), None] {
            if let Some(text) = candidate {
                if text.contains("alpha beta") {
                    saw_match = true;
                } else {
                    saw_miss = true;
                }
            } else {
                saw_none = true;
            }
        }
        assert!(saw_match);
        assert!(saw_miss);
        assert!(saw_none);
    }

    #[test]
    fn test_parse_inline_spans_soft_break_without_keep() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Paragraph),
            Event::Text("alpha".into()),
            Event::SoftBreak,
            Event::Text("beta".into()),
            Event::End(Tag::Paragraph),
        ];

        let (spans, next) = renderer.parse_inline_spans(&events, 1, Tag::Paragraph);
        assert_eq!(next, events.len());
        assert_eq!(MarkdownRenderer::spans_plain_text(&spans), "alpha beta");
    }

    #[test]
    fn test_collect_blockquotes_nested_and_breaks() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::BlockQuote),
            Event::Start(Tag::Paragraph),
            Event::Text("Line1\nLine2".into()),
            Event::End(Tag::Paragraph),
            Event::SoftBreak,
            Event::Start(Tag::BlockQuote),
            Event::Start(Tag::Paragraph),
            Event::Text("Nested".into()),
            Event::End(Tag::Paragraph),
            Event::End(Tag::BlockQuote),
            Event::End(Tag::BlockQuote),
        ];
        let mut slugs = HashMap::new();
        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs);
        assert_eq!(next, events.len());
        assert!(quotes.iter().any(|(depth, _)| *depth == 1));
        assert!(quotes.iter().any(|(depth, _)| *depth == 2));
    }

    #[test]
    fn test_collect_blockquotes_event_variants() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::BlockQuote),
            Event::Start(Tag::Paragraph),
            Event::Text("para".into()),
            Event::End(Tag::Paragraph),
            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
            Event::Text("Heading".into()),
            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
            Event::Start(Tag::List(None)),
            Event::Start(Tag::Item),
            Event::Text("item".into()),
            Event::End(Tag::Item),
            Event::End(Tag::List(None)),
            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
                "rust".into(),
            ))),
            Event::Text("fn main() {}\n".into()),
            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
                "rust".into(),
            ))),
            Event::Start(Tag::Table(vec![Alignment::Left])),
            Event::Start(Tag::TableHead),
            Event::Start(Tag::TableRow),
            Event::Start(Tag::TableCell),
            Event::Text("H".into()),
            Event::End(Tag::TableCell),
            Event::End(Tag::TableRow),
            Event::End(Tag::TableHead),
            Event::Start(Tag::TableRow),
            Event::Start(Tag::TableCell),
            Event::Text("R".into()),
            Event::End(Tag::TableCell),
            Event::End(Tag::TableRow),
            Event::End(Tag::Table(vec![Alignment::Left])),
            Event::Start(Tag::Emphasis),
            Event::Text("em".into()),
            Event::End(Tag::Emphasis),
            Event::Start(Tag::Strong),
            Event::Text("strong".into()),
            Event::End(Tag::Strong),
            Event::Start(Tag::Strikethrough),
            Event::Text("strike".into()),
            Event::End(Tag::Strikethrough),
            Event::Start(Tag::Link(
                LinkType::Inline,
                "https://example.com".into(),
                "".into(),
            )),
            Event::Text("link".into()),
            Event::End(Tag::Link(
                LinkType::Inline,
                "https://example.com".into(),
                "".into(),
            )),
            Event::Start(Tag::Image(
                LinkType::Inline,
                "img.png".into(),
                "Title".into(),
            )),
            Event::Text("alt".into()),
            Event::End(Tag::Image(
                LinkType::Inline,
                "img.png".into(),
                "Title".into(),
            )),
            Event::Code("code".into()),
            Event::SoftBreak,
            Event::HardBreak,
            Event::Html("<br>".into()),
            Event::Rule,
            Event::Start(Tag::BlockQuote),
            Event::Start(Tag::Paragraph),
            Event::Text("Nested".into()),
            Event::End(Tag::Paragraph),
            Event::End(Tag::BlockQuote),
            Event::End(Tag::BlockQuote),
        ];
        let mut slugs = HashMap::new();
        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs);
        assert_eq!(next, events.len());
        assert!(!quotes.is_empty());
    }

    #[test]
    fn test_collect_blockquotes_empty_paragraph_and_html_ignored() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::BlockQuote),
            Event::Start(Tag::Paragraph),
            Event::End(Tag::Paragraph),
            Event::Html("<span>".into()),
            Event::End(Tag::BlockQuote),
        ];
        let mut slugs = HashMap::new();
        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs);
        assert_eq!(next, events.len());
        assert!(quotes.is_empty());
    }

    #[test]
    fn test_collect_blockquotes_empty_unclosed_returns_empty() {
        let renderer = MarkdownRenderer::new();
        let events = vec![Event::Start(Tag::BlockQuote)];
        let mut slugs = HashMap::new();
        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs);
        assert_eq!(next, events.len());
        assert!(quotes.is_empty());
    }

    #[test]
    fn test_parse_list_block_elements() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::List(Some(1))),
            Event::Start(Tag::Item),
            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H3, None, vec![])),
            Event::Text("Heading".into()),
            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H3, None, vec![])),
            Event::Start(Tag::Table(vec![Alignment::Left])),
            Event::Start(Tag::TableHead),
            Event::Start(Tag::TableRow),
            Event::Start(Tag::TableCell),
            Event::Text("H".into()),
            Event::End(Tag::TableCell),
            Event::End(Tag::TableRow),
            Event::End(Tag::TableHead),
            Event::Start(Tag::TableRow),
            Event::Start(Tag::TableCell),
            Event::Text("R".into()),
            Event::End(Tag::TableCell),
            Event::End(Tag::TableRow),
            Event::End(Tag::Table(vec![Alignment::Left])),
            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
                "rust".into(),
            ))),
            Event::Text("fn main() {}\n".into()),
            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
                "rust".into(),
            ))),
            Event::Start(Tag::BlockQuote),
            Event::Start(Tag::Paragraph),
            Event::Text("Quote".into()),
            Event::End(Tag::Paragraph),
            Event::End(Tag::BlockQuote),
            Event::Rule,
            Event::HardBreak,
            Event::End(Tag::Item),
            Event::End(Tag::List(Some(1))),
        ];
        let mut slugs = HashMap::new();
        let (items, next) = renderer.parse_list(&events, 1, &mut slugs);
        assert_eq!(next, events.len());
        assert_eq!(items.len(), 1);
        Ok(())
    }

    #[test]
    fn test_parse_element_variants() {
        let renderer = MarkdownRenderer::new();
        let mut slugs = HashMap::new();
        let mut elements = Vec::new();

        let paragraph = vec![
            Event::Start(Tag::Paragraph),
            Event::Text("para".into()),
            Event::End(Tag::Paragraph),
        ];
        let next = renderer.parse_element(&paragraph, 0, &mut elements, &mut slugs);
        assert_eq!(next, paragraph.len());

        let heading = vec![
            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
            Event::Text("Heading".into()),
            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
        ];
        let next = renderer.parse_element(&heading, 0, &mut elements, &mut slugs);
        assert_eq!(next, heading.len());

        let code_block = vec![
            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
                "rust".into(),
            ))),
            Event::Text("fn main() {}\n".into()),
            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
                "rust".into(),
            ))),
        ];
        let next = renderer.parse_element(&code_block, 0, &mut elements, &mut slugs);
        assert_eq!(next, code_block.len());

        let list = vec![
            Event::Start(Tag::List(None)),
            Event::Start(Tag::Item),
            Event::Text("item".into()),
            Event::End(Tag::Item),
            Event::End(Tag::List(None)),
        ];
        let next = renderer.parse_element(&list, 0, &mut elements, &mut slugs);
        assert_eq!(next, list.len());

        let quote = vec![
            Event::Start(Tag::BlockQuote),
            Event::Start(Tag::Paragraph),
            Event::Text("quote".into()),
            Event::End(Tag::Paragraph),
            Event::End(Tag::BlockQuote),
        ];
        let next = renderer.parse_element(&quote, 0, &mut elements, &mut slugs);
        assert_eq!(next, quote.len());

        let table = vec![
            Event::Start(Tag::Table(vec![Alignment::Left])),
            Event::Start(Tag::TableHead),
            Event::Start(Tag::TableRow),
            Event::Start(Tag::TableCell),
            Event::Text("H".into()),
            Event::End(Tag::TableCell),
            Event::End(Tag::TableRow),
            Event::End(Tag::TableHead),
            Event::Start(Tag::TableRow),
            Event::Start(Tag::TableCell),
            Event::Text("R".into()),
            Event::End(Tag::TableCell),
            Event::End(Tag::TableRow),
            Event::End(Tag::Table(vec![Alignment::Left])),
        ];
        let next = renderer.parse_element(&table, 0, &mut elements, &mut slugs);
        assert_eq!(next, table.len());

        let rule = vec![Event::Rule];
        let next = renderer.parse_element(&rule, 0, &mut elements, &mut slugs);
        assert_eq!(next, rule.len());
    }

    #[test]
    fn test_parse_code_block_with_language() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let elements = renderer.parse("Intro\n\n```rust\nfn main() {}\n```")?;
        let mut rust_lang = None;
        for element in &elements {
            if let MarkdownElement::CodeBlock { language, .. } = element {
                rust_lang = language.as_deref();
            }
        }
        assert_eq!(rust_lang, Some("rust"));
        Ok(())
    }

    #[test]
    fn test_parse_code_block_empty_language() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
                "".into(),
            ))),
            Event::Text("fn main() {}".into()),
            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
                "".into(),
            ))),
        ];
        let (code, language, next) = renderer.parse_code_block(&events, 0);
        assert_eq!(language, None);
        assert_eq!(code, "fn main() {}");
        assert_eq!(next, events.len());
    }

    #[test]
    fn test_parse_code_block_indented() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Indented)),
            Event::Text("let x = 1;".into()),
            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Indented)),
        ];
        let (code, language, next) = renderer.parse_code_block(&events, 0);
        assert_eq!(language, None);
        assert_eq!(code, "let x = 1;");
        assert_eq!(next, events.len());
    }

    #[test]
    fn test_parse_table_from_markdown() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let md = "| H1 | H2 |\n| --- | --- |\n| A | B |\n| C | D |\n";
        let elements = renderer.parse(md)?;
        assert!(elements
            .iter()
            .any(|el| matches!(el, MarkdownElement::Table { .. })));
        Ok(())
    }

    #[test]
    fn test_hash_inline_spans_variants() {
        let spans = vec![
            InlineSpan::Text("t".to_string()),
            InlineSpan::Code("c".to_string()),
            InlineSpan::Strong("s".to_string()),
            InlineSpan::Emphasis("e".to_string()),
            InlineSpan::Strikethrough("x".to_string()),
            InlineSpan::Link {
                text: "link".to_string(),
                url: "https://example.com".to_string(),
            },
            InlineSpan::Image {
                src: "img.png".to_string(),
                alt: "alt".to_string(),
                title: Some("title".to_string()),
            },
        ];
        let hash = MarkdownRenderer::hash_inline_spans(&spans);
        let hash2 = MarkdownRenderer::hash_inline_spans(&[InlineSpan::Text("other".to_string())]);
        assert_ne!(hash, hash2);
    }

    #[test]
    fn test_highlight_segments_edge_cases() {
        let renderer = MarkdownRenderer::new();
        assert!(renderer.highlight_segments("", Some("a")).is_empty());
        assert_eq!(
            renderer.highlight_segments("abc", None),
            vec![(0..3, false)]
        );
        assert_eq!(
            renderer.highlight_segments("abc", Some("")),
            vec![(0..3, false)]
        );
        let segments = renderer.highlight_segments("Hello", Some("ell"));
        assert!(segments.iter().any(|(_, highlighted)| *highlighted));
    }

    #[test]
    fn test_resolve_table_widths_branches() {
        assert!(MarkdownRenderer::resolve_table_widths(50.0, &[], &[]).is_empty());
        assert_eq!(
            MarkdownRenderer::resolve_table_widths(100.0, &[10.0, 10.0], &[20.0, 30.0]),
            vec![20.0, 30.0]
        );

        assert_eq!(
            MarkdownRenderer::resolve_table_widths(10.0, &[0.0, 0.0], &[0.0, 0.0]),
            vec![5.0, 5.0]
        );

        assert_eq!(
            MarkdownRenderer::resolve_table_widths(10.0, &[10.0, 10.0], &[20.0, 20.0]),
            vec![5.0, 5.0]
        );

        assert_eq!(
            MarkdownRenderer::resolve_table_widths(30.0, &[10.0, 10.0], &[10.0, 10.0]),
            vec![15.0, 15.0]
        );

        let widths = MarkdownRenderer::resolve_table_widths(30.0, &[10.0, 10.0], &[20.0, 30.0]);
        assert_eq!(widths.len(), 2);
        assert!((widths[0] + widths[1] - 30.0).abs() < 0.1);
    }

    #[test]
    fn test_table_line_breaks_case_parses_all_rows() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let md = fs::read_to_string("tests/regression/cases/017-table-line-breaks.md")?;
        let elements = renderer.parse(&md)?;
        let rows = elements.iter().find_map(|el| match el {
            MarkdownElement::Table { rows, .. } => Some(rows),
            _ => None,
        });
        let rows = rows.expect("table present");
        assert_eq!(rows.len(), 7);
        let plain = MarkdownRenderer::elements_to_plain_text(&elements);
        assert!(plain.contains("Strong"));
        assert!(plain.contains("Attr"));
        Ok(())
    }

    #[test]
    fn test_table_line_breaks_case_renders_all_rows() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let md = fs::read_to_string("tests/regression/cases/017-table-line-breaks.md")?;
        let elements = renderer.parse(&md)?;
        with_test_ui(|ctx, ui| {
            ctx.set_visuals(egui::Visuals::light());
            renderer.render_to_ui(ui, &elements);
        });
        let (rendered, total) = renderer.table_render_stats();
        assert_eq!(rendered, total);
        assert_eq!(rendered, 7);
        Ok(())
    }

    #[test]
    fn test_table_first_column_alignment_case_parses_columns() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let md = fs::read_to_string("tests/regression/cases/026-table-first-column-align.md")?;
        let elements = renderer.parse(&md)?;
        let mut tables = elements.iter().filter_map(|el| match el {
            MarkdownElement::Table {
                headers,
                rows,
                alignments,
            } => Some((headers, rows, alignments)),
            _ => None,
        });
        let (headers, rows, alignments) = tables.next().expect("expected table");
        assert_eq!(headers.len(), 3);
        assert_eq!(alignments.len(), 3);
        assert!(rows.iter().all(|row| row.len() == 3));
        Ok(())
    }

    #[test]
    fn test_handle_width_change_requests_repaint() {
        let renderer = MarkdownRenderer::new();
        let ctx = egui::Context::default();
        renderer.handle_width_change(&ctx, 42, WidthChange::Large);
        let metrics = renderer.table_metrics.borrow();
        let entry = metrics.entry(42).expect("metrics entry");
        assert!(entry.last_discard_frame.is_some());
    }

    #[test]
    fn test_handle_width_change_skips_duplicate_frame() {
        let renderer = MarkdownRenderer::new();
        let ctx = egui::Context::default();
        renderer.handle_width_change(&ctx, 42, WidthChange::Large);
        renderer.handle_width_change(&ctx, 42, WidthChange::Large);
        let metrics = renderer.table_metrics.borrow();
        let entry = metrics.entry(42).expect("metrics entry");
        assert_eq!(entry.last_discard_frame, Some(ctx.frame_nr()));
    }

    #[test]
    fn test_render_list_multiline_indent_and_empty() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Text("First\n  Nested".to_string())];
        let item = ListItem {
            blocks: vec![MarkdownElement::Paragraph(spans.clone())],
        };
        with_test_ui(|ctx, ui| {
            ctx.set_visuals(egui::Visuals::light());
            renderer.render_list(ui, false, &[]);
            renderer.render_list(ui, true, std::slice::from_ref(&item));
        });
    }

    #[test]
    fn test_render_list_paragraph_handles_blank_parts_and_indent() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![
            InlineSpan::Text("Line 1\n\n  indented".to_string()),
            InlineSpan::Image {
                src: "assets/emoji/1f600.png".to_string(),
                alt: "img".to_string(),
                title: None,
            },
        ];
        with_test_ui(|_, ui| {
            renderer.render_list_paragraph(ui, None, Color32::WHITE, 12.0, &spans);
        });
    }

    #[test]
    fn test_render_list_paragraph_multiline_without_leading_spaces() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Text("Line 1\nLine 2".to_string())];
        with_test_ui(|_, ui| {
            renderer.render_list_paragraph(ui, None, Color32::WHITE, 12.0, &spans);
        });
    }

    #[test]
    fn test_render_inline_span_image_hover_caption_uses_cached_texture() {
        let renderer = MarkdownRenderer::new();
        let span = InlineSpan::Image {
            src: "assets/emoji/1f600.png".to_string(),
            alt: "alt".to_string(),
            title: Some("Caption".to_string()),
        };
        let _guard = ForcedRenderActions::new(&["image_hover"]);
        with_test_ui(|_, ui| {
            let image = egui::ColorImage::new([2, 2], Color32::WHITE);
            let texture = ui.ctx().load_texture(
                "test-inline-image-hover",
                image,
                egui::TextureOptions::LINEAR,
            );
            renderer.store_image_texture("assets/emoji/1f600.png", texture, [2, 2], None);
            renderer.render_inline_span(ui, &span, None, None);
        });
    }

    #[test]
    fn test_render_inline_span_forced_actions_and_image_title() {
        let renderer = MarkdownRenderer::new();
        renderer.set_highlight_phrase(Some("hi"));
        let image_span = InlineSpan::Image {
            src: "assets/emoji/1f600.png".to_string(),
            alt: "alt".to_string(),
            title: Some("Caption".to_string()),
        };
        let missing_span = InlineSpan::Image {
            src: "missing.png".to_string(),
            alt: "missing".to_string(),
            title: None,
        };
        let link_span = InlineSpan::Link {
            text: "hi link".to_string(),
            url: "https://example.com".to_string(),
        };
        let _guard = ForcedRenderActions::new(&["link_hover", "link_click", "image_hover"]);
        with_test_ui(|_, ui| {
            renderer.render_inline_span(
                ui,
                &InlineSpan::Text("hi \u{1f600}".to_string()),
                None,
                None,
            );
            renderer.render_inline_span(ui, &InlineSpan::Strong("hi".to_string()), None, None);
            renderer.render_inline_span(ui, &InlineSpan::Emphasis("hi".to_string()), None, None);
            renderer.render_inline_span(
                ui,
                &InlineSpan::Strikethrough("hi".to_string()),
                None,
                None,
            );
            renderer.render_inline_span(ui, &InlineSpan::Code("code".to_string()), None, None);
            renderer.render_inline_span(ui, &link_span, None, None);
            renderer.render_inline_span(ui, &image_span, None, None);
            renderer.render_inline_span(ui, &missing_span, None, None);
        });
    }

    #[test]
    fn test_get_or_load_image_texture_embedded_and_remote() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|ctx, ui| {
            let embedded = wait_for_image(&renderer, ctx, ui, "assets/emoji/1f600.png");
            assert!(embedded.is_some());
            let remote = renderer.get_or_load_image_texture(ui, "https://example.com/img.png");
            assert!(remote.is_none());
        });
    }

    #[test]
    fn test_get_or_load_image_texture_embedded_cache_hit() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|ctx, ui| {
            let tex = ctx.load_texture(
                "embedded-cache",
                egui::ColorImage::new([2, 2], Color32::WHITE),
                Default::default(),
            );
            renderer.store_image_texture("assets/emoji/1f600.png", tex, [2, 2], None);
            let loaded = renderer.get_or_load_image_texture(ui, "assets/emoji/1f600.png");
            assert!(loaded.is_some());
        });
    }

    #[test]
    fn test_get_or_load_image_texture_skips_recent_failure() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            renderer.note_image_failure("missing.png");
            let loaded = renderer.get_or_load_image_texture(ui, "missing.png");
            assert!(loaded.is_none());
            assert!(renderer.image_failures.borrow().contains_key("missing.png"));
        });
    }

    #[test]
    fn test_get_or_load_image_texture_skips_pending() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            renderer
                .image_pending
                .borrow_mut()
                .insert("pending.png".to_string());
            let loaded = renderer.get_or_load_image_texture(ui, "pending.png");
            assert!(loaded.is_none());
        });
    }

    #[test]
    fn test_render_inline_span_loaded_image_without_title() {
        let renderer = MarkdownRenderer::new();
        let span = InlineSpan::Image {
            src: "assets/emoji/1f600.png".to_string(),
            alt: "".to_string(),
            title: None,
        };
        with_test_ui(|ctx, ui| {
            let _ = wait_for_image(&renderer, ctx, ui, "assets/emoji/1f600.png");
            renderer.render_inline_span(ui, &span, None, None);
        });
    }

    #[test]
    fn test_get_or_make_emoji_texture_cache() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            let tex = renderer.get_or_make_emoji_texture(ui, "\u{1f600}");
            assert!(tex.size()[0] > 0);
            let cached = renderer.get_or_make_emoji_texture(ui, "\u{1f600}");
            assert_eq!(cached.size(), tex.size());
        });
    }

    #[test]
    fn test_get_or_make_emoji_texture_unknown_fallbacks() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            let tex = renderer.get_or_make_emoji_texture(ui, "not-emoji");
            assert!(tex.size()[0] > 0);
        });
    }

    #[test]
    fn test_render_overhauled_cell_fragments() {
        let renderer = MarkdownRenderer::new();
        let emoji_span = InlineSpan::Text("\u{1f600}".to_string());
        let image_span = InlineSpan::Image {
            src: "assets/emoji/1f600.png".to_string(),
            alt: "alt".to_string(),
            title: None,
        };
        with_test_ui(|_, ui| {
            renderer.render_overhauled_cell(ui, &[], 120.0, false, Some(0), 0, Align::LEFT);
            renderer.render_overhauled_cell(
                ui,
                &[emoji_span.clone(), image_span.clone()],
                120.0,
                false,
                Some(1),
                1,
                Align::LEFT,
            );
        });
    }

    #[test]
    fn test_paint_table_text_job_link_interaction() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Link {
            text: "Click here for more text".to_string(),
            url: "https://example.com".to_string(),
        }];
        let ctx = egui::Context::default();
        let click_pos = egui::pos2(5.0, 5.0);

        let input = input_with_click(click_pos, egui::PointerButton::Secondary);
        run_frame_with_input(&ctx, input, |_, ui| {
            ui.allocate_ui_at_rect(
                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
                |ui| {
                    let build =
                        renderer.build_layout_job(ui.style(), &spans, 30.0, false, Align::LEFT);
                    renderer.paint_table_text_job(ui, 120.0, build);
                },
            );
        });

        let input = input_with_click(click_pos, egui::PointerButton::Primary);
        run_frame_with_input(&ctx, input, |_, ui| {
            ui.allocate_ui_at_rect(
                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
                |ui| {
                    let build =
                        renderer.build_layout_job(ui.style(), &spans, 30.0, false, Align::LEFT);
                    renderer.paint_table_text_job(ui, 120.0, build);
                },
            );
        });
    }

    #[test]
    fn test_aligned_text_origin_anchors_to_rect() {
        let rect = egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(100.0, 20.0));
        let galley = Arc::new(Galley {
            job: Arc::new(LayoutJob::default()),
            rows: Vec::new(),
            elided: false,
            rect: egui::Rect::from_min_max(egui::pos2(0.0, 0.0), egui::pos2(20.0, 10.0)),
            mesh_bounds: egui::Rect::NOTHING,
            num_vertices: 0,
            num_indices: 0,
            pixels_per_point: 1.0,
        });
        let left_origin = MarkdownRenderer::aligned_text_origin(rect, &galley, Align::LEFT);
        let center_origin = MarkdownRenderer::aligned_text_origin(rect, &galley, Align::Center);
        let right_origin = MarkdownRenderer::aligned_text_origin(rect, &galley, Align::RIGHT);

        assert_eq!(left_origin.x, rect.left());
        assert_eq!(center_origin.x, rect.center().x - galley.rect.center().x);
        assert_eq!(right_origin.x, rect.right() - galley.rect.right());
        assert_eq!(left_origin.y, rect.top());
    }

    #[test]
    fn test_layout_job_center_rect_is_origin() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Text("Item".to_string())];
        with_test_ui(|_, ui| {
            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, true, Align::Center);
            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
            assert!(galley.rect.center().x.abs() <= 0.01);
        });
    }

    #[test]
    fn test_render_table_tablebuilder_variants() {
        let renderer = MarkdownRenderer::new();
        let headers = vec![vec![InlineSpan::Text("H1".to_string())]];
        let rows = vec![vec![
            vec![InlineSpan::Text("A".to_string())],
            vec![InlineSpan::Text("B".to_string())],
        ]];
        with_test_ui(|_, ui| {
            let table_id = renderer.compute_table_id(&headers, &rows, &[], 0);
            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
            let empty_id = renderer.compute_table_id(&headers, &[], &[], 1);
            renderer.render_table_tablebuilder(ui, &headers, &[], &[], empty_id);
        });
    }

    #[test]
    fn test_render_code_block_context_menu_clicks() {
        let renderer = MarkdownRenderer::new();
        let ctx = egui::Context::default();
        let input = input_with_click(egui::pos2(5.0, 5.0), egui::PointerButton::Primary);
        run_frame_with_input(&ctx, input, |_, ui| {
            ui.allocate_ui_at_rect(
                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
                |ui| {
                    renderer.render_code_block_context_menu(ui, "code", Some("rust"));
                },
            );
        });

        let input = input_with_click(egui::pos2(5.0, 30.0), egui::PointerButton::Primary);
        run_frame_with_input(&ctx, input, |_, ui| {
            ui.allocate_ui_at_rect(
                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
                |ui| {
                    renderer.render_code_block_context_menu(ui, "code", Some("rust"));
                },
            );
        });
    }

    #[test]
    fn test_find_syntax_for_language() {
        let renderer = MarkdownRenderer::new();
        assert!(renderer.find_syntax_for_language("rust").is_some());
        assert!(renderer.find_syntax_for_language("nonexistent").is_none());
    }

    #[test]
    fn test_find_syntax_for_language_direct_name_match() -> Result<()> {
        let mut renderer = MarkdownRenderer::new();
        let syntax = SyntaxDefinition::load_from_str(
            r#"
name: testlang
scope: source.testlang
file_extensions: [tst]
contexts:
  main:
    - match: '.'
      scope: source.testlang
"#,
            true,
            None,
        )
        .expect("syntax");
        let mut builder = renderer.syntax_set.clone().into_builder();
        builder.add(syntax);
        renderer.syntax_set = builder.build();
        assert!(renderer.find_syntax_for_language("testlang").is_some());
        Ok(())
    }

    #[test]
    fn test_find_syntax_for_language_mappings() {
        let renderer = MarkdownRenderer::new();
        assert!(renderer.find_syntax_for_language("markdown").is_some());
        assert!(renderer.find_syntax_for_language("shell").is_some());
        assert!(renderer.find_syntax_for_language("yaml").is_some());
    }

    #[test]
    fn test_find_syntax_for_language_mapped_names() {
        let renderer = MarkdownRenderer::new();
        let langs = [
            "python",
            "javascript",
            "typescript",
            "c++",
            "cpp",
            "c#",
            "shell",
            "bash",
            "powershell",
            "yaml",
            "markdown",
            "sql",
            "toml",
        ];
        for lang in langs {
            let _ = renderer.find_syntax_for_language(lang);
        }
    }

    #[test]
    fn test_find_syntax_for_language_aliases_with_empty_syntax_set() {
        let mut renderer = MarkdownRenderer::new();
        renderer.syntax_set = SyntaxSet::new();
        let langs = [
            "rust",
            "python",
            "javascript",
            "typescript",
            "c++",
            "cpp",
            "c#",
            "csharp",
            "shell",
            "bash",
            "powershell",
            "yaml",
            "markdown",
            "html",
            "css",
            "java",
            "go",
            "php",
            "ruby",
            "xml",
            "json",
            "sql",
            "toml",
            "unknownlang",
        ];
        for lang in langs {
            assert!(renderer.find_syntax_for_language(lang).is_none());
        }
    }

    #[test]
    fn test_estimate_table_image_height_with_title() {
        let renderer = MarkdownRenderer::new();
        let span = InlineSpan::Image {
            src: "assets/samples/logo.svg".to_string(),
            alt: "logo".to_string(),
            title: Some("Caption".to_string()),
        };
        with_test_ui(|_, ui| {
            let height = renderer.estimate_table_image_height(ui, &span, 120.0);
            assert!(height > 0.0);
            let fallback = renderer.estimate_table_image_height(
                ui,
                &InlineSpan::Text("text".to_string()),
                120.0,
            );
            assert!(fallback > 0.0);
        });
    }

    #[test]
    fn test_render_table_emoji() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            renderer.render_table_emoji(ui, "\u{1f600}");
        });
    }

    #[test]
    fn test_render_list_block_non_paragraph() {
        let renderer = MarkdownRenderer::new();
        let block = MarkdownElement::CodeBlock {
            language: Some("rust".to_string()),
            text: "fn main() {}".to_string(),
        };
        with_test_ui(|_, ui| {
            renderer.render_list_block(ui, &block, 12.0, Color32::WHITE);
        });
    }

    #[test]
    fn test_measure_inline_spans_with_image() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Image {
            src: "assets/samples/logo.svg".to_string(),
            alt: "logo".to_string(),
            title: None,
        }];
        with_test_ui(|_, ui| {
            let width = renderer.measure_inline_spans(ui, &spans);
            assert!(width > 0.0);
        });
    }

    #[test]
    fn test_parse_blockquote_with_nested_blocks() {
        let renderer = MarkdownRenderer::new();
        let md = r#"> # Quote Heading
> Paragraph **bold** *em* ~~strike~~ [link](https://example.com)
> ![alt](assets/samples/logo.svg "Logo")
> - Item one
>   - Nested item
> 
> ```rust
> let x = 1;
> ```
> 
> | H1 | H2 |
> | --- | --- |
> |  | ![a](assets/samples/logo.svg "Img") |
"#;
        let elements = renderer.parse(md).expect("parse");
        assert!(elements
            .iter()
            .any(|e| matches!(e, MarkdownElement::Quote { .. })));
    }

    #[test]
    fn test_parse_list_with_heading_and_table() {
        let renderer = MarkdownRenderer::new();
        let md = r#"- # Item heading
  Paragraph text with `code` and **strong**
  - Nested child
- | A | B |
  | - | - |
  | 1 | 2 |
- ```rust
  fn main() {}
  ```
- > Quote in list
- ---
"#;
        let elements = renderer.parse(md).expect("parse");
        assert!(elements
            .iter()
            .any(|e| matches!(e, MarkdownElement::List { .. })));
    }

    #[test]
    fn test_parse_list_inline_variants() {
        let renderer = MarkdownRenderer::new();
        let md = r#"- Item with *em* **strong** ~~strike~~ `code` [link](https://example.com) ![alt](assets/emoji/1f600.png "title")  
  next line"#;
        let elements = renderer.parse(md).expect("parse");
        assert!(elements
            .iter()
            .any(|e| matches!(e, MarkdownElement::List { .. })));
    }

    #[test]
    fn test_parse_blockquote_with_varied_content() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let md = r#"
> ### Quote Heading
> Paragraph with *em* **strong** ~~strike~~ `code` [link](https://example.com) ![alt](assets/emoji/1f600.png "title")  
> Next line<br>
>
> - item one
> - item two
>
> | h1 | h2 |
> | --- | --- |
> | a | b |
>
> ```rust
> fn main() {
>     // comment
> }
> ```
>
> > Nested quote
>
> ---
"#;
        let elements = renderer.parse(md)?;
        assert!(elements
            .iter()
            .any(|e| matches!(e, MarkdownElement::Quote { .. })));
        Ok(())
    }

    #[test]
    fn test_find_syntax_for_language_variants() {
        let renderer = MarkdownRenderer::new();
        assert!(renderer.find_syntax_for_language("rs").is_some());
        let cs_ext = renderer.syntax_set.find_syntax_by_extension("cs");
        let cs_lang = renderer.find_syntax_for_language("csharp");
        assert_eq!(cs_lang.is_some(), cs_ext.is_some());
        let ps_ext = renderer.syntax_set.find_syntax_by_extension("ps1");
        let ps_lang = renderer.find_syntax_for_language("powershell");
        assert_eq!(ps_lang.is_some(), ps_ext.is_some());
        assert!(renderer.find_syntax_for_language("madeuplang").is_none());
    }

    #[test]
    fn test_generate_emoji_image_variants() {
        let renderer = MarkdownRenderer::new();
        let emojis = [
            "\u{1f389}",
            "\u{2705}",
            "\u{1f680}",
            "\u{1f642}",
            "\u{1f600}",
            "\u{1f609}",
            "\u{2b50}",
            "\u{1f525}",
            "\u{1f44d}",
            "\u{1f44e}",
            "\u{1f4a1}",
            "\u{2753}",
            "\u{2757}",
            "\u{1f4dd}",
            "\u{1f9e0}",
            "\u{1f9ea}",
            "\u{1f4e6}",
            "\u{1f527}",
            "x",
        ];
        for emoji in emojis {
            let image = renderer.generate_emoji_image(emoji, 8);
            assert_eq!(image.size, [8, 8]);
        }
    }

    #[test]
    fn test_measure_inline_spans_code_and_image() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|ctx, ui| {
            let tex = ctx.load_texture(
                "test-image",
                egui::ColorImage::new([2, 2], Color32::WHITE),
                egui::TextureOptions::LINEAR,
            );
            renderer.image_textures.borrow_mut().insert(
                "image.png".to_string(),
                ImageCacheEntry {
                    texture: tex,
                    size: [64, 32],
                    modified: None,
                },
            );
            let spans = vec![
                InlineSpan::Text("Hello".to_string()),
                InlineSpan::Code("line1\nline2".to_string()),
                InlineSpan::Image {
                    src: "image.png".to_string(),
                    alt: "Alt".to_string(),
                    title: None,
                },
            ];
            let width = renderer.measure_inline_spans(ui, &spans);
            assert!(width > 0.0);
        });
    }

    #[test]
    fn test_get_or_load_image_texture_cache_and_remote() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            assert!(renderer
                .get_or_load_image_texture(ui, "https://example.com/logo.png")
                .is_none());
        });

        let temp = tempdir()?;
        let image_path = temp.path().join("image.png");
        std::fs::write(&image_path, tiny_png_bytes())?;
        let resolved = image_path.to_string_lossy().to_string();
        with_test_ui(|ctx, ui| {
            let first = wait_for_image(&renderer, ctx, ui, &resolved);
            assert!(first.is_some());
            let second = renderer.get_or_load_image_texture(ui, &resolved);
            assert!(second.is_some());
        });
        Ok(())
    }

    #[test]
    fn test_get_or_load_image_texture_stale_cache_evicted() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let temp = tempdir()?;
        let image_path = temp.path().join("image.png");
        std::fs::write(&image_path, tiny_png_bytes())?;
        let resolved = image_path.to_string_lossy().to_string();

        with_test_ui(|ctx, ui| {
            let tex = ctx.load_texture(
                "stale-image",
                egui::ColorImage::new([2, 2], Color32::WHITE),
                egui::TextureOptions::LINEAR,
            );
            renderer.image_textures.borrow_mut().insert(
                resolved.clone(),
                ImageCacheEntry {
                    texture: tex,
                    size: [2, 2],
                    modified: Some(SystemTime::UNIX_EPOCH),
                },
            );

            let result = renderer.get_or_load_image_texture(ui, &resolved);
            assert!(result.is_none());
            assert!(!renderer.image_textures.borrow().contains_key(&resolved));
            assert!(renderer.image_pending.borrow().contains(&resolved));
        });

        Ok(())
    }

    #[test]
    fn test_get_or_load_image_texture_enqueue_failure() -> Result<()> {
        let mut renderer = MarkdownRenderer::new();
        let (image_job_tx, image_job_rx) = bounded(0);
        drop(image_job_rx);
        renderer.image_job_tx = image_job_tx;

        let temp = tempdir()?;
        let image_path = temp.path().join("image.png");
        std::fs::write(&image_path, tiny_png_bytes())?;
        let resolved = image_path.to_string_lossy().to_string();

        with_test_ui(|_, ui| {
            let result = renderer.get_or_load_image_texture(ui, &resolved);
            assert!(result.is_none());
            assert!(!renderer.image_pending.borrow().contains(&resolved));
        });

        Ok(())
    }

    #[test]
    fn test_poll_image_results_records_failure() {
        let mut renderer = MarkdownRenderer::new();
        let (result_tx, result_rx) = crossbeam_channel::unbounded::<ImageLoadResult>();
        renderer.image_result_rx = result_rx;
        renderer
            .image_pending
            .borrow_mut()
            .insert("failed.png".to_string());

        result_tx
            .send(ImageLoadResult::Failed {
                key: "failed.png".to_string(),
            })
            .expect("send");
        let ctx = egui::Context::default();
        renderer.poll_image_results(&ctx);
        assert!(renderer.image_failures.borrow().contains_key("failed.png"));
        assert!(!renderer.image_pending.borrow().contains("failed.png"));
    }

    #[test]
    fn test_enqueue_image_job_full_returns_err() {
        let mut renderer = MarkdownRenderer::new();
        let (job_tx, job_rx) = bounded(1);
        renderer.image_job_tx = job_tx;
        let request = ImageLoadRequest {
            key: "full".to_string(),
            source: ImageLoadSource::Embedded(b"png"),
        };
        renderer.image_job_tx.send(request).expect("fill queue");
        let request = ImageLoadRequest {
            key: "full-2".to_string(),
            source: ImageLoadSource::Embedded(b"png"),
        };
        assert!(renderer.enqueue_image_job(request).is_err());
        drop(job_rx);
    }

    #[test]
    fn test_wait_for_image_with_limit_returns_none() {
        let renderer = MarkdownRenderer::new();
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(320.0, 240.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, input, |_, ui| {
            let missing = wait_for_image_with_limit(&renderer, &ctx, ui, "missing", 0);
            assert!(missing.is_none());
        });
    }

    #[test]
    fn test_render_table_tablebuilder_policy_mix() {
        let renderer = MarkdownRenderer::new();
        let headers = vec![
            vec![InlineSpan::Text("Version".to_string())],
            vec![InlineSpan::Text("Author".to_string())],
            vec![InlineSpan::Text("Notes".to_string())],
            vec![InlineSpan::Text("Example".to_string())],
            vec![InlineSpan::Text("Misc".to_string())],
        ];
        let rows = vec![vec![
            vec![InlineSpan::Text("1".to_string())],
            vec![InlineSpan::Text("Ada".to_string())],
            vec![InlineSpan::Text("Line 1\nLine 2".to_string())],
            vec![InlineSpan::Image {
                src: "image.png".to_string(),
                alt: "Alt".to_string(),
                title: Some("Title".to_string()),
            }],
            vec![InlineSpan::Link {
                text: "Link".to_string(),
                url: "https://example.com".to_string(),
            }],
        ]];

        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(1200.0, 720.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, input, |ctx, ui| {
            let tex = ctx.load_texture(
                "table-image",
                egui::ColorImage::new([2, 2], Color32::WHITE),
                egui::TextureOptions::LINEAR,
            );
            renderer.image_textures.borrow_mut().insert(
                "image.png".to_string(),
                ImageCacheEntry {
                    texture: tex,
                    size: [120, 80],
                    modified: None,
                },
            );
            let table_id = renderer.compute_table_id(&headers, &rows, &[], 12);
            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
        });
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(1200.0, 720.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, input, |_, ui| {
            let table_id = renderer.compute_table_id(&headers, &rows, &[], 12);
            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
        });
    }

    #[test]
    fn test_render_table_tablebuilder_extra_columns() {
        let renderer = MarkdownRenderer::new();
        let headers = vec![vec![InlineSpan::Text("H1".to_string())]];
        let rows = vec![vec![
            vec![InlineSpan::Text("C1".to_string())],
            vec![InlineSpan::Text("C2".to_string())],
            vec![InlineSpan::Text("C3".to_string())],
        ]];
        with_test_ui(|_, ui| {
            let table_id = renderer.compute_table_id(&headers, &rows, &[], 13);
            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
        });
    }

    #[test]
    fn test_render_table_tablebuilder_forced_policies() {
        let renderer = MarkdownRenderer::new();
        let _forced = ForcedTablePolicies::new(vec![
            ColumnPolicy::Auto,
            ColumnPolicy::Fixed {
                width: 120.0,
                clip: true,
            },
            ColumnPolicy::Resizable {
                min: 60.0,
                preferred: 120.0,
                clip: true,
            },
            ColumnPolicy::Remainder { clip: true },
        ]);
        let headers = vec![
            vec![InlineSpan::Text("A".to_string())],
            vec![InlineSpan::Text("B".to_string())],
            vec![InlineSpan::Text("C".to_string())],
            vec![InlineSpan::Text("D".to_string())],
        ];
        let rows = vec![vec![
            vec![InlineSpan::Text("1".to_string())],
            vec![InlineSpan::Text("2".to_string())],
            vec![InlineSpan::Text("3".to_string())],
            vec![InlineSpan::Text("4".to_string())],
        ]];
        with_test_ui(|_, ui| {
            let table_id = renderer.compute_table_id(&headers, &rows, &[], 14);
            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
        });
    }

    #[test]
    fn test_render_table_tablebuilder_fixed_columns_no_clip() {
        let renderer = MarkdownRenderer::new();
        let _forced = ForcedTablePolicies::new(vec![
            ColumnPolicy::Fixed {
                width: 80.0,
                clip: false,
            },
            ColumnPolicy::Fixed {
                width: 100.0,
                clip: false,
            },
        ]);
        let headers = vec![
            vec![InlineSpan::Text("Left".to_string())],
            vec![InlineSpan::Text("Right".to_string())],
        ];
        let rows = vec![vec![
            vec![InlineSpan::Text("A".to_string())],
            vec![InlineSpan::Text("B".to_string())],
        ]];
        with_test_ui(|_, ui| {
            let layout = *ui.layout();
            ui.allocate_ui_with_layout(Vec2::new(400.0, 0.0), layout, |ui| {
                ui.spacing_mut().item_spacing.x = 6.0;
                ui.set_width(400.0);
                let table_id = renderer.compute_table_id(&headers, &rows, &[], 16);
                renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
            });
        });
    }

    #[test]
    fn test_render_table_tablebuilder_scaled_down_min_flex_forced() {
        let renderer = MarkdownRenderer::new();
        let _forced = ForcedTablePolicies::new(vec![
            ColumnPolicy::Resizable {
                min: 50.0,
                preferred: 120.0,
                clip: false,
            },
            ColumnPolicy::Resizable {
                min: 50.0,
                preferred: 120.0,
                clip: false,
            },
        ]);
        let headers = vec![
            vec![InlineSpan::Text("A".to_string())],
            vec![InlineSpan::Text("B".to_string())],
        ];
        let rows = vec![vec![
            vec![InlineSpan::Text("One".to_string())],
            vec![InlineSpan::Text("Two".to_string())],
        ]];
        with_test_ui(|_, ui| {
            let layout = *ui.layout();
            ui.allocate_ui_with_layout(Vec2::new(106.0, 0.0), layout, |ui| {
                ui.spacing_mut().item_spacing.x = 6.0;
                ui.set_width(106.0);
                let table_id = renderer.compute_table_id(&headers, &rows, &[], 17);
                renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
            });
        });
    }

    #[test]
    fn test_render_table_tablebuilder_scaled_down_min_flex() {
        let renderer = MarkdownRenderer::new();
        let headers = vec![
            vec![InlineSpan::Text("Notes".to_string())],
            vec![InlineSpan::Text("Summary".to_string())],
            vec![InlineSpan::Text("Details".to_string())],
        ];
        let rows = vec![vec![
            vec![InlineSpan::Text("Long text 1".to_string())],
            vec![InlineSpan::Text("Long text 2".to_string())],
            vec![InlineSpan::Text("Long text 3".to_string())],
        ]];
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(120.0, 120.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, input, |_, ui| {
            let table_id = renderer.compute_table_id(&headers, &rows, &[], 15);
            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
        });
    }

    #[test]
    fn test_render_list_variants() {
        let renderer = MarkdownRenderer::new();
        let items = vec![
            ListItem {
                blocks: vec![
                    MarkdownElement::Paragraph(vec![InlineSpan::Text("Paragraph".to_string())]),
                    MarkdownElement::Header {
                        level: 2,
                        spans: vec![InlineSpan::Text("Header".to_string())],
                        id: "header".to_string(),
                    },
                ],
            },
            ListItem {
                blocks: vec![
                    MarkdownElement::CodeBlock {
                        language: None,
                        text: "code".to_string(),
                    },
                    MarkdownElement::Paragraph(vec![InlineSpan::Text("After".to_string())]),
                ],
            },
            ListItem { blocks: vec![] },
        ];
        with_test_ui(|_, ui| {
            renderer.render_list(ui, false, &items);
            renderer.render_list(ui, true, &items);
            renderer.render_list(ui, false, &[]);
        });
    }

    #[test]
    fn test_render_element_body_header_levels() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            for level in 3..=7 {
                let element = MarkdownElement::Header {
                    level,
                    spans: vec![InlineSpan::Text(format!("H{}", level))],
                    id: format!("h{}", level),
                };
                renderer.render_element_body(ui, &element);
            }
        });
    }

    #[test]
    fn test_render_table_tablebuilder_hscroll() {
        let renderer = MarkdownRenderer::new();
        let headers: Vec<Vec<InlineSpan>> = (0..8)
            .map(|i| vec![InlineSpan::Text(format!("H{}", i + 1))])
            .collect();
        let row: Vec<Vec<InlineSpan>> = (0..8)
            .map(|i| vec![InlineSpan::Text(format!("col{}", i + 1))])
            .collect();
        let rows = vec![row];
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(200.0, 120.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, input, |_, ui| {
            let table_id = renderer.compute_table_id(&headers, &rows, &[], 10);
            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
        });
    }

    #[test]
    fn test_render_table_tablebuilder_tiny_width_hscroll() {
        let renderer = MarkdownRenderer::new();
        let headers = vec![
            vec![InlineSpan::Text("A".to_string())],
            vec![InlineSpan::Text("B".to_string())],
        ];
        let rows = vec![vec![
            vec![InlineSpan::Text("1".to_string())],
            vec![InlineSpan::Text("2".to_string())],
        ]];
        with_test_ui(|_, ui| {
            let layout = *ui.layout();
            ui.allocate_ui_with_layout(Vec2::new(5.0, 0.0), layout, |ui| {
                ui.spacing_mut().item_spacing.x = 6.0;
                ui.set_width(5.0);
                let table_id = renderer.compute_table_id(&headers, &rows, &[], 18);
                renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
            });
        });
    }

    #[test]
    fn test_render_table_tablebuilder_scaled_down() {
        let renderer = MarkdownRenderer::new();
        let headers = vec![
            vec![InlineSpan::Text("Wide Header One".to_string())],
            vec![InlineSpan::Text("Wide Header Two".to_string())],
        ];
        let long_text = "W".repeat(80);
        let rows = vec![vec![
            vec![InlineSpan::Text(long_text.clone())],
            vec![InlineSpan::Text(long_text)],
        ]];
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(180.0, 120.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, input, |_, ui| {
            let table_id = renderer.compute_table_id(&headers, &rows, &[], 11);
            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
        });
    }

    #[test]
    fn test_list_marker_info_any_indent_variants() {
        assert!(MarkdownRenderer::list_marker_info_any_indent("").is_none());
        assert!(MarkdownRenderer::list_marker_info_any_indent("   ").is_none());

        let (rest, indent, content_indent, leading_cols) =
            MarkdownRenderer::list_marker_info_any_indent(" 1. item").expect("marker");
        assert_eq!(rest, "item");
        assert_eq!(indent, 1);
        assert_eq!(content_indent, 4);
        assert_eq!(leading_cols, 1);

        let (rest, indent, content_indent, leading_cols) =
            MarkdownRenderer::list_marker_info_any_indent("2)\titem").expect("marker");
        assert_eq!(rest, "item");
        assert_eq!(indent, 2);
        assert_eq!(content_indent, 4);
        assert_eq!(leading_cols, 0);
    }

    #[test]
    fn test_list_marker_info_any_indent_requires_trailing_space() {
        assert!(MarkdownRenderer::list_marker_info_any_indent("-").is_none());
        assert!(MarkdownRenderer::list_marker_info_any_indent("   -").is_none());
    }

    #[test]
    fn test_list_marker_info_any_indent_rejects_missing_whitespace() {
        assert!(MarkdownRenderer::list_marker_info_any_indent("1.item").is_none());
        assert!(MarkdownRenderer::list_marker_info_any_indent("1)item").is_none());
        assert!(MarkdownRenderer::list_marker_info_any_indent("1item").is_none());
    }

    #[test]
    fn test_collect_until_tag_end_breaks_and_code() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Emphasis),
            Event::Text("alpha".into()),
            Event::Code("beta".into()),
            Event::SoftBreak,
            Event::Html("<br>".into()),
            Event::HardBreak,
            Event::Html("<span>".into()),
            Event::End(Tag::Emphasis),
        ];
        let (text, next) = renderer.collect_until_tag_end(&events, 1, Tag::Emphasis, true);
        assert_eq!(next, events.len());
        assert_eq!(text, "alphabeta\n\n\n");

        let (text, next) = renderer.collect_until_tag_end(&events, 1, Tag::Emphasis, false);
        assert_eq!(next, events.len());
        assert_eq!(text, "alphabeta   ");

        let unclosed = vec![Event::Text("tail".into()), Event::SoftBreak];
        let (text, next) = renderer.collect_until_tag_end(&unclosed, 0, Tag::Emphasis, true);
        assert_eq!(next, unclosed.len());
        assert_eq!(text, "tail\n");
    }

    #[test]
    fn test_parse_inline_spans_with_breaks_link_image_and_unclosed() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Paragraph),
            Event::Start(Tag::Link(
                LinkType::Inline,
                "https://example.com".into(),
                "".into(),
            )),
            Event::Text("link".into()),
            Event::End(Tag::Link(
                LinkType::Inline,
                "https://example.com".into(),
                "".into(),
            )),
            Event::Start(Tag::Image(
                LinkType::Inline,
                "img.png".into(),
                "Title".into(),
            )),
            Event::Text("alt".into()),
            Event::End(Tag::Image(
                LinkType::Inline,
                "img.png".into(),
                "Title".into(),
            )),
            Event::FootnoteReference("note".into()),
            Event::End(Tag::Paragraph),
        ];
        let (spans, next) =
            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true);
        assert_eq!(next, events.len());
        assert!(spans
            .iter()
            .any(|span| matches!(span, InlineSpan::Link { .. })));
        assert!(spans
            .iter()
            .any(|span| matches!(span, InlineSpan::Image { .. })));

        let unclosed = vec![Event::Text("tail".into())];
        let (spans, next) =
            renderer.parse_inline_spans_with_breaks(&unclosed, 0, Tag::Paragraph, true);
        assert_eq!(next, unclosed.len());
        assert_eq!(MarkdownRenderer::spans_plain_text(&spans), "tail");
    }

    #[test]
    fn test_parse_inline_spans_with_breaks_mismatched_end_tag() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Text("hello".into()),
            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H1, None, vec![])),
        ];
        let (spans, next) =
            renderer.parse_inline_spans_with_breaks(&events, 0, Tag::Paragraph, true);
        assert_eq!(next, events.len());
        assert_eq!(MarkdownRenderer::spans_plain_text(&spans), "hello");
    }

    #[test]
    fn test_parse_inline_spans_unclosed_image_only() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
        ];
        let (spans, next) =
            renderer.parse_inline_spans_with_breaks(&events, 0, Tag::Paragraph, true);
        assert_eq!(next, events.len());
        assert!(spans
            .iter()
            .any(|span| matches!(span, InlineSpan::Image { .. })));
    }

    #[test]
    fn test_parse_inline_spans_image_only_skips_text_buffer() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Paragraph),
            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
            Event::End(Tag::Paragraph),
        ];
        let (spans, next) =
            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true);
        assert_eq!(next, events.len());
        assert_eq!(spans.len(), 1);
        assert!(matches!(
            spans[0],
            InlineSpan::Image { ref alt, .. } if alt.is_empty()
        ));
    }

    #[test]
    fn test_parse_list_inline_variants_unclosed() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::List(Some(1))),
            Event::Text("skip".into()),
            Event::Start(Tag::Item),
            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
            Event::Text("Dup".into()),
            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
            Event::Text("Dup".into()),
            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
            Event::Start(Tag::Emphasis),
            Event::Text("em".into()),
            Event::End(Tag::Emphasis),
            Event::Start(Tag::Strong),
            Event::Text("strong".into()),
            Event::End(Tag::Strong),
            Event::Start(Tag::Strikethrough),
            Event::Text("strike".into()),
            Event::End(Tag::Strikethrough),
            Event::Start(Tag::Link(
                LinkType::Inline,
                "https://example.com".into(),
                "".into(),
            )),
            Event::Text("link".into()),
            Event::End(Tag::Link(
                LinkType::Inline,
                "https://example.com".into(),
                "".into(),
            )),
            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
            Event::Text("alt".into()),
            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
            Event::Text("tail".into()),
            Event::SoftBreak,
            Event::FootnoteReference("note".into()),
        ];
        let mut slugs = HashMap::new();
        let (items, next) = renderer.parse_list(&events, 1, &mut slugs);
        assert_eq!(next, events.len());
        assert_eq!(items.len(), 1);
        Ok(())
    }

    #[test]
    fn test_parse_list_empty_paragraph_skips_block() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::List(Some(1))),
            Event::Start(Tag::Item),
            Event::Start(Tag::Paragraph),
            Event::End(Tag::Paragraph),
            Event::End(Tag::Item),
            Event::End(Tag::List(Some(1))),
        ];
        let mut slugs = HashMap::new();
        let (items, next) = renderer.parse_list(&events, 1, &mut slugs);
        assert_eq!(next, events.len());
        assert_eq!(items.len(), 1);
        assert!(items[0].blocks.is_empty());
        Ok(())
    }

    #[test]
    fn test_collect_blockquotes_unclosed_variants() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::BlockQuote),
            Event::Text("plain".into()),
            Event::Code("code".into()),
            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
            Event::Text("Dup".into()),
            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
            Event::Text("Dup".into()),
            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
            Event::Start(Tag::Link(
                LinkType::Inline,
                "https://example.com".into(),
                "".into(),
            )),
            Event::Text("link".into()),
            Event::End(Tag::Link(
                LinkType::Inline,
                "https://example.com".into(),
                "".into(),
            )),
            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
            Event::Text("alt".into()),
            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
            Event::FootnoteReference("note".into()),
        ];
        let mut slugs = HashMap::new();
        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs);
        assert_eq!(next, events.len());
        let mut ids = Vec::new();
        for (_, blocks) in &quotes {
            for block in blocks {
                if let MarkdownElement::Header { id, .. } = block {
                    ids.push(id.clone());
                }
            }
        }
        assert_eq!(ids.len(), 2);
        assert_ne!(ids[0], ids[1]);
        Ok(())
    }

    #[test]
    fn test_render_inline_span_context_menus() {
        let renderer = MarkdownRenderer::new();
        let code_span = InlineSpan::Code("inline".to_string());
        let ctx = egui::Context::default();
        let click = input_with_click(egui::pos2(12.0, 12.0), egui::PointerButton::Secondary);
        run_frame_with_input(&ctx, click, |_, ui| {
            renderer.render_inline_span(ui, &code_span, None, None);
        });
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(320.0, 240.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, input, |_, ui| {
            renderer.render_inline_span(ui, &code_span, None, None);
        });

        let link_span = InlineSpan::Link {
            text: "Link".to_string(),
            url: "https://example.com".to_string(),
        };
        let ctx = egui::Context::default();
        let click = input_with_click(egui::pos2(12.0, 12.0), egui::PointerButton::Secondary);
        run_frame_with_input(&ctx, click, |_, ui| {
            renderer.render_inline_span(ui, &link_span, None, None);
        });
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(320.0, 240.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, input, |_, ui| {
            renderer.render_inline_span(ui, &link_span, None, None);
        });
    }

    #[test]
    fn test_render_inline_span_image_scale_and_title() {
        let renderer = MarkdownRenderer::new();
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(40.0, 240.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, input, |_, ui| {
            let color_image = egui::ColorImage::new([200, 120], Color32::WHITE);
            let tex =
                ui.ctx()
                    .load_texture("img:test.png", color_image, egui::TextureOptions::LINEAR);
            renderer.image_textures.borrow_mut().insert(
                "test.png".to_string(),
                ImageCacheEntry {
                    texture: tex,
                    size: [200, 120],
                    modified: None,
                },
            );
            let span = InlineSpan::Image {
                src: "test.png".to_string(),
                alt: "Alt".to_string(),
                title: Some("Title".to_string()),
            };
            renderer.render_inline_span(ui, &span, None, None);
        });
    }

    #[test]
    fn test_paint_table_text_job_triggers_anchor_on_click() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Link {
            text: "Jump".to_string(),
            url: "#Section-One".to_string(),
        }];
        let ctx = egui::Context::default();
        let click_pos = std::cell::Cell::new(egui::pos2(1.0, 1.0));
        let layout_input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(220.0, 120.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, layout_input, |_, ui| {
            ui.allocate_ui_at_rect(
                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
                |ui| {
                    let build =
                        renderer.build_layout_job(ui.style(), &spans, 60.0, false, Align::LEFT);
                    let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
                    let (rect, _response) = ui.allocate_exact_size(
                        egui::vec2(120.0, galley.size().y),
                        egui::Sense::click(),
                    );
                    let text_origin =
                        MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
                    click_pos.set(text_origin + egui::vec2(2.0, 2.0));
                },
            );
        });

        let input = input_with_click(click_pos.get(), egui::PointerButton::Primary);
        run_frame_with_input(&ctx, input, |_, ui| {
            ui.allocate_ui_at_rect(
                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
                |ui| {
                    let build =
                        renderer.build_layout_job(ui.style(), &spans, 60.0, false, Align::LEFT);
                    renderer.paint_table_text_job(ui, 120.0, build);
                },
            );
        });

        assert_eq!(
            renderer.take_pending_anchor(),
            Some("section-one".to_string())
        );
    }

    #[test]
    fn test_paint_table_text_job_hover_link_does_not_trigger() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Link {
            text: "Jump".to_string(),
            url: "#Section-One".to_string(),
        }];
        let ctx = egui::Context::default();
        let hover_pos = std::cell::Cell::new(egui::pos2(1.0, 1.0));
        let layout_input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(220.0, 120.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, layout_input, |_, ui| {
            ui.allocate_ui_at_rect(
                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
                |ui| {
                    let build =
                        renderer.build_layout_job(ui.style(), &spans, 60.0, false, Align::LEFT);
                    let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
                    let (rect, _response) = ui.allocate_exact_size(
                        egui::vec2(120.0, galley.size().y),
                        egui::Sense::click(),
                    );
                    let text_origin =
                        MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
                    hover_pos.set(text_origin + egui::vec2(2.0, 2.0));
                },
            );
        });

        let mut input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(220.0, 120.0),
            )),
            ..Default::default()
        };
        input
            .events
            .push(egui::Event::PointerMoved(hover_pos.get()));
        run_frame_with_input(&ctx, input, |_, ui| {
            ui.allocate_ui_at_rect(
                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
                |ui| {
                    let build =
                        renderer.build_layout_job(ui.style(), &spans, 60.0, false, Align::LEFT);
                    renderer.paint_table_text_job(ui, 120.0, build);
                },
            );
        });

        assert!(renderer.take_pending_anchor().is_none());
    }

    #[test]
    fn test_render_inline_span_image_empty_title() {
        let renderer = MarkdownRenderer::new();
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(120.0, 120.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, input, |_, ui| {
            let color_image = egui::ColorImage::new([20, 12], Color32::WHITE);
            let tex = ui.ctx().load_texture(
                "img:empty-title.png",
                color_image,
                egui::TextureOptions::LINEAR,
            );
            renderer.image_textures.borrow_mut().insert(
                "empty-title.png".to_string(),
                ImageCacheEntry {
                    texture: tex,
                    size: [20, 12],
                    modified: None,
                },
            );
            let span = InlineSpan::Image {
                src: "empty-title.png".to_string(),
                alt: "Alt".to_string(),
                title: Some(String::new()),
            };
            renderer.render_inline_span(ui, &span, None, None);
        });
    }

    #[test]
    fn test_measure_inline_spans_empty_lines_and_styles() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            let spans = vec![
                InlineSpan::Strong("Bold\n\nLine".to_string()),
                InlineSpan::Emphasis("Em\n".to_string()),
                InlineSpan::Strikethrough("Strike".to_string()),
                InlineSpan::Link {
                    text: "Link\n".to_string(),
                    url: "https://example.com".to_string(),
                },
                InlineSpan::Code("code\n\nmore".to_string()),
            ];
            let width = renderer.measure_inline_spans(ui, &spans);
            assert!(width > 0.0);
        });
    }

    #[test]
    fn test_estimate_table_cell_height_variants() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            let style = ui.style().clone();
            let empty =
                renderer.estimate_table_cell_height(&style, ui, &[], 100.0, Align::LEFT, 18.0);
            assert_eq!(empty, 18.0);

            let emoji_spans = vec![InlineSpan::Text("".to_string())];
            let emoji_height = renderer.estimate_table_cell_height(
                &style,
                ui,
                &emoji_spans,
                100.0,
                Align::LEFT,
                18.0,
            );
            assert!(emoji_height >= 18.0);

            let spans = vec![
                InlineSpan::Text("alpha".to_string()),
                InlineSpan::Image {
                    src: "missing.png".to_string(),
                    alt: "Alt".to_string(),
                    title: None,
                },
            ];
            let height =
                renderer.estimate_table_cell_height(&style, ui, &spans, 40.0, Align::LEFT, 18.0);
            assert!(height >= 18.0);
        });
    }

    #[test]
    fn test_estimate_table_column_widths_scaling() {
        let renderer = MarkdownRenderer::new();
        let empty = renderer.estimate_table_column_widths(&[], 120.0, 6.0);
        assert_eq!(empty, vec![120.0]);

        let specs = vec![
            ColumnSpec::new(
                0,
                "A".to_string(),
                ColumnPolicy::Fixed {
                    width: 100.0,
                    clip: false,
                },
                None,
            ),
            ColumnSpec::new(
                1,
                "B".to_string(),
                ColumnPolicy::Fixed {
                    width: 100.0,
                    clip: false,
                },
                None,
            ),
        ];
        let widths = renderer.estimate_table_column_widths(&specs, 100.0, 10.0);
        assert_eq!(widths.len(), 2);
        let sum: f32 = widths.iter().sum();
        assert!((sum - 90.0).abs() < 0.5);
    }

    #[test]
    fn test_estimate_table_column_widths_no_scale_when_available() {
        let renderer = MarkdownRenderer::new();
        let specs = vec![
            ColumnSpec::new(
                0,
                "A",
                ColumnPolicy::Fixed {
                    width: 80.0,
                    clip: false,
                },
                None,
            ),
            ColumnSpec::new(
                1,
                "B",
                ColumnPolicy::Fixed {
                    width: 60.0,
                    clip: false,
                },
                None,
            ),
        ];
        let widths = renderer.estimate_table_column_widths(&specs, 300.0, 10.0);
        assert_eq!(widths, vec![80.0, 60.0]);
    }

    #[test]
    fn test_escape_table_pipes_in_inline_code_nested_lists() {
        let md_parent = "\
 - Parent
   | Col | Notes |
  | --- | --- |
  | code | `a|b` |
";
        let escaped_parent = MarkdownRenderer::escape_table_pipes_in_inline_code(md_parent);
        assert!(escaped_parent.contains(PIPE_SENTINEL));

        let md_nested = "\
- Parent
    - | Col | Notes |
      | --- | --- |
      | code | `a|b` |
";
        let escaped_nested = MarkdownRenderer::escape_table_pipes_in_inline_code(md_nested);
        assert!(escaped_nested.contains(PIPE_SENTINEL));
    }

    #[test]
    fn test_escape_table_pipes_parent_indent_list_marker_header() {
        let md = "\
- Parent
    - | H | I |
      | --- | --- |
      | 1 | 2 |";
        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert_eq!(escaped, md);
    }

    #[test]
    fn test_escape_table_pipes_parent_indent_list_marker_any_indent() {
        let md = "\
- Parent
    - | H | I |
      | --- | --- |
      | `a|b` | c |
";
        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(escaped.contains(PIPE_SENTINEL));
    }

    #[test]
    fn test_escape_table_pipes_parent_indent_marker_within_range() {
        let md = "\
- Parent
    - | H | I |
      | --- | --- |
      | `a|b` | c |
";
        let lines: Vec<&str> = md.split_inclusive('\n').collect();
        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
        let _parent_indent =
            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
        let _leading_spaces =
            MarkdownRenderer::list_marker_info_any_indent(rest).map(|(_, _, _, spaces)| spaces);
        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(escaped.contains(PIPE_SENTINEL));
    }

    #[test]
    fn test_escape_table_pipes_parent_indent_strip_without_code_indent() {
        let md = "\
- Parent
  continuation
  | H | I |
  | --- | --- |
  | `a|b` | c |
";
        let lines: Vec<&str> = md.split_inclusive('\n').collect();
        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
        let parent_indent =
            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
        let strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent);
        let code_strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent + 4);
        assert!(strip.is_some());
        assert!(code_strip.is_none());
        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(escaped.contains(PIPE_SENTINEL));
    }

    #[test]
    fn test_escape_table_pipes_parent_indent_strips_non_code_row() {
        let md = "\
- Parent
  | H | I |
  | --- | --- |
  | 1 | 2 |";
        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(escaped.contains("| H | I |"));
        assert!(escaped.contains("| --- | --- |"));
    }

    #[test]
    fn test_escape_table_pipes_parent_indent_out_of_range() {
        let md = "\
- Parent
        - Child
        continuation
";
        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert_eq!(escaped, md);
    }

    #[test]
    fn test_escape_table_pipes_parent_indent_marker_outside_range() {
        let md = "\
- Parent
      - Child
      continuation
";
        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert_eq!(escaped, md);
    }

    #[test]
    fn test_escape_table_pipes_parent_indent_marker_too_deep() {
        let md = "\
- Parent
      - Child
      | H | I |
      | --- | --- |
      | `a|b` | c |
";
        let lines: Vec<&str> = md.split_inclusive('\n').collect();
        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
        let _parent_indent =
            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
        let _leading_spaces =
            MarkdownRenderer::list_marker_info_any_indent(rest).map(|(_, _, _, spaces)| spaces);
        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert_eq!(escaped, md);
    }

    #[test]
    fn test_escape_table_pipes_parent_indent_code_strip_present() {
        let md = "\
 - Parent
      continuation
      | H | I |
      | --- | --- |
      | `a|b` | c |
";
        let lines: Vec<&str> = md.split_inclusive('\n').collect();
        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
        let parent_indent =
            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
        let strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent);
        let code_strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent + 4);
        assert!(strip.is_some());
        assert!(code_strip.is_some());
        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert_eq!(escaped, md);
    }

    #[test]
    fn test_escape_table_pipes_parent_indent_strip_only() {
        let md = "\
- Parent
  | H | I |
  | --- | --- |
  | `a|b` | c |
";
        let lines: Vec<&str> = md.split_inclusive('\n').collect();
        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
        let parent_indent =
            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
        let strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent);
        let code_strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent + 4);
        assert!(strip.is_some());
        assert!(code_strip.is_none());
        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(escaped.contains(PIPE_SENTINEL));
    }

    #[test]
    fn test_escape_table_pipes_parent_indent_marker_in_range_any_indent() {
        let md = "\
  - Parent
     - | H | I |
        | --- | --- |
       | `a|b` | c |
";
        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert!(escaped.contains(PIPE_SENTINEL));
    }

    #[test]
    fn test_escape_table_pipes_parent_indent_deep_list_marker_table_like_lines() {
        let md = "\
- Parent
        - | H | I |
        | --- | --- |
        | `a|b` | c |
";
        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
        assert_eq!(escaped, md);
    }

    #[test]
    fn test_parse_table_unclosed_and_noise() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Table(vec![Alignment::Left])),
            Event::Start(Tag::TableHead),
            Event::Start(Tag::TableRow),
            Event::Start(Tag::TableCell),
            Event::Text("H".into()),
            Event::End(Tag::TableCell),
            Event::End(Tag::TableRow),
            Event::End(Tag::TableHead),
            Event::Start(Tag::TableRow),
            Event::Text("noise".into()),
            Event::Start(Tag::TableCell),
            Event::Text("R".into()),
            Event::End(Tag::TableCell),
            Event::End(Tag::TableRow),
            Event::Text("after".into()),
        ];
        let (headers, rows, next) = renderer.parse_table(&events, 1);
        assert_eq!(headers.len(), 1);
        assert_eq!(rows.len(), 1);
        assert_eq!(next, events.len());
        Ok(())
    }

    #[test]
    fn test_parse_table_unclosed_head_exits_on_eof() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Table(vec![Alignment::Left])),
            Event::Start(Tag::TableHead),
            Event::Start(Tag::TableCell),
            Event::Text("H".into()),
            Event::End(Tag::TableCell),
        ];
        let (headers, rows, next) = renderer.parse_table(&events, 1);
        assert_eq!(headers.len(), 1);
        assert!(rows.is_empty());
        assert_eq!(next, events.len());
        Ok(())
    }

    #[test]
    fn test_parse_table_unclosed_row_exits_on_eof() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Table(vec![Alignment::Left])),
            Event::Start(Tag::TableRow),
            Event::Start(Tag::TableCell),
            Event::Text("R".into()),
            Event::End(Tag::TableCell),
        ];
        let (headers, rows, next) = renderer.parse_table(&events, 1);
        assert!(headers.is_empty());
        assert!(rows.is_empty());
        assert_eq!(next, events.len());
        Ok(())
    }

    #[test]
    fn test_parse_table_head_skips_noise() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let alignments = vec![Alignment::Left];
        let events = vec![
            Event::Start(Tag::Table(alignments.clone())),
            Event::Start(Tag::TableHead),
            Event::Text("noise".into()),
            Event::Start(Tag::TableCell),
            Event::Text("H".into()),
            Event::End(Tag::TableCell),
            Event::End(Tag::TableHead),
            Event::End(Tag::Table(alignments)),
        ];
        let (headers, rows, next) = renderer.parse_table(&events, 1);
        assert_eq!(headers.len(), 1);
        assert!(rows.is_empty());
        assert_eq!(next, events.len());
        Ok(())
    }

    #[test]
    fn test_parse_table_empty_row_skips_row() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let alignments = vec![Alignment::Left];
        let events = vec![
            Event::Start(Tag::Table(alignments.clone())),
            Event::Start(Tag::TableRow),
            Event::End(Tag::TableRow),
            Event::End(Tag::Table(alignments)),
        ];
        let (headers, rows, next) = renderer.parse_table(&events, 1);
        assert!(headers.is_empty());
        assert!(rows.is_empty());
        assert_eq!(next, events.len());
        Ok(())
    }

    #[test]
    fn test_parse_code_block_unclosed() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
                "rust".into(),
            ))),
            Event::Text("fn main() {}".into()),
            Event::Html("<span>".into()),
        ];
        let (code, language, next) = renderer.parse_code_block(&events, 0);
        assert_eq!(language.as_deref(), Some("rust"));
        assert_eq!(code, "fn main() {}");
        assert_eq!(next, events.len());
        Ok(())
    }

    #[test]
    fn test_parse_code_block_without_start_tag() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Text("fn main() {}".into()),
            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Indented)),
        ];
        let (code, language, next) = renderer.parse_code_block(&events, 0);
        assert_eq!(language, None);
        assert_eq!(code, "fn main() {}");
        assert_eq!(next, events.len());
        Ok(())
    }

    #[test]
    fn test_has_pipe_outside_inline_code_backticks() {
        assert!(MarkdownRenderer::has_pipe_outside_inline_code(r"\`|`"));
        assert!(!MarkdownRenderer::has_pipe_outside_inline_code("``a|b``"));
    }

    #[test]
    fn test_row_needs_height_estimate_variants() {
        let renderer = MarkdownRenderer::new();
        let row_with_image = vec![vec![InlineSpan::Image {
            src: "missing.png".to_string(),
            alt: "Alt".to_string(),
            title: None,
        }]];
        assert!(renderer.row_needs_height_estimate(&row_with_image));

        let row_with_newline = vec![vec![InlineSpan::Text("line1\nline2".to_string())]];
        assert!(renderer.row_needs_height_estimate(&row_with_newline));

        let row_plain = vec![vec![InlineSpan::Text("plain".to_string())]];
        assert!(!renderer.row_needs_height_estimate(&row_plain));
    }

    #[test]
    fn test_is_allowed_scheme_variants() {
        assert!(MarkdownRenderer::is_allowed_scheme("http://example.com"));
        assert!(MarkdownRenderer::is_allowed_scheme("https://example.com"));
        assert!(MarkdownRenderer::is_allowed_scheme(
            "mailto:test@example.com"
        ));
        assert!(!MarkdownRenderer::is_allowed_scheme("ftp://example.com"));
    }

    #[test]
    fn test_render_table_tablebuilder_scaled_down_adjustments() {
        let renderer = MarkdownRenderer::new();
        let headers = vec![
            vec![InlineSpan::Text("A".to_string())],
            vec![InlineSpan::Text("B".to_string())],
            vec![InlineSpan::Text("C".to_string())],
        ];
        let rows = vec![vec![
            vec![InlineSpan::Text("row1".to_string())],
            vec![InlineSpan::Text("row2".to_string())],
            vec![InlineSpan::Text("row3".to_string())],
        ]];
        let ctx = egui::Context::default();
        let widths = [220.0, 240.0];
        for (idx, width) in widths.iter().enumerate() {
            let _forced = ForcedTablePolicies::new(vec![
                ColumnPolicy::Resizable {
                    min: 40.0,
                    preferred: 200.0,
                    clip: false,
                },
                ColumnPolicy::Auto,
                ColumnPolicy::Remainder { clip: false },
            ]);
            let input = egui::RawInput {
                screen_rect: Some(egui::Rect::from_min_size(
                    egui::pos2(0.0, 0.0),
                    egui::vec2(*width, 120.0),
                )),
                ..Default::default()
            };
            run_frame_with_input(&ctx, input, |_, ui| {
                ui.spacing_mut().item_spacing.x = 2.0;
                let table_id = renderer.compute_table_id(&headers, &rows, &[], 90 + idx as u64);
                renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
            });
        }
    }

    #[test]
    fn test_render_code_block_mermaid_and_context_menu() {
        let renderer = MarkdownRenderer::new();
        let _guard = EnvVarGuard::set("MDMDVIEW_MERMAID_RENDERER", "off");
        with_test_ui(|_, ui| {
            renderer.render_code_block(ui, Some("mermaid"), "graph TD; A-->B;");
        });

        let ctx = egui::Context::default();
        let click = input_with_click(egui::pos2(12.0, 12.0), egui::PointerButton::Secondary);
        run_frame_with_input(&ctx, click, |_, ui| {
            renderer.render_code_block(ui, Some("rust"), "fn main() {}");
        });
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(320.0, 240.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, input, |_, ui| {
            renderer.render_code_block(ui, Some("rust"), "fn main() {}");
        });
    }

    #[test]
    fn test_render_code_block_highlight_styles() {
        let mut renderer = MarkdownRenderer::new();
        let theme = renderer
            .theme_set
            .themes
            .get_mut("base16-ocean.dark")
            .expect("theme");
        theme.scopes.clear();
        let selector = ScopeSelectors::from_str("source.rust").expect("selector");
        theme.scopes.push(ThemeItem {
            scope: selector,
            style: StyleModifier {
                foreground: Some(Color::WHITE),
                background: Some(Color::BLACK),
                font_style: Some(FontStyle::BOLD | FontStyle::ITALIC),
            },
        });
        with_test_ui(|_, ui| {
            renderer.render_code_block(ui, Some("rust"), "fn main() {}");
        });
    }

    #[test]
    fn test_render_code_block_highlight_and_fallback() {
        let renderer = MarkdownRenderer::new();
        let code = "fn main() {\n    let value = 1;\n    // comment with  spaces\n    \n}\n";
        with_test_ui(|_, ui| {
            renderer.render_code_block(ui, Some("rust"), code);
        });

        let mut fallback_renderer = MarkdownRenderer::new();
        fallback_renderer.syntax_set = SyntaxSet::new();
        with_test_ui(|_, ui| {
            fallback_renderer.render_code_block(ui, Some("notalanguage"), "code");
        });
    }

    #[test]
    fn test_to_superscript_maps_values() {
        let mapped = MarkdownRenderer::to_superscript("Abc123!");
        assert_ne!(mapped, "Abc123!");
    }

    #[test]
    fn test_cell_single_emoji_whitespace_only() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Text("   ".to_string())];
        assert!(renderer.cell_single_emoji(&spans).is_none());
    }

    #[test]
    fn test_table_line_info_with_list_fallback_indent() {
        let line = "  >| A |";
        let (level, rest) = MarkdownRenderer::table_line_info_with_list(line, Some(2));
        assert_eq!(level, 1);
        assert!(rest.starts_with('|'));
    }

    #[test]
    fn test_list_marker_info_any_indent_missing_punctuation() {
        assert!(MarkdownRenderer::list_marker_info_any_indent("1 item").is_none());
    }

    #[test]
    fn test_strip_indent_columns_rejects_non_whitespace() {
        assert!(MarkdownRenderer::strip_indent_columns("x", 1).is_none());
    }

    #[test]
    fn test_parse_element_image_empty_title_outside_paragraph() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
            Event::Text("alt".into()),
            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
        ];
        let mut elements = Vec::new();
        let mut slugs = HashMap::new();
        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs);
        assert_eq!(next, events.len());
        let spans = paragraph_spans(&elements[0]).expect("paragraph spans");
        let (_src, _alt, title) = image_span_fields(&spans[0]).expect("image span");
        assert!(title.is_none());
    }

    #[test]
    fn test_slugify_trailing_dash_trimmed() {
        let slug = MarkdownRenderer::slugify("Hello - ");
        assert_eq!(slug, "hello");
    }

    #[test]
    fn test_slugify_leading_whitespace_and_internal_spaces() {
        let slug = MarkdownRenderer::slugify("  Hello   World ");
        assert_eq!(slug, "hello-world");
    }

    #[test]
    fn test_render_plain_and_highlight_empty_text() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            ui.visuals_mut().override_text_color = Some(Color32::from_rgb(10, 20, 30));
            let style = InlineStyle {
                strong: true,
                ..Default::default()
            };
            renderer.render_plain_segment(ui, "", 12.0, style);
            renderer.render_plain_segment(ui, "Header", 12.0, style);
            renderer.render_highlighted_segment(ui, "", 12.0, style);
        });
    }

    #[test]
    fn test_render_plain_segment_without_color_override() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            ui.visuals_mut().override_text_color = None;
            renderer.render_plain_segment(ui, "Plain", 12.0, InlineStyle::default());
        });
    }

    #[test]
    fn test_emoji_key_for_grapheme_strips_vs16() {
        let renderer = MarkdownRenderer::new();
        let key = renderer.emoji_key_for_grapheme("\u{2705}\u{fe0f}");
        assert_eq!(key, Some("\u{2705}".to_string()));
    }

    #[test]
    fn test_expand_superscripts_long_sequence_no_expand() {
        let input = "value^abcdefghijk^";
        let out = MarkdownRenderer::expand_superscripts(input);
        assert_eq!(out, input);
    }

    #[test]
    fn test_compute_table_content_hash_stops_after_sample_rows() {
        let renderer = MarkdownRenderer::new();
        let headers = vec![vec![InlineSpan::Text("H".to_string())]];
        let rows: Vec<Vec<Vec<InlineSpan>>> = (0..(COLUMN_STATS_SAMPLE_ROWS + 1))
            .map(|idx| vec![vec![InlineSpan::Text(format!("R{idx}"))]])
            .collect();
        let hash = renderer.compute_table_content_hash(&headers, &rows, &[]);
        assert_ne!(hash, 0);
    }

    #[test]
    fn test_table_width_helpers_empty_inputs() {
        let renderer = MarkdownRenderer::new();
        let table_id = 100u64;
        let mut specs: Vec<ColumnSpec> = Vec::new();
        renderer.apply_persisted_widths(table_id, &mut specs);
        renderer.persist_resizable_widths(table_id, &[], &[]);
        let change = renderer.record_resolved_widths(table_id, 0, &[]);
        assert!(matches!(change, WidthChange::None));
        assert!(renderer
            .resolve_table_column_widths(table_id, &[], 10.0)
            .is_empty());
        assert_eq!(renderer.estimate_table_total_width(table_id, &[], 6.0), 0.0);
        with_test_ui(|_, ui| {
            let style = ui.style().clone();
            let row = vec![vec![]];
            let height =
                renderer.estimate_table_row_height(ui, &style, &row, &[Align::LEFT], &[40.0], 12.0);
            assert_eq!(height, 12.0);
            let row = vec![
                vec![InlineSpan::Text("a".to_string())],
                vec![InlineSpan::Text("b".to_string())],
            ];
            let height =
                renderer.estimate_table_row_height(ui, &style, &row, &[Align::LEFT], &[40.0], 12.0);
            assert!(height >= 12.0);
            let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(10.0, 10.0));
            renderer.paint_table_dividers(ui.painter(), ui.visuals(), rect, rect, &[], 0.0, 0.0);
        });
    }

    #[test]
    fn test_resolve_table_column_widths_ignores_invalid_stored_widths() {
        let renderer = MarkdownRenderer::new();
        let table_id = 101u64;
        {
            let mut metrics = renderer.table_metrics.borrow_mut();
            let entry = metrics.entry_mut(table_id);
            entry.resolved_widths = vec![f32::NAN, -5.0];
        }
        let specs = vec![
            ColumnSpec::new(
                0,
                "A",
                ColumnPolicy::Resizable {
                    min: 20.0,
                    preferred: 40.0,
                    clip: false,
                },
                None,
            ),
            ColumnSpec::new(1, "B", ColumnPolicy::Auto, None),
        ];
        let widths = renderer.resolve_table_column_widths(table_id, &specs, 30.0);
        assert_eq!(widths, vec![40.0, 30.0]);
    }

    #[test]
    fn test_persist_resizable_widths_stores_new_width() {
        let renderer = MarkdownRenderer::new();
        let table_id = 200u64;
        let specs = vec![ColumnSpec::new(
            0,
            "A",
            ColumnPolicy::Resizable {
                min: 20.0,
                preferred: 100.0,
                clip: false,
            },
            None,
        )];
        let widths = vec![140.0f32];
        renderer.persist_resizable_widths(table_id, &specs, &widths);
        let metrics = renderer.table_metrics.borrow();
        let entry = metrics.entry(table_id).expect("entry created");
        assert_eq!(entry.persisted_width(specs[0].policy_hash), Some(140.0));
    }

    #[test]
    fn test_persist_resizable_widths_skips_small_delta() {
        let renderer = MarkdownRenderer::new();
        let table_id = 201u64;
        let spec = ColumnSpec::new(
            0,
            "A",
            ColumnPolicy::Resizable {
                min: 20.0,
                preferred: 100.0,
                clip: false,
            },
            None,
        );
        let hash = spec.policy_hash;
        let specs = vec![spec];
        renderer.persist_resizable_widths(table_id, &specs, &[120.0]);
        renderer.persist_resizable_widths(table_id, &specs, &[120.2]);
        let metrics = renderer.table_metrics.borrow();
        let entry = metrics.entry(table_id).expect("entry created");
        let stored = entry.persisted_width(hash).unwrap_or_default();
        assert!((stored - 120.0).abs() < 0.01);
    }

    #[test]
    fn test_persist_resizable_widths_updates_on_large_delta() {
        let renderer = MarkdownRenderer::new();
        let table_id = 202u64;
        let spec = ColumnSpec::new(
            0,
            "A",
            ColumnPolicy::Resizable {
                min: 20.0,
                preferred: 100.0,
                clip: false,
            },
            None,
        );
        let hash = spec.policy_hash;
        let specs = vec![spec];
        renderer.persist_resizable_widths(table_id, &specs, &[120.0]);
        renderer.persist_resizable_widths(table_id, &specs, &[130.0]);
        let metrics = renderer.table_metrics.borrow();
        let entry = metrics.entry(table_id).expect("entry created");
        assert_eq!(entry.persisted_width(hash), Some(130.0));
    }

    #[test]
    fn test_paint_table_dividers_draws_header_separator() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(120.0, 40.0));
            renderer.paint_table_dividers(
                ui.painter(),
                ui.visuals(),
                rect,
                rect,
                &[40.0, 60.0],
                8.0,
                12.0,
            );
        });
    }

    #[test]
    fn test_paint_table_dividers_no_header_height() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(120.0, 20.0));
            renderer.paint_table_dividers(
                ui.painter(),
                ui.visuals(),
                rect,
                rect,
                &[40.0, 60.0],
                0.0,
                8.0,
            );
        });
    }

    #[test]
    fn test_paint_table_dividers_skips_header_separator_out_of_bounds() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(120.0, 20.0));
            renderer.paint_table_dividers(
                ui.painter(),
                ui.visuals(),
                rect,
                rect,
                &[40.0, 60.0],
                60.0,
                8.0,
            );
        });
    }

    #[test]
    fn test_paint_table_text_job_adds_hover_for_wrapped_text() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Text(
            "This is a long line that should wrap in a narrow cell.".to_string(),
        )];
        with_test_ui(|_, ui| {
            let build = renderer.build_layout_job(ui.style(), &spans, 20.0, false, Align::LEFT);
            let _response = renderer.paint_table_text_job(ui, 20.0, build);
        });
    }

    #[test]
    fn test_paint_table_text_job_adds_hover_for_multiline_text() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Text("Line 1\nLine 2".to_string())];
        with_test_ui(|_, ui| {
            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, false, Align::LEFT);
            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
            assert!(galley.rows.len() > 1);
            let _response = renderer.paint_table_text_job(ui, 200.0, build);
        });
    }

    #[test]
    fn test_paint_table_text_job_skips_hover_for_short_text() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Text("Short".to_string())];
        with_test_ui(|_, ui| {
            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, false, Align::LEFT);
            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
            assert_eq!(galley.rows.len(), 1);
            assert!(galley.size().x < 200.0);
            let _response = renderer.paint_table_text_job(ui, 200.0, build);
        });
    }

    #[test]
    fn test_paint_table_text_job_adds_hover_for_single_line_overflow() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Text(
            "This is a single line that should overflow the render width.".to_string(),
        )];
        with_test_ui(|_, ui| {
            let build = renderer.build_layout_job(ui.style(), &spans, 400.0, false, Align::LEFT);
            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
            assert_eq!(galley.rows.len(), 1);
            assert!(galley.size().x > 40.0);
            let _response = renderer.paint_table_text_job(ui, 40.0, build);
        });
    }

    #[test]
    fn test_link_at_pointer_outside_text_rect() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Link {
            text: "link".to_string(),
            url: "https://example.com".to_string(),
        }];
        let ctx = egui::Context::default();
        let outside_pos = std::cell::Cell::new(egui::pos2(1.0, 1.0));
        let layout_input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(220.0, 120.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, layout_input, |_, ui| {
            let build = renderer.build_layout_job(ui.style(), &spans, 40.0, false, Align::LEFT);
            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
            let (rect, _response) =
                ui.allocate_exact_size(egui::vec2(200.0, galley.size().y), egui::Sense::hover());
            let text_origin =
                MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
            let text_rect = galley.rect.translate(text_origin.to_vec2());
            let pos = egui::pos2(rect.right() - 2.0, text_rect.center().y);
            assert!(pos.x > text_rect.right());
            outside_pos.set(pos);
        });

        let mut input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(220.0, 120.0),
            )),
            ..Default::default()
        };
        input
            .events
            .push(egui::Event::PointerMoved(outside_pos.get()));
        run_frame_with_input(&ctx, input, |_, ui| {
            let build = renderer.build_layout_job(ui.style(), &spans, 40.0, false, Align::LEFT);
            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
            let (rect, response) =
                ui.allocate_exact_size(egui::vec2(200.0, galley.size().y), egui::Sense::hover());
            let text_origin =
                MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
            let link = renderer.link_at_pointer(&response, &galley, &build, text_origin);
            assert!(link.is_none());
        });
    }

    #[test]
    fn test_link_at_pointer_inside_text_rect_returns_link() {
        let renderer = MarkdownRenderer::new();
        let spans = vec![InlineSpan::Link {
            text: "link".to_string(),
            url: "#anchor".to_string(),
        }];
        let ctx = egui::Context::default();
        let click_pos = std::cell::Cell::new(egui::pos2(1.0, 1.0));
        let layout_input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(220.0, 120.0),
            )),
            ..Default::default()
        };
        run_frame_with_input(&ctx, layout_input, |_, ui| {
            let build = renderer.build_layout_job(ui.style(), &spans, 40.0, false, Align::LEFT);
            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
            let (rect, _response) =
                ui.allocate_exact_size(egui::vec2(200.0, galley.size().y), egui::Sense::hover());
            let text_origin =
                MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
            click_pos.set(text_origin + egui::vec2(2.0, 2.0));
        });

        let mut input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(220.0, 120.0),
            )),
            ..Default::default()
        };
        input
            .events
            .push(egui::Event::PointerMoved(click_pos.get()));
        run_frame_with_input(&ctx, input, |_, ui| {
            let build = renderer.build_layout_job(ui.style(), &spans, 40.0, false, Align::LEFT);
            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
            let (rect, response) =
                ui.allocate_exact_size(egui::vec2(200.0, galley.size().y), egui::Sense::hover());
            let text_origin =
                MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
            let link = renderer.link_at_pointer(&response, &galley, &build, text_origin);
            assert!(link.is_some());
        });
    }

    #[test]
    fn test_element_plain_text_list_quote_table_spacing() {
        let list = MarkdownElement::List {
            ordered: false,
            items: vec![ListItem {
                blocks: vec![
                    MarkdownElement::Paragraph(vec![InlineSpan::Text("One".to_string())]),
                    MarkdownElement::Paragraph(vec![InlineSpan::Text("Two".to_string())]),
                ],
            }],
        };
        let list_text = MarkdownRenderer::element_plain_text(&list);
        assert!(list_text.contains('\n'));

        let quote = MarkdownElement::Quote {
            depth: 1,
            blocks: vec![
                MarkdownElement::Paragraph(vec![InlineSpan::Text("Alpha".to_string())]),
                MarkdownElement::Paragraph(vec![InlineSpan::Text("Beta".to_string())]),
            ],
        };
        let quote_text = MarkdownRenderer::element_plain_text(&quote);
        assert!(quote_text.contains('\n'));

        let table = MarkdownElement::Table {
            headers: vec![
                vec![InlineSpan::Text("H1".to_string())],
                vec![InlineSpan::Text("H2".to_string())],
            ],
            rows: vec![vec![
                vec![InlineSpan::Text("A".to_string())],
                vec![InlineSpan::Text("B".to_string())],
            ]],
            alignments: vec![],
        };
        let table_text = MarkdownRenderer::element_plain_text(&table);
        assert_eq!(table_text, "H1 H2 A B");
    }

    #[test]
    fn test_resolve_image_path_data_uri_and_remote_texture_reject() {
        let renderer = MarkdownRenderer::new();
        let data_uri = "data:image/png;base64,AAAA";
        assert_eq!(renderer.resolve_image_path(data_uri), data_uri);
        with_test_ui(|_, ui| {
            assert!(renderer
                .get_or_load_image_texture(ui, "https://example.com/image.png")
                .is_none());
            assert!(renderer
                .get_or_load_image_texture(ui, "http://example.com/image.png")
                .is_none());
        });
    }

    #[test]
    fn test_is_html_line_break_rejects_non_br() {
        assert!(!MarkdownRenderer::is_html_line_break("<div>"));
        assert!(!MarkdownRenderer::is_html_line_break("br"));
    }

    #[test]
    fn test_table_line_info_variants_cover_edges() {
        let (level, rest) = MarkdownRenderer::table_line_info("text");
        assert_eq!(level, 0);
        assert_eq!(rest, "text");

        let (level, rest) = MarkdownRenderer::table_line_info("   text");
        assert_eq!(level, 0);
        assert_eq!(rest, "   text");

        let (level, rest) = MarkdownRenderer::table_line_info(">abc");
        assert_eq!(level, 1);
        assert_eq!(rest, "abc");

        let (level, rest) = MarkdownRenderer::table_line_info(" >\tabc");
        assert_eq!(level, 1);
        assert_eq!(rest, "abc");

        let (level, rest) = MarkdownRenderer::table_line_info(">");
        assert_eq!(level, 1);
        assert_eq!(rest, "");
    }

    #[test]
    fn test_list_marker_info_rejects_missing_delimiter_or_spacing() {
        assert!(MarkdownRenderer::list_marker_info("1 item").is_none());
        assert!(MarkdownRenderer::list_marker_info("1.item").is_none());
    }

    #[test]
    fn test_list_marker_info_numeric_missing_punctuation() {
        assert!(MarkdownRenderer::list_marker_info("12").is_none());
        assert!(MarkdownRenderer::list_marker_info_any_indent("  12").is_none());
    }

    #[test]
    fn test_list_marker_info_any_indent_rejects_missing_delimiter_or_spacing() {
        assert!(MarkdownRenderer::list_marker_info_any_indent("   1 item").is_none());
        assert!(MarkdownRenderer::list_marker_info_any_indent("  2.item").is_none());
    }

    #[test]
    fn test_strip_indent_columns_insufficient_indent_returns_none() {
        assert!(MarkdownRenderer::strip_indent_columns("  text", 4).is_none());
    }

    #[test]
    fn test_strip_indent_columns_whitespace_short_returns_none() {
        assert!(MarkdownRenderer::strip_indent_columns("  ", 4).is_none());
    }

    #[test]
    fn test_has_pipe_outside_inline_code_unmatched_backticks() {
        let line = "`code`` | still in code";
        assert!(!MarkdownRenderer::has_pipe_outside_inline_code(line));
    }

    #[test]
    fn test_is_table_delimiter_line_requires_dash_and_pipe() {
        assert!(!MarkdownRenderer::is_table_delimiter_line("----"));
        assert!(!MarkdownRenderer::is_table_delimiter_line("| ::: |"));
    }

    #[test]
    fn test_append_text_sections_preserves_color_when_highlighted() {
        let renderer = MarkdownRenderer::new();
        let style = egui::Style::default();
        let mut job = LayoutJob::default();
        let mut plain_text = String::new();
        let inline_style = InlineStyle {
            strong: false,
            italics: false,
            strike: false,
            color: Some(Color32::from_rgb(10, 20, 30)),
        };
        let count = renderer.append_text_sections(
            &style,
            &mut job,
            &mut plain_text,
            "hit",
            renderer.font_sizes.body,
            inline_style,
            Some("hit"),
        );
        assert_eq!(count, 3);
        assert_eq!(plain_text, "hit");
    }

    #[test]
    fn test_render_text_with_emojis_leading_emoji() {
        let renderer = MarkdownRenderer::new();
        with_test_ui(|_, ui| {
            renderer.render_text_with_emojis(ui, " test", 14.0, InlineStyle::default());
        });
    }

    #[test]
    fn test_persist_resizable_widths_records_change() {
        let renderer = MarkdownRenderer::new();
        let spec = ColumnSpec::new(
            0,
            "col",
            ColumnPolicy::Resizable {
                min: 40.0,
                preferred: 80.0,
                clip: false,
            },
            None,
        );
        let hash = spec.policy_hash;
        renderer.persist_resizable_widths(42, &[spec], &[120.0]);
        let metrics = renderer.table_metrics.borrow();
        let entry = metrics.entry(42).expect("metrics entry");
        assert_eq!(entry.persisted_width(hash), Some(120.0));
    }

    #[test]
    fn test_env_var_guard_restores_previous_value() {
        std::env::set_var("MDMDVIEW_TEST_ENV", "before");
        {
            let _guard = EnvVarGuard::set("MDMDVIEW_TEST_ENV", "after");
            assert_eq!(
                std::env::var("MDMDVIEW_TEST_ENV").ok().as_deref(),
                Some("after")
            );
        }
        assert_eq!(
            std::env::var("MDMDVIEW_TEST_ENV").ok().as_deref(),
            Some("before")
        );
        std::env::remove_var("MDMDVIEW_TEST_ENV");
    }

    #[test]
    fn test_parse_element_skips_unhandled_event() {
        let renderer = MarkdownRenderer::new();
        let events = vec![Event::Text("orphan".into())];
        let mut elements = Vec::new();
        let mut slugs = std::collections::HashMap::new();
        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs);
        assert_eq!(next, events.len());
        assert!(elements.is_empty());
    }

    #[test]
    fn test_parse_inline_spans_link_and_image() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Paragraph),
            Event::Start(Tag::Link(
                LinkType::Inline,
                "https://example.com".into(),
                "".into(),
            )),
            Event::Text("Link".into()),
            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
            Event::Start(Tag::Image(
                LinkType::Inline,
                "img.png".into(),
                "Title".into(),
            )),
            Event::Text("Alt".into()),
            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
            Event::End(Tag::Paragraph),
        ];
        let (spans, next) = renderer.parse_inline_spans(&events, 1, Tag::Paragraph);
        assert_eq!(next, events.len());
        assert!(spans
            .iter()
            .any(|span| matches!(span, InlineSpan::Link { .. })));
        assert!(spans
            .iter()
            .any(|span| matches!(span, InlineSpan::Image { .. })));
    }

    #[test]
    fn test_parse_inline_spans_with_breaks_link_and_image() {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::Paragraph),
            Event::Start(Tag::Link(
                LinkType::Inline,
                "https://example.com".into(),
                "".into(),
            )),
            Event::Text("Link".into()),
            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
            Event::Start(Tag::Image(
                LinkType::Inline,
                "img.png".into(),
                "Title".into(),
            )),
            Event::Text("Alt".into()),
            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
            Event::End(Tag::Paragraph),
        ];
        let (spans, next) =
            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, false);
        assert_eq!(next, events.len());
        assert!(spans
            .iter()
            .any(|span| matches!(span, InlineSpan::Link { .. })));
        assert!(spans
            .iter()
            .any(|span| matches!(span, InlineSpan::Image { .. })));
    }

    #[test]
    fn test_parse_list_item_heading_builds_header() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::List(None)),
            Event::Start(Tag::Item),
            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
            Event::Text("Title".into()),
            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
            Event::End(Tag::Item),
            Event::End(Tag::List(None)),
        ];
        let mut slugs = std::collections::HashMap::new();
        let (items, next) = renderer.parse_list(&events, 1, &mut slugs);
        assert_eq!(next, events.len());
        assert!(matches!(items[0].blocks[0], MarkdownElement::Header { .. }));
        Ok(())
    }

    #[test]
    fn test_parse_list_inline_formats_without_paragraph() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let events = vec![
            Event::Start(Tag::List(None)),
            Event::Start(Tag::Item),
            Event::Start(Tag::Emphasis),
            Event::Text("em".into()),
            Event::End(Tag::Emphasis),
            Event::Start(Tag::Strikethrough),
            Event::Text("strike".into()),
            Event::End(Tag::Strikethrough),
            Event::Start(Tag::Link(
                LinkType::Inline,
                "https://example.com".into(),
                "".into(),
            )),
            Event::Text("link".into()),
            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
            Event::Start(Tag::Image(
                LinkType::Inline,
                "img.png".into(),
                "Title".into(),
            )),
            Event::Text("Alt".into()),
            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
            Event::End(Tag::Item),
            Event::End(Tag::List(None)),
        ];
        let mut slugs = std::collections::HashMap::new();
        let (items, next) = renderer.parse_list(&events, 1, &mut slugs);
        assert_eq!(next, events.len());
        assert!(matches!(items[0].blocks[0], MarkdownElement::Paragraph(_)));
        let dummy = MarkdownElement::HorizontalRule;
        let mut saw_paragraph = false;
        for element in [&items[0].blocks[0], &dummy] {
            if let MarkdownElement::Paragraph(spans) = element {
                assert!(spans
                    .iter()
                    .any(|span| matches!(span, InlineSpan::Emphasis(_))));
                assert!(spans
                    .iter()
                    .any(|span| matches!(span, InlineSpan::Strikethrough(_))));
                assert!(spans
                    .iter()
                    .any(|span| matches!(span, InlineSpan::Link { .. })));
                assert!(spans
                    .iter()
                    .any(|span| matches!(span, InlineSpan::Image { .. })));
                saw_paragraph = true;
            }
        }
        assert!(saw_paragraph);
        Ok(())
    }

    #[test]
    fn test_parse_table_parses_header_and_rows() -> Result<()> {
        let renderer = MarkdownRenderer::new();
        let alignments = vec![Alignment::Left];
        let events = vec![
            Event::Start(Tag::Table(alignments.clone())),
            Event::Start(Tag::TableHead),
            Event::Start(Tag::TableRow),
            Event::Start(Tag::TableCell),
            Event::Text("H".into()),
            Event::End(Tag::TableCell),
            Event::End(Tag::TableRow),
            Event::End(Tag::TableHead),
            Event::Start(Tag::TableRow),
            Event::Start(Tag::TableCell),
            Event::Text("A".into()),
            Event::End(Tag::TableCell),
            Event::End(Tag::TableRow),
            Event::End(Tag::Table(alignments)),
        ];
        let (headers, rows, next) = renderer.parse_table(&events, 1);
        assert_eq!(next, events.len());
        assert_eq!(headers.len(), 1);
        assert_eq!(rows.len(), 1);
        Ok(())
    }
}


----------------------------------------

File: src\mermaid_renderer.rs

#[cfg(feature = "mermaid-quickjs")]
use crossbeam_channel::{bounded, Receiver, Sender, TrySendError};
use egui::{Color32, RichText, Stroke};
#[cfg(feature = "mermaid-quickjs")]
use std::cell::{Cell, RefCell};
#[cfg(feature = "mermaid-quickjs")]
use std::collections::HashSet;
#[cfg(any(test, feature = "mermaid-quickjs"))]
use std::collections::{hash_map::DefaultHasher, HashMap, VecDeque};
#[cfg(any(test, feature = "mermaid-quickjs"))]
use std::hash::{Hash, Hasher};

#[cfg(feature = "mermaid-quickjs")]
use std::path::PathBuf;
#[cfg(all(test, feature = "mermaid-quickjs"))]
use std::sync::atomic::AtomicBool;
#[cfg(feature = "mermaid-quickjs")]
use std::sync::{
    atomic::{AtomicU64, Ordering},
    Arc,
};
#[cfg(feature = "mermaid-quickjs")]
use std::thread::JoinHandle;
#[cfg(feature = "mermaid-quickjs")]
use std::time::{SystemTime, UNIX_EPOCH};

#[cfg(feature = "mermaid-quickjs")]
mod mermaid_embed {
    include!(concat!(env!("OUT_DIR"), "/mermaid_js.rs"));
}

#[cfg(feature = "mermaid-quickjs")]
const MERMAID_JS_EMPTY: bool = mermaid_embed::MERMAID_JS.is_empty();

#[cfg(all(test, feature = "mermaid-quickjs"))]
static MERMAID_JS_EMPTY_OVERRIDE: std::sync::Mutex<Option<std::thread::ThreadId>> =
    std::sync::Mutex::new(None);
#[cfg(all(test, feature = "mermaid-quickjs"))]
static FORCE_RAW_TREE_PARSE_FAIL: std::sync::atomic::AtomicBool =
    std::sync::atomic::AtomicBool::new(false);
#[cfg(all(test, feature = "mermaid-quickjs"))]
static FORCE_MERMAID_WORKER_INIT_ERROR: AtomicBool = AtomicBool::new(false);
#[cfg(all(test, feature = "mermaid-quickjs"))]
static FORCE_MERMAID_THREAD_SPAWN_ERROR: AtomicBool = AtomicBool::new(false);
#[cfg(all(test, feature = "mermaid-quickjs"))]
static FORCE_MERMAID_INIT_ERROR_STAGE: std::sync::Mutex<Option<(std::thread::ThreadId, usize)>> =
    std::sync::Mutex::new(None);
#[cfg(all(test, feature = "mermaid-quickjs"))]
static FORCE_MERMAID_RUNTIME_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
    std::sync::Mutex::new(None);
#[cfg(all(test, feature = "mermaid-quickjs"))]
static FORCE_MERMAID_CONTEXT_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
    std::sync::Mutex::new(None);
#[cfg(all(test, feature = "mermaid-quickjs"))]
static FORCE_MERMAID_UTF8_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
    std::sync::Mutex::new(None);
#[cfg(all(test, feature = "mermaid-quickjs"))]
static FORCE_MERMAID_RENDER_EVAL_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
    std::sync::Mutex::new(None);
#[cfg(all(test, feature = "mermaid-quickjs"))]
static FORCE_MERMAID_RENDER_CALL_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
    std::sync::Mutex::new(None);
#[cfg(all(test, feature = "mermaid-quickjs"))]
static FORCE_MERMAID_PIXMAP_ALLOC_FAIL: std::sync::Mutex<Option<std::thread::ThreadId>> =
    std::sync::Mutex::new(None);
#[cfg(all(test, feature = "mermaid-quickjs"))]
static FORCE_MERMAID_FACE_PARSE_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
    std::sync::Mutex::new(None);

#[cfg(feature = "mermaid-quickjs")]
fn mermaid_js_empty() -> bool {
    #[cfg(test)]
    if let Ok(guard) = MERMAID_JS_EMPTY_OVERRIDE.try_lock() {
        if let Some(id) = guard.as_ref() {
            if *id == std::thread::current().id() {
                return true;
            }
        }
    }
    MERMAID_JS_EMPTY
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn set_mermaid_js_empty_for_test(value: bool) -> Option<std::thread::ThreadId> {
    let mut guard = MERMAID_JS_EMPTY_OVERRIDE
        .lock()
        .expect("mermaid js override lock");
    let previous = *guard;
    *guard = if value {
        Some(std::thread::current().id())
    } else {
        None
    };
    previous
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn force_raw_tree_parse_fail_for_test() {
    FORCE_RAW_TREE_PARSE_FAIL.store(true, Ordering::Relaxed);
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn force_mermaid_worker_init_error_once() {
    FORCE_MERMAID_WORKER_INIT_ERROR.store(true, Ordering::Relaxed);
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn force_mermaid_thread_spawn_error_once() {
    FORCE_MERMAID_THREAD_SPAWN_ERROR.store(true, Ordering::Relaxed);
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn force_mermaid_init_error_once(stage: usize) {
    let mut guard = FORCE_MERMAID_INIT_ERROR_STAGE
        .lock()
        .expect("mermaid init error lock");
    *guard = Some((std::thread::current().id(), stage));
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn take_mermaid_flag(flag: &std::sync::Mutex<Option<std::thread::ThreadId>>) -> bool {
    let mut guard = flag.lock().expect("mermaid flag lock");
    if let Some(thread_id) = guard.take() {
        if thread_id == std::thread::current().id() {
            return true;
        }
        *guard = Some(thread_id);
    }
    false
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn force_mermaid_runtime_error_once() {
    let mut guard = FORCE_MERMAID_RUNTIME_ERROR
        .lock()
        .expect("mermaid runtime error lock");
    *guard = Some(std::thread::current().id());
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn force_mermaid_context_error_once() {
    let mut guard = FORCE_MERMAID_CONTEXT_ERROR
        .lock()
        .expect("mermaid context error lock");
    *guard = Some(std::thread::current().id());
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn force_mermaid_utf8_error_once() {
    let mut guard = FORCE_MERMAID_UTF8_ERROR
        .lock()
        .expect("mermaid utf8 error lock");
    *guard = Some(std::thread::current().id());
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn force_mermaid_render_eval_error_once() {
    let mut guard = FORCE_MERMAID_RENDER_EVAL_ERROR
        .lock()
        .expect("mermaid render eval error lock");
    *guard = Some(std::thread::current().id());
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn force_mermaid_render_call_error_once() {
    let mut guard = FORCE_MERMAID_RENDER_CALL_ERROR
        .lock()
        .expect("mermaid render call error lock");
    *guard = Some(std::thread::current().id());
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn force_mermaid_pixmap_alloc_fail_once() {
    let mut guard = FORCE_MERMAID_PIXMAP_ALLOC_FAIL
        .lock()
        .expect("mermaid pixmap fail lock");
    *guard = Some(std::thread::current().id());
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn force_mermaid_face_parse_error_once() {
    let mut guard = FORCE_MERMAID_FACE_PARSE_ERROR
        .lock()
        .expect("mermaid face parse error lock");
    *guard = Some(std::thread::current().id());
}

#[cfg(all(test, feature = "mermaid-quickjs"))]
fn maybe_force_mermaid_init_error<T>(
    stage: usize,
    result: rquickjs::Result<T>,
) -> rquickjs::Result<T> {
    if let Ok(mut guard) = FORCE_MERMAID_INIT_ERROR_STAGE.try_lock() {
        if let Some((thread_id, target_stage)) = guard.take() {
            if thread_id == std::thread::current().id() && target_stage == stage {
                return Err(rquickjs::Error::Exception);
            }
            *guard = Some((thread_id, target_stage));
        }
    }
    result
}

#[cfg(not(all(test, feature = "mermaid-quickjs")))]
fn maybe_force_mermaid_init_error<T>(
    _stage: usize,
    result: rquickjs::Result<T>,
) -> rquickjs::Result<T> {
    result
}

#[cfg(feature = "mermaid-quickjs")]
fn runtime_new_for_test() -> rquickjs::Result<rquickjs::Runtime> {
    #[cfg(all(test, feature = "mermaid-quickjs"))]
    if take_mermaid_flag(&FORCE_MERMAID_RUNTIME_ERROR) {
        return Err(rquickjs::Error::Exception);
    }
    rquickjs::Runtime::new()
}

#[cfg(feature = "mermaid-quickjs")]
fn context_full_for_test(rt: &rquickjs::Runtime) -> rquickjs::Result<rquickjs::Context> {
    #[cfg(all(test, feature = "mermaid-quickjs"))]
    if take_mermaid_flag(&FORCE_MERMAID_CONTEXT_ERROR) {
        return Err(rquickjs::Error::Exception);
    }
    rquickjs::Context::full(rt)
}

#[cfg(feature = "mermaid-quickjs")]
fn mermaid_js_str_for_test() -> Result<&'static str, std::str::Utf8Error> {
    #[cfg(all(test, feature = "mermaid-quickjs"))]
    if take_mermaid_flag(&FORCE_MERMAID_UTF8_ERROR) {
        #[allow(invalid_from_utf8)]
        {
            static INVALID_UTF8: [u8; 1] = [0xFF];
            return std::str::from_utf8(&INVALID_UTF8);
        }
    }
    std::str::from_utf8(mermaid_embed::MERMAID_JS)
}

#[cfg(feature = "mermaid-quickjs")]
fn face_parse_for_test(data: &[u8], index: u32) -> Option<ttf_parser::Face<'_>> {
    #[cfg(all(test, feature = "mermaid-quickjs"))]
    if take_mermaid_flag(&FORCE_MERMAID_FACE_PARSE_ERROR) {
        return None;
    }
    ttf_parser::Face::parse(data, index).ok()
}

#[cfg(feature = "mermaid-quickjs")]
fn eval_mermaid_wrapper<'js>(
    ctx: &rquickjs::Ctx<'js>,
    wrapper: &str,
) -> rquickjs::Result<rquickjs::Function<'js>> {
    #[cfg(all(test, feature = "mermaid-quickjs"))]
    if take_mermaid_flag(&FORCE_MERMAID_RENDER_EVAL_ERROR) {
        return Err(rquickjs::Error::Exception);
    }
    ctx.eval(wrapper)
}

#[cfg(feature = "mermaid-quickjs")]
fn call_mermaid_render<'js>(
    func: &rquickjs::Function<'js>,
    args: (&str, &str, &str, u32, u32),
) -> rquickjs::Result<rquickjs::promise::MaybePromise<'js>> {
    #[cfg(all(test, feature = "mermaid-quickjs"))]
    if take_mermaid_flag(&FORCE_MERMAID_RENDER_CALL_ERROR) {
        return Err(rquickjs::Error::Exception);
    }
    func.call(args)
}

#[cfg(feature = "mermaid-quickjs")]
fn pixmap_new_for_test(width: u32, height: u32) -> Option<tiny_skia::Pixmap> {
    #[cfg(all(test, feature = "mermaid-quickjs"))]
    if take_mermaid_flag(&FORCE_MERMAID_PIXMAP_ALLOC_FAIL) {
        return None;
    }
    tiny_skia::Pixmap::new(width, height)
}

#[cfg(feature = "mermaid-quickjs")]
struct MermaidEngine {
    #[allow(dead_code)]
    rt: rquickjs::Runtime,
    ctx: rquickjs::Context,
}

#[cfg(feature = "mermaid-quickjs")]
type MermaidJobSender = Sender<MermaidRequest>;
#[cfg(feature = "mermaid-quickjs")]
type MermaidJobReceiver = Receiver<MermaidRequest>;
#[cfg(feature = "mermaid-quickjs")]
type MermaidResultSender = Sender<MermaidResult>;
#[cfg(feature = "mermaid-quickjs")]
type MermaidResultReceiver = Receiver<MermaidResult>;

#[cfg(feature = "mermaid-quickjs")]
#[derive(Clone)]
struct MermaidTextureEntry {
    texture: egui::TextureHandle,
    size: [u32; 2],
}

#[cfg(any(test, feature = "mermaid-quickjs"))]
struct LruCache<K, V> {
    entries: HashMap<K, V>,
    order: VecDeque<K>,
    capacity: usize,
}

#[cfg(any(test, feature = "mermaid-quickjs"))]
impl<K, V> LruCache<K, V>
where
    K: Eq + std::hash::Hash + Clone,
    V: Clone,
{
    fn new(capacity: usize) -> Self {
        Self {
            entries: HashMap::new(),
            order: VecDeque::new(),
            capacity: capacity.max(1),
        }
    }

    #[cfg_attr(test, inline(never))]
    fn get(&mut self, key: &K) -> Option<V> {
        let value = self.entries.get(key).cloned();
        self.touch_if_present(&value, key);
        value
    }

    #[cfg_attr(test, inline(never))]
    fn insert(&mut self, key: K, value: V) {
        if self.entries.contains_key(&key) {
            self.entries.insert(key.clone(), value);
            self.touch(&key);
            return;
        }
        while self.entries.len() >= self.capacity {
            if !self.evict_oldest() {
                break;
            }
        }
        self.order.push_back(key.clone());
        self.entries.insert(key, value);
    }

    #[cfg(feature = "mermaid-quickjs")]
    fn remove(&mut self, key: &K) {
        self.entries.remove(key);
        self.order.retain(|entry| entry != key);
    }

    #[cfg(test)]
    fn len(&self) -> usize {
        self.entries.len()
    }

    #[cfg_attr(test, inline(never))]
    fn touch_if_present(&mut self, value: &Option<V>, key: &K) {
        if value.is_some() {
            self.touch(key);
        }
    }

    #[cfg_attr(test, inline(never))]
    fn evict_oldest(&mut self) -> bool {
        if let Some(old) = self.order.pop_front() {
            self.entries.remove(&old);
            true
        } else {
            false
        }
    }

    fn touch(&mut self, key: &K) {
        self.order.retain(|entry| entry != key);
        self.order.push_back(key.clone());
    }
}

#[cfg(feature = "mermaid-quickjs")]
struct MermaidRequest {
    svg_key: u64,
    texture_key: String,
    code: Option<String>,
    svg: Option<String>,
    width_bucket: u32,
    scale_bucket: u32,
    viewport_width: u32,
    viewport_height: u32,
    bg: Option<[u8; 4]>,
}

#[cfg(feature = "mermaid-quickjs")]
struct MermaidResult {
    svg_key: u64,
    texture_key: String,
    svg: Option<String>,
    rgba: Option<Vec<u8>>,
    size: Option<(u32, u32)>,
    error: Option<String>,
}

#[cfg(feature = "mermaid-quickjs")]
#[derive(Debug, PartialEq, Eq)]
enum MermaidEnqueueError {
    QueueFull,
    Disconnected,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum MermaidRenderPreference {
    Embedded,
    Off,
}

#[cfg(feature = "mermaid-quickjs")]
struct MermaidThemeValues {
    theme_name: String,
    main_bkg: String,
    primary: String,
    primary_border: String,
    primary_text: String,
    secondary: String,
    tertiary: String,
    line: String,
    text: String,
    cluster_bkg: String,
    cluster_border: String,
    default_link: String,
    title: String,
    label_bg: String,
    edge_label_bg: String,
    font_family: Option<String>,
}

pub(crate) struct MermaidRenderer {
    #[cfg(feature = "mermaid-quickjs")]
    mermaid_textures: RefCell<LruCache<String, MermaidTextureEntry>>,
    #[cfg(feature = "mermaid-quickjs")]
    mermaid_pending: RefCell<HashSet<String>>,
    #[cfg(feature = "mermaid-quickjs")]
    mermaid_frame_pending: Cell<bool>,
    #[cfg(feature = "mermaid-quickjs")]
    mermaid_svg_cache: RefCell<LruCache<u64, String>>,
    #[cfg(feature = "mermaid-quickjs")]
    mermaid_errors: RefCell<LruCache<u64, String>>,
    #[cfg(feature = "mermaid-quickjs")]
    mermaid_texture_errors: RefCell<LruCache<String, String>>,
    /// Job sender wrapped in Option so Drop can take and drop it first,
    /// closing the channel before joining worker threads.
    #[cfg(feature = "mermaid-quickjs")]
    mermaid_job_tx: Option<MermaidJobSender>,
    #[cfg(feature = "mermaid-quickjs")]
    mermaid_result_rx: MermaidResultReceiver,
    /// Worker thread handles for cleanup on drop.
    /// When MermaidRenderer is dropped, we join all worker threads to ensure
    /// they exit cleanly and release memory (font database, QuickJS runtime).
    #[cfg(feature = "mermaid-quickjs")]
    worker_handles: Vec<JoinHandle<()>>,
}

impl MermaidRenderer {
    #[cfg(feature = "mermaid-quickjs")]
    const MERMAID_TEXTURE_CACHE_CAPACITY: usize = 128;
    #[cfg(any(test, feature = "mermaid-quickjs"))]
    const MERMAID_WIDTH_BUCKET_STEP: u32 = 32;
    #[cfg(any(test, feature = "mermaid-quickjs"))]
    const MERMAID_SCALE_BUCKET_FACTOR: f32 = 100.0;
    #[cfg(feature = "mermaid-quickjs")]
    const MAX_MERMAID_JOBS: usize = 4;
    #[cfg(feature = "mermaid-quickjs")]
    const MERMAID_SVG_CACHE_CAPACITY: usize = 64;
    #[cfg(feature = "mermaid-quickjs")]
    const MERMAID_ERROR_CACHE_CAPACITY: usize = 64;
    #[cfg(feature = "mermaid-quickjs")]
    const MERMAID_TEXTURE_ERROR_CACHE_CAPACITY: usize = 64;
    #[cfg(feature = "mermaid-quickjs")]
    const MERMAID_MAX_TEXT_SIZE: u32 = 50_000;
    #[cfg(feature = "mermaid-quickjs")]
    const MERMAID_MAX_RENDER_SIDE: u32 = 4096;
    /// Minimum height for Mermaid placeholder to reduce layout shift when diagrams render.
    /// Most Mermaid diagrams are 150-400px tall; using 200px as a reasonable middle ground.
    #[cfg(feature = "mermaid-quickjs")]
    const MERMAID_PLACEHOLDER_MIN_HEIGHT: f32 = 200.0;

    pub(crate) fn new() -> Self {
        #[cfg(feature = "mermaid-quickjs")]
        let (mermaid_job_tx, mermaid_job_rx): (MermaidJobSender, MermaidJobReceiver) =
            bounded(Self::MAX_MERMAID_JOBS * 4);
        #[cfg(feature = "mermaid-quickjs")]
        let (mermaid_result_tx, mermaid_result_rx): (
            MermaidResultSender,
            MermaidResultReceiver,
        ) = bounded(Self::MAX_MERMAID_JOBS * 4);
        #[cfg(feature = "mermaid-quickjs")]
        let worker_handles = Self::spawn_mermaid_workers(mermaid_job_rx, mermaid_result_tx);
        Self {
            #[cfg(feature = "mermaid-quickjs")]
            mermaid_textures: RefCell::new(LruCache::new(Self::MERMAID_TEXTURE_CACHE_CAPACITY)),
            #[cfg(feature = "mermaid-quickjs")]
            mermaid_pending: RefCell::new(HashSet::new()),
            #[cfg(feature = "mermaid-quickjs")]
            mermaid_frame_pending: Cell::new(false),
            #[cfg(feature = "mermaid-quickjs")]
            mermaid_svg_cache: RefCell::new(LruCache::new(Self::MERMAID_SVG_CACHE_CAPACITY)),
            #[cfg(feature = "mermaid-quickjs")]
            mermaid_errors: RefCell::new(LruCache::new(Self::MERMAID_ERROR_CACHE_CAPACITY)),
            #[cfg(feature = "mermaid-quickjs")]
            mermaid_texture_errors: RefCell::new(LruCache::new(
                Self::MERMAID_TEXTURE_ERROR_CACHE_CAPACITY,
            )),
            #[cfg(feature = "mermaid-quickjs")]
            mermaid_job_tx: Some(mermaid_job_tx),
            #[cfg(feature = "mermaid-quickjs")]
            mermaid_result_rx,
            #[cfg(feature = "mermaid-quickjs")]
            worker_handles,
        }
    }

    fn default_mermaid_preference() -> MermaidRenderPreference {
        #[cfg(feature = "mermaid-quickjs")]
        {
            MermaidRenderPreference::Embedded
        }
        #[cfg(not(feature = "mermaid-quickjs"))]
        {
            MermaidRenderPreference::Off
        }
    }

    fn mermaid_renderer_preference() -> (MermaidRenderPreference, bool) {
        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_RENDERER") {
            let normalized = raw.trim().to_ascii_lowercase();
            return match normalized.as_str() {
                "off" => (MermaidRenderPreference::Off, true),
                "embedded" => (MermaidRenderPreference::Embedded, true),
                _ => (Self::default_mermaid_preference(), false),
            };
        }
        (Self::default_mermaid_preference(), false)
    }

    pub(crate) fn has_pending(&self) -> bool {
        #[cfg(feature = "mermaid-quickjs")]
        {
            return self.mermaid_frame_pending.get() || !self.mermaid_pending.borrow().is_empty();
        }
        #[cfg(not(feature = "mermaid-quickjs"))]
        {
            false
        }
    }

    pub(crate) fn begin_frame(&self) {
        #[cfg(feature = "mermaid-quickjs")]
        self.mermaid_frame_pending.set(false);
    }

    pub(crate) fn render_block(
        &self,
        ui: &mut egui::Ui,
        code: &str,
        ui_scale: f32,
        code_font_size: f32,
    ) -> bool {
        let (preference, _explicit) = Self::mermaid_renderer_preference();

        #[cfg(not(feature = "mermaid-quickjs"))]
        {
            let _ = code;
            let _ = ui_scale;
        }

        if preference == MermaidRenderPreference::Off {
            egui::Frame::none()
                .fill(Color32::from_rgb(25, 25, 25))
                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
                .inner_margin(8.0)
                .show(ui, |ui| {
                    ui.label(
                        RichText::new(
                            "Mermaid rendering is disabled. Set MDMDVIEW_MERMAID_RENDERER=embedded to enable.",
                        )
                        .color(Color32::from_rgb(200, 160, 80))
                        .family(egui::FontFamily::Monospace)
                        .size(code_font_size),
                    );
                    ui.add_space(6.0);
                    ui.label(
                        RichText::new(code)
                            .family(egui::FontFamily::Monospace)
                            .size(code_font_size)
                            .color(Color32::from_rgb(180, 180, 180)),
                    );
                });
            return true;
        }

        #[cfg(not(feature = "mermaid-quickjs"))]
        if _explicit && preference == MermaidRenderPreference::Embedded {
            egui::Frame::none()
                .fill(Color32::from_rgb(25, 25, 25))
                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
                .inner_margin(8.0)
                .show(ui, |ui| {
                    ui.label(
                        RichText::new(
                            "Mermaid rendering via embedded JS is unavailable (feature not enabled).",
                        )
                        .color(Color32::from_rgb(200, 160, 80))
                        .family(egui::FontFamily::Monospace)
                        .size(code_font_size),
                    );
                    ui.add_space(6.0);
                    ui.label(
                        RichText::new(code)
                            .family(egui::FontFamily::Monospace)
                            .size(code_font_size)
                            .color(Color32::from_rgb(180, 180, 180)),
                    );
                });
            return true;
        }

        #[cfg(feature = "mermaid-quickjs")]
        {
            if mermaid_js_empty() {
                egui::Frame::none()
                    .fill(Color32::from_rgb(25, 25, 25))
                    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
                    .inner_margin(8.0)
                    .show(ui, |ui| {
                        ui.label(
                            RichText::new(
                                "Mermaid rendering is unavailable (embedded JS missing).",
                            )
                            .color(Color32::from_rgb(200, 160, 80))
                            .family(egui::FontFamily::Monospace)
                            .size(code_font_size),
                        );
                        ui.add_space(6.0);
                        ui.label(
                            RichText::new(code)
                                .family(egui::FontFamily::Monospace)
                                .size(code_font_size)
                                .color(Color32::from_rgb(180, 180, 180)),
                        );
                    });
                return true;
            }
            let svg_key = Self::hash_str(code);
            let mut available_width = ui.available_width();
            let orig_available_width = available_width;
            if available_width <= Self::MERMAID_WIDTH_BUCKET_STEP as f32 {
                let fallback = ui.ctx().available_rect().width();
                if fallback > available_width {
                    available_width = fallback;
                }
            }
            if std::env::var("MDMDVIEW_MERMAID_LOG_WIDTH").is_ok() {
                eprintln!(
                    "Mermaid width: avail={:.2} fallback={:.2}",
                    orig_available_width, available_width
                );
            }
            let width_bucket = Self::width_bucket(available_width);
            let scale_bucket = Self::scale_bucket(ui_scale);
            let mut viewport_width = available_width.round().max(1.0) as u32;
            let mut viewport_height = ui
                .ctx()
                .input(|i| i.screen_rect().height())
                .round()
                .max(1.0) as u32;
            if let Some(kind) = Self::mermaid_diagram_kind(code) {
                if kind == "timeline" {
                    viewport_width = viewport_width.min(1000);
                    viewport_height = viewport_height.min(700);
                }
            }
            let bg = Self::mermaid_bg_fill();
            let texture_key = Self::texture_key(svg_key, width_bucket, scale_bucket, bg);

            if self.poll_mermaid_results(ui.ctx()) {
                ui.ctx().request_repaint();
            }

            if let Some(entry) = self.mermaid_textures.borrow_mut().get(&texture_key) {
                let (tw, th) = (entry.size[0] as f32, entry.size[1] as f32);
                let available_w = ui.available_width().max(1.0);
                let scale = if tw > available_w {
                    (available_w / tw).clamp(0.01, 4.0)
                } else {
                    1.0
                };
                let size = egui::vec2((tw * scale).round(), (th * scale).round());
                ui.add(egui::Image::new(&entry.texture).fit_to_exact_size(size));
                return true;
            }

            let svg_error = self.mermaid_errors.borrow_mut().get(&svg_key);
            let texture_error = self.mermaid_texture_errors.borrow_mut().get(&texture_key);
            if let Some(err) = svg_error.or(texture_error) {
                egui::Frame::none()
                    .fill(Color32::from_rgb(25, 25, 25))
                    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
                    .inner_margin(8.0)
                    .show(ui, |ui| {
                        ui.label(
                            RichText::new("Mermaid render failed; showing source.")
                                .color(Color32::from_rgb(200, 160, 80)),
                        );
                        ui.label(
                            RichText::new(format!(
                                "Embedded bytes:{}\nHash:{:016x}\nError:{}",
                                mermaid_embed::MERMAID_JS.len(),
                                svg_key,
                                err
                            ))
                            .family(egui::FontFamily::Monospace)
                            .size(code_font_size)
                            .color(Color32::from_rgb(180, 180, 180)),
                        );
                        ui.add_space(6.0);
                        ui.label(
                            RichText::new(code)
                                .family(egui::FontFamily::Monospace)
                                .size(code_font_size)
                                .color(Color32::from_rgb(180, 180, 180)),
                        );
                    });
                return true;
            }
            let svg = self.mermaid_svg_cache.borrow_mut().get(&svg_key);
            let pending = self.mermaid_pending.borrow().contains(&texture_key);
            let mut waiting_for_slot = false;

            if !pending {
                let (request_code, request_svg) = match svg {
                    Some(svg) => (None, Some(svg)),
                    None => (Some(code.to_string()), None),
                };
                let request = MermaidRequest {
                    svg_key,
                    texture_key: texture_key.clone(),
                    code: request_code,
                    svg: request_svg,
                    width_bucket,
                    scale_bucket,
                    viewport_width,
                    viewport_height,
                    bg,
                };
                match self.enqueue_mermaid_job(request) {
                    Ok(()) => {
                        self.mermaid_pending
                            .borrow_mut()
                            .insert(texture_key.clone());
                        ui.ctx().request_repaint();
                    }
                    Err(MermaidEnqueueError::QueueFull) => {
                        waiting_for_slot = true;
                        ui.ctx().request_repaint();
                    }
                    Err(MermaidEnqueueError::Disconnected) => {
                        self.mermaid_errors
                            .borrow_mut()
                            .insert(svg_key, "Mermaid worker pool unavailable".to_string());
                        egui::Frame::none()
                            .fill(Color32::from_rgb(25, 25, 25))
                            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
                            .inner_margin(8.0)
                            .show(ui, |ui| {
                                ui.label(
                                    RichText::new("Mermaid worker pool unavailable.")
                                        .color(Color32::from_rgb(200, 160, 80))
                                        .family(egui::FontFamily::Monospace)
                                        .size(code_font_size),
                                );
                                ui.add_space(6.0);
                                ui.label(
                                    RichText::new(code)
                                        .family(egui::FontFamily::Monospace)
                                        .size(code_font_size)
                                        .color(Color32::from_rgb(180, 180, 180)),
                                );
                            });
                        return true;
                    }
                }
            }

            let inflight = self.mermaid_pending.borrow().len();
            self.mermaid_frame_pending.set(true);
            egui::Frame::none()
                .fill(Color32::from_rgb(25, 25, 25))
                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
                .inner_margin(8.0)
                .show(ui, |ui| {
                    // Reserve minimum height for placeholder to reduce layout shift
                    // when the actual diagram renders. Most diagrams are 150-400px tall.
                    ui.set_min_height(Self::MERMAID_PLACEHOLDER_MIN_HEIGHT);
                    if waiting_for_slot {
                        ui.label(
                            RichText::new(format!(
                                "Mermaid workers busy ({}/{}) - request queued.",
                                inflight,
                                Self::MAX_MERMAID_JOBS
                            ))
                            .color(Color32::from_rgb(200, 160, 80))
                            .family(egui::FontFamily::Monospace)
                            .size(code_font_size),
                        );
                    } else {
                        ui.label(
                            RichText::new("Rendering diagram locally...")
                                .color(Color32::from_rgb(160, 200, 240)),
                        );
                    }
                });
            true
        }
        #[cfg(not(feature = "mermaid-quickjs"))]
        {
            false
        }
    }

    #[cfg(any(test, feature = "mermaid-quickjs"))]
    fn width_bucket(available_width: f32) -> u32 {
        let step = Self::MERMAID_WIDTH_BUCKET_STEP;
        let width = available_width.max(1.0).ceil() as u32;
        width.div_ceil(step) * step
    }

    #[cfg(any(test, feature = "mermaid-quickjs"))]
    fn scale_bucket(ui_scale: f32) -> u32 {
        let clamped = ui_scale.clamp(0.5, 4.0);
        (clamped * Self::MERMAID_SCALE_BUCKET_FACTOR).round() as u32
    }

    fn mermaid_diagram_kind(code: &str) -> Option<String> {
        for line in code.lines() {
            let trimmed = line.trim();
            if trimmed.is_empty() {
                continue;
            }
            if trimmed.starts_with("%%") {
                continue;
            }
            return trimmed
                .split_whitespace()
                .next()
                .map(|token| token.to_ascii_lowercase());
        }
        None
    }

    #[cfg(feature = "mermaid-quickjs")]
    fn scale_from_bucket(scale_bucket: u32) -> f32 {
        let scale = scale_bucket as f32 / Self::MERMAID_SCALE_BUCKET_FACTOR;
        scale.clamp(0.5, 4.0)
    }

    #[cfg(any(test, feature = "mermaid-quickjs"))]
    fn mermaid_bg_key(bg: Option<[u8; 4]>) -> String {
        match bg {
            Some([r, g, b, a]) => format!("{:02x}{:02x}{:02x}{:02x}", r, g, b, a),
            None => "none".to_string(),
        }
    }

    #[cfg(any(test, feature = "mermaid-quickjs"))]
    fn texture_key(
        svg_key: u64,
        width_bucket: u32,
        scale_bucket: u32,
        bg: Option<[u8; 4]>,
    ) -> String {
        let bg_key = Self::mermaid_bg_key(bg);
        format!(
            "mermaid:{:016x}:w{}:s{}:bg{}",
            svg_key, width_bucket, scale_bucket, bg_key
        )
    }

    #[cfg(feature = "mermaid-quickjs")]
    fn poll_mermaid_results(&self, ctx: &egui::Context) -> bool {
        let mut changed = false;
        while let Ok(result) = self.mermaid_result_rx.try_recv() {
            let MermaidResult {
                svg_key,
                texture_key,
                svg,
                rgba,
                size,
                error,
            } = result;
            let has_svg = svg.is_some();
            self.mermaid_pending.borrow_mut().remove(&texture_key);

            if let Some(svg) = svg {
                self.mermaid_svg_cache.borrow_mut().insert(svg_key, svg);
                self.mermaid_errors.borrow_mut().remove(&svg_key);
            }

            if let Some(rgba) = rgba {
                if let Some((w, h)) = size {
                    let img =
                        egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &rgba);
                    let tex =
                        ctx.load_texture(texture_key.clone(), img, egui::TextureOptions::LINEAR);
                    self.store_mermaid_texture(&texture_key, tex.clone(), [w, h]);
                    self.mermaid_texture_errors
                        .borrow_mut()
                        .remove(&texture_key);
                } else {
                    self.mermaid_texture_errors.borrow_mut().insert(
                        texture_key.clone(),
                        "Mermaid rasterization failed (missing size)".to_string(),
                    );
                }
            }

            if let Some(err) = error {
                if !has_svg {
                    self.mermaid_errors.borrow_mut().insert(svg_key, err);
                } else {
                    self.mermaid_texture_errors
                        .borrow_mut()
                        .insert(texture_key, err);
                }
            }

            changed = true;
        }
        changed
    }

    #[cfg(feature = "mermaid-quickjs")]
    fn enqueue_mermaid_job(&self, request: MermaidRequest) -> Result<(), MermaidEnqueueError> {
        let Some(ref tx) = self.mermaid_job_tx else {
            return Err(MermaidEnqueueError::Disconnected);
        };
        match tx.try_send(request) {
            Ok(()) => Ok(()),
            Err(TrySendError::Full(_)) => Err(MermaidEnqueueError::QueueFull),
            Err(TrySendError::Disconnected(_)) => Err(MermaidEnqueueError::Disconnected),
        }
    }

    #[cfg(feature = "mermaid-quickjs")]
    fn mermaid_worker_count() -> usize {
        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_WORKERS") {
            if let Ok(value) = raw.trim().parse::<usize>() {
                return value.clamp(1, 16);
            }
        }
        let default = std::thread::available_parallelism()
            .map(|n| n.get())
            .unwrap_or(1);
        default.min(Self::MAX_MERMAID_JOBS.max(1))
    }

    #[cfg(feature = "mermaid-quickjs")]
    fn mermaid_timeout_ms() -> u64 {
        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_TIMEOUT_MS") {
            if let Ok(value) = raw.trim().parse::<u64>() {
                return value.max(100);
            }
        }
        30_000
    }

    #[cfg(feature = "mermaid-quickjs")]
    fn spawn_mermaid_worker_thread(
        worker_idx: usize,
        worker_rx: MermaidJobReceiver,
        worker_tx: MermaidResultSender,
        worker_fontdb: Arc<usvg::fontdb::Database>,
    ) -> std::io::Result<JoinHandle<()>> {
        #[cfg(test)]
        if FORCE_MERMAID_THREAD_SPAWN_ERROR.swap(false, Ordering::Relaxed) {
            return Err(std::io::Error::other("forced mermaid spawn error"));
        }
        std::thread::Builder::new()
            .name(format!("mdmdview-mermaid-{worker_idx}"))
            .spawn(move || {
                let mut worker = MermaidWorker::new(worker_idx, worker_fontdb).map_err(|e| {
                    eprintln!("Mermaid worker init failed: {}", e);
                    e
                });
                for job in worker_rx.iter() {
                    let payload = match &mut worker {
                        Ok(state) => state.process_job(job),
                        Err(err) => {
                            let MermaidRequest {
                                svg_key,
                                texture_key,
                                svg,
                                ..
                            } = job;
                            MermaidResult {
                                svg_key,
                                texture_key,
                                svg,
                                rgba: None,
                                size: None,
                                error: Some(err.clone()),
                            }
                        }
                    };
                    let _ = worker_tx.send(payload);
                }
            })
    }

    #[cfg(feature = "mermaid-quickjs")]
    fn spawn_mermaid_workers(
        job_rx: MermaidJobReceiver,
        result_tx: MermaidResultSender,
    ) -> Vec<JoinHandle<()>> {
        let worker_count = Self::mermaid_worker_count();
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = Arc::new(fontdb);
        let mut handles = Vec::with_capacity(worker_count);
        for worker_idx in 0..worker_count {
            let worker_rx = job_rx.clone();
            let worker_tx = result_tx.clone();
            let worker_fontdb = Arc::clone(&fontdb);
            match Self::spawn_mermaid_worker_thread(worker_idx, worker_rx, worker_tx, worker_fontdb)
            {
                Ok(handle) => handles.push(handle),
                Err(err) => eprintln!("Failed to start Mermaid worker thread: {}", err),
            }
        }
        drop(job_rx);
        handles
    }

    #[cfg(feature = "mermaid-quickjs")]
    fn store_mermaid_texture(&self, key: &str, texture: egui::TextureHandle, size: [u32; 2]) {
        self.mermaid_textures
            .borrow_mut()
            .insert(key.to_string(), MermaidTextureEntry { texture, size });
    }

    #[cfg(feature = "mermaid-quickjs")]
    fn mermaid_theme_values() -> MermaidThemeValues {
        let def_main_bkg = "#FFF8DB";
        let def_primary = "#D7EEFF";
        let def_primary_border = "#9BB2C8";
        let def_primary_text = "#1C2430";
        let def_secondary = "#DFF5E1";
        let def_tertiary = "#E9E2FF";
        let def_line = "#6B7A90";
        let def_text = "#1C2430";
        let def_cluster_bkg = "#FFF1C1";
        let def_cluster_border = "#E5C07B";
        let def_default_link = def_line;
        let def_title = def_text;
        let def_label_bg = def_main_bkg;
        let def_edge_label_bg = def_main_bkg;

        let theme_name =
            std::env::var("MDMDVIEW_MERMAID_THEME").unwrap_or_else(|_| "base".to_string());
        let main_bkg =
            std::env::var("MDMDVIEW_MERMAID_MAIN_BKG").unwrap_or_else(|_| def_main_bkg.to_string());
        let primary = std::env::var("MDMDVIEW_MERMAID_PRIMARY_COLOR")
            .unwrap_or_else(|_| def_primary.to_string());
        let primary_border = std::env::var("MDMDVIEW_MERMAID_PRIMARY_BORDER")
            .unwrap_or_else(|_| def_primary_border.to_string());
        let primary_text = std::env::var("MDMDVIEW_MERMAID_PRIMARY_TEXT")
            .unwrap_or_else(|_| def_primary_text.to_string());
        let secondary = std::env::var("MDMDVIEW_MERMAID_SECONDARY_COLOR")
            .unwrap_or_else(|_| def_secondary.to_string());
        let tertiary = std::env::var("MDMDVIEW_MERMAID_TERTIARY_COLOR")
            .unwrap_or_else(|_| def_tertiary.to_string());
        let line =
            std::env::var("MDMDVIEW_MERMAID_LINE_COLOR").unwrap_or_else(|_| def_line.to_string());
        let text =
            std::env::var("MDMDVIEW_MERMAID_TEXT_COLOR").unwrap_or_else(|_| def_text.to_string());
        let cluster_bkg = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BKG")
            .unwrap_or_else(|_| def_cluster_bkg.to_string());
        let cluster_border = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BORDER")
            .unwrap_or_else(|_| def_cluster_border.to_string());
        let default_link = std::env::var("MDMDVIEW_MERMAID_LINK_COLOR")
            .unwrap_or_else(|_| def_default_link.to_string());
        let title =
            std::env::var("MDMDVIEW_MERMAID_TITLE_COLOR").unwrap_or_else(|_| def_title.to_string());
        let label_bg =
            std::env::var("MDMDVIEW_MERMAID_LABEL_BG").unwrap_or_else(|_| def_label_bg.to_string());
        let edge_label_bg = std::env::var("MDMDVIEW_MERMAID_EDGE_LABEL_BG")
            .unwrap_or_else(|_| def_edge_label_bg.to_string());
        let font_family = std::env::var("MDMDVIEW_MERMAID_FONT_FAMILY")
            .ok()
            .map(|value| value.trim().to_string())
            .filter(|value| !value.is_empty());

        MermaidThemeValues {
            theme_name,
            main_bkg,
            primary,
            primary_border,
            primary_text,
            secondary,
            tertiary,
            line,
            text,
            cluster_bkg,
            cluster_border,
            default_link,
            title,
            label_bg,
            edge_label_bg,
            font_family,
        }
    }

    #[cfg(any(test, feature = "mermaid-quickjs"))]
    fn mermaid_security_level() -> String {
        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_SECURITY") {
            let normalized = raw.trim().to_ascii_lowercase();
            if normalized == "loose" {
                return "loose".to_string();
            }
        }
        "strict".to_string()
    }

    #[cfg(feature = "mermaid-quickjs")]
    fn mermaid_site_config_json(svg_key: u64) -> String {
        let theme = Self::mermaid_theme_values();
        let security = Self::mermaid_security_level();
        let seed = format!("m{:016x}", svg_key);
        let mut entries = Vec::new();

        entries.push("\"startOnLoad\":false".to_string());
        entries.push(format!(
            "\"securityLevel\":\"{}\"",
            Self::json_escape(&security)
        ));
        entries.push("\"deterministicIds\":true".to_string());
        entries.push(format!(
            "\"deterministicIDSeed\":\"{}\"",
            Self::json_escape(&seed)
        ));
        entries.push(format!("\"maxTextSize\":{}", Self::MERMAID_MAX_TEXT_SIZE));
        if security == "strict" {
            entries.push("\"htmlLabels\":false".to_string());
            entries.push("\"flowchart\":{\"htmlLabels\":false}".to_string());
        }
        entries.push(format!(
            "\"theme\":\"{}\"",
            Self::json_escape(&theme.theme_name)
        ));

        let mut theme_vars = format!(
            concat!(
                "\"background\":\"{}\",",
                "\"mainBkg\":\"{}\",",
                "\"textColor\":\"{}\",",
                "\"titleColor\":\"{}\",",
                "\"primaryColor\":\"{}\",",
                "\"primaryBorderColor\":\"{}\",",
                "\"primaryTextColor\":\"{}\",",
                "\"secondaryColor\":\"{}\",",
                "\"tertiaryColor\":\"{}\",",
                "\"lineColor\":\"{}\",",
                "\"defaultLinkColor\":\"{}\",",
                "\"clusterBkg\":\"{}\",",
                "\"clusterBorder\":\"{}\",",
                "\"labelBackground\":\"{}\",",
                "\"edgeLabelBackground\":\"{}\""
            ),
            Self::json_escape(&theme.main_bkg),
            Self::json_escape(&theme.main_bkg),
            Self::json_escape(&theme.text),
            Self::json_escape(&theme.title),
            Self::json_escape(&theme.primary),
            Self::json_escape(&theme.primary_border),
            Self::json_escape(&theme.primary_text),
            Self::json_escape(&theme.secondary),
            Self::json_escape(&theme.tertiary),
            Self::json_escape(&theme.line),
            Self::json_escape(&theme.default_link),
            Self::json_escape(&theme.cluster_bkg),
            Self::json_escape(&theme.cluster_border),
            Self::json_escape(&theme.label_bg),
            Self::json_escape(&theme.edge_label_bg)
        );
        if let Some(font_family) = theme.font_family.as_ref() {
            theme_vars.push_str(&format!(
                ",\"fontFamily\":\"{}\"",
                Self::json_escape(font_family)
            ));
        }
        entries.push(format!("\"themeVariables\":{{{}}}", theme_vars));

        format!("{{{}}}", entries.join(","))
    }

    #[cfg(feature = "mermaid-quickjs")]
    fn json_escape(input: &str) -> String {
        let mut out = String::with_capacity(input.len());
        for ch in input.chars() {
            match ch {
                '\\' => out.push_str("\\\\"),
                '"' => out.push_str("\\\""),
                '\n' => out.push_str("\\n"),
                '\r' => out.push_str("\\r"),
                '\t' => out.push_str("\\t"),
                _ => out.push(ch),
            }
        }
        out
    }

    #[cfg(any(test, feature = "mermaid-quickjs"))]
    fn mermaid_bg_fill() -> Option<[u8; 4]> {
        if let Ok(hex) = std::env::var("MDMDVIEW_MERMAID_BG_COLOR") {
            if let Some(rgba) = Self::parse_hex_color(&hex) {
                return Some(rgba);
            }
        }
        let mode = std::env::var("MDMDVIEW_MERMAID_BG").unwrap_or_else(|_| "theme".to_string());
        match mode.as_str() {
            "transparent" => None,
            "dark" => Some([20, 20, 20, 255]),
            "light" => Some([255, 255, 255, 255]),
            _ => {
                let hex = std::env::var("MDMDVIEW_MERMAID_MAIN_BKG")
                    .unwrap_or_else(|_| "#FFF8DB".to_string());
                Self::parse_hex_color(&hex).or(Some([255, 248, 219, 255]))
            }
        }
    }

    #[cfg(any(test, feature = "mermaid-quickjs"))]
    fn parse_hex_color(s: &str) -> Option<[u8; 4]> {
        let t = s.trim();
        let hex = t.strip_prefix('#').unwrap_or(t);
        let (r, g, b, a) = match hex.len() {
            6 => (
                u8::from_str_radix(&hex[0..2], 16).ok()?,
                u8::from_str_radix(&hex[2..4], 16).ok()?,
                u8::from_str_radix(&hex[4..6], 16).ok()?,
                255,
            ),
            8 => (
                u8::from_str_radix(&hex[0..2], 16).ok()?,
                u8::from_str_radix(&hex[2..4], 16).ok()?,
                u8::from_str_radix(&hex[4..6], 16).ok()?,
                u8::from_str_radix(&hex[6..8], 16).ok()?,
            ),
            _ => return None,
        };
        Some([r, g, b, a])
    }

    #[cfg(any(test, feature = "mermaid-quickjs"))]
    fn hash_str(s: &str) -> u64 {
        let mut h = DefaultHasher::new();
        s.hash(&mut h);
        h.finish()
    }
}

#[cfg(feature = "mermaid-quickjs")]
impl Drop for MermaidRenderer {
    fn drop(&mut self) {
        // First, drop the job sender to close the channel.
        // This signals workers to exit their `for job in worker_rx.iter()` loop.
        drop(self.mermaid_job_tx.take());

        // Now join all worker threads to ensure they've fully exited
        // and released their resources (font database, QuickJS runtime).
        for handle in self.worker_handles.drain(..) {
            let _ = handle.join();
        }
    }
}

#[cfg(feature = "mermaid-quickjs")]
struct TextMeasurer {
    fontdb: Arc<usvg::fontdb::Database>,
    face_id: Option<usvg::fontdb::ID>,
    bold_face_id: Option<usvg::fontdb::ID>,
}

#[cfg(feature = "mermaid-quickjs")]
impl TextMeasurer {
    const BOLD_WIDTH_FALLBACK: f32 = 1.07;
    const BOLD_WIDTH_SCALE: f32 = 1.03;
    const LINE_HEIGHT_SCALE: f32 = 1.0;

    fn new(fontdb: Arc<usvg::fontdb::Database>) -> Self {
        let families = [
            usvg::fontdb::Family::Name("Trebuchet MS"),
            usvg::fontdb::Family::Name("Verdana"),
            usvg::fontdb::Family::Name("Arial"),
            usvg::fontdb::Family::SansSerif,
        ];
        let query = usvg::fontdb::Query {
            families: &families,
            ..Default::default()
        };
        let face_id = fontdb.query(&query);
        let bold_query = usvg::fontdb::Query {
            families: &families,
            weight: usvg::fontdb::Weight::BOLD,
            ..Default::default()
        };
        let bold_face_id = fontdb.query(&bold_query).or(face_id);
        Self {
            fontdb,
            face_id,
            bold_face_id,
        }
    }

    fn measure_text(&self, text: &str, font_size: f32, font_weight: Option<f32>) -> (f32, f32) {
        if text.is_empty() {
            return (0.0, 0.0);
        }
        let size = if font_size.is_finite() && font_size > 0.0 {
            font_size
        } else {
            16.0
        };
        let use_bold = font_weight.unwrap_or(400.0) >= 600.0;
        let face_id = if use_bold {
            self.bold_face_id.or(self.face_id)
        } else {
            self.face_id
        };
        if let Some((width, height)) = self.measure_with_face(face_id, text, size) {
            if use_bold {
                let mut adjusted = width * Self::BOLD_WIDTH_SCALE;
                if self.bold_face_id == self.face_id {
                    adjusted *= Self::BOLD_WIDTH_FALLBACK;
                }
                return (adjusted, height);
            }
            return (width, height);
        }
        Self::fallback_measure(text, size)
    }

    fn measure_with_face(
        &self,
        face_id: Option<usvg::fontdb::ID>,
        text: &str,
        font_size: f32,
    ) -> Option<(f32, f32)> {
        let face_id = face_id?;
        self.fontdb
            .with_face_data(face_id, |data, index| {
                let face = face_parse_for_test(data, index)?;
                let units_per_em = face.units_per_em().max(1) as f32;
                let scale = font_size / units_per_em;
                let fallback_advance = units_per_em * 0.5;
                let kern_subtables: Vec<_> = face
                    .tables()
                    .kern
                    .map(|kern| {
                        kern.subtables
                            .into_iter()
                            .filter(|table| table.horizontal)
                            .collect()
                    })
                    .unwrap_or_default();
                let mut max_width_units = 0.0_f32;
                let mut line_count = 0u32;

                for line in text.split('\n') {
                    line_count += 1;
                    let mut width_units = 0.0_f32;
                    let mut prev = None;
                    for ch in line.chars() {
                        if let Some(glyph) = face.glyph_index(ch) {
                            if let Some(prev_glyph) = prev {
                                let mut kern = 0.0_f32;
                                for table in &kern_subtables {
                                    if let Some(value) = table.glyphs_kerning(prev_glyph, glyph) {
                                        kern += value as f32;
                                    }
                                }
                                width_units += kern;
                            }
                            width_units += face
                                .glyph_hor_advance(glyph)
                                .map(|adv| adv as f32)
                                .unwrap_or(fallback_advance);
                            prev = Some(glyph);
                        } else {
                            width_units += fallback_advance;
                            prev = None;
                        }
                    }
                    max_width_units = max_width_units.max(width_units);
                }

                let ascender = face.ascender() as f32;
                let descender = face.descender() as f32;
                let line_gap = face.line_gap() as f32;
                let line_height_units = (ascender - descender + line_gap).max(units_per_em);
                let line_height = line_height_units * scale * Self::LINE_HEIGHT_SCALE;
                let width = max_width_units * scale;
                let height = line_height * line_count as f32;
                Some((width, height))
            })
            .flatten()
    }

    fn fallback_measure(text: &str, font_size: f32) -> (f32, f32) {
        let mut max_len = 0usize;
        let mut lines = 0usize;
        for line in text.split('\n') {
            lines += 1;
            let len = line.chars().count();
            if len > max_len {
                max_len = len;
            }
        }
        let width = max_len as f32 * font_size * 0.5;
        let height = lines as f32 * font_size * 1.2;
        (width, height)
    }
}

#[cfg(feature = "mermaid-quickjs")]
struct MermaidWorker {
    engine: MermaidEngine,
    deadline_ms: Arc<AtomicU64>,
    fontdb: Arc<usvg::fontdb::Database>,
    #[allow(dead_code)]
    text_measurer: Arc<TextMeasurer>,
}

#[cfg(feature = "mermaid-quickjs")]
impl MermaidWorker {
    const MEMORY_LIMIT_BYTES: usize = 2 * 1024 * 1024 * 1024;
    const STACK_LIMIT_BYTES: usize = 4 * 1024 * 1024;

    // DOMPurify expects a real browser DOM; stub sanitize for the QuickJS shim.
    fn patch_mermaid_js(js: &str) -> String {
        const TARGET: &str = "var hD=wRe();";
        const PATCH: &str =
            "var hD=wRe();if(!hD||typeof hD.sanitize!==\"function\"){hD={sanitize:function(html){return String(html);},addHook:function(){},removeHook:function(){},removeHooks:function(){},removeAllHooks:function(){},isSupported:true};}";
        const D3_TARGET: &str = "FY.prototype={constructor:FY,appendChild:function(i){return this._parent.insertBefore(i,this._next)},insertBefore:function(i,s){return this._parent.insertBefore(i,s)},querySelector:function(i){return this._parent.querySelector(i)},querySelectorAll:function(i){return this._parent.querySelectorAll(i)}};";
        const D3_PATCH: &str = "FY.prototype={constructor:FY,appendChild:function(i){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p?p.insertBefore(i,this._next):i},insertBefore:function(i,s){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p?p.insertBefore(i,s):i},querySelector:function(i){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p&&p.querySelector?p.querySelector(i):null},querySelectorAll:function(i){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p&&p.querySelectorAll?p.querySelectorAll(i):[]}};";
        const D3_CTOR_TARGET: &str =
            "function FY(i,s){this.ownerDocument=i.ownerDocument,this.namespaceURI=i.namespaceURI,this._next=null,this._parent=i,this.__data__=s}";
        const D3_CTOR_PATCH: &str =
            "function FY(i,s){i=i||((typeof document!==\"undefined\"&&document.body)?document.body:null);this.ownerDocument=i&&i.ownerDocument?i.ownerDocument:(typeof document!==\"undefined\"?document:null);this.namespaceURI=i&&i.namespaceURI?i.namespaceURI:null;this._next=null;this._parent=i;this.__data__=s}";
        const TEXT_WRAP_TARGET: &str = "u.text().split(/(\\s+|<br>)/).reverse()";
        const TEXT_WRAP_PATCH: &str = concat!(
            "String(typeof u.text===\"function\"?u.text():(u.textContent||\"\"))",
            ".split(/(\\s+|<br>)/).reverse()"
        );
        const MINDMAP_LAYOUT_TARGET: &str =
            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
        const MINDMAP_LAYOUT_PATCH: &str =
            "p.layout({name:\"breadthfirst\",directed:!0,spacingFactor:1.4,animate:!1}).run()";
        const MINDMAP_READY_TARGET: &str =
            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run(),p.ready(v=>{Xe.info(\"Ready\",v),u(p)})";
        const MINDMAP_READY_PATCH: &str =
            "p.layout({name:\"breadthfirst\",directed:!0,spacingFactor:1.4,animate:!1}).run(),u(p)";
        const MINDMAP_CYTO_TARGET: &str =
            "p=fWe({container:document.getElementById(\"cy\"),style:[{selector:\"edge\",style:{\"curve-style\":\"bezier\"}}]});";
        const MINDMAP_CYTO_PATCH: &str =
            "p=__mdmdview_cytoscape_stub({container:document.getElementById(\"cy\")});";
        const TIMELINE_BOUNDS_TARGET: &str = "const se=_.node().getBBox();";
        const TIMELINE_BOUNDS_PATCH: &str = concat!(
            "const se=_.node().getBBox();",
            "if(se&&typeof se.width===\"number\"&&typeof v===\"number\"){",
            "se.width=Math.max(0,se.width-2*v);",
            "}"
        );
        let mut out = if js.contains(TARGET) {
            js.replacen(TARGET, PATCH, 1)
        } else {
            js.to_string()
        };
        let debug = std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG").is_ok();
        if out.contains(D3_CTOR_TARGET) {
            out = out.replacen(D3_CTOR_TARGET, D3_CTOR_PATCH, 1);
            if debug {
                eprintln!("Mermaid patch: D3 ctor applied");
            }
        } else if debug {
            eprintln!("Mermaid patch: D3 ctor not found");
        }
        if out.contains(D3_TARGET) {
            out = out.replacen(D3_TARGET, D3_PATCH, 1);
            if debug {
                eprintln!("Mermaid patch: D3 enter applied");
            }
        } else if debug {
            eprintln!("Mermaid patch: D3 enter not found");
        }
        if out.contains(TEXT_WRAP_TARGET) {
            out = out.replacen(TEXT_WRAP_TARGET, TEXT_WRAP_PATCH, 1);
            if debug {
                eprintln!("Mermaid patch: D3 text wrap applied");
            }
        } else if debug {
            eprintln!("Mermaid patch: D3 text wrap not found");
        }
        let mut mindmap_layout_patched = false;
        if out.contains(MINDMAP_CYTO_TARGET) {
            out = out.replacen(MINDMAP_CYTO_TARGET, MINDMAP_CYTO_PATCH, 1);
            if debug {
                eprintln!("Mermaid patch: mindmap cytoscape stub applied");
            }
        } else if debug {
            eprintln!("Mermaid patch: mindmap cytoscape stub not found");
        }
        if out.contains(MINDMAP_READY_TARGET) {
            out = out.replacen(MINDMAP_READY_TARGET, MINDMAP_READY_PATCH, 1);
            mindmap_layout_patched = true;
            if debug {
                eprintln!("Mermaid patch: mindmap ready patch applied");
            }
        } else if out.contains(MINDMAP_LAYOUT_TARGET) {
            out = out.replacen(MINDMAP_LAYOUT_TARGET, MINDMAP_LAYOUT_PATCH, 1);
            mindmap_layout_patched = true;
            if debug {
                eprintln!("Mermaid patch: mindmap layout applied");
            }
        }
        if !mindmap_layout_patched && debug {
            eprintln!("Mermaid patch: mindmap layout not found");
        }
        if out.contains(TIMELINE_BOUNDS_TARGET) {
            out = out.replacen(TIMELINE_BOUNDS_TARGET, TIMELINE_BOUNDS_PATCH, 1);
            if debug {
                eprintln!("Mermaid patch: timeline bounds applied");
            }
        } else if debug {
            eprintln!("Mermaid patch: timeline bounds not found");
        }
        out
    }

    fn format_js_error(ctx: &rquickjs::Ctx<'_>, err: rquickjs::Error) -> String {
        if let rquickjs::Error::Exception = err {
            let value = ctx.catch();
            if let Some(exception) = value.as_exception() {
                let message = exception.message().filter(|value| !value.trim().is_empty());
                let stack = exception.stack().filter(|value| !value.trim().is_empty());
                if let Some(stack) = stack {
                    if let Some(message) = &message {
                        if stack.contains(message) {
                            return stack;
                        }
                        return format!("{}\n{}", message, stack);
                    }
                    return stack;
                }
                if let Some(message) = message {
                    return message;
                }
            }
            if let Some(js_string) = value.as_string().and_then(|s| s.to_string().ok()) {
                return js_string;
            }
            if let Some(number) = value.as_int() {
                return number.to_string();
            }
            if let Some(number) = value.as_float() {
                return number.to_string();
            }
            if let Some(flag) = value.as_bool() {
                return flag.to_string();
            }
            return format!("{:?}", value);
        }
        err.to_string()
    }

    fn new(worker_idx: usize, fontdb: Arc<usvg::fontdb::Database>) -> Result<Self, String> {
        use rquickjs::Function;
        if mermaid_js_empty() {
            return Err("No embedded Mermaid JS".to_string());
        }
        #[cfg(test)]
        if FORCE_MERMAID_WORKER_INIT_ERROR.swap(false, Ordering::Relaxed) {
            return Err("Mermaid worker init forced error".to_string());
        }
        let rt =
            runtime_new_for_test().map_err(|e| format!("Mermaid runtime init error: {}", e))?;
        rt.set_memory_limit(Self::MEMORY_LIMIT_BYTES);
        rt.set_max_stack_size(Self::STACK_LIMIT_BYTES);
        let deadline_ms = Arc::new(AtomicU64::new(0));
        let deadline_guard = Arc::clone(&deadline_ms);
        rt.set_interrupt_handler(Some(Box::new(move || {
            let deadline = deadline_guard.load(Ordering::Relaxed);
            if deadline == 0 {
                return false;
            }
            Self::now_ms() >= deadline
        })));
        let ctx =
            context_full_for_test(&rt).map_err(|e| format!("Mermaid context init error: {}", e))?;
        let engine = MermaidEngine { rt, ctx };
        let text_measurer = Arc::new(TextMeasurer::new(Arc::clone(&fontdb)));
        let js =
            mermaid_js_str_for_test().map_err(|_| "Mermaid JS is not valid UTF-8".to_string())?;
        let js = Self::patch_mermaid_js(js);
        let init_result: Result<(), String> = engine.ctx.with(|ctx| {
            let measurer = Arc::clone(&text_measurer);
            let measure_fn = maybe_force_mermaid_init_error(
                1,
                Function::new(
                    ctx.clone(),
                    move |text: String, font_size: f64, font_weight: Option<f64>| {
                        let weight = font_weight.map(|value| value as f32);
                        let (width, height) = measurer.measure_text(&text, font_size as f32, weight);
                        vec![width as f64, height as f64]
                    },
                ),
            )
            .map_err(|err| {
                format!(
                    "Mermaid text measure init error: {}",
                    MermaidWorker::format_js_error(&ctx, err)
                )
            })?;
            maybe_force_mermaid_init_error(2, ctx.globals().set("__mdmdview_measure_text_native", measure_fn))
                .map_err(|err| {
                    format!(
                        "Mermaid text measure init error: {}",
                        MermaidWorker::format_js_error(&ctx, err)
                    )
                })?;
            let eval = |stage: usize, label: &str, source: &str| -> Result<(), String> {
                let result = maybe_force_mermaid_init_error(stage, ctx.eval::<(), _>(source));
                result.map_err(|err| {
                    format!("{}: {}", label, MermaidWorker::format_js_error(&ctx, err))
                })
            };
            eval(3, "Mermaid DOM shim", MERMAID_DOM_SHIM)?;
            eval(4, "Mermaid JS", &js)?;
            eval(5, "Mermaid init", MERMAID_INIT_SNIPPET)?;
            if std::env::var("MDMDVIEW_MERMAID_DOM_DEBUG").is_ok() {
                let dom_ok = ctx
                    .eval::<bool, _>(
                        "var root=document.querySelector('body');var d=document.createElement('div');d.setAttribute('id','__mdmdview_dom_test');root.appendChild(d);var f=document.getElementById('__mdmdview_dom_test');!!(f&&f===d);",
                    )
                    .unwrap_or(false);
                eprintln!("Mermaid DOM debug: {}", dom_ok);
            }
            Ok(())
        });
        Self::map_init_result(init_result)?;
        if worker_idx == 0 {
            eprintln!(
                "Mermaid embedded bytes: {}",
                mermaid_embed::MERMAID_JS.len()
            );
        }
        Ok(Self {
            engine,
            deadline_ms,
            fontdb,
            text_measurer,
        })
    }

    fn render_svg(
        &mut self,
        key: u64,
        code: &str,
        viewport_width: u32,
        viewport_height: u32,
    ) -> Result<String, String> {
        use rquickjs::{promise::MaybePromise, Function};
        let timeout_ms = MermaidRenderer::mermaid_timeout_ms();
        let deadline = Self::now_ms().saturating_add(timeout_ms);
        self.deadline_ms.store(deadline, Ordering::Relaxed);
        let result = self.engine.ctx.with(|ctx| {
            let wrapper = MERMAID_RENDER_WRAPPER;
            let func: Function = eval_mermaid_wrapper(&ctx, wrapper)
                .map_err(|err| MermaidWorker::format_js_error(&ctx, err))?;
            let id = format!("m{:016x}", key);
            let site_config = MermaidRenderer::mermaid_site_config_json(key);
            let maybe: MaybePromise = call_mermaid_render(
                &func,
                (
                    id.as_str(),
                    code,
                    site_config.as_str(),
                    viewport_width,
                    viewport_height,
                ),
            )
            .map_err(|err| MermaidWorker::format_js_error(&ctx, err))?;
            maybe
                .finish::<String>()
                .map_err(|err| MermaidWorker::format_js_error(&ctx, err))
        });
        self.deadline_ms.store(0, Ordering::Relaxed);
        Self::format_render_result(result, deadline, Self::now_ms())
    }

    fn map_init_result(init_result: Result<(), String>) -> Result<(), String> {
        match init_result {
            Ok(()) => Ok(()),
            Err(err) => Err(format!("Mermaid init error: {}", err)),
        }
    }

    fn format_render_result(
        result: Result<String, String>,
        deadline: u64,
        now_ms: u64,
    ) -> Result<String, String> {
        match result {
            Ok(svg) => Ok(svg),
            Err(err) => {
                if now_ms >= deadline {
                    return Err("Mermaid render timed out".to_string());
                }
                Err(format!("Mermaid render error: {}", err))
            }
        }
    }

    fn maybe_dump_svg(svg_key: u64, code: Option<&str>, svg: &str) {
        let dir = match std::env::var("MDMDVIEW_MERMAID_DUMP_DIR") {
            Ok(value) if !value.trim().is_empty() => value,
            _ => return,
        };
        let dir = PathBuf::from(dir);
        if std::fs::create_dir_all(&dir).is_err() {
            return;
        }
        let label = code
            .and_then(|snippet| snippet.lines().next())
            .unwrap_or("mermaid");
        let mut name = String::new();
        for ch in label.chars() {
            if name.len() >= 32 {
                break;
            }
            if ch.is_ascii_alphanumeric() || ch == '-' || ch == '_' {
                name.push(ch);
            } else {
                name.push('_');
            }
        }
        if name.is_empty() {
            name.push_str("mermaid");
        }
        let filename = format!("{:016x}_{}.svg", svg_key, name);
        let path = dir.join(filename);
        let _ = std::fs::write(path, svg);
    }

    fn maybe_dump_error(svg_key: u64, code: Option<&str>, err: &str) {
        let dir = match std::env::var("MDMDVIEW_MERMAID_DUMP_DIR") {
            Ok(value) if !value.trim().is_empty() => value,
            _ => return,
        };
        let dir = PathBuf::from(dir);
        if std::fs::create_dir_all(&dir).is_err() {
            return;
        }
        let label = code
            .and_then(|snippet| snippet.lines().next())
            .unwrap_or("mermaid");
        let mut name = String::new();
        for ch in label.chars() {
            if name.len() >= 32 {
                break;
            }
            if ch.is_ascii_alphanumeric() || ch == '-' || ch == '_' {
                name.push(ch);
            } else {
                name.push('_');
            }
        }
        if name.is_empty() {
            name.push_str("mermaid");
        }
        let filename = format!("{:016x}_{}.err.txt", svg_key, name);
        let path = dir.join(filename);
        let mut payload = String::new();
        payload.push_str("error: ");
        payload.push_str(err);
        payload.push('\n');
        if let Some(code) = code {
            payload.push_str("\n---\n");
            payload.push_str(code);
            payload.push('\n');
        }
        let _ = std::fs::write(path, payload);
    }

    fn normalize_svg_size(svg: &str) -> String {
        let start = match svg.find("<svg") {
            Some(idx) => idx,
            None => return svg.to_string(),
        };
        let end = match svg[start..].find('>') {
            Some(idx) => start + idx,
            None => return svg.to_string(),
        };
        let tag = &svg[start..=end];
        let viewbox = match Self::find_svg_attr(tag, "viewBox") {
            Some(v) => v,
            None => return svg.to_string(),
        };
        let dims = Self::parse_viewbox_dims(&viewbox);
        let (width, height) = match dims {
            Some(pair) => pair,
            None => return svg.to_string(),
        };
        let mut new_tag = tag.to_string();
        let width_attr = Self::find_svg_attr(&new_tag, "width");
        if width_attr
            .as_deref()
            .map(|val| val.trim().ends_with('%'))
            .unwrap_or(true)
        {
            let value = Self::format_dim(width);
            new_tag = if width_attr.is_some() {
                Self::replace_svg_attr(&new_tag, "width", &value)
            } else {
                Self::insert_svg_attr(&new_tag, "width", &value)
            };
        }
        let height_attr = Self::find_svg_attr(&new_tag, "height");
        if height_attr
            .as_deref()
            .map(|val| val.trim().ends_with('%'))
            .unwrap_or(true)
        {
            let value = Self::format_dim(height);
            new_tag = if height_attr.is_some() {
                Self::replace_svg_attr(&new_tag, "height", &value)
            } else {
                Self::insert_svg_attr(&new_tag, "height", &value)
            };
        }
        if new_tag == tag {
            return svg.to_string();
        }
        let mut out = String::with_capacity(svg.len() + 32);
        out.push_str(&svg[..start]);
        out.push_str(&new_tag);
        out.push_str(&svg[end + 1..]);
        out
    }

    fn replace_attr(tag: &str, name: &str, value: &str) -> String {
        let needle = format!("{name}=\"");
        let start = match tag.find(&needle) {
            Some(idx) => idx + needle.len(),
            None => return tag.to_string(),
        };
        let end = match tag[start..].find('"') {
            Some(idx) => start + idx,
            None => return tag.to_string(),
        };
        let mut out = String::with_capacity(tag.len() + value.len());
        out.push_str(&tag[..start]);
        out.push_str(value);
        out.push_str(&tag[end..]);
        out
    }

    fn upsert_attr(tag: &str, name: &str, value: &str) -> String {
        let needle = format!("{name}=\"");
        if tag.contains(&needle) {
            return Self::replace_attr(tag, name, value);
        }
        let insert_at = match tag.rfind('>') {
            Some(pos) => pos,
            None => return tag.to_string(),
        };
        let mut out = String::with_capacity(tag.len() + name.len() + value.len() + 4);
        out.push_str(&tag[..insert_at]);
        out.push(' ');
        out.push_str(name);
        out.push_str("=\"");
        out.push_str(value);
        out.push('"');
        out.push_str(&tag[insert_at..]);
        out
    }

    fn flatten_svg_switches(svg: &str) -> Option<String> {
        if !svg.contains("<switch") {
            return None;
        }
        let mut out = String::with_capacity(svg.len());
        let mut remaining = svg;
        let mut changed = false;
        while let Some(start) = remaining.find("<switch") {
            let (before, after) = remaining.split_at(start);
            out.push_str(before);
            let open_end = match after.find('>') {
                Some(pos) => pos + 1,
                None => {
                    out.push_str(after);
                    remaining = "";
                    break;
                }
            };
            let after_open = &after[open_end..];
            let close_rel = match after_open.find("</switch>") {
                Some(pos) => pos,
                None => {
                    out.push_str(after);
                    remaining = "";
                    break;
                }
            };
            let inner = &after_open[..close_rel];
            let mut inner_out = String::with_capacity(inner.len());
            let mut inner_remaining = inner;
            while let Some(fo_start) = inner_remaining.find("<foreignObject") {
                let (inner_before, inner_after) = inner_remaining.split_at(fo_start);
                inner_out.push_str(inner_before);
                if let Some(fo_end_rel) = inner_after.find("</foreignObject>") {
                    inner_remaining = &inner_after[fo_end_rel + "</foreignObject>".len()..];
                } else {
                    inner_remaining = "";
                    break;
                }
            }
            inner_out.push_str(inner_remaining);
            out.push_str(&inner_out);
            changed = true;
            remaining = &after_open[close_rel + "</switch>".len()..];
        }
        out.push_str(remaining);
        if changed {
            Some(out)
        } else {
            None
        }
    }

    fn fix_journey_section_text(svg: &str, fill: &str) -> Option<String> {
        if !svg.contains("journey-section") {
            return None;
        }
        let mut out = String::with_capacity(svg.len() + 64);
        let mut remaining = svg;
        let mut changed = false;
        while let Some(idx) = remaining.find("<text") {
            let (before, after) = remaining.split_at(idx);
            out.push_str(before);
            let end = match after.find('>') {
                Some(pos) => pos + 1,
                None => {
                    out.push_str(after);
                    remaining = "";
                    break;
                }
            };
            let (tag, rest) = after.split_at(end);
            if tag.contains("journey-section") {
                let mut updated = tag.to_string();
                if let Some(style_start) = updated.find(" style=\"") {
                    let value_start = style_start + " style=\"".len();
                    if let Some(style_end) = updated[value_start..].find('"') {
                        let style_end = value_start + style_end;
                        let mut style = updated[value_start..style_end].to_string();
                        let parts: Vec<&str> = style.split(';').collect();
                        let mut rebuilt: Vec<String> = Vec::new();
                        for part in parts {
                            let trimmed = part.trim();
                            if trimmed.is_empty() {
                                continue;
                            }
                            if trimmed.starts_with("fill:") {
                                continue;
                            }
                            rebuilt.push(trimmed.to_string());
                        }
                        rebuilt.push(format!("fill:{}", fill));
                        style = rebuilt.join(";");
                        updated.replace_range(value_start..style_end, &style);
                        out.push_str(&updated);
                        changed = true;
                    } else {
                        out.push_str(tag);
                    }
                } else {
                    let insert_at = updated.len().saturating_sub(1);
                    updated.insert_str(insert_at, &format!(" style=\"fill:{};\"", fill));
                    out.push_str(&updated);
                    changed = true;
                }
            } else {
                out.push_str(tag);
            }
            remaining = rest;
        }
        out.push_str(remaining);
        if changed {
            Some(out)
        } else {
            None
        }
    }

    fn find_circle_tag(body: &str, class_name: &str) -> Option<(usize, usize, String)> {
        let needle = format!("class=\"{class_name}\"");
        let class_idx = body.find(&needle)?;
        let start = body[..class_idx].rfind("<circle")?;
        let end = body[class_idx..].find('>')? + class_idx + 1;
        Some((start, end, body[start..end].to_string()))
    }

    fn read_r_value(tag: &str) -> Option<String> {
        let needle = "r=\"";
        let start = tag.find(needle)? + needle.len();
        let end = tag[start..].find('"')? + start;
        Some(tag[start..end].to_string())
    }

    fn fix_state_end_circles(svg: &str) -> Option<String> {
        if !svg.contains("state-end") {
            return None;
        }
        let mut out = String::with_capacity(svg.len());
        let mut cursor = 0;
        let mut changed = false;
        while let Some(g_pos_rel) = svg[cursor..].find("<g") {
            let g_pos = cursor + g_pos_rel;
            out.push_str(&svg[cursor..g_pos]);
            let g_end = match svg[g_pos..].find('>') {
                Some(pos) => g_pos + pos + 1,
                None => {
                    out.push_str(&svg[g_pos..]);
                    cursor = svg.len();
                    break;
                }
            };
            let g_tag = &svg[g_pos..g_end];
            let is_end_group = g_tag.contains("root_end") || g_tag.contains("state-end");
            if !is_end_group {
                out.push_str(g_tag);
                cursor = g_end;
                continue;
            }
            let close_rel = match svg[g_end..].find("</g>") {
                Some(pos) => pos,
                None => {
                    out.push_str(&svg[g_pos..]);
                    cursor = svg.len();
                    break;
                }
            };
            let body_end = g_end + close_rel;
            let body = &svg[g_end..body_end];
            let mut body_out = body.to_string();
            if let (
                Some((s_start, s_end, state_end_tag)),
                Some((t_start, t_end, state_start_tag)),
            ) = (
                Self::find_circle_tag(body, "state-end"),
                Self::find_circle_tag(body, "state-start"),
            ) {
                if let (Some(end_r), Some(start_r)) = (
                    Self::read_r_value(&state_end_tag),
                    Self::read_r_value(&state_start_tag),
                ) {
                    let end_val = end_r.parse::<f32>().ok();
                    let start_val = start_r.parse::<f32>().ok();
                    if let (Some(end_val), Some(start_val)) = (end_val, start_val) {
                        if end_val < start_val {
                            let end_dim = Self::format_dim(start_val * 2.0);
                            let start_dim = Self::format_dim(end_val * 2.0);
                            let mut new_end_tag = Self::replace_attr(&state_end_tag, "r", &start_r);
                            let mut new_start_tag =
                                Self::replace_attr(&state_start_tag, "r", &end_r);
                            new_end_tag = Self::upsert_attr(&new_end_tag, "width", &end_dim);
                            new_end_tag = Self::upsert_attr(&new_end_tag, "height", &end_dim);
                            new_start_tag = Self::upsert_attr(&new_start_tag, "width", &start_dim);
                            new_start_tag = Self::upsert_attr(&new_start_tag, "height", &start_dim);
                            new_start_tag = new_start_tag.replace("state-start", "end-state-inner");
                            let mut rebuilt = String::with_capacity(body.len() + 16);
                            let (
                                first_start,
                                first_end,
                                first_tag,
                                second_start,
                                second_end,
                                second_tag,
                            ) = if s_start <= t_start {
                                (s_start, s_end, new_end_tag, t_start, t_end, new_start_tag)
                            } else {
                                (t_start, t_end, new_start_tag, s_start, s_end, new_end_tag)
                            };
                            rebuilt.push_str(&body[..first_start]);
                            rebuilt.push_str(&first_tag);
                            rebuilt.push_str(&body[first_end..second_start]);
                            rebuilt.push_str(&second_tag);
                            rebuilt.push_str(&body[second_end..]);
                            body_out = rebuilt;
                            changed = true;
                        }
                    }
                }
            }
            out.push_str(g_tag);
            out.push_str(&body_out);
            out.push_str("</g>");
            cursor = body_end + 4;
        }
        out.push_str(&svg[cursor..]);
        if changed {
            Some(out)
        } else {
            None
        }
    }

    fn fix_er_attribute_fills(svg: &str) -> Option<String> {
        if !svg.contains("attributeBoxOdd") && !svg.contains("attributeBoxEven") {
            return None;
        }
        let mut out = String::with_capacity(svg.len() + 32);
        let mut remaining = svg;
        let mut changed = false;
        while let Some(idx) = remaining.find("<rect") {
            let (before, after) = remaining.split_at(idx);
            out.push_str(before);
            let end = match after.find('>') {
                Some(pos) => pos + 1,
                None => {
                    out.push_str(after);
                    remaining = "";
                    break;
                }
            };
            let (tag, rest) = after.split_at(end);
            let mut updated = tag.to_string();
            if tag.contains("attributeBoxOdd") {
                updated = Self::upsert_attr(&updated, "fill", "#ffffff");
            } else if tag.contains("attributeBoxEven") {
                updated = Self::upsert_attr(&updated, "fill", "#f2f2f2");
            }
            if updated != tag {
                changed = true;
            }
            out.push_str(&updated);
            remaining = rest;
        }
        out.push_str(remaining);
        if changed {
            Some(out)
        } else {
            None
        }
    }

    fn find_svg_attr(tag: &str, name: &str) -> Option<String> {
        let needle = format!("{name}=\"");
        let start = tag.find(&needle)? + needle.len();
        let end = tag[start..].find('"')? + start;
        Some(tag[start..end].to_string())
    }

    fn replace_svg_attr(tag: &str, name: &str, value: &str) -> String {
        let needle = format!("{name}=\"");
        let start = match tag.find(&needle) {
            Some(idx) => idx + needle.len(),
            None => return tag.to_string(),
        };
        let end = match tag[start..].find('"') {
            Some(idx) => start + idx,
            None => return tag.to_string(),
        };
        let mut out = String::with_capacity(tag.len() + value.len());
        out.push_str(&tag[..start]);
        out.push_str(value);
        out.push_str(&tag[end..]);
        out
    }

    fn remove_svg_attr(tag: &str, name: &str) -> String {
        let needle = format!("{name}=\"");
        let start = match tag.find(&needle) {
            Some(idx) => idx,
            None => return tag.to_string(),
        };
        let value_start = start + needle.len();
        let end = match tag[value_start..].find('"') {
            Some(idx) => value_start + idx + 1,
            None => return tag.to_string(),
        };
        let mut out = String::with_capacity(tag.len());
        out.push_str(&tag[..start]);
        let rest = &tag[end..];
        if out.ends_with(' ') && rest.starts_with(' ') {
            out.pop();
        }
        out.push_str(rest);
        out
    }

    fn strip_svg_attr(svg: &str, name: &str) -> Option<String> {
        let start = svg.find("<svg")?;
        let end = svg[start..].find('>')? + start;
        let tag = &svg[start..=end];
        let new_tag = Self::remove_svg_attr(tag, name);
        if new_tag == tag {
            return None;
        }
        let mut out = String::with_capacity(svg.len());
        out.push_str(&svg[..start]);
        out.push_str(&new_tag);
        out.push_str(&svg[end + 1..]);
        Some(out)
    }

    fn insert_svg_attr(tag: &str, name: &str, value: &str) -> String {
        let insert_pos = match tag.find("<svg") {
            Some(idx) => idx + 4,
            None => return tag.to_string(),
        };
        let mut out = String::with_capacity(tag.len() + name.len() + value.len() + 4);
        out.push_str(&tag[..insert_pos]);
        out.push_str(&format!(" {name}=\"{value}\""));
        out.push_str(&tag[insert_pos..]);
        out
    }

    fn parse_viewbox_dims(viewbox: &str) -> Option<(f32, f32)> {
        let mut nums = Vec::new();
        for part in viewbox
            .split(|c: char| c.is_whitespace() || c == ',')
            .filter(|part| !part.is_empty())
        {
            if let Ok(value) = part.parse::<f32>() {
                nums.push(value);
            }
        }
        if nums.len() < 4 {
            return None;
        }
        let width = nums[2];
        let height = nums[3];
        if width.is_finite() && height.is_finite() && width > 0.0 && height > 0.0 {
            Some((width, height))
        } else {
            None
        }
    }

    fn format_dim(value: f32) -> String {
        let mut out = format!("{:.3}", value);
        while out.contains('.') && out.ends_with('0') {
            out.pop();
        }
        if out.ends_with('.') {
            out.pop();
        }
        out
    }

    fn process_job(&mut self, job: MermaidRequest) -> MermaidResult {
        let MermaidRequest {
            svg_key,
            texture_key,
            code,
            svg,
            width_bucket,
            scale_bucket,
            viewport_width,
            viewport_height,
            bg,
        } = job;
        let code_ref = code.as_deref();
        let svg_result = match svg {
            Some(svg) => Ok(svg),
            None => match code_ref {
                Some(code) => self.render_svg(svg_key, code, viewport_width, viewport_height),
                None => Err("Mermaid render request missing code".to_string()),
            },
        };

        match svg_result {
            Ok(svg) => {
                let mut svg = Self::normalize_svg_size(&svg);
                if let Some(updated) = Self::flatten_svg_switches(&svg) {
                    svg = updated;
                }
                let theme = MermaidRenderer::mermaid_theme_values();
                if let Some(updated) = Self::fix_journey_section_text(&svg, &theme.text) {
                    svg = updated;
                }
                if let Some(updated) = Self::fix_state_end_circles(&svg) {
                    svg = updated;
                }
                if let Some(updated) = Self::fix_er_attribute_fills(&svg) {
                    svg = updated;
                }
                Self::maybe_dump_svg(svg_key, code_ref, &svg);
                match self.rasterize_svg(&svg, width_bucket, scale_bucket, bg) {
                    Ok((rgba, w, h)) => MermaidResult {
                        svg_key,
                        texture_key,
                        svg: Some(svg),
                        rgba: Some(rgba),
                        size: Some((w, h)),
                        error: None,
                    },
                    Err(err) => {
                        Self::maybe_dump_error(svg_key, code_ref, &err);
                        MermaidResult {
                            svg_key,
                            texture_key,
                            svg: Some(svg),
                            rgba: None,
                            size: None,
                            error: Some(err),
                        }
                    }
                }
            }
            Err(err) => {
                Self::maybe_dump_error(svg_key, code_ref, &err);
                MermaidResult {
                    svg_key,
                    texture_key,
                    svg: None,
                    rgba: None,
                    size: None,
                    error: Some(err),
                }
            }
        }
    }

    fn parse_raw_svg_tree(svg: &str, opt: &usvg::Options) -> Result<usvg::Tree, String> {
        #[cfg(test)]
        if FORCE_RAW_TREE_PARSE_FAIL.swap(false, Ordering::Relaxed) {
            return Err("forced raw svg parse failure".to_string());
        }
        usvg::Tree::from_data(svg.as_bytes(), opt).map_err(|e| format!("{}", e))
    }

    fn bbox_is_valid(width: f32, height: f32, x: f32, y: f32) -> bool {
        width.is_finite()
            && height.is_finite()
            && width > 0.5
            && height > 0.5
            && x.is_finite()
            && y.is_finite()
    }

    fn should_resize_bbox(
        force_resize: bool,
        oversize_ok: bool,
        bbox_w: f32,
        bbox_h: f32,
        w_f: f32,
        h_f: f32,
    ) -> bool {
        oversize_ok && (force_resize || bbox_w > w_f * 1.2 || bbox_h > h_f * 1.2)
    }

    fn rasterize_svg(
        &self,
        svg: &str,
        width_bucket: u32,
        scale_bucket: u32,
        bg: Option<[u8; 4]>,
    ) -> Result<(Vec<u8>, u32, u32), String> {
        let opt = usvg::Options {
            resources_dir: None,
            fontdb: Arc::clone(&self.fontdb),
            image_href_resolver: Self::image_href_resolver(),
            ..Default::default()
        };

        let tree = usvg::Tree::from_data(svg.as_bytes(), &opt).map_err(|e| format!("{}", e))?;
        let mut tree = tree;
        let sz = tree.size().to_int_size();
        let (mut w, mut h) = (sz.width(), sz.height());
        let viewbox_dims = Self::find_svg_attr(svg, "viewBox")
            .and_then(|value| Self::parse_viewbox_dims(&value))
            .filter(|(vw, vh)| *vw > 0.5 && *vh > 0.5);
        if let Some((vw, vh)) = viewbox_dims {
            w = vw.ceil() as u32;
            h = vh.ceil() as u32;
        }
        let mut translate_x = 0.0_f32;
        let mut translate_y = 0.0_f32;

        let mut bbox = tree.root().abs_stroke_bounding_box();
        let mut bbox_w = bbox.width();
        let mut bbox_h = bbox.height();
        let mut bbox_valid = Self::bbox_is_valid(bbox_w, bbox_h, bbox.x(), bbox.y());
        let mut force_bbox_resize = false;

        let oversize_cap = 6.0_f32;
        if let Some(raw_svg) = Self::strip_svg_attr(svg, "viewBox") {
            if let Ok(raw_tree) = Self::parse_raw_svg_tree(&raw_svg, &opt) {
                let raw_bbox = raw_tree.root().abs_stroke_bounding_box();
                let raw_w = raw_bbox.width();
                let raw_h = raw_bbox.height();
                let raw_valid = Self::bbox_is_valid(raw_w, raw_h, raw_bbox.x(), raw_bbox.y());
                let size_w = w as f32;
                let size_h = h as f32;
                let oversize_ok = raw_w <= size_w * oversize_cap && raw_h <= size_h * oversize_cap;
                let oversized =
                    raw_valid && oversize_ok && (raw_w > size_w * 1.2 || raw_h > size_h * 1.2);
                if oversized {
                    tree = raw_tree;
                    bbox = raw_bbox;
                    bbox_w = raw_w;
                    bbox_h = raw_h;
                    bbox_valid = raw_valid;
                    force_bbox_resize = true;
                }
            }
        }
        if bbox_valid {
            let w_f = w as f32;
            let h_f = h as f32;
            let oversize_ok = bbox_w <= w_f * oversize_cap && bbox_h <= h_f * oversize_cap;
            let oversize =
                Self::should_resize_bbox(force_bbox_resize, oversize_ok, bbox_w, bbox_h, w_f, h_f);
            if oversize {
                let padding = 4.0_f32;
                let padded_w = (bbox_w + padding * 2.0).max(1.0);
                let padded_h = (bbox_h + padding * 2.0).max(1.0);
                w = padded_w.ceil() as u32;
                h = padded_h.ceil() as u32;
                translate_x = -bbox.x() + padding;
                translate_y = -bbox.y() + padding;
            }
        }

        let base_scale = MermaidRenderer::scale_from_bucket(scale_bucket);
        let mut scale = base_scale;
        if width_bucket > 0 {
            let width_scale = width_bucket as f32 / w.max(1) as f32;
            scale = scale.min(width_scale);
        }
        scale = scale.clamp(0.01, 4.0);
        let adjustment = Self::scale_adjustment_for_svg(svg);
        scale = (scale * adjustment).clamp(0.01, 4.0);

        let mut target_w = (w as f32 * scale).round() as u32;
        let mut target_h = (h as f32 * scale).round() as u32;
        target_w = target_w.max(1);
        target_h = target_h.max(1);

        if std::env::var("MDMDVIEW_MERMAID_LOG_RASTER").is_ok() {
            eprintln!(
                "Mermaid raster: svg={}x{} target={}x{} scale={:.3} bbox_valid={} bbox=({:.2},{:.2},{:.2},{:.2})",
                w,
                h,
                target_w,
                target_h,
                scale,
                bbox_valid,
                bbox.x(),
                bbox.y(),
                bbox_w,
                bbox_h
            );
        }

        let max_side = MermaidRenderer::MERMAID_MAX_RENDER_SIDE;
        if target_w > max_side || target_h > max_side {
            let clamp_scale =
                (max_side as f32 / target_w as f32).min(max_side as f32 / target_h as f32);
            scale = (scale * clamp_scale).clamp(0.01, 4.0);
            target_w = (w as f32 * scale).round() as u32;
            target_h = (h as f32 * scale).round() as u32;
        }

        let mut pixmap = pixmap_new_for_test(target_w, target_h)
            .ok_or_else(|| "Pixmap alloc failed".to_string())?;
        if let Some([r, g, b, a]) = bg {
            let color = tiny_skia::Color::from_rgba8(r, g, b, a);
            pixmap.fill(color);
        }

        let mut pmut = pixmap.as_mut();
        let mut transform = tiny_skia::Transform::from_scale(scale, scale);
        if translate_x != 0.0 || translate_y != 0.0 {
            transform = transform.pre_translate(translate_x, translate_y);
        }
        resvg::render(&tree, transform, &mut pmut);
        let data = pixmap.data().to_vec();
        Ok((data, target_w, target_h))
    }

    fn image_href_resolver() -> usvg::ImageHrefResolver<'static> {
        let resolve_data = usvg::ImageHrefResolver::default_data_resolver();
        let resolve_string = Box::new(|_: &str, _: &usvg::Options| None);
        usvg::ImageHrefResolver {
            resolve_data,
            resolve_string,
        }
    }

    fn scale_adjustment_for_svg(svg: &str) -> f32 {
        if svg.contains("aria-roledescription=\"er\"") || svg.contains("aria-roledescription='er'")
        {
            0.94
        } else {
            1.0
        }
    }

    fn now_ms() -> u64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64
    }
}

#[cfg(feature = "mermaid-quickjs")]
const MERMAID_DOM_SHIM: &str = r#"
var window = globalThis;
var __mdmdview_text_cache = {};
window.__mdmdview_bbox_rev = 0;
function __mdmdview_bump_bbox_rev() {
  window.__mdmdview_bbox_rev = (window.__mdmdview_bbox_rev || 0) + 1;
}
function __mdmdview_measure_text(text, fontSize, fontWeight) {
  var size = fontSize || 16;
  var raw = text ? String(text) : '';
  if (!raw.length) {
    return { width: 0, height: 0 };
  }
  var weight = (typeof fontWeight === 'number' && !isNaN(fontWeight)) ? fontWeight : null;
  var key = size + '|' + (weight || 0) + '|' + raw;
  var hit = __mdmdview_text_cache[key];
  if (hit) { return hit; }
  if (typeof __mdmdview_measure_text_native === 'function') {
    try {
      var native = __mdmdview_measure_text_native(raw, size, weight);
      if (native && typeof native.width === 'number' && typeof native.height === 'number') {
        __mdmdview_text_cache[key] = native;
        return native;
      }
      if (native && typeof native.length === 'number' && native.length >= 2) {
        var w = Number(native[0]);
        var h = Number(native[1]);
        if (isFinite(w) && isFinite(h)) {
          var converted = { width: w, height: h };
          __mdmdview_text_cache[key] = converted;
          return converted;
        }
      }
    } catch (e) {}
  }
  var lines = raw.split(/\n/);
  var maxLen = 0;
  for (var i = 0; i < lines.length; i++) {
    if (lines[i].length > maxLen) { maxLen = lines[i].length; }
  }
  var width = maxLen * size * 0.5;
  var height = lines.length * size * 1.2;
  var res = { width: width, height: height };
  __mdmdview_text_cache[key] = res;
  return res;
}
function __mdmdview_parse_font_size(value, baseSize) {
  if (value === null || value === undefined) { return baseSize; }
  var raw = String(value).trim();
  if (!raw) { return baseSize; }
  var num = parseFloat(raw);
  if (isNaN(num)) { return baseSize; }
  if (raw.indexOf('em') >= 0) {
    var base = baseSize || 16;
    return num * base;
  }
  if (raw.indexOf('ex') >= 0) {
    var baseEx = baseSize || 16;
    return num * baseEx * 0.5;
  }
  return num;
}
function __mdmdview_parse_font_weight_value(value) {
  if (value === null || value === undefined) { return null; }
  var raw = String(value).trim().toLowerCase();
  if (!raw) { return null; }
  if (raw === 'normal') { return 400; }
  if (raw === 'bold' || raw === 'bolder') { return 700; }
  if (raw === 'lighter') { return 300; }
  var num = parseFloat(raw);
  if (isNaN(num)) { return null; }
  return num;
}
function __mdmdview_parse_css_font_sizes(cssText, cache) {
  if (!cssText || !cache) { return; }
  var chunks = String(cssText).split('}');
  for (var i = 0; i < chunks.length; i++) {
    var rule = chunks[i];
    var parts = rule.split('{');
    if (parts.length < 2) { continue; }
    var selector = parts[0];
    var body = parts.slice(1).join('{');
    if (!selector || !body) { continue; }
    var sizeMatch = body.match(/font-size\s*:\s*([^;]+)/i);
    if (!sizeMatch) { continue; }
    var sizeValue = sizeMatch[1];
    var size = __mdmdview_parse_font_size(sizeValue, 16);
    if (!size || isNaN(size)) { continue; }
    var selectors = selector.split(',');
    for (var s = 0; s < selectors.length; s++) {
      var sel = selectors[s].trim();
      if (!sel) { continue; }
      if (sel.indexOf(':') >= 0) { continue; }
      var classMatches = sel.match(/\\.([A-Za-z0-9_-]+)/g);
      if (!classMatches || classMatches.length !== 1) { continue; }
      var cls = classMatches[0].slice(1);
      if (!cls) { continue; }
      if (!cache[cls] || cache[cls] < size) {
        cache[cls] = size;
      }
    }
  }
}
function __mdmdview_parse_css_font_weights(cssText, cache) {
  if (!cssText || !cache) { return; }
  var chunks = String(cssText).split('}');
  for (var i = 0; i < chunks.length; i++) {
    var rule = chunks[i];
    var parts = rule.split('{');
    if (parts.length < 2) { continue; }
    var selector = parts[0];
    var body = parts.slice(1).join('{');
    if (!selector || !body) { continue; }
    var weightMatch = body.match(/font-weight\s*:\s*([^;]+)/i);
    if (!weightMatch) { continue; }
    var weightValue = weightMatch[1];
    var weight = __mdmdview_parse_font_weight_value(weightValue);
    if (!weight || isNaN(weight)) { continue; }
    var selectors = selector.split(',');
    for (var s = 0; s < selectors.length; s++) {
      var sel = selectors[s].trim();
      if (!sel) { continue; }
      if (sel.indexOf(':') >= 0) { continue; }
      var classMatches = sel.match(/\\.([A-Za-z0-9_-]+)/g);
      if (!classMatches || classMatches.length !== 1) { continue; }
      var cls = classMatches[0].slice(1);
      if (!cls) { continue; }
      if (!cache[cls] || cache[cls] < weight) {
        cache[cls] = weight;
      }
    }
  }
}
function __mdmdview_collect_style_texts(node, out) {
  if (!node || !out) { return; }
  var name = (node.tagName || '').toLowerCase();
  if (name === 'style') {
    var text = __mdmdview_collect_text(node);
    if (text) { out.push(text); }
  }
  if (!node.children) { return; }
  for (var i = 0; i < node.children.length; i++) {
    __mdmdview_collect_style_texts(node.children[i], out);
  }
}
function __mdmdview_find_root_node(node) {
  if (!node) { return null; }
  var current = node;
  var last = node;
  var depth = 0;
  while (current && depth < 120) {
    last = current;
    if (!current.__mdmdview_parent_set) { break; }
    current = current.parentNode;
    depth += 1;
  }
  return last;
}
function __mdmdview_style_cache() {
  var rev = window.__mdmdview_bbox_rev || 0;
  if (window.__mdmdview_font_cache && window.__mdmdview_font_cache_rev === rev) {
    return window.__mdmdview_font_cache;
  }
  var cache = {};
  if (typeof document !== 'undefined' && document && document.getElementsByTagName) {
    var styles = document.getElementsByTagName('style') || [];
    for (var i = 0; i < styles.length; i++) {
      var text = styles[i] ? __mdmdview_collect_text(styles[i]) : '';
      __mdmdview_parse_css_font_sizes(text, cache);
    }
  }
  window.__mdmdview_font_cache = cache;
  window.__mdmdview_font_cache_rev = rev;
  window.__mdmdview_font_cache_root = null;
  window.__mdmdview_font_cache_root_rev = rev;
  return cache;
}
function __mdmdview_style_cache_for_node(node) {
  var cache = __mdmdview_style_cache();
  if (!node) { return cache; }
  var rev = window.__mdmdview_bbox_rev || 0;
  var root = __mdmdview_find_root_node(node);
  if (!root) { return cache; }
  if (window.__mdmdview_font_cache_root === root && window.__mdmdview_font_cache_root_rev === rev) {
    return cache;
  }
  var texts = [];
  __mdmdview_collect_style_texts(root, texts);
  for (var i = 0; i < texts.length; i++) {
    __mdmdview_parse_css_font_sizes(texts[i], cache);
  }
  window.__mdmdview_font_cache_root = root;
  window.__mdmdview_font_cache_root_rev = rev;
  return cache;
}
function __mdmdview_style_weight_cache() {
  var rev = window.__mdmdview_bbox_rev || 0;
  if (window.__mdmdview_font_weight_cache && window.__mdmdview_font_weight_cache_rev === rev) {
    return window.__mdmdview_font_weight_cache;
  }
  var cache = {};
  if (typeof document !== 'undefined' && document && document.getElementsByTagName) {
    var styles = document.getElementsByTagName('style') || [];
    for (var i = 0; i < styles.length; i++) {
      var text = styles[i] ? __mdmdview_collect_text(styles[i]) : '';
      __mdmdview_parse_css_font_weights(text, cache);
    }
  }
  window.__mdmdview_font_weight_cache = cache;
  window.__mdmdview_font_weight_cache_rev = rev;
  window.__mdmdview_font_weight_cache_root = null;
  window.__mdmdview_font_weight_cache_root_rev = rev;
  return cache;
}
function __mdmdview_style_weight_cache_for_node(node) {
  var cache = __mdmdview_style_weight_cache();
  if (!node) { return cache; }
  var rev = window.__mdmdview_bbox_rev || 0;
  var root = __mdmdview_find_root_node(node);
  if (!root) { return cache; }
  if (window.__mdmdview_font_weight_cache_root === root && window.__mdmdview_font_weight_cache_root_rev === rev) {
    return cache;
  }
  var texts = [];
  __mdmdview_collect_style_texts(root, texts);
  for (var i = 0; i < texts.length; i++) {
    __mdmdview_parse_css_font_weights(texts[i], cache);
  }
  window.__mdmdview_font_weight_cache_root = root;
  window.__mdmdview_font_weight_cache_root_rev = rev;
  return cache;
}
function __mdmdview_class_font_size(el) {
  if (!el) { return null; }
  var cache = __mdmdview_style_cache_for_node(el);
  if (!cache) { return null; }
  var list = __mdmdview_get_class_list(el);
  for (var i = 0; i < list.length; i++) {
    var size = cache[list[i]];
    if (size && !isNaN(size)) { return size; }
  }
  return null;
}
function __mdmdview_class_font_weight(el) {
  if (!el) { return null; }
  var cache = __mdmdview_style_weight_cache_for_node(el);
  if (!cache) { return null; }
  var list = __mdmdview_get_class_list(el);
  for (var i = 0; i < list.length; i++) {
    var weight = cache[list[i]];
    if (weight && !isNaN(weight)) { return weight; }
  }
  return null;
}
function __mdmdview_get_font_size(el) {
  var size = 16;
  if (el && el.style && el.style.fontSize) {
    size = __mdmdview_parse_font_size(el.style.fontSize, size);
    if (!isNaN(size)) { return size; }
  }
  if (el && el.style && el.style['font-size']) {
    size = __mdmdview_parse_font_size(el.style['font-size'], size);
    if (!isNaN(size)) { return size; }
  }
  if (el && el.getAttribute) {
    var attr = el.getAttribute('font-size');
    if (attr) {
      var a = __mdmdview_parse_font_size(attr, size);
      if (!isNaN(a)) { size = a; }
    }
  }
  var classSize = __mdmdview_class_font_size(el);
  if (classSize && !isNaN(classSize)) { return classSize; }
  var classList = __mdmdview_get_class_list(el);
  for (var c = 0; c < classList.length; c++) {
    var cls = classList[c];
    if (cls === 'commit-label' || cls === 'commit-label-bkg' || cls === 'tag-label' || cls === 'tag-label-bkg') {
      return 10;
    }
    if (cls === 'gitTitleText') {
      return 18;
    }
  }
  var ancestor = el;
  var steps = 0;
  while (ancestor && steps < 6) {
    if (__mdmdview_has_class(ancestor, 'commit-labels') || __mdmdview_has_class(ancestor, 'tag-labels')) {
      return 10;
    }
    ancestor = ancestor.parentNode;
    steps += 1;
  }
  var current = el;
  var depth = 0;
  while (current && depth < 4) {
    current = current.parentNode;
    if (!current) { break; }
    var parentSize = __mdmdview_class_font_size(current);
    if (parentSize && !isNaN(parentSize)) { return parentSize; }
    depth += 1;
  }
  var tag = (el && el.tagName) ? String(el.tagName).toLowerCase() : '';
  if (tag === 'text' || tag === 'tspan') {
    return size;
  }
  return size;
}
function __mdmdview_get_font_weight_raw(el) {
  if (el && el.style) {
    if (el.style.fontWeight) {
      var sw = __mdmdview_parse_font_weight_value(el.style.fontWeight);
      if (sw && !isNaN(sw)) { return sw; }
    }
    if (el.style['font-weight']) {
      var sw2 = __mdmdview_parse_font_weight_value(el.style['font-weight']);
      if (sw2 && !isNaN(sw2)) { return sw2; }
    }
  }
  if (el && el.getAttribute) {
    var attr = el.getAttribute('font-weight');
    if (attr) {
      var aw = __mdmdview_parse_font_weight_value(attr);
      if (aw && !isNaN(aw)) { return aw; }
    }
  }
  var classWeight = __mdmdview_class_font_weight(el);
  if (classWeight && !isNaN(classWeight)) { return classWeight; }
  var classList = __mdmdview_get_class_list(el);
  for (var i = 0; i < classList.length; i++) {
    var cls = classList[i];
    if (cls === 'classTitle' || cls === 'classTitleText' || cls === 'title') {
      return 700;
    }
  }
  return null;
}
function __mdmdview_get_font_weight(el) {
  var direct = __mdmdview_get_font_weight_raw(el);
  if (direct && !isNaN(direct)) { return direct; }
  var current = el;
  var depth = 0;
  while (current && depth < 4) {
    current = current.parentNode;
    if (!current) { break; }
    var parentWeight = __mdmdview_get_font_weight_raw(current);
    if (parentWeight && !isNaN(parentWeight)) { return parentWeight; }
    depth += 1;
  }
  return 400;
}
function __mdmdview_parse_num(value) {
  var num = parseFloat(value);
  return isNaN(num) ? 0 : num;
}
function __mdmdview_parse_length(value, fontSize) {
  if (value === null || value === undefined) { return 0; }
  var raw = String(value).trim();
  if (!raw) { return 0; }
  var num = parseFloat(raw);
  if (isNaN(num)) { return 0; }
  if (raw.indexOf('em') >= 0) {
    return num * (fontSize || 16);
  }
  if (raw.indexOf('ex') >= 0) {
    return num * (fontSize || 16) * 0.5;
  }
  return num;
}
function __mdmdview_transform_point(el, x, y) {
  var box = __mdmdview_apply_transform(el, { x: x, y: y, width: 0, height: 0 });
  return { x: box.x, y: box.y };
}
function __mdmdview_path_points(el) {
  var d = el && el.getAttribute ? el.getAttribute('d') : null;
  if (!d) { return []; }
  var nums = String(d).match(/-?\d*\.?\d+(?:e[-+]?\d+)?/ig);
  if (!nums || nums.length < 2) { return []; }
  var points = [];
  for (var i = 0; i + 1 < nums.length; i += 2) {
    var x = __mdmdview_parse_num(nums[i]);
    var y = __mdmdview_parse_num(nums[i + 1]);
    points.push(__mdmdview_transform_point(el, x, y));
  }
  return points;
}
function __mdmdview_path_total_length(el) {
  var points = __mdmdview_path_points(el);
  if (points.length < 2) { return 0; }
  var total = 0;
  for (var i = 1; i < points.length; i++) {
    var dx = points[i].x - points[i - 1].x;
    var dy = points[i].y - points[i - 1].y;
    total += Math.sqrt(dx * dx + dy * dy);
  }
  return total;
}
function __mdmdview_path_point_at_length(el, length) {
  var points = __mdmdview_path_points(el);
  if (!points.length) { return { x: 0, y: 0 }; }
  if (points.length === 1) { return points[0]; }
  var remaining = Math.max(0, __mdmdview_parse_num(length));
  for (var i = 1; i < points.length; i++) {
    var p0 = points[i - 1];
    var p1 = points[i];
    var dx = p1.x - p0.x;
    var dy = p1.y - p0.y;
    var seg = Math.sqrt(dx * dx + dy * dy);
    if (seg <= 0) { continue; }
    if (remaining <= seg) {
      var t = remaining / seg;
      return { x: p0.x + dx * t, y: p0.y + dy * t };
    }
    remaining -= seg;
  }
  return points[points.length - 1];
}
function __mdmdview_text_metrics(el) {
  var size = __mdmdview_get_font_size(el);
  var weight = __mdmdview_get_font_weight(el);
  if (!el || !el.children || !el.children.length) {
    var raw = el ? __mdmdview_collect_text(el) : '';
    return __mdmdview_measure_text(raw, size, weight);
  }
  var max_w = 0;
  var max_h = 0;
  var lines = 0;
  for (var i = 0; i < el.children.length; i++) {
    var child = el.children[i];
    var tag = (child.tagName || '').toLowerCase();
    if (tag !== 'tspan') { continue; }
    var text = __mdmdview_collect_text(child);
    if (!text || !String(text).trim()) { continue; }
    var child_weight = __mdmdview_get_font_weight(child);
    var m = __mdmdview_measure_text(text, size, child_weight);
    if (m.width > max_w) { max_w = m.width; }
    if (m.height > max_h) { max_h = m.height; }
    lines += 1;
  }
  if (!lines) {
    var fallback = __mdmdview_collect_text(el);
    return __mdmdview_measure_text(fallback, size, weight);
  }
  var line_height = max_h > 0 ? max_h : size * 1.2;
  return { width: max_w, height: lines * line_height };
}
function __mdmdview_apply_matrix(bbox, a, b, c, d, e, f) {
  if (!bbox) { return bbox; }
  var x = bbox.x;
  var y = bbox.y;
  var w = bbox.width;
  var h = bbox.height;
  var pts = [
    [x, y],
    [x + w, y],
    [x, y + h],
    [x + w, y + h]
  ];
  var min_x = Infinity;
  var min_y = Infinity;
  var max_x = -Infinity;
  var max_y = -Infinity;
  for (var i = 0; i < pts.length; i++) {
    var px = pts[i][0];
    var py = pts[i][1];
    var nx = a * px + c * py + e;
    var ny = b * px + d * py + f;
    if (nx < min_x) { min_x = nx; }
    if (ny < min_y) { min_y = ny; }
    if (nx > max_x) { max_x = nx; }
    if (ny > max_y) { max_y = ny; }
  }
  if (!isFinite(min_x) || !isFinite(min_y) || !isFinite(max_x) || !isFinite(max_y)) {
    return bbox;
  }
  return { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y };
}
function __mdmdview_apply_transform(el, bbox) {
  if (!el || !bbox) { return bbox; }
  var transform = el.getAttribute ? el.getAttribute('transform') : null;
  if (!transform) { return bbox; }
  var current = bbox;
  var re = /([a-zA-Z]+)\(([^)]+)\)/g;
  var match = null;
  while ((match = re.exec(String(transform))) !== null) {
    var name = match[1].toLowerCase();
    var params = match[2].split(/[, ]+/).filter(function(p) { return p.length; });
    var nums = [];
    for (var i = 0; i < params.length; i++) {
      nums.push(__mdmdview_parse_num(params[i]));
    }
    if (name === 'translate') {
      var tx = nums.length ? nums[0] : 0;
      var ty = nums.length > 1 ? nums[1] : 0;
      current = __mdmdview_apply_matrix(current, 1, 0, 0, 1, tx, ty);
    } else if (name === 'scale') {
      var sx = nums.length ? nums[0] : 1;
      var sy = nums.length > 1 ? nums[1] : sx;
      current = __mdmdview_apply_matrix(current, sx, 0, 0, sy, 0, 0);
    } else if (name === 'matrix' && nums.length >= 6) {
      current = __mdmdview_apply_matrix(
        current,
        nums[0],
        nums[1],
        nums[2],
        nums[3],
        nums[4],
        nums[5]
      );
    } else if (name === 'rotate' && nums.length) {
      var angle = nums[0] * Math.PI / 180.0;
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      if (nums.length >= 3) {
        var cx = nums[1];
        var cy = nums[2];
        current = __mdmdview_apply_matrix(current, 1, 0, 0, 1, -cx, -cy);
        current = __mdmdview_apply_matrix(current, cos, sin, -sin, cos, 0, 0);
        current = __mdmdview_apply_matrix(current, 1, 0, 0, 1, cx, cy);
      } else {
        current = __mdmdview_apply_matrix(current, cos, sin, -sin, cos, 0, 0);
      }
    } else if (name === 'skewx' && nums.length) {
      var ax = nums[0] * Math.PI / 180.0;
      current = __mdmdview_apply_matrix(current, 1, 0, Math.tan(ax), 1, 0, 0);
    } else if (name === 'skewy' && nums.length) {
      var ay = nums[0] * Math.PI / 180.0;
      current = __mdmdview_apply_matrix(current, 1, Math.tan(ay), 0, 1, 0, 0);
    }
  }
  return current;
}
function __mdmdview_children_bounds(el) {
  if (!el || !el.children || !el.children.length) { return null; }
  var min_x = Infinity;
  var min_y = Infinity;
  var max_x = -Infinity;
  var max_y = -Infinity;
  for (var i = 0; i < el.children.length; i++) {
    var child_box = __mdmdview_bbox(el.children[i]);
    if (!child_box) { continue; }
    if (!isFinite(child_box.width) || !isFinite(child_box.height)) { continue; }
    if (child_box.width <= 0 && child_box.height <= 0) { continue; }
    if (child_box.x < min_x) { min_x = child_box.x; }
    if (child_box.y < min_y) { min_y = child_box.y; }
    if (child_box.x + child_box.width > max_x) { max_x = child_box.x + child_box.width; }
    if (child_box.y + child_box.height > max_y) { max_y = child_box.y + child_box.height; }
  }
  if (isFinite(min_x) && isFinite(min_y) && isFinite(max_x) && isFinite(max_y)) {
    return { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y };
  }
  return null;
}
function __mdmdview_cache_bbox(el, box) {
  if (el && box) {
    el.__mdmdview_bbox_cache = box;
    el.__mdmdview_bbox_rev = window.__mdmdview_bbox_rev || 0;
  }
  return box;
}
function __mdmdview_bbox(el) {
  if (!el) { return { x: 0, y: 0, width: 0, height: 0 }; }
  if (el.__mdmdview_bbox_cache && el.__mdmdview_bbox_rev === (window.__mdmdview_bbox_rev || 0)) {
    return el.__mdmdview_bbox_cache;
  }
  var tag = (el.tagName || '').toLowerCase();
  if (
    tag === 'style'
    || tag === 'defs'
    || tag === 'script'
    || tag === 'title'
    || tag === 'desc'
    || tag === 'metadata'
    || tag === 'marker'
    || tag === 'clippath'
    || tag === 'mask'
    || tag === 'pattern'
    || tag === 'lineargradient'
    || tag === 'radialgradient'
    || tag === 'stop'
  ) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  if (tag === '#text') {
    var text = el.textContent || '';
    var size = __mdmdview_get_font_size(el);
    var weight = __mdmdview_get_font_weight(el);
    var m = __mdmdview_measure_text(text, size, weight);
    return __mdmdview_cache_bbox(
      el,
      __mdmdview_apply_transform(el, { x: 0, y: 0, width: m.width, height: m.height })
    );
  }
  if (tag === 'svg') {
    if (el.children && el.children.length) {
      var svg_bounds = __mdmdview_children_bounds(el);
      if (svg_bounds) {
        return __mdmdview_cache_bbox(el, __mdmdview_apply_transform(el, svg_bounds));
      }
    }
  }
  if (tag === 'text' || tag === 'tspan') {
    var metrics = __mdmdview_text_metrics(el);
    var fontSize = __mdmdview_get_font_size(el);
    var tx = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('x') : 0);
    var ty = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('y') : 0);
    var dx = __mdmdview_parse_length(el.getAttribute ? el.getAttribute('dx') : 0, fontSize);
    var dy = __mdmdview_parse_length(el.getAttribute ? el.getAttribute('dy') : 0, fontSize);
    if (tag === 'text' && el.children && el.children.length) {
      var first = el.children[0];
      var firstTag = (first.tagName || '').toLowerCase();
      if (firstTag === 'tspan') {
        if (!dx) { dx = __mdmdview_parse_length(first.getAttribute('dx'), fontSize); }
        if (!dy) { dy = __mdmdview_parse_length(first.getAttribute('dy'), fontSize); }
      }
    }
    tx += dx;
    ty += dy;
    var anchor = el.getAttribute ? el.getAttribute('text-anchor') : null;
    if (!anchor && el.style && el.style.textAnchor) { anchor = el.style.textAnchor; }
    if (anchor === 'middle') {
      tx -= metrics.width * 0.5;
    } else if (anchor === 'end' || anchor === 'right') {
      tx -= metrics.width;
    }
    var baseline = el.getAttribute ? el.getAttribute('dominant-baseline') : null;
    if (!baseline && el.style && el.style.dominantBaseline) { baseline = el.style.dominantBaseline; }
    var y = ty - metrics.height * 0.3;
    if (baseline === 'middle' || baseline === 'central') {
      y = ty - metrics.height * 0.5;
    } else if (baseline === 'hanging') {
      y = ty;
    }
    return __mdmdview_cache_bbox(
      el,
      __mdmdview_apply_transform(el, {
        x: tx,
        y: y,
        width: metrics.width,
        height: metrics.height
      })
    );
  }
  if (tag === 'rect') {
    var rx = __mdmdview_parse_num(el.getAttribute('x'));
    var ry = __mdmdview_parse_num(el.getAttribute('y'));
    var rw = __mdmdview_parse_num(el.getAttribute('width'));
    var rh = __mdmdview_parse_num(el.getAttribute('height'));
    return __mdmdview_cache_bbox(
      el,
      __mdmdview_apply_transform(el, { x: rx, y: ry, width: rw, height: rh })
    );
  }
  if (tag === 'circle') {
    var cx = __mdmdview_parse_num(el.getAttribute('cx'));
    var cy = __mdmdview_parse_num(el.getAttribute('cy'));
    var r = __mdmdview_parse_num(el.getAttribute('r'));
    return __mdmdview_cache_bbox(
      el,
      __mdmdview_apply_transform(el, { x: cx - r, y: cy - r, width: r * 2, height: r * 2 })
    );
  }
  if (tag === 'ellipse') {
    var ecx = __mdmdview_parse_num(el.getAttribute('cx'));
    var ecy = __mdmdview_parse_num(el.getAttribute('cy'));
    var erx = __mdmdview_parse_num(el.getAttribute('rx'));
    var ery = __mdmdview_parse_num(el.getAttribute('ry'));
    return __mdmdview_cache_bbox(
      el,
      __mdmdview_apply_transform(el, { x: ecx - erx, y: ecy - ery, width: erx * 2, height: ery * 2 })
    );
  }
  if (tag === 'line') {
    var x1 = __mdmdview_parse_num(el.getAttribute('x1'));
    var y1 = __mdmdview_parse_num(el.getAttribute('y1'));
    var x2 = __mdmdview_parse_num(el.getAttribute('x2'));
    var y2 = __mdmdview_parse_num(el.getAttribute('y2'));
    var min_x = Math.min(x1, x2);
    var min_y = Math.min(y1, y2);
    var max_x = Math.max(x1, x2);
    var max_y = Math.max(y1, y2);
    return __mdmdview_cache_bbox(
      el,
      __mdmdview_apply_transform(el, { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y })
    );
  }
  if (tag === 'polygon' || tag === 'polyline') {
    var points = el.getAttribute('points');
    if (points) {
      var parts = String(points).trim().split(/[\s,]+/).filter(function(p) { return p.length; });
      if (parts.length >= 2) {
        var min_px = Infinity;
        var min_py = Infinity;
        var max_px = -Infinity;
        var max_py = -Infinity;
        for (var i = 0; i + 1 < parts.length; i += 2) {
          var px = __mdmdview_parse_num(parts[i]);
          var py = __mdmdview_parse_num(parts[i + 1]);
          if (px < min_px) { min_px = px; }
          if (py < min_py) { min_py = py; }
          if (px > max_px) { max_px = px; }
          if (py > max_py) { max_py = py; }
        }
        if (isFinite(min_px) && isFinite(min_py) && isFinite(max_px) && isFinite(max_py)) {
          return __mdmdview_cache_bbox(
            el,
            __mdmdview_apply_transform(el, {
              x: min_px,
              y: min_py,
              width: max_px - min_px,
              height: max_py - min_py
            })
          );
        }
      }
    }
  }
  if (tag === 'path') {
    var d = el.getAttribute('d');
    if (d) {
      var nums = String(d).match(/-?\d*\.?\d+(?:e[-+]?\d+)?/ig);
      if (nums && nums.length >= 2) {
        var min_px = Infinity;
        var min_py = Infinity;
        var max_px = -Infinity;
        var max_py = -Infinity;
        for (var i = 0; i + 1 < nums.length; i += 2) {
          var px = __mdmdview_parse_num(nums[i]);
          var py = __mdmdview_parse_num(nums[i + 1]);
          if (px < min_px) { min_px = px; }
          if (py < min_py) { min_py = py; }
          if (px > max_px) { max_px = px; }
          if (py > max_py) { max_py = py; }
        }
        if (isFinite(min_px) && isFinite(min_py) && isFinite(max_px) && isFinite(max_py)) {
          return __mdmdview_cache_bbox(
            el,
            __mdmdview_apply_transform(el, { x: min_px, y: min_py, width: max_px - min_px, height: max_py - min_py })
          );
        }
      }
    }
  }
  var font_size = __mdmdview_get_font_size(el);
  var width_attr = el.getAttribute ? el.getAttribute('width') : null;
  var height_attr = el.getAttribute ? el.getAttribute('height') : null;
  var bw = __mdmdview_parse_length(width_attr, font_size);
  var bh = __mdmdview_parse_length(height_attr, font_size);
  if ((!bw || !bh) && el.style) {
    if (!bw && el.style.width) { bw = __mdmdview_parse_length(el.style.width, font_size); }
    if (!bh && el.style.height) { bh = __mdmdview_parse_length(el.style.height, font_size); }
  }
  if ((!bw || !bh) && el.getAttribute) {
    var view_box = el.getAttribute('viewBox');
    if (view_box) {
      var parts = String(view_box).trim().split(/[\s,]+/).filter(function(p) { return p.length; });
      if (parts.length >= 4) {
        var vbw = __mdmdview_parse_num(parts[2]);
        var vbh = __mdmdview_parse_num(parts[3]);
        if (!bw && vbw) { bw = vbw; }
        if (!bh && vbh) { bh = vbh; }
      }
    }
  }
  if (!bw && !bh) {
    var html_tag = tag === 'div' || tag === 'body' || tag === 'html';
    if (html_tag) {
      bw = window.innerWidth || 0;
      bh = window.innerHeight || 0;
    }
  }
  if (bw || bh) {
    var bx = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('x') : 0);
    var by = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('y') : 0);
    return __mdmdview_cache_bbox(
      el,
      __mdmdview_apply_transform(el, { x: bx, y: by, width: bw, height: bh })
    );
  }
  if (el.children && el.children.length) {
    var child_bounds = __mdmdview_children_bounds(el);
    if (child_bounds) {
      return __mdmdview_cache_bbox(el, __mdmdview_apply_transform(el, child_bounds));
    }
  }
  var fallback_text = el.textContent || '';
  var fallback_size = __mdmdview_get_font_size(el);
  var fallback_weight = __mdmdview_get_font_weight(el);
  var fallback = __mdmdview_measure_text(fallback_text, fallback_size, fallback_weight);
  return __mdmdview_cache_bbox(
    el,
    __mdmdview_apply_transform(el, { x: 0, y: 0, width: fallback.width, height: fallback.height })
  );
}
function __mdmdview_escape_text(text) {
  return String(text)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}
function __mdmdview_collect_text(node) {
  if (!node) { return ''; }
  if (node.tagName === '#text') { return node.textContent || ''; }
  var out = '';
  if (node.children && node.children.length) {
    for (var i = 0; i < node.children.length; i++) {
      out += __mdmdview_collect_text(node.children[i]);
    }
  }
  if (out && out.length) { return out; }
  return node.textContent || '';
}
function __mdmdview_escape_attr(text) {
  return String(text)
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;');
}
function __mdmdview_style_text(style) {
  if (!style) { return ''; }
  if (typeof style.cssText === 'string' && style.cssText.trim().length) {
    return style.cssText;
  }
  var parts = [];
  for (var key in style) {
    if (!Object.prototype.hasOwnProperty.call(style, key)) { continue; }
    if (key === 'cssText') { continue; }
    var val = style[key];
    if (typeof val === 'function') { continue; }
    if (val === null || val === undefined || val === '') { continue; }
    parts.push(key + ':' + String(val));
  }
  return parts.join(';');
}
function __mdmdview_is_shape_tag(tag) {
  var t = String(tag || '').toLowerCase();
  return t === 'rect'
    || t === 'path'
    || t === 'polygon'
    || t === 'circle'
    || t === 'ellipse'
    || t === 'line'
    || t === 'image';
}
function __mdmdview_group_has_text(node) {
  if (!node || !node.children || !node.children.length) { return false; }
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    if (!child) { continue; }
    var tag = String(child.tagName || '').toLowerCase();
    if (tag === 'text' || tag === 'foreignobject') { return true; }
    if (child.children && child.children.length && __mdmdview_group_has_text(child)) {
      return true;
    }
  }
  return false;
}
function __mdmdview_group_has_shape(node) {
  if (!node || !node.children || !node.children.length) { return false; }
  for (var i = 0; i < node.children.length; i++) {
    var child = node.children[i];
    if (!child) { continue; }
    if (__mdmdview_is_shape_tag(child.tagName)) { return true; }
    if (child.children && child.children.length && __mdmdview_group_has_shape(child)) {
      return true;
    }
  }
  return false;
}
function __mdmdview_is_labelish(node) {
  if (!node || !node.tagName) { return false; }
  var tag = String(node.tagName || '').toLowerCase();
  if (tag === 'text' || tag === 'foreignobject') { return true; }
  if (tag === 'g') {
    if (__mdmdview_has_class(node, 'clusters')) { return false; }
    if (__mdmdview_has_class(node, 'label')) { return true; }
    return __mdmdview_group_has_text(node);
  }
  return false;
}
function __mdmdview_order_children(node) {
  if (!node || !node.children || !node.children.length) {
    return node && node.children ? node.children : [];
  }
  var tag = String(node.tagName || '').toLowerCase();
  if (tag !== 'g') { return node.children; }
  if (!__mdmdview_group_has_shape(node)) { return node.children; }
  var has_label = false;
  for (var i = 0; i < node.children.length; i++) {
    if (__mdmdview_is_labelish(node.children[i])) { has_label = true; break; }
  }
  if (!has_label) { return node.children; }
  var before = [];
  var after = [];
  for (var j = 0; j < node.children.length; j++) {
    var child = node.children[j];
    if (__mdmdview_is_labelish(child)) { after.push(child); }
    else { before.push(child); }
  }
  if (!before.length || !after.length) { return node.children; }
  return before.concat(after);
}
function __mdmdview_serialize_attrs(node) {
  var out = '';
  if (!node || !node.attributes) { return out; }
  var has_style = false;
  for (var key in node.attributes) {
    if (!Object.prototype.hasOwnProperty.call(node.attributes, key)) { continue; }
    var val = node.attributes[key];
    if (val === null || val === undefined) { continue; }
    if (key === 'style') { has_style = true; }
    out += ' ' + key + '="' + __mdmdview_escape_attr(val) + '"';
  }
  if (!has_style && node.style) {
    var style_text = __mdmdview_style_text(node.style);
    if (style_text) {
      out += ' style="' + __mdmdview_escape_attr(style_text) + '"';
    }
  }
  return out;
}
function __mdmdview_serialize(node) {
  if (!node) { return ''; }
  if (node.tagName === '#text') {
    return __mdmdview_escape_text(node.textContent || '');
  }
  var tag = node.tagName || '';
  var attrs = __mdmdview_serialize_attrs(node);
  var content = '';
  var lower = String(tag).toLowerCase();
  if (node.children && node.children.length) {
    if (lower === 'style' || lower === 'script') {
      content = __mdmdview_collect_text(node);
    } else {
      var ordered = __mdmdview_order_children(node);
      for (var i = 0; i < ordered.length; i++) {
        content += __mdmdview_serialize(ordered[i]);
      }
    }
  } else if (node.textContent) {
    if (lower === 'style' || lower === 'script') {
      content = node.textContent;
    } else {
      content = __mdmdview_escape_text(node.textContent);
    }
  }
  return '<' + tag + attrs + '>' + content + '</' + tag + '>';
}
function __mdmdview_serialize_children(node) {
  if (!node || !node.children) { return ''; }
  var content = '';
  var ordered = __mdmdview_order_children(node);
  for (var i = 0; i < ordered.length; i++) {
    content += __mdmdview_serialize(ordered[i]);
  }
  return content;
}
function __mdmdview_make_style() {
  var style = { cssText: '' };
  style.setProperty = function(key, value) { style[key] = String(value); };
  style.removeProperty = function(key) { delete style[key]; };
  style.getPropertyValue = function(key) {
    return Object.prototype.hasOwnProperty.call(style, key) ? style[key] : '';
  };
  return style;
}
function __mdmdview_detach(child) {
  if (!child || typeof child !== 'object') { return; }
  var parent = child.parentNode;
  if (!parent || !parent.children) { return; }
  var idx = parent.children.indexOf(child);
  if (idx >= 0) {
    parent.children.splice(idx, 1);
    parent.childNodes = parent.children;
    parent.firstChild = parent.children[0] || null;
  }
  child.parentNode = null;
}
function __mdmdview_parse_font_px(font) {
  if (!font) { return 16; }
  var match = String(font).match(/(\d+(?:\.\d+)?)px/);
  if (match && match[1]) {
    var value = parseFloat(match[1]);
    if (!isNaN(value)) { return value; }
  }
  return 16;
}
function __mdmdview_parse_font_weight(font) {
  if (!font) { return null; }
  var raw = String(font).toLowerCase();
  if (raw.indexOf('bold') >= 0) { return 700; }
  return null;
}
function __mdmdview_make_canvas_context(canvas) {
  var ctx = {
    canvas: canvas,
    font: '',
    lineWidth: 1,
    fillStyle: '#000',
    strokeStyle: '#000',
    textAlign: 'start',
    textBaseline: 'alphabetic',
    save: function() {},
    restore: function() {},
    beginPath: function() {},
    closePath: function() {},
    moveTo: function() {},
    lineTo: function() {},
    arc: function() {},
    rect: function() {},
    fill: function() {},
    stroke: function() {},
    clip: function() {},
    translate: function() {},
    scale: function() {},
    rotate: function() {},
    clearRect: function() {},
    fillRect: function() {},
    strokeRect: function() {},
    drawImage: function() {},
    setLineDash: function() {},
    measureText: function(text) {
      var size = __mdmdview_parse_font_px(ctx.font);
      var weight = __mdmdview_parse_font_weight(ctx.font);
      var measured = __mdmdview_measure_text(text || '', size, weight);
      return { width: measured.width || 0 };
    },
    fillText: function() {},
    strokeText: function() {},
    createLinearGradient: function() { return { addColorStop: function() {} }; },
    createRadialGradient: function() { return { addColorStop: function() {} }; },
    createPattern: function() { return null; }
  };
  return ctx;
}
function __mdmdview_mindmap_get_size(node) {
  var data = node && typeof node.data === 'function' ? node.data() : null;
  var w = data && data.width !== undefined ? Number(data.width) : 80;
  var h = data && data.height !== undefined ? Number(data.height) : 40;
  if (!isFinite(w) || w <= 0) { w = 80; }
  if (!isFinite(h) || h <= 0) { h = 40; }
  return { w: w, h: h };
}
function __mdmdview_rect_intersection(hw, hh, ux, uy) {
  var ax = Math.abs(ux);
  var ay = Math.abs(uy);
  var dx = ax > 1e-6 ? hw / ax : Infinity;
  var dy = ay > 1e-6 ? hh / ay : Infinity;
  var dist = Math.min(dx, dy);
  if (!isFinite(dist) || dist <= 0) { dist = Math.max(hw, hh); }
  return dist;
}
function __mdmdview_mindmap_collect(nodes, edges) {
  var node_map = {};
  var parents = {};
  var children = {};
  var root = null;
  var root_id = null;
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (!node || typeof node.data !== 'function') { continue; }
    var data = node.data();
    if (!data) { continue; }
    var id = data.id !== undefined ? String(data.id) : null;
    if (id === null) { continue; }
    node_map[id] = node;
  }
  for (var j = 0; j < edges.length; j++) {
    var edge = edges[j];
    if (!edge || typeof edge.data !== 'function') { continue; }
    var ed = edge.data();
    if (!ed) { continue; }
    var source = ed.source !== undefined ? String(ed.source) : null;
    var target = ed.target !== undefined ? String(ed.target) : null;
    if (!source || !target) { continue; }
    if (!children[source]) { children[source] = []; }
    children[source].push(target);
    parents[target] = source;
  }
  for (var key in node_map) {
    if (!Object.prototype.hasOwnProperty.call(node_map, key)) { continue; }
    if (!Object.prototype.hasOwnProperty.call(parents, key)) {
      root = node_map[key];
      root_id = key;
      break;
    }
  }
  if (!root && nodes.length) {
    root = nodes[0];
    if (root && typeof root.data === 'function') {
      var rd = root.data();
      if (rd && rd.id !== undefined) { root_id = String(rd.id); }
    }
  }
  return { node_map: node_map, children: children, parents: parents, root: root, root_id: root_id };
}
function __mdmdview_mindmap_sorted_children(node_id, tree) {
  var kids = tree.children[node_id] || [];
  return kids.slice();
}
function __mdmdview_mindmap_assign_sides(tree) {
  var sides = {};
  var root_id = tree.root_id;
  if (!root_id) { return sides; }
  sides[root_id] = 0;
  function assign(node_id) {
    var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
    for (var i = 0; i < kids.length; i++) {
      var child_id = kids[i];
      var child_node = tree.node_map[child_id];
      var side = sides[node_id];
      if (node_id === root_id) {
        var data = child_node && typeof child_node.data === 'function' ? child_node.data() : null;
        var section = data && data.section !== undefined ? Number(data.section) : i;
        if (!isFinite(section)) { section = i; }
        side = (section % 2 === 0) ? -1 : 1;
      }
      sides[child_id] = side;
      assign(child_id);
    }
  }
  assign(root_id);
  return sides;
}
function __mdmdview_mindmap_subtree_height(node_id, tree, sizes, gap, heights) {
  var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
  if (!kids.length) {
    heights[node_id] = sizes[node_id].h;
    return heights[node_id];
  }
  var total = 0;
  for (var i = 0; i < kids.length; i++) {
    total += __mdmdview_mindmap_subtree_height(kids[i], tree, sizes, gap, heights);
  }
  total += gap * Math.max(0, kids.length - 1);
  var base = sizes[node_id].h;
  heights[node_id] = total > base ? total : base;
  return heights[node_id];
}
function __mdmdview_mindmap_layout(nodes, edges) {
  var tree = __mdmdview_mindmap_collect(nodes, edges);
  if (!tree.root || !tree.root_id) { return; }
  var sizes = {};
  for (var key in tree.node_map) {
    if (!Object.prototype.hasOwnProperty.call(tree.node_map, key)) { continue; }
    sizes[key] = __mdmdview_mindmap_get_size(tree.node_map[key]);
  }
  var sides = __mdmdview_mindmap_assign_sides(tree);
  var pad = 10;
  var root_data = tree.root && typeof tree.root.data === 'function' ? tree.root.data() : null;
  if (root_data && root_data.padding !== undefined) {
    var p = Number(root_data.padding);
    if (isFinite(p) && p > 0) { pad = p; }
  }
  var gap_x = Math.max(24, pad * 2.2);
  var positions = {};
  positions[tree.root_id] = { x: 0, y: 0 };
  var angles = {};
  angles[tree.root_id] = 0;
  var deg = Math.PI / 180;
  var left_start = 245 * deg;
  var left_end = 122 * deg;
  var right_start = 345 * deg;
  var right_end = 353 * deg;
  function assign_even(children, start, end) {
    if (!children.length) { return; }
    if (children.length === 1) {
      angles[children[0]] = (start + end) / 2;
      return;
    }
    var span = end - start;
    var step = span / (children.length - 1);
    for (var i = 0; i < children.length; i++) {
      angles[children[i]] = start + step * i;
    }
  }
  var root_kids = __mdmdview_mindmap_sorted_children(tree.root_id, tree);
  var left = [];
  var right = [];
  for (var rk = 0; rk < root_kids.length; rk++) {
    var kid = root_kids[rk];
    var side = sides[kid] || 1;
    if (side < 0) { left.push(kid); } else { right.push(kid); }
  }
  assign_even(left, left_start, left_end);
  assign_even(right, right_start, right_end);
  function spread_for_depth(depth, parent_angle) {
    var base = 38 * deg;
    var cos = Math.cos(parent_angle || 0);
    var bias = cos < 0 ? 1.4 : 1.0;
    var depth_factor = 1 + Math.max(0, depth - 1) * 0.2;
    return (base * bias) / depth_factor;
  }
  function assign_child_angles(node_id, depth) {
    var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
    if (!kids.length) { return; }
    var parent_angle = angles[node_id] || 0;
    if (kids.length === 1) {
      var sin = Math.sin(parent_angle);
      var cos = Math.cos(parent_angle);
      var offset = 0;
      if (cos < -0.1 && sin < -0.1) { offset = 20 * deg; }
      angles[kids[0]] = parent_angle + offset;
      assign_child_angles(kids[0], depth + 1);
      return;
    }
    var spread = spread_for_depth(depth, parent_angle);
    var upper = 1.3;
    var lower = 0.9;
    var start = parent_angle - spread * upper;
    var end = parent_angle + spread * lower;
    assign_even(kids, start, end);
    for (var i = 0; i < kids.length; i++) {
      assign_child_angles(kids[i], depth + 1);
    }
  }
  for (var a = 0; a < root_kids.length; a++) {
    assign_child_angles(root_kids[a], 1);
  }
  function place_node(node_id, depth) {
    var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
    if (!kids.length) { return; }
    var parent_pos = positions[node_id];
    var parent_size = sizes[node_id];
    var parent_radius = Math.max(parent_size.w, parent_size.h) / 2;
    var parent_angle = angles[node_id] || 0;
    for (var i = 0; i < kids.length; i++) {
      var child = kids[i];
      var angle = angles[child];
      if (angle === undefined) { angle = angles[node_id] || 0; }
      var child_size = sizes[child];
      var child_radius = Math.max(child_size.w, child_size.h) / 2;
      var dist = parent_radius + child_radius + gap_x;
      if (depth > 0) {
        dist *= 1.15;
      }
      var factor = 1;
      if (depth === 0) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        factor *= 1.1 * (1 + 0.2 * cos + 0.1 * sin);
      } else {
        var diff = angle - parent_angle;
        while (diff > Math.PI) { diff -= Math.PI * 2; }
        while (diff < -Math.PI) { diff += Math.PI * 2; }
        var norm = diff / (Math.PI / 6);
        if (norm > 1) { norm = 1; }
        if (norm < -1) { norm = -1; }
        factor *= 1 + 0.12 * norm;
        factor *= 0.98 + depth * 0.04;
      }
      if (depth > 0) {
        var sin = Math.sin(angle);
        var cos = Math.cos(angle);
        if (sin >= 0) {
          factor *= 1 + 0.15 * sin;
        } else if (cos > 0) {
          factor *= 1 + 0.05 * sin;
        } else {
          factor *= 1 + 0.25 * sin;
        }
        if (sin < -0.2 && cos < 0) {
          factor *= 0.9;
        }
      }
      if (kids.length === 1) {
        factor *= 0.95;
      }
      dist = dist * factor;
      var cx = parent_pos.x + Math.cos(angle) * dist;
      var cy = parent_pos.y + Math.sin(angle) * dist;
      positions[child] = { x: cx, y: cy };
      place_node(child, depth + 1);
    }
  }
  place_node(tree.root_id, 0);
  var min_x = Infinity;
  var min_y = Infinity;
  for (var id in positions) {
    if (!Object.prototype.hasOwnProperty.call(positions, id)) { continue; }
    var pos = positions[id];
    var size = sizes[id];
    var lx = pos.x - size.w / 2;
    var ly = pos.y - size.h / 2;
    if (lx < min_x) { min_x = lx; }
    if (ly < min_y) { min_y = ly; }
  }
  if (!isFinite(min_x)) { min_x = 0; }
  if (!isFinite(min_y)) { min_y = 0; }
  var dx = pad - min_x;
  var dy = pad - min_y;
  for (var nid in positions) {
    if (!Object.prototype.hasOwnProperty.call(positions, nid)) { continue; }
    positions[nid].x += dx;
    positions[nid].y += dy;
  }
  for (var n = 0; n < nodes.length; n++) {
    var node = nodes[n];
    if (!node || typeof node.data !== 'function') { continue; }
    var data = node.data();
    var id = data && data.id !== undefined ? String(data.id) : null;
    if (!id || !positions[id]) { continue; }
    node._position = { x: positions[id].x, y: positions[id].y };
    node.position = function() { return this._position; };
    data.x = positions[id].x;
    data.y = positions[id].y;
  }
  for (var e = 0; e < edges.length; e++) {
    var edge = edges[e];
    if (!edge || typeof edge.data !== 'function') { continue; }
    var ed = edge.data();
    var source = ed && ed.source !== undefined ? String(ed.source) : null;
    var target = ed && ed.target !== undefined ? String(ed.target) : null;
    if (!source || !target) { continue; }
    var s_pos = positions[source];
    var t_pos = positions[target];
    if (!s_pos || !t_pos) { continue; }
    var s_size = sizes[source];
    var t_size = sizes[target];
    var dx = t_pos.x - s_pos.x;
    var dy = t_pos.y - s_pos.y;
    var len = Math.sqrt(dx * dx + dy * dy);
    if (!isFinite(len) || len <= 0.001) { len = 1; }
    var ux = dx / len;
    var uy = dy / len;
    var s_radius = __mdmdview_rect_intersection(s_size.w / 2, s_size.h / 2, ux, uy);
    var t_radius = __mdmdview_rect_intersection(t_size.w / 2, t_size.h / 2, ux, uy);
    var overlap = -2;
    s_radius += overlap;
    t_radius += overlap;
    if (s_radius < 0) { s_radius = 0; }
    if (t_radius < 0) { t_radius = 0; }
    var max_total = len * 0.95;
    if (s_radius + t_radius > max_total) {
      var scale = max_total / (s_radius + t_radius);
      s_radius *= scale;
      t_radius *= scale;
    }
    var sx = s_pos.x + ux * s_radius;
    var sy = s_pos.y + uy * s_radius;
    var ex = t_pos.x - ux * t_radius;
    var ey = t_pos.y - uy * t_radius;
    var mx = (sx + ex) / 2;
    var my = (sy + ey) / 2;
    edge[0] = edge[0] || {};
    edge[0]._private = {
      bodyBounds: true,
      rscratch: {
        startX: sx,
        startY: sy,
        midX: mx,
        midY: my,
        endX: ex,
        endY: ey
      }
    };
  }
}
function __mdmdview_cytoscape_stub(options) {
  var nodes = [];
  var edges = [];
  function add(entry) {
    if (!entry || !entry.group) { return; }
    if (entry.group === 'nodes') {
      var node = {
        _data: entry.data || {},
        _position: entry.position || { x: 0, y: 0 },
        data: function() { return this._data; },
        position: function() { return this._position; }
      };
      nodes.push(node);
    } else if (entry.group === 'edges') {
      var edge = {
        _data: entry.data || {},
        data: function() { return this._data; }
      };
      edge[0] = { _private: { bodyBounds: false, rscratch: {} } };
      edges.push(edge);
    }
  }
  return {
    add: add,
    nodes: function() { return nodes; },
    edges: function() { return edges; },
    layout: function() {
      return { run: function() { __mdmdview_mindmap_layout(nodes, edges); return this; } };
    }
  };
}
function __mdmdview_make_element(tag, ownerDoc, ns) {
  var doc = ownerDoc;
  if (!doc && typeof document !== 'undefined' && document) { doc = document; }
  var parent = null;
  var parent_set = false;
  var node = {
    tagName: tag,
    namespaceURI: ns || null,
    firstChild: null,
    style: __mdmdview_make_style(),
    children: [],
    childNodes: [],
    attributes: {},
    textContent: '',
    setAttribute: function(key, value) {
      var v = String(value);
      this.attributes[key] = v;
      if (key === 'id') { this.id = v; }
      __mdmdview_bump_bbox_rev();
    },
    setAttributeNS: function(ns, key, value) {
      var v = String(value);
      this.attributes[key] = v;
      if (key === 'id') { this.id = v; }
      __mdmdview_bump_bbox_rev();
    },
    attr: function(key, value) {
      if (value === undefined) { return this.getAttribute(key); }
      if (value === null) { this.removeAttribute(key); return this; }
      this.setAttribute(key, value);
      return this;
    },
    getAttribute: function(key) {
      return Object.prototype.hasOwnProperty.call(this.attributes, key)
        ? this.attributes[key]
        : null;
    },
    getAttributeNS: function(ns, key) { return this.getAttribute(key); },
    text: function(value) {
      if (value === undefined) { return this.textContent || ''; }
      this.textContent = value === null ? '' : String(value);
      __mdmdview_bump_bbox_rev();
      return this;
    },
    append: function(tag) {
      var child = __mdmdview_make_element(tag, this.ownerDocument, this.namespaceURI);
      this.appendChild(child);
      return child;
    },
    removeAttribute: function(key) { delete this.attributes[key]; __mdmdview_bump_bbox_rev(); },
    removeAttributeNS: function(ns, key) { delete this.attributes[key]; __mdmdview_bump_bbox_rev(); },
    appendChild: function(child) {
      __mdmdview_detach(child);
      this.children.push(child);
      this.childNodes = this.children;
      this.firstChild = this.children[0] || null;
      if (child && typeof child === 'object') {
        child.parentNode = this;
        if (!child.ownerDocument && this.ownerDocument) { child.ownerDocument = this.ownerDocument; }
      }
      __mdmdview_bump_bbox_rev();
      return child;
    },
    removeChild: function(child) {
      var idx = this.children.indexOf(child);
      if (idx >= 0) {
        this.children.splice(idx, 1);
        this.childNodes = this.children;
      }
      if (child && typeof child === 'object') { child.parentNode = null; }
      this.firstChild = this.children[0] || null;
      __mdmdview_bump_bbox_rev();
      return child;
    },
    hasChildNodes: function() { return this.children.length > 0; },
    insertBefore: function(child, before) {
      __mdmdview_detach(child);
      var idx = this.children.indexOf(before);
      if (idx < 0) { this.children.push(child); }
      else { this.children.splice(idx, 0, child); }
      this.childNodes = this.children;
      this.firstChild = this.children[0] || null;
      if (child && typeof child === 'object') {
        child.parentNode = this;
        if (!child.ownerDocument && this.ownerDocument) { child.ownerDocument = this.ownerDocument; }
      }
      __mdmdview_bump_bbox_rev();
      return child;
    },
    remove: function() { return null; },
    querySelector: function(sel) { return __mdmdview_query_selector(this, sel); },
    querySelectorAll: function(sel) { return __mdmdview_query_selector_all(this, sel); },
    cloneNode: function(deep) {
      var copy = __mdmdview_make_element(this.tagName, this.ownerDocument, this.namespaceURI);
      copy.textContent = this.textContent;
      copy.innerHTML = this.innerHTML;
      for (var key in this.attributes) {
        if (!Object.prototype.hasOwnProperty.call(this.attributes, key)) { continue; }
        copy.attributes[key] = this.attributes[key];
      }
      if (this.style) {
        for (var prop in this.style) {
          if (!Object.prototype.hasOwnProperty.call(this.style, prop)) { continue; }
          if (typeof this.style[prop] === 'function') { continue; }
          copy.style[prop] = this.style[prop];
        }
      }
      if (deep && this.children && this.children.length) {
        for (var i = 0; i < this.children.length; i++) {
          copy.appendChild(this.children[i].cloneNode(true));
        }
      }
      return copy;
    },
    getBBox: function() {
      var box = __mdmdview_bbox(this);
      if (box) {
        box.w = box.width;
        box.h = box.height;
      }
      return box;
    },
    getBoundingClientRect: function() {
      var box = __mdmdview_bbox(this);
      if (box) {
        box.left = box.x;
        box.top = box.y;
        box.right = box.x + box.width;
        box.bottom = box.y + box.height;
        box.w = box.width;
        box.h = box.height;
      }
      return box;
    },
    getComputedTextLength: function() { return __mdmdview_bbox(this).width; },
    getTotalLength: function() { return __mdmdview_path_total_length(this); },
    getPointAtLength: function(len) { return __mdmdview_path_point_at_length(this, len); },
    addEventListener: function() {},
    removeEventListener: function() {},
    dispatchEvent: function() { return false; }
  };
  var lower = String(tag || '').toLowerCase();
  if (lower === 'canvas') {
    node.width = 300;
    node.height = 150;
    node.getContext = function(kind) {
      if (kind && String(kind).toLowerCase() !== '2d') { return null; }
      if (!node.__mdmdview_ctx) {
        node.__mdmdview_ctx = __mdmdview_make_canvas_context(node);
      }
      return node.__mdmdview_ctx;
    };
  }
  var classList = {
    add: function() {
      var list = __mdmdview_get_class_list(node);
      for (var i = 0; i < arguments.length; i++) {
        var cls = String(arguments[i]);
        if (cls && list.indexOf(cls) < 0) { list.push(cls); }
      }
      __mdmdview_set_class_list(node, list);
    },
    remove: function() {
      var list = __mdmdview_get_class_list(node);
      var next = [];
      for (var i = 0; i < list.length; i++) {
        var keep = true;
        for (var j = 0; j < arguments.length; j++) {
          if (list[i] === String(arguments[j])) { keep = false; break; }
        }
        if (keep) { next.push(list[i]); }
      }
      __mdmdview_set_class_list(node, next);
    },
    contains: function(cls) { return __mdmdview_has_class(node, cls); },
    toggle: function(cls, force) {
      var list = __mdmdview_get_class_list(node);
      var name = String(cls);
      var has = list.indexOf(name) >= 0;
      var should_add = force === undefined ? !has : !!force;
      if (should_add && !has) { list.push(name); }
      if (!should_add && has) { list = list.filter(function(item) { return item !== name; }); }
      __mdmdview_set_class_list(node, list);
      return should_add;
    }
  };
  node.classList = classList;
  Object.defineProperty(node, 'innerHTML', {
    get: function() { return __mdmdview_serialize_children(this); },
    set: function(value) {
      if (this.children && this.children.length) {
        for (var i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          if (child && typeof child === 'object') { child.parentNode = null; }
        }
      }
      this.children = [];
      this.childNodes = this.children;
      this.firstChild = null;
      this.textContent = value ? String(value) : '';
      __mdmdview_bump_bbox_rev();
    },
    configurable: true
  });
  Object.defineProperty(node, 'className', {
    get: function() {
      var cls = this.getAttribute('class');
      return cls ? String(cls) : '';
    },
    set: function(value) { this.setAttribute('class', value); },
    configurable: true
  });
  Object.defineProperty(node, 'outerHTML', {
    get: function() { return __mdmdview_serialize(this); },
    configurable: true
  });
  Object.defineProperty(node, 'ownerDocument', {
    get: function() {
      if (doc) { return doc; }
      if (typeof document !== 'undefined') { return document || null; }
      return null;
    },
    set: function(value) { doc = value; },
    configurable: true
  });
  Object.defineProperty(node, 'parentNode', {
    get: function() {
      if (parent_set) { return parent || null; }
      if (typeof document !== 'undefined' && document && document.body) { return document.body; }
      return null;
    },
    set: function(value) { parent = value; parent_set = true; },
    configurable: true
  });
  Object.defineProperty(node, 'nextSibling', {
    get: function() {
      var p = this.parentNode;
      if (!p || !p.children) { return null; }
      var idx = p.children.indexOf(this);
      return idx >= 0 && idx + 1 < p.children.length ? p.children[idx + 1] : null;
    },
    configurable: true
  });
  Object.defineProperty(node, 'previousSibling', {
    get: function() {
      var p = this.parentNode;
      if (!p || !p.children) { return null; }
      var idx = p.children.indexOf(this);
      return idx > 0 ? p.children[idx - 1] : null;
    },
    configurable: true
  });
  Object.defineProperty(node, 'firstElementChild', {
    get: function() {
      return this.children && this.children.length ? this.children[0] : null;
    },
    configurable: true
  });
  return node;
}
function __mdmdview_find_by_id(node, id) {
  if (!node || !id) { return null; }
  if (node.id === id) { return node; }
  if (node.attributes && node.attributes.id === id) { return node; }
  if (!node.children) { return null; }
  for (var i = 0; i < node.children.length; i++) {
    var hit = __mdmdview_find_by_id(node.children[i], id);
    if (hit) { return hit; }
  }
  return null;
}
function __mdmdview_find_by_tag(node, tag, matches) {
  if (!node || !tag) { return; }
  var name = (node.tagName || '').toLowerCase();
  if (name === tag) { matches.push(node); }
  if (!node.children) { return; }
  for (var i = 0; i < node.children.length; i++) {
    __mdmdview_find_by_tag(node.children[i], tag, matches);
  }
}
function __mdmdview_get_class_list(node) {
  if (!node) { return []; }
  var raw = null;
  if (node.getAttribute) { raw = node.getAttribute('class'); }
  if (raw === null || raw === undefined) { raw = node.attributes && node.attributes['class']; }
  if (!raw) { return []; }
  return String(raw).split(/\s+/).filter(function(item) { return item.length > 0; });
}
function __mdmdview_set_class_list(node, list) {
  if (!node) { return; }
  var value = (list || []).filter(function(item) { return item.length > 0; }).join(' ');
  if (node.setAttribute) { node.setAttribute('class', value); }
  else if (node.attributes) { node.attributes['class'] = value; }
}
function __mdmdview_has_class(node, className) {
  if (!node || !className) { return false; }
  var cls = node.attributes && node.attributes['class'];
  if (!cls) { return false; }
  var parts = String(cls).split(/\s+/);
  for (var i = 0; i < parts.length; i++) {
    if (parts[i] === className) { return true; }
  }
  return false;
}
function __mdmdview_find_by_class(node, className, matches) {
  if (!node || !className) { return; }
  if (__mdmdview_has_class(node, className)) { matches.push(node); }
  if (!node.children) { return; }
  for (var i = 0; i < node.children.length; i++) {
    __mdmdview_find_by_class(node.children[i], className, matches);
  }
}
function __mdmdview_get_attr(node, name) {
  if (!node || !name) { return null; }
  if (node.getAttribute) {
    var val = node.getAttribute(name);
    if (val !== null && val !== undefined) { return String(val); }
  }
  if (node.attributes && Object.prototype.hasOwnProperty.call(node.attributes, name)) {
    return String(node.attributes[name]);
  }
  return null;
}
function __mdmdview_parse_attr_selector(raw) {
  var match = raw.match(/^\[\s*([^\]=\s]+)\s*=\s*["']?([^\"'\]]+)["']?\s*\]$/);
  if (!match) { return null; }
  return { name: match[1], value: match[2] };
}
function __mdmdview_find_by_attr(node, name, value, matches) {
  if (!node || !name) { return null; }
  var attr = __mdmdview_get_attr(node, name);
  if (attr !== null && String(attr) === String(value)) {
    if (matches) { matches.push(node); }
    else { return node; }
  }
  if (!node.children) { return matches ? null : null; }
  for (var i = 0; i < node.children.length; i++) {
    var hit = __mdmdview_find_by_attr(node.children[i], name, value, matches);
    if (!matches && hit) { return hit; }
  }
  return matches ? null : null;
}
function __mdmdview_matches_simple(node, raw) {
  if (!node || !raw) { return false; }
  var attr = __mdmdview_parse_attr_selector(raw);
  if (attr) {
    var attrVal = __mdmdview_get_attr(node, attr.name);
    return attrVal !== null && String(attrVal) === String(attr.value);
  }
  if (raw[0] === '#') {
    var id = raw.slice(1);
    return node.id === id || __mdmdview_get_attr(node, 'id') === id;
  }
  if (raw[0] === '.') {
    return __mdmdview_has_class(node, raw.slice(1));
  }
  var hashIdx = raw.indexOf('#');
  if (hashIdx > 0) {
    var tagName = raw.slice(0, hashIdx).toLowerCase();
    var tagId = raw.slice(hashIdx + 1);
    return (node.tagName || '').toLowerCase() === tagName
      && (node.id === tagId || __mdmdview_get_attr(node, 'id') === tagId);
  }
  var dotIdx = raw.indexOf('.');
  if (dotIdx > 0) {
    var tag = raw.slice(0, dotIdx).toLowerCase();
    var cls = raw.slice(dotIdx + 1);
    return (node.tagName || '').toLowerCase() === tag && __mdmdview_has_class(node, cls);
  }
  return (node.tagName || '').toLowerCase() === raw.toLowerCase();
}
function __mdmdview_matches_selector(node, sel) {
  if (!node || !sel) { return false; }
  var raw = String(sel).trim();
  if (!raw) { return false; }
  var parts = raw.split(/\s+/).filter(function(part) { return part.length > 0; });
  if (parts.length <= 1) { return __mdmdview_matches_simple(node, raw); }
  var idx = parts.length - 1;
  var current = node;
  while (current && idx >= 0) {
    if (__mdmdview_matches_simple(current, parts[idx])) {
      idx -= 1;
    }
    current = current.parentNode;
  }
  return idx < 0;
}
function __mdmdview_query_selector(node, sel) {
  if (!sel) { return null; }
  var raw = String(sel).trim();
  if (!raw) { return null; }
  if (node && !node.tagName && node._parent) { node = node._parent; }
  if ((!node || !node.children) && document && document.body) { node = document.body; }
  var chain = raw.split(/\s+/).filter(function(part) { return part.length > 0; });
  if (chain.length > 1) {
    var current = node;
    for (var c = 0; c < chain.length; c++) {
      current = __mdmdview_query_selector(current, chain[c]);
      if (!current) { return null; }
    }
    return current;
  }
  var result = null;
  var attrSel = __mdmdview_parse_attr_selector(raw);
  if (attrSel) {
    result = __mdmdview_find_by_attr(node, attrSel.name, attrSel.value);
  } else if (raw[0] === '#') {
    result = __mdmdview_find_by_id(node, raw.slice(1));
  } else if (raw[0] === '.') {
    var className = raw.slice(1);
    var classMatches = [];
    __mdmdview_find_by_class(node, className, classMatches);
    result = classMatches.length ? classMatches[0] : null;
  } else if (raw.indexOf('#') > 0) {
    var hashParts = raw.split('#');
    var hashTag = hashParts[0].toLowerCase();
    var hashId = hashParts[1];
    var hashMatches = [];
    __mdmdview_find_by_tag(node, hashTag, hashMatches);
    for (var h = 0; h < hashMatches.length; h++) {
      if (hashMatches[h].id === hashId || __mdmdview_get_attr(hashMatches[h], 'id') === hashId) {
        result = hashMatches[h];
        break;
      }
    }
  } else if (raw.indexOf('.') > 0) {
    var pieces = raw.split('.');
    var tagName = pieces[0].toLowerCase();
    var clsName = pieces[1];
    var tagMatches = [];
    __mdmdview_find_by_tag(node, tagName, tagMatches);
    for (var t = 0; t < tagMatches.length; t++) {
      if (__mdmdview_has_class(tagMatches[t], clsName)) {
        result = tagMatches[t];
        break;
      }
    }
  } else {
    var tag = raw.toLowerCase();
    var matches = [];
    __mdmdview_find_by_tag(node, tag, matches);
    result = matches.length ? matches[0] : null;
  }
  return result;
}
function __mdmdview_query_selector_all(node, sel) {
  if (!sel) { return []; }
  var raw = String(sel).trim();
  if (!raw) { return []; }
  if (node && !node.tagName && node._parent) { node = node._parent; }
  if ((!node || !node.children) && document && document.body) { node = document.body; }
  var chain = raw.split(/\s+/).filter(function(part) { return part.length > 0; });
  if (chain.length > 1) {
    var current = node;
    for (var c = 0; c < chain.length; c++) {
      current = __mdmdview_query_selector(current, chain[c]);
      if (!current) { return []; }
    }
    return [current];
  }
  var attrSel = __mdmdview_parse_attr_selector(raw);
  if (attrSel) {
    var attrMatches = [];
    __mdmdview_find_by_attr(node, attrSel.name, attrSel.value, attrMatches);
    return attrMatches;
  }
  if (raw[0] === '#') {
    var hit = __mdmdview_find_by_id(node, raw.slice(1));
    return hit ? [hit] : [];
  }
  if (raw[0] === '.') {
    var className = raw.slice(1);
    var classMatches = [];
    __mdmdview_find_by_class(node, className, classMatches);
    return classMatches;
  }
  if (raw.indexOf('#') > 0) {
    var hashParts = raw.split('#');
    var hashTag = hashParts[0].toLowerCase();
    var hashId = hashParts[1];
    var hashMatches = [];
    __mdmdview_find_by_tag(node, hashTag, hashMatches);
    var hashHits = [];
    for (var h = 0; h < hashMatches.length; h++) {
      if (hashMatches[h].id === hashId || __mdmdview_get_attr(hashMatches[h], 'id') === hashId) {
        hashHits.push(hashMatches[h]);
      }
    }
    return hashHits;
  }
  if (raw.indexOf('.') > 0) {
    var pieces = raw.split('.');
    var tagName = pieces[0].toLowerCase();
    var clsName = pieces[1];
    var tagMatches = [];
    __mdmdview_find_by_tag(node, tagName, tagMatches);
    var hits = [];
    for (var t = 0; t < tagMatches.length; t++) {
      if (__mdmdview_has_class(tagMatches[t], clsName)) {
        hits.push(tagMatches[t]);
      }
    }
    return hits;
  }
  var tag = raw.toLowerCase();
  var matches = [];
  __mdmdview_find_by_tag(node, tag, matches);
  return matches;
}
var document = {
  body: __mdmdview_make_element('body'),
  head: __mdmdview_make_element('head'),
  children: [],
  childNodes: [],
  createElement: function(tag) { return __mdmdview_make_element(tag, document); },
  createElementNS: function(ns, tag) { return __mdmdview_make_element(tag, document, ns); },
  createTextNode: function(text) {
    var node = __mdmdview_make_element('#text', document);
    node.textContent = text || '';
    return node;
  },
  getElementById: function(id) { return __mdmdview_find_by_id(document, id); },
  getElementsByTagName: function(tag) {
    var raw = String(tag || '').trim().toLowerCase();
    if (!raw) { return []; }
    if (raw === 'head') { return document.head ? [document.head] : []; }
    if (raw === 'body') { return document.body ? [document.body] : []; }
    var matches = [];
    __mdmdview_find_by_tag(document, raw, matches);
    return matches;
  },
  querySelector: function(sel) {
    var raw = String(sel || '').trim().toLowerCase();
    var result = raw === 'head'
      ? document.head
      : (raw === 'body' ? document.body : __mdmdview_query_selector(document, sel));
    return result || (document && document.body ? document.body : null);
  },
  querySelectorAll: function(sel) {
    var raw = String(sel || '').trim().toLowerCase();
    var result = raw === 'head'
      ? [document.head]
      : (raw === 'body' ? [document.body] : __mdmdview_query_selector_all(document, sel));
    if (result && result.length) { return result; }
    return document && document.body ? [document.body] : [];
  },
  appendChild: function(child) {
    return document.documentElement
      ? document.documentElement.appendChild(child)
      : document.body.appendChild(child);
  },
  insertBefore: function(child, before) {
    return document.documentElement
      ? document.documentElement.insertBefore(child, before)
      : document.body.insertBefore(child, before);
  },
  removeChild: function(child) {
    return document.documentElement
      ? document.documentElement.removeChild(child)
      : document.body.removeChild(child);
  },
  hasChildNodes: function() {
    return document.documentElement
      ? document.documentElement.hasChildNodes()
      : document.body.hasChildNodes();
  },
  addEventListener: function() {}
};
window.document = document;
document.body.ownerDocument = document;
document.head.ownerDocument = document;
document.documentElement = __mdmdview_make_element('html');
document.documentElement.ownerDocument = document;
document.documentElement.appendChild(document.head);
document.documentElement.appendChild(document.body);
document.documentElement.parentNode = document;
document.children = [document.documentElement];
document.childNodes = document.children;
document.defaultView = window;
document.ownerDocument = document;
document.body.namespaceURI = 'http://www.w3.org/1999/xhtml';
document.head.namespaceURI = 'http://www.w3.org/1999/xhtml';
document.documentElement.namespaceURI = 'http://www.w3.org/1999/xhtml';
document.namespaceURI = document.body.namespaceURI;
window.ownerDocument = document;
window.namespaceURI = document.body.namespaceURI;
function __mdmdview_clear_node(node) {
  if (!node) { return; }
  if (node.children && node.children.length) {
    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];
      if (child && typeof child === 'object') { child.parentNode = null; }
    }
  }
  node.children = [];
  node.childNodes = node.children;
  node.firstChild = null;
  node.textContent = '';
}
function __mdmdview_reset_dom() {
  __mdmdview_clear_node(document.head);
  __mdmdview_clear_node(document.body);
  document.documentElement.children = [document.head, document.body];
  document.documentElement.childNodes = document.documentElement.children;
  document.documentElement.firstChild = document.head || null;
  document.head.parentNode = document.documentElement;
  document.body.parentNode = document.documentElement;
  __mdmdview_text_cache = {};
  window.__mdmdview_timer_queue = [];
  window.__mdmdview_timer_map = {};
  window.__mdmdview_now_base = 0;
  window.__mdmdview_bbox_rev = 0;
}
if (!Object.hasOwn) {
  Object.hasOwn = function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };
}
if (!Object.prototype.hasOwnProperty('ownerDocument')) {
  Object.defineProperty(Object.prototype, 'ownerDocument', {
    get: function() { return document || null; },
    set: function(value) {
      Object.defineProperty(this, 'ownerDocument', { value: value, writable: true, configurable: true });
    },
    configurable: true
  });
}
if (!Object.prototype.hasOwnProperty('parentNode')) {
  Object.defineProperty(Object.prototype, 'parentNode', {
    get: function() {
      if (this && this.__mdmdview_parent_set) {
        return this.__mdmdview_parent || null;
      }
      if (typeof document !== 'undefined' && document && document.body) { return document.body; }
      return null;
    },
    set: function(value) {
      this.__mdmdview_parent = value;
      this.__mdmdview_parent_set = true;
    },
    configurable: true
  });
}
if (!Object.prototype.hasOwnProperty('querySelector')) {
  Object.defineProperty(Object.prototype, 'querySelector', {
    value: function(sel) { return __mdmdview_query_selector(this, sel); },
    writable: true,
    configurable: true
  });
}
if (!Object.prototype.hasOwnProperty('querySelectorAll')) {
  Object.defineProperty(Object.prototype, 'querySelectorAll', {
    value: function(sel) { return __mdmdview_query_selector_all(this, sel); },
    writable: true,
    configurable: true
  });
}
if (!Object.prototype.hasOwnProperty('appendChild')) {
  Object.defineProperty(Object.prototype, 'appendChild', {
    value: function(child) {
      if (this && !this.tagName && document && document.body && this !== document.body) {
        return document.body.appendChild(child);
      }
      __mdmdview_detach(child);
      if (!this.children) { this.children = []; }
      this.children.push(child);
      this.childNodes = this.children;
      this.firstChild = this.children[0] || null;
      if (child && typeof child === 'object') {
        child.parentNode = this;
      }
      return child;
    },
    writable: true,
    configurable: true
  });
}
if (!Object.prototype.hasOwnProperty('insertBefore')) {
  Object.defineProperty(Object.prototype, 'insertBefore', {
    value: function(child, before) {
      if (this && !this.tagName && document && document.body && this !== document.body) {
        return document.body.insertBefore(child, before);
      }
      __mdmdview_detach(child);
      if (!this.children) { this.children = []; }
      var idx = this.children.indexOf(before);
      if (idx < 0) { this.children.push(child); }
      else { this.children.splice(idx, 0, child); }
      this.childNodes = this.children;
      this.firstChild = this.children[0] || null;
      if (child && typeof child === 'object') {
        child.parentNode = this;
      }
      return child;
    },
    writable: true,
    configurable: true
  });
}
if (!Object.prototype.hasOwnProperty('removeChild')) {
  Object.defineProperty(Object.prototype, 'removeChild', {
    value: function(child) {
      if (!this.children) { return child; }
      var idx = this.children.indexOf(child);
      if (idx >= 0) { this.children.splice(idx, 1); }
      this.childNodes = this.children;
      this.firstChild = this.children[0] || null;
      return child;
    },
    writable: true,
    configurable: true
  });
}
if (!Object.prototype.hasOwnProperty('matches')) {
  Object.defineProperty(Object.prototype, 'matches', {
    value: function(sel) { return __mdmdview_matches_selector(this, sel); },
    writable: true,
    configurable: true
  });
}
if (!Object.prototype.hasOwnProperty('nextSibling')) {
  Object.defineProperty(Object.prototype, 'nextSibling', {
    get: function() { return null; },
    configurable: true
  });
}
if (!Object.prototype.hasOwnProperty('previousSibling')) {
  Object.defineProperty(Object.prototype, 'previousSibling', {
    get: function() { return null; },
    configurable: true
  });
}
window.getComputedStyle = function(el) {
  return (el && el.style) ? el.style : __mdmdview_make_style();
};
window.__mdmdview_timer_queue = [];
window.__mdmdview_timer_map = {};
window.__mdmdview_next_timer_id = 1;
window.setTimeout = function(fn, ms) {
  var id = window.__mdmdview_next_timer_id++;
  window.__mdmdview_timer_map[id] = { fn: fn, interval: false };
  window.__mdmdview_timer_queue.push(id);
  return id;
};
window.clearTimeout = function(id) {
  if (window.__mdmdview_timer_map) {
    delete window.__mdmdview_timer_map[id];
  }
};
window.setInterval = function(fn, ms) {
  var id = window.__mdmdview_next_timer_id++;
  window.__mdmdview_timer_map[id] = { fn: fn, interval: true };
  window.__mdmdview_timer_queue.push(id);
  return id;
};
window.clearInterval = function(id) { window.clearTimeout(id); };
window.requestAnimationFrame = function(fn) {
  return window.setTimeout(function() { fn(0); }, 16);
};
window.cancelAnimationFrame = function(id) { window.clearTimeout(id); };
window.__mdmdview_run_timers = function(max_ticks) {
  var ticks = 0;
  var queue = window.__mdmdview_timer_queue || [];
  var map = window.__mdmdview_timer_map || {};
  var limit = typeof max_ticks === 'number' && max_ticks > 0 ? max_ticks : 1000;
  while (queue.length && ticks < limit) {
    var id = queue.shift();
    var entry = map[id];
    if (entry && typeof entry.fn === 'function') { entry.fn(); }
    if (entry && entry.interval) {
      queue.push(id);
    } else {
      delete map[id];
    }
    ticks++;
  }
  return queue.length;
};
if (!window.devicePixelRatio) { window.devicePixelRatio = 1; }
if (!window.Image) {
  window.Image = function() {
    this.complete = true;
    this.addEventListener = function() {};
    this.removeEventListener = function() {};
    return this;
  };
}
window.addEventListener = function() {};
window.removeEventListener = function() {};
window.structuredClone = function(value) {
  if (value === null || value === undefined) { return value; }
  if (typeof value !== 'object') { return value; }
  try { return JSON.parse(JSON.stringify(value)); } catch (e) {}
  if (Array.isArray(value)) { return value.slice(); }
  var out = {};
  for (var key in value) {
    if (!Object.prototype.hasOwnProperty.call(value, key)) { continue; }
    out[key] = value[key];
  }
  return out;
};
window.__mdmdview_now_base = 0;
window.performance = { now: function(){
  if (typeof Date !== 'undefined' && typeof Date.now === 'function') { return Date.now(); }
  window.__mdmdview_now_base += 1;
  return window.__mdmdview_now_base;
} };
window.console = {
  log: function(){},
  warn: function(){},
  error: function(){},
  info: function(){},
  debug: function(){},
  trace: function(){}
};
window.fetch = function(){ throw new Error('fetch disabled'); };
window.XMLHttpRequest = function(){ throw new Error('XMLHttpRequest disabled'); };
window.DOMPurify = { sanitize: function(html){ return html; } };
window.getComputedStyle = function(el) {
  var style = (el && el.style) ? el.style : __mdmdview_make_style();
  if (!style.fontSize) { style.fontSize = '16px'; }
  if (!style['font-size']) { style['font-size'] = style.fontSize; }
  if (!style.fontFamily) { style.fontFamily = 'sans-serif'; }
  if (!style['font-family']) { style['font-family'] = style.fontFamily; }
  if (!style.fontWeight) { style.fontWeight = 'normal'; }
  if (!style['font-weight']) { style['font-weight'] = style.fontWeight; }
  if (!style.fontStyle) { style.fontStyle = 'normal'; }
  if (!style['font-style']) { style['font-style'] = style.fontStyle; }
  if (el && el.getAttribute) {
    var attrSize = el.getAttribute('font-size');
    if (attrSize) {
      style.fontSize = String(attrSize);
      style['font-size'] = style.fontSize;
    }
    var attrFamily = el.getAttribute('font-family');
    if (attrFamily) {
      style.fontFamily = String(attrFamily);
      style['font-family'] = style.fontFamily;
    }
    var attrWeight = el.getAttribute('font-weight');
    if (attrWeight) {
      style.fontWeight = String(attrWeight);
      style['font-weight'] = style.fontWeight;
    }
    var attrStyle = el.getAttribute('font-style');
    if (attrStyle) {
      style.fontStyle = String(attrStyle);
      style['font-style'] = style.fontStyle;
    }
  }
  style.getPropertyValue = function(key) {
    if (Object.prototype.hasOwnProperty.call(style, key)) { return style[key]; }
    if (key === 'font-size') { return style.fontSize; }
    if (key === 'font-family') { return style.fontFamily; }
    if (key === 'font-weight') { return style.fontWeight; }
    if (key === 'font-style') { return style.fontStyle; }
    return '';
  };
  return style;
};
window.__mdmdview_viewport_width = 1200;
window.__mdmdview_viewport_height = 900;
Object.defineProperty(window, 'innerWidth', {
  get: function() { return window.__mdmdview_viewport_width || 0; },
  configurable: true
});
Object.defineProperty(window, 'innerHeight', {
  get: function() { return window.__mdmdview_viewport_height || 0; },
  configurable: true
});
if (!Object.prototype.hasOwnProperty('parentElement')) {
  Object.defineProperty(Object.prototype, 'parentElement', {
    get: function() {
      var p = this && this.parentNode ? this.parentNode : null;
      if (p && p.tagName) { return p; }
      return null;
    },
    configurable: true
  });
}
if (!Object.prototype.hasOwnProperty('offsetWidth')) {
  Object.defineProperty(Object.prototype, 'offsetWidth', {
    get: function() {
      if (this && typeof this.getBBox === 'function') {
        var width = this.getBBox().width || 0;
        if (width) { return width; }
      }
      return window.innerWidth || 0;
    },
    configurable: true
  });
}
if (!Object.prototype.hasOwnProperty('offsetHeight')) {
  Object.defineProperty(Object.prototype, 'offsetHeight', {
    get: function() {
      if (this && typeof this.getBBox === 'function') {
        var height = this.getBBox().height || 0;
        if (height) { return height; }
      }
      return window.innerHeight || 0;
    },
    configurable: true
  });
}
if (!Object.prototype.hasOwnProperty('clientWidth')) {
  Object.defineProperty(Object.prototype, 'clientWidth', {
    get: function() { return this.offsetWidth || 0; },
    configurable: true
  });
}
if (!Object.prototype.hasOwnProperty('clientHeight')) {
  Object.defineProperty(Object.prototype, 'clientHeight', {
    get: function() { return this.offsetHeight || 0; },
    configurable: true
  });
}
"#;

#[cfg(feature = "mermaid-quickjs")]
const MERMAID_INIT_SNIPPET: &str = r##"
if (window.mermaid && mermaid.mermaidAPI) {
  mermaid.mermaidAPI.initialize({startOnLoad: false});
  window.__mdmdview_is_plain_object = function(value) {
    return value && typeof value === 'object' && !Array.isArray(value);
  };
  window.__mdmdview_merge_config = function(baseConfig, overrideConfig) {
    var out = {};
    function assign(target, source) {
      if (!window.__mdmdview_is_plain_object(source)) { return; }
      for (var key in source) {
        if (!Object.prototype.hasOwnProperty.call(source, key)) { continue; }
        var value = source[key];
        if (window.__mdmdview_is_plain_object(value)) {
          if (!window.__mdmdview_is_plain_object(target[key])) { target[key] = {}; }
          assign(target[key], value);
        } else if (Array.isArray(value)) {
          target[key] = value.slice();
        } else {
          target[key] = value;
        }
      }
    }
    assign(out, baseConfig);
    assign(out, overrideConfig);
    return out;
  };
  window.__mdmdview_sanitize_config = function(cfg) {
    if (!window.__mdmdview_is_plain_object(cfg)) { return null; }
    var disallowed = {
      securityLevel: true,
      startOnLoad: true,
      maxTextSize: true,
      deterministicIds: true,
      deterministicIDSeed: true,
      htmlLabels: true,
      themeCSS: true,
      dompurifyConfig: true,
      secure: true
    };
    var out = {};
    for (var key in cfg) {
      if (!Object.prototype.hasOwnProperty.call(cfg, key)) { continue; }
      if (key.indexOf('__') === 0 || key.indexOf('proto') >= 0 || key.indexOf('constructor') >= 0) {
        continue;
      }
      if (disallowed[key]) { continue; }
      var value = cfg[key];
      if (window.__mdmdview_is_plain_object(value)) {
        var nested = window.__mdmdview_sanitize_config(value);
        if (nested && Object.keys(nested).length) { out[key] = nested; }
      } else if (Array.isArray(value)) {
        out[key] = value.slice();
      } else {
        out[key] = value;
      }
    }
    if (out.themeVariables && window.__mdmdview_is_plain_object(out.themeVariables)) {
      for (var tvKey in out.themeVariables) {
        if (!Object.prototype.hasOwnProperty.call(out.themeVariables, tvKey)) { continue; }
        var tvVal = out.themeVariables[tvKey];
        if (typeof tvVal === 'string') {
          if (!tvVal.match(/^[\d "#%(),.;A-Za-z-]+$/)) {
            delete out.themeVariables[tvKey];
          }
        }
      }
    }
    return out;
  };
  window.__mdmdview_extract_init = function(code) {
    if (typeof code !== 'string') { return { code: code, config: null }; }
    var initRe = /%%\{\s*init\s*:\s*([\s\S]*?)\s*\}%%/g;
    var found = null;
    var cleaned = code.replace(initRe, function(match, json) {
      if (found === null) {
        try { found = JSON.parse(json); } catch (e) { found = null; }
      }
      return '';
    });
    return { code: cleaned, config: found };
  };
} else {
  throw new Error('Mermaid not available');
}
"##;

#[cfg(feature = "mermaid-quickjs")]
const MERMAID_RENDER_WRAPPER: &str = r#"
(function(id, code, siteConfigJson, viewportWidth, viewportHeight){
  if (typeof __mdmdview_reset_dom === 'function') {
    __mdmdview_reset_dom();
  }
  if (typeof viewportWidth === 'number' && viewportWidth > 0) {
    window.__mdmdview_viewport_width = viewportWidth;
  }
  if (typeof viewportHeight === 'number' && viewportHeight > 0) {
    window.__mdmdview_viewport_height = viewportHeight;
  }
  var siteConfig = {};
  if (typeof siteConfigJson === 'string' && siteConfigJson.length > 0) {
    try { siteConfig = JSON.parse(siteConfigJson); } catch (e) { siteConfig = {}; }
  }
  var extracted = window.__mdmdview_extract_init(code);
  var directiveConfig = window.__mdmdview_sanitize_config(extracted.config) || {};
  var merged = window.__mdmdview_merge_config(directiveConfig, siteConfig);
  if (merged && merged.securityLevel === 'strict') {
    merged.htmlLabels = false;
    if (!merged.flowchart) { merged.flowchart = {}; }
    merged.flowchart.htmlLabels = false;
  }
  function __mdmdview_flush_timers() {
    if (typeof __mdmdview_run_timers !== 'function') { return; }
    var remaining = 0;
    var cycles = 0;
    do {
      remaining = __mdmdview_run_timers(1000);
      cycles++;
    } while (remaining > 0 && cycles < 100);
    if (remaining > 0) { throw new Error('Mermaid timer queue did not drain'); }
  }
  function __mdmdview_pump_timers(max_cycles) {
    var cycles = 0;
    function step() {
      if (typeof __mdmdview_run_timers !== 'function') {
        return Promise.resolve();
      }
      var remaining = __mdmdview_run_timers(1000);
      cycles++;
      if (remaining > 0 && cycles < max_cycles) {
        return Promise.resolve().then(step);
      }
      if (remaining > 0) {
        return Promise.reject(new Error('Mermaid timer queue did not drain'));
      }
      return Promise.resolve();
    }
    return step();
  }
  mermaid.mermaidAPI.initialize(merged);
  var renderCode = extracted && extracted.code !== undefined ? extracted.code : code;
  var svgOut = null;
  var renderResult = null;
  try {
    renderResult = mermaid.mermaidAPI.render(id, renderCode, function(svg){ svgOut = svg; });
    __mdmdview_flush_timers();
  } catch (err) {
    throw err;
  }
  if (renderResult && typeof renderResult.then === 'function') {
    var pump = __mdmdview_pump_timers(400);
    return Promise.all([renderResult, pump]).then(function(values){
      __mdmdview_flush_timers();
      var out = values && values.length ? values[0] : null;
      if (typeof out === 'string') { return out; }
      if (out && out.svg) { return out.svg; }
      if (typeof svgOut === 'string' && svgOut.length > 0) { return svgOut; }
      throw new Error('Mermaid render returned empty');
    });
  }
  if (typeof renderResult === 'string') { return renderResult; }
  if (renderResult && renderResult.svg) { return renderResult.svg; }
  if (typeof svgOut === 'string' && svgOut.length > 0) { return svgOut; }
  throw new Error('Mermaid render returned empty');
})
"#;

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;
    use std::collections::HashSet;
    use std::sync::{Arc, Mutex, OnceLock};
    use tempfile::tempdir;

    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
        ENV_LOCK
            .get_or_init(|| Mutex::new(()))
            .lock()
            .expect("env lock")
    }

    fn restore_env_var(key: &'static str, previous: Option<String>) {
        if let Some(value) = previous {
            std::env::set_var(key, value);
        } else {
            std::env::remove_var(key);
        }
    }

    #[cfg(feature = "mermaid-quickjs")]
    fn test_renderer_with_channels(
        job_tx: Option<MermaidJobSender>,
        result_rx: MermaidResultReceiver,
    ) -> MermaidRenderer {
        MermaidRenderer {
            mermaid_textures: RefCell::new(LruCache::new(4)),
            mermaid_pending: RefCell::new(HashSet::new()),
            mermaid_frame_pending: Cell::new(false),
            mermaid_svg_cache: RefCell::new(LruCache::new(4)),
            mermaid_errors: RefCell::new(LruCache::new(4)),
            mermaid_texture_errors: RefCell::new(LruCache::new(4)),
            mermaid_job_tx: job_tx,
            mermaid_result_rx: result_rx,
            worker_handles: Vec::new(),
        }
    }

    #[test]
    fn test_lru_cache_eviction_and_touch() {
        let mut cache = LruCache::new(2);
        let key_a = "a".to_string();
        let key_b = "b".to_string();
        let key_c = "c".to_string();

        cache.insert(key_a.clone(), 1);
        cache.insert(key_b.clone(), 2);
        assert_eq!(cache.get(&key_a), Some(1));
        cache.insert(key_c.clone(), 3);
        assert!(cache.get(&key_b).is_none());
        assert_eq!(cache.len(), 2);
    }

    #[test]
    fn test_lru_cache_missing_get_and_empty_order_insert() {
        let mut cache = LruCache::new(1);
        assert!(cache.get(&"missing".to_string()).is_none());
        cache.entries.insert("a".to_string(), 1);
        cache.order.clear();
        cache.insert("b".to_string(), 2);
        assert_eq!(cache.len(), 2);
    }

    #[test]
    fn test_lru_cache_capacity_zero_insert() {
        let mut cache = LruCache::new(0);
        cache.insert("a".to_string(), 1);
        assert_eq!(cache.len(), 1);
    }

    #[test]
    fn test_lru_cache_insert_overwrites_existing_key() {
        let mut cache = LruCache::new(2);
        let key = "alpha".to_string();
        cache.insert(key.clone(), 1);
        cache.insert(key.clone(), 2);
        assert_eq!(cache.get(&key), Some(2));
        assert_eq!(cache.len(), 1);
    }

    #[test]
    fn test_lru_cache_get_missing_does_not_touch_order() {
        let mut cache = LruCache::new(2);
        cache.insert("a".to_string(), 1);
        let before = cache.order.clone();
        assert!(cache.get(&"missing".to_string()).is_none());
        assert_eq!(cache.order, before);
    }

    #[test]
    fn test_lru_cache_insert_without_eviction() {
        let mut cache = LruCache::new(3);
        cache.insert("a".to_string(), 1);
        cache.insert("b".to_string(), 2);
        assert_eq!(cache.len(), 2);
        assert_eq!(cache.order.len(), 2);
    }

    #[test]
    fn test_lru_cache_touch_if_present_branches() {
        let mut cache = LruCache::new(2);
        let key = "alpha".to_string();
        cache.entries.insert(key.clone(), 1);
        cache.order.push_back(key.clone());
        let value = cache.entries.get(&key).cloned();
        cache.touch_if_present(&value, &key);
        assert_eq!(cache.order.back(), Some(&key));

        let before = cache.order.clone();
        let missing: Option<i32> = None;
        cache.touch_if_present(&missing, &"missing".to_string());
        assert_eq!(cache.order, before);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_lru_cache_touch_if_present_type_variants() {
        let mut id_cache = LruCache::new(1);
        id_cache.entries.insert(1u64, "one".to_string());
        let value = id_cache.entries.get(&1).cloned();
        id_cache.touch_if_present(&value, &1);
        let missing: Option<String> = None;
        id_cache.touch_if_present(&missing, &2);

        let mut string_cache = LruCache::new(1);
        let string_key = "a".to_string();
        string_cache
            .entries
            .insert(string_key.clone(), "one".to_string());
        let value = string_cache.entries.get(&string_key).cloned();
        string_cache.touch_if_present(&value, &string_key);
        let missing: Option<String> = None;
        string_cache.touch_if_present(&missing, &"b".to_string());

        let ctx = egui::Context::default();
        let tex = ctx.load_texture(
            "mermaid_touch_variant",
            egui::ColorImage::new([1, 1], Color32::WHITE),
            egui::TextureOptions::LINEAR,
        );
        let entry = MermaidTextureEntry {
            texture: tex,
            size: [1, 1],
        };
        let mut texture_cache = LruCache::new(1);
        let texture_key = "t".to_string();
        texture_cache
            .entries
            .insert(texture_key.clone(), entry.clone());
        let value = texture_cache.entries.get(&texture_key).cloned();
        texture_cache.touch_if_present(&value, &texture_key);
        let missing: Option<MermaidTextureEntry> = None;
        texture_cache.touch_if_present(&missing, &"missing".to_string());
    }

    #[test]
    fn test_lru_cache_evict_oldest_branches() {
        let mut cache = LruCache::new(1);
        cache.insert("alpha".to_string(), 1);
        assert!(cache.evict_oldest());
        cache.order.clear();
        assert!(!cache.evict_oldest());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_lru_cache_insert_and_evict_type_variants() {
        let mut id_cache = LruCache::new(1);
        id_cache.insert(1u64, "one".to_string());
        id_cache.insert(2u64, "two".to_string());
        id_cache.entries.insert(3u64, "three".to_string());
        id_cache.order.clear();
        id_cache.insert(4u64, "four".to_string());
        assert!(id_cache.evict_oldest());
        id_cache.order.clear();
        assert!(!id_cache.evict_oldest());

        let mut string_cache = LruCache::new(1);
        string_cache.insert("a".to_string(), "one".to_string());
        string_cache.insert("b".to_string(), "two".to_string());
        string_cache
            .entries
            .insert("c".to_string(), "three".to_string());
        string_cache.order.clear();
        string_cache.insert("d".to_string(), "four".to_string());
        assert!(string_cache.evict_oldest());
        string_cache.order.clear();
        assert!(!string_cache.evict_oldest());

        let ctx = egui::Context::default();
        let tex = ctx.load_texture(
            "mermaid_evict_variant",
            egui::ColorImage::new([1, 1], Color32::WHITE),
            egui::TextureOptions::LINEAR,
        );
        let entry = MermaidTextureEntry {
            texture: tex,
            size: [1, 1],
        };
        let mut texture_cache = LruCache::new(1);
        texture_cache.insert("a".to_string(), entry.clone());
        texture_cache.insert("b".to_string(), entry.clone());
        texture_cache.entries.insert("c".to_string(), entry.clone());
        texture_cache.order.clear();
        texture_cache.insert("d".to_string(), entry);
        assert!(texture_cache.evict_oldest());
        texture_cache.order.clear();
        assert!(!texture_cache.evict_oldest());
    }

    #[test]
    fn test_lru_cache_string_string_branches() {
        let mut cache = LruCache::new(1);
        assert!(cache.get(&"missing".to_string()).is_none());

        cache.insert("a".to_string(), "one".to_string());
        cache.insert("a".to_string(), "uno".to_string());
        assert_eq!(cache.get(&"a".to_string()), Some("uno".to_string()));

        cache.insert("b".to_string(), "two".to_string());
        assert!(cache.get(&"a".to_string()).is_none());

        cache.entries.insert("c".to_string(), "three".to_string());
        cache.order.clear();
        cache.insert("d".to_string(), "four".to_string());
        assert!(cache.len() >= 1);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_lru_cache_mermaid_type_variants() {
        let mut string_cache = LruCache::new(2);
        string_cache.insert(1u64, "one".to_string());
        string_cache.insert(2u64, "two".to_string());
        assert_eq!(string_cache.get(&1), Some("one".to_string()));
        assert!(string_cache.get(&3).is_none());
        string_cache.insert(1u64, "uno".to_string());
        string_cache.insert(3u64, "three".to_string());

        let ctx = egui::Context::default();
        let tex = ctx.load_texture(
            "mermaid_cache_test",
            egui::ColorImage::new([1, 1], Color32::WHITE),
            egui::TextureOptions::LINEAR,
        );
        let entry = MermaidTextureEntry {
            texture: tex,
            size: [1, 1],
        };
        let mut texture_cache = LruCache::new(1);
        assert!(texture_cache.get(&"missing".to_string()).is_none());
        texture_cache.insert("a".to_string(), entry.clone());
        assert!(texture_cache.get(&"a".to_string()).is_some());
        texture_cache.insert("a".to_string(), entry.clone());
        texture_cache.insert("b".to_string(), entry.clone());
        texture_cache.entries.insert("c".to_string(), entry.clone());
        texture_cache.order.clear();
        texture_cache.insert("d".to_string(), entry);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_renderer_cache_branches() {
        let renderer = MermaidRenderer::new();
        let ctx = egui::Context::default();
        let tex = ctx.load_texture(
            "mermaid_renderer_cache",
            egui::ColorImage::new([1, 1], Color32::WHITE),
            egui::TextureOptions::LINEAR,
        );
        let entry = MermaidTextureEntry {
            texture: tex,
            size: [1, 1],
        };

        {
            let mut cache = renderer.mermaid_textures.borrow_mut();
            assert!(cache.get(&"miss".to_string()).is_none());
            cache.insert("hit".to_string(), entry.clone());
            assert!(cache.get(&"hit".to_string()).is_some());
            cache.entries.insert("stale".to_string(), entry.clone());
            cache.order.clear();
            cache.insert("fresh".to_string(), entry.clone());
        }

        {
            let mut cache = renderer.mermaid_svg_cache.borrow_mut();
            assert!(cache.get(&1).is_none());
            cache.insert(1, "one".to_string());
            assert!(cache.get(&1).is_some());
            cache.entries.insert(2, "two".to_string());
            cache.order.clear();
            cache.insert(3, "three".to_string());
        }

        {
            let mut cache = renderer.mermaid_errors.borrow_mut();
            assert!(cache.get(&1).is_none());
            cache.insert(1, "err".to_string());
            assert!(cache.get(&1).is_some());
            cache.entries.insert(2, "err2".to_string());
            cache.order.clear();
            cache.insert(3, "err3".to_string());
        }

        {
            let mut cache = renderer.mermaid_texture_errors.borrow_mut();
            assert!(cache.get(&"miss".to_string()).is_none());
            cache.insert("hit".to_string(), "err".to_string());
            assert!(cache.get(&"hit".to_string()).is_some());
            cache
                .entries
                .insert("stale".to_string(), "err2".to_string());
            cache.order.clear();
            cache.insert("fresh".to_string(), "err3".to_string());
        }
    }

    #[test]
    fn test_mermaid_texture_key_changes_with_scale_and_bg() {
        let svg_key = 42;
        let width_bucket = 320;
        let scale_a = MermaidRenderer::scale_bucket(1.0);
        let scale_b = MermaidRenderer::scale_bucket(1.2);
        let bg_a = Some([255, 0, 0, 255]);
        let bg_b = Some([0, 0, 0, 255]);

        let key_a = MermaidRenderer::texture_key(svg_key, width_bucket, scale_a, bg_a);
        let key_b = MermaidRenderer::texture_key(svg_key, width_bucket, scale_b, bg_a);
        let key_c = MermaidRenderer::texture_key(svg_key, width_bucket, scale_a, bg_b);

        assert_ne!(key_a, key_b);
        assert_ne!(key_a, key_c);
    }

    #[test]
    fn test_mermaid_width_bucket_rounds_up() {
        let step = MermaidRenderer::MERMAID_WIDTH_BUCKET_STEP;
        assert_eq!(MermaidRenderer::width_bucket(1.0), step);
        assert_eq!(MermaidRenderer::width_bucket(step as f32 + 0.1), step * 2);
    }

    #[test]
    fn test_mermaid_diagram_kind_skips_comments_and_blank() {
        let code = "\n%% comment\n  \nsequenceDiagram\nAlice->>Bob: Hi";
        assert_eq!(
            MermaidRenderer::mermaid_diagram_kind(code),
            Some("sequencediagram".to_string())
        );
    }

    #[test]
    fn test_mermaid_diagram_kind_returns_none_for_comments_only() {
        let code = "%% comment\n   \n%% another";
        assert!(MermaidRenderer::mermaid_diagram_kind(code).is_none());
    }

    #[test]
    fn test_mermaid_renderer_preference_env() {
        let _lock = env_lock();
        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
        let (default_pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
        assert!(!explicit);
        #[cfg(feature = "mermaid-quickjs")]
        assert_eq!(default_pref, MermaidRenderPreference::Embedded);
        #[cfg(not(feature = "mermaid-quickjs"))]
        assert_eq!(default_pref, MermaidRenderPreference::Off);

        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
            let (pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
            assert!(explicit);
            assert_eq!(pref, MermaidRenderPreference::Embedded);
        }
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "off");
            let (pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
            assert!(explicit);
            assert_eq!(pref, MermaidRenderPreference::Off);
        }
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "bogus");
            let (pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
            assert!(!explicit);
            #[cfg(feature = "mermaid-quickjs")]
            assert_eq!(pref, MermaidRenderPreference::Embedded);
            #[cfg(not(feature = "mermaid-quickjs"))]
            assert_eq!(pref, MermaidRenderPreference::Off);
        }
    }

    #[test]
    fn test_mermaid_security_level_default_and_env() {
        let _lock = env_lock();
        std::env::remove_var("MDMDVIEW_MERMAID_SECURITY");
        assert_eq!(MermaidRenderer::mermaid_security_level(), "strict");
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_SECURITY", "loose");
            assert_eq!(MermaidRenderer::mermaid_security_level(), "loose");
        }
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_SECURITY", "strict");
            assert_eq!(MermaidRenderer::mermaid_security_level(), "strict");
        }
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_worker_count_clamps_env() {
        let _lock = env_lock();
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "0");
            assert_eq!(MermaidRenderer::mermaid_worker_count(), 1);
        }
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "999");
            assert_eq!(MermaidRenderer::mermaid_worker_count(), 16);
        }
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "nope");
            let count = MermaidRenderer::mermaid_worker_count();
            assert!(count >= 1);
            assert!(count <= MermaidRenderer::MAX_MERMAID_JOBS.max(1));
        }
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_timeout_ms_env_clamps() {
        let _lock = env_lock();
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_TIMEOUT_MS", "50");
            assert_eq!(MermaidRenderer::mermaid_timeout_ms(), 100);
        }
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_TIMEOUT_MS", "250");
            assert_eq!(MermaidRenderer::mermaid_timeout_ms(), 250);
        }
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_TIMEOUT_MS", "bad");
            assert_eq!(MermaidRenderer::mermaid_timeout_ms(), 30_000);
        }
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_theme_values_font_family_trim() {
        let _lock = env_lock();
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_FONT_FAMILY", "  ");
            let theme = MermaidRenderer::mermaid_theme_values();
            assert!(theme.font_family.is_none());
        }
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_FONT_FAMILY", "  Test Font  ");
            let theme = MermaidRenderer::mermaid_theme_values();
            assert_eq!(theme.font_family.as_deref(), Some("Test Font"));
        }
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_site_config_json_includes_security_flags() {
        let _lock = env_lock();
        {
            std::env::remove_var("MDMDVIEW_MERMAID_SECURITY");
            let json = MermaidRenderer::mermaid_site_config_json(1);
            assert!(json.contains("\"securityLevel\":\"strict\""));
            assert!(json.contains("\"htmlLabels\":false"));
            assert!(json.contains("\"flowchart\":{\"htmlLabels\":false}"));
        }
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_SECURITY", "loose");
            let json = MermaidRenderer::mermaid_site_config_json(2);
            assert!(json.contains("\"securityLevel\":\"loose\""));
            assert!(!json.contains("\"flowchart\":{\"htmlLabels\":false}"));
        }
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_site_config_json_includes_font_family() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_FONT_FAMILY", "Test Sans");
        let json = MermaidRenderer::mermaid_site_config_json(3);
        assert!(json.contains("\"fontFamily\":\"Test Sans\""));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_json_escape_handles_specials() {
        let input = "quote\" backslash\\ newline\n tab\t carriage\r";
        let escaped = MermaidRenderer::json_escape(input);
        assert!(escaped.contains("\\\""));
        assert!(escaped.contains("\\\\"));
        assert!(escaped.contains("\\n"));
        assert!(escaped.contains("\\t"));
        assert!(escaped.contains("\\r"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_image_href_resolver_blocks_external() {
        let resolver = MermaidWorker::image_href_resolver();
        let options = usvg::Options::default();
        let resolve_string = &resolver.resolve_string;

        assert!(resolve_string("http://example.com/img.png", &options).is_none());
        assert!(resolve_string("file:///tmp/foo.png", &options).is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_embed_bytes_present() {
        assert!(!super::mermaid_embed::MERMAID_JS.is_empty());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_quickjs_render_smoke() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = std::sync::Arc::new(fontdb);
        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");

        let flow = "graph TD; A-->B;";
        let seq = "sequenceDiagram\nAlice->>Bob: Hello\nBob-->>Alice: Hi";
        let class = "classDiagram\nClass01 <|-- Class02\nClass01 : +int id\nClass02 : +String name";
        let er = "erDiagram\nCUSTOMER ||--o{ ORDER : places\nORDER ||--|{ LINE_ITEM : contains\nCUSTOMER {\n  int id\n  string name\n}\nORDER {\n  int id\n  date created\n}\nLINE_ITEM {\n  int id\n  int qty\n}\n";
        let gantt = "gantt\ntitle Sample Gantt\ndateFormat  YYYY-MM-DD\nsection A\nTask 1 :a1, 2024-01-01, 5d\nTask 2 :after a1, 3d\nsection B\nTask 3 :b1, 2024-01-06, 4d\n";
        let viewport_width = 1200;
        let viewport_height = 900;

        let flow_svg = worker
            .render_svg(
                MermaidRenderer::hash_str(flow),
                flow,
                viewport_width,
                viewport_height,
            )
            .expect("flowchart render");
        let seq_svg = worker
            .render_svg(
                MermaidRenderer::hash_str(seq),
                seq,
                viewport_width,
                viewport_height,
            )
            .expect("sequence render");
        let class_svg = worker
            .render_svg(
                MermaidRenderer::hash_str(class),
                class,
                viewport_width,
                viewport_height,
            )
            .expect("class render");
        let er_svg = worker
            .render_svg(
                MermaidRenderer::hash_str(er),
                er,
                viewport_width,
                viewport_height,
            )
            .expect("er render");
        let gantt_svg = worker
            .render_svg(
                MermaidRenderer::hash_str(gantt),
                gantt,
                viewport_width,
                viewport_height,
            )
            .expect("gantt render");

        assert!(flow_svg.contains("<svg"));
        assert!(seq_svg.contains("<svg"));
        assert!(class_svg.contains("<svg"));
        assert!(er_svg.contains("<svg"));
        assert!(gantt_svg.contains("<svg"));

        let width_bucket = MermaidRenderer::width_bucket(600.0);
        let scale_bucket = MermaidRenderer::scale_bucket(1.0);
        let (rgba, w, h) = worker
            .rasterize_svg(&flow_svg, width_bucket, scale_bucket, None)
            .expect("rasterize svg");
        assert!(!rgba.is_empty());
        assert_eq!(rgba.len(), (w as usize) * (h as usize) * 4);
        assert!(w > 0);
        assert!(h > 0);
        assert!(w <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
        assert!(h <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_worker_dom_debug_env() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_DOM_DEBUG", "1");
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = Arc::new(fontdb);
        let worker = MermaidWorker::new(0, fontdb);
        assert!(worker.is_ok());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_js_empty_override_matches_thread() {
        let _lock = env_lock();
        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
        {
            let _guard = MermaidJsEmptyGuard::set(true);
            assert!(mermaid_js_empty());
        }
        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_js_empty_override_mismatch_thread() {
        let _lock = env_lock();
        let handle = std::thread::spawn(|| set_mermaid_js_empty_for_test(true));
        let _ = handle.join();
        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
        set_mermaid_js_empty_for_test(false);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_js_empty_override_false_clears() {
        let _lock = env_lock();
        set_mermaid_js_empty_for_test(true);
        let previous = set_mermaid_js_empty_for_test(false);
        assert!(previous.is_some());
        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_js_empty_override_lock_busy() {
        let _lock = env_lock();
        let guard = MERMAID_JS_EMPTY_OVERRIDE.try_lock().expect("override lock");
        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
        drop(guard);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_worker_new_fails_when_js_empty() {
        let _lock = env_lock();
        let _guard = MermaidJsEmptyGuard::set(true);
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let err = MermaidWorker::new(0, Arc::new(fontdb))
            .err()
            .expect("expected error");
        assert!(err.contains("No embedded Mermaid JS"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_measure_text_native_handles_optional_weight() {
        let _lock = env_lock();
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
        worker.engine.ctx.with(|ctx| {
            let with_weight: Vec<f64> = ctx
                .eval("__mdmdview_measure_text_native('abc', 12, 700)")
                .expect("with weight");
            let without_weight: Vec<f64> = ctx
                .eval("__mdmdview_measure_text_native('abc', 12, undefined)")
                .expect("without weight");
            assert_eq!(with_weight.len(), 2);
            assert_eq!(without_weight.len(), 2);
        });
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_map_init_result_variants() {
        assert!(MermaidWorker::map_init_result(Ok(())).is_ok());
        let err = MermaidWorker::map_init_result(Err("oops".to_string())).unwrap_err();
        assert!(err.contains("Mermaid init error: oops"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_format_render_result_variants() {
        let ok = MermaidWorker::format_render_result(Ok("<svg></svg>".to_string()), 10, 5)
            .expect("ok result");
        assert!(ok.contains("<svg"));

        let err = MermaidWorker::format_render_result(Err("boom".to_string()), 10, 5).unwrap_err();
        assert!(err.contains("Mermaid render error: boom"));

        let timeout =
            MermaidWorker::format_render_result(Err("late".to_string()), 10, 20).unwrap_err();
        assert_eq!(timeout, "Mermaid render timed out");
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_process_job_missing_code_returns_error() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = std::sync::Arc::new(fontdb);
        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");

        let job = MermaidRequest {
            svg_key: 1,
            texture_key: "missing".to_string(),
            code: None,
            svg: None,
            width_bucket: 100,
            scale_bucket: MermaidRenderer::scale_bucket(1.0),
            viewport_width: 100,
            viewport_height: 100,
            bg: None,
        };

        let result = worker.process_job(job);
        assert!(result.svg.is_none());
        assert!(result.rgba.is_none());
        assert!(result.error.is_some());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_invalid_returns_error() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = std::sync::Arc::new(fontdb);
        let worker = MermaidWorker::new(0, fontdb).expect("worker init");

        let err = worker
            .rasterize_svg("not svg", 100, MermaidRenderer::scale_bucket(1.0), None)
            .unwrap_err();
        assert!(!err.is_empty());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_logs_when_env_set() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_LOG_RASTER", "1");
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = std::sync::Arc::new(fontdb);
        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
        let svg = r#"<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"></svg>"#;
        let (data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
            .expect("rasterize svg");
        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_viewbox_filter_rejects_small() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
        let svg = r#"<svg width="100" height="100" viewBox="0 0 0 0" xmlns="http://www.w3.org/2000/svg"></svg>"#;
        let (data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
            .expect("rasterize svg");
        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_skips_resize_when_bbox_exceeds_cap() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
        let svg = r#"<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect width="1000" height="1000" fill="red"/></svg>"#;
        let (_data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
            .expect("rasterize svg");
        assert_eq!((w, h), (10, 10));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_oversize_bbox_translates() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
        let svg = r#"<svg width="100" height="50" xmlns="http://www.w3.org/2000/svg"><rect x="-60" y="0" width="200" height="50" fill="red"/></svg>"#;
        let (_data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
            .expect("rasterize svg");
        assert!(w > 100);
        assert!(h >= 50);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_oversize_bbox_translate_y_only() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
        let svg = r#"<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="0" width="100" height="200" fill="red"/></svg>"#;
        let (_data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
            .expect("rasterize svg");
        assert!(w >= 108);
        assert!(h >= 200);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_clamps_large_width() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
        let svg = r#"<svg width="4100" height="10" xmlns="http://www.w3.org/2000/svg"><rect width="4100" height="10" fill="red"/></svg>"#;
        let (_data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
            .expect("rasterize svg");
        assert!(w <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
        assert!(h > 0);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_clamps_large_height() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
        let svg = r#"<svg width="10" height="10000" xmlns="http://www.w3.org/2000/svg"><rect width="10" height="10000" fill="red"/></svg>"#;
        let (_data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
            .expect("rasterize svg");
        assert!(w > 0);
        assert!(h <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_tiny_bbox_keeps_dimensions() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
        let svg = r#"<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect width="0.1" height="0.1" fill="red"/></svg>"#;
        let (_data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
            .expect("rasterize svg");
        assert_eq!((w, h), (10, 10));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_raw_tree_parse_failure_fallback() {
        let _lock = env_lock();
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
        force_raw_tree_parse_fail_for_test();
        let svg = r#"<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect width="20" height="20" fill="red"/></svg>"#;
        let (data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
            .expect("rasterize svg");
        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
        assert!(w > 0);
        assert!(h > 0);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_bbox_validation_helpers() {
        assert!(MermaidWorker::bbox_is_valid(10.0, 10.0, 0.0, 0.0));
        assert!(!MermaidWorker::bbox_is_valid(0.0, 10.0, 0.0, 0.0));
        assert!(!MermaidWorker::bbox_is_valid(10.0, 0.0, 0.0, 0.0));
        assert!(!MermaidWorker::bbox_is_valid(f32::NAN, 10.0, 0.0, 0.0));
        assert!(!MermaidWorker::bbox_is_valid(10.0, f32::INFINITY, 0.0, 0.0));
        assert!(!MermaidWorker::bbox_is_valid(10.0, 10.0, f32::NAN, 0.0));
        assert!(!MermaidWorker::bbox_is_valid(
            10.0,
            10.0,
            0.0,
            f32::INFINITY
        ));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_should_resize_bbox_variants() {
        assert!(MermaidWorker::should_resize_bbox(
            true, true, 1.0, 1.0, 10.0, 10.0
        ));
        assert!(!MermaidWorker::should_resize_bbox(
            true, false, 50.0, 50.0, 10.0, 10.0
        ));
        assert!(MermaidWorker::should_resize_bbox(
            false, true, 20.0, 5.0, 10.0, 10.0
        ));
        assert!(!MermaidWorker::should_resize_bbox(
            false, true, 11.0, 11.0, 10.0, 10.0
        ));
        assert!(!MermaidWorker::should_resize_bbox(
            false, false, 50.0, 50.0, 10.0, 10.0
        ));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_process_job_svg_input_rasterize_error() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = std::sync::Arc::new(fontdb);
        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");

        let job = MermaidRequest {
            svg_key: 2,
            texture_key: "bad-svg".to_string(),
            code: Some("graph TD; A-->B;".to_string()),
            svg: Some("not svg".to_string()),
            width_bucket: 100,
            scale_bucket: MermaidRenderer::scale_bucket(1.0),
            viewport_width: 100,
            viewport_height: 100,
            bg: None,
        };

        let result = worker.process_job(job);
        assert!(result.svg.is_some());
        assert!(result.rgba.is_none());
        assert!(result.error.is_some());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_adjusts_for_oversized_bbox() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = std::sync::Arc::new(fontdb);
        let worker = MermaidWorker::new(0, fontdb).expect("worker init");

        let svg = r#"<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
<rect x="-50" y="-50" width="200" height="200" fill="red"/>
</svg>"#;
        let (data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
            .expect("rasterize svg");
        assert_eq!((w, h), (208, 208));
        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_viewbox_filter_skips_small_dims() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = std::sync::Arc::new(fontdb);
        let worker = MermaidWorker::new(0, fontdb).expect("worker init");

        let svg = r#"<svg width="10" height="12" viewBox="0 0 0.1 0.1" xmlns="http://www.w3.org/2000/svg">
 <rect width="0.1" height="0.1" fill="red"/>
 </svg>"#;
        let (_data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
            .expect("rasterize svg");
        assert_eq!((w, h), (10, 12));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_keeps_dimensions_for_small_bbox() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = std::sync::Arc::new(fontdb);
        let worker = MermaidWorker::new(0, fontdb).expect("worker init");

        let svg = r#"<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
 <rect x="10" y="10" width="20" height="20" fill="red"/>
 </svg>"#;
        let (_data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
            .expect("rasterize svg");
        assert_eq!((w, h), (100, 100));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_clamps_to_max_side() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = std::sync::Arc::new(fontdb);
        let worker = MermaidWorker::new(0, fontdb).expect("worker init");

        let svg = r#"<svg width="10000" height="10000" viewBox="0 0 10000 10000" xmlns="http://www.w3.org/2000/svg">
<rect width="10000" height="10000" fill="blue"/>
</svg>"#;
        let (_data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
            .expect("rasterize svg");
        assert!(w <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
        assert!(h <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_applies_background_fill() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = std::sync::Arc::new(fontdb);
        let worker = MermaidWorker::new(0, fontdb).expect("worker init");

        let svg = r#"<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"></svg>"#;
        let bg = Some([10, 20, 30, 200]);
        let (data, w, h) = worker
            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), bg)
            .expect("rasterize svg");
        assert_eq!((w, h), (4, 4));
        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
        let alpha = 200.0_f32 / 255.0;
        let expected_r = (10.0_f32 * alpha).round() as u8;
        let expected_g = (20.0_f32 * alpha).round() as u8;
        let expected_b = (30.0_f32 * alpha).round() as u8;
        assert_eq!(data[0], expected_r);
        assert_eq!(data[1], expected_g);
        assert_eq!(data[2], expected_b);
        assert_eq!(data[3], 200);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_process_job_applies_svg_fixups() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = std::sync::Arc::new(fontdb);
        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");

        let svg = r#"<svg width="120" height="120" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
<switch>
  <foreignObject><div>Plan</div></foreignObject>
  <text class="journey-section section-type-0" x="10">Plan</text>
</switch>
<g id="state-root_end-0">
  <circle class="state-end" r="5" width="10" height="10"></circle>
  <circle class="state-start" r="7" width="14" height="14"></circle>
</g>
<rect class="er attributeBoxOdd"></rect>
</svg>"#;

        let job = MermaidRequest {
            svg_key: 4,
            texture_key: "fixups".to_string(),
            code: None,
            svg: Some(svg.to_string()),
            width_bucket: 0,
            scale_bucket: MermaidRenderer::scale_bucket(1.0),
            viewport_width: 120,
            viewport_height: 120,
            bg: None,
        };

        let result = worker.process_job(job);
        let rendered = result.svg.expect("svg output");
        assert!(!rendered.contains("<switch"));
        assert!(rendered.contains("fill:"));
        assert!(rendered.contains("end-state-inner"));
        assert!(rendered.contains("attributeBoxOdd"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_dump_helpers_sanitize_labels() {
        let _lock = env_lock();
        let dir = tempdir().expect("temp dir");
        let _guard = EnvGuard::set(
            "MDMDVIEW_MERMAID_DUMP_DIR",
            dir.path().to_string_lossy().as_ref(),
        );
        MermaidWorker::maybe_dump_svg(10, Some("ok-label 123"), "<svg></svg>");
        MermaidWorker::maybe_dump_error(11, Some("::bad label::"), "boom");
        MermaidWorker::maybe_dump_error(12, Some("good_label"), "ok");
        MermaidWorker::maybe_dump_svg(13, Some("\nrest"), "<svg></svg>");
        MermaidWorker::maybe_dump_error(14, Some("dash-label"), "dash");
        MermaidWorker::maybe_dump_error(14, Some("abcdefghijklmnopqrstuvwxyz0123456789"), "long");
        MermaidWorker::maybe_dump_svg(
            16,
            Some("abcdefghijklmnopqrstuvwxyz0123456789"),
            "<svg></svg>",
        );
        MermaidWorker::maybe_dump_svg(16, Some("under_score"), "<svg></svg>");
        MermaidWorker::maybe_dump_error(15, None, "no code");
        MermaidWorker::maybe_dump_svg(17, None, "<svg></svg>");
        MermaidWorker::maybe_dump_error(18, Some(""), "empty");
        MermaidWorker::maybe_dump_svg(19, Some(""), "<svg></svg>");
        MermaidWorker::maybe_dump_error(20, Some("\nrest"), "empty-label");

        let entries: Vec<_> = std::fs::read_dir(dir.path())
            .expect("read dir")
            .filter_map(|entry| entry.ok())
            .collect();
        assert!(entries
            .iter()
            .any(|entry| entry.path().extension() == Some("svg".as_ref())));
        assert!(entries
            .iter()
            .any(|entry| entry.path().extension() == Some("txt".as_ref())));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_dump_helpers_empty_dir_env_noop() {
        let _lock = env_lock();
        let dir = tempdir().expect("temp dir");
        let seed_path = dir.path().join("seed.txt");
        std::fs::write(&seed_path, "seed").expect("seed write");
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_DUMP_DIR", "   ");
        MermaidWorker::maybe_dump_svg(20, Some("label"), "<svg></svg>");
        MermaidWorker::maybe_dump_error(21, Some("label"), "err");
        let entries: Vec<_> = std::fs::read_dir(dir.path())
            .expect("read dir")
            .filter_map(|entry| entry.ok())
            .collect();
        assert_eq!(entries.len(), 1);
        assert_eq!(entries[0].path(), seed_path);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_dump_helpers_invalid_dir_noop() {
        let _lock = env_lock();
        let dir = tempdir().expect("temp dir");
        let file_path = dir.path().join("not_a_dir.txt");
        std::fs::write(&file_path, "data").expect("write file");
        let _guard = EnvGuard::set(
            "MDMDVIEW_MERMAID_DUMP_DIR",
            file_path.to_string_lossy().as_ref(),
        );
        MermaidWorker::maybe_dump_svg(22, Some("label"), "<svg></svg>");
        MermaidWorker::maybe_dump_error(23, Some("label"), "err");
        let entries: Vec<_> = std::fs::read_dir(dir.path())
            .expect("read dir")
            .filter_map(|entry| entry.ok())
            .collect();
        assert_eq!(entries.len(), 1);
        assert!(entries[0].path().ends_with("not_a_dir.txt"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_poll_mermaid_results_handles_variants() {
        let (result_tx, result_rx) = bounded(10);
        let renderer = MermaidRenderer {
            mermaid_textures: RefCell::new(LruCache::new(4)),
            mermaid_pending: RefCell::new(std::collections::HashSet::new()),
            mermaid_frame_pending: std::cell::Cell::new(false),
            mermaid_svg_cache: RefCell::new(LruCache::new(4)),
            mermaid_errors: RefCell::new(LruCache::new(4)),
            mermaid_texture_errors: RefCell::new(LruCache::new(4)),
            mermaid_job_tx: None,
            mermaid_result_rx: result_rx,
            worker_handles: Vec::new(),
        };
        let ctx = egui::Context::default();

        renderer
            .mermaid_pending
            .borrow_mut()
            .insert("k1".to_string());
        result_tx
            .send(MermaidResult {
                svg_key: 1,
                texture_key: "k1".to_string(),
                svg: Some("<svg width=\"1\" height=\"1\"></svg>".to_string()),
                rgba: None,
                size: None,
                error: None,
            })
            .expect("send svg");
        assert!(renderer.poll_mermaid_results(&ctx));
        assert!(renderer.mermaid_svg_cache.borrow_mut().get(&1).is_some());

        renderer
            .mermaid_pending
            .borrow_mut()
            .insert("k2".to_string());
        result_tx
            .send(MermaidResult {
                svg_key: 2,
                texture_key: "k2".to_string(),
                svg: None,
                rgba: Some(vec![0, 0, 0, 0]),
                size: None,
                error: None,
            })
            .expect("send rgba missing size");
        renderer.poll_mermaid_results(&ctx);
        assert!(renderer
            .mermaid_texture_errors
            .borrow_mut()
            .get(&"k2".to_string())
            .is_some());

        renderer
            .mermaid_pending
            .borrow_mut()
            .insert("k3".to_string());
        result_tx
            .send(MermaidResult {
                svg_key: 3,
                texture_key: "k3".to_string(),
                svg: None,
                rgba: None,
                size: None,
                error: Some("boom".to_string()),
            })
            .expect("send error");
        renderer.poll_mermaid_results(&ctx);
        assert!(renderer.mermaid_errors.borrow_mut().get(&3).is_some());

        renderer
            .mermaid_pending
            .borrow_mut()
            .insert("k4".to_string());
        result_tx
            .send(MermaidResult {
                svg_key: 4,
                texture_key: "k4".to_string(),
                svg: Some("<svg width=\"1\" height=\"1\"></svg>".to_string()),
                rgba: None,
                size: None,
                error: Some("oops".to_string()),
            })
            .expect("send texture error");
        renderer.poll_mermaid_results(&ctx);
        assert!(renderer
            .mermaid_texture_errors
            .borrow_mut()
            .get(&"k4".to_string())
            .is_some());

        renderer
            .mermaid_pending
            .borrow_mut()
            .insert("k5".to_string());
        result_tx
            .send(MermaidResult {
                svg_key: 5,
                texture_key: "k5".to_string(),
                svg: None,
                rgba: Some(vec![255, 255, 255, 255]),
                size: Some((1, 1)),
                error: None,
            })
            .expect("send rgba with size");
        renderer.poll_mermaid_results(&ctx);
        assert!(renderer
            .mermaid_textures
            .borrow_mut()
            .get(&"k5".to_string())
            .is_some());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_format_js_error_variants() {
        let rt = rquickjs::Runtime::new().expect("runtime");
        let ctx = rquickjs::Context::full(&rt).expect("context");
        ctx.with(|ctx| {
            let err = ctx.eval::<(), _>("throw new Error('boom')").unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert!(msg.contains("boom"));

            let err = ctx
                .eval::<(), _>("var e = new Error('match'); e.stack = 'match\\nstack'; throw e;")
                .unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert!(msg.contains("match"));

            let err = ctx
                .eval::<(), _>("var e = new Error('note'); e.stack = 'stack only'; throw e;")
                .unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert!(!msg.is_empty());

            let err = ctx
                .eval::<(), _>("var e = new Error('blank'); e.stack = ' '; throw e;")
                .unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert!(msg.contains("blank"));

            let err = ctx
                .eval::<(), _>("throw ({ stack: 'stack-only-obj' })")
                .unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert!(!msg.is_empty());

            let err = ctx
                .eval::<(), _>("throw ({ message: 'message-only-obj' })")
                .unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert!(!msg.is_empty());

            let err = ctx
                .eval::<(), _>("var e = new Error(''); e.message = undefined; e.stack = 'stack-only'; throw e;")
                .unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert!(msg.contains("stack-only"));

            let err = ctx
                .eval::<(), _>("var e = new Error('solo'); delete e.stack; throw e;")
                .unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert!(msg.contains("solo"));

            let err = ctx
                .eval::<(), _>("var e = new Error('solo2'); e.stack = undefined; throw e;")
                .unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert!(msg.contains("solo2"));

            let err = ctx
                .eval::<(), _>("var e = new Error('zap'); e.stack = ''; throw e;")
                .unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert!(msg.contains("zap"));

            let err = ctx
                .eval::<(), _>("var e = new Error(''); e.message = ''; e.stack = ''; throw e;")
                .unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert!(!msg.is_empty());

            let err = ctx.eval::<(), _>("throw 'stringy'").unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert_eq!(msg, "stringy");

            let err = ctx.eval::<(), _>("throw 42").unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert_eq!(msg, "42");

            let err = ctx.eval::<(), _>("throw 3.5").unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert!(msg.contains("3.5"));

            let err = ctx.eval::<(), _>("throw true").unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert_eq!(msg, "true");

            let msg = MermaidWorker::format_js_error(&ctx, rquickjs::Error::Unknown);
            assert!(!msg.is_empty());

            let err = ctx.eval::<(), _>("throw ({})").unwrap_err();
            let msg = MermaidWorker::format_js_error(&ctx, err);
            assert!(!msg.is_empty());
        });
    }

    struct EnvGuard {
        key: &'static str,
        original: Option<String>,
    }

    impl EnvGuard {
        fn set(key: &'static str, value: &str) -> Self {
            let original = std::env::var(key).ok();
            std::env::set_var(key, value);
            Self { key, original }
        }
    }

    impl Drop for EnvGuard {
        fn drop(&mut self) {
            if let Some(value) = &self.original {
                std::env::set_var(self.key, value);
            } else {
                std::env::remove_var(self.key);
            }
        }
    }

    #[cfg(feature = "mermaid-quickjs")]
    struct MermaidJsEmptyGuard {
        previous: Option<std::thread::ThreadId>,
    }

    #[cfg(feature = "mermaid-quickjs")]
    impl MermaidJsEmptyGuard {
        fn set(value: bool) -> Self {
            let previous = set_mermaid_js_empty_for_test(value);
            Self { previous }
        }
    }

    #[cfg(feature = "mermaid-quickjs")]
    impl Drop for MermaidJsEmptyGuard {
        fn drop(&mut self) {
            let mut guard = MERMAID_JS_EMPTY_OVERRIDE
                .lock()
                .expect("mermaid js override lock");
            *guard = self.previous;
        }
    }

    #[test]
    fn test_parse_hex_color_and_mermaid_bg_fill() {
        let _lock = env_lock();
        assert_eq!(
            MermaidRenderer::parse_hex_color("#ff00ff"),
            Some([255, 0, 255, 255])
        );
        assert_eq!(
            MermaidRenderer::parse_hex_color("11223344"),
            Some([17, 34, 51, 68])
        );
        assert!(MermaidRenderer::parse_hex_color("bad").is_none());
        assert!(MermaidRenderer::parse_hex_color("GG0000").is_none());
        assert!(MermaidRenderer::parse_hex_color("00GG00").is_none());
        assert!(MermaidRenderer::parse_hex_color("0000GG").is_none());
        assert!(MermaidRenderer::parse_hex_color("GG000000").is_none());
        assert!(MermaidRenderer::parse_hex_color("00GG0000").is_none());
        assert!(MermaidRenderer::parse_hex_color("0000GG00").is_none());
        assert!(MermaidRenderer::parse_hex_color("000000GG").is_none());

        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG_COLOR", "#010203");
            assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([1, 2, 3, 255]));
        }

        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "transparent");
            assert_eq!(MermaidRenderer::mermaid_bg_fill(), None);
        }

        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "dark");
            assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([20, 20, 20, 255]));
        }
    }

    #[test]
    fn test_env_guard_restores_original_value() {
        let _lock = env_lock();
        std::env::set_var("MDMDVIEW_MERMAID_PATCH_DEBUG", "before");
        {
            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "after");
            assert_eq!(
                std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG")
                    .ok()
                    .as_deref(),
                Some("after")
            );
        }
        assert_eq!(
            std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG")
                .ok()
                .as_deref(),
            Some("before")
        );
        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
    }

    #[test]
    fn test_mermaid_bg_fill_invalid_color_falls_back() {
        let _lock = env_lock();
        let _guard_color = EnvGuard::set("MDMDVIEW_MERMAID_BG_COLOR", "bad");
        let _guard_mode = EnvGuard::set("MDMDVIEW_MERMAID_BG", "dark");
        assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([20, 20, 20, 255]));
    }

    #[test]
    fn test_mermaid_bg_fill_invalid_theme_color_uses_default() {
        let _lock = env_lock();
        let _guard_mode = EnvGuard::set("MDMDVIEW_MERMAID_BG", "theme");
        let _guard_bkg = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "bad");
        assert_eq!(
            MermaidRenderer::mermaid_bg_fill(),
            Some([255, 248, 219, 255])
        );
    }

    #[test]
    fn test_mermaid_bg_key_and_scale_bucket() {
        assert_eq!(MermaidRenderer::mermaid_bg_key(None), "none");
        assert_eq!(
            MermaidRenderer::mermaid_bg_key(Some([1, 2, 3, 4])),
            "01020304"
        );

        let factor = MermaidRenderer::MERMAID_SCALE_BUCKET_FACTOR;
        assert_eq!(
            MermaidRenderer::scale_bucket(0.1),
            (0.5 * factor).round() as u32
        );
        assert_eq!(
            MermaidRenderer::scale_bucket(10.0),
            (4.0 * factor).round() as u32
        );
    }

    #[test]
    fn test_mermaid_hash_str_stable_and_distinct() {
        let a = MermaidRenderer::hash_str("alpha");
        let b = MermaidRenderer::hash_str("alpha");
        let c = MermaidRenderer::hash_str("beta");
        assert_eq!(a, b);
        assert_ne!(a, c);
    }

    #[test]
    fn test_mermaid_bg_fill_light_mode() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "light");
        assert_eq!(
            MermaidRenderer::mermaid_bg_fill(),
            Some([255, 255, 255, 255])
        );
    }

    #[test]
    fn test_mermaid_bg_fill_color_override() {
        let _lock = env_lock();
        std::env::remove_var("MDMDVIEW_MERMAID_BG");
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG_COLOR", "#11223344");
        assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([17, 34, 51, 68]));
    }

    #[test]
    fn test_mermaid_bg_fill_theme_fallback() {
        let _lock = env_lock();
        let _guard_mode = EnvGuard::set("MDMDVIEW_MERMAID_BG", "theme");
        let _guard_bkg = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "#010203");
        assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([1, 2, 3, 255]));
    }

    #[test]
    fn test_render_block_off_and_embedded_without_feature() {
        let _lock = env_lock();
        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
        let renderer = MermaidRenderer::new();
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(800.0, 600.0),
            )),
            ..Default::default()
        };

        let mut rendered = true;
        let _ = ctx.run(input.clone(), |ctx| {
            egui::CentralPanel::default().show(ctx, |ui| {
                rendered = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
            });
        });
        assert!(rendered);

        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "off");
        let renderer = MermaidRenderer::new();
        let mut rendered_off = true;
        let _ = ctx.run(input.clone(), |ctx| {
            egui::CentralPanel::default().show(ctx, |ui| {
                rendered_off = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
            });
        });
        assert!(rendered_off);

        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
        let renderer = MermaidRenderer::new();
        let mut rendered_embedded = true;
        let _ = ctx.run(input, |ctx| {
            egui::CentralPanel::default().show(ctx, |ui| {
                rendered_embedded = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
            });
        });
        assert!(rendered_embedded);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_render_block_embedded_missing_js_fallback() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
        let _empty = MermaidJsEmptyGuard::set(true);
        let (_tx, rx) = bounded(1);
        let renderer = test_renderer_with_channels(None, rx);
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(800.0, 600.0),
            )),
            ..Default::default()
        };

        let mut rendered = true;
        let _ = ctx.run(input, |ctx| {
            egui::CentralPanel::default().show(ctx, |ui| {
                rendered = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
            });
        });
        assert!(rendered);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_render_block_width_fallback_for_small_ui() {
        let _lock = env_lock();
        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
        let renderer = MermaidRenderer::new();
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(800.0, 600.0),
            )),
            ..Default::default()
        };

        let mut rendered = true;
        let _ = ctx.run(input, |ctx| {
            egui::CentralPanel::default().show(ctx, |ui| {
                ui.allocate_ui_with_layout(
                    egui::vec2(20.0, 200.0),
                    egui::Layout::top_down(egui::Align::Min),
                    |ui| {
                        rendered = renderer.render_block(ui, "%% comment", 1.0, 14.0);
                    },
                );
            });
        });
        assert!(rendered);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_render_block_width_fallback_equal_screen() {
        let _lock = env_lock();
        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
        let renderer = MermaidRenderer::new();
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(20.0, 200.0),
            )),
            ..Default::default()
        };

        let mut rendered = true;
        let _ = ctx.run(input, |ctx| {
            egui::CentralPanel::default().show(ctx, |ui| {
                ui.allocate_ui_with_layout(
                    egui::vec2(20.0, 200.0),
                    egui::Layout::top_down(egui::Align::Min),
                    |ui| {
                        rendered = renderer.render_block(ui, "%% comment", 1.0, 14.0);
                    },
                );
            });
        });
        assert!(rendered);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_render_block_uses_cached_texture_scales() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
        let (_result_tx, result_rx) = bounded(1);
        let renderer = test_renderer_with_channels(None, result_rx);
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(240.0, 160.0),
            )),
            ..Default::default()
        };
        let code = "graph TD; A-->B;";
        let mut rendered_large = false;
        let mut rendered_small = false;

        let _ = ctx.run(input, |ctx| {
            egui::CentralPanel::default().show(ctx, |ui| {
                let image = egui::ColorImage::new([2, 2], Color32::WHITE);
                let texture =
                    ui.ctx()
                        .load_texture("mermaid-test", image, egui::TextureOptions::default());
                let svg_key = MermaidRenderer::hash_str(code);
                let make_key = |ui: &egui::Ui| {
                    let width_bucket = MermaidRenderer::width_bucket(ui.available_width());
                    let scale_bucket = MermaidRenderer::scale_bucket(1.0);
                    let bg = MermaidRenderer::mermaid_bg_fill();
                    MermaidRenderer::texture_key(svg_key, width_bucket, scale_bucket, bg)
                };

                let texture_key = make_key(ui);
                renderer.mermaid_textures.borrow_mut().insert(
                    texture_key.clone(),
                    MermaidTextureEntry {
                        texture: texture.clone(),
                        size: [400, 200],
                    },
                );
                rendered_large = renderer.render_block(ui, code, 1.0, 14.0);

                let texture_key = make_key(ui);
                renderer.mermaid_textures.borrow_mut().insert(
                    texture_key,
                    MermaidTextureEntry {
                        texture,
                        size: [20, 10],
                    },
                );
                rendered_small = renderer.render_block(ui, code, 1.0, 14.0);
            });
        });

        assert!(rendered_large);
        assert!(rendered_small);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_render_block_reports_cached_error() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
        let (_result_tx, result_rx) = bounded(1);
        let renderer = test_renderer_with_channels(None, result_rx);
        let code = "graph TD; A-->B;";
        let svg_key = MermaidRenderer::hash_str(code);
        renderer
            .mermaid_errors
            .borrow_mut()
            .insert(svg_key, "boom".to_string());
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(240.0, 160.0),
            )),
            ..Default::default()
        };
        let mut rendered = false;
        let _ = ctx.run(input, |ctx| {
            egui::CentralPanel::default().show(ctx, |ui| {
                rendered = renderer.render_block(ui, code, 1.0, 14.0);
            });
        });
        assert!(rendered);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_render_block_queue_full_sets_waiting() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
        let (job_tx, job_rx) = bounded(1);
        let (_result_tx, result_rx) = bounded(1);
        let renderer = test_renderer_with_channels(Some(job_tx.clone()), result_rx);
        let request = MermaidRequest {
            svg_key: 1,
            texture_key: "full".to_string(),
            code: Some("graph TD; A-->B;".to_string()),
            svg: None,
            width_bucket: 32,
            scale_bucket: MermaidRenderer::scale_bucket(1.0),
            viewport_width: 120,
            viewport_height: 120,
            bg: MermaidRenderer::mermaid_bg_fill(),
        };
        job_tx.send(request).expect("fill queue");

        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(240.0, 160.0),
            )),
            ..Default::default()
        };
        let mut rendered = false;
        let _ = ctx.run(input, |ctx| {
            egui::CentralPanel::default().show(ctx, |ui| {
                rendered = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
            });
        });
        assert!(rendered);
        assert!(renderer.mermaid_frame_pending.get());
        drop(job_rx);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_render_block_disconnected_queue_sets_error() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
        let (_result_tx, result_rx) = bounded(1);
        let renderer = test_renderer_with_channels(None, result_rx);
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(240.0, 160.0),
            )),
            ..Default::default()
        };
        let code = "graph TD; A-->B;";
        let mut rendered = false;
        let _ = ctx.run(input, |ctx| {
            egui::CentralPanel::default().show(ctx, |ui| {
                rendered = renderer.render_block(ui, code, 1.0, 14.0);
            });
        });
        assert!(rendered);
        let svg_key = MermaidRenderer::hash_str(code);
        assert!(renderer.mermaid_errors.borrow_mut().get(&svg_key).is_some());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_render_block_pending_and_width_fallback() {
        let _lock = env_lock();
        let _guard_renderer = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
        let _guard_log = EnvGuard::set("MDMDVIEW_MERMAID_LOG_WIDTH", "1");
        let (job_tx, job_rx) = bounded(2);
        let (result_tx, result_rx) = bounded(2);
        let renderer = test_renderer_with_channels(Some(job_tx), result_rx);
        result_tx
            .send(MermaidResult {
                svg_key: 99,
                texture_key: "other".to_string(),
                svg: Some("<svg width=\"1\" height=\"1\"></svg>".to_string()),
                rgba: None,
                size: None,
                error: None,
            })
            .expect("send svg");

        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(200.0, 120.0),
            )),
            ..Default::default()
        };
        let code = "timeline\n  title Demo";
        let mut rendered_first = false;
        let mut rendered_second = false;
        let _ = ctx.run(input, |ctx| {
            egui::CentralPanel::default().show(ctx, |ui| {
                let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(10.0, 80.0));
                ui.allocate_ui_at_rect(rect, |ui| {
                    rendered_first = renderer.render_block(ui, code, 1.0, 14.0);
                    rendered_second = renderer.render_block(ui, code, 1.0, 14.0);
                });
            });
        });
        assert!(rendered_first);
        assert!(rendered_second);
        drop(job_rx);
    }

    #[test]
    fn test_mermaid_cache_insert_existing_key_and_empty_order() {
        let mut cache = LruCache::new(1);
        cache.insert(1u8, "one".to_string());
        cache.insert(1u8, "uno".to_string());
        assert_eq!(cache.get(&1), Some("uno".to_string()));
        assert!(cache.get(&9).is_none());

        cache.insert(2u8, "two".to_string());
        assert!(cache.get(&1).is_none());

        cache.entries.clear();
        cache.entries.insert(2u8, "two".to_string());
        cache.order.clear();
        cache.insert(3u8, "three".to_string());
        assert_eq!(cache.len(), 2);
    }

    #[test]
    fn test_mermaid_has_pending_default_false() {
        let renderer = MermaidRenderer::new();
        assert!(!renderer.has_pending());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_has_pending_true_for_frame_or_queue() {
        let renderer = MermaidRenderer::new();
        renderer.mermaid_frame_pending.set(true);
        assert!(renderer.has_pending());
        renderer.mermaid_frame_pending.set(false);
        renderer
            .mermaid_pending
            .borrow_mut()
            .insert("pending".to_string());
        assert!(renderer.has_pending());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_journey_section_text_fill_adds_fill() {
        let input = r#"<svg><text class="journey-section section-type-0" x="0">Plan</text></svg>"#;
        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
            .expect("journey text updated");
        assert!(output.contains("class=\"journey-section section-type-0\""));
        assert!(output.contains("fill:#112233"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_journey_section_text_overwrites_fill_in_style() {
        let input = r#"<svg><text class="journey-section" style="fill:#000000;stroke:#fff" x="0">Plan</text></svg>"#;
        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
            .expect("journey text updated");
        assert!(output.contains("fill:#112233"));
        assert!(!output.contains("fill:#000000"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_journey_section_text_skips_empty_style_parts() {
        let input = r#"<svg><text class="journey-section" style="fill:#000000;;stroke:#fff" x="0">Plan</text></svg>"#;
        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
            .expect("journey text updated");
        assert!(output.contains("fill:#112233"));
        assert!(output.contains("stroke:#fff"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_journey_section_text_noop_without_marker() {
        let input = r#"<svg><text class="label" x="0">Plan</text></svg>"#;
        assert!(MermaidWorker::fix_journey_section_text(input, "#112233").is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_journey_section_text_handles_non_section_tag() {
        let input = r#"<svg><text class="label">A</text><text class="journey-section" style="fill:#000">B</text></svg>"#;
        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
            .expect("journey text updated");
        assert!(output.contains("class=\"label\""));
        assert!(output.contains("fill:#112233"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_journey_section_text_style_missing_quote_returns_none() {
        let input = r#"<svg><text class="journey-section" style="fill:#000>Plan</text></svg>"#;
        assert!(MermaidWorker::fix_journey_section_text(input, "#112233").is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_state_end_circles_swaps_radii() {
        let input = r#"<svg><g id="state-root_end-0"><circle class="state-end" r="5" width="10" height="10"></circle><circle class="state-start" r="7" width="14" height="14"></circle></g></svg>"#;
        let output =
            MermaidWorker::fix_state_end_circles(input).expect("state end circles updated");
        assert!(output.contains("class=\"state-end\" r=\"7\""));
        assert!(output.contains("class=\"end-state-inner\" r=\"5\""));
        assert!(output.contains("class=\"state-end\" r=\"7\" width=\"14\" height=\"14\""));
        assert!(output.contains("class=\"end-state-inner\" r=\"5\" width=\"10\" height=\"10\""));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_state_end_circles_swaps_radii_when_start_first() {
        let input = r#"<svg><g id="state-root_end-0"><circle class="state-start" r="7" width="14" height="14"></circle><circle class="state-end" r="5" width="10" height="10"></circle></g></svg>"#;
        let output =
            MermaidWorker::fix_state_end_circles(input).expect("state end circles updated");
        assert!(output.contains("end-state-inner"));
        assert!(output.contains("class=\"state-end\" r=\"7\""));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_state_end_circles_noop_without_marker() {
        let input = r#"<svg><g><circle class="state-start" r="7"></circle></g></svg>"#;
        assert!(MermaidWorker::fix_state_end_circles(input).is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_state_end_circles_noop_when_radii_ordered() {
        let input = r#"<svg><g id="state-root_end-0"><circle class="state-end" r="7"></circle><circle class="state-start" r="5"></circle></g></svg>"#;
        assert!(MermaidWorker::fix_state_end_circles(input).is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_state_end_circles_skips_non_end_group() {
        let input = r#"<svg><g id="state-root-0"><circle class="state-end" r="5"></circle></g><g id="state-root_end-0"><circle class="state-end" r="5" width="10" height="10"></circle><circle class="state-start" r="7" width="14" height="14"></circle></g></svg>"#;
        let output =
            MermaidWorker::fix_state_end_circles(input).expect("state end circles updated");
        assert!(output.contains("state-root-0"));
        assert!(output.contains("end-state-inner"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_state_end_circles_missing_parts_noop() {
        let missing_start =
            r#"<svg><g id="state-root_end-0"><circle class="state-end" r="5"></circle></g></svg>"#;
        assert!(MermaidWorker::fix_state_end_circles(missing_start).is_none());

        let missing_r = r#"<svg><g id="state-root_end-0"><circle class="state-end"></circle><circle class="state-start" r="7"></circle></g></svg>"#;
        assert!(MermaidWorker::fix_state_end_circles(missing_r).is_none());

        let non_numeric = r#"<svg><g id="state-root_end-0"><circle class="state-end" r="x"></circle><circle class="state-start" r="7"></circle></g></svg>"#;
        assert!(MermaidWorker::fix_state_end_circles(non_numeric).is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_find_circle_tag_missing_parts_returns_none() {
        let missing_circle = r#"<g class="state-end"></g>"#;
        assert!(MermaidWorker::find_circle_tag(missing_circle, "state-end").is_none());

        let missing_end = r#"<circle class="state-end""#;
        assert!(MermaidWorker::find_circle_tag(missing_end, "state-end").is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_read_r_value_missing_quote_returns_none() {
        let tag = r#"<circle r="10"#;
        assert!(MermaidWorker::read_r_value(tag).is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mindmap_edge_trim_uses_min_radius() {
        let dx_idx = MERMAID_DOM_SHIM
            .find("var dx = t_pos.x - s_pos.x")
            .expect("mindmap dx computed");
        let radius_idx = MERMAID_DOM_SHIM
            .find("var s_radius = __mdmdview_rect_intersection")
            .expect("mindmap radius computed");
        assert!(dx_idx < radius_idx);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mindmap_edge_overlap_padding_present() {
        assert!(MERMAID_DOM_SHIM.contains("var overlap = -2"));
        assert!(MERMAID_DOM_SHIM.contains("var max_total = len * 0.95"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_flatten_svg_switches_removes_foreignobject() {
        let input = r#"<svg><switch><foreignObject><div>Plan</div></foreignObject><text>Plan</text></switch></svg>"#;
        let output = MermaidWorker::flatten_svg_switches(input).expect("switch flattened");
        assert!(!output.contains("<switch"));
        assert!(!output.contains("foreignObject"));
        assert!(output.contains("<text>Plan</text>"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_dom_shim_clusters_not_labelish() {
        assert!(MERMAID_DOM_SHIM.contains("has_class(node, 'clusters')"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_er_attribute_fills_inlines_colors() {
        let input = r#"<svg><rect class="er attributeBoxOdd"></rect><rect class="er attributeBoxEven"></rect></svg>"#;
        let output = MermaidWorker::fix_er_attribute_fills(input).expect("er fills updated");
        assert!(output.contains("attributeBoxOdd\" fill=\"#ffffff\""));
        assert!(output.contains("attributeBoxEven\" fill=\"#f2f2f2\""));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_er_attribute_fills_handles_even_only() {
        let input = r#"<svg><rect class="er attributeBoxEven"></rect></svg>"#;
        let output = MermaidWorker::fix_er_attribute_fills(input).expect("er fills updated");
        assert!(output.contains("attributeBoxEven\" fill=\"#f2f2f2\""));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_er_attribute_fills_skips_unmatched_rects() {
        let input =
            r#"<svg><rect class="er attributeBoxOdd"></rect><rect class="er"></rect></svg>"#;
        let output = MermaidWorker::fix_er_attribute_fills(input).expect("er fills updated");
        assert!(output.contains("attributeBoxOdd\" fill=\"#ffffff\""));
        assert!(output.contains("class=\"er\"></rect>"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_er_attribute_fills_noop_without_markers() {
        let input = r#"<svg><rect class="er"></rect></svg>"#;
        assert!(MermaidWorker::fix_er_attribute_fills(input).is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_fix_er_attribute_fills_noop_when_fill_matches() {
        let input = r##"<svg><rect class="er attributeBoxOdd" fill="#ffffff"></rect></svg>"##;
        assert!(MermaidWorker::fix_er_attribute_fills(input).is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_flatten_svg_switches_noop_without_switch() {
        let input = r#"<svg><text>Plan</text></svg>"#;
        assert!(MermaidWorker::flatten_svg_switches(input).is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_flatten_svg_switches_handles_missing_close() {
        let input = r#"<svg><switch><text>Plan</text></svg>"#;
        assert!(MermaidWorker::flatten_svg_switches(input).is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_flatten_svg_switches_missing_foreign_object_close() {
        let input =
            r#"<svg><switch><foreignObject><div>Plan</div></switch><text>After</text></svg>"#;
        let output = MermaidWorker::flatten_svg_switches(input).expect("switch flattened");
        assert!(output.contains("<text>After</text>"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_patch_mermaid_js_applies_expected_replacements() {
        let js = concat!(
            "var hD=wRe();",
            "FY.prototype={constructor:FY,appendChild:function(i){return this._parent.insertBefore(i,this._next)},insertBefore:function(i,s){return this._parent.insertBefore(i,s)},querySelector:function(i){return this._parent.querySelector(i)},querySelectorAll:function(i){return this._parent.querySelectorAll(i)}};",
            "function FY(i,s){this.ownerDocument=i.ownerDocument,this.namespaceURI=i.namespaceURI,this._next=null,this._parent=i,this.__data__=s}",
            "u.text().split(/(\\s+|<br>)/).reverse()",
            "p=fWe({container:document.getElementById(\"cy\"),style:[{selector:\"edge\",style:{\"curve-style\":\"bezier\"}}]});",
            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run(),p.ready(v=>{Xe.info(\"Ready\",v),u(p)})",
            "const se=_.node().getBBox();"
        );
        let output = MermaidWorker::patch_mermaid_js(js);
        assert!(output.contains("sanitize:function"));
        assert!(output.contains("document.body"));
        assert!(output.contains("String(typeof u.text"));
        assert!(output.contains("__mdmdview_cytoscape_stub"));
        assert!(output.contains("breadthfirst"));
        assert!(output.contains("se.width=Math.max"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_patch_mermaid_js_applies_mindmap_layout_fallback() {
        let js =
            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
        let output = MermaidWorker::patch_mermaid_js(js);
        assert!(output.contains("breadthfirst"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_patch_mermaid_js_debug_paths_without_targets() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
        let js = "console.log('no targets here');";
        let output = MermaidWorker::patch_mermaid_js(js);
        assert_eq!(output, js);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_patch_mermaid_js_debug_false_branch() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
        let previous = std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG").ok();
        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
        let js =
            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
        let output = MermaidWorker::patch_mermaid_js(js);
        assert!(output.contains("breadthfirst"));
        restore_env_var("MDMDVIEW_MERMAID_PATCH_DEBUG", previous);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_patch_mermaid_js_debug_restore_when_missing() {
        let _lock = env_lock();
        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
        let previous = std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG").ok();
        let js =
            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
        let output = MermaidWorker::patch_mermaid_js(js);
        assert!(output.contains("breadthfirst"));
        restore_env_var("MDMDVIEW_MERMAID_PATCH_DEBUG", previous);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_patch_mermaid_js_debug_missing_layout_not_logged_when_debug_off() {
        let _lock = env_lock();
        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
        let js = "console.log('no targets here');";
        let output = MermaidWorker::patch_mermaid_js(js);
        assert_eq!(output, js);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_patch_mermaid_js_debug_paths_with_targets() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
        let js = concat!(
            "var hD=wRe();",
            "FY.prototype={constructor:FY,appendChild:function(i){return this._parent.insertBefore(i,this._next)},insertBefore:function(i,s){return this._parent.insertBefore(i,s)},querySelector:function(i){return this._parent.querySelector(i)},querySelectorAll:function(i){return this._parent.querySelectorAll(i)}};",
            "function FY(i,s){this.ownerDocument=i.ownerDocument,this.namespaceURI=i.namespaceURI,this._next=null,this._parent=i,this.__data__=s}",
            "u.text().split(/(\\s+|<br>)/).reverse()",
            "p=fWe({container:document.getElementById(\"cy\"),style:[{selector:\"edge\",style:{\"curve-style\":\"bezier\"}}]});",
            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run(),p.ready(v=>{Xe.info(\"Ready\",v),u(p)})",
            "const se=_.node().getBBox();"
        );
        let output = MermaidWorker::patch_mermaid_js(js);
        assert!(output.contains("sanitize:function"));
        assert!(output.contains("__mdmdview_cytoscape_stub"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_patch_mermaid_js_debug_paths_with_layout_only() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
        let js =
            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
        let output = MermaidWorker::patch_mermaid_js(js);
        assert!(output.contains("breadthfirst"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_normalize_svg_size_inserts_dimensions() {
        let svg = r#"<svg viewBox="0 0 200 100" width="100%" height="100%"></svg>"#;
        let output = MermaidWorker::normalize_svg_size(svg);
        assert!(output.contains("width=\"200\""));
        assert!(output.contains("height=\"100\""));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_normalize_svg_size_inserts_missing_dimension() {
        let svg = r#"<svg viewBox="0 0 320 240" height="100%"></svg>"#;
        let output = MermaidWorker::normalize_svg_size(svg);
        assert!(output.contains("width=\"320\""));
        assert!(output.contains("height=\"240\""));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_normalize_svg_size_skips_fixed_dimensions() {
        let svg = r#"<svg viewBox="0 0 200 100" width="200" height="100"></svg>"#;
        assert_eq!(MermaidWorker::normalize_svg_size(svg), svg);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_normalize_svg_size_no_viewbox_no_change() {
        let svg = r#"<svg width="100%" height="100%"></svg>"#;
        assert_eq!(MermaidWorker::normalize_svg_size(svg), svg);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_replace_and_upsert_attr_paths() {
        let tag = r#"<svg width="10" height="20">"#;
        let replaced = MermaidWorker::replace_attr(tag, "width", "99");
        assert!(replaced.contains("width=\"99\""));
        let unchanged = MermaidWorker::replace_attr(tag, "viewBox", "0 0 1 1");
        assert_eq!(unchanged, tag);
        let upsert_existing = MermaidWorker::upsert_attr(tag, "height", "42");
        assert!(upsert_existing.contains("height=\"42\""));
        let upsert_new = MermaidWorker::upsert_attr(tag, "viewBox", "0 0 1 1");
        assert!(upsert_new.contains("viewBox=\"0 0 1 1\""));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_strip_svg_attr_and_insert_svg_attr() {
        let svg = r#"<svg width="10" height="20"></svg>"#;
        let stripped = MermaidWorker::strip_svg_attr(svg, "width").expect("width removed");
        assert!(!stripped.contains("width=\"10\""));
        assert!(MermaidWorker::strip_svg_attr(svg, "viewBox").is_none());
        let inserted = MermaidWorker::insert_svg_attr("<svg></svg>", "viewBox", "0 0 1 1");
        assert!(inserted.contains("viewBox=\"0 0 1 1\""));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_remove_svg_attr_trims_double_space() {
        let tag = r#"<svg width="10"  height="20">"#;
        let stripped = MermaidWorker::remove_svg_attr(tag, "width");
        assert!(!stripped.contains("width=\"10\""));
        assert!(stripped.contains("height=\"20\""));
        assert!(stripped.starts_with("<svg"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_remove_svg_attr_handles_no_space_prefix() {
        let tag = r#"<svgwidth="10" height="20">"#;
        let stripped = MermaidWorker::remove_svg_attr(tag, "width");
        assert!(!stripped.contains("width=\"10\""));
        assert!(stripped.contains("height=\"20\""));
        assert!(stripped.starts_with("<svg"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_remove_svg_attr_noop_when_missing_or_unclosed() {
        let tag = r#"<svg height="20">"#;
        assert_eq!(MermaidWorker::remove_svg_attr(tag, "width"), tag);
        let unclosed = r#"<svg width="10 height=20>"#;
        assert_eq!(MermaidWorker::remove_svg_attr(unclosed, "width"), unclosed);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_remove_svg_attr_preserves_spacing_without_double_space() {
        let tag = r#"<svg width="10"height="20">"#;
        assert_eq!(
            MermaidWorker::remove_svg_attr(tag, "width"),
            "<svg height=\"20\">"
        );
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_parse_viewbox_dims_and_format_dim() {
        assert_eq!(
            MermaidWorker::parse_viewbox_dims("0 0 100 200"),
            Some((100.0, 200.0))
        );
        assert_eq!(
            MermaidWorker::parse_viewbox_dims("0,0,100,200"),
            Some((100.0, 200.0))
        );
        assert!(MermaidWorker::parse_viewbox_dims("0,0,100,0").is_none());
        assert!(MermaidWorker::parse_viewbox_dims("0 0 -1 2").is_none());
        assert!(MermaidWorker::parse_viewbox_dims("0 0 NaN 2").is_none());
        assert!(MermaidWorker::parse_viewbox_dims("0 0 inf 2").is_none());
        assert!(MermaidWorker::parse_viewbox_dims("0 0 2 inf").is_none());
        assert!(MermaidWorker::parse_viewbox_dims("bad").is_none());
        assert_eq!(MermaidWorker::format_dim(10.0), "10");
        assert_eq!(MermaidWorker::format_dim(10.5), "10.5");
        assert_eq!(MermaidWorker::format_dim(0.0), "0");
        assert_eq!(MermaidWorker::format_dim(10.123), "10.123");
        let nan = MermaidWorker::format_dim(f32::NAN);
        assert!(!nan.contains('.'));
        assert!(nan.to_lowercase().contains("nan"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_find_svg_attr_missing_quote_returns_none() {
        let tag = r#"<svg viewBox="0 0 10 10"#;
        assert!(MermaidWorker::find_svg_attr(tag, "viewBox").is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_strip_svg_attr_missing_tag_returns_none() {
        assert!(MermaidWorker::strip_svg_attr("no svg here", "width").is_none());
        let missing_end = r#"<svg width="10""#;
        assert!(MermaidWorker::strip_svg_attr(missing_end, "width").is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_text_measurer_fallback_for_missing_fonts() {
        let fontdb = Arc::new(usvg::fontdb::Database::new());
        let measurer = TextMeasurer::new(Arc::clone(&fontdb));
        let (width, height) = measurer.measure_text("abc", -1.0, Some(700.0));
        assert!(width > 0.0);
        assert!(height > 0.0);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_text_measurer_non_finite_font_size_uses_default() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let measurer = TextMeasurer::new(Arc::new(fontdb));
        let (width, height) = measurer.measure_text("abc", f32::NAN, None);
        assert!(width > 0.0);
        assert!(height > 0.0);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_text_measurer_missing_glyph_uses_fallback_advance() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let measurer = TextMeasurer::new(Arc::new(fontdb));
        let (width, height) = measurer.measure_text("\u{10FFFF}", 16.0, None);
        assert!(width > 0.0);
        assert!(height > 0.0);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_text_measurer_forced_face_parse_error_falls_back() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let measurer = TextMeasurer::new(Arc::new(fontdb));
        force_mermaid_face_parse_error_once();
        let (width, height) = measurer.measure_text("abc", 16.0, None);
        assert!(width > 0.0);
        assert!(height > 0.0);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_text_measurer_bold_adjusts_when_faces_match() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = Arc::new(fontdb);
        let face_id = fontdb.query(&usvg::fontdb::Query {
            families: &[usvg::fontdb::Family::SansSerif],
            ..Default::default()
        });
        let measurer = TextMeasurer {
            fontdb: Arc::clone(&fontdb),
            face_id,
            bold_face_id: face_id,
        };
        let (width, height) = measurer.measure_text("Test", 16.0, Some(700.0));
        assert!(width > 0.0);
        assert!(height > 0.0);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_text_measurer_empty_text_returns_zero() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let measurer = TextMeasurer::new(Arc::new(fontdb));
        let (width, height) = measurer.measure_text("", 16.0, None);
        assert_eq!(width, 0.0);
        assert_eq!(height, 0.0);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_text_measurer_fallback_handles_shorter_lines() {
        let (width, height) = TextMeasurer::fallback_measure("abcd\na", 10.0);
        assert!((width - 20.0).abs() < 0.01);
        assert!((height - 24.0).abs() < 0.01);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_text_measurer_kerning_adjusts_width_when_available() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = Arc::new(fontdb);
        let measurer = TextMeasurer::new(Arc::clone(&fontdb));
        let (w_av, _) = measurer.measure_text("AV", 16.0, None);
        let (w_a, _) = measurer.measure_text("A", 16.0, None);
        let (w_v, _) = measurer.measure_text("V", 16.0, None);
        assert!(w_av <= w_a + w_v);
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_scale_adjustment_for_svg_defaults() {
        assert_eq!(MermaidWorker::scale_adjustment_for_svg("<svg></svg>"), 1.0);
        assert_eq!(
            MermaidWorker::scale_adjustment_for_svg("<svg aria-roledescription=\"er\"></svg>"),
            0.94
        );
        assert_eq!(
            MermaidWorker::scale_adjustment_for_svg("<svg aria-roledescription='er'></svg>"),
            0.94
        );
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_enqueue_mermaid_job_disconnected() {
        let (job_tx, job_rx) = bounded(1);
        drop(job_rx);
        let (_result_tx, result_rx) = bounded(1);
        let renderer = test_renderer_with_channels(Some(job_tx), result_rx);
        let request = MermaidRequest {
            svg_key: 1,
            texture_key: "t".to_string(),
            code: Some("graph TD; A-->B;".to_string()),
            svg: None,
            width_bucket: 120,
            scale_bucket: 100,
            viewport_width: 120,
            viewport_height: 120,
            bg: None,
        };
        assert_eq!(
            renderer.enqueue_mermaid_job(request),
            Err(MermaidEnqueueError::Disconnected)
        );
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_render_block_enqueues_cached_svg() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
        let (job_tx, job_rx) = bounded(1);
        let (_result_tx, result_rx) = bounded(1);
        let renderer = test_renderer_with_channels(Some(job_tx), result_rx);
        let code = "graph TD; A-->B;";
        let svg_key = MermaidRenderer::hash_str(code);
        renderer
            .mermaid_svg_cache
            .borrow_mut()
            .insert(svg_key, "<svg></svg>".to_string());
        let ctx = egui::Context::default();
        let input = egui::RawInput {
            screen_rect: Some(egui::Rect::from_min_size(
                egui::pos2(0.0, 0.0),
                egui::vec2(240.0, 120.0),
            )),
            ..Default::default()
        };
        let mut rendered = false;
        let _ = ctx.run(input, |ctx| {
            egui::CentralPanel::default().show(ctx, |ui| {
                rendered = renderer.render_block(ui, code, 1.0, 14.0);
            });
        });
        assert!(rendered);
        let request = job_rx
            .recv_timeout(std::time::Duration::from_secs(1))
            .expect("request");
        assert!(request.svg.is_some());
        assert!(request.code.is_none());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_spawn_mermaid_workers_reports_init_error() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "1");
        force_mermaid_worker_init_error_once();
        let (job_tx, job_rx) = bounded(1);
        let (result_tx, result_rx) = bounded(1);
        let handles = MermaidRenderer::spawn_mermaid_workers(job_rx, result_tx);
        let request = MermaidRequest {
            svg_key: 2,
            texture_key: "t".to_string(),
            code: Some("graph TD; A-->B;".to_string()),
            svg: None,
            width_bucket: 120,
            scale_bucket: 100,
            viewport_width: 120,
            viewport_height: 120,
            bg: None,
        };
        job_tx.send(request).expect("send");
        let result = result_rx
            .recv_timeout(std::time::Duration::from_secs(1))
            .expect("result");
        assert!(result.error.is_some());
        drop(job_tx);
        for handle in handles {
            let _ = handle.join();
        }
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_spawn_mermaid_workers_reports_spawn_error() {
        let _lock = env_lock();
        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "1");
        force_mermaid_thread_spawn_error_once();
        let (_job_tx, job_rx) = bounded(1);
        let (result_tx, _result_rx) = bounded(1);
        let handles = MermaidRenderer::spawn_mermaid_workers(job_rx, result_tx);
        assert!(handles.is_empty());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_worker_init_error_stages() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = Arc::new(fontdb);

        force_mermaid_init_error_once(1);
        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
            .err()
            .expect("stage 1 err");
        assert!(err.contains("Mermaid text measure init error"));

        force_mermaid_init_error_once(2);
        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
            .err()
            .expect("stage 2 err");
        assert!(err.contains("Mermaid text measure init error"));

        force_mermaid_init_error_once(3);
        let err = MermaidWorker::new(0, fontdb).err().expect("stage 3 err");
        assert!(err.contains("Mermaid DOM shim"));

        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = Arc::new(fontdb);
        force_mermaid_init_error_once(4);
        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
            .err()
            .expect("stage 4 err");
        assert!(err.contains("Mermaid JS"));

        force_mermaid_init_error_once(5);
        let err = MermaidWorker::new(0, fontdb).err().expect("stage 5 err");
        assert!(err.contains("Mermaid init"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_worker_new_runtime_error_forced() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = Arc::new(fontdb);
        force_mermaid_runtime_error_once();
        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
            .err()
            .expect("runtime err");
        assert!(err.contains("Mermaid runtime init error"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_runtime_flag_mismatch_restores() {
        let handle = std::thread::spawn(|| {
            force_mermaid_runtime_error_once();
        });
        handle.join().expect("flag thread");

        let _ = runtime_new_for_test().expect("runtime ok");

        let mut guard = FORCE_MERMAID_RUNTIME_ERROR
            .lock()
            .expect("mermaid runtime flag lock");
        *guard = None;
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_worker_new_context_error_forced() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = Arc::new(fontdb);
        force_mermaid_context_error_once();
        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
            .err()
            .expect("context err");
        assert!(err.contains("Mermaid context init error"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_worker_new_utf8_error_forced() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = Arc::new(fontdb);
        force_mermaid_utf8_error_once();
        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
            .err()
            .expect("utf8 err");
        assert!(err.contains("Mermaid JS is not valid UTF-8"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_render_svg_forced_eval_error() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = Arc::new(fontdb);
        let mut worker = MermaidWorker::new(0, Arc::clone(&fontdb)).expect("worker init");
        force_mermaid_render_eval_error_once();
        let err = worker
            .render_svg(1, "graph TD; A-->B;", 480, 320)
            .unwrap_err();
        assert!(!err.is_empty());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_mermaid_render_svg_forced_call_error() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = Arc::new(fontdb);
        let mut worker = MermaidWorker::new(0, Arc::clone(&fontdb)).expect("worker init");
        force_mermaid_render_call_error_once();
        let err = worker
            .render_svg(2, "graph TD; A-->B;", 480, 320)
            .unwrap_err();
        assert!(!err.is_empty());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_parse_raw_svg_tree_invalid_svg_returns_error() {
        let options = usvg::Options::default();
        let err = MermaidWorker::parse_raw_svg_tree("<svg", &options).unwrap_err();
        assert!(!err.is_empty());
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_rasterize_svg_forced_pixmap_alloc_error() {
        let mut fontdb = usvg::fontdb::Database::new();
        fontdb.load_system_fonts();
        let fontdb = Arc::new(fontdb);
        let worker = MermaidWorker::new(0, Arc::clone(&fontdb)).expect("worker init");
        force_mermaid_pixmap_alloc_fail_once();
        let err = worker
            .rasterize_svg(
                "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"10\" height=\"10\"><rect width=\"10\" height=\"10\"/></svg>",
                0,
                100,
                None,
            )
            .unwrap_err();
        assert!(err.contains("Pixmap alloc failed"));
    }

    #[cfg(feature = "mermaid-quickjs")]
    #[test]
    fn test_svg_helper_early_returns() {
        assert_eq!(MermaidWorker::normalize_svg_size("<svg"), "<svg");
        assert_eq!(
            MermaidWorker::normalize_svg_size("<svg viewBox=\"bad\">"),
            "<svg viewBox=\"bad\">"
        );
        assert_eq!(
            MermaidWorker::replace_attr("<svg width=\"100", "width", "200"),
            "<svg width=\"100"
        );
        assert_eq!(
            MermaidWorker::upsert_attr("<svg width=\"100\"", "height", "200"),
            "<svg width=\"100\""
        );
        assert!(MermaidWorker::flatten_svg_switches("<switch").is_none());
        assert!(MermaidWorker::fix_journey_section_text("<text journey-section", "#fff").is_none());
        assert!(MermaidWorker::fix_state_end_circles("<svg><g class=\"state-end\"").is_none());
        assert!(MermaidWorker::fix_state_end_circles("<svg><g class=\"state-end\"></g").is_none());
        assert!(MermaidWorker::fix_er_attribute_fills("<rect class=\"attributeBoxOdd\"").is_none());
        assert_eq!(
            MermaidWorker::replace_svg_attr("<svg>", "width", "1"),
            "<svg>"
        );
        assert_eq!(
            MermaidWorker::replace_svg_attr("<svg width=\"100>", "width", "1"),
            "<svg width=\"100>"
        );
        assert_eq!(
            MermaidWorker::insert_svg_attr("no svg", "width", "1"),
            "no svg"
        );
    }
}


----------------------------------------

File: src\sample_files.rs

//! Sample markdown files embedded in the application
//!
//! These files demonstrate the markdown viewer capabilities and provide
//! usage instructions. They are built into the executable for easy access.

/// Represents a sample markdown file with metadata
#[derive(Debug, Clone)]
pub struct SampleFile {
    pub name: &'static str,
    pub title: &'static str,
    pub content: &'static str,
}

/// Collection of all embedded sample files
pub const SAMPLE_FILES: &[SampleFile] = &[
    SampleFile {
        name: "welcome.md",
        title: "Welcome to MarkdownView",
        content: WELCOME_CONTENT,
    },
    SampleFile {
        name: "formatting.md",
        title: "Formatting Examples",
        content: FORMATTING_CONTENT,
    },
    SampleFile {
        name: "code.md",
        title: "Code Examples",
        content: CODE_CONTENT,
    },
    SampleFile {
        name: "usage.md",
        title: "Usage Instructions",
        content: USAGE_CONTENT,
    },
    SampleFile {
        name: "search.md",
        title: "Search Tips & Examples",
        content: SEARCH_GUIDE_CONTENT,
    },
    SampleFile {
        name: "images.md",
        title: "Inline Images & Diagrams",
        content: IMAGES_CONTENT,
    },
];

/// Welcome content with basic introduction
const WELCOME_CONTENT: &str = r#"# Welcome to MarkdownView

A simple, fast markdown viewer for Windows built with Rust and egui.

## Features

- **Pure Rust Implementation** - Single executable, no dependencies
- **Fast Rendering** - Efficient markdown parsing with pulldown-cmark
- **Syntax Highlighting** - Code blocks with proper syntax coloring
- **Native File Dialogs** - Seamless Windows integration
- **Embedded Examples** - Built-in sample files to explore

## Quick Start

1. **Open a File**: Use `File  Open` or `Ctrl+O` to load a markdown file
2. **Browse Samples**: Use `File  Samples` to explore built-in examples
3. **Navigate**: Scroll to read through documents

Enjoy reading your markdown files with this lightweight, efficient viewer!

---

*Built with  using Rust, egui, and pulldown-cmark*
"#;

const FORMATTING_CONTENT: &str = r#"# Markdown Formatting Guide

This document demonstrates the various formatting options supported by MarkdownView.

## Table of Contents

- [Text Formatting](#text-formatting)
- [Headers](#headers)
- [Lists](#lists)
- [Links and Images](#links-and-images)
- [Emojis](#emojis)
- [Blockquotes](#blockquotes)
- [Horizontal Rules](#horizontal-rules)
- [Tables](#tables)

Quick jump: [Go to Lists](#lists) | [Go to Tables](#tables)

## Text Formatting

**Bold text** and *italic text* are supported, as well as ***bold italic***.

You can also use `inline code` and ~~strikethrough~~ text.

## Headers

# Header 1
## Header 2  
### Header 3
#### Header 4
##### Header 5
###### Header 6

## Lists

### Unordered Lists

- First item
- Second item
  - Nested item
  - Another nested item
- Third item
- Inline code in bullets works: use `--help` or `cargo run`
- Styled + emoji in bullets: **:rocket:** launch, *:tada:* celebration, and ~~:fire:~~ warning
- Tight list check: this item has :rocket: and `code` without blank lines between items

### Ordered Lists

1. First item
2. Second item
   1. Nested numbered item
   2. Another nested item
3. Third item

## Links and Images

[Visit Rust's website](https://rust-lang.org)

Internal anchors let you jump within this document:
- [Jump to Headers](#headers)
- [Jump to Tables](#tables)
- [Back to top](#markdown-formatting-guide)

Links are clickable and will open in your default browser.

## Emojis

Unicode emojis render as normal text if your font supports them.
Examples: Thanks!   Status:   Ship it 

Shortcodes like `:rocket:` and `:tada:` are expanded to emoji images in normal text, headers, and list items.

## Blockquotes

> This is a blockquote.
> It can span multiple lines.
> 
> > Nested blockquotes are also supported.

## Horizontal Rules

---

## Tables

| Feature | Supported | Notes |
|---------|-----------|-------|
| Headers | Yes | All levels 1-6 |
| Lists | Yes | Ordered and unordered |
| Code blocks | Yes | With syntax highlighting |
| Tables | Yes | Basic table support |
| Links | Yes | Opens in browser; internal anchors scroll in document |

---

*This covers most of the formatting features available in MarkdownView.*  
[Back to top](#markdown-formatting-guide)
"#;

/// Code examples with syntax highlighting
const SEARCH_GUIDE_CONTENT: &str = concat!(
    "# Search Tips & Examples\n\n",
    "MarkdownView's search panel is accent-aware and case-insensitive. A single query matches multiple spellings automatically.\n\n",
    "## Accent Folding\n\n",
    "- Typing `resume` highlights `r\u{00e9}sum\u{00e9}`, `RESUME`, and `re\u{0301}sume` (precomposed vs. combining accent).\n",
    "- `istanbul` matches both `\u{0130}stanbul` (Turkish dotted capital I) and `ISTANBUL`.\n",
    "- `sao` finds `S\u{00e3}o`, `SAO`, and `Sao` regardless of combining marks.\n",
    "- `nino` finds `Ni\u{00f1}o`, `NINO`, and `nin\u{0303}o`.\n\n",
    "Try opening this sample, pressing `Ctrl+F`, and searching for the words below:\n\n",
    "| Query | Matches in this document |\n",
    "|-------|-------------------------|\n",
    "| `resume` | r\u{00e9}sum\u{00e9}, RESUME, re\u{0301}sume |\n",
    "| `istanbul` | \u{0130}stanbul, ISTANBUL |\n",
    "| `sao` | S\u{00e3}o, SAO, Sao |\n",
    "| `nino` | Ni\u{00f1}o, NINO, nin\u{0303}o |\n\n",
    "> Tip: Use `Enter` / `Shift+Enter` to cycle through matches. The highlight respects grapheme clusters, so emoji and combined characters stay intact.\n\n",
);
const IMAGES_CONTENT: &str = r#"# Inline Images & Diagrams

This sample demonstrates inline images and Mermaid code blocks.

## PNG Image

Below is a PNG image using an embedded emoji asset.

![Smiley PNG](assets/emoji/1f600.png "PNG emoji sample")

## SVG Image

An SVG logo rendered via resvg/tiny-skia.

![SVG Logo](assets/samples/logo.svg "SVG sample logo")

## WEBP Image

A small WEBP sample is bundled for testing.

![WEBP Sample](assets/samples/webp_sample.webp "WEBP sample")

## Mermaid Diagram (embedded)

Mermaid code blocks are rendered as diagrams by default.
Build with `--no-default-features` or set `MDMDVIEW_MERMAID_RENDERER=off` to show the source instead.

```mermaid
graph TD;
    A[Start] --> B{Is SVG supported?};
    B -- Yes --> C[Rasterize via resvg];
    B -- No  --> D[Show placeholder];
    C --> E[Display egui texture];
    D --> E;
```

## Notes

- The WEBP sample is at `assets/samples/webp_sample.webp`. See `examples/webp_test.md` for a standalone test file.

"#;

const CODE_CONTENT: &str = r#"# Code Examples

MarkdownView supports syntax highlighting for many programming languages.

## Rust Code

```rust
fn main() {
    println!("Hello, world!");
    
    let mut vector = vec![1, 2, 3, 4, 5];
    vector.iter()
        .filter(|&x| x % 2 == 0)
        .for_each(|x| println!("Even number: {}", x));
}

// Struct definition with lifetimes
struct Config<'a> {
    name: &'a str,
    version: u32,
}

impl<'a> Config<'a> {
    fn new(name: &'a str) -> Self {
        Config { name, version: 1 }
    }
}
```

## Python Code

```python
def fibonacci(n):
    """Generate fibonacci sequence up to n"""
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    
    sequence = [0, 1]
    while len(sequence) < n:
        sequence.append(sequence[-1] + sequence[-2])
    
    return sequence

# List comprehension example
squares = [x**2 for x in range(10) if x % 2 == 0]
print(f"Even squares: {squares}")
```

## JavaScript Code

```javascript
// Modern JavaScript with async/await
async function fetchUserData(userId) {
    try {
        const response = await fetch(`/api/users/${userId}`);
        const userData = await response.json();
        
        return {
            ...userData,
            lastUpdated: new Date().toISOString()
        };
    } catch (error) {
        console.error('Failed to fetch user data:', error);
        throw error;
    }
}

// Arrow functions and destructuring
const processData = ({ name, age, email }) => ({
    displayName: name.toUpperCase(),
    isAdult: age >= 18,
    emailDomain: email.split('@')[1]
});
```

## SQL Code

```sql
-- Complex query with joins and aggregation
SELECT 
    u.username,
    u.email,
    COUNT(o.id) as total_orders,
    SUM(oi.price * oi.quantity) as total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
LEFT JOIN order_items oi ON o.id = oi.order_id
WHERE u.created_at >= '2023-01-01'
GROUP BY u.id, u.username, u.email
HAVING COUNT(o.id) > 5
ORDER BY total_spent DESC
LIMIT 20;
```

## Inline Code

You can also use `inline code` within paragraphs, like `let x = 42;` or `print("hello")`.

---

*Syntax highlighting is powered by the syntect library, supporting dozens of languages.*
"#;

/// Usage instructions and tips
const USAGE_CONTENT: &str = r#"# Usage Instructions

## Opening Files

### File Menu
- Use `File  Open` from the menu bar
- Keyboard shortcut: `Ctrl+O`
- Select any `.md` or `.markdown` file from your system

### Drag and Drop
- Drag markdown files directly into the application window
- Multiple files can be opened in sequence

## Viewing Sample Files

### Built-in Examples
- Use `File  Samples` to browse embedded examples
- These files demonstrate various markdown features
- Perfect for testing and learning

### Sample File List
- **welcome.md** - Introduction and overview
- **formatting.md** - Text formatting examples  
- **code.md** - Syntax highlighting examples
- **usage.md** - This usage guide

## Navigation

### Scrolling
- Use mouse wheel or trackpad to scroll
- Keyboard arrows for line-by-line navigation
- Page Up/Page Down for faster scrolling

### Window Controls
- Resize the window as needed
- Content automatically reflows
- Minimum window size is enforced

## Keyboard Shortcuts

| Shortcut | Action |
|----------|--------|
| `Ctrl+O` | Open file |
| `Ctrl+W` | Close current file |
| `F5` | Reload current file |
| `Ctrl+Q` | Quit application |
| `F11` | Toggle fullscreen |
| `Ctrl++` | Zoom in (increase font size) |
| `Ctrl+-` | Zoom out (decrease font size) |
| `Ctrl` + Mouse Wheel | Zoom in/out |
| `Ctrl+0` | Reset zoom to default size |
| `Home` | Go to top of document |
| `End` | Go to bottom of document |
| `Page Up` | Scroll up one page |
| `Page Down` | Scroll down one page |

## File Associations

### Windows Integration
To make MarkdownView the default for `.md` files:

1. Right-click any `.md` file
2. Select "Open with  Choose another app"
3. Browse to the MarkdownView executable
4. Check "Always use this app"

### Supported Extensions
- `.md` - Standard markdown files
- `.markdown` - Alternative markdown extension
- `.mdown` - Another common variation
- `.mkd` - Short markdown extension

## Performance

### Large Files
- Files up to several MB render efficiently
- Very large files (>10MB) may take a moment to parse
- Consider breaking up extremely large documents

### Memory Usage
- Minimal memory footprint
- Parsed content is cached for fast scrolling
- No memory leaks during normal operation

## Troubleshooting

### Common Issues

**File won't open**
- Check file extension is `.md` or `.markdown`
- Ensure file isn't locked by another application
- Verify file contains valid UTF-8 text

**Display issues**
- Try resizing the window
- Restart the application
- Check if file contains very long lines

**Performance problems**
- Close and reopen large files
- Ensure adequate system memory
- Consider breaking up large documents

### Getting Help

For bugs or feature requests:
1. Check the application works with sample files
2. Try reproducing with a minimal markdown file
3. Note your Windows version and system specs

---

*Thank you for using MarkdownView! We hope it serves your markdown reading needs well.*
"#;

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;

    #[test]
    fn test_sample_files_exist() {
        assert_eq!(SAMPLE_FILES.len(), 6);

        let names: Vec<&str> = SAMPLE_FILES.iter().map(|f| f.name).collect();
        assert!(names.contains(&"welcome.md"));
        assert!(names.contains(&"formatting.md"));
        assert!(names.contains(&"code.md"));
        assert!(names.contains(&"usage.md"));
        assert!(names.contains(&"search.md"));
        assert!(names.contains(&"images.md"));
    }

    #[test]
    fn test_sample_files_content_not_empty() {
        for file in SAMPLE_FILES {
            assert!(!file.content.is_empty());
            assert!(!file.title.is_empty());
            assert!(!file.name.is_empty());
        }
    }

    #[test]
    fn test_sample_files_are_valid_markdown() {
        use pulldown_cmark::{Options, Parser};

        for file in SAMPLE_FILES {
            let parser = Parser::new_ext(file.content, Options::all());
            let events: Vec<_> = parser.collect();
            assert!(!events.is_empty());
        }
    }

    #[test]
    fn test_welcome_content_structure() {
        assert!(WELCOME_CONTENT.contains("# Welcome"));
        assert!(WELCOME_CONTENT.contains("## Features"));
        assert!(WELCOME_CONTENT.contains("## Quick Start"));
    }

    #[test]
    fn test_formatting_content_examples() {
        assert!(FORMATTING_CONTENT.contains("**Bold text**"));
        assert!(FORMATTING_CONTENT.contains("*italic text*"));
        assert!(FORMATTING_CONTENT.contains("`inline code`"));
        assert!(FORMATTING_CONTENT.contains("| Feature | Supported |"));
    }

    #[test]
    fn test_code_content_languages() {
        assert!(CODE_CONTENT.contains("```rust"));
        assert!(CODE_CONTENT.contains("```python"));
        assert!(CODE_CONTENT.contains("```javascript"));
        assert!(CODE_CONTENT.contains("```sql"));
    }

    #[test]
    fn test_usage_content_sections() {
        assert!(USAGE_CONTENT.contains("## Opening Files"));
        assert!(USAGE_CONTENT.contains("## Keyboard Shortcuts"));
        assert!(USAGE_CONTENT.contains("## Troubleshooting"));
    }

    #[test]
    fn test_search_guide_examples_present() {
        assert!(SEARCH_GUIDE_CONTENT.contains("rsum"));
        assert!(SEARCH_GUIDE_CONTENT.contains("stanbul"));
        assert!(SEARCH_GUIDE_CONTENT.contains("So"));
        assert!(SEARCH_GUIDE_CONTENT.contains("Nio"));
        assert!(SEARCH_GUIDE_CONTENT.contains("Ctrl+F"));
    }

    #[test]
    fn test_images_content_mentions_samples() {
        assert!(IMAGES_CONTENT.contains("Inline Images"));
        assert!(IMAGES_CONTENT.contains("WEBP Sample"));
        assert!(IMAGES_CONTENT.contains("```mermaid"));
    }
}


----------------------------------------

File: src\table_support\column_spec.rs

use std::cmp::max;
use std::hash::{Hash, Hasher};

use egui_extras::Column;
use unicode_segmentation::UnicodeSegmentation;
use unicode_width::UnicodeWidthStr;

use crate::markdown_renderer::InlineSpan;

const MAX_REMAINDER_COLUMNS: usize = 2;

fn normalize_body_font_px(body: f32) -> f32 {
    if body.is_finite() && body > 4.0 {
        body
    } else {
        14.0
    }
}

fn px(body_px: f32, factor: f32) -> f32 {
    normalize_body_font_px(body_px) * factor
}

#[derive(Debug, Clone, PartialEq)]
pub enum ColumnPolicy {
    Auto,
    Fixed {
        width: f32,
        clip: bool,
    },
    Remainder {
        clip: bool,
    },
    Resizable {
        min: f32,
        preferred: f32,
        clip: bool,
    },
}

impl ColumnPolicy {
    pub fn to_column(&self) -> Column {
        match self {
            ColumnPolicy::Auto => Column::auto(),
            ColumnPolicy::Fixed { width, clip } => {
                let mut col = Column::exact(*width);
                if *clip {
                    col = col.clip(true);
                }
                col
            }
            ColumnPolicy::Remainder { clip } => {
                let mut col = Column::remainder();
                if *clip {
                    col = col.clip(true);
                }
                col
            }
            ColumnPolicy::Resizable {
                min,
                preferred,
                clip,
            } => {
                let mut col = Column::initial(*preferred).at_least(*min).resizable(true);
                if *clip {
                    col = col.clip(true);
                }
                col
            }
        }
    }
}

impl Hash for ColumnPolicy {
    fn hash<H: Hasher>(&self, state: &mut H) {
        std::mem::discriminant(self).hash(state);
        match self {
            ColumnPolicy::Auto => {}
            ColumnPolicy::Fixed { width, clip } => {
                width.to_bits().hash(state);
                clip.hash(state);
            }
            ColumnPolicy::Remainder { clip } => {
                clip.hash(state);
            }
            ColumnPolicy::Resizable {
                min,
                preferred,
                clip,
            } => {
                min.to_bits().hash(state);
                preferred.to_bits().hash(state);
                clip.hash(state);
            }
        }
    }
}

#[derive(Debug, Clone)]
pub struct ColumnSpec {
    pub index: usize,
    pub ident: String,
    pub policy: ColumnPolicy,
    pub tooltip: Option<String>,
    pub policy_hash: u64,
}

impl ColumnSpec {
    pub fn new(
        index: usize,
        ident: impl Into<String>,
        policy: ColumnPolicy,
        tooltip: Option<String>,
    ) -> Self {
        let ident = ident.into();
        let policy_hash = calculate_policy_hash(index, &ident, &policy);
        Self {
            index,
            ident,
            policy,
            tooltip,
            policy_hash,
        }
    }

    pub fn as_column(&self) -> Column {
        self.policy.to_column()
    }

    pub fn set_policy(&mut self, policy: ColumnPolicy) {
        self.policy = policy;
        self.policy_hash = calculate_policy_hash(self.index, &self.ident, &self.policy);
    }

    pub fn apply_preferred_width(&mut self, width: f32) {
        if let ColumnPolicy::Resizable {
            min,
            ref mut preferred,
            ..
        } = self.policy
        {
            let clamped = width.max(min);
            *preferred = clamped;
            self.policy_hash = calculate_policy_hash(self.index, &self.ident, &self.policy);
        }
    }
}

#[derive(Debug, Clone, Copy, Default)]
pub struct RichContentFlags {
    pub has_link: bool,
    pub has_image: bool,
    pub has_emoji_like: bool,
}

#[derive(Debug, Clone, Default)]
pub struct ColumnStat {
    pub max_graphemes: usize,
    pub longest_word: usize,
    pub rich_content: RichContentFlags,
}

pub struct TableColumnContext<'a> {
    pub headers: &'a [Vec<InlineSpan>],
    pub rows: &'a [Vec<Vec<InlineSpan>>],
    pub stats: &'a [ColumnStat],
    pub body_font_px: f32,
    pub table_id: u64,
}

impl<'a> TableColumnContext<'a> {
    pub fn new(
        headers: &'a [Vec<InlineSpan>],
        rows: &'a [Vec<Vec<InlineSpan>>],
        stats: &'a [ColumnStat],
        body_font_px: f32,
        table_id: u64,
    ) -> Self {
        Self {
            headers,
            rows,
            stats,
            body_font_px,
            table_id,
        }
    }

    pub fn column_stat(&self, idx: usize) -> Option<&ColumnStat> {
        self.stats.get(idx)
    }
}

fn calculate_policy_hash(index: usize, ident: &str, policy: &ColumnPolicy) -> u64 {
    let mut hasher = std::collections::hash_map::DefaultHasher::new();
    index.hash(&mut hasher);
    ident.hash(&mut hasher);
    std::mem::discriminant(policy).hash(&mut hasher);
    match policy {
        ColumnPolicy::Auto => {}
        ColumnPolicy::Fixed { width, clip } => {
            width.to_bits().hash(&mut hasher);
            clip.hash(&mut hasher);
        }
        ColumnPolicy::Remainder { clip } => {
            clip.hash(&mut hasher);
        }
        ColumnPolicy::Resizable { min, clip, .. } => {
            min.to_bits().hash(&mut hasher);
            clip.hash(&mut hasher);
        }
    }
    hasher.finish()
}

pub fn derive_column_specs(ctx: &TableColumnContext) -> Vec<ColumnSpec> {
    let mut remainder_assigned = 0usize;
    let mut fallback_idx: Option<usize> = None;
    let mut fallback_score: usize = 0;
    let column_count = ctx
        .stats
        .len()
        .max(ctx.headers.len())
        .max(ctx.rows.iter().map(|r| r.len()).max().unwrap_or(0));

    let mut scored_indices: Vec<(usize, usize)> = Vec::with_capacity(column_count);

    let mut specs: Vec<ColumnSpec> = (0..column_count)
        .map(|idx| {
            let spans = ctx.headers.get(idx).map(|v| v.as_slice()).unwrap_or(&[]);
            let label = header_text(spans);
            let stat = ctx.column_stat(idx);

            let candidate_score = stat
                .map(|s| {
                    let mut score = s.max_graphemes + s.longest_word * 2;
                    if s.rich_content.has_image {
                        score += 50;
                    }
                    if s.rich_content.has_link {
                        score += 25;
                    }
                    score
                })
                .unwrap_or_else(|| label.len());
            if candidate_score > fallback_score {
                fallback_score = candidate_score;
                fallback_idx = Some(idx);
            }
            scored_indices.push((idx, candidate_score));

            let policy =
                classify_column(&label, idx, &mut remainder_assigned, stat, ctx.body_font_px);
            let tooltip = column_tooltip(&label, &policy);
            ColumnSpec::new(idx, label, policy, tooltip)
        })
        .collect();

    // Ensure at least one remainder if none assigned and available
    if remainder_assigned == 0 {
        let mut candidate = fallback_idx;
        if let Some(idx) = candidate {
            if matches!(specs[idx].policy, ColumnPolicy::Fixed { .. }) {
                candidate = None;
            }
        }
        let has_non_fixed_other = specs
            .iter()
            .enumerate()
            .any(|(idx, spec)| idx != 0 && !matches!(spec.policy, ColumnPolicy::Fixed { .. }));
        if has_non_fixed_other && (candidate.is_none() || candidate == Some(0)) {
            candidate = scored_indices
                .iter()
                .filter(|(idx, _)| *idx != 0)
                .filter(|(idx, _)| !matches!(specs[*idx].policy, ColumnPolicy::Fixed { .. }))
                .max_by_key(|(_, score)| *score)
                .map(|(idx, _)| *idx);
        }
        if candidate.is_none() {
            for (idx, spec) in specs.iter().enumerate() {
                if !matches!(spec.policy, ColumnPolicy::Fixed { .. }) {
                    candidate = Some(idx);
                    break;
                }
            }
        }
        if let Some(idx) = candidate {
            let spec = &mut specs[idx];
            spec.set_policy(ColumnPolicy::Remainder { clip: false });
            remainder_assigned += 1;
        }
    }

    // Promote additional wide columns to remainder up to the cap
    scored_indices.sort_by(|a, b| b.1.cmp(&a.1));
    for (idx, _) in scored_indices {
        if remainder_assigned >= MAX_REMAINDER_COLUMNS {
            break;
        }
        let spec = &mut specs[idx];
        if matches!(spec.policy, ColumnPolicy::Resizable { .. })
            && column_needs_remainder(ctx.column_stat(idx))
        {
            spec.set_policy(ColumnPolicy::Remainder { clip: false });
            remainder_assigned += 1;
        }
    }

    specs
}

fn header_text(spans: &[InlineSpan]) -> String {
    let mut text = String::new();
    for span in spans {
        match span {
            InlineSpan::Text(t)
            | InlineSpan::Strong(t)
            | InlineSpan::Emphasis(t)
            | InlineSpan::Strikethrough(t)
            | InlineSpan::Code(t) => {
                if !text.is_empty() {
                    text.push(' ');
                }
                text.push_str(t.trim());
            }
            InlineSpan::Link { text: t, .. } => {
                if !text.is_empty() {
                    text.push(' ');
                }
                text.push_str(t.trim());
            }
            InlineSpan::Image { alt, .. } => {
                if !text.is_empty() {
                    text.push(' ');
                }
                text.push_str(alt.trim());
            }
        }
    }
    if text.trim().is_empty() {
        "Column".to_string()
    } else {
        text.trim().to_string()
    }
}

fn classify_column(
    label: &str,
    index: usize,
    remainder_assigned: &mut usize,
    stat: Option<&ColumnStat>,
    body_font_px: f32,
) -> ColumnPolicy {
    let lower = label.to_ascii_lowercase();
    if matches_any(&lower, &["version", "rev", "#", "id"]) {
        return ColumnPolicy::Fixed {
            width: px(body_font_px, 5.8).clamp(80.0, 160.0),
            clip: true,
        };
    }
    if matches_any(&lower, &["date", "time", "timestamp"]) {
        return ColumnPolicy::Fixed {
            width: px(body_font_px, 8.5).clamp(110.0, 200.0),
            clip: false,
        };
    }
    if matches_any(&lower, &["author", "owner", "assignee", "user"]) {
        return ColumnPolicy::Resizable {
            min: px(body_font_px, 7.5),
            preferred: px(body_font_px, 10.0),
            clip: false,
        };
    }
    if matches_any(&lower, &["status", "state"]) {
        return ColumnPolicy::Fixed {
            width: px(body_font_px, 7.0).clamp(90.0, 180.0),
            clip: true,
        };
    }
    if matches_any(
        &lower,
        &["notes", "changes", "description", "details", "summary"],
    ) {
        return ColumnPolicy::Resizable {
            min: px(body_font_px, 10.5),
            preferred: px(body_font_px, 14.5),
            clip: false,
        };
    }
    if matches_any(
        &lower,
        &["example", "examples", "sample", "use case", "use cases"],
    ) {
        *remainder_assigned += 1;
        return ColumnPolicy::Remainder { clip: false };
    }
    if index == 0 {
        // First column typically identifiers; keep fixed only for short labels.
        if stat
            .map(|s| s.max_graphemes <= 18 && s.longest_word <= 12)
            .unwrap_or_else(|| label.len() <= 12)
        {
            return ColumnPolicy::Fixed {
                width: px(body_font_px, 7.0).clamp(80.0, 180.0),
                clip: true,
            };
        }
    }
    if *remainder_assigned < MAX_REMAINDER_COLUMNS && column_needs_remainder(stat) {
        *remainder_assigned += 1;
        return ColumnPolicy::Remainder { clip: false };
    }
    ColumnPolicy::Resizable {
        min: px(body_font_px, 7.0),
        preferred: px(body_font_px, 9.5),
        clip: false,
    }
}

fn column_needs_remainder(stat: Option<&ColumnStat>) -> bool {
    if let Some(stat) = stat {
        stat.rich_content.has_image
            || stat.longest_word > 18
            || stat.max_graphemes > 60
            || stat.rich_content.has_link
    } else {
        false
    }
}

fn matches_any(label: &str, needles: &[&str]) -> bool {
    needles.iter().any(|needle| label.contains(needle))
}

fn column_tooltip(label: &str, policy: &ColumnPolicy) -> Option<String> {
    let description = match policy {
        ColumnPolicy::Auto => "Auto-sized column".to_string(),
        ColumnPolicy::Fixed { width, clip } => format!(
            "Fixed width {:.0}px{}",
            width,
            if *clip { " (clipped)" } else { "" }
        ),
        ColumnPolicy::Remainder { clip } => format!(
            "Shared remainder width{}",
            if *clip { " (clipped)" } else { "" }
        ),
        ColumnPolicy::Resizable {
            min,
            preferred,
            clip,
        } => format!(
            "Resizable (min {:.0}px, start {:.0}px{})",
            min,
            preferred,
            if *clip { ", clipped" } else { "" }
        ),
    };
    Some(format!("{label}: {description}"))
}

pub fn compute_column_stats(
    headers: &[Vec<InlineSpan>],
    rows: &[Vec<Vec<InlineSpan>>],
    max_samples: usize,
) -> Vec<ColumnStat> {
    let column_count = max(
        headers.len(),
        rows.iter().map(|row| row.len()).max().unwrap_or(0),
    );
    if column_count == 0 {
        return Vec::new();
    }

    let mut stats = vec![ColumnStat::default(); column_count];

    for (idx, header) in headers.iter().enumerate() {
        accumulate_stats_for_cell(header, &mut stats[idx]);
    }

    let mut sampled_rows = 0;
    for row in rows.iter() {
        for (idx, cell) in row.iter().enumerate().take(column_count) {
            accumulate_stats_for_cell(cell, &mut stats[idx]);
        }
        sampled_rows += 1;
        if sampled_rows >= max_samples {
            break;
        }
    }

    stats
}

fn accumulate_stats_for_cell(spans: &[InlineSpan], stat: &mut ColumnStat) {
    if stat.rich_content.has_image {
        // rich-content flags persist; skip repeated scans for pure images.
    }
    let mut has_link = stat.rich_content.has_link;
    let mut has_image = stat.rich_content.has_image;
    let mut has_emoji_like = stat.rich_content.has_emoji_like;

    for span in spans {
        match span {
            InlineSpan::Link { .. } => has_link = true,
            InlineSpan::Image { .. } => has_image = true,
            _ => {}
        }
    }

    let text = spans_to_text(spans);
    if !text.is_empty() {
        let graphemes = text.graphemes(true).count();
        let display_width = UnicodeWidthStr::width(text.as_str());
        stat.max_graphemes = stat.max_graphemes.max(display_width.max(graphemes));

        for word in text.split_whitespace() {
            let word_len = UnicodeWidthStr::width(word).max(word.graphemes(true).count());
            stat.longest_word = stat.longest_word.max(word_len);
        }

        if !has_emoji_like {
            has_emoji_like = text.chars().any(|c| matches!(c as u32, 0x1F300..=0x1FAFF));
        }
    }

    stat.rich_content = RichContentFlags {
        has_link,
        has_image,
        has_emoji_like,
    };
}

fn spans_to_text(spans: &[InlineSpan]) -> String {
    let mut text = String::new();
    for span in spans {
        match span {
            InlineSpan::Text(t)
            | InlineSpan::Code(t)
            | InlineSpan::Strong(t)
            | InlineSpan::Emphasis(t)
            | InlineSpan::Strikethrough(t) => {
                if !text.is_empty() {
                    text.push(' ');
                }
                text.push_str(t);
            }
            InlineSpan::Link { text: t, .. } => {
                if !text.is_empty() {
                    text.push(' ');
                }
                text.push_str(t);
            }
            InlineSpan::Image { alt, .. } => {
                if !text.is_empty() {
                    text.push(' ');
                }
                text.push_str(alt);
            }
        }
    }
    text.trim().to_string()
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;

    fn span(text: &str) -> InlineSpan {
        InlineSpan::Text(text.to_string())
    }

    #[test]
    fn classify_version_column() {
        let headers = vec![vec![span("Version")], vec![span("Changes")]];
        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
        let stats = compute_column_stats(&headers, &rows, 32);
        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
        let specs = derive_column_specs(&ctx);
        assert!(matches!(specs[0].policy, ColumnPolicy::Fixed { .. }));
        assert!(matches!(specs[1].policy, ColumnPolicy::Remainder { .. }));
    }

    #[test]
    fn classify_author_column() {
        let headers = vec![vec![span("Author")], vec![span("Examples")]];
        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
        let stats = compute_column_stats(&headers, &rows, 32);
        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
        let specs = derive_column_specs(&ctx);
        assert!(matches!(specs[0].policy, ColumnPolicy::Resizable { .. }));
        assert!(matches!(specs[1].policy, ColumnPolicy::Remainder { .. }));
    }

    #[test]
    fn classify_examples_column() {
        let headers = vec![
            vec![span("Element")],
            vec![span("Symbol")],
            vec![span("Description")],
            vec![span("Examples")],
        ];
        assert_eq!(header_text(&headers[3]), "Examples");
        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
        let stats = compute_column_stats(&headers, &rows, 32);
        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
        let specs = derive_column_specs(&ctx);
        assert!(matches!(specs[3].policy, ColumnPolicy::Remainder { .. }));
        assert!(matches!(specs[2].policy, ColumnPolicy::Resizable { .. }));
    }

    #[test]
    fn compute_stats_counts_text() {
        let headers = vec![vec![span("Head")]];
        let rows = vec![vec![vec![span("Emoji  test")]]];
        let stats = compute_column_stats(&headers, &rows, 32);
        assert_eq!(stats.len(), 1);
        assert!(stats[0].max_graphemes >= 4);
        assert!(stats[0].longest_word >= 5);
        assert!(stats[0].rich_content.has_emoji_like);
    }

    #[test]
    fn fallback_assigns_remainder_based_on_stats() {
        let headers = vec![vec![span("Foo")], vec![span("Bar")]];
        let rows = vec![vec![
            vec![span("Short")],
            vec![span(
                "This column contains a very long sentence that should force remainder selection.",
            )],
        ]];
        let stats = compute_column_stats(&headers, &rows, 32);
        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
        let specs = derive_column_specs(&ctx);
        assert!(matches!(specs[1].policy, ColumnPolicy::Remainder { .. }));
    }

    #[test]
    fn fallback_avoids_first_column_when_possible() {
        let headers = vec![
            vec![span("Center")],
            vec![span("Left")],
            vec![span("Right")],
        ];
        let rows = vec![vec![
            vec![span("Centered label with enough words to raise score")],
            vec![span("L1")],
            vec![span("R1")],
        ]];
        let stats = compute_column_stats(&headers, &rows, 32);
        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
        let specs = derive_column_specs(&ctx);
        assert!(!matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
        assert!(specs[1..]
            .iter()
            .any(|spec| matches!(spec.policy, ColumnPolicy::Remainder { .. })));
    }

    #[test]
    fn derive_column_specs_handles_missing_stats_with_fixed_columns() {
        let headers = vec![vec![span("Alpha")], vec![span("Status")]];
        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
        let stats: Vec<ColumnStat> = Vec::new();
        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
        let specs = derive_column_specs(&ctx);
        assert_eq!(specs.len(), 2);
        assert!(matches!(specs[0].policy, ColumnPolicy::Fixed { .. }));
        assert!(matches!(specs[1].policy, ColumnPolicy::Fixed { .. }));
    }

    #[test]
    fn derive_column_specs_empty_header_label_uses_fixed_policy() {
        let headers = vec![Vec::new()];
        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
        let stats: Vec<ColumnStat> = Vec::new();
        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
        let specs = derive_column_specs(&ctx);
        assert_eq!(specs.len(), 1);
        assert!(matches!(specs[0].policy, ColumnPolicy::Fixed { .. }));
    }

    #[test]
    fn derive_column_specs_picks_first_non_fixed_when_best_is_fixed() {
        let headers = vec![vec![span("Notes")], vec![span("Status")]];
        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
        let stats: Vec<ColumnStat> = Vec::new();
        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
        let specs = derive_column_specs(&ctx);
        assert!(matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
    }

    #[test]
    fn fallback_skips_fixed_candidate_for_remainder() {
        let headers = vec![
            vec![span("Version")],
            vec![span("Notes")],
            vec![span("Owner")],
        ];
        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
        let stats = vec![
            ColumnStat {
                max_graphemes: 50,
                longest_word: 10,
                rich_content: RichContentFlags {
                    has_link: false,
                    has_image: false,
                    has_emoji_like: false,
                },
            },
            ColumnStat {
                max_graphemes: 5,
                longest_word: 5,
                rich_content: RichContentFlags {
                    has_link: false,
                    has_image: false,
                    has_emoji_like: false,
                },
            },
            ColumnStat {
                max_graphemes: 4,
                longest_word: 4,
                rich_content: RichContentFlags {
                    has_link: false,
                    has_image: false,
                    has_emoji_like: false,
                },
            },
        ];
        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
        let specs = derive_column_specs(&ctx);
        assert!(matches!(specs[0].policy, ColumnPolicy::Fixed { .. }));
        assert!(specs[1..]
            .iter()
            .any(|spec| matches!(spec.policy, ColumnPolicy::Remainder { .. })));
    }

    #[test]
    fn examples_header_prefers_remainder() {
        let headers = vec![vec![span("Examples")], vec![span("Description")]];
        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
        let stats = compute_column_stats(&headers, &rows, 32);
        let ctx = TableColumnContext::new(&headers, &rows, &stats, 16.0, 0);
        let specs = derive_column_specs(&ctx);
        assert!(matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
        assert!(matches!(specs[1].policy, ColumnPolicy::Resizable { .. }));
    }

    #[test]
    fn multiple_remainder_columns_allowed() {
        let headers = vec![
            vec![span("Summary")],
            vec![span("Details")],
            vec![span("Examples")],
        ];
        let rows = vec![vec![
            vec![span("short")],
            vec![span(
                "Long content that should trigger a remainder column due to its width and words.",
            )],
            vec![span(
                "Another large column with links https://example.com and more text.",
            )],
        ]];
        let stats = compute_column_stats(&headers, &rows, 32);
        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
        let specs = derive_column_specs(&ctx);
        let remainder_count = specs
            .iter()
            .filter(|s| matches!(s.policy, ColumnPolicy::Remainder { .. }))
            .count();
        assert!(remainder_count >= 2);
    }

    #[test]
    fn cjk_widths_increase_stat_estimates() {
        let headers = vec![vec![span("")], vec![span("Column")]];
        let rows = vec![vec![vec![span("")], vec![span("short")]]];
        let stats = compute_column_stats(&headers, &rows, 32);
        assert!(stats[0].max_graphemes > stats[1].max_graphemes);
    }

    #[test]
    fn test_header_text_and_spans_to_text_variants() {
        let spans = vec![
            InlineSpan::Text(" Alpha ".to_string()),
            InlineSpan::Strong("Beta".to_string()),
            InlineSpan::Emphasis("Gamma".to_string()),
            InlineSpan::Strikethrough("Delta".to_string()),
            InlineSpan::Code("Epsilon".to_string()),
            InlineSpan::Link {
                text: "Zeta".to_string(),
                url: "https://example.invalid".to_string(),
            },
            InlineSpan::Image {
                src: "img.png".to_string(),
                alt: "Eta".to_string(),
                title: None,
            },
        ];

        let header = header_text(&spans);
        assert!(header.contains("Alpha"));
        assert!(header.contains("Beta"));
        assert!(header.contains("Zeta"));
        assert!(header.contains("Eta"));

        let text = spans_to_text(&spans);
        assert!(text.contains("Alpha"));
        assert!(text.contains("Zeta"));
        assert!(text.contains("Eta"));

        assert_eq!(header_text(&[]), "Column");
        assert_eq!(
            header_text(&[InlineSpan::Text("   ".to_string())]),
            "Column"
        );
    }

    #[test]
    fn test_column_policy_to_column_and_tooltip() {
        let policies = vec![
            ColumnPolicy::Auto,
            ColumnPolicy::Fixed {
                width: 120.0,
                clip: true,
            },
            ColumnPolicy::Remainder { clip: false },
            ColumnPolicy::Resizable {
                min: 50.0,
                preferred: 140.0,
                clip: true,
            },
        ];

        for policy in policies {
            let _col = policy.to_column();
            let tooltip = column_tooltip("Header", &policy).expect("tooltip");
            assert!(tooltip.contains("Header"));
        }
    }

    #[test]
    fn test_apply_preferred_width_clamps_and_hash_stable_for_resizable() {
        let mut spec = ColumnSpec::new(
            0,
            "body",
            ColumnPolicy::Resizable {
                min: 50.0,
                preferred: 120.0,
                clip: false,
            },
            None,
        );
        let original_hash = spec.policy_hash;
        spec.apply_preferred_width(10.0);
        assert!(matches!(spec.policy, ColumnPolicy::Resizable { .. }));
        assert_eq!(spec.policy_hash, original_hash);

        let mut fixed = ColumnSpec::new(
            1,
            "fixed",
            ColumnPolicy::Fixed {
                width: 40.0,
                clip: false,
            },
            None,
        );
        let fixed_hash = fixed.policy_hash;
        fixed.apply_preferred_width(100.0);
        assert_eq!(fixed.policy_hash, fixed_hash);
    }

    #[test]
    fn test_column_spec_hash_includes_index() {
        let policy = ColumnPolicy::Resizable {
            min: 40.0,
            preferred: 120.0,
            clip: false,
        };
        let first = ColumnSpec::new(0, "Header", policy.clone(), None);
        let second = ColumnSpec::new(1, "Header", policy, None);
        assert_ne!(first.policy_hash, second.policy_hash);
    }

    #[test]
    fn test_compute_column_stats_empty() {
        let stats = compute_column_stats(&[], &[], 10);
        assert!(stats.is_empty());
    }

    #[test]
    fn test_classify_date_status_notes_columns() {
        let mut remainder = 0usize;
        let date_policy = classify_column("Date", 0, &mut remainder, None, 14.0);
        let status_policy = classify_column("Status", 1, &mut remainder, None, 14.0);
        let notes_policy = classify_column("Notes", 2, &mut remainder, None, 14.0);

        assert!(matches!(date_policy, ColumnPolicy::Fixed { .. }));
        assert!(matches!(status_policy, ColumnPolicy::Fixed { .. }));
        assert!(matches!(notes_policy, ColumnPolicy::Resizable { .. }));
    }

    #[test]
    fn test_derive_column_specs_remainder_for_rich_content() {
        let headers = vec![vec![span("Body")]];
        let rows = vec![vec![vec![InlineSpan::Link {
            text: "verylonglinkword".to_string(),
            url: "https://example.invalid".to_string(),
        }]]];
        let stats = compute_column_stats(&headers, &rows, 32);
        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
        let specs = derive_column_specs(&ctx);

        assert!(matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
    }

    #[test]
    fn test_normalize_body_font_px_defaults_for_invalid_values() {
        assert_eq!(normalize_body_font_px(f32::NAN), 14.0);
        assert_eq!(normalize_body_font_px(-10.0), 14.0);
        assert_eq!(normalize_body_font_px(0.0), 14.0);
        assert_eq!(normalize_body_font_px(12.0), 12.0);
        assert_eq!(px(10.0, 2.0), 20.0);
    }

    #[test]
    fn test_column_policy_tooltip_variants_for_clip_flags() {
        let fixed = ColumnPolicy::Fixed {
            width: 120.0,
            clip: false,
        };
        let remainder = ColumnPolicy::Remainder { clip: true };

        let fixed_tooltip = column_tooltip("Fixed", &fixed).expect("tooltip");
        assert!(!fixed_tooltip.contains("clipped"));

        let remainder_tooltip = column_tooltip("Remainder", &remainder).expect("tooltip");
        assert!(remainder_tooltip.contains("clipped"));
    }

    #[test]
    fn test_set_policy_updates_hash() {
        let mut spec = ColumnSpec::new(0, "col", ColumnPolicy::Auto, None);
        let original = spec.policy_hash;
        spec.set_policy(ColumnPolicy::Fixed {
            width: 100.0,
            clip: true,
        });
        assert_ne!(spec.policy_hash, original);
    }

    #[test]
    fn test_apply_preferred_width_updates_preferred_value() {
        let mut spec = ColumnSpec::new(
            0,
            "body",
            ColumnPolicy::Resizable {
                min: 50.0,
                preferred: 120.0,
                clip: false,
            },
            None,
        );
        spec.apply_preferred_width(180.0);
        assert!(matches!(spec.policy, ColumnPolicy::Resizable { .. }));
    }

    #[test]
    fn test_column_policy_hash_variants() {
        let policies = [
            ColumnPolicy::Auto,
            ColumnPolicy::Fixed {
                width: 120.0,
                clip: true,
            },
            ColumnPolicy::Remainder { clip: true },
            ColumnPolicy::Resizable {
                min: 40.0,
                preferred: 120.0,
                clip: true,
            },
        ];
        for policy in policies {
            let mut hasher = std::collections::hash_map::DefaultHasher::new();
            policy.hash(&mut hasher);
            let _ = hasher.finish();
        }
    }

    #[test]
    fn test_column_policy_to_column_clipped_variants() {
        let fixed = ColumnPolicy::Fixed {
            width: 120.0,
            clip: true,
        };
        let fixed_unclipped = ColumnPolicy::Fixed {
            width: 120.0,
            clip: false,
        };
        let remainder = ColumnPolicy::Remainder { clip: true };
        let resizable = ColumnPolicy::Resizable {
            min: 40.0,
            preferred: 120.0,
            clip: true,
        };
        let _ = fixed.to_column();
        let _ = fixed_unclipped.to_column();
        let _ = remainder.to_column();
        let _ = resizable.to_column();
    }

    #[test]
    fn test_column_needs_remainder_none_is_false() {
        assert!(!column_needs_remainder(None));
    }

    #[test]
    fn test_accumulate_stats_for_cell_tracks_images() {
        let spans = vec![InlineSpan::Image {
            src: "img.png".to_string(),
            alt: "Alt".to_string(),
            title: None,
        }];
        let mut stat = ColumnStat::default();
        accumulate_stats_for_cell(&spans, &mut stat);
        assert!(stat.rich_content.has_image);
    }

    #[test]
    fn test_accumulate_stats_detects_emoji_like_text() {
        let emoji = char::from_u32(0x1F600).expect("emoji");
        let spans = vec![InlineSpan::Text(format!("Hello {emoji}"))];
        let mut stat = ColumnStat::default();
        accumulate_stats_for_cell(&spans, &mut stat);
        assert!(stat.rich_content.has_emoji_like);
    }

    #[test]
    fn test_remainder_cap_forces_resizable() {
        let mut remainder = MAX_REMAINDER_COLUMNS;
        let stat = ColumnStat {
            max_graphemes: 80,
            longest_word: 40,
            rich_content: RichContentFlags {
                has_link: true,
                has_image: false,
                has_emoji_like: false,
            },
        };
        let policy = classify_column("Notes", 2, &mut remainder, Some(&stat), 14.0);
        assert!(matches!(policy, ColumnPolicy::Resizable { .. }));
    }

    #[test]
    fn test_compute_column_stats_respects_max_samples() {
        let headers = vec![vec![span("Header")]];
        let rows = vec![
            vec![vec![span("short")]],
            vec![vec![span("this_is_a_much_longer_token")]],
        ];
        let stats = compute_column_stats(&headers, &rows, 1);
        assert_eq!(stats.len(), 1);
        assert!(stats[0].longest_word < 20, "should ignore second row");
    }

    #[test]
    fn test_accumulate_stats_preserves_existing_flags() {
        let mut stat = ColumnStat {
            max_graphemes: 0,
            longest_word: 0,
            rich_content: RichContentFlags {
                has_link: false,
                has_image: true,
                has_emoji_like: false,
            },
        };
        accumulate_stats_for_cell(&[InlineSpan::Text("plain".to_string())], &mut stat);
        assert!(stat.rich_content.has_image);
        assert!(!stat.rich_content.has_link);
    }

    #[test]
    fn test_derive_column_specs_empty_context_returns_empty() {
        let headers: Vec<Vec<InlineSpan>> = Vec::new();
        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
        let stats: Vec<ColumnStat> = Vec::new();
        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
        let specs = derive_column_specs(&ctx);
        assert!(specs.is_empty());
    }

    #[test]
    fn test_header_text_link_and_image_first() {
        let spans = vec![InlineSpan::Link {
            text: "Docs".to_string(),
            url: "https://example.com".to_string(),
        }];
        assert_eq!(header_text(&spans), "Docs");
        let spans = vec![InlineSpan::Image {
            src: "img.png".to_string(),
            alt: "Diagram".to_string(),
            title: None,
        }];
        assert_eq!(header_text(&spans), "Diagram");
    }

    #[test]
    fn test_column_needs_remainder_true_for_long_words() {
        let stat = ColumnStat {
            max_graphemes: 10,
            longest_word: 24,
            rich_content: RichContentFlags {
                has_link: false,
                has_image: false,
                has_emoji_like: false,
            },
        };
        assert!(column_needs_remainder(Some(&stat)));
    }

    #[test]
    fn test_column_needs_remainder_true_for_images() {
        let stat = ColumnStat {
            max_graphemes: 5,
            longest_word: 5,
            rich_content: RichContentFlags {
                has_link: false,
                has_image: true,
                has_emoji_like: false,
            },
        };
        assert!(column_needs_remainder(Some(&stat)));
    }

    #[test]
    fn test_classify_column_skips_remainder_when_limit_reached() {
        let mut remainder_assigned = MAX_REMAINDER_COLUMNS;
        let stat = ColumnStat {
            max_graphemes: 2,
            longest_word: 2,
            rich_content: RichContentFlags {
                has_link: false,
                has_image: true,
                has_emoji_like: false,
            },
        };
        let policy = classify_column("misc", 1, &mut remainder_assigned, Some(&stat), 14.0);
        assert!(matches!(policy, ColumnPolicy::Resizable { .. }));
    }

    #[test]
    fn test_accumulate_stats_empty_text_and_existing_emoji_flag() {
        let mut stat = ColumnStat {
            max_graphemes: 0,
            longest_word: 0,
            rich_content: RichContentFlags {
                has_link: false,
                has_image: false,
                has_emoji_like: true,
            },
        };
        accumulate_stats_for_cell(&[InlineSpan::Text("Hello".to_string())], &mut stat);
        assert!(stat.rich_content.has_emoji_like);

        let mut empty_stat = ColumnStat::default();
        accumulate_stats_for_cell(&[], &mut empty_stat);
        assert_eq!(empty_stat.max_graphemes, 0);
    }
}


----------------------------------------

File: src\table_support\metrics.rs

use std::collections::HashMap;

#[allow(dead_code)]
#[derive(Debug, Default, Clone)]
pub struct RowMetrics {
    pub max_height: f32,
    pub dirty: bool,
}

#[allow(dead_code)]
#[derive(Debug, Default, Clone)]
pub struct TableMetricEntry {
    pub rows: Vec<RowMetrics>,
    pub rendered_rows: usize,
    pub total_rows: usize,
    pub header_height: f32,
    pub resolved_widths: Vec<f32>,
    pub last_width_frame: u64,
    pub last_discard_frame: Option<u64>,
    pub persisted_column_widths: HashMap<u64, f32>,
    pub pending_user_resize: Option<PendingResize>,
    /// Font size when widths were last persisted. Used to invalidate
    /// persisted widths when zoom level changes.
    pub persisted_font_size: Option<f32>,
}

#[derive(Debug, Clone, Copy)]
pub struct PendingResize {
    pub column_hash: u64,
    pub width: f32,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum WidthChange {
    None,
    Small,
    Large,
}

const WIDTH_EPSILON: f32 = 0.15;
const WIDTH_LARGE_DELTA: f32 = 0.75;

impl TableMetricEntry {
    pub fn ensure_row(&mut self, index: usize) -> &mut RowMetrics {
        if index >= self.rows.len() {
            self.rows.resize_with(index + 1, RowMetrics::default);
        }
        &mut self.rows[index]
    }

    pub fn row(&self, index: usize) -> Option<&RowMetrics> {
        self.rows.get(index)
    }

    pub fn begin_pass(&mut self, total_rows: usize) {
        self.total_rows = total_rows;
        self.rendered_rows = 0;
    }

    pub fn note_row_rendered(&mut self) {
        self.rendered_rows += 1;
    }

    pub fn persisted_width(&self, key: u64) -> Option<f32> {
        self.persisted_column_widths.get(&key).copied()
    }

    pub fn set_persisted_width(&mut self, key: u64, width: f32) {
        self.persisted_column_widths.insert(key, width);
    }

    pub fn remove_persisted_width(&mut self, key: u64) {
        self.persisted_column_widths.remove(&key);
    }

    pub fn update_widths(&mut self, widths: &[f32], frame_id: u64) -> WidthChange {
        if widths.is_empty() {
            self.resolved_widths.clear();
            self.last_width_frame = frame_id;
            return WidthChange::None;
        }

        let first_update = self.resolved_widths.is_empty();
        let mut change = WidthChange::None;
        if !first_update && self.resolved_widths.len() != widths.len() {
            change = WidthChange::Large;
        } else {
            for (old, new) in self.resolved_widths.iter().zip(widths.iter()) {
                let delta = (old - new).abs();
                if delta > WIDTH_LARGE_DELTA {
                    change = WidthChange::Large;
                    break;
                }
                if delta > WIDTH_EPSILON {
                    change = WidthChange::Small;
                }
            }
        }

        self.resolved_widths.clear();
        self.resolved_widths.extend_from_slice(widths);
        self.last_width_frame = frame_id;

        change
    }

    pub fn header_height(&self) -> Option<f32> {
        if self.header_height > 0.0 {
            Some(self.header_height)
        } else {
            None
        }
    }

    pub fn update_header_height(&mut self, height: f32) -> bool {
        let clamped = height.max(0.0);
        if (self.header_height - clamped).abs() > 0.5 {
            self.header_height = clamped;
            true
        } else {
            false
        }
    }

    pub fn current_widths(&self) -> &[f32] {
        &self.resolved_widths
    }

    /// Check if font size has changed since widths were last persisted.
    /// If so, clear all persisted widths and update the stored font size.
    /// Returns true if widths were cleared.
    pub fn check_font_size_change(&mut self, current_font_size: f32) -> bool {
        const FONT_SIZE_EPSILON: f32 = 0.5;
        if let Some(stored_font) = self.persisted_font_size {
            if (stored_font - current_font_size).abs() > FONT_SIZE_EPSILON {
                self.persisted_column_widths.clear();
                self.persisted_font_size = Some(current_font_size);
                return true;
            }
        } else {
            self.persisted_font_size = Some(current_font_size);
        }
        false
    }
}

#[allow(dead_code)]
#[derive(Debug, Default, Clone)]
pub struct TableMetrics {
    tables: HashMap<u64, TableMetricEntry>,
}

impl TableMetrics {
    pub fn entry_mut(&mut self, table_id: u64) -> &mut TableMetricEntry {
        self.tables.entry(table_id).or_default()
    }

    pub fn entry(&self, table_id: u64) -> Option<&TableMetricEntry> {
        self.tables.get(&table_id)
    }

    pub fn totals(&self) -> (usize, usize) {
        self.tables
            .values()
            .fold((0, 0), |(rendered, total), entry| {
                (rendered + entry.rendered_rows, total + entry.total_rows)
            })
    }

    pub fn clear(&mut self) {
        self.tables.clear();
    }
}

#[allow(dead_code)]
#[derive(Debug, Default, Clone)]
pub struct CacheStats {
    pub hits: u64,
    pub misses: u64,
}

impl CacheStats {
    pub fn record_hit(&mut self) {
        self.hits += 1;
    }

    pub fn record_miss(&mut self) {
        self.misses += 1;
    }
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;

    #[test]
    fn update_widths_detects_large_change() {
        let mut entry = TableMetricEntry::default();
        assert_eq!(entry.update_widths(&[100.0, 120.0], 1), WidthChange::None);
        assert_eq!(entry.update_widths(&[100.2, 120.6], 2), WidthChange::Small);
        assert_eq!(entry.update_widths(&[140.0, 120.6], 3), WidthChange::Large);
    }

    #[test]
    fn font_size_change_clears_persisted_widths() {
        let mut entry = TableMetricEntry::default();

        // Set some persisted widths at font size 14.0
        entry.set_persisted_width(1, 100.0);
        entry.set_persisted_width(2, 150.0);
        assert!(!entry.check_font_size_change(14.0)); // First call sets baseline
        assert_eq!(entry.persisted_width(1), Some(100.0));
        assert_eq!(entry.persisted_width(2), Some(150.0));

        // Small font size change (within epsilon) should NOT clear
        assert!(!entry.check_font_size_change(14.3));
        assert_eq!(entry.persisted_width(1), Some(100.0));

        // Large font size change should clear all persisted widths
        assert!(entry.check_font_size_change(16.0));
        assert_eq!(entry.persisted_width(1), None);
        assert_eq!(entry.persisted_width(2), None);
        assert_eq!(entry.persisted_font_size, Some(16.0));
    }

    #[test]
    fn row_management_tracks_rows_and_rendered_counts() {
        let mut entry = TableMetricEntry::default();
        entry.begin_pass(3);
        assert_eq!(entry.total_rows, 3);
        assert_eq!(entry.rendered_rows, 0);

        let row = entry.ensure_row(2);
        row.max_height = 12.0;
        row.dirty = true;

        assert_eq!(entry.row(2).map(|r| r.max_height), Some(12.0));
        assert_eq!(entry.row(2).map(|r| r.dirty), Some(true));
        assert!(entry.row(5).is_none());

        entry.note_row_rendered();
        entry.note_row_rendered();
        assert_eq!(entry.rendered_rows, 2);
    }

    #[test]
    fn persisted_widths_can_be_added_and_removed() {
        let mut entry = TableMetricEntry::default();
        assert!(entry.persisted_width(10).is_none());
        entry.set_persisted_width(10, 123.0);
        assert_eq!(entry.persisted_width(10), Some(123.0));
        entry.remove_persisted_width(10);
        assert!(entry.persisted_width(10).is_none());
    }

    #[test]
    fn update_widths_handles_empty_and_length_change() {
        let mut entry = TableMetricEntry::default();
        assert_eq!(entry.update_widths(&[], 1), WidthChange::None);
        assert!(entry.current_widths().is_empty());

        assert_eq!(entry.update_widths(&[50.0, 60.0], 2), WidthChange::None);
        assert_eq!(entry.update_widths(&[50.0], 3), WidthChange::Large);
    }

    #[test]
    fn header_height_updates_when_changed() {
        let mut entry = TableMetricEntry::default();
        assert!(entry.header_height().is_none());
        assert!(entry.update_header_height(24.0));
        assert_eq!(entry.header_height(), Some(24.0));
        assert!(!entry.update_header_height(24.2));
        assert!(entry.update_header_height(30.0));
        assert_eq!(entry.header_height(), Some(30.0));
    }

    #[test]
    fn table_metrics_totals_and_clear() {
        let mut metrics = TableMetrics::default();
        metrics.entry_mut(1).begin_pass(2);
        metrics.entry_mut(1).note_row_rendered();
        metrics.entry_mut(2).begin_pass(3);
        metrics.entry_mut(2).note_row_rendered();
        metrics.entry_mut(2).note_row_rendered();

        assert_eq!(metrics.totals(), (3, 5));
        metrics.clear();
        assert!(metrics.entry(1).is_none());
    }

    #[test]
    fn cache_stats_counts_hits_and_misses() {
        let mut stats = CacheStats::default();
        stats.record_hit();
        stats.record_hit();
        stats.record_miss();
        assert_eq!(stats.hits, 2);
        assert_eq!(stats.misses, 1);
    }
}


----------------------------------------

File: src\table_support\mod.rs

pub mod column_spec;
pub mod metrics;

pub use column_spec::{
    compute_column_stats, derive_column_specs, ColumnPolicy, ColumnSpec, ColumnStat,
    RichContentFlags, TableColumnContext,
};
pub use metrics::{CacheStats, RowMetrics, TableMetricEntry, TableMetrics, WidthChange};


----------------------------------------

File: src\window_state.rs

use std::fs;
use std::io::{Read, Write};
use std::path::PathBuf;

#[derive(Debug, Clone, Copy)]
pub struct WindowState {
    pub pos: [f32; 2],
    pub size: [f32; 2],
    pub maximized: bool,
}

fn config_dir() -> Option<PathBuf> {
    // Crossplatform config dir without extra deps
    #[cfg(target_os = "windows")]
    {
        if let Ok(appdata) = std::env::var("APPDATA") {
            let mut p = PathBuf::from(appdata);
            p.push("MarkdownView");
            return Some(p);
        }
    }

    #[cfg(target_os = "macos")]
    {
        if let Ok(home) = std::env::var("HOME") {
            let mut p = PathBuf::from(home);
            p.push("Library/Application Support/MarkdownView");
            return Some(p);
        }
    }

    // Linux / others: XDG or ~/.config
    if let Ok(xdg) = std::env::var("XDG_CONFIG_HOME") {
        let mut p = PathBuf::from(xdg);
        p.push("mdmdview");
        return Some(p);
    }
    if let Ok(home) = std::env::var("HOME") {
        let mut p = PathBuf::from(home);
        p.push(".config/mdmdview");
        return Some(p);
    }
    None
}

fn state_path() -> Option<PathBuf> {
    config_dir().map(|mut dir| {
        dir.push("window_state.txt");
        dir
    })
}

pub fn load_window_state() -> Option<WindowState> {
    #[cfg(windows)]
    {
        if let Some(ws) = load_window_state_registry() {
            return Some(ws);
        }
    }
    let path = state_path()?;
    let mut f = fs::File::open(path).ok()?;
    let mut s = String::new();
    f.read_to_string(&mut s).ok()?;
    // expected format: "x y w h max"
    let parts: Vec<&str> = s.split_whitespace().collect();
    if parts.len() < 5 {
        return None;
    }
    let x = parts[0].parse::<f32>().ok()?;
    let y = parts[1].parse::<f32>().ok()?;
    let w = parts[2].parse::<f32>().ok()?;
    let h = parts[3].parse::<f32>().ok()?;
    let max = matches!(parts[4], "1" | "true" | "True");
    Some(WindowState {
        pos: [x, y],
        size: [w, h],
        maximized: max,
    })
}

pub fn save_window_state(state: &WindowState) -> std::io::Result<()> {
    #[cfg(windows)]
    {
        if let Err(e) = save_window_state_registry(state) {
            eprintln!("Failed to write window state to registry: {e}");
        }
    }
    if let Some(mut dir) = config_dir() {
        if !dir.exists() {
            fs::create_dir_all(&dir)?;
        }
        dir.push("window_state.txt");
        let mut f = fs::File::create(&dir)?;
        write_window_state(&mut f, state)?;
    }
    Ok(())
}

fn write_window_state(writer: &mut dyn Write, state: &WindowState) -> std::io::Result<()> {
    // simple whitespace separated format
    #[cfg(test)]
    if take_forced_file_write_error() {
        return Err(std::io::Error::other("forced write error"));
    }
    writeln!(
        writer,
        "{} {} {} {} {}",
        state.pos[0], state.pos[1], state.size[0], state.size[1], state.maximized as u8
    )?;
    Ok(())
}

pub fn sanitize_window_state(ws: WindowState) -> Option<WindowState> {
    // Basic sanity: finite values
    if !ws.pos[0].is_finite()
        || !ws.pos[1].is_finite()
        || !ws.size[0].is_finite()
        || !ws.size[1].is_finite()
    {
        return None;
    }

    // Clamp to reasonable ranges
    let min_w = 600.0f32;
    let min_h = 400.0f32;
    let max_w = 10000.0f32;
    let max_h = 10000.0f32;
    let max_pos = 20000.0f32; // avoid absurdly large coordinates

    let w = ws.size[0].clamp(min_w, max_w);
    let h = ws.size[1].clamp(min_h, max_h);
    let x = ws.pos[0].max(0.0).min(max_pos);
    let y = ws.pos[1].max(0.0).min(max_pos);

    Some(WindowState {
        pos: [x, y],
        size: [w, h],
        maximized: ws.maximized,
    })
}

#[cfg(all(windows, not(test)))]
fn load_window_state_registry() -> Option<WindowState> {
    use winreg::enums::HKEY_CURRENT_USER;
    use winreg::RegKey;
    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
    let key = hkcu.open_subkey("Software\\MarkdownView").ok()?;
    let x: u32 = key.get_value("PosX").ok()?;
    let y: u32 = key.get_value("PosY").ok()?;
    let w: u32 = key.get_value("Width").ok()?;
    let h: u32 = key.get_value("Height").ok()?;
    let maximized: u32 = key.get_value("Maximized").unwrap_or(0);
    Some(WindowState {
        pos: [x as f32, y as f32],
        size: [w as f32, h as f32],
        maximized: maximized != 0,
    })
}

#[cfg(all(windows, not(test)))]
fn save_window_state_registry(state: &WindowState) -> std::io::Result<()> {
    use winreg::enums::{HKEY_CURRENT_USER, KEY_READ, KEY_WRITE};
    use winreg::RegKey;
    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
    let (key, _disp) =
        hkcu.create_subkey_with_flags("Software\\MarkdownView", KEY_READ | KEY_WRITE)?;
    let to_u32 = |v: f32| -> u32 {
        if v.is_finite() {
            v.max(0.0).min(u32::MAX as f32).round() as u32
        } else {
            0
        }
    };
    key.set_value("PosX", &to_u32(state.pos[0]))?;
    key.set_value("PosY", &to_u32(state.pos[1]))?;
    key.set_value("Width", &to_u32(state.size[0]))?;
    key.set_value("Height", &to_u32(state.size[1]))?;
    key.set_value("Maximized", &(state.maximized as u32))?;
    Ok(())
}

#[cfg(test)]
thread_local! {
    static FORCED_FILE_WRITE_ERROR: std::cell::RefCell<bool> =
        const { std::cell::RefCell::new(false) };
}

#[cfg(test)]
fn take_forced_file_write_error() -> bool {
    FORCED_FILE_WRITE_ERROR.with(|flag| flag.replace(false))
}

#[cfg(test)]
fn force_file_write_error_once() {
    FORCED_FILE_WRITE_ERROR.with(|flag| {
        *flag.borrow_mut() = true;
    });
}

#[cfg(all(windows, test))]
thread_local! {
    static FORCED_REGISTRY_LOAD: std::cell::RefCell<Option<WindowState>> =
        const { std::cell::RefCell::new(None) };
    static FORCED_REGISTRY_SAVE_ERROR: std::cell::RefCell<bool> =
        const { std::cell::RefCell::new(false) };
}

#[cfg(all(windows, test))]
fn take_forced_registry_load() -> Option<WindowState> {
    FORCED_REGISTRY_LOAD.with(|slot| slot.borrow_mut().take())
}

#[cfg(all(windows, test))]
fn take_forced_registry_save_error() -> bool {
    FORCED_REGISTRY_SAVE_ERROR.with(|flag| flag.replace(false))
}

#[cfg(all(windows, test))]
fn force_registry_load_once(state: WindowState) {
    FORCED_REGISTRY_LOAD.with(|slot| {
        *slot.borrow_mut() = Some(state);
    });
}

#[cfg(all(windows, test))]
fn force_registry_save_error_once() {
    FORCED_REGISTRY_SAVE_ERROR.with(|flag| {
        *flag.borrow_mut() = true;
    });
}

#[cfg(all(windows, test))]
fn load_window_state_registry() -> Option<WindowState> {
    take_forced_registry_load()
}

#[cfg(all(windows, test))]
fn save_window_state_registry(_state: &WindowState) -> std::io::Result<()> {
    if take_forced_registry_save_error() {
        return Err(std::io::Error::other("forced registry error"));
    }
    Ok(())
}

#[cfg(test)]
#[cfg_attr(coverage_nightly, coverage(off))]
mod tests {
    use super::*;
    use std::sync::{Mutex, OnceLock};
    use tempfile::TempDir;

    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
        ENV_LOCK
            .get_or_init(|| Mutex::new(()))
            .lock()
            .expect("env lock")
    }

    struct EnvGuard {
        key: &'static str,
        original: Option<String>,
    }

    impl EnvGuard {
        fn set(key: &'static str, value: &str) -> Self {
            let original = std::env::var(key).ok();
            std::env::set_var(key, value);
            Self { key, original }
        }

        fn unset(key: &'static str) -> Self {
            let original = std::env::var(key).ok();
            std::env::remove_var(key);
            Self { key, original }
        }
    }

    impl Drop for EnvGuard {
        fn drop(&mut self) {
            if let Some(value) = &self.original {
                std::env::set_var(self.key, value);
            } else {
                std::env::remove_var(self.key);
            }
        }
    }

    #[test]
    fn test_sanitize_window_state_clamps_and_rejects_invalid() {
        let invalid = WindowState {
            pos: [f32::NAN, 10.0],
            size: [800.0, 600.0],
            maximized: false,
        };
        assert!(sanitize_window_state(invalid).is_none());

        let input = WindowState {
            pos: [-50.0, 25000.0],
            size: [100.0, 200.0],
            maximized: true,
        };
        let sanitized = sanitize_window_state(input).expect("expected sanitized state");
        assert_eq!(sanitized.pos[0], 0.0);
        assert_eq!(sanitized.pos[1], 20000.0);
        assert_eq!(sanitized.size[0], 600.0);
        assert_eq!(sanitized.size[1], 400.0);
        assert!(sanitized.maximized);
    }

    #[test]
    fn test_sanitize_window_state_rejects_non_finite_components() {
        let invalid_y = WindowState {
            pos: [10.0, f32::NAN],
            size: [800.0, 600.0],
            maximized: false,
        };
        assert!(sanitize_window_state(invalid_y).is_none());

        let invalid_w = WindowState {
            pos: [10.0, 20.0],
            size: [f32::NAN, 600.0],
            maximized: false,
        };
        assert!(sanitize_window_state(invalid_w).is_none());

        let invalid_h = WindowState {
            pos: [10.0, 20.0],
            size: [800.0, f32::NAN],
            maximized: false,
        };
        assert!(sanitize_window_state(invalid_h).is_none());
    }

    #[test]
    fn test_save_and_load_window_state_from_file() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());

        let state = WindowState {
            pos: [120.0, 80.0],
            size: [1024.0, 768.0],
            maximized: false,
        };
        save_window_state(&state).expect("save");

        let loaded = load_window_state().expect("load");
        assert_eq!(loaded.pos, state.pos);
        assert_eq!(loaded.size, state.size);
        assert_eq!(loaded.maximized, state.maximized);
    }

    #[test]
    fn test_save_window_state_creates_dir_and_writes_file() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());

        let config_dir = temp.path().join("MarkdownView");
        let _ = fs::remove_dir_all(&config_dir);

        let state = WindowState {
            pos: [10.0, 20.0],
            size: [800.0, 600.0],
            maximized: true,
        };
        save_window_state(&state).expect("save");

        let path = config_dir.join("window_state.txt");
        let contents = fs::read_to_string(&path).expect("read");
        let mut parts = contents.split_whitespace();
        let pos_x: f32 = parts.next().expect("pos x").parse().expect("parse pos x");
        let pos_y: f32 = parts.next().expect("pos y").parse().expect("parse pos y");
        let size_x: f32 = parts.next().expect("size x").parse().expect("parse size x");
        let size_y: f32 = parts.next().expect("size y").parse().expect("parse size y");
        let max_flag = parts.next().expect("max flag");
        assert_eq!(pos_x, state.pos[0]);
        assert_eq!(pos_y, state.pos[1]);
        assert_eq!(size_x, state.size[0]);
        assert_eq!(size_y, state.size[1]);
        assert_eq!(max_flag, "1");
    }

    #[test]
    fn test_write_window_state_error_propagates() {
        struct FailingWriter;

        impl Write for FailingWriter {
            fn write(&mut self, _buf: &[u8]) -> std::io::Result<usize> {
                Err(std::io::Error::other("fail"))
            }

            fn flush(&mut self) -> std::io::Result<()> {
                Ok(())
            }
        }

        let state = WindowState {
            pos: [1.0, 2.0],
            size: [3.0, 4.0],
            maximized: false,
        };
        let mut writer = FailingWriter;
        let err = write_window_state(&mut writer, &state).expect_err("err");
        assert_eq!(err.kind(), std::io::ErrorKind::Other);
        writer.flush().expect("flush");
    }

    #[test]
    fn test_save_window_state_errors_when_state_path_is_dir() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());

        let config_dir = temp.path().join("MarkdownView");
        fs::create_dir_all(&config_dir).expect("create config dir");
        let state_dir = config_dir.join("window_state.txt");
        fs::create_dir_all(&state_dir).expect("create state dir");

        let state = WindowState {
            pos: [1.0, 2.0],
            size: [3.0, 4.0],
            maximized: false,
        };
        assert!(save_window_state(&state).is_err());
    }

    #[test]
    fn test_save_window_state_forced_write_error_propagates() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());

        force_file_write_error_once();
        let state = WindowState {
            pos: [1.0, 2.0],
            size: [3.0, 4.0],
            maximized: false,
        };
        let err = save_window_state(&state).expect_err("expected error");
        assert_eq!(err.kind(), std::io::ErrorKind::Other);
    }

    #[test]
    fn test_save_window_state_when_dir_exists() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
        let config_dir = temp.path().join("MarkdownView");
        fs::create_dir_all(&config_dir).expect("create config dir");

        let state = WindowState {
            pos: [5.0, 6.0],
            size: [700.0, 500.0],
            maximized: false,
        };
        save_window_state(&state).expect("save");
        let path = config_dir.join("window_state.txt");
        assert!(path.exists());
    }

    #[test]
    fn test_load_window_state_prefers_registry_when_forced() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());

        let state = WindowState {
            pos: [42.0, 24.0],
            size: [800.0, 600.0],
            maximized: true,
        };
        force_registry_load_once(state);

        let loaded = load_window_state().expect("load");
        assert_eq!(loaded.pos, state.pos);
        assert_eq!(loaded.size, state.size);
        assert_eq!(loaded.maximized, state.maximized);
    }

    #[test]
    fn test_save_window_state_registry_error_still_writes_file() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
        force_registry_save_error_once();

        let state = WindowState {
            pos: [10.0, 20.0],
            size: [1024.0, 768.0],
            maximized: false,
        };
        save_window_state(&state).expect("save");

        let path = temp.path().join("MarkdownView").join("window_state.txt");
        assert!(path.exists());
    }

    #[test]
    fn test_load_window_state_rejects_bad_file() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());

        let mut config = temp.path().join("MarkdownView");
        std::fs::create_dir_all(&config).expect("create config dir");
        config.push("window_state.txt");
        std::fs::write(&config, "10 20 30").expect("write bad data");

        assert!(load_window_state().is_none());
    }

    #[test]
    fn test_load_window_state_rejects_invalid_numbers() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());

        let mut config = temp.path().join("MarkdownView");
        std::fs::create_dir_all(&config).expect("create config dir");
        config.push("window_state.txt");
        std::fs::write(&config, "x y 10 20 true").expect("write bad data");

        assert!(load_window_state().is_none());
    }

    #[test]
    fn test_load_window_state_rejects_invalid_components() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());

        let mut config = temp.path().join("MarkdownView");
        std::fs::create_dir_all(&config).expect("create config dir");
        config.push("window_state.txt");

        std::fs::write(&config, "10 y 30 40 1").expect("write bad data");
        assert!(load_window_state().is_none());

        std::fs::write(&config, "10 20 w 40 1").expect("write bad data");
        assert!(load_window_state().is_none());

        std::fs::write(&config, "10 20 30 h 1").expect("write bad data");
        assert!(load_window_state().is_none());
    }

    #[test]
    fn test_load_window_state_rejects_invalid_utf8() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());

        let mut config = temp.path().join("MarkdownView");
        std::fs::create_dir_all(&config).expect("create config dir");
        config.push("window_state.txt");
        std::fs::write(&config, [0xFF, 0xFE, 0xFD]).expect("write bad data");

        assert!(load_window_state().is_none());
    }

    #[test]
    fn test_load_window_state_parses_maximized_true() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());

        let mut config = temp.path().join("MarkdownView");
        std::fs::create_dir_all(&config).expect("create config dir");
        config.push("window_state.txt");
        std::fs::write(&config, "10 20 300 400 true").expect("write data");

        let loaded = load_window_state().expect("load");
        assert!(loaded.maximized);
    }

    #[test]
    fn test_load_window_state_returns_none_when_missing() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());

        assert!(load_window_state().is_none());
    }

    #[test]
    fn test_config_dir_falls_back_to_xdg() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard_appdata = EnvGuard::unset("APPDATA");
        let _guard_home = EnvGuard::unset("HOME");
        let _guard_xdg = EnvGuard::set("XDG_CONFIG_HOME", temp.path().to_string_lossy().as_ref());

        let dir = config_dir().expect("config dir");
        assert!(dir.starts_with(temp.path()));
        assert!(dir.ends_with("mdmdview"));
    }

    #[test]
    fn test_config_dir_falls_back_to_home() {
        let _lock = env_lock();
        let temp = TempDir::new().expect("temp dir");
        let _guard_appdata = EnvGuard::unset("APPDATA");
        let _guard_xdg = EnvGuard::unset("XDG_CONFIG_HOME");
        let _guard_home = EnvGuard::set("HOME", temp.path().to_string_lossy().as_ref());

        let dir = config_dir().expect("config dir");
        assert!(dir.starts_with(temp.path()));
        assert!(dir.ends_with(std::path::Path::new(".config").join("mdmdview")));
    }

    #[test]
    fn test_config_dir_none_without_env() {
        let _lock = env_lock();
        let _guard_appdata = EnvGuard::unset("APPDATA");
        let _guard_xdg = EnvGuard::unset("XDG_CONFIG_HOME");
        let _guard_home = EnvGuard::unset("HOME");

        assert!(config_dir().is_none());
        let state = WindowState {
            pos: [1.0, 2.0],
            size: [800.0, 600.0],
            maximized: false,
        };
        save_window_state(&state).expect("save ok");
        assert!(load_window_state().is_none());
    }
}


----------------------------------------


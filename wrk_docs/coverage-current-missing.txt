C:\language\mdmdview\src\app.rs:
    1|       |/// Main application logic for the markdown viewer
    2|       |///
    3|       |/// This module contains the primary app state, UI logic, and event handling
    4|       |/// for the markdown viewer application built with egui.
    5|       |use crate::{MarkdownElement, MarkdownRenderer, SampleFile, WindowState, SAMPLE_FILES};
    6|       |use anyhow::{bail, Result};
    7|       |use egui::text::LayoutJob;
    8|       |use egui::text::TextFormat;
    9|       |use egui::{menu, CentralPanel, Color32, Context, RichText, TopBottomPanel};
   10|       |use egui::{TextEdit, TextStyle};
   11|       |#[cfg(not(test))]
   12|       |use rfd::FileDialog;
   13|       |#[cfg(test)]
   14|       |use std::cell::RefCell;
   15|       |#[cfg(test)]
   16|       |use std::collections::HashSet;
   17|       |use std::collections::VecDeque;
   18|       |use std::io::ErrorKind;
   19|       |use std::path::{Path, PathBuf};
   20|       |use unicode_casefold::UnicodeCaseFold;
   21|       |use unicode_normalization::UnicodeNormalization;
   22|       |
   23|       |/// Prefix used for application/window titles.
   24|       |pub const APP_TITLE_PREFIX: &str = "mdmdview";
   25|       |const BUILD_VERSION: &str = env!("CARGO_PKG_VERSION");
   26|       |const BUILD_TIMESTAMP: &str = env!("MDMDVIEW_BUILD_TIMESTAMP");
   27|       |
   28|       |/// Entry in navigation history for back/forward navigation
   29|       |#[derive(Clone, Debug)]
   30|       |struct HistoryEntry {
   31|       |    file_path: Option<PathBuf>,
   32|       |    title: String,
   33|       |    content: String,
   34|       |}
   35|       |
   36|       |/// Main application state and logic
   37|       |pub struct MarkdownViewerApp {
   38|       |    /// Markdown renderer instance
   39|       |    renderer: MarkdownRenderer,
   40|       |    /// Currently loaded file path
   41|       |    current_file: Option<PathBuf>,
   42|       |    /// Current markdown content as string
   43|       |    current_content: String,
   44|       |    /// Buffer for raw view (read-only for now)
   45|       |    raw_buffer: String,
   46|       |    /// Parsed markdown elements ready for rendering
   47|       |    parsed_elements: Vec<MarkdownElement>,
   48|       |    /// Application title for window
   49|       |    title: String,
   50|       |    /// Error message to display if any
   51|       |    error_message: Option<String>,
   52|       |    /// Navigation request for keyboard shortcuts
   53|       |    nav_request: Option<NavigationRequest>,
   54|       |    /// Scroll area ID for state management
   55|       |    scroll_area_id: egui::Id,
   56|       |    /// Flag to request fullscreen toggle
   57|       |    toggle_fullscreen: bool,
   58|       |    /// Current view mode
   59|       |    view_mode: ViewMode,
   60|       |    /// Wrap long lines in raw view
   61|       |    wrap_raw: bool,
   62|       |    /// Whether the table wrap overhaul renderer is active
   63|       |    table_wrap_overhaul_enabled: bool,
   64|       |    /// Write mode: allow editing in Raw view
   65|       |    write_enabled: bool,
   66|       |    /// Remember caret position in raw editor (byte index)
   67|       |    raw_cursor: Option<usize>,
   68|       |    /// Request focus for raw editor on next render
   69|       |    raw_focus_requested: bool,
   70|       |    /// Flag to request reload of current file (handled outside input context)
   71|       |    reload_requested: bool,
   72|       |    /// Defer toggling view mode to outside input context
   73|       |    view_toggle_requested: bool,
   74|       |    /// Defer toggling write mode to outside input context
   75|       |    write_toggle_requested: bool,
   76|       |    /// Last known window position (for persistence)
   77|       |    last_window_pos: Option<[f32; 2]>,
   78|       |    /// Last known window size (for persistence)
   79|       |    last_window_size: Option<[f32; 2]>,
   80|       |    /// Last known maximized state
   81|       |    last_window_maximized: bool,
   82|       |    /// Last persisted window snapshot to avoid redundant disk writes
   83|       |    last_persisted_state: Option<WindowState>,
   84|       |    /// Throttle saving window state
   85|       |    last_persist_instant: std::time::Instant,
   86|       |    // Search state
   87|       |    show_search: bool,
   88|       |    search_query: String,
   89|       |    last_query: String,
   90|       |    last_match_index: Option<usize>,
   91|       |    pending_scroll_to_element: Option<usize>,
   92|       |    search_focus_requested: bool,
   93|       |    /// Deferred caret movement (in lines) for raw editor
   94|       |    pending_raw_cursor_line_move: Option<i32>,
   95|       |    // Navigation history
   96|       |    /// History of visited files and samples for back/forward navigation
   97|       |    history: Vec<HistoryEntry>,
   98|       |    /// Current position in history
   99|       |    history_index: usize,
  100|       |    /// Maximum history entries to keep
  101|       |    max_history: usize,
  102|       |    // Drag and drop state
  103|       |    /// Visual state: file is being dragged over window
  104|       |    drag_hover: bool,
  105|       |    /// Queue of files waiting to be opened (from multi-file drop)
  106|       |    pending_files: VecDeque<PathBuf>,
  107|       |}
  108|       |
  109|       |/// Navigation request for keyboard-triggered scrolling
  110|       |#[derive(Debug, Clone)]
  111|       |enum NavigationRequest {
  112|       |    Top,
  113|       |    Bottom,
  114|       |    PageUp,
  115|       |    PageDown,
  116|       |    ScrollUp,   // Arrow up - fine scrolling
  117|       |    ScrollDown, // Arrow down - fine scrolling
  118|       |}
  119|       |
  120|       |/// Which view the user is in
  121|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
  122|       |enum ViewMode {
  123|       |    Rendered,
  124|       |    Raw,
  125|       |}
  126|       |
  127|       |#[cfg(test)]
  128|       |thread_local! {
  129|       |    static FORCED_ACTIONS: RefCell<HashSet<&'static str>> = RefCell::new(HashSet::new());
  130|       |}
  131|       |
  132|       |#[cfg(test)]
  133|     77|fn action_triggered(clicked: bool, action: &'static str) -> bool {
  134|     77|    clicked || FORCED_ACTIONS.with(|actions| actions.borrow().contains(action))
  135|     77|}
  136|       |
  137|       |#[cfg(not(test))]
  138|       |fn action_triggered(clicked: bool, _action: &'static str) -> bool {
  139|       |    clicked
  140|       |}
  141|       |
  142|       |#[cfg(test)]
  143|      1|fn consume_forced_action(action: &'static str) -> bool {
  144|      1|    FORCED_ACTIONS.with(|actions| actions.borrow_mut().take(action).is_some())
  145|      1|}
  146|       |
  147|       |#[cfg(not(test))]
  148|       |fn consume_forced_action(_action: &'static str) -> bool {
  149|       |    false
  150|       |}
  151|       |
  152|       |impl MarkdownViewerApp {
  153|      4|    fn toggle_write_mode(&mut self, ctx: &Context) {
  154|      4|        if self.write_enabled {
  155|       |            // About to disable; capture current cursor if in Raw view
  156|      1|            if matches!(self.view_mode, ViewMode::Raw) {
                             ^0
  157|      1|                let editor_id = egui::Id::new("raw_editor");
  158|      1|                if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
  159|      1|                    if let Some(range) = state.cursor.char_range() {
  160|      1|                        self.raw_cursor = Some(range.primary.index);
  161|      1|                    }
                                  ^0
  162|      0|                }
  163|      0|            }
  164|      1|            self.write_enabled = false;
  165|       |        } else {
  166|       |            // Enabling write mode: ensure the raw editor will gain focus
  167|      3|            self.write_enabled = true;
  168|      3|            if matches!(self.view_mode, ViewMode::Raw) {
                             ^0
  169|      3|                self.raw_focus_requested = true;
  170|      3|            }
                          ^0
  171|       |        }
  172|      4|    }
  173|       |
  174|      4|    fn move_raw_cursor_lines(&mut self, ctx: &Context, delta_lines: i32) {
  175|      4|        if !matches!(self.view_mode, ViewMode::Raw) || !self.write_enabled {
                          ^0
  176|      0|            return;
  177|      4|        }
  178|      4|        let editor_id = egui::Id::new("raw_editor");
  179|      4|        if let Some(mut state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
                                  ^3
  180|      3|            let mut idx = state
  181|      3|                .cursor
  182|      3|                .char_range()
  183|      3|                .map(|r| r.primary.index)
  184|      3|                .unwrap_or_else(|| self.raw_cursor.unwrap_or(0))
                                                 ^0              ^0
  185|      3|                .min(self.raw_buffer.len());
  186|       |
  187|      3|            let s = self.raw_buffer.as_str();
  188|      3|            match delta_lines.cmp(&0) {
  189|       |                std::cmp::Ordering::Less => {
  190|      1|                    let mut lines = -delta_lines;
  191|       |                    // Move to start of current line
  192|      1|                    idx = s[..idx].rfind('\n').map(|p| p + 1).unwrap_or(0);
  193|      2|                    while lines > 0 && idx > 0 {
                                                     ^1
  194|      1|                        if let Some(prev_nl) = s[..idx.saturating_sub(1)].rfind('\n') {
                                                  ^0
  195|      0|                            idx = prev_nl + 1;
  196|      1|                        } else {
  197|      1|                            idx = 0;
  198|      1|                        }
  199|      1|                        lines -= 1;
  200|       |                    }
  201|       |                }
  202|       |                std::cmp::Ordering::Greater => {
  203|      2|                    let mut lines = delta_lines;
  204|       |                    // Move to start of next line
  205|      2|                    if let Some(nl) = s[idx..].find('\n') {
  206|      2|                        idx = (idx + nl + 1).min(s.len());
  207|      2|                        lines -= 1;
  208|      2|                    }
                                  ^0
  209|      3|                    while lines > 0 && idx < s.len() {
                                                     ^1
  210|      1|                        if let Some(nl) = s[idx..].find('\n') {
  211|      1|                            idx = (idx + nl + 1).min(s.len());
  212|      1|                        } else {
  213|      0|                            idx = s.len();
  214|      0|                        }
  215|      1|                        lines -= 1;
  216|       |                    }
  217|       |                }
  218|      0|                std::cmp::Ordering::Equal => {}
  219|       |            }
  220|      3|            let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(idx));
  221|      3|            state.cursor.set_char_range(Some(cr));
  222|      3|            state.store(ctx, editor_id);
  223|      3|            self.raw_cursor = Some(idx);
  224|      3|            self.raw_focus_requested = true; // keep focus and make caret visible
  225|      1|        }
  226|      4|    }
  227|      2|    fn clear_search_state(&mut self) {
  228|      2|        self.search_query.clear();
  229|      2|        self.last_query.clear();
  230|      2|        self.last_match_index = None;
  231|      2|        self.pending_scroll_to_element = None;
  232|      2|        self.renderer.set_highlight_phrase(None);
  233|      2|    }
  234|      4|    fn find_next(&mut self) {
  235|      4|        if self.search_query.is_empty() && self.last_query.is_empty() {
                                                         ^1              ^1
  236|      0|            return;
  237|      4|        }
  238|      4|        let needle = if !self.search_query.is_empty() {
  239|      3|            self.last_query = self.search_query.clone();
  240|      3|            Self::fold_for_search(&self.search_query)
  241|       |        } else {
  242|      1|            Self::fold_for_search(&self.last_query)
  243|       |        };
  244|      4|        if needle.is_empty() {
  245|      0|            return;
  246|      4|        }
  247|      4|        let mut start = self.last_match_index.unwrap_or(usize::MAX);
  248|      4|        if start == usize::MAX {
  249|      2|            start = 0;
  250|      2|        } else {
  251|      2|            start = start.saturating_add(1);
  252|      2|        }
  253|       |        // Wrap-around search forward
  254|      4|        let total = self.parsed_elements.len();
  255|      5|        for pass in 0..2 {
  256|      5|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
  257|      4|                Box::new(start..total)
  258|       |            } else {
  259|      1|                Box::new(0..start.min(total))
  260|       |            };
  261|      8|            for idx in range {
                              ^7
  262|      7|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
  263|      7|                    &self.parsed_elements[idx],
  264|       |                );
  265|      7|                if Self::fold_for_search(&text).contains(&needle) {
  266|      4|                    self.last_match_index = Some(idx);
  267|      4|                    self.pending_scroll_to_element = Some(idx);
  268|      4|                    return;
  269|      3|                }
  270|       |            }
  271|       |        }
  272|      4|    }
  273|       |
  274|      3|    fn find_previous(&mut self) {
  275|      3|        if self.search_query.is_empty() && self.last_query.is_empty() {
                                                         ^0              ^0
  276|      0|            return;
  277|      3|        }
  278|      3|        let needle = if !self.search_query.is_empty() {
  279|      3|            self.last_query = self.search_query.clone();
  280|      3|            Self::fold_for_search(&self.search_query)
  281|       |        } else {
  282|      0|            Self::fold_for_search(&self.last_query)
  283|       |        };
  284|      3|        if needle.is_empty() {
  285|      0|            return;
  286|      3|        }
  287|      3|        let total = self.parsed_elements.len();
  288|      3|        let mut start = self.last_match_index.unwrap_or(0);
  289|      3|        if start == 0 {
  290|      3|            start = total.saturating_sub(1);
  291|      3|        } else {
  292|      0|            start = start.saturating_sub(1);
  293|      0|        }
  294|       |        // Wrap-around search backward
  295|      3|        for pass in 0..2 {
  296|      3|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
  297|      3|                Box::new((0..=start).rev())
  298|       |            } else {
  299|      0|                Box::new(((start + 1)..total).rev())
  300|       |            };
  301|      7|            for idx in range {
  302|      7|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
  303|      7|                    &self.parsed_elements[idx],
  304|       |                );
  305|      7|                if Self::fold_for_search(&text).contains(&needle) {
  306|      3|                    self.last_match_index = Some(idx);
  307|      3|                    self.pending_scroll_to_element = Some(idx);
  308|      3|                    return;
  309|      4|                }
  310|       |            }
  311|       |        }
  312|      3|    }
  313|       |    /// Create a new application instance
  314|     64|    pub fn new() -> Self {
  315|     64|        let mut app = Self {
  316|     64|            renderer: MarkdownRenderer::new(),
  317|     64|            current_file: None,
  318|     64|            current_content: String::new(),
  319|     64|            raw_buffer: String::new(),
  320|     64|            parsed_elements: Vec::new(),
  321|     64|            title: APP_TITLE_PREFIX.to_string(),
  322|     64|            error_message: None,
  323|     64|            nav_request: None,
  324|     64|            scroll_area_id: egui::Id::new("main_scroll_area"),
  325|     64|            toggle_fullscreen: false,
  326|     64|            view_mode: ViewMode::Rendered,
  327|     64|            wrap_raw: false,
  328|     64|            table_wrap_overhaul_enabled: true,
  329|     64|            write_enabled: false,
  330|     64|            raw_cursor: None,
  331|     64|            raw_focus_requested: false,
  332|     64|            reload_requested: false,
  333|     64|            view_toggle_requested: false,
  334|     64|            write_toggle_requested: false,
  335|     64|            last_window_pos: None,
  336|     64|            last_window_size: None,
  337|     64|            last_window_maximized: false,
  338|     64|            last_persisted_state: None,
  339|     64|            last_persist_instant: std::time::Instant::now(),
  340|     64|            show_search: false,
  341|     64|            search_query: String::new(),
  342|     64|            last_query: String::new(),
  343|     64|            last_match_index: None,
  344|     64|            pending_scroll_to_element: None,
  345|     64|            search_focus_requested: false,
  346|     64|            pending_raw_cursor_line_move: None,
  347|     64|            history: Vec::new(),
  348|     64|            history_index: 0,
  349|     64|            max_history: 50,
  350|     64|            drag_hover: false,
  351|     64|            pending_files: VecDeque::new(),
  352|     64|        };
  353|     64|        app.renderer
  354|     64|            .set_table_wrap_overhaul_enabled(app.table_wrap_overhaul_enabled);
  355|       |
  356|       |        // Load welcome content by default
  357|     64|        if let Some(welcome) = SAMPLE_FILES.iter().find(|f| f.name == "welcome.md") {
  358|     64|            app.load_content(welcome.content, Some("Welcome".to_string()));
  359|     64|        }
                      ^0
  360|       |
  361|     64|        app
  362|     64|    }
  363|       |
  364|      1|    pub fn set_table_wrap_overhaul_enabled(&mut self, enabled: bool) {
  365|      1|        self.table_wrap_overhaul_enabled = enabled;
  366|      1|        self.renderer.set_table_wrap_overhaul_enabled(enabled);
  367|      1|    }
  368|       |
  369|      1|    fn toggle_table_wrap_overhaul(&mut self) {
  370|      1|        let enabled = !self.table_wrap_overhaul_enabled;
  371|      1|        self.set_table_wrap_overhaul_enabled(enabled);
  372|      1|    }
  373|       |
  374|       |    /// Check if file has valid markdown extension
  375|     88|    fn is_valid_markdown_file(&self, path: &Path) -> bool {
  376|     88|        if let Some(ext) = path.extension() {
                                  ^87
  377|     87|            let ext = ext.to_string_lossy().to_lowercase();
  378|     87|            matches!(ext.as_str(), "md" | "markdown" | "mdown" | "mkd" | "txt")
                          ^81                           ^12          ^9        ^8      ^7
  379|       |        } else {
  380|      1|            false
  381|       |        }
  382|     88|    }
  383|       |
  384|       |    /// Handle dropped files from drag-and-drop operation
  385|      8|    fn handle_file_drop(&mut self, paths: Vec<PathBuf>) {
  386|      8|        if paths.is_empty() {
  387|      0|            return;
  388|      8|        }
  389|       |
  390|      8|        let mut valid_files = Vec::new();
  391|      8|        let mut errors = Vec::new();
  392|       |
  393|       |        // Validate all dropped files
  394|     80|        for path in paths {
                          ^72
  395|     72|            if !path.exists() {
  396|      0|                errors.push(format!("File not found: {}", path.display()));
  397|      0|                continue;
  398|     72|            }
  399|       |
  400|     72|            if path.is_dir() {
  401|       |                // Handle directory by scanning for markdown files
  402|      2|                match self.scan_directory(&path) {
  403|      2|                    Ok(dir_files) => {
  404|      2|                        if dir_files.is_empty() {
  405|      1|                            errors.push(format!(
  406|      1|                                "No markdown files in directory: {}",
  407|      1|                                path.display()
  408|      1|                            ));
  409|      1|                        } else {
  410|      1|                            valid_files.extend(dir_files);
  411|      1|                        }
  412|       |                    }
  413|      0|                    Err(e) => {
  414|      0|                        errors.push(format!("Cannot read directory {}: {}", path.display(), e));
  415|      0|                    }
  416|       |                }
  417|      2|                continue;
  418|     70|            }
  419|       |
  420|     70|            if !self.is_valid_markdown_file(&path) {
  421|      2|                errors.push(format!(
  422|      2|                    "Not a markdown file: {}",
  423|      2|                    path.file_name().unwrap_or_default().to_string_lossy()
  424|       |                ));
  425|      2|                continue;
  426|     68|            }
  427|       |
  428|     68|            valid_files.push(path);
  429|       |        }
  430|       |
  431|       |        // Limit to prevent memory issues
  432|       |        const MAX_FILES: usize = 50;
  433|      8|        if valid_files.len() > MAX_FILES {
  434|      1|            self.error_message = Some(format!(
  435|      1|                "Too many files ({}). Maximum is {}.\n\
  436|      1|                 Please drop files in smaller batches.",
  437|      1|                valid_files.len(),
  438|      1|                MAX_FILES
  439|      1|            ));
  440|      1|            return;
  441|      7|        }
  442|       |
  443|       |        // Handle valid files
  444|      7|        if !valid_files.is_empty() {
  445|       |            // Open first file immediately
  446|      5|            let first_file = valid_files.remove(0);
  447|      5|            if let Err(e) = self.load_file(first_file, true) {
                                     ^0
  448|      0|                self.error_message = Some(format!("Failed to load file: {}", e));
  449|      0|                return;
  450|      5|            }
  451|       |
  452|       |            // Queue remaining files
  453|      5|            self.pending_files.extend(valid_files.iter().cloned());
  454|       |
  455|       |            // Show info message if multiple files
  456|      5|            if !self.pending_files.is_empty() {
  457|      2|                eprintln!(
  458|      2|                    "Queued {} files. Use Alt+Right to navigate to the next file.",
  459|      2|                    self.pending_files.len()
  460|      2|                );
  461|      3|            }
  462|      2|        }
  463|       |
  464|       |        // Show errors if any
  465|      7|        if !errors.is_empty() {
  466|      3|            let valid_count = if valid_files.is_empty() {
  467|      3|                0
  468|       |            } else {
  469|      0|                valid_files.len() + 1
  470|       |            };
  471|      3|            let error_msg = if errors.len() == 1 && valid_count == 0 {
  472|      3|                errors[0].clone()
  473|      0|            } else if valid_count == 0 {
  474|       |                // All files failed
  475|      0|                format!("No valid files:\n{}", errors.join("\n"))
  476|       |            } else {
  477|       |                // Some succeeded, some failed
  478|      0|                format!(
  479|      0|                    "Opened {} files. Skipped {}:\n{}",
  480|       |                    valid_count,
  481|      0|                    errors.len(),
  482|      0|                    errors.join("\n")
  483|       |                )
  484|       |            };
  485|      3|            self.error_message = Some(error_msg);
  486|      4|        }
  487|      8|    }
  488|       |
  489|       |    /// Scan directory for markdown files (non-recursive)
  490|      4|    fn scan_directory(&self, dir: &Path) -> Result<Vec<PathBuf>> {
  491|      4|        let mut files = Vec::new();
  492|       |
  493|      4|        let entries = std::fs::read_dir(dir)?;
                                                          ^0
  494|       |
  495|     12|        for entry in entries {
                          ^8
  496|      8|            let entry = entry?;
                                           ^0
  497|      8|            let path = entry.path();
  498|       |
  499|       |            // Only include files (not subdirectories)
  500|      8|            if path.is_file() && self.is_valid_markdown_file(&path) {
                                               ^7   ^7                     ^7
  501|      6|                files.push(path);
  502|      6|            }
                          ^2
  503|       |        }
  504|       |
  505|       |        // Sort alphabetically for predictable order
  506|      4|        files.sort();
  507|       |
  508|      4|        Ok(files)
  509|      4|    }
  510|       |
  511|       |    /// Load markdown content from a string
  512|    109|    pub fn load_content(&mut self, content: &str, title: Option<String>) {
  513|    109|        self.current_content = content.to_string();
  514|    109|        self.raw_buffer = self.current_content.clone();
  515|    109|        self.error_message = None;
  516|    109|        self.nav_request = None; // Reset any pending navigation
  517|       |                                 // Ensure scroll resets to top on new content
  518|    109|        self.pending_scroll_to_element = Some(0);
  519|    109|        self.renderer.clear_table_layout_cache();
  520|       |
  521|    109|        match self.renderer.parse(content) {
  522|    109|            Ok(elements) => {
  523|    109|                self.parsed_elements = elements;
  524|    109|                if let Some(title) = title {
                                          ^108
  525|    108|                    self.title = format!("{APP_TITLE_PREFIX} - {}", title);
  526|    108|                }
                              ^1
  527|       |            }
  528|      0|            Err(e) => {
  529|      0|                self.error_message = Some(format!("Failed to parse markdown: {}", e));
  530|      0|                self.parsed_elements.clear();
  531|      0|            }
  532|       |        }
  533|    109|    }
  534|       |
  535|       |    /// Load markdown content from a file path
  536|     16|    pub fn load_file(&mut self, path: PathBuf, record_history: bool) -> Result<()> {
  537|       |        // Push current state to history before loading new file
  538|     16|        if record_history && !self.current_content.is_empty() {
                                           ^14
  539|     14|            self.push_history();
  540|     14|        }
                      ^2
  541|       |
  542|     16|        let (content, lossy) = Self::read_file_lossy(&path)?;
                           ^14      ^14                                  ^2
  543|     14|        let filename = path
  544|     14|            .file_name()
  545|     14|            .and_then(|n| n.to_str())
  546|     14|            .unwrap_or("Unknown")
  547|     14|            .to_string();
  548|       |
  549|     14|        let base = path.parent().map(|p| p.to_path_buf());
  550|     14|        self.renderer.set_base_dir(base.as_deref());
  551|     14|        self.current_file = Some(path);
  552|     14|        self.load_content(&content, Some(filename));
  553|     14|        if lossy {
  554|      1|            eprintln!("Loaded file with invalid UTF-8; replaced invalid sequences.");
  555|     13|        }
  556|     14|        Ok(())
  557|     16|    }
  558|       |
  559|       |    /// Normalize all line endings to Unix style (\n)
  560|       |    /// Handles Windows (\r\n), Unix (\n), and old Mac (\r) formats
  561|     21|    fn normalize_line_endings(s: &str) -> String {
  562|       |        // Order matters: replace \r\n first (Windows), then remaining \r (old Mac)
  563|     21|        s.replace("\r\n", "\n").replace('\r', "\n")
  564|     21|    }
  565|       |
  566|     16|    fn read_file_lossy(path: &Path) -> Result<(String, bool)> {
  567|     16|        match std::fs::read_to_string(path) {
  568|     13|            Ok(s) => Ok((Self::normalize_line_endings(&s), false)),
  569|      3|            Err(e) if e.kind() == ErrorKind::InvalidData => {
                              ^1                                     ^1
  570|      1|                let bytes = std::fs::read(path)?;
                                                             ^0
  571|      1|                let s = String::from_utf8_lossy(&bytes).into_owned();
  572|      1|                Ok((Self::normalize_line_endings(&s), true))
  573|       |            }
  574|      2|            Err(e) => Err(e.into()),
  575|       |        }
  576|     16|    }
  577|       |
  578|      3|    fn current_window_state(&self) -> Option<WindowState> {
  579|      3|        let pos = self.last_window_pos?;
                                                    ^0
  580|      3|        let size = self.last_window_size?;
                                                      ^0
  581|      3|        Some(WindowState {
  582|      3|            pos,
  583|      3|            size,
  584|      3|            maximized: self.last_window_maximized,
  585|      3|        })
  586|      3|    }
  587|       |
  588|     20|    fn compute_window_adjustment(
  589|     20|        outer_rect: Option<egui::Rect>,
  590|     20|        monitor_size: Option<egui::Vec2>,
  591|     20|    ) -> Option<(egui::Pos2, egui::Vec2)> {
  592|     20|        let outer = outer_rect?;
                          ^4                ^16
  593|      4|        let monitor = monitor_size?;
                                                ^0
  594|       |
  595|      4|        if monitor.x <= 0.0 || monitor.y <= 0.0 {
  596|      0|            return None;
  597|      4|        }
  598|       |
  599|       |        const MIN_WIDTH: f32 = 600.0;
  600|       |        const MIN_HEIGHT: f32 = 400.0;
  601|       |        const OFFSCREEN_TOLERANCE: f32 = 32.0;
  602|       |
  603|      4|        let mut pos = outer.min;
  604|      4|        let mut size = outer.size();
  605|      4|        let mut adjusted = false;
  606|       |
  607|      4|        if !pos.x.is_finite() || !pos.y.is_finite() {
  608|      0|            pos = egui::pos2(0.0, 0.0);
  609|      0|            adjusted = true;
  610|      4|        }
  611|      4|        if !size.x.is_finite() || !size.y.is_finite() {
  612|      0|            size = egui::vec2(MIN_WIDTH, MIN_HEIGHT);
  613|      0|            adjusted = true;
  614|      4|        }
  615|       |
  616|      4|        let available_width = monitor.x.max(MIN_WIDTH);
  617|      4|        let available_height = monitor.y.max(MIN_HEIGHT);
  618|       |
  619|      4|        if size.x < MIN_WIDTH {
  620|      2|            size.x = MIN_WIDTH.min(available_width);
  621|      2|            adjusted = true;
  622|      2|        }
  623|      4|        if size.y < MIN_HEIGHT {
  624|      2|            size.y = MIN_HEIGHT.min(available_height);
  625|      2|            adjusted = true;
  626|      2|        }
  627|      4|        if size.x > available_width {
  628|      0|            size.x = available_width;
  629|      0|            adjusted = true;
  630|      4|        }
  631|      4|        if size.y > available_height {
  632|      0|            size.y = available_height;
  633|      0|            adjusted = true;
  634|      4|        }
  635|       |
  636|      4|        let max_pos = egui::pos2((monitor.x - size.x).max(0.0), (monitor.y - size.y).max(0.0));
  637|       |
  638|      4|        if pos.x <= -0.25 * size.x {
  639|      1|            pos.x = 0.0;
  640|      1|            adjusted = true;
  641|      3|        }
  642|      4|        if pos.y <= -0.25 * size.y {
  643|      1|            pos.y = 0.0;
  644|      1|            adjusted = true;
  645|      3|        }
  646|      4|        if pos.x > max_pos.x + OFFSCREEN_TOLERANCE {
  647|      1|            pos.x = max_pos.x;
  648|      1|            adjusted = true;
  649|      3|        }
  650|      4|        if pos.y > max_pos.y + OFFSCREEN_TOLERANCE {
  651|      1|            pos.y = max_pos.y;
  652|      1|            adjusted = true;
  653|      3|        }
  654|       |
  655|      4|        if adjusted {
  656|      3|            size.x = size.x.max(MIN_WIDTH.min(available_width));
  657|      3|            size.y = size.y.max(MIN_HEIGHT.min(available_height));
  658|      3|            Some((pos, size))
  659|       |        } else {
  660|      1|            None
  661|       |        }
  662|     20|    }
  663|       |
  664|      5|    fn window_state_changed(&self, new_state: &WindowState) -> bool {
  665|      5|        match &self.last_persisted_state {
  666|      2|            Some(prev) => {
  667|      2|                let pos_changed = (prev.pos[0] - new_state.pos[0]).abs() > 0.5
  668|      1|                    || (prev.pos[1] - new_state.pos[1]).abs() > 0.5;
  669|      2|                let size_changed = (prev.size[0] - new_state.size[0]).abs() > 0.5
  670|      2|                    || (prev.size[1] - new_state.size[1]).abs() > 0.5;
  671|      2|                let maximized_changed = prev.maximized != new_state.maximized;
  672|      2|                pos_changed || size_changed || maximized_changed
                                             ^1              ^1
  673|       |            }
  674|      3|            None => true,
  675|       |        }
  676|      5|    }
  677|       |
  678|     27|    fn fold_for_search(input: &str) -> String {
  679|     27|        input.case_fold().nfkc().collect()
  680|     27|    }
  681|       |
  682|       |    /// Push current state to navigation history
  683|     24|    fn push_history(&mut self) {
  684|       |        // Truncate forward history if we're not at the end
  685|     24|        if self.history_index < self.history.len() {
  686|      1|            self.history.truncate(self.history_index);
  687|     23|        }
  688|       |
  689|       |        // Create entry for current state
  690|     24|        let entry = HistoryEntry {
  691|     24|            file_path: self.current_file.clone(),
  692|     24|            title: self.title.clone(),
  693|     24|            content: self.current_content.clone(),
  694|     24|        };
  695|       |
  696|     24|        self.history.push(entry);
  697|       |
  698|       |        // Limit history size
  699|     24|        if self.history.len() > self.max_history {
  700|      0|            self.history.remove(0);
  701|     24|        } else {
  702|     24|            self.history_index = self.history.len();
  703|     24|        }
  704|     24|    }
  705|       |
  706|       |    /// Navigate back in history
  707|      1|    fn navigate_back(&mut self) -> bool {
  708|      1|        if self.history_index > 0 {
  709|      1|            self.history_index -= 1;
  710|      1|            self.restore_from_history();
  711|      1|            true
  712|       |        } else {
  713|      0|            false
  714|       |        }
  715|      1|    }
  716|       |
  717|       |    /// Navigate forward in history
  718|      2|    fn navigate_forward(&mut self) -> bool {
  719|       |        // First try pending files queue
  720|      2|        if let Some(next_file) = self.pending_files.pop_front() {
  721|       |            // Load next file from queue
  722|      2|            if let Err(e) = self.load_file(next_file, true) {
                                     ^0
  723|      0|                self.error_message = Some(format!("Failed to load file: {}", e));
  724|      2|            }
  725|      2|            return true;
  726|      0|        }
  727|       |
  728|       |        // Otherwise use history navigation (existing code)
  729|      0|        if self.history_index < self.history.len() - 1 {
  730|      0|            self.history_index += 1;
  731|      0|            self.restore_from_history();
  732|      0|            true
  733|       |        } else {
  734|      0|            false
  735|       |        }
  736|      2|    }
  737|       |
  738|       |    /// Restore state from history at current index
  739|      1|    fn restore_from_history(&mut self) {
  740|      1|        if let Some(entry) = self.history.get(self.history_index) {
  741|      1|            self.current_file = entry.file_path.clone();
  742|      1|            self.title = entry.title.clone();
  743|      1|            self.current_content = entry.content.clone();
  744|      1|            self.raw_buffer = self.current_content.clone();
  745|       |
  746|       |            // Re-parse content
  747|      1|            match self.renderer.parse(&self.current_content) {
  748|      1|                Ok(elements) => {
  749|      1|                    self.parsed_elements = elements;
  750|      1|                    self.error_message = None;
  751|      1|                }
  752|      0|                Err(e) => {
  753|      0|                    self.error_message = Some(format!("Failed to parse: {}", e));
  754|      0|                }
  755|       |            }
  756|       |
  757|       |            // Set base dir for images
  758|      1|            if let Some(ref path) = self.current_file {
                                      ^0
  759|      0|                self.renderer.set_base_dir(path.parent());
  760|      1|            } else {
  761|      1|                self.renderer.set_base_dir(None);
  762|      1|            }
  763|       |
  764|       |            // Scroll to top
  765|      1|            self.pending_scroll_to_element = Some(0);
  766|      0|        }
  767|      1|    }
  768|       |
  769|       |    /// Check if we can navigate back
  770|      2|    fn can_navigate_back(&self) -> bool {
  771|      2|        self.history_index > 0
  772|      2|    }
  773|       |
  774|       |    /// Check if we can navigate forward
  775|      3|    fn can_navigate_forward(&self) -> bool {
  776|      3|        !self.pending_files.is_empty() || self.history_index < self.history.len().saturating_sub(1)
                                                        ^1                   ^1
  777|      3|    }
  778|       |
  779|       |    /// Request a reload of the current file (processed outside of input context)
  780|      2|    fn request_reload(&mut self) {
  781|      2|        if self.current_file.is_some() {
  782|      2|            self.reload_requested = true;
  783|      2|        } else {
  784|      0|            self.error_message = Some("No file loaded to reload".to_string());
  785|      0|        }
  786|      2|    }
  787|       |
  788|       |    /// Reload the currently opened file from disk
  789|      3|    pub fn reload_current_file(&mut self) -> Result<()> {
  790|      3|        let path = if let Some(p) = self.current_file.clone() {
                          ^2                 ^2
  791|      2|            p
  792|       |        } else {
  793|      1|            bail!("No file loaded to reload");
  794|       |        };
  795|      2|        self.load_file(path, false)
  796|      3|    }
  797|       |
  798|       |    /// Load a sample file by name
  799|     10|    pub fn load_sample(&mut self, sample: &SampleFile) {
  800|       |        // Push current state to history before loading sample
  801|     10|        if !self.current_content.is_empty() {
  802|     10|            self.push_history();
  803|     10|        }
                      ^0
  804|       |
  805|     10|        self.current_file = None;
  806|       |        // Samples have no file base-dir
  807|     10|        self.renderer.set_base_dir(None);
  808|     10|        self.load_content(sample.content, Some(sample.title.to_string()));
  809|       |        // Scroll to top for new sample
  810|     10|        self.pending_scroll_to_element = Some(0);
  811|     10|    }
  812|       |
  813|       |    /// Close the current file and return to welcome screen
  814|      4|    pub fn close_current_file(&mut self) {
  815|      4|        self.current_file = None;
  816|      4|        self.renderer.set_base_dir(None);
  817|      4|        if let Some(welcome) = SAMPLE_FILES.iter().find(|f| f.name == "welcome.md") {
  818|      4|            self.load_content(welcome.content, Some("Welcome".to_string()));
  819|      4|            self.pending_scroll_to_element = Some(0);
  820|      4|        } else {
  821|      0|            // Fallback if welcome file is missing
  822|      0|            self.current_content.clear();
  823|      0|            self.parsed_elements.clear();
  824|      0|            self.title = APP_TITLE_PREFIX.to_string();
  825|      0|            self.error_message = None;
  826|      0|        }
  827|      4|    }
  828|       |
  829|       |    /// Open file dialog to select a markdown file
  830|       |    #[cfg(not(test))]
  831|       |    fn open_file_dialog(&mut self) {
  832|       |        if let Some(path) = FileDialog::new()
  833|       |            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
  834|       |            .add_filter("All files", &["*"])
  835|       |            .set_title("Open Markdown File")
  836|       |            .pick_file()
  837|       |        {
  838|       |            if let Err(e) = self.load_file(path, true) {
  839|       |                self.error_message = Some(format!("Failed to open file: {}", e));
  840|       |            }
  841|       |        }
  842|       |    }
  843|       |
  844|       |    #[cfg(test)]
  845|      5|    fn open_file_dialog(&mut self) {
  846|      5|        self.error_message = Some("File dialog disabled in tests".to_string());
  847|      5|    }
  848|       |
  849|       |    /// Toggle between Rendered and Raw view
  850|      4|    fn toggle_view_mode(&mut self, ctx: &Context) {
  851|       |        // If leaving Raw view while editing, capture cursor before switching
  852|      4|        if matches!(self.view_mode, ViewMode::Raw) && self.write_enabled {
                         ^3                                         ^1
  853|      0|            let editor_id = egui::Id::new("raw_editor");
  854|      0|            if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
  855|      0|                if let Some(range) = state.cursor.char_range() {
  856|      0|                    self.raw_cursor = Some(range.primary.index);
  857|      0|                }
  858|      0|            }
  859|      4|        }
  860|      4|        self.view_mode = match self.view_mode {
  861|       |            ViewMode::Rendered => {
  862|      3|                self.raw_focus_requested = true;
  863|      3|                ViewMode::Raw
  864|       |            }
  865|      1|            ViewMode::Raw => ViewMode::Rendered,
  866|       |        };
  867|      4|    }
  868|       |
  869|       |    /// Handle keyboard shortcuts
  870|     22|    fn handle_shortcuts(&mut self, ctx: &Context) {
  871|     22|        ctx.input_mut(|i| {
  872|     22|            let in_raw_edit = matches!(self.view_mode, ViewMode::Raw) && self.write_enabled;
                                            ^15                                        ^7
  873|       |            // Ctrl+O - Open file
  874|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  875|     22|                egui::Modifiers::CTRL,
  876|     22|                egui::Key::O,
  877|     22|            )) {
  878|      1|                self.open_file_dialog();
  879|     21|            }
  880|       |
  881|       |            // Alt-based accelerators for common actions (mnemonics)
  882|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  883|     22|                egui::Modifiers::ALT,
  884|     22|                egui::Key::O,
  885|     22|            )) {
  886|      1|                self.open_file_dialog();
  887|     21|            }
  888|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  889|     22|                egui::Modifiers::ALT,
  890|     22|                egui::Key::W,
  891|     22|            )) {
  892|      1|                self.close_current_file();
  893|     21|            }
  894|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  895|     22|                egui::Modifiers::ALT,
  896|     22|                egui::Key::Q,
  897|     22|            )) {
  898|      0|                ctx.send_viewport_cmd(egui::ViewportCommand::Close);
  899|     22|            }
  900|       |
  901|       |            // Ctrl+Q - Quit application
  902|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  903|     22|                egui::Modifiers::CTRL,
  904|     22|                egui::Key::Q,
  905|     22|            )) {
  906|      0|                ctx.send_viewport_cmd(egui::ViewportCommand::Close);
  907|     22|            }
  908|       |
  909|       |            // Ctrl+W - Close current file
  910|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  911|     22|                egui::Modifiers::CTRL,
  912|     22|                egui::Key::W,
  913|     22|            )) {
  914|      1|                self.close_current_file();
  915|     21|            }
  916|       |
  917|       |            // Ctrl+F - Open search dialog
  918|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  919|     22|                egui::Modifiers::CTRL,
  920|     22|                egui::Key::F,
  921|     22|            )) {
  922|      1|                self.show_search = true;
  923|      1|                if self.last_match_index.is_none() {
  924|      1|                    self.last_match_index = Some(0);
  925|      1|                }
                              ^0
  926|      1|                self.search_focus_requested = true;
  927|     21|            }
  928|       |
  929|       |            // F3 navigation: next / previous
  930|     22|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F3) {
  931|      0|                self.find_next();
  932|     22|            }
  933|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  934|     22|                egui::Modifiers::SHIFT,
  935|     22|                egui::Key::F3,
  936|     22|            )) || i.consume_shortcut(&egui::KeyboardShortcut::new(
  937|     22|                egui::Modifiers::ALT,
  938|     22|                egui::Key::F3,
  939|     22|            )) {
  940|      0|                self.find_previous();
  941|     22|            }
  942|       |
  943|       |            // Ctrl+Plus - Zoom in
  944|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  945|     22|                egui::Modifiers::CTRL,
  946|     22|                egui::Key::Plus,
  947|     22|            )) {
  948|      0|                self.renderer.zoom_in();
  949|     22|            }
  950|       |
  951|       |            // Ctrl+Minus - Zoom out
  952|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  953|     22|                egui::Modifiers::CTRL,
  954|     22|                egui::Key::Minus,
  955|     22|            )) {
  956|      0|                self.renderer.zoom_out();
  957|     22|            }
  958|       |
  959|       |            // Ctrl+0 - Reset zoom
  960|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  961|     22|                egui::Modifiers::CTRL,
  962|     22|                egui::Key::Num0,
  963|     22|            )) {
  964|      0|                self.renderer.reset_zoom();
  965|     22|            }
  966|       |
  967|       |            // Alt+Left - Navigate back
  968|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  969|     22|                egui::Modifiers::ALT,
  970|     22|                egui::Key::ArrowLeft,
  971|     22|            )) {
  972|      0|                self.navigate_back();
  973|     22|            }
  974|       |
  975|       |            // Alt+Right - Navigate forward
  976|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  977|     22|                egui::Modifiers::ALT,
  978|     22|                egui::Key::ArrowRight,
  979|     22|            )) {
  980|      0|                self.navigate_forward();
  981|     22|            }
  982|       |
  983|       |            // Ctrl + Mouse Wheel - Zoom
  984|     22|            if i.modifiers.ctrl {
  985|      1|                let mut total = 0.0f32;
  986|      2|                for ev in &i.events {
                                  ^1
  987|      1|                    if let egui::Event::MouseWheel { delta, .. } = ev {
  988|      1|                        total += delta.y;
  989|      1|                    }
                                  ^0
  990|       |                }
  991|      1|                if total.abs() > 0.0 {
  992|      1|                    if total > 0.0 {
  993|      1|                        self.renderer.zoom_in();
  994|      1|                    } else if total < 0.0 {
                                            ^0
  995|      0|                        self.renderer.zoom_out();
  996|      0|                    }
  997|      0|                }
  998|     21|            }
  999|       |
 1000|       |            // Ctrl+R - Toggle raw view
 1001|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1002|     22|                egui::Modifiers::CTRL,
 1003|     22|                egui::Key::R,
 1004|     22|            )) {
 1005|      1|                // Defer to avoid acting inside input context
 1006|      1|                self.view_toggle_requested = true;
 1007|     21|            }
 1008|       |            // Ctrl+E - Toggle write mode (deferred)
 1009|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1010|     22|                egui::Modifiers::CTRL,
 1011|     22|                egui::Key::E,
 1012|     22|            )) {
 1013|      1|                self.write_toggle_requested = true;
 1014|     21|            }
 1015|       |            // Ctrl+S - Save document
 1016|     22|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1017|     22|                egui::Modifiers::CTRL,
 1018|     22|                egui::Key::S,
 1019|     22|            )) {
 1020|      1|                if let Err(e) = self.save_current_document() {
                                         ^0
 1021|      0|                    self.error_message = Some(format!("Failed to save: {}", e));
 1022|      1|                }
 1023|     21|            }
 1024|       |            // Note: No global Alt+R to avoid conflict (File > Reload vs View > Raw)
 1025|       |
 1026|       |            // F11 - Toggle fullscreen (set flag to handle outside input context)
 1027|     22|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F11) {
 1028|      1|                self.toggle_fullscreen = true;
 1029|     21|            }
 1030|       |
 1031|       |            // F5 - Reload current file (set flag; actual IO handled outside input context)
 1032|     22|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F5) {
 1033|      1|                self.request_reload();
 1034|     21|            }
 1035|       |
 1036|       |            // Esc - dismiss search dialog if visible
 1037|     22|            if self.show_search && i.consume_key(egui::Modifiers::NONE, egui::Key::Escape) {
                                                 ^3^3                                 ^3
 1038|      0|                self.clear_search_state();
 1039|      0|                self.show_search = false;
 1040|     22|            }
 1041|       |
 1042|       |            // Only consume navigation keys when not editing in raw view
 1043|     22|            if !in_raw_edit {
 1044|     16|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
 1045|      1|                    self.nav_request = Some(NavigationRequest::PageUp);
 1046|     15|                }
 1047|     16|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
 1048|      0|                    self.nav_request = Some(NavigationRequest::PageDown);
 1049|     16|                }
 1050|       |                // Home - Go to top of document
 1051|     16|                if i.consume_key(egui::Modifiers::NONE, egui::Key::Home) {
 1052|      0|                    self.nav_request = Some(NavigationRequest::Top);
 1053|     16|                }
 1054|       |
 1055|       |                // End - Go to bottom of document
 1056|     16|                if i.consume_key(egui::Modifiers::NONE, egui::Key::End) {
 1057|      0|                    self.nav_request = Some(NavigationRequest::Bottom);
 1058|     16|                }
 1059|       |
 1060|       |                // Arrow Up - Fine scroll up
 1061|     16|                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowUp) {
 1062|      0|                    self.nav_request = Some(NavigationRequest::ScrollUp);
 1063|     16|                }
 1064|       |
 1065|       |                // Arrow Down - Fine scroll down
 1066|     16|                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowDown) {
 1067|      1|                    self.nav_request = Some(NavigationRequest::ScrollDown);
 1068|     15|                }
 1069|       |            } else {
 1070|       |                // In raw edit mode: implement PageUp/PageDown by moving caret by ~a page of lines
 1071|       |                const PAGE_LINES: i32 = 24; // match desired_rows for the editor
 1072|      6|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
 1073|      0|                    self.pending_raw_cursor_line_move = Some(-PAGE_LINES);
 1074|      0|                    self.raw_focus_requested = true;
 1075|      6|                }
 1076|      6|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
 1077|      1|                    self.pending_raw_cursor_line_move = Some(PAGE_LINES);
 1078|      1|                    self.raw_focus_requested = true;
 1079|      5|                }
 1080|       |            }
 1081|     22|        });
 1082|     22|    }
 1083|       |
 1084|       |    /// Render the menu bar
 1085|     18|    fn render_menu_bar(&mut self, ctx: &Context) {
 1086|     18|        TopBottomPanel::top("menu_bar").show(ctx, |ui| {
 1087|     18|            let alt_pressed = ui.input(|i| i.modifiers.alt);
 1088|     18|            let menu_text_color = if ui.visuals().dark_mode {
 1089|     18|                Color32::WHITE
 1090|       |            } else {
 1091|      0|                Color32::BLACK
 1092|       |            };
 1093|     18|            menu::bar(ui, |ui| {
 1094|     18|                ui.menu_button(
 1095|     18|                    Self::menu_text_with_mnemonic(None, "File", 'F', alt_pressed, menu_text_color),
 1096|      0|                    |ui| {
 1097|      0|                        self.render_file_menu(ui, alt_pressed, menu_text_color);
 1098|      0|                    },
 1099|       |                );
 1100|       |
 1101|     18|                ui.menu_button(
 1102|     18|                    Self::menu_text_with_mnemonic(None, "View", 'V', alt_pressed, menu_text_color),
 1103|      0|                    |ui| {
 1104|      0|                        self.render_view_menu(ui, ctx, alt_pressed, menu_text_color);
 1105|      0|                    },
 1106|       |                );
 1107|       |
 1108|     18|                ui.menu_button("Help", |ui| {
                                                          ^0
 1109|      0|                    self.render_help_menu(ui);
 1110|      0|                });
 1111|     18|            });
 1112|     18|        });
 1113|       |
 1114|       |        // No programmatic overlay menus; rely on pointer to open egui menus.
 1115|     18|    }
 1116|       |
 1117|      4|    fn render_file_menu(
 1118|      4|        &mut self,
 1119|      4|        ui: &mut egui::Ui,
 1120|      4|        alt_pressed: bool,
 1121|      4|        menu_text_color: Color32,
 1122|      4|    ) {
 1123|      4|        ui.horizontal(|ui| {
 1124|      4|            let button = ui.add(egui::Button::new(Self::menu_text_with_mnemonic(
 1125|      4|                None,
 1126|      4|                "Open...",
 1127|       |                'O',
 1128|      4|                alt_pressed,
 1129|      4|                menu_text_color,
 1130|       |            )));
 1131|      4|            if action_triggered(button.clicked(), "file_open") {
 1132|      1|                self.open_file_dialog();
 1133|      1|                ui.close_menu();
 1134|      3|            }
 1135|      4|            ui.with_layout(
 1136|      4|                egui::Layout::right_to_left(egui::Align::Center),
 1137|      4|                |ui| {
 1138|      4|                    ui.label(RichText::new("Ctrl+O").color(menu_text_color));
 1139|      4|                },
 1140|       |            );
 1141|      4|        });
 1142|       |
 1143|      4|        ui.horizontal(|ui| {
 1144|      4|            let enabled = !self.current_content.is_empty();
 1145|      4|            let button = ui.add_enabled(
 1146|      4|                enabled,
 1147|      4|                egui::Button::new(Self::menu_text_with_mnemonic(
 1148|      4|                    None,
 1149|      4|                    "Save",
 1150|       |                    'S',
 1151|      4|                    alt_pressed,
 1152|      4|                    menu_text_color,
 1153|       |                )),
 1154|       |            );
 1155|      4|            if action_triggered(button.clicked(), "file_save") {
 1156|      1|                if let Err(e) = self.save_current_document() {
                                         ^0
 1157|      0|                    self.error_message = Some(format!("Failed to save: {}", e));
 1158|      1|                }
 1159|      1|                ui.close_menu();
 1160|      3|            }
 1161|      4|            ui.with_layout(
 1162|      4|                egui::Layout::right_to_left(egui::Align::Center),
 1163|      4|                |ui| {
 1164|      4|                    ui.label(RichText::new("Ctrl+S").color(menu_text_color));
 1165|      4|                },
 1166|       |            );
 1167|      4|        });
 1168|       |
 1169|      4|        ui.horizontal(|ui| {
 1170|      4|            let button = ui.add(egui::Button::new(Self::menu_text_with_mnemonic(
 1171|      4|                None,
 1172|      4|                "Close",
 1173|       |                'C',
 1174|      4|                alt_pressed,
 1175|      4|                menu_text_color,
 1176|       |            )));
 1177|      4|            if action_triggered(button.clicked(), "file_close") {
 1178|      1|                self.close_current_file();
 1179|      1|                ui.close_menu();
 1180|      3|            }
 1181|      4|            ui.with_layout(
 1182|      4|                egui::Layout::right_to_left(egui::Align::Center),
 1183|      4|                |ui| {
 1184|      4|                    ui.label(RichText::new("Ctrl+W").color(menu_text_color));
 1185|      4|                },
 1186|       |            );
 1187|      4|        });
 1188|       |
 1189|      4|        ui.horizontal(|ui| {
 1190|      4|            let enabled = self.current_file.is_some();
 1191|      4|            let button = ui.add_enabled(
 1192|      4|                enabled,
 1193|      4|                egui::Button::new(Self::menu_text_with_mnemonic(
 1194|      4|                    None,
 1195|      4|                    "Reload",
 1196|       |                    'R',
 1197|      4|                    alt_pressed,
 1198|      4|                    menu_text_color,
 1199|       |                )),
 1200|       |            );
 1201|      4|            if action_triggered(button.clicked(), "file_reload") {
 1202|      1|                self.request_reload();
 1203|      1|                ui.close_menu();
 1204|      3|            }
 1205|      4|            ui.with_layout(
 1206|      4|                egui::Layout::right_to_left(egui::Align::Center),
 1207|      4|                |ui| {
 1208|      4|                    ui.label(RichText::new("F5").color(menu_text_color));
 1209|      4|                },
 1210|       |            );
 1211|      4|        });
 1212|       |
 1213|      4|        ui.horizontal(|ui| {
 1214|      4|            let button = ui.add(egui::Button::new(Self::menu_text_with_mnemonic(
 1215|      4|                None,
 1216|      4|                "Find...",
 1217|       |                'F',
 1218|      4|                alt_pressed,
 1219|      4|                menu_text_color,
 1220|       |            )));
 1221|      4|            if action_triggered(button.clicked(), "file_find") {
 1222|      1|                self.show_search = true;
 1223|      1|                self.search_focus_requested = true;
 1224|      1|                ui.close_menu();
 1225|      3|            }
 1226|      4|            ui.with_layout(
 1227|      4|                egui::Layout::right_to_left(egui::Align::Center),
 1228|      4|                |ui| {
 1229|      4|                    ui.label(RichText::new("Ctrl+F").color(menu_text_color));
 1230|      4|                },
 1231|       |            );
 1232|      4|        });
 1233|       |
 1234|      4|        ui.separator();
 1235|       |
 1236|      4|        if action_triggered(false, "file_samples_menu") {
 1237|      1|            self.render_samples_menu(ui);
 1238|      1|        } else {
 1239|      3|            ui.menu_button(
 1240|      3|                Self::menu_text_with_mnemonic(None, "Samples", 'S', alt_pressed, menu_text_color),
 1241|      0|                |ui| {
 1242|      0|                    self.render_samples_menu(ui);
 1243|      0|                },
 1244|       |            );
 1245|       |        }
 1246|      4|    }
 1247|       |
 1248|      1|    fn render_samples_menu(&mut self, ui: &mut egui::Ui) {
 1249|      1|        let mut forced = consume_forced_action("file_sample");
 1250|      7|        for sample in SAMPLE_FILES {
                          ^6
 1251|      6|            let clicked = ui.button(sample.title).clicked();
 1252|      6|            let triggered = if forced {
 1253|      1|                forced = false;
 1254|      1|                true
 1255|       |            } else {
 1256|      5|                clicked
 1257|       |            };
 1258|      6|            if triggered {
 1259|      1|                self.load_sample(sample);
 1260|      1|                ui.close_menu();
 1261|      5|            }
 1262|       |        }
 1263|      1|    }
 1264|       |
 1265|      2|    fn render_view_menu(
 1266|      2|        &mut self,
 1267|      2|        ui: &mut egui::Ui,
 1268|      2|        ctx: &Context,
 1269|      2|        alt_pressed: bool,
 1270|      2|        menu_text_color: Color32,
 1271|      2|    ) {
 1272|      2|        ui.horizontal(|ui| {
 1273|      2|            let enabled = self.can_navigate_back();
 1274|      2|            let button = ui.add_enabled(enabled, egui::Button::new("<- Back"));
 1275|      2|            if action_triggered(button.clicked(), "view_back") {
 1276|      1|                self.navigate_back();
 1277|      1|                ui.close_menu();
 1278|      1|            }
 1279|      2|            ui.with_layout(
 1280|      2|                egui::Layout::right_to_left(egui::Align::Center),
 1281|      2|                |ui| {
 1282|      2|                    ui.label(RichText::new("Alt+Left").color(menu_text_color));
 1283|      2|                },
 1284|       |            );
 1285|      2|        });
 1286|       |
 1287|      2|        ui.horizontal(|ui| {
 1288|      2|            let enabled = self.can_navigate_forward();
 1289|      2|            let button = ui.add_enabled(enabled, egui::Button::new("Forward ->"));
 1290|      2|            if action_triggered(button.clicked(), "view_forward") {
 1291|      1|                self.navigate_forward();
 1292|      1|                ui.close_menu();
 1293|      1|            }
 1294|      2|            ui.with_layout(
 1295|      2|                egui::Layout::right_to_left(egui::Align::Center),
 1296|      2|                |ui| {
 1297|      2|                    ui.label(RichText::new("Alt+Right").color(menu_text_color));
 1298|      2|                },
 1299|       |            );
 1300|      2|        });
 1301|       |
 1302|      2|        ui.separator();
 1303|       |
 1304|      2|        ui.horizontal(|ui| {
 1305|      2|            let selected = matches!(self.view_mode, ViewMode::Raw);
 1306|      2|            let button = ui.add(egui::SelectableLabel::new(
 1307|      2|                selected,
 1308|      2|                Self::menu_text_with_mnemonic(
 1309|      2|                    None,
 1310|      2|                    "Raw Markdown",
 1311|       |                    'R',
 1312|      2|                    alt_pressed,
 1313|      2|                    menu_text_color,
 1314|       |                ),
 1315|       |            ));
 1316|      2|            if action_triggered(button.clicked(), "view_raw") {
 1317|      1|                self.toggle_view_mode(ctx);
 1318|      1|                ui.close_menu();
 1319|      1|            }
 1320|      2|            ui.with_layout(
 1321|      2|                egui::Layout::right_to_left(egui::Align::Center),
 1322|      2|                |ui| {
 1323|      2|                    ui.label(RichText::new("Ctrl+R").color(menu_text_color));
 1324|      2|                },
 1325|       |            );
 1326|      2|        });
 1327|       |
 1328|      2|        ui.horizontal(|ui| {
 1329|      2|            let selected = self.write_enabled;
 1330|      2|            let button = ui.add(egui::SelectableLabel::new(
 1331|      2|                selected,
 1332|      2|                Self::menu_text_with_mnemonic(
 1333|      2|                    None,
 1334|      2|                    "Write Mode",
 1335|       |                    'W',
 1336|      2|                    alt_pressed,
 1337|      2|                    menu_text_color,
 1338|       |                ),
 1339|       |            ));
 1340|      2|            if action_triggered(button.clicked(), "view_write") {
 1341|      1|                self.toggle_write_mode(ctx);
 1342|      1|                ui.close_menu();
 1343|      1|            }
 1344|      2|            ui.with_layout(
 1345|      2|                egui::Layout::right_to_left(egui::Align::Center),
 1346|      2|                |ui| {
 1347|      2|                    ui.label(RichText::new("Ctrl+E").color(menu_text_color));
 1348|      2|                },
 1349|       |            );
 1350|      2|        });
 1351|       |
 1352|      2|        ui.horizontal(|ui| {
 1353|      2|            let button = ui.selectable_label(self.wrap_raw, "Wrap Raw Lines");
 1354|      2|            if action_triggered(button.clicked(), "view_wrap_raw") {
 1355|      1|                self.wrap_raw = !self.wrap_raw;
 1356|      1|            }
 1357|      2|        });
 1358|       |
 1359|      2|        ui.horizontal(|ui| {
 1360|      2|            let label = if self.table_wrap_overhaul_enabled {
 1361|      2|                "Table Wrap Overhaul (new)"
 1362|       |            } else {
 1363|      0|                "Table Wrap Overhaul (legacy)"
 1364|       |            };
 1365|      2|            let button = ui.selectable_label(self.table_wrap_overhaul_enabled, label);
 1366|      2|            if action_triggered(button.clicked(), "view_table_wrap") {
 1367|      1|                self.toggle_table_wrap_overhaul();
 1368|      1|                ui.close_menu();
 1369|      1|            }
 1370|      2|        });
 1371|       |
 1372|      2|        ui.horizontal(|ui| {
 1373|      2|            let button = ui.button("Zoom In");
 1374|      2|            if action_triggered(button.clicked(), "view_zoom_in") {
 1375|      1|                self.renderer.zoom_in();
 1376|      1|                ui.close_menu();
 1377|      1|            }
 1378|      2|            ui.with_layout(
 1379|      2|                egui::Layout::right_to_left(egui::Align::Center),
 1380|      2|                |ui| {
 1381|      2|                    ui.label(RichText::new("Ctrl++").color(menu_text_color));
 1382|      2|                },
 1383|       |            );
 1384|      2|        });
 1385|       |
 1386|      2|        ui.horizontal(|ui| {
 1387|      2|            let button = ui.button("Zoom Out");
 1388|      2|            if action_triggered(button.clicked(), "view_zoom_out") {
 1389|      1|                self.renderer.zoom_out();
 1390|      1|                ui.close_menu();
 1391|      1|            }
 1392|      2|            ui.with_layout(
 1393|      2|                egui::Layout::right_to_left(egui::Align::Center),
 1394|      2|                |ui| {
 1395|      2|                    ui.label(RichText::new("Ctrl+-").color(menu_text_color));
 1396|      2|                },
 1397|       |            );
 1398|      2|        });
 1399|       |
 1400|      2|        ui.horizontal(|ui| {
 1401|      2|            let button = ui.button("Reset Zoom");
 1402|      2|            if action_triggered(button.clicked(), "view_zoom_reset") {
 1403|      1|                self.renderer.reset_zoom();
 1404|      1|                ui.close_menu();
 1405|      1|            }
 1406|      2|            ui.with_layout(
 1407|      2|                egui::Layout::right_to_left(egui::Align::Center),
 1408|      2|                |ui| {
 1409|      2|                    ui.label(RichText::new("Ctrl+0").color(menu_text_color));
 1410|      2|                },
 1411|       |            );
 1412|      2|        });
 1413|       |
 1414|      2|        ui.separator();
 1415|       |
 1416|      2|        ui.horizontal(|ui| {
 1417|      2|            let button = ui.button("Toggle Fullscreen");
 1418|      2|            if action_triggered(button.clicked(), "view_fullscreen") {
 1419|      1|                let is_fullscreen = ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
 1420|      1|                ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(!is_fullscreen));
 1421|      1|                ui.close_menu();
 1422|      1|            }
 1423|      2|            ui.with_layout(
 1424|      2|                egui::Layout::right_to_left(egui::Align::Center),
 1425|      2|                |ui| {
 1426|      2|                    ui.label(RichText::new("F11").color(menu_text_color));
 1427|      2|                },
 1428|       |            );
 1429|      2|        });
 1430|      2|    }
 1431|       |
 1432|      2|    fn render_help_menu(&mut self, ui: &mut egui::Ui) {
 1433|      2|        let usage_button = ui.button("Usage Instructions");
 1434|      2|        if action_triggered(usage_button.clicked(), "help_usage") {
 1435|      4|            if let Some(usage) = SAMPLE_FILES.iter().find(|f| f.name == "usage.md") {
                                      ^1       ^1                  ^1
 1436|      1|                self.load_sample(usage);
 1437|      1|            }
                          ^0
 1438|      1|            ui.close_menu();
 1439|      1|        }
 1440|       |
 1441|      2|        let about_button = ui.button("About");
 1442|      2|        if action_triggered(about_button.clicked(), "help_about") {
 1443|      1|            if let Some(welcome) = SAMPLE_FILES.iter().find(|f| f.name == "welcome.md") {
 1444|      1|                self.load_sample(welcome);
 1445|      1|            }
                          ^0
 1446|      1|            ui.close_menu();
 1447|      1|        }
 1448|      2|    }
 1449|       |
 1450|      2|    fn render_main_context_menu(&mut self, ui: &mut egui::Ui) {
 1451|      2|        ui.label("Select text, then use Ctrl+C to copy");
 1452|      2|        ui.separator();
 1453|       |
 1454|      2|        let copy_all_button = ui.button("Copy All Text");
 1455|      2|        if action_triggered(copy_all_button.clicked(), "context_copy_all") {
 1456|      1|            let all_text = MarkdownRenderer::elements_to_plain_text(&self.parsed_elements);
 1457|      1|            ui.ctx().copy_text(all_text);
 1458|      1|            ui.close_menu();
 1459|      1|        }
 1460|       |
 1461|      2|        let copy_md_button = ui.button("Copy as Markdown");
 1462|      2|        if action_triggered(copy_md_button.clicked(), "context_copy_markdown") {
 1463|      1|            ui.ctx().copy_text(self.current_content.clone());
 1464|      1|            ui.close_menu();
 1465|      1|        }
 1466|       |
 1467|      2|        ui.separator();
 1468|       |
 1469|      2|        let top_button = ui.button("Go to Top");
 1470|      2|        if action_triggered(top_button.clicked(), "context_top") {
 1471|      1|            self.nav_request = Some(NavigationRequest::Top);
 1472|      1|            ui.close_menu();
 1473|      1|        }
 1474|       |
 1475|      2|        let bottom_button = ui.button("Go to Bottom");
 1476|      2|        if action_triggered(bottom_button.clicked(), "context_bottom") {
 1477|      1|            self.nav_request = Some(NavigationRequest::Bottom);
 1478|      1|            ui.close_menu();
 1479|      1|        }
 1480|      2|    }
 1481|       |    /// Render the status bar
 1482|     19|    fn render_status_bar(&self, ctx: &Context) {
 1483|     19|        TopBottomPanel::bottom("status_bar").show(ctx, |ui| {
 1484|     19|            ui.horizontal(|ui| {
 1485|       |                // Current file info
 1486|     19|                if let Some(path) = &self.current_file {
                                          ^1
 1487|      1|                    ui.label(format!("File: {}", path.display()));
 1488|     18|                } else if !self.parsed_elements.is_empty() {
 1489|     17|                    ui.label("Sample file");
 1490|     17|                } else {
 1491|      1|                    ui.label("No file loaded");
 1492|      1|                }
 1493|       |
 1494|       |                // Show pending file count if files are queued
 1495|     19|                if !self.pending_files.is_empty() {
 1496|      1|                    ui.separator();
 1497|      1|                    ui.label(
 1498|      1|                        RichText::new(format!("{} files in queue", self.pending_files.len()))
 1499|      1|                            .color(egui::Color32::from_rgb(100, 150, 255)),
 1500|      1|                    );
 1501|      1|
 1502|      1|                    ui.label(
 1503|      1|                        RichText::new("(Alt+Right for next)")
 1504|      1|                            .color(egui::Color32::GRAY)
 1505|      1|                            .italics(),
 1506|      1|                    );
 1507|     18|                }
 1508|       |
 1509|     19|                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1510|       |                    // Document stats
 1511|     19|                    let element_count = self.parsed_elements.len();
 1512|     19|                    let char_count = self.current_content.len();
 1513|     19|                    let mode = match self.view_mode {
 1514|     12|                        ViewMode::Rendered => "Rendered",
 1515|      7|                        ViewMode::Raw => "Raw",
 1516|       |                    };
 1517|     19|                    let status = format!(
 1518|     19|                        "Mode: {} | Elements: {} | Characters: {}",
 1519|       |                        mode, element_count, char_count
 1520|       |                    );
 1521|     19|                    ui.label(status).on_hover_ui(|ui| {
                                                                    ^0
 1522|      0|                        ui.label(format!("Version: {}", BUILD_VERSION));
 1523|      0|                        ui.label(format!("Built: {}", BUILD_TIMESTAMP));
 1524|      0|                    });
 1525|       |
 1526|     19|                    let wrap_label = if self.table_wrap_overhaul_enabled {
 1527|     19|                        RichText::new("Wrap: Overhaul").color(Color32::from_rgb(120, 200, 255))
 1528|       |                    } else {
 1529|      0|                        RichText::new("Wrap: Legacy").color(Color32::from_rgb(140, 140, 140))
 1530|       |                    };
 1531|     19|                    let cache_tip = if self.table_wrap_overhaul_enabled {
 1532|     19|                        let (hits, misses) = self.renderer.table_layout_cache_stats();
 1533|     19|                        let (rendered_rows, total_rows) = self.renderer.table_render_stats();
 1534|     19|                        let row_info = if total_rows > 0 {
 1535|      0|                            format!("
 1536|      0|Rows rendered this frame: {} / {}", rendered_rows, total_rows)
 1537|       |                        } else {
 1538|     19|                            String::new()
 1539|       |                        };
 1540|     19|                        format!(
 1541|     19|                            "Table layout cache: {} hits / {} misses{}",
 1542|       |                            hits, misses, row_info
 1543|       |                        )
 1544|       |                    } else {
 1545|      0|                        "Legacy table renderer active. Toggle via View > Table Wrap Overhaul or CLI flag.".to_string()
 1546|       |                    };
 1547|     19|                    ui.label(wrap_label).on_hover_text(cache_tip);
 1548|     19|                });
 1549|     19|            });
 1550|     19|        });
 1551|     19|    }
 1552|       |    /// Handle drag-drop events from egui
 1553|     19|    fn handle_drag_drop_events(&mut self, ctx: &Context) {
 1554|     19|        ctx.input(|i| {
 1555|       |            // Check if files are being hovered
 1556|     19|            self.drag_hover = !i.raw.hovered_files.is_empty();
 1557|       |
 1558|       |            // Check if files were dropped
 1559|     19|            if !i.raw.dropped_files.is_empty() {
 1560|      1|                let paths: Vec<PathBuf> = i
 1561|      1|                    .raw
 1562|      1|                    .dropped_files
 1563|      1|                    .iter()
 1564|      1|                    .filter_map(|f| f.path.clone())
 1565|      1|                    .collect();
 1566|       |
 1567|      1|                self.handle_file_drop(paths);
 1568|     18|            }
 1569|     19|        });
 1570|     19|    }
 1571|       |
 1572|       |    /// Render drag-and-drop overlay when files are hovered
 1573|     19|    fn render_drag_overlay(&self, ctx: &Context) {
 1574|     19|        if !self.drag_hover {
 1575|     18|            return;
 1576|      1|        }
 1577|       |
 1578|       |        // Full-screen overlay
 1579|      1|        egui::Area::new(egui::Id::new("drag_overlay"))
 1580|      1|            .fixed_pos(egui::pos2(0.0, 0.0))
 1581|      1|            .order(egui::Order::Foreground)
 1582|      1|            .show(ctx, |ui| {
 1583|      1|                let screen_rect = ctx.screen_rect();
 1584|       |
 1585|       |                // Semi-transparent dark background
 1586|      1|                ui.painter()
 1587|      1|                    .rect_filled(screen_rect, 0.0, egui::Color32::from_black_alpha(180));
 1588|       |
 1589|       |                // Dashed border effect using rounded rect with stroke
 1590|      1|                let border_rect = screen_rect.shrink(20.0);
 1591|      1|                let border_color = egui::Color32::from_rgb(100, 150, 255);
 1592|       |
 1593|       |                // Draw border
 1594|      1|                ui.painter()
 1595|      1|                    .rect_stroke(border_rect, 8.0, egui::Stroke::new(4.0, border_color));
 1596|       |
 1597|       |                // Center text
 1598|      1|                ui.allocate_ui_at_rect(screen_rect, |ui| {
 1599|      1|                    ui.vertical_centered(|ui| {
 1600|      1|                        ui.add_space(screen_rect.height() / 2.0 - 80.0);
 1601|       |
 1602|       |                        // Main message
 1603|      1|                        ui.label(
 1604|      1|                            RichText::new("Drop files to open")
 1605|      1|                                .size(36.0)
 1606|      1|                                .color(egui::Color32::WHITE)
 1607|      1|                                .strong(),
 1608|       |                        );
 1609|       |
 1610|      1|                        ui.add_space(20.0);
 1611|       |
 1612|       |                        // Supported formats
 1613|      1|                        ui.label(
 1614|      1|                            RichText::new("Supported: .md, .markdown, .mdown, .mkd, .txt")
 1615|      1|                                .size(18.0)
 1616|      1|                                .color(egui::Color32::LIGHT_GRAY),
 1617|       |                        );
 1618|       |
 1619|      1|                        ui.add_space(10.0);
 1620|       |
 1621|       |                        // Additional hint
 1622|      1|                        ui.label(
 1623|      1|                            RichText::new("Drop multiple files to open them in sequence")
 1624|      1|                                .size(14.0)
 1625|      1|                                .color(egui::Color32::from_rgb(150, 150, 150))
 1626|      1|                                .italics(),
 1627|       |                        );
 1628|      1|                    });
 1629|      1|                });
 1630|      1|            });
 1631|     19|    }
 1632|       |}
 1633|       |
 1634|       |impl eframe::App for MarkdownViewerApp {
 1635|       |    /// Update function called every frame
 1636|      0|    fn update(&mut self, ctx: &Context, _frame: &mut eframe::Frame) {
 1637|      0|        self.update_inner(ctx);
 1638|      0|    }
 1639|       |
 1640|      0|    fn auto_save_interval(&self) -> std::time::Duration {
 1641|      0|        std::time::Duration::from_secs(30)
 1642|      0|    }
 1643|       |
 1644|      0|    fn save(&mut self, _storage: &mut dyn eframe::Storage) {
 1645|       |        // Persist window position and size on app save/exit
 1646|      0|        self.persist_window_state();
 1647|      0|    }
 1648|       |}
 1649|       |
 1650|       |impl MarkdownViewerApp {
 1651|     18|    fn update_inner(&mut self, ctx: &Context) {
 1652|       |        // Handle drag-drop events
 1653|     18|        self.handle_drag_drop_events(ctx);
 1654|       |
 1655|       |        // Handle keyboard shortcuts
 1656|     18|        self.handle_shortcuts(ctx);
 1657|       |
 1658|       |        // Keep native window title in sync with the current document
 1659|     18|        ctx.send_viewport_cmd(egui::ViewportCommand::Title(self.title.clone()));
 1660|       |
 1661|     18|        let (monitor_size, outer_rect, inner_rect, is_fullscreen, is_maximized) = ctx.input(|i| {
 1662|     18|            let vp = i.viewport();
 1663|     18|            (
 1664|     18|                vp.monitor_size,
 1665|     18|                vp.outer_rect,
 1666|     18|                vp.inner_rect,
 1667|     18|                vp.fullscreen.unwrap_or(false),
 1668|     18|                vp.maximized.unwrap_or(false),
 1669|     18|            )
 1670|     18|        });
 1671|       |
 1672|     18|        let mut adjusted = false;
 1673|     18|        if !is_fullscreen {
 1674|     18|            if let Some((pos, size)) = Self::compute_window_adjustment(outer_rect, monitor_size) {
                                       ^1   ^1
 1675|      1|                adjusted = true;
 1676|      1|                ctx.send_viewport_cmd(egui::ViewportCommand::OuterPosition(pos));
 1677|      1|                ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(size));
 1678|      1|                self.last_window_pos = Some([pos.x, pos.y]);
 1679|      1|                self.last_window_size = Some([size.x, size.y]);
 1680|     17|            }
 1681|      0|        }
 1682|       |
 1683|     18|        if !adjusted {
 1684|     17|            if let Some(outer) = outer_rect {
                                      ^1
 1685|      1|                self.last_window_pos = Some([outer.left(), outer.top()]);
 1686|     16|            }
 1687|     17|            if !is_fullscreen {
 1688|     17|                if let Some(inner) = inner_rect {
                                          ^1
 1689|      1|                    self.last_window_size = Some([inner.width(), inner.height()]);
 1690|     16|                }
 1691|      0|            }
 1692|      1|        }
 1693|     18|        self.last_window_maximized = is_maximized;
 1694|       |
 1695|       |        // Opportunistically persist window state if it changed, throttled to once per second
 1696|     18|        if self.should_persist_window_state() {
 1697|      1|            self.persist_window_state();
 1698|      1|            self.last_persist_instant = std::time::Instant::now();
 1699|     17|        }
 1700|       |
 1701|       |        // Handle fullscreen toggle outside input context to avoid deadlocks
 1702|     18|        if self.toggle_fullscreen {
 1703|      1|            self.toggle_fullscreen = false;
 1704|      1|            let current_fullscreen = ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
 1705|      1|            ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(!current_fullscreen));
 1706|     17|        }
 1707|       |
 1708|       |        // Handle deferred view toggle outside of input context
 1709|     18|        if self.view_toggle_requested {
 1710|      1|            self.view_toggle_requested = false;
 1711|      1|            self.toggle_view_mode(ctx);
 1712|     17|        }
 1713|       |
 1714|       |        // Handle deferred write toggle outside of input context
 1715|     18|        if self.write_toggle_requested {
 1716|      1|            self.write_toggle_requested = false;
 1717|      1|            self.toggle_write_mode(ctx);
 1718|     17|        }
 1719|       |
 1720|       |        // Handle deferred caret movement for raw editor
 1721|     18|        if let Some(delta) = self.pending_raw_cursor_line_move.take() {
                                  ^2
 1722|      2|            self.move_raw_cursor_lines(ctx, delta);
 1723|     16|        }
 1724|       |
 1725|       |        // Handle reload request outside input context to avoid blocking within input handling
 1726|     18|        if self.reload_requested {
 1727|      1|            self.reload_requested = false;
 1728|      1|            if let Err(e) = self.reload_current_file() {
 1729|      1|                self.error_message = Some(format!("Failed to reload file: {}", e));
 1730|      1|            }
                          ^0
 1731|     17|        }
 1732|       |
 1733|       |        // Render menu bar
 1734|     18|        self.render_menu_bar(ctx);
 1735|       |
 1736|       |        // Main content area
 1737|     18|        let central_response = CentralPanel::default().show(ctx, |ui| {
 1738|       |            // Show error message if any
 1739|     18|            if let Some(ref error) = self.error_message {
                                      ^2
 1740|      2|                ui.colored_label(Color32::RED, format!("Error: {}", error));
 1741|      2|                ui.separator();
 1742|     16|            }
 1743|       |
 1744|       |            // Render markdown content in a scrollable area
 1745|     18|            let scroll_delta = if let Some(nav) = self.nav_request.take() {
                                                         ^7
 1746|      7|                match nav {
 1747|       |                    NavigationRequest::Top => {
 1748|       |                        // Scroll to top: use a large POSITIVE delta to reach the beginning
 1749|      2|                        egui::Vec2::new(0.0, 100000.0)
 1750|       |                    }
 1751|       |                    NavigationRequest::Bottom => {
 1752|       |                        // Scroll to bottom: use a large NEGATIVE delta to reach the end
 1753|      1|                        egui::Vec2::new(0.0, -100000.0)
 1754|       |                    }
 1755|       |                    NavigationRequest::PageUp => {
 1756|      1|                        let viewport_height = ui.available_height();
 1757|      1|                        let page_size = viewport_height * 0.8;
 1758|      1|                        egui::Vec2::new(0.0, page_size) // Positive = scroll up (show earlier content)
 1759|       |                    }
 1760|       |                    NavigationRequest::PageDown => {
 1761|      1|                        let viewport_height = ui.available_height();
 1762|      1|                        let page_size = viewport_height * 0.8;
 1763|      1|                        egui::Vec2::new(0.0, -page_size) // Negative = scroll down (show later content)
 1764|       |                    }
 1765|       |                    NavigationRequest::ScrollUp => {
 1766|      1|                        egui::Vec2::new(0.0, 40.0) // Positive = fine scroll up
 1767|       |                    }
 1768|       |                    NavigationRequest::ScrollDown => {
 1769|      1|                        egui::Vec2::new(0.0, -40.0) // Negative = fine scroll down
 1770|       |                    }
 1771|       |                }
 1772|       |            } else {
 1773|     11|                egui::Vec2::ZERO
 1774|       |            };
 1775|       |
 1776|     18|            egui::ScrollArea::vertical()
 1777|     18|                .id_source(self.scroll_area_id)
 1778|     18|                .auto_shrink([false, false])
 1779|     18|                .scroll_bar_visibility(egui::scroll_area::ScrollBarVisibility::VisibleWhenNeeded)
 1780|     18|                .show(ui, |ui| {
 1781|       |                    // Apply scroll delta if we have navigation
 1782|     18|                    if scroll_delta != egui::Vec2::ZERO {
 1783|      7|                        ui.scroll_with_delta(scroll_delta);
 1784|     11|                    }
 1785|       |
 1786|     18|                    ui.spacing_mut().item_spacing.y = 8.0;
 1787|       |
 1788|     18|                    if self.parsed_elements.is_empty() && self.error_message.is_none() {
                                                                        ^1                 ^1
 1789|      1|                        ui.vertical_centered(|ui| {
 1790|      1|                            ui.add_space(50.0);
 1791|      1|                            ui.label(RichText::new("Welcome to MarkdownView").size(24.0).strong());
 1792|      1|                            ui.add_space(20.0);
 1793|      1|                            ui.label("Open a markdown file or select a sample to get started.");
 1794|      1|                            ui.add_space(20.0);
 1795|       |
 1796|      1|                            if action_triggered(ui.button("Open File").clicked(), "welcome_open") {
 1797|      1|                                self.open_file_dialog();
 1798|      1|                            }
                                          ^0
 1799|      1|                        });
 1800|       |                    } else {
 1801|     17|                        match self.view_mode {
 1802|       |                            ViewMode::Rendered => {
 1803|       |                                // Update highlight phrase: prefer live input, else last executed
 1804|     10|                                if self.show_search && !self.search_query.is_empty() {
                                                                     ^2
 1805|      2|                                    self.renderer.set_highlight_phrase(Some(&self.search_query));
 1806|      8|                                } else if !self.last_query.is_empty() {
 1807|      1|                                    self.renderer.set_highlight_phrase(Some(&self.last_query));
 1808|      7|                                } else {
 1809|      7|                                    self.renderer.set_highlight_phrase(None);
 1810|      7|                                }
 1811|       |
 1812|     10|                                self.renderer.render_to_ui(ui, &self.parsed_elements);
 1813|       |                                // If a header anchor was clicked, scroll to it
 1814|     10|                                if let Some(anchor) = self.renderer.take_pending_anchor() {
                                                          ^1
 1815|      1|                                    if let Some(rect) = self.renderer.header_rect_for(&anchor) {
 1816|      1|                                        // Align target header to the top of the visible area
 1817|      1|                                        ui.scroll_to_rect(rect, Some(egui::Align::Min));
 1818|      1|                                    }
                                                  ^0
 1819|      9|                                }
 1820|       |                                // If a search requested a scroll, align to top of visible area
 1821|     10|                                if let Some(idx) = self.pending_scroll_to_element.take() {
                                                          ^5
 1822|      5|                                    if let Some(rect) = self.renderer.element_rect_at(idx) {
 1823|      5|                                        ui.scroll_to_rect(rect, Some(egui::Align::Min));
 1824|      5|                                    }
                                                  ^0
 1825|      5|                                }
 1826|       |                            }
 1827|       |                            ViewMode::Raw => {
 1828|       |                                // Raw markdown view; editable when write mode is enabled
 1829|      7|                                if self.write_enabled {
 1830|      6|                                    let editor_id = egui::Id::new("raw_editor");
 1831|       |                                    // If we have a remembered cursor, restore it (clamped)
 1832|      6|                                    if let Some(mut idx) = self.raw_cursor.take() {
 1833|      6|                                        idx = idx.min(self.raw_buffer.len());
 1834|      2|                                        if let Some(mut state) =
 1835|      6|                                            egui::text_edit::TextEditState::load(
 1836|      6|                                                ui.ctx(),
 1837|      6|                                                editor_id,
 1838|      6|                                            )
 1839|      2|                                        {
 1840|      2|                                            let cr = egui::text::CCursorRange::one(
 1841|      2|                                                egui::text::CCursor::new(idx),
 1842|      2|                                            );
 1843|      2|                                            state.cursor.set_char_range(Some(cr));
 1844|      2|                                            state.store(ui.ctx(), editor_id);
 1845|      4|                                        } else {
 1846|      4|                                            let mut state =
 1847|      4|                                                egui::text_edit::TextEditState::default();
 1848|      4|                                            let cr = egui::text::CCursorRange::one(
 1849|      4|                                                egui::text::CCursor::new(idx),
 1850|      4|                                            );
 1851|      4|                                            state.cursor.set_char_range(Some(cr));
 1852|      4|                                            state.store(ui.ctx(), editor_id);
 1853|      4|                                        }
 1854|      0|                                    }
 1855|      6|                                    let before = self.raw_buffer.clone();
 1856|      6|                                    let resp = ui.add(
 1857|      6|                                        TextEdit::multiline(&mut self.raw_buffer)
 1858|      6|                                            .font(TextStyle::Monospace)
 1859|      6|                                            .code_editor()
 1860|      6|                                            .lock_focus(false)
 1861|      6|                                            .interactive(true)
 1862|      6|                                            .desired_width(f32::INFINITY)
 1863|      6|                                            .desired_rows(24)
 1864|      6|                                            .id_source(editor_id),
 1865|       |                                    );
 1866|      6|                                    if self.raw_focus_requested {
 1867|      3|                                        resp.request_focus();
 1868|      3|                                        self.raw_focus_requested = false;
 1869|      3|                                    }
 1870|       |                                    // Remember cursor position for next time
 1871|      6|                                    if let Some(state) =
 1872|      6|                                        egui::text_edit::TextEditState::load(ui.ctx(), editor_id)
 1873|       |                                    {
 1874|      6|                                        if let Some(range) = state.cursor.char_range() {
 1875|      6|                                            let idx = range.primary.index;
 1876|      6|                                            self.raw_cursor = Some(idx);
 1877|      6|                                        }
                                                      ^0
 1878|      0|                                    }
 1879|      6|                                    if self.raw_buffer != before {
 1880|      1|                                        self.current_content = self.raw_buffer.clone();
 1881|      1|                                        match self.renderer.parse(&self.current_content) {
 1882|      1|                                            Ok(elements) => {
 1883|      1|                                                self.parsed_elements = elements;
 1884|      1|                                                self.error_message = None;
 1885|      1|                                            }
 1886|      0|                                            Err(e) => {
 1887|      0|                                                self.error_message = Some(format!(
 1888|      0|                                                    "Failed to parse markdown: {}",
 1889|      0|                                                    e
 1890|      0|                                                ));
 1891|      0|                                            }
 1892|       |                                        }
 1893|      5|                                    }
 1894|      1|                                } else {
 1895|      1|                                    // Read-only
 1896|      1|                                    let mut tmp = self.raw_buffer.clone();
 1897|      1|                                    ui.add(
 1898|      1|                                        TextEdit::multiline(&mut tmp)
 1899|      1|                                            .font(TextStyle::Monospace)
 1900|      1|                                            .code_editor()
 1901|      1|                                            .lock_focus(false)
 1902|      1|                                            .interactive(false)
 1903|      1|                                            .desired_width(f32::INFINITY)
 1904|      1|                                            .desired_rows(24),
 1905|      1|                                    );
 1906|      1|                                }
 1907|       |                            }
 1908|       |                        }
 1909|       |                    }
 1910|     18|                });
 1911|     18|        });
 1912|       |
 1913|       |        // Add context menu for the main panel
 1914|     18|        central_response.response.context_menu(|ui| {
                                                                  ^0
 1915|      0|            self.render_main_context_menu(ui);
 1916|      0|        });
 1917|       |
 1918|       |        // Render floating search dialog (non-modal, always on top)
 1919|     18|        self.render_search_dialog(ctx);
 1920|       |
 1921|       |        // Render status bar
 1922|     18|        self.render_status_bar(ctx);
 1923|       |
 1924|       |        // Render drag-and-drop overlay (must be last to appear on top)
 1925|     18|        self.render_drag_overlay(ctx);
 1926|     18|        }
 1927|       |
 1928|       |    // Build a rich-text label with only the mnemonic character underlined (visual cue only).
 1929|     63|    fn menu_text_with_mnemonic(
 1930|     63|        prefix: Option<&str>,
 1931|     63|        label: &str,
 1932|     63|        mnemonic: char,
 1933|     63|        underline: bool,
 1934|     63|        text_color: Color32,
 1935|     63|    ) -> LayoutJob {
 1936|     63|        let mut job = LayoutJob::default();
 1937|     63|        let default_fmt = TextFormat {
 1938|     63|            color: text_color,
 1939|     63|            ..TextFormat::default()
 1940|     63|        };
 1941|     63|        if let Some(p) = prefix {
                                  ^0
 1942|      0|            job.append(p, 0.0, default_fmt.clone());
 1943|     63|        }
 1944|     63|        let m = mnemonic.to_ascii_lowercase();
 1945|     63|        let mut applied = false;
 1946|    325|        for c in label.chars() {
                               ^63   ^63
 1947|    325|            let mut fmt = default_fmt.clone();
 1948|    325|            if underline && !applied && c.to_ascii_lowercase() == m {
                                          ^0          ^0
 1949|      0|                // Use a subtle underline color; white works well on dark theme
 1950|      0|                fmt.underline = egui::Stroke::new(1.0, text_color);
 1951|      0|                applied = true;
 1952|    325|            }
 1953|    325|            let s = c.to_string();
 1954|    325|            job.append(&s, 0.0, fmt);
 1955|       |        }
 1956|     63|        job
 1957|     63|    }
 1958|      1|    fn persist_window_state(&mut self) {
 1959|      1|        if let Some(state) = self.current_window_state() {
 1960|      1|            if !self.window_state_changed(&state) {
 1961|      0|                return;
 1962|      1|            }
 1963|      1|            if crate::save_window_state(&state).is_ok() {
 1964|      1|                self.last_persist_instant = std::time::Instant::now();
 1965|      1|                self.last_persisted_state = Some(state);
 1966|      1|            }
                          ^0
 1967|      0|        }
 1968|      1|    }
 1969|       |
 1970|     18|    fn should_persist_window_state(&self) -> bool {
 1971|     18|        if self.last_persist_instant.elapsed() < std::time::Duration::from_secs(1) {
 1972|     17|            return false;
 1973|      1|        }
 1974|      1|        if let Some(state) = self.current_window_state() {
 1975|      1|            self.window_state_changed(&state)
 1976|       |        } else {
 1977|      0|            false
 1978|       |        }
 1979|     18|    }
 1980|       |
 1981|       |    /// Save current document. If no file is associated, prompts for a path.
 1982|      3|    fn save_current_document(&mut self) -> Result<()> {
 1983|      3|        if let Some(path) = self.current_file.clone() {
 1984|      3|            std::fs::write(&path, &self.current_content)?;
                                                                      ^0
 1985|      3|            let parent = path.parent();
 1986|      3|            self.renderer.set_base_dir(parent);
 1987|      3|            Ok(())
 1988|      0|        } else if let Some(path) = self.prompt_save_path() {
 1989|      0|            std::fs::write(&path, &self.current_content)?;
 1990|      0|            let filename = path
 1991|      0|                .file_name()
 1992|      0|                .and_then(|n| n.to_str())
 1993|      0|                .unwrap_or("Unknown")
 1994|      0|                .to_string();
 1995|      0|            self.current_file = Some(path);
 1996|      0|            if let Some(parent) = self.current_file.as_ref().and_then(|p| p.parent()) {
 1997|      0|                self.renderer.set_base_dir(Some(parent));
 1998|      0|            } else {
 1999|      0|                self.renderer.set_base_dir(None);
 2000|      0|            }
 2001|      0|            self.title = format!("{APP_TITLE_PREFIX} - {}", filename);
 2002|      0|            Ok(())
 2003|       |        } else {
 2004|      0|            Ok(())
 2005|       |        }
 2006|      3|    }
 2007|       |
 2008|       |    #[cfg(not(test))]
 2009|       |    fn prompt_save_path(&self) -> Option<PathBuf> {
 2010|       |        FileDialog::new()
 2011|       |            .set_title("Save Markdown File")
 2012|       |            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
 2013|       |            .save_file()
 2014|       |    }
 2015|       |
 2016|       |    #[cfg(test)]
 2017|      1|    fn prompt_save_path(&self) -> Option<PathBuf> {
 2018|      1|        None
 2019|      1|    }
 2020|       |
 2021|       |    /// Render the floating non-modal search dialog
 2022|     21|    fn render_search_dialog(&mut self, ctx: &Context) {
 2023|     21|        if !self.show_search {
 2024|     16|            return;
 2025|      5|        }
 2026|      5|        let prev_open = self.show_search;
 2027|      5|        let mut open = self.show_search;
 2028|      5|        let prev_query = self.search_query.clone();
 2029|      5|        egui::Window::new("Find")
 2030|      5|            .collapsible(false)
 2031|      5|            .resizable(false)
 2032|      5|            .default_pos(egui::pos2(80.0, 80.0))
 2033|      5|            .open(&mut open)
 2034|      5|            .show(ctx, |ui| {
 2035|      5|                let mut submitted_next = action_triggered(false, "search_submit");
 2036|      5|                ui.horizontal(|ui| {
 2037|      5|                    let text_edit = egui::TextEdit::singleline(&mut self.search_query)
 2038|      5|                        .hint_text("Search text...")
 2039|      5|                        .desired_width(240.0);
 2040|      5|                    let resp = ui.add(text_edit);
 2041|      5|                    if self.search_focus_requested {
 2042|      1|                        resp.request_focus();
 2043|      1|                        self.search_focus_requested = false;
 2044|      4|                    }
 2045|      5|                    if resp.lost_focus() && ui.input(|i| i.key_pressed(egui::Key::Enter)) {
                                                          ^0 ^0        ^0^0          ^0
 2046|      0|                        submitted_next = true;
 2047|      5|                    }
 2048|      5|                    let next_button = ui.button("Next (F3)");
 2049|      5|                    if action_triggered(next_button.clicked(), "search_next") || submitted_next {
                                                                                               ^3
 2050|      2|                        self.find_next();
 2051|      3|                    }
 2052|      5|                    let prev_button = ui.button("Prev (Shift+F3)");
 2053|      5|                    if action_triggered(prev_button.clicked(), "search_prev") {
 2054|      2|                        self.find_previous();
 2055|      3|                    }
 2056|      5|                });
 2057|      5|            });
 2058|      5|        if action_triggered(false, "search_close") {
 2059|      1|            open = false;
 2060|      4|        }
 2061|       |        // Dynamic search: scroll to first match from anchor whenever the input changes
 2062|      5|        if self.search_query != prev_query {
 2063|      1|            if self.search_query.is_empty() {
 2064|      0|                self.last_query.clear();
 2065|      0|                self.renderer.set_highlight_phrase(None);
 2066|      0|            } else {
 2067|      1|                self.last_query = self.search_query.clone();
 2068|       |                // Use current last match as baseline if set, else start of doc
 2069|      1|                let baseline = self.last_match_index.unwrap_or(0);
 2070|      1|                let needle = Self::fold_for_search(&self.search_query);
 2071|      1|                let total = self.parsed_elements.len();
 2072|      1|                let mut found: Option<usize> = None;
 2073|      1|                for pass in 0..2 {
 2074|      1|                    let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
 2075|      1|                        Box::new(baseline..total)
 2076|       |                    } else {
 2077|      0|                        Box::new(0..baseline.min(total))
 2078|       |                    };
 2079|      1|                    for idx in range {
 2080|      1|                        let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
 2081|      1|                            &self.parsed_elements[idx],
 2082|       |                        );
 2083|      1|                        if Self::fold_for_search(&text).contains(&needle) {
 2084|      1|                            found = Some(idx);
 2085|      1|                            break;
 2086|      0|                        }
 2087|       |                    }
 2088|      1|                    if found.is_some() {
 2089|      1|                        break;
 2090|      0|                    }
 2091|       |                }
 2092|      1|                if let Some(idx) = found {
 2093|      1|                    self.last_match_index = Some(idx);
 2094|      1|                    self.pending_scroll_to_element = Some(idx);
 2095|      1|                }
                              ^0
 2096|       |            }
 2097|      4|        }
 2098|       |        // If dialog closed via close button, clear before hiding
 2099|      5|        if prev_open && !open {
 2100|      1|            self.clear_search_state();
 2101|      4|        }
 2102|      5|        self.show_search = open;
 2103|     21|    }
 2104|       |
 2105|       |    // No overlay menu helpers; we only render egui's built-in menus.
 2106|       |}
 2107|       |
 2108|       |impl Default for MarkdownViewerApp {
 2109|      1|    fn default() -> Self {
 2110|      1|        Self::new()
 2111|      1|    }
 2112|       |}
 2113|       |
 2114|       |#[cfg(test)]
 2115|       |mod tests {
 2116|       |    use super::*;
 2117|       |    use crate::markdown_renderer::InlineSpan;
 2118|       |    use std::io::Write;
 2119|       |    use std::time::Duration;
 2120|       |    use tempfile::{NamedTempFile, TempDir};
 2121|       |
 2122|       |    struct ForcedActions {
 2123|       |        actions: Vec<&'static str>,
 2124|       |    }
 2125|       |
 2126|       |    impl ForcedActions {
 2127|      9|        fn new(actions: &[&'static str]) -> Self {
 2128|      9|            FORCED_ACTIONS.with(|set| {
 2129|      9|                let mut set = set.borrow_mut();
 2130|     37|                for action in actions {
                                  ^28
 2131|     28|                    set.insert(*action);
 2132|     28|                }
 2133|      9|            });
 2134|      9|            Self {
 2135|      9|                actions: actions.to_vec(),
 2136|      9|            }
 2137|      9|        }
 2138|       |    }
 2139|       |
 2140|       |    impl Drop for ForcedActions {
 2141|      9|        fn drop(&mut self) {
 2142|      9|            FORCED_ACTIONS.with(|set| {
 2143|      9|                let mut set = set.borrow_mut();
 2144|     37|                for action in &self.actions {
                                  ^28
 2145|     28|                    set.remove(action);
 2146|     28|                }
 2147|      9|            });
 2148|      9|        }
 2149|       |    }
 2150|       |
 2151|       |    struct EnvGuard {
 2152|       |        key: &'static str,
 2153|       |        original: Option<String>,
 2154|       |    }
 2155|       |
 2156|       |    impl EnvGuard {
 2157|      1|        fn set(key: &'static str, value: &str) -> Self {
 2158|      1|            let original = std::env::var(key).ok();
 2159|      1|            std::env::set_var(key, value);
 2160|      1|            Self { key, original }
 2161|      1|        }
 2162|       |    }
 2163|       |
 2164|       |    impl Drop for EnvGuard {
 2165|      1|        fn drop(&mut self) {
 2166|      1|            if let Some(value) = &self.original {
 2167|      1|                std::env::set_var(self.key, value);
 2168|      1|            } else {
 2169|      0|                std::env::remove_var(self.key);
 2170|      0|            }
 2171|      1|        }
 2172|       |    }
 2173|       |
 2174|     36|    fn test_input() -> egui::RawInput {
 2175|     36|        let mut input = egui::RawInput::default();
 2176|     36|        input.screen_rect = Some(egui::Rect::from_min_size(
 2177|     36|            egui::pos2(0.0, 0.0),
 2178|     36|            egui::vec2(1024.0, 768.0),
 2179|     36|        ));
 2180|     36|        input
 2181|     36|    }
 2182|       |
 2183|      2|    fn test_input_with_viewport(
 2184|      2|        outer_rect: Option<egui::Rect>,
 2185|      2|        inner_rect: Option<egui::Rect>,
 2186|      2|        monitor_size: Option<egui::Vec2>,
 2187|      2|        fullscreen: Option<bool>,
 2188|      2|        maximized: Option<bool>,
 2189|      2|    ) -> egui::RawInput {
 2190|      2|        let mut input = test_input();
 2191|      2|        if let Some(info) = input.viewports.get_mut(&egui::ViewportId::ROOT) {
 2192|      2|            info.outer_rect = outer_rect;
 2193|      2|            info.inner_rect = inner_rect;
 2194|      2|            info.monitor_size = monitor_size;
 2195|      2|            info.fullscreen = fullscreen;
 2196|      2|            info.maximized = maximized;
 2197|      2|        }
                      ^0
 2198|      2|        input
 2199|      2|    }
 2200|       |
 2201|      7|    fn with_test_ui<F>(f: F)
 2202|      7|    where
 2203|      7|        F: FnOnce(&egui::Context, &mut egui::Ui),
 2204|       |    {
 2205|      7|        let ctx = egui::Context::default();
 2206|      7|        let input = test_input();
 2207|      7|        ctx.begin_frame(input);
 2208|      7|        egui::CentralPanel::default().show(&ctx, |ui| {
 2209|      7|            f(&ctx, ui);
 2210|      7|        });
 2211|      7|        let _ = ctx.end_frame();
 2212|      7|    }
 2213|       |
 2214|     13|    fn run_update(app: &mut MarkdownViewerApp, input: egui::RawInput) {
 2215|     13|        let ctx = egui::Context::default();
 2216|     13|        ctx.begin_frame(input);
 2217|     13|        app.update_inner(&ctx);
 2218|     13|        let _ = ctx.end_frame();
 2219|     13|    }
 2220|       |
 2221|      5|    fn run_frame<F>(ctx: &egui::Context, input: egui::RawInput, f: F)
 2222|      5|    where
 2223|      5|        F: FnOnce(&egui::Context),
 2224|       |    {
 2225|      5|        ctx.begin_frame(input);
 2226|      5|        f(ctx);
 2227|      5|        let _ = ctx.end_frame();
 2228|      5|    }
 2229|       |
 2230|       |    #[test]
 2231|      1|    fn test_normalize_line_endings() {
 2232|       |        // Windows style (\r\n)
 2233|      1|        assert_eq!(
 2234|      1|            MarkdownViewerApp::normalize_line_endings("Hello\r\nWorld"),
 2235|       |            "Hello\nWorld"
 2236|       |        );
 2237|       |
 2238|       |        // Unix style (\n) - no change
 2239|      1|        assert_eq!(
 2240|      1|            MarkdownViewerApp::normalize_line_endings("Hello\nWorld"),
 2241|       |            "Hello\nWorld"
 2242|       |        );
 2243|       |
 2244|       |        // Old Mac style (\r)
 2245|      1|        assert_eq!(
 2246|      1|            MarkdownViewerApp::normalize_line_endings("Hello\rWorld"),
 2247|       |            "Hello\nWorld"
 2248|       |        );
 2249|       |
 2250|       |        // Mixed line endings
 2251|      1|        assert_eq!(
 2252|      1|            MarkdownViewerApp::normalize_line_endings("A\r\nB\nC\rD"),
 2253|       |            "A\nB\nC\nD"
 2254|       |        );
 2255|       |
 2256|       |        // Multiple blank lines with Windows endings
 2257|      1|        assert_eq!(
 2258|      1|            MarkdownViewerApp::normalize_line_endings("A\r\n\r\nB"),
 2259|       |            "A\n\nB"
 2260|       |        );
 2261|       |
 2262|       |        // Empty string
 2263|      1|        assert_eq!(MarkdownViewerApp::normalize_line_endings(""), "");
 2264|       |
 2265|       |        // No line endings
 2266|      1|        assert_eq!(
 2267|      1|            MarkdownViewerApp::normalize_line_endings("Single line"),
 2268|       |            "Single line"
 2269|       |        );
 2270|      1|    }
 2271|       |
 2272|       |    #[test]
 2273|      1|    fn test_load_file_with_windows_line_endings() -> Result<()> {
 2274|      1|        let mut app = MarkdownViewerApp::new();
 2275|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2276|       |
 2277|       |        // Write content with explicit Windows line endings
 2278|      1|        temp_file.write_all(b"Line 1\r\nLine 2\r\n\r\nParagraph text")?;
                                                                                    ^0
 2279|      1|        temp_file.flush()?;
                                       ^0
 2280|       |
 2281|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 2282|       |
 2283|       |        // Should not contain any \r characters after normalization
 2284|      1|        assert!(!app.current_content.contains('\r'));
 2285|      1|        assert!(app.current_content.contains("Line 1\nLine 2"));
 2286|      1|        assert!(app.current_content.contains("\n\nParagraph"));
 2287|      1|        Ok(())
 2288|      1|    }
 2289|       |
 2290|       |    #[test]
 2291|      1|    fn test_load_file_with_mixed_line_endings() -> Result<()> {
 2292|      1|        let mut app = MarkdownViewerApp::new();
 2293|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2294|       |
 2295|       |        // Mix of \r\n (Windows), \n (Unix), and \r (old Mac)
 2296|      1|        temp_file.write_all(b"Line 1\r\nLine 2\nLine 3\rLine 4")?;
                                                                              ^0
 2297|      1|        temp_file.flush()?;
                                       ^0
 2298|       |
 2299|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 2300|       |
 2301|       |        // All should be normalized to \n
 2302|      1|        assert!(!app.current_content.contains('\r'));
 2303|      1|        assert_eq!(app.current_content.lines().count(), 4);
 2304|      1|        let lines: Vec<&str> = app.current_content.lines().collect();
 2305|      1|        assert_eq!(lines[0], "Line 1");
 2306|      1|        assert_eq!(lines[1], "Line 2");
 2307|      1|        assert_eq!(lines[2], "Line 3");
 2308|      1|        assert_eq!(lines[3], "Line 4");
 2309|      1|        Ok(())
 2310|      1|    }
 2311|       |
 2312|       |    #[test]
 2313|      1|    fn test_app_creation() {
 2314|      1|        let app = MarkdownViewerApp::new();
 2315|      1|        assert!(!app.parsed_elements.is_empty()); // Should load welcome content
 2316|      1|        assert!(app.title.contains(APP_TITLE_PREFIX));
 2317|      1|        assert!(app.error_message.is_none());
 2318|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 2319|      1|    }
 2320|       |
 2321|       |    #[test]
 2322|      1|    fn test_load_content() {
 2323|      1|        let mut app = MarkdownViewerApp::new();
 2324|      1|        let content = "# Test Header\n\nThis is test content.";
 2325|       |
 2326|      1|        app.load_content(content, Some("Test".to_string()));
 2327|       |
 2328|      1|        assert_eq!(app.current_content, content);
 2329|      1|        assert_eq!(app.raw_buffer, content);
 2330|      1|        assert!(app.title.contains("Test"));
 2331|      1|        assert!(!app.parsed_elements.is_empty());
 2332|      1|        assert!(app.error_message.is_none());
 2333|      1|    }
 2334|       |
 2335|       |    #[test]
 2336|      1|    fn test_toggle_view_mode() {
 2337|      1|        let mut app = MarkdownViewerApp::new();
 2338|      1|        let ctx = egui::Context::default();
 2339|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 2340|      1|        app.toggle_view_mode(&ctx);
 2341|      1|        assert!(matches!(app.view_mode, ViewMode::Raw));
                              ^0
 2342|      1|        app.toggle_view_mode(&ctx);
 2343|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 2344|      1|    }
 2345|       |
 2346|       |    #[test]
 2347|      1|    fn test_load_sample() {
 2348|      1|        let mut app = MarkdownViewerApp::new();
 2349|      1|        let sample = &SAMPLE_FILES[0]; // First sample file
 2350|       |
 2351|      1|        app.load_sample(sample);
 2352|       |
 2353|      1|        assert_eq!(app.current_content, sample.content);
 2354|      1|        assert!(app.title.contains(sample.title));
 2355|      1|        assert!(!app.parsed_elements.is_empty());
 2356|      1|        assert!(app.current_file.is_none()); // Sample files don't set file path
 2357|      1|    }
 2358|       |
 2359|       |    #[test]
 2360|      1|    fn test_load_file() -> Result<()> {
 2361|      1|        let mut app = MarkdownViewerApp::new();
 2362|       |
 2363|       |        // Create a temporary markdown file
 2364|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2365|      1|        let content = "# Temporary File\n\nThis is a test markdown file.";
 2366|      1|        temp_file.write_all(content.as_bytes())?;
                                                             ^0
 2367|      1|        temp_file.flush()?;
                                       ^0
 2368|       |
 2369|      1|        let path = temp_file.path().to_path_buf();
 2370|      1|        app.load_file(path.clone(), true)?;
                                                       ^0
 2371|       |
 2372|      1|        assert_eq!(app.current_content, content);
 2373|      1|        assert_eq!(app.current_file, Some(path));
 2374|      1|        assert!(!app.parsed_elements.is_empty());
 2375|      1|        assert!(app.error_message.is_none());
 2376|       |
 2377|      1|        Ok(())
 2378|      1|    }
 2379|       |
 2380|       |    #[test]
 2381|      1|    fn test_load_invalid_markdown() {
 2382|      1|        let mut app = MarkdownViewerApp::new();
 2383|       |        // Even "invalid" markdown should parse successfully with pulldown-cmark
 2384|       |        // as it's very permissive
 2385|      1|        let content = "This is just plain text with some <invalid> HTML tags";
 2386|       |
 2387|      1|        app.load_content(content, Some("Invalid".to_string()));
 2388|       |
 2389|       |        // Should still work - pulldown-cmark is very permissive
 2390|      1|        assert_eq!(app.current_content, content);
 2391|      1|        assert!(app.error_message.is_none() || app.error_message.is_some()); // Either is ok
                                                             ^0                ^0
 2392|      1|    }
 2393|       |
 2394|       |    #[test]
 2395|      1|    fn test_load_empty_content() {
 2396|      1|        let mut app = MarkdownViewerApp::new();
 2397|      1|        app.load_content("", Some("Empty".to_string()));
 2398|       |
 2399|      1|        assert_eq!(app.current_content, "");
 2400|      1|        assert!(app.title.contains("Empty"));
 2401|      1|        assert!(app.error_message.is_none());
 2402|      1|    }
 2403|       |
 2404|       |    #[test]
 2405|      1|    fn test_load_nonexistent_file() {
 2406|      1|        let mut app = MarkdownViewerApp::new();
 2407|      1|        let fake_path = PathBuf::from("/nonexistent/file.md");
 2408|       |
 2409|      1|        let result = app.load_file(fake_path, true);
 2410|      1|        assert!(result.is_err());
 2411|      1|    }
 2412|       |
 2413|       |    #[test]
 2414|      1|    fn test_reload_current_file() -> Result<()> {
 2415|      1|        let mut app = MarkdownViewerApp::new();
 2416|       |
 2417|       |        // Create a temporary markdown file
 2418|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2419|      1|        let content1 = "# Title\n\nVersion 1";
 2420|      1|        temp_file.write_all(content1.as_bytes())?;
                                                              ^0
 2421|      1|        temp_file.flush()?;
                                       ^0
 2422|       |
 2423|      1|        let path = temp_file.path().to_path_buf();
 2424|      1|        app.load_file(path.clone(), true)?;
                                                       ^0
 2425|      1|        assert!(app.current_content.contains("Version 1"));
 2426|       |
 2427|       |        // Update file content
 2428|      1|        let content2 = "# Title\n\nVersion 2";
 2429|      1|        temp_file.as_file_mut().set_len(0)?; // clear
                                                        ^0
 2430|      1|        temp_file.write_all(content2.as_bytes())?;
                                                              ^0
 2431|      1|        temp_file.flush()?;
                                       ^0
 2432|       |
 2433|       |        // Reload and verify
 2434|      1|        app.reload_current_file()?;
                                               ^0
 2435|      1|        assert!(app.current_content.contains("Version 2"));
 2436|      1|        Ok(())
 2437|      1|    }
 2438|       |
 2439|       |    #[test]
 2440|      1|    fn test_load_file_with_invalid_utf8() -> Result<()> {
 2441|      1|        let mut app = MarkdownViewerApp::new();
 2442|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2443|      1|        let bytes = b"Hello\xFFWorld";
 2444|      1|        temp_file.write_all(bytes)?;
                                                ^0
 2445|      1|        temp_file.flush()?;
                                       ^0
 2446|       |
 2447|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 2448|       |
 2449|      1|        assert!(app.current_content.contains('\u{FFFD}'));
 2450|      1|        assert!(!app.parsed_elements.is_empty());
 2451|      1|        assert!(app.error_message.is_none());
 2452|      1|        Ok(())
 2453|      1|    }
 2454|       |
 2455|       |    #[test]
 2456|      1|    fn test_reload_without_file() {
 2457|      1|        let mut app = MarkdownViewerApp::new();
 2458|      1|        assert!(app.current_file.is_none());
 2459|      1|        let result = app.reload_current_file();
 2460|      1|        assert!(result.is_err());
 2461|      1|    }
 2462|       |
 2463|       |    #[test]
 2464|      1|    fn test_window_state_change_detection() {
 2465|      1|        let mut app = MarkdownViewerApp::new();
 2466|      1|        app.last_window_pos = Some([10.0, 10.0]);
 2467|      1|        app.last_window_size = Some([800.0, 600.0]);
 2468|      1|        app.last_window_maximized = false;
 2469|       |
 2470|      1|        let state = app.current_window_state().expect("state");
 2471|      1|        assert!(app.window_state_changed(&state));
 2472|      1|        app.last_persisted_state = Some(state);
 2473|      1|        assert!(!app.window_state_changed(&state));
 2474|       |
 2475|      1|        let mut moved = state;
 2476|      1|        moved.pos = [12.0, 10.0];
 2477|      1|        assert!(app.window_state_changed(&moved));
 2478|      1|    }
 2479|       |
 2480|       |    #[test]
 2481|      1|    fn test_fold_for_search_handles_case_and_accents() {
 2482|      1|        assert_eq!(
 2483|      1|            MarkdownViewerApp::fold_for_search("\u{00C4}\u{00DF}"),
 2484|      1|            MarkdownViewerApp::fold_for_search("\u{00E4}SS")
 2485|       |        );
 2486|      1|        assert_eq!(
 2487|      1|            MarkdownViewerApp::fold_for_search("To\u{0301}m"),
 2488|      1|            MarkdownViewerApp::fold_for_search("T\u{00D3}m")
 2489|       |        );
 2490|      1|    }
 2491|       |
 2492|       |    #[test]
 2493|      1|    fn test_title_updates() {
 2494|      1|        let mut app = MarkdownViewerApp::new();
 2495|       |
 2496|       |        // Test with custom title
 2497|      1|        app.load_content("# Test", Some("Custom Title".to_string()));
 2498|      1|        assert!(app.title.contains("Custom Title"));
 2499|       |
 2500|       |        // Test with no title (should keep existing)
 2501|      1|        let old_title = app.title.clone();
 2502|      1|        app.load_content("# Another Test", None);
 2503|      1|        assert_eq!(app.title, old_title); // Should remain unchanged
 2504|      1|    }
 2505|       |
 2506|       |    #[test]
 2507|      1|    fn test_complex_markdown_loading() {
 2508|      1|        let mut app = MarkdownViewerApp::new();
 2509|      1|        let complex_content = r#"# Complex Document
 2510|      1|
 2511|      1|## With Multiple Sections
 2512|      1|
 2513|      1|This has **bold** and *italic* text.
 2514|      1|
 2515|      1|```rust
 2516|      1|fn main() {
 2517|      1|    println!("Hello, world!");
 2518|      1|}
 2519|      1|```
 2520|      1|
 2521|      1|- List item 1
 2522|      1|- List item 2
 2523|      1|
 2524|      1|> A blockquote
 2525|      1|
 2526|      1|[A link](https://example.com)
 2527|      1|
 2528|      1|---
 2529|      1|
 2530|      1|The end.
 2531|      1|"#;
 2532|       |
 2533|      1|        app.load_content(complex_content, Some("Complex".to_string()));
 2534|       |
 2535|      1|        assert_eq!(app.current_content, complex_content);
 2536|      1|        assert!(app.title.contains("Complex"));
 2537|      1|        assert!(!app.parsed_elements.is_empty());
 2538|      1|        assert!(app.error_message.is_none());
 2539|       |
 2540|       |        // Should have parsed various element types
 2541|      1|        assert!(app.parsed_elements.len() > 5); // Complex document should have many elements
 2542|      1|    }
 2543|       |
 2544|       |    #[test]
 2545|      1|    fn test_error_handling() {
 2546|      1|        let app = MarkdownViewerApp::new();
 2547|       |
 2548|       |        // Test that app starts without errors
 2549|      1|        assert!(app.error_message.is_none());
 2550|       |
 2551|       |        // Even with the welcome content loaded, should be error-free
 2552|      1|        assert!(!app.parsed_elements.is_empty());
 2553|      1|    }
 2554|       |
 2555|       |    #[test]
 2556|      1|    fn test_default_state() {
 2557|      1|        let app = MarkdownViewerApp::default();
 2558|       |
 2559|       |        // Default should be same as new()
 2560|      1|        assert!(!app.parsed_elements.is_empty());
 2561|      1|        assert!(app.title.contains(APP_TITLE_PREFIX));
 2562|      1|        assert!(app.error_message.is_none());
 2563|      1|        assert!(app.current_file.is_none());
 2564|      1|    }
 2565|       |
 2566|       |    #[test]
 2567|      1|    fn test_sample_files_integration() {
 2568|      1|        let mut app = MarkdownViewerApp::new();
 2569|       |
 2570|       |        // Test loading each sample file
 2571|      7|        for sample in SAMPLE_FILES {
                          ^6
 2572|      6|            app.load_sample(sample);
 2573|       |
 2574|      6|            assert_eq!(app.current_content, sample.content);
 2575|      6|            assert!(app.title.contains(sample.title));
 2576|      6|            assert!(app.current_file.is_none());
 2577|      6|            assert!(app.error_message.is_none());
 2578|       |        }
 2579|      1|    }
 2580|       |
 2581|       |    #[test]
 2582|      1|    fn test_close_current_file() {
 2583|      1|        let mut app = MarkdownViewerApp::new();
 2584|       |
 2585|       |        // Load some content first
 2586|      1|        app.load_content("# Test Content", Some("Test File".to_string()));
 2587|      1|        assert!(app.title.contains("Test File"));
 2588|       |
 2589|       |        // Close the file
 2590|      1|        app.close_current_file();
 2591|       |
 2592|       |        // Should return to welcome screen
 2593|      1|        assert!(app.title.contains("Welcome"));
 2594|      1|        assert!(app.current_file.is_none());
 2595|      1|        assert!(!app.parsed_elements.is_empty()); // Should have welcome content
 2596|      1|        assert!(app.error_message.is_none());
 2597|      1|    }
 2598|       |
 2599|       |    #[test]
 2600|      1|    fn test_navigation_request_enum() {
 2601|       |        // Test that the enum values exist and are correct
 2602|      1|        let _top = NavigationRequest::Top;
 2603|      1|        let _bottom = NavigationRequest::Bottom;
 2604|      1|        let _page_up = NavigationRequest::PageUp;
 2605|      1|        let _page_down = NavigationRequest::PageDown;
 2606|      1|        let _scroll_up = NavigationRequest::ScrollUp;
 2607|      1|        let _scroll_down = NavigationRequest::ScrollDown;
 2608|       |
 2609|       |        // Ensure it's cloneable and debuggable
 2610|      1|        let nav = NavigationRequest::Top;
 2611|      1|        let _cloned = nav.clone();
 2612|      1|        let _debug = format!("{:?}", nav);
 2613|       |
 2614|       |        // Basic compilation test performed by using the enum and Debug/Clone
 2615|      1|    }
 2616|       |
 2617|       |    #[test]
 2618|      1|    fn test_navigation_state_initialization() {
 2619|      1|        let app = MarkdownViewerApp::new();
 2620|       |        // Test that nav_request is initialized to None
 2621|      1|        assert!(app.nav_request.is_none());
 2622|       |        // Test that fullscreen toggle flag is initialized to false
 2623|      1|        assert!(!app.toggle_fullscreen);
 2624|      1|    }
 2625|       |
 2626|       |    #[test]
 2627|      1|    fn test_fullscreen_toggle_flag() {
 2628|      1|        let mut app = MarkdownViewerApp::new();
 2629|       |
 2630|       |        // Initially should be false
 2631|      1|        assert!(!app.toggle_fullscreen);
 2632|       |
 2633|       |        // Simulate F11 key press (this would be set in handle_shortcuts)
 2634|      1|        app.toggle_fullscreen = true;
 2635|      1|        assert!(app.toggle_fullscreen);
 2636|       |
 2637|       |        // After handling, it should be reset to false
 2638|      1|        app.toggle_fullscreen = false;
 2639|      1|        assert!(!app.toggle_fullscreen);
 2640|      1|    }
 2641|       |
 2642|       |    #[test]
 2643|      1|    fn test_navigation_state_reset_on_load() {
 2644|      1|        let mut app = MarkdownViewerApp::new();
 2645|       |
 2646|       |        // Set a navigation request
 2647|      1|        app.nav_request = Some(NavigationRequest::Top);
 2648|      1|        assert!(app.nav_request.is_some());
 2649|       |
 2650|       |        // Load content should reset navigation state
 2651|      1|        app.load_content("# Test Content", Some("Test".to_string()));
 2652|      1|        assert!(app.nav_request.is_none());
 2653|      1|    }
 2654|       |
 2655|       |    #[test]
 2656|      1|    fn test_page_navigation_calculations() {
 2657|       |        // Test the page size calculation logic used in navigation
 2658|      1|        let viewport_height = 800.0f32;
 2659|      1|        let page_size = viewport_height * 0.8;
 2660|      1|        assert_eq!(page_size, 640.0);
 2661|       |
 2662|       |        // Test boundary conditions for Page Up
 2663|      1|        let current_offset = 100.0f32;
 2664|      1|        let new_offset_up = (current_offset - page_size).max(0.0);
 2665|      1|        assert_eq!(new_offset_up, 0.0); // Should clamp to 0
 2666|       |
 2667|       |        // Test Page Down calculation
 2668|      1|        let new_offset_down = current_offset + page_size;
 2669|      1|        assert_eq!(new_offset_down, 740.0);
 2670|       |
 2671|       |        // Test that Page Up from near top goes to 0
 2672|      1|        let near_top = 300.0f32;
 2673|      1|        let from_near_top = (near_top - page_size).max(0.0);
 2674|      1|        assert_eq!(from_near_top, 0.0);
 2675|      1|    }
 2676|       |
 2677|       |    #[test]
 2678|      1|    fn test_compute_window_adjustment_clamps_offscreen_window() {
 2679|      1|        let outer = egui::Rect::from_min_size(egui::pos2(1200.0, 900.0), egui::vec2(800.0, 600.0));
 2680|      1|        let monitor = egui::vec2(1024.0, 768.0);
 2681|      1|        let (pos, size) = MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(monitor))
 2682|      1|            .expect("should adjust window geometry");
 2683|      1|        assert!(pos.x <= monitor.x - size.x + 1.0);
 2684|      1|        assert!(pos.y <= monitor.y - size.y + 1.0);
 2685|      1|    }
 2686|       |
 2687|       |    #[test]
 2688|      1|    fn test_compute_window_adjustment_respects_min_size() {
 2689|      1|        let outer = egui::Rect::from_min_size(egui::pos2(-200.0, -100.0), egui::vec2(200.0, 100.0));
 2690|      1|        let monitor = egui::vec2(1920.0, 1080.0);
 2691|      1|        let (pos, size) = MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(monitor))
 2692|      1|            .expect("should enforce minimum window size");
 2693|      1|        assert!(size.x >= 600.0);
 2694|      1|        assert!(size.y >= 400.0);
 2695|      1|        assert!(pos.x >= 0.0);
 2696|      1|        assert!(pos.y >= 0.0);
 2697|      1|    }
 2698|       |
 2699|       |    #[test]
 2700|      1|    fn test_is_valid_markdown_file() {
 2701|      1|        let app = MarkdownViewerApp::new();
 2702|       |
 2703|       |        // Valid markdown extensions
 2704|      1|        assert!(app.is_valid_markdown_file(Path::new("test.md")));
 2705|      1|        assert!(app.is_valid_markdown_file(Path::new("test.markdown")));
 2706|      1|        assert!(app.is_valid_markdown_file(Path::new("test.mdown")));
 2707|      1|        assert!(app.is_valid_markdown_file(Path::new("test.mkd")));
 2708|      1|        assert!(app.is_valid_markdown_file(Path::new("test.txt")));
 2709|       |
 2710|       |        // Case insensitive
 2711|      1|        assert!(app.is_valid_markdown_file(Path::new("test.MD")));
 2712|      1|        assert!(app.is_valid_markdown_file(Path::new("test.Markdown")));
 2713|       |
 2714|       |        // Invalid extensions
 2715|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.pdf")));
 2716|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.docx")));
 2717|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.html")));
 2718|       |
 2719|       |        // No extension
 2720|      1|        assert!(!app.is_valid_markdown_file(Path::new("test")));
 2721|      1|    }
 2722|       |
 2723|       |    #[test]
 2724|      1|    fn test_scan_directory() -> Result<()> {
 2725|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2726|      1|        let dir_path = temp_dir.path();
 2727|       |
 2728|       |        // Create test files
 2729|      1|        std::fs::write(dir_path.join("zebra.md"), "# Z")?;
                                                                      ^0
 2730|      1|        std::fs::write(dir_path.join("alpha.md"), "# A")?;
                                                                      ^0
 2731|      1|        std::fs::write(dir_path.join("image.png"), "fake")?;
                                                                        ^0
 2732|      1|        std::fs::write(dir_path.join("beta.markdown"), "# B")?;
                                                                           ^0
 2733|       |
 2734|       |        // Create subdirectory (should be ignored)
 2735|      1|        std::fs::create_dir(dir_path.join("subdir"))?;
                                                                  ^0
 2736|      1|        std::fs::write(dir_path.join("subdir/nested.md"), "# N")?;
                                                                              ^0
 2737|       |
 2738|      1|        let app = MarkdownViewerApp::new();
 2739|      1|        let files = app.scan_directory(dir_path)?;
                                                              ^0
 2740|       |
 2741|       |        // Should find 3 markdown files (alpha, beta, zebra)
 2742|       |        // Should NOT find image.png or nested.md
 2743|      1|        assert_eq!(files.len(), 3);
 2744|       |
 2745|       |        // Should be sorted alphabetically
 2746|      1|        assert!(files[0].ends_with("alpha.md"));
 2747|      1|        assert!(files[1].ends_with("beta.markdown"));
 2748|      1|        assert!(files[2].ends_with("zebra.md"));
 2749|       |
 2750|      1|        Ok(())
 2751|      1|    }
 2752|       |
 2753|       |    #[test]
 2754|      1|    fn test_scan_empty_directory() -> Result<()> {
 2755|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2756|      1|        let app = MarkdownViewerApp::new();
 2757|      1|        let files = app.scan_directory(temp_dir.path())?;
                                                                     ^0
 2758|       |
 2759|      1|        assert_eq!(files.len(), 0);
 2760|      1|        Ok(())
 2761|      1|    }
 2762|       |
 2763|       |    #[test]
 2764|      1|    fn test_single_file_drop() -> Result<()> {
 2765|      1|        let mut app = MarkdownViewerApp::new();
 2766|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2767|      1|        let file = temp_dir.path().join("test.md");
 2768|      1|        std::fs::write(&file, "# Test")?;
                                                     ^0
 2769|       |
 2770|      1|        app.handle_file_drop(vec![file.clone()]);
 2771|       |
 2772|      1|        assert_eq!(app.current_file, Some(file));
 2773|      1|        assert!(app.pending_files.is_empty());
 2774|      1|        assert!(app.error_message.is_none());
 2775|      1|        Ok(())
 2776|      1|    }
 2777|       |
 2778|       |    #[test]
 2779|      1|    fn test_multiple_files_drop() -> Result<()> {
 2780|      1|        let mut app = MarkdownViewerApp::new();
 2781|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2782|       |
 2783|      1|        let files: Vec<PathBuf> = (0..5)
 2784|      5|            .map(|i| {
                           ^1
 2785|      5|                let path = temp_dir.path().join(format!("file{}.md", i));
 2786|      5|                std::fs::write(&path, format!("# File {}", i)).unwrap();
 2787|      5|                path
 2788|      5|            })
 2789|      1|            .collect();
 2790|       |
 2791|      1|        app.handle_file_drop(files.clone());
 2792|       |
 2793|      1|        assert_eq!(app.current_file, Some(files[0].clone()));
 2794|      1|        assert_eq!(app.pending_files.len(), 4);
 2795|      1|        Ok(())
 2796|      1|    }
 2797|       |
 2798|       |    #[test]
 2799|      1|    fn test_directory_drop() -> Result<()> {
 2800|      1|        let mut app = MarkdownViewerApp::new();
 2801|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2802|       |
 2803|       |        // Create files in directory
 2804|      1|        std::fs::write(temp_dir.path().join("a.md"), "# A")?;
                                                                         ^0
 2805|      1|        std::fs::write(temp_dir.path().join("b.md"), "# B")?;
                                                                         ^0
 2806|      1|        std::fs::write(temp_dir.path().join("c.md"), "# C")?;
                                                                         ^0
 2807|       |
 2808|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 2809|       |
 2810|      1|        assert!(app.current_file.is_some());
 2811|      1|        assert_eq!(app.pending_files.len(), 2);
 2812|      1|        Ok(())
 2813|      1|    }
 2814|       |
 2815|       |    #[test]
 2816|      1|    fn test_invalid_file_drop() {
 2817|      1|        let mut app = MarkdownViewerApp::new();
 2818|      1|        let temp_dir = tempfile::TempDir::new().unwrap();
 2819|      1|        let file = temp_dir.path().join("test.pdf");
 2820|      1|        std::fs::write(&file, "fake pdf").unwrap();
 2821|       |
 2822|      1|        app.handle_file_drop(vec![file]);
 2823|       |
 2824|       |        // Current file should remain None (or welcome sample)
 2825|      1|        assert!(app.error_message.is_some());
 2826|      1|        assert!(app
 2827|      1|            .error_message
 2828|      1|            .as_ref()
 2829|      1|            .unwrap()
 2830|      1|            .contains("Not a markdown file"));
 2831|      1|    }
 2832|       |
 2833|       |    #[test]
 2834|      1|    fn test_too_many_files() {
 2835|      1|        let mut app = MarkdownViewerApp::new();
 2836|      1|        let temp_dir = tempfile::TempDir::new().unwrap();
 2837|       |
 2838|      1|        let files: Vec<PathBuf> = (0..60)
 2839|     60|            .map(|i| {
                           ^1
 2840|     60|                let path = temp_dir.path().join(format!("file{}.md", i));
 2841|     60|                std::fs::write(&path, format!("# File {}", i)).unwrap();
 2842|     60|                path
 2843|     60|            })
 2844|      1|            .collect();
 2845|       |
 2846|      1|        app.handle_file_drop(files);
 2847|       |
 2848|      1|        assert!(app.error_message.is_some());
 2849|      1|        assert!(app
 2850|      1|            .error_message
 2851|      1|            .as_ref()
 2852|      1|            .unwrap()
 2853|      1|            .contains("Too many files"));
 2854|      1|    }
 2855|       |
 2856|       |    #[test]
 2857|      1|    fn test_queue_navigation() -> Result<()> {
 2858|      1|        let mut app = MarkdownViewerApp::new();
 2859|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2860|       |
 2861|      1|        let file1 = temp_dir.path().join("file1.md");
 2862|      1|        let file2 = temp_dir.path().join("file2.md");
 2863|       |
 2864|      1|        std::fs::write(&file1, "# File 1")?;
                                                        ^0
 2865|      1|        std::fs::write(&file2, "# File 2")?;
                                                        ^0
 2866|       |
 2867|       |        // Load first file and queue second
 2868|      1|        app.load_file(file1.clone(), true)?;
                                                        ^0
 2869|      1|        app.pending_files.push_back(file2.clone());
 2870|       |
 2871|      1|        assert!(app.can_navigate_forward());
 2872|      1|        app.navigate_forward();
 2873|      1|        assert_eq!(app.current_file, Some(file2));
 2874|      1|        assert!(app.pending_files.is_empty());
 2875|       |
 2876|      1|        Ok(())
 2877|      1|    }
 2878|       |
 2879|       |    #[test]
 2880|      1|    fn test_mixed_valid_invalid_files() -> Result<()> {
 2881|      1|        let mut app = MarkdownViewerApp::new();
 2882|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2883|       |
 2884|      1|        let md_file = temp_dir.path().join("test.md");
 2885|      1|        let pdf_file = temp_dir.path().join("test.pdf");
 2886|       |
 2887|      1|        std::fs::write(&md_file, "# Test")?;
                                                        ^0
 2888|      1|        std::fs::write(&pdf_file, "fake pdf")?;
                                                           ^0
 2889|       |
 2890|      1|        app.handle_file_drop(vec![md_file.clone(), pdf_file]);
 2891|       |
 2892|       |        // Should open the valid markdown file
 2893|      1|        assert_eq!(app.current_file, Some(md_file));
 2894|       |        // Should show error about the invalid file
 2895|      1|        assert!(app.error_message.is_some());
 2896|      1|        Ok(())
 2897|      1|    }
 2898|       |
 2899|       |    #[test]
 2900|      1|    fn test_empty_directory_drop() -> Result<()> {
 2901|      1|        let mut app = MarkdownViewerApp::new();
 2902|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2903|       |
 2904|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 2905|       |
 2906|      1|        assert!(app.error_message.is_some());
 2907|      1|        assert!(app
 2908|      1|            .error_message
 2909|      1|            .as_ref()
 2910|      1|            .unwrap()
 2911|      1|            .contains("No markdown files"));
 2912|      1|        Ok(())
 2913|      1|    }
 2914|       |
 2915|       |    #[test]
 2916|      1|    fn test_open_file_dialog_stub_sets_error() {
 2917|      1|        let mut app = MarkdownViewerApp::new();
 2918|      1|        app.open_file_dialog();
 2919|      1|        assert_eq!(
 2920|      1|            app.error_message.as_deref(),
 2921|       |            Some("File dialog disabled in tests")
 2922|       |        );
 2923|      1|    }
 2924|       |
 2925|       |    #[test]
 2926|      1|    fn test_prompt_save_path_stub_returns_none() {
 2927|      1|        let app = MarkdownViewerApp::new();
 2928|      1|        assert!(app.prompt_save_path().is_none());
 2929|      1|    }
 2930|       |
 2931|       |    #[test]
 2932|      1|    fn test_save_current_document_writes_file() -> Result<()> {
 2933|      1|        let mut app = MarkdownViewerApp::new();
 2934|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2935|      1|        let file_path = temp_dir.path().join("doc.md");
 2936|      1|        app.current_file = Some(file_path.clone());
 2937|      1|        app.current_content = "Hello world".to_string();
 2938|       |
 2939|      1|        app.save_current_document()?;
                                                 ^0
 2940|      1|        let saved = std::fs::read_to_string(&file_path)?;
                                                                     ^0
 2941|      1|        assert_eq!(saved, "Hello world");
 2942|      1|        Ok(())
 2943|      1|    }
 2944|       |
 2945|       |    #[test]
 2946|      1|    fn test_render_menu_and_context_helpers() {
 2947|      1|        let mut app = MarkdownViewerApp::new();
 2948|      1|        app.current_content = "content".to_string();
 2949|      1|        app.current_file = Some(PathBuf::from("doc.md"));
 2950|      1|        app.history = vec![
 2951|      1|            HistoryEntry {
 2952|      1|                file_path: None,
 2953|      1|                title: "first".to_string(),
 2954|      1|                content: "one".to_string(),
 2955|      1|            },
 2956|      1|            HistoryEntry {
 2957|      1|                file_path: None,
 2958|      1|                title: "second".to_string(),
 2959|      1|                content: "two".to_string(),
 2960|      1|            },
 2961|       |        ];
 2962|      1|        app.history_index = 1;
 2963|       |
 2964|      1|        with_test_ui(|ctx, ui| {
 2965|      1|            app.render_file_menu(ui, false, Color32::WHITE);
 2966|      1|            app.render_view_menu(ui, ctx, false, Color32::WHITE);
 2967|      1|            app.render_help_menu(ui);
 2968|      1|            app.render_main_context_menu(ui);
 2969|      1|        });
 2970|      1|    }
 2971|       |
 2972|       |    #[test]
 2973|      1|    fn test_update_inner_rendered_mode_smoke() {
 2974|      1|        let mut app = MarkdownViewerApp::new();
 2975|      1|        app.load_content("# Title\n\nParagraph text", Some("Doc".to_string()));
 2976|      1|        app.pending_scroll_to_element = Some(0);
 2977|      1|        app.nav_request = Some(NavigationRequest::Top);
 2978|      1|        app.show_search = true;
 2979|      1|        app.search_query = "Paragraph".to_string();
 2980|       |
 2981|      1|        run_update(&mut app, test_input());
 2982|      1|        assert!(app.pending_scroll_to_element.is_none());
 2983|      1|    }
 2984|       |
 2985|       |    #[test]
 2986|      1|    fn test_update_inner_raw_mode_smoke() {
 2987|      1|        let mut app = MarkdownViewerApp::new();
 2988|      1|        app.load_content("Line1\nLine2\nLine3\n", Some("Doc".to_string()));
 2989|      1|        app.view_mode = ViewMode::Raw;
 2990|      1|        app.write_enabled = true;
 2991|      1|        app.raw_buffer = app.current_content.clone();
 2992|      1|        app.raw_cursor = Some(0);
 2993|      1|        app.raw_focus_requested = true;
 2994|       |
 2995|      1|        run_update(&mut app, test_input());
 2996|       |
 2997|      1|        app.pending_raw_cursor_line_move = Some(1);
 2998|      1|        run_update(&mut app, test_input());
 2999|      1|    }
 3000|       |
 3001|       |    #[test]
 3002|      1|    fn test_handle_shortcuts_save_and_flags() -> Result<()> {
 3003|      1|        let mut app = MarkdownViewerApp::new();
 3004|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3005|      1|        let file_path = temp_dir.path().join("save.md");
 3006|      1|        app.current_file = Some(file_path.clone());
 3007|      1|        app.current_content = "Saved content".to_string();
 3008|       |
 3009|      1|        let mut input = test_input();
 3010|      1|        input.events = vec![
 3011|      1|            egui::Event::Key {
 3012|      1|                key: egui::Key::F,
 3013|      1|                physical_key: None,
 3014|      1|                pressed: true,
 3015|      1|                modifiers: egui::Modifiers::CTRL,
 3016|      1|                repeat: false,
 3017|      1|            },
 3018|      1|            egui::Event::Key {
 3019|      1|                key: egui::Key::R,
 3020|      1|                physical_key: None,
 3021|      1|                pressed: true,
 3022|      1|                modifiers: egui::Modifiers::CTRL,
 3023|      1|                repeat: false,
 3024|      1|            },
 3025|      1|            egui::Event::Key {
 3026|      1|                key: egui::Key::E,
 3027|      1|                physical_key: None,
 3028|      1|                pressed: true,
 3029|      1|                modifiers: egui::Modifiers::CTRL,
 3030|      1|                repeat: false,
 3031|      1|            },
 3032|      1|            egui::Event::Key {
 3033|      1|                key: egui::Key::S,
 3034|      1|                physical_key: None,
 3035|      1|                pressed: true,
 3036|      1|                modifiers: egui::Modifiers::CTRL,
 3037|      1|                repeat: false,
 3038|      1|            },
 3039|      1|            egui::Event::Key {
 3040|      1|                key: egui::Key::F11,
 3041|      1|                physical_key: None,
 3042|      1|                pressed: true,
 3043|      1|                modifiers: egui::Modifiers::NONE,
 3044|      1|                repeat: false,
 3045|      1|            },
 3046|      1|            egui::Event::Key {
 3047|      1|                key: egui::Key::F5,
 3048|      1|                physical_key: None,
 3049|      1|                pressed: true,
 3050|      1|                modifiers: egui::Modifiers::NONE,
 3051|      1|                repeat: false,
 3052|      1|            },
 3053|      1|            egui::Event::Key {
 3054|      1|                key: egui::Key::PageUp,
 3055|      1|                physical_key: None,
 3056|      1|                pressed: true,
 3057|      1|                modifiers: egui::Modifiers::NONE,
 3058|      1|                repeat: false,
 3059|      1|            },
 3060|      1|            egui::Event::Key {
 3061|      1|                key: egui::Key::ArrowDown,
 3062|      1|                physical_key: None,
 3063|      1|                pressed: true,
 3064|      1|                modifiers: egui::Modifiers::NONE,
 3065|      1|                repeat: false,
 3066|      1|            },
 3067|       |        ];
 3068|       |
 3069|      1|        let ctx = egui::Context::default();
 3070|      1|        ctx.begin_frame(input);
 3071|      1|        app.handle_shortcuts(&ctx);
 3072|      1|        let _ = ctx.end_frame();
 3073|       |
 3074|      1|        assert!(app.show_search);
 3075|      1|        assert!(app.view_toggle_requested);
 3076|      1|        assert!(app.write_toggle_requested);
 3077|      1|        assert!(app.toggle_fullscreen);
 3078|      1|        assert!(app.reload_requested);
 3079|      1|        assert!(app.nav_request.is_some());
 3080|       |
 3081|      1|        let saved = std::fs::read_to_string(&file_path)?;
                                                                     ^0
 3082|      1|        assert_eq!(saved, "Saved content");
 3083|      1|        Ok(())
 3084|      1|    }
 3085|       |
 3086|       |    #[test]
 3087|      1|    fn test_handle_shortcuts_open_and_close() {
 3088|      1|        let mut app = MarkdownViewerApp::new();
 3089|      1|        app.load_content("Content", Some("Doc".to_string()));
 3090|       |
 3091|      1|        let mut input = test_input();
 3092|      1|        input.events = vec![
 3093|      1|            egui::Event::Key {
 3094|      1|                key: egui::Key::O,
 3095|      1|                physical_key: None,
 3096|      1|                pressed: true,
 3097|      1|                modifiers: egui::Modifiers::CTRL,
 3098|      1|                repeat: false,
 3099|      1|            },
 3100|      1|            egui::Event::Key {
 3101|      1|                key: egui::Key::O,
 3102|      1|                physical_key: None,
 3103|      1|                pressed: true,
 3104|      1|                modifiers: egui::Modifiers::ALT,
 3105|      1|                repeat: false,
 3106|      1|            },
 3107|      1|            egui::Event::Key {
 3108|      1|                key: egui::Key::W,
 3109|      1|                physical_key: None,
 3110|      1|                pressed: true,
 3111|      1|                modifiers: egui::Modifiers::CTRL,
 3112|      1|                repeat: false,
 3113|      1|            },
 3114|      1|            egui::Event::Key {
 3115|      1|                key: egui::Key::W,
 3116|      1|                physical_key: None,
 3117|      1|                pressed: true,
 3118|      1|                modifiers: egui::Modifiers::ALT,
 3119|      1|                repeat: false,
 3120|      1|            },
 3121|       |        ];
 3122|       |
 3123|      1|        let ctx = egui::Context::default();
 3124|      1|        ctx.begin_frame(input);
 3125|      1|        app.handle_shortcuts(&ctx);
 3126|      1|        let _ = ctx.end_frame();
 3127|       |
 3128|      1|        assert!(app.current_file.is_none());
 3129|      1|    }
 3130|       |
 3131|       |    #[test]
 3132|      1|    fn test_handle_shortcuts_ctrl_mousewheel_zoom() {
 3133|      1|        let mut app = MarkdownViewerApp::new();
 3134|      1|        let original = app.renderer.font_sizes().body;
 3135|       |
 3136|      1|        let mut input = test_input();
 3137|      1|        input.modifiers = egui::Modifiers::CTRL;
 3138|      1|        input.events = vec![egui::Event::MouseWheel {
 3139|      1|            unit: egui::MouseWheelUnit::Point,
 3140|      1|            delta: egui::vec2(0.0, 1.0),
 3141|      1|            modifiers: egui::Modifiers::CTRL,
 3142|      1|        }];
 3143|       |
 3144|      1|        let ctx = egui::Context::default();
 3145|      1|        ctx.begin_frame(input);
 3146|      1|        app.handle_shortcuts(&ctx);
 3147|      1|        let _ = ctx.end_frame();
 3148|       |
 3149|      1|        assert!(app.renderer.font_sizes().body > original);
 3150|      1|    }
 3151|       |
 3152|       |    #[test]
 3153|      1|    fn test_handle_shortcuts_raw_edit_page_navigation() {
 3154|      1|        let mut app = MarkdownViewerApp::new();
 3155|      1|        app.view_mode = ViewMode::Raw;
 3156|      1|        app.write_enabled = true;
 3157|       |
 3158|      1|        let mut input = test_input();
 3159|      1|        input.events = vec![egui::Event::Key {
 3160|      1|            key: egui::Key::PageDown,
 3161|      1|            physical_key: None,
 3162|      1|            pressed: true,
 3163|      1|            modifiers: egui::Modifiers::NONE,
 3164|      1|            repeat: false,
 3165|      1|        }];
 3166|       |
 3167|      1|        let ctx = egui::Context::default();
 3168|      1|        ctx.begin_frame(input);
 3169|      1|        app.handle_shortcuts(&ctx);
 3170|      1|        let _ = ctx.end_frame();
 3171|       |
 3172|      1|        assert_eq!(app.pending_raw_cursor_line_move, Some(24));
 3173|      1|    }
 3174|       |
 3175|       |    #[test]
 3176|      1|    fn test_handle_drag_drop_events_and_overlay() -> Result<()> {
 3177|      1|        let mut app = MarkdownViewerApp::new();
 3178|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3179|      1|        let file_path = temp_dir.path().join("drop.md");
 3180|      1|        std::fs::write(&file_path, "# Temp")?;
                                                          ^0
 3181|       |
 3182|      1|        let mut input = test_input();
 3183|      1|        input.hovered_files = vec![egui::HoveredFile {
 3184|      1|            path: Some(file_path.clone()),
 3185|      1|            ..Default::default()
 3186|      1|        }];
 3187|      1|        input.dropped_files = vec![egui::DroppedFile {
 3188|      1|            path: Some(file_path.clone()),
 3189|      1|            ..Default::default()
 3190|      1|        }];
 3191|       |
 3192|      1|        let ctx = egui::Context::default();
 3193|      1|        ctx.begin_frame(input);
 3194|      1|        app.handle_drag_drop_events(&ctx);
 3195|      1|        app.render_drag_overlay(&ctx);
 3196|      1|        let _ = ctx.end_frame();
 3197|       |
 3198|      1|        assert!(app.drag_hover);
 3199|      1|        assert_eq!(app.current_file, Some(file_path));
 3200|      1|        Ok(())
 3201|      1|    }
 3202|       |
 3203|       |    #[test]
 3204|      1|    fn test_render_status_bar_smoke() {
 3205|      1|        let mut app = MarkdownViewerApp::new();
 3206|      1|        app.load_content("Body text", Some("Doc".to_string()));
 3207|      1|        app.pending_files.push_back(PathBuf::from("next.md"));
 3208|       |
 3209|      1|        let ctx = egui::Context::default();
 3210|      1|        ctx.begin_frame(test_input());
 3211|      1|        app.render_status_bar(&ctx);
 3212|      1|        let _ = ctx.end_frame();
 3213|      1|    }
 3214|       |
 3215|       |    #[test]
 3216|      1|    fn test_toggle_write_mode_captures_cursor_and_focus() {
 3217|      1|        let mut app = MarkdownViewerApp::new();
 3218|      1|        app.view_mode = ViewMode::Raw;
 3219|      1|        app.write_enabled = true;
 3220|      1|        app.raw_buffer = "Line1\nLine2\n".to_string();
 3221|       |
 3222|      1|        let ctx = egui::Context::default();
 3223|      1|        ctx.begin_frame(test_input());
 3224|      1|        let editor_id = egui::Id::new("raw_editor");
 3225|      1|        let mut state = egui::text_edit::TextEditState::default();
 3226|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(3));
 3227|      1|        state.cursor.set_char_range(Some(cr));
 3228|      1|        state.store(&ctx, editor_id);
 3229|       |
 3230|      1|        app.toggle_write_mode(&ctx);
 3231|      1|        let _ = ctx.end_frame();
 3232|       |
 3233|      1|        assert!(!app.write_enabled);
 3234|      1|        assert_eq!(app.raw_cursor, Some(3));
 3235|       |
 3236|      1|        app.write_enabled = false;
 3237|      1|        app.raw_focus_requested = false;
 3238|      1|        app.toggle_write_mode(&ctx);
 3239|       |
 3240|      1|        assert!(app.write_enabled);
 3241|      1|        assert!(app.raw_focus_requested);
 3242|      1|    }
 3243|       |
 3244|       |    #[test]
 3245|      1|    fn test_move_raw_cursor_lines_up_and_down() {
 3246|      1|        let mut app = MarkdownViewerApp::new();
 3247|      1|        app.view_mode = ViewMode::Raw;
 3248|      1|        app.write_enabled = true;
 3249|      1|        app.raw_buffer = "one\ntwo\nthree\nfour".to_string();
 3250|       |
 3251|      1|        let ctx = egui::Context::default();
 3252|      1|        ctx.begin_frame(test_input());
 3253|      1|        let editor_id = egui::Id::new("raw_editor");
 3254|      1|        let mut state = egui::text_edit::TextEditState::default();
 3255|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(4));
 3256|      1|        state.cursor.set_char_range(Some(cr));
 3257|      1|        state.store(&ctx, editor_id);
 3258|       |
 3259|      1|        app.move_raw_cursor_lines(&ctx, -1);
 3260|      1|        let first = app.raw_cursor;
 3261|      1|        app.move_raw_cursor_lines(&ctx, 2);
 3262|      1|        let second = app.raw_cursor;
 3263|      1|        let _ = ctx.end_frame();
 3264|       |
 3265|      1|        assert!(first.is_some());
 3266|      1|        assert!(second.is_some());
 3267|      1|        assert!(app.raw_focus_requested);
 3268|      1|    }
 3269|       |
 3270|       |    #[test]
 3271|      1|    fn test_find_next_previous_wraps() {
 3272|      1|        let mut app = MarkdownViewerApp::new();
 3273|      1|        app.parsed_elements = vec![
 3274|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("alpha".to_string())]),
 3275|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("beta".to_string())]),
 3276|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("gamma".to_string())]),
 3277|       |        ];
 3278|       |
 3279|      1|        app.search_query = "beta".to_string();
 3280|      1|        app.find_next();
 3281|      1|        assert_eq!(app.last_match_index, Some(1));
 3282|      1|        assert_eq!(app.pending_scroll_to_element, Some(1));
 3283|       |
 3284|      1|        app.search_query.clear();
 3285|      1|        app.last_query = "gamma".to_string();
 3286|      1|        app.last_match_index = Some(0);
 3287|      1|        app.pending_scroll_to_element = None;
 3288|      1|        app.find_next();
 3289|      1|        assert_eq!(app.last_match_index, Some(2));
 3290|       |
 3291|      1|        app.search_query = "alpha".to_string();
 3292|      1|        app.last_match_index = Some(0);
 3293|      1|        app.find_previous();
 3294|      1|        assert_eq!(app.last_match_index, Some(0));
 3295|      1|    }
 3296|       |
 3297|       |    #[test]
 3298|      1|    fn test_clear_search_state_resets_fields() {
 3299|      1|        let mut app = MarkdownViewerApp::new();
 3300|      1|        app.search_query = "Query".to_string();
 3301|      1|        app.last_query = "Last".to_string();
 3302|      1|        app.last_match_index = Some(2);
 3303|      1|        app.pending_scroll_to_element = Some(1);
 3304|      1|        app.renderer.set_highlight_phrase(Some("Query"));
 3305|       |
 3306|      1|        app.clear_search_state();
 3307|       |
 3308|      1|        assert!(app.search_query.is_empty());
 3309|      1|        assert!(app.last_query.is_empty());
 3310|      1|        assert!(app.last_match_index.is_none());
 3311|      1|        assert!(app.pending_scroll_to_element.is_none());
 3312|      1|    }
 3313|       |
 3314|       |    #[test]
 3315|      1|    fn test_render_file_menu_forced_actions() -> Result<()> {
 3316|      1|        let mut app = MarkdownViewerApp::new();
 3317|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3318|      1|        let file_path = temp_dir.path().join("doc.md");
 3319|      1|        std::fs::write(&file_path, "old")?;
                                                       ^0
 3320|      1|        app.current_file = Some(file_path.clone());
 3321|      1|        app.current_content = "new content".to_string();
 3322|       |
 3323|       |        {
 3324|      1|            let _guard = ForcedActions::new(&[
 3325|      1|                "file_open",
 3326|      1|                "file_save",
 3327|      1|                "file_reload",
 3328|      1|                "file_find",
 3329|      1|            ]);
 3330|      1|            with_test_ui(|_ctx, ui| {
 3331|      1|                app.render_file_menu(ui, false, Color32::WHITE);
 3332|      1|            });
 3333|       |        }
 3334|       |
 3335|      1|        assert!(app.error_message.is_some());
 3336|      1|        assert!(app.reload_requested);
 3337|      1|        assert!(app.show_search);
 3338|      1|        assert!(app.search_focus_requested);
 3339|      1|        let saved = std::fs::read_to_string(&file_path)?;
                                                                     ^0
 3340|      1|        assert_eq!(saved, "new content");
 3341|       |
 3342|       |        {
 3343|      1|            let _guard = ForcedActions::new(&["file_close"]);
 3344|      1|            with_test_ui(|_ctx, ui| {
 3345|      1|                app.render_file_menu(ui, false, Color32::WHITE);
 3346|      1|            });
 3347|       |        }
 3348|       |
 3349|      1|        assert!(app.current_file.is_none());
 3350|      1|        Ok(())
 3351|      1|    }
 3352|       |
 3353|       |    #[test]
 3354|      1|    fn test_render_file_menu_samples_forced() {
 3355|      1|        let mut app = MarkdownViewerApp::new();
 3356|      1|        let _guard = ForcedActions::new(&["file_samples_menu", "file_sample"]);
 3357|      1|        with_test_ui(|_ctx, ui| {
 3358|      1|            app.render_file_menu(ui, false, Color32::WHITE);
 3359|      1|        });
 3360|       |
 3361|      1|        let sample = SAMPLE_FILES
 3362|      1|            .iter()
 3363|      1|            .find(|sample| sample.name == "welcome.md")
 3364|      1|            .expect("welcome sample");
 3365|      1|        assert_eq!(app.current_content, sample.content);
 3366|      1|    }
 3367|       |
 3368|       |    #[test]
 3369|      1|    fn test_render_view_menu_forced_actions() -> Result<()> {
 3370|      1|        let mut app = MarkdownViewerApp::new();
 3371|      1|        app.load_content("Body", Some("Doc".to_string()));
 3372|      1|        app.history = vec![
 3373|      1|            HistoryEntry {
 3374|      1|                file_path: None,
 3375|      1|                title: "first".to_string(),
 3376|      1|                content: "one".to_string(),
 3377|      1|            },
 3378|      1|            HistoryEntry {
 3379|      1|                file_path: None,
 3380|      1|                title: "second".to_string(),
 3381|      1|                content: "two".to_string(),
 3382|      1|            },
 3383|       |        ];
 3384|      1|        app.history_index = 1;
 3385|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3386|      1|        let next_path = temp_dir.path().join("next.md");
 3387|      1|        std::fs::write(&next_path, "Next")?;
                                                        ^0
 3388|      1|        app.pending_files.push_back(next_path);
 3389|       |
 3390|      1|        let _guard = ForcedActions::new(&[
 3391|      1|            "view_back",
 3392|      1|            "view_forward",
 3393|      1|            "view_raw",
 3394|      1|            "view_write",
 3395|      1|            "view_wrap_raw",
 3396|      1|            "view_table_wrap",
 3397|      1|            "view_zoom_in",
 3398|      1|            "view_zoom_out",
 3399|      1|            "view_zoom_reset",
 3400|      1|            "view_fullscreen",
 3401|      1|        ]);
 3402|      1|        with_test_ui(|ctx, ui| {
 3403|      1|            app.render_view_menu(ui, ctx, false, Color32::WHITE);
 3404|      1|        });
 3405|       |
 3406|      1|        assert!(matches!(app.view_mode, ViewMode::Raw));
                              ^0
 3407|      1|        assert!(app.write_enabled);
 3408|      1|        assert!(app.wrap_raw);
 3409|      1|        assert!(!app.table_wrap_overhaul_enabled);
 3410|      1|        assert!(app.current_file.is_some());
 3411|      1|        Ok(())
 3412|      1|    }
 3413|       |
 3414|       |    #[test]
 3415|      1|    fn test_render_help_menu_forced_actions() {
 3416|      1|        let mut app = MarkdownViewerApp::new();
 3417|      1|        let _guard = ForcedActions::new(&["help_usage", "help_about"]);
 3418|      1|        with_test_ui(|_ctx, ui| {
 3419|      1|            app.render_help_menu(ui);
 3420|      1|        });
 3421|       |
 3422|      1|        let welcome = SAMPLE_FILES
 3423|      1|            .iter()
 3424|      1|            .find(|sample| sample.name == "welcome.md")
 3425|      1|            .expect("welcome sample");
 3426|      1|        assert_eq!(app.current_content, welcome.content);
 3427|      1|    }
 3428|       |
 3429|       |    #[test]
 3430|      1|    fn test_render_main_context_menu_forced_actions() {
 3431|      1|        let mut app = MarkdownViewerApp::new();
 3432|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 3433|      1|            "Alpha".to_string(),
 3434|      1|        )])];
 3435|      1|        app.current_content = "Alpha".to_string();
 3436|       |
 3437|      1|        let _guard = ForcedActions::new(&[
 3438|      1|            "context_copy_all",
 3439|      1|            "context_copy_markdown",
 3440|      1|            "context_top",
 3441|      1|            "context_bottom",
 3442|      1|        ]);
 3443|      1|        with_test_ui(|_ctx, ui| {
 3444|      1|            app.render_main_context_menu(ui);
 3445|      1|        });
 3446|       |
 3447|      1|        assert!(matches!(app.nav_request, Some(NavigationRequest::Bottom)));
                              ^0
 3448|      1|    }
 3449|       |
 3450|       |    #[test]
 3451|      1|    fn test_render_search_dialog_forced_actions() {
 3452|      1|        let mut app = MarkdownViewerApp::new();
 3453|      1|        app.parsed_elements = vec![
 3454|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("alpha beta".to_string())]),
 3455|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("gamma".to_string())]),
 3456|       |        ];
 3457|      1|        app.show_search = true;
 3458|      1|        app.search_focus_requested = true;
 3459|       |
 3460|      1|        let ctx = egui::Context::default();
 3461|      1|        run_frame(&ctx, test_input(), |ctx| {
 3462|      1|            app.render_search_dialog(ctx);
 3463|      1|        });
 3464|       |
 3465|      1|        let mut input = test_input();
 3466|      1|        input.events = vec![egui::Event::Text("beta".to_string())];
 3467|      1|        let _guard = ForcedActions::new(&["search_submit", "search_next", "search_prev"]);
 3468|      1|        run_frame(&ctx, input, |ctx| {
 3469|      1|            app.render_search_dialog(ctx);
 3470|      1|        });
 3471|       |
 3472|      1|        assert!(app.last_match_index.is_some());
 3473|       |
 3474|      1|        app.show_search = true;
 3475|      1|        let _guard = ForcedActions::new(&["search_close"]);
 3476|      1|        run_frame(&ctx, test_input(), |ctx| {
 3477|      1|            app.render_search_dialog(ctx);
 3478|      1|        });
 3479|       |
 3480|      1|        assert!(!app.show_search);
 3481|      1|        assert!(app.search_query.is_empty());
 3482|      1|    }
 3483|       |
 3484|       |    #[test]
 3485|      1|    fn test_update_inner_welcome_open() {
 3486|      1|        let mut app = MarkdownViewerApp::new();
 3487|      1|        app.current_content.clear();
 3488|      1|        app.parsed_elements.clear();
 3489|      1|        app.error_message = None;
 3490|      1|        let _guard = ForcedActions::new(&["welcome_open"]);
 3491|      1|        run_update(&mut app, test_input());
 3492|       |
 3493|      1|        assert!(app.error_message.is_some());
 3494|      1|    }
 3495|       |
 3496|       |    #[test]
 3497|      1|    fn test_update_inner_deferred_actions_and_window_adjustment() -> Result<()> {
 3498|      1|        let mut app = MarkdownViewerApp::new();
 3499|      1|        app.raw_buffer = "one\ntwo\nthree\n".to_string();
 3500|      1|        app.current_content = app.raw_buffer.clone();
 3501|      1|        app.pending_raw_cursor_line_move = Some(1);
 3502|      1|        app.toggle_fullscreen = true;
 3503|      1|        app.view_toggle_requested = true;
 3504|      1|        app.write_toggle_requested = true;
 3505|      1|        app.reload_requested = true;
 3506|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3507|      1|        app.current_file = Some(temp_dir.path().join("missing.md"));
 3508|      1|        app.last_persist_instant = std::time::Instant::now() - Duration::from_secs(2);
 3509|      1|        app.last_persisted_state = None;
 3510|       |
 3511|      1|        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());
 3512|       |
 3513|      1|        let outer = egui::Rect::from_min_size(egui::pos2(-50.0, -50.0), egui::vec2(100.0, 100.0));
 3514|      1|        let inner = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 150.0));
 3515|      1|        let input = test_input_with_viewport(
 3516|      1|            Some(outer),
 3517|      1|            Some(inner),
 3518|      1|            Some(egui::vec2(800.0, 600.0)),
 3519|      1|            Some(false),
 3520|      1|            Some(false),
 3521|       |        );
 3522|       |
 3523|      1|        let ctx = egui::Context::default();
 3524|      1|        ctx.begin_frame(input);
 3525|      1|        let editor_id = egui::Id::new("raw_editor");
 3526|      1|        let mut state = egui::text_edit::TextEditState::default();
 3527|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(2));
 3528|      1|        state.cursor.set_char_range(Some(cr));
 3529|      1|        state.store(&ctx, editor_id);
 3530|       |
 3531|      1|        app.update_inner(&ctx);
 3532|      1|        let _ = ctx.end_frame();
 3533|       |
 3534|      1|        assert!(app.last_window_pos.is_some());
 3535|      1|        assert!(app.last_window_size.is_some());
 3536|      1|        assert!(app.error_message.is_some());
 3537|      1|        assert!(matches!(app.view_mode, ViewMode::Raw));
                              ^0
 3538|      1|        assert!(app.write_enabled);
 3539|      1|        assert!(app.raw_cursor.is_some());
 3540|      1|        assert!(app.last_persisted_state.is_some());
 3541|      1|        Ok(())
 3542|      1|    }
 3543|       |
 3544|       |    #[test]
 3545|      1|    fn test_update_inner_window_no_adjustment() {
 3546|      1|        let mut app = MarkdownViewerApp::new();
 3547|      1|        app.load_content("Body", Some("Doc".to_string()));
 3548|       |
 3549|      1|        let outer = egui::Rect::from_min_size(egui::pos2(10.0, 10.0), egui::vec2(900.0, 600.0));
 3550|      1|        let inner = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(900.0, 600.0));
 3551|      1|        let input = test_input_with_viewport(
 3552|      1|            Some(outer),
 3553|      1|            Some(inner),
 3554|      1|            Some(egui::vec2(1024.0, 768.0)),
 3555|      1|            Some(false),
 3556|      1|            Some(true),
 3557|       |        );
 3558|       |
 3559|      1|        let ctx = egui::Context::default();
 3560|      1|        ctx.begin_frame(input);
 3561|      1|        app.update_inner(&ctx);
 3562|      1|        let _ = ctx.end_frame();
 3563|       |
 3564|      1|        assert_eq!(app.last_window_pos, Some([10.0, 10.0]));
 3565|      1|        assert_eq!(app.last_window_size, Some([900.0, 600.0]));
 3566|      1|        assert!(app.last_window_maximized);
 3567|      1|    }
 3568|       |
 3569|       |    #[test]
 3570|      1|    fn test_update_inner_rendered_highlight_and_scroll() {
 3571|      1|        let mut app = MarkdownViewerApp::new();
 3572|      1|        app.load_content("# Title\n\nParagraph text", Some("Doc".to_string()));
 3573|      1|        app.show_search = true;
 3574|      1|        app.search_query = "Paragraph".to_string();
 3575|       |
 3576|      1|        run_update(&mut app, test_input());
 3577|       |
 3578|      1|        app.show_search = false;
 3579|      1|        app.last_query = "Paragraph".to_string();
 3580|      1|        app.pending_scroll_to_element = Some(0);
 3581|      1|        app.renderer.trigger_link("#title");
 3582|      1|        app.error_message = Some("Error".to_string());
 3583|       |
 3584|      1|        run_update(&mut app, test_input());
 3585|       |
 3586|      1|        assert!(app.pending_scroll_to_element.is_none());
 3587|      1|    }
 3588|       |
 3589|       |    #[test]
 3590|      1|    fn test_update_inner_nav_requests() {
 3591|      1|        let mut app = MarkdownViewerApp::new();
 3592|      1|        app.load_content("Line1\nLine2\nLine3", Some("Doc".to_string()));
 3593|       |
 3594|      1|        let navs = [
 3595|      1|            NavigationRequest::Top,
 3596|      1|            NavigationRequest::Bottom,
 3597|      1|            NavigationRequest::PageUp,
 3598|      1|            NavigationRequest::PageDown,
 3599|      1|            NavigationRequest::ScrollUp,
 3600|      1|            NavigationRequest::ScrollDown,
 3601|      1|        ];
 3602|      7|        for nav in navs {
                          ^6
 3603|      6|            app.nav_request = Some(nav);
 3604|      6|            run_update(&mut app, test_input());
 3605|      6|        }
 3606|      1|    }
 3607|       |
 3608|       |    #[test]
 3609|      1|    fn test_update_inner_raw_editing_updates_buffer() {
 3610|      1|        let mut app = MarkdownViewerApp::new();
 3611|      1|        app.load_content("hello", Some("Doc".to_string()));
 3612|      1|        app.view_mode = ViewMode::Raw;
 3613|      1|        app.write_enabled = true;
 3614|      1|        app.raw_cursor = Some(0);
 3615|      1|        app.raw_focus_requested = true;
 3616|       |
 3617|      1|        let ctx = egui::Context::default();
 3618|      1|        run_frame(&ctx, test_input(), |ctx| {
 3619|      1|            app.update_inner(ctx);
 3620|      1|        });
 3621|       |
 3622|      1|        let mut input = test_input();
 3623|      1|        input.events = vec![egui::Event::Text("x".to_string())];
 3624|      1|        run_frame(&ctx, input, |ctx| {
 3625|      1|            app.update_inner(ctx);
 3626|      1|        });
 3627|       |
 3628|      1|        assert!(app.raw_buffer.contains('x'));
 3629|      1|        assert!(app.current_content.contains('x'));
 3630|      1|    }
 3631|       |
 3632|       |    #[test]
 3633|      1|    fn test_update_inner_raw_editing_without_state() {
 3634|      1|        let mut app = MarkdownViewerApp::new();
 3635|      1|        app.view_mode = ViewMode::Raw;
 3636|      1|        app.write_enabled = true;
 3637|      1|        app.raw_buffer = "hello".to_string();
 3638|      1|        app.current_content = app.raw_buffer.clone();
 3639|      1|        app.raw_cursor = Some(1);
 3640|       |
 3641|      1|        let ctx = egui::Context::default();
 3642|      1|        ctx.begin_frame(test_input());
 3643|      1|        app.update_inner(&ctx);
 3644|      1|        let _ = ctx.end_frame();
 3645|       |
 3646|      1|        assert!(app.raw_cursor.is_some());
 3647|      1|    }
 3648|       |
 3649|       |    #[test]
 3650|      1|    fn test_update_inner_raw_read_only() {
 3651|      1|        let mut app = MarkdownViewerApp::new();
 3652|      1|        app.view_mode = ViewMode::Raw;
 3653|      1|        app.write_enabled = false;
 3654|      1|        app.raw_buffer = "read only".to_string();
 3655|       |
 3656|      1|        run_update(&mut app, test_input());
 3657|      1|    }
 3658|       |}

C:\language\mdmdview\src\emoji_assets.rs:
    1|       |use egui::Color32 as C;
    2|       |
    3|       |// Draw simple vector fallback icons for a subset of emoji.
    4|      9|pub fn make_image(emoji: &str, size: usize) -> Option<egui::ColorImage> {
    5|      9|    let mut img = egui::ColorImage::new([size, size], C::TRANSPARENT);
    6|      9|    match emoji {
    7|      9|        "\u{2705}" => {
    8|      1|            draw_circle(&mut img, size, C::from_rgb(34, 139, 34));
    9|      1|            draw_check(&mut img, size, C::WHITE);
   10|      1|            Some(img)
   11|       |        }
   12|      8|        "\u{1f389}" => {
   13|      1|            draw_circle(&mut img, size, C::from_rgb(255, 215, 0));
   14|      1|            confetti(&mut img, size);
   15|      1|            Some(img)
   16|       |        }
   17|      7|        "\u{1f680}" => {
   18|      1|            draw_circle(&mut img, size, C::from_rgb(60, 60, 170));
   19|      1|            rocket(
   20|      1|                &mut img,
   21|      1|                size,
   22|      1|                C::from_rgb(230, 230, 230),
   23|      1|                C::from_rgb(255, 110, 60),
   24|       |            );
   25|      1|            Some(img)
   26|       |        }
   27|      6|        "\u{2764}" | "\u{1f496}" => {
                                   ^5
   28|      2|            heart(&mut img, size, C::from_rgb(220, 20, 60));
   29|      2|            Some(img)
   30|       |        }
   31|      4|        "\u{2b50}" => {
   32|      1|            star(&mut img, size, C::from_rgb(255, 215, 0));
   33|      1|            Some(img)
   34|       |        }
   35|      3|        "\u{1f525}" => {
   36|      1|            flame(&mut img, size);
   37|      1|            Some(img)
   38|       |        }
   39|      2|        _ => None,
   40|       |    }
   41|      9|}
   42|       |
   43|      3|fn draw_circle(img: &mut egui::ColorImage, size: usize, color: C) {
   44|      3|    let cx = (size as i32) / 2;
   45|      3|    let cy = cx;
   46|      3|    let r = (size as i32) / 2 - 2;
   47|     72|    for y in 0..size as i32 {
                              ^3
   48|  1.72k|        for x in 0..size as i32 {
                                  ^72
   49|  1.72k|            let dx = x - cx;
   50|  1.72k|            let dy = y - cy;
   51|  1.72k|            if dx * dx + dy * dy <= r * r {
   52|    951|                img[(x as usize, y as usize)] = color;
   53|    951|            }
                          ^777
   54|       |        }
   55|       |    }
   56|      3|}
   57|       |
   58|      1|fn draw_check(img: &mut egui::ColorImage, size: usize, color: C) {
   59|      1|    let s = size as i32;
   60|     40|    let mut plot = |x: i32, y: i32| {
                      ^1
   61|     40|        if x >= 0 && y >= 0 && x < s && y < s {
   62|     40|            img[(x as usize, y as usize)] = color;
   63|     40|        }
                      ^0
   64|     40|    };
   65|       |    // simple check mark
   66|      8|    for i in 0..s / 3 {
                              ^1
   67|      8|        plot(s / 3 - i, s * 2 / 3 + i);
   68|      8|        plot(s / 3 - i + 1, s * 2 / 3 + i);
   69|      8|    }
   70|     12|    for i in 0..s / 2 {
                              ^1
   71|     12|        plot(s / 3 + i, s * 2 / 3 - i);
   72|     12|        plot(s / 3 + i + 1, s * 2 / 3 - i);
   73|     12|    }
   74|      1|}
   75|       |
   76|      1|fn confetti(img: &mut egui::ColorImage, size: usize) {
   77|      1|    let dots = [
   78|      1|        C::from_rgb(255, 80, 80),
   79|      1|        C::from_rgb(80, 180, 255),
   80|      1|        C::from_rgb(120, 220, 120),
   81|      1|        C::from_rgb(220, 120, 220),
   82|      1|    ];
   83|      1|    let s = size as i32;
   84|      4|    for (i, col) in dots.iter().enumerate() {
                                  ^1   ^1     ^1
   85|      4|        let x = (s / 4) * ((i as i32) + 1);
   86|      4|        let y = (s / 5) * ((i as i32) + 1);
   87|      4|        if x < s && y < s {
                                  ^3
   88|      3|            img[(x as usize, y as usize)] = *col;
   89|      3|        }
                      ^1
   90|       |    }
   91|      1|}
   92|       |
   93|      1|fn rocket(img: &mut egui::ColorImage, size: usize, body: C, flame: C) {
   94|      1|    let s = size as i32;
   95|       |    // body
   96|     12|    for y in s / 4..s * 3 / 4 {
                           ^1     ^1
   97|     96|        for x in s / 3..s * 2 / 3 {
                               ^12    ^12
   98|     96|            img[(x as usize, y as usize)] = body;
   99|     96|        }
  100|       |    }
  101|       |    // nose
  102|      4|    for i in 0..s / 6 {
                              ^1
  103|     16|        for x in s / 2 - i..=s / 2 + i {
                               ^4          ^4
  104|     16|            let y = s / 4 - i;
  105|     16|            if y >= 0 {
  106|     16|                img[(x as usize, y as usize)] = body;
  107|     16|            }
                          ^0
  108|       |        }
  109|       |    }
  110|       |    // flame
  111|      4|    for i in 0..s / 6 {
                              ^1
  112|     16|        for x in s / 2 - i..=s / 2 + i {
                               ^4          ^4
  113|     16|            let y = s * 3 / 4 + i;
  114|     16|            if y < s {
  115|     16|                img[(x as usize, y as usize)] = flame;
  116|     16|            }
                          ^0
  117|       |        }
  118|       |    }
  119|      1|}
  120|       |
  121|      2|fn heart(img: &mut egui::ColorImage, size: usize, color: C) {
  122|      2|    let s = size as i32;
  123|     48|    for y in 0..s {
                              ^2
  124|  1.15k|        for x in 0..s {
                                  ^48
  125|  1.15k|            let dx = x - s / 2;
  126|  1.15k|            let dy = y - s / 3;
  127|  1.15k|            let a = (dx * dx + dy * dy - s * s / 16) < 0;
  128|  1.15k|            let b = x > s / 4 && x < 3 * s / 4 && y > s / 3 && y < s * 3 / 4;
                                               ^816             ^528         ^330
  129|  1.15k|            if a || b {
                                  ^934
  130|    318|                img[(x as usize, y as usize)] = color;
  131|    834|            }
  132|       |        }
  133|       |    }
  134|      2|}
  135|       |
  136|      1|fn star(img: &mut egui::ColorImage, size: usize, color: C) {
  137|      1|    let s = size as i32;
  138|     24|    for i in 0..s {
                              ^1
  139|     24|        let y = i;
  140|     24|        let x1 = s / 2;
  141|     24|        let x2 = s / 2 - i / 2;
  142|     24|        let x3 = s / 2 + i / 2;
  143|     24|        if x2 >= 0 {
  144|     24|            img[(x2 as usize, y as usize)] = color;
  145|     24|        }
                      ^0
  146|     24|        img[(x1 as usize, y as usize)] = color;
  147|     24|        if x3 < s {
  148|     24|            img[(x3 as usize, y as usize)] = color;
  149|     24|        }
                      ^0
  150|       |    }
  151|      1|}
  152|       |
  153|      1|fn flame(img: &mut egui::ColorImage, size: usize) {
  154|      1|    let s = size as i32;
  155|      1|    let base = C::from_rgb(255, 140, 0);
  156|      1|    let tip = C::from_rgb(255, 220, 120);
  157|     24|    for y in 0..s {
                              ^1
  158|    576|        for x in 0..s {
                                  ^24
  159|    576|            let dx = (x - s / 2) as f32 / (s as f32 / 3.5);
  160|    576|            let dy = (y - s) as f32 / (s as f32 / 1.5);
  161|    576|            let v = (dx * dx + dy * dy).sqrt();
  162|    576|            if v < 1.0 {
  163|    161|                let t = 1.0 - v;
  164|    161|                img[(x as usize, y as usize)] = C::from_rgb(
  165|    161|                    (base.r() as f32 * t + tip.r() as f32 * (1.0 - t)) as u8,
  166|    161|                    (base.g() as f32 * t + tip.g() as f32 * (1.0 - t)) as u8,
  167|    161|                    (base.b() as f32 * t + tip.b() as f32 * (1.0 - t)) as u8,
  168|    161|                );
  169|    415|            }
  170|       |        }
  171|       |    }
  172|      1|}
  173|       |
  174|       |#[cfg(test)]
  175|       |mod tests {
  176|       |    use super::*;
  177|       |
  178|      7|    fn has_non_transparent_pixel(img: &egui::ColorImage) -> bool {
  179|    587|        img.pixels.iter().any(|p| p.a() != 0)
                      ^7                ^7
  180|      7|    }
  181|       |
  182|       |    #[test]
  183|      1|    fn test_make_image_known_emojis_produce_pixels() {
  184|      1|        let emojis = [
  185|      1|            "\u{2705}",
  186|      1|            "\u{1f389}",
  187|      1|            "\u{1f680}",
  188|      1|            "\u{2764}",
  189|      1|            "\u{1f496}",
  190|      1|            "\u{2b50}",
  191|      1|            "\u{1f525}",
  192|      1|        ];
  193|       |
  194|      8|        for emoji in emojis {
                          ^7
  195|      7|            let img = make_image(emoji, 24).expect("expected fallback image");
  196|      7|            assert!(has_non_transparent_pixel(&img));
  197|       |        }
  198|      1|    }
  199|       |
  200|       |    #[test]
  201|      1|    fn test_make_image_unknown_returns_none() {
  202|      1|        assert!(make_image("\u{1f47d}", 24).is_none());
  203|      1|    }
  204|       |}

C:\language\mdmdview\src\emoji_catalog.rs:
    1|       |use std::collections::HashMap;
    2|       |
    3|       |// Return embedded emoji sprites keyed by real Unicode emoji characters.
    4|    339|pub fn image_bytes_for(emoji: &str) -> Option<&'static [u8]> {
    5|    339|    match emoji {
    6|    339|        "\u{1f389}" => Some(include_bytes!(concat!(
    7|      2|            env!("CARGO_MANIFEST_DIR"),
    8|      2|            "/assets/emoji/1f389.png"
    9|      2|        ))),
   10|    337|        "\u{2705}" => Some(include_bytes!(concat!(
   11|      1|            env!("CARGO_MANIFEST_DIR"),
   12|      1|            "/assets/emoji/2705.png"
   13|      1|        ))),
   14|    336|        "\u{1f680}" => Some(include_bytes!(concat!(
   15|      3|            env!("CARGO_MANIFEST_DIR"),
   16|      3|            "/assets/emoji/1f680.png"
   17|      3|        ))),
   18|    333|        "\u{1f642}" => Some(include_bytes!(concat!(
   19|      1|            env!("CARGO_MANIFEST_DIR"),
   20|      1|            "/assets/emoji/1f642.png"
   21|      1|        ))),
   22|    332|        "\u{1f600}" => Some(include_bytes!(concat!(
   23|      1|            env!("CARGO_MANIFEST_DIR"),
   24|      1|            "/assets/emoji/1f600.png"
   25|      1|        ))),
   26|    331|        "\u{1f609}" => Some(include_bytes!(concat!(
   27|      1|            env!("CARGO_MANIFEST_DIR"),
   28|      1|            "/assets/emoji/1f609.png"
   29|      1|        ))),
   30|    330|        "\u{2b50}" => Some(include_bytes!(concat!(
   31|      1|            env!("CARGO_MANIFEST_DIR"),
   32|      1|            "/assets/emoji/2b50.png"
   33|      1|        ))),
   34|    329|        "\u{1f525}" => Some(include_bytes!(concat!(
   35|      1|            env!("CARGO_MANIFEST_DIR"),
   36|      1|            "/assets/emoji/1f525.png"
   37|      1|        ))),
   38|    328|        "\u{1f44d}" => Some(include_bytes!(concat!(
   39|      1|            env!("CARGO_MANIFEST_DIR"),
   40|      1|            "/assets/emoji/1f44d.png"
   41|      1|        ))),
   42|    327|        "\u{1f44e}" => Some(include_bytes!(concat!(
   43|      1|            env!("CARGO_MANIFEST_DIR"),
   44|      1|            "/assets/emoji/1f44e.png"
   45|      1|        ))),
   46|    326|        "\u{1f4a1}" => Some(include_bytes!(concat!(
   47|      1|            env!("CARGO_MANIFEST_DIR"),
   48|      1|            "/assets/emoji/1f4a1.png"
   49|      1|        ))),
   50|    325|        "\u{2753}" => Some(include_bytes!(concat!(
   51|      1|            env!("CARGO_MANIFEST_DIR"),
   52|      1|            "/assets/emoji/2753.png"
   53|      1|        ))),
   54|    324|        "\u{2757}" => Some(include_bytes!(concat!(
   55|      1|            env!("CARGO_MANIFEST_DIR"),
   56|      1|            "/assets/emoji/2757.png"
   57|      1|        ))),
   58|    323|        "\u{1f4dd}" => Some(include_bytes!(concat!(
   59|      1|            env!("CARGO_MANIFEST_DIR"),
   60|      1|            "/assets/emoji/1f4dd.png"
   61|      1|        ))),
   62|    322|        "\u{1f9e0}" => Some(include_bytes!(concat!(
   63|      1|            env!("CARGO_MANIFEST_DIR"),
   64|      1|            "/assets/emoji/1f9e0.png"
   65|      1|        ))),
   66|    321|        "\u{1f9ea}" => Some(include_bytes!(concat!(
   67|      1|            env!("CARGO_MANIFEST_DIR"),
   68|      1|            "/assets/emoji/1f9ea.png"
   69|      1|        ))),
   70|    320|        "\u{1f4e6}" => Some(include_bytes!(concat!(
   71|      1|            env!("CARGO_MANIFEST_DIR"),
   72|      1|            "/assets/emoji/1f4e6.png"
   73|      1|        ))),
   74|    319|        "\u{1f527}" => Some(include_bytes!(concat!(
   75|      1|            env!("CARGO_MANIFEST_DIR"),
   76|      1|            "/assets/emoji/1f527.png"
   77|      1|        ))),
   78|    318|        _ => None,
   79|       |    }
   80|    339|}
   81|       |
   82|      6|pub fn shortcode_map() -> &'static HashMap<&'static str, &'static str> {
   83|       |    use std::sync::OnceLock;
   84|       |    static MAP: OnceLock<HashMap<&'static str, &'static str>> = OnceLock::new();
   85|      6|    MAP.get_or_init(|| {
                                     ^1
   86|      1|        HashMap::from([
   87|      1|            (":tada:", "\u{1f389}"),
   88|      1|            (":white_check_mark:", "\u{2705}"),
   89|      1|            (":check_mark:", "\u{2705}"),
   90|      1|            (":rocket:", "\u{1f680}"),
   91|      1|            (":slightly_smiling_face:", "\u{1f642}"),
   92|      1|            (":grinning:", "\u{1f600}"),
   93|      1|            (":wink:", "\u{1f609}"),
   94|      1|            (":star:", "\u{2b50}"),
   95|      1|            (":fire:", "\u{1f525}"),
   96|      1|            (":thumbsup:", "\u{1f44d}"),
   97|      1|            (":thumbsdown:", "\u{1f44e}"),
   98|      1|            (":bulb:", "\u{1f4a1}"),
   99|      1|            (":question:", "\u{2753}"),
  100|      1|            (":exclamation:", "\u{2757}"),
  101|      1|            (":memo:", "\u{1f4dd}"),
  102|      1|            (":brain:", "\u{1f9e0}"),
  103|      1|            (":test_tube:", "\u{1f9ea}"),
  104|      1|            (":package:", "\u{1f4e6}"),
  105|      1|            (":wrench:", "\u{1f527}"),
  106|      1|        ])
  107|      1|    })
  108|      6|}
  109|       |
  110|       |#[cfg(test)]
  111|       |mod tests {
  112|       |    use super::*;
  113|       |
  114|       |    #[test]
  115|      1|    fn test_image_bytes_for_known_emojis() {
  116|      1|        let emojis = [
  117|      1|            "\u{1f389}",
  118|      1|            "\u{2705}",
  119|      1|            "\u{1f680}",
  120|      1|            "\u{1f642}",
  121|      1|            "\u{1f600}",
  122|      1|            "\u{1f609}",
  123|      1|            "\u{2b50}",
  124|      1|            "\u{1f525}",
  125|      1|            "\u{1f44d}",
  126|      1|            "\u{1f44e}",
  127|      1|            "\u{1f4a1}",
  128|      1|            "\u{2753}",
  129|      1|            "\u{2757}",
  130|      1|            "\u{1f4dd}",
  131|      1|            "\u{1f9e0}",
  132|      1|            "\u{1f9ea}",
  133|      1|            "\u{1f4e6}",
  134|      1|            "\u{1f527}",
  135|      1|        ];
  136|       |
  137|     19|        for emoji in emojis {
                          ^18
  138|     18|            let bytes = image_bytes_for(emoji).expect("expected embedded emoji bytes");
  139|     18|            assert!(!bytes.is_empty());
  140|       |        }
  141|      1|    }
  142|       |
  143|       |    #[test]
  144|      1|    fn test_image_bytes_for_unknown_emoji() {
  145|      1|        assert!(image_bytes_for("\u{1f47d}").is_none());
  146|      1|    }
  147|       |
  148|       |    #[test]
  149|      1|    fn test_shortcode_map_contains_expected_entries() {
  150|      1|        let map = shortcode_map();
  151|      1|        assert_eq!(map.get(":tada:"), Some(&"\u{1f389}"));
  152|      1|        assert_eq!(map.get(":white_check_mark:"), Some(&"\u{2705}"));
  153|      1|        assert_eq!(map.get(":rocket:"), Some(&"\u{1f680}"));
  154|      1|        assert_eq!(map.get(":fire:"), Some(&"\u{1f525}"));
  155|      1|        assert_eq!(map.get(":wrench:"), Some(&"\u{1f527}"));
  156|      1|        assert!(map.get(":does_not_exist:").is_none());
  157|      1|    }
  158|       |}

C:\language\mdmdview\src\main.rs:
    1|       |#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")] // Hide console in release mode
    2|       |
    3|       |/// Main entry point for the MarkdownView application
    4|       |///
    5|       |/// A simple, standalone markdown viewer for Windows built with Rust and egui.
    6|       |/// This application provides a clean interface for viewing markdown files with
    7|       |/// syntax highlighting, embedded samples, and essential viewing features.
    8|       |#[cfg(not(test))]
    9|       |use mdmdview::{load_window_state, sanitize_window_state, MarkdownViewerApp, APP_TITLE_PREFIX};
   10|       |
   11|       |/// Application entry point
   12|       |#[cfg(not(test))]
   13|       |fn main() -> Result<(), eframe::Error> {
   14|       |    // Configure logging for debugging (only in debug builds)
   15|       |    #[cfg(debug_assertions)]
   16|       |    env_logger::init();
   17|       |
   18|       |    // Parse command line arguments
   19|       |    let mut initial_file: Option<std::path::PathBuf> = None;
   20|       |    let mut table_wrap_cli: Option<bool> = None;
   21|       |    for arg in std::env::args().skip(1) {
   22|       |        match arg.as_str() {
   23|       |            "--table-wrap" => table_wrap_cli = Some(true),
   24|       |            "--no-table-wrap" => table_wrap_cli = Some(false),
   25|       |            _ if initial_file.is_none() => initial_file = Some(std::path::PathBuf::from(&arg)),
   26|       |            _ => {}
   27|       |        }
   28|       |    }
   29|       |    let table_wrap_env = std::env::var("MDMDVIEW_TABLE_WRAP_OVERHAUL")
   30|       |        .ok()
   31|       |        .and_then(|value| parse_bool_flag(&value));
   32|       |    let table_wrap_enabled = table_wrap_cli.or(table_wrap_env).unwrap_or(true);
   33|       |
   34|       |    // Set up eframe options for the native window
   35|       |    let mut viewport = egui::ViewportBuilder::default()
   36|       |        .with_title(format!("{APP_TITLE_PREFIX} - A Simple Markdown Viewer"))
   37|       |        .with_inner_size(egui::Vec2::new(1000.0, 700.0))
   38|       |        .with_min_inner_size(egui::Vec2::new(600.0, 400.0))
   39|       |        .with_icon(create_app_icon())
   40|       |        .with_resizable(true)
   41|       |        .with_maximize_button(true)
   42|       |        .with_minimize_button(true)
   43|       |        .with_drag_and_drop(true);
   44|       |
   45|       |    // Restore previous window position/size if available
   46|       |    if let Some(ws) = load_window_state() {
   47|       |        if let Some(ws) = sanitize_window_state(ws) {
   48|       |            viewport = viewport
   49|       |                .with_inner_size(egui::Vec2::new(ws.size[0], ws.size[1]))
   50|       |                .with_position(egui::pos2(ws.pos[0], ws.pos[1]))
   51|       |                .with_maximized(ws.maximized);
   52|       |        }
   53|       |    }
   54|       |
   55|       |    let native_options = eframe::NativeOptions {
   56|       |        viewport,
   57|       |        // Keep native persist as well; our explicit file handles crossplatform dirs
   58|       |        persist_window: true,
   59|       |        ..Default::default()
   60|       |    };
   61|       |
   62|       |    // Launch the application
   63|       |    eframe::run_native(
   64|       |        APP_TITLE_PREFIX,
   65|       |        native_options,
   66|       |        Box::new(move |cc| {
   67|       |            // Configure egui styling for better markdown display
   68|       |            configure_egui_style(&cc.egui_ctx);
   69|       |
   70|       |            let mut app = MarkdownViewerApp::new();
   71|       |            app.set_table_wrap_overhaul_enabled(table_wrap_enabled);
   72|       |
   73|       |            // Load initial file if provided via command line
   74|       |            if let Some(file_path) = initial_file {
   75|       |                if file_path.exists() && file_path.is_file() {
   76|       |                    if let Err(e) = app.load_file(file_path, true) {
   77|       |                        eprintln!("Failed to load file: {}", e);
   78|       |                        // Continue with default welcome screen
   79|       |                    }
   80|       |                } else {
   81|       |                    eprintln!("File not found: {}", file_path.display());
   82|       |                    // Continue with default welcome screen
   83|       |                }
   84|       |            }
   85|       |
   86|       |            Box::new(app)
   87|       |        }),
   88|       |    )
   89|       |}
   90|       |
   91|       |#[cfg(test)]
   92|      0|fn main() {}
   93|       |
   94|       |/// Create an application icon from embedded data
   95|      2|fn create_app_icon() -> egui::IconData {
   96|       |    // Create a 32x32 markdown-style document icon
   97|      2|    let size = 32;
   98|      2|    let mut rgba_data = Vec::with_capacity(size * size * 4);
   99|       |
  100|     64|    for y in 0..size {
                              ^2
  101|  2.04k|        for x in 0..size {
                                  ^64
  102|  2.04k|            let (r, g, b, a) = if x == 0 || x == size - 1 || y == 0 || y == size - 1 {
                                                          ^1.98k           ^1.92k    ^1.86k
  103|       |                // Border
  104|    248|                (60, 60, 60, 255)
  105|  1.80k|            } else if x == 1 || x == size - 2 || y == 1 || y == size - 2 {
                                              ^1.74k           ^1.68k    ^1.62k
  106|       |                // Inner border for depth
  107|    232|                (80, 80, 80, 255)
  108|  1.56k|            } else if (4..=8).contains(&y) && (4..=28).contains(&x) {
                                                            ^280     ^280     ^280
  109|       |                // Header area (title bar)
  110|    250|                if (6..=12).contains(&x) {
  111|     70|                    (100, 150, 255, 255) // Blue for # header
  112|    180|                } else if (14..=26).contains(&x) {
  113|    130|                    (200, 200, 200, 255) // Light text
  114|       |                } else {
  115|     50|                    (250, 250, 250, 255) // Background
  116|       |                }
  117|  1.31k|            } else if (11..=13).contains(&y) && (4..=28).contains(&x) {
                                                              ^168     ^168     ^168
  118|       |                // Text line 1
  119|    150|                if (6..=8).contains(&x) {
  120|     18|                    (150, 150, 150, 255) // Bullet point
  121|    132|                } else if (10..=24).contains(&x) {
  122|     90|                    (180, 180, 180, 255) // Text
  123|       |                } else {
  124|     42|                    (250, 250, 250, 255) // Background
  125|       |                }
  126|  1.16k|            } else if (15..=17).contains(&y) && (4..=28).contains(&x) {
                                                              ^168     ^168     ^168
  127|       |                // Text line 2
  128|    150|                if (6..=8).contains(&x) {
  129|     18|                    (150, 150, 150, 255) // Bullet point
  130|    132|                } else if (10..=22).contains(&x) {
  131|     78|                    (180, 180, 180, 255) // Text
  132|       |                } else {
  133|     54|                    (250, 250, 250, 255) // Background
  134|       |                }
  135|  1.01k|            } else if (20..=22).contains(&y) && (6..=26).contains(&x) {
                                                              ^168     ^168     ^168
  136|       |                // Code block area
  137|    126|                if (8..=24).contains(&x) {
  138|    102|                    (100, 255, 100, 255) // Green code text
  139|       |                } else {
  140|     24|                    (40, 40, 40, 255) // Dark background
  141|       |                }
  142|    892|            } else if (25..=27).contains(&y) && (4..=28).contains(&x) {
                                                              ^168     ^168     ^168
  143|       |                // Text line 3
  144|    150|                if (6..=20).contains(&x) {
  145|     90|                    (180, 180, 180, 255) // Text
  146|       |                } else {
  147|     60|                    (250, 250, 250, 255) // Background
  148|       |                }
  149|       |            } else {
  150|       |                // Document background
  151|    742|                (250, 250, 250, 255)
  152|       |            };
  153|       |
  154|  2.04k|            rgba_data.extend_from_slice(&[r, g, b, a]);
  155|       |        }
  156|       |    }
  157|       |
  158|      2|    egui::IconData {
  159|      2|        rgba: rgba_data,
  160|      2|        width: size as u32,
  161|      2|        height: size as u32,
  162|      2|    }
  163|      2|}
  164|       |
  165|       |/// Configure egui styling for optimal markdown display
  166|      1|fn configure_egui_style(ctx: &egui::Context) {
  167|      1|    let mut style = (*ctx.style()).clone();
  168|       |
  169|       |    // Configure spacing for better readability
  170|      1|    style.spacing.item_spacing = egui::Vec2::new(8.0, 8.0);
  171|      1|    style.spacing.window_margin = egui::Margin::same(8.0);
  172|      1|    style.spacing.menu_margin = egui::Margin::same(6.0);
  173|       |
  174|       |    // Configure interaction settings
  175|      1|    style.interaction.resize_grab_radius_side = 8.0;
  176|      1|    style.interaction.resize_grab_radius_corner = 12.0;
  177|       |
  178|       |    // Configure visuals for better contrast with black background
  179|      1|    style.visuals.window_rounding = egui::Rounding::same(4.0);
  180|      1|    style.visuals.menu_rounding = egui::Rounding::same(4.0);
  181|       |
  182|       |    // Set to true black background for maximum contrast
  183|      1|    if style.visuals.dark_mode {
  184|      1|        style.visuals.window_fill = egui::Color32::BLACK;
  185|      1|        style.visuals.panel_fill = egui::Color32::BLACK;
  186|      1|        style.visuals.faint_bg_color = egui::Color32::from_gray(20);
  187|      1|        style.visuals.extreme_bg_color = egui::Color32::BLACK;
  188|      1|        // The text color will be handled by egui's theme system
  189|      1|    }
                  ^0
  190|       |
  191|      1|    ctx.set_style(style);
  192|       |
  193|       |    // Use default fonts - egui has good built-in font support
  194|       |    // Custom fonts could be added here if needed
  195|      1|}
  196|       |
  197|      5|fn parse_bool_flag(value: &str) -> Option<bool> {
  198|      5|    match value.trim().to_ascii_lowercase().as_str() {
  199|      5|        "1" | "true" | "yes" | "on" => Some(true),
                            ^4       ^3      ^3      ^2
  200|      3|        "0" | "false" | "no" | "off" => Some(false),
                            ^2        ^1     ^1       ^2
  201|      1|        _ => None,
  202|       |    }
  203|      5|}
  204|       |
  205|       |#[cfg(test)]
  206|       |mod tests {
  207|       |    use super::*;
  208|       |
  209|       |    #[test]
  210|      1|    fn test_app_icon_creation() {
  211|      1|        let icon = create_app_icon();
  212|      1|        assert_eq!(icon.width, 32);
  213|      1|        assert_eq!(icon.height, 32);
  214|      1|        assert_eq!(icon.rgba.len(), 32 * 32 * 4); // RGBA format
  215|      1|    }
  216|       |
  217|       |    #[test]
  218|      1|    fn test_main_function_setup() {
  219|       |        // Test that the main function components work
  220|       |        // This is a basic smoke test
  221|      1|        let icon = create_app_icon();
  222|      1|        assert!(!icon.rgba.is_empty());
  223|      1|    }
  224|       |
  225|       |    #[test]
  226|      1|    fn test_parse_bool_flag() {
  227|      1|        assert_eq!(parse_bool_flag("true"), Some(true));
  228|      1|        assert_eq!(parse_bool_flag("FALSE"), Some(false));
  229|      1|        assert_eq!(parse_bool_flag("1"), Some(true));
  230|      1|        assert_eq!(parse_bool_flag("0"), Some(false));
  231|      1|        assert_eq!(parse_bool_flag("unknown"), None);
  232|      1|    }
  233|       |
  234|       |    #[test]
  235|      1|    fn test_configure_egui_style_dark_mode() {
  236|      1|        let ctx = egui::Context::default();
  237|      1|        let mut style = (*ctx.style()).clone();
  238|      1|        style.visuals.dark_mode = true;
  239|      1|        ctx.set_style(style);
  240|       |
  241|      1|        configure_egui_style(&ctx);
  242|       |
  243|      1|        let style = ctx.style();
  244|      1|        assert_eq!(style.spacing.item_spacing, egui::Vec2::new(8.0, 8.0));
  245|      1|        assert_eq!(style.spacing.window_margin, egui::Margin::same(8.0));
  246|      1|        assert_eq!(style.spacing.menu_margin, egui::Margin::same(6.0));
  247|      1|        assert_eq!(style.visuals.window_rounding, egui::Rounding::same(4.0));
  248|      1|        assert_eq!(style.visuals.menu_rounding, egui::Rounding::same(4.0));
  249|      1|        assert_eq!(style.visuals.window_fill, egui::Color32::BLACK);
  250|      1|        assert_eq!(style.visuals.panel_fill, egui::Color32::BLACK);
  251|      1|        assert_eq!(style.visuals.faint_bg_color, egui::Color32::from_gray(20));
  252|      1|        assert_eq!(style.visuals.extreme_bg_color, egui::Color32::BLACK);
  253|      1|    }
  254|       |}

C:\language\mdmdview\src\markdown_renderer.rs:
    1|       |use crate::table_support::{
    2|       |    compute_column_stats, derive_column_specs, ColumnPolicy, ColumnSpec, ColumnStat,
    3|       |    TableColumnContext, TableMetrics, WidthChange,
    4|       |};
    5|       |use crate::{emoji_assets, emoji_catalog};
    6|       |use anyhow::Result;
    7|       |use crossbeam_channel::{
    8|       |    bounded, Receiver as KrokiJobReceiver, Sender as KrokiJobSender, TrySendError,
    9|       |};
   10|       |use egui::{
   11|       |    text::{Galley, LayoutJob, TextWrapping},
   12|       |    Align, Color32, Context, FontSelection, Painter, RichText, Stroke, Vec2, Visuals,
   13|       |};
   14|       |use egui_extras::TableBuilder;
   15|       |use pulldown_cmark::{Event, LinkType, Options, Parser, Tag};
   16|       |use std::cell::RefCell;
   17|       |use std::collections::{hash_map::DefaultHasher, HashMap, HashSet, VecDeque};
   18|       |use std::hash::{Hash, Hasher};
   19|       |use std::ops::Range;
   20|       |use std::path::{Path, PathBuf};
   21|       |use std::sync::{mpsc::Receiver, Arc};
   22|       |use std::time::{Duration, SystemTime};
   23|       |use syntect::easy::HighlightLines;
   24|       |use syntect::highlighting::ThemeSet;
   25|       |use syntect::parsing::SyntaxSet;
   26|       |use syntect::util::LinesWithEndings;
   27|       |use unicode_casefold::UnicodeCaseFold;
   28|       |use unicode_normalization::UnicodeNormalization;
   29|       |use unicode_segmentation::UnicodeSegmentation;
   30|       |
   31|       |// Embedded Mermaid JS bytes are generated in build.rs into OUT_DIR.
   32|       |// Place mermaid.min.js at assets/vendor/mermaid.min.js to embed it.
   33|       |#[cfg(feature = "mermaid-quickjs")]
   34|       |mod mermaid_embed {
   35|       |    include!(concat!(env!("OUT_DIR"), "/mermaid_js.rs"));
   36|       |}
   37|       |
   38|       |#[cfg(feature = "mermaid-quickjs")]
   39|       |struct MermaidEngine {
   40|       |    #[allow(dead_code)]
   41|       |    rt: rquickjs::Runtime,
   42|       |    ctx: rquickjs::Context,
   43|       |}
   44|       |
   45|       |#[derive(Clone, Copy, Default)]
   46|       |struct InlineStyle {
   47|       |    strong: bool,
   48|       |    italics: bool,
   49|       |    strike: bool,
   50|       |    color: Option<Color32>,
   51|       |}
   52|       |
   53|       |#[cfg(test)]
   54|       |thread_local! {
   55|       |    static FORCED_RENDER_ACTIONS: RefCell<HashSet<&'static str>> = RefCell::new(HashSet::new());
   56|       |}
   57|       |
   58|       |#[cfg(test)]
   59|     11|fn render_action_triggered(triggered: bool, action: &'static str) -> bool {
   60|     11|    triggered || FORCED_RENDER_ACTIONS.with(|actions| actions.borrow().contains(action))
   61|     11|}
   62|       |
   63|       |#[cfg(not(test))]
   64|       |fn render_action_triggered(triggered: bool, _action: &'static str) -> bool {
   65|       |    triggered
   66|       |}
   67|       |
   68|       |/// Font size configuration
   69|       |#[derive(Debug, Clone)]
   70|       |pub struct FontSizes {
   71|       |    pub body: f32,
   72|       |    pub h1: f32,
   73|       |    pub h2: f32,
   74|       |    pub h3: f32,
   75|       |    pub h4: f32,
   76|       |    pub h5: f32,
   77|       |    pub h6: f32,
   78|       |    pub code: f32,
   79|       |}
   80|       |
   81|       |impl Default for FontSizes {
   82|    109|    fn default() -> Self {
   83|    109|        Self {
   84|    109|            body: 14.0,
   85|    109|            h1: 28.0,
   86|    109|            h2: 24.0,
   87|    109|            h3: 20.0,
   88|    109|            h4: 18.0,
   89|    109|            h5: 16.0,
   90|    109|            h6: 14.0,
   91|    109|            code: 12.0,
   92|    109|        }
   93|    109|    }
   94|       |}
   95|       |
   96|       |/// Represents an inline text span with formatting
   97|       |#[derive(Debug, Clone)]
   98|       |pub enum InlineSpan {
   99|       |    Text(String),
  100|       |    Code(String),
  101|       |    Strong(String),
  102|       |    Emphasis(String),
  103|       |    Strikethrough(String),
  104|       |    Link {
  105|       |        text: String,
  106|       |        url: String,
  107|       |    },
  108|       |    Image {
  109|       |        src: String,
  110|       |        alt: String,
  111|       |        title: Option<String>,
  112|       |    },
  113|       |}
  114|       |
  115|       |impl InlineSpan {
  116|     16|    fn text_content(&self) -> Option<&str> {
  117|     16|        match self {
  118|     13|            InlineSpan::Text(t)
  119|      0|            | InlineSpan::Code(t)
  120|      1|            | InlineSpan::Strong(t)
  121|      0|            | InlineSpan::Emphasis(t)
  122|     14|            | InlineSpan::Strikethrough(t) => Some(t.as_str()),
                                                      ^0
  123|      1|            InlineSpan::Link { text, .. } => Some(text.as_str()),
  124|      1|            InlineSpan::Image { .. } => None,
  125|       |        }
  126|     16|    }
  127|       |
  128|     14|    fn is_text_like(&self) -> bool {
  129|     14|        !matches!(self, InlineSpan::Image { .. })
  130|     14|    }
  131|       |}
  132|       |
  133|       |#[cfg_attr(not(test), allow(dead_code))]
  134|       |#[derive(Debug, Clone)]
  135|       |enum CellFragment<'a> {
  136|       |    Text(&'a [InlineSpan]),
  137|       |    Emoji(String),
  138|       |    Image(&'a InlineSpan),
  139|       |}
  140|       |
  141|       |#[cfg_attr(not(test), allow(dead_code))]
  142|       |#[derive(Debug, Clone)]
  143|       |struct LayoutJobBuild {
  144|       |    job: LayoutJob,
  145|       |    #[allow(dead_code)]
  146|       |    plain_text: String,
  147|       |    #[cfg_attr(not(test), allow(dead_code))]
  148|       |    link_ranges: Vec<LinkRange>,
  149|       |}
  150|       |
  151|       |#[cfg_attr(not(test), allow(dead_code))]
  152|       |#[derive(Debug, Clone)]
  153|       |struct LinkRange {
  154|       |    char_range: Range<usize>,
  155|       |    url: String,
  156|       |}
  157|       |
  158|       |const TABLE_LAYOUT_CACHE_CAPACITY: usize = 512;
  159|       |const COLUMN_STATS_SAMPLE_ROWS: usize = 128;
  160|       |
  161|       |#[derive(Debug, Clone, Hash, PartialEq, Eq)]
  162|       |struct CellLayoutKey {
  163|       |    row: Option<usize>,
  164|       |    col: usize,
  165|       |    width: u32,
  166|       |    strong: bool,
  167|       |    highlight_hash: u64,
  168|       |    content_hash: u64,
  169|       |}
  170|       |
  171|       |struct CellLayoutCache {
  172|       |    entries: HashMap<CellLayoutKey, LayoutJobBuild>,
  173|       |    order: VecDeque<CellLayoutKey>,
  174|       |    hits: u64,
  175|       |    misses: u64,
  176|       |    capacity: usize,
  177|       |}
  178|       |
  179|       |#[derive(Clone)]
  180|       |struct ColumnStatsCacheEntry {
  181|       |    content_hash: u64,
  182|       |    stats: Vec<ColumnStat>,
  183|       |}
  184|       |
  185|       |impl CellLayoutCache {
  186|    102|    fn new(capacity: usize) -> Self {
  187|    102|        Self {
  188|    102|            entries: HashMap::new(),
  189|    102|            order: VecDeque::new(),
  190|    102|            hits: 0,
  191|    102|            misses: 0,
  192|    102|            capacity,
  193|    102|        }
  194|    102|    }
  195|       |
  196|     16|    fn get(&mut self, key: &CellLayoutKey) -> Option<LayoutJobBuild> {
  197|     16|        if let Some(build) = self.entries.get(key) {
                                  ^1
  198|      1|            self.hits += 1;
  199|      1|            Some(build.clone())
  200|       |        } else {
  201|     15|            self.misses += 1;
  202|     15|            None
  203|       |        }
  204|     16|    }
  205|       |
  206|     15|    fn insert(&mut self, key: CellLayoutKey, build: LayoutJobBuild) {
  207|     15|        if self.entries.len() >= self.capacity && !self.entries.contains_key(&key) {
                                                                ^0^0
  208|      0|            while self.entries.len() >= self.capacity {
  209|      0|                if let Some(old) = self.order.pop_front() {
  210|      0|                    self.entries.remove(&old);
  211|      0|                } else {
  212|      0|                    break;
  213|       |                }
  214|       |            }
  215|     15|        }
  216|     43|        self.order.retain(|existing| existing != &key);
                      ^15        ^15
  217|     15|        self.order.push_back(key.clone());
  218|     15|        self.entries.insert(key, build);
  219|     15|    }
  220|       |
  221|    201|    fn clear(&mut self) {
  222|    201|        self.entries.clear();
  223|    201|        self.order.clear();
  224|    201|        self.hits = 0;
  225|    201|        self.misses = 0;
  226|    201|    }
  227|       |
  228|     22|    fn stats(&self) -> (u64, u64) {
  229|     22|        (self.hits, self.misses)
  230|     22|    }
  231|       |}
  232|       |
  233|       |/// Represents a rendered markdown element
  234|       |#[derive(Debug, Clone)]
  235|       |pub enum MarkdownElement {
  236|       |    Paragraph(Vec<InlineSpan>),
  237|       |    Header {
  238|       |        level: u8,
  239|       |        spans: Vec<InlineSpan>,
  240|       |        id: String,
  241|       |    },
  242|       |    CodeBlock {
  243|       |        language: Option<String>,
  244|       |        text: String,
  245|       |    },
  246|       |    List {
  247|       |        ordered: bool,
  248|       |        items: Vec<Vec<InlineSpan>>,
  249|       |    }, // List items are also inline spans
  250|       |    Quote {
  251|       |        depth: u8,
  252|       |        lines: Vec<Vec<InlineSpan>>,
  253|       |    },
  254|       |    HorizontalRule,
  255|       |    Table {
  256|       |        headers: Vec<Vec<InlineSpan>>,   // header cells as inline spans
  257|       |        rows: Vec<Vec<Vec<InlineSpan>>>, // rows -> cells -> spans
  258|       |    },
  259|       |}
  260|       |
  261|       |/// Type alias for table parsing result
  262|       |type TableParseResult = (Vec<Vec<InlineSpan>>, Vec<Vec<Vec<InlineSpan>>>, usize);
  263|       |
  264|       |/// Type alias for quote lines (each line is a sequence of inline spans)
  265|       |type QuoteLines = Vec<Vec<InlineSpan>>;
  266|       |
  267|       |struct ImageCacheEntry {
  268|       |    texture: egui::TextureHandle,
  269|       |    size: [u32; 2],
  270|       |    modified: Option<SystemTime>,
  271|       |}
  272|       |
  273|       |struct KrokiRequest {
  274|       |    key: u64,
  275|       |    url: String,
  276|       |    payload: String,
  277|       |}
  278|       |
  279|       |#[derive(Debug, PartialEq, Eq)]
  280|       |enum KrokiEnqueueError {
  281|       |    QueueFull,
  282|       |    Disconnected,
  283|       |}
  284|       |
  285|       |/// Markdown renderer with proper inline element handling
  286|       |pub struct MarkdownRenderer {
  287|       |    font_sizes: FontSizes,
  288|       |    syntax_set: SyntaxSet,
  289|       |    theme_set: ThemeSet,
  290|       |    emoji_textures: RefCell<HashMap<String, egui::TextureHandle>>,
  291|       |    image_textures: RefCell<HashMap<String, ImageCacheEntry>>,
  292|       |    // Mapping of header id -> last rendered rect (for in-document navigation)
  293|       |    header_rects: RefCell<HashMap<String, egui::Rect>>,
  294|       |    // Last clicked internal anchor (e.g., "getting-started") for the app to consume
  295|       |    pending_anchor: RefCell<Option<String>>,
  296|       |    // Unique counter to avoid egui Id collisions for repeated links
  297|       |    link_counter: RefCell<u64>,
  298|       |    // Per-frame rect for each top-level element in render order
  299|       |    element_rects: RefCell<Vec<egui::Rect>>,
  300|       |    // Optional highlight phrase (lowercased) for in-text highlighting
  301|       |    highlight_phrase: RefCell<Option<String>>,
  302|       |    // Cache for image/diagram textures
  303|       |    // Base directory used to resolve relative image paths
  304|       |    base_dir: RefCell<Option<PathBuf>>,
  305|       |    // Kroki (default Mermaid path) state
  306|       |    kroki_pending: RefCell<HashSet<u64>>, // code_hashes in flight
  307|       |    kroki_svg_cache: RefCell<HashMap<u64, Vec<u8>>>, // code_hash -> image bytes (PNG preferred)
  308|       |    kroki_errors: RefCell<HashMap<u64, String>>, // code_hash -> last error
  309|       |    kroki_job_tx: KrokiJobSender<KrokiRequest>, // UI -> worker queue
  310|       |    kroki_rx: Receiver<(u64, Result<Vec<u8>, String>)>, // background -> UI thread
  311|       |    #[cfg(feature = "mermaid-quickjs")]
  312|       |    mermaid_engine: RefCell<Option<MermaidEngine>>,
  313|       |    #[cfg(feature = "mermaid-quickjs")]
  314|       |    mermaid_svg_cache: RefCell<HashMap<u64, String>>, // code_hash -> SVG string
  315|       |    #[cfg(feature = "mermaid-quickjs")]
  316|       |    mermaid_failed: RefCell<HashSet<u64>>, // hashes that failed rendering; skip reattempts
  317|       |    #[cfg(feature = "mermaid-quickjs")]
  318|       |    mermaid_init_logged: RefCell<bool>,
  319|       |    #[cfg(feature = "mermaid-quickjs")]
  320|       |    mermaid_last_error: RefCell<Option<String>>,
  321|       |    table_wrap_overhaul_enabled: bool,
  322|       |    table_layout_cache: RefCell<CellLayoutCache>,
  323|       |    table_metrics: RefCell<TableMetrics>,
  324|       |    column_stats_cache: RefCell<HashMap<u64, ColumnStatsCacheEntry>>,
  325|       |}
  326|       |
  327|       |impl Default for MarkdownRenderer {
  328|      0|    fn default() -> Self {
  329|      0|        Self::new()
  330|      0|    }
  331|       |}
  332|       |
  333|       |impl MarkdownRenderer {
  334|       |    #[cfg_attr(not(test), allow(dead_code))]
  335|     12|    fn cell_fragments<'a>(&'a self, spans: &'a [InlineSpan]) -> Vec<CellFragment<'a>> {
  336|     12|        let mut fragments = Vec::new();
  337|     12|        let mut run_start: Option<usize> = None;
  338|     12|        let flush_run =
  339|      2|            |start: &mut Option<usize>, end: usize, fragments: &mut Vec<CellFragment<'a>>| {
  340|      2|                if let Some(run_begin) = start.take() {
                                          ^1
  341|      1|                    if run_begin < end {
  342|      1|                        fragments.push(CellFragment::Text(&spans[run_begin..end]));
  343|      1|                    }
                                  ^0
  344|      1|                }
  345|      2|            };
  346|       |
  347|     16|        for (idx, span) in spans.iter().enumerate() {
                                         ^12   ^12    ^12
  348|     16|            if let Some(emoji_key) = self.span_is_single_emoji(span) {
                                      ^1
  349|      1|                flush_run(&mut run_start, idx, &mut fragments);
  350|      1|                fragments.push(CellFragment::Emoji(emoji_key));
  351|      1|                continue;
  352|     15|            }
  353|       |
  354|     15|            if matches!(span, InlineSpan::Image { .. }) {
                             ^14
  355|      1|                flush_run(&mut run_start, idx, &mut fragments);
  356|      1|                fragments.push(CellFragment::Image(span));
  357|      1|                continue;
  358|     14|            }
  359|       |
  360|     14|            if span.is_text_like() && run_start.is_none() {
  361|     13|                run_start = Some(idx);
  362|     13|            }
                          ^1
  363|       |        }
  364|       |
  365|     12|        if let Some(start) = run_start {
  366|     12|            fragments.push(CellFragment::Text(&spans[start..]));
  367|     12|        }
                      ^0
  368|       |
  369|     12|        fragments
  370|     12|    }
  371|       |
  372|     16|    fn span_is_single_emoji(&self, span: &InlineSpan) -> Option<String> {
  373|     16|        let text = span.text_content()?;
                          ^15                       ^1
  374|     15|        let trimmed = text.trim();
  375|     15|        if trimmed.is_empty() {
  376|      0|            return None;
  377|     15|        }
  378|     15|        let mut graphemes = trimmed.graphemes(true);
  379|     15|        let first = graphemes.next()?;
                                                  ^0
  380|     15|        if graphemes.next().is_some() {
  381|     14|            return None;
  382|      1|        }
  383|      1|        if first != trimmed {
  384|      0|            return None;
  385|      1|        }
  386|      1|        self.emoji_key_for_grapheme(first)
  387|     16|    }
  388|       |
  389|     43|    fn highlight_segments(&self, text: &str, highlight: Option<&str>) -> Vec<(Range<usize>, bool)> {
  390|     43|        if text.is_empty() {
  391|      0|            return Vec::new();
  392|     43|        }
  393|     43|        let Some(needle) = highlight.filter(|h| !h.is_empty()) else {
                               ^34                             ^34^34
  394|      9|            return vec![(0..text.len(), false)];
  395|       |        };
  396|       |
  397|     34|        let mut folded = String::new();
  398|     34|        let mut folded_to_char: Vec<usize> = Vec::new();
  399|     34|        let mut char_ranges: Vec<(usize, usize)> = Vec::new();
  400|    245|        for (char_idx, (byte_idx, ch)) in text.char_indices().enumerate() {
                                                        ^34  ^34            ^34
  401|    245|            let folded_piece: String = ch.to_string().case_fold().nfkc().collect();
  402|    245|            let before = folded.len();
  403|    245|            folded.push_str(&folded_piece);
  404|    245|            let after = folded.len();
  405|    248|            for _ in before..after {
                                   ^245    ^245
  406|    248|                folded_to_char.push(char_idx);
  407|    248|            }
  408|    245|            char_ranges.push((byte_idx, byte_idx + ch.len_utf8()));
  409|       |        }
  410|       |
  411|     34|        if folded.is_empty() {
  412|      0|            return vec![(0..text.len(), false)];
  413|     34|        }
  414|       |
  415|     34|        let mut segments = Vec::new();
  416|     34|        let mut rendered_until = 0usize;
  417|     34|        let mut search_at = 0usize;
  418|     41|        while let Some(pos) = folded[search_at..].find(needle) {
                                     ^7
  419|      7|            let abs = search_at + pos;
  420|      7|            if abs >= folded_to_char.len() {
  421|      0|                break;
  422|      7|            }
  423|      7|            let start_char_idx = folded_to_char[abs];
  424|      7|            let (start_byte, _) = char_ranges[start_char_idx];
  425|      7|            if start_byte > rendered_until {
  426|      1|                segments.push((rendered_until..start_byte, false));
  427|      6|            }
  428|      7|            let match_end = abs + needle.len();
  429|      7|            let end_char_idx = if match_end == 0 {
  430|      0|                start_char_idx
  431|       |            } else {
  432|      7|                folded_to_char[match_end.saturating_sub(1)]
  433|       |            };
  434|      7|            let (_, end_byte) = char_ranges[end_char_idx];
  435|      7|            segments.push((start_byte..end_byte, true));
  436|      7|            rendered_until = end_byte;
  437|      7|            search_at = match_end;
  438|       |        }
  439|       |
  440|     34|        if rendered_until < text.len() {
  441|     34|            segments.push((rendered_until..text.len(), false));
  442|     34|        }
                      ^0
  443|       |
  444|     34|        if segments.is_empty() {
  445|      0|            segments.push((0..text.len(), false));
  446|     34|        }
  447|     34|        segments
  448|     43|    }
  449|       |
  450|       |    #[cfg_attr(not(test), allow(dead_code))]
  451|     19|    fn build_layout_job(
  452|     19|        &self,
  453|     19|        style: &egui::Style,
  454|     19|        spans: &[InlineSpan],
  455|     19|        wrap_width: f32,
  456|     19|        strong_override: bool,
  457|     19|    ) -> LayoutJobBuild {
  458|     19|        let mut job = LayoutJob {
  459|     19|            wrap: TextWrapping {
  460|     19|                max_width: wrap_width.max(1.0),
  461|     19|                ..Default::default()
  462|     19|            },
  463|     19|            break_on_newline: true,
  464|     19|            halign: Align::LEFT,
  465|     19|            ..Default::default()
  466|     19|        };
  467|       |
  468|     19|        let highlight = self
  469|     19|            .highlight_phrase
  470|     19|            .borrow()
  471|     19|            .clone()
  472|     19|            .filter(|s| !s.is_empty());
                                       ^10^10
  473|       |
  474|     19|        let mut plain_text = String::new();
  475|     19|        let mut link_ranges = Vec::new();
  476|     19|        let mut job_char_offset = 0usize;
  477|       |
  478|     44|        for span in spans {
                          ^25
  479|     25|            match span {
  480|      0|                InlineSpan::Image { .. } => {}
  481|      1|                InlineSpan::Code(code) => {
  482|      1|                    job_char_offset +=
  483|      1|                        self.append_code_span(style, &mut job, &mut plain_text, code);
  484|      1|                }
  485|      4|                InlineSpan::Link { text, url } => {
  486|      4|                    let inline_style = InlineStyle {
  487|      4|                        strong: strong_override,
  488|      4|                        color: Some(if Self::is_external_url(url) {
  489|      3|                            Color32::from_rgb(120, 190, 255)
  490|       |                        } else {
  491|      1|                            Color32::LIGHT_BLUE
  492|       |                        }),
  493|      4|                        ..Default::default()
  494|       |                    };
  495|      4|                    let mut normalized = self.fix_unicode_chars(text);
  496|      4|                    normalized = Self::expand_shortcodes(&normalized);
  497|      4|                    normalized = Self::expand_superscripts(&normalized);
  498|      4|                    let appended = self.append_text_sections(
  499|      4|                        style,
  500|      4|                        &mut job,
  501|      4|                        &mut plain_text,
  502|      4|                        &normalized,
  503|      4|                        self.font_sizes.body,
  504|      4|                        inline_style,
  505|      4|                        highlight.as_deref(),
  506|       |                    );
  507|      4|                    if appended > 0 {
  508|      4|                        let start_char = job_char_offset;
  509|      4|                        job_char_offset += appended;
  510|      4|                        link_ranges.push(LinkRange {
  511|      4|                            char_range: start_char..job_char_offset,
  512|      4|                            url: url.clone(),
  513|      4|                        });
  514|      4|                    }
                                  ^0
  515|       |                }
  516|      1|                InlineSpan::Strong(text) => {
  517|      1|                    job_char_offset += self.append_plain_span(
  518|      1|                        style,
  519|      1|                        &mut job,
  520|      1|                        &mut plain_text,
  521|      1|                        text,
  522|      1|                        InlineStyle {
  523|      1|                            strong: true,
  524|      1|                            ..Default::default()
  525|      1|                        },
  526|      1|                        highlight.as_deref(),
  527|      1|                    );
  528|      1|                }
  529|      1|                InlineSpan::Emphasis(text) => {
  530|      1|                    job_char_offset += self.append_plain_span(
  531|      1|                        style,
  532|      1|                        &mut job,
  533|      1|                        &mut plain_text,
  534|      1|                        text,
  535|      1|                        InlineStyle {
  536|      1|                            italics: true,
  537|      1|                            strong: strong_override,
  538|      1|                            ..Default::default()
  539|      1|                        },
  540|      1|                        highlight.as_deref(),
  541|      1|                    );
  542|      1|                }
  543|      1|                InlineSpan::Strikethrough(text) => {
  544|      1|                    job_char_offset += self.append_plain_span(
  545|      1|                        style,
  546|      1|                        &mut job,
  547|      1|                        &mut plain_text,
  548|      1|                        text,
  549|      1|                        InlineStyle {
  550|      1|                            strike: true,
  551|      1|                            strong: strong_override,
  552|      1|                            ..Default::default()
  553|      1|                        },
  554|      1|                        highlight.as_deref(),
  555|      1|                    );
  556|      1|                }
  557|     17|                InlineSpan::Text(text) => {
  558|     17|                    job_char_offset += self.append_plain_span(
  559|     17|                        style,
  560|     17|                        &mut job,
  561|     17|                        &mut plain_text,
  562|     17|                        text,
  563|     17|                        InlineStyle {
  564|     17|                            strong: strong_override,
  565|     17|                            ..Default::default()
  566|     17|                        },
  567|     17|                        highlight.as_deref(),
  568|     17|                    );
  569|     17|                }
  570|       |            }
  571|       |        }
  572|       |
  573|     19|        LayoutJobBuild {
  574|     19|            job,
  575|     19|            plain_text,
  576|     19|            link_ranges,
  577|     19|        }
  578|     19|    }
  579|       |
  580|     20|    fn append_plain_span(
  581|     20|        &self,
  582|     20|        style: &egui::Style,
  583|     20|        job: &mut LayoutJob,
  584|     20|        plain_text: &mut String,
  585|     20|        text: &str,
  586|     20|        inline_style: InlineStyle,
  587|     20|        highlight: Option<&str>,
  588|     20|    ) -> usize {
  589|     20|        if text.is_empty() {
  590|      0|            return 0;
  591|     20|        }
  592|     20|        let mut normalized = self.fix_unicode_chars(text);
  593|     20|        normalized = Self::expand_shortcodes(&normalized);
  594|     20|        normalized = Self::expand_superscripts(&normalized);
  595|     20|        if normalized.is_empty() {
  596|      0|            return 0;
  597|     20|        }
  598|     20|        self.append_text_sections(
  599|     20|            style,
  600|     20|            job,
  601|     20|            plain_text,
  602|     20|            &normalized,
  603|     20|            self.font_sizes.body,
  604|     20|            inline_style,
  605|     20|            highlight,
  606|       |        )
  607|     20|    }
  608|       |
  609|      1|    fn append_code_span(
  610|      1|        &self,
  611|      1|        style: &egui::Style,
  612|      1|        job: &mut LayoutJob,
  613|      1|        plain_text: &mut String,
  614|      1|        code: &str,
  615|      1|    ) -> usize {
  616|      1|        if code.is_empty() {
  617|      0|            return 0;
  618|      1|        }
  619|      1|        plain_text.push_str(code);
  620|      1|        let visuals = &style.visuals;
  621|      1|        let (bg, fg) = if visuals.dark_mode {
  622|      1|            (
  623|      1|                Color32::from_rgb(30, 30, 30),
  624|      1|                Color32::from_rgb(180, 255, 180),
  625|      1|            )
  626|       |        } else {
  627|      0|            (Color32::WHITE, Color32::from_rgb(60, 80, 150))
  628|       |        };
  629|      1|        let rich = RichText::new(code.to_string())
  630|      1|            .size(self.font_sizes.code)
  631|      1|            .monospace()
  632|      1|            .background_color(bg)
  633|      1|            .color(fg);
  634|      1|        rich.append_to(job, style, FontSelection::Default, Align::LEFT);
  635|      1|        code.chars().count()
  636|      1|    }
  637|       |
  638|       |    #[allow(clippy::too_many_arguments)]
  639|     24|    fn append_text_sections(
  640|     24|        &self,
  641|     24|        style: &egui::Style,
  642|     24|        job: &mut LayoutJob,
  643|     24|        plain_text: &mut String,
  644|     24|        text: &str,
  645|     24|        font_size: f32,
  646|     24|        inline_style: InlineStyle,
  647|     24|        highlight: Option<&str>,
  648|     24|    ) -> usize {
  649|     24|        if text.is_empty() {
  650|      0|            return 0;
  651|     24|        }
  652|     24|        plain_text.push_str(text);
  653|     24|        let char_count = text.chars().count();
  654|     24|        let visuals = &style.visuals;
  655|     24|        let segments = self.highlight_segments(text, highlight);
  656|     51|        for (range, highlighted) in segments {
                           ^27    ^27
  657|     27|            if range.is_empty() {
  658|      0|                continue;
  659|     27|            }
  660|     27|            let slice = &text[range];
  661|     27|            let mut rich = RichText::new(slice.to_string()).size(font_size);
  662|     27|            if inline_style.strong {
  663|      9|                rich = rich.strong();
  664|     18|            }
  665|     27|            if inline_style.italics {
  666|      1|                rich = rich.italics();
  667|     26|            }
  668|     27|            if inline_style.strike {
  669|      1|                rich = rich.strikethrough();
  670|     26|            }
  671|     27|            let mut text_color = inline_style.color;
  672|     27|            if highlighted {
  673|      2|                rich = rich.background_color(visuals.selection.bg_fill);
  674|      2|                if text_color.is_none() {
  675|      2|                    text_color = Some(visuals.selection.stroke.color);
  676|      2|                }
                              ^0
  677|     25|            }
  678|     27|            if let Some(color) = text_color {
                                      ^6
  679|      6|                rich = rich.color(color);
  680|     21|            }
  681|     27|            rich.append_to(job, style, FontSelection::Default, Align::LEFT);
  682|       |        }
  683|     24|        char_count
  684|     24|    }
  685|       |
  686|       |    const MAX_KROKI_JOBS: usize = 4;
  687|       |
  688|       |    /// Create a new markdown renderer
  689|    102|    pub fn new() -> Self {
  690|    102|        let (tx, rx) = std::sync::mpsc::channel();
  691|    102|        let (job_tx, job_rx): (KrokiJobSender<KrokiRequest>, KrokiJobReceiver<KrokiRequest>) =
  692|    102|            bounded(Self::MAX_KROKI_JOBS * 4);
  693|    510|        for worker_idx in 0..Self::MAX_KROKI_JOBS {
                          ^408
  694|    408|            let worker_rx = job_rx.clone();
  695|    408|            let result_tx = tx.clone();
  696|    408|            if let Err(err) = std::thread::Builder::new()
                                     ^0
  697|    408|                .name(format!("mdmdview-kroki-{worker_idx}"))
  698|    408|                .spawn(move || {
  699|    408|                    let agent = ureq::AgentBuilder::new()
  700|    408|                        .timeout_connect(Duration::from_secs(5))
  701|    408|                        .timeout_read(Duration::from_secs(10))
  702|    408|                        .timeout_write(Duration::from_secs(10))
  703|    408|                        .build();
  704|    408|                    for job in worker_rx.iter() {
                                      ^0
  705|      0|                        let result = MarkdownRenderer::perform_kroki_with_agent(
  706|      0|                            &agent,
  707|      0|                            &job.url,
  708|      0|                            &job.payload,
  709|      0|                        );
  710|      0|                        let _ = result_tx.send((job.key, result));
  711|      0|                    }
  712|    408|                })
  713|      0|            {
  714|      0|                eprintln!("Failed to start Kroki worker thread: {}", err);
  715|    408|            }
  716|       |        }
  717|    102|        drop(job_rx);
  718|    102|        Self {
  719|    102|            font_sizes: FontSizes::default(),
  720|    102|            syntax_set: SyntaxSet::load_defaults_newlines(),
  721|    102|            theme_set: ThemeSet::load_defaults(),
  722|    102|            emoji_textures: RefCell::new(HashMap::new()),
  723|    102|            image_textures: RefCell::new(HashMap::new()),
  724|    102|            header_rects: RefCell::new(HashMap::new()),
  725|    102|            pending_anchor: RefCell::new(None),
  726|    102|            link_counter: RefCell::new(0),
  727|    102|            element_rects: RefCell::new(Vec::new()),
  728|    102|            highlight_phrase: RefCell::new(None),
  729|    102|            base_dir: RefCell::new(None),
  730|    102|            kroki_pending: RefCell::new(HashSet::new()),
  731|    102|            kroki_svg_cache: RefCell::new(HashMap::new()),
  732|    102|            kroki_errors: RefCell::new(HashMap::new()),
  733|    102|            kroki_job_tx: job_tx,
  734|    102|            kroki_rx: rx,
  735|    102|            #[cfg(feature = "mermaid-quickjs")]
  736|    102|            mermaid_engine: RefCell::new(None),
  737|    102|            #[cfg(feature = "mermaid-quickjs")]
  738|    102|            mermaid_svg_cache: RefCell::new(HashMap::new()),
  739|    102|            #[cfg(feature = "mermaid-quickjs")]
  740|    102|            mermaid_failed: RefCell::new(HashSet::new()),
  741|    102|            #[cfg(feature = "mermaid-quickjs")]
  742|    102|            mermaid_init_logged: RefCell::new(false),
  743|    102|            #[cfg(feature = "mermaid-quickjs")]
  744|    102|            mermaid_last_error: RefCell::new(None),
  745|    102|            table_wrap_overhaul_enabled: true,
  746|    102|            table_layout_cache: RefCell::new(CellLayoutCache::new(TABLE_LAYOUT_CACHE_CAPACITY)),
  747|    102|            table_metrics: RefCell::new(TableMetrics::default()),
  748|    102|            column_stats_cache: RefCell::new(HashMap::new()),
  749|    102|        }
  750|    102|    }
  751|       |
  752|       |    /// UI scale factor derived from body font size relative to default.
  753|       |    /// Used to scale non-text elements (e.g., images) consistently with zoom.
  754|      4|    fn ui_scale(&self) -> f32 {
  755|      4|        let default_body = FontSizes::default().body;
  756|      4|        (self.font_sizes.body / default_body).clamp(0.5, 4.0)
  757|      4|    }
  758|       |
  759|       |    /// Get current font sizes
  760|      2|    pub fn font_sizes(&self) -> &FontSizes {
  761|      2|        &self.font_sizes
  762|      2|    }
  763|       |
  764|       |    /// Parse markdown content into elements with proper inline handling
  765|    122|    pub fn parse(&self, markdown: &str) -> Result<Vec<MarkdownElement>, anyhow::Error> {
  766|    122|        let mut options = Options::empty();
  767|    122|        options.insert(Options::ENABLE_STRIKETHROUGH);
  768|    122|        options.insert(Options::ENABLE_TABLES);
  769|    122|        options.insert(Options::ENABLE_TASKLISTS);
  770|       |
  771|    122|        let parser = Parser::new_ext(markdown, options);
  772|    122|        let mut elements = Vec::new();
  773|    122|        let events = parser.collect::<Vec<_>>();
  774|       |
  775|    122|        let mut i = 0;
  776|       |        // Track header slug occurrences for stable de-duplication
  777|    122|        let mut slug_counts: HashMap<String, usize> = HashMap::new();
  778|  1.03k|        while i < events.len() {
  779|    913|            i = self.parse_element(&events, i, &mut elements, &mut slug_counts)?;
                                                                                             ^0
  780|       |        }
  781|       |
  782|    122|        Ok(elements)
  783|    122|    }
  784|       |
  785|       |    /// Parse a single element from the event stream
  786|    913|    fn parse_element(
  787|    913|        &self,
  788|    913|        events: &[Event],
  789|    913|        start: usize,
  790|    913|        elements: &mut Vec<MarkdownElement>,
  791|    913|        slug_counts: &mut HashMap<String, usize>,
  792|    913|    ) -> Result<usize, anyhow::Error> {
  793|    913|        match &events[start] {
  794|       |            Event::Start(Tag::Paragraph) => {
  795|       |                // Always preserve line breaks in paragraphs (consistent with blockquotes)
  796|       |                // This allows poetry, lyrics, and structured content to render correctly
  797|    293|                let (spans, next_idx) =
  798|    293|                    self.parse_inline_spans_with_breaks(events, start + 1, Tag::Paragraph, true)?;
                                                                                                              ^0
  799|    293|                if !spans.is_empty() {
  800|    293|                    elements.push(MarkdownElement::Paragraph(spans));
  801|    293|                }
                              ^0
  802|    293|                Ok(next_idx)
  803|       |            }
  804|       |            // Images encountered outside paragraphs: treat as a single paragraph with an inline image
  805|      0|            Event::Start(Tag::Image(_, url, title)) => {
  806|      0|                let (alt, next_idx) = self.collect_until_tag_end(
  807|      0|                    events,
  808|      0|                    start + 1,
  809|      0|                    Tag::Image(LinkType::Inline, "".into(), "".into()),
  810|      0|                )?;
  811|      0|                let mut spans: Vec<InlineSpan> = Vec::new();
  812|      0|                spans.push(InlineSpan::Image {
  813|      0|                    src: url.to_string(),
  814|      0|                    alt,
  815|      0|                    title: if title.is_empty() {
  816|      0|                        None
  817|       |                    } else {
  818|      0|                        Some(title.to_string())
  819|       |                    },
  820|       |                });
  821|      0|                elements.push(MarkdownElement::Paragraph(spans));
  822|      0|                Ok(next_idx)
  823|       |            }
  824|    329|            Event::Start(Tag::Heading(level, _, _)) => {
  825|    329|                let (spans, next_idx) =
  826|    329|                    self.parse_inline_spans(events, start + 1, Tag::Heading(*level, None, vec![]))?;
                                                                                                                ^0
  827|    329|                let title_text = Self::spans_plain_text(&spans);
  828|    329|                let base = Self::slugify(&title_text);
  829|    329|                let count = slug_counts.entry(base.clone()).or_insert(0);
  830|    329|                let id = if *count == 0 {
  831|    327|                    base.clone()
  832|       |                } else {
  833|      2|                    format!("{}-{}", base, *count)
  834|       |                };
  835|    329|                *count += 1;
  836|    329|                elements.push(MarkdownElement::Header {
  837|    329|                    level: *level as u8,
  838|    329|                    spans,
  839|    329|                    id,
  840|    329|                });
  841|    329|                Ok(next_idx)
  842|       |            }
  843|       |            Event::Start(Tag::CodeBlock(_)) => {
  844|      7|                let (code_text, language, next_idx) = self.parse_code_block(events, start)?;
                                                                                                        ^0
  845|      7|                elements.push(MarkdownElement::CodeBlock {
  846|      7|                    language,
  847|      7|                    text: code_text,
  848|      7|                });
  849|      7|                Ok(next_idx)
  850|       |            }
  851|    187|            Event::Start(Tag::List(first_item)) => {
  852|    187|                let (items, next_idx) = self.parse_list(events, start + 1, *first_item, 0)?;
                                                                                                        ^0
  853|    187|                elements.push(MarkdownElement::List {
  854|    187|                    ordered: first_item.is_some(),
  855|    187|                    items,
  856|    187|                });
  857|    187|                Ok(next_idx)
  858|       |            }
  859|       |            Event::Rule => {
  860|     82|                elements.push(MarkdownElement::HorizontalRule);
  861|     82|                Ok(start + 1)
  862|       |            }
  863|       |            Event::Start(Tag::BlockQuote) => {
  864|      6|                let (quotes, next_idx) = self.collect_blockquotes(events, start + 1, 1)?;
                                                                                                     ^0
  865|     15|                for (depth, lines) in quotes {
                                   ^9     ^9
  866|      9|                    if !lines.is_empty() {
  867|      9|                        elements.push(MarkdownElement::Quote { depth, lines });
  868|      9|                    }
                                  ^0
  869|       |                }
  870|      6|                Ok(next_idx)
  871|       |            }
  872|       |            Event::Start(Tag::Table(_)) => {
  873|      9|                let (headers, rows, next_idx) = self.parse_table(events, start + 1)?;
                                                                                                 ^0
  874|      9|                elements.push(MarkdownElement::Table { headers, rows });
  875|      9|                Ok(next_idx)
  876|       |            }
  877|       |            _ => {
  878|       |                // Skip other events
  879|      0|                Ok(start + 1)
  880|       |            }
  881|       |        }
  882|    913|    }
  883|       |
  884|       |    // Build a slug from text similar to GitHub: lowercase, spaces->dashes, strip punctuation
  885|    329|    fn slugify(text: &str) -> String {
  886|    329|        let mut out = String::with_capacity(text.len());
  887|    329|        let mut last_dash = false;
  888|  4.40k|        for ch in text.chars() {
                                ^329 ^329
  889|  4.40k|            let c = ch.to_ascii_lowercase();
  890|  4.40k|            if c.is_ascii_alphanumeric() {
  891|  4.07k|                out.push(c);
  892|  4.07k|                last_dash = false;
  893|  4.07k|            } else if c.is_whitespace() || c == '-' {
                                    ^331^331               ^9
  894|    325|                if !last_dash && !out.is_empty() {
                                               ^321
  895|    321|                    out.push('-');
  896|    321|                    last_dash = true;
  897|    321|                }
                              ^4
  898|      6|            } else {
  899|      6|                // drop punctuation/symbols
  900|      6|            }
  901|       |        }
  902|       |        // Trim trailing dash if any
  903|    329|        if out.ends_with('-') {
  904|      0|            out.pop();
  905|    329|        }
  906|    329|        out
  907|    329|    }
  908|       |
  909|    357|    fn spans_plain_text(spans: &[InlineSpan]) -> String {
  910|    357|        let mut s = String::new();
  911|    719|        for span in spans {
                          ^362
  912|    362|            match span {
  913|    357|                InlineSpan::Text(t)
  914|      1|                | InlineSpan::Strong(t)
  915|      0|                | InlineSpan::Emphasis(t)
  916|    358|                | InlineSpan::Strikethrough(t) => s.push_str(t),
                                                          ^0
  917|      1|                InlineSpan::Code(t) => s.push_str(t),
  918|      1|                InlineSpan::Link { text, .. } => s.push_str(text),
  919|      2|                InlineSpan::Image { alt, title, .. } => {
  920|      2|                    if !alt.is_empty() {
  921|      2|                        s.push_str(alt);
  922|      2|                    }
                                  ^0
  923|      2|                    if let Some(t) = title {
                                              ^1
  924|      1|                        if !t.is_empty() {
  925|      1|                            if !s.is_empty() {
  926|      1|                                s.push(' ');
  927|      1|                            }
                                          ^0
  928|      1|                            s.push_str(t);
  929|      0|                        }
  930|      1|                    }
  931|       |                }
  932|       |            }
  933|       |        }
  934|    357|        s
  935|    357|    }
  936|       |
  937|       |    /// Extract plain text from all markdown elements
  938|      5|    pub fn elements_to_plain_text(elements: &[MarkdownElement]) -> String {
  939|      5|        let mut result = String::new();
  940|     12|        for element in elements.iter() {
                                     ^5       ^5
  941|     12|            match element {
  942|      4|                MarkdownElement::Paragraph(spans) | MarkdownElement::Header { spans, .. } => {
                                                                                            ^2
  943|      6|                    if !result.is_empty() {
  944|      2|                        result.push('\n');
  945|      4|                    }
  946|      6|                    result.push_str(&Self::spans_plain_text(spans));
  947|       |                }
  948|      2|                MarkdownElement::CodeBlock { text, .. } => {
  949|      2|                    if !result.is_empty() {
  950|      1|                        result.push('\n');
  951|      1|                    }
  952|      2|                    result.push_str(text);
  953|       |                }
  954|      1|                MarkdownElement::List { items, .. } => {
  955|      2|                    for item in items {
                                      ^1
  956|      1|                        if !result.is_empty() {
  957|      1|                            result.push('\n');
  958|      1|                        }
                                      ^0
  959|      1|                        result.push_str(&Self::spans_plain_text(item));
  960|       |                    }
  961|       |                }
  962|      1|                MarkdownElement::Quote { lines, .. } => {
  963|      2|                    for line in lines {
                                      ^1
  964|      1|                        if !result.is_empty() {
  965|      1|                            result.push('\n');
  966|      1|                        }
                                      ^0
  967|      1|                        result.push_str(&Self::spans_plain_text(line));
  968|       |                    }
  969|       |                }
  970|      1|                MarkdownElement::Table { headers, rows } => {
  971|       |                    // Headers
  972|      2|                    for header in headers {
                                      ^1
  973|      1|                        if !result.is_empty() {
  974|      1|                            result.push('\n');
  975|      1|                        }
                                      ^0
  976|      1|                        result.push_str(&Self::spans_plain_text(header));
  977|       |                    }
  978|       |                    // Rows
  979|      2|                    for row in rows {
                                      ^1
  980|      2|                        for cell in row {
                                          ^1
  981|      1|                            if !result.is_empty() {
  982|      1|                                result.push('\n');
  983|      1|                            }
                                          ^0
  984|      1|                            result.push_str(&Self::spans_plain_text(cell));
  985|       |                        }
  986|       |                    }
  987|       |                }
  988|       |                MarkdownElement::HorizontalRule => {
  989|      1|                    if !result.is_empty() {
  990|      1|                        result.push_str("\n---\n");
  991|      1|                    }
                                  ^0
  992|       |                }
  993|       |            }
  994|       |        }
  995|      5|        result
  996|      5|    }
  997|       |
  998|       |    /// Collect blockquotes into (depth, lines) entries; supports nesting and multi-line content
  999|      9|    fn collect_blockquotes(
 1000|      9|        &self,
 1001|      9|        events: &[Event],
 1002|      9|        start: usize,
 1003|      9|        depth: u8,
 1004|      9|    ) -> Result<(Vec<(u8, QuoteLines)>, usize), anyhow::Error> {
 1005|      9|        let mut i = start;
 1006|      9|        let mut result: Vec<(u8, QuoteLines)> = Vec::new();
 1007|      9|        let mut lines: QuoteLines = Vec::new();
 1008|      9|        let mut current: Vec<InlineSpan> = Vec::new();
 1009|       |
 1010|     12|        let push_line = |current: &mut Vec<InlineSpan>, lines: &mut QuoteLines| {
                          ^9
 1011|     12|            lines.push(std::mem::take(current));
 1012|     12|        };
 1013|       |
 1014|     21|        while i < events.len() {
 1015|     21|            match &events[i] {
 1016|       |                Event::Start(Tag::Paragraph) => {
 1017|      9|                    let (mut para, next) =
 1018|      9|                        self.parse_inline_spans_with_breaks(events, i + 1, Tag::Paragraph, true)?;
                                                                                                              ^0
 1019|       |                    // Split para into lines on explicit "\n"
 1020|      9|                    let mut line: Vec<InlineSpan> = Vec::new();
 1021|     28|                    while let Some(span) = para.first().cloned() {
                                                 ^19
 1022|     19|                        para.remove(0);
 1023|     17|                        match span {
 1024|     17|                            InlineSpan::Text(t) if t.contains('\n') => {
                                                           ^3                   ^3
 1025|      3|                                let parts: Vec<&str> = t.split('\n').collect();
 1026|      6|                                for (pi, part) in parts.iter().enumerate() {
                                                                ^3           ^3
 1027|      6|                                    if !part.is_empty() {
 1028|      0|                                        line.push(InlineSpan::Text(part.to_string()));
 1029|      6|                                    }
 1030|      6|                                    if pi < parts.len() - 1 {
 1031|      3|                                        push_line(&mut line, &mut lines);
 1032|      3|                                        line = Vec::new();
 1033|      3|                                    }
 1034|       |                                }
 1035|       |                            }
 1036|     16|                            other => line.push(other),
 1037|       |                        }
 1038|       |                    }
 1039|      9|                    if !line.is_empty() {
 1040|      9|                        push_line(&mut line, &mut lines);
 1041|      9|                    }
                                  ^0
 1042|      9|                    i = next;
 1043|       |                }
 1044|      0|                Event::SoftBreak | Event::HardBreak => {
 1045|      0|                    push_line(&mut current, &mut lines);
 1046|      0|                    i += 1;
 1047|      0|                }
 1048|       |                Event::Start(Tag::BlockQuote) => {
 1049|       |                    // flush current collected lines for this depth
 1050|      3|                    if !current.is_empty() {
 1051|      0|                        push_line(&mut current, &mut lines);
 1052|      3|                    }
 1053|      3|                    if !lines.is_empty() {
 1054|      3|                        result.push((depth, std::mem::take(&mut lines)));
 1055|      3|                    }
                                  ^0
 1056|       |                    // collect nested
 1057|      3|                    let (nested, next) = self.collect_blockquotes(events, i + 1, depth + 1)?;
                                                                                                         ^0
 1058|      3|                    result.extend(nested);
 1059|      3|                    i = next;
 1060|       |                }
 1061|       |                Event::End(Tag::BlockQuote) => {
 1062|      9|                    if !current.is_empty() {
 1063|      0|                        push_line(&mut current, &mut lines);
 1064|      9|                    }
 1065|      9|                    if !lines.is_empty() {
 1066|      6|                        result.push((depth, lines));
 1067|      6|                    }
                                  ^3
 1068|      9|                    return Ok((result, i + 1));
 1069|       |                }
 1070|      0|                _ => {
 1071|      0|                    i += 1;
 1072|      0|                }
 1073|       |            }
 1074|       |        }
 1075|      0|        if !current.is_empty() {
 1076|      0|            push_line(&mut current, &mut lines);
 1077|      0|        }
 1078|      0|        if !lines.is_empty() {
 1079|      0|            result.push((depth, lines));
 1080|      0|        }
 1081|      0|        Ok((result, i))
 1082|      9|    }
 1083|       |
 1084|       |    /// Parse inline spans until reaching the end tag
 1085|    747|    fn parse_inline_spans_with_breaks(
 1086|    747|        &self,
 1087|    747|        events: &[Event],
 1088|    747|        start: usize,
 1089|    747|        end_tag: Tag,
 1090|    747|        keep_breaks: bool,
 1091|    747|    ) -> Result<(Vec<InlineSpan>, usize), anyhow::Error> {
 1092|    747|        let mut spans = Vec::new();
 1093|    747|        let mut i = start;
 1094|    747|        let mut text_buffer = String::new();
 1095|       |
 1096|  1.63k|        while i < events.len() {
 1097|  1.63k|            match &events[i] {
 1098|    747|                Event::End(tag)
 1099|    747|                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
 1100|       |                {
 1101|    747|                    if !text_buffer.is_empty() {
 1102|    624|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1103|    624|                        text_buffer.clear();
 1104|    624|                    }
                                  ^123
 1105|    747|                    return Ok((spans, i + 1));
 1106|       |                }
 1107|    707|                Event::Text(text) => {
 1108|    707|                    text_buffer.push_str(text);
 1109|    707|                    i += 1;
 1110|    707|                }
 1111|       |                Event::SoftBreak | Event::HardBreak => {
 1112|     19|                    if keep_breaks {
 1113|     19|                        if !text_buffer.is_empty() {
 1114|     14|                            spans.push(InlineSpan::Text(text_buffer.clone()));
 1115|     14|                            text_buffer.clear();
 1116|     14|                        }
                                      ^5
 1117|     19|                        spans.push(InlineSpan::Text("\n".to_string()));
 1118|      0|                    } else {
 1119|      0|                        text_buffer.push(' ');
 1120|      0|                    }
 1121|     19|                    i += 1;
 1122|       |                }
 1123|     46|                Event::Code(code) => {
 1124|     46|                    if !text_buffer.is_empty() {
 1125|     16|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1126|     16|                        text_buffer.clear();
 1127|     30|                    }
 1128|     46|                    spans.push(InlineSpan::Code(code.to_string()));
 1129|     46|                    i += 1;
 1130|       |                }
 1131|       |                Event::Start(Tag::Strong) => {
 1132|     11|                    if !text_buffer.is_empty() {
 1133|      2|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1134|      2|                        text_buffer.clear();
 1135|      9|                    }
 1136|     11|                    let (inner_text, next_i) =
 1137|     11|                        self.collect_until_tag_end(events, i + 1, Tag::Strong)?;
                                                                                            ^0
 1138|     11|                    spans.push(InlineSpan::Strong(inner_text));
 1139|     11|                    i = next_i;
 1140|       |                }
 1141|       |                Event::Start(Tag::Emphasis) => {
 1142|     82|                    if !text_buffer.is_empty() {
 1143|      5|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1144|      5|                        text_buffer.clear();
 1145|     77|                    }
 1146|     82|                    let (inner_text, next_i) =
 1147|     82|                        self.collect_until_tag_end(events, i + 1, Tag::Emphasis)?;
                                                                                              ^0
 1148|     82|                    spans.push(InlineSpan::Emphasis(inner_text));
 1149|     82|                    i = next_i;
 1150|       |                }
 1151|       |                Event::Start(Tag::Strikethrough) => {
 1152|      2|                    if !text_buffer.is_empty() {
 1153|      2|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1154|      2|                        text_buffer.clear();
 1155|      2|                    }
                                  ^0
 1156|      2|                    let (inner_text, next_i) =
 1157|      2|                        self.collect_until_tag_end(events, i + 1, Tag::Strikethrough)?;
                                                                                                   ^0
 1158|      2|                    spans.push(InlineSpan::Strikethrough(inner_text));
 1159|      2|                    i = next_i;
 1160|       |                }
 1161|     11|                Event::Start(Tag::Link(_, url, _)) => {
 1162|     11|                    if !text_buffer.is_empty() {
 1163|      6|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1164|      6|                        text_buffer.clear();
 1165|      6|                    }
                                  ^5
 1166|     11|                    let url_str = url.to_string();
 1167|     11|                    let (link_text, next_i) = self.collect_until_tag_end(
 1168|     11|                        events,
 1169|     11|                        i + 1,
 1170|     11|                        Tag::Link(LinkType::Inline, "".into(), "".into()),
 1171|      0|                    )?;
 1172|     11|                    spans.push(InlineSpan::Link {
 1173|     11|                        text: link_text,
 1174|     11|                        url: url_str,
 1175|     11|                    });
 1176|     11|                    i = next_i;
 1177|       |                }
 1178|     10|                Event::Start(Tag::Image(_, url, title)) => {
 1179|     10|                    if !text_buffer.is_empty() {
 1180|      2|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1181|      2|                        text_buffer.clear();
 1182|      8|                    }
 1183|     10|                    let url_str = url.to_string();
 1184|     10|                    let (alt_text, next_i) = self.collect_until_tag_end(
 1185|     10|                        events,
 1186|     10|                        i + 1,
 1187|     10|                        Tag::Image(LinkType::Inline, "".into(), "".into()),
 1188|      0|                    )?;
 1189|     10|                    spans.push(InlineSpan::Image {
 1190|     10|                        src: url_str,
 1191|     10|                        alt: alt_text,
 1192|     10|                        title: if title.is_empty() {
 1193|      1|                            None
 1194|       |                        } else {
 1195|      9|                            Some(title.to_string())
 1196|       |                        },
 1197|       |                    });
 1198|     10|                    i = next_i;
 1199|       |                }
 1200|      1|                _ => {
 1201|      1|                    i += 1;
 1202|      1|                }
 1203|       |            }
 1204|       |        }
 1205|       |
 1206|      0|        if !text_buffer.is_empty() {
 1207|      0|            spans.push(InlineSpan::Text(text_buffer));
 1208|      0|        }
 1209|       |
 1210|      0|        Ok((spans, i))
 1211|    747|    }
 1212|       |
 1213|       |    /// Default inline parsing without preserving explicit line breaks
 1214|    329|    fn parse_inline_spans(
 1215|    329|        &self,
 1216|    329|        events: &[Event],
 1217|    329|        start: usize,
 1218|    329|        end_tag: Tag,
 1219|    329|    ) -> Result<(Vec<InlineSpan>, usize), anyhow::Error> {
 1220|    329|        self.parse_inline_spans_with_breaks(events, start, end_tag, false)
 1221|    329|    }
 1222|       |
 1223|       |    /// Collect text until a specific end tag
 1224|    731|    fn collect_until_tag_end(
 1225|    731|        &self,
 1226|    731|        events: &[Event],
 1227|    731|        start: usize,
 1228|    731|        end_tag: Tag,
 1229|    731|    ) -> Result<(String, usize), anyhow::Error> {
 1230|    731|        let mut text = String::new();
 1231|    731|        let mut i = start;
 1232|       |
 1233|  1.46k|        while i < events.len() {
 1234|  1.46k|            match &events[i] {
 1235|    733|                Event::End(tag)
 1236|    733|                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
                                                                                                   ^731
 1237|       |                {
 1238|    731|                    return Ok((text, i + 1));
 1239|       |                }
 1240|    731|                Event::Text(t) => {
 1241|    731|                    text.push_str(t);
 1242|    731|                }
 1243|      0|                Event::Code(code) => {
 1244|      0|                    text.push_str(code);
 1245|      0|                }
 1246|      4|                _ => {}
 1247|       |            }
 1248|    735|            i += 1;
 1249|       |        }
 1250|       |
 1251|      0|        Ok((text, i))
 1252|    731|    }
 1253|       |
 1254|       |    /// Parse a code block
 1255|      7|    fn parse_code_block(
 1256|      7|        &self,
 1257|      7|        events: &[Event],
 1258|      7|        start: usize,
 1259|      7|    ) -> Result<(String, Option<String>, usize), anyhow::Error> {
 1260|      7|        let mut language = None;
 1261|      7|        let mut code_text = String::new();
 1262|      7|        let mut i = start;
 1263|       |
 1264|       |        // Extract language from the start tag
 1265|      7|        if let Event::Start(Tag::CodeBlock(kind)) = &events[start] {
 1266|      7|            if let pulldown_cmark::CodeBlockKind::Fenced(lang) = kind {
 1267|      7|                if !lang.is_empty() {
 1268|      7|                    language = Some(lang.to_string());
 1269|      7|                }
                              ^0
 1270|      0|            }
 1271|      7|            i += 1;
 1272|      0|        }
 1273|       |
 1274|     14|        while i < events.len() {
 1275|     14|            match &events[i] {
 1276|       |                Event::End(Tag::CodeBlock(_)) => {
 1277|      7|                    return Ok((code_text, language, i + 1));
 1278|       |                }
 1279|      7|                Event::Text(text) => {
 1280|      7|                    code_text.push_str(text);
 1281|      7|                }
 1282|      0|                _ => {}
 1283|       |            }
 1284|      7|            i += 1;
 1285|       |        }
 1286|       |
 1287|      0|        Ok((code_text, language, i))
 1288|      7|    }
 1289|       |
 1290|       |    /// Parse a list with basic nested-list flattening
 1291|    192|    fn parse_list(
 1292|    192|        &self,
 1293|    192|        events: &[Event],
 1294|    192|        start: usize,
 1295|    192|        first_item: Option<u64>,
 1296|    192|        depth: usize,
 1297|    192|    ) -> Result<(Vec<Vec<InlineSpan>>, usize), anyhow::Error> {
 1298|    192|        let mut items: Vec<Vec<InlineSpan>> = Vec::new();
 1299|    192|        let mut i = start;
 1300|    192|        let _is_ordered = first_item.is_some();
 1301|       |
 1302|    919|        while i < events.len() {
 1303|    919|            match &events[i] {
 1304|    192|                Event::End(Tag::List(_)) => return Ok((items, i + 1)),
 1305|       |                Event::Start(Tag::Item) => {
 1306|    727|                    i += 1;
 1307|    727|                    let mut spans: Vec<InlineSpan> = Vec::new();
 1308|       |                    loop {
 1309|  2.57k|                        if i >= events.len() {
 1310|      0|                            break;
 1311|  2.57k|                        }
 1312|  2.57k|                        match &events[i] {
 1313|       |                            Event::End(Tag::Item) => {
 1314|    727|                                i += 1;
 1315|    727|                                break;
 1316|       |                            }
 1317|       |                            Event::Start(Tag::Paragraph) => {
 1318|      0|                                let (ps, next) =
 1319|      0|                                    self.parse_inline_spans(events, i + 1, Tag::Paragraph)?;
 1320|      0|                                spans.extend(ps);
 1321|      0|                                i = next;
 1322|       |                            }
 1323|    264|                            Event::Code(code) => {
 1324|    264|                                spans.push(InlineSpan::Code(code.to_string()));
 1325|    264|                                i += 1;
 1326|    264|                            }
 1327|       |                            Event::Start(Tag::Emphasis) => {
 1328|      3|                                let (inner_text, next) =
 1329|      3|                                    self.collect_until_tag_end(events, i + 1, Tag::Emphasis)?;
                                                                                                          ^0
 1330|      3|                                spans.push(InlineSpan::Emphasis(inner_text));
 1331|      3|                                i = next;
 1332|       |                            }
 1333|       |                            Event::Start(Tag::Strong) => {
 1334|    587|                                let (inner_text, next) =
 1335|    587|                                    self.collect_until_tag_end(events, i + 1, Tag::Strong)?;
                                                                                                        ^0
 1336|    587|                                spans.push(InlineSpan::Strong(inner_text));
 1337|    587|                                i = next;
 1338|       |                            }
 1339|       |                            Event::Start(Tag::Strikethrough) => {
 1340|      3|                                let (inner_text, next) =
 1341|      3|                                    self.collect_until_tag_end(events, i + 1, Tag::Strikethrough)?;
                                                                                                               ^0
 1342|      3|                                spans.push(InlineSpan::Strikethrough(inner_text));
 1343|      3|                                i = next;
 1344|       |                            }
 1345|     22|                            Event::Start(Tag::Link(_, url, _)) => {
 1346|     22|                                let url_str = url.to_string();
 1347|     22|                                let (link_text, next) = self.collect_until_tag_end(
 1348|     22|                                    events,
 1349|     22|                                    i + 1,
 1350|     22|                                    Tag::Link(LinkType::Inline, "".into(), "".into()),
 1351|      0|                                )?;
 1352|     22|                                spans.push(InlineSpan::Link {
 1353|     22|                                    text: link_text,
 1354|     22|                                    url: url_str,
 1355|     22|                                });
 1356|     22|                                i = next;
 1357|       |                            }
 1358|      0|                            Event::Start(Tag::Image(_, url, title)) => {
 1359|      0|                                let url_str = url.to_string();
 1360|      0|                                let (alt_text, next) = self.collect_until_tag_end(
 1361|      0|                                    events,
 1362|      0|                                    i + 1,
 1363|      0|                                    Tag::Image(LinkType::Inline, "".into(), "".into()),
 1364|      0|                                )?;
 1365|      0|                                spans.push(InlineSpan::Image {
 1366|      0|                                    src: url_str,
 1367|      0|                                    alt: alt_text,
 1368|      0|                                    title: if title.is_empty() {
 1369|      0|                                        None
 1370|       |                                    } else {
 1371|      0|                                        Some(title.to_string())
 1372|       |                                    },
 1373|       |                                });
 1374|      0|                                i = next;
 1375|       |                            }
 1376|      5|                            Event::Start(Tag::List(child_first)) => {
 1377|      5|                                let (child_items, next) =
 1378|      5|                                    self.parse_list(events, i + 1, *child_first, depth + 1)?;
                                                                                                         ^0
 1379|      5|                                i = next;
 1380|      5|                                let ordered_child = child_first.is_some();
 1381|      9|                                for (idx, child) in child_items.into_iter().enumerate() {
                                                                  ^5          ^5          ^5
 1382|      9|                                    spans.push(InlineSpan::Text("\n".to_string()));
 1383|       |                                    // Indentation: 4 spaces per nested level
 1384|      9|                                    let indent = " ".repeat(4 * (depth + 1));
 1385|      9|                                    let marker = if ordered_child {
 1386|      4|                                        format!("{}.", idx + 1)
 1387|       |                                    } else {
 1388|      5|                                        "-".to_string()
 1389|       |                                    };
 1390|      9|                                    spans.push(InlineSpan::Text(format!("{}{} ", indent, marker)));
 1391|      9|                                    spans.extend(child);
 1392|       |                                }
 1393|       |                            }
 1394|    961|                            Event::Text(t) => {
 1395|    961|                                spans.push(InlineSpan::Text(t.to_string()));
 1396|    961|                                i += 1;
 1397|    961|                            }
 1398|      0|                            Event::SoftBreak | Event::HardBreak => {
 1399|      0|                                spans.push(InlineSpan::Text(" ".into()));
 1400|      0|                                i += 1;
 1401|      0|                            }
 1402|      0|                            _ => {
 1403|      0|                                i += 1;
 1404|      0|                            }
 1405|       |                        }
 1406|       |                    }
 1407|    727|                    items.push(spans);
 1408|       |                }
 1409|      0|                _ => i += 1,
 1410|       |            }
 1411|       |        }
 1412|       |
 1413|      0|        Ok((items, i))
 1414|    192|    }
 1415|       |
 1416|       |    /// Parse a table with headers and rows
 1417|      9|    fn parse_table(
 1418|      9|        &self,
 1419|      9|        events: &[Event],
 1420|      9|        start: usize,
 1421|      9|    ) -> Result<TableParseResult, anyhow::Error> {
 1422|      9|        let mut headers: Vec<Vec<InlineSpan>> = Vec::new();
 1423|      9|        let mut rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
 1424|      9|        let mut i = start;
 1425|       |
 1426|     63|        while i < events.len() {
 1427|     63|            match &events[i] {
 1428|       |                Event::Start(Tag::TableHead) => {
 1429|      9|                    i += 1;
 1430|     27|                    while i < events.len() {
 1431|     27|                        match &events[i] {
 1432|       |                            Event::Start(Tag::TableCell) => {
 1433|     18|                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
 1434|     18|                                    events,
 1435|     18|                                    i + 1,
 1436|     18|                                    Tag::TableCell,
 1437|       |                                    true,
 1438|      0|                                )?;
 1439|     18|                                headers.push(spans);
 1440|     18|                                i = next_idx;
 1441|       |                            }
 1442|       |                            Event::End(Tag::TableHead) => {
 1443|      9|                                i += 1;
 1444|      9|                                break;
 1445|       |                            }
 1446|      0|                            _ => i += 1,
 1447|       |                        }
 1448|       |                    }
 1449|       |                }
 1450|       |                Event::Start(Tag::TableRow) => {
 1451|     45|                    i += 1;
 1452|     45|                    let mut row: Vec<Vec<InlineSpan>> = Vec::new();
 1453|    143|                    while i < events.len() {
 1454|    143|                        match &events[i] {
 1455|       |                            Event::Start(Tag::TableCell) => {
 1456|     98|                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
 1457|     98|                                    events,
 1458|     98|                                    i + 1,
 1459|     98|                                    Tag::TableCell,
 1460|       |                                    true,
 1461|      0|                                )?;
 1462|     98|                                row.push(spans);
 1463|     98|                                i = next_idx;
 1464|       |                            }
 1465|       |                            Event::End(Tag::TableRow) => {
 1466|     45|                                i += 1;
 1467|     45|                                if !row.is_empty() {
 1468|     45|                                    rows.push(row);
 1469|     45|                                }
                                              ^0
 1470|     45|                                break;
 1471|       |                            }
 1472|      0|                            _ => i += 1,
 1473|       |                        }
 1474|       |                    }
 1475|       |                }
 1476|      9|                Event::End(Tag::Table(_)) => return Ok((headers, rows, i + 1)),
 1477|      0|                _ => i += 1,
 1478|       |            }
 1479|       |        }
 1480|      0|        Ok((headers, rows, i))
 1481|      9|    }
 1482|       |
 1483|       |    /// Render parsed markdown elements to egui UI
 1484|     13|    pub fn render_to_ui(&self, ui: &mut egui::Ui, elements: &[MarkdownElement]) {
 1485|       |        // Clear header rects before rendering a new frame
 1486|     13|        self.header_rects.borrow_mut().clear();
 1487|       |        // Reset per-frame link counter to ensure link IDs are stable across frames
 1488|     13|        *self.link_counter.borrow_mut() = 0;
 1489|       |        // Reset per-frame element rects
 1490|     13|        self.element_rects.borrow_mut().clear();
 1491|     23|        for (element_idx, element) in elements.iter().enumerate() {
                                                    ^13      ^13    ^13
 1492|       |            // Wrap each element in a no-op frame to capture its rect
 1493|     23|            let ir = egui::Frame::none().show(ui, |ui| {
 1494|     23|                match element {
 1495|     12|                    MarkdownElement::Paragraph(spans) => {
 1496|     12|                        self.render_inline_spans(ui, spans);
 1497|     12|                        ui.add_space(4.0);
 1498|     12|                    }
 1499|      1|                    MarkdownElement::Quote { depth, lines } => {
 1500|      1|                        ui.add_space(4.0);
 1501|      1|                        let bar_width = 3.0;
 1502|      1|                        let bar_gap = 6.0;
 1503|      1|                        let left_pad = 10.0 + (*depth as f32) * (bar_width + bar_gap);
 1504|       |                        // Substack-like styling: dark grey block with orange accent bars and white text
 1505|      1|                        let bg = Color32::from_rgb(24, 24, 24);
 1506|       |
 1507|      1|                        let resp = egui::Frame::none()
 1508|      1|                            .fill(bg)
 1509|      1|                            .stroke(Stroke::new(1.0, Color32::from_rgb(40, 40, 40)))
 1510|      1|                            .rounding(egui::Rounding::same(6.0))
 1511|      1|                            .inner_margin(egui::Margin {
 1512|      1|                                left: left_pad,
 1513|      1|                                right: 10.0,
 1514|      1|                                top: 8.0,
 1515|      1|                                bottom: 8.0,
 1516|      1|                            })
 1517|      1|                            .show(ui, |ui| {
 1518|      2|                                for (li, line) in lines.iter().enumerate() {
                                                                ^1           ^1
 1519|       |                                    // White text for quote content
 1520|      2|                                    ui.style_mut().visuals.override_text_color =
 1521|      2|                                        Some(Color32::WHITE);
 1522|      2|                                    self.render_inline_spans(ui, line);
 1523|      2|                                    ui.style_mut().visuals.override_text_color = None;
 1524|      2|                                    if li + 1 < lines.len() {
 1525|      1|                                        ui.add_space(3.0);
 1526|      1|                                    }
 1527|       |                                }
 1528|      1|                            });
 1529|       |
 1530|       |                        // Draw vertical orange quote bars on the left of the frame
 1531|      1|                        let rect = resp.response.rect;
 1532|      1|                        let top = rect.top() + 6.0;
 1533|      1|                        let bottom = rect.bottom() - 6.0;
 1534|      1|                        let bar_color = Color32::from_rgb(255, 103, 25); // Substack-like orange
 1535|      1|                        for d in 0..*depth {
 1536|      1|                            let x = rect.left() + 6.0 + (d as f32) * (bar_width + bar_gap);
 1537|      1|                            let bar_rect = egui::Rect::from_min_max(
 1538|      1|                                egui::pos2(x, top),
 1539|      1|                                egui::pos2(x + bar_width, bottom),
 1540|      1|                            );
 1541|      1|                            ui.painter().rect_filled(bar_rect, 2.0, bar_color);
 1542|      1|                        }
 1543|       |
 1544|      1|                        ui.add_space(6.0);
 1545|       |                    }
 1546|      4|                    MarkdownElement::Header { level, spans, id } => {
 1547|      4|                        let font_size = match level {
 1548|      4|                            1 => self.font_sizes.h1,
 1549|      0|                            2 => self.font_sizes.h2,
 1550|      0|                            3 => self.font_sizes.h3,
 1551|      0|                            4 => self.font_sizes.h4,
 1552|      0|                            5 => self.font_sizes.h5,
 1553|      0|                            6 => self.font_sizes.h6,
 1554|      0|                            _ => self.font_sizes.body,
 1555|       |                        };
 1556|       |
 1557|      4|                        ui.add_space(8.0);
 1558|      4|                        let resp = ui.horizontal_wrapped(|ui| {
 1559|       |                            // Avoid artificial gaps between header fragments
 1560|      4|                            ui.spacing_mut().item_spacing.x = 0.0;
 1561|      8|                            for span in spans {
                                              ^4
 1562|      4|                                self.render_inline_span(ui, span, Some(font_size), Some(true));
 1563|      4|                            }
 1564|      4|                        });
 1565|       |                        // Record the header rect for in-document navigation
 1566|      4|                        self.header_rects
 1567|      4|                            .borrow_mut()
 1568|      4|                            .insert(id.clone(), resp.response.rect);
 1569|      4|                        ui.add_space(6.0);
 1570|       |                    }
 1571|      1|                    MarkdownElement::CodeBlock { language, text } => {
 1572|      1|                        self.render_code_block(ui, language.as_deref(), text);
 1573|      1|                    }
 1574|      1|                    MarkdownElement::List { ordered, items } => {
 1575|      1|                        self.render_list(ui, *ordered, items);
 1576|      1|                    }
 1577|      1|                    MarkdownElement::HorizontalRule => {
 1578|      1|                        ui.add_space(8.0);
 1579|      1|                        ui.separator();
 1580|      1|                        ui.add_space(8.0);
 1581|      1|                    }
 1582|      3|                    MarkdownElement::Table { headers, rows } => {
 1583|      3|                        self.render_table(ui, headers, rows, element_idx);
 1584|      3|                    }
 1585|       |                }
 1586|     23|            });
 1587|     23|            self.element_rects.borrow_mut().push(ir.response.rect);
 1588|       |        }
 1589|       |        // Add a little extra breathing room at the end so
 1590|       |        // the final line doesn't sit flush under the status bar.
 1591|     13|        ui.add_space(16.0);
 1592|     13|    }
 1593|       |
 1594|       |    /// Render inline spans in a wrapped horizontal layout
 1595|     14|    fn render_inline_spans(&self, ui: &mut egui::Ui, spans: &[InlineSpan]) {
 1596|     14|        ui.horizontal_wrapped(|ui| {
 1597|       |            // Avoid adding UI spacing between inline fragments
 1598|     14|            ui.spacing_mut().item_spacing.x = 0.0;
 1599|     62|            for span in spans {
                              ^48
 1600|     48|                self.render_inline_span(ui, span, None, None);
 1601|     48|            }
 1602|     14|        });
 1603|     14|    }
 1604|       |
 1605|       |    /// Fix Unicode characters that may not render properly in the default font
 1606|     87|    fn fix_unicode_chars(&self, text: &str) -> String {
 1607|     87|        let normalized: String = text.nfc().collect();
 1608|    504|        if !normalized.chars().any(|c| {
                          ^87                ^87
 1609|    502|            matches!(
 1610|    504|                c,
 1611|       |                '\u{2011}'
 1612|       |                    | '\u{00AD}'
 1613|       |                    | '\u{2010}'
 1614|       |                    | '\u{2212}'
 1615|       |                    | '\u{2013}'
 1616|       |                    | '\u{2014}'
 1617|       |                    | '\u{00A0}'
 1618|       |                    | '\u{202F}'
 1619|       |                    | '\u{2190}'
 1620|       |                    | '\u{2192}'
 1621|       |                    | '\u{2191}'
 1622|       |                    | '\u{2193}'
 1623|       |            )
 1624|    504|        }) {
 1625|     85|            return normalized;
 1626|      2|        }
 1627|       |
 1628|      2|        let mut out = String::with_capacity(normalized.len());
 1629|     12|        for ch in normalized.chars() {
                                ^2         ^2
 1630|     12|            match ch {
 1631|       |                '\u{2011}' | '\u{00AD}' | '\u{2010}' | '\u{2212}' | '\u{2013}' | '\u{2014}' => {
 1632|      1|                    out.push('-')
 1633|       |                }
 1634|      1|                '\u{00A0}' | '\u{202F}' => out.push(' '),
 1635|      1|                '\u{2190}' => {
 1636|      1|                    out.push('<');
 1637|      1|                    out.push('-');
 1638|      1|                }
 1639|      1|                '\u{2192}' => {
 1640|      1|                    out.push('-');
 1641|      1|                    out.push('>');
 1642|      1|                }
 1643|      1|                '\u{2191}' => {
 1644|      1|                    out.push('^');
 1645|      1|                }
 1646|      1|                '\u{2193}' => {
 1647|      1|                    out.push('v');
 1648|      1|                }
 1649|      6|                _ => out.push(ch),
 1650|       |            }
 1651|       |        }
 1652|      2|        out
 1653|     87|    }
 1654|       |
 1655|       |    #[cfg(test)]
 1656|      3|    pub(crate) fn normalize_text_for_test(&self, text: &str) -> String {
 1657|      3|        self.fix_unicode_chars(text)
 1658|      3|    }
 1659|       |
 1660|       |    /// Render a single inline span    /// Render a single inline span
 1661|     67|    fn render_inline_span(
 1662|     67|        &self,
 1663|     67|        ui: &mut egui::Ui,
 1664|     67|        span: &InlineSpan,
 1665|     67|        font_size: Option<f32>,
 1666|     67|        strong: Option<bool>,
 1667|     67|    ) {
 1668|     67|        let size = font_size.unwrap_or(self.font_sizes.body);
 1669|     67|        let is_strong = strong.unwrap_or(false);
 1670|       |
 1671|     67|        match span {
 1672|     52|            InlineSpan::Text(text) => {
 1673|     52|                let fixed_text = self.fix_unicode_chars(text);
 1674|     52|                let style = InlineStyle {
 1675|     52|                    strong: is_strong,
 1676|     52|                    ..Default::default()
 1677|     52|                };
 1678|     52|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 1679|     52|            }
 1680|      1|            InlineSpan::Code(code) => {
 1681|       |                // Inline code: adapt style to theme (light vs dark)
 1682|      1|                ui.spacing_mut().item_spacing.x = 0.0;
 1683|      1|                let is_dark = ui.visuals().dark_mode;
 1684|      1|                let (bg, fg) = if is_dark {
 1685|      0|                    (
 1686|      0|                        Color32::from_rgb(30, 30, 30),
 1687|      0|                        Color32::from_rgb(180, 255, 180),
 1688|      0|                    )
 1689|       |                } else {
 1690|       |                    // Light theme: white background with readable code color
 1691|      1|                    (Color32::WHITE, Color32::from_rgb(60, 80, 150))
 1692|       |                };
 1693|      1|                let response = ui.add(
 1694|      1|                    egui::Label::new(
 1695|      1|                        RichText::new(code.clone())
 1696|      1|                            .size(self.font_sizes.code)
 1697|      1|                            .family(egui::FontFamily::Monospace)
 1698|      1|                            .background_color(bg)
 1699|      1|                            .color(fg),
 1700|       |                    )
 1701|      1|                    .wrap(false),
 1702|       |                );
 1703|       |
 1704|       |                // Add context menu for code
 1705|      1|                response.context_menu(|ui| {
                                                         ^0
 1706|      0|                    self.render_inline_code_context_menu(ui, code);
 1707|      0|                });
 1708|       |            }
 1709|      2|            InlineSpan::Strong(text) => {
 1710|      2|                let fixed_text = self.fix_unicode_chars(text);
 1711|      2|                let style = InlineStyle {
 1712|      2|                    strong: true,
 1713|      2|                    ..Default::default()
 1714|      2|                };
 1715|      2|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 1716|      2|            }
 1717|      1|            InlineSpan::Emphasis(text) => {
 1718|      1|                let fixed_text = self.fix_unicode_chars(text);
 1719|      1|                let style = InlineStyle {
 1720|      1|                    italics: true,
 1721|      1|                    strong: is_strong,
 1722|      1|                    ..Default::default()
 1723|      1|                };
 1724|      1|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 1725|      1|            }
 1726|      1|            InlineSpan::Strikethrough(text) => {
 1727|      1|                let fixed_text = self.fix_unicode_chars(text);
 1728|      1|                let style = InlineStyle {
 1729|      1|                    strike: true,
 1730|      1|                    strong: is_strong,
 1731|      1|                    ..Default::default()
 1732|      1|                };
 1733|      1|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 1734|      1|            }
 1735|      4|            InlineSpan::Link { text, url } => {
 1736|      4|                let fixed_text = self.fix_unicode_chars(text);
 1737|      4|                let group = ui.horizontal_wrapped(|ui| {
 1738|       |                    // Render link-like styled text with emoji expansion
 1739|      4|                    let color = if Self::is_external_url(url) {
 1740|       |                        // Slightly different color to indicate external website links
 1741|      2|                        Color32::from_rgb(120, 190, 255)
 1742|       |                    } else {
 1743|      2|                        Color32::LIGHT_BLUE
 1744|       |                    };
 1745|      4|                    let style = InlineStyle {
 1746|      4|                        strong: is_strong,
 1747|      4|                        color: Some(color),
 1748|      4|                        ..Default::default()
 1749|      4|                    };
 1750|      4|                    self.render_text_with_emojis(ui, &fixed_text, size, style);
 1751|      4|                });
 1752|       |                // Use a unique id per link occurrence to avoid collisions when the same URL appears multiple times
 1753|      4|                let mut counter = self.link_counter.borrow_mut();
 1754|      4|                let id = egui::Id::new(format!("link:{}:{}", *counter, url));
 1755|      4|                *counter += 1;
 1756|      4|                let r = ui.interact(group.response.rect, id, egui::Sense::click());
 1757|      4|                if render_action_triggered(r.hovered(), "link_hover") {
 1758|      2|                    ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
 1759|      2|                }
 1760|      4|                if render_action_triggered(r.clicked(), "link_click") {
 1761|      2|                    self.trigger_link(url);
 1762|      2|                }
 1763|       |
 1764|       |                // Add context menu for links
 1765|      4|                r.context_menu(|ui| {
                                                  ^0
 1766|      0|                    self.render_link_context_menu(ui, text, url);
 1767|      0|                });
 1768|       |            }
 1769|      6|            InlineSpan::Image { src, alt, title } => {
 1770|       |                // Resolve path
 1771|      6|                let resolved = self.resolve_image_path(src);
 1772|      6|                let available_w = ui.available_width().max(1.0);
 1773|       |                // Try to get or load texture
 1774|      6|                if let Some((tex, w, h)) = self.get_or_load_image_texture(ui, &resolved) {
                                           ^3   ^3 ^3
 1775|      3|                    let (tw, th) = (w as f32, h as f32);
 1776|       |                    // Scale logic:
 1777|       |                    // - Start at UI scale (e.g., 1.0 for 100%, 1.1 for 110%).
 1778|       |                    // - Only downscale further if it would exceed available width.
 1779|      3|                    let base_scale = self.ui_scale();
 1780|      3|                    let scaled_w = tw * base_scale;
 1781|      3|                    let scale = if scaled_w > available_w {
 1782|      0|                        (available_w / tw).clamp(0.01, 4.0)
 1783|       |                    } else {
 1784|      3|                        base_scale
 1785|       |                    };
 1786|      3|                    let size = egui::vec2((tw * scale).round(), (th * scale).round());
 1787|      3|                    let image = egui::Image::new(&tex).fit_to_exact_size(size);
 1788|      3|                    let resp = ui.add(image);
 1789|      3|                    if let Some(t) = title {
 1790|      3|                        if !t.is_empty() {
 1791|      3|                            if render_action_triggered(resp.hovered(), "image_hover") {
 1792|      1|                                resp.on_hover_text(t.clone());
 1793|      2|                            }
 1794|       |                            // Subtle caption below image
 1795|      3|                            ui.add_space(2.0);
 1796|      3|                            ui.label(
 1797|      3|                                RichText::new(t.clone())
 1798|      3|                                    .size(self.font_sizes.body - 2.0)
 1799|      3|                                    .color(Color32::from_rgb(140, 140, 140)),
 1800|       |                            );
 1801|      0|                        }
 1802|      0|                    }
 1803|      3|                    ui.add_space(6.0);
 1804|       |                } else {
 1805|       |                    // Placeholder with alt and error info
 1806|      3|                    egui::Frame::none()
 1807|      3|                        .fill(Color32::from_rgb(30, 30, 30))
 1808|      3|                        .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 1809|      3|                        .inner_margin(8.0)
 1810|      3|                        .show(ui, |ui| {
 1811|      3|                            let msg = if src.starts_with("http://") || src.starts_with("https://") {
 1812|      1|                                "Remote images are disabled"
 1813|       |                            } else {
 1814|      2|                                "Image not found or unsupported"
 1815|       |                            };
 1816|      3|                            let label = if alt.is_empty() {
 1817|      1|                                src.as_str()
 1818|       |                            } else {
 1819|      2|                                alt.as_str()
 1820|       |                            };
 1821|      3|                            ui.label(
 1822|      3|                                RichText::new(format!("{}\n{}", label, msg))
 1823|      3|                                    .size(self.font_sizes.body),
 1824|       |                            );
 1825|      3|                        });
 1826|      3|                    ui.add_space(6.0);
 1827|       |                }
 1828|       |            }
 1829|       |        }
 1830|     67|    }
 1831|       |
 1832|      7|    fn extract_fragment(url: &str) -> Option<String> {
 1833|      7|        if let Some(stripped) = url.strip_prefix('#') {
                                  ^3
 1834|       |            // Already a fragment within current document
 1835|      3|            return Some(stripped.to_ascii_lowercase());
 1836|      4|        }
 1837|      4|        None
 1838|      7|    }
 1839|       |
 1840|      8|    fn is_external_url(url: &str) -> bool {
 1841|      8|        let lower = url.to_ascii_lowercase();
 1842|      8|        lower.starts_with("http://")
 1843|      8|            || lower.starts_with("https://")
 1844|      3|            || lower.starts_with("mailto:")
 1845|      3|            || lower.starts_with("www.")
 1846|      8|    }
 1847|       |
 1848|     60|    fn render_text_with_emojis(
 1849|     60|        &self,
 1850|     60|        ui: &mut egui::Ui,
 1851|     60|        text: &str,
 1852|     60|        size: f32,
 1853|     60|        style: InlineStyle,
 1854|     60|    ) {
 1855|     60|        let mut buffer = String::new();
 1856|    316|        for g in text.graphemes(true) {
                               ^60  ^60
 1857|    316|            if let Some(key) = self.emoji_key_for_grapheme(g) {
                                      ^0
 1858|       |                // Flush buffered text first (with highlighting if active)
 1859|      0|                if !buffer.is_empty() {
 1860|      0|                    self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
 1861|      0|                    buffer.clear();
 1862|      0|                }
 1863|      0|                let handle = self.get_or_make_emoji_texture(ui, &key);
 1864|      0|                let sz = size * 1.2;
 1865|      0|                ui.add(egui::Image::new(&handle).max_width(sz).max_height(sz));
 1866|    316|            } else {
 1867|    316|                buffer.push_str(g);
 1868|    316|            }
 1869|       |        }
 1870|     60|        if !buffer.is_empty() {
 1871|     60|            self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
 1872|     60|        }
                      ^0
 1873|     60|    }
 1874|       |
 1875|     60|    fn render_text_segment_with_optional_highlight(
 1876|     60|        &self,
 1877|     60|        ui: &mut egui::Ui,
 1878|     60|        segment: &str,
 1879|     60|        size: f32,
 1880|     60|        style: InlineStyle,
 1881|     60|    ) {
 1882|       |        // First expand emoji shortcodes, then superscript ^...^ notation
 1883|     60|        let expanded = Self::expand_shortcodes(segment);
 1884|     60|        let expanded = Self::expand_superscripts(&expanded);
 1885|     60|        if let Some(h) = self
                                  ^19
 1886|     60|            .highlight_phrase
 1887|     60|            .borrow()
 1888|     60|            .as_ref()
 1889|     60|            .filter(|s| !s.is_empty())
                                       ^19^19
 1890|       |        {
 1891|     24|            for (range, highlighted) in self.highlight_segments(&expanded, Some(h)) {
                                                      ^19  ^19                ^19        ^19
 1892|     24|                if range.is_empty() {
 1893|      0|                    continue;
 1894|     24|                }
 1895|     24|                let slice = &expanded[range];
 1896|     24|                if highlighted {
 1897|      5|                    self.render_highlighted_segment(ui, slice, size, style);
 1898|     19|                } else {
 1899|     19|                    self.render_plain_segment(ui, slice, size, style);
 1900|     19|                }
 1901|       |            }
 1902|     19|            return;
 1903|     41|        }
 1904|     41|        self.render_plain_segment(ui, &expanded, size, style);
 1905|     60|    }
 1906|       |
 1907|     60|    fn render_plain_segment(&self, ui: &mut egui::Ui, text: &str, size: f32, style: InlineStyle) {
 1908|     60|        if text.is_empty() {
 1909|      0|            return;
 1910|     60|        }
 1911|     60|        let mut rich = RichText::new(text).size(size);
 1912|     60|        if style.strong {
 1913|      8|            rich = rich.strong();
 1914|     52|        }
 1915|     60|        if style.italics {
 1916|      1|            rich = rich.italics();
 1917|     59|        }
 1918|     60|        if style.strike {
 1919|      1|            rich = rich.strikethrough();
 1920|     59|        }
 1921|     60|        if let Some(color) = style.color {
                                  ^4
 1922|      4|            rich = rich.color(color);
 1923|     56|        }
 1924|     60|        let response = ui.add(egui::Label::new(rich).wrap(true));
 1925|       |
 1926|       |        // Add context menu for text
 1927|       |        // Note: Due to egui limitations, selection is cleared on right-click
 1928|       |        // As a workaround, we provide "Copy Text" for the segment
 1929|     60|        response.context_menu(|ui| {
                                                 ^0
 1930|      0|            self.render_text_context_menu(ui, text);
 1931|      0|        });
 1932|     60|    }
 1933|       |
 1934|      5|    fn render_highlighted_segment(
 1935|      5|        &self,
 1936|      5|        ui: &mut egui::Ui,
 1937|      5|        text: &str,
 1938|      5|        size: f32,
 1939|      5|        style: InlineStyle,
 1940|      5|    ) {
 1941|      5|        if text.is_empty() {
 1942|      0|            return;
 1943|      5|        }
 1944|      5|        let visuals = ui.visuals();
 1945|      5|        let bg = visuals.selection.bg_fill;
 1946|      5|        let mut text_color = style.color;
 1947|      5|        let fallback_color = visuals.selection.stroke.color;
 1948|      5|        if text_color.is_none() {
 1949|      5|            text_color = Some(fallback_color);
 1950|      5|        }
                      ^0
 1951|       |
 1952|      5|        let mut rich = RichText::new(text).size(size).background_color(bg);
 1953|      5|        if style.strong {
 1954|      0|            rich = rich.strong();
 1955|      5|        }
 1956|      5|        if style.italics {
 1957|      0|            rich = rich.italics();
 1958|      5|        }
 1959|      5|        if style.strike {
 1960|      0|            rich = rich.strikethrough();
 1961|      5|        }
 1962|      5|        if let Some(color) = text_color {
 1963|      5|            rich = rich.color(color);
 1964|      5|        }
                      ^0
 1965|      5|        let response = ui.add(egui::Label::new(rich).wrap(true));
 1966|       |
 1967|       |        // Add context menu for highlighted text
 1968|      5|        response.context_menu(|ui| {
                                                 ^0
 1969|      0|            self.render_text_context_menu(ui, text);
 1970|      0|        });
 1971|      5|    }
 1972|       |
 1973|      1|    fn render_text_context_menu(&self, ui: &mut egui::Ui, text: &str) {
 1974|      1|        if ui.button("Copy Text").clicked() {
 1975|      0|            self.copy_text_and_close(ui, text);
 1976|      1|        }
 1977|      1|        ui.label("Tip: Use Ctrl+C to copy selected text");
 1978|      1|    }
 1979|       |
 1980|      1|    fn render_inline_code_context_menu(&self, ui: &mut egui::Ui, code: &str) {
 1981|      1|        if ui.button("Copy Code").clicked() {
 1982|      0|            self.copy_text_and_close(ui, code);
 1983|      1|        }
 1984|      1|    }
 1985|       |
 1986|      1|    fn render_code_block_context_menu(
 1987|      1|        &self,
 1988|      1|        ui: &mut egui::Ui,
 1989|      1|        code: &str,
 1990|      1|        language: Option<&str>,
 1991|      1|    ) {
 1992|      1|        if ui.button("Copy Code").clicked() {
 1993|      0|            self.copy_text_and_close(ui, code);
 1994|      1|        }
 1995|      1|        if let Some(lang) = language {
 1996|      1|            if ui.button(format!("Copy as {}", lang)).clicked() {
 1997|      0|                self.copy_text_and_close(ui, &format!("```{}\n{}\n```", lang, code));
 1998|      1|            }
 1999|      0|        }
 2000|      1|    }
 2001|       |
 2002|      1|    fn render_link_context_menu(&self, ui: &mut egui::Ui, text: &str, url: &str) {
 2003|      1|        if ui.button("Open Link").clicked() {
 2004|      0|            self.trigger_link(url);
 2005|      0|            ui.close_menu();
 2006|      1|        }
 2007|      1|        ui.separator();
 2008|      1|        if ui.button("Copy Link Text").clicked() {
 2009|      0|            self.copy_text_and_close(ui, text);
 2010|      1|        }
 2011|      1|        if ui.button("Copy Link URL").clicked() {
 2012|      0|            self.copy_text_and_close(ui, url);
 2013|      1|        }
 2014|      1|    }
 2015|       |
 2016|      1|    fn render_cell_context_menu(&self, ui: &mut egui::Ui, text: &str) {
 2017|      1|        if ui.button("Copy Cell Text").clicked() {
 2018|      0|            self.copy_text_and_close(ui, text);
 2019|      1|        }
 2020|      1|    }
 2021|       |
 2022|      1|    fn copy_text_and_close(&self, ui: &mut egui::Ui, text: &str) {
 2023|      1|        ui.ctx().copy_text(text.to_string());
 2024|      1|        ui.close_menu();
 2025|      1|    }
 2026|       |
 2027|       |    /// Map a grapheme cluster to an emoji image key if available.
 2028|    317|    fn emoji_key_for_grapheme(&self, g: &str) -> Option<String> {
 2029|    317|        if crate::emoji_catalog::image_bytes_for(g).is_some() {
 2030|      1|            return Some(g.to_string());
 2031|    316|        }
 2032|    316|        let stripped: String = g.chars().filter(|&c| c != '\u{FE0F}').collect();
 2033|    316|        if stripped != g && crate::emoji_catalog::image_bytes_for(&stripped).is_some() {
                                          ^0                                               ^0
 2034|      0|            return Some(stripped);
 2035|    316|        }
 2036|       |        // If the grapheme explicitly requests emoji presentation (contains VS16),
 2037|       |        // treat it as an emoji even if we don't have a sprite; fall back to a
 2038|       |        // generated placeholder via emoji_assets to avoid stray tofu.
 2039|    316|        if g.chars().any(|c| c == '\u{FE0F}') {
 2040|      0|            return Some(stripped); // prefer stripped as the texture key
 2041|    316|        }
 2042|    316|        None
 2043|    317|    }
 2044|       |
 2045|      1|    fn get_or_make_emoji_texture(&self, ui: &mut egui::Ui, emoji: &str) -> egui::TextureHandle {
 2046|      1|        if let Some(tex) = self.emoji_textures.borrow().get(emoji) {
                                  ^0
 2047|      0|            return tex.clone();
 2048|      1|        }
 2049|       |
 2050|      1|        let img = if let Some(bytes) = emoji_catalog::image_bytes_for(emoji) {
                                            ^0
 2051|      0|            match image::load_from_memory(bytes) {
 2052|      0|                Ok(dyn_img) => {
 2053|      0|                    let rgba = dyn_img.to_rgba8();
 2054|      0|                    let (w, h) = rgba.dimensions();
 2055|      0|                    let pixels = rgba.into_vec();
 2056|      0|                    egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &pixels)
 2057|       |                }
 2058|      0|                Err(_) => emoji_assets::make_image(emoji, 64)
 2059|      0|                    .unwrap_or_else(|| self.generate_emoji_image(emoji, 64)),
 2060|       |            }
 2061|       |        } else {
 2062|      1|            emoji_assets::make_image(emoji, 64)
 2063|      1|                .unwrap_or_else(|| self.generate_emoji_image(emoji, 64))
 2064|       |        };
 2065|      1|        let handle = ui.ctx().load_texture(
 2066|      1|            format!("emoji:{}", emoji),
 2067|      1|            img,
 2068|       |            egui::TextureOptions::LINEAR,
 2069|       |        );
 2070|      1|        self.emoji_textures
 2071|      1|            .borrow_mut()
 2072|      1|            .insert(emoji.to_string(), handle.clone());
 2073|      1|        handle
 2074|      1|    }
 2075|       |
 2076|       |    // Rough width measurement for inline spans without wrapping
 2077|      5|    fn measure_inline_spans(&self, ui: &egui::Ui, spans: &[InlineSpan]) -> f32 {
 2078|      5|        let mut width = 0.0f32;
 2079|      5|        ui.fonts(|fonts| {
 2080|     11|            for span in spans {
                              ^6
 2081|      6|                match span {
 2082|      5|                    InlineSpan::Text(t)
 2083|      0|                    | InlineSpan::Strong(t)
 2084|      0|                    | InlineSpan::Emphasis(t)
 2085|      0|                    | InlineSpan::Strikethrough(t)
 2086|      1|                    | InlineSpan::Link { text: t, .. } => {
 2087|      6|                        let body = egui::FontId::proportional(self.font_sizes.body);
 2088|       |                        // Expand shortcodes to better estimate width and count emojis
 2089|      6|                        let expanded = Self::expand_shortcodes(t);
 2090|      6|                        let galley = fonts.layout_no_wrap(expanded.clone(), body, Color32::WHITE);
 2091|      6|                        width += galley.size().x;
 2092|       |                        // Add a small extra width for emoji images (drawn larger than text)
 2093|      6|                        let emoji_extra = expanded
 2094|      6|                            .chars()
 2095|     18|                            .filter(|c| Self::is_known_emoji(*c))
                                           ^6
 2096|      6|                            .count() as f32
 2097|      6|                            * (self.font_sizes.body * 0.2);
 2098|      6|                        width += emoji_extra;
 2099|       |                    }
 2100|      0|                    InlineSpan::Code(code) => {
 2101|      0|                        let mono = egui::FontId::monospace(self.font_sizes.code);
 2102|      0|                        let galley = fonts.layout_no_wrap(code.to_string(), mono, Color32::WHITE);
 2103|      0|                        width += galley.size().x + 6.0; // small padding for code background
 2104|      0|                    }
 2105|      0|                    InlineSpan::Image { src, .. } => {
 2106|       |                        // Use cached texture size if available; otherwise a conservative thumbnail.
 2107|      0|                        let cap = (ui.available_width() * 0.6).max(48.0);
 2108|      0|                        let cached = self
 2109|      0|                            .image_textures
 2110|      0|                            .borrow()
 2111|      0|                            .get(src)
 2112|      0|                            .map(|entry| entry.size[0] as f32 * self.ui_scale());
 2113|      0|                        let approx = cached.unwrap_or(self.font_sizes.body * 12.0);
 2114|      0|                        width += approx.min(cap);
 2115|       |                    }
 2116|       |                }
 2117|      6|                width += 4.0; // spacing between spans
 2118|       |            }
 2119|      5|        });
 2120|      5|        width
 2121|      5|    }
 2122|       |
 2123|     18|    fn is_known_emoji(c: char) -> bool {
 2124|     17|        matches!(
 2125|     18|            c,
 2126|       |            '\u{1f389}' // 
 2127|       |                | '\u{2705}' // 
 2128|       |                | '\u{1f680}' // 
 2129|       |                | '\u{1f642}' // 
 2130|       |                | '\u{1f600}' // 
 2131|       |                | '\u{1f609}' // 
 2132|       |                | '\u{2b50}'  // 
 2133|       |                | '\u{1f525}' // 
 2134|       |                | '\u{1f44d}' // 
 2135|       |                | '\u{1f44e}' // 
 2136|       |                | '\u{1f4a1}' // 
 2137|       |                | '\u{2753}'  // 
 2138|       |                | '\u{2757}'  // 
 2139|       |                | '\u{1f4dd}' // 
 2140|       |                | '\u{1f9e0}' // 
 2141|       |                | '\u{1f9ea}' // 
 2142|       |                | '\u{1f4e6}' // 
 2143|       |                | '\u{1f527}' // 
 2144|       |        )
 2145|     18|    }
 2146|       |
 2147|     93|    fn expand_shortcodes(s: &str) -> String {
 2148|       |        use crate::emoji_catalog::shortcode_map;
 2149|     93|        if !s.contains(':') {
 2150|     89|            return s.to_string();
 2151|      4|        }
 2152|      4|        let mut out = String::new();
 2153|      4|        let map = shortcode_map();
 2154|      4|        let mut i = 0;
 2155|      4|        let bytes = s.as_bytes();
 2156|     41|        while i < s.len() {
 2157|     37|            if bytes[i] == b':' {
 2158|     22|                if let Some(end_rel) = bytes[i + 1..].iter().position(|&b| b == b':') {
                                          ^4         ^4                    ^4
 2159|      4|                    let end = i + 1 + end_rel;
 2160|      4|                    let code = &s[i..=end];
 2161|      4|                    if let Some(&emoji) = map.get(code) {
 2162|      4|                        out.push_str(emoji);
 2163|      4|                        i = end + 1;
 2164|      4|                        continue;
 2165|      0|                    }
 2166|      0|                }
 2167|     33|            }
 2168|       |            // advance by one UTF-8 character
 2169|     33|            let ch = s[i..].chars().next().unwrap();
 2170|     33|            out.push(ch);
 2171|     33|            i += ch.len_utf8();
 2172|       |        }
 2173|      4|        out
 2174|     93|    }
 2175|       |
 2176|       |    // Expand ^...^ segments into Unicode superscript characters when available.
 2177|       |    // Example: "5^th^" -> "5??"
 2178|     88|    fn expand_superscripts(s: &str) -> String {
 2179|     88|        if !s.contains('^') {
 2180|     84|            return s.to_string();
 2181|      4|        }
 2182|      4|        let mut out = String::new();
 2183|      4|        let mut chars = s.chars().peekable();
 2184|    160|        while let Some(c) = chars.next() {
                                     ^156
 2185|    156|            if c == '^' {
 2186|       |                // Look ahead to see if there's a matching closing caret within reasonable bounds
 2187|      6|                let mut buf = String::new();
 2188|      6|                let mut found_closing = false;
 2189|      6|                let mut temp_chars = chars.clone();
 2190|      6|                let mut char_count = 0;
 2191|       |
 2192|     17|                while let Some(&nc) = temp_chars.peek() {
 2193|     17|                    if nc == '^' {
 2194|      3|                        found_closing = true;
 2195|      3|                        break;
 2196|     14|                    }
 2197|     14|                    if !nc.is_alphanumeric() && !matches!(nc, '+' | '-' | '=' | '(' | ')') {
                                                               ^3       ^3
 2198|      3|                        break;
 2199|     11|                    }
 2200|     11|                    if char_count >= 10 {
 2201|      0|                        break;
 2202|     11|                    }
 2203|     11|                    temp_chars.next();
 2204|     11|                    char_count += 1;
 2205|       |                }
 2206|       |
 2207|      6|                if found_closing && char_count > 0 {
                                                  ^3
 2208|      3|                    for _ in 0..char_count {
 2209|      5|                        if let Some(nc) = chars.next() {
 2210|      5|                            buf.push(nc);
 2211|      5|                        }
                                      ^0
 2212|       |                    }
 2213|       |                    // Skip the closing caret
 2214|      3|                    chars.next();
 2215|      3|                    out.push_str(&Self::to_superscript(&buf));
 2216|      3|                } else {
 2217|      3|                    out.push('^');
 2218|      3|                }
 2219|    150|            } else {
 2220|    150|                out.push(c);
 2221|    150|            }
 2222|       |        }
 2223|      4|        out
 2224|     88|    }
 2225|       |
 2226|      4|    fn to_superscript(s: &str) -> String {
 2227|      4|        s.chars()
 2228|     12|            .map(|c| match c {
                           ^4
 2229|      0|                '0' => '\u{2070}',
 2230|      1|                '1' => '\u{00b9}',
 2231|      2|                '2' => '\u{00b2}',
 2232|      1|                '3' => '\u{00b3}',
 2233|      0|                '4' => '\u{2074}',
 2234|      0|                '5' => '\u{2075}',
 2235|      0|                '6' => '\u{2076}',
 2236|      0|                '7' => '\u{2077}',
 2237|      0|                '8' => '\u{2078}',
 2238|      0|                '9' => '\u{2079}',
 2239|      0|                '+' => '\u{207a}',
 2240|      0|                '-' => '\u{207b}',
 2241|      0|                '=' => '\u{207c}',
 2242|      0|                '(' => '\u{207d}',
 2243|      0|                ')' => '\u{207e}',
 2244|      1|                'a' | 'A' => '\u{1d43}',
 2245|      1|                'b' | 'B' => '\u{1d47}',
 2246|      1|                'c' | 'C' => '\u{1d9c}',
 2247|      0|                'd' | 'D' => '\u{1d48}',
 2248|      0|                'e' | 'E' => '\u{1d49}',
 2249|      0|                'f' | 'F' => '\u{1da0}',
 2250|      0|                'g' | 'G' => '\u{1d4d}',
 2251|      2|                'h' | 'H' => '\u{02b0}',
 2252|      0|                'i' | 'I' => '\u{2071}',
 2253|      0|                'j' | 'J' => '\u{02b2}',
 2254|      0|                'k' | 'K' => '\u{1d4f}',
 2255|      0|                'l' | 'L' => '\u{02e1}',
 2256|      0|                'm' | 'M' => '\u{1d50}',
 2257|      0|                'n' | 'N' => '\u{207f}',
 2258|      0|                'o' | 'O' => '\u{1d52}',
 2259|      0|                'p' | 'P' => '\u{1d56}',
 2260|      0|                'q' | 'Q' => '\u{1d56}',
 2261|      0|                'r' | 'R' => '\u{02b3}',
 2262|      0|                's' | 'S' => '\u{02e2}',
 2263|      2|                't' | 'T' => '\u{1d57}',
 2264|      0|                'u' | 'U' => '\u{1d58}',
 2265|      0|                'v' | 'V' => '\u{1d5b}',
 2266|      0|                'w' | 'W' => '\u{02b7}',
 2267|      0|                'x' | 'X' => '\u{02e3}',
 2268|      0|                'y' | 'Y' => '\u{02b8}',
 2269|      0|                'z' | 'Z' => '\u{1dbb}',
 2270|      1|                other => other,
 2271|     12|            })
 2272|      4|            .collect()
 2273|      4|    }
 2274|       |
 2275|      2|    fn generate_emoji_image(&self, emoji: &str, size: usize) -> egui::ColorImage {
 2276|       |        // Simple procedural placeholder icons to keep binary small and avoid external assets
 2277|       |        use egui::Color32 as C;
 2278|      2|        let mut img = egui::ColorImage::new([size, size], C::TRANSPARENT);
 2279|      2|        let cx = (size as i32) / 2;
 2280|      2|        let cy = cx;
 2281|      2|        let r = (size as i32) / 2 - 2;
 2282|       |
 2283|      2|        let (base, accent) = match emoji {
 2284|      2|            "\u{1f389}" => (C::from_rgb(255, 215, 0), C::from_rgb(255, 80, 80)),
                                         ^0
 2285|      2|            "\u{2705}" => (C::from_rgb(30, 150, 30), C::WHITE),
                                        ^0
 2286|      2|            "\u{1f680}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 100, 100)),
                                         ^0
 2287|      2|            "\u{1f642}" | "\u{1f600}" | "\u{1f609}" => {
 2288|      0|                (C::from_rgb(255, 205, 64), C::from_rgb(90, 60, 10))
 2289|       |            }
 2290|      2|            "\u{2b50}" => (C::from_rgb(255, 215, 0), C::WHITE),
                                        ^0
 2291|      2|            "\u{1f525}" => (C::from_rgb(255, 120, 50), C::from_rgb(255, 200, 120)),
                                         ^0
 2292|      2|            "\u{1f44d}" | "\u{1f44e}" => (C::from_rgb(200, 200, 200), C::from_rgb(80, 80, 80)),
                                                       ^0
 2293|      2|            "\u{1f4a1}" => (C::from_rgb(255, 240, 120), C::from_rgb(255, 255, 255)),
                                         ^0
 2294|      2|            "\u{2753}" | "\u{2757}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 255, 255)),
                                                     ^0
 2295|      2|            "\u{1f4dd}" => (C::from_rgb(240, 240, 200), C::from_rgb(140, 140, 140)),
                                         ^0
 2296|      2|            "\u{1f9e0}" => (C::from_rgb(220, 160, 200), C::from_rgb(255, 255, 255)),
                                         ^0
 2297|      2|            "\u{1f9ea}" => (C::from_rgb(180, 220, 255), C::from_rgb(120, 160, 240)),
                                         ^0
 2298|      2|            "\u{1f4e6}" => (C::from_rgb(205, 170, 125), C::from_rgb(150, 110, 70)),
                                         ^0
 2299|      2|            "\u{1f527}" => (C::from_rgb(160, 170, 180), C::from_rgb(220, 220, 220)),
                                         ^0
 2300|      2|            _ => (C::from_rgb(180, 180, 180), C::WHITE),
 2301|       |        };
 2302|       |
 2303|       |        // draw filled circle
 2304|     80|        for y in 0..size as i32 {
                                  ^2
 2305|  4.35k|            for x in 0..size as i32 {
                                      ^80
 2306|  4.35k|                let dx = x - cx;
 2307|  4.35k|                let dy = y - cy;
 2308|  4.35k|                if dx * dx + dy * dy <= r * r {
 2309|  2.93k|                    img[(x as usize, y as usize)] = base;
 2310|  2.93k|                }
                              ^1.41k
 2311|       |            }
 2312|       |        }
 2313|       |
 2314|       |        // add a simple accent (diagonal highlight)
 2315|     80|        for t in 0..size {
                                  ^2
 2316|     80|            let x = t as i32;
 2317|     80|            let y = (t as i32) / 2;
 2318|     80|            let xx = (x / 2 + 6).clamp(0, size as i32 - 1) as usize;
 2319|     80|            let yy = (y + 6).clamp(0, size as i32 - 1) as usize;
 2320|     80|            img[(xx, yy)] = accent;
 2321|     80|        }
 2322|       |
 2323|      2|        img
 2324|      2|    }
 2325|       |
 2326|       |    /// Render a list with proper inline formatting, including simple nested lines
 2327|       |    /// Render a list with proper inline formatting, including simple nested lines
 2328|      1|    fn render_list(&self, ui: &mut egui::Ui, ordered: bool, items: &[Vec<InlineSpan>]) {
 2329|      1|        if items.is_empty() {
 2330|      0|            return;
 2331|      1|        }
 2332|       |
 2333|      1|        ui.add_space(4.0);
 2334|       |
 2335|      2|        for (index, spans) in items.iter().enumerate() {
                                            ^1    ^1     ^1
 2336|       |            // Split into lines on embedded '\n'
 2337|      2|            let mut lines: Vec<Vec<InlineSpan>> = vec![Vec::new()];
 2338|      2|            for s in spans.clone() {
 2339|      2|                match s {
 2340|      2|                    InlineSpan::Text(t) if t.contains('\n') => {
                                                   ^0                   ^0
 2341|      0|                        let parts: Vec<&str> = t.split('\n').collect();
 2342|      0|                        for (pi, part) in parts.iter().enumerate() {
 2343|      0|                            if !part.is_empty() {
 2344|      0|                                lines
 2345|      0|                                    .last_mut()
 2346|      0|                                    .unwrap()
 2347|      0|                                    .push(InlineSpan::Text(part.to_string()));
 2348|      0|                            }
 2349|      0|                            if pi < parts.len() - 1 {
 2350|      0|                                lines.push(Vec::new());
 2351|      0|                            }
 2352|       |                        }
 2353|       |                    }
 2354|      2|                    other => lines.last_mut().unwrap().push(other),
 2355|       |                }
 2356|       |            }
 2357|       |
 2358|      2|            for (li, mut line) in lines.into_iter().enumerate() {
 2359|      2|                ui.horizontal_wrapped(|ui| {
 2360|      2|                    if li == 0 {
 2361|      2|                        let marker = if ordered {
 2362|      0|                            format!("{}.", index + 1)
 2363|       |                        } else {
 2364|      2|                            "-".to_string()
 2365|       |                        };
 2366|      2|                        let marker_color = if ui.visuals().dark_mode {
 2367|      2|                            Color32::from_rgb(180, 180, 180)
 2368|       |                        } else {
 2369|      0|                            Color32::BLACK
 2370|       |                        };
 2371|      2|                        ui.label(
 2372|      2|                            RichText::new(format!("{} ", marker))
 2373|      2|                                .size(self.font_sizes.body)
 2374|      2|                                .color(marker_color),
 2375|       |                        );
 2376|       |                    } else {
 2377|       |                        // Determine additional indentation from leading spaces in this line
 2378|      0|                        let mut leading_spaces = 0usize;
 2379|      0|                        if let Some(InlineSpan::Text(t0)) = line.first() {
 2380|      0|                            leading_spaces = t0.chars().take_while(|c| *c == ' ').count();
 2381|      0|                        }
 2382|      0|                        if leading_spaces > 0 {
 2383|      0|                            if let Some(InlineSpan::Text(t0)) = line.get_mut(0) {
 2384|      0|                                let trimmed = t0.trim_start_matches(' ').to_string();
 2385|      0|                                *t0 = trimmed;
 2386|      0|                            }
 2387|      0|                        }
 2388|      0|                        let indent_px = 18.0 + (leading_spaces as f32) * 6.0;
 2389|      0|                        ui.add_space(indent_px);
 2390|       |                    }
 2391|      2|                    ui.spacing_mut().item_spacing.x = 0.0;
 2392|      4|                    for span in &line {
                                      ^2
 2393|      2|                        self.render_inline_span(ui, span, None, None);
 2394|      2|                    }
 2395|      2|                });
 2396|       |            }
 2397|       |        }
 2398|       |
 2399|      1|        ui.add_space(4.0);
 2400|      1|    }
 2401|       |
 2402|       |    /// Render a code block with syntax highlighting
 2403|      3|    fn render_code_block(&self, ui: &mut egui::Ui, language: Option<&str>, code: &str) {
 2404|      3|        ui.add_space(8.0);
 2405|       |
 2406|       |        // Special handling for Mermaid diagrams
 2407|      3|        if let Some(lang) = language {
 2408|      3|            if lang.eq_ignore_ascii_case("mermaid") && self.render_mermaid_block(ui, code) {
                                                                     ^0   ^0                   ^0  ^0
 2409|      0|                ui.add_space(8.0);
 2410|      0|                return;
 2411|      3|            }
 2412|      0|        }
 2413|       |
 2414|      3|        let frame_response = egui::Frame::none()
 2415|      3|            .fill(Color32::from_rgb(25, 25, 25))
 2416|      3|            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2417|      3|            .inner_margin(8.0)
 2418|      3|            .show(ui, |ui| {
 2419|      3|                ui.with_layout(egui::Layout::top_down(egui::Align::LEFT), |ui| {
 2420|      3|                    if let Some(lang) = language {
 2421|      3|                        ui.label(
 2422|      3|                            RichText::new(lang)
 2423|      3|                                .size(self.font_sizes.code - 1.0)
 2424|      3|                                .color(Color32::from_rgb(150, 150, 150))
 2425|      3|                                .family(egui::FontFamily::Monospace),
 2426|      3|                        );
 2427|      3|                        ui.add_space(2.0);
 2428|      3|                    }
                                  ^0
 2429|       |
 2430|       |                    // Try syntax highlighting
 2431|      3|                    if let Some(lang) = language {
 2432|      3|                        if let Some(syntax) = self
                                                  ^2
 2433|      3|                            .find_syntax_for_language(lang)
 2434|      3|                            .or_else(|| self.syntax_set.find_syntax_by_first_line(code))
                                                      ^1              ^1                        ^1
 2435|       |                        {
 2436|      2|                            let theme = &self.theme_set.themes["base16-ocean.dark"];
 2437|      2|                            let mut h = HighlightLines::new(syntax, theme);
 2438|       |
 2439|      2|                            for line in LinesWithEndings::from(code) {
 2440|      2|                                let ranges =
 2441|      2|                                    h.highlight_line(line, &self.syntax_set).unwrap_or_default();
 2442|       |
 2443|      2|                                ui.horizontal_wrapped(|ui| {
 2444|       |                                    // Remove spacing between tokens to avoid visual gaps
 2445|      2|                                    ui.spacing_mut().item_spacing.x = 0.0;
 2446|     19|                                    for (style, text) in ranges {
                                                       ^17    ^17
 2447|       |                                        // Drop newline characters completely; they're handled by the outer line loop
 2448|     17|                                        let cleaned = text.replace(['\n', '\r'], "");
 2449|       |
 2450|     17|                                        if cleaned.is_empty() {
 2451|      1|                                            continue;
 2452|     16|                                        }
 2453|       |
 2454|       |                                        // Check if this token is pure whitespace (spaces or tabs only)
 2455|     16|                                        if cleaned.chars().all(|c| c == ' ' || c == '\t') {
                                                                                             ^12
 2456|      4|                                            // Render whitespace as transparent to preserve layout without visual gaps
 2457|      4|                                            ui.label(
 2458|      4|                                                RichText::new(cleaned)
 2459|      4|                                                    .size(self.font_sizes.code)
 2460|      4|                                                    .color(Color32::TRANSPARENT)
 2461|      4|                                                    .family(egui::FontFamily::Monospace),
 2462|      4|                                            );
 2463|      4|                                        } else {
 2464|       |                                            // For non-whitespace, use normal highlighting but replace spaces with transparent ones
 2465|     12|                                            let color = Color32::from_rgb(
 2466|     12|                                                style.foreground.r,
 2467|     12|                                                style.foreground.g,
 2468|     12|                                                style.foreground.b,
 2469|       |                                            );
 2470|       |
 2471|       |                                            // Split by spaces and handle separately
 2472|     12|                                            let parts: Vec<&str> = cleaned.split(' ').collect();
 2473|     12|                                            for (i, part) in parts.iter().enumerate() {
 2474|     12|                                                if !part.is_empty() {
 2475|     12|                                                    let mut rich_text = RichText::new(*part)
 2476|     12|                                                        .size(self.font_sizes.code)
 2477|     12|                                                        .color(color)
 2478|     12|                                                        .family(egui::FontFamily::Monospace);
 2479|       |
 2480|     12|                                                    if style.font_style.contains(
 2481|       |                                                        syntect::highlighting::FontStyle::BOLD,
 2482|      0|                                                    ) {
 2483|      0|                                                        rich_text = rich_text.strong();
 2484|     12|                                                    }
 2485|     12|                                                    if style.font_style.contains(
 2486|       |                                                        syntect::highlighting::FontStyle::ITALIC,
 2487|      0|                                                    ) {
 2488|      0|                                                        rich_text = rich_text.italics();
 2489|     12|                                                    }
 2490|       |
 2491|     12|                                                    ui.label(rich_text);
 2492|      0|                                                }
 2493|       |
 2494|       |                                                // Add transparent space between parts (except after last part)
 2495|     12|                                                if i < parts.len() - 1 {
 2496|      0|                                                    ui.label(
 2497|      0|                                                        RichText::new(" ")
 2498|      0|                                                            .size(self.font_sizes.code)
 2499|      0|                                                            .color(Color32::TRANSPARENT)
 2500|      0|                                                            .family(egui::FontFamily::Monospace),
 2501|      0|                                                    );
 2502|     12|                                                }
 2503|       |                                            }
 2504|       |                                        }
 2505|       |                                    }
 2506|      2|                                });
 2507|       |                            }
 2508|      2|                            return; // Early return if highlighting succeeded
 2509|      1|                        }
 2510|      0|                    }
 2511|       |
 2512|       |                    // Fallback: render as plain text
 2513|      1|                    ui.label(
 2514|      1|                        RichText::new(code)
 2515|      1|                            .size(self.font_sizes.code)
 2516|      1|                            .color(Color32::from_rgb(220, 220, 220))
 2517|      1|                            .family(egui::FontFamily::Monospace),
 2518|       |                    );
 2519|      3|                });
 2520|      3|            });
 2521|       |
 2522|       |        // Add context menu for code blocks
 2523|      3|        frame_response.response.context_menu(|ui| {
                                                                ^0
 2524|      0|            self.render_code_block_context_menu(ui, code, language.as_deref());
 2525|      0|        });
 2526|       |
 2527|      3|        ui.add_space(8.0);
 2528|      3|    }
 2529|       |
 2530|       |    /// Try to render a Mermaid diagram. Returns true if handled (rendered or placeholder drawn).
 2531|      4|    fn render_mermaid_block(&self, ui: &mut egui::Ui, code: &str) -> bool {
 2532|       |        // First, drain any completed Kroki jobs into local caches.
 2533|      4|        self.poll_kroki_results();
 2534|       |
 2535|       |        // If QuickJS feature is enabled, attempt rendering to SVG then rasterize like normal SVG.
 2536|       |        #[cfg(feature = "mermaid-quickjs")]
 2537|       |        {
 2538|       |            let key = Self::hash_str(code);
 2539|       |            if self.mermaid_failed.borrow().contains(&key) {
 2540|       |                // Previously failed; show brief diagnostics and bail
 2541|       |                let bytes = mermaid_embed::MERMAID_JS.len();
 2542|       |                let last = self.mermaid_last_error.borrow().clone().unwrap_or_default();
 2543|       |                egui::Frame::none().inner_margin(4.0).show(ui, |ui| {
 2544|       |                    ui.label(
 2545|       |                        RichText::new(format!(
 2546|       |                            "Mermaid skipped (prev fail). Bytes:{} Hash:{:016x}\n{}",
 2547|       |                            bytes, key, last
 2548|       |                        ))
 2549|       |                        .family(egui::FontFamily::Monospace)
 2550|       |                        .size(self.font_sizes.code),
 2551|       |                    );
 2552|       |                });
 2553|       |                return true;
 2554|       |            } else if let Some(tex) = self.get_or_load_mermaid_texture(ui, code) {
 2555|       |                let size = tex.size();
 2556|       |                let (tw, th) = (size[0] as f32, size[1] as f32);
 2557|       |                let available_w = ui.available_width().max(1.0);
 2558|       |                let base_scale = self.ui_scale();
 2559|       |                let scaled_w = tw * base_scale;
 2560|       |                let scale = if scaled_w > available_w {
 2561|       |                    (available_w / tw).clamp(0.01, 4.0)
 2562|       |                } else {
 2563|       |                    base_scale
 2564|       |                };
 2565|       |                let size = egui::vec2((tw * scale).round(), (th * scale).round());
 2566|       |                ui.add(egui::Image::new(&tex).fit_to_exact_size(size));
 2567|       |                return true;
 2568|       |            } else {
 2569|       |                // Mark as failed to avoid repeated attempts causing jank
 2570|       |                self.mermaid_failed.borrow_mut().insert(key);
 2571|       |                let bytes = mermaid_embed::MERMAID_JS.len();
 2572|       |                let last = self
 2573|       |                    .mermaid_last_error
 2574|       |                    .borrow()
 2575|       |                    .clone()
 2576|       |                    .unwrap_or_else(|| "unknown error".to_string());
 2577|       |                egui::Frame::none()
 2578|       |                    .fill(Color32::from_rgb(25, 25, 25))
 2579|       |                    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2580|       |                    .inner_margin(8.0)
 2581|       |                    .show(ui, |ui| {
 2582|       |                        ui.label(
 2583|       |                            RichText::new("Mermaid render failed; showing source.")
 2584|       |                                .color(Color32::from_rgb(200, 160, 80)),
 2585|       |                        );
 2586|       |                        ui.label(
 2587|       |                            RichText::new(format!(
 2588|       |                                "Embedded bytes:{}\nHash:{:016x}\nError:{}",
 2589|       |                                bytes, key, last
 2590|       |                            ))
 2591|       |                            .family(egui::FontFamily::Monospace)
 2592|       |                            .size(self.font_sizes.code)
 2593|       |                            .color(Color32::from_rgb(180, 180, 180)),
 2594|       |                        );
 2595|       |                    });
 2596|       |                // fall through to code block rendering
 2597|       |            }
 2598|       |        }
 2599|       |
 2600|       |        // Default path: render via Kroki service (non-blocking)
 2601|      4|        let key = Self::hash_str(code);
 2602|       |
 2603|      4|        if !Self::kroki_enabled() {
 2604|      1|            egui::Frame::none()
 2605|      1|                .fill(Color32::from_rgb(25, 25, 25))
 2606|      1|                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2607|      1|                .inner_margin(8.0)
 2608|      1|                .show(ui, |ui| {
 2609|      1|                    ui.label(
 2610|      1|                        RichText::new("Mermaid rendering via Kroki is disabled. Set MDMDVIEW_ENABLE_KROKI=1 to enable network rendering.")
 2611|      1|                            .color(Color32::from_rgb(200, 160, 80))
 2612|      1|                            .family(egui::FontFamily::Monospace)
 2613|      1|                            .size(self.font_sizes.code),
 2614|       |                    );
 2615|      1|                });
 2616|      1|            return false;
 2617|      3|        }
 2618|       |        // If we already have an SVG for this diagram, rasterize to a texture and draw it
 2619|      3|        if let Some(img_bytes) = self.kroki_svg_cache.borrow().get(&key) {
                                  ^2
 2620|       |            // Use a width-bucketed texture cache key to avoid re-rasterizing too often
 2621|      2|            let width_bucket = (ui.available_width().ceil() as u32) / 32 * 32;
 2622|      2|            let cache_key = format!("mermaid:{}:w{}", key, width_bucket);
 2623|      2|            if let Some(entry) = self.image_textures.borrow().get(&cache_key) {
                                      ^0
 2624|      0|                let tex = entry.texture.clone();
 2625|      0|                let (tw, th) = (entry.size[0] as f32, entry.size[1] as f32);
 2626|      0|                let available_w = ui.available_width().max(1.0);
 2627|      0|                let base_scale = self.ui_scale();
 2628|      0|                let scaled_w = tw * base_scale;
 2629|      0|                let scale = if scaled_w > available_w {
 2630|      0|                    (available_w / tw).clamp(0.01, 4.0)
 2631|       |                } else {
 2632|      0|                    base_scale
 2633|       |                };
 2634|      0|                let size = egui::vec2((tw * scale).round(), (th * scale).round());
 2635|      0|                ui.add(egui::Image::new(&tex).fit_to_exact_size(size));
 2636|      0|                return true;
 2637|      2|            }
 2638|       |
 2639|       |            // Decode image bytes (prefer PNG). Fallback to SVG if not raster.
 2640|      1|            if let Some((img, w, h)) =
 2641|      2|                Self::bytes_to_color_image_guess(img_bytes, Self::mermaid_bg_fill())
 2642|       |            {
 2643|      1|                let tex =
 2644|      1|                    ui.ctx()
 2645|      1|                        .load_texture(cache_key.clone(), img, egui::TextureOptions::LINEAR);
 2646|      1|                self.store_image_texture(&cache_key, tex.clone(), [w, h], None);
 2647|       |                // Draw now
 2648|      1|                let (tw, th) = (w as f32, h as f32);
 2649|      1|                let available_w = ui.available_width().max(1.0);
 2650|      1|                let base_scale = self.ui_scale();
 2651|      1|                let scaled_w = tw * base_scale;
 2652|      1|                let scale = if scaled_w > available_w {
 2653|      0|                    (available_w / tw).clamp(0.01, 4.0)
 2654|       |                } else {
 2655|      1|                    base_scale
 2656|       |                };
 2657|      1|                let size = egui::vec2((tw * scale).round(), (th * scale).round());
 2658|      1|                ui.add(egui::Image::new(&tex).fit_to_exact_size(size));
 2659|      1|                return true;
 2660|      1|            } else {
 2661|      1|                // Decode failed; record error and fall through to message/source
 2662|      1|                self.kroki_errors
 2663|      1|                    .borrow_mut()
 2664|      1|                    .insert(key, "Failed to decode diagram bytes".to_string());
 2665|      1|            }
 2666|      1|        }
 2667|       |
 2668|       |        // If there was a prior error, show diagnostics and let caller show source
 2669|      2|        if let Some(err) = self.kroki_errors.borrow().get(&key) {
                                  ^1
 2670|      1|            egui::Frame::none()
 2671|      1|                .fill(Color32::from_rgb(25, 25, 25))
 2672|      1|                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2673|      1|                .inner_margin(8.0)
 2674|      1|                .show(ui, |ui| {
 2675|      1|                    ui.label(
 2676|      1|                        RichText::new(format!(
 2677|      1|                            "Mermaid render failed via Kroki; showing source.\n{}",
 2678|       |                            err
 2679|       |                        ))
 2680|      1|                        .color(Color32::from_rgb(200, 160, 80)),
 2681|       |                    );
 2682|      1|                });
 2683|      1|            return false; // let caller render the source block
 2684|      1|        }
 2685|       |
 2686|       |        // If no job is pending, enqueue one for the worker pool
 2687|      1|        let should_schedule = {
 2688|      1|            let pending = self.kroki_pending.borrow();
 2689|      1|            !pending.contains(&key)
 2690|       |        };
 2691|      1|        let waiting_for_slot = if should_schedule {
 2692|      1|            let inflight_before = {
 2693|      1|                let pending = self.kroki_pending.borrow();
 2694|      1|                pending.len()
 2695|       |            };
 2696|      1|            match self.spawn_kroki_job(key, code) {
 2697|       |                Ok(()) => {
 2698|      0|                    self.kroki_pending.borrow_mut().insert(key);
 2699|      0|                    ui.ctx().request_repaint();
 2700|      0|                    inflight_before >= Self::MAX_KROKI_JOBS
 2701|       |                }
 2702|       |                Err(KrokiEnqueueError::QueueFull) => {
 2703|      1|                    ui.ctx().request_repaint();
 2704|      1|                    true
 2705|       |                }
 2706|       |                Err(KrokiEnqueueError::Disconnected) => {
 2707|      0|                    self.kroki_errors
 2708|      0|                        .borrow_mut()
 2709|      0|                        .insert(key, "Mermaid worker pool unavailable".to_string());
 2710|      0|                    return false;
 2711|       |                }
 2712|       |            }
 2713|       |        } else {
 2714|      0|            let pending = self.kroki_pending.borrow();
 2715|      0|            pending.len() >= Self::MAX_KROKI_JOBS
 2716|       |        };
 2717|       |
 2718|      1|        let inflight_count = self.kroki_pending.borrow().len();
 2719|       |
 2720|       |        // Show placeholder while rendering or waiting for an available worker
 2721|      1|        egui::Frame::none()
 2722|      1|            .fill(Color32::from_rgb(25, 25, 25))
 2723|      1|            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2724|      1|            .inner_margin(8.0)
 2725|      1|            .show(ui, |ui| {
 2726|      1|                let url = self.kroki_base_url();
 2727|      1|                if waiting_for_slot {
 2728|      1|                    ui.label(
 2729|      1|                        RichText::new(format!(
 2730|      1|                            "Mermaid workers busy ({}/{}) - request queued.",
 2731|      1|                            inflight_count,
 2732|      1|                            Self::MAX_KROKI_JOBS
 2733|      1|                        ))
 2734|      1|                        .color(Color32::from_rgb(200, 160, 80))
 2735|      1|                        .family(egui::FontFamily::Monospace)
 2736|      1|                        .size(self.font_sizes.code),
 2737|      1|                    );
 2738|      1|                    ui.label(
 2739|      1|                        RichText::new(format!("Queue target: {}", url))
 2740|      1|                            .color(Color32::from_rgb(160, 200, 240)),
 2741|      1|                    );
 2742|      1|                } else {
 2743|      0|                    ui.label(
 2744|      0|                        RichText::new(format!("Rendering diagram via Kroki...\n{}", url))
 2745|      0|                            .color(Color32::from_rgb(160, 200, 240)),
 2746|      0|                    );
 2747|      0|                }
 2748|      1|            });
 2749|      1|        true
 2750|      4|    }
 2751|       |
 2752|       |    #[cfg(feature = "mermaid-quickjs")]
 2753|       |    fn render_mermaid_to_svg_string(&self, code: &str) -> Option<String> {
 2754|       |        use rquickjs::{Context, Function, Runtime};
 2755|       |        // Quick check
 2756|       |        if mermaid_embed::MERMAID_JS.is_empty() {
 2757|       |            self.mermaid_last_error
 2758|       |                .borrow_mut()
 2759|       |                .replace("No embedded Mermaid JS".to_string());
 2760|       |            return None;
 2761|       |        }
 2762|       |        // Initialize engine once
 2763|       |        if self.mermaid_engine.borrow().is_none() {
 2764|       |            let rt = Runtime::new().ok()?;
 2765|       |            let ctx = Context::full(&rt).ok()?;
 2766|       |            let engine = MermaidEngine { rt, ctx };
 2767|       |            // Load library and shim
 2768|       |            let _ = engine.ctx.with(|ctx| {
 2769|       |                let shim = r#"
 2770|       |                    var window = globalThis;
 2771|       |                    var document = {
 2772|       |                      body: {},
 2773|       |                      createElement: function(tag){
 2774|       |                        return {
 2775|       |                          innerHTML: '',
 2776|       |                          setAttribute: function(){},
 2777|       |                          getAttribute: function(){ return null; },
 2778|       |                          appendChild: function(){},
 2779|       |                          querySelector: function(){ return null; },
 2780|       |                        };
 2781|       |                      },
 2782|       |                      createElementNS: function(ns, tag){ return this.createElement(tag); },
 2783|       |                      getElementById: function(){ return null; },
 2784|       |                      querySelector: function(){ return null; },
 2785|       |                    };
 2786|       |                    window.document = document;
 2787|       |                    // Minimal timers and raf
 2788|       |                    window.setTimeout = function(fn, ms){ fn(); return 1; };
 2789|       |                    window.clearTimeout = function(id){};
 2790|       |                    window.requestAnimationFrame = function(fn){ fn(0); return 1; };
 2791|       |                    window.performance = { now: function(){ return 0; } };
 2792|       |                "#;
 2793|       |                if let Err(e) = ctx.eval::<(), _>(shim) {
 2794|       |                    self.mermaid_last_error
 2795|       |                        .borrow_mut()
 2796|       |                        .replace(format!("Shim error: {}", e));
 2797|       |                }
 2798|       |                if let Ok(js) = std::str::from_utf8(mermaid_embed::MERMAID_JS) {
 2799|       |                    if let Err(e) = ctx.eval::<(), _>(js) {
 2800|       |                        self.mermaid_last_error
 2801|       |                            .borrow_mut()
 2802|       |                            .replace(format!("Mermaid eval error: {}", e));
 2803|       |                    }
 2804|       |                    if let Err(e) = ctx.eval::<(), _>(
 2805|       |                        r#"if (window.mermaid && mermaid.mermaidAPI) {
 2806|       |                               mermaid.mermaidAPI.initialize({startOnLoad: false, securityLevel: 'loose'});
 2807|       |                           } else { throw new Error('Mermaid not available'); }
 2808|       |                        "#,
 2809|       |                    ) {
 2810|       |                        self.mermaid_last_error
 2811|       |                            .borrow_mut()
 2812|       |                            .replace(format!("Mermaid init error: {}", e));
 2813|       |                    }
 2814|       |                }
 2815|       |                Ok::<(), ()>(())
 2816|       |            });
 2817|       |            self.mermaid_engine.borrow_mut().replace(engine);
 2818|       |            // One-time log for diagnostics
 2819|       |            if !*self.mermaid_init_logged.borrow() {
 2820|       |                eprintln!(
 2821|       |                    "Mermaid embedded bytes: {}",
 2822|       |                    mermaid_embed::MERMAID_JS.len()
 2823|       |                );
 2824|       |                *self.mermaid_init_logged.borrow_mut() = true;
 2825|       |            }
 2826|       |        }
 2827|       |
 2828|       |        // Use cache if available
 2829|       |        let key = Self::hash_str(code);
 2830|       |        if let Some(svg) = self.mermaid_svg_cache.borrow().get(&key) {
 2831|       |            return Some(svg.clone());
 2832|       |        }
 2833|       |
 2834|       |        // Render fresh
 2835|       |        let svg = self.mermaid_engine.borrow().as_ref().and_then(|engine| {
 2836|       |            engine.ctx.with(|ctx| {
 2837|       |                // Minimal DOM shim sufficient for mermaid.mermaidAPI.render
 2838|       |                let wrapper = r#"
 2839|       |                (function(id, code){
 2840|       |                    var svgOut = null;
 2841|       |                    mermaid.mermaidAPI.render(id, code, function(svg){ svgOut = svg; });
 2842|       |                    if (typeof svgOut !== 'string' || svgOut.length === 0) {
 2843|       |                        throw new Error('Mermaid render returned empty');
 2844|       |                    }
 2845|       |                    return svgOut;
 2846|       |                })
 2847|       |            "#;
 2848|       |                let func: Function = match ctx.eval(wrapper) {
 2849|       |                    Ok(f) => f,
 2850|       |                    Err(e) => {
 2851|       |                        self.mermaid_last_error
 2852|       |                            .borrow_mut()
 2853|       |                            .replace(format!("Wrapper eval error: {}", e));
 2854|       |                        return None;
 2855|       |                    }
 2856|       |                };
 2857|       |                let id = format!("m{:016x}", key);
 2858|       |                let svg: String = match func.call((id.as_str(), code)) {
 2859|       |                    Ok(s) => s,
 2860|       |                    Err(e) => {
 2861|       |                        self.mermaid_last_error
 2862|       |                            .borrow_mut()
 2863|       |                            .replace(format!("Mermaid call error: {}", e));
 2864|       |                        return None;
 2865|       |                    }
 2866|       |                };
 2867|       |                Some(svg)
 2868|       |            })
 2869|       |        });
 2870|       |        if let Some(svg) = svg {
 2871|       |            self.mermaid_svg_cache.borrow_mut().insert(key, svg.clone());
 2872|       |            self.mermaid_last_error.borrow_mut().take();
 2873|       |            return Some(svg);
 2874|       |        }
 2875|       |        self.mermaid_last_error
 2876|       |            .borrow_mut()
 2877|       |            .replace("Mermaid render produced no SVG".to_string());
 2878|       |        None
 2879|       |    }
 2880|       |
 2881|       |    #[cfg(feature = "mermaid-quickjs")]
 2882|       |    fn get_or_load_mermaid_texture(
 2883|       |        &self,
 2884|       |        ui: &egui::Ui,
 2885|       |        code: &str,
 2886|       |    ) -> Option<egui::TextureHandle> {
 2887|       |        let key = Self::hash_str(code);
 2888|       |        let width_bucket = (ui.available_width().ceil() as u32).saturating_sub(0) / 16 * 16;
 2889|       |        let cache_key = format!("mermaid:{}:w{}", key, width_bucket);
 2890|       |        if let Some(entry) = self.image_textures.borrow().get(&cache_key) {
 2891|       |            return Some(entry.texture.clone());
 2892|       |        }
 2893|       |        let svg = self.render_mermaid_to_svg_string(code)?;
 2894|       |        let (img, w, h) = Self::svg_bytes_to_color_image(svg.as_bytes())?;
 2895|       |        let tex = ui
 2896|       |            .ctx()
 2897|       |            .load_texture(cache_key.clone(), img, egui::TextureOptions::LINEAR);
 2898|       |        self.store_image_texture(&cache_key, tex.clone(), [w, h], None);
 2899|       |        Some(tex)
 2900|       |    }
 2901|       |
 2902|     14|    fn hash_str(s: &str) -> u64 {
 2903|     14|        let mut h = DefaultHasher::new();
 2904|     14|        s.hash(&mut h);
 2905|     14|        h.finish()
 2906|     14|    }
 2907|       |
 2908|     40|    fn hash_inline_spans(spans: &[InlineSpan]) -> u64 {
 2909|     40|        let mut h = DefaultHasher::new();
 2910|     80|        for span in spans {
                          ^40
 2911|     40|            match span {
 2912|     37|                InlineSpan::Text(t) => {
 2913|     37|                    0u8.hash(&mut h);
 2914|     37|                    t.hash(&mut h);
 2915|     37|                }
 2916|      0|                InlineSpan::Code(t) => {
 2917|      0|                    1u8.hash(&mut h);
 2918|      0|                    t.hash(&mut h);
 2919|      0|                }
 2920|      0|                InlineSpan::Strong(t) => {
 2921|      0|                    2u8.hash(&mut h);
 2922|      0|                    t.hash(&mut h);
 2923|      0|                }
 2924|      0|                InlineSpan::Emphasis(t) => {
 2925|      0|                    3u8.hash(&mut h);
 2926|      0|                    t.hash(&mut h);
 2927|      0|                }
 2928|      0|                InlineSpan::Strikethrough(t) => {
 2929|      0|                    4u8.hash(&mut h);
 2930|      0|                    t.hash(&mut h);
 2931|      0|                }
 2932|      3|                InlineSpan::Link { text, url } => {
 2933|      3|                    5u8.hash(&mut h);
 2934|      3|                    text.hash(&mut h);
 2935|      3|                    url.hash(&mut h);
 2936|      3|                }
 2937|      0|                InlineSpan::Image { src, alt, title } => {
 2938|      0|                    6u8.hash(&mut h);
 2939|      0|                    src.hash(&mut h);
 2940|      0|                    alt.hash(&mut h);
 2941|      0|                    title.hash(&mut h);
 2942|      0|                }
 2943|       |            }
 2944|       |        }
 2945|     40|        h.finish()
 2946|     40|    }
 2947|       |
 2948|      4|    fn compute_table_id(
 2949|      4|        &self,
 2950|      4|        headers: &[Vec<InlineSpan>],
 2951|      4|        rows: &[Vec<Vec<InlineSpan>>],
 2952|      4|        element_index: usize,
 2953|      4|    ) -> u64 {
 2954|      4|        let mut hasher = DefaultHasher::new();
 2955|      4|        if let Some(base) = self.base_dir.borrow().as_ref() {
                                  ^0
 2956|      0|            base.hash(&mut hasher);
 2957|      4|        }
 2958|      4|        hasher.write_usize(element_index);
 2959|      4|        hasher.write_u64(self.compute_table_content_hash(headers, rows));
 2960|      4|        hasher.finish()
 2961|      4|    }
 2962|       |
 2963|      6|    fn compute_table_content_hash(
 2964|      6|        &self,
 2965|      6|        headers: &[Vec<InlineSpan>],
 2966|      6|        rows: &[Vec<Vec<InlineSpan>>],
 2967|      6|    ) -> u64 {
 2968|      6|        let mut hasher = DefaultHasher::new();
 2969|      6|        hasher.write_usize(headers.len());
 2970|     16|        for header in headers {
                          ^10
 2971|     10|            hasher.write_u64(Self::hash_inline_spans(header));
 2972|     10|        }
 2973|      6|        let mut counted = 0usize;
 2974|     14|        for row in rows {
                          ^8
 2975|     22|            for cell in row {
                              ^14
 2976|     14|                hasher.write_u64(Self::hash_inline_spans(cell));
 2977|     14|            }
 2978|      8|            counted += 1;
 2979|      8|            if counted >= COLUMN_STATS_SAMPLE_ROWS {
 2980|      0|                break;
 2981|      8|            }
 2982|       |        }
 2983|      6|        hasher.finish()
 2984|      6|    }
 2985|       |
 2986|      2|    fn column_stats_for_table(
 2987|      2|        &self,
 2988|      2|        table_id: u64,
 2989|      2|        headers: &[Vec<InlineSpan>],
 2990|      2|        rows: &[Vec<Vec<InlineSpan>>],
 2991|      2|    ) -> Vec<ColumnStat> {
 2992|      2|        let content_hash = self.compute_table_content_hash(headers, rows);
 2993|      2|        if let Some(entry) = self
                                  ^0
 2994|      2|            .column_stats_cache
 2995|      2|            .borrow()
 2996|      2|            .get(&table_id)
 2997|      2|            .filter(|entry| entry.content_hash == content_hash)
                                          ^0                    ^0
 2998|       |        {
 2999|      0|            return entry.stats.clone();
 3000|      2|        }
 3001|      2|        let stats = compute_column_stats(headers, rows, COLUMN_STATS_SAMPLE_ROWS);
 3002|      2|        self.column_stats_cache.borrow_mut().insert(
 3003|      2|            table_id,
 3004|      2|            ColumnStatsCacheEntry {
 3005|      2|                content_hash,
 3006|      2|                stats: stats.clone(),
 3007|      2|            },
 3008|      2|        );
 3009|      2|        stats
 3010|      2|    }
 3011|       |
 3012|       |    // Drain any completed Kroki jobs and cache their results
 3013|      5|    fn poll_kroki_results(&self) {
 3014|       |        loop {
 3015|      7|            match self.kroki_rx.try_recv() {
 3016|      1|                Ok((key, Ok(svg))) => {
 3017|      1|                    self.kroki_svg_cache.borrow_mut().insert(key, svg);
 3018|      1|                    self.kroki_pending.borrow_mut().remove(&key);
 3019|      1|                }
 3020|      1|                Ok((key, Err(err))) => {
 3021|      1|                    self.kroki_errors.borrow_mut().insert(key, err);
 3022|      1|                    self.kroki_pending.borrow_mut().remove(&key);
 3023|      1|                }
 3024|      4|                Err(std::sync::mpsc::TryRecvError::Empty) => break,
 3025|      1|                Err(std::sync::mpsc::TryRecvError::Disconnected) => break,
 3026|       |            }
 3027|       |        }
 3028|      5|    }
 3029|       |
 3030|      7|    fn kroki_enabled() -> bool {
 3031|      7|        match std::env::var("MDMDVIEW_ENABLE_KROKI") {
 3032|      6|            Ok(value) => {
 3033|      6|                let normalized = value.trim().to_ascii_lowercase();
 3034|      6|                matches!(normalized.as_str(), "1" | "true" | "yes" | "on")
                              ^4                                  ^3       ^2      ^2
 3035|       |            }
 3036|      1|            Err(_) => false,
 3037|       |        }
 3038|      7|    }
 3039|       |
 3040|       |    #[cfg(test)]
 3041|      3|    pub(crate) fn kroki_enabled_for_tests() -> bool {
 3042|      3|        Self::kroki_enabled()
 3043|      3|    }
 3044|       |
 3045|      4|    fn kroki_base_url(&self) -> String {
 3046|      4|        std::env::var("MDMDVIEW_KROKI_URL").unwrap_or_else(|_| "https://kroki.io".to_string())
                                                                             ^2                 ^2
 3047|      4|    }
 3048|       |
 3049|       |    #[cfg(not(test))]
 3050|       |    fn perform_kroki_with_agent(
 3051|       |        agent: &ureq::Agent,
 3052|       |        url: &str,
 3053|       |        payload: &str,
 3054|       |    ) -> Result<Vec<u8>, String> {
 3055|       |        let resp = agent
 3056|       |            .post(url)
 3057|       |            .set("Content-Type", "text/plain")
 3058|       |            .send_string(payload)
 3059|       |            .map_err(|e| format!("ureq error: {}", e))?;
 3060|       |        if resp.status() >= 200 && resp.status() < 300 {
 3061|       |            let mut bytes: Vec<u8> = Vec::new();
 3062|       |            let mut reader = resp.into_reader();
 3063|       |            use std::io::Read as _;
 3064|       |            reader
 3065|       |                .read_to_end(&mut bytes)
 3066|       |                .map_err(|e| format!("read body: {}", e))?;
 3067|       |            if bytes.is_empty() {
 3068|       |                return Err("Empty SVG from Kroki".to_string());
 3069|       |            }
 3070|       |            Ok(bytes)
 3071|       |        } else {
 3072|       |            Err(format!("HTTP {} from Kroki", resp.status()))
 3073|       |        }
 3074|       |    }
 3075|       |
 3076|       |    #[cfg(test)]
 3077|      0|    fn perform_kroki_with_agent(
 3078|      0|        _agent: &ureq::Agent,
 3079|      0|        _url: &str,
 3080|      0|        _payload: &str,
 3081|      0|    ) -> Result<Vec<u8>, String> {
 3082|      0|        Err("Kroki disabled in tests".to_string())
 3083|      0|    }
 3084|       |
 3085|      3|    fn spawn_kroki_job(&self, key: u64, code: &str) -> Result<(), KrokiEnqueueError> {
 3086|       |        // Prefer PNG to avoid client-side SVG CSS/foreignObject limitations
 3087|      3|        let url = format!("{}/mermaid/png", self.kroki_base_url());
 3088|      3|        let payload = self.wrap_mermaid_theme(code);
 3089|      3|        match self
 3090|      3|            .kroki_job_tx
 3091|      3|            .try_send(KrokiRequest { key, url, payload })
 3092|       |        {
 3093|      0|            Ok(()) => Ok(()),
 3094|      2|            Err(TrySendError::Full(_)) => Err(KrokiEnqueueError::QueueFull),
 3095|      1|            Err(TrySendError::Disconnected(_)) => Err(KrokiEnqueueError::Disconnected),
 3096|       |        }
 3097|      3|    }
 3098|       |
 3099|      3|    fn wrap_mermaid_theme(&self, code: &str) -> String {
 3100|       |        // If user already provided an init block, respect it
 3101|      3|        if code.contains("%%{") && code.contains("}%%") && code.contains("init") {
                                                 ^0   ^0                 ^0   ^0
 3102|      0|            return code.to_string();
 3103|      3|        }
 3104|       |        // Pastel palette defaults (nice contrast on dark/light UIs)
 3105|      3|        let def_main_bkg = "#FFF8DB"; // soft warm yellow
 3106|      3|        let def_primary = "#D7EEFF"; // pastel blue (nodes)
 3107|      3|        let def_primary_border = "#9BB2C8"; // muted blue border
 3108|      3|        let def_primary_text = "#1C2430"; // dark slate text
 3109|      3|        let def_secondary = "#DFF5E1"; // pastel green
 3110|      3|        let def_tertiary = "#E9E2FF"; // pastel lavender
 3111|      3|        let def_line = "#6B7A90"; // slate lines/arrows
 3112|      3|        let def_text = "#1C2430"; // general text
 3113|      3|        let def_cluster_bkg = "#FFF1C1"; // soft yellow, slightly deeper
 3114|      3|        let def_cluster_border = "#E5C07B"; // golden
 3115|      3|        let def_default_link = def_line;
 3116|      3|        let def_title = def_text;
 3117|      3|        let def_label_bg = def_main_bkg;
 3118|      3|        let def_edge_label_bg = def_main_bkg;
 3119|       |
 3120|       |        // Allow overrides via env vars (keep defaults above if absent)
 3121|      3|        let theme_name =
 3122|      3|            std::env::var("MDMDVIEW_MERMAID_THEME").unwrap_or_else(|_| "base".to_string());
 3123|      3|        let main_bkg =
 3124|      3|            std::env::var("MDMDVIEW_MERMAID_MAIN_BKG").unwrap_or_else(|_| def_main_bkg.to_string());
 3125|      3|        let primary = std::env::var("MDMDVIEW_MERMAID_PRIMARY_COLOR")
 3126|      3|            .unwrap_or_else(|_| def_primary.to_string());
 3127|      3|        let primary_border = std::env::var("MDMDVIEW_MERMAID_PRIMARY_BORDER")
 3128|      3|            .unwrap_or_else(|_| def_primary_border.to_string());
 3129|      3|        let primary_text = std::env::var("MDMDVIEW_MERMAID_PRIMARY_TEXT")
 3130|      3|            .unwrap_or_else(|_| def_primary_text.to_string());
 3131|      3|        let secondary = std::env::var("MDMDVIEW_MERMAID_SECONDARY_COLOR")
 3132|      3|            .unwrap_or_else(|_| def_secondary.to_string());
 3133|      3|        let tertiary = std::env::var("MDMDVIEW_MERMAID_TERTIARY_COLOR")
 3134|      3|            .unwrap_or_else(|_| def_tertiary.to_string());
 3135|      3|        let line =
 3136|      3|            std::env::var("MDMDVIEW_MERMAID_LINE_COLOR").unwrap_or_else(|_| def_line.to_string());
 3137|      3|        let text =
 3138|      3|            std::env::var("MDMDVIEW_MERMAID_TEXT_COLOR").unwrap_or_else(|_| def_text.to_string());
 3139|      3|        let cluster_bkg = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BKG")
 3140|      3|            .unwrap_or_else(|_| def_cluster_bkg.to_string());
 3141|      3|        let cluster_border = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BORDER")
 3142|      3|            .unwrap_or_else(|_| def_cluster_border.to_string());
 3143|      3|        let default_link = std::env::var("MDMDVIEW_MERMAID_LINK_COLOR")
 3144|      3|            .unwrap_or_else(|_| def_default_link.to_string());
 3145|      3|        let title =
 3146|      3|            std::env::var("MDMDVIEW_MERMAID_TITLE_COLOR").unwrap_or_else(|_| def_title.to_string());
 3147|      3|        let label_bg =
 3148|      3|            std::env::var("MDMDVIEW_MERMAID_LABEL_BG").unwrap_or_else(|_| def_label_bg.to_string());
 3149|      3|        let edge_label_bg = std::env::var("MDMDVIEW_MERMAID_EDGE_LABEL_BG")
 3150|      3|            .unwrap_or_else(|_| def_edge_label_bg.to_string());
 3151|       |
 3152|      3|        let theme = format!(
 3153|      3|            concat!(
 3154|       |                "%%{{init: {{\"theme\": \"{}\", \"themeVariables\": {{",
 3155|       |                "\"background\": \"{}\", ",
 3156|       |                "\"mainBkg\": \"{}\", ",
 3157|       |                "\"textColor\": \"{}\", ",
 3158|       |                "\"titleColor\": \"{}\", ",
 3159|       |                "\"primaryColor\": \"{}\", ",
 3160|       |                "\"primaryBorderColor\": \"{}\", ",
 3161|       |                "\"primaryTextColor\": \"{}\", ",
 3162|       |                "\"secondaryColor\": \"{}\", ",
 3163|       |                "\"tertiaryColor\": \"{}\", ",
 3164|       |                "\"lineColor\": \"{}\", ",
 3165|       |                "\"defaultLinkColor\": \"{}\", ",
 3166|       |                "\"clusterBkg\": \"{}\", ",
 3167|       |                "\"clusterBorder\": \"{}\", ",
 3168|       |                "\"labelBackground\": \"{}\", ",
 3169|       |                "\"edgeLabelBackground\": \"{}\"",
 3170|       |                "}} }}%%\n"
 3171|       |            ),
 3172|       |            theme_name,
 3173|       |            main_bkg,
 3174|       |            main_bkg,
 3175|       |            text,
 3176|       |            title,
 3177|       |            primary,
 3178|       |            primary_border,
 3179|       |            primary_text,
 3180|       |            secondary,
 3181|       |            tertiary,
 3182|       |            line,
 3183|       |            default_link,
 3184|       |            cluster_bkg,
 3185|       |            cluster_border,
 3186|       |            label_bg,
 3187|       |            edge_label_bg
 3188|       |        );
 3189|      3|        format!("{}{}", theme, code)
 3190|      3|    }
 3191|       |
 3192|       |    // Choose background fill for Mermaid rasterization, based on env
 3193|      5|    fn mermaid_bg_fill() -> Option<[u8; 4]> {
 3194|       |        // Preferred: explicit color
 3195|      5|        if let Ok(hex) = std::env::var("MDMDVIEW_MERMAID_BG_COLOR") {
                                ^1
 3196|      1|            if let Some(rgba) = Self::parse_hex_color(&hex) {
 3197|      1|                return Some(rgba);
 3198|      0|            }
 3199|      4|        }
 3200|       |        // Mode selector; default to the theme's main background
 3201|      4|        let mode = std::env::var("MDMDVIEW_MERMAID_BG").unwrap_or_else(|_| "theme".to_string());
                                                                                         ^2      ^2
 3202|      4|        match mode.as_str() {
 3203|      4|            "transparent" => None,
                                           ^1
 3204|      3|            "dark" => Some([20, 20, 20, 255]),
                                    ^1
 3205|      2|            "light" => Some([255, 255, 255, 255]),
                                     ^0
 3206|       |            _ /* theme */ => {
 3207|      2|                let hex = std::env::var("MDMDVIEW_MERMAID_MAIN_BKG").unwrap_or_else(|_| "#FFF8DB".to_string());
 3208|      2|                Self::parse_hex_color(&hex).or(Some([255, 248, 219, 255]))
 3209|       |            }
 3210|       |        }
 3211|      5|    }
 3212|       |
 3213|      6|    fn parse_hex_color(s: &str) -> Option<[u8; 4]> {
 3214|      6|        let t = s.trim();
 3215|      6|        let hex = t.strip_prefix('#').unwrap_or(t);
 3216|      6|        let (r, g, b, a) = match hex.len() {
                           ^5 ^5 ^5 ^5
 3217|       |            6 => (
 3218|      4|                u8::from_str_radix(&hex[0..2], 16).ok()?,
                                                                     ^0
 3219|      4|                u8::from_str_radix(&hex[2..4], 16).ok()?,
                                                                     ^0
 3220|      4|                u8::from_str_radix(&hex[4..6], 16).ok()?,
                                                                     ^0
 3221|       |                255,
 3222|       |            ),
 3223|       |            8 => (
 3224|      1|                u8::from_str_radix(&hex[0..2], 16).ok()?,
                                                                     ^0
 3225|      1|                u8::from_str_radix(&hex[2..4], 16).ok()?,
                                                                     ^0
 3226|      1|                u8::from_str_radix(&hex[4..6], 16).ok()?,
                                                                     ^0
 3227|      1|                u8::from_str_radix(&hex[6..8], 16).ok()?,
                                                                     ^0
 3228|       |            ),
 3229|      1|            _ => return None,
 3230|       |        };
 3231|      5|        Some([r, g, b, a])
 3232|      6|    }
 3233|       |
 3234|       |    /// Render a table using an egui Grid
 3235|      3|    fn render_table(
 3236|      3|        &self,
 3237|      3|        ui: &mut egui::Ui,
 3238|      3|        headers: &[Vec<InlineSpan>],
 3239|      3|        rows: &[Vec<Vec<InlineSpan>>],
 3240|      3|        element_index: usize,
 3241|      3|    ) {
 3242|      3|        if headers.is_empty() {
 3243|      0|            return;
 3244|      3|        }
 3245|       |
 3246|      3|        if self.table_wrap_overhaul_enabled {
 3247|      2|            self.render_table_tablebuilder(ui, headers, rows, element_index);
 3248|      2|            ui.add_space(8.0);
 3249|      2|            return;
 3250|      1|        }
 3251|       |
 3252|      1|        ui.add_space(8.0);
 3253|       |
 3254|       |        const MIN_COL_MULTIPLIER: f32 = 6.0;
 3255|       |        const HARD_MIN_COL_WIDTH: f32 = 48.0;
 3256|       |        const MAX_WRAP_MULTIPLIER: f32 = 30.0;
 3257|       |
 3258|      1|        let min_floor = (self.font_sizes.body * MIN_COL_MULTIPLIER).max(HARD_MIN_COL_WIDTH);
 3259|      1|        let wrap_cap = (self.font_sizes.body * MAX_WRAP_MULTIPLIER).min(640.0);
 3260|       |
 3261|       |        // 1) Establish baseline widths from headers so small columns don't collapse
 3262|      1|        let min_widths: Vec<f32> = headers
 3263|      1|            .iter()
 3264|      2|            .map(|h| self.measure_inline_spans(ui, h).max(min_floor))
                           ^1
 3265|      1|            .collect();
 3266|      1|        if min_widths.is_empty() {
 3267|      0|            return;
 3268|      1|        }
 3269|       |
 3270|       |        // 2) Allow body cells to request more width (capped so single verbose cells don't dominate)
 3271|      1|        let mut desired_widths = min_widths.clone();
 3272|      2|        for row in rows {
                          ^1
 3273|      2|            for (ci, cell) in row.iter().enumerate() {
                                            ^1         ^1
 3274|      2|                if ci >= desired_widths.len() {
 3275|      0|                    break;
 3276|      2|                }
 3277|      2|                let measured = self.measure_inline_spans(ui, cell).max(min_floor);
 3278|      2|                desired_widths[ci] = desired_widths[ci].max(measured.min(wrap_cap));
 3279|       |            }
 3280|       |        }
 3281|       |
 3282|      1|        let available = ui.available_width().max(100.0);
 3283|      1|        let widths = Self::resolve_table_widths(available, &min_widths, &desired_widths);
 3284|       |
 3285|      1|        self.render_table_legacy(ui, headers, rows, &widths);
 3286|      1|        ui.add_space(8.0);
 3287|      3|    }
 3288|       |
 3289|      1|    fn render_table_legacy(
 3290|      1|        &self,
 3291|      1|        ui: &mut egui::Ui,
 3292|      1|        headers: &[Vec<InlineSpan>],
 3293|      1|        rows: &[Vec<Vec<InlineSpan>>],
 3294|      1|        widths: &[f32],
 3295|      1|    ) {
 3296|      1|        egui::Frame::none()
 3297|      1|            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 3298|      1|            .show(ui, |ui| {
 3299|      1|                egui::Grid::new("md_table").striped(true).show(ui, |ui| {
 3300|      2|                    for (ci, h) in headers.iter().enumerate() {
                                                 ^1      ^1     ^1
 3301|      2|                        let w = widths.get(ci).copied().unwrap_or(120.0);
 3302|      2|                        ui.push_id(("header", ci), |ui| {
 3303|      2|                            ui.allocate_ui_with_layout(
 3304|      2|                                Vec2::new(w, 0.0),
 3305|      2|                                egui::Layout::top_down(egui::Align::LEFT),
 3306|      2|                                |ui| {
 3307|      2|                                    ui.set_width(w);
 3308|      2|                                    ui.set_max_width(w);
 3309|      2|                                    self.render_table_cell_spans(ui, h, w, true);
 3310|      2|                                },
 3311|       |                            );
 3312|      2|                        });
 3313|       |                    }
 3314|      1|                    ui.end_row();
 3315|       |
 3316|      1|                    for (ri, row) in rows.iter().enumerate() {
 3317|      2|                        for (ci, cell) in row.iter().enumerate() {
                                                        ^1         ^1
 3318|      2|                            if ci < headers.len() {
 3319|      2|                                let w = widths.get(ci).copied().unwrap_or(120.0);
 3320|      2|                                ui.push_id(("cell", ri, ci), |ui| {
 3321|      2|                                    ui.allocate_ui_with_layout(
 3322|      2|                                        Vec2::new(w, 0.0),
 3323|      2|                                        egui::Layout::top_down(egui::Align::LEFT),
 3324|      2|                                        |ui| {
 3325|      2|                                            ui.set_width(w);
 3326|      2|                                            ui.set_max_width(w);
 3327|      2|                                            self.render_table_cell_spans(ui, cell, w, false);
 3328|      2|                                        },
 3329|       |                                    );
 3330|      2|                                });
 3331|      0|                            }
 3332|       |                        }
 3333|      1|                        ui.end_row();
 3334|       |                    }
 3335|      1|                });
 3336|      1|            });
 3337|      1|    }
 3338|       |
 3339|     10|    fn extend_table_rect(target: &mut Option<egui::Rect>, rect: egui::Rect) {
 3340|     10|        if rect.min.x.is_nan() || rect.min.y.is_nan() || rect.max.x.is_nan() || rect.max.y.is_nan()
 3341|       |        {
 3342|      0|            return;
 3343|     10|        }
 3344|     10|        if let Some(existing) = target {
                                  ^6
 3345|      6|            existing.min.x = existing.min.x.min(rect.min.x);
 3346|      6|            existing.min.y = existing.min.y.min(rect.min.y);
 3347|      6|            existing.max.x = existing.max.x.max(rect.max.x);
 3348|      6|            existing.max.y = existing.max.y.max(rect.max.y);
 3349|      6|        } else {
 3350|      4|            *target = Some(rect);
 3351|      4|        }
 3352|     10|    }
 3353|       |
 3354|      2|    fn render_table_tablebuilder(
 3355|      2|        &self,
 3356|      2|        ui: &mut egui::Ui,
 3357|      2|        headers: &[Vec<InlineSpan>],
 3358|      2|        rows: &[Vec<Vec<InlineSpan>>],
 3359|      2|        element_index: usize,
 3360|      2|    ) {
 3361|      2|        let table_id = self.compute_table_id(headers, rows, element_index);
 3362|      2|        let column_stats = self.column_stats_for_table(table_id, headers, rows);
 3363|      2|        let ctx =
 3364|      2|            TableColumnContext::new(headers, rows, &column_stats, self.font_sizes.body, table_id);
 3365|      2|        let mut column_specs = derive_column_specs(&ctx);
 3366|      3|        let row_max = rows.iter().map(|r| r.len()).max().unwrap_or(0);
                          ^2        ^2   ^2     ^2               ^2    ^2
 3367|      2|        let target_cols = column_specs.len().max(row_max).max(1);
 3368|      2|        while column_specs.len() < target_cols {
 3369|      0|            column_specs.push(ColumnSpec::new(
 3370|      0|                format!("Column {}", column_specs.len() + 1),
 3371|      0|                crate::table_support::ColumnPolicy::Remainder { clip: false },
 3372|      0|                None,
 3373|      0|            ));
 3374|      0|        }
 3375|      2|        self.begin_table_pass(table_id, rows.len());
 3376|      2|        self.apply_persisted_widths(table_id, &mut column_specs);
 3377|       |
 3378|      2|        let prev_spacing = ui.spacing().item_spacing;
 3379|      2|        if prev_spacing.x < 6.0 {
 3380|      0|            ui.spacing_mut().item_spacing.x = 6.0;
 3381|      2|        }
 3382|       |
 3383|       |        // Rough header height estimation using equally divided width; refines on next frame via cache.
 3384|      2|        let mut header_height = self.row_height_fallback();
 3385|      2|        if !column_specs.is_empty() {
 3386|      2|            let approx_width = (ui.available_width() / column_specs.len() as f32)
 3387|      2|                .max(self.font_sizes.body * 6.0)
 3388|      2|                .max(48.0);
 3389|      2|            let style = ui.style().clone();
 3390|      2|            header_height = headers
 3391|      2|                .iter()
 3392|      2|                .enumerate()
 3393|      4|                .map(|(ci, spans)| {
                               ^2
 3394|      4|                    let build = self.cached_layout_job(&style, None, ci, spans, approx_width, true);
 3395|      4|                    ui.fonts(|f| f.layout_job(build.job.clone()).size().y + 6.0)
 3396|      4|                })
 3397|      4|                .fold(header_height, |acc, h| acc.max(h));
                               ^2   ^2
 3398|      2|            header_height = header_height.min(self.row_height_fallback() * 3.0);
 3399|      0|        }
 3400|       |
 3401|      2|        let mut table = TableBuilder::new(ui).striped(true);
 3402|      6|        for spec in &column_specs {
                          ^4
 3403|      4|            table = table.column(spec.as_column());
 3404|      4|        }
 3405|       |
 3406|      2|        let fallback_row_height = self.row_height_fallback();
 3407|      2|        let row_heights: Vec<f32> = (0..rows.len())
 3408|      3|            .map(|idx| self.row_height_hint(table_id, idx))
                           ^2
 3409|      2|            .collect();
 3410|       |
 3411|       |        // Use RefCell to allow capturing widths from body closure.
 3412|       |        // BUG FIX: Previously captured ui.min_rect().width() which is the cell *content* width.
 3413|       |        // Now we capture body.widths() which gives the actual *allocated* column widths.
 3414|       |        // See: https://docs.rs/egui_extras/latest/egui_extras/struct.TableBody.html#method.widths
 3415|      2|        let column_widths: RefCell<Vec<f32>> = RefCell::new(vec![0.0f32; column_specs.len()]);
 3416|       |        // Track header and body rects separately for accurate table bounds calculation.
 3417|       |        // The header rect captures the header row bounds, body_rect captures body row bounds.
 3418|       |        // These are combined after rendering to get the full table rect.
 3419|      2|        let mut header_rect: Option<egui::Rect> = None;
 3420|      2|        let mut body_rect: Option<egui::Rect> = None;
 3421|       |        // body_layout_rect captures the allocated layout region from body.max_rect(),
 3422|       |        // which is more accurate than union of cell min_rects for table width.
 3423|      2|        let body_layout_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);
 3424|       |        // Track clip rects separately for header and body, then union them.
 3425|       |        // This ensures dividers respect scroll boundaries for both regions.
 3426|      2|        let mut header_clip_rect: Option<egui::Rect> = None;
 3427|      2|        let body_clip_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);
 3428|      2|        let mut painter: Option<Painter> = None;
 3429|      2|        let mut visuals: Option<Visuals> = None;
 3430|      2|        let mut ctx_snapshot: Option<Context> = None;
 3431|       |
 3432|      2|        let mut height_growth = false;
 3433|      2|        table
 3434|      2|            .header(header_height, |mut header| {
 3435|      4|                for (ci, _) in column_specs.iter().enumerate() {
                                             ^2                  ^2
 3436|      4|                    header.col(|ui| {
 3437|      4|                        let width = ui.available_width().max(1.0);
 3438|      4|                        let spans = headers.get(ci).map(|v| v.as_slice()).unwrap_or(&[]);
 3439|      4|                        let _ = self.render_overhauled_cell(ui, spans, width, true, None, ci);
 3440|       |                        // NOTE: Do NOT capture ui.min_rect().width() here - that's the content width,
 3441|       |                        // not the column width. Column widths are captured from body.widths() below.
 3442|       |                        // Extend header_rect (not body_rect) for accurate header bounds.
 3443|      4|                        Self::extend_table_rect(&mut header_rect, ui.min_rect());
 3444|      4|                        if header_clip_rect.is_none() {
 3445|      2|                            header_clip_rect = Some(ui.clip_rect());
 3446|      2|                            painter = Some(ui.painter().clone());
 3447|      2|                            visuals = Some(ui.visuals().clone());
 3448|      2|                            ctx_snapshot = Some(ui.ctx().clone());
 3449|      2|                        }
 3450|      4|                    });
 3451|       |                }
 3452|      2|            })
 3453|      2|            .body(|body| {
 3454|       |                // Capture the actual allocated column widths from the table layout system.
 3455|       |                // This MUST be done before heterogeneous_rows() consumes the body.
 3456|      2|                *column_widths.borrow_mut() = body.widths().to_vec();
 3457|       |
 3458|       |                // Capture body's layout rect for accurate table width calculation.
 3459|       |                // This is the allocated region, not the content bounds.
 3460|      2|                *body_layout_rect.borrow_mut() = Some(body.max_rect());
 3461|       |
 3462|      2|                let row_height_hints = row_heights.clone();
 3463|      3|                body.heterogeneous_rows(row_height_hints.into_iter(), |mut row| {
                              ^2   ^2                 ^2               ^2
 3464|      3|                    let idx = row.index();
 3465|      3|                    let row_cells = rows.get(idx);
 3466|      3|                    let mut row_height = fallback_row_height;
 3467|      6|                    for (ci, _) in column_specs.iter().enumerate() {
                                                 ^3                  ^3
 3468|      6|                        let mut cell_height = fallback_row_height;
 3469|      6|                        row.col(|ui| {
 3470|      6|                            let width = ui.available_width().max(1.0);
 3471|      6|                            let spans = row_cells
 3472|      6|                                .and_then(|cells| cells.get(ci))
 3473|      6|                                .map(|cell| cell.as_slice())
 3474|      6|                                .unwrap_or(&[]);
 3475|      6|                            cell_height =
 3476|      6|                                self.render_overhauled_cell(ui, spans, width, false, Some(idx), ci);
 3477|       |                            // Extend body_rect (not header_rect) for accurate body bounds.
 3478|      6|                            Self::extend_table_rect(&mut body_rect, ui.min_rect());
 3479|      6|                            if body_clip_rect.borrow().is_none() {
 3480|      2|                                *body_clip_rect.borrow_mut() = Some(ui.clip_rect());
 3481|       |                                // Also capture painter/visuals/ctx if not already captured from header
 3482|      2|                                if painter.is_none() {
 3483|      0|                                    painter = Some(ui.painter().clone());
 3484|      0|                                    visuals = Some(ui.visuals().clone());
 3485|      0|                                    ctx_snapshot = Some(ui.ctx().clone());
 3486|      2|                                }
 3487|      4|                            }
 3488|      6|                        });
 3489|      6|                        row_height = row_height.max(cell_height);
 3490|      6|                        if cell_height > row_heights[idx] + 0.5 {
 3491|      0|                            height_growth = true;
 3492|      6|                        }
 3493|       |                    }
 3494|      3|                    self.update_row_height(table_id, idx, row_height);
 3495|      3|                    self.note_row_rendered(table_id);
 3496|      3|                });
 3497|      2|            });
 3498|       |
 3499|      2|        ui.spacing_mut().item_spacing = prev_spacing;
 3500|       |
 3501|       |        // Extract column widths from RefCell for use in divider painting
 3502|      2|        let widths = column_widths.into_inner();
 3503|      2|        let layout_rect = body_layout_rect.into_inner();
 3504|      2|        let body_clip = body_clip_rect.into_inner();
 3505|       |
 3506|       |        // Combine header and body clip rects to ensure dividers respect scroll bounds.
 3507|      2|        let clip_rect = match (header_clip_rect, body_clip) {
 3508|      2|            (Some(h), Some(b)) => Some(h.union(b)),
 3509|      0|            (Some(h), None) => Some(h),
 3510|      0|            (None, Some(b)) => Some(b),
 3511|      0|            (None, None) => None,
 3512|       |        };
 3513|       |
 3514|       |        // Calculate accurate table width from column widths.
 3515|       |        // This is more accurate than union of cell min_rects which may be smaller
 3516|       |        // than the allocated column space.
 3517|      2|        let calculated_width: f32 = widths.iter().sum();
 3518|       |
 3519|       |        // Combine header and body rects into the full table rect.
 3520|       |        // Use calculated width for accuracy when column widths are available.
 3521|      2|        let table_rect = match (header_rect, body_rect, layout_rect) {
 3522|       |            // Best case: use header for top/left, body for bottom, calculated width for right
 3523|      2|            (Some(h), Some(b), _) if calculated_width > 0.0 => {
 3524|      2|                let left = h.left().min(b.left());
 3525|      2|                let top = h.top();
 3526|      2|                let bottom = b.bottom();
 3527|      2|                let right = left + calculated_width;
 3528|      2|                Some(egui::Rect::from_min_max(
 3529|      2|                    egui::pos2(left, top),
 3530|      2|                    egui::pos2(right, bottom),
 3531|      2|                ))
 3532|       |            }
 3533|       |            // Fallback: use union of header and body
 3534|      0|            (Some(h), Some(b), _) => Some(h.union(b)),
 3535|       |            // Header only with layout rect
 3536|      0|            (Some(h), None, Some(layout)) if calculated_width > 0.0 => {
 3537|      0|                let left = h.left().min(layout.left());
 3538|      0|                let right = left + calculated_width;
 3539|      0|                Some(egui::Rect::from_min_max(
 3540|      0|                    egui::pos2(left, h.top()),
 3541|      0|                    egui::pos2(right, h.bottom()),
 3542|      0|                ))
 3543|       |            }
 3544|      0|            (Some(h), None, _) => Some(h),
 3545|      0|            (None, Some(b), _) => Some(b),
 3546|      0|            (None, None, Some(layout)) => Some(layout),
 3547|      0|            (None, None, None) => None,
 3548|       |        };
 3549|       |
 3550|      2|        if let (Some(rect), Some(clip_rect), Some(painter), Some(visuals), Some(ctx)) =
 3551|      2|            (table_rect, clip_rect, painter, visuals, ctx_snapshot)
 3552|       |        {
 3553|      2|            if column_specs.len() == widths.len() && widths.iter().any(|w| *w > 0.0) {
 3554|      2|                let frame_id = ctx.frame_nr();
 3555|      2|                let change = self.record_resolved_widths(table_id, frame_id, &widths);
 3556|      2|                self.persist_resizable_widths(table_id, &column_specs, &widths);
 3557|      2|                self.handle_width_change(&ctx, table_id, change);
 3558|      2|                self.paint_table_dividers(
 3559|      2|                    &painter,
 3560|      2|                    &visuals,
 3561|      2|                    rect,
 3562|      2|                    clip_rect,
 3563|      2|                    &widths,
 3564|      2|                    header_height,
 3565|       |                );
 3566|      2|                if height_growth {
 3567|      0|                    ctx.request_repaint();
 3568|      2|                }
 3569|      0|            }
 3570|      0|        }
 3571|      2|    }
 3572|       |
 3573|     22|    fn row_height_fallback(&self) -> f32 {
 3574|     22|        self.font_sizes.body * 1.6
 3575|     22|    }
 3576|       |
 3577|      3|    fn row_height_hint(&self, table_id: u64, idx: usize) -> f32 {
 3578|      3|        let fallback = self.row_height_fallback();
 3579|      3|        self.table_metrics
 3580|      3|            .borrow()
 3581|      3|            .entry(table_id)
 3582|      3|            .and_then(|entry| entry.row(idx))
 3583|      3|            .map(|m| {
                                   ^0
 3584|      0|                if m.max_height > 0.0 {
 3585|      0|                    m.max_height
 3586|       |                } else {
 3587|      0|                    fallback
 3588|       |                }
 3589|      0|            })
 3590|      3|            .unwrap_or(fallback)
 3591|      3|    }
 3592|       |
 3593|      3|    fn update_row_height(&self, table_id: u64, idx: usize, height: f32) {
 3594|      3|        let clamped = height.max(self.row_height_fallback());
 3595|      3|        let mut metrics = self.table_metrics.borrow_mut();
 3596|      3|        let entry = metrics.entry_mut(table_id);
 3597|      3|        let row = entry.ensure_row(idx);
 3598|      3|        row.max_height = clamped;
 3599|      3|        row.dirty = false;
 3600|      3|    }
 3601|       |
 3602|      2|    fn begin_table_pass(&self, table_id: u64, total_rows: usize) {
 3603|      2|        let mut metrics = self.table_metrics.borrow_mut();
 3604|      2|        metrics.entry_mut(table_id).begin_pass(total_rows);
 3605|      2|    }
 3606|       |
 3607|      3|    fn note_row_rendered(&self, table_id: u64) {
 3608|      3|        let mut metrics = self.table_metrics.borrow_mut();
 3609|      3|        metrics.entry_mut(table_id).note_row_rendered();
 3610|      3|    }
 3611|       |
 3612|      2|    fn apply_persisted_widths(&self, table_id: u64, specs: &mut [ColumnSpec]) {
 3613|      2|        if specs.is_empty() {
 3614|      0|            return;
 3615|      2|        }
 3616|      2|        let mut metrics = self.table_metrics.borrow_mut();
 3617|      2|        let entry = metrics.entry_mut(table_id);
 3618|      4|        for spec in specs.iter_mut() {
                                  ^2    ^2
 3619|      4|            if let Some(width) = entry.persisted_width(spec.policy_hash) {
                                      ^0
 3620|      0|                spec.apply_preferred_width(width);
 3621|      4|            }
 3622|       |        }
 3623|      2|    }
 3624|       |
 3625|      5|    fn persist_resizable_widths(&self, table_id: u64, specs: &[ColumnSpec], widths: &[f32]) {
 3626|      5|        if specs.is_empty() || widths.is_empty() {
 3627|      0|            return;
 3628|      5|        }
 3629|      5|        let mut metrics = self.table_metrics.borrow_mut();
 3630|      5|        let entry = metrics.entry_mut(table_id);
 3631|       |
 3632|       |        // Check if font size changed since last persist - if so, clear old widths
 3633|       |        // to prevent size mismatch after zoom changes. Skip persisting in this
 3634|       |        // frame so the next layout can compute fresh widths before we store them.
 3635|      5|        if entry.check_font_size_change(self.font_sizes.body) {
 3636|      1|            return;
 3637|      4|        }
 3638|       |
 3639|      6|        for (spec, width) in specs.iter().zip(widths.iter()) {
                                           ^4    ^4     ^4  ^4     ^4
 3640|      6|            if let ColumnPolicy::Resizable { .. } = spec.policy {
 3641|      2|                let stored = entry.persisted_width(spec.policy_hash).unwrap_or(-1.0);
 3642|      2|                if stored < 0.0 || (stored - width).abs() > 0.5 {
                                                 ^0
 3643|      2|                    entry.set_persisted_width(spec.policy_hash, *width);
 3644|      2|                }
                              ^0
 3645|      4|            }
 3646|       |        }
 3647|      5|    }
 3648|       |
 3649|      2|    fn record_resolved_widths(&self, table_id: u64, frame_id: u64, widths: &[f32]) -> WidthChange {
 3650|      2|        if widths.is_empty() {
 3651|      0|            return WidthChange::None;
 3652|      2|        }
 3653|      2|        let mut metrics = self.table_metrics.borrow_mut();
 3654|      2|        metrics.entry_mut(table_id).update_widths(widths, frame_id)
 3655|      2|    }
 3656|       |
 3657|      2|    fn handle_width_change(&self, ctx: &Context, table_id: u64, change: WidthChange) {
 3658|      2|        if matches!(change, WidthChange::Large) {
 3659|      0|            let frame_id = ctx.frame_nr();
 3660|      0|            let mut metrics = self.table_metrics.borrow_mut();
 3661|      0|            let entry = metrics.entry_mut(table_id);
 3662|      0|            if entry.last_discard_frame != Some(frame_id) {
 3663|      0|                ctx.request_repaint();
 3664|      0|                entry.last_discard_frame = Some(frame_id);
 3665|      0|            }
 3666|      2|        }
 3667|      2|    }
 3668|       |
 3669|       |    /// Paint vertical dividers between table columns, a horizontal header separator,
 3670|       |    /// and an outer border.
 3671|       |    ///
 3672|       |    /// # Arguments
 3673|       |    /// * `widths` - The actual allocated column widths from `TableBody::widths()`.
 3674|       |    ///   IMPORTANT: These must NOT be cell content widths from `ui.min_rect()`,
 3675|       |    ///   which would cause dividers to be misaligned.
 3676|       |    /// * `header_height` - The height of the header row. A horizontal separator is
 3677|       |    ///   drawn at this y-offset to visually separate header from body rows.
 3678|      2|    fn paint_table_dividers(
 3679|      2|        &self,
 3680|      2|        painter: &Painter,
 3681|      2|        visuals: &Visuals,
 3682|      2|        rect: egui::Rect,
 3683|      2|        clip_rect: egui::Rect,
 3684|      2|        widths: &[f32],
 3685|      2|        header_height: f32,
 3686|      2|    ) {
 3687|      2|        if widths.len() <= 1 {
 3688|      0|            return;
 3689|      2|        }
 3690|      2|        let separator_color = visuals
 3691|      2|            .widgets
 3692|      2|            .noninteractive
 3693|      2|            .bg_stroke
 3694|      2|            .color
 3695|      2|            .gamma_multiply(0.9);
 3696|      2|        let separator_stroke = Stroke::new(1.0, separator_color);
 3697|      2|        let border_stroke = visuals.window_stroke();
 3698|      2|        let painter = painter.with_clip_rect(clip_rect);
 3699|       |
 3700|       |        // Draw vertical dividers between columns
 3701|      2|        let mut x = rect.left();
 3702|      2|        for width in widths.iter().take(widths.len().saturating_sub(1)) {
 3703|      2|            x += *width;
 3704|      2|            let x_pos = (x.round() + 0.5).clamp(rect.left(), rect.right());
 3705|      2|            painter.vline(x_pos, rect.y_range(), separator_stroke);
 3706|      2|        }
 3707|       |
 3708|       |        // Draw horizontal separator below header row
 3709|      2|        if header_height > 0.0 {
 3710|      2|            let header_y = rect.top() + header_height;
 3711|      2|            if header_y > rect.top() && header_y < rect.bottom() {
 3712|      2|                painter.hline(rect.x_range(), header_y.round() + 0.5, separator_stroke);
 3713|      2|            }
                          ^0
 3714|      0|        }
 3715|       |
 3716|       |        // Draw outer border
 3717|      2|        painter.rect_stroke(rect, 0.0, border_stroke);
 3718|      2|    }
 3719|       |
 3720|     10|    fn render_overhauled_cell(
 3721|     10|        &self,
 3722|     10|        ui: &mut egui::Ui,
 3723|     10|        spans: &[InlineSpan],
 3724|     10|        width: f32,
 3725|     10|        is_header: bool,
 3726|     10|        row_idx: Option<usize>,
 3727|     10|        col_idx: usize,
 3728|     10|    ) -> f32 {
 3729|     10|        let fallback_height = self.row_height_fallback();
 3730|     10|        let fragments = self.cell_fragments(spans);
 3731|     10|        let inner = ui.allocate_ui_with_layout(
 3732|     10|            Vec2::new(width, 0.0),
 3733|     10|            egui::Layout::top_down(egui::Align::LEFT),
 3734|     10|            |ui| {
 3735|     10|                ui.set_width(width);
 3736|     10|                ui.set_max_width(width);
 3737|     10|                ui.spacing_mut().item_spacing = egui::vec2(4.0, 2.0);
 3738|     10|                if fragments.is_empty() {
 3739|      0|                    ui.allocate_exact_size(
 3740|      0|                        Vec2::new(width, self.font_sizes.body * 1.2),
 3741|      0|                        egui::Sense::hover(),
 3742|       |                    );
 3743|      0|                    return;
 3744|     10|                }
 3745|     20|                for fragment in fragments {
                                  ^10
 3746|     10|                    match fragment {
 3747|     10|                        CellFragment::Text(slice) => {
 3748|     10|                            let build = self.cached_layout_job(
 3749|     10|                                ui.style(),
 3750|     10|                                row_idx,
 3751|     10|                                col_idx,
 3752|     10|                                slice,
 3753|     10|                                width,
 3754|     10|                                is_header,
 3755|     10|                            );
 3756|     10|                            self.paint_table_text_job(ui, width, build);
 3757|     10|                        }
 3758|      0|                        CellFragment::Emoji(key) => {
 3759|      0|                            self.render_table_emoji(ui, &key);
 3760|      0|                        }
 3761|      0|                        CellFragment::Image(span) => {
 3762|      0|                            self.render_inline_span(ui, span, None, Some(is_header));
 3763|      0|                        }
 3764|       |                    }
 3765|       |                }
 3766|     10|            },
 3767|       |        );
 3768|     10|        inner.response.rect.height().max(fallback_height)
 3769|     10|    }
 3770|       |
 3771|     10|    fn paint_table_text_job(
 3772|     10|        &self,
 3773|     10|        ui: &mut egui::Ui,
 3774|     10|        width: f32,
 3775|     10|        build: LayoutJobBuild,
 3776|     10|    ) -> egui::Response {
 3777|     10|        let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
 3778|     10|        let height = galley.size().y;
 3779|     10|        let (rect, mut response) =
 3780|     10|            ui.allocate_exact_size(Vec2::new(width, height), egui::Sense::click());
 3781|     10|        let text_color = ui.visuals().text_color();
 3782|     10|        ui.painter_at(rect)
 3783|     10|            .galley(rect.left_top(), galley.clone(), text_color);
 3784|     10|        if galley.rows.len() > 1 {
 3785|      0|            response = response.on_hover_text(build.plain_text.clone());
 3786|     10|        }
 3787|     10|        response.context_menu(|ui| {
                                                 ^0
 3788|      0|            self.render_cell_context_menu(ui, &build.plain_text);
 3789|      0|        });
 3790|       |
 3791|     10|        if let Some(link) = self.link_at_pointer(&response, &galley, &build) {
                                  ^0
 3792|      0|            ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
 3793|      0|            response = response.on_hover_text(link.url.clone());
 3794|      0|            if response.clicked() {
 3795|      0|                self.trigger_link(&link.url);
 3796|      0|            }
 3797|     10|        }
 3798|       |
 3799|     10|        response
 3800|     10|    }
 3801|       |
 3802|     16|    fn cached_layout_job(
 3803|     16|        &self,
 3804|     16|        style: &egui::Style,
 3805|     16|        row_idx: Option<usize>,
 3806|     16|        col_idx: usize,
 3807|     16|        spans: &[InlineSpan],
 3808|     16|        width: f32,
 3809|     16|        is_header: bool,
 3810|     16|    ) -> LayoutJobBuild {
 3811|     16|        if !self.table_wrap_overhaul_enabled {
 3812|      0|            return self.build_layout_job(style, spans, width, is_header);
 3813|     16|        }
 3814|     16|        let highlight_hash = self
 3815|     16|            .highlight_phrase
 3816|     16|            .borrow()
 3817|     16|            .as_ref()
 3818|     16|            .map(|s| Self::hash_str(s))
                                   ^8             ^8
 3819|     16|            .unwrap_or(0);
 3820|     16|        let content_hash = Self::hash_inline_spans(spans);
 3821|     16|        let key = CellLayoutKey {
 3822|     16|            row: row_idx,
 3823|     16|            col: col_idx,
 3824|     16|            width: width.round() as u32,
 3825|     16|            strong: is_header,
 3826|     16|            highlight_hash,
 3827|     16|            content_hash,
 3828|     16|        };
 3829|     16|        if let Some(build) = self.table_layout_cache.borrow_mut().get(&key) {
                                  ^1
 3830|      1|            return build;
 3831|     15|        }
 3832|     15|        let build = self.build_layout_job(style, spans, width, is_header);
 3833|     15|        self.table_layout_cache
 3834|     15|            .borrow_mut()
 3835|     15|            .insert(key, build.clone());
 3836|     15|        build
 3837|     16|    }
 3838|       |
 3839|     10|    fn link_at_pointer<'a>(
 3840|     10|        &self,
 3841|     10|        response: &egui::Response,
 3842|     10|        galley: &Arc<Galley>,
 3843|     10|        build: &'a LayoutJobBuild,
 3844|     10|    ) -> Option<&'a LinkRange> {
 3845|     10|        let pointer = response.hover_pos()?;
                          ^0
 3846|      0|        let local = pointer - response.rect.left_top();
 3847|      0|        let cursor = galley.cursor_from_pos(local);
 3848|      0|        let idx = cursor.ccursor.index;
 3849|      0|        build
 3850|      0|            .link_ranges
 3851|      0|            .iter()
 3852|      0|            .find(|range| range.char_range.contains(&idx))
 3853|     10|    }
 3854|       |
 3855|      0|    fn render_table_emoji(&self, ui: &mut egui::Ui, emoji: &str) {
 3856|      0|        let handle = self.get_or_make_emoji_texture(ui, emoji);
 3857|      0|        let size = self.font_sizes.body * 1.2;
 3858|      0|        ui.add(
 3859|      0|            egui::Image::new(&handle)
 3860|      0|                .max_size(Vec2::splat(size))
 3861|      0|                .sense(egui::Sense::hover()),
 3862|       |        );
 3863|      0|    }
 3864|       |
 3865|       |    /// Render table cell spans with proper text wrapping within the given width
 3866|      4|    fn render_table_cell_spans(
 3867|      4|        &self,
 3868|      4|        ui: &mut egui::Ui,
 3869|      4|        spans: &[InlineSpan],
 3870|      4|        max_width: f32,
 3871|      4|        is_header: bool,
 3872|      4|    ) {
 3873|       |        // Render content with wrapping, forcing exact width to ensure wrapping occurs
 3874|      4|        ui.vertical(|ui| {
 3875|      4|            ui.set_width(max_width); // Force exact width
 3876|      4|            ui.set_max_width(max_width);
 3877|      4|            ui.spacing_mut().item_spacing.y = 0.0;
 3878|       |
 3879|       |            // Render all spans in a wrapped horizontal layout
 3880|      4|            ui.horizontal_wrapped(|ui| {
 3881|      4|                ui.spacing_mut().item_spacing.x = 0.0;
 3882|      4|                ui.set_width(max_width);
 3883|      8|                for span in spans {
                                  ^4
 3884|      4|                    self.render_inline_span(ui, span, None, Some(is_header));
 3885|      4|                }
 3886|      4|            });
 3887|      4|        });
 3888|      4|    }
 3889|       |
 3890|      3|    fn resolve_table_widths(available: f32, mins: &[f32], desired: &[f32]) -> Vec<f32> {
 3891|      3|        debug_assert_eq!(mins.len(), desired.len());
 3892|      3|        if mins.is_empty() {
 3893|      0|            return Vec::new();
 3894|      3|        }
 3895|      3|        let clamped_available = available.max(1.0);
 3896|      3|        let desired_total: f32 = desired.iter().sum();
 3897|      3|        let min_total: f32 = mins.iter().sum();
 3898|       |
 3899|      3|        let mut widths = if desired_total <= clamped_available {
 3900|      1|            desired.to_vec()
 3901|      2|        } else if min_total >= clamped_available {
 3902|      1|            if min_total <= f32::EPSILON {
 3903|      0|                vec![clamped_available / mins.len() as f32; mins.len()]
 3904|       |            } else {
 3905|      1|                mins.iter()
 3906|      4|                    .map(|m| m * (clamped_available / min_total))
                                   ^1
 3907|      1|                    .collect()
 3908|       |            }
 3909|       |        } else {
 3910|      1|            let mut widths = mins.to_vec();
 3911|      1|            let extra = clamped_available - min_total;
 3912|      1|            let slack: Vec<f32> = desired
 3913|      1|                .iter()
 3914|      1|                .zip(mins.iter())
 3915|      4|                .map(|(d, m)| (d - m).max(0.0))
                               ^1
 3916|      1|                .collect();
 3917|      1|            let total_slack: f32 = slack.iter().sum();
 3918|      1|            if total_slack <= f32::EPSILON {
 3919|      0|                let bonus = extra / widths.len() as f32;
 3920|      0|                for w in &mut widths {
 3921|      0|                    *w += bonus;
 3922|      0|                }
 3923|       |            } else {
 3924|      4|                for (w, s) in widths.iter_mut().zip(slack.iter()) {
                                            ^1                ^1  ^1
 3925|      4|                    *w += extra * (*s / total_slack);
 3926|      4|                }
 3927|       |            }
 3928|      1|            widths
 3929|       |        };
 3930|       |
 3931|      3|        let sum: f32 = widths.iter().sum();
 3932|      3|        if sum > clamped_available + 0.5 {
 3933|      0|            let ratio = clamped_available / sum;
 3934|      0|            for w in &mut widths {
 3935|      0|                *w *= ratio;
 3936|      0|            }
 3937|      3|        }
 3938|      3|        widths
 3939|      3|    }
 3940|       |
 3941|       |    /// Open URL in default browser
 3942|       |    #[cfg(not(test))]
 3943|       |    fn open_url(&self, url: &str) {
 3944|       |        if let Err(e) = webbrowser::open(url) {
 3945|       |            eprintln!("Failed to open URL {}: {}", url, e);
 3946|       |        }
 3947|       |    }
 3948|       |
 3949|       |    #[cfg(test)]
 3950|      3|    fn open_url(&self, _url: &str) {}
 3951|       |
 3952|      7|    pub(crate) fn trigger_link(&self, url: &str) {
 3953|      7|        if let Some(fragment) = Self::extract_fragment(url) {
                                  ^3
 3954|      3|            *self.pending_anchor.borrow_mut() = Some(fragment);
 3955|      4|        } else if Self::is_allowed_scheme(url) {
 3956|      3|            self.open_url(url);
 3957|      3|        } else {
 3958|      1|            eprintln!("Blocked link with unsupported scheme: {}", url);
 3959|      1|        }
 3960|      7|    }
 3961|       |
 3962|      4|    fn is_allowed_scheme(url: &str) -> bool {
 3963|      4|        url.starts_with("http://") || url.starts_with("https://") || url.starts_with("mailto:")
                                                                                   ^2  ^2
 3964|      4|    }
 3965|       |
 3966|       |    /// Consume and return the last clicked internal anchor, if any
 3967|     15|    pub fn take_pending_anchor(&self) -> Option<String> {
 3968|     15|        self.pending_anchor.borrow_mut().take()
 3969|     15|    }
 3970|       |
 3971|       |    /// Lookup a header rect by its id (slug)
 3972|      2|    pub fn header_rect_for(&self, id: &str) -> Option<egui::Rect> {
 3973|      2|        self.header_rects.borrow().get(id).copied()
 3974|      2|    }
 3975|       |
 3976|       |    /// Lookup the rect for the n-th top-level element rendered in the last frame
 3977|      6|    pub fn element_rect_at(&self, index: usize) -> Option<egui::Rect> {
 3978|      6|        self.element_rects.borrow().get(index).copied()
 3979|      6|    }
 3980|       |
 3981|       |    /// Set or clear the highlight phrase (case-insensitive)
 3982|     16|    pub fn set_highlight_phrase(&self, phrase: Option<&str>) {
 3983|     16|        if let Some(p) = phrase {
                                  ^7
 3984|      7|            self.highlight_phrase
 3985|      7|                .borrow_mut()
 3986|      7|                .replace(p.case_fold().nfkc().collect());
 3987|      9|        } else {
 3988|      9|            self.highlight_phrase.borrow_mut().take();
 3989|      9|        }
 3990|     16|        self.clear_table_layout_cache();
 3991|     16|    }
 3992|       |
 3993|     68|    pub fn set_table_wrap_overhaul_enabled(&mut self, enabled: bool) {
 3994|     68|        self.table_wrap_overhaul_enabled = enabled;
 3995|     68|        self.clear_table_layout_cache();
 3996|     68|    }
 3997|       |
 3998|      3|    pub fn table_wrap_overhaul_enabled(&self) -> bool {
 3999|      3|        self.table_wrap_overhaul_enabled
 4000|      3|    }
 4001|       |
 4002|    201|    pub fn clear_table_layout_cache(&self) {
 4003|    201|        self.table_layout_cache.borrow_mut().clear();
 4004|    201|        self.table_metrics.borrow_mut().clear();
 4005|    201|        self.column_stats_cache.borrow_mut().clear();
 4006|    201|    }
 4007|       |
 4008|     22|    pub fn table_layout_cache_stats(&self) -> (u64, u64) {
 4009|     22|        self.table_layout_cache.borrow().stats()
 4010|     22|    }
 4011|       |
 4012|     20|    pub fn table_render_stats(&self) -> (usize, usize) {
 4013|     20|        self.table_metrics.borrow().totals()
 4014|     20|    }
 4015|       |
 4016|       |    /// Get a plain-text representation of a markdown element (for search)
 4017|     18|    pub fn element_plain_text(element: &MarkdownElement) -> String {
 4018|     18|        match element {
 4019|     18|            MarkdownElement::Paragraph(spans) => Self::spans_plain_text(spans),
 4020|      0|            MarkdownElement::Header { spans, .. } => Self::spans_plain_text(spans),
 4021|      0|            MarkdownElement::CodeBlock { text, .. } => text.clone(),
 4022|      0|            MarkdownElement::List { items, .. } => {
 4023|      0|                let mut out = String::new();
 4024|      0|                for item in items {
 4025|      0|                    if !out.is_empty() {
 4026|      0|                        out.push('\n');
 4027|      0|                    }
 4028|      0|                    out.push_str(&Self::spans_plain_text(item));
 4029|       |                }
 4030|      0|                out
 4031|       |            }
 4032|      0|            MarkdownElement::Quote { lines, .. } => {
 4033|      0|                let mut out = String::new();
 4034|      0|                for line in lines {
 4035|      0|                    if !out.is_empty() {
 4036|      0|                        out.push('\n');
 4037|      0|                    }
 4038|      0|                    out.push_str(&Self::spans_plain_text(line));
 4039|       |                }
 4040|      0|                out
 4041|       |            }
 4042|      0|            MarkdownElement::HorizontalRule => String::from("---"),
 4043|      0|            MarkdownElement::Table { headers, rows } => {
 4044|      0|                let mut out = String::new();
 4045|      0|                for h in headers {
 4046|      0|                    if !out.is_empty() {
 4047|      0|                        out.push(' ');
 4048|      0|                    }
 4049|      0|                    out.push_str(&Self::spans_plain_text(h));
 4050|       |                }
 4051|      0|                for row in rows {
 4052|      0|                    for cell in row {
 4053|      0|                        out.push(' ');
 4054|      0|                        out.push_str(&Self::spans_plain_text(cell));
 4055|      0|                    }
 4056|       |                }
 4057|      0|                out
 4058|       |            }
 4059|       |        }
 4060|     18|    }
 4061|       |
 4062|       |    /// Set the base directory for resolving relative image paths
 4063|     36|    pub fn set_base_dir(&self, dir: Option<&Path>) {
 4064|     36|        if let Some(d) = dir {
                                  ^20
 4065|     20|            self.base_dir.borrow_mut().replace(d.to_path_buf());
 4066|     20|        } else {
 4067|     16|            self.base_dir.borrow_mut().take();
 4068|     16|        }
 4069|     36|    }
 4070|       |
 4071|     10|    fn resolve_image_path(&self, src: &str) -> String {
 4072|     10|        if src.starts_with("http://") || src.starts_with("https://") || src.starts_with("data:") {
                                                                                      ^9  ^9
 4073|       |            // Keep as-is; we don't fetch remote or parse data URIs yet
 4074|      1|            return src.to_string();
 4075|      9|        }
 4076|      9|        let p = Path::new(src);
 4077|      9|        if p.is_absolute() {
 4078|      1|            return src.to_string();
 4079|      8|        }
 4080|      8|        if let Some(base) = self.base_dir.borrow().as_ref() {
                                  ^4
 4081|      4|            let joined = base.join(p);
 4082|      4|            return joined.to_string_lossy().into_owned();
 4083|      4|        }
 4084|      4|        src.to_string()
 4085|     10|    }
 4086|       |
 4087|      7|    fn get_or_load_image_texture(
 4088|      7|        &self,
 4089|      7|        ui: &egui::Ui,
 4090|      7|        resolved_src: &str,
 4091|      7|    ) -> Option<(egui::TextureHandle, u32, u32)> {
 4092|       |        // Reject remote for now
 4093|      7|        if resolved_src.starts_with("http://") || resolved_src.starts_with("https://") {
 4094|      1|            return None;
 4095|      6|        }
 4096|       |
 4097|      6|        let path = Path::new(resolved_src);
 4098|       |
 4099|      6|        if let Some(entry) = self.image_textures.borrow().get(resolved_src) {
                                  ^0
 4100|      0|            let stale = Self::image_source_stale(entry.modified, path);
 4101|      0|            if !stale {
 4102|      0|                return Some((entry.texture.clone(), entry.size[0], entry.size[1]));
 4103|      0|            }
 4104|      6|        }
 4105|       |
 4106|       |        // Try embedded assets first
 4107|      6|        if let Some(bytes) = Self::embedded_image_bytes(resolved_src) {
                                  ^2
 4108|      2|            if let Some((color_image, w, h)) = Self::bytes_to_color_image_guess(bytes, None) {
 4109|      2|                let tex = ui.ctx().load_texture(
 4110|      2|                    format!("img:{}", resolved_src),
 4111|      2|                    color_image,
 4112|       |                    egui::TextureOptions::LINEAR,
 4113|       |                );
 4114|      2|                self.store_image_texture(resolved_src, tex.clone(), [w, h], None);
 4115|      2|                return Some((tex, w, h));
 4116|      0|            }
 4117|      4|        }
 4118|       |
 4119|      4|        if !path.exists() {
 4120|      2|            return None;
 4121|      2|        }
 4122|       |
 4123|      2|        let bytes = std::fs::read(path).ok()?;
                                                          ^0
 4124|      2|        let (color_image, w, h) = if Self::is_svg_path(resolved_src) {
 4125|      0|            match Self::svg_bytes_to_color_image(&bytes) {
 4126|      0|                Some((ci, w, h)) => (ci, w, h),
 4127|      0|                None => return None,
 4128|       |            }
 4129|       |        } else {
 4130|      2|            let img = image::load_from_memory(&bytes).ok()?;
                                                                        ^0
 4131|      2|            let rgba = img.to_rgba8();
 4132|      2|            let (w, h) = rgba.dimensions();
 4133|      2|            let ci = egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &rgba);
 4134|      2|            (ci, w, h)
 4135|       |        };
 4136|      2|        let tex = ui.ctx().load_texture(
 4137|      2|            format!("img:{}", resolved_src),
 4138|      2|            color_image,
 4139|       |            egui::TextureOptions::LINEAR,
 4140|       |        );
 4141|      2|        let modified = Self::disk_image_timestamp(path);
 4142|      2|        self.store_image_texture(resolved_src, tex.clone(), [w, h], modified);
 4143|      2|        Some((tex, w, h))
 4144|      7|    }
 4145|       |
 4146|      5|    fn disk_image_timestamp(path: &Path) -> Option<SystemTime> {
 4147|      5|        std::fs::metadata(path).ok()?.modified().ok()
                                                  ^0
 4148|      5|    }
 4149|       |
 4150|      2|    fn image_source_stale(cached_modified: Option<SystemTime>, path: &Path) -> bool {
 4151|      2|        if !path.exists() {
 4152|      0|            return false;
 4153|      2|        }
 4154|      2|        let current = Self::disk_image_timestamp(path);
 4155|      2|        match (cached_modified, current) {
 4156|      2|            (Some(prev), Some(cur)) => prev != cur,
 4157|      0|            (Some(_), None) => true,
 4158|      0|            (None, Some(_)) => true,
 4159|      0|            (None, None) => false,
 4160|       |        }
 4161|      2|    }
 4162|       |
 4163|      5|    fn store_image_texture(
 4164|      5|        &self,
 4165|      5|        key: &str,
 4166|      5|        texture: egui::TextureHandle,
 4167|      5|        size: [u32; 2],
 4168|      5|        modified: Option<SystemTime>,
 4169|      5|    ) {
 4170|      5|        self.image_textures.borrow_mut().insert(
 4171|      5|            key.to_string(),
 4172|      5|            ImageCacheEntry {
 4173|      5|                texture,
 4174|      5|                size,
 4175|      5|                modified,
 4176|      5|            },
 4177|      5|        );
 4178|      5|    }
 4179|       |
 4180|       |    /// Return embedded image bytes for known assets used in sample files
 4181|      6|    fn embedded_image_bytes(path: &str) -> Option<&'static [u8]> {
 4182|      6|        match path.replace('\\', "/").as_str() {
 4183|       |            // Smiley PNG
 4184|      6|            "assets/emoji/1f600.png" => Some(include_bytes!("../assets/emoji/1f600.png")),
                                                      ^0
 4185|       |            // SVG logo and WEBP sample used by images.md
 4186|      6|            "assets/samples/logo.svg" => Some(include_bytes!("../assets/samples/logo.svg")),
                                                       ^1
 4187|      5|            "assets/samples/webp_sample.webp" => {
 4188|      1|                Some(include_bytes!("../assets/samples/webp_sample.webp"))
 4189|       |            }
 4190|      4|            _ => None,
 4191|       |        }
 4192|      6|    }
 4193|       |
 4194|      2|    fn is_svg_path(p: &str) -> bool {
 4195|      2|        p.rsplit('.')
 4196|      2|            .next()
 4197|      2|            .map(|e| e.eq_ignore_ascii_case("svg"))
 4198|      2|            .unwrap_or(false)
 4199|      2|    }
 4200|       |
 4201|      0|    fn svg_bytes_to_color_image(bytes: &[u8]) -> Option<(egui::ColorImage, u32, u32)> {
 4202|      0|        Self::svg_bytes_to_color_image_with_bg(bytes, None)
 4203|      0|    }
 4204|       |
 4205|      2|    fn svg_bytes_to_color_image_with_bg(
 4206|      2|        bytes: &[u8],
 4207|      2|        bg: Option<[u8; 4]>,
 4208|      2|    ) -> Option<(egui::ColorImage, u32, u32)> {
 4209|       |        // Parse SVG
 4210|      2|        let mut opt = usvg::Options::default();
 4211|       |        // Load system fonts so <text> elements render via resvg
 4212|      2|        let mut db = usvg::fontdb::Database::new();
 4213|      2|        db.load_system_fonts();
 4214|      2|        opt.fontdb = std::sync::Arc::new(db);
 4215|      2|        let tree = usvg::Tree::from_data(bytes, &opt).ok()?;
                          ^1                                            ^1
 4216|       |        // Determine output size in pixels
 4217|      1|        let sz = tree.size();
 4218|      1|        let pix = sz.to_int_size();
 4219|      1|        let (mut w, mut h) = (pix.width(), pix.height());
 4220|      1|        if w == 0 || h == 0 {
 4221|      0|            // Fallback if unspecified
 4222|      0|            w = 256;
 4223|      0|            h = 256;
 4224|      1|        }
 4225|       |        // Clamp to a reasonable texture size
 4226|      1|        let max_side: u32 = 4096;
 4227|      1|        if w > max_side || h > max_side {
 4228|      0|            let scale = (max_side as f32 / w as f32).min(max_side as f32 / h as f32);
 4229|      0|            w = (w as f32 * scale) as u32;
 4230|      0|            h = (h as f32 * scale) as u32;
 4231|      1|        }
 4232|      1|        let mut pixmap = tiny_skia::Pixmap::new(w, h)?;
                                                                   ^0
 4233|       |        // Optional background fill for better contrast against dark UI
 4234|      1|        if let Some([r, g, b, a]) = bg {
                                   ^0 ^0 ^0 ^0
 4235|      0|            let color = tiny_skia::Color::from_rgba8(r, g, b, a);
 4236|      0|            pixmap.fill(color);
 4237|      1|        }
 4238|      1|        let mut pmut = pixmap.as_mut();
 4239|      1|        resvg::render(&tree, tiny_skia::Transform::identity(), &mut pmut);
 4240|      1|        let data = pixmap.data();
 4241|      1|        let img = egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], data);
 4242|      1|        Some((img, w, h))
 4243|      2|    }
 4244|       |
 4245|       |    // Try decode as raster image first (PNG/JPEG/WEBP). If that fails, try SVG.
 4246|      4|    fn bytes_to_color_image_guess(
 4247|      4|        bytes: &[u8],
 4248|      4|        bg: Option<[u8; 4]>,
 4249|      4|    ) -> Option<(egui::ColorImage, u32, u32)> {
 4250|      4|        if let Ok(img) = image::load_from_memory(bytes) {
                                ^2
 4251|      2|            let rgba = img.to_rgba8();
 4252|      2|            let (w, h) = rgba.dimensions();
 4253|      2|            let mut ci = egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &rgba);
 4254|      2|            if let Some([br, bgc, bb, ba]) = bg {
                                       ^1  ^1   ^1  ^1
 4255|       |                // Composite over solid bg
 4256|      4|                for p in ci.pixels.iter_mut() {
                                       ^1        ^1
 4257|      4|                    let a = p[3] as f32 / 255.0;
 4258|      4|                    let inv = 1.0 - a;
 4259|      4|                    p[0] = (a * p[0] as f32 + inv * br as f32) as u8;
 4260|      4|                    p[1] = (a * p[1] as f32 + inv * bgc as f32) as u8;
 4261|      4|                    p[2] = (a * p[2] as f32 + inv * bb as f32) as u8;
 4262|      4|                    p[3] = ba; // fully opaque output
 4263|      4|                }
 4264|      1|            }
 4265|      2|            return Some((ci, w, h));
 4266|      2|        }
 4267|       |        // Fallback to SVG
 4268|      2|        Self::svg_bytes_to_color_image_with_bg(bytes, bg)
 4269|      4|    }
 4270|       |
 4271|       |    /// Find syntax definition for a given language name
 4272|       |    /// Maps common language names to their syntax definitions
 4273|      5|    fn find_syntax_for_language(&self, lang: &str) -> Option<&syntect::parsing::SyntaxReference> {
 4274|       |        // Create a mapping of common language names to their syntect equivalents
 4275|      5|        let lang_lower = lang.to_lowercase();
 4276|       |
 4277|       |        // Try direct name match first
 4278|      5|        if let Some(syntax) = self.syntax_set.find_syntax_by_name(&lang_lower) {
                                  ^0
 4279|      0|            return Some(syntax);
 4280|      5|        }
 4281|       |
 4282|       |        // Try extension-based matching
 4283|      5|        if let Some(syntax) = self.syntax_set.find_syntax_by_extension(&lang_lower) {
                                  ^0
 4284|      0|            return Some(syntax);
 4285|      5|        }
 4286|       |
 4287|       |        // Handle common language mappings
 4288|      5|        let mapped_lang = match lang_lower.as_str() {
 4289|      5|            "rust" => "rs",
                                    ^3
 4290|      2|            "python" => "py",
                                      ^0
 4291|      2|            "javascript" => "js",
                                          ^0
 4292|      2|            "typescript" => "ts",
                                          ^0
 4293|      2|            "c++" | "cpp" => "cpp",
                                           ^0
 4294|      2|            "c#" | "csharp" => "cs",
                                             ^0
 4295|      2|            "shell" | "bash" => "sh",
                                              ^0
 4296|      2|            "powershell" => "ps1",
                                          ^0
 4297|      2|            "yaml" => "yml",
                                    ^0
 4298|      2|            "markdown" => "md",
                                        ^0
 4299|      2|            "html" => "html",
                                    ^0
 4300|      2|            "css" => "css",
                                   ^0
 4301|      2|            "java" => "java",
                                    ^0
 4302|      2|            "go" => "go",
                                  ^0
 4303|      2|            "php" => "php",
                                   ^0
 4304|      2|            "ruby" => "rb",
                                    ^0
 4305|      2|            "xml" => "xml",
                                   ^0
 4306|      2|            "json" => "json",
                                    ^0
 4307|      2|            "sql" => "sql",
                                   ^0
 4308|      2|            "toml" => "toml",
                                    ^0
 4309|      2|            _ => &lang_lower,
 4310|       |        };
 4311|       |
 4312|       |        // Try mapped extension
 4313|      5|        self.syntax_set
 4314|      5|            .find_syntax_by_extension(mapped_lang)
 4315|      5|            .or_else(|| self.syntax_set.find_syntax_by_name(mapped_lang))
                                      ^2              ^2                  ^2
 4316|      5|    }
 4317|       |
 4318|       |    /// Zoom in (increase font sizes)
 4319|      3|    pub fn zoom_in(&mut self) {
 4320|      3|        self.font_sizes.body = (self.font_sizes.body * 1.1).min(32.0);
 4321|      3|        self.font_sizes.h1 = (self.font_sizes.h1 * 1.1).min(48.0);
 4322|      3|        self.font_sizes.h2 = (self.font_sizes.h2 * 1.1).min(42.0);
 4323|      3|        self.font_sizes.h3 = (self.font_sizes.h3 * 1.1).min(36.0);
 4324|      3|        self.font_sizes.h4 = (self.font_sizes.h4 * 1.1).min(32.0);
 4325|      3|        self.font_sizes.h5 = (self.font_sizes.h5 * 1.1).min(28.0);
 4326|      3|        self.font_sizes.h6 = (self.font_sizes.h6 * 1.1).min(24.0);
 4327|      3|        self.font_sizes.code = (self.font_sizes.code * 1.1).min(20.0);
 4328|      3|        self.clear_table_layout_cache();
 4329|      3|    }
 4330|       |
 4331|       |    /// Zoom out (decrease font sizes)
 4332|      2|    pub fn zoom_out(&mut self) {
 4333|      2|        self.font_sizes.body = (self.font_sizes.body * 0.9).max(8.0);
 4334|      2|        self.font_sizes.h1 = (self.font_sizes.h1 * 0.9).max(16.0);
 4335|      2|        self.font_sizes.h2 = (self.font_sizes.h2 * 0.9).max(14.0);
 4336|      2|        self.font_sizes.h3 = (self.font_sizes.h3 * 0.9).max(12.0);
 4337|      2|        self.font_sizes.h4 = (self.font_sizes.h4 * 0.9).max(11.0);
 4338|      2|        self.font_sizes.h5 = (self.font_sizes.h5 * 0.9).max(10.0);
 4339|      2|        self.font_sizes.h6 = (self.font_sizes.h6 * 0.9).max(9.0);
 4340|      2|        self.font_sizes.code = (self.font_sizes.code * 0.9).max(8.0);
 4341|      2|        self.clear_table_layout_cache();
 4342|      2|    }
 4343|       |
 4344|       |    /// Reset zoom to default
 4345|      2|    pub fn reset_zoom(&mut self) {
 4346|      2|        self.font_sizes = FontSizes::default();
 4347|      2|        self.clear_table_layout_cache();
 4348|      2|    }
 4349|       |}
 4350|       |
 4351|       |#[cfg(test)]
 4352|       |mod tests {
 4353|       |    use super::*;
 4354|       |    use crate::SAMPLE_FILES;
 4355|       |    use image::codecs::png::PngEncoder;
 4356|       |    use image::ColorType;
 4357|       |    use image::ImageEncoder;
 4358|       |    use std::sync::{Mutex, OnceLock};
 4359|       |    use tempfile::tempdir;
 4360|       |
 4361|      4|    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
 4362|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
 4363|      4|        ENV_LOCK.get_or_init(|| Mutex::new(())).lock().expect("env lock")
                                              ^1         ^1
 4364|      4|    }
 4365|       |
 4366|       |    struct ForcedRenderActions {
 4367|       |        actions: Vec<&'static str>,
 4368|       |    }
 4369|       |
 4370|       |    impl ForcedRenderActions {
 4371|      1|        fn new(actions: &[&'static str]) -> Self {
 4372|      1|            FORCED_RENDER_ACTIONS.with(|set| {
 4373|      1|                let mut set = set.borrow_mut();
 4374|      4|                for action in actions {
                                  ^3
 4375|      3|                    set.insert(*action);
 4376|      3|                }
 4377|      1|            });
 4378|      1|            Self {
 4379|      1|                actions: actions.to_vec(),
 4380|      1|            }
 4381|      1|        }
 4382|       |    }
 4383|       |
 4384|       |    impl Drop for ForcedRenderActions {
 4385|      1|        fn drop(&mut self) {
 4386|      1|            FORCED_RENDER_ACTIONS.with(|set| {
 4387|      1|                let mut set = set.borrow_mut();
 4388|      4|                for action in &self.actions {
                                  ^3
 4389|      3|                    set.remove(action);
 4390|      3|                }
 4391|      1|            });
 4392|      1|        }
 4393|       |    }
 4394|       |
 4395|     13|    fn with_test_ui<F>(f: F)
 4396|     13|    where
 4397|     13|        F: FnOnce(&egui::Context, &mut egui::Ui),
 4398|       |    {
 4399|     13|        let ctx = egui::Context::default();
 4400|     13|        let mut input = egui::RawInput::default();
 4401|     13|        input.screen_rect = Some(egui::Rect::from_min_size(
 4402|     13|            egui::pos2(0.0, 0.0),
 4403|     13|            egui::vec2(1024.0, 768.0),
 4404|     13|        ));
 4405|     13|        ctx.begin_frame(input);
 4406|     13|        egui::CentralPanel::default().show(&ctx, |ui| {
 4407|     13|            f(&ctx, ui);
 4408|     13|        });
 4409|     13|        let _ = ctx.end_frame();
 4410|     13|    }
 4411|       |
 4412|      2|    fn tiny_png_bytes() -> Vec<u8> {
 4413|      2|        let width = 2u32;
 4414|      2|        let height = 2u32;
 4415|      2|        let pixels = vec![255u8; (width * height * 4) as usize];
 4416|      2|        let mut out = Vec::new();
 4417|      2|        let encoder = PngEncoder::new(&mut out);
 4418|      2|        encoder
 4419|      2|            .write_image(&pixels, width, height, ColorType::Rgba8)
 4420|      2|            .expect("encode png");
 4421|      2|        out
 4422|      2|    }
 4423|       |
 4424|       |    struct EnvGuard {
 4425|       |        key: &'static str,
 4426|       |        original: Option<String>,
 4427|       |    }
 4428|       |
 4429|       |    impl EnvGuard {
 4430|      6|        fn set(key: &'static str, value: &str) -> Self {
 4431|      6|            let original = std::env::var(key).ok();
 4432|      6|            std::env::set_var(key, value);
 4433|      6|            Self { key, original }
 4434|      6|        }
 4435|       |    }
 4436|       |
 4437|       |    impl Drop for EnvGuard {
 4438|      6|        fn drop(&mut self) {
 4439|      6|            if let Some(value) = &self.original {
                                      ^0
 4440|      0|                std::env::set_var(self.key, value);
 4441|      6|            } else {
 4442|      6|                std::env::remove_var(self.key);
 4443|      6|            }
 4444|      6|        }
 4445|       |    }
 4446|       |
 4447|       |    #[test]
 4448|      1|    fn test_markdown_renderer_creation() {
 4449|      1|        let renderer = MarkdownRenderer::new();
 4450|      1|        assert_eq!(renderer.font_sizes.body, 14.0);
 4451|      1|        assert_eq!(renderer.font_sizes.h1, 28.0);
 4452|      1|    }
 4453|       |
 4454|       |    #[test]
 4455|      1|    fn test_superscript_expansion_basic() {
 4456|      1|        let s = "5^th^ and m^2^";
 4457|      1|        let out = MarkdownRenderer::expand_superscripts(s);
 4458|      1|        assert!(out.contains("5"));
 4459|      1|        assert!(out.contains("m"));
 4460|      1|    }
 4461|       |
 4462|       |    #[test]
 4463|      1|    fn test_superscript_expansion_single_caret() {
 4464|       |        // Test that single carets (not paired) are left as-is
 4465|      1|        let s = "2^32 = 4,294,967,296";
 4466|      1|        let out = MarkdownRenderer::expand_superscripts(s);
 4467|      1|        assert_eq!(
 4468|       |            out, "2^32 = 4,294,967,296",
 4469|      0|            "Single caret should be preserved"
 4470|       |        );
 4471|       |
 4472|       |        // Test the problematic line from the bug report
 4473|      1|        let problematic = "A 32-bit address bus would provide 2^32 = 4,294,967,296 bytes (4 GB) of addressable memory.";
 4474|      1|        let fixed = MarkdownRenderer::expand_superscripts(problematic);
 4475|      1|        assert_eq!(
 4476|       |            fixed, problematic,
 4477|      0|            "Text should remain unchanged when no paired carets exist"
 4478|       |        );
 4479|       |
 4480|       |        // Test mixed cases
 4481|      1|        let mixed = "Use 2^32 for math and 5^th^ for ordinal";
 4482|      1|        let result = MarkdownRenderer::expand_superscripts(mixed);
 4483|      1|        assert!(result.contains("2^32"), "Single caret should be preserved");
                                                       ^0
 4484|      1|        assert!(result.contains("5"), "Paired carets should be converted");
                                                         ^0
 4485|      1|    }
 4486|       |
 4487|       |    #[test]
 4488|      1|    fn test_font_sizes_default() {
 4489|      1|        let sizes = FontSizes::default();
 4490|      1|        assert_eq!(sizes.body, 14.0);
 4491|      1|        assert_eq!(sizes.h1, 28.0);
 4492|      1|        assert_eq!(sizes.code, 12.0);
 4493|      1|    }
 4494|       |
 4495|       |    #[test]
 4496|      1|    fn test_zoom_functionality() {
 4497|      1|        let mut renderer = MarkdownRenderer::new();
 4498|      1|        let original_body = renderer.font_sizes.body;
 4499|       |
 4500|      1|        renderer.zoom_in();
 4501|      1|        assert!(renderer.font_sizes.body > original_body);
 4502|       |
 4503|      1|        renderer.zoom_out();
 4504|      1|        assert!(renderer.font_sizes.body < original_body * 1.1);
 4505|       |
 4506|      1|        renderer.reset_zoom();
 4507|      1|        assert_eq!(renderer.font_sizes.body, original_body);
 4508|      1|    }
 4509|       |
 4510|       |    #[test]
 4511|      1|    fn font_size_change_does_not_repersist_stale_widths() {
 4512|      1|        let mut renderer = MarkdownRenderer::new();
 4513|      1|        let table_id = 7u64;
 4514|      1|        let specs = vec![ColumnSpec::new(
 4515|       |            "A",
 4516|      1|            ColumnPolicy::Resizable {
 4517|      1|                min: 20.0,
 4518|      1|                preferred: 100.0,
 4519|      1|                clip: false,
 4520|      1|            },
 4521|      1|            None,
 4522|       |        )];
 4523|      1|        let widths = vec![100.0f32];
 4524|       |
 4525|       |        // Initial persist at default font size.
 4526|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
 4527|      1|        let policy_hash = specs[0].policy_hash;
 4528|       |        {
 4529|      1|            let metrics = renderer.table_metrics.borrow();
 4530|      1|            let entry = metrics.entry(table_id).expect("entry created");
 4531|      1|            assert_eq!(entry.persisted_width(policy_hash), Some(100.0));
 4532|      1|            assert_eq!(entry.persisted_font_size, Some(renderer.font_sizes.body));
 4533|       |        }
 4534|       |
 4535|       |        // Simulate zoom: font size changes but widths captured are still the old ones.
 4536|      1|        renderer.font_sizes.body = 16.0;
 4537|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
 4538|       |        {
 4539|      1|            let metrics = renderer.table_metrics.borrow();
 4540|      1|            let entry = metrics.entry(table_id).expect("entry exists");
 4541|       |            // Cleared and NOT re-saved in the same frame.
 4542|      1|            assert_eq!(entry.persisted_width(policy_hash), None);
 4543|      1|            assert_eq!(entry.persisted_font_size, Some(16.0));
 4544|       |        }
 4545|       |
 4546|       |        // Next frame with new layout widths should persist again.
 4547|      1|        let new_widths = vec![80.0f32];
 4548|      1|        renderer.persist_resizable_widths(table_id, &specs, &new_widths);
 4549|      1|        let metrics = renderer.table_metrics.borrow();
 4550|      1|        let entry = metrics.entry(table_id).expect("entry exists");
 4551|      1|        assert_eq!(entry.persisted_width(policy_hash), Some(80.0));
 4552|      1|        assert_eq!(entry.persisted_font_size, Some(16.0));
 4553|      1|    }
 4554|       |
 4555|       |    #[test]
 4556|      1|    fn test_tight_list_inline_code_and_styles() {
 4557|      1|        let renderer = MarkdownRenderer::new();
 4558|      1|        let md = "- Use `code` and **bold** and *italic* and ~~strike~~\\n";
 4559|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4560|      1|        assert_eq!(parsed.len(), 1);
 4561|      1|        match &parsed[0] {
 4562|      1|            MarkdownElement::List { ordered, items } => {
 4563|      1|                assert!(!ordered);
 4564|      1|                assert_eq!(items.len(), 1);
 4565|      1|                let spans = &items[0];
 4566|      1|                assert!(spans
 4567|      1|                    .iter()
 4568|      1|                    .any(|s| matches!(s, InlineSpan::Code(c) if c == "code")));
 4569|      1|                assert!(spans
 4570|      1|                    .iter()
 4571|      1|                    .any(|s| matches!(s, InlineSpan::Strong(t) if t.contains("bold"))));
 4572|      1|                assert!(spans
 4573|      1|                    .iter()
 4574|      1|                    .any(|s| matches!(s, InlineSpan::Emphasis(t) if t.contains("italic"))));
 4575|      1|                assert!(spans
 4576|      1|                    .iter()
 4577|      1|                    .any(|s| matches!(s, InlineSpan::Strikethrough(t) if t.contains("strike"))));
 4578|       |            }
 4579|      0|            other => panic!("Expected List, got {:?}", other),
 4580|       |        }
 4581|      1|    }
 4582|       |
 4583|       |    #[test]
 4584|      1|    fn test_expand_shortcodes_basic() {
 4585|      1|        let rocket = MarkdownRenderer::expand_shortcodes(":rocket:");
 4586|      1|        assert_ne!(rocket, ":rocket:");
 4587|      1|        assert!(crate::emoji_catalog::image_bytes_for(&rocket).is_some());
 4588|       |
 4589|      1|        let tada = MarkdownRenderer::expand_shortcodes(":tada:");
 4590|      1|        assert_ne!(tada, ":tada:");
 4591|      1|        assert!(crate::emoji_catalog::image_bytes_for(&tada).is_some());
 4592|       |
 4593|      1|        assert_eq!(
 4594|      1|            MarkdownRenderer::expand_shortcodes("Hello :tada:!"),
 4595|      1|            format!("Hello {}!", tada)
 4596|       |        );
 4597|      1|    }
 4598|       |
 4599|       |    #[test]
 4600|      1|    fn test_fix_unicode_chars_normalizes_basic_cases() {
 4601|      1|        let renderer = MarkdownRenderer::new();
 4602|      1|        let input = "A\u{00A0}B\u{2013}C";
 4603|      1|        let normalized = renderer.normalize_text_for_test(input);
 4604|      1|        assert_eq!(normalized, "A B-C");
 4605|       |
 4606|      1|        let arrows = renderer.normalize_text_for_test("   ");
 4607|      1|        assert_eq!(arrows, "<- -> ^ v");
 4608|       |
 4609|      1|        let untouched = renderer.normalize_text_for_test("Plain text");
 4610|      1|        assert_eq!(untouched, "Plain text");
 4611|      1|    }
 4612|       |
 4613|       |    #[test]
 4614|      1|    fn test_elements_to_plain_text_basic() {
 4615|      1|        let elements = vec![
 4616|      1|            MarkdownElement::Header {
 4617|      1|                level: 1,
 4618|      1|                spans: vec![InlineSpan::Text("Test Header".to_string())],
 4619|      1|                id: "test-header".to_string(),
 4620|      1|            },
 4621|      1|            MarkdownElement::Paragraph(vec![
 4622|      1|                InlineSpan::Text("This is a ".to_string()),
 4623|      1|                InlineSpan::Strong("bold".to_string()),
 4624|      1|                InlineSpan::Text(" paragraph.".to_string()),
 4625|      1|            ]),
 4626|       |        ];
 4627|       |
 4628|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 4629|      1|        assert!(plain_text.contains("Test Header"));
 4630|      1|        assert!(plain_text.contains("This is a bold paragraph."));
 4631|      1|    }
 4632|       |
 4633|       |    #[test]
 4634|      1|    fn test_elements_to_plain_text_code_block() {
 4635|      1|        let elements = vec![MarkdownElement::CodeBlock {
 4636|      1|            language: Some("rust".to_string()),
 4637|      1|            text: "fn main() {\n    println!(\"Hello\");\n}".to_string(),
 4638|      1|        }];
 4639|       |
 4640|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 4641|      1|        assert_eq!(plain_text, "fn main() {\n    println!(\"Hello\");\n}");
 4642|      1|    }
 4643|       |
 4644|       |    #[test]
 4645|      1|    fn test_elements_to_plain_text_with_links() {
 4646|      1|        let elements = vec![MarkdownElement::Paragraph(vec![
 4647|      1|            InlineSpan::Text("Visit ".to_string()),
 4648|      1|            InlineSpan::Link {
 4649|      1|                text: "GitHub".to_string(),
 4650|      1|                url: "https://github.com".to_string(),
 4651|      1|            },
 4652|      1|            InlineSpan::Text(" for more.".to_string()),
 4653|      1|        ])];
 4654|       |
 4655|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 4656|      1|        assert_eq!(plain_text, "Visit GitHub for more.");
 4657|      1|    }
 4658|       |
 4659|       |    #[test]
 4660|      1|    fn test_image_source_stale_detects_file_changes() {
 4661|       |        use std::time::Duration as StdDuration;
 4662|       |
 4663|      1|        let dir = tempfile::tempdir().expect("temp dir");
 4664|      1|        let file_path = dir.path().join("image.bin");
 4665|      1|        std::fs::write(&file_path, [1u8, 2, 3, 4]).expect("write image");
 4666|      1|        let initial = MarkdownRenderer::disk_image_timestamp(&file_path);
 4667|      1|        assert!(!MarkdownRenderer::image_source_stale(initial, &file_path));
 4668|       |
 4669|      1|        std::thread::sleep(StdDuration::from_millis(5));
 4670|      1|        std::fs::write(&file_path, [4u8, 3, 2, 1]).expect("rewrite image");
 4671|       |
 4672|      1|        assert!(MarkdownRenderer::image_source_stale(initial, &file_path));
 4673|      1|    }
 4674|       |
 4675|       |    #[test]
 4676|      1|    fn test_inline_code_preserves_whitespace() {
 4677|      1|        let renderer = MarkdownRenderer::new();
 4678|      1|        let md = "Start `code` end";
 4679|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4680|      1|        match &parsed[0] {
 4681|      1|            MarkdownElement::Paragraph(spans) => {
 4682|      2|                let code_span = spans.iter().find_map(|span| match span {
                                  ^1          ^1           ^1
 4683|      1|                    InlineSpan::Code(t) => Some(t),
 4684|      1|                    _ => None,
 4685|      2|                });
 4686|      1|                assert_eq!(code_span, Some(&"code".to_string()));
 4687|       |            }
 4688|      0|            other => panic!("Expected Paragraph, got {:?}", other),
 4689|       |        }
 4690|      1|    }
 4691|       |
 4692|       |    #[test]
 4693|      1|    fn test_kroki_enabled_env_flag() {
 4694|      1|        let _lock = env_lock();
 4695|      1|        std::env::remove_var("MDMDVIEW_ENABLE_KROKI");
 4696|      1|        assert!(!MarkdownRenderer::kroki_enabled_for_tests());
 4697|       |
 4698|      1|        std::env::set_var("MDMDVIEW_ENABLE_KROKI", "true");
 4699|      1|        assert!(MarkdownRenderer::kroki_enabled_for_tests());
 4700|       |
 4701|      1|        std::env::set_var("MDMDVIEW_ENABLE_KROKI", "0");
 4702|      1|        assert!(!MarkdownRenderer::kroki_enabled_for_tests());
 4703|       |
 4704|      1|        std::env::remove_var("MDMDVIEW_ENABLE_KROKI");
 4705|      1|    }
 4706|       |
 4707|       |    #[test]
 4708|      1|    fn test_spawn_kroki_job_reports_queue_disconnect() {
 4709|      1|        let mut renderer = MarkdownRenderer::new();
 4710|      1|        let (temp_tx, temp_rx) = crossbeam_channel::bounded::<KrokiRequest>(1);
 4711|      1|        drop(temp_rx);
 4712|      1|        renderer.kroki_job_tx = temp_tx;
 4713|      1|        let result = renderer.spawn_kroki_job(1, "graph TD; A-->B;");
 4714|      1|        assert!(matches!(result, Err(KrokiEnqueueError::Disconnected)));
                              ^0
 4715|      1|    }
 4716|       |
 4717|       |    #[test]
 4718|      1|    fn test_spawn_kroki_job_reports_queue_full() {
 4719|      1|        let mut renderer = MarkdownRenderer::new();
 4720|      1|        let (temp_tx, temp_rx) = crossbeam_channel::bounded::<KrokiRequest>(1);
 4721|       |        // Fill the bounded channel so subsequent sends report Full
 4722|      1|        temp_tx
 4723|      1|            .try_send(KrokiRequest {
 4724|      1|                key: 99,
 4725|      1|                url: "https://example.invalid/diagram".to_string(),
 4726|      1|                payload: "graph TD; A-->B;".to_string(),
 4727|      1|            })
 4728|      1|            .expect("pre-fill queue");
 4729|      1|        renderer.kroki_job_tx = temp_tx.clone();
 4730|       |        // Keep receiver alive (unused) to avoid disconnecting the channel
 4731|      1|        let _guard = temp_rx;
 4732|      1|        let result = renderer.spawn_kroki_job(42, "graph TD; B-->C;");
 4733|      1|        assert!(matches!(result, Err(KrokiEnqueueError::QueueFull)));
                              ^0
 4734|      1|    }
 4735|       |
 4736|       |    #[test]
 4737|      1|    fn test_footnote_markers_render_as_visible_text() {
 4738|      1|        let renderer = MarkdownRenderer::new();
 4739|      1|        let md = "Paragraph with footnote[^1].\n\n[^1]: footnote body.";
 4740|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4741|      1|        assert_eq!(parsed.len(), 2);
 4742|      1|        let first_plain = MarkdownRenderer::element_plain_text(&parsed[0]);
 4743|      1|        assert!(
 4744|      1|            first_plain.contains("footnote[^1]"),
 4745|      0|            "footnote marker should remain visible, got {first_plain}"
 4746|       |        );
 4747|      1|        let second_plain = MarkdownRenderer::element_plain_text(&parsed[1]);
 4748|      1|        assert!(
 4749|      1|            second_plain.contains("[^1]: footnote body."),
 4750|      0|            "footnote definition should remain visible, got {second_plain}"
 4751|       |        );
 4752|      1|    }
 4753|       |
 4754|       |    #[test]
 4755|      1|    fn test_parse_headers_assign_ids_and_dedupe() {
 4756|      1|        let renderer = MarkdownRenderer::new();
 4757|      1|        let md = "# Getting Started\n\n## Getting Started\n\n### API & Usage\n\n## API & Usage\n";
 4758|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4759|       |
 4760|      1|        let mut ids = vec![];
 4761|      5|        for el in parsed {
                          ^4
 4762|      4|            if let MarkdownElement::Header { id, .. } = el {
 4763|      4|                ids.push(id);
 4764|      4|            }
                          ^0
 4765|       |        }
 4766|      1|        assert_eq!(ids.len(), 4);
 4767|      1|        assert_eq!(ids[0], "getting-started");
 4768|      1|        assert_eq!(ids[1], "getting-started-1");
 4769|      1|        assert_eq!(ids[2], "api-usage");
 4770|      1|        assert_eq!(ids[3], "api-usage-1");
 4771|      1|    }
 4772|       |
 4773|       |    #[test]
 4774|      1|    fn test_formatting_sample_contains_expected_header_ids() {
 4775|      1|        let renderer = MarkdownRenderer::new();
 4776|      1|        let formatting = SAMPLE_FILES
 4777|      1|            .iter()
 4778|      2|            .find(|f| f.name == "formatting.md")
                           ^1
 4779|      1|            .expect("formatting sample present");
 4780|      1|        let parsed = renderer.parse(formatting.content).expect("parse ok");
 4781|      1|        let ids: Vec<String> = parsed
 4782|      1|            .into_iter()
 4783|     37|            .filter_map(|el| match el {
                           ^1
 4784|     18|                MarkdownElement::Header { id, .. } => Some(id),
 4785|     19|                _ => None,
 4786|     37|            })
 4787|      1|            .collect();
 4788|       |
 4789|     10|        for expected in [
 4790|       |            "markdown-formatting-guide",
 4791|      1|            "table-of-contents",
 4792|      1|            "text-formatting",
 4793|      1|            "headers",
 4794|      1|            "lists",
 4795|      1|            "links-and-images",
 4796|      1|            "emojis",
 4797|      1|            "blockquotes",
 4798|      1|            "horizontal-rules",
 4799|      1|            "tables",
 4800|       |        ] {
 4801|    101|            assert!(ids.iter().any(|id| id == expected), "missing id {expected}");
                          ^10     ^10        ^10                       ^0
 4802|       |        }
 4803|      1|    }
 4804|       |
 4805|       |    #[test]
 4806|      1|    fn test_inline_image_parsing() {
 4807|      1|        let renderer = MarkdownRenderer::new();
 4808|      1|        let md = "Here is an image: ![Alt text](images/pic.webp \"Title\") end.";
 4809|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4810|      1|        assert_eq!(parsed.len(), 1);
 4811|      1|        match &parsed[0] {
 4812|      1|            MarkdownElement::Paragraph(spans) => {
 4813|      2|                let img = spans.iter().find(|s| matches!(s, InlineSpan::Image { .. }));
                                  ^1    ^1           ^1
 4814|      1|                assert!(img.is_some(), "image inline span present");
                                                     ^0
 4815|      1|                if let InlineSpan::Image { src, alt, title } = img.unwrap() {
 4816|      1|                    assert_eq!(src, "images/pic.webp");
 4817|      1|                    assert_eq!(alt, "Alt text");
 4818|      1|                    assert_eq!(title.as_deref(), Some("Title"));
 4819|      0|                }
 4820|       |            }
 4821|      0|            other => panic!("Expected Paragraph, got {:?}", other),
 4822|       |        }
 4823|      1|    }
 4824|       |
 4825|       |    #[test]
 4826|      1|    fn test_image_text_in_plain_text_index() {
 4827|      1|        let renderer = MarkdownRenderer::new();
 4828|      1|        let md = "![Diagram](./a.png \"Flow\")";
 4829|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4830|      1|        let text = MarkdownRenderer::element_plain_text(&parsed[0]);
 4831|      1|        assert!(text.contains("Diagram"));
 4832|      1|        assert!(text.contains("Flow"));
 4833|      1|    }
 4834|       |
 4835|       |    #[test]
 4836|      1|    fn test_cell_fragments_split_text_and_images() {
 4837|      1|        let renderer = MarkdownRenderer::new();
 4838|      1|        let spans = vec![
 4839|      1|            InlineSpan::Text("alpha".into()),
 4840|      1|            InlineSpan::Strong("beta".into()),
 4841|      1|            InlineSpan::Image {
 4842|      1|                src: "img.png".into(),
 4843|      1|                alt: "img".into(),
 4844|      1|                title: None,
 4845|      1|            },
 4846|      1|            InlineSpan::Text("gamma".into()),
 4847|       |        ];
 4848|      1|        let fragments = renderer.cell_fragments(&spans);
 4849|      1|        assert_eq!(fragments.len(), 3);
 4850|      1|        match &fragments[0] {
 4851|      1|            CellFragment::Text(slice) => assert_eq!(slice.len(), 2),
 4852|      0|            other => panic!("expected text fragment, got {:?}", other),
 4853|       |        }
 4854|      1|        match &fragments[1] {
 4855|      1|            CellFragment::Image(span) => {
 4856|      1|                if let InlineSpan::Image { src, .. } = span {
 4857|      1|                    assert_eq!(src, "img.png");
 4858|       |                } else {
 4859|      0|                    panic!("image fragment should point to inline image span");
 4860|       |                }
 4861|       |            }
 4862|      0|            other => panic!("second fragment should be image, got {:?}", other),
 4863|       |        }
 4864|      1|        match &fragments[2] {
 4865|      1|            CellFragment::Text(slice) => {
 4866|      1|                assert_eq!(slice.len(), 1);
 4867|      1|                if let InlineSpan::Text(content) = &slice[0] {
 4868|      1|                    assert_eq!(content, "gamma");
 4869|       |                } else {
 4870|      0|                    panic!("expected trailing text span");
 4871|       |                }
 4872|       |            }
 4873|      0|            other => panic!("expected trailing text fragment, got {:?}", other),
 4874|       |        }
 4875|      1|    }
 4876|       |
 4877|       |    #[test]
 4878|      1|    fn test_cell_fragments_detect_single_emoji_span() {
 4879|      1|        let renderer = MarkdownRenderer::new();
 4880|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 4881|      1|            .get(":rocket:")
 4882|      1|            .expect("rocket shortcode");
 4883|      1|        let spans = vec![
 4884|      1|            InlineSpan::Text((*rocket).to_string()),
 4885|      1|            InlineSpan::Text("tail".into()),
 4886|       |        ];
 4887|      1|        let fragments = renderer.cell_fragments(&spans);
 4888|      1|        assert_eq!(fragments.len(), 2);
 4889|      1|        assert!(matches!(
                              ^0
 4890|      1|            &fragments[0],
 4891|      1|            CellFragment::Emoji(e) if !e.is_empty()
 4892|       |        ));
 4893|      1|        assert!(matches!(fragments[1], CellFragment::Text(_)));
                              ^0
 4894|      1|    }
 4895|       |
 4896|       |    #[test]
 4897|      1|    fn test_layout_job_builder_respects_wrap_width() {
 4898|      1|        let renderer = MarkdownRenderer::new();
 4899|      1|        let spans = vec![InlineSpan::Text(
 4900|      1|            "A long column entry that should wrap neatly within the supplied width.".into(),
 4901|      1|        )];
 4902|      1|        let style = egui::Style::default();
 4903|      1|        let build = renderer.build_layout_job(&style, &spans, 180.0, false);
 4904|      1|        assert_eq!(build.job.wrap.max_width, 180.0);
 4905|      1|        assert!(
 4906|      1|            build.job.text.contains("column entry"),
 4907|      0|            "plain text should be preserved"
 4908|       |        );
 4909|      1|    }
 4910|       |
 4911|       |    #[test]
 4912|      1|    fn test_layout_job_builder_highlights_matches() {
 4913|      1|        let renderer = MarkdownRenderer::new();
 4914|      1|        renderer.set_highlight_phrase(Some("wrap"));
 4915|      1|        let spans = vec![InlineSpan::Text("wrap me, wrap me again".into())];
 4916|      1|        let style = egui::Style::default();
 4917|      1|        let build = renderer.build_layout_job(&style, &spans, 200.0, false);
 4918|      1|        let highlight_bg = style.visuals.selection.bg_fill;
 4919|      1|        assert!(
 4920|      1|            build
 4921|      1|                .job
 4922|      1|                .sections
 4923|      1|                .iter()
 4924|      1|                .any(|s| s.format.background == highlight_bg),
 4925|      0|            "at least one section should carry highlight background"
 4926|       |        );
 4927|      1|    }
 4928|       |
 4929|       |    #[test]
 4930|      1|    fn test_layout_job_builder_tracks_link_ranges() {
 4931|      1|        let renderer = MarkdownRenderer::new();
 4932|      1|        let spans = vec![InlineSpan::Link {
 4933|      1|            text: "Docs".into(),
 4934|      1|            url: "https://example.org/docs".into(),
 4935|      1|        }];
 4936|      1|        let style = egui::Style::default();
 4937|      1|        let build = renderer.build_layout_job(&style, &spans, 220.0, false);
 4938|      1|        assert_eq!(build.link_ranges.len(), 1);
 4939|      1|        let link = &build.link_ranges[0];
 4940|      1|        assert_eq!(link.url, "https://example.org/docs");
 4941|      1|        let char_len = link.char_range.end - link.char_range.start;
 4942|      1|        let linked_text: String = build
 4943|      1|            .job
 4944|      1|            .text
 4945|      1|            .chars()
 4946|      1|            .skip(link.char_range.start)
 4947|      1|            .take(char_len)
 4948|      1|            .collect();
 4949|      1|        assert_eq!(linked_text, "Docs");
 4950|      1|    }
 4951|       |
 4952|       |    #[test]
 4953|      1|    fn test_table_width_solver_keeps_short_columns_readable() {
 4954|      1|        let mins = vec![90.0, 90.0, 90.0, 90.0];
 4955|      1|        let desired = vec![120.0, 120.0, 360.0, 160.0];
 4956|      1|        let widths = MarkdownRenderer::resolve_table_widths(420.0, &mins, &desired);
 4957|      1|        assert_eq!(widths.len(), 4);
 4958|       |        // Narrow columns should stay near their minimums even when a wide column exists
 4959|      1|        assert!(
 4960|      1|            widths[0] >= 85.0,
 4961|      0|            "Version column shrank too far: {}",
 4962|      0|            widths[0]
 4963|       |        );
 4964|      1|        assert!(
 4965|      1|            widths[2] > widths[0],
 4966|      0|            "Wide column should retain more width"
 4967|       |        );
 4968|      1|        let sum: f32 = widths.iter().sum();
 4969|      1|        assert!(
 4970|      1|            (sum - 420.0).abs() < 0.5,
 4971|      0|            "Widths should consume available space, got {sum}"
 4972|       |        );
 4973|      1|    }
 4974|       |
 4975|       |    #[test]
 4976|      1|    fn test_table_width_solver_handles_constrained_space() {
 4977|      1|        let mins = vec![100.0, 100.0, 100.0, 100.0];
 4978|      1|        let desired = vec![200.0, 240.0, 360.0, 160.0];
 4979|      1|        let widths = MarkdownRenderer::resolve_table_widths(260.0, &mins, &desired);
 4980|      1|        assert_eq!(widths.len(), 4);
 4981|      1|        assert!(
 4982|      4|            widths.iter().all(|w| *w > 0.0),
                          ^1            ^1
 4983|      0|            "Widths must stay positive even when clamped hard"
 4984|       |        );
 4985|      1|        let sum: f32 = widths.iter().sum();
 4986|      1|        assert!(
 4987|      1|            (sum - 260.0).abs() < 0.5,
 4988|      0|            "Widths should sum to available space even under tight constraints"
 4989|       |        );
 4990|      1|    }
 4991|       |
 4992|       |    #[test]
 4993|      1|    fn table_cells_keep_images_and_formatting() {
 4994|      1|        let renderer = MarkdownRenderer::new();
 4995|      1|        let md = "\
 4996|      1|| H1 | H2 |
 4997|      1|| --- | --- |
 4998|      1|| text ![Alt](img.png) | **bold** and [link](https://example.com) |";
 4999|      1|        let elements = renderer.parse(md).expect("parse ok");
 5000|      1|        let table = elements
 5001|      1|            .iter()
 5002|      1|            .find_map(|el| match el {
 5003|      1|                MarkdownElement::Table { headers: _, rows } => Some(rows),
 5004|      0|                _ => None,
 5005|      1|            })
 5006|      1|            .expect("table present");
 5007|      1|        assert_eq!(table.len(), 1);
 5008|      1|        let row = &table[0];
 5009|      1|        assert!(row[0]
 5010|      1|            .iter()
 5011|      1|            .any(|span| matches!(span, InlineSpan::Image { src, .. } if src == "img.png")));
 5012|      1|        assert!(row[1]
 5013|      1|            .iter()
 5014|      1|            .any(|span| matches!(span, InlineSpan::Strong(text) if text.contains("bold"))));
 5015|      1|        assert!(row[1].iter().any(|span| matches!(
 5016|      1|            span,
 5017|      1|            InlineSpan::Link { url, .. } if url == "https://example.com"
 5018|       |        )));
 5019|      1|    }
 5020|       |
 5021|       |    #[test]
 5022|      1|    fn table_ids_are_unique_per_position() {
 5023|      1|        let renderer = MarkdownRenderer::new();
 5024|      1|        let md = "\
 5025|      1|| H |
 5026|      1|| - |
 5027|      1|| a |
 5028|      1|
 5029|      1|| H |
 5030|      1|| - |
 5031|      1|| a |";
 5032|      1|        let elements = renderer.parse(md).expect("parse ok");
 5033|      1|        let tables: Vec<_> = elements
 5034|      1|            .iter()
 5035|      1|            .enumerate()
 5036|      2|            .filter_map(|(idx, el)| match el {
                           ^1
 5037|      2|                MarkdownElement::Table { headers, rows } => {
 5038|      2|                    Some(renderer.compute_table_id(headers, rows, idx))
 5039|       |                }
 5040|      0|                _ => None,
 5041|      2|            })
 5042|      1|            .collect();
 5043|      1|        assert_eq!(tables.len(), 2);
 5044|      1|        assert_ne!(tables[0], tables[1], "table ids should differ by position");
                                                       ^0
 5045|      1|    }
 5046|       |
 5047|       |    #[test]
 5048|      1|    fn test_render_to_ui_rich_document_populates_rects_and_table_stats() {
 5049|      1|        let renderer = MarkdownRenderer::new();
 5050|      1|        let md = "\
 5051|      1|# Coverage Demo
 5052|      1|
 5053|      1|Paragraph with :tada: emoji and **bold** text and a [link](#target).
 5054|      1|
 5055|      1|> Quote line one
 5056|      1|> Quote line two
 5057|      1|
 5058|      1|- item one
 5059|      1|- item two
 5060|      1|
 5061|      1|---
 5062|      1|
 5063|      1|```rust
 5064|      1|fn main() {}
 5065|      1|```
 5066|      1|
 5067|      1|| Col A | Col B |
 5068|      1|| --- | --- |
 5069|      1|| A1 | B1 |
 5070|      1|| A2 | B2 |
 5071|      1|
 5072|      1|![Logo](assets/samples/logo.svg \"Logo\")
 5073|      1|![Sample](assets/samples/webp_sample.webp \"Sample\")
 5074|      1|![Missing](missing_test_image.png \"Missing\")
 5075|      1|![Remote](https://example.com/image.png \"Remote\")
 5076|      1|";
 5077|       |
 5078|      1|        let elements = renderer.parse(md).expect("parse ok");
 5079|      1|        renderer.set_highlight_phrase(Some("item"));
 5080|       |
 5081|      1|        with_test_ui(|_, ui| {
 5082|      1|            renderer.render_to_ui(ui, &elements);
 5083|      1|        });
 5084|       |
 5085|      1|        assert!(renderer.element_rect_at(0).is_some());
 5086|      1|        assert!(renderer.header_rect_for("coverage-demo").is_some());
 5087|      1|        let (rendered, total) = renderer.table_render_stats();
 5088|      1|        assert!(total > 0);
 5089|      1|        assert!(rendered > 0);
 5090|      1|        let (_hits, misses) = renderer.table_layout_cache_stats();
 5091|      1|        assert!(misses > 0);
 5092|      1|    }
 5093|       |
 5094|       |    #[test]
 5095|      1|    fn test_table_layout_cache_records_hits() {
 5096|      1|        let renderer = MarkdownRenderer::new();
 5097|      1|        let spans = vec![InlineSpan::Text("alpha".to_string())];
 5098|      1|        let style = egui::Style::default();
 5099|       |
 5100|      1|        let _ = renderer.cached_layout_job(&style, Some(0), 0, &spans, 120.0, false);
 5101|      1|        let _ = renderer.cached_layout_job(&style, Some(0), 0, &spans, 120.0, false);
 5102|       |
 5103|      1|        let (hits, misses) = renderer.table_layout_cache_stats();
 5104|      1|        assert!(hits >= 1);
 5105|      1|        assert!(misses >= 1);
 5106|       |
 5107|      1|        renderer.clear_table_layout_cache();
 5108|      1|        assert_eq!(renderer.table_layout_cache_stats(), (0, 0));
 5109|      1|    }
 5110|       |
 5111|       |    #[test]
 5112|      1|    fn test_trigger_link_handles_fragments_and_schemes() {
 5113|      1|        let renderer = MarkdownRenderer::new();
 5114|       |
 5115|      1|        renderer.trigger_link("#Section-One");
 5116|      1|        assert_eq!(
 5117|      1|            renderer.take_pending_anchor(),
 5118|      1|            Some("section-one".to_string())
 5119|       |        );
 5120|      1|        assert!(renderer.take_pending_anchor().is_none());
 5121|       |
 5122|      1|        renderer.trigger_link("ftp://example.com");
 5123|      1|        assert!(renderer.take_pending_anchor().is_none());
 5124|       |
 5125|      1|        renderer.trigger_link("https://example.com");
 5126|      1|        assert!(renderer.take_pending_anchor().is_none());
 5127|       |
 5128|      1|        renderer.trigger_link("mailto:hello@example.com");
 5129|      1|        assert!(renderer.take_pending_anchor().is_none());
 5130|      1|    }
 5131|       |
 5132|       |    #[test]
 5133|      1|    fn test_resolve_image_path_with_base_dir() {
 5134|      1|        let renderer = MarkdownRenderer::new();
 5135|      1|        let temp = tempdir().expect("temp dir");
 5136|      1|        renderer.set_base_dir(Some(temp.path()));
 5137|       |
 5138|      1|        let resolved = renderer.resolve_image_path("sample.png");
 5139|      1|        assert!(resolved.contains("sample.png"));
 5140|       |
 5141|      1|        let abs = temp.path().join("abs.png");
 5142|      1|        let abs_str = abs.to_string_lossy().into_owned();
 5143|      1|        assert_eq!(renderer.resolve_image_path(&abs_str), abs_str);
 5144|       |
 5145|      1|        renderer.set_base_dir(None);
 5146|      1|        assert_eq!(renderer.resolve_image_path("relative.png"), "relative.png");
 5147|      1|    }
 5148|       |
 5149|       |    #[test]
 5150|      1|    fn test_disk_image_loads_and_caches() {
 5151|      1|        let renderer = MarkdownRenderer::new();
 5152|      1|        let temp = tempdir().expect("temp dir");
 5153|      1|        let image_path = temp.path().join("disk.png");
 5154|       |
 5155|      1|        let mut img = image::RgbaImage::new(2, 2);
 5156|      4|        for pixel in img.pixels_mut() {
                                   ^1  ^1
 5157|      4|            *pixel = image::Rgba([10, 20, 30, 255]);
 5158|      4|        }
 5159|      1|        img.save(&image_path).expect("save png");
 5160|       |
 5161|      1|        renderer.set_base_dir(Some(temp.path()));
 5162|      1|        let resolved = renderer.resolve_image_path("disk.png");
 5163|      1|        with_test_ui(|_, ui| {
 5164|      1|            let loaded = renderer.get_or_load_image_texture(ui, &resolved);
 5165|      1|            assert!(loaded.is_some());
 5166|      1|        });
 5167|       |
 5168|      1|        assert!(renderer.image_textures.borrow().contains_key(&resolved));
 5169|      1|    }
 5170|       |
 5171|       |    #[test]
 5172|      1|    fn test_context_menu_helpers_execute() {
 5173|      1|        let renderer = MarkdownRenderer::new();
 5174|      1|        with_test_ui(|_, ui| {
 5175|      1|            renderer.render_text_context_menu(ui, "text");
 5176|      1|            renderer.render_inline_code_context_menu(ui, "code");
 5177|      1|            renderer.render_code_block_context_menu(ui, "fn main() {}", Some("rust"));
 5178|      1|            renderer.render_link_context_menu(ui, "label", "#anchor");
 5179|      1|            renderer.render_cell_context_menu(ui, "cell");
 5180|      1|            renderer.copy_text_and_close(ui, "direct-copy");
 5181|      1|        });
 5182|      1|    }
 5183|       |
 5184|       |    #[test]
 5185|      1|    fn test_table_wrap_overhaul_toggle() {
 5186|      1|        let mut renderer = MarkdownRenderer::new();
 5187|      1|        assert!(renderer.table_wrap_overhaul_enabled());
 5188|      1|        renderer.set_table_wrap_overhaul_enabled(false);
 5189|      1|        assert!(!renderer.table_wrap_overhaul_enabled());
 5190|      1|        renderer.set_table_wrap_overhaul_enabled(true);
 5191|      1|        assert!(renderer.table_wrap_overhaul_enabled());
 5192|      1|    }
 5193|       |
 5194|       |    #[test]
 5195|      1|    fn test_build_layout_job_covers_inline_styles() {
 5196|      1|        let renderer = MarkdownRenderer::new();
 5197|      1|        renderer.set_highlight_phrase(Some("code"));
 5198|      1|        let spans = vec![
 5199|      1|            InlineSpan::Text("plain".to_string()),
 5200|      1|            InlineSpan::Strong("bold".to_string()),
 5201|      1|            InlineSpan::Emphasis("italics".to_string()),
 5202|      1|            InlineSpan::Strikethrough("strike".to_string()),
 5203|      1|            InlineSpan::Code("code".to_string()),
 5204|      1|            InlineSpan::Link {
 5205|      1|                text: "ext".to_string(),
 5206|      1|                url: "https://example.com".to_string(),
 5207|      1|            },
 5208|      1|            InlineSpan::Link {
 5209|      1|                text: "local".to_string(),
 5210|      1|                url: "#anchor".to_string(),
 5211|      1|            },
 5212|       |        ];
 5213|       |
 5214|      1|        with_test_ui(|_, ui| {
 5215|      1|            let style = ui.style().clone();
 5216|      1|            let build = renderer.build_layout_job(&style, &spans, 200.0, false);
 5217|      1|            assert!(build.plain_text.contains("plain"));
 5218|      1|            assert_eq!(build.link_ranges.len(), 2);
 5219|      1|        });
 5220|      1|    }
 5221|       |
 5222|       |    #[test]
 5223|      1|    fn test_render_inline_span_variants() {
 5224|      1|        let renderer = MarkdownRenderer::new();
 5225|      1|        let temp = tempdir().expect("temp dir");
 5226|      1|        let image_path = temp.path().join("image.png");
 5227|      1|        std::fs::write(&image_path, tiny_png_bytes()).expect("write png");
 5228|      1|        renderer.set_base_dir(Some(temp.path()));
 5229|       |
 5230|      1|        let image_span = InlineSpan::Image {
 5231|      1|            src: "image.png".to_string(),
 5232|      1|            alt: "Alt".to_string(),
 5233|      1|            title: Some("Title".to_string()),
 5234|      1|        };
 5235|      1|        let missing_span = InlineSpan::Image {
 5236|      1|            src: "missing.png".to_string(),
 5237|      1|            alt: "".to_string(),
 5238|      1|            title: None,
 5239|      1|        };
 5240|       |
 5241|      1|        let _guard = ForcedRenderActions::new(&["link_hover", "link_click", "image_hover"]);
 5242|      1|        with_test_ui(|_, ui| {
 5243|      1|            ui.visuals_mut().dark_mode = false;
 5244|      1|            renderer.render_inline_span(ui, &InlineSpan::Code("code".to_string()), None, None);
 5245|       |
 5246|      1|            ui.visuals_mut().dark_mode = true;
 5247|      1|            renderer.render_inline_span(ui, &InlineSpan::Text("text".to_string()), None, None);
 5248|      1|            renderer.render_inline_span(ui, &InlineSpan::Strong("bold".to_string()), None, None);
 5249|      1|            renderer.render_inline_span(
 5250|      1|                ui,
 5251|      1|                &InlineSpan::Emphasis("italic".to_string()),
 5252|      1|                None,
 5253|      1|                None,
 5254|       |            );
 5255|      1|            renderer.render_inline_span(
 5256|      1|                ui,
 5257|      1|                &InlineSpan::Strikethrough("strike".to_string()),
 5258|      1|                None,
 5259|      1|                None,
 5260|       |            );
 5261|      1|            renderer.render_inline_span(
 5262|      1|                ui,
 5263|      1|                &InlineSpan::Link {
 5264|      1|                    text: "ext".to_string(),
 5265|      1|                    url: "https://example.com".to_string(),
 5266|      1|                },
 5267|      1|                None,
 5268|      1|                None,
 5269|       |            );
 5270|      1|            renderer.render_inline_span(
 5271|      1|                ui,
 5272|      1|                &InlineSpan::Link {
 5273|      1|                    text: "local".to_string(),
 5274|      1|                    url: "#anchor".to_string(),
 5275|      1|                },
 5276|      1|                None,
 5277|      1|                None,
 5278|       |            );
 5279|      1|            renderer.render_inline_span(ui, &image_span, None, None);
 5280|      1|            renderer.render_inline_span(ui, &missing_span, None, None);
 5281|      1|        });
 5282|      1|    }
 5283|       |
 5284|       |    #[test]
 5285|      1|    fn test_parse_lists_and_blockquotes() {
 5286|      1|        let renderer = MarkdownRenderer::new();
 5287|      1|        let md = "\
 5288|      1|- Item 1
 5289|      1|- Item 2
 5290|      1|  - Nested
 5291|      1|
 5292|      1|1. First
 5293|      1|2. Second
 5294|      1|
 5295|      1|> Quote line
 5296|      1|> > Nested quote
 5297|      1|
 5298|      1|---";
 5299|       |
 5300|      1|        let elements = renderer.parse(md).expect("parse ok");
 5301|      1|        assert!(elements.iter().any(|el| matches!(
 5302|      1|            el,
 5303|       |            MarkdownElement::List { ordered: false, .. }
 5304|       |        )));
 5305|      1|        assert!(elements
 5306|      1|            .iter()
 5307|      2|            .any(|el| matches!(el, MarkdownElement::List { ordered: true, .. })));
                           ^1
 5308|      1|        assert!(elements
 5309|      1|            .iter()
 5310|      3|            .any(|el| matches!(el, MarkdownElement::Quote { .. })));
                           ^1
 5311|      1|        assert!(elements
 5312|      1|            .iter()
 5313|      5|            .any(|el| matches!(el, MarkdownElement::HorizontalRule)));
                           ^1
 5314|      1|    }
 5315|       |
 5316|       |    #[test]
 5317|      1|    fn test_elements_to_plain_text_variants() {
 5318|      1|        let elements = vec![
 5319|      1|            MarkdownElement::Header {
 5320|      1|                level: 1,
 5321|      1|                spans: vec![InlineSpan::Text("Title".to_string())],
 5322|      1|                id: "title".to_string(),
 5323|      1|            },
 5324|      1|            MarkdownElement::Paragraph(vec![
 5325|      1|                InlineSpan::Text("Hello".to_string()),
 5326|      1|                InlineSpan::Code("code".to_string()),
 5327|      1|            ]),
 5328|      1|            MarkdownElement::CodeBlock {
 5329|      1|                language: Some("rust".to_string()),
 5330|      1|                text: "fn main() {}".to_string(),
 5331|      1|            },
 5332|      1|            MarkdownElement::List {
 5333|      1|                ordered: false,
 5334|      1|                items: vec![vec![InlineSpan::Text("Item".to_string())]],
 5335|      1|            },
 5336|      1|            MarkdownElement::Quote {
 5337|      1|                depth: 1,
 5338|      1|                lines: vec![vec![InlineSpan::Text("Quote".to_string())]],
 5339|      1|            },
 5340|      1|            MarkdownElement::HorizontalRule,
 5341|      1|            MarkdownElement::Table {
 5342|      1|                headers: vec![vec![InlineSpan::Text("H".to_string())]],
 5343|      1|                rows: vec![vec![vec![InlineSpan::Image {
 5344|      1|                    src: "img.png".to_string(),
 5345|      1|                    alt: "Alt".to_string(),
 5346|      1|                    title: None,
 5347|      1|                }]]],
 5348|      1|            },
 5349|       |        ];
 5350|      1|        let text = MarkdownRenderer::elements_to_plain_text(&elements);
 5351|      1|        assert!(text.contains("Title"));
 5352|      1|        assert!(text.contains("Hello"));
 5353|      1|        assert!(text.contains("fn main"));
 5354|      1|        assert!(text.contains("Item"));
 5355|      1|        assert!(text.contains("Quote"));
 5356|      1|        assert!(text.contains("Alt"));
 5357|      1|    }
 5358|       |
 5359|       |    #[test]
 5360|      1|    fn test_table_rendering_legacy_and_overhaul() {
 5361|      1|        let mut renderer = MarkdownRenderer::new();
 5362|      1|        let headers = vec![
 5363|      1|            vec![InlineSpan::Text("H1".to_string())],
 5364|      1|            vec![InlineSpan::Text("H2".to_string())],
 5365|       |        ];
 5366|      1|        let rows = vec![vec![
 5367|      1|            vec![InlineSpan::Text("Cell".to_string())],
 5368|      1|            vec![InlineSpan::Link {
 5369|      1|                text: "Link".to_string(),
 5370|      1|                url: "https://example.com".to_string(),
 5371|      1|            }],
 5372|       |        ]];
 5373|      1|        let elements = vec![MarkdownElement::Table { headers, rows }];
 5374|       |
 5375|      1|        with_test_ui(|_, ui| {
 5376|      1|            renderer.render_to_ui(ui, &elements);
 5377|      1|        });
 5378|       |
 5379|      1|        renderer.set_table_wrap_overhaul_enabled(false);
 5380|      1|        with_test_ui(|_, ui| {
 5381|      1|            renderer.render_to_ui(ui, &elements);
 5382|      1|        });
 5383|      1|    }
 5384|       |
 5385|       |    #[test]
 5386|      1|    fn test_measure_inline_spans_and_emoji_texture() {
 5387|      1|        let renderer = MarkdownRenderer::new();
 5388|      1|        let spans = vec![
 5389|      1|            InlineSpan::Text("Hello".to_string()),
 5390|      1|            InlineSpan::Text("".to_string()),
 5391|       |        ];
 5392|       |
 5393|      1|        with_test_ui(|_, ui| {
 5394|      1|            let width = renderer.measure_inline_spans(ui, &spans);
 5395|      1|            assert!(width > 0.0);
 5396|      1|            let tex = renderer.get_or_make_emoji_texture(ui, "");
 5397|      1|            assert!(tex.size()[0] > 0);
 5398|      1|        });
 5399|       |
 5400|      1|        let img = renderer.generate_emoji_image("", 16);
 5401|      1|        assert_eq!(img.size[0], 16);
 5402|      1|    }
 5403|       |
 5404|       |    #[test]
 5405|      1|    fn test_poll_kroki_results_caches() {
 5406|      1|        let mut renderer = MarkdownRenderer::new();
 5407|      1|        let (tx, rx) = std::sync::mpsc::channel();
 5408|      1|        renderer.kroki_rx = rx;
 5409|      1|        renderer.kroki_pending.borrow_mut().insert(1);
 5410|      1|        renderer.kroki_pending.borrow_mut().insert(2);
 5411|      1|        tx.send((1, Ok(vec![1, 2, 3]))).expect("send ok");
 5412|      1|        tx.send((2, Err("boom".to_string())))
 5413|      1|            .expect("send err");
 5414|       |
 5415|      1|        renderer.poll_kroki_results();
 5416|       |
 5417|      1|        assert!(renderer.kroki_svg_cache.borrow().contains_key(&1));
 5418|      1|        assert!(renderer.kroki_errors.borrow().contains_key(&2));
 5419|      1|        assert!(!renderer.kroki_pending.borrow().contains(&1));
 5420|      1|    }
 5421|       |
 5422|       |    #[test]
 5423|      1|    fn test_render_mermaid_block_paths() {
 5424|      1|        let _lock = env_lock();
 5425|      1|        let renderer = MarkdownRenderer::new();
 5426|      1|        let code = "graph TD; A-->B;";
 5427|      1|        let key = MarkdownRenderer::hash_str(code);
 5428|       |
 5429|      1|        let _guard = EnvGuard::set("MDMDVIEW_ENABLE_KROKI", "1");
 5430|      1|        let _guard_url = EnvGuard::set("MDMDVIEW_KROKI_URL", "https://example.invalid");
 5431|       |
 5432|      1|        renderer
 5433|      1|            .kroki_svg_cache
 5434|      1|            .borrow_mut()
 5435|      1|            .insert(key, tiny_png_bytes());
 5436|       |
 5437|      1|        with_test_ui(|_, ui| {
 5438|      1|            assert!(renderer.render_mermaid_block(ui, code));
 5439|      1|        });
 5440|       |
 5441|      1|        let bad_code = "graph TD; B-->C;";
 5442|      1|        let bad_key = MarkdownRenderer::hash_str(bad_code);
 5443|      1|        renderer
 5444|      1|            .kroki_svg_cache
 5445|      1|            .borrow_mut()
 5446|      1|            .insert(bad_key, vec![1, 2, 3]);
 5447|       |
 5448|      1|        with_test_ui(|_, ui| {
 5449|      1|            assert!(!renderer.render_mermaid_block(ui, bad_code));
 5450|      1|        });
 5451|       |
 5452|      1|        let mut renderer = MarkdownRenderer::new();
 5453|      1|        let (tx, _rx) = crossbeam_channel::bounded(0);
 5454|      1|        renderer.kroki_job_tx = tx;
 5455|      1|        with_test_ui(|_, ui| {
 5456|      1|            assert!(renderer.render_mermaid_block(ui, "graph TD; C-->D;"));
 5457|      1|        });
 5458|      1|    }
 5459|       |
 5460|       |    #[test]
 5461|      1|    fn test_render_mermaid_block_disabled() {
 5462|      1|        let _lock = env_lock();
 5463|      1|        let renderer = MarkdownRenderer::new();
 5464|      1|        let _guard = EnvGuard::set("MDMDVIEW_ENABLE_KROKI", "0");
 5465|      1|        with_test_ui(|_, ui| {
 5466|      1|            assert!(!renderer.render_mermaid_block(ui, "graph TD; A-->B;"));
 5467|      1|        });
 5468|      1|    }
 5469|       |
 5470|       |    #[test]
 5471|      1|    fn test_parse_hex_color_and_mermaid_bg_fill() {
 5472|      1|        let _lock = env_lock();
 5473|      1|        assert_eq!(
 5474|      1|            MarkdownRenderer::parse_hex_color("#ff00ff"),
 5475|       |            Some([255, 0, 255, 255])
 5476|       |        );
 5477|      1|        assert_eq!(
 5478|      1|            MarkdownRenderer::parse_hex_color("11223344"),
 5479|       |            Some([17, 34, 51, 68])
 5480|       |        );
 5481|      1|        assert!(MarkdownRenderer::parse_hex_color("bad").is_none());
 5482|       |
 5483|       |        {
 5484|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG_COLOR", "#010203");
 5485|      1|            assert_eq!(
 5486|      1|                MarkdownRenderer::mermaid_bg_fill(),
 5487|       |                Some([1, 2, 3, 255])
 5488|       |            );
 5489|       |        }
 5490|       |
 5491|       |        {
 5492|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "transparent");
 5493|      1|            assert_eq!(MarkdownRenderer::mermaid_bg_fill(), None);
 5494|       |        }
 5495|       |
 5496|       |        {
 5497|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "dark");
 5498|      1|            assert_eq!(
 5499|      1|                MarkdownRenderer::mermaid_bg_fill(),
 5500|       |                Some([20, 20, 20, 255])
 5501|       |            );
 5502|       |        }
 5503|      1|    }
 5504|       |
 5505|       |    #[test]
 5506|      1|    fn test_find_syntax_for_language() {
 5507|      1|        let renderer = MarkdownRenderer::new();
 5508|      1|        assert!(renderer.find_syntax_for_language("rust").is_some());
 5509|      1|        assert!(renderer.find_syntax_for_language("nonexistent").is_none());
 5510|      1|    }
 5511|       |
 5512|       |    #[test]
 5513|      1|    fn test_render_code_block_highlight_and_fallback() {
 5514|      1|        let renderer = MarkdownRenderer::new();
 5515|      1|        with_test_ui(|_, ui| {
 5516|      1|            renderer.render_code_block(ui, Some("rust"), "fn main() {}");
 5517|      1|            renderer.render_code_block(ui, Some("notalanguage"), "code");
 5518|      1|        });
 5519|      1|    }
 5520|       |
 5521|       |    #[test]
 5522|      1|    fn test_to_superscript_maps_values() {
 5523|      1|        let mapped = MarkdownRenderer::to_superscript("Abc123!");
 5524|      1|        assert_ne!(mapped, "Abc123!");
 5525|      1|    }
 5526|       |}

C:\language\mdmdview\src\sample_files.rs:
    1|       |//! Sample markdown files embedded in the application
    2|       |//!
    3|       |//! These files demonstrate the markdown viewer capabilities and provide
    4|       |//! usage instructions. They are built into the executable for easy access.
    5|       |
    6|       |/// Represents a sample markdown file with metadata
    7|       |#[derive(Debug, Clone)]
    8|       |pub struct SampleFile {
    9|       |    pub name: &'static str,
   10|       |    pub title: &'static str,
   11|       |    pub content: &'static str,
   12|       |}
   13|       |
   14|       |/// Collection of all embedded sample files
   15|       |pub const SAMPLE_FILES: &[SampleFile] = &[
   16|       |    SampleFile {
   17|       |        name: "welcome.md",
   18|       |        title: "Welcome to MarkdownView",
   19|       |        content: WELCOME_CONTENT,
   20|       |    },
   21|       |    SampleFile {
   22|       |        name: "formatting.md",
   23|       |        title: "Formatting Examples",
   24|       |        content: FORMATTING_CONTENT,
   25|       |    },
   26|       |    SampleFile {
   27|       |        name: "code.md",
   28|       |        title: "Code Examples",
   29|       |        content: CODE_CONTENT,
   30|       |    },
   31|       |    SampleFile {
   32|       |        name: "usage.md",
   33|       |        title: "Usage Instructions",
   34|       |        content: USAGE_CONTENT,
   35|       |    },
   36|       |    SampleFile {
   37|       |        name: "search.md",
   38|       |        title: "Search Tips & Examples",
   39|       |        content: SEARCH_GUIDE_CONTENT,
   40|       |    },
   41|       |    SampleFile {
   42|       |        name: "images.md",
   43|       |        title: "Inline Images & Diagrams",
   44|       |        content: IMAGES_CONTENT,
   45|       |    },
   46|       |];
   47|       |
   48|       |/// Welcome content with basic introduction
   49|       |const WELCOME_CONTENT: &str = r#"# Welcome to MarkdownView
   50|       |
   51|       |A simple, fast markdown viewer for Windows built with Rust and egui.
   52|       |
   53|       |## Features
   54|       |
   55|       |- **Pure Rust Implementation** - Single executable, no dependencies
   56|       |- **Fast Rendering** - Efficient markdown parsing with pulldown-cmark
   57|       |- **Syntax Highlighting** - Code blocks with proper syntax coloring
   58|       |- **Native File Dialogs** - Seamless Windows integration
   59|       |- **Embedded Examples** - Built-in sample files to explore
   60|       |
   61|       |## Quick Start
   62|       |
   63|       |1. **Open a File**: Use `File  Open` or `Ctrl+O` to load a markdown file
   64|       |2. **Browse Samples**: Use `File  Samples` to explore built-in examples
   65|       |3. **Navigate**: Scroll to read through documents
   66|       |
   67|       |Enjoy reading your markdown files with this lightweight, efficient viewer!
   68|       |
   69|       |---
   70|       |
   71|       |*Built with  using Rust, egui, and pulldown-cmark*
   72|       |"#;
   73|       |
   74|       |const FORMATTING_CONTENT: &str = r#"# Markdown Formatting Guide
   75|       |
   76|       |This document demonstrates the various formatting options supported by MarkdownView.
   77|       |
   78|       |## Table of Contents
   79|       |
   80|       |- [Text Formatting](#text-formatting)
   81|       |- [Headers](#headers)
   82|       |- [Lists](#lists)
   83|       |- [Links and Images](#links-and-images)
   84|       |- [Emojis](#emojis)
   85|       |- [Blockquotes](#blockquotes)
   86|       |- [Horizontal Rules](#horizontal-rules)
   87|       |- [Tables](#tables)
   88|       |
   89|       |Quick jump: [Go to Lists](#lists)  [Go to Tables](#tables)
   90|       |
   91|       |## Text Formatting
   92|       |
   93|       |**Bold text** and *italic text* are supported, as well as ***bold italic***.
   94|       |
   95|       |You can also use `inline code` and ~~strikethrough~~ text.
   96|       |
   97|       |## Headers
   98|       |
   99|       |# Header 1
  100|       |## Header 2  
  101|       |### Header 3
  102|       |#### Header 4
  103|       |##### Header 5
  104|       |###### Header 6
  105|       |
  106|       |## Lists
  107|       |
  108|       |### Unordered Lists
  109|       |
  110|       |- First item
  111|       |- Second item
  112|       |  - Nested item
  113|       |  - Another nested item
  114|       |- Third item
  115|       |- Inline code in bullets works: use `--help` or `cargo run`
  116|       |- Styled + emoji in bullets: **:rocket:** launch, *:tada:* celebration, and ~~:fire:~~ warning
  117|       |- Tight list check: this item has :rocket: and `code` without blank lines between items
  118|       |
  119|       |### Ordered Lists
  120|       |
  121|       |1. First item
  122|       |2. Second item
  123|       |   1. Nested numbered item
  124|       |   2. Another nested item
  125|       |3. Third item
  126|       |
  127|       |## Links and Images
  128|       |
  129|       |[Visit Rust's website](https://rust-lang.org)
  130|       |
  131|       |Internal anchors let you jump within this document:
  132|       |- [Jump to Headers](#headers)
  133|       |- [Jump to Tables](#tables)
  134|       |- [Back to top](#markdown-formatting-guide)
  135|       |
  136|       |Links are clickable and will open in your default browser.
  137|       |
  138|       |## Emojis
  139|       |
  140|       |Unicode emojis render as normal text if your font supports them.
  141|       |Examples: Thanks!   Status:   Ship it 
  142|       |
  143|       |Shortcodes like `:rocket:` and `:tada:` are expanded to emoji images in normal text, headers, and list items.
  144|       |
  145|       |## Blockquotes
  146|       |
  147|       |> This is a blockquote.
  148|       |> It can span multiple lines.
  149|       |> 
  150|       |> > Nested blockquotes are also supported.
  151|       |
  152|       |## Horizontal Rules
  153|       |
  154|       |---
  155|       |
  156|       |## Tables
  157|       |
  158|       || Feature | Supported | Notes |
  159|       ||---------|-----------|-------|
  160|       || Headers |  | All levels 1-6 |
  161|       || Lists |  | Ordered and unordered |
  162|       || Code blocks |  | With syntax highlighting |
  163|       || Tables |  | Basic table support |
  164|       || Links |  | Opens in browser; internal anchors scroll indocument |
  165|       |
  166|       |---
  167|       |
  168|       |*This covers most of the formatting features available in MarkdownView.*  
  169|       |[Back to top](#markdown-formatting-guide)
  170|       |"#;
  171|       |
  172|       |/// Code examples with syntax highlighting
  173|       |const SEARCH_GUIDE_CONTENT: &str = concat!(
  174|       |    "# Search Tips & Examples\n\n",
  175|       |    "MarkdownView's search panel is accent-aware and case-insensitive. A single query matches multiple spellings automatically.\n\n",
  176|       |    "## Accent Folding\n\n",
  177|       |    "- Typing `resume` highlights `r\u{00e9}sum\u{00e9}`, `RESUME`, and `re\u{0301}sume` (precomposed vs. combining accent).\n",
  178|       |    "- `istanbul` matches both `\u{0130}stanbul` (Turkish dotted capital I) and `ISTANBUL`.\n",
  179|       |    "- `sao` finds `S\u{00e3}o`, `SAO`, and `Sao` regardless of combining marks.\n",
  180|       |    "- `nino` finds `Ni\u{00f1}o`, `NINO`, and `nin\u{0303}o`.\n\n",
  181|       |    "Try opening this sample, pressing `Ctrl+F`, and searching for the words below:\n\n",
  182|       |    "| Query | Matches in this document |\n",
  183|       |    "|-------|-------------------------|\n",
  184|       |    "| `resume` | r\u{00e9}sum\u{00e9}, RESUME, re\u{0301}sume |\n",
  185|       |    "| `istanbul` | \u{0130}stanbul, ISTANBUL |\n",
  186|       |    "| `sao` | S\u{00e3}o, SAO, Sao |\n",
  187|       |    "| `nino` | Ni\u{00f1}o, NINO, nin\u{0303}o |\n\n",
  188|       |    "> Tip: Use `Enter` / `Shift+Enter` to cycle through matches. The highlight respects grapheme clusters, so emoji and combined characters stay intact.\n\n",
  189|       |);
  190|       |const IMAGES_CONTENT: &str = r#"# Inline Images & Diagrams
  191|       |
  192|       |This sample demonstrates inline images and Mermaid code blocks.
  193|       |
  194|       |## PNG Image
  195|       |
  196|       |Below is a PNG image using an embedded emoji asset.
  197|       |
  198|       |![Smiley PNG](assets/emoji/1f600.png "PNG emoji sample")
  199|       |
  200|       |## SVG Image
  201|       |
  202|       |An SVG logo rendered via resvg/tiny-skia.
  203|       |
  204|       |![SVG Logo](assets/samples/logo.svg "SVG sample logo")
  205|       |
  206|       |## WEBP Image
  207|       |
  208|       |A small WEBP sample is bundled for testing.
  209|       |
  210|       |![WEBP Sample](assets/samples/webp_sample.webp "WEBP sample")
  211|       |
  212|       |## Mermaid Diagram (feature-gated)
  213|       |
  214|       |When the `mermaid-quickjs` feature is enabled, Mermaid code blocks are rendered as diagrams.
  215|       |Otherwise, the source is shown with an informational note.
  216|       |
  217|       |```mermaid
  218|       |graph TD;
  219|       |    A[Start] --> B{Is SVG supported?};
  220|       |    B -- Yes --> C[Rasterize via resvg];
  221|       |    B -- No  --> D[Show placeholder];
  222|       |    C --> E[Display egui texture];
  223|       |    D --> E;
  224|       |```
  225|       |
  226|       |## Notes
  227|       |
  228|       |- The WEBP sample is at `assets/samples/webp_sample.webp`. See `examples/webp_test.md` for a standalone test file.
  229|       |
  230|       |"#;
  231|       |
  232|       |const CODE_CONTENT: &str = r#"# Code Examples
  233|       |
  234|       |MarkdownView supports syntax highlighting for many programming languages.
  235|       |
  236|       |## Rust Code
  237|       |
  238|       |```rust
  239|       |fn main() {
  240|       |    println!("Hello, world!");
  241|       |    
  242|       |    let mut vector = vec![1, 2, 3, 4, 5];
  243|       |    vector.iter()
  244|       |        .filter(|&x| x % 2 == 0)
  245|       |        .for_each(|x| println!("Even number: {}", x));
  246|       |}
  247|       |
  248|       |// Struct definition with lifetimes
  249|       |struct Config<'a> {
  250|       |    name: &'a str,
  251|       |    version: u32,
  252|       |}
  253|       |
  254|       |impl<'a> Config<'a> {
  255|       |    fn new(name: &'a str) -> Self {
  256|       |        Config { name, version: 1 }
  257|       |    }
  258|       |}
  259|       |```
  260|       |
  261|       |## Python Code
  262|       |
  263|       |```python
  264|       |def fibonacci(n):
  265|       |    """Generate fibonacci sequence up to n"""
  266|       |    if n <= 0:
  267|       |        return []
  268|       |    elif n == 1:
  269|       |        return [0]
  270|       |    
  271|       |    sequence = [0, 1]
  272|       |    while len(sequence) < n:
  273|       |        sequence.append(sequence[-1] + sequence[-2])
  274|       |    
  275|       |    return sequence
  276|       |
  277|       |# List comprehension example
  278|       |squares = [x**2 for x in range(10) if x % 2 == 0]
  279|       |print(f"Even squares: {squares}")
  280|       |```
  281|       |
  282|       |## JavaScript Code
  283|       |
  284|       |```javascript
  285|       |// Modern JavaScript with async/await
  286|       |async function fetchUserData(userId) {
  287|       |    try {
  288|       |        const response = await fetch(`/api/users/${userId}`);
  289|       |        const userData = await response.json();
  290|       |        
  291|       |        return {
  292|       |            ...userData,
  293|       |            lastUpdated: new Date().toISOString()
  294|       |        };
  295|       |    } catch (error) {
  296|       |        console.error('Failed to fetch user data:', error);
  297|       |        throw error;
  298|       |    }
  299|       |}
  300|       |
  301|       |// Arrow functions and destructuring
  302|       |const processData = ({ name, age, email }) => ({
  303|       |    displayName: name.toUpperCase(),
  304|       |    isAdult: age >= 18,
  305|       |    emailDomain: email.split('@')[1]
  306|       |});
  307|       |```
  308|       |
  309|       |## SQL Code
  310|       |
  311|       |```sql
  312|       |-- Complex query with joins and aggregation
  313|       |SELECT 
  314|       |    u.username,
  315|       |    u.email,
  316|       |    COUNT(o.id) as total_orders,
  317|       |    SUM(oi.price * oi.quantity) as total_spent
  318|       |FROM users u
  319|       |LEFT JOIN orders o ON u.id = o.user_id
  320|       |LEFT JOIN order_items oi ON o.id = oi.order_id
  321|       |WHERE u.created_at >= '2023-01-01'
  322|       |GROUP BY u.id, u.username, u.email
  323|       |HAVING COUNT(o.id) > 5
  324|       |ORDER BY total_spent DESC
  325|       |LIMIT 20;
  326|       |```
  327|       |
  328|       |## Inline Code
  329|       |
  330|       |You can also use `inline code` within paragraphs, like `let x = 42;` or `print("hello")`.
  331|       |
  332|       |---
  333|       |
  334|       |*Syntax highlighting is powered by the syntect library, supporting dozens of languages.*
  335|       |"#;
  336|       |
  337|       |/// Usage instructions and tips
  338|       |const USAGE_CONTENT: &str = r#"# Usage Instructions
  339|       |
  340|       |## Opening Files
  341|       |
  342|       |### File Menu
  343|       |- Use `File  Open` from the menu bar
  344|       |- Keyboard shortcut: `Ctrl+O`
  345|       |- Select any `.md` or `.markdown` file from your system
  346|       |
  347|       |### Drag and Drop
  348|       |- Drag markdown files directly into the application window
  349|       |- Multiple files can be opened in sequence
  350|       |
  351|       |## Viewing Sample Files
  352|       |
  353|       |### Built-in Examples
  354|       |- Use `File  Samples` to browse embedded examples
  355|       |- These files demonstrate various markdown features
  356|       |- Perfect for testing and learning
  357|       |
  358|       |### Sample File List
  359|       |- **welcome.md** - Introduction and overview
  360|       |- **formatting.md** - Text formatting examples  
  361|       |- **code.md** - Syntax highlighting examples
  362|       |- **usage.md** - This usage guide
  363|       |
  364|       |## Navigation
  365|       |
  366|       |### Scrolling
  367|       |- Use mouse wheel or trackpad to scroll
  368|       |- Keyboard arrows for line-by-line navigation
  369|       |- Page Up/Page Down for faster scrolling
  370|       |
  371|       |### Window Controls
  372|       |- Resize the window as needed
  373|       |- Content automatically reflows
  374|       |- Minimum window size is enforced
  375|       |
  376|       |## Keyboard Shortcuts
  377|       |
  378|       || Shortcut | Action |
  379|       ||----------|--------|
  380|       || `Ctrl+O` | Open file |
  381|       || `Ctrl+W` | Close current file |
  382|       || `F5` | Reload current file |
  383|       || `Ctrl+Q` | Quit application |
  384|       || `F11` | Toggle fullscreen |
  385|       || `Ctrl++` | Zoom in (increase font size) |
  386|       || `Ctrl+-` | Zoom out (decrease font size) |
  387|       || `Ctrl` + Mouse Wheel | Zoom in/out |
  388|       || `Ctrl+0` | Reset zoom to default size |
  389|       || `Home` | Go to top of document |
  390|       || `End` | Go to bottom of document |
  391|       || `Page Up` | Scroll up one page |
  392|       || `Page Down` | Scroll down one page |
  393|       |
  394|       |## File Associations
  395|       |
  396|       |### Windows Integration
  397|       |To make MarkdownView the default for `.md` files:
  398|       |
  399|       |1. Right-click any `.md` file
  400|       |2. Select "Open with  Choose another app"
  401|       |3. Browse to the MarkdownView executable
  402|       |4. Check "Always use this app"
  403|       |
  404|       |### Supported Extensions
  405|       |- `.md` - Standard markdown files
  406|       |- `.markdown` - Alternative markdown extension
  407|       |- `.mdown` - Another common variation
  408|       |- `.mkd` - Short markdown extension
  409|       |
  410|       |## Performance
  411|       |
  412|       |### Large Files
  413|       |- Files up to several MB render efficiently
  414|       |- Very large files (>10MB) may take a moment to parse
  415|       |- Consider breaking up extremely large documents
  416|       |
  417|       |### Memory Usage
  418|       |- Minimal memory footprint
  419|       |- Parsed content is cached for fast scrolling
  420|       |- No memory leaks during normal operation
  421|       |
  422|       |## Troubleshooting
  423|       |
  424|       |### Common Issues
  425|       |
  426|       |**File won't open**
  427|       |- Check file extension is `.md` or `.markdown`
  428|       |- Ensure file isn't locked by another application
  429|       |- Verify file contains valid UTF-8 text
  430|       |
  431|       |**Display issues**
  432|       |- Try resizing the window
  433|       |- Restart the application
  434|       |- Check if file contains very long lines
  435|       |
  436|       |**Performance problems**
  437|       |- Close and reopen large files
  438|       |- Ensure adequate system memory
  439|       |- Consider breaking up large documents
  440|       |
  441|       |### Getting Help
  442|       |
  443|       |For bugs or feature requests:
  444|       |1. Check the application works with sample files
  445|       |2. Try reproducing with a minimal markdown file
  446|       |3. Note your Windows version and system specs
  447|       |
  448|       |---
  449|       |
  450|       |*Thank you for using MarkdownView! We hope it serves your markdown reading needs well.*
  451|       |"#;
  452|       |
  453|       |#[cfg(test)]
  454|       |mod tests {
  455|       |    use super::*;
  456|       |
  457|       |    #[test]
  458|      1|    fn test_sample_files_exist() {
  459|      1|        assert_eq!(SAMPLE_FILES.len(), 6);
  460|       |
  461|      1|        let names: Vec<&str> = SAMPLE_FILES.iter().map(|f| f.name).collect();
  462|      1|        assert!(names.contains(&"welcome.md"));
  463|      1|        assert!(names.contains(&"formatting.md"));
  464|      1|        assert!(names.contains(&"code.md"));
  465|      1|        assert!(names.contains(&"usage.md"));
  466|      1|        assert!(names.contains(&"search.md"));
  467|      1|        assert!(names.contains(&"images.md"));
  468|      1|    }
  469|       |
  470|       |    #[test]
  471|      1|    fn test_sample_files_content_not_empty() {
  472|      7|        for file in SAMPLE_FILES {
                          ^6
  473|      6|            assert!(!file.content.is_empty(), "File {} has empty content", file.name);
                                                            ^0
  474|      6|            assert!(!file.title.is_empty(), "File {} has empty title", file.name);
                                                          ^0
  475|      6|            assert!(!file.name.is_empty(), "File has empty name");
                                                         ^0
  476|       |        }
  477|      1|    }
  478|       |
  479|       |    #[test]
  480|      1|    fn test_sample_files_are_valid_markdown() {
  481|       |        use pulldown_cmark::{Options, Parser};
  482|       |
  483|      7|        for file in SAMPLE_FILES {
                          ^6
  484|      6|            let parser = Parser::new_ext(file.content, Options::all());
  485|      6|            let events: Vec<_> = parser.collect();
  486|      6|            assert!(!events.is_empty(), "File {} produces no markdown events", file.name);
                                                      ^0
  487|       |        }
  488|      1|    }
  489|       |
  490|       |    #[test]
  491|      1|    fn test_welcome_content_structure() {
  492|      1|        assert!(WELCOME_CONTENT.contains("# Welcome"));
  493|      1|        assert!(WELCOME_CONTENT.contains("## Features"));
  494|      1|        assert!(WELCOME_CONTENT.contains("## Quick Start"));
  495|      1|    }
  496|       |
  497|       |    #[test]
  498|      1|    fn test_formatting_content_examples() {
  499|      1|        assert!(FORMATTING_CONTENT.contains("**Bold text**"));
  500|      1|        assert!(FORMATTING_CONTENT.contains("*italic text*"));
  501|      1|        assert!(FORMATTING_CONTENT.contains("`inline code`"));
  502|      1|        assert!(FORMATTING_CONTENT.contains("| Feature | Supported |"));
  503|      1|    }
  504|       |
  505|       |    #[test]
  506|      1|    fn test_code_content_languages() {
  507|      1|        assert!(CODE_CONTENT.contains("```rust"));
  508|      1|        assert!(CODE_CONTENT.contains("```python"));
  509|      1|        assert!(CODE_CONTENT.contains("```javascript"));
  510|      1|        assert!(CODE_CONTENT.contains("```sql"));
  511|      1|    }
  512|       |
  513|       |    #[test]
  514|      1|    fn test_usage_content_sections() {
  515|      1|        assert!(USAGE_CONTENT.contains("## Opening Files"));
  516|      1|        assert!(USAGE_CONTENT.contains("## Keyboard Shortcuts"));
  517|      1|        assert!(USAGE_CONTENT.contains("## Troubleshooting"));
  518|      1|    }
  519|       |
  520|       |    #[test]
  521|      1|    fn test_search_guide_examples_present() {
  522|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("rsum"));
  523|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("stanbul"));
  524|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("So"));
  525|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("Nio"));
  526|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("Ctrl+F"));
  527|      1|    }
  528|       |}

C:\language\mdmdview\src\table_support\column_spec.rs:
    1|       |use std::cmp::max;
    2|       |use std::hash::{Hash, Hasher};
    3|       |
    4|       |use egui_extras::Column;
    5|       |use unicode_segmentation::UnicodeSegmentation;
    6|       |use unicode_width::UnicodeWidthStr;
    7|       |
    8|       |use crate::markdown_renderer::InlineSpan;
    9|       |
   10|       |const MAX_REMAINDER_COLUMNS: usize = 2;
   11|       |
   12|     21|fn normalize_body_font_px(body: f32) -> f32 {
   13|     21|    if body.is_finite() && body > 4.0 {
   14|     21|        body
   15|       |    } else {
   16|      0|        14.0
   17|       |    }
   18|     21|}
   19|       |
   20|     21|fn px(body_px: f32, factor: f32) -> f32 {
   21|     21|    normalize_body_font_px(body_px) * factor
   22|     21|}
   23|       |
   24|       |#[derive(Debug, Clone, PartialEq)]
   25|       |pub enum ColumnPolicy {
   26|       |    Auto,
   27|       |    Fixed {
   28|       |        width: f32,
   29|       |        clip: bool,
   30|       |    },
   31|       |    Remainder {
   32|       |        clip: bool,
   33|       |    },
   34|       |    Resizable {
   35|       |        min: f32,
   36|       |        preferred: f32,
   37|       |        clip: bool,
   38|       |    },
   39|       |}
   40|       |
   41|       |impl ColumnPolicy {
   42|      4|    pub fn to_column(&self) -> Column {
   43|      4|        match self {
   44|      0|            ColumnPolicy::Auto => Column::auto(),
   45|      2|            ColumnPolicy::Fixed { width, clip } => {
   46|      2|                let mut col = Column::exact(*width);
   47|      2|                if *clip {
   48|      2|                    col = col.clip(true);
   49|      2|                }
                              ^0
   50|      2|                col
   51|       |            }
   52|      2|            ColumnPolicy::Remainder { clip } => {
   53|      2|                let mut col = Column::remainder();
   54|      2|                if *clip {
   55|      0|                    col = col.clip(true);
   56|      2|                }
   57|      2|                col
   58|       |            }
   59|       |            ColumnPolicy::Resizable {
   60|      0|                min,
   61|      0|                preferred,
   62|      0|                clip,
   63|       |            } => {
   64|      0|                let mut col = Column::initial(*preferred).at_least(*min).resizable(true);
   65|      0|                if *clip {
   66|      0|                    col = col.clip(true);
   67|      0|                }
   68|      0|                col
   69|       |            }
   70|       |        }
   71|      4|    }
   72|       |}
   73|       |
   74|       |impl Hash for ColumnPolicy {
   75|     23|    fn hash<H: Hasher>(&self, state: &mut H) {
   76|     23|        std::mem::discriminant(self).hash(state);
   77|     23|        match self {
   78|      0|            ColumnPolicy::Auto => {}
   79|      5|            ColumnPolicy::Fixed { width, clip } => {
   80|      5|                width.to_bits().hash(state);
   81|      5|                clip.hash(state);
   82|      5|            }
   83|      9|            ColumnPolicy::Remainder { clip } => {
   84|      9|                clip.hash(state);
   85|      9|            }
   86|       |            ColumnPolicy::Resizable {
   87|      9|                min,
   88|      9|                preferred,
   89|      9|                clip,
   90|      9|            } => {
   91|      9|                min.to_bits().hash(state);
   92|      9|                preferred.to_bits().hash(state);
   93|      9|                clip.hash(state);
   94|      9|            }
   95|       |        }
   96|     23|    }
   97|       |}
   98|       |
   99|       |#[derive(Debug, Clone)]
  100|       |pub struct ColumnSpec {
  101|       |    pub ident: String,
  102|       |    pub policy: ColumnPolicy,
  103|       |    pub tooltip: Option<String>,
  104|       |    pub policy_hash: u64,
  105|       |}
  106|       |
  107|       |impl ColumnSpec {
  108|     20|    pub fn new(ident: impl Into<String>, policy: ColumnPolicy, tooltip: Option<String>) -> Self {
  109|     20|        let ident = ident.into();
  110|     20|        let policy_hash = calculate_policy_hash(&ident, &policy);
  111|     20|        Self {
  112|     20|            ident,
  113|     20|            policy,
  114|     20|            tooltip,
  115|     20|            policy_hash,
  116|     20|        }
  117|     20|    }
  118|       |
  119|      4|    pub fn as_column(&self) -> Column {
  120|      4|        self.policy.to_column()
  121|      4|    }
  122|       |
  123|      3|    pub fn set_policy(&mut self, policy: ColumnPolicy) {
  124|      3|        self.policy = policy;
  125|      3|        self.policy_hash = calculate_policy_hash(&self.ident, &self.policy);
  126|      3|    }
  127|       |
  128|      0|    pub fn apply_preferred_width(&mut self, width: f32) {
  129|       |        if let ColumnPolicy::Resizable {
  130|      0|            min,
  131|      0|            ref mut preferred,
  132|       |            ..
  133|      0|        } = self.policy
  134|      0|        {
  135|      0|            let clamped = width.max(min);
  136|      0|            *preferred = clamped;
  137|      0|            self.policy_hash = calculate_policy_hash(&self.ident, &self.policy);
  138|      0|        }
  139|      0|    }
  140|       |}
  141|       |
  142|       |#[derive(Debug, Clone, Copy, Default)]
  143|       |pub struct RichContentFlags {
  144|       |    pub has_link: bool,
  145|       |    pub has_image: bool,
  146|       |    pub has_emoji_like: bool,
  147|       |}
  148|       |
  149|       |#[derive(Debug, Clone, Default)]
  150|       |pub struct ColumnStat {
  151|       |    pub max_graphemes: usize,
  152|       |    pub longest_word: usize,
  153|       |    pub rich_content: RichContentFlags,
  154|       |}
  155|       |
  156|       |pub struct TableColumnContext<'a> {
  157|       |    pub headers: &'a [Vec<InlineSpan>],
  158|       |    pub rows: &'a [Vec<Vec<InlineSpan>>],
  159|       |    pub stats: &'a [ColumnStat],
  160|       |    pub body_font_px: f32,
  161|       |    pub table_id: u64,
  162|       |}
  163|       |
  164|       |impl<'a> TableColumnContext<'a> {
  165|      8|    pub fn new(
  166|      8|        headers: &'a [Vec<InlineSpan>],
  167|      8|        rows: &'a [Vec<Vec<InlineSpan>>],
  168|      8|        stats: &'a [ColumnStat],
  169|      8|        body_font_px: f32,
  170|      8|        table_id: u64,
  171|      8|    ) -> Self {
  172|      8|        Self {
  173|      8|            headers,
  174|      8|            rows,
  175|      8|            stats,
  176|      8|            body_font_px,
  177|      8|            table_id,
  178|      8|        }
  179|      8|    }
  180|       |
  181|     24|    pub fn column_stat(&self, idx: usize) -> Option<&ColumnStat> {
  182|     24|        self.stats.get(idx)
  183|     24|    }
  184|       |}
  185|       |
  186|     23|fn calculate_policy_hash(ident: &str, policy: &ColumnPolicy) -> u64 {
  187|     23|    let mut hasher = std::collections::hash_map::DefaultHasher::new();
  188|     23|    ident.hash(&mut hasher);
  189|     23|    policy.hash(&mut hasher);
  190|     23|    hasher.finish()
  191|     23|}
  192|       |
  193|      8|pub fn derive_column_specs(ctx: &TableColumnContext) -> Vec<ColumnSpec> {
  194|      8|    let mut remainder_assigned = 0usize;
  195|      8|    let mut fallback_idx: Option<usize> = None;
  196|      8|    let mut fallback_score: usize = 0;
  197|      8|    let column_count = ctx
  198|      8|        .stats
  199|      8|        .len()
  200|      8|        .max(ctx.headers.len())
  201|      8|        .max(ctx.rows.iter().map(|r| r.len()).max().unwrap_or(0));
                                                   ^5^5
  202|       |
  203|      8|    let mut scored_indices: Vec<(usize, usize)> = Vec::with_capacity(column_count);
  204|       |
  205|      8|    let mut specs: Vec<ColumnSpec> = (0..column_count)
  206|     19|        .map(|idx| {
                       ^8
  207|     19|            let spans = ctx.headers.get(idx).map(|v| v.as_slice()).unwrap_or(&[]);
  208|     19|            let label = header_text(spans);
  209|     19|            let stat = ctx.column_stat(idx);
  210|       |
  211|     19|            let candidate_score = stat
  212|     19|                .map(|s| {
  213|     19|                    let mut score = s.max_graphemes + s.longest_word * 2;
  214|     19|                    if s.rich_content.has_image {
  215|      0|                        score += 50;
  216|     19|                    }
  217|     19|                    if s.rich_content.has_link {
  218|      1|                        score += 25;
  219|     18|                    }
  220|     19|                    score
  221|     19|                })
  222|     19|                .unwrap_or_else(|| label.len());
                                                 ^0    ^0
  223|     19|            if candidate_score > fallback_score {
  224|     15|                fallback_score = candidate_score;
  225|     15|                fallback_idx = Some(idx);
  226|     15|            }
                          ^4
  227|     19|            scored_indices.push((idx, candidate_score));
  228|       |
  229|     19|            let policy =
  230|     19|                classify_column(&label, idx, &mut remainder_assigned, stat, ctx.body_font_px);
  231|     19|            let tooltip = column_tooltip(&label, &policy);
  232|     19|            ColumnSpec::new(label, policy, tooltip)
  233|     19|        })
  234|      8|        .collect();
  235|       |
  236|       |    // Ensure at least one remainder if none assigned and available
  237|      8|    if remainder_assigned == 0 {
  238|      2|        let mut candidate = fallback_idx;
  239|      2|        if let Some(idx) = candidate {
  240|      2|            if matches!(specs[idx].policy, ColumnPolicy::Fixed { .. }) {
                             ^0
  241|      2|                candidate = None;
  242|      2|            }
                          ^0
  243|      0|        }
  244|      2|        if candidate.is_none() {
  245|      2|            candidate = specs
  246|      2|                .iter()
  247|      2|                .enumerate()
  248|      4|                .find(|(_, spec)| !matches!(spec.policy, ColumnPolicy::Fixed { .. }))
                               ^2                ^2
  249|      2|                .map(|(idx, _)| idx);
  250|      0|        }
  251|      2|        if let Some(idx) = candidate {
  252|      2|            if let Some(spec) = specs.get_mut(idx) {
  253|      2|                spec.set_policy(ColumnPolicy::Remainder { clip: false });
  254|      2|                remainder_assigned += 1;
  255|      2|            }
                          ^0
  256|      0|        }
  257|      6|    }
  258|       |
  259|       |    // Promote additional wide columns to remainder up to the cap
  260|     15|    scored_indices.sort_by(|a, b| b.1.cmp(&a.1));
                  ^8             ^8
  261|     26|    for (idx, _) in scored_indices {
                       ^19
  262|     19|        if remainder_assigned >= MAX_REMAINDER_COLUMNS {
  263|      1|            break;
  264|     18|        }
  265|     18|        if let Some(spec) = specs.get_mut(idx) {
  266|     18|            if matches!(spec.policy, ColumnPolicy::Resizable { .. })
                             ^13
  267|      5|                && column_needs_remainder(ctx.column_stat(idx))
  268|      1|            {
  269|      1|                spec.set_policy(ColumnPolicy::Remainder { clip: false });
  270|      1|                remainder_assigned += 1;
  271|     17|            }
  272|      0|        }
  273|       |    }
  274|       |
  275|      8|    specs
  276|      8|}
  277|       |
  278|     20|fn header_text(spans: &[InlineSpan]) -> String {
  279|     20|    let mut text = String::new();
  280|     40|    for span in spans {
                      ^20
  281|     20|        match span {
  282|     20|            InlineSpan::Text(t)
  283|      0|            | InlineSpan::Strong(t)
  284|      0|            | InlineSpan::Emphasis(t)
  285|      0|            | InlineSpan::Strikethrough(t)
  286|      0|            | InlineSpan::Code(t) => {
  287|     20|                if !text.is_empty() {
  288|      0|                    text.push(' ');
  289|     20|                }
  290|     20|                text.push_str(t.trim());
  291|       |            }
  292|      0|            InlineSpan::Link { text: t, .. } => {
  293|      0|                if !text.is_empty() {
  294|      0|                    text.push(' ');
  295|      0|                }
  296|      0|                text.push_str(t.trim());
  297|       |            }
  298|      0|            InlineSpan::Image { alt, .. } => {
  299|      0|                if !text.is_empty() {
  300|      0|                    text.push(' ');
  301|      0|                }
  302|      0|                text.push_str(alt.trim());
  303|       |            }
  304|       |        }
  305|       |    }
  306|     20|    if text.trim().is_empty() {
  307|      0|        "Column".to_string()
  308|       |    } else {
  309|     20|        text.trim().to_string()
  310|       |    }
  311|     20|}
  312|       |
  313|     19|fn classify_column(
  314|     19|    label: &str,
  315|     19|    index: usize,
  316|     19|    remainder_assigned: &mut usize,
  317|     19|    stat: Option<&ColumnStat>,
  318|     19|    body_font_px: f32,
  319|     19|) -> ColumnPolicy {
  320|     19|    let lower = label.to_ascii_lowercase();
  321|     19|    if matches_any(&lower, &["version", "rev", "#", "id"]) {
  322|      1|        return ColumnPolicy::Fixed {
  323|      1|            width: px(body_font_px, 5.8).clamp(80.0, 160.0),
  324|      1|            clip: true,
  325|      1|        };
  326|     18|    }
  327|     18|    if matches_any(&lower, &["date", "time", "timestamp"]) {
  328|      0|        return ColumnPolicy::Fixed {
  329|      0|            width: px(body_font_px, 8.5).clamp(110.0, 200.0),
  330|      0|            clip: false,
  331|      0|        };
  332|     18|    }
  333|     18|    if matches_any(&lower, &["author", "owner", "assignee", "user"]) {
  334|      1|        return ColumnPolicy::Resizable {
  335|      1|            min: px(body_font_px, 7.5),
  336|      1|            preferred: px(body_font_px, 10.0),
  337|      1|            clip: false,
  338|      1|        };
  339|     17|    }
  340|     17|    if matches_any(&lower, &["status", "state"]) {
  341|      0|        return ColumnPolicy::Fixed {
  342|      0|            width: px(body_font_px, 7.0).clamp(90.0, 180.0),
  343|      0|            clip: true,
  344|      0|        };
  345|     17|    }
  346|     17|    if matches_any(
  347|     17|        &lower,
  348|     17|        &["notes", "changes", "description", "details", "summary"],
  349|       |    ) {
  350|      5|        return ColumnPolicy::Resizable {
  351|      5|            min: px(body_font_px, 10.5),
  352|      5|            preferred: px(body_font_px, 14.5),
  353|      5|            clip: false,
  354|      5|        };
  355|     12|    }
  356|     12|    if matches_any(
  357|     12|        &lower,
  358|     12|        &["example", "examples", "sample", "use case", "use cases"],
  359|       |    ) {
  360|      4|        *remainder_assigned += 1;
  361|      4|        return ColumnPolicy::Remainder { clip: false };
  362|      8|    }
  363|      8|    if index == 0 {
  364|       |        // First column typically identifiers; keep fixed only for short labels.
  365|      4|        if stat
  366|      4|            .map(|s| s.max_graphemes <= 18 && s.longest_word <= 12)
  367|      4|            .unwrap_or_else(|| label.len() <= 12)
                                             ^0    ^0
  368|       |        {
  369|      4|            return ColumnPolicy::Fixed {
  370|      4|                width: px(body_font_px, 7.0).clamp(80.0, 180.0),
  371|      4|                clip: true,
  372|      4|            };
  373|      0|        }
  374|      4|    }
  375|      4|    if *remainder_assigned < MAX_REMAINDER_COLUMNS && column_needs_remainder(stat) {
  376|      2|        *remainder_assigned += 1;
  377|      2|        return ColumnPolicy::Remainder { clip: false };
  378|      2|    }
  379|      2|    ColumnPolicy::Resizable {
  380|      2|        min: px(body_font_px, 7.0),
  381|      2|        preferred: px(body_font_px, 9.5),
  382|      2|        clip: false,
  383|      2|    }
  384|     19|}
  385|       |
  386|      9|fn column_needs_remainder(stat: Option<&ColumnStat>) -> bool {
  387|      9|    if let Some(stat) = stat {
  388|      9|        stat.rich_content.has_image
  389|      9|            || stat.longest_word > 18
  390|      9|            || stat.max_graphemes > 60
  391|      7|            || stat.rich_content.has_link
  392|       |    } else {
  393|      0|        false
  394|       |    }
  395|      9|}
  396|       |
  397|    101|fn matches_any(label: &str, needles: &[&str]) -> bool {
  398|    351|    needles.iter().any(|needle| label.contains(needle))
                  ^101           ^101
  399|    101|}
  400|       |
  401|     19|fn column_tooltip(label: &str, policy: &ColumnPolicy) -> Option<String> {
  402|     19|    let description = match policy {
  403|      0|        ColumnPolicy::Auto => "Auto-sized column".to_string(),
  404|      5|        ColumnPolicy::Fixed { width, clip } => format!(
  405|      5|            "Fixed width {:.0}px{}",
  406|       |            width,
  407|      5|            if *clip { " (clipped)" } else { "" }
                                                           ^0
  408|       |        ),
  409|      6|        ColumnPolicy::Remainder { clip } => format!(
  410|      6|            "Shared remainder width{}",
  411|      6|            if *clip { " (clipped)" } else { "" }
                                     ^0
  412|       |        ),
  413|       |        ColumnPolicy::Resizable {
  414|      8|            min,
  415|      8|            preferred,
  416|      8|            clip,
  417|      8|        } => format!(
  418|      8|            "Resizable (min {:.0}px, start {:.0}px{})",
  419|       |            min,
  420|       |            preferred,
  421|      8|            if *clip { ", clipped" } else { "" }
                                     ^0
  422|       |        ),
  423|       |    };
  424|     19|    Some(format!("{label}: {description}"))
  425|     19|}
  426|       |
  427|     10|pub fn compute_column_stats(
  428|     10|    headers: &[Vec<InlineSpan>],
  429|     10|    rows: &[Vec<Vec<InlineSpan>>],
  430|     10|    max_samples: usize,
  431|     10|) -> Vec<ColumnStat> {
  432|     10|    let column_count = max(
  433|     10|        headers.len(),
  434|     10|        rows.iter().map(|row| row.len()).max().unwrap_or(0),
                                            ^7  ^7
  435|       |    );
  436|     10|    if column_count == 0 {
  437|      0|        return Vec::new();
  438|     10|    }
  439|       |
  440|     10|    let mut stats = vec![ColumnStat::default(); column_count];
  441|       |
  442|     22|    for (idx, header) in headers.iter().enumerate() {
                                       ^10     ^10    ^10
  443|     22|        accumulate_stats_for_cell(header, &mut stats[idx]);
  444|     22|    }
  445|       |
  446|     10|    let mut sampled_rows = 0;
  447|     10|    for row in rows.iter() {
                      ^7
  448|     14|        for (idx, cell) in row.iter().enumerate().take(column_count) {
                                         ^7         ^7          ^7   ^7
  449|     14|            accumulate_stats_for_cell(cell, &mut stats[idx]);
  450|     14|        }
  451|      7|        sampled_rows += 1;
  452|      7|        if sampled_rows >= max_samples {
  453|      0|            break;
  454|      7|        }
  455|       |    }
  456|       |
  457|     10|    stats
  458|     10|}
  459|       |
  460|     36|fn accumulate_stats_for_cell(spans: &[InlineSpan], stat: &mut ColumnStat) {
  461|     36|    if stat.rich_content.has_image {
  462|      0|        // rich-content flags persist; skip repeated scans for pure images.
  463|     36|    }
  464|     36|    let mut has_link = stat.rich_content.has_link;
  465|     36|    let mut has_image = stat.rich_content.has_image;
  466|     36|    let mut has_emoji_like = stat.rich_content.has_emoji_like;
  467|       |
  468|     72|    for span in spans {
                      ^36
  469|     36|        match span {
  470|      1|            InlineSpan::Link { .. } => has_link = true,
  471|      0|            InlineSpan::Image { .. } => has_image = true,
  472|     35|            _ => {}
  473|       |        }
  474|       |    }
  475|       |
  476|     36|    let text = spans_to_text(spans);
  477|     36|    if !text.is_empty() {
  478|     36|        let graphemes = text.graphemes(true).count();
  479|     36|        let display_width = UnicodeWidthStr::width(text.as_str());
  480|     36|        stat.max_graphemes = stat.max_graphemes.max(display_width.max(graphemes));
  481|       |
  482|     72|        for word in text.split_whitespace() {
                                  ^36  ^36
  483|     72|            let word_len = UnicodeWidthStr::width(word).max(word.graphemes(true).count());
  484|     72|            stat.longest_word = stat.longest_word.max(word_len);
  485|     72|        }
  486|       |
  487|     36|        if !has_emoji_like {
  488|    404|            has_emoji_like = text.chars().any(|c| matches!(c as u32, 0x1F300..=0x1FAFF));
                                           ^36          ^36                        ^1
  489|      0|        }
  490|      0|    }
  491|       |
  492|     36|    stat.rich_content = RichContentFlags {
  493|     36|        has_link,
  494|     36|        has_image,
  495|     36|        has_emoji_like,
  496|     36|    };
  497|     36|}
  498|       |
  499|     36|fn spans_to_text(spans: &[InlineSpan]) -> String {
  500|     36|    let mut text = String::new();
  501|     72|    for span in spans {
                      ^36
  502|     36|        match span {
  503|     35|            InlineSpan::Text(t)
  504|      0|            | InlineSpan::Code(t)
  505|      0|            | InlineSpan::Strong(t)
  506|      0|            | InlineSpan::Emphasis(t)
  507|      0|            | InlineSpan::Strikethrough(t) => {
  508|     35|                if !text.is_empty() {
  509|      0|                    text.push(' ');
  510|     35|                }
  511|     35|                text.push_str(t);
  512|       |            }
  513|      1|            InlineSpan::Link { text: t, .. } => {
  514|      1|                if !text.is_empty() {
  515|      0|                    text.push(' ');
  516|      1|                }
  517|      1|                text.push_str(t);
  518|       |            }
  519|      0|            InlineSpan::Image { alt, .. } => {
  520|      0|                if !text.is_empty() {
  521|      0|                    text.push(' ');
  522|      0|                }
  523|      0|                text.push_str(alt);
  524|       |            }
  525|       |        }
  526|       |    }
  527|     36|    text.trim().to_string()
  528|     36|}
  529|       |
  530|       |#[cfg(test)]
  531|       |mod tests {
  532|       |    use super::*;
  533|       |
  534|     26|    fn span(text: &str) -> InlineSpan {
  535|     26|        InlineSpan::Text(text.to_string())
  536|     26|    }
  537|       |
  538|       |    #[test]
  539|      1|    fn classify_version_column() {
  540|      1|        let headers = vec![vec![span("Version")], vec![span("Changes")]];
  541|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  542|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  543|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  544|      1|        let specs = derive_column_specs(&ctx);
  545|      1|        assert!(
  546|      1|            matches!(specs[0].policy, ColumnPolicy::Fixed { .. }),
                          ^0
  547|      0|            "policy = {:?}",
  548|      0|            specs[0].policy
  549|       |        );
  550|      1|        assert!(
  551|      1|            matches!(specs[1].policy, ColumnPolicy::Remainder { .. }),
                          ^0
  552|      0|            "policy = {:?}",
  553|      0|            specs[1].policy
  554|       |        );
  555|      1|    }
  556|       |
  557|       |    #[test]
  558|      1|    fn classify_author_column() {
  559|      1|        let headers = vec![vec![span("Author")], vec![span("Examples")]];
  560|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  561|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  562|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  563|      1|        let specs = derive_column_specs(&ctx);
  564|      1|        assert!(
  565|      1|            matches!(specs[0].policy, ColumnPolicy::Resizable { .. }),
                          ^0
  566|      0|            "policy = {:?}",
  567|      0|            specs[0].policy
  568|       |        );
  569|      1|        assert!(
  570|      1|            matches!(specs[1].policy, ColumnPolicy::Remainder { .. }),
                          ^0
  571|      0|            "policy = {:?}",
  572|      0|            specs[1].policy
  573|       |        );
  574|      1|    }
  575|       |
  576|       |    #[test]
  577|      1|    fn classify_examples_column() {
  578|      1|        let headers = vec![
  579|      1|            vec![span("Element")],
  580|      1|            vec![span("Symbol")],
  581|      1|            vec![span("Description")],
  582|      1|            vec![span("Examples")],
  583|       |        ];
  584|      1|        assert_eq!(header_text(&headers[3]), "Examples");
  585|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  586|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  587|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  588|      1|        let specs = derive_column_specs(&ctx);
  589|      1|        assert!(
  590|      1|            matches!(specs[3].policy, ColumnPolicy::Remainder { .. }),
                          ^0
  591|      0|            "policy = {:?}",
  592|      0|            specs[3].policy
  593|       |        );
  594|      1|        assert!(
  595|      1|            matches!(specs[2].policy, ColumnPolicy::Resizable { .. }),
                          ^0
  596|      0|            "policy = {:?}",
  597|      0|            specs[2].policy
  598|       |        );
  599|      1|    }
  600|       |
  601|       |    #[test]
  602|      1|    fn compute_stats_counts_text() {
  603|      1|        let headers = vec![vec![span("Head")]];
  604|      1|        let rows = vec![vec![vec![span("Emoji  test")]]];
  605|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  606|      1|        assert_eq!(stats.len(), 1);
  607|      1|        assert!(stats[0].max_graphemes >= 4);
  608|      1|        assert!(stats[0].longest_word >= 5);
  609|      1|        assert!(stats[0].rich_content.has_emoji_like);
  610|      1|    }
  611|       |
  612|       |    #[test]
  613|      1|    fn fallback_assigns_remainder_based_on_stats() {
  614|      1|        let headers = vec![vec![span("Foo")], vec![span("Bar")]];
  615|      1|        let rows = vec![vec![
  616|      1|            vec![span("Short")],
  617|      1|            vec![span(
  618|      1|                "This column contains a very long sentence that should force remainder selection.",
  619|       |            )],
  620|       |        ]];
  621|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  622|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  623|      1|        let specs = derive_column_specs(&ctx);
  624|      1|        assert!(matches!(specs[1].policy, ColumnPolicy::Remainder { .. }));
                              ^0
  625|      1|    }
  626|       |
  627|       |    #[test]
  628|      1|    fn examples_header_prefers_remainder() {
  629|      1|        let headers = vec![vec![span("Examples")], vec![span("Description")]];
  630|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  631|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  632|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 16.0, 0);
  633|      1|        let specs = derive_column_specs(&ctx);
  634|      1|        assert!(matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
                              ^0
  635|      1|        assert!(matches!(specs[1].policy, ColumnPolicy::Resizable { .. }));
                              ^0
  636|      1|    }
  637|       |
  638|       |    #[test]
  639|      1|    fn multiple_remainder_columns_allowed() {
  640|      1|        let headers = vec![
  641|      1|            vec![span("Summary")],
  642|      1|            vec![span("Details")],
  643|      1|            vec![span("Examples")],
  644|       |        ];
  645|      1|        let rows = vec![vec![
  646|      1|            vec![span("short")],
  647|      1|            vec![span(
  648|      1|                "Long content that should trigger a remainder column due to its width and words.",
  649|       |            )],
  650|      1|            vec![span(
  651|      1|                "Another large column with links https://example.com and more text.",
  652|       |            )],
  653|       |        ]];
  654|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  655|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  656|      1|        let specs = derive_column_specs(&ctx);
  657|      1|        let remainder_count = specs
  658|      1|            .iter()
  659|      3|            .filter(|s| matches!(s.policy, ColumnPolicy::Remainder { .. }))
                           ^1
  660|      1|            .count();
  661|      1|        assert!(
  662|      1|            remainder_count >= 2,
  663|      0|            "should allow multiple remainder columns, got {remainder_count}"
  664|       |        );
  665|      1|    }
  666|       |
  667|       |    #[test]
  668|      1|    fn cjk_widths_increase_stat_estimates() {
  669|      1|        let headers = vec![vec![span("")], vec![span("Column")]];
  670|      1|        let rows = vec![vec![vec![span("")], vec![span("short")]]];
  671|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  672|      1|        assert!(stats[0].max_graphemes > stats[1].max_graphemes);
  673|      1|    }
  674|       |}

C:\language\mdmdview\src\table_support\metrics.rs:
    1|       |use std::collections::HashMap;
    2|       |
    3|       |#[allow(dead_code)]
    4|       |#[derive(Debug, Default, Clone)]
    5|       |pub struct RowMetrics {
    6|       |    pub max_height: f32,
    7|       |    pub dirty: bool,
    8|       |}
    9|       |
   10|       |#[allow(dead_code)]
   11|       |#[derive(Debug, Default, Clone)]
   12|       |pub struct TableMetricEntry {
   13|       |    pub rows: Vec<RowMetrics>,
   14|       |    pub rendered_rows: usize,
   15|       |    pub total_rows: usize,
   16|       |    pub resolved_widths: Vec<f32>,
   17|       |    pub last_width_frame: u64,
   18|       |    pub last_discard_frame: Option<u64>,
   19|       |    pub persisted_column_widths: HashMap<u64, f32>,
   20|       |    pub pending_user_resize: Option<PendingResize>,
   21|       |    /// Font size when widths were last persisted. Used to invalidate
   22|       |    /// persisted widths when zoom level changes.
   23|       |    pub persisted_font_size: Option<f32>,
   24|       |}
   25|       |
   26|       |#[derive(Debug, Clone, Copy)]
   27|       |pub struct PendingResize {
   28|       |    pub column_hash: u64,
   29|       |    pub width: f32,
   30|       |}
   31|       |
   32|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   33|       |pub enum WidthChange {
   34|       |    None,
   35|       |    Small,
   36|       |    Large,
   37|       |}
   38|       |
   39|       |const WIDTH_EPSILON: f32 = 0.15;
   40|       |const WIDTH_LARGE_DELTA: f32 = 0.75;
   41|       |
   42|       |impl TableMetricEntry {
   43|      4|    pub fn ensure_row(&mut self, index: usize) -> &mut RowMetrics {
   44|      4|        if index >= self.rows.len() {
   45|      4|            self.rows.resize_with(index + 1, RowMetrics::default);
   46|      4|        }
                      ^0
   47|      4|        &mut self.rows[index]
   48|      4|    }
   49|       |
   50|      6|    pub fn row(&self, index: usize) -> Option<&RowMetrics> {
   51|      6|        self.rows.get(index)
   52|      6|    }
   53|       |
   54|      5|    pub fn begin_pass(&mut self, total_rows: usize) {
   55|      5|        self.total_rows = total_rows;
   56|      5|        self.rendered_rows = 0;
   57|      5|    }
   58|       |
   59|      8|    pub fn note_row_rendered(&mut self) {
   60|      8|        self.rendered_rows += 1;
   61|      8|    }
   62|       |
   63|     17|    pub fn persisted_width(&self, key: u64) -> Option<f32> {
   64|     17|        self.persisted_column_widths.get(&key).copied()
   65|     17|    }
   66|       |
   67|      5|    pub fn set_persisted_width(&mut self, key: u64, width: f32) {
   68|      5|        self.persisted_column_widths.insert(key, width);
   69|      5|    }
   70|       |
   71|      1|    pub fn remove_persisted_width(&mut self, key: u64) {
   72|      1|        self.persisted_column_widths.remove(&key);
   73|      1|    }
   74|       |
   75|      8|    pub fn update_widths(&mut self, widths: &[f32], frame_id: u64) -> WidthChange {
   76|      8|        if widths.is_empty() {
   77|      1|            self.resolved_widths.clear();
   78|      1|            self.last_width_frame = frame_id;
   79|      1|            return WidthChange::None;
   80|      7|        }
   81|       |
   82|      7|        let first_update = self.resolved_widths.is_empty();
   83|      7|        let mut change = WidthChange::None;
   84|      7|        if !first_update && self.resolved_widths.len() != widths.len() {
                                          ^3                   ^3
   85|      1|            change = WidthChange::Large;
   86|      1|        } else {
   87|      6|            for (old, new) in self.resolved_widths.iter().zip(widths.iter()) {
                               ^3   ^3
   88|      3|                let delta = (old - new).abs();
   89|      3|                if delta > WIDTH_LARGE_DELTA {
   90|      1|                    change = WidthChange::Large;
   91|      1|                    break;
   92|      2|                }
   93|      2|                if delta > WIDTH_EPSILON {
   94|      2|                    change = WidthChange::Small;
   95|      2|                }
                              ^0
   96|       |            }
   97|       |        }
   98|       |
   99|      7|        self.resolved_widths.clear();
  100|      7|        self.resolved_widths.extend_from_slice(widths);
  101|      7|        self.last_width_frame = frame_id;
  102|       |
  103|      7|        change
  104|      8|    }
  105|       |
  106|      1|    pub fn current_widths(&self) -> &[f32] {
  107|      1|        &self.resolved_widths
  108|      1|    }
  109|       |
  110|       |    /// Check if font size has changed since widths were last persisted.
  111|       |    /// If so, clear all persisted widths and update the stored font size.
  112|       |    /// Returns true if widths were cleared.
  113|      8|    pub fn check_font_size_change(&mut self, current_font_size: f32) -> bool {
  114|       |        const FONT_SIZE_EPSILON: f32 = 0.5;
  115|      8|        if let Some(stored_font) = self.persisted_font_size {
                                  ^4
  116|      4|            if (stored_font - current_font_size).abs() > FONT_SIZE_EPSILON {
  117|      2|                self.persisted_column_widths.clear();
  118|      2|                self.persisted_font_size = Some(current_font_size);
  119|      2|                return true;
  120|      2|            }
  121|      4|        } else {
  122|      4|            self.persisted_font_size = Some(current_font_size);
  123|      4|        }
  124|      6|        false
  125|      8|    }
  126|       |}
  127|       |
  128|       |#[allow(dead_code)]
  129|       |#[derive(Debug, Default, Clone)]
  130|       |pub struct TableMetrics {
  131|       |    tables: HashMap<u64, TableMetricEntry>,
  132|       |}
  133|       |
  134|       |impl TableMetrics {
  135|     22|    pub fn entry_mut(&mut self, table_id: u64) -> &mut TableMetricEntry {
  136|     22|        self.tables.entry(table_id).or_default()
  137|     22|    }
  138|       |
  139|      7|    pub fn entry(&self, table_id: u64) -> Option<&TableMetricEntry> {
  140|      7|        self.tables.get(&table_id)
  141|      7|    }
  142|       |
  143|     21|    pub fn totals(&self) -> (usize, usize) {
  144|     21|        self.tables
  145|     21|            .values()
  146|     21|            .fold((0, 0), |(rendered, total), entry| {
                                                                   ^3
  147|      3|                (rendered + entry.rendered_rows, total + entry.total_rows)
  148|      3|            })
  149|     21|    }
  150|       |
  151|    202|    pub fn clear(&mut self) {
  152|    202|        self.tables.clear();
  153|    202|    }
  154|       |}
  155|       |
  156|       |#[allow(dead_code)]
  157|       |#[derive(Debug, Default, Clone)]
  158|       |pub struct CacheStats {
  159|       |    pub hits: u64,
  160|       |    pub misses: u64,
  161|       |}
  162|       |
  163|       |impl CacheStats {
  164|      2|    pub fn record_hit(&mut self) {
  165|      2|        self.hits += 1;
  166|      2|    }
  167|       |
  168|      1|    pub fn record_miss(&mut self) {
  169|      1|        self.misses += 1;
  170|      1|    }
  171|       |}
  172|       |
  173|       |#[cfg(test)]
  174|       |mod tests {
  175|       |    use super::*;
  176|       |
  177|       |    #[test]
  178|      1|    fn update_widths_detects_large_change() {
  179|      1|        let mut entry = TableMetricEntry::default();
  180|      1|        assert_eq!(entry.update_widths(&[100.0, 120.0], 1), WidthChange::None);
  181|      1|        assert_eq!(entry.update_widths(&[100.2, 120.6], 2), WidthChange::Small);
  182|      1|        assert_eq!(entry.update_widths(&[140.0, 120.6], 3), WidthChange::Large);
  183|      1|    }
  184|       |
  185|       |    #[test]
  186|      1|    fn font_size_change_clears_persisted_widths() {
  187|      1|        let mut entry = TableMetricEntry::default();
  188|       |
  189|       |        // Set some persisted widths at font size 14.0
  190|      1|        entry.set_persisted_width(1, 100.0);
  191|      1|        entry.set_persisted_width(2, 150.0);
  192|      1|        assert!(!entry.check_font_size_change(14.0)); // First call sets baseline
  193|      1|        assert_eq!(entry.persisted_width(1), Some(100.0));
  194|      1|        assert_eq!(entry.persisted_width(2), Some(150.0));
  195|       |
  196|       |        // Small font size change (within epsilon) should NOT clear
  197|      1|        assert!(!entry.check_font_size_change(14.3));
  198|      1|        assert_eq!(entry.persisted_width(1), Some(100.0));
  199|       |
  200|       |        // Large font size change should clear all persisted widths
  201|      1|        assert!(entry.check_font_size_change(16.0));
  202|      1|        assert_eq!(entry.persisted_width(1), None);
  203|      1|        assert_eq!(entry.persisted_width(2), None);
  204|      1|        assert_eq!(entry.persisted_font_size, Some(16.0));
  205|      1|    }
  206|       |
  207|       |    #[test]
  208|      1|    fn row_management_tracks_rows_and_rendered_counts() {
  209|      1|        let mut entry = TableMetricEntry::default();
  210|      1|        entry.begin_pass(3);
  211|      1|        assert_eq!(entry.total_rows, 3);
  212|      1|        assert_eq!(entry.rendered_rows, 0);
  213|       |
  214|      1|        let row = entry.ensure_row(2);
  215|      1|        row.max_height = 12.0;
  216|      1|        row.dirty = true;
  217|       |
  218|      1|        assert_eq!(entry.row(2).map(|r| r.max_height), Some(12.0));
  219|      1|        assert_eq!(entry.row(2).map(|r| r.dirty), Some(true));
  220|      1|        assert!(entry.row(5).is_none());
  221|       |
  222|      1|        entry.note_row_rendered();
  223|      1|        entry.note_row_rendered();
  224|      1|        assert_eq!(entry.rendered_rows, 2);
  225|      1|    }
  226|       |
  227|       |    #[test]
  228|      1|    fn persisted_widths_can_be_added_and_removed() {
  229|      1|        let mut entry = TableMetricEntry::default();
  230|      1|        assert!(entry.persisted_width(10).is_none());
  231|      1|        entry.set_persisted_width(10, 123.0);
  232|      1|        assert_eq!(entry.persisted_width(10), Some(123.0));
  233|      1|        entry.remove_persisted_width(10);
  234|      1|        assert!(entry.persisted_width(10).is_none());
  235|      1|    }
  236|       |
  237|       |    #[test]
  238|      1|    fn update_widths_handles_empty_and_length_change() {
  239|      1|        let mut entry = TableMetricEntry::default();
  240|      1|        assert_eq!(entry.update_widths(&[], 1), WidthChange::None);
  241|      1|        assert!(entry.current_widths().is_empty());
  242|       |
  243|      1|        assert_eq!(entry.update_widths(&[50.0, 60.0], 2), WidthChange::None);
  244|      1|        assert_eq!(entry.update_widths(&[50.0], 3), WidthChange::Large);
  245|      1|    }
  246|       |
  247|       |    #[test]
  248|      1|    fn table_metrics_totals_and_clear() {
  249|      1|        let mut metrics = TableMetrics::default();
  250|      1|        metrics.entry_mut(1).begin_pass(2);
  251|      1|        metrics.entry_mut(1).note_row_rendered();
  252|      1|        metrics.entry_mut(2).begin_pass(3);
  253|      1|        metrics.entry_mut(2).note_row_rendered();
  254|      1|        metrics.entry_mut(2).note_row_rendered();
  255|       |
  256|      1|        assert_eq!(metrics.totals(), (3, 5));
  257|      1|        metrics.clear();
  258|      1|        assert!(metrics.entry(1).is_none());
  259|      1|    }
  260|       |
  261|       |    #[test]
  262|      1|    fn cache_stats_counts_hits_and_misses() {
  263|      1|        let mut stats = CacheStats::default();
  264|      1|        stats.record_hit();
  265|      1|        stats.record_hit();
  266|      1|        stats.record_miss();
  267|      1|        assert_eq!(stats.hits, 2);
  268|      1|        assert_eq!(stats.misses, 1);
  269|      1|    }
  270|       |}

C:\language\mdmdview\src\window_state.rs:
    1|       |use std::fs;
    2|       |use std::io::{Read, Write};
    3|       |use std::path::PathBuf;
    4|       |
    5|       |#[derive(Debug, Clone, Copy)]
    6|       |pub struct WindowState {
    7|       |    pub pos: [f32; 2],
    8|       |    pub size: [f32; 2],
    9|       |    pub maximized: bool,
   10|       |}
   11|       |
   12|      4|fn config_dir() -> Option<PathBuf> {
   13|       |    // Crossplatform config dir without extra deps
   14|       |    #[cfg(target_os = "windows")]
   15|       |    {
   16|      4|        if let Ok(appdata) = std::env::var("APPDATA") {
   17|      4|            let mut p = PathBuf::from(appdata);
   18|      4|            p.push("MarkdownView");
   19|      4|            return Some(p);
   20|      0|        }
   21|       |    }
   22|       |
   23|       |    #[cfg(target_os = "macos")]
   24|       |    {
   25|       |        if let Ok(home) = std::env::var("HOME") {
   26|       |            let mut p = PathBuf::from(home);
   27|       |            p.push("Library/Application Support/MarkdownView");
   28|       |            return Some(p);
   29|       |        }
   30|       |    }
   31|       |
   32|       |    // Linux / others: XDG or ~/.config
   33|      0|    if let Ok(xdg) = std::env::var("XDG_CONFIG_HOME") {
   34|      0|        let mut p = PathBuf::from(xdg);
   35|      0|        p.push("mdmdview");
   36|      0|        return Some(p);
   37|      0|    }
   38|      0|    if let Ok(home) = std::env::var("HOME") {
   39|      0|        let mut p = PathBuf::from(home);
   40|      0|        p.push(".config/mdmdview");
   41|      0|        return Some(p);
   42|      0|    }
   43|      0|    None
   44|      4|}
   45|       |
   46|      2|fn state_path() -> Option<PathBuf> {
   47|      2|    config_dir().map(|mut dir| {
   48|      2|        dir.push("window_state.txt");
   49|      2|        dir
   50|      2|    })
   51|      2|}
   52|       |
   53|      2|pub fn load_window_state() -> Option<WindowState> {
   54|       |    #[cfg(windows)]
   55|       |    {
   56|      2|        if let Some(ws) = load_window_state_registry() {
                                  ^0
   57|      0|            return Some(ws);
   58|      2|        }
   59|       |    }
   60|      2|    let path = state_path()?;
                                         ^0
   61|      2|    let mut f = fs::File::open(path).ok()?;
                                                       ^0
   62|      2|    let mut s = String::new();
   63|      2|    f.read_to_string(&mut s).ok()?;
                                               ^0
   64|       |    // expected format: "x y w h max"
   65|      2|    let parts: Vec<&str> = s.split_whitespace().collect();
   66|      2|    if parts.len() < 5 {
   67|      1|        return None;
   68|      1|    }
   69|      1|    let x = parts[0].parse::<f32>().ok()?;
                                                      ^0
   70|      1|    let y = parts[1].parse::<f32>().ok()?;
                                                      ^0
   71|      1|    let w = parts[2].parse::<f32>().ok()?;
                                                      ^0
   72|      1|    let h = parts[3].parse::<f32>().ok()?;
                                                      ^0
   73|      1|    let max = matches!(parts[4], "1" | "true" | "True");
                            ^0
   74|      1|    Some(WindowState {
   75|      1|        pos: [x, y],
   76|      1|        size: [w, h],
   77|      1|        maximized: max,
   78|      1|    })
   79|      2|}
   80|       |
   81|      2|pub fn save_window_state(state: &WindowState) -> std::io::Result<()> {
   82|       |    #[cfg(windows)]
   83|       |    {
   84|      2|        if let Err(e) = save_window_state_registry(state) {
                                 ^0
   85|      0|            eprintln!("Failed to write window state to registry: {e}");
   86|      2|        }
   87|       |    }
   88|      2|    if let Some(mut dir) = config_dir() {
   89|      2|        if !dir.exists() {
   90|      2|            fs::create_dir_all(&dir)?;
                                                  ^0
   91|      0|        }
   92|      2|        dir.push("window_state.txt");
   93|      2|        let mut f = fs::File::create(&dir)?;
                                                        ^0
   94|       |        // simple whitespace separated format
   95|      2|        writeln!(
   96|      2|            f,
   97|      2|            "{} {} {} {} {}",
   98|      2|            state.pos[0], state.pos[1], state.size[0], state.size[1], state.maximized as u8
   99|      0|        )?;
  100|      0|    }
  101|      2|    Ok(())
  102|      2|}
  103|       |
  104|      2|pub fn sanitize_window_state(ws: WindowState) -> Option<WindowState> {
  105|       |    // Basic sanity: finite values
  106|      2|    if !ws.pos[0].is_finite()
  107|      1|        || !ws.pos[1].is_finite()
  108|      1|        || !ws.size[0].is_finite()
  109|      1|        || !ws.size[1].is_finite()
  110|       |    {
  111|      1|        return None;
  112|      1|    }
  113|       |
  114|       |    // Clamp to reasonable ranges
  115|      1|    let min_w = 600.0f32;
  116|      1|    let min_h = 400.0f32;
  117|      1|    let max_w = 10000.0f32;
  118|      1|    let max_h = 10000.0f32;
  119|      1|    let max_pos = 20000.0f32; // avoid absurdly large coordinates
  120|       |
  121|      1|    let w = ws.size[0].clamp(min_w, max_w);
  122|      1|    let h = ws.size[1].clamp(min_h, max_h);
  123|      1|    let x = ws.pos[0].max(0.0).min(max_pos);
  124|      1|    let y = ws.pos[1].max(0.0).min(max_pos);
  125|       |
  126|      1|    Some(WindowState {
  127|      1|        pos: [x, y],
  128|      1|        size: [w, h],
  129|      1|        maximized: ws.maximized,
  130|      1|    })
  131|      2|}
  132|       |
  133|       |#[cfg(all(windows, not(test)))]
  134|       |fn load_window_state_registry() -> Option<WindowState> {
  135|       |    use winreg::enums::HKEY_CURRENT_USER;
  136|       |    use winreg::RegKey;
  137|       |    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  138|       |    let key = hkcu.open_subkey("Software\\MarkdownView").ok()?;
  139|       |    let x: u32 = key.get_value("PosX").ok()?;
  140|       |    let y: u32 = key.get_value("PosY").ok()?;
  141|       |    let w: u32 = key.get_value("Width").ok()?;
  142|       |    let h: u32 = key.get_value("Height").ok()?;
  143|       |    let maximized: u32 = key.get_value("Maximized").unwrap_or(0);
  144|       |    Some(WindowState {
  145|       |        pos: [x as f32, y as f32],
  146|       |        size: [w as f32, h as f32],
  147|       |        maximized: maximized != 0,
  148|       |    })
  149|       |}
  150|       |
  151|       |#[cfg(all(windows, not(test)))]
  152|       |fn save_window_state_registry(state: &WindowState) -> std::io::Result<()> {
  153|       |    use winreg::enums::{HKEY_CURRENT_USER, KEY_READ, KEY_WRITE};
  154|       |    use winreg::RegKey;
  155|       |    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  156|       |    let (key, _disp) =
  157|       |        hkcu.create_subkey_with_flags("Software\\MarkdownView", KEY_READ | KEY_WRITE)?;
  158|       |    let to_u32 = |v: f32| -> u32 {
  159|       |        if v.is_finite() {
  160|       |            v.max(0.0).min(u32::MAX as f32).round() as u32
  161|       |        } else {
  162|       |            0
  163|       |        }
  164|       |    };
  165|       |    key.set_value("PosX", &to_u32(state.pos[0]))?;
  166|       |    key.set_value("PosY", &to_u32(state.pos[1]))?;
  167|       |    key.set_value("Width", &to_u32(state.size[0]))?;
  168|       |    key.set_value("Height", &to_u32(state.size[1]))?;
  169|       |    key.set_value("Maximized", &(state.maximized as u32))?;
  170|       |    Ok(())
  171|       |}
  172|       |
  173|       |#[cfg(all(windows, test))]
  174|      2|fn load_window_state_registry() -> Option<WindowState> {
  175|      2|    None
  176|      2|}
  177|       |
  178|       |#[cfg(all(windows, test))]
  179|      2|fn save_window_state_registry(_state: &WindowState) -> std::io::Result<()> {
  180|      2|    Ok(())
  181|      2|}
  182|       |
  183|       |#[cfg(test)]
  184|       |mod tests {
  185|       |    use super::*;
  186|       |    use std::sync::{Mutex, OnceLock};
  187|       |    use tempfile::TempDir;
  188|       |
  189|      2|    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
  190|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
  191|      2|        ENV_LOCK.get_or_init(|| Mutex::new(())).lock().expect("env lock")
                                              ^1         ^1
  192|      2|    }
  193|       |
  194|       |    struct EnvGuard {
  195|       |        key: &'static str,
  196|       |        original: Option<String>,
  197|       |    }
  198|       |
  199|       |    impl EnvGuard {
  200|      2|        fn set(key: &'static str, value: &str) -> Self {
  201|      2|            let original = std::env::var(key).ok();
  202|      2|            std::env::set_var(key, value);
  203|      2|            Self { key, original }
  204|      2|        }
  205|       |
  206|      0|        fn unset(key: &'static str) -> Self {
  207|      0|            let original = std::env::var(key).ok();
  208|      0|            std::env::remove_var(key);
  209|      0|            Self { key, original }
  210|      0|        }
  211|       |    }
  212|       |
  213|       |    impl Drop for EnvGuard {
  214|      2|        fn drop(&mut self) {
  215|      2|            if let Some(value) = &self.original {
  216|      2|                std::env::set_var(self.key, value);
  217|      2|            } else {
  218|      0|                std::env::remove_var(self.key);
  219|      0|            }
  220|      2|        }
  221|       |    }
  222|       |
  223|       |    #[test]
  224|      1|    fn test_sanitize_window_state_clamps_and_rejects_invalid() {
  225|      1|        let invalid = WindowState {
  226|      1|            pos: [f32::NAN, 10.0],
  227|      1|            size: [800.0, 600.0],
  228|      1|            maximized: false,
  229|      1|        };
  230|      1|        assert!(sanitize_window_state(invalid).is_none());
  231|       |
  232|      1|        let input = WindowState {
  233|      1|            pos: [-50.0, 25000.0],
  234|      1|            size: [100.0, 200.0],
  235|      1|            maximized: true,
  236|      1|        };
  237|      1|        let sanitized = sanitize_window_state(input).expect("expected sanitized state");
  238|      1|        assert_eq!(sanitized.pos[0], 0.0);
  239|      1|        assert_eq!(sanitized.pos[1], 20000.0);
  240|      1|        assert_eq!(sanitized.size[0], 600.0);
  241|      1|        assert_eq!(sanitized.size[1], 400.0);
  242|      1|        assert!(sanitized.maximized);
  243|      1|    }
  244|       |
  245|       |    #[test]
  246|      1|    fn test_save_and_load_window_state_from_file() {
  247|      1|        let _lock = env_lock();
  248|      1|        let temp = TempDir::new().expect("temp dir");
  249|      1|        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  250|       |
  251|      1|        let state = WindowState {
  252|      1|            pos: [120.0, 80.0],
  253|      1|            size: [1024.0, 768.0],
  254|      1|            maximized: false,
  255|      1|        };
  256|      1|        save_window_state(&state).expect("save");
  257|       |
  258|      1|        let loaded = load_window_state().expect("load");
  259|      1|        assert_eq!(loaded.pos, state.pos);
  260|      1|        assert_eq!(loaded.size, state.size);
  261|      1|        assert_eq!(loaded.maximized, state.maximized);
  262|      1|    }
  263|       |
  264|       |    #[test]
  265|      1|    fn test_load_window_state_rejects_bad_file() {
  266|      1|        let _lock = env_lock();
  267|      1|        let temp = TempDir::new().expect("temp dir");
  268|      1|        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  269|       |
  270|      1|        let mut config = temp.path().join("MarkdownView");
  271|      1|        std::fs::create_dir_all(&config).expect("create config dir");
  272|      1|        config.push("window_state.txt");
  273|      1|        std::fs::write(&config, "10 20 30").expect("write bad data");
  274|       |
  275|      1|        assert!(load_window_state().is_none());
  276|      1|    }
  277|       |}

c:\language\mdmdview\target\llvm-cov-target\debug\build\glutin_egl_sys-dcef47d8a173377f\out\egl_bindings.rs:
    1|       |
    2|       |        mod __gl_imports {
    3|       |            pub use std::mem;
    4|       |            pub use std::marker::Send;
    5|       |            pub use std::os::raw;
    6|       |        }
    7|       |    
    8|       |
    9|       |        pub mod types {
   10|       |            #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)]
   11|       |    
   12|       |// platform-specific aliases are unknown
   13|       |// IMPORTANT: these are alises to the same level of the bindings
   14|       |// the values must be defined by the user
   15|       |#[allow(dead_code)]
   16|       |pub type khronos_utime_nanoseconds_t = super::khronos_utime_nanoseconds_t;
   17|       |#[allow(dead_code)]
   18|       |pub type khronos_uint64_t = super::khronos_uint64_t;
   19|       |#[allow(dead_code)]
   20|       |pub type khronos_ssize_t = super::khronos_ssize_t;
   21|       |pub type EGLNativeDisplayType = super::EGLNativeDisplayType;
   22|       |#[allow(dead_code)]
   23|       |pub type EGLNativePixmapType = super::EGLNativePixmapType;
   24|       |#[allow(dead_code)]
   25|       |pub type EGLNativeWindowType = super::EGLNativeWindowType;
   26|       |pub type EGLint = super::EGLint;
   27|       |#[allow(dead_code)]
   28|       |pub type NativeDisplayType = super::NativeDisplayType;
   29|       |#[allow(dead_code)]
   30|       |pub type NativePixmapType = super::NativePixmapType;
   31|       |#[allow(dead_code)]
   32|       |pub type NativeWindowType = super::NativeWindowType;
   33|       |
   34|       |// EGL alises
   35|       |pub type Bool = EGLBoolean; // TODO: not sure
   36|       |pub type EGLBoolean = super::__gl_imports::raw::c_uint;
   37|       |pub type EGLenum = super::__gl_imports::raw::c_uint;
   38|       |pub type EGLAttribKHR = isize;
   39|       |pub type EGLAttrib = isize;
   40|       |pub type EGLConfig = *const super::__gl_imports::raw::c_void;
   41|       |pub type EGLContext = *const super::__gl_imports::raw::c_void;
   42|       |pub type EGLDeviceEXT = *const super::__gl_imports::raw::c_void;
   43|       |pub type EGLDisplay = *const super::__gl_imports::raw::c_void;
   44|       |pub type EGLSurface = *const super::__gl_imports::raw::c_void;
   45|       |pub type EGLClientBuffer = *const super::__gl_imports::raw::c_void;
   46|       |pub enum __eglMustCastToProperFunctionPointerType_fn {}
   47|       |pub type __eglMustCastToProperFunctionPointerType =
   48|       |    *mut __eglMustCastToProperFunctionPointerType_fn;
   49|       |pub type EGLImageKHR = *const super::__gl_imports::raw::c_void;
   50|       |pub type EGLImage = *const super::__gl_imports::raw::c_void;
   51|       |pub type EGLOutputLayerEXT = *const super::__gl_imports::raw::c_void;
   52|       |pub type EGLOutputPortEXT = *const super::__gl_imports::raw::c_void;
   53|       |pub type EGLSyncKHR = *const super::__gl_imports::raw::c_void;
   54|       |pub type EGLSync = *const super::__gl_imports::raw::c_void;
   55|       |pub type EGLTimeKHR = khronos_utime_nanoseconds_t;
   56|       |pub type EGLTime = khronos_utime_nanoseconds_t;
   57|       |pub type EGLSyncNV = *const super::__gl_imports::raw::c_void;
   58|       |pub type EGLTimeNV = khronos_utime_nanoseconds_t;
   59|       |pub type EGLuint64NV = khronos_utime_nanoseconds_t;
   60|       |pub type EGLStreamKHR = *const super::__gl_imports::raw::c_void;
   61|       |pub type EGLuint64KHR = khronos_uint64_t;
   62|       |pub type EGLNativeFileDescriptorKHR = super::__gl_imports::raw::c_int;
   63|       |pub type EGLsizeiANDROID = khronos_ssize_t;
   64|       |pub type EGLSetBlobFuncANDROID = extern "system" fn(*const super::__gl_imports::raw::c_void,
   65|       |                                                    EGLsizeiANDROID,
   66|       |                                                    *const super::__gl_imports::raw::c_void,
   67|       |                                                    EGLsizeiANDROID)
   68|       |                                                    -> ();
   69|       |pub type EGLGetBlobFuncANDROID = extern "system" fn(*const super::__gl_imports::raw::c_void,
   70|       |                                                    EGLsizeiANDROID,
   71|       |                                                    *mut super::__gl_imports::raw::c_void,
   72|       |                                                    EGLsizeiANDROID)
   73|       |                                                    -> EGLsizeiANDROID;
   74|       |
   75|       |#[repr(C)]
   76|       |pub struct EGLClientPixmapHI {
   77|       |    pData: *const super::__gl_imports::raw::c_void,
   78|       |    iWidth: EGLint,
   79|       |    iHeight: EGLint,
   80|       |    iStride: EGLint,
   81|       |}
   82|       |
   83|       |}
   84|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT: types::EGLenum = 0x3088;
   85|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT_NONPRE: types::EGLenum = 0x308B;
   86|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT_PRE: types::EGLenum = 0x308C;
   87|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_MASK_SIZE: types::EGLenum = 0x303E;
   88|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_SIZE: types::EGLenum = 0x3021;
   89|       |#[allow(dead_code, non_upper_case_globals)] pub const BACK_BUFFER: types::EGLenum = 0x3084;
   90|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_ACCESS: types::EGLenum = 0x3002;
   91|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_ALLOC: types::EGLenum = 0x3003;
   92|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_ATTRIBUTE: types::EGLenum = 0x3004;
   93|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_CONFIG: types::EGLenum = 0x3005;
   94|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_CONTEXT: types::EGLenum = 0x3006;
   95|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_CURRENT_SURFACE: types::EGLenum = 0x3007;
   96|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_DEVICE_EXT: types::EGLenum = 0x322B;
   97|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_DISPLAY: types::EGLenum = 0x3008;
   98|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_MATCH: types::EGLenum = 0x3009;
   99|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_NATIVE_PIXMAP: types::EGLenum = 0x300A;
  100|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_NATIVE_WINDOW: types::EGLenum = 0x300B;
  101|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_PARAMETER: types::EGLenum = 0x300C;
  102|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_SURFACE: types::EGLenum = 0x300D;
  103|       |#[allow(dead_code, non_upper_case_globals)] pub const BIND_TO_TEXTURE_RGB: types::EGLenum = 0x3039;
  104|       |#[allow(dead_code, non_upper_case_globals)] pub const BIND_TO_TEXTURE_RGBA: types::EGLenum = 0x303A;
  105|       |#[allow(dead_code, non_upper_case_globals)] pub const BLUE_SIZE: types::EGLenum = 0x3022;
  106|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_AGE_EXT: types::EGLenum = 0x313D;
  107|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_DESTROYED: types::EGLenum = 0x3095;
  108|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_PRESERVED: types::EGLenum = 0x3094;
  109|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_SIZE: types::EGLenum = 0x3020;
  110|       |#[allow(dead_code, non_upper_case_globals)] pub const CLIENT_APIS: types::EGLenum = 0x308D;
  111|       |#[allow(dead_code, non_upper_case_globals)] pub const CL_EVENT_HANDLE: types::EGLenum = 0x309C;
  112|       |#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE: types::EGLenum = 0x3087;
  113|       |#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE_LINEAR: types::EGLenum = 0x308A;
  114|       |#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE_sRGB: types::EGLenum = 0x3089;
  115|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_BUFFER_TYPE: types::EGLenum = 0x303F;
  116|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_EXT: types::EGLenum = 0x3339;
  117|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_FIXED_EXT: types::EGLenum = 0x333A;
  118|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_FLOAT_EXT: types::EGLenum = 0x333B;
  119|       |#[allow(dead_code, non_upper_case_globals)] pub const CONDITION_SATISFIED: types::EGLenum = 0x30F6;
  120|       |#[allow(dead_code, non_upper_case_globals)] pub const CONFIG_CAVEAT: types::EGLenum = 0x3027;
  121|       |#[allow(dead_code, non_upper_case_globals)] pub const CONFIG_ID: types::EGLenum = 0x3028;
  122|       |#[allow(dead_code, non_upper_case_globals)] pub const CONFORMANT: types::EGLenum = 0x3042;
  123|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CLIENT_TYPE: types::EGLenum = 0x3097;
  124|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CLIENT_VERSION: types::EGLenum = 0x3098;
  125|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FLAGS_KHR: types::EGLenum = 0x30FC;
  126|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_LOST: types::EGLenum = 0x300E;
  127|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION: types::EGLenum = 0x3098;
  128|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION_KHR: types::EGLenum = 0x3098;
  129|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION: types::EGLenum = 0x30FB;
  130|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION_KHR: types::EGLenum = 0x30FB;
  131|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT: types::EGLenum = 0x00000002;
  132|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR: types::EGLenum = 0x00000002;
  133|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_CORE_PROFILE_BIT: types::EGLenum = 0x00000001;
  134|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR: types::EGLenum = 0x00000001;
  135|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_DEBUG: types::EGLenum = 0x31B0;
  136|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_DEBUG_BIT_KHR: types::EGLenum = 0x00000001;
  137|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_FORWARD_COMPATIBLE: types::EGLenum = 0x31B1;
  138|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR: types::EGLenum = 0x00000002;
  139|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_NO_ERROR_KHR: types::EGLenum = 0x31B3;
  140|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_PROFILE_MASK: types::EGLenum = 0x30FD;
  141|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_PROFILE_MASK_KHR: types::EGLenum = 0x30FD;
  142|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY: types::EGLenum = 0x31BD;
  143|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT: types::EGLenum = 0x3138;
  144|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR: types::EGLenum = 0x31BD;
  145|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS: types::EGLenum = 0x31B2;
  146|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR: types::EGLenum = 0x00000004;
  147|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS_EXT: types::EGLenum = 0x30BF;
  148|       |#[allow(dead_code, non_upper_case_globals)] pub const CORE_NATIVE_ENGINE: types::EGLenum = 0x305B;
  149|       |#[allow(dead_code, non_upper_case_globals)] pub const DEFAULT_DISPLAY: types::EGLNativeDisplayType = 0 as types::EGLNativeDisplayType;
  150|       |#[allow(dead_code, non_upper_case_globals)] pub const DEPTH_SIZE: types::EGLenum = 0x3025;
  151|       |#[allow(dead_code, non_upper_case_globals)] pub const DEVICE_EXT: types::EGLenum = 0x322C;
  152|       |#[allow(dead_code, non_upper_case_globals)] pub const DISPLAY_SCALING: types::EGLenum = 10000;
  153|       |#[allow(dead_code, non_upper_case_globals)] pub const DONT_CARE: types::EGLint = -1 as types::EGLint;
  154|       |#[allow(dead_code, non_upper_case_globals)] pub const DRAW: types::EGLenum = 0x3059;
  155|       |#[allow(dead_code, non_upper_case_globals)] pub const DRM_DEVICE_FILE_EXT: types::EGLenum = 0x3233;
  156|       |#[allow(dead_code, non_upper_case_globals)] pub const DRM_MASTER_FD_EXT: types::EGLenum = 0x333C;
  157|       |#[allow(dead_code, non_upper_case_globals)] pub const EXTENSIONS: types::EGLenum = 0x3055;
  158|       |#[allow(dead_code, non_upper_case_globals)] pub const FALSE: types::EGLBoolean = 0;
  159|       |#[allow(dead_code, non_upper_case_globals)] pub const FOREVER: types::EGLuint64KHR = 0xFFFFFFFFFFFFFFFF;
  160|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE: types::EGLenum = 0x309D;
  161|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE_LINEAR: types::EGLenum = 0x308A;
  162|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE_SRGB: types::EGLenum = 0x3089;
  163|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_RENDERBUFFER: types::EGLenum = 0x30B9;
  164|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_2D: types::EGLenum = 0x30B1;
  165|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_3D: types::EGLenum = 0x30B2;
  166|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_X: types::EGLenum = 0x30B4;
  167|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: types::EGLenum = 0x30B6;
  168|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: types::EGLenum = 0x30B8;
  169|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_X: types::EGLenum = 0x30B3;
  170|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Y: types::EGLenum = 0x30B5;
  171|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Z: types::EGLenum = 0x30B7;
  172|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_LEVEL: types::EGLenum = 0x30BC;
  173|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_ZOFFSET: types::EGLenum = 0x30BD;
  174|       |#[allow(dead_code, non_upper_case_globals)] pub const GREEN_SIZE: types::EGLenum = 0x3023;
  175|       |#[allow(dead_code, non_upper_case_globals)] pub const HEIGHT: types::EGLenum = 0x3056;
  176|       |#[allow(dead_code, non_upper_case_globals)] pub const HORIZONTAL_RESOLUTION: types::EGLenum = 0x3090;
  177|       |#[allow(dead_code, non_upper_case_globals)] pub const IMAGE_PRESERVED: types::EGLenum = 0x30D2;
  178|       |#[allow(dead_code, non_upper_case_globals)] pub const LARGEST_PBUFFER: types::EGLenum = 0x3058;
  179|       |#[allow(dead_code, non_upper_case_globals)] pub const LEVEL: types::EGLenum = 0x3029;
  180|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET: types::EGLenum = 0x31BF;
  181|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_EXT: types::EGLenum = 0x31BF;
  182|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_KHR: types::EGLenum = 0x31BF;
  183|       |#[allow(dead_code, non_upper_case_globals)] pub const LUMINANCE_BUFFER: types::EGLenum = 0x308F;
  184|       |#[allow(dead_code, non_upper_case_globals)] pub const LUMINANCE_SIZE: types::EGLenum = 0x303D;
  185|       |#[allow(dead_code, non_upper_case_globals)] pub const MATCH_NATIVE_PIXMAP: types::EGLenum = 0x3041;
  186|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_HEIGHT: types::EGLenum = 0x302A;
  187|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_PIXELS: types::EGLenum = 0x302B;
  188|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_WIDTH: types::EGLenum = 0x302C;
  189|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_SWAP_INTERVAL: types::EGLenum = 0x303C;
  190|       |#[allow(dead_code, non_upper_case_globals)] pub const MIN_SWAP_INTERVAL: types::EGLenum = 0x303B;
  191|       |#[allow(dead_code, non_upper_case_globals)] pub const MIPMAP_LEVEL: types::EGLenum = 0x3083;
  192|       |#[allow(dead_code, non_upper_case_globals)] pub const MIPMAP_TEXTURE: types::EGLenum = 0x3082;
  193|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE: types::EGLenum = 0x3099;
  194|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_BOX: types::EGLenum = 0x309B;
  195|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_BOX_BIT: types::EGLenum = 0x0200;
  196|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_DEFAULT: types::EGLenum = 0x309A;
  197|       |#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_RENDERABLE: types::EGLenum = 0x302D;
  198|       |#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_VISUAL_ID: types::EGLenum = 0x302E;
  199|       |#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_VISUAL_TYPE: types::EGLenum = 0x302F;
  200|       |#[allow(dead_code, non_upper_case_globals)] pub const NONE: types::EGLenum = 0x3038;
  201|       |#[allow(dead_code, non_upper_case_globals)] pub const NON_CONFORMANT_CONFIG: types::EGLenum = 0x3051;
  202|       |#[allow(dead_code, non_upper_case_globals)] pub const NOT_INITIALIZED: types::EGLenum = 0x3001;
  203|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_CONTEXT: types::EGLContext = 0 as types::EGLContext;
  204|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_DEVICE_EXT: types::EGLDeviceEXT = 0 as types::EGLDeviceEXT;
  205|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_DISPLAY: types::EGLDisplay = 0 as types::EGLDisplay;
  206|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_IMAGE: types::EGLImage = 0 as types::EGLImage;
  207|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_NATIVE_FENCE_FD_ANDROID: types::EGLint = -1;
  208|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION: types::EGLenum = 0x31BE;
  209|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_EXT: types::EGLenum = 0x31BE;
  210|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_KHR: types::EGLenum = 0x31BE;
  211|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_SURFACE: types::EGLSurface = 0 as types::EGLSurface;
  212|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_SYNC: types::EGLSync = 0 as types::EGLSync;
  213|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_TEXTURE: types::EGLenum = 0x305C;
  214|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_API: types::EGLenum = 0x30A2;
  215|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_BIT: types::EGLenum = 0x0008;
  216|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES2_BIT: types::EGLenum = 0x0004;
  217|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES3_BIT: types::EGLenum = 0x00000040;
  218|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES3_BIT_KHR: types::EGLenum = 0x00000040;
  219|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES_API: types::EGLenum = 0x30A0;
  220|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES_BIT: types::EGLenum = 0x0001;
  221|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_API: types::EGLenum = 0x30A1;
  222|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_BIT: types::EGLenum = 0x0002;
  223|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_IMAGE: types::EGLenum = 0x3096;
  224|       |#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER_BIT: types::EGLenum = 0x0001;
  225|       |#[allow(dead_code, non_upper_case_globals)] pub const PIXEL_ASPECT_RATIO: types::EGLenum = 0x3092;
  226|       |#[allow(dead_code, non_upper_case_globals)] pub const PIXMAP_BIT: types::EGLenum = 0x0002;
  227|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_ANDROID_KHR: types::EGLenum = 0x3141;
  228|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_DEVICE_EXT: types::EGLenum = 0x313F;
  229|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_GBM_KHR: types::EGLenum = 0x31D7;
  230|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_GBM_MESA: types::EGLenum = 0x31D7;
  231|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_WAYLAND_EXT: types::EGLenum = 0x31D8;
  232|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_WAYLAND_KHR: types::EGLenum = 0x31D8;
  233|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_EXT: types::EGLenum = 0x31D5;
  234|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_KHR: types::EGLenum = 0x31D5;
  235|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_SCREEN_EXT: types::EGLenum = 0x31D6;
  236|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_SCREEN_KHR: types::EGLenum = 0x31D6;
  237|       |#[allow(dead_code, non_upper_case_globals)] pub const READ: types::EGLenum = 0x305A;
  238|       |#[allow(dead_code, non_upper_case_globals)] pub const RED_SIZE: types::EGLenum = 0x3024;
  239|       |#[allow(dead_code, non_upper_case_globals)] pub const RENDERABLE_TYPE: types::EGLenum = 0x3040;
  240|       |#[allow(dead_code, non_upper_case_globals)] pub const RENDER_BUFFER: types::EGLenum = 0x3086;
  241|       |#[allow(dead_code, non_upper_case_globals)] pub const RGB_BUFFER: types::EGLenum = 0x308E;
  242|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLES: types::EGLenum = 0x3031;
  243|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLE_BUFFERS: types::EGLenum = 0x3032;
  244|       |#[allow(dead_code, non_upper_case_globals)] pub const SIGNALED: types::EGLenum = 0x30F2;
  245|       |#[allow(dead_code, non_upper_case_globals)] pub const SINGLE_BUFFER: types::EGLenum = 0x3085;
  246|       |#[allow(dead_code, non_upper_case_globals)] pub const SLOW_CONFIG: types::EGLenum = 0x3050;
  247|       |#[allow(dead_code, non_upper_case_globals)] pub const STENCIL_SIZE: types::EGLenum = 0x3026;
  248|       |#[allow(dead_code, non_upper_case_globals)] pub const SUCCESS: types::EGLenum = 0x3000;
  249|       |#[allow(dead_code, non_upper_case_globals)] pub const SURFACE_TYPE: types::EGLenum = 0x3033;
  250|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_BEHAVIOR: types::EGLenum = 0x3093;
  251|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_BEHAVIOR_PRESERVED_BIT: types::EGLenum = 0x0400;
  252|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CL_EVENT: types::EGLenum = 0x30FE;
  253|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CL_EVENT_COMPLETE: types::EGLenum = 0x30FF;
  254|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CONDITION: types::EGLenum = 0x30F8;
  255|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CONDITION_KHR: types::EGLenum = 0x30F8;
  256|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FENCE: types::EGLenum = 0x30F9;
  257|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FENCE_KHR: types::EGLenum = 0x30F9;
  258|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FLUSH_COMMANDS_BIT: types::EGLenum = 0x0001;
  259|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_ANDROID: types::EGLenum = 0x3144;
  260|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_FD_ANDROID: types::EGLenum = 0x3145;
  261|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_SIGNALED_ANDROID: types::EGLenum = 0x3146;
  262|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_PRIOR_COMMANDS_COMPLETE: types::EGLenum = 0x30F0;
  263|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_PRIOR_COMMANDS_COMPLETE_KHR: types::EGLenum = 0x30F0;
  264|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_STATUS: types::EGLenum = 0x30F1;
  265|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_TYPE: types::EGLenum = 0x30F7;
  266|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_2D: types::EGLenum = 0x305F;
  267|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_FORMAT: types::EGLenum = 0x3080;
  268|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_RGB: types::EGLenum = 0x305D;
  269|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_RGBA: types::EGLenum = 0x305E;
  270|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_TARGET: types::EGLenum = 0x3081;
  271|       |#[allow(dead_code, non_upper_case_globals)] pub const TIMEOUT_EXPIRED: types::EGLenum = 0x30F5;
  272|       |#[allow(dead_code, non_upper_case_globals)] pub const TRACK_REFERENCES_KHR: types::EGLenum = 0x3352;
  273|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_BLUE_VALUE: types::EGLenum = 0x3035;
  274|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_GREEN_VALUE: types::EGLenum = 0x3036;
  275|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RED_VALUE: types::EGLenum = 0x3037;
  276|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RGB: types::EGLenum = 0x3052;
  277|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_TYPE: types::EGLenum = 0x3034;
  278|       |#[allow(dead_code, non_upper_case_globals)] pub const TRUE: types::EGLBoolean = 1;
  279|       |#[allow(dead_code, non_upper_case_globals)] pub const UNKNOWN: types::EGLint = -1 as types::EGLint;
  280|       |#[allow(dead_code, non_upper_case_globals)] pub const UNSIGNALED: types::EGLenum = 0x30F3;
  281|       |#[allow(dead_code, non_upper_case_globals)] pub const VENDOR: types::EGLenum = 0x3053;
  282|       |#[allow(dead_code, non_upper_case_globals)] pub const VERSION: types::EGLenum = 0x3054;
  283|       |#[allow(dead_code, non_upper_case_globals)] pub const VERTICAL_RESOLUTION: types::EGLenum = 0x3091;
  284|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT: types::EGLenum = 0x3088;
  285|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_NONPRE: types::EGLenum = 0x308B;
  286|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_PRE: types::EGLenum = 0x308C;
  287|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_PRE_BIT: types::EGLenum = 0x0040;
  288|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE: types::EGLenum = 0x3087;
  289|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_LINEAR: types::EGLenum = 0x308A;
  290|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_LINEAR_BIT: types::EGLenum = 0x0020;
  291|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_sRGB: types::EGLenum = 0x3089;
  292|       |#[allow(dead_code, non_upper_case_globals)] pub const WIDTH: types::EGLenum = 0x3057;
  293|       |#[allow(dead_code, non_upper_case_globals)] pub const WINDOW_BIT: types::EGLenum = 0x0004;
  294|       |
  295|       |        #[allow(dead_code, missing_copy_implementations)]
  296|       |        #[derive(Clone)]
  297|       |        pub struct FnPtr {
  298|       |            /// The function pointer that will be used when calling the function.
  299|       |            f: *const __gl_imports::raw::c_void,
  300|       |            /// True if the pointer points to a real function, false if points to a `panic!` fn.
  301|       |            is_loaded: bool,
  302|       |        }
  303|       |
  304|       |        impl FnPtr {
  305|       |            /// Creates a `FnPtr` from a load attempt.
  306|      0|            fn new(ptr: *const __gl_imports::raw::c_void) -> FnPtr {
  307|      0|                if ptr.is_null() {
  308|      0|                    FnPtr {
  309|      0|                        f: missing_fn_panic as *const __gl_imports::raw::c_void,
  310|      0|                        is_loaded: false
  311|      0|                    }
  312|       |                } else {
  313|      0|                    FnPtr { f: ptr, is_loaded: true }
  314|       |                }
  315|      0|            }
  316|       |
  317|       |            /// Returns `true` if the function has been successfully loaded.
  318|       |            ///
  319|       |            /// If it returns `false`, calling the corresponding function will fail.
  320|       |            #[inline]
  321|       |            #[allow(dead_code)]
  322|      0|            pub fn is_loaded(&self) -> bool {
  323|      0|                self.is_loaded
  324|      0|            }
  325|       |        }
  326|       |    
  327|       |#[inline(never)]
  328|      0|        fn missing_fn_panic() -> ! {
  329|      0|            panic!("egl function was not loaded")
  330|       |        }
  331|       |
  332|       |        #[allow(non_camel_case_types, non_snake_case, dead_code)]
  333|       |        #[derive(Clone)]
  334|       |        pub struct Egl {
  335|       |pub BindAPI: FnPtr,
  336|       |pub BindTexImage: FnPtr,
  337|       |pub ChooseConfig: FnPtr,
  338|       |/// Fallbacks: ClientWaitSyncKHR
  339|       |pub ClientWaitSync: FnPtr,
  340|       |pub ClientWaitSyncKHR: FnPtr,
  341|       |pub CopyBuffers: FnPtr,
  342|       |pub CreateContext: FnPtr,
  343|       |pub CreateImage: FnPtr,
  344|       |pub CreatePbufferFromClientBuffer: FnPtr,
  345|       |pub CreatePbufferSurface: FnPtr,
  346|       |pub CreatePixmapSurface: FnPtr,
  347|       |pub CreatePlatformPixmapSurface: FnPtr,
  348|       |pub CreatePlatformPixmapSurfaceEXT: FnPtr,
  349|       |pub CreatePlatformWindowSurface: FnPtr,
  350|       |pub CreatePlatformWindowSurfaceEXT: FnPtr,
  351|       |/// Fallbacks: CreateSync64KHR
  352|       |pub CreateSync: FnPtr,
  353|       |pub CreateSyncKHR: FnPtr,
  354|       |pub CreateWindowSurface: FnPtr,
  355|       |pub DestroyContext: FnPtr,
  356|       |/// Fallbacks: DestroyImageKHR
  357|       |pub DestroyImage: FnPtr,
  358|       |pub DestroySurface: FnPtr,
  359|       |/// Fallbacks: DestroySyncKHR
  360|       |pub DestroySync: FnPtr,
  361|       |pub DestroySyncKHR: FnPtr,
  362|       |pub DupNativeFenceFDANDROID: FnPtr,
  363|       |pub GetConfigAttrib: FnPtr,
  364|       |pub GetConfigs: FnPtr,
  365|       |pub GetCurrentContext: FnPtr,
  366|       |pub GetCurrentDisplay: FnPtr,
  367|       |pub GetCurrentSurface: FnPtr,
  368|       |pub GetDisplay: FnPtr,
  369|       |pub GetError: FnPtr,
  370|       |pub GetPlatformDisplay: FnPtr,
  371|       |pub GetPlatformDisplayEXT: FnPtr,
  372|       |pub GetProcAddress: FnPtr,
  373|       |pub GetSyncAttrib: FnPtr,
  374|       |pub GetSyncAttribKHR: FnPtr,
  375|       |pub Initialize: FnPtr,
  376|       |pub MakeCurrent: FnPtr,
  377|       |pub QueryAPI: FnPtr,
  378|       |pub QueryContext: FnPtr,
  379|       |pub QueryDeviceAttribEXT: FnPtr,
  380|       |pub QueryDeviceStringEXT: FnPtr,
  381|       |pub QueryDevicesEXT: FnPtr,
  382|       |pub QueryDisplayAttribEXT: FnPtr,
  383|       |/// Fallbacks: QueryDisplayAttribEXT, QueryDisplayAttribNV
  384|       |pub QueryDisplayAttribKHR: FnPtr,
  385|       |pub QueryString: FnPtr,
  386|       |pub QuerySurface: FnPtr,
  387|       |pub ReleaseTexImage: FnPtr,
  388|       |pub ReleaseThread: FnPtr,
  389|       |pub SurfaceAttrib: FnPtr,
  390|       |pub SwapBuffers: FnPtr,
  391|       |pub SwapBuffersWithDamageEXT: FnPtr,
  392|       |pub SwapBuffersWithDamageKHR: FnPtr,
  393|       |pub SwapInterval: FnPtr,
  394|       |pub Terminate: FnPtr,
  395|       |pub WaitClient: FnPtr,
  396|       |pub WaitGL: FnPtr,
  397|       |pub WaitNative: FnPtr,
  398|       |pub WaitSync: FnPtr,
  399|       |pub WaitSyncKHR: FnPtr,
  400|       |_priv: ()
  401|       |}
  402|       |impl Egl {
  403|       |            /// Load each OpenGL symbol using a custom load function. This allows for the
  404|       |            /// use of functions like `glfwGetProcAddress` or `SDL_GL_GetProcAddress`.
  405|       |            ///
  406|       |            /// ~~~ignore
  407|       |            /// let gl = Gl::load_with(|s| glfw.get_proc_address(s));
  408|       |            /// ~~~
  409|       |            #[allow(dead_code, unused_variables)]
  410|      0|            pub fn load_with<F>(mut loadfn: F) -> Egl where F: FnMut(&'static str) -> *const __gl_imports::raw::c_void {
  411|       |                #[inline(never)]
  412|      0|                fn do_metaloadfn(loadfn: &mut dyn FnMut(&'static str) -> *const __gl_imports::raw::c_void,
  413|      0|                                 symbol: &'static str,
  414|      0|                                 symbols: &[&'static str])
  415|      0|                                 -> *const __gl_imports::raw::c_void {
  416|      0|                    let mut ptr = loadfn(symbol);
  417|      0|                    if ptr.is_null() {
  418|      0|                        for &sym in symbols {
  419|      0|                            ptr = loadfn(sym);
  420|      0|                            if !ptr.is_null() { break; }
  421|       |                        }
  422|      0|                    }
  423|      0|                    ptr
  424|      0|                }
  425|      0|                let mut metaloadfn = |symbol: &'static str, symbols: &[&'static str]| {
  426|      0|                    do_metaloadfn(&mut loadfn, symbol, symbols)
  427|      0|                };
  428|      0|                Egl {
  429|      0|BindAPI: FnPtr::new(metaloadfn("eglBindAPI", &[])),
  430|      0|BindTexImage: FnPtr::new(metaloadfn("eglBindTexImage", &[])),
  431|      0|ChooseConfig: FnPtr::new(metaloadfn("eglChooseConfig", &[])),
  432|      0|ClientWaitSync: FnPtr::new(metaloadfn("eglClientWaitSync", &["eglClientWaitSyncKHR"])),
  433|      0|ClientWaitSyncKHR: FnPtr::new(metaloadfn("eglClientWaitSyncKHR", &[])),
  434|      0|CopyBuffers: FnPtr::new(metaloadfn("eglCopyBuffers", &[])),
  435|      0|CreateContext: FnPtr::new(metaloadfn("eglCreateContext", &[])),
  436|      0|CreateImage: FnPtr::new(metaloadfn("eglCreateImage", &[])),
  437|      0|CreatePbufferFromClientBuffer: FnPtr::new(metaloadfn("eglCreatePbufferFromClientBuffer", &[])),
  438|      0|CreatePbufferSurface: FnPtr::new(metaloadfn("eglCreatePbufferSurface", &[])),
  439|      0|CreatePixmapSurface: FnPtr::new(metaloadfn("eglCreatePixmapSurface", &[])),
  440|      0|CreatePlatformPixmapSurface: FnPtr::new(metaloadfn("eglCreatePlatformPixmapSurface", &[])),
  441|      0|CreatePlatformPixmapSurfaceEXT: FnPtr::new(metaloadfn("eglCreatePlatformPixmapSurfaceEXT", &[])),
  442|      0|CreatePlatformWindowSurface: FnPtr::new(metaloadfn("eglCreatePlatformWindowSurface", &[])),
  443|      0|CreatePlatformWindowSurfaceEXT: FnPtr::new(metaloadfn("eglCreatePlatformWindowSurfaceEXT", &[])),
  444|      0|CreateSync: FnPtr::new(metaloadfn("eglCreateSync", &["eglCreateSync64KHR"])),
  445|      0|CreateSyncKHR: FnPtr::new(metaloadfn("eglCreateSyncKHR", &[])),
  446|      0|CreateWindowSurface: FnPtr::new(metaloadfn("eglCreateWindowSurface", &[])),
  447|      0|DestroyContext: FnPtr::new(metaloadfn("eglDestroyContext", &[])),
  448|      0|DestroyImage: FnPtr::new(metaloadfn("eglDestroyImage", &["eglDestroyImageKHR"])),
  449|      0|DestroySurface: FnPtr::new(metaloadfn("eglDestroySurface", &[])),
  450|      0|DestroySync: FnPtr::new(metaloadfn("eglDestroySync", &["eglDestroySyncKHR"])),
  451|      0|DestroySyncKHR: FnPtr::new(metaloadfn("eglDestroySyncKHR", &[])),
  452|      0|DupNativeFenceFDANDROID: FnPtr::new(metaloadfn("eglDupNativeFenceFDANDROID", &[])),
  453|      0|GetConfigAttrib: FnPtr::new(metaloadfn("eglGetConfigAttrib", &[])),
  454|      0|GetConfigs: FnPtr::new(metaloadfn("eglGetConfigs", &[])),
  455|      0|GetCurrentContext: FnPtr::new(metaloadfn("eglGetCurrentContext", &[])),
  456|      0|GetCurrentDisplay: FnPtr::new(metaloadfn("eglGetCurrentDisplay", &[])),
  457|      0|GetCurrentSurface: FnPtr::new(metaloadfn("eglGetCurrentSurface", &[])),
  458|      0|GetDisplay: FnPtr::new(metaloadfn("eglGetDisplay", &[])),
  459|      0|GetError: FnPtr::new(metaloadfn("eglGetError", &[])),
  460|      0|GetPlatformDisplay: FnPtr::new(metaloadfn("eglGetPlatformDisplay", &[])),
  461|      0|GetPlatformDisplayEXT: FnPtr::new(metaloadfn("eglGetPlatformDisplayEXT", &[])),
  462|      0|GetProcAddress: FnPtr::new(metaloadfn("eglGetProcAddress", &[])),
  463|      0|GetSyncAttrib: FnPtr::new(metaloadfn("eglGetSyncAttrib", &[])),
  464|      0|GetSyncAttribKHR: FnPtr::new(metaloadfn("eglGetSyncAttribKHR", &[])),
  465|      0|Initialize: FnPtr::new(metaloadfn("eglInitialize", &[])),
  466|      0|MakeCurrent: FnPtr::new(metaloadfn("eglMakeCurrent", &[])),
  467|      0|QueryAPI: FnPtr::new(metaloadfn("eglQueryAPI", &[])),
  468|      0|QueryContext: FnPtr::new(metaloadfn("eglQueryContext", &[])),
  469|      0|QueryDeviceAttribEXT: FnPtr::new(metaloadfn("eglQueryDeviceAttribEXT", &[])),
  470|      0|QueryDeviceStringEXT: FnPtr::new(metaloadfn("eglQueryDeviceStringEXT", &[])),
  471|      0|QueryDevicesEXT: FnPtr::new(metaloadfn("eglQueryDevicesEXT", &[])),
  472|      0|QueryDisplayAttribEXT: FnPtr::new(metaloadfn("eglQueryDisplayAttribEXT", &[])),
  473|      0|QueryDisplayAttribKHR: FnPtr::new(metaloadfn("eglQueryDisplayAttribKHR", &["eglQueryDisplayAttribEXT", "eglQueryDisplayAttribNV"])),
  474|      0|QueryString: FnPtr::new(metaloadfn("eglQueryString", &[])),
  475|      0|QuerySurface: FnPtr::new(metaloadfn("eglQuerySurface", &[])),
  476|      0|ReleaseTexImage: FnPtr::new(metaloadfn("eglReleaseTexImage", &[])),
  477|      0|ReleaseThread: FnPtr::new(metaloadfn("eglReleaseThread", &[])),
  478|      0|SurfaceAttrib: FnPtr::new(metaloadfn("eglSurfaceAttrib", &[])),
  479|      0|SwapBuffers: FnPtr::new(metaloadfn("eglSwapBuffers", &[])),
  480|      0|SwapBuffersWithDamageEXT: FnPtr::new(metaloadfn("eglSwapBuffersWithDamageEXT", &[])),
  481|      0|SwapBuffersWithDamageKHR: FnPtr::new(metaloadfn("eglSwapBuffersWithDamageKHR", &[])),
  482|      0|SwapInterval: FnPtr::new(metaloadfn("eglSwapInterval", &[])),
  483|      0|Terminate: FnPtr::new(metaloadfn("eglTerminate", &[])),
  484|      0|WaitClient: FnPtr::new(metaloadfn("eglWaitClient", &[])),
  485|      0|WaitGL: FnPtr::new(metaloadfn("eglWaitGL", &[])),
  486|      0|WaitNative: FnPtr::new(metaloadfn("eglWaitNative", &[])),
  487|      0|WaitSync: FnPtr::new(metaloadfn("eglWaitSync", &[])),
  488|      0|WaitSyncKHR: FnPtr::new(metaloadfn("eglWaitSyncKHR", &[])),
  489|      0|_priv: ()
  490|      0|}
  491|      0|        }
  492|       |#[allow(non_snake_case, unused_variables, dead_code)]
  493|      0|            #[inline] pub unsafe fn BindAPI(&self, api: types::EGLenum) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLenum) -> types::EGLBoolean>(self.BindAPI.f)(api) }
  494|       |#[allow(non_snake_case, unused_variables, dead_code)]
  495|      0|            #[inline] pub unsafe fn BindTexImage(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, buffer: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint) -> types::EGLBoolean>(self.BindTexImage.f)(dpy, surface, buffer) }
  496|       |#[allow(non_snake_case, unused_variables, dead_code)]
  497|      0|            #[inline] pub unsafe fn ChooseConfig(&self, dpy: types::EGLDisplay, attrib_list: *const types::EGLint, configs: *mut types::EGLConfig, config_size: types::EGLint, num_config: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, *const types::EGLint, *mut types::EGLConfig, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.ChooseConfig.f)(dpy, attrib_list, configs, config_size, num_config) }
  498|       |#[allow(non_snake_case, unused_variables, dead_code)]
  499|      0|            #[inline] pub unsafe fn ClientWaitSync(&self, dpy: types::EGLDisplay, sync: types::EGLSync, flags: types::EGLint, timeout: types::EGLTime) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync, types::EGLint, types::EGLTime) -> types::EGLint>(self.ClientWaitSync.f)(dpy, sync, flags, timeout) }
  500|       |#[allow(non_snake_case, unused_variables, dead_code)]
  501|      0|            #[inline] pub unsafe fn ClientWaitSyncKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, flags: types::EGLint, timeout: types::EGLTimeKHR) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint, types::EGLTimeKHR) -> types::EGLint>(self.ClientWaitSyncKHR.f)(dpy, sync, flags, timeout) }
  502|       |#[allow(non_snake_case, unused_variables, dead_code)]
  503|      0|            #[inline] pub unsafe fn CopyBuffers(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, target: types::EGLNativePixmapType) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLNativePixmapType) -> types::EGLBoolean>(self.CopyBuffers.f)(dpy, surface, target) }
  504|       |#[allow(non_snake_case, unused_variables, dead_code)]
  505|      0|            #[inline] pub unsafe fn CreateContext(&self, dpy: types::EGLDisplay, config: types::EGLConfig, share_context: types::EGLContext, attrib_list: *const types::EGLint) -> types::EGLContext { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLContext, *const types::EGLint) -> types::EGLContext>(self.CreateContext.f)(dpy, config, share_context, attrib_list) }
  506|       |#[allow(non_snake_case, unused_variables, dead_code)]
  507|      0|            #[inline] pub unsafe fn CreateImage(&self, dpy: types::EGLDisplay, ctx: types::EGLContext, target: types::EGLenum, buffer: types::EGLClientBuffer, attrib_list: *const types::EGLAttrib) -> types::EGLImage { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLContext, types::EGLenum, types::EGLClientBuffer, *const types::EGLAttrib) -> types::EGLImage>(self.CreateImage.f)(dpy, ctx, target, buffer, attrib_list) }
  508|       |#[allow(non_snake_case, unused_variables, dead_code)]
  509|      0|            #[inline] pub unsafe fn CreatePbufferFromClientBuffer(&self, dpy: types::EGLDisplay, buftype: types::EGLenum, buffer: types::EGLClientBuffer, config: types::EGLConfig, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLenum, types::EGLClientBuffer, types::EGLConfig, *const types::EGLint) -> types::EGLSurface>(self.CreatePbufferFromClientBuffer.f)(dpy, buftype, buffer, config, attrib_list) }
  510|       |#[allow(non_snake_case, unused_variables, dead_code)]
  511|      0|            #[inline] pub unsafe fn CreatePbufferSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *const types::EGLint) -> types::EGLSurface>(self.CreatePbufferSurface.f)(dpy, config, attrib_list) }
  512|       |#[allow(non_snake_case, unused_variables, dead_code)]
  513|      0|            #[inline] pub unsafe fn CreatePixmapSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, pixmap: types::EGLNativePixmapType, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLNativePixmapType, *const types::EGLint) -> types::EGLSurface>(self.CreatePixmapSurface.f)(dpy, config, pixmap, attrib_list) }
  514|       |#[allow(non_snake_case, unused_variables, dead_code)]
  515|      0|            #[inline] pub unsafe fn CreatePlatformPixmapSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_pixmap: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -> types::EGLSurface>(self.CreatePlatformPixmapSurface.f)(dpy, config, native_pixmap, attrib_list) }
  516|       |#[allow(non_snake_case, unused_variables, dead_code)]
  517|      0|            #[inline] pub unsafe fn CreatePlatformPixmapSurfaceEXT(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_pixmap: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLint) -> types::EGLSurface>(self.CreatePlatformPixmapSurfaceEXT.f)(dpy, config, native_pixmap, attrib_list) }
  518|       |#[allow(non_snake_case, unused_variables, dead_code)]
  519|      0|            #[inline] pub unsafe fn CreatePlatformWindowSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_window: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -> types::EGLSurface>(self.CreatePlatformWindowSurface.f)(dpy, config, native_window, attrib_list) }
  520|       |#[allow(non_snake_case, unused_variables, dead_code)]
  521|      0|            #[inline] pub unsafe fn CreatePlatformWindowSurfaceEXT(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_window: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLint) -> types::EGLSurface>(self.CreatePlatformWindowSurfaceEXT.f)(dpy, config, native_window, attrib_list) }
  522|       |#[allow(non_snake_case, unused_variables, dead_code)]
  523|      0|            #[inline] pub unsafe fn CreateSync(&self, dpy: types::EGLDisplay, type_: types::EGLenum, attrib_list: *const types::EGLAttrib) -> types::EGLSync { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLenum, *const types::EGLAttrib) -> types::EGLSync>(self.CreateSync.f)(dpy, type_, attrib_list) }
  524|       |#[allow(non_snake_case, unused_variables, dead_code)]
  525|      0|            #[inline] pub unsafe fn CreateSyncKHR(&self, dpy: types::EGLDisplay, type_: types::EGLenum, attrib_list: *const types::EGLint) -> types::EGLSyncKHR { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLenum, *const types::EGLint) -> types::EGLSyncKHR>(self.CreateSyncKHR.f)(dpy, type_, attrib_list) }
  526|       |#[allow(non_snake_case, unused_variables, dead_code)]
  527|      0|            #[inline] pub unsafe fn CreateWindowSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, win: types::EGLNativeWindowType, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLNativeWindowType, *const types::EGLint) -> types::EGLSurface>(self.CreateWindowSurface.f)(dpy, config, win, attrib_list) }
  528|       |#[allow(non_snake_case, unused_variables, dead_code)]
  529|      0|            #[inline] pub unsafe fn DestroyContext(&self, dpy: types::EGLDisplay, ctx: types::EGLContext) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLContext) -> types::EGLBoolean>(self.DestroyContext.f)(dpy, ctx) }
  530|       |#[allow(non_snake_case, unused_variables, dead_code)]
  531|      0|            #[inline] pub unsafe fn DestroyImage(&self, dpy: types::EGLDisplay, image: types::EGLImage) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLImage) -> types::EGLBoolean>(self.DestroyImage.f)(dpy, image) }
  532|       |#[allow(non_snake_case, unused_variables, dead_code)]
  533|      0|            #[inline] pub unsafe fn DestroySurface(&self, dpy: types::EGLDisplay, surface: types::EGLSurface) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface) -> types::EGLBoolean>(self.DestroySurface.f)(dpy, surface) }
  534|       |#[allow(non_snake_case, unused_variables, dead_code)]
  535|      0|            #[inline] pub unsafe fn DestroySync(&self, dpy: types::EGLDisplay, sync: types::EGLSync) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync) -> types::EGLBoolean>(self.DestroySync.f)(dpy, sync) }
  536|       |#[allow(non_snake_case, unused_variables, dead_code)]
  537|      0|            #[inline] pub unsafe fn DestroySyncKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR) -> types::EGLBoolean>(self.DestroySyncKHR.f)(dpy, sync) }
  538|       |#[allow(non_snake_case, unused_variables, dead_code)]
  539|      0|            #[inline] pub unsafe fn DupNativeFenceFDANDROID(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR) -> types::EGLint>(self.DupNativeFenceFDANDROID.f)(dpy, sync) }
  540|       |#[allow(non_snake_case, unused_variables, dead_code)]
  541|      0|            #[inline] pub unsafe fn GetConfigAttrib(&self, dpy: types::EGLDisplay, config: types::EGLConfig, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.GetConfigAttrib.f)(dpy, config, attribute, value) }
  542|       |#[allow(non_snake_case, unused_variables, dead_code)]
  543|      0|            #[inline] pub unsafe fn GetConfigs(&self, dpy: types::EGLDisplay, configs: *mut types::EGLConfig, config_size: types::EGLint, num_config: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, *mut types::EGLConfig, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.GetConfigs.f)(dpy, configs, config_size, num_config) }
  544|       |#[allow(non_snake_case, unused_variables, dead_code)]
  545|      0|            #[inline] pub unsafe fn GetCurrentContext(&self, ) -> types::EGLContext { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLContext>(self.GetCurrentContext.f)() }
  546|       |#[allow(non_snake_case, unused_variables, dead_code)]
  547|      0|            #[inline] pub unsafe fn GetCurrentDisplay(&self, ) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLDisplay>(self.GetCurrentDisplay.f)() }
  548|       |#[allow(non_snake_case, unused_variables, dead_code)]
  549|      0|            #[inline] pub unsafe fn GetCurrentSurface(&self, readdraw: types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLint) -> types::EGLSurface>(self.GetCurrentSurface.f)(readdraw) }
  550|       |#[allow(non_snake_case, unused_variables, dead_code)]
  551|      0|            #[inline] pub unsafe fn GetDisplay(&self, display_id: types::EGLNativeDisplayType) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLNativeDisplayType) -> types::EGLDisplay>(self.GetDisplay.f)(display_id) }
  552|       |#[allow(non_snake_case, unused_variables, dead_code)]
  553|      0|            #[inline] pub unsafe fn GetError(&self, ) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLint>(self.GetError.f)() }
  554|       |#[allow(non_snake_case, unused_variables, dead_code)]
  555|      0|            #[inline] pub unsafe fn GetPlatformDisplay(&self, platform: types::EGLenum, native_display: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLenum, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -> types::EGLDisplay>(self.GetPlatformDisplay.f)(platform, native_display, attrib_list) }
  556|       |#[allow(non_snake_case, unused_variables, dead_code)]
  557|      0|            #[inline] pub unsafe fn GetPlatformDisplayEXT(&self, platform: types::EGLenum, native_display: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLenum, *mut __gl_imports::raw::c_void, *const types::EGLint) -> types::EGLDisplay>(self.GetPlatformDisplayEXT.f)(platform, native_display, attrib_list) }
  558|       |#[allow(non_snake_case, unused_variables, dead_code)]
  559|      0|            #[inline] pub unsafe fn GetProcAddress(&self, procname: *const __gl_imports::raw::c_char) -> types::__eglMustCastToProperFunctionPointerType { __gl_imports::mem::transmute::<_, extern "system" fn(*const __gl_imports::raw::c_char) -> types::__eglMustCastToProperFunctionPointerType>(self.GetProcAddress.f)(procname) }
  560|       |#[allow(non_snake_case, unused_variables, dead_code)]
  561|      0|            #[inline] pub unsafe fn GetSyncAttrib(&self, dpy: types::EGLDisplay, sync: types::EGLSync, attribute: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.GetSyncAttrib.f)(dpy, sync, attribute, value) }
  562|       |#[allow(non_snake_case, unused_variables, dead_code)]
  563|      0|            #[inline] pub unsafe fn GetSyncAttribKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.GetSyncAttribKHR.f)(dpy, sync, attribute, value) }
  564|       |#[allow(non_snake_case, unused_variables, dead_code)]
  565|      0|            #[inline] pub unsafe fn Initialize(&self, dpy: types::EGLDisplay, major: *mut types::EGLint, minor: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, *mut types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.Initialize.f)(dpy, major, minor) }
  566|       |#[allow(non_snake_case, unused_variables, dead_code)]
  567|      0|            #[inline] pub unsafe fn MakeCurrent(&self, dpy: types::EGLDisplay, draw: types::EGLSurface, read: types::EGLSurface, ctx: types::EGLContext) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLSurface, types::EGLContext) -> types::EGLBoolean>(self.MakeCurrent.f)(dpy, draw, read, ctx) }
  568|       |#[allow(non_snake_case, unused_variables, dead_code)]
  569|      0|            #[inline] pub unsafe fn QueryAPI(&self, ) -> types::EGLenum { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLenum>(self.QueryAPI.f)() }
  570|       |#[allow(non_snake_case, unused_variables, dead_code)]
  571|      0|            #[inline] pub unsafe fn QueryContext(&self, dpy: types::EGLDisplay, ctx: types::EGLContext, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLContext, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.QueryContext.f)(dpy, ctx, attribute, value) }
  572|       |#[allow(non_snake_case, unused_variables, dead_code)]
  573|      0|            #[inline] pub unsafe fn QueryDeviceAttribEXT(&self, device: types::EGLDeviceEXT, attribute: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDeviceEXT, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.QueryDeviceAttribEXT.f)(device, attribute, value) }
  574|       |#[allow(non_snake_case, unused_variables, dead_code)]
  575|      0|            #[inline] pub unsafe fn QueryDeviceStringEXT(&self, device: types::EGLDeviceEXT, name: types::EGLint) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDeviceEXT, types::EGLint) -> *const __gl_imports::raw::c_char>(self.QueryDeviceStringEXT.f)(device, name) }
  576|       |#[allow(non_snake_case, unused_variables, dead_code)]
  577|      0|            #[inline] pub unsafe fn QueryDevicesEXT(&self, max_devices: types::EGLint, devices: *mut types::EGLDeviceEXT, num_devices: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLint, *mut types::EGLDeviceEXT, *mut types::EGLint) -> types::EGLBoolean>(self.QueryDevicesEXT.f)(max_devices, devices, num_devices) }
  578|       |#[allow(non_snake_case, unused_variables, dead_code)]
  579|      0|            #[inline] pub unsafe fn QueryDisplayAttribEXT(&self, dpy: types::EGLDisplay, attribute: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.QueryDisplayAttribEXT.f)(dpy, attribute, value) }
  580|       |#[allow(non_snake_case, unused_variables, dead_code)]
  581|      0|            #[inline] pub unsafe fn QueryDisplayAttribKHR(&self, dpy: types::EGLDisplay, name: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.QueryDisplayAttribKHR.f)(dpy, name, value) }
  582|       |#[allow(non_snake_case, unused_variables, dead_code)]
  583|      0|            #[inline] pub unsafe fn QueryString(&self, dpy: types::EGLDisplay, name: types::EGLint) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint) -> *const __gl_imports::raw::c_char>(self.QueryString.f)(dpy, name) }
  584|       |#[allow(non_snake_case, unused_variables, dead_code)]
  585|      0|            #[inline] pub unsafe fn QuerySurface(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.QuerySurface.f)(dpy, surface, attribute, value) }
  586|       |#[allow(non_snake_case, unused_variables, dead_code)]
  587|      0|            #[inline] pub unsafe fn ReleaseTexImage(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, buffer: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint) -> types::EGLBoolean>(self.ReleaseTexImage.f)(dpy, surface, buffer) }
  588|       |#[allow(non_snake_case, unused_variables, dead_code)]
  589|      0|            #[inline] pub unsafe fn ReleaseThread(&self, ) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLBoolean>(self.ReleaseThread.f)() }
  590|       |#[allow(non_snake_case, unused_variables, dead_code)]
  591|      0|            #[inline] pub unsafe fn SurfaceAttrib(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, attribute: types::EGLint, value: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint, types::EGLint) -> types::EGLBoolean>(self.SurfaceAttrib.f)(dpy, surface, attribute, value) }
  592|       |#[allow(non_snake_case, unused_variables, dead_code)]
  593|      0|            #[inline] pub unsafe fn SwapBuffers(&self, dpy: types::EGLDisplay, surface: types::EGLSurface) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface) -> types::EGLBoolean>(self.SwapBuffers.f)(dpy, surface) }
  594|       |#[allow(non_snake_case, unused_variables, dead_code)]
  595|      0|            #[inline] pub unsafe fn SwapBuffersWithDamageEXT(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, rects: *mut types::EGLint, n_rects: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, *mut types::EGLint, types::EGLint) -> types::EGLBoolean>(self.SwapBuffersWithDamageEXT.f)(dpy, surface, rects, n_rects) }
  596|       |#[allow(non_snake_case, unused_variables, dead_code)]
  597|      0|            #[inline] pub unsafe fn SwapBuffersWithDamageKHR(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, rects: *mut types::EGLint, n_rects: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, *mut types::EGLint, types::EGLint) -> types::EGLBoolean>(self.SwapBuffersWithDamageKHR.f)(dpy, surface, rects, n_rects) }
  598|       |#[allow(non_snake_case, unused_variables, dead_code)]
  599|      0|            #[inline] pub unsafe fn SwapInterval(&self, dpy: types::EGLDisplay, interval: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint) -> types::EGLBoolean>(self.SwapInterval.f)(dpy, interval) }
  600|       |#[allow(non_snake_case, unused_variables, dead_code)]
  601|      0|            #[inline] pub unsafe fn Terminate(&self, dpy: types::EGLDisplay) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay) -> types::EGLBoolean>(self.Terminate.f)(dpy) }
  602|       |#[allow(non_snake_case, unused_variables, dead_code)]
  603|      0|            #[inline] pub unsafe fn WaitClient(&self, ) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLBoolean>(self.WaitClient.f)() }
  604|       |#[allow(non_snake_case, unused_variables, dead_code)]
  605|      0|            #[inline] pub unsafe fn WaitGL(&self, ) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLBoolean>(self.WaitGL.f)() }
  606|       |#[allow(non_snake_case, unused_variables, dead_code)]
  607|      0|            #[inline] pub unsafe fn WaitNative(&self, engine: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLint) -> types::EGLBoolean>(self.WaitNative.f)(engine) }
  608|       |#[allow(non_snake_case, unused_variables, dead_code)]
  609|      0|            #[inline] pub unsafe fn WaitSync(&self, dpy: types::EGLDisplay, sync: types::EGLSync, flags: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync, types::EGLint) -> types::EGLBoolean>(self.WaitSync.f)(dpy, sync, flags) }
  610|       |#[allow(non_snake_case, unused_variables, dead_code)]
  611|      0|            #[inline] pub unsafe fn WaitSyncKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, flags: types::EGLint) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint) -> types::EGLint>(self.WaitSyncKHR.f)(dpy, sync, flags) }
  612|       |}
  613|       |
  614|       |        unsafe impl __gl_imports::Send for Egl {}

c:\language\mdmdview\target\llvm-cov-target\debug\build\glutin_wgl_sys-10af08ee4ccaf0a2\out\wgl_extra_bindings.rs:
    1|       |
    2|       |        mod __gl_imports {
    3|       |            pub use std::mem;
    4|       |            pub use std::marker::Send;
    5|       |            pub use std::os::raw;
    6|       |        }
    7|       |    
    8|       |
    9|       |        pub mod types {
   10|       |            #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)]
   11|       |    
   12|       |// Common types from OpenGL 1.1
   13|       |pub type GLenum = super::__gl_imports::raw::c_uint;
   14|       |pub type GLboolean = super::__gl_imports::raw::c_uchar;
   15|       |pub type GLbitfield = super::__gl_imports::raw::c_uint;
   16|       |pub type GLvoid = super::__gl_imports::raw::c_void;
   17|       |pub type GLbyte = super::__gl_imports::raw::c_char;
   18|       |pub type GLshort = super::__gl_imports::raw::c_short;
   19|       |pub type GLint = super::__gl_imports::raw::c_int;
   20|       |pub type GLclampx = super::__gl_imports::raw::c_int;
   21|       |pub type GLubyte = super::__gl_imports::raw::c_uchar;
   22|       |pub type GLushort = super::__gl_imports::raw::c_ushort;
   23|       |pub type GLuint = super::__gl_imports::raw::c_uint;
   24|       |pub type GLsizei = super::__gl_imports::raw::c_int;
   25|       |pub type GLfloat = super::__gl_imports::raw::c_float;
   26|       |pub type GLclampf = super::__gl_imports::raw::c_float;
   27|       |pub type GLdouble = super::__gl_imports::raw::c_double;
   28|       |pub type GLclampd = super::__gl_imports::raw::c_double;
   29|       |pub type GLeglImageOES = *const super::__gl_imports::raw::c_void;
   30|       |pub type GLchar = super::__gl_imports::raw::c_char;
   31|       |pub type GLcharARB = super::__gl_imports::raw::c_char;
   32|       |
   33|       |#[cfg(target_os = "macos")]
   34|       |pub type GLhandleARB = *const super::__gl_imports::raw::c_void;
   35|       |#[cfg(not(target_os = "macos"))]
   36|       |pub type GLhandleARB = super::__gl_imports::raw::c_uint;
   37|       |
   38|       |pub type GLhalfARB = super::__gl_imports::raw::c_ushort;
   39|       |pub type GLhalf = super::__gl_imports::raw::c_ushort;
   40|       |
   41|       |// Must be 32 bits
   42|       |pub type GLfixed = GLint;
   43|       |
   44|       |pub type GLintptr = isize;
   45|       |pub type GLsizeiptr = isize;
   46|       |pub type GLint64 = i64;
   47|       |pub type GLuint64 = u64;
   48|       |pub type GLintptrARB = isize;
   49|       |pub type GLsizeiptrARB = isize;
   50|       |pub type GLint64EXT = i64;
   51|       |pub type GLuint64EXT = u64;
   52|       |
   53|       |pub enum __GLsync {}
   54|       |pub type GLsync = *const __GLsync;
   55|       |
   56|       |// compatible with OpenCL cl_context
   57|       |pub enum _cl_context {}
   58|       |pub enum _cl_event {}
   59|       |
   60|       |pub type GLDEBUGPROC = Option<extern "system" fn(source: GLenum,
   61|       |                                                 gltype: GLenum,
   62|       |                                                 id: GLuint,
   63|       |                                                 severity: GLenum,
   64|       |                                                 length: GLsizei,
   65|       |                                                 message: *const GLchar,
   66|       |                                                 userParam: *mut super::__gl_imports::raw::c_void)>;
   67|       |pub type GLDEBUGPROCARB = Option<extern "system" fn(source: GLenum,
   68|       |                                                    gltype: GLenum,
   69|       |                                                    id: GLuint,
   70|       |                                                    severity: GLenum,
   71|       |                                                    length: GLsizei,
   72|       |                                                    message: *const GLchar,
   73|       |                                                    userParam: *mut super::__gl_imports::raw::c_void)>;
   74|       |pub type GLDEBUGPROCKHR = Option<extern "system" fn(source: GLenum,
   75|       |                                                    gltype: GLenum,
   76|       |                                                    id: GLuint,
   77|       |                                                    severity: GLenum,
   78|       |                                                    length: GLsizei,
   79|       |                                                    message: *const GLchar,
   80|       |                                                    userParam: *mut super::__gl_imports::raw::c_void)>;
   81|       |
   82|       |// GLES 1 types
   83|       |// "pub type GLclampx = i32;",
   84|       |
   85|       |// GLES 1/2 types (tagged for GLES 1)
   86|       |// "pub type GLbyte = i8;",
   87|       |// "pub type GLubyte = u8;",
   88|       |// "pub type GLfloat = GLfloat;",
   89|       |// "pub type GLclampf = GLfloat;",
   90|       |// "pub type GLfixed = i32;",
   91|       |// "pub type GLint64 = i64;",
   92|       |// "pub type GLuint64 = u64;",
   93|       |// "pub type GLintptr = intptr_t;",
   94|       |// "pub type GLsizeiptr = ssize_t;",
   95|       |
   96|       |// GLES 1/2 types (tagged for GLES 2 - attribute syntax is limited)
   97|       |// "pub type GLbyte = i8;",
   98|       |// "pub type GLubyte = u8;",
   99|       |// "pub type GLfloat = GLfloat;",
  100|       |// "pub type GLclampf = GLfloat;",
  101|       |// "pub type GLfixed = i32;",
  102|       |// "pub type GLint64 = i64;",
  103|       |// "pub type GLuint64 = u64;",
  104|       |// "pub type GLint64EXT = i64;",
  105|       |// "pub type GLuint64EXT = u64;",
  106|       |// "pub type GLintptr = intptr_t;",
  107|       |// "pub type GLsizeiptr = ssize_t;",
  108|       |
  109|       |// GLES 2 types (none currently)
  110|       |
  111|       |// Vendor extension types
  112|       |pub type GLDEBUGPROCAMD = Option<extern "system" fn(id: GLuint,
  113|       |                                                    category: GLenum,
  114|       |                                                    severity: GLenum,
  115|       |                                                    length: GLsizei,
  116|       |                                                    message: *const GLchar,
  117|       |                                                    userParam: *mut super::__gl_imports::raw::c_void)>;
  118|       |pub type GLhalfNV = super::__gl_imports::raw::c_ushort;
  119|       |pub type GLvdpauSurfaceNV = GLintptr;
  120|       |
  121|       |// From WinNT.h
  122|       |
  123|       |pub type CHAR = super::__gl_imports::raw::c_char;
  124|       |pub type HANDLE = PVOID;
  125|       |pub type LONG = super::__gl_imports::raw::c_long;
  126|       |pub type LPCSTR = *const super::__gl_imports::raw::c_char;
  127|       |pub type VOID = ();
  128|       |// #define DECLARE_HANDLE(name) struct name##__{int unused;}; typedef struct name##__ *name
  129|       |pub type HPBUFFERARB = *const super::__gl_imports::raw::c_void;
  130|       |pub type HPBUFFEREXT = *const super::__gl_imports::raw::c_void;
  131|       |pub type HVIDEOOUTPUTDEVICENV = *const super::__gl_imports::raw::c_void;
  132|       |pub type HPVIDEODEV = *const super::__gl_imports::raw::c_void;
  133|       |pub type HPGPUNV = *const super::__gl_imports::raw::c_void;
  134|       |pub type HGPUNV = *const super::__gl_imports::raw::c_void;
  135|       |pub type HVIDEOINPUTDEVICENV = *const super::__gl_imports::raw::c_void;
  136|       |
  137|       |// From Windef.h
  138|       |
  139|       |pub type BOOL = super::__gl_imports::raw::c_int;
  140|       |pub type BYTE = super::__gl_imports::raw::c_uchar;
  141|       |pub type COLORREF = DWORD;
  142|       |pub type FLOAT = super::__gl_imports::raw::c_float;
  143|       |pub type HDC = HANDLE;
  144|       |pub type HENHMETAFILE = HANDLE;
  145|       |pub type HGLRC = *const super::__gl_imports::raw::c_void;
  146|       |pub type INT = super::__gl_imports::raw::c_int;
  147|       |pub type PVOID = *const super::__gl_imports::raw::c_void;
  148|       |pub type LPVOID = *const super::__gl_imports::raw::c_void;
  149|       |pub enum __PROC_fn {}
  150|       |pub type PROC = *mut __PROC_fn;
  151|       |
  152|       |#[repr(C)]
  153|       |pub struct RECT {
  154|       |    left: LONG,
  155|       |    top: LONG,
  156|       |    right: LONG,
  157|       |    bottom: LONG,
  158|       |}
  159|       |
  160|       |pub type UINT = super::__gl_imports::raw::c_uint;
  161|       |pub type USHORT = super::__gl_imports::raw::c_ushort;
  162|       |pub type WORD = super::__gl_imports::raw::c_ushort;
  163|       |
  164|       |// From BaseTsd.h
  165|       |
  166|       |pub type INT32 = i32;
  167|       |pub type INT64 = i64;
  168|       |
  169|       |// From IntSafe.h
  170|       |
  171|       |pub type DWORD = super::__gl_imports::raw::c_ulong;
  172|       |
  173|       |// From Wingdi.h
  174|       |
  175|       |#[repr(C)]
  176|       |pub struct POINTFLOAT {
  177|       |    pub x: FLOAT,
  178|       |    pub y: FLOAT,
  179|       |}
  180|       |
  181|       |#[repr(C)]
  182|       |pub struct GLYPHMETRICSFLOAT {
  183|       |    pub gmfBlackBoxX: FLOAT,
  184|       |    pub gmfBlackBoxY: FLOAT,
  185|       |    pub gmfptGlyphOrigin: POINTFLOAT,
  186|       |    pub gmfCellIncX: FLOAT,
  187|       |    pub gmfCellIncY: FLOAT,
  188|       |}
  189|       |pub type LPGLYPHMETRICSFLOAT = *const GLYPHMETRICSFLOAT;
  190|       |
  191|       |#[repr(C)]
  192|       |pub struct LAYERPLANEDESCRIPTOR {
  193|       |    pub nSize: WORD,
  194|       |    pub nVersion: WORD,
  195|       |    pub dwFlags: DWORD,
  196|       |    pub iPixelType: BYTE,
  197|       |    pub cColorBits: BYTE,
  198|       |    pub cRedBits: BYTE,
  199|       |    pub cRedShift: BYTE,
  200|       |    pub cGreenBits: BYTE,
  201|       |    pub cGreenShift: BYTE,
  202|       |    pub cBlueBits: BYTE,
  203|       |    pub cBlueShift: BYTE,
  204|       |    pub cAlphaBits: BYTE,
  205|       |    pub cAlphaShift: BYTE,
  206|       |    pub cAccumBits: BYTE,
  207|       |    pub cAccumRedBits: BYTE,
  208|       |    pub cAccumGreenBits: BYTE,
  209|       |    pub cAccumBlueBits: BYTE,
  210|       |    pub cAccumAlphaBits: BYTE,
  211|       |    pub cDepthBits: BYTE,
  212|       |    pub cStencilBits: BYTE,
  213|       |    pub cAuxBuffers: BYTE,
  214|       |    pub iLayerType: BYTE,
  215|       |    pub bReserved: BYTE,
  216|       |    pub crTransparent: COLORREF,
  217|       |}
  218|       |
  219|       |#[repr(C)]
  220|       |pub struct PIXELFORMATDESCRIPTOR {
  221|       |    pub nSize: WORD,
  222|       |    pub nVersion: WORD,
  223|       |    pub dwFlags: DWORD,
  224|       |    pub iPixelType: BYTE,
  225|       |    pub cColorBits: BYTE,
  226|       |    pub cRedBits: BYTE,
  227|       |    pub cRedShift: BYTE,
  228|       |    pub cGreenBits: BYTE,
  229|       |    pub cGreenShift: BYTE,
  230|       |    pub cBlueBits: BYTE,
  231|       |    pub cBlueShift: BYTE,
  232|       |    pub cAlphaBits: BYTE,
  233|       |    pub cAlphaShift: BYTE,
  234|       |    pub cAccumBits: BYTE,
  235|       |    pub cAccumRedBits: BYTE,
  236|       |    pub cAccumGreenBits: BYTE,
  237|       |    pub cAccumBlueBits: BYTE,
  238|       |    pub cAccumAlphaBits: BYTE,
  239|       |    pub cDepthBits: BYTE,
  240|       |    pub cStencilBits: BYTE,
  241|       |    pub cAuxBuffers: BYTE,
  242|       |    pub iLayerType: BYTE,
  243|       |    pub bReserved: BYTE,
  244|       |    pub dwLayerMask: DWORD,
  245|       |    pub dwVisibleMask: DWORD,
  246|       |    pub dwDamageMask: DWORD,
  247|       |}
  248|       |
  249|       |#[repr(C)]
  250|       |pub struct _GPU_DEVICE {
  251|       |    cb: DWORD,
  252|       |    DeviceName: [CHAR; 32],
  253|       |    DeviceString: [CHAR; 128],
  254|       |    Flags: DWORD,
  255|       |    rcVirtualScreen: RECT,
  256|       |}
  257|       |
  258|       |pub struct GPU_DEVICE(_GPU_DEVICE);
  259|       |pub struct PGPU_DEVICE(*const _GPU_DEVICE);
  260|       |
  261|       |}
  262|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCELERATION_ARB: types::GLenum = 0x2003;
  263|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_ALPHA_BITS_ARB: types::GLenum = 0x2021;
  264|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_BITS_ARB: types::GLenum = 0x201D;
  265|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_BLUE_BITS_ARB: types::GLenum = 0x2020;
  266|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_GREEN_BITS_ARB: types::GLenum = 0x201F;
  267|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_RED_BITS_ARB: types::GLenum = 0x201E;
  268|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_BITS_ARB: types::GLenum = 0x201B;
  269|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_SHIFT_ARB: types::GLenum = 0x201C;
  270|       |#[allow(dead_code, non_upper_case_globals)] pub const AUX_BUFFERS_ARB: types::GLenum = 0x2024;
  271|       |#[allow(dead_code, non_upper_case_globals)] pub const BLUE_BITS_ARB: types::GLenum = 0x2019;
  272|       |#[allow(dead_code, non_upper_case_globals)] pub const BLUE_SHIFT_ARB: types::GLenum = 0x201A;
  273|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_BITS_ARB: types::GLenum = 0x2014;
  274|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB: types::GLenum = 0x00000002;
  275|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CORE_PROFILE_BIT_ARB: types::GLenum = 0x00000001;
  276|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_DEBUG_BIT_ARB: types::GLenum = 0x00000001;
  277|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_ES2_PROFILE_BIT_EXT: types::GLenum = 0x00000004;
  278|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FLAGS_ARB: types::GLenum = 0x2094;
  279|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FORWARD_COMPATIBLE_BIT_ARB: types::GLenum = 0x00000002;
  280|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_LAYER_PLANE_ARB: types::GLenum = 0x2093;
  281|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION_ARB: types::GLenum = 0x2091;
  282|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION_ARB: types::GLenum = 0x2092;
  283|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_NO_ERROR_ARB: types::GLenum = 0x31B3;
  284|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_PROFILE_MASK_ARB: types::GLenum = 0x9126;
  285|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_ARB: types::GLenum = 0x2097;
  286|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB: types::GLenum = 0x2098;
  287|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_NONE_ARB: types::GLenum = 0;
  288|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB: types::GLenum = 0x8256;
  289|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_ROBUST_ACCESS_BIT_ARB: types::GLenum = 0x00000004;
  290|       |#[allow(dead_code, non_upper_case_globals)] pub const DEPTH_BITS_ARB: types::GLenum = 0x2022;
  291|       |#[allow(dead_code, non_upper_case_globals)] pub const DOUBLE_BUFFER_ARB: types::GLenum = 0x2011;
  292|       |#[allow(dead_code, non_upper_case_globals)] pub const DRAW_TO_BITMAP_ARB: types::GLenum = 0x2002;
  293|       |#[allow(dead_code, non_upper_case_globals)] pub const DRAW_TO_WINDOW_ARB: types::GLenum = 0x2001;
  294|       |#[allow(dead_code, non_upper_case_globals)] pub const FONT_LINES: types::GLenum = 0;
  295|       |#[allow(dead_code, non_upper_case_globals)] pub const FONT_POLYGONS: types::GLenum = 1;
  296|       |#[allow(dead_code, non_upper_case_globals)] pub const FRAMEBUFFER_SRGB_CAPABLE_ARB: types::GLenum = 0x20A9;
  297|       |#[allow(dead_code, non_upper_case_globals)] pub const FRAMEBUFFER_SRGB_CAPABLE_EXT: types::GLenum = 0x20A9;
  298|       |#[allow(dead_code, non_upper_case_globals)] pub const FULL_ACCELERATION_ARB: types::GLenum = 0x2027;
  299|       |#[allow(dead_code, non_upper_case_globals)] pub const GENERIC_ACCELERATION_ARB: types::GLenum = 0x2026;
  300|       |#[allow(dead_code, non_upper_case_globals)] pub const GREEN_BITS_ARB: types::GLenum = 0x2017;
  301|       |#[allow(dead_code, non_upper_case_globals)] pub const GREEN_SHIFT_ARB: types::GLenum = 0x2018;
  302|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_ARB: types::GLenum = 0x8252;
  303|       |#[allow(dead_code, non_upper_case_globals)] pub const NEED_PALETTE_ARB: types::GLenum = 0x2004;
  304|       |#[allow(dead_code, non_upper_case_globals)] pub const NEED_SYSTEM_PALETTE_ARB: types::GLenum = 0x2005;
  305|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_ACCELERATION_ARB: types::GLenum = 0x2025;
  306|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_ARB: types::GLenum = 0x8261;
  307|       |#[allow(dead_code, non_upper_case_globals)] pub const NUMBER_OVERLAYS_ARB: types::GLenum = 0x2008;
  308|       |#[allow(dead_code, non_upper_case_globals)] pub const NUMBER_PIXEL_FORMATS_ARB: types::GLenum = 0x2000;
  309|       |#[allow(dead_code, non_upper_case_globals)] pub const NUMBER_UNDERLAYS_ARB: types::GLenum = 0x2009;
  310|       |#[allow(dead_code, non_upper_case_globals)] pub const PIXEL_TYPE_ARB: types::GLenum = 0x2013;
  311|       |#[allow(dead_code, non_upper_case_globals)] pub const RED_BITS_ARB: types::GLenum = 0x2015;
  312|       |#[allow(dead_code, non_upper_case_globals)] pub const RED_SHIFT_ARB: types::GLenum = 0x2016;
  313|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLES_ARB: types::GLenum = 0x2042;
  314|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLE_BUFFERS_ARB: types::GLenum = 0x2041;
  315|       |#[allow(dead_code, non_upper_case_globals)] pub const SHARE_ACCUM_ARB: types::GLenum = 0x200E;
  316|       |#[allow(dead_code, non_upper_case_globals)] pub const SHARE_DEPTH_ARB: types::GLenum = 0x200C;
  317|       |#[allow(dead_code, non_upper_case_globals)] pub const SHARE_STENCIL_ARB: types::GLenum = 0x200D;
  318|       |#[allow(dead_code, non_upper_case_globals)] pub const STENCIL_BITS_ARB: types::GLenum = 0x2023;
  319|       |#[allow(dead_code, non_upper_case_globals)] pub const STEREO_ARB: types::GLenum = 0x2012;
  320|       |#[allow(dead_code, non_upper_case_globals)] pub const SUPPORT_GDI_ARB: types::GLenum = 0x200F;
  321|       |#[allow(dead_code, non_upper_case_globals)] pub const SUPPORT_OPENGL_ARB: types::GLenum = 0x2010;
  322|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_COPY_ARB: types::GLenum = 0x2029;
  323|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_EXCHANGE_ARB: types::GLenum = 0x2028;
  324|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_LAYER_BUFFERS_ARB: types::GLenum = 0x2006;
  325|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_MAIN_PLANE: types::GLenum = 0x00000001;
  326|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_METHOD_ARB: types::GLenum = 0x2007;
  327|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY1: types::GLenum = 0x00000002;
  328|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY10: types::GLenum = 0x00000400;
  329|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY11: types::GLenum = 0x00000800;
  330|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY12: types::GLenum = 0x00001000;
  331|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY13: types::GLenum = 0x00002000;
  332|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY14: types::GLenum = 0x00004000;
  333|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY15: types::GLenum = 0x00008000;
  334|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY2: types::GLenum = 0x00000004;
  335|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY3: types::GLenum = 0x00000008;
  336|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY4: types::GLenum = 0x00000010;
  337|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY5: types::GLenum = 0x00000020;
  338|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY6: types::GLenum = 0x00000040;
  339|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY7: types::GLenum = 0x00000080;
  340|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY8: types::GLenum = 0x00000100;
  341|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY9: types::GLenum = 0x00000200;
  342|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDEFINED_ARB: types::GLenum = 0x202A;
  343|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY1: types::GLenum = 0x00010000;
  344|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY10: types::GLenum = 0x02000000;
  345|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY11: types::GLenum = 0x04000000;
  346|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY12: types::GLenum = 0x08000000;
  347|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY13: types::GLenum = 0x10000000;
  348|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY14: types::GLenum = 0x20000000;
  349|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY15: types::GLenum = 0x40000000;
  350|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY2: types::GLenum = 0x00020000;
  351|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY3: types::GLenum = 0x00040000;
  352|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY4: types::GLenum = 0x00080000;
  353|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY5: types::GLenum = 0x00100000;
  354|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY6: types::GLenum = 0x00200000;
  355|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY7: types::GLenum = 0x00400000;
  356|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY8: types::GLenum = 0x00800000;
  357|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY9: types::GLenum = 0x01000000;
  358|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_ALPHA_VALUE_ARB: types::GLenum = 0x203A;
  359|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_ARB: types::GLenum = 0x200A;
  360|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_BLUE_VALUE_ARB: types::GLenum = 0x2039;
  361|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_GREEN_VALUE_ARB: types::GLenum = 0x2038;
  362|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_INDEX_VALUE_ARB: types::GLenum = 0x203B;
  363|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RED_VALUE_ARB: types::GLenum = 0x2037;
  364|       |#[allow(dead_code, non_upper_case_globals)] pub const TYPE_COLORINDEX_ARB: types::GLenum = 0x202C;
  365|       |#[allow(dead_code, non_upper_case_globals)] pub const TYPE_RGBA_ARB: types::GLenum = 0x202B;
  366|       |#[allow(dead_code, non_upper_case_globals)] pub const TYPE_RGBA_FLOAT_ARB: types::GLenum = 0x21A0;
  367|       |
  368|       |        #[allow(dead_code, missing_copy_implementations)]
  369|       |        #[derive(Clone)]
  370|       |        pub struct FnPtr {
  371|       |            /// The function pointer that will be used when calling the function.
  372|       |            f: *const __gl_imports::raw::c_void,
  373|       |            /// True if the pointer points to a real function, false if points to a `panic!` fn.
  374|       |            is_loaded: bool,
  375|       |        }
  376|       |
  377|       |        impl FnPtr {
  378|       |            /// Creates a `FnPtr` from a load attempt.
  379|      0|            fn new(ptr: *const __gl_imports::raw::c_void) -> FnPtr {
  380|      0|                if ptr.is_null() {
  381|      0|                    FnPtr {
  382|      0|                        f: missing_fn_panic as *const __gl_imports::raw::c_void,
  383|      0|                        is_loaded: false
  384|      0|                    }
  385|       |                } else {
  386|      0|                    FnPtr { f: ptr, is_loaded: true }
  387|       |                }
  388|      0|            }
  389|       |
  390|       |            /// Returns `true` if the function has been successfully loaded.
  391|       |            ///
  392|       |            /// If it returns `false`, calling the corresponding function will fail.
  393|       |            #[inline]
  394|       |            #[allow(dead_code)]
  395|      0|            pub fn is_loaded(&self) -> bool {
  396|      0|                self.is_loaded
  397|      0|            }
  398|       |        }
  399|       |    
  400|       |#[inline(never)]
  401|      0|        fn missing_fn_panic() -> ! {
  402|      0|            panic!("wgl function was not loaded")
  403|       |        }
  404|       |
  405|       |        #[allow(non_camel_case_types, non_snake_case, dead_code)]
  406|       |        #[derive(Clone)]
  407|       |        pub struct Wgl {
  408|       |pub ChoosePixelFormatARB: FnPtr,
  409|       |pub CopyContext: FnPtr,
  410|       |pub CreateContext: FnPtr,
  411|       |pub CreateContextAttribsARB: FnPtr,
  412|       |pub CreateLayerContext: FnPtr,
  413|       |pub DeleteContext: FnPtr,
  414|       |pub DescribeLayerPlane: FnPtr,
  415|       |pub GetCurrentContext: FnPtr,
  416|       |pub GetCurrentDC: FnPtr,
  417|       |pub GetExtensionsStringARB: FnPtr,
  418|       |pub GetExtensionsStringEXT: FnPtr,
  419|       |pub GetLayerPaletteEntries: FnPtr,
  420|       |pub GetPixelFormatAttribfvARB: FnPtr,
  421|       |pub GetPixelFormatAttribivARB: FnPtr,
  422|       |pub GetProcAddress: FnPtr,
  423|       |pub GetSwapIntervalEXT: FnPtr,
  424|       |pub MakeCurrent: FnPtr,
  425|       |pub RealizeLayerPalette: FnPtr,
  426|       |pub SetLayerPaletteEntries: FnPtr,
  427|       |pub ShareLists: FnPtr,
  428|       |pub SwapIntervalEXT: FnPtr,
  429|       |pub SwapLayerBuffers: FnPtr,
  430|       |pub UseFontBitmaps: FnPtr,
  431|       |pub UseFontBitmapsA: FnPtr,
  432|       |pub UseFontBitmapsW: FnPtr,
  433|       |pub UseFontOutlines: FnPtr,
  434|       |pub UseFontOutlinesA: FnPtr,
  435|       |pub UseFontOutlinesW: FnPtr,
  436|       |_priv: ()
  437|       |}
  438|       |impl Wgl {
  439|       |            /// Load each OpenGL symbol using a custom load function. This allows for the
  440|       |            /// use of functions like `glfwGetProcAddress` or `SDL_GL_GetProcAddress`.
  441|       |            ///
  442|       |            /// ~~~ignore
  443|       |            /// let gl = Gl::load_with(|s| glfw.get_proc_address(s));
  444|       |            /// ~~~
  445|       |            #[allow(dead_code, unused_variables)]
  446|      0|            pub fn load_with<F>(mut loadfn: F) -> Wgl where F: FnMut(&'static str) -> *const __gl_imports::raw::c_void {
  447|       |                #[inline(never)]
  448|      0|                fn do_metaloadfn(loadfn: &mut dyn FnMut(&'static str) -> *const __gl_imports::raw::c_void,
  449|      0|                                 symbol: &'static str,
  450|      0|                                 symbols: &[&'static str])
  451|      0|                                 -> *const __gl_imports::raw::c_void {
  452|      0|                    let mut ptr = loadfn(symbol);
  453|      0|                    if ptr.is_null() {
  454|      0|                        for &sym in symbols {
  455|      0|                            ptr = loadfn(sym);
  456|      0|                            if !ptr.is_null() { break; }
  457|       |                        }
  458|      0|                    }
  459|      0|                    ptr
  460|      0|                }
  461|      0|                let mut metaloadfn = |symbol: &'static str, symbols: &[&'static str]| {
  462|      0|                    do_metaloadfn(&mut loadfn, symbol, symbols)
  463|      0|                };
  464|      0|                Wgl {
  465|      0|ChoosePixelFormatARB: FnPtr::new(metaloadfn("wglChoosePixelFormatARB", &[])),
  466|      0|CopyContext: FnPtr::new(metaloadfn("wglCopyContext", &[])),
  467|      0|CreateContext: FnPtr::new(metaloadfn("wglCreateContext", &[])),
  468|      0|CreateContextAttribsARB: FnPtr::new(metaloadfn("wglCreateContextAttribsARB", &[])),
  469|      0|CreateLayerContext: FnPtr::new(metaloadfn("wglCreateLayerContext", &[])),
  470|      0|DeleteContext: FnPtr::new(metaloadfn("wglDeleteContext", &[])),
  471|      0|DescribeLayerPlane: FnPtr::new(metaloadfn("wglDescribeLayerPlane", &[])),
  472|      0|GetCurrentContext: FnPtr::new(metaloadfn("wglGetCurrentContext", &[])),
  473|      0|GetCurrentDC: FnPtr::new(metaloadfn("wglGetCurrentDC", &[])),
  474|      0|GetExtensionsStringARB: FnPtr::new(metaloadfn("wglGetExtensionsStringARB", &[])),
  475|      0|GetExtensionsStringEXT: FnPtr::new(metaloadfn("wglGetExtensionsStringEXT", &[])),
  476|      0|GetLayerPaletteEntries: FnPtr::new(metaloadfn("wglGetLayerPaletteEntries", &[])),
  477|      0|GetPixelFormatAttribfvARB: FnPtr::new(metaloadfn("wglGetPixelFormatAttribfvARB", &[])),
  478|      0|GetPixelFormatAttribivARB: FnPtr::new(metaloadfn("wglGetPixelFormatAttribivARB", &[])),
  479|      0|GetProcAddress: FnPtr::new(metaloadfn("wglGetProcAddress", &[])),
  480|      0|GetSwapIntervalEXT: FnPtr::new(metaloadfn("wglGetSwapIntervalEXT", &[])),
  481|      0|MakeCurrent: FnPtr::new(metaloadfn("wglMakeCurrent", &[])),
  482|      0|RealizeLayerPalette: FnPtr::new(metaloadfn("wglRealizeLayerPalette", &[])),
  483|      0|SetLayerPaletteEntries: FnPtr::new(metaloadfn("wglSetLayerPaletteEntries", &[])),
  484|      0|ShareLists: FnPtr::new(metaloadfn("wglShareLists", &[])),
  485|      0|SwapIntervalEXT: FnPtr::new(metaloadfn("wglSwapIntervalEXT", &[])),
  486|      0|SwapLayerBuffers: FnPtr::new(metaloadfn("wglSwapLayerBuffers", &[])),
  487|      0|UseFontBitmaps: FnPtr::new(metaloadfn("wglUseFontBitmaps", &[])),
  488|      0|UseFontBitmapsA: FnPtr::new(metaloadfn("wglUseFontBitmapsA", &[])),
  489|      0|UseFontBitmapsW: FnPtr::new(metaloadfn("wglUseFontBitmapsW", &[])),
  490|      0|UseFontOutlines: FnPtr::new(metaloadfn("wglUseFontOutlines", &[])),
  491|      0|UseFontOutlinesA: FnPtr::new(metaloadfn("wglUseFontOutlinesA", &[])),
  492|      0|UseFontOutlinesW: FnPtr::new(metaloadfn("wglUseFontOutlinesW", &[])),
  493|      0|_priv: ()
  494|      0|}
  495|      0|        }
  496|       |#[allow(non_snake_case, unused_variables, dead_code)]
  497|      0|            #[inline] pub unsafe fn ChoosePixelFormatARB(&self, hdc: types::HDC, piAttribIList: *const __gl_imports::raw::c_int, pfAttribFList: *const types::FLOAT, nMaxFormats: types::UINT, piFormats: *mut __gl_imports::raw::c_int, nNumFormats: *mut types::UINT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, *const __gl_imports::raw::c_int, *const types::FLOAT, types::UINT, *mut __gl_imports::raw::c_int, *mut types::UINT) -> types::BOOL>(self.ChoosePixelFormatARB.f)(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats) }
  498|       |#[allow(non_snake_case, unused_variables, dead_code)]
  499|      0|            #[inline] pub unsafe fn CopyContext(&self, hglrcSrc: types::HGLRC, hglrcDst: types::HGLRC, mask: types::UINT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HGLRC, types::HGLRC, types::UINT) -> types::BOOL>(self.CopyContext.f)(hglrcSrc, hglrcDst, mask) }
  500|       |#[allow(non_snake_case, unused_variables, dead_code)]
  501|      0|            #[inline] pub unsafe fn CreateContext(&self, hDc: types::HDC) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC) -> types::HGLRC>(self.CreateContext.f)(hDc) }
  502|       |#[allow(non_snake_case, unused_variables, dead_code)]
  503|      0|            #[inline] pub unsafe fn CreateContextAttribsARB(&self, hDC: types::HDC, hShareContext: types::HGLRC, attribList: *const __gl_imports::raw::c_int) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::HGLRC, *const __gl_imports::raw::c_int) -> types::HGLRC>(self.CreateContextAttribsARB.f)(hDC, hShareContext, attribList) }
  504|       |#[allow(non_snake_case, unused_variables, dead_code)]
  505|      0|            #[inline] pub unsafe fn CreateLayerContext(&self, hDc: types::HDC, level: __gl_imports::raw::c_int) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int) -> types::HGLRC>(self.CreateLayerContext.f)(hDc, level) }
  506|       |#[allow(non_snake_case, unused_variables, dead_code)]
  507|      0|            #[inline] pub unsafe fn DeleteContext(&self, oldContext: types::HGLRC) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HGLRC) -> types::BOOL>(self.DeleteContext.f)(oldContext) }
  508|       |#[allow(non_snake_case, unused_variables, dead_code)]
  509|      0|            #[inline] pub unsafe fn DescribeLayerPlane(&self, hDc: types::HDC, pixelFormat: __gl_imports::raw::c_int, layerPlane: __gl_imports::raw::c_int, nBytes: types::UINT, plpd: *const types::LAYERPLANEDESCRIPTOR) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, types::UINT, *const types::LAYERPLANEDESCRIPTOR) -> types::BOOL>(self.DescribeLayerPlane.f)(hDc, pixelFormat, layerPlane, nBytes, plpd) }
  510|       |#[allow(non_snake_case, unused_variables, dead_code)]
  511|      0|            #[inline] pub unsafe fn GetCurrentContext(&self, ) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::HGLRC>(self.GetCurrentContext.f)() }
  512|       |#[allow(non_snake_case, unused_variables, dead_code)]
  513|      0|            #[inline] pub unsafe fn GetCurrentDC(&self, ) -> types::HDC { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::HDC>(self.GetCurrentDC.f)() }
  514|       |#[allow(non_snake_case, unused_variables, dead_code)]
  515|      0|            #[inline] pub unsafe fn GetExtensionsStringARB(&self, hdc: types::HDC) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC) -> *const __gl_imports::raw::c_char>(self.GetExtensionsStringARB.f)(hdc) }
  516|       |#[allow(non_snake_case, unused_variables, dead_code)]
  517|      0|            #[inline] pub unsafe fn GetExtensionsStringEXT(&self, ) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn() -> *const __gl_imports::raw::c_char>(self.GetExtensionsStringEXT.f)() }
  518|       |#[allow(non_snake_case, unused_variables, dead_code)]
  519|      0|            #[inline] pub unsafe fn GetLayerPaletteEntries(&self, hdc: types::HDC, iLayerPlane: __gl_imports::raw::c_int, iStart: __gl_imports::raw::c_int, cEntries: __gl_imports::raw::c_int, pcr: *const types::COLORREF) -> __gl_imports::raw::c_int { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, __gl_imports::raw::c_int, *const types::COLORREF) -> __gl_imports::raw::c_int>(self.GetLayerPaletteEntries.f)(hdc, iLayerPlane, iStart, cEntries, pcr) }
  520|       |#[allow(non_snake_case, unused_variables, dead_code)]
  521|      0|            #[inline] pub unsafe fn GetPixelFormatAttribfvARB(&self, hdc: types::HDC, iPixelFormat: __gl_imports::raw::c_int, iLayerPlane: __gl_imports::raw::c_int, nAttributes: types::UINT, piAttributes: *const __gl_imports::raw::c_int, pfValues: *mut types::FLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, types::UINT, *const __gl_imports::raw::c_int, *mut types::FLOAT) -> types::BOOL>(self.GetPixelFormatAttribfvARB.f)(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues) }
  522|       |#[allow(non_snake_case, unused_variables, dead_code)]
  523|      0|            #[inline] pub unsafe fn GetPixelFormatAttribivARB(&self, hdc: types::HDC, iPixelFormat: __gl_imports::raw::c_int, iLayerPlane: __gl_imports::raw::c_int, nAttributes: types::UINT, piAttributes: *const __gl_imports::raw::c_int, piValues: *mut __gl_imports::raw::c_int) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, types::UINT, *const __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -> types::BOOL>(self.GetPixelFormatAttribivARB.f)(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues) }
  524|       |#[allow(non_snake_case, unused_variables, dead_code)]
  525|      0|            #[inline] pub unsafe fn GetProcAddress(&self, lpszProc: types::LPCSTR) -> types::PROC { __gl_imports::mem::transmute::<_, extern "system" fn(types::LPCSTR) -> types::PROC>(self.GetProcAddress.f)(lpszProc) }
  526|       |#[allow(non_snake_case, unused_variables, dead_code)]
  527|      0|            #[inline] pub unsafe fn GetSwapIntervalEXT(&self, ) -> __gl_imports::raw::c_int { __gl_imports::mem::transmute::<_, extern "system" fn() -> __gl_imports::raw::c_int>(self.GetSwapIntervalEXT.f)() }
  528|       |#[allow(non_snake_case, unused_variables, dead_code)]
  529|      0|            #[inline] pub unsafe fn MakeCurrent(&self, hDc: types::HDC, newContext: types::HGLRC) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::HGLRC) -> types::BOOL>(self.MakeCurrent.f)(hDc, newContext) }
  530|       |#[allow(non_snake_case, unused_variables, dead_code)]
  531|      0|            #[inline] pub unsafe fn RealizeLayerPalette(&self, hdc: types::HDC, iLayerPlane: __gl_imports::raw::c_int, bRealize: types::BOOL) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, types::BOOL) -> types::BOOL>(self.RealizeLayerPalette.f)(hdc, iLayerPlane, bRealize) }
  532|       |#[allow(non_snake_case, unused_variables, dead_code)]
  533|      0|            #[inline] pub unsafe fn SetLayerPaletteEntries(&self, hdc: types::HDC, iLayerPlane: __gl_imports::raw::c_int, iStart: __gl_imports::raw::c_int, cEntries: __gl_imports::raw::c_int, pcr: *const types::COLORREF) -> __gl_imports::raw::c_int { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, __gl_imports::raw::c_int, *const types::COLORREF) -> __gl_imports::raw::c_int>(self.SetLayerPaletteEntries.f)(hdc, iLayerPlane, iStart, cEntries, pcr) }
  534|       |#[allow(non_snake_case, unused_variables, dead_code)]
  535|      0|            #[inline] pub unsafe fn ShareLists(&self, hrcSrvShare: types::HGLRC, hrcSrvSource: types::HGLRC) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HGLRC, types::HGLRC) -> types::BOOL>(self.ShareLists.f)(hrcSrvShare, hrcSrvSource) }
  536|       |#[allow(non_snake_case, unused_variables, dead_code)]
  537|      0|            #[inline] pub unsafe fn SwapIntervalEXT(&self, interval: __gl_imports::raw::c_int) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(__gl_imports::raw::c_int) -> types::BOOL>(self.SwapIntervalEXT.f)(interval) }
  538|       |#[allow(non_snake_case, unused_variables, dead_code)]
  539|      0|            #[inline] pub unsafe fn SwapLayerBuffers(&self, hdc: types::HDC, fuFlags: types::UINT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::UINT) -> types::BOOL>(self.SwapLayerBuffers.f)(hdc, fuFlags) }
  540|       |#[allow(non_snake_case, unused_variables, dead_code)]
  541|      0|            #[inline] pub unsafe fn UseFontBitmaps(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD) -> types::BOOL>(self.UseFontBitmaps.f)(hDC, first, count, listBase) }
  542|       |#[allow(non_snake_case, unused_variables, dead_code)]
  543|      0|            #[inline] pub unsafe fn UseFontBitmapsA(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD) -> types::BOOL>(self.UseFontBitmapsA.f)(hDC, first, count, listBase) }
  544|       |#[allow(non_snake_case, unused_variables, dead_code)]
  545|      0|            #[inline] pub unsafe fn UseFontBitmapsW(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD) -> types::BOOL>(self.UseFontBitmapsW.f)(hDC, first, count, listBase) }
  546|       |#[allow(non_snake_case, unused_variables, dead_code)]
  547|      0|            #[inline] pub unsafe fn UseFontOutlines(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD, deviation: types::FLOAT, extrusion: types::FLOAT, format: __gl_imports::raw::c_int, lpgmf: types::LPGLYPHMETRICSFLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD, types::FLOAT, types::FLOAT, __gl_imports::raw::c_int, types::LPGLYPHMETRICSFLOAT) -> types::BOOL>(self.UseFontOutlines.f)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf) }
  548|       |#[allow(non_snake_case, unused_variables, dead_code)]
  549|      0|            #[inline] pub unsafe fn UseFontOutlinesA(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD, deviation: types::FLOAT, extrusion: types::FLOAT, format: __gl_imports::raw::c_int, lpgmf: types::LPGLYPHMETRICSFLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD, types::FLOAT, types::FLOAT, __gl_imports::raw::c_int, types::LPGLYPHMETRICSFLOAT) -> types::BOOL>(self.UseFontOutlinesA.f)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf) }
  550|       |#[allow(non_snake_case, unused_variables, dead_code)]
  551|      0|            #[inline] pub unsafe fn UseFontOutlinesW(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD, deviation: types::FLOAT, extrusion: types::FLOAT, format: __gl_imports::raw::c_int, lpgmf: types::LPGLYPHMETRICSFLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD, types::FLOAT, types::FLOAT, __gl_imports::raw::c_int, types::LPGLYPHMETRICSFLOAT) -> types::BOOL>(self.UseFontOutlinesW.f)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf) }
  552|       |}
  553|       |
  554|       |        unsafe impl __gl_imports::Send for Wgl {}
# HLD — D2 Edge Label Placement Fix V1

Date: 2026.02.22
Revision: V1 — design review of 2026.02.21 original

## Scope

This design addresses **bug 1 only**: edge labels overlapping node boxes. It does **not** address bug 2 (edges routing through intermediate nodes), which is a separate edge-routing problem requiring a different fix.

## Problem Statement

Edge labels in our D2 renderer frequently overlap node boxes. Two root causes:

1. **Label position is computed from the enter segment only.** The current `compute_label_position()` (edge_routing.rs:716–744) uses the midpoint of the *last segment before the destination*, with a fixed 10px perpendicular offset. For multi-segment routes, the enter segment is typically short (it's the stub from the channel into the destination port), so the label lands right on top of or inside the destination node.

2. **Label dimensions are not considered during placement.** The routing code emits a bare `Point` for the label center, but never checks whether the label's bounding box (text width × height) will intersect any node. The SVG renderer estimates label size at render time (svg_render.rs:623–625) but by then it's too late to move anything.

### Visual evidence

**Screenshot 1** (horizontal architecture): Labels "HTTPS", "verify", "sessions", "route", "CRUD" all overlap their destination boxes. The labels are placed on the short enter stub that goes directly into the box.

**Screenshot 2** (vertical platform): The "route" label between API Gateway and Service overlaps the API Gateway box.

### How D2 official handles this

D2's Dagre layout places labels at a **percentage along the total route** (default 50% = midpoint). The `lib/label` package computes position by walking the polyline from start to the target percentage of total arc length, then offsets perpendicular. Labels end up in the inter-rank gap where there is space, not near either endpoint.

## Design Review: Issues Found in Original (2026.02.21)

### Issue 1 (Critical): Wrong dimension for perpendicular offset on vertical segments

The original design uses `label_height / 2 + padding` for the perpendicular offset on **all** segments. This is only correct for horizontal segments (where perpendicular = vertical). For vertical segments, the perpendicular direction is horizontal, so the offset must use `label_width / 2 + padding` to ensure the label clears the route line.

**Concrete example:** Label "HTTPS" at font_size 14:
- `label_height = 14 * 1.4 = 19.6px` (from `measure_and_wrap_label`)
- `label_width = 5 chars * 14 * 0.55 = 38.5px`
- Original offset for vertical segment: `19.6/2 + 4 = 13.8px`
- Label right edge would be at: `route_x - 13.8 + 38.5/2 = route_x + 5.45px` — **overlaps the route line by 5.45px**

**Fix:** `compute_label_position` must accept both `label_width` and `label_height`, and use the appropriate dimension per axis:
- Horizontal segment → offset by `label_height / 2 + padding` (vertical clearance)
- Vertical segment → offset by `label_width / 2 + padding` (horizontal clearance)

### Issue 2 (Critical): `font_size` not available via `RenderOptions`

The original design says "thread font_size from `RenderOptions`" but `RenderOptions` only has `dark_mode` and `font_family` — no `font_size`. The call site in `layout.rs` already derives `font_size` from `Theme::for_mode(options.dark_mode).font_size`, so the value is available, but the plumbing is wrong.

**Fix:** Don't add `font_size` to `RenderOptions`. Instead, `layout()` already has `font_size` in scope — pass it directly alongside `options`:

```rust
// layout.rs — already has these in scope:
let font_size = theme.font_size;
let font_family = &options.font_family;

// Pass both to route_all_edges:
edge_routing::route_all_edges(graph, font_size, font_family);
```

This avoids changing the public `RenderOptions` API and keeps font resolution in one place (`layout.rs`).

### Issue 3 (Moderate): Self-loop labels missing `label_width`/`label_height`

The original design only updates the orthogonal routing path. Self-loops (edge_routing.rs:70–86) have their own label positioning code and won't get `label_width`/`label_height` set, leaving them at `0.0`. The SVG renderer's fallback would catch this, but it means self-loop labels can't participate in the nudge pass.

**Fix:** After the self-loop route is computed, measure the label and store dimensions:

```rust
if src_idx == dst_idx {
    // ... existing self-loop route computation ...
    if let Some(ref label_text) = graph.graph[eidx].label {
        let m = crate::text::measure_and_wrap_label(label_text, font_size, font_family);
        graph.graph[eidx].label_width = m.width;
        graph.graph[eidx].label_height = m.height;
    }
}
```

### Issue 4 (Moderate): Nudge algorithm underspecified

The original design says "slide ±5px along the route direction" but omits:
- What happens when sliding reaches a segment endpoint (continue to next segment, or stop?)
- How to pick the slide direction (toward source or toward destination?)
- Stopping condition (first clear position, or optimal position?)
- What if no clear position exists on the entire route?

**Fix:** Specify the algorithm concretely. See "Change 3" below for the full specification.

### Issue 5 (Moderate): Endpoint nodes should not be unconditionally excluded from nudge

The original design excludes source and destination nodes from overlap checks. But for short 2-point routes, the label is at the midpoint between source and destination — if the gap is tight (e.g., `NODE_SPACING_V = 60px` with large nodes), the label could still overlap an endpoint.

**Fix:** Check **all** nodes in the nudge pass, including endpoints. But for 2-point routes where the label has nowhere to slide (the entire route is one segment between the two endpoints), accept the placement as-is — there's no better position on the route. For 3+ point routes, nudge against all nodes.

### Issue 6 (Minor): `rects_intersect` utility not defined anywhere in the crate

The nudge code references `rects_intersect` but this function doesn't exist in `geo.rs` or anywhere in `crates/d2`.

**Fix:** Add to `geo.rs`:

```rust
impl Rect {
    pub fn intersects(&self, other: &Rect) -> bool {
        self.x < other.x + other.width
            && self.x + self.width > other.x
            && self.y < other.y + other.height
            && self.y + self.height > other.y
    }
}
```

### Issue 7 (Minor): Measurement height mismatch between `text.rs` and `svg_render.rs`

`text::measure_and_wrap_label` uses `LINE_HEIGHT_FACTOR = 1.4`, giving `height = font_size * 1.4` for a single line. The SVG renderer currently uses `font_size * 1.2`. After this change, both will use the stored `label_height` from `measure_and_wrap_label`, so the mismatch is resolved. Worth noting that the halo will be ~2.8px taller than before at font_size 14 — a negligible visual change.

## Revised Design

### Change 1: Percentage-along-route placement

Replace the enter-segment heuristic with a **percentage-of-total-arc-length** approach.

**Algorithm:**

```
fn compute_label_position(
    route: &[Point],
    percentage: f64,
    label_width: f64,
    label_height: f64,
) -> Option<Point>
    1. Compute total route length: sum of Euclidean distances between
       consecutive points.
    2. Target distance = total_length * percentage.
    3. Walk segments from start, accumulating distance:
       - When accumulated + segment_length >= target_distance:
         - t = (target_distance - accumulated) / segment_length
         - label_center = lerp(segment_start, segment_end, t)
         - Determine segment orientation (horizontal vs vertical)
         - Horizontal: offset = label_height / 2 + LABEL_PADDING → shift upward
         - Vertical:   offset = label_width  / 2 + LABEL_PADDING → shift leftward
         - Return offset label_center
    4. Fallback: return midpoint of entire route (degenerate case).
```

The default percentage is **0.5** (route midpoint). This naturally places labels in the inter-rank channel, which is the longest segment for typical orthogonal routes.

**Why 50%:** For a 4-point orthogonal route (port → bend → bend → port), the midpoint falls on the channel segment — the horizontal or vertical run between the two bends — which is the open gap between ranks where no nodes live. For a 2-point straight route, the midpoint is equidistant from both nodes, also correct.

### Change 2: Label bounding box stored on edge data

Add label dimensions to `D2EdgeData` so the routing code can reason about overlap:

```rust
// In graph.rs — D2EdgeData
pub label_position: Option<Point>,
pub label_width: f64,     // NEW
pub label_height: f64,    // NEW
```

Default both to `0.0` in whatever impl handles D2EdgeData construction (there is no explicit `Default` impl for `D2EdgeData` — it's constructed directly in the compiler).

Compute during routing using `text::measure_and_wrap_label()`:

```rust
let font_size_for_edge = graph.graph[eidx].style.font_size.unwrap_or(default_font_size);
let m = crate::text::measure_and_wrap_label(label_text, font_size_for_edge, font_family);
```

Note: `measure_and_wrap_label` ignores `font_family` internally (parameter is `_font_family`) — the char width is always `font_size * 0.55`. This is acceptable; the heuristic just needs to be consistent between routing and rendering.

The SVG renderer then reads `edge.label_width` / `edge.label_height` instead of re-estimating. This ensures the halo rect matches the clearance the routing code reserved.

### Change 3: Post-placement overlap nudge

After all label positions are computed, run a nudge pass to fix remaining overlaps.

**Full specification:**

```rust
fn nudge_overlapping_labels(graph: &mut D2Graph) {
    let node_rects: Vec<(NodeIndex, Rect)> = /* all non-root nodes with box_ */;

    for &eidx in &graph.edges {
        let edge = &graph.graph[eidx];
        let pos = match edge.label_position { Some(p) => p, None => continue };
        let route = edge.route.clone();
        let lw = edge.label_width;
        let lh = edge.label_height;
        if lw < 1.0 || lh < 1.0 { continue; }

        // For 2-point routes, there's nowhere to slide — skip nudge.
        if route.len() <= 2 { continue; }

        let pad = 3.0; // halo padding
        let label_rect = Rect::new(
            pos.x - lw / 2.0 - pad,
            pos.y - lh / 2.0 - pad,
            lw + pad * 2.0,
            lh + pad * 2.0,
        );

        // Check overlap against ALL nodes (including endpoints).
        let has_overlap = node_rects.iter()
            .any(|(_, nr)| label_rect.intersects(nr));

        if !has_overlap { continue; }

        // Slide along route to find clear position.
        // Strategy: binary-search style — try positions at 10%, 20%, ...
        // 90% along the route, pick the one with maximum clearance.
        let best = find_best_label_position(
            &route, lw, lh, pad, &node_rects,
        );
        if let Some(new_pos) = best {
            graph.graph[eidx].label_position = Some(new_pos);
        }
        // else: keep original position (no improvement found)
    }
}

fn find_best_label_position(
    route: &[Point],
    label_width: f64,
    label_height: f64,
    pad: f64,
    node_rects: &[(NodeIndex, Rect)],
) -> Option<Point> {
    let candidates = [0.5, 0.4, 0.6, 0.3, 0.7, 0.2, 0.8, 0.1, 0.9];
    //               center-out search order

    let mut best_pos: Option<Point> = None;
    let mut best_clearance: f64 = f64::NEG_INFINITY;

    for &pct in &candidates {
        let pos = compute_label_position(route, pct, label_width, label_height)?;
        let lr = Rect::new(
            pos.x - label_width / 2.0 - pad,
            pos.y - label_height / 2.0 - pad,
            label_width + pad * 2.0,
            label_height + pad * 2.0,
        );

        let overlaps = node_rects.iter().any(|(_, nr)| lr.intersects(nr));
        if !overlaps {
            return Some(pos); // First non-overlapping position wins
        }

        // Track clearance for fallback
        let min_clearance = node_rects.iter()
            .map(|(_, nr)| min_separation(&lr, nr))
            .fold(f64::INFINITY, f64::min);
        if min_clearance > best_clearance {
            best_clearance = min_clearance;
            best_pos = Some(pos);
        }
    }

    best_pos // Returns the position with most clearance, even if still overlapping
}
```

**Design rationale:**
- Center-out search order (0.5, 0.4, 0.6, ...) prefers positions near the route midpoint, which looks most natural.
- Fixed candidate percentages avoid the complexity of continuous sliding and segment boundary crossing.
- 9 candidates is cheap (9 × arc-length walks = 9 × O(route_points)).
- If no candidate is overlap-free, we pick the one with the best clearance — this degrades gracefully rather than failing.
- 2-point routes are skipped (nowhere to slide — the entire route is one segment between source and destination).

### Change 4: Perpendicular offset scales with label dimensions (axis-aware)

Replace the fixed `LABEL_OFFSET = 10.0` with a dynamic offset that uses the correct dimension per axis:

```rust
const LABEL_PADDING: f64 = 4.0;

// In compute_label_position, after finding the segment and interpolation point:
if dx.abs() > dy.abs() {
    // Horizontal segment → vertical offset
    let offset = (label_height / 2.0) + LABEL_PADDING;
    Some(Point::new(px, py - offset))
} else {
    // Vertical segment → horizontal offset
    let offset = (label_width / 2.0) + LABEL_PADDING;
    Some(Point::new(px - offset, py))
}
```

This ensures that:
- On horizontal segments, the label's bottom edge clears the route by `LABEL_PADDING` pixels.
- On vertical segments, the label's right edge clears the route by `LABEL_PADDING` pixels.

## Detailed File Changes

### `crates/d2/src/geo.rs`

Add `intersects` method to `Rect`:

```rust
impl Rect {
    // ... existing methods ...

    /// Test whether two rectangles overlap (strict intersection, not touching).
    pub fn intersects(&self, other: &Rect) -> bool {
        self.x < other.right()
            && self.right() > other.x
            && self.y < other.bottom()
            && self.bottom() > other.y
    }
}
```

Add a `min_separation` free function (or method) for the nudge's clearance metric:

```rust
/// Minimum axis-aligned separation between two rects (negative = overlapping).
pub fn min_rect_separation(a: &Rect, b: &Rect) -> f64 {
    let sep_x = if a.right() <= b.x {
        b.x - a.right()
    } else if b.right() <= a.x {
        a.x - b.right()
    } else {
        // Overlapping on X — report negative overlap
        -(a.right().min(b.right()) - a.x.max(b.x))
    };

    let sep_y = if a.bottom() <= b.y {
        b.y - a.bottom()
    } else if b.bottom() <= a.y {
        a.y - b.bottom()
    } else {
        -(a.bottom().min(b.bottom()) - a.y.max(b.y))
    };

    // If separated on either axis, return that separation.
    // If overlapping on both, return the most-negative (worst).
    if sep_x >= 0.0 || sep_y >= 0.0 {
        sep_x.max(sep_y) // at least one axis is clear
    } else {
        sep_x.max(sep_y) // both overlapping, return least-bad
    }
}
```

### `crates/d2/src/graph.rs`

Add two fields to `D2EdgeData`:

```rust
pub struct D2EdgeData {
    pub label: Option<String>,
    pub src_arrow: ArrowheadType,
    pub dst_arrow: ArrowheadType,
    pub style: Style,
    pub route_type: RouteType,
    pub route: Vec<Point>,
    pub label_position: Option<Point>,
    pub label_width: f64,     // NEW
    pub label_height: f64,    // NEW
}
```

Update every construction site in `compiler.rs` to initialize both as `0.0`.

### `crates/d2/src/edge_routing.rs`

1. **Change `route_all_edges` signature** to accept font parameters:

```rust
pub fn route_all_edges(graph: &mut D2Graph, font_size: f64, font_family: &str) {
    // ... self-loop handling (also measure labels here) ...
    route_orthogonal_edges(graph, &non_self_loops, font_size, font_family);
    nudge_overlapping_labels(graph);
}
```

2. **Update self-loop label handling** to store dimensions.

3. **Replace `compute_label_position`** with the arc-length-percentage version that takes `label_width` and `label_height`.

4. **Update `route_orthogonal_edges`** call site to compute label measurement before calling `compute_label_position`:

```rust
for ec in &classified {
    let route = build_route(ec, &src_rect, &dst_rect);

    let (label_pos, label_w, label_h) = if let Some(ref text) = graph.graph[ec.edge_idx].label {
        let fs = graph.graph[ec.edge_idx].style.font_size.unwrap_or(font_size);
        let m = crate::text::measure_and_wrap_label(text, fs, font_family);
        let pos = compute_label_position(&route, 0.5, m.width, m.height);
        (pos, m.width, m.height)
    } else {
        (None, 0.0, 0.0)
    };

    graph.graph[ec.edge_idx].route = route;
    graph.graph[ec.edge_idx].route_type = RouteType::Orthogonal;
    graph.graph[ec.edge_idx].label_position = label_pos;
    graph.graph[ec.edge_idx].label_width = label_w;
    graph.graph[ec.edge_idx].label_height = label_h;
}
```

5. **Add `nudge_overlapping_labels`** and `find_best_label_position` as specified in Change 3.

6. **Remove `LABEL_OFFSET` constant** (replaced by `LABEL_PADDING` + dynamic sizing).

### `crates/d2/src/svg_render.rs`

Update the edge label section (~lines 602–650) to use stored dimensions:

```rust
let label_width = if edge.label_width > 0.0 {
    edge.label_width
} else {
    // Fallback for edges that didn't go through routing (shouldn't happen)
    label.chars().count() as f64 * font_size * 0.55
};
let label_height = if edge.label_height > 0.0 {
    edge.label_height
} else {
    font_size * 1.2
};
```

### `crates/d2/src/layout.rs`

Update the `route_all_edges` call:

```rust
// Before:
edge_routing::route_all_edges(graph);

// After:
edge_routing::route_all_edges(graph, font_size, font_family);
```

Both `font_size` and `font_family` are already in scope in `layout()`.

## Test Plan

### Existing tests to update

These tests assert specific label positions and will see values shift. The structural invariants (label between nodes, label offset from line) should still hold:

- `test_label_between_nodes` — label y between a.bottom and b.top ✓ (midpoint of 2-point route is still in the gap)
- `test_label_between_nodes_horizontal` — label x between a.right and b.left ✓
- `test_ortho_label_horizontal` — offset assertion may change (dynamic offset vs fixed 10px)
- `test_ortho_label_vertical` — offset assertion may change
- `test_ortho_labels_spread` — distance assertion still holds (different routes = different midpoints)

### New tests

1. **`test_label_at_route_midpoint`** — For a 4-point route, verify the label position is at 50% of total arc length, not at the enter segment midpoint.

2. **`test_label_no_node_overlap`** — The primary bug test. Architecture diagram:
   ```d2
   direction: right
   lb: Load Balancer
   gw: API Gateway
   auth: Auth; redis: Redis; orders: Orders; pg: PostgreSQL
   lb -> gw: HTTPS; gw -> auth: verify; auth -> redis: sessions
   gw -> orders: route; orders -> pg: CRUD
   ```
   For every labeled edge, compute `label_rect` and assert it doesn't intersect any non-endpoint node's `box_`.

3. **`test_label_dimensions_stored`** — After routing, verify `label_width > 0` and `label_height > 0` for every labeled edge, including self-loops.

4. **`test_label_offset_uses_correct_dimension`** — For a vertical segment, assert the label center is offset by at least `label_width / 2` from the route line. For a horizontal segment, assert offset by at least `label_height / 2`.

5. **`test_nudge_finds_clear_position`** — Construct a tight layout where 50% placement overlaps a node, verify the nudge finds a non-overlapping position at a different percentage.

6. **`test_parallel_labels_dont_overlap`** — Two labeled edges sharing a gap should have non-overlapping label rects.

7. **`test_rect_intersects`** — Unit test for the new `Rect::intersects` method in geo.rs.

8. **`test_self_loop_label_dimensions`** — Self-loop edge should have `label_width > 0` and `label_height > 0`.

## Risk Assessment

**Low risk:** The change is confined to label positioning output. Node positions, edge routes (waypoints), and the SVG rendering structure are unaffected. The only outputs that change are `label_position`, `label_width`, and `label_height` on `D2EdgeData`.

**Regression risk:** Existing tests that assert specific label coordinates will need updating. The structural invariants (label between nodes, label offset from line) should still hold — only the specific position within the gap changes.

**Performance:** The arc-length walk is O(P) per edge where P is route points (typically 2–4). The nudge pass is O(E × 9 × P × N) where E is labeled edges with overlap, 9 is candidate percentages, P is route points, and N is node count. For typical diagrams (< 100 nodes, < 100 edges) this is negligible. Worst case: 100 edges × 9 × 4 × 100 = 360,000 operations — trivial.

## Implementation Order

1. Add `Rect::intersects` and `min_rect_separation` to `geo.rs` — utility, no behavior change.
2. Add `label_width` / `label_height` fields to `D2EdgeData` in `graph.rs` — mechanical, update construction sites.
3. Change `route_all_edges` signature to `(graph, font_size, font_family)` — plumbing through `layout.rs`.
4. Replace `compute_label_position` with arc-length-percentage version — **this fixes the primary bug**.
5. Update self-loop handling to measure and store label dimensions.
6. Update SVG renderer to use stored dimensions — consistency fix.
7. Add `nudge_overlapping_labels` — safety net for remaining edge cases.
8. Update existing tests, add new tests.
9. Visual verification against the two screenshot scenarios.

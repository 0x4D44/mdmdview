# Table Divider Regression Triage
**Date:** 2025-11-19  
**Context:** User reports (a) a fixed divider grid pinned to the top of the viewport that doesn’t scroll with the table, and (b) other tables still exhibiting poor column alignment. Reviewed `feat/table-dividers` vs `master` to isolate regressions introduced by the new metrics/divider work.

---

## Findings
1. **Divider overlay paints against stale geometry**  
   - In `render_table_tablebuilder` (`src/markdown_renderer.rs:3324-3415`) we fetch `body.widths()`, `body.max_rect()`, clip rect, visuals, and painter *before* invoking `body.heterogeneous_rows(...)`. These values reflect the pre-scroll viewport rather than the post-layout table body.  
   - After rendering, we reuse the cached `rect`/`painter` to draw dividers via `paint_table_dividers` (`src/markdown_renderer.rs:3413`). Because the scroll-offset-adjusted rect is never recomputed, the overlay stays “pinned” at the original coordinates, creating the immobile grid the user sees.

2. **Persisted widths leak between unrelated tables**  
   - `table_id` (`src/markdown_renderer.rs:2998`) hashes header text plus row count, but ignores actual row content or document identity. Any two tables with the same headers and row count share a `TableMetricEntry`, so `persist_resizable_widths` (line 3392) seeds future tables with widths captured elsewhere.  
   - Canonical `master` only tracked row heights, so this cross-table contamination is new and explains “other tables still poorly aligned.” Short tables inherit widths from unrelated tables with matching headers.

3. **No user-driven width detection yet**  
   - `TableMetricEntry::pending_user_resize` (`src/table_support/metrics.rs:20`) remains unused; we persist widths every frame whether or not the user dragged a divider. That means any heuristic change or content-driven width swing overwrites the cache immediately, so the cache can neither stabilize nor respect actual user intent.  
   - `master` never attempted persistence, so this will keep causing alignment churn until we wire drag detection.

4. **Docs/tests don’t cover overlay behavior**  
   - README only recently mentioned the divider overlay (`README.md:52`), but there’s no QA asset verifying scrolling alignment. Tests cover column_spec heuristics, not renderer geometry, so regressions slipped through.

---

## Proposed Plan
### Status Update – 2025-11-19
- `render_table_tablebuilder` now tracks column widths/rectangles directly from the header/body cell `Ui` instances, so dividers use the exact scroll-transformed coordinates. We extend a bounding rect per cell and reuse egui’s painter/clip rect captured from the live ScrollArea instead of caching pre-scroll geometry.
- `table_id` now hashes the sampled table content plus the current base directory, eliminating collisions between unrelated tables (resolved width persistence no longer bleeds across docs).
- `cargo clippy --all-targets -D warnings` and `cargo test` both pass with the new implementation.

### Remaining Work
1. **Fix divider geometry**
   - Validate visually that the new per-cell rect accumulation behaves under virtualization + scrolling; add regression screenshots.
   - Consider consolidating the width capture with egui’s state (once upstream exposes APIs) to reduce duplication.

2. **Harden table identity**
   - Redefine `table_id` to hash `(document_path, table_index_within_doc, header_hash, sampled_content_hash)`. We can get `document_path` from the renderer/base_dir; table index can increment per render. This prevents unrelated tables from sharing metrics.  
   - Update `table_metrics.entry_mut` callers + cache-clearing paths accordingly, and migrate existing persisted data in-memory (safe since cache resets each run).

3. **Implement real resize persistence**
   - Wire `PendingResize` by hooking into egui’s per-column resize responses (the resizable `Column` exposes drag state). Detect when a user drags a divider, store the column hash + width, and only write to `persisted_column_widths` in that case.  
   - Until drag detection ships, leave persistence disabled to avoid alignment regressions.

4. **QA & docs**
   - Once geometry + persistence are fixed, capture a GIF/screenshot set of the threat-model regression sample showing dividers scrolling correctly at 100/125/150 % DPI.  
   - Expand `docs/QA-table-wrap.md` with explicit “Verify dividers scroll with content” and “Verify width cache respects user drags” steps.

---

## Validation Checklist (after fixes)
- [ ] Divider overlay follows scroll position (manual QA across DPI settings).
- [ ] No cross-table width leakage when navigating between docs (spot-check by logging `table_id` hashes).
- [ ] User drag persistence survives rerenders and does not affect untouched tables.
- [ ] `cargo fmt`, `cargo clippy --all-targets -D warnings`, `cargo test`.
- [ ] README/QA docs updated with new screenshots + guidance once feature is stable.

# HLD: Content-Driven Table Width

**Date**: 2026-02-05
**Version**: 2
**Status**: Design
**Authors**: Arthur + Claude

## Revision History

| Version | Changes |
|---------|---------|
| V1 | Initial design |
| V2 | Fixed critical issues: (1) Remainder columns still over-expand inside narrower container; (2) Content-based estimate and policy-based widths disagree; (3) Need two-mode rendering; (4) Per-column natural widths required, not just total; (5) Persisted user widths integration |

## 1. Problem Statement

Tables currently stretch to fill the full viewport width. A 2-column table with
short content (e.g., "Authentication Module" / "Complete") expands to ~1100px on
a typical display, with one column absorbing ~90% of the space as empty padding.

The root cause: `Column::remainder()` greedily fills all remaining space, and
the rendering pipeline unconditionally allocates `ui.available_width()` as the
table container width.

## 2. Design Goal

Tables should size to their content, capped at the viewport width. A 2-column
table with short text might be 300px wide; a 5-column data table might be 900px;
a table with long descriptions might fill the viewport. The table should never be
wider than the viewport (horizontal scroll aside), but also should never stretch
beyond what its content demands.

## 3. Current Pipeline (Relevant Steps)

```
MarkdownElement::Table { headers, rows, alignments }
       │
       ▼
column_stats_for_table()        → Vec<ColumnStat>     (content metrics)
       │
       ▼
derive_column_specs()           → Vec<ColumnSpec>      (Fixed/Resizable/Remainder/Auto)
       │
       ▼
resolve_table_column_widths()   → Vec<f32>             (per-column desired widths)
       │
       ▼
┌─ Layout calculations in render_table_tablebuilder() ─┐
│                                                       │
│  available_width = ui.available_width()     ◄── PROBLEM 1: always full viewport │
│  content_width = max(desired_total, available_width)                             │
│  use_hscroll = (fixed_total > available) OR (flex_mins > remaining)              │
│                                                       │
│  if !use_hscroll:                                     │
│    adjusted_widths = scale flex columns to fit         │
│    Column::remainder() fills ALL remaining  ◄── PROBLEM 2: greedy expansion     │
│  else:                                                │
│    render in horizontal scroll area                   │
│                                                       │
│  render_table(ui, max_width)                          │
│    ui.allocate_ui_with_layout(max_width, ...)         │
│    ui.set_width(max_width)              ◄── PROBLEM 3: forces full width        │
│    TableBuilder::new(ui)...                           │
└───────────────────────────────────────────────────────┘
```

**Critical insight from V1 review**: Fixing only the container width
(Problem 1+3) is insufficient. Even within a narrower container,
`Column::remainder()` absorbs all leftover space (Problem 2). Example:

```
Container: 316px (content-driven)
Fixed column "Name": 98px (policy)
Spacing: 6px
Remainder column "Status": 316 - 98 - 6 = 212px  ← still too wide!
Content "In Progress" only needs ~113px
```

The fix must address both the container width AND the column widths.

## 4. Proposed Pipeline

```
MarkdownElement::Table { headers, rows, alignments }
       │
       ▼
column_stats_for_table()           → Vec<ColumnStat>
       │
       ▼
derive_column_specs()              → Vec<ColumnSpec>
       │
       ▼
resolve_table_column_widths()      → Vec<f32>         (policy-based)
       │
       ▼
┌─ NEW: estimate_natural_column_widths() ───────────────┐
│                                                        │
│  For each column:                                      │
│    natural[i] = max(content_estimate[i],               │
│                     resolved_width[i],                  │
│                     persisted_width[i])                 │
│                                                        │
│  natural_total = sum(natural) + spacing                │
│                                                        │
└────────────────────────────────────────────────────────┘
       │
       ▼
┌─ MODIFIED: render_table_tablebuilder() ───────────────┐
│                                                        │
│  effective_width = min(natural_total, viewport_width)   │
│                                                        │
│  if effective_width < viewport_width:                   │
│    ──► CONTENT-FIT MODE                                │
│    Use natural column widths directly                   │
│    No Remainder expansion                               │
│    Container = effective_width                           │
│  else:                                                  │
│    ──► VIEWPORT-FILL MODE                              │
│    Existing policy logic unchanged                      │
│    Container = viewport_width                           │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 5. Detailed Design

### 5.1 New Function: `estimate_natural_column_widths`

Returns per-column natural widths by combining content statistics,
policy-resolved widths, and user-persisted widths.

```rust
/// Estimate per-column natural widths from content, policy, and user state.
///
/// For each column, takes the maximum of:
/// - Content-based estimate (from ColumnStat grapheme/word counts)
/// - Policy-resolved width (from resolve_table_column_widths)
/// - User-persisted width (if user has manually resized)
///
/// Each column width is clamped to [MIN_COL_WIDTH, MAX_COL_WIDTH].
fn estimate_natural_column_widths(
    &self,
    column_stats: &[ColumnStat],
    headers: &[Vec<InlineSpan>],
    resolved_widths: &[f32],
    column_count: usize,
) -> Vec<f32>
```

**Algorithm:**

```
for each column i:
    // 1. Content-based estimate
    header_graphemes = unicode_width(header_text[i])
    content_graphemes = stats[i].max_graphemes  (already UnicodeWidth-based)

    display_graphemes = max(header_graphemes, content_graphemes)
    content_width = display_graphemes * CHAR_WIDTH_FACTOR + CELL_PADDING

    // 2. Policy-resolved width (respects Fixed widths, Resizable preferred)
    policy_width = resolved_widths[i]

    // 3. Take the wider of content vs policy
    natural = max(content_width, policy_width)

    // 4. Clamp
    natural_widths[i] = clamp(natural, MIN_COL_WIDTH, MAX_COL_WIDTH)
```

**Why `max(content, policy)`?**
- Fixed "Status" at 98px but content needs 113px → use 113px (content wins)
- Fixed "ID" at 98px, content only needs 40px → use 98px (policy wins, keeps alignment)
- Remainder min_floor 84px, content needs 200px → use 200px (content wins)
- Resizable preferred 133px, content needs 50px → use 133px (preferred wins)

This ensures columns are never narrower than their policy or content requires.

**Constants** (relative to `body_font_px` for zoom support):

| Constant | Formula | At 14px | Purpose |
|----------|---------|---------|---------|
| `CHAR_WIDTH_FACTOR` | `body_font_px * 0.62` | 8.7px | Average character width (proportional font) |
| `CELL_PADDING` | `body_font_px * 1.8` | 25px | Horizontal padding (egui cell margins + breathing room) |
| `MIN_COL_WIDTH` | `body_font_px * 4.0` | 56px | Minimum column width |
| `MAX_COL_WIDTH` | `body_font_px * 35.0` | 490px | Maximum single column width (text wraps beyond this) |

**Why 0.62 and 1.8?** The char width factor is calibrated for typical
proportional fonts at body size. The cell padding accounts for egui's
internal cell margins (~8px each side) plus visual breathing room. These
can be tuned empirically after initial implementation.

### 5.2 New Helper: `natural_table_width`

Thin wrapper that sums per-column widths + spacing:

```rust
fn natural_table_width(
    natural_widths: &[f32],
    column_spacing: f32,
) -> f32 {
    let spacing = column_spacing * natural_widths.len().saturating_sub(1) as f32;
    natural_widths.iter().sum::<f32>() + spacing
}
```

### 5.3 Modified: `render_table_tablebuilder`

**Change 1**: Compute natural widths and effective width

After `resolve_table_column_widths` and before the layout calculations,
add:

```rust
let viewport_width = ui.available_width().max(1.0);  // renamed from available_width
let natural_widths = self.estimate_natural_column_widths(
    &column_stats, headers, &resolved_widths, column_specs.len(),
);
let natural_total = natural_table_width(&natural_widths, column_spacing);
let effective_width = natural_total.min(viewport_width);
let content_fits = effective_width < viewport_width - 0.5;
```

**Change 2**: Two-mode column layout

```rust
let column_layout: Vec<Column> = if use_hscroll {
    // UNCHANGED: horizontal scroll mode
    column_specs.iter().map(|spec| spec.as_column()).collect()
} else if content_fits {
    // NEW: CONTENT-FIT MODE — columns sized to content
    column_specs
        .iter()
        .enumerate()
        .map(|(idx, spec)| {
            let width = natural_widths
                .get(idx)
                .copied()
                .unwrap_or(min_floor)
                .max(1.0);
            let clip = match spec.policy {
                ColumnPolicy::Fixed { clip, .. } => clip,
                ColumnPolicy::Resizable { clip, .. } => clip,
                ColumnPolicy::Remainder { clip } => clip,
                ColumnPolicy::Auto => false,
            };
            let mut col = Column::initial(width)
                .at_least(min_floor.min(width))
                .resizable(true);
            if clip {
                col = col.clip(true);
            }
            col
        })
        .collect()
} else {
    // UNCHANGED: VIEWPORT-FILL MODE — existing policy logic
    column_specs
        .iter()
        .enumerate()
        .map(|(idx, spec)| {
            // ... existing code unchanged ...
        })
        .collect()
};
```

**Change 3**: Pass correct width to render closure

```rust
if use_hscroll {
    // UNCHANGED
    egui::ScrollArea::horizontal()
        .show(ui, |ui| {
            ui.set_min_width(content_width);
            render_table(ui, content_width);
        });
} else if content_fits {
    // NEW: content-fit mode — allocate only what's needed
    render_table(ui, effective_width);
} else {
    // UNCHANGED: viewport-fill mode
    render_table(ui, viewport_width);
}
```

### 5.4 Impact on `use_hscroll` Decision

The hscroll check continues to use `viewport_width` (not
`effective_width`), because horizontal scroll should only appear when
content physically cannot fit the viewport. No change needed.

### 5.5 Impact on Column Policy System

`derive_column_specs` and `ColumnPolicy` remain unchanged.

In **content-fit mode**, column policies are consulted only for their
`clip` flag. The width comes from `natural_widths`, not from the policy.
This is correct because:

- Fixed columns: natural width = max(content, fixed_width), so the column
  is at least as wide as the policy intended
- Resizable columns: natural width = max(content, preferred), so user
  preferences are respected
- Remainder columns: natural width = max(content, min_floor), which is
  content-driven — exactly what we want

In **viewport-fill mode**, the existing logic is unchanged: Remainder
columns expand via `Column::remainder()`, Fixed columns stay fixed, etc.

### 5.6 Impact on Persisted Widths

User-resized columns store their widths in `persisted_column_widths`,
keyed by `policy_hash`. These are applied by `apply_persisted_widths`
which updates the Resizable column specs' preferred width.

This feeds into `resolve_table_column_widths`, which returns the
persisted width for Resizable columns. Since
`estimate_natural_column_widths` takes `resolved_widths` as input and
uses `max(content, resolved)`, persisted widths are respected.

If a user widens a column beyond its content width:
1. Persisted width stored (e.g., 300px)
2. `resolved_widths[i]` = 300px (from persisted)
3. `natural_widths[i]` = max(content_est, 300) = 300px
4. `natural_total` grows, `effective_width` grows (up to viewport)
5. Table accommodates the user's choice

No changes needed.

### 5.7 Zoom Behaviour

All constants scale with `body_font_px`. At 2× zoom, char widths and
paddings double, natural widths double, effective_width grows (capped at
viewport). Columns scale proportionally. No changes needed.

### 5.8 Impact on Width Persistence and Feedback Loop

After rendering, `body.widths()` returns actual column widths.
`record_resolved_widths` caches these for the next frame.
`persist_resizable_widths` saves user-adjusted Resizable widths.

In content-fit mode, columns use `Column::initial(width).resizable(true)`.
If the user resizes, the new width is persisted. On the next frame,
`resolved_widths` picks up the persisted width, `natural_widths`
includes it, and the table width adjusts accordingly. The feedback loop
is preserved.

## 6. Worked Examples

### Example A: 2-Column Short Content (The Bug Case)

```markdown
| Name | Status |
|------|--------|
| Authentication Module | Complete |
| Database Layer | In Progress |
```

**Column stats**:
- Col 0: max_graphemes=21 ("Authentication Module"), longest_word=14
- Col 1: max_graphemes=11 ("In Progress"), longest_word=8

**Policy-resolved widths** (current code):
- Col 0 "Name" (index 0, short label) → Fixed 98px → resolved = 98
- Col 1 "Status" → Fixed 98px → resolved = 98

**Content estimates** (at 14px):
- char_factor = 14 × 0.62 = 8.7px, padding = 14 × 1.8 = 25px
- Col 0: 21 × 8.7 + 25 = 183 + 25 = 208px
- Col 1: 11 × 8.7 + 25 = 96 + 25 = 121px

**Natural widths** = max(content, resolved):
- Col 0: max(208, 98) = 208px
- Col 1: max(121, 98) = 121px

**natural_total** = 208 + 121 + 6 = 335px

**effective_width** = min(335, 1100) = 335px

**content_fits** = true (335 < 1100)

**Result**: Content-fit mode. Col 0 = 208px, Col 1 = 121px. Table = 335px.
Content reads naturally without excessive whitespace.

### Example B: 5-Column Data Table

```markdown
| Operation | Time (ms) | Memory (MB) | CPU (%) | Status |
|-----------|-----------|-------------|---------|--------|
| File Load | 12.5 | 45.2 | 15 | Pass |
| Syntax Highlight | 45.7 | 89.4 | 78 | Slow |
```

**Column stats** (max_graphemes):
- Col 0: 16, Col 1: 9, Col 2: 11, Col 3: 7, Col 4: 6

**Content estimates**:
- Col 0: 16 × 8.7 + 25 = 164px
- Col 1: max("Time (ms)"=9, 9) × 8.7 + 25 = 103px
- Col 2: 11 × 8.7 + 25 = 121px
- Col 3: max("CPU (%)"=7, 7) × 8.7 + 25 = 86px
- Col 4: max("Status"=6, 6) × 8.7 + 25 = 77px

**Policy-resolved** (at 14px):
- Col 0: Fixed 98px (index 0, short)
- Col 1: Fixed 119px ("Time" matches "time")
- Col 2: Resizable preferred 133px
- Col 3: Resizable preferred 133px (doesn't match specials)
- Col 4: Fixed 98px ("Status")

**Natural widths** = max(content, resolved):
- Col 0: max(164, 98) = 164px
- Col 1: max(103, 119) = 119px
- Col 2: max(121, 133) = 133px
- Col 3: max(86, 133) = 133px
- Col 4: max(77, 98) = 98px

**natural_total** = 164 + 119 + 133 + 133 + 98 + 24 = 671px

**effective_width** = min(671, 1100) = 671px

**content_fits** = true

**Result**: Content-fit mode. Table = 671px. Compact, well-proportioned.

### Example C: Table With Long Description

```markdown
| ID | Description |
|----|-------------|
| 1 | This module handles all authentication flows including OAuth2, SAML, and JWT token validation with automatic refresh |
```

**Column stats**:
- Col 0: max_graphemes=2, longest_word=2
- Col 1: max_graphemes=109, longest_word=14

**Content estimates**:
- Col 0: max(2, 2) × 8.7 + 25 = 42px → clamped to MIN=56px
- Col 1: 109 × 8.7 + 25 = 973px → clamped to MAX=490px

**Policy-resolved**:
- Col 0: Fixed 98px (index 0)
- Col 1: Remainder min_floor 84px

**Natural widths** = max(content, resolved):
- Col 0: max(56, 98) = 98px
- Col 1: max(490, 84) = 490px

**natural_total** = 98 + 490 + 6 = 594px

**effective_width** = min(594, 1100) = 594px

**content_fits** = true

**Result**: Content-fit mode. Description wraps at 490px.

### Example D: Wide Table That Needs Full Viewport

```markdown
| ID | Name | Type | Status | Priority | Created | Updated | Author | Tags |
```

9 columns × ~100-150px each ≈ 1150px total.

**natural_total** ≈ 1150px
**effective_width** = min(1150, 1100) = 1100px
**content_fits** = false

**Result**: Viewport-fill mode. Existing policy logic kicks in. Columns
scale down to fit. Horizontal scroll if needed. **No change from current
behaviour.**

### Example E: All-Fixed Columns (Original Bug)

```markdown
| Name | Status |
|------|--------|
| Widget | Active |
```

Both columns Fixed at 98px each. Content: "Widget" (6 chars), "Active" (6 chars).

**Content estimates**:
- Col 0: 6 × 8.7 + 25 = 77px
- Col 1: 6 × 8.7 + 25 = 77px

**Natural widths** = max(content, resolved):
- Col 0: max(77, 98) = 98px (policy wins — keeps alignment)
- Col 1: max(77, 98) = 98px

**natural_total** = 98 + 98 + 6 = 202px

**effective_width** = 202px. **content_fits** = true.

**Result**: Content-fit mode. Both columns at 98px. Table = 202px.
The "squished left" appearance is resolved because the table container
is exactly 202px — no gap between the table and surrounding content.

**The all-Fixed bug is resolved without needing the Remainder fallback.**

### Example F: Single Column

```markdown
| Item |
|------|
| Apple |
| Banana |
```

**Content**: max_graphemes=6 ("Banana"), header "Item" = 4.

**Natural width**: max(6, 4) × 8.7 + 25 = 77px. Policy: Fixed ~98px.
natural = max(77, 98) = 98px.

**natural_total** = 98px. **content_fits** = true.

**Result**: Content-fit mode. Single column at 98px. Not stretched.

## 7. Edge Cases

### 7.1 Empty Table (Headers Only, No Rows)

Stats come from headers only. Content estimates based on header text.
Works as expected — header widths determine natural width.

### 7.2 Very Narrow Viewport (300px)

natural_total = 335px (Example A). effective_width = min(335, 300) = 300px.
content_fits = false. Viewport-fill mode. Existing scale-down or hscroll
logic handles this. No change from current.

### 7.3 User Has Resized a Column Wider

Persisted width feeds into resolved_widths. natural_widths picks it up
via max(content, resolved). natural_total grows. effective_width grows
(up to viewport). Table accommodates. See §5.6.

### 7.4 Table With Images

`has_image` flag doesn't currently affect the content-based estimate
directly (images are counted by grapheme count of alt text). However,
actual image rendering will be wider.

**Mitigation**: Keep the existing column policy logic for image columns
(which already promotes them to Remainder with appropriate minimums).
In viewport-fill mode, these columns get proper space. In content-fit
mode, the natural width from content stats alone may underestimate.

**Open question**: Should `estimate_natural_column_widths` add a bonus
for image columns? E.g., `if has_image: natural = max(natural, 168px)`.
This can be tuned in implementation.

### 7.5 Content-Fit Mode Boundary

When `natural_total` is just slightly below `viewport_width` (e.g.,
1095px vs 1100px), content-fit mode activates and columns may look
slightly narrower than expected. The 0.5px threshold in
`content_fits = effective_width < viewport_width - 0.5` prevents
boundary oscillation.

### 7.6 Bold Header Text

Headers are rendered in bold which is slightly wider than body text.
The content estimate uses the same `CHAR_WIDTH_FACTOR` for headers
and body. This may slightly underestimate header width.

**Mitigation**: The `CELL_PADDING` constant (25px at 14px font)
provides enough breathing room for the bold width delta (~10-15%).
Can be tuned if needed.

### 7.7 CJK / Double-Width Characters

`ColumnStat.max_graphemes` uses `UnicodeWidthStr::width()` which
returns 2 for CJK characters. So `max_graphemes` is a display-width
count, not a character count. The `CHAR_WIDTH_FACTOR` is calibrated
for single-width characters, so CJK characters (which count as 2)
naturally get 2× the width estimate. This is correct.

## 8. Files to Modify

### 8.1 `src/table_support/column_spec.rs`

No changes required. Column policies remain as-is. The previous
Remainder-fallback fix should remain reverted.

### 8.2 `src/markdown_renderer.rs`

**New function**: `estimate_natural_column_widths` (~30 lines)
- Input: column stats, headers, resolved widths, column count
- Output: Vec<f32> of per-column natural widths
- Location: near existing `estimate_table_*` functions

**New helper**: `natural_table_width` (~5 lines)
- Input: natural widths vec, column spacing
- Output: total table width

**Modified function**: `render_table_tablebuilder` (~30 lines changed)
- Compute natural widths and effective width
- Add `content_fits` branch in column layout creation
- Add `content_fits` branch in render dispatch
- Rename `available_width` → `viewport_width` for clarity

Estimated diff: ~70 lines added/changed.

### 8.3 Tests

**New tests**:
- `test_natural_widths_two_short_columns` — verifies per-column estimates
- `test_natural_widths_uses_max_of_content_and_policy` — content vs policy
- `test_natural_widths_clamped_to_bounds` — MIN/MAX enforcement
- `test_natural_table_width_sums_correctly` — total width calculation
- `test_content_fit_mode_activated` — content_fits = true when natural < viewport
- `test_viewport_fill_mode_for_wide_tables` — content_fits = false when natural >= viewport

**Updated tests**:
- `estimate_table_total_width` tests may need updating if function is merged
- Any test that forces column policies should still work (viewport-fill mode unchanged)

## 9. Migration / Backward Compatibility

- Column policies unchanged — user's existing column resize state preserved
- No serialised state changes
- Visual change: tables will be narrower on wide viewports (intended)
- Wide tables (natural ≥ viewport) behave identically to current
- No API changes — internal-only refactoring

## 10. Risks

| Risk | Severity | Mitigation |
|------|----------|------------|
| `CHAR_WIDTH_FACTOR` inaccurate for actual font | Medium | Tune empirically; CELL_PADDING provides buffer; easy to adjust constant |
| Tables look "too narrow" | Low | max(content, policy) ensures at least policy width; constants tunable |
| Regression in viewport-fill mode | Low | Existing code path unchanged when content_fits = false |
| Width oscillation at content/viewport boundary | Low | 0.5px threshold prevents toggling; egui table stable IDs |
| Image columns too narrow in content-fit mode | Medium | Add image bonus in estimate; existing image column policies provide fallback |
| Performance with many tables | Low | Estimation is O(columns) arithmetic on cached ColumnStat; negligible |

## 11. Summary

The fix introduces a **two-mode rendering system**:

1. **Content-fit mode** (natural width < viewport): Table container and
   columns sized to content. No `Column::remainder()` expansion.
   All columns use `Column::initial(natural_width).resizable(true)`.

2. **Viewport-fill mode** (natural width ≥ viewport): Existing
   behaviour unchanged. Remainder columns expand, policies enforced.

The mode switch is determined by comparing the sum of per-column natural
widths (content-driven estimates) against the viewport width.

This resolves:
- **Squished left**: Table container matches content → no empty gap
- **Stretched full width**: Columns sized to content → no greedy expansion
- **All-Fixed columns**: Container = sum(fixed widths) → no wasted space

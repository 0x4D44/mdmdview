# Add Navigation History for File Navigation

**Date:** 2025-01-06
**Issue:** Opening samples (Help → About, File → Samples) discards current file with no way back
**User Impact:** Loss of context when viewing help/samples

## Problem Analysis

### Current State

The application maintains only one file reference:
```rust
pub struct MarkdownViewerApp {
    current_file: Option<PathBuf>,
    // ... other fields
}
```

When a sample is loaded:
```rust
pub fn load_sample(&mut self, sample: &SampleFile) {
    self.current_file = None;  // ← Discards previous file!
    // ...
}
```

**Result:** No way to return to the previously opened file.

### User Workflow That Breaks

1. Open `important_document.md`
2. Click Help → About (to check version or features)
3. **STUCK** - Can't get back to `important_document.md`
4. Must use File → Open and navigate to file again

## Proposed Solutions

### Option 1: Simple Back/Forward History (Recommended)

Add a navigation history that tracks opened files:

**Data Structure:**
```rust
pub struct MarkdownViewerApp {
    current_file: Option<PathBuf>,
    current_content: String,
    // ... existing fields

    // Navigation history
    history: Vec<HistoryEntry>,
    history_index: usize,  // Current position in history
}

#[derive(Clone)]
struct HistoryEntry {
    file: Option<PathBuf>,
    title: String,
    content: String,
    scroll_position: f32,  // Optional: remember scroll position
}
```

**Navigation:**
- Back: Move to `history[history_index - 1]`
- Forward: Move to `history[history_index + 1]`
- New file/sample: Truncate history at current index, push new entry

**UI:**
- Back button or Alt+Left / Ctrl+[
- Forward button or Alt+Right / Ctrl+]
- Menu items: View → Back, View → Forward
- Grayed out when not available

**Pros:**
- Intuitive (like web browser)
- Supports multiple back/forward steps
- Can remember scroll positions
- Works for both files and samples

**Cons:**
- More complex implementation
- Need to manage history size (limit to ~50 entries?)
- Need to store content snapshots

### Option 2: Simple "Previous File" Memory

Just remember the last file that was opened:

**Data Structure:**
```rust
pub struct MarkdownViewerApp {
    current_file: Option<PathBuf>,
    previous_file: Option<PathBuf>,  // Just the last file
    // ... other fields
}
```

**Logic:**
- When loading a file: `previous_file = current_file.clone()`
- Add "Back to Previous" action that swaps current and previous

**Pros:**
- Extremely simple
- Minimal memory overhead
- Easy to implement

**Cons:**
- Only remembers one file
- Can't go back multiple steps
- Loses context if user opens multiple samples

### Option 3: Don't Replace File with Samples

Open samples in a "preview mode" that doesn't affect current_file:

**Data Structure:**
```rust
pub struct MarkdownViewerApp {
    current_file: Option<PathBuf>,
    current_content: String,

    // Separate state for sample viewing
    viewing_sample: bool,
    sample_content: String,
    sample_title: String,
}
```

**Logic:**
- When opening sample: Set `viewing_sample = true`, keep `current_file` intact
- "Close Sample" / "Back to File" returns to `current_file`

**Pros:**
- Preserves current_file perfectly
- Clear separation between files and samples

**Cons:**
- Duplicates state (current_content vs sample_content)
- Complex state management
- What if user wants to keep sample open and open a file?

## Recommendation

**Use Option 1: Simple Back/Forward History**

### Reasoning

1. **User Expectations:** Browser-like navigation is familiar and intuitive
2. **Flexibility:** Handles multiple navigation steps, not just one
3. **Extensibility:** Can add features like:
   - Remember scroll positions
   - History menu showing recent files
   - Ctrl+Tab to cycle through history
4. **Robustness:** Works for any navigation pattern user might use
5. **Professional:** Matches standard application behavior

### Implementation Scope

Start with minimal viable implementation:
- History vector with entries
- Back/Forward navigation
- Keyboard shortcuts (Alt+Left/Right)
- Don't implement: scroll position memory, history menu (can add later)

## Implementation Plan

### Phase 1: Add History Data Structure ✓

1. Define `HistoryEntry` struct:
   ```rust
   #[derive(Clone, Debug)]
   struct HistoryEntry {
       file_path: Option<PathBuf>,
       title: String,
       content: String,
       is_sample: bool,  // Track if this is a sample file
   }
   ```

2. Add history fields to `MarkdownViewerApp`:
   ```rust
   history: Vec<HistoryEntry>,
   history_index: usize,
   max_history: usize,  // Limit history size (default 50)
   ```

3. Initialize in `new()`:
   ```rust
   history: Vec::new(),
   history_index: 0,
   max_history: 50,
   ```

### Phase 2: Add History Management Methods ✓

```rust
impl MarkdownViewerApp {
    /// Add current state to history
    fn push_history(&mut self) {
        // Truncate forward history if we're not at the end
        if self.history_index < self.history.len() {
            self.history.truncate(self.history_index);
        }

        // Create entry for current state
        let entry = HistoryEntry {
            file_path: self.current_file.clone(),
            title: self.title.clone(),
            content: self.current_content.clone(),
            is_sample: self.current_file.is_none(),
        };

        self.history.push(entry);

        // Limit history size
        if self.history.len() > self.max_history {
            self.history.remove(0);
        } else {
            self.history_index = self.history.len();
        }
    }

    /// Navigate back in history
    fn navigate_back(&mut self) -> bool {
        if self.history_index > 0 {
            self.history_index -= 1;
            self.restore_from_history();
            true
        } else {
            false
        }
    }

    /// Navigate forward in history
    fn navigate_forward(&mut self) -> bool {
        if self.history_index < self.history.len() - 1 {
            self.history_index += 1;
            self.restore_from_history();
            true
        } else {
            false
        }
    }

    /// Restore state from history at current index
    fn restore_from_history(&mut self) {
        if let Some(entry) = self.history.get(self.history_index) {
            self.current_file = entry.file_path.clone();
            self.title = entry.title.clone();
            self.current_content = entry.content.clone();
            self.raw_buffer = self.current_content.clone();

            // Re-parse content
            match self.renderer.parse(&self.current_content) {
                Ok(elements) => {
                    self.parsed_elements = elements;
                    self.error_message = None;
                }
                Err(e) => {
                    self.error_message = Some(format!("Failed to parse: {}", e));
                }
            }

            // Set base dir for images
            if let Some(ref path) = self.current_file {
                self.renderer.set_base_dir(path.parent());
            } else {
                self.renderer.set_base_dir(None);
            }

            // Scroll to top
            self.pending_scroll_to_element = Some(0);
        }
    }

    fn can_navigate_back(&self) -> bool {
        self.history_index > 0
    }

    fn can_navigate_forward(&self) -> bool {
        self.history_index < self.history.len().saturating_sub(1)
    }
}
```

### Phase 3: Update File Loading Methods ✓

Modify methods to push to history before loading new content:

1. **`load_file()`** - Add history push before loading
2. **`load_sample()`** - Add history push before loading
3. **`load_content()`** - This is called by both, push history here?

**Decision:** Push history in `load_file()` and `load_sample()` separately for clarity.

```rust
pub fn load_file(&mut self, path: PathBuf) -> Result<()> {
    // Push current state to history before loading new file
    if !self.current_content.is_empty() {
        self.push_history();
    }

    // Existing loading code...
    let (content, lossy) = Self::read_file_lossy(&path)?;
    // ... rest of method
}

pub fn load_sample(&mut self, sample: &SampleFile) {
    // Push current state to history before loading sample
    if !self.current_content.is_empty() {
        self.push_history();
    }

    // Existing loading code...
    self.current_file = None;
    // ... rest of method
}
```

### Phase 4: Add Keyboard Shortcuts ✓

In `handle_shortcuts()`:

```rust
// Alt+Left - Navigate back
if i.consume_shortcut(&egui::KeyboardShortcut::new(
    egui::Modifiers::ALT,
    egui::Key::ArrowLeft,
)) {
    self.navigate_back();
}

// Alt+Right - Navigate forward
if i.consume_shortcut(&egui::KeyboardShortcut::new(
    egui::Modifiers::ALT,
    egui::Key::ArrowRight,
)) {
    self.navigate_forward();
}

// Also support Ctrl+[ and Ctrl+] (common in some editors)
if i.consume_shortcut(&egui::KeyboardShortcut::new(
    egui::Modifiers::CTRL,
    egui::Key::OpenBracket,
)) {
    self.navigate_back();
}

if i.consume_shortcut(&egui::KeyboardShortcut::new(
    egui::Modifiers::CTRL,
    egui::Key::CloseBracket,
)) {
    self.navigate_forward();
}
```

### Phase 5: Add Menu Items ✓

Add to View menu:

```rust
// In render_menu_bar(), View menu
ui.horizontal(|ui| {
    let enabled = self.can_navigate_back();
    if ui.add_enabled(enabled, egui::Button::new("← Back")).clicked() {
        self.navigate_back();
        ui.close_menu();
    }
    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
        ui.label(RichText::new("Alt+←").color(menu_text_color));
    });
});

ui.horizontal(|ui| {
    let enabled = self.can_navigate_forward();
    if ui.add_enabled(enabled, egui::Button::new("→ Forward")).clicked() {
        self.navigate_forward();
        ui.close_menu();
    }
    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
        ui.label(RichText::new("Alt+→").color(menu_text_color));
    });
});
```

### Phase 6: Testing ✓

**Manual Tests:**
1. Open a file (`test.md`)
2. Click Help → About
3. Press Alt+Left (or click View → Back)
4. Verify file `test.md` is restored
5. Press Alt+Right (or click View → Forward)
6. Verify About screen is shown again

**Edge Cases:**
1. Open file → Sample → File → Sample → Back → Back → Back (verify correct order)
2. Open file → Sample → Back → Open different file (verify forward history cleared)
3. App startup with no history (verify Back/Forward disabled)
4. History size limit (open 60 files, verify oldest are dropped)

**Unit Tests:**
```rust
#[test]
fn test_navigation_history_back_forward() {
    let mut app = MarkdownViewerApp::new();

    // Initial state - welcome screen
    assert!(!app.can_navigate_back());
    assert!(!app.can_navigate_forward());

    // Load a file
    app.load_content("# File 1", Some("File 1".to_string()));
    app.push_history();

    // Load another file
    app.load_content("# File 2", Some("File 2".to_string()));

    // Should be able to go back
    assert!(app.can_navigate_back());
    assert!(!app.can_navigate_forward());

    // Go back
    app.navigate_back();
    assert!(app.title.contains("File 1"));

    // Should be able to go forward
    assert!(app.can_navigate_forward());

    // Go forward
    app.navigate_forward();
    assert!(app.title.contains("File 2"));
}

#[test]
fn test_navigation_history_truncates_on_new_load() {
    let mut app = MarkdownViewerApp::new();

    // Load sequence: A -> B -> C
    app.load_content("# A", Some("A".to_string()));
    app.push_history();
    app.load_content("# B", Some("B".to_string()));
    app.push_history();
    app.load_content("# C", Some("C".to_string()));

    // Go back: C -> B
    app.navigate_back();

    // Load new file D (should truncate C from forward history)
    app.load_content("# D", Some("D".to_string()));

    // Should not be able to go forward to C
    assert!(!app.can_navigate_forward());

    // But should be able to go back to B then A
    app.navigate_back();
    assert!(app.title.contains("B"));
    app.navigate_back();
    assert!(app.title.contains("A"));
}
```

### Phase 7: Documentation ✓

1. Add keyboard shortcuts to README.md:
   ```markdown
   | Alt+← | Navigate back |
   | Alt+→ | Navigate forward |
   ```

2. Update CLAUDE.md:
   - Note navigation history feature
   - Explain history management

3. Add comments in code explaining history logic

## Technical Considerations

### Memory Usage

**Per Entry:**
- PathBuf: ~24 bytes + path string
- Title string: ~24 bytes + title text
- Content string: ~24 bytes + content (could be large!)
- is_sample: 1 byte

**50 entries with 100KB average content:**
- ~5MB total
- Acceptable for desktop application

**Optimization (if needed later):**
- Store only file path + title for files
- Reload content from disk when navigating back
- Only store content for samples (since they're small and in-memory)

### History Limits

- Default limit: 50 entries
- Prevents unbounded growth
- Users opening hundreds of files won't exhaust memory

### Edge Cases

1. **File modified on disk:** When navigating back to a file, we restore the content from history (old version). User can press F5 to reload from disk.

2. **File deleted:** History contains content, so it will still show. If user tries to reload (F5), error message shown.

3. **Sample → File → Back → Save:** User navigates back to a sample. If they press Ctrl+S, should prompt for "Save As" (current behavior).

4. **Initial welcome screen:** First item in history. Navigating back does nothing initially.

## Success Criteria

- [✓] Can open file, then Help → About, then navigate back to file
- [✓] Alt+Left navigates back
- [✓] Alt+Right navigates forward
- [✓] Back/Forward menu items show correct enabled state
- [✓] History persists through multiple navigation steps
- [✓] Forward history cleared when loading new file mid-history
- [✓] No crashes or memory issues
- [✓] All existing tests still pass

## Risk Assessment

**Low Risk** - This feature:
- Adds new functionality without changing existing behavior
- Doesn't modify file loading logic significantly
- Can be disabled by just not pushing history
- Well-defined scope

## Performance Impact

**Negligible** - The overhead:
- Vec operations are O(1) for push/access
- Memory usage is bounded (50 entries max)
- No performance impact on rendering or file I/O

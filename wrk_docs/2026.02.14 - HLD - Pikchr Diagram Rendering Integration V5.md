# HLD: Pikchr Diagram Rendering Integration

**Date**: 2026-02-14
**Author**: Arthur & Claude
**Status**: Draft
**Version**: 5.0.0

---

## Revision History

| Version | Date       | Changes                                                        |
|---------|------------|----------------------------------------------------------------|
| 1.0.0   | 2026-02-14 | Initial draft                                                  |
| 2.0.0   | 2026-02-14 | Review pass 1: 5 critical, 5 major, 6 minor fixes (see below) |
| 3.0.0   | 2026-02-14 | Review pass 2: 2 medium, 3 minor fixes (see below)            |
| 4.0.0   | 2026-02-14 | Review pass 3: 1 medium, 1 minor fix (see below)              |
| 5.0.0   | 2026-02-14 | Holistic review: 5 gaps addressed (see below)                  |

### V5 Review Findings

**Holistic review -- gaps identified after all critical/medium issues were resolved:**

- G1: **Helper functions used but not defined**. `hash_str()`, `bucket_width()`,
  and `bucket_scale()` were called in code listings but never shown. Added
  implementations to section 5.1.10.
- G2: **No context menu on Pikchr diagram blocks**. Mermaid blocks also lack a
  context menu, so this is a known limitation, not a regression. Noted in
  section 5.3.3 for future consideration.
- G3: **Sample Pikchr syntax unverified**. The sample diagrams in section 5.3.6
  should be validated against the actual Pikchr parser before shipping. Added
  verification step to rollout plan (section 9.2).
- G4: **No input size defense**. Pikchr has no documented resource limits. A
  pathologically large input could cause long render times or excessive memory.
  Added risk entry to section 9.1 with mitigation.
- G5: **User-facing documentation gaps**. The welcome and usage samples could
  mention Pikchr availability. Noted in section 10 (Future Considerations).

### V4 Review Findings

**Medium fix:**
- M8: `PikchrTextureEntry` needs `#[derive(Clone)]` -- the LruCache requires
  `V: Clone` and `get()` returns cloned values. Without the derive, this won't
  compile.

**Minor fix:**
- m10: Added code listings for `new()`, `begin_frame()`, `has_pending()`, and
  `release_gpu_textures()` implementations. These are trivial but their absence
  could cause ambiguity during implementation.

### V3 Review Findings

**Medium fixes (would cause issues during implementation):**
- M6: RefMut lifetime hazard in `render_block()` step 1 -- `self.errors.borrow_mut()`
  in an `if let` scrutinee keeps the `RefMut` alive for the entire `if let` block,
  overlapping with `self.render_error_block()`. Fixed by cloning and dropping the
  borrow explicitly before calling render.
- M7: `resvg::render(&tree, transform, &mut pixmap.as_mut())` won't compile --
  can't take `&mut` of a temporary rvalue. Fixed by binding to a local variable.

**Minor fixes (clarity, correctness):**
- m7: Section 2.2 removed misleading claim about "async caching" -- the entire
  Pikchr pipeline is synchronous, including texture upload.
- m8: Clarified that `render_pikchr_to_svg` is a static associated function on
  `PikchrRenderer` (not a free function) so test call syntax is unambiguous.
- m9: Specified that the LruCache variant used is the one with `get(&mut self)`
  for true LRU access-order tracking (matching `mermaid_renderer.rs`'s version).

### V2 Review Findings

**Critical fixes (would cause compilation failures or incorrect behaviour):**
- C1: `PikchrFlags` API corrected from bitwise OR to method-based builder pattern
- C2: SVG cache key now accounts for dark mode (composite key, not just code hash)
- C3: `src/lib.rs` added to modified files list (module declaration required)
- C4: `SampleFile` entry corrected to include all three fields (`name`, `title`, `content`)
- C5: `RefCell` borrow lifetime fixed in `render_block()` code sample

**Major fixes (incorrect assumptions or design gaps):**
- M1: Data structures changed to reuse existing `LruCache<K,V>` from codebase
- M2: Removed contradictory claim about extracting shared rasterization logic
- M3: Build configurations table corrected (features add to defaults, not replace)
- M4: Test count assertion update noted (`SAMPLE_FILES.len()` changes from 7 to 8)
- M5: `begin_frame()` documented as intentional no-op for API symmetry

**Minor fixes (style, documentation, completeness):**
- m1: License clarified (pikchr.c = public domain, Rust crate = MIT/Apache-2.0)
- m2: `pic` language alias removed (PIC is a different language; ambiguity risk)
- m3: Font handling noted as risk with mitigation
- m4: CLAUDE.md update specifics documented
- m5: Sample file uses inline const to match existing pattern
- m6: `clamp_dimensions` helper defined inline

---

## 1. Overview

### 1.1 Motivation

mdmdview currently supports Mermaid diagram rendering via an embedded QuickJS engine.
Users have requested support for additional diagram types. Pikchr is an ideal
candidate because:

- It is a **single C file** (~10K lines) with zero external dependencies
- It produces **SVG output** directly, plugging into our existing rasterization pipeline
- The C source (`pikchr.c`) is **public domain**; the Rust crate wrapper is MIT/Apache-2.0
- It is battle-tested in production (Fossil VCS, the SQLite project's version control)
- It preserves the **single-binary distribution** model that defines mdmdview

### 1.2 What is Pikchr?

Pikchr (pronounced "picture") is a PIC-like markup language for diagrams in
technical documentation. Created by D. Richard Hipp (author of SQLite), it
converts text descriptions into SVG diagrams.

Example input:
```pikchr
arrow right 200% "Markdown" "Source"
box rad 10px "Pikchr" "Renderer" fit
arrow right 200% "SVG" "Output"
box rad 10px "Rasterizer" fit
arrow right 200% "Texture" "Display"
```

Key characteristics:
- Declarative diagram language with automatic layout
- Supports boxes, circles, cylinders, arrows, lines, arcs, splines
- Relative positioning ("right of", "below", "2nd box")
- Labels, colors, line styles, fill patterns
- Variables and expressions for computed layouts
- Dark mode support via `PIKCHR_DARK_MODE` flag

### 1.3 Scope

This document covers the design for integrating Pikchr as an embedded diagram
renderer in mdmdview. The integration follows the same patterns established by
the Mermaid renderer where possible, but is dramatically simpler because Pikchr
is a synchronous C function call rather than an asynchronous JavaScript engine.

### 1.4 Non-Goals

- Replacing or competing with Mermaid (they serve different diagram types)
- Supporting Pikchr editing/preview (would be a separate feature)
- Adding a GUI diagram editor
- Server-side rendering or network-based approaches

---

## 2. Architecture

### 2.1 High-Level Data Flow

```
Markdown file
    |
    v
pulldown-cmark parser
    |
    v
CodeBlock { language: "pikchr", text: "..." }
    |
    v
render_code_block() detects language == "pikchr"
    |
    v
pikchr_renderer.render_block(ui, code, ui_scale, code_font_size)
    |
    v
pikchr::Pikchr::render(code, None, flags)  -->  SVG string
    |
    v
SVG rasterization (usvg + resvg + tiny-skia)  -->  RGBA pixels
    |
    v
egui texture upload  -->  displayed in UI
```

### 2.2 Key Design Decision: Synchronous Rendering

Unlike Mermaid, which requires an asynchronous worker pool (QuickJS engine,
DOM shim, multi-second render times), Pikchr renders **synchronously in
microseconds**. A typical Pikchr diagram renders in 50-500 microseconds.

This means:
- **No worker threads** needed
- **No job queue** or pending state
- **No placeholder/spinner UI**
- Rendering happens inline during the egui frame
- Texture upload is also synchronous (fast enough at Pikchr's output sizes)
- The entire pipeline -- parse, render, rasterize, upload -- completes in a single frame

This dramatically simplifies the architecture compared to Mermaid's ~9,000 lines.

### 2.3 Component Architecture

```
MarkdownRenderer
    |
    +-- mermaid: MermaidRenderer       (existing, ~9K lines)
    |
    +-- pikchr: PikchrRenderer         (new, ~300-500 lines)
            |
            +-- texture_cache: LruCache<String, PikchrTextureEntry>
            +-- error_cache: LruCache<u64, String>
            +-- svg_cache: LruCache<u128, String>     (keyed by code_hash + dark_mode)
```

`PikchrRenderer` is a new struct stored alongside `MermaidRenderer` in
`MarkdownRenderer`. It follows the same public API pattern:

| Method                     | Purpose                                       |
|----------------------------|-----------------------------------------------|
| `new()`                    | Constructor                                   |
| `render_block(ui, code, ui_scale, code_font_size)` | Main entry point called during rendering |
| `begin_frame()`            | No-op (API symmetry with MermaidRenderer)     |
| `has_pending()`            | Always returns `false` (sync rendering)       |
| `release_gpu_textures()`   | Free GPU textures on minimize/cleanup         |

---

## 3. Dependency: `pikchr` Crate

### 3.1 Crate Details

| Field          | Value                                                   |
|----------------|---------------------------------------------------------|
| Crate          | [`pikchr`](https://crates.io/crates/pikchr)            |
| Version        | 0.1.4                                                   |
| Last updated   | 2025-03-01                                              |
| License        | MIT / Apache-2.0 (dual); underlying pikchr.c is public domain |
| Dependencies   | `libc` (runtime), `cc` (build)                          |
| Size           | ~300 KB (mostly pikchr.c)                               |
| Upstream       | Bundles pikchr.c from pikchr.org (2025-02-28 snapshot)  |

### 3.2 Rust API

```rust
use pikchr::{Pikchr, PikchrFlags};

// Configure flags via builder methods (NOT bitwise OR)
let mut flags = PikchrFlags::default();
flags.generate_plain_errors();  // plain text errors, not HTML
flags.use_dark_mode();          // invert colors for dark backgrounds

// Render a diagram to SVG
let result = Pikchr::render(source_code, None, flags);

match result {
    Ok(svg) => {
        // svg implements Deref<Target=str> and Display
        // svg.width() -> isize
        // svg.height() -> isize
        // svg.rendered() -> &str
        println!("{}", svg);
    }
    Err(error_message) => {
        eprintln!("Pikchr error: {}", error_message);
    }
}
```

**Important API notes:**
- `PikchrFlags` uses **method-based configuration**, not bitwise flags.
  Setter methods (`use_dark_mode()`, `generate_plain_errors()`) return
  `&mut Self` for optional chaining.
- `Pikchr` does **not** implement `Send` or `Sync`. This is fine because we
  render synchronously on the main thread and immediately extract the SVG
  string via `.to_string()`, after which the `Pikchr` value is dropped.
- `Pikchr::render()` takes `PikchrFlags` by value (`PikchrFlags` is `Copy`).

### 3.3 Underlying C API

The crate wraps the single C function:

```c
char *pikchr(
    const char *zText,      // Input Pikchr source text
    const char *zClass,     // Optional CSS class for <svg> element
    unsigned int mFlags,    // PIKCHR_PLAINTEXT_ERRORS | PIKCHR_DARK_MODE
    int *pnWidth,           // Output: SVG width (negative on error)
    int *pnHeight           // Output: SVG height
);
```

Memory: Returns `malloc()`-allocated string. The Rust crate handles `free()`.

### 3.4 Why Use the Crate vs. Raw FFI

The `pikchr` crate:
- Bundles a recent snapshot of `pikchr.c` (no need to vendor it ourselves)
- Handles `cc` compilation in its own `build.rs`
- Provides safe Rust wrappers with proper memory management
- Handles `CString` conversion and null termination
- Returns `Result<Pikchr, String>` with proper error handling
- Provides typed flags via `PikchrFlags`

Building our own FFI binding would save zero dependencies (we'd still need `cc`
and `libc`) while adding maintenance burden. The crate is small, well-maintained,
and MIT-licensed. No reason to reinvent it.

---

## 4. Feature Flag Design

### 4.1 Cargo Feature Structure

```toml
[features]
default = ["mermaid-embedded", "pikchr"]

# Pikchr diagram rendering (embedded C library)
pikchr = ["dep:pikchr"]
```

```toml
[dependencies.pikchr]
version = "0.1"
optional = true
```

### 4.2 Conditional Compilation

All Pikchr code wrapped in `#[cfg(feature = "pikchr")]`:

```rust
#[cfg(feature = "pikchr")]
pub(crate) mod pikchr_renderer;
```

When the feature is disabled, `pikchr` code blocks render as ordinary code
blocks (no syntax highlighting will be available for "pikchr" as syntect has
no Pikchr grammar, so they render as plain monospace text).

### 4.3 Build Configurations

| Configuration                                              | Mermaid | Pikchr |
|------------------------------------------------------------|---------|--------|
| `cargo build` (default)                                    | Yes     | Yes    |
| `cargo build --no-default-features`                        | No      | No     |
| `cargo build --no-default-features --features pikchr`      | No      | Yes    |
| `cargo build --no-default-features --features mermaid-embedded` | Yes | No     |
| `cargo build --features mermaid-embedded`                  | Yes     | Yes*   |

*`--features` adds to defaults; pikchr is in default, so it remains enabled.
Use `--no-default-features --features mermaid-embedded` to get Mermaid-only.

---

## 5. Detailed Design

### 5.1 New File: `src/pikchr_renderer.rs`

Estimated size: **300-500 lines** (including tests).

#### 5.1.1 Data Structures

Reuses the existing `LruCache<K, V>` type already defined in
`markdown_renderer.rs` (HashMap + VecDeque, with insert/get/clear/remove).
To avoid duplication, we either:
- (a) Move `LruCache` to a shared utility module and import from both renderers, or
- (b) Define a local copy in `pikchr_renderer.rs` (matches current pattern where
  `mermaid_renderer.rs` and `markdown_renderer.rs` each have their own `LruCache`)

Option (b) is simpler and matches existing conventions. The type is ~80 lines.

We use the `mermaid_renderer.rs` variant of `LruCache`, where `get(&mut self)`
updates access order (true LRU eviction). The `markdown_renderer.rs` variant
has `get(&self)` which doesn't track access order (insertion-order eviction).
True LRU is better here because recently-viewed diagrams should stay cached.

```rust
/// Pikchr diagram renderer.
///
/// Renders Pikchr markup to SVG using the embedded pikchr C library,
/// then rasterizes SVG to egui textures via usvg/resvg.
/// Synchronous rendering -- no worker threads needed.
pub(crate) struct PikchrRenderer {
    /// LRU cache: texture_key (String) -> (TextureHandle, [width, height])
    textures: RefCell<LruCache<String, PikchrTextureEntry>>,
    /// SVG cache: svg_cache_key (u128: code_hash << 1 | dark_mode) -> SVG string
    svg_cache: RefCell<LruCache<u128, String>>,
    /// Error cache: code_hash (u64) -> error message
    /// (Errors don't depend on dark_mode, only on source syntax.)
    errors: RefCell<LruCache<u64, String>>,
}

#[derive(Clone)]
struct PikchrTextureEntry {
    texture: egui::TextureHandle,  // TextureHandle is Clone (wraps Arc)
    size: [u32; 2],                // Copy
}
```

#### 5.1.2 Cache Key Design

**SVG cache key** -- must incorporate dark mode because `PIKCHR_DARK_MODE`
produces different SVG output for the same source code:

```rust
/// Composite SVG cache key: embeds both the source code hash and dark_mode flag.
fn svg_cache_key(code_hash: u64, dark_mode: bool) -> u128 {
    ((code_hash as u128) << 1) | (dark_mode as u128)
}
```

**Texture cache key** -- must additionally incorporate width bucket, scale
bucket, and dark mode (since the rasterized output depends on all of these):

```
pikchr:{code_hash}:w{width_bucket}:s{scale_bucket}:dm{dark_mode}
```

**Error cache key** -- keyed by `code_hash` only (u64). Pikchr syntax errors
depend on source code, not on dark mode, so a single key suffices. When the
user edits the source, the hash changes and the old error is not matched.

#### 5.1.3 Cache Capacity Constants

```rust
const PIKCHR_TEXTURE_CACHE_CAPACITY: usize = 64;
const PIKCHR_SVG_CACHE_CAPACITY: usize = 64;
const PIKCHR_ERROR_CACHE_CAPACITY: usize = 32;
```

These are conservative. Pikchr diagrams are small (a few KB of SVG) so 64
entries is plenty without meaningful memory pressure.

#### 5.1.4 Core Rendering Method

```rust
pub(crate) fn render_block(
    &self,
    ui: &mut egui::Ui,
    code: &str,
    ui_scale: f32,
    code_font_size: f32,
) -> bool {
    let code_hash = hash_str(code);
    let dark_mode = ui.visuals().dark_mode;
    let svg_key = svg_cache_key(code_hash, dark_mode);

    // 1. Check error cache (don't re-render known failures).
    //    Errors depend only on syntax, not dark_mode, so keyed by code_hash.
    //    Clone the error and drop the RefMut before calling render_error_block,
    //    to avoid holding a borrow on self.errors across a &self method call.
    let cached_err = self.errors.borrow_mut().get(&code_hash);
    if let Some(err) = cached_err {
        self.render_error_block(ui, &err, code, code_font_size);
        return true;
    }

    // 2. Compute texture cache key (incorporates width bucket + scale + theme)
    let available_width = ui.available_width().max(1.0);
    let width_bucket = bucket_width(available_width);
    let scale_bucket = bucket_scale(ui_scale);
    let texture_key = format!(
        "pikchr:{:016x}:w{}:s{}:dm{}",
        code_hash, width_bucket, scale_bucket, dark_mode as u8
    );

    // 3. Check texture cache.
    //    Bind the borrow to a variable to keep RefCell Ref alive across the
    //    render_texture call.
    {
        let mut cache = self.textures.borrow_mut();
        if let Some(entry) = cache.get(&texture_key) {
            Self::render_texture(ui, &entry, available_width);
            return true;
        }
    }

    // 4. Check SVG cache or render fresh SVG
    let svg = {
        let mut svg_cache = self.svg_cache.borrow_mut();
        if let Some(cached) = svg_cache.get(&svg_key) {
            cached
        } else {
            drop(svg_cache); // Release borrow before calling render
            match Self::render_pikchr_to_svg(code, dark_mode) {
                Ok(svg) => {
                    self.svg_cache.borrow_mut().insert(svg_key, svg.clone());
                    svg
                }
                Err(err) => {
                    self.errors.borrow_mut().insert(code_hash, err.clone());
                    self.render_error_block(ui, &err, code, code_font_size);
                    return true;
                }
            }
        }
    };

    // 5. Rasterize SVG to RGBA and upload as texture
    match Self::rasterize_and_upload(ui.ctx(), &texture_key, &svg, width_bucket, scale_bucket) {
        Ok(entry) => {
            Self::render_texture(ui, &entry, available_width);
            self.textures.borrow_mut().insert(texture_key, entry);
            true
        }
        Err(err) => {
            self.errors.borrow_mut().insert(code_hash, err.clone());
            self.render_error_block(ui, &err, code, code_font_size);
            true
        }
    }
}
```

#### 5.1.5 Pikchr-to-SVG Rendering

Static associated function on `PikchrRenderer` (no `&self` -- pure input/output):

```rust
fn render_pikchr_to_svg(code: &str, dark_mode: bool) -> Result<String, String> {
    use pikchr::{Pikchr, PikchrFlags};

    let mut flags = PikchrFlags::default();
    flags.generate_plain_errors();
    if dark_mode {
        flags.use_dark_mode();
    }

    Pikchr::render(code, None, flags)
        .map(|svg| svg.to_string())
        .map_err(|e| e.to_string())
}
```

This is the entire Pikchr integration point. One function call. Compare this
with Mermaid's ~2,000-line QuickJS initialization, DOM shim, and worker pool.

Note: `Pikchr` (the return type) does not implement `Send`/`Sync`, but this
is irrelevant -- we call `.to_string()` immediately to extract the SVG and
let the `Pikchr` value drop. All rendering happens on the main thread.

#### 5.1.6 SVG Rasterization

A standalone rasterization function within `PikchrRenderer`. This is simpler
than Mermaid's rasterizer (which handles viewBox manipulation, bounding box
correction, diagram-specific SVG patching, etc.) because Pikchr generates
clean, well-formed SVG with explicit dimensions.

```rust
fn rasterize_and_upload(
    ctx: &egui::Context,
    texture_key: &str,
    svg: &str,
    width_bucket: u32,
    scale_bucket: u32,
) -> Result<PikchrTextureEntry, String> {
    // Parse SVG with default options.
    // Note: using default fontdb. Pikchr SVGs use basic text labels which
    // resolve fine with system fonts. If font issues arise in the future,
    // we can pass a shared fontdb (as Mermaid does).
    let opt = usvg::Options::default();
    let tree = usvg::Tree::from_data(svg.as_bytes(), &opt)
        .map_err(|e| format!("SVG parse error: {}", e))?;

    // Compute dimensions from the parsed SVG tree
    let size = tree.size().to_int_size();
    let (w, h) = (size.width().max(1), size.height().max(1));

    // Compute scale factor
    let base_scale = scale_bucket as f32 / 100.0;
    let width_scale = if width_bucket > 0 {
        width_bucket as f32 / w.max(1) as f32
    } else {
        base_scale
    };
    let scale = base_scale.min(width_scale).clamp(0.1, 4.0);

    let mut target_w = (w as f32 * scale).round().max(1.0) as u32;
    let mut target_h = (h as f32 * scale).round().max(1.0) as u32;

    // Clamp to reasonable maximum (same as Mermaid: 4096)
    let max_side: u32 = 4096;
    if target_w > max_side || target_h > max_side {
        let clamp_scale =
            (max_side as f32 / target_w as f32).min(max_side as f32 / target_h as f32);
        target_w = (target_w as f32 * clamp_scale).round().max(1.0) as u32;
        target_h = (target_h as f32 * clamp_scale).round().max(1.0) as u32;
    }

    // Rasterize: Pikchr SVGs have no background fill, so the pixmap starts
    // transparent and the diagram draws on top.
    let mut pixmap = tiny_skia::Pixmap::new(target_w, target_h)
        .ok_or_else(|| "Pixmap allocation failed".to_string())?;
    let transform = tiny_skia::Transform::from_scale(scale, scale);
    // Bind PixmapMut to a local -- can't take &mut of a temporary rvalue.
    let mut pmut = pixmap.as_mut();
    resvg::render(&tree, transform, &mut pmut);

    // Upload to GPU
    let rgba = pixmap.data().to_vec();
    let image = egui::ColorImage::from_rgba_unmultiplied(
        [target_w as usize, target_h as usize],
        &rgba,
    );
    let texture = ctx.load_texture(
        texture_key.to_string(),
        image,
        egui::TextureOptions::LINEAR,
    );

    Ok(PikchrTextureEntry {
        texture,
        size: [target_w, target_h],
    })
}
```

#### 5.1.7 Texture Display

```rust
fn render_texture(
    ui: &mut egui::Ui,
    entry: &PikchrTextureEntry,
    available_width: f32,
) {
    let (tw, th) = (entry.size[0] as f32, entry.size[1] as f32);
    let scale = if tw > available_width {
        (available_width / tw).clamp(0.01, 4.0)
    } else {
        1.0
    };
    let size = egui::vec2((tw * scale).round(), (th * scale).round());
    ui.add(egui::Image::new(&entry.texture).fit_to_exact_size(size));
}
```

#### 5.1.8 Error Display

```rust
fn render_error_block(
    &self,
    ui: &mut egui::Ui,
    error: &str,
    code: &str,
    code_font_size: f32,
) {
    let tc = ThemeColors::current(ui.visuals().dark_mode);
    egui::Frame::none()
        .fill(tc.box_bg)
        .stroke(egui::Stroke::new(1.0, egui::Color32::from_rgb(200, 80, 80)))
        .inner_margin(8.0)
        .show(ui, |ui| {
            ui.label(
                egui::RichText::new("Pikchr rendering error:")
                    .color(egui::Color32::from_rgb(200, 80, 80))
                    .size(code_font_size),
            );
            ui.label(
                egui::RichText::new(error)
                    .color(egui::Color32::LIGHT_GRAY)
                    .size(code_font_size)
                    .family(egui::FontFamily::Monospace),
            );
            ui.add_space(4.0);
            ui.label(
                egui::RichText::new(code)
                    .size(code_font_size)
                    .color(tc.code_fallback_text)
                    .family(egui::FontFamily::Monospace),
            );
        });
}
```

#### 5.1.9 Lifecycle Methods

```rust
impl PikchrRenderer {
    pub(crate) fn new() -> Self {
        Self {
            textures: RefCell::new(LruCache::new(PIKCHR_TEXTURE_CACHE_CAPACITY)),
            svg_cache: RefCell::new(LruCache::new(PIKCHR_SVG_CACHE_CAPACITY)),
            errors: RefCell::new(LruCache::new(PIKCHR_ERROR_CACHE_CAPACITY)),
        }
    }

    /// No-op. API symmetry with MermaidRenderer.
    /// Pikchr renders synchronously so there is no per-frame pending state to reset.
    pub(crate) fn begin_frame(&self) {}

    /// Always false. Pikchr renders synchronously; nothing is ever pending.
    pub(crate) fn has_pending(&self) -> bool {
        false
    }

    /// Release GPU textures to reduce idle GPU usage (e.g., when minimized).
    /// SVG and error caches are retained for fast texture rebuilds on next render.
    pub(crate) fn release_gpu_textures(&self) {
        self.textures.borrow_mut().clear();
    }
}
```

#### 5.1.10 Helper Functions

Three helper functions are used throughout `PikchrRenderer` but were not
previously shown. They are private functions within the module.

```rust
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

/// Hash a string to a u64 using the standard library's DefaultHasher.
/// Used for cache key generation -- not cryptographic.
fn hash_str(s: &str) -> u64 {
    let mut hasher = DefaultHasher::new();
    s.hash(&mut hasher);
    hasher.finish()
}

/// Quantize a width value to 32-pixel buckets to avoid cache thrashing
/// when the panel width changes by a few pixels (e.g., during resize).
/// Returns the bucket midpoint as u32.
fn bucket_width(width: f32) -> u32 {
    let bucket = (width / 32.0).round() as u32;
    bucket * 32
}

/// Quantize a UI scale factor to integer percentage buckets.
/// e.g., 1.0 -> 100, 1.25 -> 125, 1.5 -> 150.
/// Matches the bucketing strategy in mermaid_renderer.rs.
fn bucket_scale(scale: f32) -> u32 {
    (scale * 100.0).round() as u32
}
```

These are simple, pure functions. `hash_str` uses `DefaultHasher` which is
`SipHash` under the hood -- no need for a faster hasher since Pikchr source
strings are small. `bucket_width` and `bucket_scale` prevent cache
invalidation from sub-pixel layout jitter.

### 5.2 Dark Mode Handling

Pikchr has native dark mode support via the `PIKCHR_DARK_MODE` flag, which
inverts diagram colors in the SVG output itself. This is superior to
post-processing SVG colors.

The same source code produces **different SVGs** in light vs dark mode.
Therefore:

1. The **SVG cache** uses a composite key `(code_hash, dark_mode)` encoded as
   `u128` -- see `svg_cache_key()` in section 5.1.2.
2. The **texture cache** key includes `dm{0|1}`, so textures are theme-specific.
3. The **error cache** uses `code_hash` only -- syntax errors don't depend on
   theme. This means a syntax error cached in light mode correctly prevents
   redundant re-rendering in dark mode too.

When the user toggles dark/light mode, cached SVGs and textures for the
previous theme simply aren't matched, and new ones are rendered on demand.

### 5.3 Modifications to Existing Files

#### 5.3.1 `Cargo.toml`

```toml
[features]
default = ["mermaid-embedded", "pikchr"]
# ... existing features ...
# Pikchr diagram rendering (embedded C library, compiled from C source)
pikchr = ["dep:pikchr"]

[dependencies.pikchr]
version = "0.1"
optional = true
```

No changes to `[build-dependencies]`. The `pikchr` crate handles its own C
compilation via its own `build.rs`. The `cc` crate it depends on is pulled
in transitively.

#### 5.3.2 `src/lib.rs`

Add the conditional module declaration alongside `mermaid_renderer`:

```rust
pub(crate) mod mermaid_renderer;
#[cfg(feature = "pikchr")]
pub(crate) mod pikchr_renderer;
```

#### 5.3.3 `src/markdown_renderer.rs`

**New field in `MarkdownRenderer`** (after line 592):

```rust
mermaid: MermaidRenderer,
#[cfg(feature = "pikchr")]
pikchr: pikchr_renderer::PikchrRenderer,
```

**Constructor** (`MarkdownRenderer::new()`, after line 965):

```rust
mermaid,
#[cfg(feature = "pikchr")]
pikchr: pikchr_renderer::PikchrRenderer::new(),
```

**Code block dispatch** (`render_code_block()`, after the Mermaid check at line 3897):

```rust
// Special handling for Mermaid diagrams
if let Some(lang) = language {
    if lang.eq_ignore_ascii_case("mermaid") {
        let _ = self.render_mermaid_block(ui, code);
        ui.add_space(8.0);
        return;
    }
    #[cfg(feature = "pikchr")]
    if lang.eq_ignore_ascii_case("pikchr") {
        let _ = self.render_pikchr_block(ui, code);
        ui.add_space(8.0);
        return;
    }
}
```

Note: We recognise only `pikchr` as the language identifier, not `pic`. PIC is
a distinct AT&T language with different syntax. Treating `pic` blocks as Pikchr
would cause confusing errors for users with genuine PIC diagrams.

**Context menu**: Neither Mermaid nor Pikchr diagram blocks currently have a
right-click context menu (e.g., "Copy SVG", "Copy as PNG", "View source").
This is a known limitation shared with Mermaid and is out of scope for initial
Pikchr integration. If context menus are added later, they should be added to
both diagram types simultaneously for UI consistency.

**New method** (near `render_mermaid_block` at line 3993):

```rust
#[cfg(feature = "pikchr")]
fn render_pikchr_block(&self, ui: &mut egui::Ui, code: &str) -> bool {
    self.pikchr
        .render_block(ui, code, self.ui_scale(), self.font_sizes.code)
}
```

**Syntax highlight skip** (in `highlight_code()`, after the Mermaid skip at line 5785):

```rust
// Skip mermaid blocks - they're rendered as diagrams, not highlighted code
if lang.eq_ignore_ascii_case("mermaid") {
    return None;
}
#[cfg(feature = "pikchr")]
if lang.eq_ignore_ascii_case("pikchr") {
    return None;
}
```

**Frame lifecycle** (in the method that calls `self.mermaid.begin_frame()` at line 2737):

```rust
self.mermaid.begin_frame();
#[cfg(feature = "pikchr")]
self.pikchr.begin_frame();  // No-op; API symmetry with MermaidRenderer
```

**GPU release** (`release_gpu_textures()` at line 5456):

```rust
pub fn release_gpu_textures(&self) {
    self.emoji_textures.borrow_mut().clear();
    self.image_textures.borrow_mut().clear();
    self.mermaid.release_gpu_textures();
    #[cfg(feature = "pikchr")]
    self.pikchr.release_gpu_textures();
}
```

**Pending check** (`has_pending_renders()` at line 5423): No change needed.
Pikchr renders synchronously and is never pending.

#### 5.3.4 `src/app.rs`

No direct changes needed. The app interacts with `MarkdownRenderer`, which
internally manages the `PikchrRenderer`. All lifecycle calls (begin_frame,
release_gpu_textures, has_pending_renders) already delegate through
`MarkdownRenderer`.

#### 5.3.5 `build.rs`

No changes needed. The `pikchr` crate handles its own C compilation.

#### 5.3.6 `src/sample_files.rs`

Add a new sample entry to the `SAMPLE_FILES` array (after the "Inline Images
& Diagrams" entry):

```rust
SampleFile {
    name: "pikchr.md",
    title: "Pikchr Diagrams",
    content: PIKCHR_CONTENT,
},
```

Add the content as an inline const (matching the existing pattern -- most
samples use inline `const`, only `stress_test.md` uses `include_str!`):

```rust
const PIKCHR_CONTENT: &str = r#"# Pikchr Diagrams

mdmdview supports [Pikchr](https://pikchr.org) diagrams -- a PIC-like
markup language for diagrams in technical documentation.

## Simple Flow

```pikchr
arrow right 200% "Request" above
box "Server" fit rad 10px
arrow right 200% "Response" above
```

## Architecture Diagram

```pikchr
box "Browser" fit rad 10px
arrow right 250% "HTTP" above
box "Web Server" fit rad 10px
arrow right 250% "SQL" above
cylinder "Database" fit
```

## Decision Flow

```pikchr
box "Start" fit rad 50%
arrow down
diamond "OK?" fit
arrow right 200% "Yes" above
box "Done" fit rad 50%
move to 2nd last diamond.s
arrow down "No" ljust
box "Retry" fit rad 10px
arrow left then up then right to 1st box.w
```
"#;
```

**Update test assertion**: The existing `test_sample_files_exist` test asserts
`SAMPLE_FILES.len() == 7`. This must be updated to `8`.

#### 5.3.7 `CLAUDE.md`

Update the following sections:

**Architecture > Core Components**: Add a new subsection after Mermaid:

> 8. **Pikchr Renderer** (`src/pikchr_renderer.rs`)
>    - Pikchr diagram rendering via embedded C library
>    - Synchronous rendering (no worker threads)
>    - SVG rasterization via usvg/resvg (shared pipeline with Mermaid)
>    - Texture caching with LRU eviction
>    - Dark mode support via native `PIKCHR_DARK_MODE` flag

**Feature Flags and Environment Variables > Cargo Features**: Add:

> - `pikchr`: Enables embedded Pikchr diagram rendering (default)
>   - Disable with: `cargo build --no-default-features --features mermaid-embedded`
>   - Adds `pikchr` crate dependency (C library compiled at build time)

---

## 6. Testing Strategy

### 6.1 Unit Tests (in `pikchr_renderer.rs`)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_render_simple_diagram() {
        let svg = PikchrRenderer::render_pikchr_to_svg(
            "box \"Hello\" fit",
            false,
        );
        assert!(svg.is_ok());
        let svg = svg.unwrap();
        assert!(svg.contains("<svg"));
        assert!(svg.contains("Hello"));
    }

    #[test]
    fn test_render_dark_mode_produces_different_svg() {
        let light = PikchrRenderer::render_pikchr_to_svg("box \"Test\" fit", false).unwrap();
        let dark = PikchrRenderer::render_pikchr_to_svg("box \"Test\" fit", true).unwrap();
        assert_ne!(light, dark);
    }

    #[test]
    fn test_render_invalid_syntax() {
        let result = PikchrRenderer::render_pikchr_to_svg(
            "this is not valid pikchr syntax }{}{",
            false,
        );
        assert!(result.is_err());
    }

    #[test]
    fn test_render_empty_input() {
        let result = PikchrRenderer::render_pikchr_to_svg("", false);
        // Empty input produces empty/minimal SVG, not an error
        assert!(result.is_ok());
    }

    #[test]
    fn test_svg_cache_key_differs_by_dark_mode() {
        let key_light = svg_cache_key(12345, false);
        let key_dark = svg_cache_key(12345, true);
        assert_ne!(key_light, key_dark);
    }

    #[test]
    fn test_svg_cache_key_differs_by_code_hash() {
        let key1 = svg_cache_key(12345, false);
        let key2 = svg_cache_key(67890, false);
        assert_ne!(key1, key2);
    }

    #[test]
    fn test_texture_key_includes_all_components() {
        let key = format!("pikchr:{:016x}:w{}:s{}:dm{}", 12345u64, 640, 100, 0);
        assert!(key.contains("pikchr:"));
        assert!(key.contains(":w640:"));
        assert!(key.contains(":s100:"));
        assert!(key.contains(":dm0"));
    }

    #[test]
    fn test_svg_contains_dimensions() {
        let svg = PikchrRenderer::render_pikchr_to_svg(
            "box \"Test\" fit",
            false,
        ).unwrap();
        assert!(svg.contains("width") || svg.contains("viewBox"));
    }

    #[test]
    fn test_complex_diagram() {
        let code = r#"
            arrow right 200% "Markdown" "Source"
            box rad 10px "Pikchr" "Renderer" fit
            arrow right 200% "SVG" "Output"
            box rad 10px "Rasterizer" fit
        "#;
        let svg = PikchrRenderer::render_pikchr_to_svg(code, false);
        assert!(svg.is_ok());
    }

    #[test]
    fn test_width_bucketing() {
        // Same bucket for nearby widths
        assert_eq!(bucket_width(640.0), bucket_width(641.0));
        assert_eq!(bucket_width(640.0), bucket_width(660.0));
        // Different buckets for widths 32px+ apart
        assert_ne!(bucket_width(640.0), bucket_width(673.0));
    }

    #[test]
    fn test_renderer_new_creates_empty_caches() {
        let renderer = PikchrRenderer::new();
        // No panics, caches start empty
        assert!(!renderer.has_pending());
    }
}
```

### 6.2 Integration Tests (in `markdown_renderer.rs`)

```rust
#[cfg(feature = "pikchr")]
#[test]
fn test_pikchr_code_block_parsed() {
    let renderer = MarkdownRenderer::new();
    let elements = renderer.parse("```pikchr\nbox \"Hello\"\n```");
    assert_eq!(elements.len(), 1);
    match &elements[0] {
        MarkdownElement::CodeBlock { language, .. } => {
            assert_eq!(language.as_deref(), Some("pikchr"));
        }
        _ => panic!("Expected CodeBlock"),
    }
}

#[cfg(feature = "pikchr")]
#[test]
fn test_pikchr_not_syntax_highlighted() {
    let renderer = MarkdownRenderer::new();
    let elements = renderer.parse("```pikchr\nbox \"Hello\"\n```");
    match &elements[0] {
        MarkdownElement::CodeBlock { highlighted, .. } => {
            assert!(highlighted.is_none(), "Pikchr blocks should skip syntax highlighting");
        }
        _ => panic!("Expected CodeBlock"),
    }
}
```

### 6.3 Test Coverage Goals

| Area                        | Test type     | Count |
|-----------------------------|---------------|-------|
| SVG rendering (valid input) | Unit          | 4-6   |
| SVG rendering (errors)      | Unit          | 2-3   |
| Dark mode SVG differences   | Unit          | 1-2   |
| Cache key correctness       | Unit          | 3-4   |
| Width bucketing              | Unit          | 1-2   |
| Renderer construction        | Unit          | 1     |
| Language detection           | Integration   | 1-2   |
| Syntax highlight skip       | Integration   | 1     |
| **Total**                   |               | ~18   |

---

## 7. Performance Considerations

### 7.1 Rendering Speed

Pikchr renders in microseconds. Even a complex diagram with dozens of objects
completes in under 1 millisecond. This is fast enough to render synchronously
within an egui frame (16ms budget at 60 FPS) without any perceptible lag.

### 7.2 SVG Rasterization

The SVG-to-RGBA rasterization via `usvg`/`resvg` is the more expensive step
(typically 1-10ms depending on diagram complexity and output size). This is
still well within frame budget, especially since:

- Results are cached (subsequent frames are texture lookups only)
- Pikchr diagrams are typically simpler than Mermaid diagrams
- The cache key bucketing prevents re-rasterization for minor width changes

### 7.3 Memory Footprint

| Component                  | Estimated size        |
|----------------------------|-----------------------|
| `pikchr.c` compiled code   | ~100 KB in binary     |
| SVG cache (64 entries)     | ~256 KB typical       |
| Texture cache (64 entries) | ~10-50 MB GPU memory  |
| Error cache (32 entries)   | ~16 KB                |

The binary size increase is minimal (~100 KB for the compiled C code).

### 7.4 Compared to Mermaid

| Metric                   | Mermaid              | Pikchr              |
|--------------------------|----------------------|---------------------|
| Binary size overhead     | ~3.3 MB (mermaid.js) | ~100 KB (pikchr.c)  |
| Render time (typical)    | 500ms - 5s           | 0.05 - 1ms          |
| Worker threads needed    | 1-4                  | 0                   |
| Memory (JS runtime)      | ~50 MB per worker    | 0                   |
| Async machinery          | Channels, pending    | None                |
| Code complexity          | ~9,000 lines         | ~300-500 lines      |

### 7.5 Known Risks

**Font resolution**: The Pikchr rasterizer uses `usvg::Options::default()`,
which loads system fonts but does not share Mermaid's custom `fontdb`. Pikchr
generates simple SVGs with basic text labels (typically sans-serif), so this is
unlikely to cause issues. If font problems arise on specific systems, the fix
is to pass a shared `Arc<fontdb::Database>` to `usvg::Options`, matching
Mermaid's approach.

---

## 8. File Summary

| File                       | Action     | Description                                       |
|----------------------------|------------|---------------------------------------------------|
| `Cargo.toml`               | Modify     | Add `pikchr` feature and dependency               |
| `src/lib.rs`               | Modify     | Add `#[cfg(feature = "pikchr")] mod pikchr_renderer` |
| `src/pikchr_renderer.rs`   | **Create** | New module: PikchrRenderer (~300-500 lines)       |
| `src/markdown_renderer.rs` | Modify     | Add pikchr field, dispatch, lifecycle integration |
| `src/sample_files.rs`      | Modify     | Add Pikchr sample content + update test assertion |
| `CLAUDE.md`                | Modify     | Document Pikchr feature and architecture          |

No changes to: `build.rs`, `src/app.rs`, `src/main.rs`, `src/mermaid_renderer.rs`,
`src/window_state.rs`.

---

## 9. Rollout and Risk

### 9.1 Risks

| Risk                                    | Likelihood | Impact | Mitigation                               |
|-----------------------------------------|------------|--------|------------------------------------------|
| `pikchr` crate becomes unmaintained     | Low        | Low    | Can vendor `pikchr.c` directly if needed |
| C compilation fails on some platforms   | Low        | Medium | `cc` crate is battle-tested; CI catches  |
| Pikchr SVG not compatible with usvg     | Low        | Medium | Pikchr generates simple, clean SVG       |
| Binary size objections                  | Very low   | Low    | ~100 KB is negligible                    |
| Font resolution issues on some systems  | Low        | Low    | Fall back to shared fontdb if needed     |
| Pathologically large Pikchr input       | Very low   | Medium | Pikchr has no documented resource limits. A multi-megabyte input could cause long render times or OOM. Mitigate by truncating input beyond a reasonable threshold (e.g., 64 KB) with an error message. Deferred: unlikely in normal use; can add if reported. |

### 9.2 Rollout Plan

1. Add `pikchr` dependency and feature flag to `Cargo.toml`
2. Add module declaration to `src/lib.rs`
3. Create `src/pikchr_renderer.rs` with core rendering + cache + error handling
4. Wire into `markdown_renderer.rs` (field, dispatch, lifecycle)
5. Write unit tests in `pikchr_renderer.rs`
6. Write integration tests in `markdown_renderer.rs`
7. Add Pikchr sample content to `sample_files.rs` + update test assertion
8. **Verify sample diagrams**: Run each sample Pikchr snippet from section 5.3.6
   through `Pikchr::render()` in a unit test to confirm they produce valid SVG.
   Fix any syntax errors before shipping.
9. Build debug + release, run full test suite
10. Update `CLAUDE.md` to document the Pikchr feature

### 9.3 Version Bump

This is a new feature (backward-compatible addition): **minor version bump**.
`1.6.0` -> `1.7.0`.

---

## 10. Future Considerations

These are explicitly **out of scope** for this change but worth noting:

- **Shared SVG rasterization utility**: If we add more diagram types, extract
  the SVG-to-texture pipeline into a shared module. For now, the minor
  duplication between Mermaid and Pikchr rasterization is acceptable (Mermaid's
  is heavily specialized with viewBox manipulation, bbox correction, HTML entity
  conversion, diagram-specific SVG patching, etc.)

- **Shared LruCache module**: Three separate `LruCache` definitions exist
  (markdown_renderer, mermaid_renderer, and now pikchr_renderer). A shared
  utility module would reduce duplication. Deferred to avoid touching working
  code for a cosmetic improvement.

- **Pikchr syntax highlighting**: The code block source could benefit from basic
  syntax highlighting (keywords, strings, numbers). Low priority.

- **Live preview in raw mode**: Editing Pikchr source in raw mode and seeing
  the diagram update in real-time. Would require a split-pane view.

- **User-facing documentation updates**: The existing welcome sample
  (`welcome.md`) and usage sample could mention Pikchr alongside Mermaid as a
  supported diagram type. The Pikchr-specific sample (section 5.3.6) provides
  dedicated examples, but a one-line mention in the welcome/usage samples would
  improve discoverability for users who don't browse the Samples menu.

- **Context menus on diagram blocks**: Right-click menus for "Copy SVG",
  "Copy as PNG", "View source" would be useful for both Mermaid and Pikchr
  diagram blocks. Should be implemented as a shared feature for all diagram
  types, not Pikchr-specific.

---

## References

- [Pikchr Official Site](https://pikchr.org/home/doc/trunk/homepage.md)
- [Pikchr User Manual](https://pikchr.org/home/doc/trunk/doc/userman.md)
- [Pikchr Integration Guide](https://pikchr.org/home/doc/trunk/doc/integrate.md)
- [Pikchr Download Options](https://pikchr.org/home/doc/trunk/doc/download.md)
- [`pikchr` Rust crate](https://lib.rs/crates/pikchr)
- [`pikchr` crate source](https://github.com/kinnison/pikchr)
- [`pikchr` API docs](https://docs.rs/pikchr/0.1.4/pikchr/)

# Table Column Stabilization & Divider Alignment (Revised)

**Revision Date:** 2025-11-14

## 0. Revision History
| Date | Author | Notes |
|------|--------|-------|
| 2025-11-14 | Codex | Initial draft circulated. |
| 2025-11-14 | Codex | Post-review overhaul: clarified column heuristics, stats collection, width caching, user-resize flow, and compatibility details. |

## 1. Summary
- **Audience:** renderer/table engineers, reviewers, QA.
- **Goal:** eliminate the divider and column-width defects shown in `Screenshot 2025-11-14 121230.png` by (a) redesigning column sizing heuristics and (b) explicitly painting stable vertical separators when `table_wrap_overhaul_enabled` is active.
- **Scope:** `ColumnSpec` derivation, `TableMetrics`, TableBuilder rendering path, QA/docs/tests. Legacy `egui::Grid` path remains untouched aside from regression testing.

## 2. Problem Statement
1. **Dividers wander or overwrite text.** The TableBuilder path never draws separators and queries `ui.available_width()` per cell, so minor layout jitter manifests as stray lines or missing gutters.
2. **Columns swap priorities.** Heuristics mark Description as `Remainder` while Examples is capped at 200 px, so Description balloons and Examples shrinks—even though the sample table shows the exact opposite need. Hard-coded pixel constants also ignore DPI changes.
3. **Widths leak between tables.** `TableMetrics` stores only per-row heights; column widths recompute from scratch every frame and there is no per-table identity, so wide tables briefly stretch narrow tables when flipping between tabs.

## 3. Goals & Non-Goals
- **Goals**
  1. Deterministic divider placement that never covers glyphs and remains stable while scrolling/resizing.
  2. Column sizing that blends semantic hints, measured content, and DPI scaling so “Examples” style columns consistently receive the widest share.
  3. Respect the existing View > Table Wrap toggle and command-line flags.
- **Non-Goals**
  - No additional UI controls (sticky headers, manual column reordering, etc.).
  - No changes to the legacy `Grid` renderer beyond regression coverage.

## 4. Current State Analysis (Reviewed)
| Area | Finding | Issue |
|------|---------|-------|
| Heuristics | Static mapping keyed only on header text. | Ignores actual cell content; only first remainder wins, so later wide columns never expand. |
| Rendering | Each cell uses `ui.available_width()`; no `TableBody::widths()` usage; no separators. | Causes the “off-by-one” look, stripes overlap glyphs, and there is no way to align dividers. |
| Metrics | `TableMetrics` tracks only row heights keyed by row index. | No place to cache resolved widths, no table identity, and no comparison to know when to request a second pass. |
| DPI | Fixed pixel values (120/150/200). | At 125% scale Description gains an extra px while Examples loses one, exaggerating mismatch. |
| User resizing | Column policies mark only heuristic-based columns as `Resizable`. | Manual drag state is forgotten between frames because we rebuild specs every time. |

## 5. Proposed Design (Post-Review)

### 5.1 Column Policy & Stats
1. **Context struct:** Introduce `TableColumnContext { headers, rows, body_font_px, table_id }`. `derive_column_specs(ctx: &TableColumnContext)` replaces the old signature so heuristics can use font scale and stats.
2. **Stats sampling:** Implement `compute_column_stats(rows, max_samples)` that scans up to 128 visible rows (or all rows if fewer) and returns:
   - `max_text_width_em` (using existing `measure_inline_spans` converted to ems to remain DPI independent).
   - `longest_word_chars` (used to detect wide unbreakable tokens).
   - `rich_content_flags` (emoji/image/link counts).
   - Results cached per `table_id` + `row_version` to avoid rescan unless the markdown changes.
3. **Heuristic rules (applied in order):**
   - Columns explicitly tagged as id/version/date keep `Fixed` policy with width = `(factor * body_font_px)`; factors are stored centrally so UI scaling remains consistent.
   - The first column defaults to `Fixed` 7.5× body font unless stats indicate >2× width need, in which case it becomes `Resizable`.
   - Description/Details columns become `Resizable { min=12×body_font, preferred=18×body_font }`.
   - Examples/Sample/Use cases columns become `Remainder` unless stats say they are actually short; if remainder already assigned, convert the largest-stat column to `Remainder`.
   - If no column qualifies, the widest measured column becomes `Remainder` to guarantee at least one flexible column.
4. **User resize persistence:** Store `HashMap<policy_hash, f32>` inside `TableMetrics` keyed by column id. When egui notifies a resize on a `Resizable` column, update the map and seed `Column::initial()` with the persisted width next frame.
5. **Tooltips:** Show both semantic rule and actual px (e.g., “Examples: Remainder (shared, min 14×body ≈ 196 px)”).

### 5.2 Divider Rendering Pipeline
1. **Width capture:** Within `table.body(|body| { … })`, after `heterogeneous_rows`, call `let widths = body.widths().to_vec();`. Store them via `table_metrics.update_widths(table_id, &widths, frame_id)`.
2. **Spacing & padding:** 
   - Apply `table.spacing_mut().cell_padding = Vec2::splat(6.0);` and set `ui.spacing_mut().item_spacing = vec2(4.0, 2.0)` before rendering cells to guarantee at least 3 px of whitespace from dividers.
3. **Painting dividers:**
   - Compute cumulative sums anchored to `body.max_rect().left()`.
   - Paint all interior lines using `painter.vline` and `separator_stroke = ui.visuals().widgets.noninteractive.bg_stroke.with_width(1.0)`.
   - Draw an outer border using `ui.painter().rect_stroke` to match existing frame visuals.
4. **Jitter control:**
   - `update_widths` returns `WidthChange::None | Small | Large`. When `Large`, call `ctx.request_discard("table-width-settle")`. Guard with `last_discard_frame` so we request at most once per frame.
   - While waiting for the next frame, continue painting using previous stable widths to avoid flicker.
5. **Selection/hover compatibility:** Dividers are painted after rows, so they do not intercept pointer events; we rely on `painter.layer_id()` equal to `LayerId::new(Order::Foreground, ...)` to keep lines above backgrounds but below tooltips.

### 5.3 Metrics & Identity
1. **Table identity:** Compute `table_id = hash(headers, rows.len(), file_path?)` once per markdown table render call. Store metrics in `HashMap<table_id, TableMetrics>` so switching documents no longer leaks widths.
2. **TableMetrics struct:**
   ```rust
   struct TableMetrics {
       rows: Vec<RowMetric>,
       resolved_widths: Vec<f32>,
       last_width_frame: u64,
       last_discard_frame: Option<u64>,
       persisted_column_widths: HashMap<u64, f32>,
   }
   ```
3. **Lifecycle:** `clear_table_layout_cache()` clears both layout cache and metrics map. Toggling table wrap or changing fonts also resets entries to avoid stale values.

### 5.4 DPI & Measurement Strategy
- Replace numeric literals with helpers such as `fn px(body: f32, factor: f32) -> f32 { body * factor }` and centralize factors (first column 7.5, version 5.0, etc.).
- Stats reported in ems so they survive DPI changes; only when building `ColumnPolicy` do we convert to px.
- Tests use deterministic body font sizes to avoid snapshot drift.

### 5.5 Compatibility & Feature Flags
- `TableBody::widths()` arrived in egui 0.27; our dependency is already ≥0.28, but we add a `#[cfg]` guard so the code compiles if someone targets an older egui for tests.
- Divider painting is active only in the overhaul path (`table_wrap_overhaul_enabled`). The legacy path still uses `Grid` for determinism.\n
### 5.6 Edge Cases Considered
- **Single-column tables:** Remainder rule degenerates to a single column; dividers are skipped.
- **Tables wider than viewport:** Divider painting uses clipped rect so lines do not leak into scrollbars; we use `clip_rect = body.clip_rect()`.
- **Emoji/image-only columns:** Stats detect non-textual content and set a minimum width (10× body font) to avoid comically narrow emoji columns.

## 6. Implementation Plan
1. **Context plumbing** – Create `TableColumnContext` and thread it through `derive_column_specs`. Update callers and tests.
2. **Stats module** – Implement `compute_column_stats` + caching, with unit tests covering mixed content and sampling limits.
3. **Heuristics rewrite** – Encode the rule set above, ensure only one remainder column, and integrate persisted widths.
4. **Metrics refactor** – Extend `TableMetrics`, add per-table map, implement `update_widths` + persistence helpers.
5. **Renderer updates** – Apply spacing tweaks, render cells with new padding, capture widths, paint dividers, handle `request_discard`.
6. **Escapes & config** – Add `
7. **Docs/tests** – Update QA doc, add regression markdown (threat-model table) plus tests for width ordering, tweak README features section.

## 7. Testing Strategy
- **Unit tests**
  - `column_spec.rs`: cases for Description/Examples, fallback remainder, stats override, DPI scaling math.
  - `table_metrics.rs` (new) to verify width-change thresholds and persistence storage.
- **Integration tests**
  - Renderer harness that feeds the regression table and inspects `TableMetrics::resolved_widths` to ensure `Examples >= Description + 40 px` across DPI variants.
  - Verify divider painting toggles via env flag.
- **Manual QA**
  - Load regression samples at 100/125/150% DPI; resize window; confirm dividers stay aligned and user-resized columns persist.
  - Toggle table wrap on/off and confirm legacy renderer unaffected.
- **Performance**
  - Benchmark 5k-row table before/after; target <5% regression. Sampling limited rows and caching widths minimizes additional work.

## 8. Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|------------|
| Width stats scanning large tables | Low/Med | Limit scan to first 128 rows and reuse cached stats unless markdown changes. |
| `request_discard` loop on oscillating widths | Medium | Track last discard frame and require >=1 frame between requests; also clamp widths before comparison. |
| Divider stroke clashes with custom themes | Low | Use visuals-derived colors and expose env flag to disable. |
| User-resize persistence conflicts with heuristic updates | Medium | Persisted widths always win unless user double-clicks reset or column disappears; add dev tool to clear persistence. |

## 9. Rollout Checklist
1. Implement and land column-spec/context/stat changes with tests.
2. Land metrics refactor + divider painting.
3. Update docs/QA/regression assets; document env flag.
4. `cargo fmt && cargo clippy --all-targets -D warnings && cargo test`.
5. Capture before/after screenshots for release notes and attach to PR.

## 10. Outstanding Questions (Tracked)
| # | Question | Resolution |
|---|----------|------------|
| 1 | Should divider env flag default to off for ultra-low GPUs? | No; default on, but QA verifies fallback. |
| 2 | How to identify tables uniquely? | Hash of header text, row count, file path (relative) to keep collisions low. |
| 3 | Do we need sticky headers? | Out of scope; revisit once sizing/dividers ship. |


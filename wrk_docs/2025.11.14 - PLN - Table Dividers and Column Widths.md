# Implementation Plan — Table Divider Alignment & Column Width Corrections

**Plan Date:** 2025-11-14  
**Linked HLD:** wrk_docs/2025.11.14 - HLD - Table Dividers and Column Widths.md

## Stage 0 – Preparation
- [ ] Create tracking issue referencing the HLD and attach screenshot 2025-11-14 121230.png.
- [ ] Capture current behavior (screenshots + notes) for `examples/regressions/table-threat-model.md` at 100% DPI.
- [ ] Branch from `feat/table-column-fixes` (or rebase onto latest master).

## Stage 1 – Context & Metrics Plumbing
**Goal:** provide renderer + column logic with font scale, stats, and per-table storage.

Tasks:
1. Add `TableColumnContext { headers, rows, stats, body_font_px, table_id }` and thread it through `derive_column_specs`.
2. Implement `compute_column_stats(rows, max_samples=128)` with grapheme counts, longest word, and rich-content flags per column.
3. Add `column_stats_cache: HashMap<table_id, ColumnStatsCacheEntry>` inside `MarkdownRenderer`; use table+content hashes for invalidation.
4. Extend `TableMetrics` to store per-table entries with `resolved_widths`, `persisted_column_widths`, `last_width_frame`, `last_discard_frame`.
5. Update cache-clear path to wipe both layout cache and table metrics/stats.

Exit Criteria:
- `column_spec` unit tests build with the new context signature.
- Renderer compiles and stats cache hits during repeated renders (log via debug output or QA notes).

## Stage 2 – Heuristic Rewrite & DPI Scaling
**Goal:** ensure Examples columns capture remainder width, Description stays moderate, and overrides use body font scale.

Tasks:
1. Replace magic pixel widths with helpers like `px(body_font_px, factor)` sourced from renderer state.
2. Update `classify_column` to match semantic rules (Examples ⇒ remainder, Description ⇒ resizable, metadata ⇒ fixed/resizable) and assign fallback remainder via stats.
3. Add tooltips reflecting semantic rule + computed px width.
4. Expand unit coverage (Examples remainder, stats-based fallback, DPI scaling).

Exit Criteria:
- `cargo test column_spec` passes with new cases.
- Manual run: `examples/regressions/table-threat-model.md` shows Examples wider than Description at 100% DPI.

## Stage 3 – Renderer Integration
**Goal:** feed computed context, capture resolved widths, persist user resizes, and provide per-table row metrics.

Tasks:
1. Compute `table_id` per table render and pass `TableColumnContext` into `derive_column_specs`.
2. Before rendering rows, seed resizable columns with `persisted_column_widths` (if any); after rendering, capture `body.widths().to_vec()`.
3. Update row-height hint/update paths to operate per table ID.
4. Store resolved widths via `TableMetricEntry::update_widths(table_id, widths, frame_id)`; persist resizable widths if they change >ε.
5. Expose `table_render_stats()` via `TableMetrics::totals()` so UI still reports accurate stats.

Exit Criteria:
- `cargo fmt`, `cargo test column_spec`, and metrics unit tests pass.
- Manual: resizable column adjustments persist after restart.

## Stage 4 – Divider Overlay
**Goal:** draw theme-aware dividers/borders without interfering with content.

Tasks:
1. After capturing widths, compute cumulative x-positions using `body.max_rect()` and `body.ui().clip_rect()`.
2. Paint vertical lines with `painter.vline(x.round() + 0.5, rect.y_range(), separator_stroke)` (stroke derived from visuals) and draw outer border via `painter.rect_stroke`.
3. Add gutter padding (`spacing.item_spacing.x = 6.0`) before rendering cells to prevent overlaps.
4. If `update_widths` reports `WidthChange::Large` (>0.75 px) request a repaint once per frame to settle widths before painting.
5. Optionally add a logger flag to debug width capture in QA builds.

Exit Criteria:
- Visual verification: dividers align even during resize and don’t cut through text.
- QA on threat-model sample at 100/125/150% DPI shows stable gutters.

## Stage 5 – Docs, QA & Release Prep
**Goal:** ensure documentation and samples describe the new behavior.

Tasks:
1. Update README advanced features (already partially done) and add a “divider overlay” description after implementation.
2. Finalize `docs/QA-table-wrap.md` section with the exact steps + expected screenshots.
3. Capture before/after screenshots for threat-model sample after divider work lands.
4. Run full `cargo fmt`, `cargo clippy --all-targets -D warnings`, and `cargo test`.
5. Prepare release-note entries referencing the regression fix and attach screenshots.

Exit Criteria:
- Docs reviewed; QA sign-off recorded.
- CI clean and PR ready for review.

## Stage 6 – Rollout & Monitoring
- Merge feature branch once approved.
- Post screenshots + summary in release notes under “Table Rendering”.
- Monitor issue tracker; if divider overlay causes GPU issues, consider a follow-up flag or hotfix.
- Close tracking issue after monitoring window.

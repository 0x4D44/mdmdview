# HLD — D2 Orthogonal Edge Routing

**Date:** 2026-02-21
**Author:** Claude Opus 4.6 + Arthur
**Status:** Draft
**Crate:** `mdmdview-d2` (`crates/d2/`)

---

## 1. Problem Statement

The current edge routing produces diagonal Bézier curves between node centers. For diagrams with multiple cross-container edges — especially with `direction: right` — this creates visual chaos:

```
direction: right

services: Services {
  gw: API Gateway
  auth: Auth Service
  orders: Order Service
  notify: Notification Service
  gw -> auth: verify token
  gw -> orders: route request
  orders -> notify: order placed
}

data: Data Layer {
  pg: PostgreSQL {shape: cylinder}
  redis: Redis {shape: cylinder}
  s3: Object Store {shape: cylinder}
}

lb -> services.gw: HTTPS
services.auth -> data.redis: sessions
services.orders -> data.pg: CRUD
services.notify -> data.s3: templates
```

**Observed defects:**

| # | Symptom | Root Cause |
|---|---------|------------|
| 1 | Cross-container edges (auth→redis, orders→pg, notify→s3) form a tangled diagonal bundle | Center-to-center Bézier routing: all edges fan through the same gap area at different angles |
| 2 | Edge labels ("CRUD", "sessions", "templates") pile up on top of each other | Labels placed at geometric midpoint of diagonal paths that converge in the same area |
| 3 | Edges cross unnecessarily | No awareness of other edges; only parallel edges (same src/dst pair) are offset |
| 4 | Arrows enter/exit nodes at arbitrary angles | Shape clipping from center creates angled attachment points |

**What we want:** Edges should follow horizontal and vertical paths with clean right-angle turns — the standard look for architecture diagrams and the style used by the official D2 renderer (dagre/ELK).

---

## 2. How the Official D2 Renderer Handles This

The official D2 tool uses dagre (layered layout) with ELK's orthogonal edge routing. Key properties:

1. **Orthogonal paths** — Edges travel in axis-aligned segments only (horizontal or vertical, never diagonal)
2. **Port-based attachment** — Edges exit source and enter destination at specific port locations on the shape boundary, chosen based on direction
3. **Routing channels** — The gap between ranks contains a grid of channels where edge segments are spaced apart
4. **Labels on straight segments** — Labels are placed on the longest horizontal/vertical segment, never at a diagonal midpoint
5. **Rounded corners** — Bends use small arc radii (typically 2–5px) for visual polish

---

## 3. Design

### 3.1 Route Shape: Three-Segment Orthogonal Path

For a hierarchical layout, edges connect nodes in different ranks. The primary routing pattern is a **three-segment path**:

```
direction: right                    direction: down

  ┌─────┐                            ┌─────┐
  │ src ├──── exit ─┐                │ src │
  └─────┘           │ channel        └──┬──┘
                    │ (vertical)        │ exit
  ┌─────┐           │                   │ (vertical)
  │ dst ◄──── enter─┘            ┌──────┤ channel (horizontal)
  └─────┘                        │      │
                              ┌──▼──┐
                              │ dst │
                              └─────┘
```

**Segment definitions for `direction: right` (primary axis = X, cross axis = Y):**

| Segment | Direction | From | To |
|---------|-----------|------|----|
| Exit | Horizontal (+X) | Source shape right edge | Channel X position |
| Channel | Vertical (±Y) | Source Y level → Destination Y level | Along the channel X |
| Enter | Horizontal (+X) | Channel X position | Destination shape left edge |

For `direction: down`, swap X↔Y: exit is vertical (+Y), channel is horizontal (±X), enter is vertical (+Y).

**Degenerate cases:**

- **Same-Y nodes** (direction: right): Channel segment has zero length → collapses to a straight horizontal line. This is the common case for nodes in the same rank row.
- **Same-rank edges**: Source and destination are in the same rank. Route with a U-turn: exit sideways, jog perpendicular, re-enter. (Rare in practice for Sugiyama layouts.)
- **Adjacent rank, aligned**: Exit + enter with no channel = straight line.
- **Back-edges** (reversed during cycle removal): Route the same way as forward edges; the arrowhead direction is already correct.

### 3.2 Rank Metadata: Exposing Layout Structure to the Router

**Current problem:** The edge router (`edge_routing.rs`) runs after layout but has no access to rank structure. It only sees final `box_` positions.

**Solution:** Store rank boundaries on the graph so the router can compute channel positions.

```rust
// In graph.rs — add to D2Graph:

/// Rank boundary information computed during layout.
/// Used by edge routing to place orthogonal channel segments.
pub struct RankInfo {
    /// For each rank index, the extent in the primary axis.
    /// direction=right: (min_x, max_x) of all nodes in that rank.
    /// direction=down: (min_y, max_y) of all nodes in that rank.
    pub rank_extents: Vec<(f64, f64)>,

    /// The primary-axis midpoint between adjacent ranks.
    /// `channel_positions[i]` = midpoint between rank i and rank i+1.
    /// This is where vertical (or horizontal) channel segments run.
    pub channel_positions: Vec<f64>,

    /// Mapping from NodeIndex → rank index.
    pub node_rank: HashMap<NodeIndex, usize>,
}
```

**Populated by:** `layout_sugiyama.rs` after `assign_coordinates()` completes. The data is computed from the final node positions — no Sugiyama internals leak into the graph.

**Stored on:** `D2Graph.rank_info: Option<RankInfo>`. Set to `None` for empty diagrams or single-node layouts.

### 3.3 Channel Allocation: Preventing Edge Overlap

When multiple edges cross the same inter-rank gap, their channel segments must be spaced apart vertically (for direction=right) or horizontally (for direction=down).

**Algorithm:**

1. **Group edges by inter-rank gap.** An edge from rank `i` to rank `j` (where `j > i`) uses the gap between ranks `i` and `j-1` (it may span multiple gaps for long-span edges).

2. **Within each gap, sort edges by destination cross-position.** For direction=right, sort by destination Y. This ensures edges don't cross unnecessarily.

3. **Assign channel offsets.** Starting from the gap's channel center, spread edges using `CHANNEL_SPACING` (12px). The center edge gets offset 0; others are offset symmetrically.

```
Gap between rank 0 and rank 1 (direction: right):

  channel_x = midpoint of gap

  edge A (dst.y = 100) → channel_y stays at 100
  edge B (dst.y = 150) → channel_y stays at 150
  edge C (dst.y = 200) → channel_y stays at 200

  But if edges have the SAME destination Y range, offset:
  edge A, B both going to y≈150 → A at channel_x - 6, B at channel_x + 6
```

**For multi-rank-spanning edges** (e.g., rank 0 → rank 3), the edge needs to pass through intermediate gaps. The channel segment runs through all gaps at the same cross-axis position — no intermediate bends.

### 3.4 Port Selection: Where Edges Attach to Shapes

Instead of always using center-to-center direction for shape clipping, choose attachment ports based on the layout direction:

**For direction=right:**
- Source: right edge of shape (middle-right port)
- Destination: left edge of shape (middle-left port)

**For direction=down:**
- Source: bottom edge of shape
- Destination: top edge of shape

**Port Y/X position on the shape edge:**

When a node has multiple outgoing edges, space the ports along the shape edge to prevent overlap:

```rust
/// Compute exit port position on source shape.
fn exit_port(
    rect: &Rect,
    direction: Direction,
    port_index: usize,
    total_ports: usize,
) -> Point {
    let spacing = match direction {
        Direction::Right | Direction::Left => rect.height,
        Direction::Down | Direction::Up => rect.width,
    };

    // Distribute ports evenly along the exit edge
    let step = spacing / (total_ports as f64 + 1.0);
    let offset = step * (port_index as f64 + 1.0);

    match direction {
        Direction::Right => Point::new(rect.right(), rect.y + offset),
        Direction::Left => Point::new(rect.x, rect.y + offset),
        Direction::Down => Point::new(rect.x + offset, rect.bottom()),
        Direction::Up => Point::new(rect.x + offset, rect.y),
    }
}
```

Similarly for entry ports on the destination shape.

### 3.5 Rounded Corners

Bare right-angle bends look harsh. Add small radius arcs at each bend point.

**SVG representation:** Replace the sharp corner with a quadratic Bézier arc:

```
Sharp:   L channel_x, src_y  L channel_x, dst_y
Rounded: L channel_x-r, src_y  Q channel_x, src_y  channel_x, src_y+r
         L channel_x, dst_y-r  Q channel_x, dst_y  channel_x+r, dst_y
```

**Corner radius:** `BEND_RADIUS = 5.0` pixels. Clamped to half the shorter segment length so tight corners don't overshoot.

### 3.6 Route Data Format

The current `D2EdgeData.route: Vec<Point>` stores cubic Bézier control points. The SVG renderer interprets them as `M p0 C p1 p2 p3 C ...`.

**For orthogonal routes, we need a mixed path:** line segments + optional quadratic Bézier arcs at corners.

**Option A — Polyline with implicit rounding (chosen):**

Store the route as a sequence of waypoints. The SVG renderer adds rounded corners automatically:

```rust
// D2EdgeData — no change to field type
pub route: Vec<Point>,

// New field to distinguish path interpretation
pub route_type: RouteType,

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RouteType {
    /// Cubic Bézier: [start, ctrl1, ctrl2, end, ctrl1, ctrl2, end, ...]
    Bezier,
    /// Orthogonal polyline: [p0, p1, p2, ...] rendered as L segments
    /// with automatic rounded corners at bend points.
    Orthogonal,
}
```

The SVG renderer checks `route_type` and chooses the appropriate path construction:
- `Bezier` → existing `M ... C ...` logic (unchanged)
- `Orthogonal` → `M p0 L p1 L p2 ... L pN` with optional corner rounding

This keeps self-loops and any future curved edges on the Bézier path while new orthogonal routes use the polyline path.

### 3.7 Label Placement

For orthogonal routes, labels belong on the **longest straight segment** of the path:

```rust
fn orthogonal_label_position(route: &[Point]) -> Option<Point> {
    if route.len() < 2 {
        return None;
    }

    // Find the longest segment
    let mut best_len = 0.0f64;
    let mut best_mid = route[0];

    for pair in route.windows(2) {
        let dx = pair[1].x - pair[0].x;
        let dy = pair[1].y - pair[0].y;
        let len = dx.abs() + dy.abs(); // Manhattan for axis-aligned
        if len > best_len {
            best_len = len;
            best_mid = Point::new(
                (pair[0].x + pair[1].x) / 2.0,
                (pair[0].y + pair[1].y) / 2.0,
            );
        }
    }

    Some(best_mid)
}
```

For direction=right, the longest segment is typically the horizontal exit or enter segment. The label is centered on it with the existing halo background.

**Label offset:** Shift the label perpendicular to the segment by `font_size * 0.8` to sit above/beside the line rather than on top of it. For horizontal segments: shift Y upward. For vertical segments: shift X leftward.

### 3.8 Arrowhead Alignment

The existing `arrowhead_polygon()` function computes direction from the last two route points. This already works for orthogonal routes — the last segment is axis-aligned, so the arrowhead points in the correct cardinal direction.

No change needed to `arrowhead_polygon()` or `diamond_arrowhead()`.

### 3.9 SVG Renderer Changes

`svg_render.rs::render_edges()` currently builds the path as:

```rust
path = "M start C ctrl1 ctrl2 end C ctrl1 ctrl2 end ..."
```

Add a branch for orthogonal routes:

```rust
match edge.route_type {
    RouteType::Bezier => {
        // existing cubic Bézier logic (unchanged)
    }
    RouteType::Orthogonal => {
        path.push_str(&format!("M {} {}", route[0].x, route[0].y));

        if BEND_RADIUS > 0.0 && route.len() >= 3 {
            // Emit L segments with Q arcs at corners
            for i in 0..route.len() {
                // ... rounded corner logic per §3.5
            }
        } else {
            // Simple polyline
            for pt in &route[1..] {
                path.push_str(&format!(" L {} {}", pt.x, pt.y));
            }
        }
    }
}
```

### 3.10 Interaction with Existing Features

| Feature | Impact |
|---------|--------|
| **Self-loops** | No change. Self-loops already use a dedicated Bézier path (`self_loop_route`). They keep `RouteType::Bezier`. |
| **Parallel edges** | Parallel edges between the same pair use separate channel offsets (§3.3). The perpendicular offset logic in the current code is replaced by port spacing (§3.4). |
| **Animated/dashed edges** | `stroke-dasharray` applies identically to polyline paths. No change. |
| **Back-edges** | Routed identically to forward edges. Arrowhead direction is already correct. |
| **Shape clipping** | Replaced by port selection (§3.4) for orthogonal routes. `clip_to_shape` remains available for Bézier routes. |
| **Direction overrides** | Container-level direction overrides already produce different rank orientations. The router reads the effective direction from rank metadata. |

---

## 4. Implementation Plan

### Phase 1: Rank Metadata (Small)

**Files:** `graph.rs`, `layout_sugiyama.rs`, `layout.rs`

1. Add `RankInfo` struct and `D2Graph.rank_info` field to `graph.rs`
2. Add `RouteType` enum and `D2EdgeData.route_type` field to `graph.rs` (default: `Bezier`)
3. After `assign_coordinates()` in `layout_sugiyama.rs`, compute and store `RankInfo`:
   - Iterate final node positions to build `rank_extents`
   - Compute `channel_positions` as midpoints between adjacent rank extents
   - Build `node_rank` map
4. Store on graph in `layout.rs` after `layout_recursive()` completes

**Tests:**
- `rank_info` is populated for simple chain (`a -> b -> c`)
- `channel_positions` are between rank extents
- `node_rank` maps every non-root node to a rank

### Phase 2: Orthogonal Router (Core)

**Files:** `edge_routing.rs`

1. Add `route_orthogonal()` function alongside existing `route_all_edges()`
2. Implement three-segment path generation:
   - Exit port → channel position → enter port
   - Handle all four directions
3. Channel allocation: group edges by gap, sort by cross position, assign offsets
4. Port selection: compute exit/entry ports with multi-port spacing
5. Set `route_type = Orthogonal` on routed edges
6. Keep `self_loop_route()` on `Bezier` path
7. Update `route_all_edges()` to call `route_orthogonal()` when `rank_info` is available, falling back to the existing Bézier logic when it's not

**Tests:**
- Simple `a -> b` (direction=right): route is horizontal line (3 collinear points)
- `a -> b` (direction=down): route is vertical line
- Cross-rank with Y offset: route has 3 or 4 waypoints forming an L or Z shape
- Multiple edges same gap: channel offsets are spaced apart
- Self-loop: still uses Bézier route

### Phase 3: SVG Rendering (Small)

**Files:** `svg_render.rs`

1. Add `RouteType::Orthogonal` branch in `render_edges()`
2. Implement polyline path with rounded corners (§3.5)
3. Arrowhead rendering: no changes needed (direction from last segment)

**Tests:**
- SVG output contains `L` commands (not `C`) for orthogonal edges
- Rounded corners produce `Q` commands when `BEND_RADIUS > 0`
- Arrowheads point in correct cardinal direction

### Phase 4: Label Placement (Small)

**Files:** `edge_routing.rs`

1. Compute label position using `orthogonal_label_position()` for orthogonal routes
2. Offset label perpendicular to the segment direction
3. Keep existing midpoint logic for Bézier routes

**Tests:**
- Label on horizontal segment: Y above the line
- Label on vertical segment: X left of the line
- Label between shape boundaries (not overlapping nodes)

---

## 5. Constants

```rust
/// Spacing between parallel channel segments in the same inter-rank gap.
const CHANNEL_SPACING: f64 = 12.0;

/// Minimum gap between the last node edge and the channel center.
/// Ensures the exit/enter segments have visible length.
const MIN_STUB_LENGTH: f64 = 15.0;

/// Radius for rounded corners at orthogonal bends.
const BEND_RADIUS: f64 = 5.0;

/// Perpendicular offset for edge labels from the path segment.
const LABEL_OFFSET: f64 = 10.0;
```

---

## 6. Edge Cases

### 6.1 Long-Span Edges (Skipping Ranks)

An edge from rank 0 to rank 3 spans gaps 0–1, 1–2, and 2–3. The channel segment runs vertically through all three gaps at the same X position (for direction=right). The route is still three segments: exit → one long vertical → enter.

### 6.2 Same-Rank Edges

When source and destination are in the same rank (e.g., within a container's internal layout), the edge needs a U-turn:

```
  ┌─────┐    ┌─────┐
  │  a  ├──┐ │  b  │
  └─────┘  │ └──┬──┘
           │    │
           └────┘
```

Route: exit right → down (small jog) → left → enter bottom. This is a four-segment path. Use a small offset below both nodes.

### 6.3 Container Boundary Crossing

Cross-container edges (e.g., `services.auth -> data.redis`) are routed between the leaf nodes' absolute positions. The container boundary is not explicitly modeled in the route — the edge passes through the container border visually. This matches the official D2 renderer behavior.

### 6.4 Direction: Left and Up

For `direction: left`, the primary axis is -X. Exit ports are on the left of the source, entry ports on the right of the destination. Channel segments are vertical. The three-segment pattern is mirrored.

For `direction: up`, the primary axis is -Y. Exit ports are on top, entry on bottom. Channel segments are horizontal.

The implementation handles all four directions via the same code with axis swapping:

```rust
/// Primary and cross axes for a given direction.
fn axes(direction: Direction) -> (Axis, Axis, f64) {
    match direction {
        Direction::Right => (Axis::X, Axis::Y, 1.0),
        Direction::Left  => (Axis::X, Axis::Y, -1.0),
        Direction::Down  => (Axis::Y, Axis::X, 1.0),
        Direction::Up    => (Axis::Y, Axis::X, -1.0),
    }
}
```

### 6.5 Nodes with Many Edges

A node with 5+ outgoing edges could crowd the exit ports. The port distribution (§3.4) spaces them evenly along the shape edge. For very dense nodes, the spacing may become tight — clamp minimum port spacing to `4.0px`.

---

## 7. Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| Orthogonal routing may look worse for simple 2-node diagrams (straight line is better) | Degenerate case detection: when src and dst are aligned on the cross axis, emit a straight line (2 points, no bends) |
| Channel allocation complexity for large diagrams | Start with simple cross-position sorting. Can upgrade to full channel routing (sweep-line) later if needed. |
| Mixed Bézier/orthogonal in the same diagram | `RouteType` per-edge allows this. Self-loops stay Bézier; all other edges go orthogonal. |
| Rounded corners overshoot on short segments | Clamp `BEND_RADIUS` to `min(segment_length / 2)` at each corner |
| Regression in existing passing tests | The Bézier path is preserved as fallback. Existing edge label tests may need updating since label positions will change. |

---

## 8. What This HLD Does NOT Address

- **Edge-node avoidance**: Edges that pass through intermediate nodes' bounding boxes. This requires obstacle-aware routing (e.g., visibility graph or A*), which is significantly more complex. Deferred to a future iteration.
- **Edge crossing minimization**: The crossing reduction in Sugiyama handles node ordering, but edge routing can still produce crossings. Full crossing minimization in the routing phase is a separate problem.
- **Container descendant stranding** (V3 HLD bug A): This is a layout bug, not a routing bug. It should be fixed independently — orthogonal routing will produce correct paths given correct node positions.
- **Curved orthogonal edges**: Some renderers use spline-based routing that follows orthogonal corridors but with smooth curves. This HLD uses polyline + rounded corners, which is simpler and matches the official D2 aesthetic.

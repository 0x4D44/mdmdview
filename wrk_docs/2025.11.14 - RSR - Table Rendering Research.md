# Table Rendering Research Report

**Date:** 2025.11.14
**Author:** Claude
**Purpose:** Research open-source table rendering implementations to inform table column width and border fixes

---

## Executive Summary

This report synthesizes research from multiple sources on table rendering implementations, focusing on:
1. Column width calculation algorithms
2. Border and divider rendering approaches
3. Best practices from production Rust libraries

**Key Finding:** The current table rendering issues in mdmdview stem from:
- egui framework limitations (no native cell dividers)
- Column width calculation edge cases with text wrapping
- Potential off-by-one issues in column index mapping

**Recommended Approach:** Implement a 3-tier proportional distribution algorithm with grapheme-aware measurements and add manual border rendering using egui's painter API.

---

## Part 1: egui Table Implementations

### 1.1 Official egui_extras::TableBuilder

**Repository:** https://github.com/emilk/egui (crates/egui_extras)

**Column Sizing Strategies:**

The `Column` enum provides four sizing approaches:

```rust
// Auto-sizing based on content
Column::auto()

// Exact fixed width (never shrinks or grows)
Column::exact(width)

// Initial width with optional constraints
Column::initial(width).at_least(min).at_most(max)

// Remainder space (leftover after other columns sized)
Column::remainder()
```

**Basic Example:**

```rust
use egui_extras::{TableBuilder, Column};

TableBuilder::new(ui)
    .striped(true)
    .resizable(true)
    .cell_layout(egui::Layout::left_to_right(egui::Align::Center))
    .column(Column::auto())
    .column(Column::remainder().at_least(40.0).clip(true).resizable(true))
    .column(Column::auto())
    .header(20.0, |mut header| {
        header.col(|ui| { ui.heading("First"); });
        header.col(|ui| { ui.heading("Second"); });
        header.col(|ui| { ui.heading("Third"); });
    })
    .body(|mut body| {
        body.row(30.0, |mut row| {
            row.col(|ui| { ui.label("Cell 1"); });
            row.col(|ui| { ui.label("Cell 2"); });
            row.col(|ui| { ui.label("Cell 3"); });
        });
    });
```

**Known Issues with Column::auto():**

**Problem:** Columns past the first become too narrow, causing unwanted text wrapping despite available space.

**Root Cause:** Text wrapping during layout calculation. When columns are measured, wrapping text occupies less horizontal space, causing the layout engine to continue with reduced measurements.

**Workarounds:**

```rust
// Option 1: Disable text wrapping globally
ui.style_mut().wrap = Some(false);

// Option 2: Use non-wrapping labels
egui::Label::new(text).wrap(false)

// Option 3: Adjust spacing (partial fix)
ui.spacing_mut().item_spacing.x += 5.0;
```

### 1.2 Third-Party egui Table Libraries

**egui_commonmark** - Markdown Viewer with Table Support
- Repository: https://github.com/lampsitter/egui_commonmark
- Renders GFM tables as native egui widgets
- Basic usage:
  ```rust
  use egui_commonmark::*;
  let mut cache = CommonMarkCache::default();
  CommonMarkViewer::new().show(ui, &mut cache, markdown);
  ```

**egui_table (by rerun-io)** - Advanced Table Viewer
- Repository: https://github.com/rerun-io/egui_table
- Features: Auto-sized/resizable columns, hierarchical headers, sticky columns
- Supports millions of rows with virtual scrolling

**egui_tabular** - Table Editor
- Repository: https://github.com/romixlab/egui_tabular
- Features: CSV import/export, column reordering, keyboard navigation
- Fast and responsive with virtual scrolling

---

## Part 2: Border and Divider Rendering

### 2.1 Current State of egui Framework

**Critical Finding:** egui_extras::TableBuilder has **NO native support** for cell dividers.

**Open GitHub Issues:**
- Issue #4783: "egui_extras: table cell dividers"
- Issue #4158: "egui_extras: vertical separator between columns"

**Current Official Approach:**

```rust
TableBuilder::new(ui)
    .striped(true)  // Alternating row backgrounds only
```

This provides visual row separation using subtle background colors per `egui::Visuals::striped`.

### 2.2 Workarounds for Drawing Borders

**Option 1: Using egui Painter Methods**

```rust
// For vertical separators
ui.painter().vline(x, y_range, stroke);

// For horizontal separators
ui.painter().hline(x_range, y, stroke);

// For custom backgrounds/borders
ui.painter().rect_filled(rect, corner_radius, fill_color);
ui.painter().rect_stroke(rect, corner_radius, stroke);
```

**Known Issue:** `painter.vline()` and `painter.hline()` don't work with `Rangef::EVERYTHING`. Use specific range values like `Rangef::new(10.0, 200.0)` instead.

**Option 2: Using Frame for Outer Borders**

```rust
Frame::none()
    .stroke(Stroke::new(2.0, color))
    .show(ui, |ui| {
        // Table content
    });
```

**Limitation:** Applies borders on all four sides only (no cell dividers).

**Option 3: Manual Cell Border Implementation**

Based on community discussions, manual row/column border drawing requires:

1. Track rectangle positions of each cell/row during rendering
2. After rendering completes, paint lines/rectangles using the painter
3. Handle complexity that row rectangles aren't known until all cells are painted

Example pattern:
```rust
// Paint row backgrounds
let paint_bg = |ui: &mut egui::Ui| {
    let gapless_rect = ui.max_rect().expand2(0.5 * item_spacing);
    ui.painter().rect_filled(gapless_rect, 0.0, bg_color);
};
```

---

## Part 3: Column Width Calculation Algorithms

### 3.1 Web Standard (CSS table-layout: auto)

The W3C CSS 2 Tables specification describes the automatic table layout algorithm:

1. **Max Width Phase**: Try to fit columns without breaking lines
2. **Distribution Phase**: Distribute leftover space among columns if available
3. **Shrinking Phase**: Shrink columns to minimum widths if max widths are too wide
4. **Overflow**: Overflow table's container if even minimum widths are too wide

**Key Principle:** Column's minimum width = width of longest unbreakable string in its cells

### 3.2 Terminal Table Libraries

Research from production Rust libraries:

**prettytable-rs:**
- Simple content-based width calculation
- Scans all cells to find max width per column
- No sophisticated distribution algorithm

**comfy-table:**
- Advanced 7-step dynamic algorithm
- **Step 6 (Critical):** Simulates text wrapping to find actual width needs
- Proportional distribution with constraint solving
- Performance: ~470 microseconds for complex tables

**tabled:**
- Modular strategy pattern (wrap, truncate, justify)
- Supports explicit width specification: `.width([10, 20, 30])`
- Terminal-aware sizing with priority-based truncation

### 3.3 Recommended 3-Tier Algorithm

For GUI table rendering with variable content:

```
Tier 1: Perfect Fit
  If sum(desired_widths) <= available_width:
    Use desired_widths as-is

Tier 2: Minimum Fit (Proportional Scaling)
  If sum(min_widths) > available_width:
    Scale all proportionally: widths[i] = available_width * (mins[i] / min_total)

Tier 3: Slack Distribution (Most Common)
  If between minimum and desired:
    slack[i] = desired[i] - mins[i]
    total_slack = sum(slack)
    extra_space = available_width - sum(mins)
    widths[i] = mins[i] + (extra_space / total_slack) * slack[i]
```

**Key Features:**
- Grapheme-aware measurement (emoji clusters counted as 1 unit)
- Font-aware (proportional vs monospace fonts)
- Wrap caps prevent oversized cells from dominating
- Fair remainder distribution (left-to-right for visual balance)

---

## Part 4: Markdown Table Rendering

### 4.1 GFM (GitHub Flavored Markdown) Specification

**Syntax Requirements:**
```markdown
| Header 1 | Header 2 |
|----------|----------|
| Cell 1   | Cell 2   |
```

**Alignment Codes:**
- `:-` = left align (default)
- `-:` = right align
- `:-:` = center align

**Constraints:**
- Only inline content allowed (no nested lists, code blocks)
- Delimiter row requires minimum one dash per cell
- Spaces between pipes trimmed automatically

### 4.2 pulldown-cmark Event Flow

Tables are parsed as event streams:
```
Event::Start(Tag::Table)
  Event::Start(Tag::TableHead)
    Event::Start(Tag::TableCell) + Event::Text(...) + Event::End
  Event::End(Tag::TableHead)
  Event::Start(Tag::TableRow)
    Event::Start(Tag::TableCell) + Event::Text(...) + Event::End
  Event::End(Tag::TableRow)
Event::End(Tag::Table)
```

**Important:** No width calculations in parser - that's entirely the renderer's responsibility.

### 4.3 Other Markdown Renderers

**comrak** (Rust CommonMark + GFM):
- Full GFM table support
- Constructs AST (unlike pulldown-cmark's pull parser)
- HTML rendering via customizable formatter
- Width calculation: Delegates to CSS

**mdBook** (Rust Documentation):
- Renders tables as HTML
- CSS controls via `--content-max-width` variable
- Relies on browser `table-layout: auto`

---

## Part 5: Critical Implementation Insights

### 5.1 Grapheme-Aware Width Calculation

**Always use grapheme clusters, not byte/char counts:**

```rust
use unicode_segmentation::UnicodeSegmentation;

fn measure_text_width(text: &str) -> f32 {
    text.graphemes(true).count() as f32 * char_width
}
```

**Why:** Emoji, combining characters, and CJK characters must be counted correctly.

### 5.2 Text Wrapping Simulation

**Key Insight from comfy-table:** Measure width by simulating actual text wrapping.

```rust
fn calculate_content_width(text: &str, max_width: usize) -> usize {
    let wrapped_lines = wrap_text(text, max_width);
    wrapped_lines.iter()
        .map(|line| grapheme_count(line))
        .max()
        .unwrap_or(0)
}
```

This prevents the "cascade wrapping" issue where columns become too narrow.

### 5.3 Constraint Hierarchy

**Priority Order:**
1. **Hard constraints** (Column::exact, at_least, at_most)
2. **Soft constraints** (content-based preferences)
3. **Proportional distribution** (fair allocation of remainder)

### 5.4 Common Mistakes to Avoid

‚ùå **Don't:** Count bytes or chars for width
‚úÖ **Do:** Use grapheme clusters with unicode-segmentation

‚ùå **Don't:** Allow unlimited column expansion
‚úÖ **Do:** Set wrap_cap to prevent dominance

‚ùå **Don't:** Use `Rangef::EVERYTHING` with painter lines
‚úÖ **Do:** Calculate specific ranges for vline/hline

‚ùå **Don't:** Assume equal column count in all rows
‚úÖ **Do:** Handle ragged tables gracefully

---

## Part 6: Performance Considerations

### 6.1 Sampling Strategy

For large tables:
- Only scan first 32 rows for width calculation (configurable max_samples)
- Preserves performance while capturing typical content patterns

### 6.2 Virtual Scrolling

```rust
// For uniform row heights - more performant
body.rows(row_height, num_rows, |mut row| {
    // Only visible rows rendered
});

// For variable row heights
body.heterogeneous_rows(row_heights.into_iter(), |mut row| {
    // Only visible rows rendered
});
```

### 6.3 Caching

- Cache per-table metrics (min_widths, desired_widths)
- Invalidate on content change or window resize
- Texture caching for repeated renders

---

## Part 7: Recommended Implementation for mdmdview

### 7.1 Immediate Fixes

**For Column Width Issues:**
1. Review column index mapping in width resolution
2. Add debug logging to track which column gets which width
3. Verify that header count matches body column count
4. Check for off-by-one errors in column iteration

**For Border Issues:**
1. Implement manual painter-based cell dividers
2. Track cell rectangles during rendering
3. Post-render painting of vertical/horizontal lines
4. Use specific coordinate ranges (not EVERYTHING)

### 7.2 Long-Term Architecture

**Recommended Rendering Path:**
1. Parse markdown ‚Üí MarkdownElement::Table
2. Analyze columns ‚Üí ColumnMetrics (existing code)
3. Calculate widths ‚Üí 3-tier algorithm (existing code)
4. **NEW:** Track cell rectangles during render
5. Render cells using TableBuilder
6. **NEW:** Post-render paint borders using painter

**Maintain Existing Strengths:**
- Grapheme-aware measurement ‚úì
- Font-aware sizing ‚úì
- Intelligent column classification ‚úì
- Content-aware fallback ‚úì
- Responsive adaptation ‚úì

**Add Missing Features:**
- Cell dividers (painter-based)
- Column border rendering
- GFM alignment rendering
- Better debug output for width calculation

---

## Part 8: Test Strategy

### 8.1 Test Cases for Column Width

```markdown
<!-- Test 1: Equal columns -->
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |

<!-- Test 2: Unequal content -->
| Short | This is a much longer header | X |
|-------|------------------------------|---|
| A     | Content here                 | Y |

<!-- Test 3: Emoji and Unicode -->
| Symbol | Description |
|--------|-------------|
| üöÄ     | Rocket      |
| ‰∏≠Êñá   | Chinese     |

<!-- Test 4: Many columns -->
| A | B | C | D | E | F | G | H |
|---|---|---|---|---|---|---|---|
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
```

### 8.2 Test Cases for Borders

- Single cell table
- 2x2 table
- Table with varying column counts per row
- Narrow window (force wrapping)
- Wide window (check divider alignment)

### 8.3 Visual Regression Tests

1. Take screenshots of known-good tables
2. Compare after implementation changes
3. Verify divider positions
4. Check column alignment

---

## Part 9: References

### Primary Sources

**egui Framework:**
- https://github.com/emilk/egui
- https://docs.rs/egui_extras/latest/egui_extras/struct.TableBuilder.html
- GitHub Issues: #4783, #4158

**Markdown Specifications:**
- GFM: https://github.github.com/gfm/
- pulldown-cmark: https://github.com/pulldown-cmark/pulldown-cmark

**Table Layout Libraries:**
- comfy-table: https://github.com/Nukesor/comfy-table
- prettytable-rs: https://github.com/phsym/prettytable-rs
- tabled: https://github.com/zhiburt/tabled

**Unicode Handling:**
- unicode_segmentation: https://docs.rs/unicode-segmentation/
- unicode_width: https://docs.rs/unicode-width/

### CSS Standards

- W3C CSS 2 Table Layout: https://www.w3.org/TR/CSS2/tables.html
- MDN table-layout: https://developer.mozilla.org/en-US/docs/Web/CSS/table-layout

---

## Part 10: Conclusion

### Key Findings

1. **egui Limitation:** No native cell dividers - requires manual painter implementation
2. **Algorithm Quality:** mdmdview's 3-tier slack distribution is sound and matches CSS standards
3. **Root Cause Hypothesis:** Column width bugs likely stem from index mapping or text wrapping cascade
4. **Border Solution:** Manual post-render painting using ui.painter() with tracked cell rectangles

### Recommended Next Steps

1. **Debug Session:**
   - Add logging to width calculation
   - Verify column index mapping
   - Check header vs body column count alignment

2. **Border Implementation:**
   - Track cell rectangles in Vec during render
   - Post-render paint vertical/horizontal lines
   - Use specific coordinate ranges (not EVERYTHING)

3. **Testing:**
   - Create comprehensive test markdown file
   - Visual regression testing
   - Performance profiling with large tables

### Success Criteria

‚úì Column widths match content requirements
‚úì All columns visible without overflow
‚úì Cell dividers render in correct positions
‚úì Borders align with cell boundaries
‚úì No performance degradation
‚úì Unicode/emoji handled correctly

---

**End of Research Report**

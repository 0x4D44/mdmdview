# HLD: Minimize GPU Idle Optimization

**Date:** 2026-02-08
**Status:** Draft
**Author:** Claude (pair with Arthur)

## Problem Statement

When mdmdview is minimized with a complex document loaded (e.g., `test_stress.md`), Windows
Task Manager reports **2.6% GPU utilization** despite zero CPU usage and zero frame rendering.
Arthur's other egui apps show **0.1% GPU** when minimized.

## Root Cause Analysis

The 2.6% GPU is **real GPU engine work**, not a measurement artifact. It comes from:

1. **OpenGL driver housekeeping** on live texture objects — the NVIDIA/Intel driver performs
   background maintenance (residency management, context validation, internal bookkeeping) that
   scales with the number and size of texture objects in the context.

2. **GPU P-state elevation** — the larger VRAM footprint (~37 MB) prevents the GPU from
   dropping to its deepest idle power state (P8). At a higher clock, the same fixed overhead
   registers as a higher utilization percentage.

With `test_stress.md` fully scrolled, mdmdview holds ~24 GPU texture objects totaling ~37.5 MB:

| Category              | Count  | VRAM       | Notes                          |
|-----------------------|--------|------------|--------------------------------|
| Mermaid diagrams      | 8      | 34.4 MB    | 4.3 MB each (1200x900 RGBA8)  |
| Emoji textures        | ~20    | 320 KB     | 16 KB each (64x64 RGBA8)      |
| Font atlas            | 1      | 2.5 MB     | egui-managed, cannot release   |
| egui UI chrome        | 1      | 150 KB     | egui-managed, cannot release   |
| **Total**             | **~30**| **~37.5 MB** |                             |

A simple egui app has ~3 textures totaling ~2 MB, explaining the 0.1% baseline.

### Empirical Evidence

- **Repaint debug test**: With `test_stress.md` loaded, only 5 frames in 25 seconds, then
  silence. No continuous repainting, no table oscillation, no mermaid polling.
- **eframe 0.27 behavior**: Correctly skips `request_redraw()` when minimized. Repaint
  requests from app code are queued then discarded by the minimize check.
- **CPU near zero**: Confirms no event loop spinning — the overhead is GPU-side driver work.

## Proposed Solution

Release application-managed GPU textures when the window transitions to minimized state.
On restore, textures rebuild lazily through the existing rendering pipeline.

### What to Release

| Cache                  | Owner                | Release?  | Rebuild Cost                  |
|------------------------|----------------------|-----------|-------------------------------|
| `mermaid_textures`     | `MermaidRenderer`    | **Yes**   | Fast: rasterize from SVG cache (~10-50ms/diagram) |
| `emoji_textures`       | `MarkdownRenderer`   | **Yes**   | Fast: decode embedded PNGs (~1ms/emoji) |
| `image_textures`       | `MarkdownRenderer`   | **Yes**   | Medium: re-decode from disk/cache |
| `mermaid_svg_cache`    | `MermaidRenderer`    | No        | Retain — needed for fast texture rebuild |
| `mermaid_errors`       | `MermaidRenderer`    | No        | Retain — prevents retry storms |
| Font atlas             | egui                 | No        | Framework-managed, no API to release |
| egui UI chrome         | egui                 | No        | Framework-managed |

### What NOT to Release

- **SVG cache**: Kept in system RAM (not GPU). Needed to rebuild mermaid textures quickly
  on restore without re-running QuickJS. Costs ~100 KB-2 MB RAM — negligible.
- **Error caches**: Prevent re-attempting failed renders.
- **Table metrics/layout caches**: Already cleared per-document; not GPU resources.

## Detailed Design

### 1. State Tracking in `MarkdownViewerApp`

Add a `was_minimized: bool` field to detect **transitions**, not just current state:

```rust
// In MarkdownViewerApp struct (app.rs)
/// Tracks previous minimized state to detect transitions.
was_minimized: bool,
```

Initialize to `false` in the constructor.

### 2. Minimize Detection in `update_impl()`

At the top of `update_impl()`, after the startup frame logic, detect minimize/restore
transitions:

```rust
// Detect minimize/restore transitions
let is_minimized = ctx.input(|i| {
    i.viewport().minimized.unwrap_or(false)
});

if is_minimized && !self.was_minimized {
    // Transition: visible → minimized
    self.renderer.release_gpu_textures();
}

if !is_minimized && self.was_minimized {
    // Transition: minimized → restored
    ctx.request_repaint(); // Force re-render to rebuild textures
}

self.was_minimized = is_minimized;
```

**Important caveat**: eframe 0.27 typically skips calling `update()` when minimized (the
`request_redraw()` call is suppressed). This means the minimize transition may only be detected
on the **first frame after restore**. We handle both directions:

- **Minimize transition** (`!was_minimized && is_minimized`): If `update()` runs while the
  window is being minimized (race window), we release textures immediately.
- **Restore detection** (`was_minimized && !is_minimized`): When `update()` is NOT called
  during minimized state, `was_minimized` stays `false`. We need an alternative detection.

**Alternative approach for robustness**: Since `update()` may not be called while minimized,
we can instead use an **idle timeout** strategy — release textures after N seconds of
inactivity (no user events). This avoids reliance on minimized state detection entirely.

### 3. Recommended Approach: Idle Timeout (Primary) + Minimize Detection (Belt-and-Suspenders)

Two complementary mechanisms:

#### 3a. Idle Timeout

Track time since last user interaction. After a configurable timeout (e.g., 60 seconds),
release GPU textures. This covers minimized windows (where `update()` stops being called)
AND idle visible windows.

```rust
// In MarkdownViewerApp struct
last_interaction: std::time::Instant,
gpu_textures_released: bool,
```

In `update_impl()`:

```rust
// Track user activity
let has_activity = ctx.input(|i| {
    !i.events.is_empty()
        || i.pointer.delta() != egui::Vec2::ZERO
        || i.raw_scroll_delta != egui::Vec2::ZERO
});

if has_activity {
    self.last_interaction = std::time::Instant::now();
    if self.gpu_textures_released {
        // User returned — textures rebuild lazily on next render
        self.gpu_textures_released = false;
    }
}

// Release textures after idle timeout
const GPU_IDLE_TIMEOUT: Duration = Duration::from_secs(60);
if !self.gpu_textures_released
    && self.last_interaction.elapsed() > GPU_IDLE_TIMEOUT
    && self.screenshot.is_none()
{
    self.renderer.release_gpu_textures();
    self.gpu_textures_released = true;
}
```

#### 3b. Minimize Detection (Supplementary)

If `update()` does happen to run during the minimize transition, release immediately
without waiting for the idle timeout:

```rust
let is_minimized = ctx.input(|i| {
    i.viewport().minimized.unwrap_or(false)
});

if is_minimized && !self.gpu_textures_released && self.screenshot.is_none() {
    self.renderer.release_gpu_textures();
    self.gpu_textures_released = true;
}
```

### 4. New Methods on `MarkdownRenderer`

Add a public method to release all application-managed GPU textures:

```rust
// In MarkdownRenderer (markdown_renderer.rs)

/// Release GPU textures to reduce idle GPU usage (e.g., when minimized).
/// Textures rebuild lazily on next render. SVG/error caches are retained
/// so rebuilds are fast.
pub fn release_gpu_textures(&self) {
    self.emoji_textures.borrow_mut().clear();
    self.image_textures.borrow_mut().clear();
    self.mermaid.release_gpu_textures();
}
```

### 5. New Methods on `MermaidRenderer`

Add a public method to clear the texture cache only (preserving SVG cache):

```rust
// In MermaidRenderer (mermaid_renderer.rs)

/// Release GPU textures to reduce idle GPU usage.
/// SVG cache is retained so diagrams can be quickly re-rasterized on restore.
pub(crate) fn release_gpu_textures(&self) {
    #[cfg(feature = "mermaid-quickjs")]
    {
        self.mermaid_textures.borrow_mut().clear();
        // Note: mermaid_svg_cache intentionally retained
        // Note: mermaid_errors intentionally retained
        // Note: mermaid_texture_errors intentionally retained
    }
}
```

The `TextureCache` struct needs a `clear()` method added:

```rust
// In TextureCache (mermaid_renderer.rs)
fn clear(&mut self) {
    self.entries.clear();
    self.order.clear();
    self.current_bytes = 0;
}
```

### 6. `ImageCache::clear()` Method

`ImageCache` currently lacks a `clear()` method. Add one:

```rust
// In ImageCache (markdown_renderer.rs)
fn clear(&mut self) {
    self.entries.clear();
    self.order.clear();
    self.total_bytes = 0;
}
```

### 7. Texture Rebuild on Restore

No special rebuild logic is needed. The existing lazy-loading pipeline handles everything:

- **Mermaid diagrams**: On next render, `render_block()` checks `mermaid_textures` cache.
  Cache miss → checks `mermaid_svg_cache` (still populated) → rasterizes SVG to PNG →
  uploads texture. Cost: ~10-50ms per diagram, spread across frames.

- **Emoji textures**: On next render, emoji rendering checks `emoji_textures` cache.
  Cache miss → decodes embedded PNG asset → uploads texture. Cost: ~1ms per emoji.

- **Image textures**: On next render, image rendering checks `image_textures` cache.
  Cache miss → enqueues async load from disk → uploads on completion. Cost: varies by
  image size, but async so non-blocking.

The only user-visible effect is a **brief flash** on the first frame after restore where
mermaid diagram placeholders appear before textures are rebuilt. This settles within 2-5
frames (~50-150ms).

## Edge Cases

### Minimize During Mermaid Rendering

If the user minimizes while mermaid diagrams are still rendering:
- Worker threads continue (they're CPU-only, not GPU)
- Results queue in the bounded channel
- On restore, `poll_mermaid_results()` drains the queue and creates textures
- If `release_gpu_textures()` fires between completion and polling, the results are
  still in the channel — they'll be picked up on the next frame

### Rapid Minimize/Restore Cycling

If the user rapidly Alt-Tabs:
- Textures released on minimize, rebuilt on restore
- Could cause texture thrashing if cycling faster than rebuild time
- Mitigation: the idle timeout approach (60s) naturally prevents thrashing for quick
  minimize/restore cycles. The immediate minimize detection only fires if `update()`
  happens to run during the transition (rare).

### Screenshot Mode

- Never release textures during screenshot capture (`self.screenshot.is_some()`)
- Screenshots need all textures present for correct rendering

### Multiple Zoom Levels Cached

If the user zoomed in/out before minimizing, multiple scale variants of mermaid textures
may be cached. All are released. On restore, only the current zoom level's textures
rebuild — previous zoom levels rebuild lazily if the user zooms again.

### No Document Loaded

If no document is loaded, there are no application textures to release. The release
methods are safe to call on empty caches (no-ops).

## Expected Impact

### GPU Usage When Minimized

| Scenario                          | Before  | After   |
|-----------------------------------|---------|---------|
| test_stress.md, minimized         | 2.6%    | ~0.1%   |
| Simple document, minimized        | ~0.5%   | ~0.1%   |
| No document, minimized            | ~0.1%   | ~0.1%   |

### Restore Latency

| Content Type        | Rebuild Time  | Frames to Settle |
|---------------------|---------------|------------------|
| Mermaid diagrams    | 10-50ms each  | 2-5 frames       |
| Emoji               | ~1ms each     | 1 frame          |
| Images (from disk)  | 5-50ms each   | 2-3 frames       |
| Total (test_stress) | ~200-500ms    | 3-5 frames       |

### Memory Impact

- GPU VRAM freed: ~35-37 MB (for test_stress.md)
- System RAM unchanged (SVG cache, error caches retained)
- On restore: VRAM re-allocated as textures rebuild

## Implementation Order

1. Add `TextureCache::clear()` to `MermaidRenderer` (trivial)
2. Add `ImageCache::clear()` to `MarkdownRenderer` (trivial)
3. Add `MermaidRenderer::release_gpu_textures()` (trivial)
4. Add `MarkdownRenderer::release_gpu_textures()` (trivial)
5. Add state fields to `MarkdownViewerApp` (`last_interaction`, `gpu_textures_released`)
6. Add idle timeout + minimize detection logic in `update_impl()`
7. Write tests for cache clearing methods
8. Write integration test for release/rebuild cycle
9. Manual verification: load test_stress.md, scroll to bottom, minimize, check GPU%

## Testing Strategy

### Unit Tests

- `TextureCache::clear()` zeroes `current_bytes` and empties entries/order
- `ImageCache::clear()` zeroes `total_bytes` and empties entries/order
- `LruCache::clear()` empties entries/order (already has `clear()`)
- `MermaidRenderer::release_gpu_textures()` clears texture cache but retains SVG cache
- `MarkdownRenderer::release_gpu_textures()` clears emoji + image + mermaid textures

### Integration Tests

- Load document with mermaid diagrams → verify textures cached
- Call `release_gpu_textures()` → verify texture caches empty, SVG cache retained
- Re-render → verify textures rebuilt from SVG cache (cache hit, not re-render via QuickJS)

### Manual Verification

1. Build release: `cargo build --release`
2. Open `test_stress.md`, scroll to bottom (trigger all 8 mermaid renders)
3. Wait 10 seconds for everything to settle
4. Note GPU% in Task Manager (expected: ~2.6%)
5. Minimize window
6. Wait 60+ seconds (idle timeout)
7. Check GPU% (expected: ~0.1%)
8. Restore window — verify diagrams re-render within ~500ms
9. Check GPU% returns to normal rendering level

## Alternatives Considered

### A. Switch to wgpu Backend

Would achieve near-zero idle GPU through modern API idle management. Rejected because:
- Major architectural change affecting build system, dependencies, and compatibility
- wgpu has its own issues (buffer GC starvation when minimized — egui #7434)
- Disproportionate effort for a ~2.5% GPU reduction

### B. Deactivate OpenGL Context When Minimized

Call `glutin::make_not_current()` to fully release the GL context. Rejected because:
- Not accessible through eframe's abstraction layer
- Would require rebuilding ALL state (including framework textures) on restore
- Risk of GL errors if any code touches the context while deactivated

### C. Accept the Overhead

2.6% GPU is minor and has negligible impact on system performance or battery. However:
- Arthur's other egui apps achieve 0.1% — consistency matters
- The fix is low-risk and straightforward
- Demonstrates good resource hygiene

### D. Release Only Mermaid Textures (Partial)

Since mermaid dominates at 34.4 MB / 8 textures, could skip emoji and images. However:
- Clearing all three caches is equally simple (one method call each)
- Emoji and image textures add marginal but real overhead
- Consistency: release everything or nothing

## Open Questions

1. **Idle timeout duration**: 60 seconds is conservative. Could be 30s or configurable
   via environment variable (`MDMDVIEW_GPU_IDLE_TIMEOUT_SECS`). What does Arthur prefer?

2. **Visual feedback on restore**: Should we show a subtle "Rebuilding..." indicator during
   the 200-500ms rebuild, or just accept the brief placeholder flash? The flash is barely
   noticeable at 60fps.

3. **Should the idle timeout also apply to visible-but-idle windows?** The current design
   says yes — if you walk away from your desk for 60 seconds, textures are released even
   if the window is visible. This further reduces GPU for "leave it open all day" scenarios.
   Downside: brief visual flash when you return and move the mouse.

## References

- [GPUs in the Task Manager — DirectX Developer Blog](https://devblogs.microsoft.com/directx/gpus-in-the-task-manager/)
- [egui Issue #3982: Windows: High CPU Usage when minimized](https://github.com/emilk/egui/issues/3982)
- [egui Issue #3321: Graphical glitches after minimized](https://github.com/emilk/egui/issues/3321)
- [imgui Issue #7844: 100% GPU usage while minimised](https://github.com/ocornut/imgui/issues/7844)
- [egui Issue #4527: High CPU usage when accesskit enabled](https://github.com/emilk/egui/issues/4527)
- [Khronos Forums: High GPU usage drawing nothing](https://community.khronos.org/t/high-gpu-usage-even-when-drawing-nothing-on-the-window-and-even-with-framerate-limiting/108031)
- [NVIDIA Forums: GPU P-state stuck at maximum](https://forums.developer.nvidia.com/t/gpu-is-stuck-to-maximun-power-state-at-idle-when-using-multiple-monitors/310924)

# Memory Leak Fix Implementation Plan

**Date**: 2026-01-16
**Version**: 1.3
**Related Investigation**: `wrk_journals/2026.01.16 - JRN - Memory Leak Investigation.md`

---

## Executive Summary

This plan addresses memory leak issues identified in mdmdview that caused memory usage to grow to 32GB+ during extended use with Mermaid diagrams and emoji-heavy documents. The primary culprit is the unbounded `emoji_textures` HashMap that holds TextureHandles forever, preventing egui from freeing textures.

**Estimated Impact**: Reduce worst-case memory growth from unbounded to capped at ~100-150MB for texture caches.

---

## Issues to Address (Priority Order)

| Priority | Issue | Location | Current State | Target State |
|----------|-------|----------|---------------|--------------|
| P0 | `emoji_textures` unbounded | `markdown_renderer.rs:371` | `HashMap<String, TextureHandle>` | LRU cache, capacity 512 |
| P1 | `image_failures` unbounded | `markdown_renderer.rs:374` | `HashMap<String, ImageFailure>` | LRU cache, capacity 256 |
| P2 | Cache clearing on file load | `app.rs:752` | Only table cache cleared | Clear image_failures too |
| P3 | QuickJS memory limit excessive | `mermaid_renderer.rs:1450` | 2GB per worker | 512MB per worker |
| P4 | JS text cache unbounded | `mermaid_renderer.rs` (DOM shim) | Never cleared | Add clearing function |
| P5 | egui texture cleanup research | N/A | No explicit cleanup | Research & implement if needed |
| P6 | SVG cache size-based eviction | `mermaid_renderer.rs` | Count-based only (64 entries) | Add size limit (~100MB) |
| P7 | QuickJS explicit GC | `mermaid_renderer.rs` | Implicit GC only | Add explicit `ctx.gc()` call |

---

## Issues Analyzed But NOT Requiring Fixes

The following issues were identified during investigation but determined to be either self-limiting or already properly bounded:

### Already Bounded (Proper LRU/Capacity Limits)

| Component | Location | Capacity | Status |
|-----------|----------|----------|--------|
| `image_textures` (ImageCache) | `markdown_renderer.rs:372` | 256 | âœ… LRU eviction implemented |
| `mermaid_textures` | `mermaid_renderer.rs:444` | 128 | âœ… LRU eviction implemented |
| `mermaid_svg_cache` | `mermaid_renderer.rs:450` | 64 + 100MB | âœ… LRU eviction + size limit (Stage 9 adds 100MB cap) |
| `mermaid_errors` | `mermaid_renderer.rs:452` | 64 | âœ… LRU eviction implemented |
| `mermaid_texture_errors` | `mermaid_renderer.rs:454` | 64 | âœ… LRU eviction implemented |
| `table_layout_cache` | `markdown_renderer.rs:393` | 512 | âœ… LRU eviction implemented |
| Navigation history | `app.rs:342` | 50 entries | âœ… FIFO eviction at capacity |
| `pending_files` | `app.rs:351` | 50 files | âœ… Capped per drag-drop |

### Cleared Per Frame/Document

| Component | Location | Behavior | Status |
|-----------|----------|----------|--------|
| `header_rects` | `markdown_renderer.rs:378` | Cleared per frame (line 2507) | âœ… Cannot accumulate |
| `element_rects` | `markdown_renderer.rs:386` | Cleared per frame (line 2513) | âœ… Cannot accumulate |
| `column_stats_cache` | `markdown_renderer.rs:395` | Cleared on file load via `clear_table_layout_cache()` | âœ… Resets between docs |

### Self-Limiting (Bounded by External Factors)

| Component | Location | Limiting Factor | Status |
|-----------|----------|-----------------|--------|
| `mermaid_pending` HashSet | `mermaid_renderer.rs:446` | Bounded by job queue (16 max). Entries removed on result. | âœ… Self-limiting |
| `image_pending` HashSet | `markdown_renderer.rs:373` | Bounded by `IMAGE_MAX_PENDING=64`. Entries removed on completion. | âœ… Self-limiting |

### Shared Resources (Fixed Overhead, Not Leaks)

| Component | Location | Behavior | Status |
|-----------|----------|----------|--------|
| Font database | `mermaid_renderer.rs` | Shared Arc across workers, loaded once at startup (~10-50MB) | âœ… Fixed overhead, freed on app exit |

### Performance Issues (Not Memory Leaks)

| Issue | Assessment |
|-------|------------|
| Multiple RGBA buffer copies in Mermaid rasterization | Performance overhead only, not a leak. Buffers freed after use. |

---

## Implementation Stages

### Stage 1: Create Generic LRU Cache (Foundation)

**Goal**: Create a reusable LRU cache that can be used for both emoji_textures and image_failures.

**File**: `c:\language\mdmdview\src\markdown_renderer.rs`

**Rationale**: The codebase already has two similar LRU implementations (`ImageCache` at line 284, `CellLayoutCache` at line 175, and `LruCache` in mermaid_renderer.rs). Rather than creating a third variant, we'll create a generic one that can be reused.

#### Step 1.1: Define Generic LruCache

Add after line 162 (after the constants):

```rust
/// Generic LRU cache with configurable capacity.
/// Used for emoji textures, image failures, and other bounded caches.
struct LruCache<K, V> {
    entries: HashMap<K, V>,
    order: VecDeque<K>,
    capacity: usize,
}

impl<K, V> LruCache<K, V>
where
    K: Eq + std::hash::Hash + Clone,
    V: Clone,
{
    fn new(capacity: usize) -> Self {
        Self {
            entries: HashMap::new(),
            order: VecDeque::new(),
            capacity: capacity.max(1),
        }
    }

    fn get(&mut self, key: &K) -> Option<V> {
        let value = self.entries.get(key).cloned();
        if value.is_some() {
            self.touch(key);
        }
        value
    }

    fn contains_key(&self, key: &K) -> bool {
        self.entries.contains_key(key)
    }

    fn insert(&mut self, key: K, value: V) {
        if self.entries.contains_key(&key) {
            self.entries.insert(key.clone(), value);
            self.touch(&key);
            return;
        }
        while self.entries.len() >= self.capacity {
            if let Some(old) = self.order.pop_front() {
                self.entries.remove(&old);
            } else {
                break;
            }
        }
        self.order.push_back(key.clone());
        self.entries.insert(key, value);
    }

    fn remove(&mut self, key: &K) {
        self.entries.remove(key);
        self.order.retain(|entry| entry != key);
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.order.clear();
    }

    fn len(&self) -> usize {
        self.entries.len()
    }

    fn touch(&mut self, key: &K) {
        self.order.retain(|entry| entry != key);
        self.order.push_back(key.clone());
    }
}
```

#### Step 1.2: Add Capacity Constants

Add after line 161:

```rust
const EMOJI_TEXTURE_CACHE_CAPACITY: usize = 512;
const IMAGE_FAILURE_CACHE_CAPACITY: usize = 256;
```

**Testing**:
- Unit test: Verify LRU eviction behavior
- Unit test: Verify capacity enforcement
- Unit test: Verify touch() updates order correctly

---

### Stage 2: Convert emoji_textures to LRU Cache (P0 - Critical)

**Goal**: Replace unbounded HashMap with bounded LRU cache.

**File**: `c:\language\mdmdview\src\markdown_renderer.rs`

#### Step 2.1: Update Field Declaration

Change line 371 from:
```rust
emoji_textures: RefCell<HashMap<String, egui::TextureHandle>>,
```

To:
```rust
emoji_textures: RefCell<LruCache<String, egui::TextureHandle>>,
```

#### Step 2.2: Update Initialization

Change line 753 from:
```rust
emoji_textures: RefCell::new(HashMap::new()),
```

To:
```rust
emoji_textures: RefCell::new(LruCache::new(EMOJI_TEXTURE_CACHE_CAPACITY)),
```

#### Step 2.3: Update get_or_make_emoji_texture()

Change lines 3004-3050. The key changes:

Line 3005 - Update get() call:
```rust
// Old:
if let Some(tex) = self.emoji_textures.borrow().get(emoji) {
    return tex.clone();
}

// New:
if let Some(tex) = self.emoji_textures.borrow_mut().get(&emoji.to_string()) {
    return tex;
}
```

Line 3047-3049 - insert() call should work as-is since LruCache has same method signature.

#### Step 2.4: Add Public Clearing Method

Add new public method after `clear_table_layout_cache()` (around line 4902):

```rust
/// Clear the emoji texture cache. Call when memory pressure is high
/// or when switching between very different documents.
pub fn clear_emoji_cache(&self) {
    self.emoji_textures.borrow_mut().clear();
}

/// Get emoji texture cache statistics for debugging.
#[cfg(test)]
pub fn emoji_cache_len(&self) -> usize {
    self.emoji_textures.borrow().len()
}
```

**Testing**:
- Integration test: Open 10 files with different emojis, verify cache size <= 512
- Integration test: Verify LRU eviction (oldest emojis evicted first)
- Unit test: Verify `clear_emoji_cache()` works
- Memory test: Monitor RSS while loading emoji-heavy documents

---

### Stage 3: Convert image_failures to LRU Cache (P1 - High)

**Goal**: Replace unbounded HashMap with bounded LRU cache.

**File**: `c:\language\mdmdview\src\markdown_renderer.rs`

#### Step 3.1: Update Field Declaration

Change line 374 from:
```rust
image_failures: RefCell<HashMap<String, ImageFailure>>,
```

To:
```rust
image_failures: RefCell<LruCache<String, ImageFailure>>,
```

#### Step 3.2: Update Initialization

Change line 756 from:
```rust
image_failures: RefCell::new(HashMap::new()),
```

To:
```rust
image_failures: RefCell::new(LruCache::new(IMAGE_FAILURE_CACHE_CAPACITY)),
```

#### Step 3.3: Update should_retry_image()

The method at approximately line 5000-5020 needs updates:

```rust
fn should_retry_image(&self, key: &str) -> bool {
    let mut failures = self.image_failures.borrow_mut();
    if let Some(failure) = failures.get(&key.to_string()) {
        if failure.last_attempt.elapsed() < IMAGE_FAILURE_BACKOFF {
            return false;
        }
    }
    failures.remove(&key.to_string());
    true
}
```

#### Step 3.4: Update record_image_failure()

Update the insert call (around line 5022):
```rust
self.image_failures.borrow_mut().insert(
    key.to_string(),
    ImageFailure {
        last_attempt: Instant::now(),
    },
);
```

#### Step 3.5: Add Public Clearing Method

```rust
/// Clear the image failure cache.
pub fn clear_image_failure_cache(&self) {
    self.image_failures.borrow_mut().clear();
}
```

**Testing**:
- Unit test: Verify failure tracking still works
- Unit test: Verify backoff behavior unchanged
- Unit test: Verify LRU eviction of old failures
- Integration test: Open files with many broken images, verify bounded growth

---

### Stage 4: Reduce QuickJS Memory Limit (P2 - Moderate)

**Goal**: Reduce per-worker memory limit from 2GB to 512MB.

**File**: `c:\language\mdmdview\src\mermaid_renderer.rs`

#### Step 4.1: Update Memory Limit Constant

Find line ~1450:
```rust
const MEMORY_LIMIT_BYTES: usize = 2 * 1024 * 1024 * 1024;  // 2GB
```

Change to:
```rust
const MEMORY_LIMIT_BYTES: usize = 512 * 1024 * 1024;  // 512MB
```

#### Step 4.2: Add Environment Variable Override

Allow runtime configuration for edge cases:

```rust
fn memory_limit_bytes() -> usize {
    if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_MEMORY_MB") {
        if let Ok(mb) = raw.trim().parse::<usize>() {
            return (mb * 1024 * 1024).clamp(64 * 1024 * 1024, 2 * 1024 * 1024 * 1024);
        }
    }
    512 * 1024 * 1024  // Default 512MB
}
```

**Testing**:
- Integration test: Render complex Mermaid diagrams, verify no regressions
- Memory test: Verify total QuickJS memory < 4GB with 8 workers
- Test with MDMDVIEW_MERMAID_MEMORY_MB override

---

### Stage 5: Add JavaScript Text Cache Clearing (P3 - Low)

**Goal**: Prevent unbounded growth of `__mdmdview_text_cache` in QuickJS workers.

**File**: `c:\language\mdmdview\src\mermaid_renderer.rs`

#### Step 5.1: Add Cache Clear Function to DOM Shim

Find `MERMAID_DOM_SHIM` constant (around line 2536). Add to the JavaScript:

```javascript
var __mdmdview_text_cache = {};
var __mdmdview_text_cache_size = 0;
var __mdmdview_text_cache_max = 10000;

function __mdmdview_clear_text_cache() {
    __mdmdview_text_cache = {};
    __mdmdview_text_cache_size = 0;
}

// Update measureText to track cache size and auto-clear
// (modify existing measureText implementation)
```

#### Step 5.2: Periodic Cache Clearing

Option A: Clear after each diagram render (simple, ensures no accumulation)
Option B: Clear when cache exceeds threshold (more efficient)

In `render_svg()` method, after successful render:
```rust
// Clear JS text cache periodically to prevent accumulation
self.engine.ctx.with(|ctx| {
    let _ = ctx.eval::<(), _>("if(__mdmdview_text_cache_size > 5000) __mdmdview_clear_text_cache();");
});
```

#### Step 5.3: Add Explicit QuickJS GC (P7)

After clearing the text cache, trigger explicit garbage collection to ensure memory is reclaimed promptly:

```rust
// In render_svg() method, after successful render:
self.engine.ctx.with(|ctx| {
    // Clear JS text cache periodically
    let _ = ctx.eval::<(), _>("if(__mdmdview_text_cache_size > 5000) __mdmdview_clear_text_cache();");

    // Trigger explicit GC to reclaim memory from cleared cache and render temporaries
    ctx.run_gc();
});
```

**Rationale**: While QuickJS has implicit GC, explicit GC after heavy operations ensures memory is reclaimed promptly rather than accumulating until the next implicit GC cycle.

**Testing**:
- Integration test: Render 1000 diagrams, verify memory stable
- Unit test: Verify cache clearing function works
- Memory test: Compare RSS with/without explicit GC after 500 renders

---

### Stage 6: Clear Caches on File Load (P2 - High)

**Goal**: Clear stale caches when loading new files, per investigation Fix #3.

**File**: `c:\language\mdmdview\src\app.rs`

#### Step 6.1: Add Cache Clearing in load_content()

Find line 752 in `load_content()`:
```rust
self.renderer.clear_table_layout_cache();
```

Add after it:
```rust
self.renderer.clear_table_layout_cache();
self.renderer.clear_image_failure_cache();  // NEW: Clear stale image failures
```

**Rationale**: When switching files, failed image paths from the previous document are no longer relevant. The backoff mechanism is per-session, but failure entries should reset per-document.

#### Step 6.2: Design Decision - emoji_textures NOT Cleared on File Load

**Investigation Recommendation**: Fix #3 suggests clearing both `emoji_cache` and `image_failure_cache` on file load.

**Plan Decision**: Do NOT clear `emoji_textures` on every file load.

**Justification**:
1. **LRU handles it**: With Stage 2's LRU conversion (capacity 512), old emojis are automatically evicted when capacity is reached
2. **Emoji reuse is common**: Emojis like ğŸ˜€ ğŸ“ âœ… appear across many documents; clearing would cause unnecessary re-rendering
3. **Memory impact is bounded**: 512 emojis Ã— ~50KB = ~25MB max, which is acceptable
4. **Performance benefit**: Avoiding texture recreation improves responsiveness when navigating between files

**Alternative if memory pressure observed**: Add `clear_emoji_cache()` call, but this is not expected to be necessary given the LRU bounds.

**Testing**:
- Unit test: Verify `image_failures` is empty after loading new file
- Integration test: Load file with broken image, load different file, verify failure cache cleared
- Memory test: Verify emoji cache stays bounded at 512 entries across many file loads

---

### Stage 7: egui Texture Cleanup Research (P5 - Research)

**Goal**: Investigate whether egui provides explicit texture cleanup APIs and implement if beneficial.

**Background**: When textures are evicted from LRU caches, the `TextureHandle` is dropped. In egui 0.27, this should automatically free the texture due to reference counting. However, we should verify this behavior and determine if explicit cleanup provides additional benefits.

#### Step 7.1: Research egui Texture Management

Investigate:
1. Does `egui::Context::forget_image()` or similar exist?
2. What happens when `TextureHandle` is dropped?
3. Is there any texture manager accumulation over time?
4. Does egui provide memory usage statistics?

#### Step 7.2: Implement If Beneficial

If research shows explicit cleanup is beneficial:

```rust
// In LruCache evict_oldest(), before removing entry:
if let Some(texture_handle) = self.entries.get(&old) {
    // Call egui cleanup API if available
    // ctx.forget_image(texture_handle.id());  // Hypothetical API
}
self.entries.remove(&old);
```

**Deliverable**: Document findings and implement if egui provides relevant APIs.

**Testing**:
- Memory profiling before/after implementing explicit cleanup
- Verify no texture leaks via egui debug tools (if available)

---

### Stage 8: Optional Enhancements

#### 8.1: Add Memory Statistics Logging

Add optional debug logging to track cache sizes:

```rust
#[cfg(debug_assertions)]
pub fn log_cache_stats(&self) {
    eprintln!(
        "Cache stats: emoji={}, image={}, image_fail={}, table={}",
        self.emoji_textures.borrow().len(),
        self.image_textures.borrow().entries.len(),
        self.image_failures.borrow().len(),
        self.table_layout_cache.borrow().entries.len(),
    );
}
```

#### 8.2: Add Manual Cache Clear Command (Optional)

Consider adding a keyboard shortcut (e.g., Ctrl+Shift+M) to manually clear all caches if user experiences memory pressure.

---

### Stage 9: SVG Cache Size-Based Eviction (P6 - Low)

**Goal**: Add size-based eviction to the Mermaid SVG cache to prevent excessive memory usage from large SVG strings.

**File**: `c:\language\mdmdview\src\mermaid_renderer.rs`

**Background**: The current `mermaid_svg_cache` is bounded by entry count (64), but individual SVG strings can be 100KB-10MB each. With 64 entries, worst-case memory usage is 640MB just for cached SVGs.

#### Step 9.1: Add Size Tracking to SVG Cache

Modify the LruCache to track total size in bytes:

```rust
const MERMAID_SVG_CACHE_CAPACITY: usize = 64;
const MERMAID_SVG_CACHE_MAX_BYTES: usize = 100 * 1024 * 1024;  // 100MB

struct SvgCache {
    entries: HashMap<u64, String>,
    order: VecDeque<u64>,
    capacity: usize,
    max_bytes: usize,
    current_bytes: usize,
}
```

#### Step 9.2: Update Insert to Track Size

```rust
fn insert(&mut self, key: u64, svg: String) {
    let svg_size = svg.len();

    // Evict if adding this SVG would exceed byte limit
    while self.current_bytes + svg_size > self.max_bytes && !self.order.is_empty() {
        self.evict_oldest();
    }

    // Also respect entry count limit
    while self.entries.len() >= self.capacity {
        self.evict_oldest();
    }

    if self.entries.contains_key(&key) {
        // Update: subtract old size, add new size
        if let Some(old) = self.entries.get(&key) {
            self.current_bytes -= old.len();
        }
    }

    self.current_bytes += svg_size;
    self.order.push_back(key);
    self.entries.insert(key, svg);
}

fn evict_oldest(&mut self) {
    if let Some(old_key) = self.order.pop_front() {
        if let Some(old_svg) = self.entries.remove(&old_key) {
            self.current_bytes -= old_svg.len();
        }
    }
}
```

#### Step 9.3: Add Size Monitoring (Debug)

```rust
#[cfg(debug_assertions)]
pub fn svg_cache_stats(&self) -> (usize, usize) {
    (self.mermaid_svg_cache.borrow().entries.len(),
     self.mermaid_svg_cache.borrow().current_bytes)
}
```

**Testing**:
- Unit test: Verify size-based eviction triggers when total exceeds 100MB
- Unit test: Verify entry-count eviction still works
- Integration test: Load documents with 100+ large Mermaid diagrams, verify SVG cache stays under 100MB

---

## Testing Strategy

### Unit Tests

| Test | File | Description |
|------|------|-------------|
| `test_lru_cache_eviction` | markdown_renderer.rs | Verify oldest entries evicted at capacity |
| `test_lru_cache_touch` | markdown_renderer.rs | Verify accessed entries move to end |
| `test_emoji_cache_bounded` | markdown_renderer.rs | Verify emoji cache respects capacity |
| `test_image_failure_bounded` | markdown_renderer.rs | Verify failure cache respects capacity |
| `test_quickjs_memory_limit` | mermaid_renderer.rs | Verify reduced memory limit applied |

### Integration Tests

| Test | Description |
|------|-------------|
| `test_memory_stable_emoji_heavy` | Load 100 files with different emojis, verify memory bounded |
| `test_memory_stable_mermaid_heavy` | Render 500 Mermaid diagrams, verify memory bounded |
| `test_long_running_session` | Simulate 8-hour session, verify no unbounded growth |

### Manual Testing Checklist

- [ ] Open application, check baseline memory (~50-100MB)
- [ ] Load 20 different emoji-heavy documents
- [ ] Verify memory stays below 300MB
- [ ] Load document with 10 Mermaid diagrams
- [ ] Zoom in/out repeatedly (generates texture variants)
- [ ] Verify memory stays below 500MB
- [ ] Leave running for 1 hour with periodic interactions
- [ ] Verify no memory growth beyond expected cache sizes

---

## Rollback Plan

Each stage is independent and can be rolled back separately:

1. **Stage 1-2 (emoji_textures)**: Revert to `HashMap<String, TextureHandle>`
2. **Stage 3 (image_failures)**: Revert to `HashMap<String, ImageFailure>`
3. **Stage 4 (QuickJS limit)**: Revert constant to 2GB
4. **Stage 5 (JS cache)**: Remove cache clearing code

**Git Strategy**: Commit each stage separately with clear commit messages for easy cherry-pick reversal.

---

## Success Metrics

| Metric | Before | Target | Measurement |
|--------|--------|--------|-------------|
| Memory after 100 emoji files | Unbounded (GB+) | < 200MB | Task Manager RSS |
| Memory after 500 Mermaid renders | Unbounded | < 400MB | Task Manager RSS |
| Memory after 8hr session | 32GB+ reported | < 500MB | Task Manager RSS |
| Emoji cache size | Unbounded | <= 512 entries | Debug logging |
| Image failure cache size | Unbounded | <= 256 entries | Debug logging |
| QuickJS memory per worker | 2GB | 512MB | Environment limit |

---

## Implementation Order

```
Week 1:
â”œâ”€â”€ Stage 1: Generic LRU Cache (2-3 hours)
â”‚   â”œâ”€â”€ Implement LruCache<K,V>
â”‚   â”œâ”€â”€ Write unit tests
â”‚   â””â”€â”€ Commit: "feat: add generic LRU cache for bounded texture storage"
â”‚
â”œâ”€â”€ Stage 2: emoji_textures conversion (2-3 hours)
â”‚   â”œâ”€â”€ Convert field type
â”‚   â”œâ”€â”€ Update all usages
â”‚   â”œâ”€â”€ Add clearing method
â”‚   â”œâ”€â”€ Write tests
â”‚   â””â”€â”€ Commit: "fix: convert emoji_textures to bounded LRU cache"
â”‚
â”œâ”€â”€ Stage 3: image_failures conversion (1-2 hours)
â”‚   â”œâ”€â”€ Convert field type
â”‚   â”œâ”€â”€ Update all usages
â”‚   â”œâ”€â”€ Write tests
â”‚   â””â”€â”€ Commit: "fix: convert image_failures to bounded LRU cache"
â”‚
â””â”€â”€ Stage 6: Cache clearing on file load (30 min)
    â”œâ”€â”€ Add clear_image_failure_cache() call in load_content()
    â”œâ”€â”€ Write test
    â””â”€â”€ Commit: "fix: clear image failure cache on file load"

Week 2:
â”œâ”€â”€ Stage 4: QuickJS memory limit (1 hour)
â”‚   â”œâ”€â”€ Update constant
â”‚   â”œâ”€â”€ Add env var override
â”‚   â”œâ”€â”€ Test with complex diagrams
â”‚   â””â”€â”€ Commit: "perf: reduce QuickJS memory limit from 2GB to 512MB"
â”‚
â”œâ”€â”€ Stage 5: JS text cache clearing + explicit GC (2-3 hours)
â”‚   â”œâ”€â”€ Add clearing function to DOM shim
â”‚   â”œâ”€â”€ Implement periodic clearing
â”‚   â”œâ”€â”€ Add explicit ctx.run_gc() call (P7)
â”‚   â”œâ”€â”€ Test accumulation prevention
â”‚   â””â”€â”€ Commit: "fix: add JS text cache clearing and explicit QuickJS GC"
â”‚
â”œâ”€â”€ Stage 7: egui texture cleanup research (1-2 hours)
â”‚   â”œâ”€â”€ Research egui 0.27 texture management APIs
â”‚   â”œâ”€â”€ Document findings
â”‚   â”œâ”€â”€ Implement if beneficial
â”‚   â””â”€â”€ Commit: "docs: document egui texture lifecycle" or "fix: add explicit texture cleanup"
â”‚
â”œâ”€â”€ Stage 9: SVG cache size-based eviction (2-3 hours)
â”‚   â”œâ”€â”€ Add size tracking to SvgCache struct
â”‚   â”œâ”€â”€ Implement size-based eviction (100MB limit)
â”‚   â”œâ”€â”€ Update insert/evict methods
â”‚   â”œâ”€â”€ Write tests
â”‚   â””â”€â”€ Commit: "fix: add size-based eviction to Mermaid SVG cache"
â”‚
â””â”€â”€ Final: Integration testing & documentation
    â”œâ”€â”€ Run full test suite
    â”œâ”€â”€ Manual memory testing
    â”œâ”€â”€ Update CLAUDE.md if needed
    â””â”€â”€ Commit: "docs: update memory management documentation"
```

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| LRU eviction causes visible re-rendering | Low | Low | 512 capacity is generous for typical use |
| QuickJS 512MB too low for complex diagrams | Low | Medium | Env var override available |
| Performance regression from cache management | Low | Low | LRU operations are O(n) but n is small |
| Existing tests fail | Medium | Low | Fix tests as part of implementation |

---

## Appendix: File Change Summary

| File | Changes |
|------|---------|
| `src/markdown_renderer.rs` | Add LruCache<K,V>, convert emoji_textures, convert image_failures, add clearing methods |
| `src/mermaid_renderer.rs` | Reduce memory limit to 512MB, add env var override, add JS cache clearing, add explicit GC, add size-based SVG cache eviction |
| `src/app.rs` | Add `clear_image_failure_cache()` call in `load_content()` |

**Estimated Total LOC Changed**: ~250-300 lines added/modified

---

## Appendix: Complete Issue Tracking Matrix

This matrix shows ALL issues found during investigation and their disposition:

### Issues Being Fixed

| # | Issue | Severity | Action | Stage |
|---|-------|----------|--------|-------|
| 1 | `emoji_textures` unbounded HashMap | CRITICAL | Fix with LRU cache (capacity 512) | Stage 2 |
| 2 | `image_failures` unbounded HashMap | HIGH | Fix with LRU cache (capacity 256) | Stage 3 |
| 3 | `image_failures` not cleared on file load | HIGH | Add clearing call in `load_content()` | Stage 6 |
| 4 | QuickJS 2GB per worker limit | MODERATE | Reduce to 512MB + env var override | Stage 4 |
| 5 | JS `__mdmdview_text_cache` unbounded | MODERATE | Add periodic clearing when size > 5000 | Stage 5 |
| 6 | egui texture cleanup not explicit | MODERATE | Research egui APIs & implement if beneficial | Stage 7 |
| 7 | SVG cache no size limit (64 Ã— 10MB = 640MB) | LOW | Add size-based eviction (100MB cap) | Stage 9 |
| 8 | QuickJS GC not explicitly triggered | LOW | Add `ctx.run_gc()` after heavy operations | Stage 5 |

### Design Decisions (Deliberate Deviations from Investigation)

| # | Investigation Recommendation | Plan Decision | Justification |
|---|------------------------------|---------------|---------------|
| 9 | Fix #3: Clear `emoji_textures` on file load | NOT implementing | LRU (Stage 2) handles this. Clearing would hurt performance due to emoji reuse across docs. Memory bounded to ~25MB max. See Stage 6.2. |

### Issues Not Requiring Fixes (Already Bounded or Self-Limiting)

| # | Component | Category | Justification |
|---|-----------|----------|---------------|
| 10 | `mermaid_pending` HashSet | Self-limiting | Bounded by job queue (16 max), entries removed on result |
| 11 | `image_pending` HashSet | Self-limiting | Bounded by IMAGE_MAX_PENDING=64, entries removed on completion |
| 12 | `column_stats_cache` HashMap | Cleared between files | `clear_table_layout_cache()` called on file load |
| 13 | `image_textures` ImageCache | Already bounded | LRU with capacity 256 |
| 14 | `mermaid_textures` LRU | Already bounded | LRU with capacity 128 |
| 15 | `mermaid_errors` LRU | Already bounded | LRU with capacity 64 |
| 16 | `mermaid_texture_errors` LRU | Already bounded | LRU with capacity 64 |
| 17 | `table_layout_cache` | Already bounded | LRU with capacity 512 |
| 18 | `header_rects` HashMap | Cleared per frame | Line 2507 clears on each render |
| 19 | `element_rects` Vec | Cleared per frame | Line 2513 clears on each render |
| 20 | Navigation history | Already bounded | FIFO eviction at 50 entries |
| 21 | `pending_files` VecDeque | Already bounded | Capped at 50 per drag-drop |
| 22 | RGBA buffer copies in Mermaid | Performance only | Not a leak - buffers freed after use |
| 23 | Font database | Fixed overhead | Shared Arc, loaded once (~10-50MB), freed on app exit |

**Summary**:
- **8 issues being fixed** (Stages 2-7, 9)
- **1 deliberate deviation** documented with justification
- **14 issues verified as already handled** (bounded, cleared, or self-limiting)

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2026-01-16 | Initial plan based on memory leak investigation |
| 1.1 | 2026-01-16 | Added: Stage 6 (cache clearing on file load), Stage 7 (egui research), complete issue tracking matrix, "Issues NOT Requiring Fixes" section |
| 1.2 | 2026-01-16 | Complete coverage review: Added all 14 bounded components from journal, documented deliberate deviation for emoji clearing (Fix #3), expanded Issue Tracking Matrix to 21 items with full justifications |
| 1.3 | 2026-01-16 | Added 3 low-priority items from deep agent review: Stage 9 (SVG cache size-based eviction), Step 5.3 (explicit QuickJS GC), font database documentation. Total issues tracked: 23 |


# HLD: Pikchr Diagram Rendering Integration

**Date**: 2026-02-14
**Author**: Arthur & Claude
**Status**: Draft
**Version**: 1.0.0

---

## 1. Overview

### 1.1 Motivation

mdmdview currently supports Mermaid diagram rendering via an embedded QuickJS engine.
Users have requested support for additional diagram types. Pikchr is an ideal
candidate because:

- It is a **single C file** (~10K lines) with zero external dependencies
- It produces **SVG output** directly, plugging into our existing rasterization pipeline
- It is **public domain** (no licensing concerns)
- It is battle-tested in production (Fossil VCS, the SQLite project's version control)
- It preserves the **single-binary distribution** model that defines mdmdview

### 1.2 What is Pikchr?

Pikchr (pronounced "picture") is a PIC-like markup language for diagrams in
technical documentation. Created by D. Richard Hipp (author of SQLite), it
converts text descriptions into SVG diagrams.

Example input:
```pikchr
arrow right 200% "Markdown" "Source"
box rad 10px "Pikchr" "Renderer" fit
arrow right 200% "SVG" "Output"
box rad 10px "Rasterizer" fit
arrow right 200% "Texture" "Display"
```

Key characteristics:
- Declarative diagram language with automatic layout
- Supports boxes, circles, cylinders, arrows, lines, arcs, splines
- Relative positioning ("right of", "below", "2nd box")
- Labels, colors, line styles, fill patterns
- Variables and expressions for computed layouts
- Dark mode support via `PIKCHR_DARK_MODE` flag

### 1.3 Scope

This document covers the design for integrating Pikchr as an embedded diagram
renderer in mdmdview. The integration follows the same patterns established by
the Mermaid renderer where possible, but is dramatically simpler because Pikchr
is a synchronous C function call rather than an asynchronous JavaScript engine.

### 1.4 Non-Goals

- Replacing or competing with Mermaid (they serve different diagram types)
- Supporting Pikchr editing/preview (would be a separate feature)
- Adding a GUI diagram editor
- Server-side rendering or network-based approaches

---

## 2. Architecture

### 2.1 High-Level Data Flow

```
Markdown file
    |
    v
pulldown-cmark parser
    |
    v
CodeBlock { language: "pikchr", text: "..." }
    |
    v
render_code_block() detects language == "pikchr"
    |
    v
pikchr_renderer.render_block(ui, code, ui_scale, code_font_size)
    |
    v
pikchr::Pikchr::render(code, None, flags)  -->  SVG string
    |
    v
SVG rasterization (usvg + resvg + tiny-skia)  -->  RGBA pixels
    |
    v
egui texture upload  -->  displayed in UI
```

### 2.2 Key Design Decision: Synchronous Rendering

Unlike Mermaid, which requires an asynchronous worker pool (QuickJS engine,
DOM shim, multi-second render times), Pikchr renders **synchronously in
microseconds**. A typical Pikchr diagram renders in 50-500 microseconds.

This means:
- **No worker threads** needed
- **No job queue** or pending state
- **No placeholder/spinner UI**
- Rendering happens inline during the egui frame
- The only async component is caching the rasterized texture

This dramatically simplifies the architecture compared to Mermaid's ~9,000 lines.

### 2.3 Component Architecture

```
MarkdownRenderer
    |
    +-- mermaid: MermaidRenderer       (existing, ~9K lines)
    |
    +-- pikchr: PikchrRenderer         (new, ~300-500 lines)
            |
            +-- texture_cache: LruTextureCache
            +-- error_cache: LruCache<u64, String>
            +-- svg_cache: LruCache<u64, String>
```

`PikchrRenderer` is a new struct stored alongside `MermaidRenderer` in
`MarkdownRenderer`. It follows the same public API pattern:

| Method                     | Purpose                                       |
|----------------------------|-----------------------------------------------|
| `new()`                    | Constructor                                   |
| `render_block(ui, code, ui_scale, code_font_size)` | Main entry point called during rendering |
| `begin_frame()`            | Per-frame bookkeeping (cache maintenance)     |
| `has_pending()`            | Always returns `false` (sync rendering)       |
| `release_gpu_textures()`   | Free GPU textures on minimize/cleanup         |

---

## 3. Dependency: `pikchr` Crate

### 3.1 Crate Details

| Field          | Value                                                   |
|----------------|---------------------------------------------------------|
| Crate          | [`pikchr`](https://crates.io/crates/pikchr)            |
| Version        | 0.1.4                                                   |
| Last updated   | 2025-03-01                                              |
| License        | MIT / Apache-2.0 (dual)                                 |
| Dependencies   | `libc` (runtime), `cc` (build)                          |
| Size           | ~300 KB (mostly pikchr.c)                               |
| Upstream       | Bundles pikchr.c from pikchr.org (2025-02-28 snapshot)  |

### 3.2 Rust API

```rust
use pikchr::{Pikchr, PikchrFlags};

// Render a diagram to SVG
let result = Pikchr::render(source_code, None, PikchrFlags::default());

match result {
    Ok(svg) => {
        // svg implements Display, Deref<Target=str>
        // svg.width() -> i32
        // svg.height() -> i32
        println!("{}", svg);
    }
    Err(error_message) => {
        eprintln!("Pikchr error: {}", error_message);
    }
}
```

Flags:
- `PikchrFlags::default()` - Standard rendering
- `PikchrFlags::DARK_MODE` - Inverts colors for dark backgrounds
- `PikchrFlags::PLAINTEXT_ERRORS` - Error messages as plain text (not HTML)

### 3.3 Underlying C API

The crate wraps the single C function:

```c
char *pikchr(
    const char *zText,      // Input Pikchr source text
    const char *zClass,     // Optional CSS class for <svg> element
    unsigned int mFlags,    // PIKCHR_PLAINTEXT_ERRORS | PIKCHR_DARK_MODE
    int *pnWidth,           // Output: SVG width (negative on error)
    int *pnHeight           // Output: SVG height
);
```

Memory: Returns `malloc()`-allocated string. The Rust crate handles `free()`.

### 3.4 Why Use the Crate vs. Raw FFI

The `pikchr` crate:
- Bundles a recent snapshot of `pikchr.c` (no need to vendor it ourselves)
- Handles `cc` compilation in its own `build.rs`
- Provides safe Rust wrappers with proper memory management
- Handles `CString` conversion and null termination
- Returns `Result<Pikchr, String>` with proper error handling
- Provides typed flags via `PikchrFlags`

Building our own FFI binding would save zero dependencies (we'd still need `cc`
and `libc`) while adding maintenance burden. The crate is small, well-maintained,
and MIT-licensed. No reason to reinvent it.

---

## 4. Feature Flag Design

### 4.1 Cargo Feature Structure

```toml
[features]
default = ["mermaid-embedded", "pikchr"]

# Pikchr diagram rendering (embedded C library)
pikchr = ["dep:pikchr"]
```

```toml
[dependencies.pikchr]
version = "0.1"
optional = true
```

### 4.2 Conditional Compilation

All Pikchr code wrapped in `#[cfg(feature = "pikchr")]`:

```rust
#[cfg(feature = "pikchr")]
mod pikchr_renderer;

#[cfg(feature = "pikchr")]
use pikchr_renderer::PikchrRenderer;
```

When the feature is disabled, `pikchr` code blocks render as ordinary syntax-
highlighted code blocks (no special handling).

### 4.3 Build Configurations

| Configuration                                      | Mermaid | Pikchr |
|----------------------------------------------------|---------|--------|
| `cargo build` (default)                            | Yes     | Yes    |
| `cargo build --no-default-features`                | No      | No     |
| `cargo build --no-default-features --features pikchr` | No  | Yes    |
| `cargo build --features mermaid-embedded`          | Yes     | No*    |

*Unless `pikchr` is also in default features (which it will be).

---

## 5. Detailed Design

### 5.1 New File: `src/pikchr_renderer.rs`

Estimated size: **300-500 lines** (including tests).

#### 5.1.1 Data Structures

```rust
/// Pikchr diagram renderer.
///
/// Renders Pikchr markup to SVG using the embedded pikchr C library,
/// then rasterizes SVG to egui textures via usvg/resvg.
/// Synchronous rendering - no worker threads needed.
pub(crate) struct PikchrRenderer {
    /// LRU cache: texture_key -> (TextureHandle, [width, height])
    textures: RefCell<HashMap<String, PikchrTextureEntry>>,
    /// LRU order tracking for texture eviction
    texture_order: RefCell<VecDeque<String>>,
    /// SVG cache: svg_key (hash of source) -> SVG string
    svg_cache: RefCell<HashMap<u64, String>>,
    svg_order: RefCell<VecDeque<u64>>,
    /// Error cache: svg_key -> error message (prevents re-rendering known failures)
    errors: RefCell<HashMap<u64, String>>,
    error_order: RefCell<VecDeque<u64>>,
}

struct PikchrTextureEntry {
    texture: egui::TextureHandle,
    size: [u32; 2],
}
```

#### 5.1.2 Cache Capacity Constants

```rust
/// Maximum number of cached textures (GPU memory)
const PIKCHR_TEXTURE_CACHE_CAPACITY: usize = 64;
/// Maximum number of cached SVG strings
const PIKCHR_SVG_CACHE_CAPACITY: usize = 64;
/// Maximum number of cached errors
const PIKCHR_ERROR_CACHE_CAPACITY: usize = 32;
```

These are conservative. Pikchr diagrams are small (a few KB of SVG) so 64
entries is plenty without meaningful memory pressure.

#### 5.1.3 Core Rendering Method

```rust
pub(crate) fn render_block(
    &self,
    ui: &mut egui::Ui,
    code: &str,
    ui_scale: f32,
    code_font_size: f32,
) -> bool {
    let svg_key = hash_str(code);
    let dark_mode = ui.visuals().dark_mode;

    // 1. Check error cache (don't re-render known failures)
    if let Some(err) = self.errors.borrow().get(&svg_key) {
        self.render_error_block(ui, err, code, code_font_size);
        return true;
    }

    // 2. Compute texture cache key (incorporates width bucket + scale + theme)
    let available_width = ui.available_width().max(1.0);
    let width_bucket = bucket_width(available_width);
    let scale_bucket = bucket_scale(ui_scale);
    let texture_key = format!(
        "pikchr:{:016x}:w{}:s{}:dm{}",
        svg_key, width_bucket, scale_bucket, dark_mode as u8
    );

    // 3. Check texture cache
    if let Some(entry) = self.textures.borrow().get(&texture_key) {
        self.render_texture(ui, entry, available_width);
        return true;
    }

    // 4. Check SVG cache or render fresh SVG
    let svg = if let Some(cached) = self.svg_cache.borrow().get(&svg_key) {
        cached.clone()
    } else {
        match self.render_pikchr_to_svg(code, dark_mode) {
            Ok(svg) => {
                self.cache_svg(svg_key, svg.clone());
                svg
            }
            Err(err) => {
                self.cache_error(svg_key, err.clone());
                self.render_error_block(ui, &err, code, code_font_size);
                return true;
            }
        }
    };

    // 5. Rasterize SVG to RGBA and upload as texture
    match self.rasterize_and_upload(ui.ctx(), &texture_key, &svg, width_bucket, scale_bucket) {
        Ok(entry) => {
            self.render_texture(ui, &entry, available_width);
            self.cache_texture(texture_key, entry);
            true
        }
        Err(err) => {
            self.cache_error(svg_key, err.clone());
            self.render_error_block(ui, &err, code, code_font_size);
            true
        }
    }
}
```

#### 5.1.4 Pikchr-to-SVG Rendering

```rust
fn render_pikchr_to_svg(&self, code: &str, dark_mode: bool) -> Result<String, String> {
    use pikchr::{Pikchr, PikchrFlags};

    let mut flags = PikchrFlags::PLAINTEXT_ERRORS;
    if dark_mode {
        flags |= PikchrFlags::DARK_MODE;
    }

    Pikchr::render(code, None, flags)
        .map(|svg| svg.to_string())
        .map_err(|e| e.to_string())
}
```

This is the entire Pikchr integration point. One function call. Compare this
with Mermaid's ~2,000-line QuickJS initialization, DOM shim, and worker pool.

#### 5.1.5 SVG Rasterization

Reuses the same `usvg` + `resvg` + `tiny-skia` pipeline that Mermaid uses.
We extract the common rasterization logic rather than duplicating it:

```rust
fn rasterize_and_upload(
    &self,
    ctx: &egui::Context,
    texture_key: &str,
    svg: &str,
    width_bucket: u32,
    scale_bucket: u32,
) -> Result<PikchrTextureEntry, String> {
    // Parse SVG
    let opt = usvg::Options::default();
    let tree = usvg::Tree::from_data(svg.as_bytes(), &opt)
        .map_err(|e| format!("SVG parse error: {}", e))?;

    // Compute dimensions
    let size = tree.size().to_int_size();
    let (w, h) = (size.width().max(1), size.height().max(1));

    // Compute scale factor
    let base_scale = scale_bucket as f32 / 100.0;
    let width_scale = width_bucket as f32 / w.max(1) as f32;
    let scale = base_scale.min(width_scale).clamp(0.1, 4.0);

    let target_w = (w as f32 * scale).round().max(1.0) as u32;
    let target_h = (h as f32 * scale).round().max(1.0) as u32;

    // Clamp to reasonable maximum
    let max_side = 4096;
    let (target_w, target_h) = clamp_dimensions(target_w, target_h, max_side);

    // Rasterize
    let mut pixmap = tiny_skia::Pixmap::new(target_w, target_h)
        .ok_or_else(|| "Pixmap allocation failed".to_string())?;

    // Pikchr SVGs have no background; fill with transparent
    let transform = tiny_skia::Transform::from_scale(scale, scale);
    resvg::render(&tree, transform, &mut pixmap.as_mut());

    // Upload to GPU
    let rgba = pixmap.data().to_vec();
    let image = egui::ColorImage::from_rgba_unmultiplied(
        [target_w as usize, target_h as usize],
        &rgba,
    );
    let texture = ctx.load_texture(
        texture_key.to_string(),
        image,
        egui::TextureOptions::LINEAR,
    );

    Ok(PikchrTextureEntry {
        texture,
        size: [target_w, target_h],
    })
}
```

#### 5.1.6 Texture Display

```rust
fn render_texture(
    &self,
    ui: &mut egui::Ui,
    entry: &PikchrTextureEntry,
    available_width: f32,
) {
    let (tw, th) = (entry.size[0] as f32, entry.size[1] as f32);
    let scale = if tw > available_width {
        (available_width / tw).clamp(0.01, 4.0)
    } else {
        1.0
    };
    let size = egui::vec2((tw * scale).round(), (th * scale).round());
    ui.add(egui::Image::new(&entry.texture).fit_to_exact_size(size));
}
```

#### 5.1.7 Error Display

```rust
fn render_error_block(
    &self,
    ui: &mut egui::Ui,
    error: &str,
    code: &str,
    code_font_size: f32,
) {
    let tc = ThemeColors::current(ui.visuals().dark_mode);
    egui::Frame::none()
        .fill(tc.box_bg)
        .stroke(egui::Stroke::new(1.0, egui::Color32::from_rgb(200, 80, 80)))
        .inner_margin(8.0)
        .show(ui, |ui| {
            ui.label(
                egui::RichText::new("Pikchr rendering error:")
                    .color(egui::Color32::from_rgb(200, 80, 80))
                    .size(code_font_size),
            );
            ui.label(
                egui::RichText::new(error)
                    .color(egui::Color32::LIGHT_GRAY)
                    .size(code_font_size)
                    .family(egui::FontFamily::Monospace),
            );
            ui.add_space(4.0);
            ui.label(
                egui::RichText::new(code)
                    .size(code_font_size)
                    .color(tc.code_fallback_text)
                    .family(egui::FontFamily::Monospace),
            );
        });
}
```

### 5.2 Cache Key Design

The texture cache key incorporates all parameters that affect the rendered output:

```
pikchr:{svg_hash}:w{width_bucket}:s{scale_bucket}:dm{dark_mode}
```

Components:
- `svg_hash`: 64-bit hash of the Pikchr source code (u64, hex-encoded)
- `width_bucket`: Available width rounded to nearest 32px (matches Mermaid)
- `scale_bucket`: UI scale * 100, rounded (matches Mermaid)
- `dark_mode`: 0 or 1 (Pikchr renders differently in dark mode via `PIKCHR_DARK_MODE` flag)

Note: Dark mode is a cache key component because Pikchr's `PIKCHR_DARK_MODE`
flag inverts colors in the SVG output itself. The same source code produces
different SVGs in light vs dark mode. The SVG cache is therefore also keyed
by `(svg_hash, dark_mode)` rather than just `svg_hash`.

### 5.3 Dark Mode Handling

Pikchr has native dark mode support via the `PIKCHR_DARK_MODE` flag, which
inverts diagram colors. This is superior to post-processing SVG colors.

When the user toggles dark/light mode:
1. The SVG cache key includes `dark_mode`, so cached SVGs for the wrong theme
   are simply not matched
2. New SVGs are rendered with the correct flag
3. Texture cache key also includes `dm{0|1}`, so textures are theme-specific

SVG cache key: `(hash(code), dark_mode)` -- a composite key or two separate
caches indexed by `u64` where the key embeds dark_mode in the hash.

### 5.4 Modifications to Existing Files

#### 5.4.1 `Cargo.toml`

```toml
[features]
default = ["mermaid-embedded", "pikchr"]
# ... existing features ...
# Pikchr diagram rendering (embedded C library, compiled from C source)
pikchr = ["dep:pikchr"]

[dependencies.pikchr]
version = "0.1"
optional = true
```

Also add `cc` to `[build-dependencies]` if not already present (the `pikchr`
crate's own build.rs handles this, so no change needed at our level).

#### 5.4.2 `src/markdown_renderer.rs`

**New field in `MarkdownRenderer`**:

```rust
pub struct MarkdownRenderer {
    // ... existing fields ...
    mermaid: MermaidRenderer,
    #[cfg(feature = "pikchr")]
    pikchr: PikchrRenderer,
    // ...
}
```

**Constructor** (`MarkdownRenderer::new()`):

```rust
Self {
    // ... existing fields ...
    mermaid,
    #[cfg(feature = "pikchr")]
    pikchr: PikchrRenderer::new(),
    // ...
}
```

**Code block dispatch** (`render_code_block()`):

```rust
// Special handling for Mermaid diagrams
if let Some(lang) = language {
    if lang.eq_ignore_ascii_case("mermaid") {
        let _ = self.render_mermaid_block(ui, code);
        ui.add_space(8.0);
        return;
    }
    #[cfg(feature = "pikchr")]
    if lang.eq_ignore_ascii_case("pikchr") || lang.eq_ignore_ascii_case("pic") {
        let _ = self.render_pikchr_block(ui, code);
        ui.add_space(8.0);
        return;
    }
}
```

We recognize both `pikchr` and `pic` as language identifiers (PIC is the
original AT&T language that Pikchr is derived from).

**New method**:

```rust
#[cfg(feature = "pikchr")]
fn render_pikchr_block(&self, ui: &mut egui::Ui, code: &str) -> bool {
    self.pikchr
        .render_block(ui, code, self.ui_scale(), self.font_sizes.code)
}
```

**Syntax highlight skip** (alongside Mermaid skip):

```rust
if lang.eq_ignore_ascii_case("mermaid") {
    return None;
}
#[cfg(feature = "pikchr")]
if lang.eq_ignore_ascii_case("pikchr") || lang.eq_ignore_ascii_case("pic") {
    return None;
}
```

**Frame lifecycle** (`begin_frame()`):

```rust
self.mermaid.begin_frame();
#[cfg(feature = "pikchr")]
self.pikchr.begin_frame();
```

**Pending check** (`has_pending_renders()`):

```rust
pub fn has_pending_renders(&self) -> bool {
    self.mermaid.has_pending()
    || !self.image_pending.borrow().is_empty()
    // Pikchr is synchronous; never pending
}
```

No change needed here since Pikchr renders synchronously.

**GPU release** (`release_gpu_textures()`):

```rust
pub fn release_gpu_textures(&self) {
    // ... existing image cleanup ...
    self.mermaid.release_gpu_textures();
    #[cfg(feature = "pikchr")]
    self.pikchr.release_gpu_textures();
}
```

#### 5.4.3 `src/app.rs`

No direct changes needed. The app interacts with `MarkdownRenderer`, which
internally manages the `PikchrRenderer`. All lifecycle calls (begin_frame,
release_gpu_textures, has_pending_renders) already delegate through
`MarkdownRenderer`.

#### 5.4.4 `build.rs`

No changes needed. The `pikchr` crate handles its own C compilation via its
own `build.rs`. We don't need to embed any external assets.

#### 5.4.5 `src/sample_files.rs`

Add a new sample file demonstrating Pikchr syntax:

```rust
SampleFile {
    name: "Pikchr Diagrams",
    content: include_str!("../assets/samples/pikchr_sample.md"),
}
```

This sample would showcase basic Pikchr diagrams: boxes, arrows, flowcharts,
sequence-style diagrams, and dark mode rendering.

### 5.5 Sample Pikchr Markdown

Create `assets/samples/pikchr_sample.md`:

````markdown
# Pikchr Diagrams

mdmdview supports [Pikchr](https://pikchr.org) diagrams. Pikchr is a PIC-like
markup language for diagrams in technical documentation.

## Simple Flow

```pikchr
arrow right 200% "Request" above
box "Server" fit rad 10px
arrow right 200% "Response" above
```

## Architecture Diagram

```pikchr
box "Browser" fit rad 10px
arrow right 250% "HTTP" above
box "Web Server" fit rad 10px
arrow right 250% "SQL" above
cylinder "Database" fit
```

## Decision Flow

```pikchr
box "Start" fit rad 50%
arrow down
diamond "OK?" fit
arrow right 200% "Yes" above
box "Done" fit rad 50%
move to 2nd last diamond.s
arrow down "No" ljust
box "Retry" fit rad 10px
arrow left then up then right to 1st box.w
```
````

---

## 6. Testing Strategy

### 6.1 Unit Tests (in `pikchr_renderer.rs`)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_render_simple_diagram() {
        let svg = render_pikchr_to_svg_standalone(
            "box \"Hello\" fit",
            false,
        );
        assert!(svg.is_ok());
        let svg = svg.unwrap();
        assert!(svg.contains("<svg"));
        assert!(svg.contains("Hello"));
    }

    #[test]
    fn test_render_dark_mode() {
        let light = render_pikchr_to_svg_standalone("box \"Test\" fit", false).unwrap();
        let dark = render_pikchr_to_svg_standalone("box \"Test\" fit", true).unwrap();
        // Dark and light modes should produce different SVGs
        assert_ne!(light, dark);
    }

    #[test]
    fn test_render_invalid_syntax() {
        let result = render_pikchr_to_svg_standalone(
            "this is not valid pikchr syntax }{}{",
            false,
        );
        assert!(result.is_err());
    }

    #[test]
    fn test_render_empty_input() {
        let result = render_pikchr_to_svg_standalone("", false);
        // Empty input produces empty/minimal SVG, not an error
        assert!(result.is_ok());
    }

    #[test]
    fn test_cache_key_includes_dark_mode() {
        let key_light = texture_key(12345, 640, 100, false);
        let key_dark = texture_key(12345, 640, 100, true);
        assert_ne!(key_light, key_dark);
    }

    #[test]
    fn test_cache_key_includes_width_bucket() {
        let key1 = texture_key(12345, 640, 100, false);
        let key2 = texture_key(12345, 672, 100, false);
        assert_ne!(key1, key2);
    }

    #[test]
    fn test_svg_contains_dimensions() {
        let svg = render_pikchr_to_svg_standalone(
            "box \"Test\" fit",
            false,
        ).unwrap();
        // Pikchr SVGs should have width/height or viewBox
        assert!(svg.contains("width") || svg.contains("viewBox"));
    }

    #[test]
    fn test_complex_diagram() {
        let code = r#"
            arrow right 200% "Markdown" "Source"
            box rad 10px "Pikchr" "Renderer" fit
            arrow right 200% "SVG" "Output"
            box rad 10px "Rasterizer" fit
        "#;
        let svg = render_pikchr_to_svg_standalone(code, false);
        assert!(svg.is_ok());
    }
}
```

### 6.2 Integration Tests (in `markdown_renderer.rs`)

```rust
#[cfg(feature = "pikchr")]
#[test]
fn test_pikchr_code_block_detected() {
    let renderer = MarkdownRenderer::new();
    let elements = renderer.parse("```pikchr\nbox \"Hello\"\n```");
    assert_eq!(elements.len(), 1);
    match &elements[0] {
        MarkdownElement::CodeBlock { language, .. } => {
            assert_eq!(language.as_deref(), Some("pikchr"));
        }
        _ => panic!("Expected CodeBlock"),
    }
}

#[cfg(feature = "pikchr")]
#[test]
fn test_pic_language_alias() {
    // "pic" should also be recognized as pikchr
    let renderer = MarkdownRenderer::new();
    let elements = renderer.parse("```pic\nbox \"Hello\"\n```");
    assert_eq!(elements.len(), 1);
    match &elements[0] {
        MarkdownElement::CodeBlock { language, .. } => {
            assert_eq!(language.as_deref(), Some("pic"));
        }
        _ => panic!("Expected CodeBlock"),
    }
}
```

### 6.3 Test Coverage Goals

| Area                        | Test type     | Count |
|-----------------------------|---------------|-------|
| SVG rendering (valid input) | Unit          | 5-8   |
| SVG rendering (errors)      | Unit          | 3-5   |
| Dark mode SVG differences   | Unit          | 2-3   |
| Cache key correctness       | Unit          | 3-5   |
| Language detection           | Integration   | 2-3   |
| Syntax highlight skip       | Integration   | 1-2   |
| **Total**                   |               | ~20   |

---

## 7. Performance Considerations

### 7.1 Rendering Speed

Pikchr renders in microseconds. Even a complex diagram with dozens of objects
completes in under 1 millisecond. This is fast enough to render synchronously
within an egui frame (16ms budget at 60 FPS) without any perceptible lag.

### 7.2 SVG Rasterization

The SVG-to-RGBA rasterization via `usvg`/`resvg` is the more expensive step
(typically 1-10ms depending on diagram complexity and output size). This is
still well within frame budget, especially since:

- Results are cached (subsequent frames are texture lookups only)
- Pikchr diagrams are typically simpler than Mermaid diagrams
- The cache key bucketing prevents re-rasterization for minor width changes

### 7.3 Memory Footprint

| Component                  | Estimated size        |
|----------------------------|-----------------------|
| `pikchr.c` compiled code   | ~100 KB in binary     |
| SVG cache (64 entries)     | ~256 KB typical       |
| Texture cache (64 entries) | ~10-50 MB GPU memory  |
| Error cache (32 entries)   | ~16 KB                |

The binary size increase is minimal (~100 KB for the compiled C code).

### 7.4 Compared to Mermaid

| Metric                   | Mermaid              | Pikchr              |
|--------------------------|----------------------|---------------------|
| Binary size overhead     | ~3.3 MB (mermaid.js) | ~100 KB (pikchr.c)  |
| Render time (typical)    | 500ms - 5s           | 0.05 - 1ms          |
| Worker threads needed    | 1-4                  | 0                   |
| Memory (JS runtime)      | ~50 MB per worker    | 0                   |
| Async machinery          | Channels, pending    | None                |
| Code complexity           | ~9,000 lines         | ~300-500 lines      |

---

## 8. File Summary

| File                              | Action     | Description                                       |
|-----------------------------------|------------|---------------------------------------------------|
| `Cargo.toml`                      | Modify     | Add `pikchr` feature and dependency               |
| `src/pikchr_renderer.rs`          | **Create** | New module: PikchrRenderer (~300-500 lines)        |
| `src/markdown_renderer.rs`        | Modify     | Add pikchr field, dispatch, lifecycle integration  |
| `assets/samples/pikchr_sample.md` | **Create** | Sample markdown showcasing Pikchr diagrams         |
| `src/sample_files.rs`             | Modify     | Register the new Pikchr sample file                |

No changes to: `build.rs`, `src/app.rs`, `src/main.rs`, `src/mermaid_renderer.rs`,
`src/window_state.rs`.

---

## 9. Rollout and Risk

### 9.1 Risks

| Risk                                    | Likelihood | Impact | Mitigation                               |
|-----------------------------------------|------------|--------|------------------------------------------|
| `pikchr` crate becomes unmaintained     | Low        | Low    | Can vendor `pikchr.c` directly if needed |
| C compilation fails on some platforms   | Low        | Medium | `cc` crate is battle-tested; CI catches  |
| Pikchr SVG not compatible with usvg     | Low        | Medium | Pikchr generates simple, clean SVG       |
| Binary size objections                  | Very low   | Low    | ~100 KB is negligible                    |

### 9.2 Rollout Plan

1. Add `pikchr` dependency and feature flag to `Cargo.toml`
2. Create `src/pikchr_renderer.rs` with core rendering + cache + error handling
3. Wire into `markdown_renderer.rs` (field, dispatch, lifecycle)
4. Write unit tests in `pikchr_renderer.rs`
5. Write integration tests in `markdown_renderer.rs`
6. Create sample file and register in `sample_files.rs`
7. Build debug + release, run full test suite
8. Update `CLAUDE.md` to document the Pikchr feature

### 9.3 Version Bump

This is a new feature (backward-compatible addition): **minor version bump**.
`1.6.0` -> `1.7.0`.

---

## 10. Future Considerations

These are explicitly **out of scope** for this change but worth noting:

- **Shared SVG rasterization utility**: If we add more diagram types, extract
  the SVG-to-texture pipeline into a shared module. For now, minor duplication
  between Mermaid and Pikchr rasterization is acceptable (Mermaid's is heavily
  specialized with viewBox manipulation, bbox correction, etc.)

- **Pikchr syntax highlighting**: The code block source could benefit from basic
  syntax highlighting (keywords, strings, numbers). Low priority.

- **Live preview in raw mode**: Editing Pikchr source in raw mode and seeing
  the diagram update in real-time. Would require a split-pane view.

---

## References

- [Pikchr Official Site](https://pikchr.org/home/doc/trunk/homepage.md)
- [Pikchr User Manual](https://pikchr.org/home/doc/trunk/doc/userman.md)
- [Pikchr Integration Guide](https://pikchr.org/home/doc/trunk/doc/integrate.md)
- [Pikchr Download Options](https://pikchr.org/home/doc/trunk/doc/download.md)
- [`pikchr` Rust crate](https://lib.rs/crates/pikchr)
- [`pikchr` crate source](https://github.com/kinnison/pikchr)

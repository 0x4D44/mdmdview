# High-Level Design: Drag and Drop Support for mdmdview

**Date:** 2025-11-09
**Author:** Claude
**Status:** Design Proposal
**Priority:** Medium

## Executive Summary

This document outlines the design for adding drag-and-drop functionality to mdmdview, allowing users to open markdown files by dragging them from their file manager directly into the application window. This feature will improve user experience by providing a more intuitive way to open files, complementing the existing Fileâ†’Open dialog and command-line argument methods.

## Table of Contents

1. [Current State Analysis](#current-state-analysis)
2. [Problem Statement](#problem-statement)
3. [Requirements](#requirements)
4. [Proposed Solution](#proposed-solution)
5. [Technical Design](#technical-design)
6. [Implementation Plan](#implementation-plan)
7. [Edge Cases and Error Handling](#edge-cases-and-error-handling)
8. [Testing Strategy](#testing-strategy)
9. [Future Enhancements](#future-enhancements)
10. [Alternatives Considered](#alternatives-considered)

---

## Current State Analysis

### Existing File Opening Methods

mdmdview currently supports three ways to open markdown files:

1. **File Menu** (`Ctrl+O`)
   - Uses native file dialog via `rfd` crate
   - Single file selection only
   - Filtered to `.md`, `.markdown`, `.mdown`, `.mkd` extensions
   - Implementation in `MarkdownViewerApp::render_menu_bar()`

2. **Command-Line Arguments**
   - Accepts file path as first argument
   - Parsed in `src/main.rs`
   - Opens file on startup
   - Example: `mdmdview.exe document.md`

3. **Sample Files Menu**
   - Embedded markdown examples
   - Accessed via File â†’ Samples
   - Loads from `SAMPLE_FILES` constant array

### Current Architecture Relevant to Drag-Drop

- **Application Framework**: Uses `eframe` (egui) for windowing
- **File Loading**: `MarkdownViewerApp::load_file()` method handles file opening
- **Navigation History**: Recently added back/forward navigation
- **Error Handling**: Graceful error display in UI via `error_message` field
- **Platform**: Cross-platform (Windows, Linux, macOS)

### Gaps

- No visual feedback for drag-over state
- No support for opening files via drag-and-drop
- Users must navigate through file dialogs for each file

---

## Problem Statement

### User Pain Points

1. **Workflow Friction**: Users browsing markdown files in file explorer must:
   - Switch to mdmdview window
   - Open file dialog
   - Navigate to same directory they were just viewing
   - Select file

2. **No Quick Preview**: Cannot quickly drop multiple files to view in sequence

3. **Inconsistent with Modern Apps**: Most document viewers support drag-and-drop

### Business Value

- **Improved UX**: Reduces friction in common workflow
- **Professional Polish**: Matches user expectations for modern applications
- **Increased Adoption**: Users more likely to use app as default markdown viewer

---

## Requirements

### Functional Requirements

#### FR1: Single File Drop
- **Description**: User can drag a single markdown file from file explorer and drop it onto the mdmdview window to open it
- **Acceptance Criteria**:
  - File opens in current window
  - Previous file is saved to navigation history
  - Supports all valid markdown extensions (`.md`, `.markdown`, `.mdown`, `.mkd`, `.txt`)
  - Invalid files show error message (same as Fileâ†’Open)

#### FR2: Multiple File Drop
- **Description**: User can drag multiple files and drop them onto the window
- **Acceptance Criteria**:
  - First file opens immediately
  - Remaining files added to a "pending queue"
  - User can navigate forward through queue using Alt+â†’
  - Queue persists until user opens a different file via other methods

#### FR3: Visual Feedback
- **Description**: Window provides visual feedback during drag operation
- **Acceptance Criteria**:
  - Window shows overlay or border change when file is dragged over
  - Overlay indicates whether drop is valid (file type accepted)
  - Visual feedback disappears when drag leaves window or drop completes

#### FR4: Directory Drop
- **Description**: User can drag a directory onto the window
- **Acceptance Criteria**:
  - All markdown files in directory (non-recursive) are added to pending queue
  - Files sorted alphabetically
  - First file opens immediately
  - Maximum of 50 files to prevent memory issues

### Non-Functional Requirements

#### NFR1: Performance
- File drop must respond within 100ms
- Large directories (>100 files) should show "too many files" warning

#### NFR2: Cross-Platform
- Must work on Windows, Linux, and macOS
- Use platform-native drag-drop events via egui

#### NFR3: Accessibility
- Keyboard shortcuts remain primary navigation method
- Drag-drop is supplementary, not replacement

#### NFR4: Security
- Only local file paths accepted (no URLs or remote paths)
- Path validation before attempting to read
- Sandboxed file reading (existing `load_file()` security)

---

## Proposed Solution

### High-Level Approach

1. **Enable egui drag-drop support** in viewport configuration
2. **Monitor drag events** in main update loop
3. **Validate dropped files** (extension, exists, readable)
4. **Integrate with existing file loading** mechanism
5. **Add visual overlay** for drag-over feedback
6. **Extend navigation history** to support file queues

### User Flow

```
User drags file(s) from file explorer
    â†“
File enters mdmdview window
    â†“
[Visual feedback: overlay shows "Drop to open"]
    â†“
User releases mouse (drop)
    â†“
App validates file(s)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Single file?                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ YES â†’ Open immediately              â”‚
â”‚ NO  â†’ Open first, queue rest        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
Update navigation history
    â†“
Show file content (or error)
```

### Architecture Changes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MarkdownViewerApp                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ + pending_files: VecDeque<PathBuf>             â”‚  NEW
â”‚ + drag_hover: bool                              â”‚  NEW
â”‚ + fn handle_file_drop(&mut self, files: Vec)   â”‚  NEW
â”‚ + fn process_pending_file(&mut self)           â”‚  NEW
â”‚ + fn render_drag_overlay(&self, ui)            â”‚  NEW
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ uses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Existing: load_file(path: PathBuf)             â”‚
â”‚ Existing: push_history()                        â”‚
â”‚ Existing: navigate_forward()                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Technical Design

### 1. egui Integration

#### Enable Drag-Drop in Viewport

In `src/main.rs`, modify viewport configuration:

```rust
let viewport = egui::ViewportBuilder::default()
    .with_title(format!("{APP_TITLE_PREFIX} - A Simple Markdown Viewer"))
    .with_inner_size(egui::Vec2::new(1000.0, 700.0))
    .with_drag_and_drop(true)  // NEW: Enable drag-drop
    // ... existing configuration
```

#### Event Handling in Update Loop

egui provides drag-drop events via `InputState`:

```rust
// In MarkdownViewerApp::update()
ctx.input(|i| {
    // Check if files are being hovered
    if !i.raw.hovered_files.is_empty() {
        self.drag_hover = true;
    } else {
        self.drag_hover = false;
    }

    // Check if files were dropped
    if !i.raw.dropped_files.is_empty() {
        let files: Vec<PathBuf> = i.raw.dropped_files
            .iter()
            .filter_map(|f| f.path.clone())
            .collect();

        self.handle_file_drop(files);
    }
});
```

### 2. File Drop Handler

```rust
impl MarkdownViewerApp {
    /// Handle dropped files from drag-and-drop operation
    fn handle_file_drop(&mut self, paths: Vec<PathBuf>) {
        let mut valid_files = Vec::new();
        let mut errors = Vec::new();

        // Validate and filter files
        for path in paths {
            if !path.exists() {
                errors.push(format!("File not found: {}", path.display()));
                continue;
            }

            if path.is_dir() {
                // Handle directory: scan for markdown files
                match self.scan_directory(&path) {
                    Ok(files) => valid_files.extend(files),
                    Err(e) => errors.push(format!("Cannot read directory: {}", e)),
                }
            } else {
                // Handle single file
                if self.is_valid_markdown_file(&path) {
                    valid_files.push(path);
                } else {
                    errors.push(format!("Not a markdown file: {}", path.display()));
                }
            }
        }

        // Limit to prevent memory issues
        const MAX_FILES: usize = 50;
        if valid_files.len() > MAX_FILES {
            self.error_message = Some(format!(
                "Too many files ({}). Maximum is {}.",
                valid_files.len(),
                MAX_FILES
            ));
            return;
        }

        // Handle valid files
        if !valid_files.is_empty() {
            // Push current state to history if we have content
            if !self.current_content.is_empty() {
                self.push_history();
            }

            // Open first file immediately
            let first_file = valid_files.remove(0);
            if let Err(e) = self.load_file(first_file) {
                self.error_message = Some(format!("Failed to load file: {}", e));
            }

            // Queue remaining files
            self.pending_files.extend(valid_files);
        }

        // Show errors if any
        if !errors.is_empty() {
            let error_msg = if errors.len() == 1 {
                errors[0].clone()
            } else {
                format!("Multiple errors:\n{}", errors.join("\n"))
            };
            self.error_message = Some(error_msg);
        }
    }

    /// Check if file has valid markdown extension
    fn is_valid_markdown_file(&self, path: &Path) -> bool {
        if let Some(ext) = path.extension() {
            let ext = ext.to_string_lossy().to_lowercase();
            matches!(ext.as_str(), "md" | "markdown" | "mdown" | "mkd" | "txt")
        } else {
            false
        }
    }

    /// Scan directory for markdown files (non-recursive)
    fn scan_directory(&self, dir: &Path) -> Result<Vec<PathBuf>> {
        let mut files = Vec::new();

        for entry in std::fs::read_dir(dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.is_file() && self.is_valid_markdown_file(&path) {
                files.push(path);
            }
        }

        // Sort alphabetically
        files.sort();

        Ok(files)
    }
}
```

### 3. Pending Files Queue

Add to `MarkdownViewerApp` struct:

```rust
pub struct MarkdownViewerApp {
    // ... existing fields

    /// Queue of files waiting to be opened (from multi-file drop)
    pending_files: VecDeque<PathBuf>,

    /// Visual state: file is being dragged over window
    drag_hover: bool,
}
```

Integrate with existing navigation:

```rust
impl MarkdownViewerApp {
    /// Navigate forward - extended to support pending files
    fn navigate_forward(&mut self) -> bool {
        // First try pending files queue
        if let Some(next_file) = self.pending_files.pop_front() {
            // Push current state to history
            if !self.current_content.is_empty() {
                self.push_history();
            }

            // Load next file from queue
            if let Err(e) = self.load_file(next_file) {
                self.error_message = Some(format!("Failed to load file: {}", e));
            }
            return true;
        }

        // Otherwise use history navigation
        if self.history_index < self.history.len() - 1 {
            self.history_index += 1;
            self.restore_from_history();
            true
        } else {
            false
        }
    }

    /// Check if forward navigation is available
    fn can_navigate_forward(&self) -> bool {
        !self.pending_files.is_empty()
            || self.history_index < self.history.len().saturating_sub(1)
    }
}
```

### 4. Visual Feedback Overlay

```rust
impl MarkdownViewerApp {
    /// Render drag-and-drop overlay when files are hovered
    fn render_drag_overlay(&self, ctx: &egui::Context) {
        if !self.drag_hover {
            return;
        }

        // Full-screen overlay
        egui::Area::new("drag_overlay")
            .fixed_pos(egui::pos2(0.0, 0.0))
            .show(ctx, |ui| {
                let screen_rect = ctx.screen_rect();

                // Semi-transparent background
                ui.painter().rect_filled(
                    screen_rect,
                    0.0,
                    egui::Color32::from_black_alpha(128),
                );

                // Dashed border
                ui.painter().rect_stroke(
                    screen_rect.shrink(20.0),
                    8.0,
                    egui::Stroke::new(3.0, egui::Color32::from_rgb(100, 150, 255)),
                );

                // Center text
                ui.allocate_ui_at_rect(screen_rect, |ui| {
                    ui.vertical_centered(|ui| {
                        ui.add_space(screen_rect.height() / 2.0 - 50.0);

                        ui.label(
                            RichText::new("ğŸ“„ Drop files to open")
                                .size(32.0)
                                .color(egui::Color32::WHITE),
                        );

                        ui.add_space(10.0);

                        ui.label(
                            RichText::new("Markdown files (.md, .markdown, .mdown, .mkd)")
                                .size(16.0)
                                .color(egui::Color32::LIGHT_GRAY),
                        );
                    });
                });
            });
    }
}
```

### 5. Integration in Main Update Loop

```rust
impl eframe::App for MarkdownViewerApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // Handle drag-drop events (BEFORE rendering UI)
        self.handle_drag_drop_events(ctx);

        // Render drag overlay (OVER everything else)
        if self.drag_hover {
            self.render_drag_overlay(ctx);
        }

        // ... existing UI rendering (menu bar, central panel, etc.)
    }
}
```

### 6. Status Bar Enhancement

Show pending file count in status bar:

```rust
// In render_status_bar()
if !self.pending_files.is_empty() {
    ui.separator();
    ui.label(
        RichText::new(format!("ğŸ“‹ {} files in queue", self.pending_files.len()))
            .color(egui::Color32::from_rgb(100, 150, 255))
    );
}
```

---

## Implementation Plan

### Phase 1: Core Drag-Drop (Minimal Viable Feature)
**Goal**: Single file drag-drop works

1. âœ… Enable drag-drop in viewport configuration
2. âœ… Add `drag_hover` field to `MarkdownViewerApp`
3. âœ… Implement `handle_drag_drop_events()` for single file
4. âœ… Implement `is_valid_markdown_file()` validator
5. âœ… Test on Windows, Linux, macOS

**Deliverable**: User can drag single `.md` file and it opens

### Phase 2: Visual Feedback
**Goal**: User sees overlay during drag

1. âœ… Implement `render_drag_overlay()`
2. âœ… Add dashed border and semi-transparent background
3. âœ… Add descriptive text
4. âœ… Test visual appearance

**Deliverable**: Drag overlay shows when file hovers over window

### Phase 3: Multi-File Support
**Goal**: Multiple files can be dropped

1. âœ… Add `pending_files: VecDeque<PathBuf>` field
2. âœ… Modify `handle_file_drop()` to queue files
3. âœ… Extend `navigate_forward()` to check pending queue first
4. âœ… Add status bar indicator for queue size
5. âœ… Test with 5, 10, 50 files

**Deliverable**: User can drop multiple files and navigate through them

### Phase 4: Directory Support
**Goal**: Dragging folder opens all markdown files

1. âœ… Implement `scan_directory()` method
2. âœ… Add directory detection in `handle_file_drop()`
3. âœ… Implement file limit (50 files max)
4. âœ… Test with nested directories (should not recurse)

**Deliverable**: User can drop folder and all `.md` files open

### Phase 5: Polish and Edge Cases
**Goal**: Production-ready feature

1. âœ… Comprehensive error messages
2. âœ… Handle non-existent files gracefully
3. âœ… Handle permission errors
4. âœ… Add logging for debugging
5. âœ… Update CLAUDE.md documentation
6. âœ… Add unit tests

**Deliverable**: Robust, tested feature ready for release

---

## Edge Cases and Error Handling

### Edge Case 1: Invalid File Types
**Scenario**: User drops non-markdown file (e.g., `.docx`, `.pdf`)

**Handling**:
```rust
if !self.is_valid_markdown_file(&path) {
    self.error_message = Some(format!(
        "Cannot open '{}': Not a markdown file. \
         Supported: .md, .markdown, .mdown, .mkd",
        path.file_name().unwrap_or_default().to_string_lossy()
    ));
    return;
}
```

### Edge Case 2: File Does Not Exist
**Scenario**: Dropped file was deleted between drag start and drop

**Handling**:
```rust
if !path.exists() {
    self.error_message = Some(format!(
        "File not found: {}",
        path.display()
    ));
    return;
}
```

### Edge Case 3: Permission Denied
**Scenario**: User drops file they don't have read permission for

**Handling**: Existing `load_file()` already handles this via `anyhow::Result`

### Edge Case 4: Too Many Files
**Scenario**: User drops folder with 500 markdown files

**Handling**:
```rust
const MAX_FILES: usize = 50;
if valid_files.len() > MAX_FILES {
    self.error_message = Some(format!(
        "Too many files ({}). Maximum is {}. \
         Consider opening files individually or in smaller batches.",
        valid_files.len(),
        MAX_FILES
    ));
    // Optionally: offer to open first 50
    valid_files.truncate(MAX_FILES);
}
```

### Edge Case 5: Mixed Valid/Invalid Files
**Scenario**: User drops 10 files, 3 are markdown, 7 are images

**Handling**:
```rust
// Open valid files, show warning about invalid ones
if !errors.is_empty() && !valid_files.is_empty() {
    self.error_message = Some(format!(
        "Opened {} markdown files. Skipped {} non-markdown files.",
        valid_files.len(),
        errors.len()
    ));
}
```

### Edge Case 6: Drop While Editing
**Scenario**: User is in Write mode editing a file, drops new file

**Handling**:
```rust
// In handle_file_drop(), before loading new file:
if self.write_enabled && self.has_unsaved_changes() {
    // Auto-save current file (existing behavior)
    self.toggle_write_mode(ctx);  // Saves and disables write mode
}
```

### Edge Case 7: Network Paths (Windows UNC)
**Scenario**: User drops file from `\\server\share\file.md`

**Handling**: Should work automatically since `PathBuf` supports UNC paths

### Edge Case 8: Symlinks
**Scenario**: User drops symlink to markdown file

**Handling**: `PathBuf::exists()` follows symlinks, so should work naturally

---

## Testing Strategy

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_is_valid_markdown_file() {
        let app = MarkdownViewerApp::new();

        assert!(app.is_valid_markdown_file(Path::new("test.md")));
        assert!(app.is_valid_markdown_file(Path::new("test.markdown")));
        assert!(app.is_valid_markdown_file(Path::new("test.mdown")));
        assert!(app.is_valid_markdown_file(Path::new("test.mkd")));
        assert!(app.is_valid_markdown_file(Path::new("test.txt")));

        assert!(!app.is_valid_markdown_file(Path::new("test.pdf")));
        assert!(!app.is_valid_markdown_file(Path::new("test.docx")));
        assert!(!app.is_valid_markdown_file(Path::new("test")));
    }

    #[test]
    fn test_scan_directory() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let dir_path = temp_dir.path();

        // Create test files
        std::fs::write(dir_path.join("file1.md"), "# Test 1")?;
        std::fs::write(dir_path.join("file2.markdown"), "# Test 2")?;
        std::fs::write(dir_path.join("image.png"), "fake image")?;
        std::fs::write(dir_path.join("file3.md"), "# Test 3")?;

        let app = MarkdownViewerApp::new();
        let files = app.scan_directory(dir_path)?;

        assert_eq!(files.len(), 3);
        assert!(files[0].ends_with("file1.md"));
        assert!(files[1].ends_with("file2.markdown"));
        assert!(files[2].ends_with("file3.md"));

        Ok(())
    }

    #[test]
    fn test_handle_file_drop_single_file() {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.md");
        std::fs::write(&file_path, "# Test").unwrap();

        app.handle_file_drop(vec![file_path.clone()]);

        assert_eq!(app.current_file, Some(file_path));
        assert!(app.pending_files.is_empty());
        assert!(app.error_message.is_none());
    }

    #[test]
    fn test_handle_file_drop_multiple_files() {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = TempDir::new().unwrap();

        let file1 = temp_dir.path().join("test1.md");
        let file2 = temp_dir.path().join("test2.md");
        let file3 = temp_dir.path().join("test3.md");

        std::fs::write(&file1, "# Test 1").unwrap();
        std::fs::write(&file2, "# Test 2").unwrap();
        std::fs::write(&file3, "# Test 3").unwrap();

        app.handle_file_drop(vec![file1.clone(), file2.clone(), file3.clone()]);

        // First file should be opened
        assert_eq!(app.current_file, Some(file1));

        // Remaining files in queue
        assert_eq!(app.pending_files.len(), 2);
        assert_eq!(app.pending_files[0], file2);
        assert_eq!(app.pending_files[1], file3);
    }

    #[test]
    fn test_handle_file_drop_directory() {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = TempDir::new().unwrap();
        let dir_path = temp_dir.path();

        // Create multiple markdown files
        std::fs::write(dir_path.join("a.md"), "# A").unwrap();
        std::fs::write(dir_path.join("b.md"), "# B").unwrap();
        std::fs::write(dir_path.join("c.md"), "# C").unwrap();

        app.handle_file_drop(vec![dir_path.to_path_buf()]);

        // First file (alphabetically) should be opened
        assert!(app.current_file.is_some());
        assert_eq!(app.pending_files.len(), 2);
    }

    #[test]
    fn test_handle_file_drop_too_many_files() {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = TempDir::new().unwrap();

        // Create 60 files (over the limit)
        let files: Vec<PathBuf> = (0..60)
            .map(|i| {
                let path = temp_dir.path().join(format!("file{}.md", i));
                std::fs::write(&path, format!("# File {}", i)).unwrap();
                path
            })
            .collect();

        app.handle_file_drop(files);

        // Should show error and not open any files
        assert!(app.error_message.is_some());
        assert!(app.error_message.as_ref().unwrap().contains("Too many files"));
    }

    #[test]
    fn test_pending_files_navigation() {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = TempDir::new().unwrap();

        let file1 = temp_dir.path().join("test1.md");
        let file2 = temp_dir.path().join("test2.md");

        std::fs::write(&file1, "# Test 1").unwrap();
        std::fs::write(&file2, "# Test 2").unwrap();

        // Open first file and queue second
        app.load_file(file1.clone()).unwrap();
        app.pending_files.push_back(file2.clone());

        // Navigate forward should open queued file
        assert!(app.can_navigate_forward());
        app.navigate_forward();
        assert_eq!(app.current_file, Some(file2));
        assert!(app.pending_files.is_empty());
    }
}
```

### Manual Testing Checklist

#### Windows Testing
- [ ] Drop single `.md` file from Explorer
- [ ] Drop multiple files (3-5 files)
- [ ] Drop folder with markdown files
- [ ] Drop mix of `.md` and non-markdown files
- [ ] Drop from network share (`\\server\share`)
- [ ] Drop while app is minimized (should restore window)
- [ ] Drag over window without dropping (should show overlay)
- [ ] Drop invalid file type (should show error)

#### Linux Testing
- [ ] Drop from Nautilus (GNOME)
- [ ] Drop from Dolphin (KDE)
- [ ] Drop from Thunar (XFCE)
- [ ] Drop file with spaces in name
- [ ] Drop file with unicode characters
- [ ] Drop symlink to markdown file

#### macOS Testing
- [ ] Drop from Finder
- [ ] Drop from desktop
- [ ] Drop file with unicode filename
- [ ] Drop alias to markdown file

#### Cross-Platform
- [ ] Test with files in deeply nested directories
- [ ] Test with very long filenames (255 chars)
- [ ] Test with readonly files
- [ ] Test navigation after multi-file drop
- [ ] Test history persistence after drops
- [ ] Test that Write mode auto-saves before drop

---

## Future Enhancements

### Enhancement 1: Recursive Directory Scan
**Description**: Option to recursively scan dropped directories

**Design**:
- Add checkbox in settings: "Include subdirectories when dropping folders"
- Store in `AppConfig` struct
- Limit total files to 100 even with recursion

### Enhancement 2: Image Drop in Write Mode
**Description**: Drop images to insert markdown syntax

**Design**:
```rust
// When in Write mode and image is dropped:
if self.write_enabled && self.is_image_file(&path) {
    // Insert markdown image syntax at cursor position
    let image_path = self.make_relative_path(&path);
    let markdown = format!("![]({})", image_path);
    self.insert_at_cursor(markdown);
}
```

### Enhancement 3: URL Drag-Drop
**Description**: Drag URL from browser, auto-fetch markdown

**Design**:
- Detect if dropped item is URL (via egui event)
- Fetch content via `ureq`
- Convert HTML to markdown if needed
- Security: Require user confirmation before fetching

### Enhancement 4: Drag-Drop Reordering
**Description**: Drag files in pending queue to reorder

**Design**:
- Show queue panel with file list
- Allow drag-drop within list to reorder
- Save queue to disk for session persistence

### Enhancement 5: Open in New Window
**Description**: Hold Ctrl/Cmd while dropping to open in new window

**Design**:
- Detect modifier keys during drop
- Spawn new process: `mdmdview.exe <dropped-file>`
- Platform-specific: Use `std::process::Command`

---

## Alternatives Considered

### Alternative 1: Tabbed Interface
**Description**: Instead of navigation history, use tabs like a browser

**Pros**:
- Visual representation of open files
- Easy switching between files
- Familiar UX pattern

**Cons**:
- Major UI redesign required
- egui tab support is basic
- Would complicate existing navigation history

**Decision**: Rejected. Too invasive for this phase. Could revisit later.

### Alternative 2: Drop on Taskbar/Dock Icon
**Description**: Support dropping files on application icon (Windows taskbar, macOS dock)

**Pros**:
- More discoverable
- Works when app is minimized

**Cons**:
- Platform-specific implementation
- Windows: Requires shell integration
- macOS: Requires Info.plist modifications
- Complex for cross-platform support

**Decision**: Deferred to future enhancement. Focus on in-window drop first.

### Alternative 3: File Watcher for Dropped Directories
**Description**: Continuously watch dropped directories for new files

**Pros**:
- Auto-updates when user adds files to watched directory
- Useful for documentation projects

**Cons**:
- Significant complexity
- Resource usage (file system monitoring)
- Unclear UX for stopping watch

**Decision**: Rejected. Out of scope for drag-drop feature.

---

## Open Questions

1. **Q**: Should we allow dropping non-local files (e.g., HTTP URLs)?
   **A**: No for MVP. Can be future enhancement with security review.

2. **Q**: Should pending queue persist across app restarts?
   **A**: No for MVP. Queue clears on exit. Can be future enhancement.

3. **Q**: What happens if user drops file while another is still loading?
   **A**: Queue it. File loading is fast enough that race conditions unlikely.

4. **Q**: Should we show thumbnail preview for images in markdown?
   **A**: Out of scope for drag-drop feature. App already shows images in rendered view.

5. **Q**: Should directory scan be recursive?
   **A**: No for MVP. Non-recursive only. Can add option later.

---

## Success Metrics

### User-Facing Metrics
- **Adoption**: % of users who use drag-drop vs Fileâ†’Open dialog (if telemetry added)
- **Support Tickets**: Reduction in "how do I open a file" questions

### Technical Metrics
- **Performance**: Drop-to-open latency < 100ms (measured)
- **Reliability**: Zero crashes from drag-drop (tested on 3 platforms)
- **Error Handling**: All edge cases show meaningful error messages

### Validation Criteria
- [ ] All manual tests pass on Windows, Linux, macOS
- [ ] All unit tests pass
- [ ] Code review approved
- [ ] Documentation updated (CLAUDE.md, README.md)
- [ ] No compiler warnings
- [ ] Release build tested

---

## References

- [egui drag-drop documentation](https://docs.rs/egui/latest/egui/struct.DroppedFile.html)
- [eframe viewport options](https://docs.rs/eframe/latest/eframe/struct.NativeOptions.html)
- [mdmdview navigation history design](/plans/2025.01.06%20-%20Add%20Navigation%20History.md)
- [Cross-platform file dialogs (rfd)](https://docs.rs/rfd/latest/rfd/)

---

## Approval

- [ ] Design Reviewed
- [ ] Technical Approach Approved
- [ ] Security Review Complete
- [ ] Ready for Implementation

**Next Steps**: Proceed with Phase 1 implementation (Core Drag-Drop)

# PLN — D2 Conformance Test Suite

Date: 2026.02.21

## Objective

Build a conformance test suite that compares our D2 renderer (`crates/d2`) against the canonical D2 CLI (`d2` from terrastruct/d2). The suite generates SVGs from both renderers for a shared corpus of `.d2` fixtures, then performs structural comparisons to surface layout and routing defects — especially label-over-node overlaps and edges passing through boxes.

This is **not** a pixel-diff suite. We compare structural properties extracted from the SVGs: node positions, edge routes, label positions, and overlap violations. Pixel diffs are fragile across renderers with different styling; structural checks catch the bugs we care about.

## Prerequisites

- Install the D2 CLI: `scoop install main/d2` (or `go install oss.terrastruct.com/d2@latest`)
- Python 3.10+ with `lxml` for SVG parsing: `pip install lxml`
- The `crates/d2` Rust crate (already in the workspace)

## Architecture

```
tests/d2_conformance/
  fixtures/                  ← .d2 input files (shared corpus)
    001-simple-connection.d2
    002-three-chain.d2
    ...
  reference/                 ← canonical SVGs from `d2` CLI (generated, git-tracked)
    001-simple-connection.svg
    ...
  actual/                    ← our SVGs from crates/d2 (generated, .gitignored)
    001-simple-connection.svg
    ...
  analysis/                  ← structural comparison reports (generated, .gitignored)
    001-simple-connection.json
    ...

tools/d2_conformance/
  generate_reference.py      ← runs `d2` CLI on all fixtures → reference/
  generate_actual.py         ← runs our Rust renderer on all fixtures → actual/
  compare.py                 ← structural SVG comparison → analysis/
  report.py                  ← summary report (stdout + markdown)
  d2_svg_parse.py            ← shared SVG parsing utilities (extract rects, paths, text positions)
```

## Fixture Corpus

Create `.d2` files that exercise the specific layout scenarios where we have bugs, plus general coverage. Each fixture should be small (< 20 nodes) and focused on one layout concern.

### Required fixtures (minimum set — implement ALL of these):

**Basic layout:**
```
001-simple-connection.d2        — a -> b (baseline: 2 nodes, 1 edge)
002-three-chain.d2              — a -> b -> c (linear chain)
003-reverse-direction.d2        — direction: right; a -> b -> c
004-bidirectional.d2            — a -> b; b -> a
005-self-loop.d2                — a -> a
```

**Labels on edges:**
```
010-labeled-edge.d2             — a -> b: hello
011-multi-labeled-edges.d2      — a -> b: foo; a -> c: bar; b -> c: baz
012-long-label.d2               — a -> b: "This is a very long edge label"
013-label-horizontal.d2         — direction: right; a -> b: label
```

**Containers:**
```
020-simple-container.d2         — group: { a; b; a -> b }
021-nested-containers.d2        — outer: { inner: { a; b }; c }
022-cross-container-edge.d2     — A: { x }; B: { y }; A.x -> B.y: msg
023-container-to-child.d2       — group: { a; b }; group -> group.a
```

**The specific bugs we're fixing (high priority):**
```
030-architecture-labels.d2      — The first screenshot bug: multi-container architecture
                                  with cross-container labeled edges (HTTPS, verify, sessions, etc.)
                                  See reproduction D2 source below.
031-vertical-edge-through-node.d2 — The second screenshot bug: vertical layout where
                                    edge passes through an intermediate node (CDN case)
032-label-near-box.d2           — Edge label positioned so close to destination node
                                  that text overlaps the box
033-parallel-labeled-edges.d2   — Multiple labeled edges between same pair of containers
                                  (labels should spread, not stack)
```

**Shapes:**
```
040-cylinder-shape.d2           — db.shape: cylinder; app -> db
041-diamond-shape.d2            — decision.shape: diamond; a -> decision -> b
042-mixed-shapes.d2             — circle, diamond, cylinder, rectangle in one diagram
```

**Stress / edge cases:**
```
050-many-nodes-same-rank.d2     — a -> b; a -> c; a -> d; a -> e; a -> f (fan-out)
051-deep-chain.d2               — a -> b -> c -> d -> e -> f -> g (7-deep)
052-disconnected-components.d2  — a -> b; c -> d (two separate subgraphs)
053-wide-fanout-labels.d2       — hub -> spoke1: l1; hub -> spoke2: l2; ... (5+ labeled edges from one node)
```

### Fixture source for bug reproduction (030):

```d2
# 030-architecture-labels.d2
# Reproduces: labels overlapping boxes in multi-container architecture

direction: right

lb: Load Balancer

gw: API Gateway

auth: Auth
redis: Redis
orders: Orders
pg: PostgreSQL

lb -> gw: HTTPS
gw -> auth: verify
auth -> redis: sessions
gw -> orders: route
orders -> pg: CRUD
```

### Fixture source for bug reproduction (031):

```d2
# 031-vertical-edge-through-node.d2
# Reproduces: edge passing through intermediate node in vertical layout

platform: Platform {
  frontend: Frontend {
    app: React App
    cdn: CDN
  }
  backend: Backend {
    gw: API Gateway
    svc: Service
  }
  frontend.app -> frontend.cdn
  frontend.cdn -> backend.gw: fetch
  backend.gw -> backend.svc: route
}
```

## Structural Comparison (compare.py)

Don't do pixel diffs. Instead, parse both SVGs and extract:

1. **Node bounding boxes** — `<rect>`, `<circle>`, `<ellipse>` elements with their (x, y, width, height)
2. **Edge routes** — `<path>` or `<polyline>` elements, extract waypoints
3. **Text positions** — `<text>` elements with (x, y) and content
4. **Labels** — text elements near edges (not inside node bounding boxes)

Then check these **structural invariants** (the things that are broken in our renderer):

### Invariant 1: Labels must not overlap nodes
For each edge label text position, check that the label's bounding box (text position ± estimated text size) does not intersect any node's bounding box (except its own source/destination if the label is *inside* the node by design). **This is the primary bug.**

### Invariant 2: Edges must not pass through non-endpoint nodes
For each edge route, check that no segment of the polyline intersects the bounding box of any node that is not the edge's source or destination. **This is the second bug.**

### Invariant 3: Nodes must not overlap other nodes
No two sibling node bounding boxes should intersect (containers are allowed to contain children).

### Invariant 4: Labels should be near their edge
Each label's position should be within a reasonable distance of its edge route (e.g., within 50px of some point on the route).

### Comparison against reference
For each fixture, also report:
- **Our node positions** vs **reference node positions** (relative ordering, not absolute coords)
- **Our edge routing style** vs **reference** (number of waypoints, general shape)
- **Our label placement** vs **reference** (which side of the edge, relative position along route)

Output: per-fixture JSON with pass/fail for each invariant, plus a summary.

## Rust Test Harness

In addition to the Python tooling, add a `#[cfg(test)]` module in `crates/d2/src/lib.rs` (or a separate `tests/conformance.rs`) that:

1. Reads each `.d2` fixture from `tests/d2_conformance/fixtures/`
2. Renders through our pipeline (`render_d2_to_svg`)
3. Parses the output SVG (use a lightweight XML parser, or just regex for rect/text extraction)
4. Checks the structural invariants above (label-not-overlapping-node, edge-not-through-node)
5. Fails the test with a clear message identifying which invariant failed and for which element

This gives us `cargo test` integration so regressions are caught automatically without running Python.

## Implementation Steps

Use agents to parallelize where possible:

### Step 1: Create fixture files (agent: general-purpose)
Write all the `.d2` fixture files listed above into `tests/d2_conformance/fixtures/`. Ensure the syntax is valid by checking against the D2 language spec. The two bug-reproduction fixtures (030, 031) are the highest priority.

### Step 2: Build Python tooling (agent: general-purpose)
Create the `tools/d2_conformance/` scripts:
- `generate_reference.py` — shell out to `d2 <input>.d2 <output>.svg` for each fixture
- `generate_actual.py` — shell out to a small Rust binary or use `cargo test` output
  - Option A: Write a tiny `examples/d2_render.rs` that reads stdin D2 and writes stdout SVG
  - Option B: Have the Rust test harness dump SVGs to `tests/d2_conformance/actual/`
- `d2_svg_parse.py` — parse SVG to extract rects, paths, text positions. Use `lxml.etree`.
- `compare.py` — implement the 4 structural invariants above. Output per-fixture JSON.
- `report.py` — read all JSON files, print a summary table, exit nonzero if any invariant fails.

### Step 3: Build Rust test harness (agent: general-purpose)
Add `tests/d2_conformance.rs` (integration test) or extend `crates/d2/src/lib.rs` tests:
- Glob `tests/d2_conformance/fixtures/*.d2`
- Render each through `render_d2_to_svg()`
- Parse the SVG output to extract element positions
- Assert invariants 1-4
- On failure, dump the SVG to `tests/d2_conformance/actual/` for debugging

### Step 4: Generate reference baselines
Run `d2` CLI on all fixtures and commit the reference SVGs. These are the ground truth. Steps:
- `python tools/d2_conformance/generate_reference.py`
- Inspect a few reference SVGs visually to confirm they look correct
- `git add tests/d2_conformance/reference/`

### Step 5: First conformance run
Run the full suite and document current pass/fail status:
- `cargo test d2_conformance`
- `python tools/d2_conformance/compare.py`
- `python tools/d2_conformance/report.py`
- Expect failures on invariants 1 and 2 (the known bugs). Document baseline.

## Agent Parallelism

Steps 1 and 2 can run in parallel (fixtures don't depend on Python tools and vice versa).
Step 3 can run in parallel with Step 2 (Rust tests don't depend on Python tools).
Steps 4 and 5 depend on Steps 1-3 completing.

Suggested agent breakdown:
- **Agent A** (general-purpose): Steps 1 + 4 — create fixtures, generate reference SVGs
- **Agent B** (general-purpose): Step 2 — build Python comparison tooling
- **Agent C** (general-purpose): Step 3 — build Rust test harness
- After A, B, C converge: Step 5 — run the suite and document results

## Success Criteria

- All `.d2` fixtures parse and render without errors in both renderers
- Structural invariant checks run and produce clear pass/fail per fixture
- Bug-reproduction fixtures (030, 031) fail invariants 1 and 2 respectively (confirming the bugs are detectable)
- The suite runs in < 30 seconds for the full corpus
- Reference SVGs are committed and stable

## Non-Goals

- Pixel-perfect visual comparison (different renderers, different fonts — not useful)
- Matching D2 CLI's exact node coordinates (our layout algorithm is different)
- Testing D2 language features we don't support (icons, images, markdown labels, tooltips, etc.)
- CI integration (future work, after the bugs are fixed)

## Notes

- The existing Mermaid visual test infrastructure (`tools/mermaid_visual_check.py`, `tools/mermaid_review_pack.py`) uses pixel diffs against `mermaid-cli`. Our D2 approach is deliberately different — structural comparison is more robust for catching the specific layout bugs we have.
- D2 CLI uses Dagre layout by default. Use `d2 --layout elk` for cleaner orthogonal routing if Dagre reference SVGs look messy. ELK is closer to what our Sugiyama-based layout aims for.
- If `d2` CLI is not installed, the Python scripts should skip gracefully with a clear message. The Rust invariant tests should always run (they don't need the reference SVGs).

# Implementation Plan - Table Rendering Final Polish

**Date:** 2025-11-30
**Author:** Claude
**Branch:** feat/table-dividers
**HLD Reference:** `wrk_docs/2025.11.29 - HLD - Table Rendering Review and Recommendations.md`

---

## Overview

This plan implements the fixes and improvements identified in the design review. The work is divided into stages that can be completed independently, with validation checkpoints after each stage.

**Scope:** Fixes 1-4 from the HLD (high and medium priority items)
**Estimated Stages:** 6
**Dependencies:** None - all changes are internal to the table rendering system

---

## Stage 1: Add Horizontal Header Separator

**Goal:** Draw a horizontal line between the header row and body rows for visual clarity.

### Tasks

1.1. **Modify `paint_table_dividers` signature**
   - File: `src/markdown_renderer.rs`
   - Location: Line 3549
   - Change: Add `header_height: f32` parameter
   - Rationale: Need to know where the header ends to draw the separator

1.2. **Draw horizontal separator line**
   - File: `src/markdown_renderer.rs`
   - Location: Inside `paint_table_dividers()`, after vertical dividers, before outer border
   - Change: Add `painter.hline()` call at `rect.top() + header_height`
   - Use same stroke style as vertical separators for consistency

1.3. **Update call site to pass header height**
   - File: `src/markdown_renderer.rs`
   - Location: Line 3447 (call to `paint_table_dividers`)
   - Change: Pass the computed `header_height` variable

1.4. **Handle edge case: no header**
   - Ensure separator is not drawn if `header_height <= 0.0`

### Code Changes

```rust
// Updated signature (line ~3549):
fn paint_table_dividers(
    &self,
    painter: &Painter,
    visuals: &Visuals,
    rect: egui::Rect,
    clip_rect: egui::Rect,
    widths: &[f32],
    header_height: f32,  // NEW
) {
    // ... existing vertical divider code ...

    // NEW: Draw horizontal separator below header
    if header_height > 0.0 {
        let header_y = rect.top() + header_height;
        if header_y > rect.top() && header_y < rect.bottom() {
            painter.hline(rect.x_range(), header_y.round() + 0.5, separator_stroke);
        }
    }

    // ... existing outer border code ...
}

// Updated call site (line ~3447):
self.paint_table_dividers(&painter, &visuals, rect, clip_rect, &widths, header_height);
```

### Validation

- `cargo check` passes
- `cargo clippy` clean
- `cargo test` passes
- Visual test: Open `examples/regressions/table-threat-model.md` and verify horizontal line appears below header row

---

## Stage 2: Capture Header Rect Separately

**Goal:** Track the header's bounding rectangle separately from body cells for accurate table rect calculation.

### Tasks

2.1. **Add header_rect tracking variable**
   - File: `src/markdown_renderer.rs`
   - Location: Line ~3370 (near other rect variables)
   - Change: Add `let mut header_rect: Option<egui::Rect> = None;`

2.2. **Capture header rect in header callback**
   - File: `src/markdown_renderer.rs`
   - Location: Inside header callback, line ~3386
   - Change: Extend `header_rect` instead of `table_rect` for header cells

2.3. **Combine header and body rects after rendering**
   - File: `src/markdown_renderer.rs`
   - Location: After `.body()` closure, before divider painting
   - Change: Union `header_rect` with body-derived rect for final `table_rect`

### Code Changes

```rust
// Add variable (line ~3370):
let mut header_rect: Option<egui::Rect> = None;

// In header callback (line ~3386):
Self::extend_table_rect(&mut header_rect, ui.min_rect());  // Changed from table_rect

// After body closure, compute final table_rect:
let final_table_rect = match (header_rect, table_rect) {
    (Some(h), Some(b)) => Some(h.union(b)),
    (Some(h), None) => Some(h),
    (None, Some(b)) => Some(b),
    (None, None) => None,
};
```

### Validation

- `cargo check` passes
- `cargo test` passes
- Visual test: Table borders should encompass both header and body

---

## Stage 3: Calculate Table Rect from Column Widths

**Goal:** Use the captured column widths to calculate an accurate table width, avoiding reliance on cell content min_rect.

### Tasks

3.1. **Capture body starting position**
   - File: `src/markdown_renderer.rs`
   - Location: Inside body closure, before `heterogeneous_rows`
   - Change: Record `body.max_rect().left()` as the table's left edge

3.2. **Calculate table width from column widths sum**
   - File: `src/markdown_renderer.rs`
   - Location: After body closure
   - Change: `table_width = column_widths.iter().sum()`

3.3. **Construct table rect from calculated dimensions**
   - File: `src/markdown_renderer.rs`
   - Location: Before divider painting
   - Change: Create rect from (left, top) to (left + width, bottom)

3.4. **Fallback to existing behavior if widths unavailable**
   - Keep the union-of-min_rects as a fallback for edge cases

### Code Changes

```rust
// Inside body closure:
let body_left = body.max_rect().left();
let body_top = body.max_rect().top();

// After body closure:
let widths = column_widths.into_inner();
let calculated_width: f32 = widths.iter().sum();

// Construct accurate table rect:
if let Some(header_r) = header_rect {
    let table_left = header_r.left().min(body_left);
    let table_top = header_r.top();
    let table_bottom = table_rect.map(|r| r.bottom()).unwrap_or(body_top);
    let table_right = table_left + calculated_width;

    let accurate_rect = egui::Rect::from_min_max(
        egui::pos2(table_left, table_top),
        egui::pos2(table_right, table_bottom),
    );
    // Use accurate_rect for divider painting
}
```

### Validation

- `cargo check` passes
- `cargo test` passes
- Visual test: Table border should exactly match column boundaries
- Test at different window widths to verify border tracks column resizing

---

## Stage 4: Improve Clip Rect Handling

**Goal:** Capture a more reliable clip rect that covers the entire table region.

### Tasks

4.1. **Capture clip rect from body context**
   - File: `src/markdown_renderer.rs`
   - Location: Inside body closure
   - Change: Use `body.max_rect()` to inform clip region

4.2. **Union header and body clip rects**
   - If header and body have different clip regions (unlikely but possible), union them

4.3. **Ensure dividers respect scroll area bounds**
   - The clip rect should prevent dividers from drawing into scrollbars

### Code Changes

```rust
// Inside body closure, after widths capture:
let body_clip = ui.clip_rect();  // Or derive from scroll area

// After body:
let final_clip = match (header_clip, body_clip) {
    (Some(h), Some(b)) => h.union(b),
    (Some(h), None) => h,
    (None, Some(b)) => b,
    (None, None) => rect,  // Fallback to table rect
};
```

### Validation

- `cargo check` passes
- `cargo test` passes
- Visual test: Scroll a long table and verify dividers don't extend into scrollbar area

---

## Stage 5: Invalidate Persisted Widths on Zoom Change

**Goal:** Clear persisted column widths when font size changes to prevent size mismatch.

### Tasks

5.1. **Add font size tracking to TableMetricEntry**
   - File: `src/table_support/metrics.rs`
   - Location: `TableMetricEntry` struct
   - Change: Add `pub persisted_font_size: Option<f32>` field

5.2. **Check font size in persist_resizable_widths**
   - File: `src/markdown_renderer.rs`
   - Location: `persist_resizable_widths()` function
   - Change: Compare current font size to stored; clear widths if different

5.3. **Store font size when persisting widths**
   - Update `persisted_font_size` after clearing or when first persisting

5.4. **Add unit test for font size change behavior**
   - File: `src/table_support/metrics.rs`
   - Test that changing font size triggers width reset

### Code Changes

```rust
// In metrics.rs, TableMetricEntry:
pub persisted_font_size: Option<f32>,

// In markdown_renderer.rs, persist_resizable_widths():
fn persist_resizable_widths(&self, table_id: u64, specs: &[ColumnSpec], widths: &[f32]) {
    // ... existing checks ...
    let mut metrics = self.table_metrics.borrow_mut();
    let entry = metrics.entry_mut(table_id);

    // NEW: Check for font size change
    let current_font = self.font_sizes.body;
    if let Some(stored_font) = entry.persisted_font_size {
        if (stored_font - current_font).abs() > 0.5 {
            entry.persisted_column_widths.clear();
        }
    }
    entry.persisted_font_size = Some(current_font);

    // ... existing persistence logic ...
}
```

### Validation

- `cargo check` passes
- `cargo test` passes (including new test)
- Manual test: Open a table, resize a column, change zoom (Ctrl++/-), verify column widths reset

---

## Stage 6: Final Cleanup and Documentation

**Goal:** Clean up code, add missing documentation, and update QA guide.

### Tasks

6.1. **Remove unused variables and dead code**
   - Review for any variables made obsolete by the refactoring
   - Run `cargo clippy` and address all warnings

6.2. **Add inline documentation for new code**
   - Document the header separator logic
   - Document the table rect calculation approach
   - Document the zoom/font size invalidation

6.3. **Update QA guide**
   - File: `docs/QA-table-wrap.md`
   - Add test case for header separator visibility
   - Add test case for zoom + persisted width behavior

6.4. **Update journal**
   - Create `wrk_journals/2025.11.30 - JRN - Table Polish Implementation.md`
   - Log completion of each stage

6.5. **Final test suite run**
   - `cargo fmt`
   - `cargo clippy`
   - `cargo test`
   - `cargo build --release`

### Validation

- All lint/format checks pass
- All tests pass
- Release build succeeds
- QA guide reflects new behavior

---

## Code Changes Summary

| Stage | File | Change Type | Lines (est.) |
|-------|------|-------------|--------------|
| 1 | `markdown_renderer.rs` | Modify | +10 |
| 2 | `markdown_renderer.rs` | Modify | +15 |
| 3 | `markdown_renderer.rs` | Modify | +20 |
| 4 | `markdown_renderer.rs` | Modify | +10 |
| 5 | `metrics.rs`, `markdown_renderer.rs` | Modify | +20 |
| 6 | `QA-table-wrap.md`, journal | Add/Modify | +30 |

**Total estimated changes:** ~105 lines added/modified

---

## Rollback Plan

Each stage is independent and can be reverted individually:

1. **Stage 1:** Remove `header_height` parameter and `hline` call
2. **Stage 2:** Revert to single `table_rect` variable
3. **Stage 3:** Revert to union-of-min_rects calculation
4. **Stage 4:** Revert to first-cell clip rect capture
5. **Stage 5:** Remove font size tracking field and checks
6. **Stage 6:** N/A (documentation only)

If multiple stages need rollback, use `git revert` on the stage commits.

---

## Dependencies Between Stages

```
Stage 1 ──┐
          ├──► Stage 6 (cleanup)
Stage 2 ──┤
          │
Stage 3 ──┤ (depends on Stage 2 for header_rect)
          │
Stage 4 ──┤
          │
Stage 5 ──┘
```

**Recommended order:** 1 → 2 → 3 → 4 → 5 → 6

Stages 1, 4, and 5 are independent and could be done in parallel if needed.

---

## Success Criteria

1. **Functional:**
   - Header separator line visible in all tables
   - Table borders align exactly with column boundaries
   - Dividers do not leak into scrollbars
   - Persisted widths reset after zoom change

2. **Quality:**
   - Zero compiler warnings
   - Zero Clippy warnings
   - All tests pass
   - Code is documented

3. **Performance:**
   - No measurable regression in table rendering speed
   - Cache hit rate unchanged

---

## Post-Implementation

After all stages complete:

1. Create PR from `feat/table-dividers` to `master`
2. Include before/after screenshots in PR description
3. Reference this plan and the HLD in the PR
4. Request review focusing on visual correctness
5. Merge after approval

---

## References

- HLD: `wrk_docs/2025.11.29 - HLD - Table Rendering Review and Recommendations.md`
- Previous HLD: `wrk_docs/2025.11.28 - HLD - Table Rendering Bug Fixes.md`
- QA Guide: `docs/QA-table-wrap.md`
- Test files: `examples/regressions/table-wrap.md`, `examples/regressions/table-threat-model.md`

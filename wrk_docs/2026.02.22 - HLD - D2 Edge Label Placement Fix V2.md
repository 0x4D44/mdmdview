# HLD — D2 Edge Label Placement Fix V2

Date: 2026.02.22
Revision: V2 — second review pass

## Change Log

- **V1 → V2:** Six additional issues found during second review pass (see "V2 Review" section below). All are moderate or minor — no new critical issues.

## Scope

This design addresses **bug 1 only**: edge labels overlapping node boxes. It does **not** address bug 2 (edges routing through intermediate nodes), which is a separate edge-routing problem requiring a different fix.

## Problem Statement

Edge labels in our D2 renderer frequently overlap node boxes. Two root causes:

1. **Label position is computed from the enter segment only.** The current `compute_label_position()` (edge_routing.rs:716–744) uses the midpoint of the *last segment before the destination*, with a fixed 10px perpendicular offset. For multi-segment routes, the enter segment is typically short (it's the stub from the channel into the destination port), so the label lands right on top of or inside the destination node.

2. **Label dimensions are not considered during placement.** The routing code emits a bare `Point` for the label center, but never checks whether the label's bounding box (text width × height) will intersect any node. The SVG renderer estimates label size at render time (svg_render.rs:623–625) but by then it's too late to move anything.

### Visual evidence

**Screenshot 1** (horizontal architecture): Labels "HTTPS", "verify", "sessions", "route", "CRUD" all overlap their destination boxes. The labels are placed on the short enter stub that goes directly into the box.

**Screenshot 2** (vertical platform): The "route" label between API Gateway and Service overlaps the API Gateway box.

### How D2 official handles this

D2's Dagre layout places labels at a **percentage along the total route** (default 50% = midpoint). The `lib/label` package computes position by walking the polyline from start to the target percentage of total arc length, then offsets perpendicular. Labels end up in the inter-rank gap where there is space, not near either endpoint.

## Issues Found in Original Design (2026.02.21)

### Issue 1 (Critical): Wrong dimension for perpendicular offset on vertical segments

The original design uses `label_height / 2 + padding` for the perpendicular offset on **all** segments. This is only correct for horizontal segments (where perpendicular = vertical). For vertical segments, the perpendicular direction is horizontal, so the offset must use `label_width / 2 + padding`.

**Concrete example:** Label "HTTPS" at font_size 14:
- `label_height = 14 * 1.4 = 19.6px`, `label_width = 5 * 14 * 0.55 = 38.5px`
- Original offset for vertical segment: `19.6/2 + 4 = 13.8px`
- Label right edge at: `route_x - 13.8 + 38.5/2 = route_x + 5.45px` — **overlaps the route line**

**Fix:** `compute_label_position` accepts both `label_width` and `label_height`, uses `label_height` for horizontal segments and `label_width` for vertical segments.

### Issue 2 (Critical): `font_size` not available via `RenderOptions`

`RenderOptions` only has `dark_mode` and `font_family`. The call site in `layout.rs` already derives `font_size` from the theme.

**Fix:** Pass `font_size` and `font_family` directly from `layout()` to `route_all_edges()`, since both are already in scope there.

### Issue 3 (Moderate): Self-loop labels missing `label_width`/`label_height`

Self-loops (edge_routing.rs:70–86) have their own label positioning code and won't get `label_width`/`label_height` set under the original design.

**Fix:** Also measure and store dimensions for self-loop labels.

### Issue 4 (Moderate): Nudge algorithm underspecified

**Fix:** See "Change 3" for the full center-out candidate search specification.

### Issue 5 (Moderate): Endpoint nodes should not be unconditionally excluded from nudge

**Fix:** Check all nodes including endpoints, but skip the nudge entirely for 2-point routes (no alternative positions available).

### Issue 6 (Minor): `rects_intersect` utility not defined

**Fix:** Add `Rect::intersects` to `geo.rs`.

### Issue 7 (Minor): Measurement height mismatch

`text.rs` uses 1.4× line height; `svg_render.rs` uses 1.2×. After this change both use stored dimensions from `measure_and_wrap_label`, resolving the mismatch. Halo will be ~2.8px taller at font_size 14 — negligible.

## V2 Review: Additional Issues

### Issue 8 (Moderate): `?` operator in `find_best_label_position` causes premature abort

V1's nudge function uses:
```rust
let pos = compute_label_position(route, pct, label_width, label_height)?;
```

The `?` causes the entire function to return `None` if any single candidate percentage fails, skipping all remaining candidates. `compute_label_position` returns `None` only for degenerate routes (< 2 points), which the caller already guards against. But this is fragile — if the function ever returns `None` for other reasons, the nudge silently gives up.

**Fix:** Use `match`/`continue` instead of `?`:
```rust
let pos = match compute_label_position(route, pct, label_width, label_height) {
    Some(p) => p,
    None => continue,
};
```

### Issue 9 (Moderate): Container nodes produce false positives in nudge overlap check

Container nodes have bounding boxes that encompass all their children. An edge label positioned between two children (inside the container's gap) would be falsely flagged as overlapping the container, triggering unnecessary nudging.

**Example:** In `services: { gw; auth; gw -> auth: verify }`, the "verify" label sits in the gap between `gw` and `auth`, which is inside the `services` container rect. The nudge would detect overlap with `services` and try to move the label — even though visually it's in clear space.

**Fix:** Only check **leaf nodes** (non-containers) in the nudge pass. Container background fills are visually distinct from node fills, so a label "inside" a container but between children is acceptable:
```rust
let node_rects: Vec<(NodeIndex, Rect)> = graph.objects.iter()
    .filter(|&&idx| idx != graph.root)
    .filter(|&&idx| !graph.graph[idx].is_container)  // NEW: skip containers
    .filter_map(|&idx| graph.graph[idx].box_.map(|r| (idx, r)))
    .collect();
```

### Issue 10 (Moderate): Borrow checker prevents iterating edges while mutating label position

The nudge iterates `&graph.edges` (borrows `graph` via the `edges` field) while also writing `graph.graph[eidx].label_position` (requires mutable borrow). This won't compile — Rust sees the shared borrow of `graph` from the iterator conflicting with the mutable borrow for the write.

**Fix:** Clone the edge indices before iterating (same pattern used at the top of `route_all_edges`):
```rust
let edge_indices: Vec<EdgeIndex> = graph.edges.clone();
for &eidx in &edge_indices {
    // graph is now free for mutable access
    graph.graph[eidx].label_position = Some(new_pos);
}
```

### Issue 11 (Minor): Halo padding constant duplicated

The nudge uses `pad = 3.0` (matching `svg_render.rs`'s halo padding). If the SVG renderer's padding changes, the nudge would compute the wrong overlap bounds.

**Fix:** Define a shared constant:
```rust
// In edge_routing.rs (or a shared location):
/// Padding added around edge label text for the background halo (pixels).
/// Must match the value used in svg_render.rs for label halo rects.
pub(crate) const LABEL_HALO_PADDING: f64 = 3.0;
```

Reference from both `edge_routing.rs` (nudge) and `svg_render.rs` (halo rect).

### Issue 12 (Minor): Function name mismatch

V1's nudge pseudocode calls `min_separation(&lr, nr)` but the `geo.rs` addition was named `min_rect_separation`. Inconsistent.

**Fix:** Use `min_rect_separation` consistently, or make it a method on Rect: `lr.min_separation(nr)`.

### Known Limitation: Label-vs-label overlap not addressed

Two edge labels could overlap each other (e.g., parallel edges in the same gap with similar route lengths). This design only handles label-vs-node overlap. Label-vs-label overlap is mitigated by channel spreading (parallel edges get different routes and thus different midpoints), but is not explicitly detected or fixed. The conformance test suite will surface cases where this matters, and it can be addressed as a follow-up if needed.

## Revised Design

### Change 1: Percentage-along-route placement

Replace the enter-segment heuristic with a **percentage-of-total-arc-length** approach.

```rust
/// Padding between label halo edge and route line (pixels).
const LABEL_PADDING: f64 = 4.0;

/// Compute label position at a percentage along the total route arc length.
/// Returns the label center point, offset perpendicular to the segment.
/// Uses `label_height` for horizontal segment offset, `label_width` for vertical.
fn compute_label_position(
    route: &[Point],
    percentage: f64,
    label_width: f64,
    label_height: f64,
) -> Option<Point> {
    if route.len() < 2 {
        return None;
    }

    // 1. Compute segment lengths and total.
    let mut seg_lengths: Vec<f64> = Vec::with_capacity(route.len() - 1);
    let mut total = 0.0;
    for i in 0..route.len() - 1 {
        let len = route[i].distance_to(&route[i + 1]);
        seg_lengths.push(len);
        total += len;
    }

    if total < 1e-6 {
        return Some(route[0]);
    }

    // 2. Walk to target distance.
    let target = total * percentage.clamp(0.0, 1.0);
    let mut accumulated = 0.0;

    for (i, &seg_len) in seg_lengths.iter().enumerate() {
        if accumulated + seg_len >= target || i == seg_lengths.len() - 1 {
            let t = if seg_len > 1e-6 {
                (target - accumulated) / seg_len
            } else {
                0.5
            };
            let a = route[i];
            let b = route[i + 1];
            let px = a.x + (b.x - a.x) * t;
            let py = a.y + (b.y - a.y) * t;

            // 3. Axis-aware perpendicular offset.
            let dx = b.x - a.x;
            let dy = b.y - a.y;

            return if dx.abs() > dy.abs() {
                // Horizontal segment → offset upward using label height
                let offset = (label_height / 2.0) + LABEL_PADDING;
                Some(Point::new(px, py - offset))
            } else {
                // Vertical segment → offset leftward using label width
                let offset = (label_width / 2.0) + LABEL_PADDING;
                Some(Point::new(px - offset, py))
            };
        }
        accumulated += seg_len;
    }

    None
}
```

**Default percentage: 0.5** (route midpoint). For a typical 4-point orthogonal route (port → bend → bend → port), the midpoint falls on the channel segment — the longest run in the inter-rank gap where no nodes live. For 2-point routes, the midpoint is equidistant from both nodes.

### Change 2: Label bounding box stored on edge data

Add label dimensions to `D2EdgeData`:

```rust
// In graph.rs
pub struct D2EdgeData {
    // ... existing fields ...
    pub label_position: Option<Point>,
    pub label_width: f64,     // NEW
    pub label_height: f64,    // NEW
}
```

Initialize to `0.0` at the construction site in `compiler.rs` (line 295).

Compute during routing using per-edge font size:

```rust
let font_size_for_edge = graph.graph[eidx].style.font_size.unwrap_or(default_font_size);
let m = crate::text::measure_and_wrap_label(label_text, font_size_for_edge, font_family);
```

Note: `measure_and_wrap_label` ignores `font_family` internally (parameter is `_font_family`) — the char width is always `font_size * CHAR_WIDTH_FACTOR (0.55)`. This is acceptable; the heuristic just needs to be consistent between routing and rendering.

### Change 3: Post-placement overlap nudge

After all label positions are computed, run a nudge pass against **leaf nodes only** (skip containers).

```rust
/// Padding added around edge label text for the background halo (pixels).
/// Shared between edge_routing.rs (nudge) and svg_render.rs (halo rect).
pub(crate) const LABEL_HALO_PADDING: f64 = 3.0;

fn nudge_overlapping_labels(graph: &mut D2Graph) {
    // Collect leaf node rects only (containers produce false positives).
    let node_rects: Vec<(NodeIndex, Rect)> = graph.objects.iter()
        .filter(|&&idx| idx != graph.root)
        .filter(|&&idx| !graph.graph[idx].is_container)
        .filter_map(|&idx| graph.graph[idx].box_.map(|r| (idx, r)))
        .collect();

    // Clone edge indices to avoid borrow conflict with graph mutation.
    let edge_indices: Vec<EdgeIndex> = graph.edges.clone();

    for &eidx in &edge_indices {
        let pos = match graph.graph[eidx].label_position {
            Some(p) => p,
            None => continue,
        };
        let lw = graph.graph[eidx].label_width;
        let lh = graph.graph[eidx].label_height;
        if lw < 1.0 || lh < 1.0 { continue; }

        let route = graph.graph[eidx].route.clone();

        // For 2-point routes, there's no alternative position — skip nudge.
        if route.len() <= 2 { continue; }

        let label_rect = Rect::new(
            pos.x - lw / 2.0 - LABEL_HALO_PADDING,
            pos.y - lh / 2.0 - LABEL_HALO_PADDING,
            lw + LABEL_HALO_PADDING * 2.0,
            lh + LABEL_HALO_PADDING * 2.0,
        );

        // Check overlap against leaf nodes (including edge endpoints).
        let has_overlap = node_rects.iter().any(|(_, nr)| label_rect.intersects(nr));
        if !has_overlap { continue; }

        // Search for a clear position using center-out candidate percentages.
        if let Some(new_pos) = find_best_label_position(
            &route, lw, lh, &node_rects,
        ) {
            graph.graph[eidx].label_position = Some(new_pos);
        }
        // else: keep original (no improvement found — degrade gracefully)
    }
}

fn find_best_label_position(
    route: &[Point],
    label_width: f64,
    label_height: f64,
    node_rects: &[(NodeIndex, Rect)],
) -> Option<Point> {
    // Center-out search: prefer positions near the route midpoint.
    let candidates = [0.5, 0.4, 0.6, 0.3, 0.7, 0.2, 0.8, 0.15, 0.85];

    let mut best_pos: Option<Point> = None;
    let mut best_clearance: f64 = f64::NEG_INFINITY;

    for &pct in &candidates {
        let pos = match compute_label_position(route, pct, label_width, label_height) {
            Some(p) => p,
            None => continue, // skip this candidate, try others
        };

        let lr = Rect::new(
            pos.x - label_width / 2.0 - LABEL_HALO_PADDING,
            pos.y - label_height / 2.0 - LABEL_HALO_PADDING,
            label_width + LABEL_HALO_PADDING * 2.0,
            label_height + LABEL_HALO_PADDING * 2.0,
        );

        let overlaps = node_rects.iter().any(|(_, nr)| lr.intersects(nr));
        if !overlaps {
            return Some(pos); // First non-overlapping position wins
        }

        // Track clearance for fallback (least-bad position).
        let min_clearance = node_rects.iter()
            .map(|(_, nr)| min_rect_separation(&lr, nr))
            .fold(f64::INFINITY, f64::min);
        if min_clearance > best_clearance {
            best_clearance = min_clearance;
            best_pos = Some(pos);
        }
    }

    best_pos
}
```

**Design rationale:**
- Center-out search order (0.5, 0.4, 0.6, ...) prefers positions near the route midpoint, which looks most natural.
- 9 fixed candidates avoids continuous sliding complexity and segment boundary handling.
- 9 × arc-length walk per overlapping edge is cheap (~36 distance calculations per edge).
- `match`/`continue` instead of `?` ensures one bad candidate doesn't abort the search.
- If no candidate is overlap-free, returns the one with best clearance (graceful degradation).
- 2-point routes are skipped (only one possible segment, no room to slide).
- Leaf nodes only — containers are excluded to avoid false positives.
- Edge indices cloned before iteration to satisfy the borrow checker.

### Change 4: Perpendicular offset scales with label dimensions (axis-aware)

Integrated into `compute_label_position` above. Replace `LABEL_OFFSET = 10.0` with:
- Horizontal segment: `(label_height / 2) + LABEL_PADDING` → vertical clearance
- Vertical segment: `(label_width / 2) + LABEL_PADDING` → horizontal clearance

## Detailed File Changes

### `crates/d2/src/geo.rs`

Add `intersects` and `min_separation` to `Rect`:

```rust
impl Rect {
    // ... existing methods ...

    /// Test whether two rectangles overlap (strict intersection, not touching).
    pub fn intersects(&self, other: &Rect) -> bool {
        self.x < other.right()
            && self.right() > other.x
            && self.y < other.bottom()
            && self.bottom() > other.y
    }

    /// Minimum axis-aligned separation (negative = overlapping depth).
    pub fn min_separation(&self, other: &Rect) -> f64 {
        let sep_x = if self.right() <= other.x {
            other.x - self.right()
        } else if other.right() <= self.x {
            self.x - other.right()
        } else {
            -(self.right().min(other.right()) - self.x.max(other.x))
        };

        let sep_y = if self.bottom() <= other.y {
            other.y - self.bottom()
        } else if other.bottom() <= self.y {
            self.y - other.bottom()
        } else {
            -(self.bottom().min(other.bottom()) - self.y.max(other.y))
        };

        // Separated on either axis = positive; overlapping on both = negative.
        if sep_x >= 0.0 || sep_y >= 0.0 {
            sep_x.max(sep_y)
        } else {
            sep_x.max(sep_y)
        }
    }
}
```

### `crates/d2/src/graph.rs`

Add two fields to `D2EdgeData`:

```rust
pub struct D2EdgeData {
    pub label: Option<String>,
    pub src_arrow: ArrowheadType,
    pub dst_arrow: ArrowheadType,
    pub style: Style,
    pub route_type: RouteType,
    pub route: Vec<Point>,
    pub label_position: Option<Point>,
    pub label_width: f64,     // NEW
    pub label_height: f64,    // NEW
}
```

### `crates/d2/src/compiler.rs`

Update the single D2EdgeData construction site (~line 295):

```rust
let edge_data = D2EdgeData {
    label,
    src_arrow,
    dst_arrow,
    style: Style::default(),
    route_type: RouteType::Bezier,
    route: Vec::new(),
    label_position: None,
    label_width: 0.0,     // NEW
    label_height: 0.0,    // NEW
};
```

### `crates/d2/src/edge_routing.rs`

1. **Replace constants:**
   - Remove `LABEL_OFFSET`
   - Add `LABEL_PADDING = 4.0`
   - Add `LABEL_HALO_PADDING = 3.0` (pub(crate))

2. **Change `route_all_edges` signature:**
   ```rust
   pub fn route_all_edges(graph: &mut D2Graph, font_size: f64, font_family: &str) {
       let edge_indices: Vec<EdgeIndex> = graph.edges.clone();
       let mut non_self_loops: Vec<EdgeIndex> = Vec::new();

       for &eidx in &edge_indices {
           // ... existing self-loop check ...
           if src_idx == dst_idx {
               // ... existing self-loop route ...
               // NEW: measure and store label dimensions for self-loops
               if let Some(ref label_text) = graph.graph[eidx].label {
                   let fs = graph.graph[eidx].style.font_size.unwrap_or(font_size);
                   let m = crate::text::measure_and_wrap_label(label_text, fs, font_family);
                   graph.graph[eidx].label_width = m.width;
                   graph.graph[eidx].label_height = m.height;
               }
           } else {
               non_self_loops.push(eidx);
           }
       }

       route_orthogonal_edges(graph, &non_self_loops, font_size, font_family);
       nudge_overlapping_labels(graph);
   }
   ```

3. **Replace `compute_label_position`** with the arc-length-percentage version (see Change 1).

4. **Update `route_orthogonal_edges`** to accept and use font parameters:
   ```rust
   fn route_orthogonal_edges(
       graph: &mut D2Graph,
       edge_indices: &[EdgeIndex],
       font_size: f64,
       font_family: &str,
   ) {
       // ... existing classification and allocation ...

       for ec in &classified {
           let route = build_route(ec, &src_rect, &dst_rect);

           let (label_pos, label_w, label_h) = if let Some(ref text) = graph.graph[ec.edge_idx].label {
               let fs = graph.graph[ec.edge_idx].style.font_size.unwrap_or(font_size);
               let m = crate::text::measure_and_wrap_label(text, fs, font_family);
               let pos = compute_label_position(&route, 0.5, m.width, m.height);
               (pos, m.width, m.height)
           } else {
               (None, 0.0, 0.0)
           };

           graph.graph[ec.edge_idx].route = route;
           graph.graph[ec.edge_idx].route_type = RouteType::Orthogonal;
           graph.graph[ec.edge_idx].label_position = label_pos;
           graph.graph[ec.edge_idx].label_width = label_w;
           graph.graph[ec.edge_idx].label_height = label_h;
       }
   }
   ```

5. **Add `nudge_overlapping_labels` and `find_best_label_position`** (see Change 3).

### `crates/d2/src/svg_render.rs`

1. **Import and use shared constant:**
   ```rust
   use crate::edge_routing::LABEL_HALO_PADDING;
   ```

2. **Update edge label rendering** (~line 622) to use stored dimensions:
   ```rust
   // Replace:
   let char_width = font_size * 0.55;
   let label_width = label.chars().count() as f64 * char_width;
   let label_height = font_size * 1.2;
   let pad = 3.0;

   // With:
   let label_width = if edge.label_width > 0.0 {
       edge.label_width
   } else {
       label.chars().count() as f64 * font_size * 0.55
   };
   let label_height = if edge.label_height > 0.0 {
       edge.label_height
   } else {
       font_size * 1.2
   };
   let pad = LABEL_HALO_PADDING;
   ```

### `crates/d2/src/layout.rs`

Update the `route_all_edges` call (line 53):

```rust
// Before:
edge_routing::route_all_edges(graph);

// After:
edge_routing::route_all_edges(graph, font_size, font_family);
```

Both `font_size` and `font_family` are already in scope in `layout()`.

## Test Plan

### Existing tests to update

Structural invariants should still hold. Specific coordinate values may shift:

- `test_label_between_nodes` — label y between a.bottom and b.top ✓
- `test_label_between_nodes_horizontal` — label x between a.right and b.left ✓
- `test_ortho_label_horizontal` — offset direction same, magnitude changes (dynamic vs fixed 10px)
- `test_ortho_label_vertical` — offset direction same, magnitude changes
- `test_ortho_labels_spread` — distance invariant holds (different routes → different midpoints)

### New tests

1. **`test_rect_intersects`** — Unit tests for the new `Rect::intersects` method. Cover: overlapping, touching (edge cases), separated, nested.

2. **`test_rect_min_separation`** — Unit tests for `Rect::min_separation`. Cover: positive separation, zero (touching), negative (overlapping).

3. **`test_label_at_route_midpoint`** — For a 4-point route, verify the label is at 50% of total arc length (not at the enter segment midpoint).

4. **`test_label_offset_horizontal_segment`** — On a horizontal segment, assert label center is offset upward by at least `label_height / 2` from the route line.

5. **`test_label_offset_vertical_segment`** — On a vertical segment, assert label center is offset leftward by at least `label_width / 2` from the route line.

6. **`test_label_no_node_overlap`** — The primary bug reproduction test. Architecture diagram:
   ```d2
   direction: right
   lb: Load Balancer
   gw: API Gateway
   auth: Auth
   redis: Redis
   orders: Orders
   pg: PostgreSQL
   lb -> gw: HTTPS
   gw -> auth: verify
   auth -> redis: sessions
   gw -> orders: route
   orders -> pg: CRUD
   ```
   For every labeled edge, compute `label_rect` (with halo padding) and assert it doesn't intersect any leaf node's `box_`.

7. **`test_label_dimensions_stored`** — After routing, verify `label_width > 0` and `label_height > 0` for every labeled edge.

8. **`test_self_loop_label_dimensions`** — Self-loop edge should have `label_width > 0` and `label_height > 0` after routing.

9. **`test_nudge_finds_clear_position`** — Construct a layout where 50% placement overlaps a node. Verify the final label position doesn't overlap (nudge found an alternative).

10. **`test_parallel_labels_no_overlap`** — Two labeled edges sharing a gap should have non-overlapping label rects.

## Known Limitations

1. **Label-vs-label overlap:** Not detected or fixed. Mitigated by channel spreading giving parallel edges different routes (and thus different midpoints). Can be addressed as a follow-up if the conformance tests surface real cases.

2. **Container title overlap:** A label inside a container could overlap the container's title text at the top-left. Detecting this requires container title dimension tracking, which is not in scope.

3. **2-point route labels:** When two nodes are close together (small gap), the 50% midpoint label may overlap both endpoints. The nudge skips 2-point routes since there's no alternative position on the route. The fix for this case is to increase inter-node spacing, which is a layout concern (separate design).

## Risk Assessment

**Low risk:** Changes confined to label position, width, and height on `D2EdgeData`. Node positions, edge waypoints, and SVG structure are unaffected.

**Regression risk:** Existing tests asserting specific coordinates will need updated expected values. Structural invariants (label between nodes, label on correct side of line) should hold.

**Performance:** Arc-length walk: O(P) per edge, P typically 2–4. Nudge: O(E × 9 × N) for overlapping edges only. Negligible for diagrams < 1000 elements.

## Implementation Order

1. Add `Rect::intersects` and `Rect::min_separation` to `geo.rs` + unit tests
2. Add `label_width` / `label_height` to `D2EdgeData`, update compiler.rs construction
3. Add `LABEL_HALO_PADDING` constant to `edge_routing.rs`, reference from `svg_render.rs`
4. Change `route_all_edges` signature to `(graph, font_size, font_family)`, update `layout.rs` call site
5. Replace `compute_label_position` with arc-length-percentage version (fixes primary bug)
6. Update self-loop handling to measure and store label dimensions
7. Update SVG renderer to use stored dimensions
8. Add `nudge_overlapping_labels` + `find_best_label_position`
9. Update existing tests, add new tests
10. Visual verification against screenshot scenarios

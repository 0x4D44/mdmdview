# HLD: Light/Dark Mode Toggle

**Date:** 2026-02-09
**Status:** Draft
**Author:** Arthur + Claude

## 1. Problem Statement

mdmdview is currently dark-mode only. Users (specifically lawyers) need a light mode option. The application has ~95 hardcoded `Color32` values tuned for dark backgrounds, spread across 4 source files. We need a clean, maintainable way to support both themes with a runtime toggle.

## 2. Requirements

1. **Toggle**: A visible control in the status bar to switch between light and dark mode
2. **Persistence**: Theme preference survives app restart
3. **Complete**: All visual elements must look correct in both modes (links, code blocks, blockquotes, inline code, mermaid boxes, syntax highlighting)
4. **Default**: New installations default to dark mode (preserve current behavior)
5. **Minimal disruption**: Don't break existing tests (222 `MarkdownRenderer::new()` call sites)

## 3. Scope Analysis

### 3.1 Color Audit Summary

**Theme-critical** (~30 hardcoded color sites that need light/dark variants):

| Category | File | Lines | Colors (Dark) |
|----------|------|-------|---------------|
| External links | markdown_renderer.rs | 743, 2905 | `(120, 190, 255)` |
| Internal links | markdown_renderer.rs | 745, 2907 | `LIGHT_BLUE` |
| Inline code bg | markdown_renderer.rs | 872, 2844 | `(30, 30, 30)` |
| Inline code fg | markdown_renderer.rs | 872, 2844 | `(180, 255, 180)` |
| Blockquote bg | markdown_renderer.rs | 2643 | `(24, 24, 24)` |
| Blockquote border | markdown_renderer.rs | 2647 | `(40, 40, 40)` |
| Blockquote text | markdown_renderer.rs | 2658 | `WHITE` |
| Blockquote bar | markdown_renderer.rs | 2669 | `(255, 103, 25)` |
| Code block bg | markdown_renderer.rs | 2972, 3902 | `(30, 30, 30)` / `(25, 25, 25)` |
| Code block border | markdown_renderer.rs | 2973, 3903 | `(60, 60, 60)` |
| Code label | markdown_renderer.rs | 2964, 3911 | `(140, 140, 140)` / `(150, 150, 150)` |
| Code fallback text | markdown_renderer.rs | 3972 | `(220, 220, 220)` |
| Syntect theme | markdown_renderer.rs | 5778 | `"base16-ocean.dark"` |
| Mermaid box bg | mermaid_renderer.rs | 769,795,822,897,962,988 | `(25, 25, 25)` |
| Mermaid box border | mermaid_renderer.rs | 770,796,823,898,963,989 | `(60, 60, 60)` |
| Mermaid title text | mermaid_renderer.rs | 777,803,830,903,968,1002 | `(200, 160, 80)` |
| Mermaid body text | mermaid_renderer.rs | 786,812,839,914,921,977 | `(180, 180, 180)` |
| Status bar loading | app.rs | 2131 | `(120, 200, 255)` |
| Status bar queue | app.rs | 2140 | `(100, 150, 255)` |
| Status bar hint | app.rs | 2145 | `GRAY` |

**Already theme-aware** (no changes needed):
- Search highlighting: uses `visuals.selection.bg_fill` / `visuals.selection.stroke.color`
- Table dividers: uses `visuals.widgets.noninteractive.bg_stroke.color`
- List markers: uses `ui.visuals().text_color()`
- Menu text: already checks `dark_mode` (app.rs:2032-2036)
- `configure_egui_style()`: already conditionally applies true-black only in dark mode (main.rs:451-456)

**Theme-independent** (no changes needed):
- Emoji fallback colors in `emoji_assets.rs` (intrinsic to emoji, e.g., red heart = red)
- Emoji fallback colors in `markdown_renderer.rs` lines 3624-3707 (same reason)
- Error label `Color32::RED` (app.rs:2483) - works on both backgrounds
- Drag overlay `from_black_alpha(180)` (app.rs:2266) - dark overlay works on both

**Status bar accent colors** (lines 2131, 2140, 2145): The blues `(120, 200, 255)` and `(100, 150, 255)` have good contrast on both light and dark backgrounds. `GRAY` may need adjustment on light - TBD during visual testing.

### 3.2 Syntax Highlighting Complication

Syntax highlighting via syntect happens at **parse time**, not render time. The highlighted tokens (with colors) are baked into `MarkdownElement::CodeBlock.highlighted`. This means:

- Changing the syntect theme requires re-parsing the entire document
- This is a fast in-memory operation (no file I/O), so acceptable
- The toggle handler must trigger a re-parse after switching themes

### 3.3 Test Impact

- 222 calls to `MarkdownRenderer::new()` across tests
- Solution: keep `new()` signature unchanged (defaults to dark mode). Add `set_dark_mode()` setter.
- Test `AppSettings` construction sites need `dark_mode: true` field added

## 4. Design

### 4.1 Architecture Overview

```
                          +-----------------+
                          |   ThemeColors   |  src/theme.rs (NEW)
                          |  DARK / LIGHT   |
                          |  ::current(bool)|
                          +---------+-------+
                                    |
                    Used by all rendering code
                                    |
          +-------------------------+-------------------------+
          |                         |                         |
 markdown_renderer.rs      mermaid_renderer.rs          app.rs
 (links, code, quotes)    (error/info boxes)       (status bar)
          |
          +-- highlight_code() uses self.dark_mode
              to select syntect theme
```

```
 Persistence:                Toggle Flow:
 +-----------+
 |AppSettings|  <-- load on startup     User clicks [Dark/Light]
 | dark_mode |  --> save on toggle            |
 +-----------+                          toggle_theme()
      |                                       |
      +-- settings.txt (file)           1. Flip settings.dark_mode
      +-- Registry (Windows)            2. ctx.set_visuals(dark/light)
                                        3. Apply true-black if dark
                                        4. renderer.set_dark_mode()
                                        5. Re-parse content (syntax hl)
                                        6. Save settings to disk
```

### 4.2 Component: ThemeColors (`src/theme.rs`)

New module providing a centralized color palette struct.

```rust
use egui::Color32;

/// All theme-dependent colors, centralized for easy maintenance.
/// Use `ThemeColors::current(dark_mode)` to get the active palette.
#[derive(Clone, Copy, Debug)]
pub struct ThemeColors {
    // Links
    pub link: Color32,
    pub link_internal: Color32,

    // Code blocks (fenced)
    pub code_bg: Color32,
    pub code_border: Color32,
    pub code_label: Color32,
    pub code_fallback_text: Color32,

    // Inline code
    pub inline_code_bg: Color32,
    pub inline_code_fg: Color32,

    // Blockquotes
    pub blockquote_bg: Color32,
    pub blockquote_border: Color32,
    pub blockquote_text: Color32,
    pub blockquote_bar: Color32,

    // Info/error boxes (mermaid errors, etc.)
    pub box_bg: Color32,
    pub box_border: Color32,
    pub box_title: Color32,
    pub box_body: Color32,

    // Status bar accents
    pub status_loading: Color32,
    pub status_queue: Color32,
    pub status_hint: Color32,
}

impl ThemeColors {
    pub const DARK: Self = Self {
        link:               Color32::from_rgb(120, 190, 255),
        link_internal:      Color32::from_rgb(135, 206, 250), // LIGHT_BLUE equivalent
        code_bg:            Color32::from_rgb(30, 30, 30),
        code_border:        Color32::from_rgb(60, 60, 60),
        code_label:         Color32::from_rgb(140, 140, 140),
        code_fallback_text: Color32::from_rgb(220, 220, 220),
        inline_code_bg:     Color32::from_rgb(30, 30, 30),
        inline_code_fg:     Color32::from_rgb(180, 255, 180),
        blockquote_bg:      Color32::from_rgb(24, 24, 24),
        blockquote_border:  Color32::from_rgb(40, 40, 40),
        blockquote_text:    Color32::WHITE,
        blockquote_bar:     Color32::from_rgb(255, 103, 25),
        box_bg:             Color32::from_rgb(25, 25, 25),
        box_border:         Color32::from_rgb(60, 60, 60),
        box_title:          Color32::from_rgb(200, 160, 80),
        box_body:           Color32::from_rgb(180, 180, 180),
                status_loading:     Color32::from_rgb(120, 200, 255),
                status_queue:       Color32::from_rgb(100, 150, 255),
                status_hint:        Color32::GRAY,
    };

    pub const LIGHT: Self = Self {
        link:               Color32::from_rgb(0, 102, 204),
        link_internal:      Color32::from_rgb(0, 80, 180),
        code_bg:            Color32::from_rgb(245, 245, 245),
        code_border:        Color32::from_rgb(210, 210, 210),
        code_label:         Color32::from_rgb(120, 120, 120),
        code_fallback_text: Color32::from_rgb(50, 50, 50),
        inline_code_bg:     Color32::WHITE,
        inline_code_fg:     Color32::from_rgb(60, 80, 150),
        blockquote_bg:      Color32::from_rgb(245, 245, 248),
        blockquote_border:  Color32::from_rgb(215, 215, 220),
        blockquote_text:    Color32::from_rgb(40, 40, 40),
        blockquote_bar:     Color32::from_rgb(255, 103, 25), // same orange both modes
        box_bg:             Color32::from_rgb(245, 245, 245),
        box_border:         Color32::from_rgb(200, 200, 200),
        box_title:          Color32::from_rgb(160, 100, 20),
        box_body:           Color32::from_rgb(80, 80, 80),
                status_loading:     Color32::from_rgb(30, 120, 200),
                status_queue:       Color32::from_rgb(30, 100, 200),
                status_hint:        Color32::from_rgb(130, 130, 130),
    };

    /// Get the color palette for the current theme mode.
    pub fn current(dark_mode: bool) -> &'static Self {
        if dark_mode { &Self::DARK } else { &Self::LIGHT }
    }

    /// Get the syntect theme name for syntax highlighting.
    pub fn syntect_theme(dark_mode: bool) -> &'static str {
        if dark_mode { "base16-ocean.dark" } else { "InspiredGitHub" }
    }
}
```

**Design decisions:**
- `const` values = zero runtime cost, no allocation
- Static references = no copying
- All dark values match current hardcoded values exactly (no visual regression)
- Blockquote bar stays orange in both modes (brand identity, good contrast on both)
- Light link blue `(0, 102, 204)` is standard web link blue
- Light code bg `(245, 245, 245)` matches GitHub-style code blocks

**Note on `LIGHT_BLUE`:** egui's `Color32::LIGHT_BLUE` is `(135, 206, 250)`. Since we can't use named constants in `const` struct initialization, we use the literal RGB value.

### 4.3 Component: AppSettings Persistence (`src/window_state.rs`)

**Struct change:**
```rust
pub struct AppSettings {
    pub allow_remote_images: bool,
    pub dark_mode: bool,   // NEW
}
```

**Default:** Manual impl replacing `#[derive(Default)]`:
```rust
impl Default for AppSettings {
    fn default() -> Self {
        Self {
            allow_remote_images: false,
            dark_mode: true,  // Dark mode is the default for new installs
        }
    }
}
```

**File format** (`settings.txt`):
```
allow_remote_images=0
dark_mode=1
```

**Windows Registry** (`HKCU\Software\MarkdownView`):
```
AllowRemoteImages  REG_DWORD  0x00000000
DarkMode           REG_DWORD  0x00000001
```

Both `load_app_settings()` and `save_app_settings()` updated to handle the new field.
Registry functions updated similarly.

### 4.4 Component: MarkdownRenderer Changes (`src/markdown_renderer.rs`)

**New field + setter:**
```rust
pub struct MarkdownRenderer {
    // ... existing fields ...
    dark_mode: bool,
}

impl MarkdownRenderer {
    pub fn new() -> Self {
        Self {
            // ... existing defaults ...
            dark_mode: true,  // Default to dark
        }
    }

    pub fn set_dark_mode(&mut self, dark: bool) {
        self.dark_mode = dark;
    }
}
```

**Syntect theme selection** (line 5778):
```rust
// Before:
let theme = &self.theme_set.themes["base16-ocean.dark"];

// After:
let theme = &self.theme_set.themes[ThemeColors::syntect_theme(self.dark_mode)];
```

**Color replacements** - at each site, replace hardcoded `Color32::from_rgb(...)` with:
```rust
let tc = ThemeColors::current(ui.visuals().dark_mode);
// Then use tc.link, tc.code_bg, etc.
```

Specific sites (grouped by element type):

**Links** (4 sites: lines 743, 745, 2905, 2907):
```rust
// Before:
let color = if url.starts_with('#') { Color32::LIGHT_BLUE } else { Color32::from_rgb(120, 190, 255) };

// After:
let tc = ThemeColors::current(ui.visuals().dark_mode);
let color = if url.starts_with('#') { tc.link_internal } else { tc.link };
```

**Inline code** (2 sites: lines 872-879, 2844-2852):
```rust
// Before:
let (bg, fg) = if visuals.dark_mode {
    (Color32::from_rgb(30, 30, 30), Color32::from_rgb(180, 255, 180))
} else {
    (Color32::WHITE, Color32::from_rgb(60, 80, 150))
};

// After:
let tc = ThemeColors::current(visuals.dark_mode);
let (bg, fg) = (tc.inline_code_bg, tc.inline_code_fg);
```

**Blockquotes** (1 site: lines 2643-2669):
```rust
// Before:
let bg = Color32::from_rgb(24, 24, 24);
.stroke(Stroke::new(1.0, Color32::from_rgb(40, 40, 40)))
ui.style_mut().visuals.override_text_color = Some(Color32::WHITE);
let bar_color = Color32::from_rgb(255, 103, 25);

// After:
let tc = ThemeColors::current(ui.visuals().dark_mode);
let bg = tc.blockquote_bg;
.stroke(Stroke::new(1.0, tc.blockquote_border))
ui.style_mut().visuals.override_text_color = Some(tc.blockquote_text);
let bar_color = tc.blockquote_bar;
```

**Code blocks without highlighting** (1 site: lines 2964-2973):
```rust
let tc = ThemeColors::current(ui.visuals().dark_mode);
// Use tc.code_bg, tc.code_border, tc.code_label
```

**Code blocks with highlighting** (1 site: lines 3902-3911):
```rust
let tc = ThemeColors::current(ui.visuals().dark_mode);
// Use tc.code_bg, tc.code_border, tc.code_label
```

**Code fallback text** (1 site: line 3972):
```rust
let tc = ThemeColors::current(ui.visuals().dark_mode);
// Use tc.code_fallback_text
```

### 4.5 Component: Mermaid Renderer Changes (`src/mermaid_renderer.rs`)

6 nearly identical error/info box patterns at lines 769, 795, 822, 897, 962, 988. Each follows:
```rust
egui::Frame::none()
    .fill(Color32::from_rgb(25, 25, 25))
    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
    .show(ui, |ui| {
        ui.label(RichText::new("...").color(Color32::from_rgb(200, 160, 80)));
        ui.label(RichText::new(code).color(Color32::from_rgb(180, 180, 180)));
    });
```

Replace each with:
```rust
let tc = ThemeColors::current(ui.visuals().dark_mode);
egui::Frame::none()
    .fill(tc.box_bg)
    .stroke(Stroke::new(1.0, tc.box_border))
    .show(ui, |ui| {
        ui.label(RichText::new("...").color(tc.box_title));
        ui.label(RichText::new(code).color(tc.box_body));
    });
```

### 4.6 Component: App Toggle (`src/app.rs`)

**Struct changes:**
Replace standalone `allow_remote_images: bool` with full `settings: AppSettings`:
```rust
pub struct MarkdownViewerApp {
    // ... existing fields ...
    settings: AppSettings,  // Replaces allow_remote_images field
}
```

Update all `self.allow_remote_images` references to `self.settings.allow_remote_images`.

**Status bar toggle** (in `render_status_bar()`, right-to-left layout):
```rust
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
    // Theme toggle - rightmost item
    let label = if self.settings.dark_mode { "Dark" } else { "Light" };
    if ui.small_button(label).clicked() {
        self.theme_toggle_requested = true;
    }
    ui.separator();

    // ... existing stats code ...
});
```

Note: We use a deferred flag (`theme_toggle_requested`) similar to `view_toggle_requested` and `write_toggle_requested` to avoid borrowing conflicts (the status bar borrows `&self` but the toggle needs `&mut self` + `ctx`).

**Keyboard shortcut** (in `handle_shortcuts()`):
```rust
// Ctrl+Shift+T - Toggle theme
if input.consume_shortcut(&egui::KeyboardShortcut::new(
    egui::Modifiers::CTRL | egui::Modifiers::SHIFT, egui::Key::T
)) {
    self.theme_toggle_requested = true;
}
```

**Deferred toggle handling** (in `update()`, alongside other deferred actions):
```rust
if self.theme_toggle_requested {
    self.theme_toggle_requested = false;
    self.toggle_theme(ctx);
}
```

**`toggle_theme()` method:**
```rust
fn toggle_theme(&mut self, ctx: &egui::Context) {
    self.settings.dark_mode = !self.settings.dark_mode;
    Self::apply_visuals(ctx, self.settings.dark_mode);
    self.renderer.set_dark_mode(self.settings.dark_mode);

    // Re-parse to update syntax highlighting colors
    if !self.current_content.is_empty() {
        self.parsed_elements = self.renderer.parse(&self.current_content);
    }

    let _ = save_app_settings(&self.settings);
}

fn apply_visuals(ctx: &egui::Context, dark: bool) {
    if dark {
        let mut v = egui::Visuals::dark();
        v.window_fill = Color32::BLACK;
        v.panel_fill = Color32::BLACK;
        v.faint_bg_color = Color32::from_gray(20);
        v.extreme_bg_color = Color32::BLACK;
        ctx.set_visuals(v);
    } else {
        ctx.set_visuals(egui::Visuals::light());
    }
}
```

### 4.7 Component: Startup Theme (`src/main.rs`)

After `MarkdownViewerApp::new()` (line 340), apply saved theme:
```rust
let mut app = MarkdownViewerApp::new();
app.apply_saved_theme(&cc.egui_ctx);  // NEW: applies visuals from settings
```

Where `apply_saved_theme()` calls `apply_visuals(ctx, self.settings.dark_mode)`.

This runs AFTER `configure_egui_style()` (line 333) which sets spacing/rounding. `set_visuals()` only replaces the visuals portion of the style, preserving spacing/rounding.

If screenshot mode is active with explicit `--theme` flag, the screenshot theme takes precedence (existing code at lines 318-331 runs first).

### 4.8 Module Registration (`src/lib.rs`)

```rust
pub mod theme;
// ... existing modules ...
pub use theme::ThemeColors;
```

## 5. Light Mode Color Palette

### 5.1 Color Table

| Name | Dark Mode | Light Mode | Rationale |
|------|-----------|------------|-----------|
| link | `(120, 190, 255)` | `(0, 102, 204)` | Standard web link blue |
| link_internal | `(135, 206, 250)` | `(0, 80, 180)` | Slightly darker than external |
| code_bg | `(30, 30, 30)` | `(245, 245, 245)` | GitHub-style light gray |
| code_border | `(60, 60, 60)` | `(210, 210, 210)` | Subtle border |
| code_label | `(140, 140, 140)` | `(120, 120, 120)` | Muted language label |
| code_fallback_text | `(220, 220, 220)` | `(50, 50, 50)` | Near-black on light |
| inline_code_bg | `(30, 30, 30)` | `WHITE` | Clean inline highlight |
| inline_code_fg | `(180, 255, 180)` | `(60, 80, 150)` | Already existed |
| blockquote_bg | `(24, 24, 24)` | `(245, 245, 248)` | Very subtle warm gray |
| blockquote_border | `(40, 40, 40)` | `(215, 215, 220)` | Subtle |
| blockquote_text | `WHITE` | `(40, 40, 40)` | Near-black |
| blockquote_bar | `(255, 103, 25)` | `(255, 103, 25)` | Same Substack orange |
| box_bg | `(25, 25, 25)` | `(245, 245, 245)` | Match code block bg |
| box_border | `(60, 60, 60)` | `(200, 200, 200)` | Match code block border |
| box_title | `(200, 160, 80)` | `(160, 100, 20)` | Darker amber on light |
| box_body | `(180, 180, 180)` | `(80, 80, 80)` | Medium gray |
| status_loading | `(120, 200, 255)` | `(30, 120, 200)` | Darker blue on light bg |
| status_queue | `(100, 150, 255)` | `(30, 100, 200)` | Darker blue on light bg |
| status_hint | `GRAY` | `(130, 130, 130)` | Slightly darker gray on light |

### 5.2 Syntect Themes

- **Dark:** `"base16-ocean.dark"` (current, no change)
- **Light:** `"InspiredGitHub"` (clean, GitHub-like, available in syntect defaults)

### 5.3 egui Built-in Visuals

- **Dark mode:** `egui::Visuals::dark()` + true-black overrides (BLACK panel_fill, window_fill, extreme_bg_color; `from_gray(20)` faint_bg_color)
- **Light mode:** `egui::Visuals::light()` (default egui light theme, no overrides needed)

egui's light visuals automatically handle:
- Text color (near-black)
- Widget backgrounds
- Selection colors
- Separator colors
- Scroll bar colors

## 6. Edge Cases

### 6.1 Default for New Installations
`AppSettings::default()` returns `dark_mode: true`. A brand new install with no settings file gets dark mode.

### 6.2 Missing `dark_mode` Key in Settings File
If the settings file exists but has no `dark_mode` line (upgrade from older version), the field retains its default value (`true` = dark mode). Backward compatible.

### 6.3 Windows Registry Missing Key
`key.get_value("DarkMode").unwrap_or(1)` defaults to dark mode if the key doesn't exist.

### 6.4 Screenshot Mode
Screenshot `--theme light/dark` overrides the saved preference. The app's `settings.dark_mode` isn't updated â€” screenshots are one-shot.

### 6.5 Re-parse Performance
Re-parsing on theme toggle is fast: it's pure in-memory string processing. Even a large document (1000+ elements) re-parses in <50ms. The user won't notice.

### 6.6 Mermaid Rendered Images
Mermaid diagrams rendered via QuickJS produce raster images with theme-specific backgrounds. On theme toggle, existing mermaid textures would show dark-themed diagrams on a light background (or vice versa). The existing mermaid texture cache should be invalidated on theme switch. **TODO: Verify if this is needed or if mermaid re-renders automatically.**

## 7. Files Modified

| File | Type | Summary |
|------|------|---------|
| `src/theme.rs` | **NEW** | `ThemeColors` struct with DARK/LIGHT palettes + syntect theme helper |
| `src/lib.rs` | Edit | Add `pub mod theme` + `pub use theme::ThemeColors` |
| `src/window_state.rs` | Edit | Add `dark_mode` to `AppSettings`, manual `Default`, file/registry persistence |
| `src/app.rs` | Edit | Replace `allow_remote_images` with `settings: AppSettings`, add toggle button + toggle logic |
| `src/markdown_renderer.rs` | Edit | Add `dark_mode` field + setter, replace ~12 color sites with `ThemeColors`, switch syntect theme |
| `src/mermaid_renderer.rs` | Edit | Replace ~6 error box color sites with `ThemeColors` |
| `src/main.rs` | Edit | Apply saved theme at startup after app construction |

## 8. Testing Strategy

### 8.1 Existing Tests
- All 222 `MarkdownRenderer::new()` call sites unchanged (defaults to dark)
- All `AppSettings { ... }` test constructors get `dark_mode: true`
- `cargo test` must pass with zero failures

### 8.2 New Unit Tests

**theme.rs:**
- `test_dark_colors_match_current` - verify DARK palette matches current hardcoded values
- `test_light_colors_exist` - verify LIGHT palette has all non-default values
- `test_current_returns_correct_palette` - verify `current(true) == DARK`, `current(false) == LIGHT`
- `test_syntect_theme_names` - verify valid theme names

**window_state.rs:**
- `test_dark_mode_default_is_true` - verify `AppSettings::default().dark_mode == true`
- `test_settings_round_trip_dark_mode` - save and load with dark_mode=true/false
- `test_settings_missing_dark_mode_key` - file without dark_mode line defaults to true
- `test_settings_dark_mode_false` - verify dark_mode=0 loads as false

**markdown_renderer.rs:**
- `test_highlight_code_dark_theme` - verify dark syntect theme is used
- `test_highlight_code_light_theme` - verify light syntect theme after set_dark_mode(false)

### 8.3 Manual Visual Testing
1. Launch app with default (dark) theme
2. Click "Dark" button in status bar -> switches to light
3. Verify: links, code blocks, blockquotes, inline code, mermaid boxes all readable
4. Click "Light" -> switches back to dark
5. Verify: everything matches original appearance (no regression)
6. Restart app -> verify theme persisted
7. Open code-heavy file -> verify syntax highlighting matches theme
8. Use `mdscreensnap` for before/after comparison

### 8.4 Build Verification
```bash
cargo test           # All tests pass
cargo build          # Debug build, zero warnings
cargo build --release  # Release build succeeds
cargo clippy         # No new warnings
```

## 9. Version Impact

This is a new feature (minor version bump). Update `Cargo.toml` version accordingly.

## 10. Resolved Decisions

1. **Keyboard shortcut**: `Ctrl+Shift+T` toggles theme (in addition to the status bar button). Add to `handle_shortcuts()` in app.rs.
2. **Status bar accent colors**: Include in ThemeColors for completeness. Add `status_loading`, `status_queue`, `status_hint` fields.

## 11. Open Questions

1. **Mermaid cache invalidation**: Do we need to clear mermaid texture cache on theme toggle? Need to verify if QuickJS-rendered mermaid images have theme-specific backgrounds.

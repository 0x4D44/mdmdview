# Implementation Plan — D2 Orthogonal Edge Routing

**Date:** 2026-02-21
**Design:** `wrk_docs/2026.02.21 - HLD - D2 Orthogonal Edge Routing V3.md`
**Crate:** `mdmdview-d2` (`crates/d2/`), currently v0.1.0

---

## Overview

Replace the center-to-center Bézier edge routing with orthogonal (axis-aligned) edge routing using three-segment paths routed through inter-rank channels. Self-loops remain Bézier. This is a minor version bump (0.1.0 → 0.2.0) — new public enum, new field on `D2EdgeData`.

Five stages, each a commit point. Each stage compiles, passes tests, and preserves existing behavior until Stage 3 flips the switch.

---

## Stage 1 — Data Model

**Goal:** Add `RouteType` enum and field. Zero behavior change.

**File: `crates/d2/src/graph.rs`**
1. Add `RouteType` enum (Bezier, Orthogonal) with `Default` → Bezier, derives Debug/Clone/Copy/PartialEq/Eq
2. Add `pub route_type: RouteType` field to `D2EdgeData`
3. Update all `D2EdgeData` struct literals (in `compiler.rs`, `edge_routing.rs` tests, `layout_sugiyama.rs` tests) to include `route_type: RouteType::Bezier`

**File: `crates/d2/Cargo.toml`**
- Bump version to 0.2.0

**Validation:**
- `cargo build -p mdmdview-d2` — no warnings
- `cargo test -p mdmdview-d2` — all existing tests pass unchanged

**Commit:** `feat(d2): add RouteType enum for orthogonal edge routing`

---

## Stage 2 — Hierarchy Utilities + SVG Polyline

Two independent pieces that Stage 3 depends on. Build both now so Stage 3 can focus purely on routing logic.

### 2A: Hierarchy utilities

**File: `crates/d2/src/edge_routing.rs`** — add four functions:

```
fn ancestor_chain(graph: &D2Graph, node: NodeIndex) -> HashSet<NodeIndex>
fn find_lca(graph: &D2Graph, a: NodeIndex, b: NodeIndex) -> NodeIndex
fn child_ancestor_of(graph: &D2Graph, node: NodeIndex, ancestor: NodeIndex) -> NodeIndex
fn effective_direction(graph: &D2Graph, container: NodeIndex) -> Direction
```

All private (`pub(crate)` if needed by tests). Implementation straight from HLD §3.2.

**Tests** (in `edge_routing::tests`):

| Test | Setup | Assertion |
|------|-------|-----------|
| `test_find_lca_root_level` | `a: { x } \n b: { y } \n a.x -> b.y` | `find_lca(x, y) == root` |
| `test_find_lca_siblings` | `g: { a; b } \n g.a -> g.b` | `find_lca(a, b) == g` |
| `test_find_lca_container_to_descendant` | `g: { a } \n g -> g.a` | `find_lca(g, a) == g` |
| `test_child_ancestor_of_direct` | `g: { a; b }` | `child_ancestor_of(a, g) == a` |
| `test_child_ancestor_of_nested` | `g: { inner: { a } }` | `child_ancestor_of(a, g) == inner` |
| `test_child_ancestor_of_guard` | `g: { a }` | `child_ancestor_of(g, g) == g` |
| `test_effective_direction_inherit` | `direction: right \n g: { a }` | `effective_direction(g) == Right` |
| `test_effective_direction_override` | `direction: right \n g: { direction: down; a }` | `effective_direction(g) == Down` |
| `test_effective_direction_root` | `direction: right \n a` | `effective_direction(root) == Right` |

### 2B: SVG polyline with rounded corners

**File: `crates/d2/src/svg_render.rs`**

1. Add `polyline_with_rounded_corners(points: &[Point], radius: f64) -> String`
   - Reuse existing `c()` function (line 24) for coordinate rounding
   - Implementation straight from HLD §3.5
2. Add constant `const BEND_RADIUS: f64 = 5.0;`
3. Add `RouteType::Orthogonal` branch in `render_edges()`:
   - Extract existing Bézier path construction into a `build_bezier_path(route: &[Point]) -> String` helper
   - Match on `edge.route_type`: Bezier → `build_bezier_path`, Orthogonal → `polyline_with_rounded_corners`
4. Add `use crate::graph::RouteType;` import

**Tests** (in `svg_render::tests`):

| Test | Assertion |
|------|-----------|
| `test_polyline_two_points` | Straight line `M ... L ...`, no `Q` |
| `test_polyline_three_points` | Contains `L` and `Q` commands |
| `test_polyline_corner_clamping` | Very short segments → `r` < BEND_RADIUS |
| `test_polyline_degenerate` | Empty/single point → empty string |
| `test_orthogonal_route_renders_polyline` | Full render of graph with `route_type=Orthogonal` edge produces `L`/`Q` in SVG, not `C` |

**Validation:**
- `cargo build -p mdmdview-d2` — no warnings
- `cargo test -p mdmdview-d2` — all tests pass (existing + new)

**Commit:** `feat(d2): add hierarchy utilities and SVG polyline renderer`

---

## Stage 3 — Orthogonal Router (Core)

**Goal:** Replace Bézier routing with orthogonal routing for all non-self-loop edges. This is the big stage.

**File: `crates/d2/src/edge_routing.rs`**

### New constants:
```rust
const CHANNEL_SPACING: f64 = 12.0;
const MIN_STUB_LENGTH: f64 = 15.0;
const SAME_RANK_JOG: f64 = 30.0;
```

### New types:
```rust
/// Classification of an edge for routing purposes.
struct EdgeClassification {
    edge_idx: EdgeIndex,
    src: NodeIndex,
    dst: NodeIndex,
    lca: NodeIndex,
    direction: Direction,
    kind: EdgeKind,           // Forward, Backward, SameRank, ContainerDescendant
    gap_start: f64,
    gap_end: f64,
    channel_pos: f64,         // assigned during allocation
    src_port: Point,          // assigned during allocation
    dst_port: Point,          // assigned during allocation
}

enum EdgeKind {
    Forward,
    Backward,
    SameRank,
    ContainerDescendant,
}
```

### New function: `compute_port()` (HLD §3.4)
- Two branches: shapes with dedicated clipping (Diamond/Hexagon/Circle/Oval) vs all others (bounding-box)
- Takes shape, rect, direction, port_cross → Point

### New function: `route_orthogonal_edges(graph: &mut D2Graph)`
Three-pass structure:

**Pass 1 — Classify:** For each non-self-loop edge:
- Compute LCA, src_anc, dst_anc via hierarchy utilities
- Detect container-to-descendant (src_anc == lca || dst_anc == lca)
- Detect forward/backward/same-rank from ancestor center positions
- Compute (gap_start, gap_end) per direction and forward/backward
- Store in `Vec<EdgeClassification>`

**Pass 2 — Allocate:**
- **Channels:** Group by `(lca, gap_key)` where `gap_key = (gap_start.round() as i64, gap_end.round() as i64)`. Sort each group by (source cross-pos, destination cross-pos). Spread channel positions symmetrically with clamping.
- **Source ports:** Group edges by (source node, exit side). Sort by destination cross-pos. Distribute ports evenly along the exit edge (with 4px fallback).
- **Destination ports:** Group edges by (destination node, entry side). Sort by source cross-pos. Distribute ports evenly along the entry edge (with 4px fallback).

**Pass 3 — Build:** For each edge, construct the route points:
- **Forward:** `[src_port, (channel, src_port_cross), (channel, dst_port_cross), dst_port]` — collapse to 2 points if same cross-position
- **Backward:** Same three-segment shape but with reversed sides
- **SameRank:** 4-point jog path per HLD §3.7
- **ContainerDescendant:** L-shaped path via node positions
- Set `route_type = RouteType::Orthogonal`

### Modify `route_all_edges()`:
- Self-loops: existing Bézier logic (unchanged)
- All other edges: call `route_orthogonal_edges(graph)` instead of per-edge Bézier

### Tests:

| Test | D2 Source | Assertion |
|------|-----------|-----------|
| `test_ortho_straight_horizontal` | `direction: right \n a -> b` | 2 route points, route_type == Orthogonal |
| `test_ortho_straight_vertical` | `a -> b` (default down) | 2 route points, route_type == Orthogonal |
| `test_ortho_straight_left` | `direction: left \n a -> b` | 2 points, dst left of src |
| `test_ortho_straight_up` | `direction: up \n a -> b` | 2 points, dst above src |
| `test_ortho_three_segment` | `direction: right \n a -> c \n b -> c` | a→c has 4 points (a/b at different Y, so a→c needs vertical jog) |
| `test_ortho_same_rank_jog` | Two same-rank nodes with edge | 4 points, jog extends beyond both nodes |
| `test_ortho_channel_spread` | `direction: right \n a -> c \n a -> d` (c, d same rank) | Two edges with different channel_pos in same gap |
| `test_ortho_cross_container` | Architecture example (lb, services, data) | All cross-container edges have 4-point routes, channels between container boundaries |
| `test_ortho_backward_edge` | `direction: right \n a -> b \n b -> a` | b→a exits from left side |
| `test_ortho_deep_nesting` | 3-level nesting with cross-level edge | Correct LCA, channel in outer gap |
| `test_ortho_self_loop_unchanged` | `a -> a` | route_type == Bezier, 7 points (unchanged) |
| `test_ortho_container_descendant` | `g: { a } \n g -> g.a` | L-shaped route |
| `test_ortho_architecture_integration` | Full architecture example from HLD §1 | All edges routed, no panics, no empty routes |

**Validation:**
- `cargo build -p mdmdview-d2` — no warnings
- `cargo test -p mdmdview-d2` — all tests pass
- Existing label position tests may need assertion updates (label positions shift with orthogonal routing)

**Commit:** `feat(d2): implement orthogonal edge routing`

---

## Stage 4 — Label Placement

**Goal:** Place edge labels on the enter segment with perpendicular offset.

**File: `crates/d2/src/edge_routing.rs`**

Modify `route_orthogonal_edges()` Pass 3 to set `label_position`:
1. For labeled edges, identify the enter segment: `route[N-2] → route[N-1]`
2. Compute midpoint of enter segment
3. Apply perpendicular offset (LABEL_OFFSET = 10.0):
   - Horizontal segment → shift Y upward (-Y)
   - Vertical segment → shift X leftward (-X)
4. For unlabeled edges: `label_position = None`

Add constant:
```rust
const LABEL_OFFSET: f64 = 10.0;
```

### Tests:

| Test | Assertion |
|------|-----------|
| `test_ortho_label_horizontal` | Label between src and dst horizontally, offset above the line |
| `test_ortho_label_vertical` | Label between src and dst vertically, offset left of the line |
| `test_ortho_label_unlabeled` | `label_position == None` |
| `test_ortho_labels_spread` | Multiple edges in same gap: labels at different positions |

### Fix existing tests:
- `test_label_between_nodes` — may need updated bounds (orthogonal label is on enter segment, still between nodes)
- `test_label_between_nodes_horizontal` — same
- `test_unlabeled_edge_no_label_position` — should pass unchanged

**Validation:**
- `cargo test -p mdmdview-d2` — all tests pass including updated existing label tests

**Commit:** `feat(d2): add orthogonal edge label placement`

---

## Stage 5 — Full Build + Visual Verification

**Goal:** Verify the full application builds and renders correctly.

1. `cargo build` — full workspace, no warnings
2. `cargo build --release` — release build
3. `cargo test -p mdmdview-d2` — all D2 tests pass
4. `cargo run` — open app, load the Architecture Example sample, visually verify:
   - Edges are axis-aligned with right-angle turns
   - Labels are readable and not piled up
   - Self-loops still render as curves
   - Arrowheads point in correct directions
   - No edges clipped by viewBox
5. `mdscreensnap` — capture screenshot for comparison with the original

**Commit:** `chore(d2): bump version to 0.2.0`

---

## File Change Summary

| File | Stage | Changes |
|------|-------|---------|
| `crates/d2/Cargo.toml` | 1, 5 | Version bump |
| `crates/d2/src/graph.rs` | 1 | Add `RouteType` enum + field on `D2EdgeData` |
| `crates/d2/src/compiler.rs` | 1 | Add `route_type: RouteType::Bezier` to edge construction |
| `crates/d2/src/edge_routing.rs` | 2, 3, 4 | Hierarchy utils, orthogonal router, label placement |
| `crates/d2/src/svg_render.rs` | 2 | `polyline_with_rounded_corners()`, route_type branch |
| `crates/d2/src/layout_sugiyama.rs` | 1 | Update test edge construction (add `route_type` field) |

---

## Risk Checkpoints

After each stage, check:
- [ ] `cargo build -p mdmdview-d2` — zero warnings
- [ ] `cargo test -p mdmdview-d2` — all pass
- [ ] No changes outside `crates/d2/` (isolated blast radius)

If Stage 3 tests fail on edge label positions → defer label fixes to Stage 4 (temporarily allow label test failures in Stage 3 by marking them `#[ignore]`).

---

## Known V1 Limitations (Not In Scope)

These are documented in the HLD and explicitly deferred:
- Long-span edge channels may overlap with shorter edges in intermediate gaps (HLD §6.1)
- Same-side port collision for same-rank jog destinations (HLD §6.7)
- Edge-node avoidance (HLD §8)
- Mixed-direction container routing (HLD §8)

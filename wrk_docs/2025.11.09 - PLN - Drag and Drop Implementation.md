# Implementation Plan: Drag and Drop Support for mdmdview

**Date:** 2025-11-09
**Author:** Claude
**Status:** Ready for Implementation
**Related Design:** [2025.11.09 - HLD - Drag and Drop Support.md](./2025.11.09%20-%20HLD%20-%20Drag%20and%20Drop%20Support.md)

## Executive Summary

This document provides a detailed, step-by-step implementation plan for adding drag-and-drop functionality to mdmdview. The implementation is divided into 5 phases, each with specific tasks, acceptance criteria, and testing checkpoints. Total estimated implementation time: 8-12 hours.

## Table of Contents

1. [Phase Overview](#phase-overview)
2. [Phase 1: Core Drag-Drop](#phase-1-core-drag-drop)
3. [Phase 2: Visual Feedback](#phase-2-visual-feedback)
4. [Phase 3: Multi-File Support](#phase-3-multi-file-support)
5. [Phase 4: Directory Support](#phase-4-directory-support)
6. [Phase 5: Polish and Testing](#phase-5-polish-and-testing)
7. [Testing Strategy](#testing-strategy)
8. [Rollback Plan](#rollback-plan)

---

## Phase Overview

| Phase | Focus | Duration | Deliverable |
|-------|-------|----------|-------------|
| 1 | Core Drag-Drop | 2 hours | Single file drop works |
| 2 | Visual Feedback | 1.5 hours | Drag overlay displays |
| 3 | Multi-File Support | 2.5 hours | Multiple files queue and navigate |
| 4 | Directory Support | 2 hours | Folders open all markdown files |
| 5 | Polish & Testing | 2-4 hours | Production-ready feature |

**Dependencies:**
- All phases must be completed sequentially
- Each phase builds on the previous one
- Testing must pass before proceeding to next phase

---

## Phase 1: Core Drag-Drop

**Goal:** Enable basic single-file drag-drop functionality

**Duration:** ~2 hours

### Task 1.1: Enable Drag-Drop in Viewport

**File:** `src/main.rs`

**Changes:**
```rust
// Around line 24-32, modify viewport configuration
let mut viewport = egui::ViewportBuilder::default()
    .with_title(format!("{APP_TITLE_PREFIX} - A Simple Markdown Viewer"))
    .with_inner_size(egui::Vec2::new(1000.0, 700.0))
    .with_min_inner_size(egui::Vec2::new(600.0, 400.0))
    .with_icon(create_app_icon())
    .with_resizable(true)
    .with_maximize_button(true)
    .with_minimize_button(true)
    .with_drag_and_drop(true);  // ADD THIS LINE
```

**Acceptance Criteria:**
- [ ] Code compiles without warnings
- [ ] Application runs normally
- [ ] Window behavior unchanged

**Testing:**
```bash
cargo build
cargo run
# Verify app starts and functions normally
```

---

### Task 1.2: Add Drag State Field

**File:** `src/app.rs`

**Changes:**
```rust
// Add to MarkdownViewerApp struct (around line 20-77)
pub struct MarkdownViewerApp {
    // ... existing fields

    /// Visual state: file is being dragged over window
    drag_hover: bool,
}

// Update new() method (around line 97-200)
impl MarkdownViewerApp {
    pub fn new() -> Self {
        // ... existing initialization

        Self {
            // ... existing fields
            drag_hover: false,
        }
    }
}
```

**Acceptance Criteria:**
- [ ] Struct compiles
- [ ] `new()` initializes field to `false`
- [ ] No compiler warnings

**Testing:**
```bash
cargo build
cargo run
```

---

### Task 1.3: Implement File Validation Method

**File:** `src/app.rs`

**Changes:**
```rust
impl MarkdownViewerApp {
    /// Check if file has valid markdown extension
    fn is_valid_markdown_file(&self, path: &Path) -> bool {
        if let Some(ext) = path.extension() {
            let ext = ext.to_string_lossy().to_lowercase();
            matches!(ext.as_str(), "md" | "markdown" | "mdown" | "mkd" | "txt")
        } else {
            false
        }
    }
}
```

**Add imports at top of file:**
```rust
use std::path::Path;
```

**Acceptance Criteria:**
- [ ] Method compiles
- [ ] Accepts all valid markdown extensions
- [ ] Rejects non-markdown files

**Testing:**
```rust
#[test]
fn test_is_valid_markdown_file() {
    let app = MarkdownViewerApp::new();

    assert!(app.is_valid_markdown_file(Path::new("test.md")));
    assert!(app.is_valid_markdown_file(Path::new("test.markdown")));
    assert!(app.is_valid_markdown_file(Path::new("test.mdown")));
    assert!(app.is_valid_markdown_file(Path::new("test.mkd")));
    assert!(app.is_valid_markdown_file(Path::new("test.txt")));

    assert!(!app.is_valid_markdown_file(Path::new("test.pdf")));
    assert!(!app.is_valid_markdown_file(Path::new("test.docx")));
    assert!(!app.is_valid_markdown_file(Path::new("test")));
}
```

Run test:
```bash
cargo test test_is_valid_markdown_file
```

---

### Task 1.4: Implement Basic File Drop Handler

**File:** `src/app.rs`

**Changes:**
```rust
impl MarkdownViewerApp {
    /// Handle dropped files from drag-and-drop operation
    fn handle_file_drop(&mut self, paths: Vec<PathBuf>) {
        if paths.is_empty() {
            return;
        }

        // For Phase 1, only handle first file
        let path = &paths[0];

        // Validate file exists
        if !path.exists() {
            self.error_message = Some(format!("File not found: {}", path.display()));
            return;
        }

        // Validate it's a file (not directory)
        if !path.is_file() {
            self.error_message = Some(format!(
                "Not a file: {}. Directories will be supported in Phase 4.",
                path.display()
            ));
            return;
        }

        // Validate markdown extension
        if !self.is_valid_markdown_file(path) {
            self.error_message = Some(format!(
                "Not a markdown file: {}\nSupported extensions: .md, .markdown, .mdown, .mkd, .txt",
                path.display()
            ));
            return;
        }

        // Push current state to history if we have content
        if !self.current_content.is_empty() {
            self.push_history();
        }

        // Load the file
        if let Err(e) = self.load_file(path.clone()) {
            self.error_message = Some(format!("Failed to load file: {}", e));
        }
    }
}
```

**Acceptance Criteria:**
- [ ] Method compiles
- [ ] Handles single file correctly
- [ ] Shows appropriate error messages
- [ ] Integrates with existing `load_file()` and `push_history()`

---

### Task 1.5: Add Event Handling in Update Loop

**File:** `src/app.rs`

**Changes:**
```rust
impl MarkdownViewerApp {
    /// Handle drag-drop events from egui
    fn handle_drag_drop_events(&mut self, ctx: &egui::Context) {
        ctx.input(|i| {
            // Check if files are being hovered
            if !i.raw.hovered_files.is_empty() {
                self.drag_hover = true;
            } else {
                self.drag_hover = false;
            }

            // Check if files were dropped
            if !i.raw.dropped_files.is_empty() {
                let paths: Vec<PathBuf> = i.raw.dropped_files
                    .iter()
                    .filter_map(|f| f.path.clone())
                    .collect();

                self.handle_file_drop(paths);
            }
        });
    }
}

// Modify update() method (around line 400+)
impl eframe::App for MarkdownViewerApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // ADD THIS LINE at the very beginning
        self.handle_drag_drop_events(ctx);

        // ... rest of existing update() code
    }
}
```

**Acceptance Criteria:**
- [ ] Event handling integrated into update loop
- [ ] `drag_hover` state updates correctly
- [ ] File drop triggers `handle_file_drop()`

---

### Task 1.6: Phase 1 Integration Testing

**Manual Tests:**

1. **Test: Drop single markdown file**
   ```
   Action: Drag test.md from file explorer, drop on window
   Expected: File opens, content displays
   ```

2. **Test: Drop invalid file type**
   ```
   Action: Drag image.png from file explorer, drop on window
   Expected: Error message shows "Not a markdown file"
   ```

3. **Test: Drop non-existent file**
   ```
   Action: Create test.md, start dragging, delete file mid-drag, drop
   Expected: Error message shows "File not found"
   ```

4. **Test: Drop with existing file open**
   ```
   Action: Open file1.md, drop file2.md
   Expected: file1.md saved to history, file2.md opens
   Action: Press Alt+‚Üê
   Expected: file1.md restored
   ```

**Checkpoint:**
- [ ] All manual tests pass
- [ ] No crashes or panics
- [ ] Error messages clear and helpful
- [ ] History navigation works

---

## Phase 2: Visual Feedback

**Goal:** Add visual overlay during drag operations

**Duration:** ~1.5 hours

### Task 2.1: Implement Drag Overlay Rendering

**File:** `src/app.rs`

**Changes:**
```rust
impl MarkdownViewerApp {
    /// Render drag-and-drop overlay when files are hovered
    fn render_drag_overlay(&self, ctx: &egui::Context) {
        if !self.drag_hover {
            return;
        }

        // Full-screen overlay
        egui::Area::new(egui::Id::new("drag_overlay"))
            .fixed_pos(egui::pos2(0.0, 0.0))
            .order(egui::Order::Foreground)
            .show(ctx, |ui| {
                let screen_rect = ctx.screen_rect();

                // Semi-transparent dark background
                ui.painter().rect_filled(
                    screen_rect,
                    0.0,
                    egui::Color32::from_black_alpha(180),
                );

                // Dashed border effect using multiple rects
                let border_rect = screen_rect.shrink(20.0);
                let border_color = egui::Color32::from_rgb(100, 150, 255);

                // Draw dashed border by drawing segments
                ui.painter().rect_stroke(
                    border_rect,
                    8.0,
                    egui::Stroke::new(4.0, border_color),
                );

                // Center text
                ui.allocate_ui_at_rect(screen_rect, |ui| {
                    ui.vertical_centered(|ui| {
                        ui.add_space(screen_rect.height() / 2.0 - 80.0);

                        // Main message with file emoji
                        ui.label(
                            RichText::new("üìÑ Drop files to open")
                                .size(36.0)
                                .color(egui::Color32::WHITE)
                                .strong(),
                        );

                        ui.add_space(20.0);

                        // Supported formats
                        ui.label(
                            RichText::new("Supported: .md, .markdown, .mdown, .mkd, .txt")
                                .size(18.0)
                                .color(egui::Color32::LIGHT_GRAY),
                        );

                        ui.add_space(10.0);

                        // Additional hint
                        ui.label(
                            RichText::new("Drop multiple files to open them in sequence")
                                .size(14.0)
                                .color(egui::Color32::from_rgb(150, 150, 150))
                                .italics(),
                        );
                    });
                });
            });
    }
}
```

**Acceptance Criteria:**
- [ ] Overlay appears when dragging over window
- [ ] Overlay disappears when drag leaves window
- [ ] Overlay disappears after drop
- [ ] Text is centered and readable
- [ ] Border is visible and attractive

---

### Task 2.2: Integrate Overlay into Update Loop

**File:** `src/app.rs`

**Changes:**
```rust
impl eframe::App for MarkdownViewerApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // Handle drag-drop events (existing)
        self.handle_drag_drop_events(ctx);

        // ... existing UI code (menu bar, panels, etc.)

        // ADD THIS at the very end, AFTER all other UI rendering
        // This ensures overlay is drawn on top
        self.render_drag_overlay(ctx);

        // ... rest of update() code (window state, etc.)
    }
}
```

**Acceptance Criteria:**
- [ ] Overlay renders on top of all other UI
- [ ] No interference with menu bar or panels
- [ ] Overlay doesn't block drop functionality

---

### Task 2.3: Phase 2 Integration Testing

**Manual Tests:**

1. **Test: Drag hover visual feedback**
   ```
   Action: Drag file over window (don't drop)
   Expected:
   - Overlay appears with semi-transparent background
   - "üìÑ Drop files to open" text centered
   - Border visible around window edge
   ```

2. **Test: Drag leave**
   ```
   Action: Drag file over window, drag out of window
   Expected: Overlay disappears
   ```

3. **Test: Drop visual transition**
   ```
   Action: Drag file over window, release to drop
   Expected: Overlay disappears, file opens
   ```

4. **Test: Multiple drags**
   ```
   Action: Drag file in, drag out, drag in again
   Expected: Overlay appears/disappears smoothly each time
   ```

**Checkpoint:**
- [ ] Overlay visual design approved
- [ ] No flickering or visual glitches
- [ ] Works smoothly on all platforms

---

## Phase 3: Multi-File Support

**Goal:** Handle multiple file drops with navigation queue

**Duration:** ~2.5 hours

### Task 3.1: Add Pending Files Queue Field

**File:** `src/app.rs`

**Changes:**
```rust
use std::collections::VecDeque;

pub struct MarkdownViewerApp {
    // ... existing fields

    /// Queue of files waiting to be opened (from multi-file drop)
    pending_files: VecDeque<PathBuf>,
}

// Update new() method
impl MarkdownViewerApp {
    pub fn new() -> Self {
        // ... existing initialization

        Self {
            // ... existing fields
            drag_hover: false,
            pending_files: VecDeque::new(),
        }
    }
}
```

**Acceptance Criteria:**
- [ ] Field added to struct
- [ ] Initialized in `new()`
- [ ] Compiles without warnings

---

### Task 3.2: Update File Drop Handler for Multiple Files

**File:** `src/app.rs`

**Changes:**
```rust
impl MarkdownViewerApp {
    /// Handle dropped files from drag-and-drop operation
    fn handle_file_drop(&mut self, paths: Vec<PathBuf>) {
        if paths.is_empty() {
            return;
        }

        let mut valid_files = Vec::new();
        let mut errors = Vec::new();

        // Validate all dropped files
        for path in paths {
            if !path.exists() {
                errors.push(format!("File not found: {}", path.display()));
                continue;
            }

            if path.is_dir() {
                // Phase 4 will handle directories
                errors.push(format!(
                    "Directory not yet supported: {}",
                    path.display()
                ));
                continue;
            }

            if !self.is_valid_markdown_file(&path) {
                errors.push(format!(
                    "Not a markdown file: {}",
                    path.file_name().unwrap_or_default().to_string_lossy()
                ));
                continue;
            }

            valid_files.push(path);
        }

        // Limit to prevent memory issues
        const MAX_FILES: usize = 50;
        if valid_files.len() > MAX_FILES {
            self.error_message = Some(format!(
                "Too many files ({}). Maximum is {}.\n\
                 Please drop files in smaller batches.",
                valid_files.len(),
                MAX_FILES
            ));
            return;
        }

        // Handle valid files
        if !valid_files.is_empty() {
            // Push current state to history if we have content
            if !self.current_content.is_empty() {
                self.push_history();
            }

            // Open first file immediately
            let first_file = valid_files.remove(0);
            if let Err(e) = self.load_file(first_file) {
                self.error_message = Some(format!("Failed to load file: {}", e));
                return;
            }

            // Queue remaining files
            self.pending_files.extend(valid_files);

            // Show info message if multiple files
            if !self.pending_files.is_empty() {
                eprintln!(
                    "Queued {} files. Use Alt+‚Üí to navigate to next file.",
                    self.pending_files.len()
                );
            }
        }

        // Show errors if any
        if !errors.is_empty() {
            let error_msg = if errors.len() == 1 {
                errors[0].clone()
            } else if valid_files.is_empty() {
                // All files failed
                format!("No valid files:\n{}", errors.join("\n"))
            } else {
                // Some succeeded, some failed
                format!(
                    "Opened {} files. Skipped {}:\n{}",
                    valid_files.len() + 1, // +1 for the file already opened
                    errors.len(),
                    errors.join("\n")
                )
            };
            self.error_message = Some(error_msg);
        }
    }
}
```

**Acceptance Criteria:**
- [ ] Handles multiple valid files
- [ ] First file opens immediately
- [ ] Remaining files queued
- [ ] Error messages for invalid files
- [ ] Respects MAX_FILES limit

---

### Task 3.3: Extend Navigation Forward to Check Queue

**File:** `src/app.rs`

**Changes:**
```rust
impl MarkdownViewerApp {
    /// Navigate forward - extended to support pending files
    fn navigate_forward(&mut self) -> bool {
        // First try pending files queue
        if let Some(next_file) = self.pending_files.pop_front() {
            // Push current state to history
            if !self.current_content.is_empty() {
                self.push_history();
            }

            // Load next file from queue
            if let Err(e) = self.load_file(next_file) {
                self.error_message = Some(format!("Failed to load file: {}", e));
            }
            return true;
        }

        // Otherwise use history navigation (existing code)
        if self.history_index < self.history.len() - 1 {
            self.history_index += 1;
            self.restore_from_history();
            true
        } else {
            false
        }
    }

    /// Check if forward navigation is available
    fn can_navigate_forward(&self) -> bool {
        !self.pending_files.is_empty()
            || self.history_index < self.history.len().saturating_sub(1)
    }
}
```

**Acceptance Criteria:**
- [ ] Forward navigation checks queue first
- [ ] Falls back to history if queue empty
- [ ] `can_navigate_forward()` accounts for queue
- [ ] Queue depletes as user navigates forward

---

### Task 3.4: Add Queue Status to Status Bar

**File:** `src/app.rs`

**Changes:**
```rust
// In render_status_bar() method (around line 800+)
fn render_status_bar(&self, ctx: &egui::Context) {
    TopBottomPanel::bottom("status_bar")
        .exact_height(24.0)
        .show(ctx, |ui| {
            ui.horizontal(|ui| {
                // ... existing status bar content

                // ADD THIS: Show pending file count
                if !self.pending_files.is_empty() {
                    ui.separator();
                    ui.label(
                        RichText::new(format!(
                            "üìã {} files in queue",
                            self.pending_files.len()
                        ))
                        .color(egui::Color32::from_rgb(100, 150, 255))
                    );

                    ui.label(
                        RichText::new("(Alt+‚Üí for next)")
                            .color(egui::Color32::GRAY)
                            .italics()
                    );
                }

                // ... rest of status bar
            });
        });
}
```

**Acceptance Criteria:**
- [ ] Queue count displays when files queued
- [ ] Count updates as files navigated
- [ ] Disappears when queue empty
- [ ] Doesn't interfere with other status items

---

### Task 3.5: Phase 3 Integration Testing

**Manual Tests:**

1. **Test: Drop 3 files**
   ```
   Action: Select file1.md, file2.md, file3.md, drag and drop together
   Expected:
   - file1.md opens immediately
   - Status bar shows "üìã 2 files in queue"
   - Alt+‚Üí opens file2.md
   - Status bar shows "üìã 1 files in queue"
   - Alt+‚Üí opens file3.md
   - Status bar queue indicator disappears
   ```

2. **Test: Drop 10 files**
   ```
   Action: Drop 10 markdown files
   Expected:
   - First file opens
   - Status bar shows "üìã 9 files in queue"
   - Can navigate through all with Alt+‚Üí
   ```

3. **Test: Drop mixed files**
   ```
   Action: Drop 3 .md files and 2 .txt files and 1 .pdf
   Expected:
   - First markdown opens
   - Error message shows: "Opened 5 files. Skipped 1: Not a markdown file: file.pdf"
   - 4 files in queue
   ```

4. **Test: Drop 60 files**
   ```
   Action: Create 60 markdown files, drop all
   Expected: Error message "Too many files (60). Maximum is 50."
   ```

5. **Test: Queue and history interaction**
   ```
   Action:
   1. Open file1.md via File‚ÜíOpen
   2. Drop file2.md, file3.md, file4.md
   3. Press Alt+‚Üí (should open file2.md from queue)
   4. Press Alt+‚Üê (should go back to file1.md from history)
   5. Press Alt+‚Üí (should go to file2.md from history, NOT queue)
   Expected: Queue and history work independently
   ```

**Checkpoint:**
- [ ] All multi-file tests pass
- [ ] Queue navigation smooth
- [ ] Status bar updates correctly
- [ ] History and queue don't conflict

---

## Phase 4: Directory Support

**Goal:** Enable dragging folders to open all markdown files within

**Duration:** ~2 hours

### Task 4.1: Implement Directory Scanner

**File:** `src/app.rs`

**Changes:**
```rust
use anyhow::Result;

impl MarkdownViewerApp {
    /// Scan directory for markdown files (non-recursive)
    fn scan_directory(&self, dir: &Path) -> Result<Vec<PathBuf>> {
        let mut files = Vec::new();

        let entries = std::fs::read_dir(dir)?;

        for entry in entries {
            let entry = entry?;
            let path = entry.path();

            // Only include files (not subdirectories)
            if path.is_file() && self.is_valid_markdown_file(&path) {
                files.push(path);
            }
        }

        // Sort alphabetically for predictable order
        files.sort();

        Ok(files)
    }
}
```

**Acceptance Criteria:**
- [ ] Scans directory successfully
- [ ] Filters only markdown files
- [ ] Ignores subdirectories
- [ ] Returns sorted list
- [ ] Handles permission errors gracefully

---

### Task 4.2: Add Unit Tests for Directory Scanner

**File:** `src/app.rs`

**Changes:**
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_scan_directory() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let dir_path = temp_dir.path();

        // Create test files
        std::fs::write(dir_path.join("zebra.md"), "# Z")?;
        std::fs::write(dir_path.join("alpha.md"), "# A")?;
        std::fs::write(dir_path.join("image.png"), "fake")?;
        std::fs::write(dir_path.join("beta.markdown"), "# B")?;

        // Create subdirectory (should be ignored)
        std::fs::create_dir(dir_path.join("subdir"))?;
        std::fs::write(dir_path.join("subdir/nested.md"), "# N")?;

        let app = MarkdownViewerApp::new();
        let files = app.scan_directory(dir_path)?;

        // Should find 3 markdown files (alpha, beta, zebra)
        // Should NOT find image.png or nested.md
        assert_eq!(files.len(), 3);

        // Should be sorted alphabetically
        assert!(files[0].ends_with("alpha.md"));
        assert!(files[1].ends_with("beta.markdown"));
        assert!(files[2].ends_with("zebra.md"));

        Ok(())
    }

    #[test]
    fn test_scan_empty_directory() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let app = MarkdownViewerApp::new();
        let files = app.scan_directory(temp_dir.path())?;

        assert_eq!(files.len(), 0);
        Ok(())
    }
}
```

**Testing:**
```bash
cargo test test_scan_directory
cargo test test_scan_empty_directory
```

**Acceptance Criteria:**
- [ ] Both tests pass
- [ ] Directory scanning verified

---

### Task 4.3: Update File Drop Handler for Directories

**File:** `src/app.rs`

**Changes:**
```rust
impl MarkdownViewerApp {
    fn handle_file_drop(&mut self, paths: Vec<PathBuf>) {
        if paths.is_empty() {
            return;
        }

        let mut valid_files = Vec::new();
        let mut errors = Vec::new();

        // Validate all dropped items
        for path in paths {
            if !path.exists() {
                errors.push(format!("Not found: {}", path.display()));
                continue;
            }

            if path.is_dir() {
                // NEW: Handle directory
                match self.scan_directory(&path) {
                    Ok(dir_files) => {
                        if dir_files.is_empty() {
                            errors.push(format!(
                                "No markdown files in directory: {}",
                                path.display()
                            ));
                        } else {
                            valid_files.extend(dir_files);
                        }
                    }
                    Err(e) => {
                        errors.push(format!(
                            "Cannot read directory {}: {}",
                            path.display(),
                            e
                        ));
                    }
                }
            } else if path.is_file() {
                // Existing file handling
                if !self.is_valid_markdown_file(&path) {
                    errors.push(format!(
                        "Not a markdown file: {}",
                        path.file_name().unwrap_or_default().to_string_lossy()
                    ));
                    continue;
                }
                valid_files.push(path);
            }
        }

        // ... rest of method remains same (limit check, loading, etc.)
    }
}
```

**Acceptance Criteria:**
- [ ] Directories are scanned
- [ ] Markdown files from directory added to queue
- [ ] Empty directories show appropriate error
- [ ] Permission errors handled gracefully

---

### Task 4.4: Phase 4 Integration Testing

**Manual Tests:**

1. **Test: Drop folder with 5 markdown files**
   ```
   Setup: Create folder with alpha.md, beta.md, charlie.md, delta.md, echo.md
   Action: Drag folder, drop on window
   Expected:
   - alpha.md opens (alphabetically first)
   - Status bar shows "üìã 4 files in queue"
   - Alt+‚Üí cycles through beta, charlie, delta, echo
   ```

2. **Test: Drop folder with mixed files**
   ```
   Setup: Create folder with 3 .md files, 2 .png files, 1 .txt file
   Action: Drop folder
   Expected:
   - First markdown file opens
   - 2 more in queue (3 total markdown files + 1 txt)
   - Error message about skipped files
   ```

3. **Test: Drop empty folder**
   ```
   Setup: Create empty folder
   Action: Drop folder
   Expected: Error "No markdown files in directory: <path>"
   ```

4. **Test: Drop folder with only subdirectories**
   ```
   Setup: Create folder with only subdirectories containing markdown files
   Action: Drop folder
   Expected: Error "No markdown files in directory" (subdirs ignored)
   ```

5. **Test: Drop mix of files and folders**
   ```
   Setup: Select 2 individual .md files and 1 folder with 3 .md files
   Action: Drop all together
   Expected:
   - First file opens
   - 4 files in queue (1 individual + 3 from folder)
   - All accessible via Alt+‚Üí
   ```

**Checkpoint:**
- [ ] Directory scanning works
- [ ] Mixed drops (files + folders) work
- [ ] Error handling for edge cases
- [ ] Files from directory properly sorted

---

## Phase 5: Polish and Testing

**Goal:** Comprehensive testing, error handling, documentation

**Duration:** ~2-4 hours

### Task 5.1: Comprehensive Error Messages

**File:** `src/app.rs`

**Changes:**
```rust
impl MarkdownViewerApp {
    fn handle_file_drop(&mut self, paths: Vec<PathBuf>) {
        // ... existing validation code

        // Enhanced error reporting
        if !errors.is_empty() {
            let error_msg = if errors.len() == 1 {
                // Single error
                errors[0].clone()
            } else if valid_files.is_empty() {
                // All failed
                format!(
                    "Could not open any files:\n\n{}",
                    errors.iter()
                        .take(10)  // Limit to first 10 errors
                        .map(|e| format!("‚Ä¢ {}", e))
                        .collect::<Vec<_>>()
                        .join("\n")
                )
            } else {
                // Some succeeded, some failed
                let success_count = valid_files.len() + 1;  // +1 for opened file
                let total = success_count + errors.len();
                format!(
                    "Opened {}/{} files successfully.\n\n\
                     Skipped files:\n{}",
                    success_count,
                    total,
                    errors.iter()
                        .take(5)  // Show first 5 errors
                        .map(|e| format!("‚Ä¢ {}", e))
                        .collect::<Vec<_>>()
                        .join("\n")
                )
            };
            self.error_message = Some(error_msg);
        } else if valid_files.len() > 1 {
            // All succeeded, show success message for multi-file
            eprintln!(
                "‚úì Loaded {} files. {} queued. Use Alt+‚Üí to navigate.",
                valid_files.len() + 1,
                self.pending_files.len()
            );
        }
    }
}
```

**Acceptance Criteria:**
- [ ] Error messages are clear and actionable
- [ ] Success messages informative
- [ ] Error list limited to prevent UI overflow

---

### Task 5.2: Add Logging for Debugging

**File:** `src/app.rs`

**Changes:**
```rust
impl MarkdownViewerApp {
    fn handle_file_drop(&mut self, paths: Vec<PathBuf>) {
        #[cfg(debug_assertions)]
        eprintln!("DEBUG: Dropped {} items", paths.len());

        // ... validation loop
        for path in paths {
            #[cfg(debug_assertions)]
            eprintln!("DEBUG: Processing: {}", path.display());

            // ... validation code
        }

        #[cfg(debug_assertions)]
        eprintln!(
            "DEBUG: Validated {} files, {} errors",
            valid_files.len(),
            errors.len()
        );

        // ... rest of method
    }
}
```

**Acceptance Criteria:**
- [ ] Debug logging only in debug builds
- [ ] Helpful for troubleshooting issues
- [ ] No performance impact in release

---

### Task 5.3: Update Documentation

**Files to Update:**

**1. CLAUDE.md**
```markdown
## Key Keyboard Shortcuts

...existing shortcuts...

### File Operations
- Drag files from file explorer to open them
- Drop multiple files to create navigation queue
- Drop folders to open all markdown files within
```

**2. README.md**
```markdown
## Features

- **Drag and Drop Support** - Drag markdown files or folders directly into the window
  - Drop single or multiple files
  - Drop folders to open all markdown files
  - Visual feedback during drag operations
  - Files queue for sequential navigation

...

### Opening Files

- Use `File > Open` or `Ctrl+O` to load a markdown file
- **Drag and drop**: Drag `.md` files or folders directly into the window
  - Multiple files are queued and accessible via `Alt+‚Üí`
- Drag and drop `.md` files directly into the application
...
```

**Acceptance Criteria:**
- [ ] CLAUDE.md updated with drag-drop info
- [ ] README.md feature list updated
- [ ] Usage instructions added

---

### Task 5.4: Complete Unit Test Suite

**File:** `src/app.rs`

**Add comprehensive tests:**

```rust
#[cfg(test)]
mod drag_drop_tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_single_file_drop() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = TempDir::new()?;
        let file = temp_dir.path().join("test.md");
        std::fs::write(&file, "# Test")?;

        app.handle_file_drop(vec![file.clone()]);

        assert_eq!(app.current_file, Some(file));
        assert!(app.pending_files.is_empty());
        assert!(app.error_message.is_none());
        Ok(())
    }

    #[test]
    fn test_multiple_files_drop() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = TempDir::new()?;

        let files: Vec<PathBuf> = (0..5)
            .map(|i| {
                let path = temp_dir.path().join(format!("file{}.md", i));
                std::fs::write(&path, format!("# File {}", i)).unwrap();
                path
            })
            .collect();

        app.handle_file_drop(files.clone());

        assert_eq!(app.current_file, Some(files[0].clone()));
        assert_eq!(app.pending_files.len(), 4);
        Ok(())
    }

    #[test]
    fn test_directory_drop() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = TempDir::new()?;

        // Create files in directory
        std::fs::write(temp_dir.path().join("a.md"), "# A")?;
        std::fs::write(temp_dir.path().join("b.md"), "# B")?;
        std::fs::write(temp_dir.path().join("c.md"), "# C")?;

        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);

        assert!(app.current_file.is_some());
        assert_eq!(app.pending_files.len(), 2);
        Ok(())
    }

    #[test]
    fn test_invalid_file_drop() {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = TempDir::new().unwrap();
        let file = temp_dir.path().join("test.pdf");
        std::fs::write(&file, "fake pdf").unwrap();

        app.handle_file_drop(vec![file]);

        assert!(app.current_file.is_none());
        assert!(app.error_message.is_some());
        assert!(app.error_message.as_ref().unwrap().contains("Not a markdown file"));
    }

    #[test]
    fn test_too_many_files() {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = TempDir::new().unwrap();

        let files: Vec<PathBuf> = (0..60)
            .map(|i| {
                let path = temp_dir.path().join(format!("file{}.md", i));
                std::fs::write(&path, format!("# File {}", i)).unwrap();
                path
            })
            .collect();

        app.handle_file_drop(files);

        assert!(app.error_message.is_some());
        assert!(app.error_message.as_ref().unwrap().contains("Too many files"));
    }

    #[test]
    fn test_queue_navigation() -> Result<()> {
        let mut app = MarkdownViewerApp::new();
        let temp_dir = TempDir::new()?;

        let file1 = temp_dir.path().join("file1.md");
        let file2 = temp_dir.path().join("file2.md");

        std::fs::write(&file1, "# File 1")?;
        std::fs::write(&file2, "# File 2")?;

        // Load first file and queue second
        app.load_file(file1.clone())?;
        app.pending_files.push_back(file2.clone());

        assert!(app.can_navigate_forward());
        app.navigate_forward();
        assert_eq!(app.current_file, Some(file2));
        assert!(app.pending_files.is_empty());

        Ok(())
    }
}
```

**Run all tests:**
```bash
cargo test drag_drop_tests
```

**Acceptance Criteria:**
- [ ] All unit tests pass
- [ ] Test coverage for main scenarios
- [ ] Edge cases tested

---

### Task 5.5: Cross-Platform Testing

**Testing Checklist:**

**Windows:**
- [ ] Drop from Windows Explorer
- [ ] Drop from Desktop
- [ ] Drop from network share (`\\server\share`)
- [ ] Drop while minimized
- [ ] Drop with very long paths
- [ ] Unicode filenames work

**Linux (if available):**
- [ ] Drop from Nautilus
- [ ] Drop from Dolphin
- [ ] Symlink drops work
- [ ] Permission errors handled

**macOS (if available):**
- [ ] Drop from Finder
- [ ] Alias drops work
- [ ] Unicode filenames work

**Acceptance Criteria:**
- [ ] Works on at least 2 platforms
- [ ] No platform-specific crashes
- [ ] Error messages appropriate for platform

---

### Task 5.6: Performance Testing

**Tests:**

1. **Rapid drop test**
   ```
   Action: Quickly drop 5 different files in succession
   Expected: Each drop processed correctly, no lag
   ```

2. **Large queue test**
   ```
   Action: Drop 50 files (max limit)
   Expected:
   - Processes within 1 second
   - All files accessible
   - No memory issues
   ```

3. **Large directory test**
   ```
   Action: Drop folder with 100 markdown files
   Expected: Shows "Too many files" error quickly
   ```

**Acceptance Criteria:**
- [ ] Drop response time < 100ms for single file
- [ ] No UI freeze during processing
- [ ] Memory usage reasonable

---

### Task 5.7: Final Integration Testing

**Complete workflow tests:**

1. **Full workflow test:**
   ```
   1. Start app
   2. Drop file1.md
   3. Edit in Write mode
   4. Drop folder with 3 files
   5. Verify file1.md auto-saved
   6. Navigate through queued files with Alt+‚Üí
   7. Navigate back through history with Alt+‚Üê
   8. Close app
   9. Restart app
   10. Verify window state restored
   ```

2. **Error recovery test:**
   ```
   1. Drop invalid file (error shown)
   2. Drop valid file (should work)
   3. Drop mix of valid/invalid (should open valid ones)
   ```

3. **Queue management test:**
   ```
   1. Drop 10 files
   2. Navigate forward through 5 files
   3. Open different file via File‚ÜíOpen
   4. Verify queue cleared
   5. Alt+‚Üê should go to history, not queue
   ```

**Acceptance Criteria:**
- [ ] All workflow tests pass
- [ ] No crashes or data loss
- [ ] Behavior is intuitive

---

## Testing Strategy

### Test Pyramid

```
        Manual Tests (Cross-platform)
              /\
             /  \
            /    \
      Integration Tests
          /      \
         /        \
    Unit Tests (Automated)
```

### Testing Phases

| Phase | Unit Tests | Integration Tests | Manual Tests |
|-------|------------|-------------------|--------------|
| 1 | File validation | Single file drop | Platform testing |
| 2 | N/A | Overlay rendering | Visual QA |
| 3 | Queue management | Multi-file flow | Navigation testing |
| 4 | Directory scan | Directory drop | Edge cases |
| 5 | Complete suite | Full workflows | Regression |

### Automated Tests

**Run before each commit:**
```bash
# Run all tests
cargo test

# Run specific test suites
cargo test test_is_valid_markdown_file
cargo test test_scan_directory
cargo test drag_drop_tests

# Run with output
cargo test -- --nocapture
```

### Manual Testing Sessions

**Session 1: Basic functionality (30 min)**
- Single file drops
- Invalid file handling
- Visual feedback

**Session 2: Multi-file (45 min)**
- Multiple file drops
- Queue navigation
- History integration

**Session 3: Directories (30 min)**
- Folder drops
- Mixed drops
- Edge cases

**Session 4: Cross-platform (60 min)**
- Windows testing
- Linux testing
- macOS testing

**Session 5: Regression (30 min)**
- All existing features still work
- No breaking changes

---

## Rollback Plan

### If Phase 1 Fails
- Revert viewport changes in `main.rs`
- Remove `drag_hover` field
- Remove event handling code
- Feature can be reattempted

### If Phase 2 Fails
- Comment out `render_drag_overlay()` call
- Phase 1 still functional
- Can retry overlay design

### If Phase 3 Fails
- Remove `pending_files` field
- Revert to Phase 1 (single file only)
- Multi-file can be future enhancement

### If Phase 4 Fails
- Keep directory handling disabled
- Phases 1-3 remain functional
- Add error message: "Directories not yet supported"

### Complete Rollback
```bash
# If entire feature needs to be rolled back:
git revert <commit-hash>
# Or create feature flag:
const ENABLE_DRAG_DROP: bool = false;
```

---

## Success Criteria

### MVP (Minimum Viable Product)
- [ ] Single file drag-drop works
- [ ] Visual feedback during drag
- [ ] Error messages clear
- [ ] No crashes on drop

### Complete Feature
- [ ] All 5 phases implemented
- [ ] All unit tests pass
- [ ] Manual testing complete on 2+ platforms
- [ ] Documentation updated
- [ ] Zero compiler warnings
- [ ] Performance acceptable (<100ms response)

### Quality Gates
1. **Code Quality**: All tests pass, no warnings
2. **UX Quality**: User testing shows feature is intuitive
3. **Performance**: Drop-to-open < 100ms
4. **Stability**: No crashes in 100+ test drops

---

## Timeline

### Estimated Schedule

| Phase | Tasks | Duration | Cumulative |
|-------|-------|----------|------------|
| Phase 1 | 6 tasks | 2 hours | 2 hours |
| Phase 2 | 3 tasks | 1.5 hours | 3.5 hours |
| Phase 3 | 5 tasks | 2.5 hours | 6 hours |
| Phase 4 | 4 tasks | 2 hours | 8 hours |
| Phase 5 | 7 tasks | 2-4 hours | 10-12 hours |

**Total: 10-12 hours**

### Suggested Breakdown
- **Day 1**: Phases 1-2 (3.5 hours)
- **Day 2**: Phase 3 (2.5 hours)
- **Day 3**: Phases 4-5 (4-6 hours)

---

## Next Steps

1. **Review this plan** with stakeholders
2. **Set up development branch**: `git checkout -b feature/drag-drop`
3. **Begin Phase 1** implementation
4. **Test incrementally** after each phase
5. **Document progress** in commit messages
6. **Create pull request** after Phase 5

**Ready to begin implementation!** üöÄ

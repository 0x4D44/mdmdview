# Table Formatting HLD (2025-11-20)

## Goals
- Preserve cell content (line breaks, images, nested formatting) in table rendering.
- Prevent cache bleed between distinct tables and stabilize sizing across frames.
- Make header/row heights adaptive to content and zoom.
- Improve column width policies for diverse data (CJK, multiple wide columns, trailing cells).
- Keep legacy renderer usable without image-driven width explosions.
- Add regression coverage to lock behavior.

## Current State (summary of issues)
- Cell parser used for tables (`collect_cell_spans`) ignores soft/hard breaks and images; link bodies lose styling.
- Table IDs hash only content (first 128 rows) + base_dir, so identical tables share metrics/persisted widths.
- TableBuilder header height fixed at 28px; row height hints come from previous frame, causing transient clipping.
- Column policies: single remainder, first column forced fixed, extra columns (rows > headers) fall back to remainder w/out stats; width stats use grapheme counts (underestimates CJK/fullwidth).
- Legacy width solver treats any image span as `ui.available_width()`.

## Design Overview
We will refactor parsing, sizing, and metrics to make table rendering data-driven and instance-scoped, with adaptive sizing and richer heuristics. Changes are additive and gated by the existing "Table Wrap Overhaul" flag where applicable; legacy renderer receives minimal safety fixes.

## Detailed Design
### 1) Unified inline parsing for table cells
- Replace `collect_cell_spans` with a call to the general inline parser (`parse_inline_spans_with_breaks`) configured to stop at `End(TableCell)`.
- Ensure soft/hard breaks become `InlineSpan::Text("\n")` (consistent with paragraphs/quotes when `keep_breaks=true`).
- Include images, links, emphasis, strong, strike, code exactly as other inline contexts.
- Add tests: newline preservation, inline code + styling, image inside cell, link with nested formatting.

### 2) Table identity & cache scoping
- Add `element_index: usize` to `MarkdownElement::Table` creation path (pass from parse loop position).
- Expand `compute_table_id` inputs with element_index and document hash (e.g., hash of entire event stream length + base_dir) so per-instance metrics/cache keys are unique.
- When element count changes between frames (tracked in `element_rects.len()` vs previous), clear `table_layout_cache`, `table_metrics`, and `column_stats_cache` to avoid stale entries.
- Persisted column widths: scope by `table_id` (already) but ensure `policy_hash` remains stable; add a version salt to invalidate old persisted widths when policy rules change.

### 3) Adaptive header and row heights
- Pre-measure header rows:
  - For TableBuilder path, run `render_overhauled_cell` into a throwaway `Ui` with `ui.allocate_ui_at_rect` using available width to compute per-header heights; set `header_height` to max measured + padding instead of constant 28px.
- Row height stabilization:
  - During body rendering, if measured `cell_height` > provided `row_height_hint + epsilon`, call `ctx.request_repaint()` and update the stored height immediately for use on the same frame (store in a local `row_heights` vector before layout submission). 
  - Option B (safer): two-pass body: first measure only to collect heights, second render with final heights; guarded behind a feature flag if perf risk is high.

### 4) Column policy improvements
- Compute stats for all effective columns (max of headers.len and widest row), filling missing headers with synthetic labels ("Column N") before deriving specs.
- Allow multiple remainder-like columns: choose all columns whose stats indicate long text/rich content (using `column_needs_remainder`) up to a limit (e.g., 2) when available width permits; fall back to resizable otherwise.
- Relax first-column fixed rule: make it fixed only if short text/identifier pattern; otherwise treat as resizable and eligible for remainder.
- Use display width estimation:
  - Switch from grapheme count to `unicode_width::UnicodeWidthStr` on the concatenated text when computing `max_graphemes/longest_word` equivalents; keep rich-content flags.
- Tooltip updates to reflect new policies.

### 5) Width resolution and images
- Legacy renderer: replace image width estimate with a capped thumbnail width: `min(natural_or_cache, wrap_cap * 0.5)`; if unknown, use `font_sizes.body * 12` as a heuristic instead of `available_width`.
- For overhaul path, cached layouts already measure; ensure `render_overhauled_cell` passes actual image sizes (from texture cache) into width contributions where egui handles clipping.

### 6) Cache & metrics lifecycle
- On `clear_table_layout_cache()`, also clear new element-index map.
- Track cache stats per frame to surface regressions in status bar (optional).

### 7) Tests
- Unit tests (Rust, `#[cfg(test)]`):
  - Parser: table cell keeps newlines, images, styled links.
  - ID uniqueness: two identical tables at different positions yield different ids; persisted widths do not cross-apply.
  - Header height: when header text wraps, measured header height exceeds 28px and is used.
  - Row height: tall cell triggers repaint flag or two-pass output; ensure no zero heights.
  - Column policies: multiple remainder selection, first column not always fixed, CJK width > ASCII width.
  - Legacy width solver: image span does not force available width.
- Integration-ish: render small markdown samples through `render_table_tablebuilder` in a headless `egui::CtxRef` to assert no panic and reasonable widths (approach: crate-local helper).

### 8) Performance considerations
- Measuring headers and two-pass rows increases work; keep caches keyed by width bucket (ceil to 2px) to limit churn.
- Limit remainder columns to 2 to avoid over-allocation; keep TableBuilder column count stable.
- Sampling cap for column stats stays 128 rows; early exit unchanged.

### 9) Backward compatibility & rollout
- Keep the legacy renderer untouched except for safer image width estimate.
- All major behavioral changes live behind the existing "Table Wrap Overhaul" flag (default on); allow CLI/env override to disable while stabilizing.
- Add a metrics version constant; bump to invalidate persisted widths once when upgrading.

### 10) Work breakdown
1. Parsing refactor + tests.
2. Table ID scoping, cache invalidation, persisted width versioning.
3. Adaptive header/row height implementation (choose one-pass with immediate update; add feature flag for two-pass if needed).
4. Column policy/stat changes (CJK width, multiple remainders, extra columns).
5. Legacy image width cap.
6. Test additions and doc update (TABLE_LAYOUT_QUICK_REFERENCE.md + README toggle note).

## Open Questions
- Accept small perf hit for two-pass row layout, or prefer repaint-on-growth? (default: repaint-on-growth; revisit with profiling.)
- Should persisted widths survive font size changes? We may reset persisted widths when zoom changes to avoid mistracking.
- Cap on remainder columns (2 vs dynamic) – tune after manual trials.

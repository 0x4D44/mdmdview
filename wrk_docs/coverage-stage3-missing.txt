C:\language\mdmdview\src\app.rs:
    1|       |/// Main application logic for the markdown viewer
    2|       |///
    3|       |/// This module contains the primary app state, UI logic, and event handling
    4|       |/// for the markdown viewer application built with egui.
    5|       |use crate::{MarkdownElement, MarkdownRenderer, SampleFile, WindowState, SAMPLE_FILES};
    6|       |use anyhow::{bail, Result};
    7|       |use egui::text::LayoutJob;
    8|       |use egui::text::TextFormat;
    9|       |use egui::{menu, CentralPanel, Color32, Context, RichText, TopBottomPanel};
   10|       |use egui::{TextEdit, TextStyle};
   11|       |#[cfg(not(test))]
   12|       |use rfd::FileDialog;
   13|       |use std::collections::VecDeque;
   14|       |use std::io::ErrorKind;
   15|       |use std::path::{Path, PathBuf};
   16|       |use unicode_casefold::UnicodeCaseFold;
   17|       |use unicode_normalization::UnicodeNormalization;
   18|       |
   19|       |/// Prefix used for application/window titles.
   20|       |pub const APP_TITLE_PREFIX: &str = "mdmdview";
   21|       |const BUILD_VERSION: &str = env!("CARGO_PKG_VERSION");
   22|       |const BUILD_TIMESTAMP: &str = env!("MDMDVIEW_BUILD_TIMESTAMP");
   23|       |
   24|       |/// Entry in navigation history for back/forward navigation
   25|       |#[derive(Clone, Debug)]
   26|       |struct HistoryEntry {
   27|       |    file_path: Option<PathBuf>,
   28|       |    title: String,
   29|       |    content: String,
   30|       |}
   31|       |
   32|       |/// Main application state and logic
   33|       |pub struct MarkdownViewerApp {
   34|       |    /// Markdown renderer instance
   35|       |    renderer: MarkdownRenderer,
   36|       |    /// Currently loaded file path
   37|       |    current_file: Option<PathBuf>,
   38|       |    /// Current markdown content as string
   39|       |    current_content: String,
   40|       |    /// Buffer for raw view (read-only for now)
   41|       |    raw_buffer: String,
   42|       |    /// Parsed markdown elements ready for rendering
   43|       |    parsed_elements: Vec<MarkdownElement>,
   44|       |    /// Application title for window
   45|       |    title: String,
   46|       |    /// Error message to display if any
   47|       |    error_message: Option<String>,
   48|       |    /// Navigation request for keyboard shortcuts
   49|       |    nav_request: Option<NavigationRequest>,
   50|       |    /// Scroll area ID for state management
   51|       |    scroll_area_id: egui::Id,
   52|       |    /// Flag to request fullscreen toggle
   53|       |    toggle_fullscreen: bool,
   54|       |    /// Current view mode
   55|       |    view_mode: ViewMode,
   56|       |    /// Wrap long lines in raw view
   57|       |    wrap_raw: bool,
   58|       |    /// Whether the table wrap overhaul renderer is active
   59|       |    table_wrap_overhaul_enabled: bool,
   60|       |    /// Write mode: allow editing in Raw view
   61|       |    write_enabled: bool,
   62|       |    /// Remember caret position in raw editor (byte index)
   63|       |    raw_cursor: Option<usize>,
   64|       |    /// Request focus for raw editor on next render
   65|       |    raw_focus_requested: bool,
   66|       |    /// Flag to request reload of current file (handled outside input context)
   67|       |    reload_requested: bool,
   68|       |    /// Defer toggling view mode to outside input context
   69|       |    view_toggle_requested: bool,
   70|       |    /// Defer toggling write mode to outside input context
   71|       |    write_toggle_requested: bool,
   72|       |    /// Last known window position (for persistence)
   73|       |    last_window_pos: Option<[f32; 2]>,
   74|       |    /// Last known window size (for persistence)
   75|       |    last_window_size: Option<[f32; 2]>,
   76|       |    /// Last known maximized state
   77|       |    last_window_maximized: bool,
   78|       |    /// Last persisted window snapshot to avoid redundant disk writes
   79|       |    last_persisted_state: Option<WindowState>,
   80|       |    /// Throttle saving window state
   81|       |    last_persist_instant: std::time::Instant,
   82|       |    // Search state
   83|       |    show_search: bool,
   84|       |    search_query: String,
   85|       |    last_query: String,
   86|       |    last_match_index: Option<usize>,
   87|       |    pending_scroll_to_element: Option<usize>,
   88|       |    search_focus_requested: bool,
   89|       |    /// Deferred caret movement (in lines) for raw editor
   90|       |    pending_raw_cursor_line_move: Option<i32>,
   91|       |    // Navigation history
   92|       |    /// History of visited files and samples for back/forward navigation
   93|       |    history: Vec<HistoryEntry>,
   94|       |    /// Current position in history
   95|       |    history_index: usize,
   96|       |    /// Maximum history entries to keep
   97|       |    max_history: usize,
   98|       |    // Drag and drop state
   99|       |    /// Visual state: file is being dragged over window
  100|       |    drag_hover: bool,
  101|       |    /// Queue of files waiting to be opened (from multi-file drop)
  102|       |    pending_files: VecDeque<PathBuf>,
  103|       |}
  104|       |
  105|       |/// Navigation request for keyboard-triggered scrolling
  106|       |#[derive(Debug, Clone)]
  107|       |enum NavigationRequest {
  108|       |    Top,
  109|       |    Bottom,
  110|       |    PageUp,
  111|       |    PageDown,
  112|       |    ScrollUp,   // Arrow up - fine scrolling
  113|       |    ScrollDown, // Arrow down - fine scrolling
  114|       |}
  115|       |
  116|       |/// Which view the user is in
  117|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
  118|       |enum ViewMode {
  119|       |    Rendered,
  120|       |    Raw,
  121|       |}
  122|       |
  123|       |impl MarkdownViewerApp {
  124|      0|    fn toggle_write_mode(&mut self, ctx: &Context) {
  125|      0|        if self.write_enabled {
  126|       |            // About to disable; capture current cursor if in Raw view
  127|      0|            if matches!(self.view_mode, ViewMode::Raw) {
  128|      0|                let editor_id = egui::Id::new("raw_editor");
  129|      0|                if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
  130|      0|                    if let Some(range) = state.cursor.char_range() {
  131|      0|                        self.raw_cursor = Some(range.primary.index);
  132|      0|                    }
  133|      0|                }
  134|      0|            }
  135|      0|            self.write_enabled = false;
  136|       |        } else {
  137|       |            // Enabling write mode: ensure the raw editor will gain focus
  138|      0|            self.write_enabled = true;
  139|      0|            if matches!(self.view_mode, ViewMode::Raw) {
  140|      0|                self.raw_focus_requested = true;
  141|      0|            }
  142|       |        }
  143|      0|    }
  144|       |
  145|      1|    fn move_raw_cursor_lines(&mut self, ctx: &Context, delta_lines: i32) {
  146|      1|        if !matches!(self.view_mode, ViewMode::Raw) || !self.write_enabled {
                          ^0
  147|      0|            return;
  148|      1|        }
  149|      1|        let editor_id = egui::Id::new("raw_editor");
  150|      1|        if let Some(mut state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
                                  ^0
  151|      0|            let mut idx = state
  152|      0|                .cursor
  153|      0|                .char_range()
  154|      0|                .map(|r| r.primary.index)
  155|      0|                .unwrap_or_else(|| self.raw_cursor.unwrap_or(0))
  156|      0|                .min(self.raw_buffer.len());
  157|       |
  158|      0|            let s = self.raw_buffer.as_str();
  159|      0|            match delta_lines.cmp(&0) {
  160|       |                std::cmp::Ordering::Less => {
  161|      0|                    let mut lines = -delta_lines;
  162|       |                    // Move to start of current line
  163|      0|                    idx = s[..idx].rfind('\n').map(|p| p + 1).unwrap_or(0);
  164|      0|                    while lines > 0 && idx > 0 {
  165|      0|                        if let Some(prev_nl) = s[..idx.saturating_sub(1)].rfind('\n') {
  166|      0|                            idx = prev_nl + 1;
  167|      0|                        } else {
  168|      0|                            idx = 0;
  169|      0|                        }
  170|      0|                        lines -= 1;
  171|       |                    }
  172|       |                }
  173|       |                std::cmp::Ordering::Greater => {
  174|      0|                    let mut lines = delta_lines;
  175|       |                    // Move to start of next line
  176|      0|                    if let Some(nl) = s[idx..].find('\n') {
  177|      0|                        idx = (idx + nl + 1).min(s.len());
  178|      0|                        lines -= 1;
  179|      0|                    }
  180|      0|                    while lines > 0 && idx < s.len() {
  181|      0|                        if let Some(nl) = s[idx..].find('\n') {
  182|      0|                            idx = (idx + nl + 1).min(s.len());
  183|      0|                        } else {
  184|      0|                            idx = s.len();
  185|      0|                        }
  186|      0|                        lines -= 1;
  187|       |                    }
  188|       |                }
  189|      0|                std::cmp::Ordering::Equal => {}
  190|       |            }
  191|      0|            let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(idx));
  192|      0|            state.cursor.set_char_range(Some(cr));
  193|      0|            state.store(ctx, editor_id);
  194|      0|            self.raw_cursor = Some(idx);
  195|      0|            self.raw_focus_requested = true; // keep focus and make caret visible
  196|      1|        }
  197|      1|    }
  198|      0|    fn clear_search_state(&mut self) {
  199|      0|        self.search_query.clear();
  200|      0|        self.last_query.clear();
  201|      0|        self.last_match_index = None;
  202|      0|        self.pending_scroll_to_element = None;
  203|      0|        self.renderer.set_highlight_phrase(None);
  204|      0|    }
  205|      0|    fn find_next(&mut self) {
  206|      0|        if self.search_query.is_empty() && self.last_query.is_empty() {
  207|      0|            return;
  208|      0|        }
  209|      0|        let needle = if !self.search_query.is_empty() {
  210|      0|            self.last_query = self.search_query.clone();
  211|      0|            Self::fold_for_search(&self.search_query)
  212|       |        } else {
  213|      0|            Self::fold_for_search(&self.last_query)
  214|       |        };
  215|      0|        if needle.is_empty() {
  216|      0|            return;
  217|      0|        }
  218|      0|        let mut start = self.last_match_index.unwrap_or(usize::MAX);
  219|      0|        if start == usize::MAX {
  220|      0|            start = 0;
  221|      0|        } else {
  222|      0|            start = start.saturating_add(1);
  223|      0|        }
  224|       |        // Wrap-around search forward
  225|      0|        let total = self.parsed_elements.len();
  226|      0|        for pass in 0..2 {
  227|      0|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
  228|      0|                Box::new(start..total)
  229|       |            } else {
  230|      0|                Box::new(0..start.min(total))
  231|       |            };
  232|      0|            for idx in range {
  233|      0|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
  234|      0|                    &self.parsed_elements[idx],
  235|       |                );
  236|      0|                if Self::fold_for_search(&text).contains(&needle) {
  237|      0|                    self.last_match_index = Some(idx);
  238|      0|                    self.pending_scroll_to_element = Some(idx);
  239|      0|                    return;
  240|      0|                }
  241|       |            }
  242|       |        }
  243|      0|    }
  244|       |
  245|      0|    fn find_previous(&mut self) {
  246|      0|        if self.search_query.is_empty() && self.last_query.is_empty() {
  247|      0|            return;
  248|      0|        }
  249|      0|        let needle = if !self.search_query.is_empty() {
  250|      0|            self.last_query = self.search_query.clone();
  251|      0|            Self::fold_for_search(&self.search_query)
  252|       |        } else {
  253|      0|            Self::fold_for_search(&self.last_query)
  254|       |        };
  255|      0|        if needle.is_empty() {
  256|      0|            return;
  257|      0|        }
  258|      0|        let total = self.parsed_elements.len();
  259|      0|        let mut start = self.last_match_index.unwrap_or(0);
  260|      0|        if start == 0 {
  261|      0|            start = total.saturating_sub(1);
  262|      0|        } else {
  263|      0|            start = start.saturating_sub(1);
  264|      0|        }
  265|       |        // Wrap-around search backward
  266|      0|        for pass in 0..2 {
  267|      0|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
  268|      0|                Box::new((0..=start).rev())
  269|       |            } else {
  270|      0|                Box::new(((start + 1)..total).rev())
  271|       |            };
  272|      0|            for idx in range {
  273|      0|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
  274|      0|                    &self.parsed_elements[idx],
  275|       |                );
  276|      0|                if Self::fold_for_search(&text).contains(&needle) {
  277|      0|                    self.last_match_index = Some(idx);
  278|      0|                    self.pending_scroll_to_element = Some(idx);
  279|      0|                    return;
  280|      0|                }
  281|       |            }
  282|       |        }
  283|      0|    }
  284|       |    /// Create a new application instance
  285|     46|    pub fn new() -> Self {
  286|     46|        let mut app = Self {
  287|     46|            renderer: MarkdownRenderer::new(),
  288|     46|            current_file: None,
  289|     46|            current_content: String::new(),
  290|     46|            raw_buffer: String::new(),
  291|     46|            parsed_elements: Vec::new(),
  292|     46|            title: APP_TITLE_PREFIX.to_string(),
  293|     46|            error_message: None,
  294|     46|            nav_request: None,
  295|     46|            scroll_area_id: egui::Id::new("main_scroll_area"),
  296|     46|            toggle_fullscreen: false,
  297|     46|            view_mode: ViewMode::Rendered,
  298|     46|            wrap_raw: false,
  299|     46|            table_wrap_overhaul_enabled: true,
  300|     46|            write_enabled: false,
  301|     46|            raw_cursor: None,
  302|     46|            raw_focus_requested: false,
  303|     46|            reload_requested: false,
  304|     46|            view_toggle_requested: false,
  305|     46|            write_toggle_requested: false,
  306|     46|            last_window_pos: None,
  307|     46|            last_window_size: None,
  308|     46|            last_window_maximized: false,
  309|     46|            last_persisted_state: None,
  310|     46|            last_persist_instant: std::time::Instant::now(),
  311|     46|            show_search: false,
  312|     46|            search_query: String::new(),
  313|     46|            last_query: String::new(),
  314|     46|            last_match_index: None,
  315|     46|            pending_scroll_to_element: None,
  316|     46|            search_focus_requested: false,
  317|     46|            pending_raw_cursor_line_move: None,
  318|     46|            history: Vec::new(),
  319|     46|            history_index: 0,
  320|     46|            max_history: 50,
  321|     46|            drag_hover: false,
  322|     46|            pending_files: VecDeque::new(),
  323|     46|        };
  324|     46|        app.renderer
  325|     46|            .set_table_wrap_overhaul_enabled(app.table_wrap_overhaul_enabled);
  326|       |
  327|       |        // Load welcome content by default
  328|     46|        if let Some(welcome) = SAMPLE_FILES.iter().find(|f| f.name == "welcome.md") {
  329|     46|            app.load_content(welcome.content, Some("Welcome".to_string()));
  330|     46|        }
                      ^0
  331|       |
  332|     46|        app
  333|     46|    }
  334|       |
  335|      0|    pub fn set_table_wrap_overhaul_enabled(&mut self, enabled: bool) {
  336|      0|        self.table_wrap_overhaul_enabled = enabled;
  337|      0|        self.renderer.set_table_wrap_overhaul_enabled(enabled);
  338|      0|    }
  339|       |
  340|      0|    fn toggle_table_wrap_overhaul(&mut self) {
  341|      0|        let enabled = !self.table_wrap_overhaul_enabled;
  342|      0|        self.set_table_wrap_overhaul_enabled(enabled);
  343|      0|    }
  344|       |
  345|       |    /// Check if file has valid markdown extension
  346|     88|    fn is_valid_markdown_file(&self, path: &Path) -> bool {
  347|     88|        if let Some(ext) = path.extension() {
                                  ^87
  348|     87|            let ext = ext.to_string_lossy().to_lowercase();
  349|     87|            matches!(ext.as_str(), "md" | "markdown" | "mdown" | "mkd" | "txt")
                          ^81                           ^12          ^9        ^8      ^7
  350|       |        } else {
  351|      1|            false
  352|       |        }
  353|     88|    }
  354|       |
  355|       |    /// Handle dropped files from drag-and-drop operation
  356|      8|    fn handle_file_drop(&mut self, paths: Vec<PathBuf>) {
  357|      8|        if paths.is_empty() {
  358|      0|            return;
  359|      8|        }
  360|       |
  361|      8|        let mut valid_files = Vec::new();
  362|      8|        let mut errors = Vec::new();
  363|       |
  364|       |        // Validate all dropped files
  365|     80|        for path in paths {
                          ^72
  366|     72|            if !path.exists() {
  367|      0|                errors.push(format!("File not found: {}", path.display()));
  368|      0|                continue;
  369|     72|            }
  370|       |
  371|     72|            if path.is_dir() {
  372|       |                // Handle directory by scanning for markdown files
  373|      2|                match self.scan_directory(&path) {
  374|      2|                    Ok(dir_files) => {
  375|      2|                        if dir_files.is_empty() {
  376|      1|                            errors.push(format!(
  377|      1|                                "No markdown files in directory: {}",
  378|      1|                                path.display()
  379|      1|                            ));
  380|      1|                        } else {
  381|      1|                            valid_files.extend(dir_files);
  382|      1|                        }
  383|       |                    }
  384|      0|                    Err(e) => {
  385|      0|                        errors.push(format!("Cannot read directory {}: {}", path.display(), e));
  386|      0|                    }
  387|       |                }
  388|      2|                continue;
  389|     70|            }
  390|       |
  391|     70|            if !self.is_valid_markdown_file(&path) {
  392|      2|                errors.push(format!(
  393|      2|                    "Not a markdown file: {}",
  394|      2|                    path.file_name().unwrap_or_default().to_string_lossy()
  395|       |                ));
  396|      2|                continue;
  397|     68|            }
  398|       |
  399|     68|            valid_files.push(path);
  400|       |        }
  401|       |
  402|       |        // Limit to prevent memory issues
  403|       |        const MAX_FILES: usize = 50;
  404|      8|        if valid_files.len() > MAX_FILES {
  405|      1|            self.error_message = Some(format!(
  406|      1|                "Too many files ({}). Maximum is {}.\n\
  407|      1|                 Please drop files in smaller batches.",
  408|      1|                valid_files.len(),
  409|      1|                MAX_FILES
  410|      1|            ));
  411|      1|            return;
  412|      7|        }
  413|       |
  414|       |        // Handle valid files
  415|      7|        if !valid_files.is_empty() {
  416|       |            // Open first file immediately
  417|      5|            let first_file = valid_files.remove(0);
  418|      5|            if let Err(e) = self.load_file(first_file, true) {
                                     ^0
  419|      0|                self.error_message = Some(format!("Failed to load file: {}", e));
  420|      0|                return;
  421|      5|            }
  422|       |
  423|       |            // Queue remaining files
  424|      5|            self.pending_files.extend(valid_files.iter().cloned());
  425|       |
  426|       |            // Show info message if multiple files
  427|      5|            if !self.pending_files.is_empty() {
  428|      2|                eprintln!(
  429|      2|                    "Queued {} files. Use Alt+Right to navigate to the next file.",
  430|      2|                    self.pending_files.len()
  431|      2|                );
  432|      3|            }
  433|      2|        }
  434|       |
  435|       |        // Show errors if any
  436|      7|        if !errors.is_empty() {
  437|      3|            let valid_count = if valid_files.is_empty() {
  438|      3|                0
  439|       |            } else {
  440|      0|                valid_files.len() + 1
  441|       |            };
  442|      3|            let error_msg = if errors.len() == 1 && valid_count == 0 {
  443|      3|                errors[0].clone()
  444|      0|            } else if valid_count == 0 {
  445|       |                // All files failed
  446|      0|                format!("No valid files:\n{}", errors.join("\n"))
  447|       |            } else {
  448|       |                // Some succeeded, some failed
  449|      0|                format!(
  450|      0|                    "Opened {} files. Skipped {}:\n{}",
  451|       |                    valid_count,
  452|      0|                    errors.len(),
  453|      0|                    errors.join("\n")
  454|       |                )
  455|       |            };
  456|      3|            self.error_message = Some(error_msg);
  457|      4|        }
  458|      8|    }
  459|       |
  460|       |    /// Scan directory for markdown files (non-recursive)
  461|      4|    fn scan_directory(&self, dir: &Path) -> Result<Vec<PathBuf>> {
  462|      4|        let mut files = Vec::new();
  463|       |
  464|      4|        let entries = std::fs::read_dir(dir)?;
                                                          ^0
  465|       |
  466|     12|        for entry in entries {
                          ^8
  467|      8|            let entry = entry?;
                                           ^0
  468|      8|            let path = entry.path();
  469|       |
  470|       |            // Only include files (not subdirectories)
  471|      8|            if path.is_file() && self.is_valid_markdown_file(&path) {
                                               ^7   ^7                     ^7
  472|      6|                files.push(path);
  473|      6|            }
                          ^2
  474|       |        }
  475|       |
  476|       |        // Sort alphabetically for predictable order
  477|      4|        files.sort();
  478|       |
  479|      4|        Ok(files)
  480|      4|    }
  481|       |
  482|       |    /// Load markdown content from a string
  483|     81|    pub fn load_content(&mut self, content: &str, title: Option<String>) {
  484|     81|        self.current_content = content.to_string();
  485|     81|        self.raw_buffer = self.current_content.clone();
  486|     81|        self.error_message = None;
  487|     81|        self.nav_request = None; // Reset any pending navigation
  488|       |                                 // Ensure scroll resets to top on new content
  489|     81|        self.pending_scroll_to_element = Some(0);
  490|     81|        self.renderer.clear_table_layout_cache();
  491|       |
  492|     81|        match self.renderer.parse(content) {
  493|     81|            Ok(elements) => {
  494|     81|                self.parsed_elements = elements;
  495|     81|                if let Some(title) = title {
                                          ^80
  496|     80|                    self.title = format!("{APP_TITLE_PREFIX} - {}", title);
  497|     80|                }
                              ^1
  498|       |            }
  499|      0|            Err(e) => {
  500|      0|                self.error_message = Some(format!("Failed to parse markdown: {}", e));
  501|      0|                self.parsed_elements.clear();
  502|      0|            }
  503|       |        }
  504|     81|    }
  505|       |
  506|       |    /// Load markdown content from a file path
  507|     14|    pub fn load_file(&mut self, path: PathBuf, record_history: bool) -> Result<()> {
  508|       |        // Push current state to history before loading new file
  509|     14|        if record_history && !self.current_content.is_empty() {
                                           ^13
  510|     13|            self.push_history();
  511|     13|        }
                      ^1
  512|       |
  513|     14|        let (content, lossy) = Self::read_file_lossy(&path)?;
                           ^13      ^13                                  ^1
  514|     13|        let filename = path
  515|     13|            .file_name()
  516|     13|            .and_then(|n| n.to_str())
  517|     13|            .unwrap_or("Unknown")
  518|     13|            .to_string();
  519|       |
  520|     13|        let base = path.parent().map(|p| p.to_path_buf());
  521|     13|        self.renderer.set_base_dir(base.as_deref());
  522|     13|        self.current_file = Some(path);
  523|     13|        self.load_content(&content, Some(filename));
  524|     13|        if lossy {
  525|      1|            eprintln!("Loaded file with invalid UTF-8; replaced invalid sequences.");
  526|     12|        }
  527|     13|        Ok(())
  528|     14|    }
  529|       |
  530|       |    /// Normalize all line endings to Unix style (\n)
  531|       |    /// Handles Windows (\r\n), Unix (\n), and old Mac (\r) formats
  532|     20|    fn normalize_line_endings(s: &str) -> String {
  533|       |        // Order matters: replace \r\n first (Windows), then remaining \r (old Mac)
  534|     20|        s.replace("\r\n", "\n").replace('\r', "\n")
  535|     20|    }
  536|       |
  537|     14|    fn read_file_lossy(path: &Path) -> Result<(String, bool)> {
  538|     14|        match std::fs::read_to_string(path) {
  539|     12|            Ok(s) => Ok((Self::normalize_line_endings(&s), false)),
  540|      2|            Err(e) if e.kind() == ErrorKind::InvalidData => {
                              ^1                                     ^1
  541|      1|                let bytes = std::fs::read(path)?;
                                                             ^0
  542|      1|                let s = String::from_utf8_lossy(&bytes).into_owned();
  543|      1|                Ok((Self::normalize_line_endings(&s), true))
  544|       |            }
  545|      1|            Err(e) => Err(e.into()),
  546|       |        }
  547|     14|    }
  548|       |
  549|      1|    fn current_window_state(&self) -> Option<WindowState> {
  550|      1|        let pos = self.last_window_pos?;
                                                    ^0
  551|      1|        let size = self.last_window_size?;
                                                      ^0
  552|      1|        Some(WindowState {
  553|      1|            pos,
  554|      1|            size,
  555|      1|            maximized: self.last_window_maximized,
  556|      1|        })
  557|      1|    }
  558|       |
  559|      5|    fn compute_window_adjustment(
  560|      5|        outer_rect: Option<egui::Rect>,
  561|      5|        monitor_size: Option<egui::Vec2>,
  562|      5|    ) -> Option<(egui::Pos2, egui::Vec2)> {
  563|      5|        let outer = outer_rect?;
                          ^2                ^3
  564|      2|        let monitor = monitor_size?;
                                                ^0
  565|       |
  566|      2|        if monitor.x <= 0.0 || monitor.y <= 0.0 {
  567|      0|            return None;
  568|      2|        }
  569|       |
  570|       |        const MIN_WIDTH: f32 = 600.0;
  571|       |        const MIN_HEIGHT: f32 = 400.0;
  572|       |        const OFFSCREEN_TOLERANCE: f32 = 32.0;
  573|       |
  574|      2|        let mut pos = outer.min;
  575|      2|        let mut size = outer.size();
  576|      2|        let mut adjusted = false;
  577|       |
  578|      2|        if !pos.x.is_finite() || !pos.y.is_finite() {
  579|      0|            pos = egui::pos2(0.0, 0.0);
  580|      0|            adjusted = true;
  581|      2|        }
  582|      2|        if !size.x.is_finite() || !size.y.is_finite() {
  583|      0|            size = egui::vec2(MIN_WIDTH, MIN_HEIGHT);
  584|      0|            adjusted = true;
  585|      2|        }
  586|       |
  587|      2|        let available_width = monitor.x.max(MIN_WIDTH);
  588|      2|        let available_height = monitor.y.max(MIN_HEIGHT);
  589|       |
  590|      2|        if size.x < MIN_WIDTH {
  591|      1|            size.x = MIN_WIDTH.min(available_width);
  592|      1|            adjusted = true;
  593|      1|        }
  594|      2|        if size.y < MIN_HEIGHT {
  595|      1|            size.y = MIN_HEIGHT.min(available_height);
  596|      1|            adjusted = true;
  597|      1|        }
  598|      2|        if size.x > available_width {
  599|      0|            size.x = available_width;
  600|      0|            adjusted = true;
  601|      2|        }
  602|      2|        if size.y > available_height {
  603|      0|            size.y = available_height;
  604|      0|            adjusted = true;
  605|      2|        }
  606|       |
  607|      2|        let max_pos = egui::pos2((monitor.x - size.x).max(0.0), (monitor.y - size.y).max(0.0));
  608|       |
  609|      2|        if pos.x <= -0.25 * size.x {
  610|      1|            pos.x = 0.0;
  611|      1|            adjusted = true;
  612|      1|        }
  613|      2|        if pos.y <= -0.25 * size.y {
  614|      1|            pos.y = 0.0;
  615|      1|            adjusted = true;
  616|      1|        }
  617|      2|        if pos.x > max_pos.x + OFFSCREEN_TOLERANCE {
  618|      1|            pos.x = max_pos.x;
  619|      1|            adjusted = true;
  620|      1|        }
  621|      2|        if pos.y > max_pos.y + OFFSCREEN_TOLERANCE {
  622|      1|            pos.y = max_pos.y;
  623|      1|            adjusted = true;
  624|      1|        }
  625|       |
  626|      2|        if adjusted {
  627|      2|            size.x = size.x.max(MIN_WIDTH.min(available_width));
  628|      2|            size.y = size.y.max(MIN_HEIGHT.min(available_height));
  629|      2|            Some((pos, size))
  630|       |        } else {
  631|      0|            None
  632|       |        }
  633|      5|    }
  634|       |
  635|      3|    fn window_state_changed(&self, new_state: &WindowState) -> bool {
  636|      3|        match &self.last_persisted_state {
  637|      2|            Some(prev) => {
  638|      2|                let pos_changed = (prev.pos[0] - new_state.pos[0]).abs() > 0.5
  639|      1|                    || (prev.pos[1] - new_state.pos[1]).abs() > 0.5;
  640|      2|                let size_changed = (prev.size[0] - new_state.size[0]).abs() > 0.5
  641|      2|                    || (prev.size[1] - new_state.size[1]).abs() > 0.5;
  642|      2|                let maximized_changed = prev.maximized != new_state.maximized;
  643|      2|                pos_changed || size_changed || maximized_changed
                                             ^1              ^1
  644|       |            }
  645|      1|            None => true,
  646|       |        }
  647|      3|    }
  648|       |
  649|      4|    fn fold_for_search(input: &str) -> String {
  650|      4|        input.case_fold().nfkc().collect()
  651|      4|    }
  652|       |
  653|       |    /// Push current state to navigation history
  654|     20|    fn push_history(&mut self) {
  655|       |        // Truncate forward history if we're not at the end
  656|     20|        if self.history_index < self.history.len() {
  657|      0|            self.history.truncate(self.history_index);
  658|     20|        }
  659|       |
  660|       |        // Create entry for current state
  661|     20|        let entry = HistoryEntry {
  662|     20|            file_path: self.current_file.clone(),
  663|     20|            title: self.title.clone(),
  664|     20|            content: self.current_content.clone(),
  665|     20|        };
  666|       |
  667|     20|        self.history.push(entry);
  668|       |
  669|       |        // Limit history size
  670|     20|        if self.history.len() > self.max_history {
  671|      0|            self.history.remove(0);
  672|     20|        } else {
  673|     20|            self.history_index = self.history.len();
  674|     20|        }
  675|     20|    }
  676|       |
  677|       |    /// Navigate back in history
  678|      0|    fn navigate_back(&mut self) -> bool {
  679|      0|        if self.history_index > 0 {
  680|      0|            self.history_index -= 1;
  681|      0|            self.restore_from_history();
  682|      0|            true
  683|       |        } else {
  684|      0|            false
  685|       |        }
  686|      0|    }
  687|       |
  688|       |    /// Navigate forward in history
  689|      1|    fn navigate_forward(&mut self) -> bool {
  690|       |        // First try pending files queue
  691|      1|        if let Some(next_file) = self.pending_files.pop_front() {
  692|       |            // Load next file from queue
  693|      1|            if let Err(e) = self.load_file(next_file, true) {
                                     ^0
  694|      0|                self.error_message = Some(format!("Failed to load file: {}", e));
  695|      1|            }
  696|      1|            return true;
  697|      0|        }
  698|       |
  699|       |        // Otherwise use history navigation (existing code)
  700|      0|        if self.history_index < self.history.len() - 1 {
  701|      0|            self.history_index += 1;
  702|      0|            self.restore_from_history();
  703|      0|            true
  704|       |        } else {
  705|      0|            false
  706|       |        }
  707|      1|    }
  708|       |
  709|       |    /// Restore state from history at current index
  710|      0|    fn restore_from_history(&mut self) {
  711|      0|        if let Some(entry) = self.history.get(self.history_index) {
  712|      0|            self.current_file = entry.file_path.clone();
  713|      0|            self.title = entry.title.clone();
  714|      0|            self.current_content = entry.content.clone();
  715|      0|            self.raw_buffer = self.current_content.clone();
  716|       |
  717|       |            // Re-parse content
  718|      0|            match self.renderer.parse(&self.current_content) {
  719|      0|                Ok(elements) => {
  720|      0|                    self.parsed_elements = elements;
  721|      0|                    self.error_message = None;
  722|      0|                }
  723|      0|                Err(e) => {
  724|      0|                    self.error_message = Some(format!("Failed to parse: {}", e));
  725|      0|                }
  726|       |            }
  727|       |
  728|       |            // Set base dir for images
  729|      0|            if let Some(ref path) = self.current_file {
  730|      0|                self.renderer.set_base_dir(path.parent());
  731|      0|            } else {
  732|      0|                self.renderer.set_base_dir(None);
  733|      0|            }
  734|       |
  735|       |            // Scroll to top
  736|      0|            self.pending_scroll_to_element = Some(0);
  737|      0|        }
  738|      0|    }
  739|       |
  740|       |    /// Check if we can navigate back
  741|      1|    fn can_navigate_back(&self) -> bool {
  742|      1|        self.history_index > 0
  743|      1|    }
  744|       |
  745|       |    /// Check if we can navigate forward
  746|      2|    fn can_navigate_forward(&self) -> bool {
  747|      2|        !self.pending_files.is_empty() || self.history_index < self.history.len().saturating_sub(1)
                                                        ^1                   ^1
  748|      2|    }
  749|       |
  750|       |    /// Request a reload of the current file (processed outside of input context)
  751|      1|    fn request_reload(&mut self) {
  752|      1|        if self.current_file.is_some() {
  753|      1|            self.reload_requested = true;
  754|      1|        } else {
  755|      0|            self.error_message = Some("No file loaded to reload".to_string());
  756|      0|        }
  757|      1|    }
  758|       |
  759|       |    /// Reload the currently opened file from disk
  760|      2|    pub fn reload_current_file(&mut self) -> Result<()> {
  761|      2|        let path = if let Some(p) = self.current_file.clone() {
                          ^1                 ^1
  762|      1|            p
  763|       |        } else {
  764|      1|            bail!("No file loaded to reload");
  765|       |        };
  766|      1|        self.load_file(path, false)
  767|      2|    }
  768|       |
  769|       |    /// Load a sample file by name
  770|      7|    pub fn load_sample(&mut self, sample: &SampleFile) {
  771|       |        // Push current state to history before loading sample
  772|      7|        if !self.current_content.is_empty() {
  773|      7|            self.push_history();
  774|      7|        }
                      ^0
  775|       |
  776|      7|        self.current_file = None;
  777|       |        // Samples have no file base-dir
  778|      7|        self.renderer.set_base_dir(None);
  779|      7|        self.load_content(sample.content, Some(sample.title.to_string()));
  780|       |        // Scroll to top for new sample
  781|      7|        self.pending_scroll_to_element = Some(0);
  782|      7|    }
  783|       |
  784|       |    /// Close the current file and return to welcome screen
  785|      3|    pub fn close_current_file(&mut self) {
  786|      3|        self.current_file = None;
  787|      3|        self.renderer.set_base_dir(None);
  788|      3|        if let Some(welcome) = SAMPLE_FILES.iter().find(|f| f.name == "welcome.md") {
  789|      3|            self.load_content(welcome.content, Some("Welcome".to_string()));
  790|      3|            self.pending_scroll_to_element = Some(0);
  791|      3|        } else {
  792|      0|            // Fallback if welcome file is missing
  793|      0|            self.current_content.clear();
  794|      0|            self.parsed_elements.clear();
  795|      0|            self.title = APP_TITLE_PREFIX.to_string();
  796|      0|            self.error_message = None;
  797|      0|        }
  798|      3|    }
  799|       |
  800|       |    /// Open file dialog to select a markdown file
  801|       |    #[cfg(not(test))]
  802|       |    fn open_file_dialog(&mut self) {
  803|       |        if let Some(path) = FileDialog::new()
  804|       |            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
  805|       |            .add_filter("All files", &["*"])
  806|       |            .set_title("Open Markdown File")
  807|       |            .pick_file()
  808|       |        {
  809|       |            if let Err(e) = self.load_file(path, true) {
  810|       |                self.error_message = Some(format!("Failed to open file: {}", e));
  811|       |            }
  812|       |        }
  813|       |    }
  814|       |
  815|       |    #[cfg(test)]
  816|      3|    fn open_file_dialog(&mut self) {
  817|      3|        self.error_message = Some("File dialog disabled in tests".to_string());
  818|      3|    }
  819|       |
  820|       |    /// Toggle between Rendered and Raw view
  821|      2|    fn toggle_view_mode(&mut self, ctx: &Context) {
  822|       |        // If leaving Raw view while editing, capture cursor before switching
  823|      2|        if matches!(self.view_mode, ViewMode::Raw) && self.write_enabled {
                         ^1                                         ^1
  824|      0|            let editor_id = egui::Id::new("raw_editor");
  825|      0|            if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
  826|      0|                if let Some(range) = state.cursor.char_range() {
  827|      0|                    self.raw_cursor = Some(range.primary.index);
  828|      0|                }
  829|      0|            }
  830|      2|        }
  831|      2|        self.view_mode = match self.view_mode {
  832|       |            ViewMode::Rendered => {
  833|      1|                self.raw_focus_requested = true;
  834|      1|                ViewMode::Raw
  835|       |            }
  836|      1|            ViewMode::Raw => ViewMode::Rendered,
  837|       |        };
  838|      2|    }
  839|       |
  840|       |    /// Handle keyboard shortcuts
  841|      7|    fn handle_shortcuts(&mut self, ctx: &Context) {
  842|      7|        ctx.input_mut(|i| {
  843|      7|            let in_raw_edit = matches!(self.view_mode, ViewMode::Raw) && self.write_enabled;
                                            ^4                                         ^3
  844|       |            // Ctrl+O - Open file
  845|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  846|      7|                egui::Modifiers::CTRL,
  847|      7|                egui::Key::O,
  848|      7|            )) {
  849|      1|                self.open_file_dialog();
  850|      6|            }
  851|       |
  852|       |            // Alt-based accelerators for common actions (mnemonics)
  853|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  854|      7|                egui::Modifiers::ALT,
  855|      7|                egui::Key::O,
  856|      7|            )) {
  857|      1|                self.open_file_dialog();
  858|      6|            }
  859|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  860|      7|                egui::Modifiers::ALT,
  861|      7|                egui::Key::W,
  862|      7|            )) {
  863|      1|                self.close_current_file();
  864|      6|            }
  865|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  866|      7|                egui::Modifiers::ALT,
  867|      7|                egui::Key::Q,
  868|      7|            )) {
  869|      0|                ctx.send_viewport_cmd(egui::ViewportCommand::Close);
  870|      7|            }
  871|       |
  872|       |            // Ctrl+Q - Quit application
  873|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  874|      7|                egui::Modifiers::CTRL,
  875|      7|                egui::Key::Q,
  876|      7|            )) {
  877|      0|                ctx.send_viewport_cmd(egui::ViewportCommand::Close);
  878|      7|            }
  879|       |
  880|       |            // Ctrl+W - Close current file
  881|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  882|      7|                egui::Modifiers::CTRL,
  883|      7|                egui::Key::W,
  884|      7|            )) {
  885|      1|                self.close_current_file();
  886|      6|            }
  887|       |
  888|       |            // Ctrl+F - Open search dialog
  889|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  890|      7|                egui::Modifiers::CTRL,
  891|      7|                egui::Key::F,
  892|      7|            )) {
  893|      1|                self.show_search = true;
  894|      1|                if self.last_match_index.is_none() {
  895|      1|                    self.last_match_index = Some(0);
  896|      1|                }
                              ^0
  897|      1|                self.search_focus_requested = true;
  898|      6|            }
  899|       |
  900|       |            // F3 navigation: next / previous
  901|      7|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F3) {
  902|      0|                self.find_next();
  903|      7|            }
  904|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  905|      7|                egui::Modifiers::SHIFT,
  906|      7|                egui::Key::F3,
  907|      7|            )) || i.consume_shortcut(&egui::KeyboardShortcut::new(
  908|      7|                egui::Modifiers::ALT,
  909|      7|                egui::Key::F3,
  910|      7|            )) {
  911|      0|                self.find_previous();
  912|      7|            }
  913|       |
  914|       |            // Ctrl+Plus - Zoom in
  915|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  916|      7|                egui::Modifiers::CTRL,
  917|      7|                egui::Key::Plus,
  918|      7|            )) {
  919|      0|                self.renderer.zoom_in();
  920|      7|            }
  921|       |
  922|       |            // Ctrl+Minus - Zoom out
  923|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  924|      7|                egui::Modifiers::CTRL,
  925|      7|                egui::Key::Minus,
  926|      7|            )) {
  927|      0|                self.renderer.zoom_out();
  928|      7|            }
  929|       |
  930|       |            // Ctrl+0 - Reset zoom
  931|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  932|      7|                egui::Modifiers::CTRL,
  933|      7|                egui::Key::Num0,
  934|      7|            )) {
  935|      0|                self.renderer.reset_zoom();
  936|      7|            }
  937|       |
  938|       |            // Alt+Left - Navigate back
  939|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  940|      7|                egui::Modifiers::ALT,
  941|      7|                egui::Key::ArrowLeft,
  942|      7|            )) {
  943|      0|                self.navigate_back();
  944|      7|            }
  945|       |
  946|       |            // Alt+Right - Navigate forward
  947|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  948|      7|                egui::Modifiers::ALT,
  949|      7|                egui::Key::ArrowRight,
  950|      7|            )) {
  951|      0|                self.navigate_forward();
  952|      7|            }
  953|       |
  954|       |            // Ctrl + Mouse Wheel - Zoom
  955|      7|            if i.modifiers.ctrl {
  956|      1|                let mut total = 0.0f32;
  957|      2|                for ev in &i.events {
                                  ^1
  958|      1|                    if let egui::Event::MouseWheel { delta, .. } = ev {
  959|      1|                        total += delta.y;
  960|      1|                    }
                                  ^0
  961|       |                }
  962|      1|                if total.abs() > 0.0 {
  963|      1|                    if total > 0.0 {
  964|      1|                        self.renderer.zoom_in();
  965|      1|                    } else if total < 0.0 {
                                            ^0
  966|      0|                        self.renderer.zoom_out();
  967|      0|                    }
  968|      0|                }
  969|      6|            }
  970|       |
  971|       |            // Ctrl+R - Toggle raw view
  972|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  973|      7|                egui::Modifiers::CTRL,
  974|      7|                egui::Key::R,
  975|      7|            )) {
  976|      1|                // Defer to avoid acting inside input context
  977|      1|                self.view_toggle_requested = true;
  978|      6|            }
  979|       |            // Ctrl+E - Toggle write mode (deferred)
  980|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  981|      7|                egui::Modifiers::CTRL,
  982|      7|                egui::Key::E,
  983|      7|            )) {
  984|      1|                self.write_toggle_requested = true;
  985|      6|            }
  986|       |            // Ctrl+S - Save document
  987|      7|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  988|      7|                egui::Modifiers::CTRL,
  989|      7|                egui::Key::S,
  990|      7|            )) {
  991|      1|                if let Err(e) = self.save_current_document() {
                                         ^0
  992|      0|                    self.error_message = Some(format!("Failed to save: {}", e));
  993|      1|                }
  994|      6|            }
  995|       |            // Note: No global Alt+R to avoid conflict (File > Reload vs View > Raw)
  996|       |
  997|       |            // F11 - Toggle fullscreen (set flag to handle outside input context)
  998|      7|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F11) {
  999|      1|                self.toggle_fullscreen = true;
 1000|      6|            }
 1001|       |
 1002|       |            // F5 - Reload current file (set flag; actual IO handled outside input context)
 1003|      7|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F5) {
 1004|      1|                self.request_reload();
 1005|      6|            }
 1006|       |
 1007|       |            // Esc - dismiss search dialog if visible
 1008|      7|            if self.show_search && i.consume_key(egui::Modifiers::NONE, egui::Key::Escape) {
                                                 ^2^2                                 ^2
 1009|      0|                self.clear_search_state();
 1010|      0|                self.show_search = false;
 1011|      7|            }
 1012|       |
 1013|       |            // Only consume navigation keys when not editing in raw view
 1014|      7|            if !in_raw_edit {
 1015|      4|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
 1016|      1|                    self.nav_request = Some(NavigationRequest::PageUp);
 1017|      3|                }
 1018|      4|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
 1019|      0|                    self.nav_request = Some(NavigationRequest::PageDown);
 1020|      4|                }
 1021|       |                // Home - Go to top of document
 1022|      4|                if i.consume_key(egui::Modifiers::NONE, egui::Key::Home) {
 1023|      0|                    self.nav_request = Some(NavigationRequest::Top);
 1024|      4|                }
 1025|       |
 1026|       |                // End - Go to bottom of document
 1027|      4|                if i.consume_key(egui::Modifiers::NONE, egui::Key::End) {
 1028|      0|                    self.nav_request = Some(NavigationRequest::Bottom);
 1029|      4|                }
 1030|       |
 1031|       |                // Arrow Up - Fine scroll up
 1032|      4|                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowUp) {
 1033|      0|                    self.nav_request = Some(NavigationRequest::ScrollUp);
 1034|      4|                }
 1035|       |
 1036|       |                // Arrow Down - Fine scroll down
 1037|      4|                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowDown) {
 1038|      1|                    self.nav_request = Some(NavigationRequest::ScrollDown);
 1039|      3|                }
 1040|       |            } else {
 1041|       |                // In raw edit mode: implement PageUp/PageDown by moving caret by ~a page of lines
 1042|       |                const PAGE_LINES: i32 = 24; // match desired_rows for the editor
 1043|      3|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
 1044|      0|                    self.pending_raw_cursor_line_move = Some(-PAGE_LINES);
 1045|      0|                    self.raw_focus_requested = true;
 1046|      3|                }
 1047|      3|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
 1048|      1|                    self.pending_raw_cursor_line_move = Some(PAGE_LINES);
 1049|      1|                    self.raw_focus_requested = true;
 1050|      2|                }
 1051|       |            }
 1052|      7|        });
 1053|      7|    }
 1054|       |
 1055|       |    /// Render the menu bar
 1056|      3|    fn render_menu_bar(&mut self, ctx: &Context) {
 1057|      3|        TopBottomPanel::top("menu_bar").show(ctx, |ui| {
 1058|      3|            let alt_pressed = ui.input(|i| i.modifiers.alt);
 1059|      3|            let menu_text_color = if ui.visuals().dark_mode {
 1060|      3|                Color32::WHITE
 1061|       |            } else {
 1062|      0|                Color32::BLACK
 1063|       |            };
 1064|      3|            menu::bar(ui, |ui| {
 1065|      3|                ui.menu_button(
 1066|      3|                    Self::menu_text_with_mnemonic(None, "File", 'F', alt_pressed, menu_text_color),
 1067|      0|                    |ui| {
 1068|      0|                        self.render_file_menu(ui, alt_pressed, menu_text_color);
 1069|      0|                    },
 1070|       |                );
 1071|       |
 1072|      3|                ui.menu_button(
 1073|      3|                    Self::menu_text_with_mnemonic(None, "View", 'V', alt_pressed, menu_text_color),
 1074|      0|                    |ui| {
 1075|      0|                        self.render_view_menu(ui, ctx, alt_pressed, menu_text_color);
 1076|      0|                    },
 1077|       |                );
 1078|       |
 1079|      3|                ui.menu_button("Help", |ui| {
                                                          ^0
 1080|      0|                    self.render_help_menu(ui);
 1081|      0|                });
 1082|      3|            });
 1083|      3|        });
 1084|       |
 1085|       |        // No programmatic overlay menus; rely on pointer to open egui menus.
 1086|      3|    }
 1087|       |
 1088|      1|    fn render_file_menu(
 1089|      1|        &mut self,
 1090|      1|        ui: &mut egui::Ui,
 1091|      1|        alt_pressed: bool,
 1092|      1|        menu_text_color: Color32,
 1093|      1|    ) {
 1094|      1|        ui.horizontal(|ui| {
 1095|      1|            if ui
 1096|      1|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1097|      1|                    None,
 1098|      1|                    "Open...",
 1099|      1|                    'O',
 1100|      1|                    alt_pressed,
 1101|      1|                    menu_text_color,
 1102|      1|                )))
 1103|      1|                .clicked()
 1104|      0|            {
 1105|      0|                self.open_file_dialog();
 1106|      0|                ui.close_menu();
 1107|      1|            }
 1108|      1|            ui.with_layout(
 1109|      1|                egui::Layout::right_to_left(egui::Align::Center),
 1110|      1|                |ui| {
 1111|      1|                    ui.label(RichText::new("Ctrl+O").color(menu_text_color));
 1112|      1|                },
 1113|       |            );
 1114|      1|        });
 1115|       |
 1116|      1|        ui.horizontal(|ui| {
 1117|      1|            let enabled = !self.current_content.is_empty();
 1118|      1|            let button = ui.add_enabled(
 1119|      1|                enabled,
 1120|      1|                egui::Button::new(Self::menu_text_with_mnemonic(
 1121|      1|                    None,
 1122|      1|                    "Save",
 1123|       |                    'S',
 1124|      1|                    alt_pressed,
 1125|      1|                    menu_text_color,
 1126|       |                )),
 1127|       |            );
 1128|      1|            if button.clicked() {
 1129|      0|                if let Err(e) = self.save_current_document() {
 1130|      0|                    self.error_message = Some(format!("Failed to save: {}", e));
 1131|      0|                }
 1132|      0|                ui.close_menu();
 1133|      1|            }
 1134|      1|            ui.with_layout(
 1135|      1|                egui::Layout::right_to_left(egui::Align::Center),
 1136|      1|                |ui| {
 1137|      1|                    ui.label(RichText::new("Ctrl+S").color(menu_text_color));
 1138|      1|                },
 1139|       |            );
 1140|      1|        });
 1141|       |
 1142|      1|        ui.horizontal(|ui| {
 1143|      1|            if ui
 1144|      1|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1145|      1|                    None,
 1146|      1|                    "Close",
 1147|      1|                    'C',
 1148|      1|                    alt_pressed,
 1149|      1|                    menu_text_color,
 1150|      1|                )))
 1151|      1|                .clicked()
 1152|      0|            {
 1153|      0|                self.close_current_file();
 1154|      0|                ui.close_menu();
 1155|      1|            }
 1156|      1|            ui.with_layout(
 1157|      1|                egui::Layout::right_to_left(egui::Align::Center),
 1158|      1|                |ui| {
 1159|      1|                    ui.label(RichText::new("Ctrl+W").color(menu_text_color));
 1160|      1|                },
 1161|       |            );
 1162|      1|        });
 1163|       |
 1164|      1|        ui.horizontal(|ui| {
 1165|      1|            let enabled = self.current_file.is_some();
 1166|      1|            let button = ui.add_enabled(
 1167|      1|                enabled,
 1168|      1|                egui::Button::new(Self::menu_text_with_mnemonic(
 1169|      1|                    None,
 1170|      1|                    "Reload",
 1171|       |                    'R',
 1172|      1|                    alt_pressed,
 1173|      1|                    menu_text_color,
 1174|       |                )),
 1175|       |            );
 1176|      1|            if button.clicked() {
 1177|      0|                self.request_reload();
 1178|      0|                ui.close_menu();
 1179|      1|            }
 1180|      1|            ui.with_layout(
 1181|      1|                egui::Layout::right_to_left(egui::Align::Center),
 1182|      1|                |ui| {
 1183|      1|                    ui.label(RichText::new("F5").color(menu_text_color));
 1184|      1|                },
 1185|       |            );
 1186|      1|        });
 1187|       |
 1188|      1|        ui.horizontal(|ui| {
 1189|      1|            if ui
 1190|      1|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1191|      1|                    None,
 1192|      1|                    "Find...",
 1193|      1|                    'F',
 1194|      1|                    alt_pressed,
 1195|      1|                    menu_text_color,
 1196|      1|                )))
 1197|      1|                .clicked()
 1198|      0|            {
 1199|      0|                self.show_search = true;
 1200|      0|                self.search_focus_requested = true;
 1201|      0|                ui.close_menu();
 1202|      1|            }
 1203|      1|            ui.with_layout(
 1204|      1|                egui::Layout::right_to_left(egui::Align::Center),
 1205|      1|                |ui| {
 1206|      1|                    ui.label(RichText::new("Ctrl+F").color(menu_text_color));
 1207|      1|                },
 1208|       |            );
 1209|      1|        });
 1210|       |
 1211|      1|        ui.separator();
 1212|       |
 1213|      1|        ui.menu_button(
 1214|      1|            Self::menu_text_with_mnemonic(None, "Samples", 'S', alt_pressed, menu_text_color),
 1215|      0|            |ui| {
 1216|      0|                for sample in SAMPLE_FILES {
 1217|      0|                    if ui.button(sample.title).clicked() {
 1218|      0|                        self.load_sample(sample);
 1219|      0|                        ui.close_menu();
 1220|      0|                    }
 1221|       |                }
 1222|      0|            },
 1223|       |        );
 1224|      1|    }
 1225|       |
 1226|      1|    fn render_view_menu(
 1227|      1|        &mut self,
 1228|      1|        ui: &mut egui::Ui,
 1229|      1|        ctx: &Context,
 1230|      1|        alt_pressed: bool,
 1231|      1|        menu_text_color: Color32,
 1232|      1|    ) {
 1233|      1|        ui.horizontal(|ui| {
 1234|      1|            let enabled = self.can_navigate_back();
 1235|      1|            if ui
 1236|      1|                .add_enabled(enabled, egui::Button::new("<- Back"))
 1237|      1|                .clicked()
 1238|      0|            {
 1239|      0|                self.navigate_back();
 1240|      0|                ui.close_menu();
 1241|      1|            }
 1242|      1|            ui.with_layout(
 1243|      1|                egui::Layout::right_to_left(egui::Align::Center),
 1244|      1|                |ui| {
 1245|      1|                    ui.label(RichText::new("Alt+Left").color(menu_text_color));
 1246|      1|                },
 1247|       |            );
 1248|      1|        });
 1249|       |
 1250|      1|        ui.horizontal(|ui| {
 1251|      1|            let enabled = self.can_navigate_forward();
 1252|      1|            if ui
 1253|      1|                .add_enabled(enabled, egui::Button::new("Forward ->"))
 1254|      1|                .clicked()
 1255|      0|            {
 1256|      0|                self.navigate_forward();
 1257|      0|                ui.close_menu();
 1258|      1|            }
 1259|      1|            ui.with_layout(
 1260|      1|                egui::Layout::right_to_left(egui::Align::Center),
 1261|      1|                |ui| {
 1262|      1|                    ui.label(RichText::new("Alt+Right").color(menu_text_color));
 1263|      1|                },
 1264|       |            );
 1265|      1|        });
 1266|       |
 1267|      1|        ui.separator();
 1268|       |
 1269|      1|        ui.horizontal(|ui| {
 1270|      1|            let selected = matches!(self.view_mode, ViewMode::Raw);
 1271|      1|            if ui
 1272|      1|                .add(egui::SelectableLabel::new(
 1273|      1|                    selected,
 1274|      1|                    Self::menu_text_with_mnemonic(
 1275|      1|                        None,
 1276|      1|                        "Raw Markdown",
 1277|      1|                        'R',
 1278|      1|                        alt_pressed,
 1279|      1|                        menu_text_color,
 1280|      1|                    ),
 1281|      1|                ))
 1282|      1|                .clicked()
 1283|      0|            {
 1284|      0|                self.toggle_view_mode(ctx);
 1285|      0|                ui.close_menu();
 1286|      1|            }
 1287|      1|            ui.with_layout(
 1288|      1|                egui::Layout::right_to_left(egui::Align::Center),
 1289|      1|                |ui| {
 1290|      1|                    ui.label(RichText::new("Ctrl+R").color(menu_text_color));
 1291|      1|                },
 1292|       |            );
 1293|      1|        });
 1294|       |
 1295|      1|        ui.horizontal(|ui| {
 1296|      1|            let selected = self.write_enabled;
 1297|      1|            if ui
 1298|      1|                .add(egui::SelectableLabel::new(
 1299|      1|                    selected,
 1300|      1|                    Self::menu_text_with_mnemonic(
 1301|      1|                        None,
 1302|      1|                        "Write Mode",
 1303|      1|                        'W',
 1304|      1|                        alt_pressed,
 1305|      1|                        menu_text_color,
 1306|      1|                    ),
 1307|      1|                ))
 1308|      1|                .clicked()
 1309|      0|            {
 1310|      0|                self.toggle_write_mode(ctx);
 1311|      0|                ui.close_menu();
 1312|      1|            }
 1313|      1|            ui.with_layout(
 1314|      1|                egui::Layout::right_to_left(egui::Align::Center),
 1315|      1|                |ui| {
 1316|      1|                    ui.label(RichText::new("Ctrl+E").color(menu_text_color));
 1317|      1|                },
 1318|       |            );
 1319|      1|        });
 1320|       |
 1321|      1|        ui.horizontal(|ui| {
 1322|      1|            if ui.selectable_label(self.wrap_raw, "Wrap Raw Lines").clicked() {
 1323|      0|                self.wrap_raw = !self.wrap_raw;
 1324|      1|            }
 1325|      1|        });
 1326|       |
 1327|      1|        ui.horizontal(|ui| {
 1328|      1|            let label = if self.table_wrap_overhaul_enabled {
 1329|      1|                "Table Wrap Overhaul (new)"
 1330|       |            } else {
 1331|      0|                "Table Wrap Overhaul (legacy)"
 1332|       |            };
 1333|      1|            if ui
 1334|      1|                .selectable_label(self.table_wrap_overhaul_enabled, label)
 1335|      1|                .clicked()
 1336|      0|            {
 1337|      0|                self.toggle_table_wrap_overhaul();
 1338|      0|                ui.close_menu();
 1339|      1|            }
 1340|      1|        });
 1341|       |
 1342|      1|        ui.horizontal(|ui| {
 1343|      1|            if ui.button("Zoom In").clicked() {
 1344|      0|                self.renderer.zoom_in();
 1345|      0|                ui.close_menu();
 1346|      1|            }
 1347|      1|            ui.with_layout(
 1348|      1|                egui::Layout::right_to_left(egui::Align::Center),
 1349|      1|                |ui| {
 1350|      1|                    ui.label(RichText::new("Ctrl++").color(menu_text_color));
 1351|      1|                },
 1352|       |            );
 1353|      1|        });
 1354|       |
 1355|      1|        ui.horizontal(|ui| {
 1356|      1|            if ui.button("Zoom Out").clicked() {
 1357|      0|                self.renderer.zoom_out();
 1358|      0|                ui.close_menu();
 1359|      1|            }
 1360|      1|            ui.with_layout(
 1361|      1|                egui::Layout::right_to_left(egui::Align::Center),
 1362|      1|                |ui| {
 1363|      1|                    ui.label(RichText::new("Ctrl+-").color(menu_text_color));
 1364|      1|                },
 1365|       |            );
 1366|      1|        });
 1367|       |
 1368|      1|        ui.horizontal(|ui| {
 1369|      1|            if ui.button("Reset Zoom").clicked() {
 1370|      0|                self.renderer.reset_zoom();
 1371|      0|                ui.close_menu();
 1372|      1|            }
 1373|      1|            ui.with_layout(
 1374|      1|                egui::Layout::right_to_left(egui::Align::Center),
 1375|      1|                |ui| {
 1376|      1|                    ui.label(RichText::new("Ctrl+0").color(menu_text_color));
 1377|      1|                },
 1378|       |            );
 1379|      1|        });
 1380|       |
 1381|      1|        ui.separator();
 1382|       |
 1383|      1|        ui.horizontal(|ui| {
 1384|      1|            if ui.button("Toggle Fullscreen").clicked() {
 1385|      0|                let is_fullscreen = ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
 1386|      0|                ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(!is_fullscreen));
 1387|      0|                ui.close_menu();
 1388|      1|            }
 1389|      1|            ui.with_layout(
 1390|      1|                egui::Layout::right_to_left(egui::Align::Center),
 1391|      1|                |ui| {
 1392|      1|                    ui.label(RichText::new("F11").color(menu_text_color));
 1393|      1|                },
 1394|       |            );
 1395|      1|        });
 1396|      1|    }
 1397|       |
 1398|      1|    fn render_help_menu(&mut self, ui: &mut egui::Ui) {
 1399|      1|        if ui.button("Usage Instructions").clicked() {
 1400|      0|            if let Some(usage) = SAMPLE_FILES.iter().find(|f| f.name == "usage.md") {
 1401|      0|                self.load_sample(usage);
 1402|      0|            }
 1403|      0|            ui.close_menu();
 1404|      1|        }
 1405|       |
 1406|      1|        if ui.button("About").clicked() {
 1407|      0|            if let Some(welcome) = SAMPLE_FILES.iter().find(|f| f.name == "welcome.md") {
 1408|      0|                self.load_sample(welcome);
 1409|      0|            }
 1410|      0|            ui.close_menu();
 1411|      1|        }
 1412|      1|    }
 1413|       |
 1414|      1|    fn render_main_context_menu(&mut self, ui: &mut egui::Ui) {
 1415|      1|        ui.label("Select text, then use Ctrl+C to copy");
 1416|      1|        ui.separator();
 1417|       |
 1418|      1|        if ui.button("Copy All Text").clicked() {
 1419|      0|            let all_text = MarkdownRenderer::elements_to_plain_text(&self.parsed_elements);
 1420|      0|            ui.ctx().copy_text(all_text);
 1421|      0|            ui.close_menu();
 1422|      1|        }
 1423|       |
 1424|      1|        if ui.button("Copy as Markdown").clicked() {
 1425|      0|            ui.ctx().copy_text(self.current_content.clone());
 1426|      0|            ui.close_menu();
 1427|      1|        }
 1428|       |
 1429|      1|        ui.separator();
 1430|       |
 1431|      1|        if ui.button("Go to Top").clicked() {
 1432|      0|            self.nav_request = Some(NavigationRequest::Top);
 1433|      0|            ui.close_menu();
 1434|      1|        }
 1435|       |
 1436|      1|        if ui.button("Go to Bottom").clicked() {
 1437|      0|            self.nav_request = Some(NavigationRequest::Bottom);
 1438|      0|            ui.close_menu();
 1439|      1|        }
 1440|      1|    }
 1441|       |    /// Render the status bar
 1442|      4|    fn render_status_bar(&self, ctx: &Context) {
 1443|      4|        TopBottomPanel::bottom("status_bar").show(ctx, |ui| {
 1444|      4|            ui.horizontal(|ui| {
 1445|       |                // Current file info
 1446|      4|                if let Some(path) = &self.current_file {
                                          ^0
 1447|      0|                    ui.label(format!("File: {}", path.display()));
 1448|      4|                } else if !self.parsed_elements.is_empty() {
 1449|      4|                    ui.label("Sample file");
 1450|      4|                } else {
 1451|      0|                    ui.label("No file loaded");
 1452|      0|                }
 1453|       |
 1454|       |                // Show pending file count if files are queued
 1455|      4|                if !self.pending_files.is_empty() {
 1456|      1|                    ui.separator();
 1457|      1|                    ui.label(
 1458|      1|                        RichText::new(format!("{} files in queue", self.pending_files.len()))
 1459|      1|                            .color(egui::Color32::from_rgb(100, 150, 255)),
 1460|      1|                    );
 1461|      1|
 1462|      1|                    ui.label(
 1463|      1|                        RichText::new("(Alt+Right for next)")
 1464|      1|                            .color(egui::Color32::GRAY)
 1465|      1|                            .italics(),
 1466|      1|                    );
 1467|      3|                }
 1468|       |
 1469|      4|                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1470|       |                    // Document stats
 1471|      4|                    let element_count = self.parsed_elements.len();
 1472|      4|                    let char_count = self.current_content.len();
 1473|      4|                    let mode = match self.view_mode {
 1474|      2|                        ViewMode::Rendered => "Rendered",
 1475|      2|                        ViewMode::Raw => "Raw",
 1476|       |                    };
 1477|      4|                    let status = format!(
 1478|      4|                        "Mode: {} | Elements: {} | Characters: {}",
 1479|       |                        mode, element_count, char_count
 1480|       |                    );
 1481|      4|                    ui.label(status).on_hover_ui(|ui| {
                                                                    ^0
 1482|      0|                        ui.label(format!("Version: {}", BUILD_VERSION));
 1483|      0|                        ui.label(format!("Built: {}", BUILD_TIMESTAMP));
 1484|      0|                    });
 1485|       |
 1486|      4|                    let wrap_label = if self.table_wrap_overhaul_enabled {
 1487|      4|                        RichText::new("Wrap: Overhaul").color(Color32::from_rgb(120, 200, 255))
 1488|       |                    } else {
 1489|      0|                        RichText::new("Wrap: Legacy").color(Color32::from_rgb(140, 140, 140))
 1490|       |                    };
 1491|      4|                    let cache_tip = if self.table_wrap_overhaul_enabled {
 1492|      4|                        let (hits, misses) = self.renderer.table_layout_cache_stats();
 1493|      4|                        let (rendered_rows, total_rows) = self.renderer.table_render_stats();
 1494|      4|                        let row_info = if total_rows > 0 {
 1495|      0|                            format!("
 1496|      0|Rows rendered this frame: {} / {}", rendered_rows, total_rows)
 1497|       |                        } else {
 1498|      4|                            String::new()
 1499|       |                        };
 1500|      4|                        format!(
 1501|      4|                            "Table layout cache: {} hits / {} misses{}",
 1502|       |                            hits, misses, row_info
 1503|       |                        )
 1504|       |                    } else {
 1505|      0|                        "Legacy table renderer active. Toggle via View > Table Wrap Overhaul or CLI flag.".to_string()
 1506|       |                    };
 1507|      4|                    ui.label(wrap_label).on_hover_text(cache_tip);
 1508|      4|                });
 1509|      4|            });
 1510|      4|        });
 1511|      4|    }
 1512|       |    /// Handle drag-drop events from egui
 1513|      4|    fn handle_drag_drop_events(&mut self, ctx: &Context) {
 1514|      4|        ctx.input(|i| {
 1515|       |            // Check if files are being hovered
 1516|      4|            self.drag_hover = !i.raw.hovered_files.is_empty();
 1517|       |
 1518|       |            // Check if files were dropped
 1519|      4|            if !i.raw.dropped_files.is_empty() {
 1520|      1|                let paths: Vec<PathBuf> = i
 1521|      1|                    .raw
 1522|      1|                    .dropped_files
 1523|      1|                    .iter()
 1524|      1|                    .filter_map(|f| f.path.clone())
 1525|      1|                    .collect();
 1526|       |
 1527|      1|                self.handle_file_drop(paths);
 1528|      3|            }
 1529|      4|        });
 1530|      4|    }
 1531|       |
 1532|       |    /// Render drag-and-drop overlay when files are hovered
 1533|      4|    fn render_drag_overlay(&self, ctx: &Context) {
 1534|      4|        if !self.drag_hover {
 1535|      3|            return;
 1536|      1|        }
 1537|       |
 1538|       |        // Full-screen overlay
 1539|      1|        egui::Area::new(egui::Id::new("drag_overlay"))
 1540|      1|            .fixed_pos(egui::pos2(0.0, 0.0))
 1541|      1|            .order(egui::Order::Foreground)
 1542|      1|            .show(ctx, |ui| {
 1543|      1|                let screen_rect = ctx.screen_rect();
 1544|       |
 1545|       |                // Semi-transparent dark background
 1546|      1|                ui.painter()
 1547|      1|                    .rect_filled(screen_rect, 0.0, egui::Color32::from_black_alpha(180));
 1548|       |
 1549|       |                // Dashed border effect using rounded rect with stroke
 1550|      1|                let border_rect = screen_rect.shrink(20.0);
 1551|      1|                let border_color = egui::Color32::from_rgb(100, 150, 255);
 1552|       |
 1553|       |                // Draw border
 1554|      1|                ui.painter()
 1555|      1|                    .rect_stroke(border_rect, 8.0, egui::Stroke::new(4.0, border_color));
 1556|       |
 1557|       |                // Center text
 1558|      1|                ui.allocate_ui_at_rect(screen_rect, |ui| {
 1559|      1|                    ui.vertical_centered(|ui| {
 1560|      1|                        ui.add_space(screen_rect.height() / 2.0 - 80.0);
 1561|       |
 1562|       |                        // Main message
 1563|      1|                        ui.label(
 1564|      1|                            RichText::new("Drop files to open")
 1565|      1|                                .size(36.0)
 1566|      1|                                .color(egui::Color32::WHITE)
 1567|      1|                                .strong(),
 1568|       |                        );
 1569|       |
 1570|      1|                        ui.add_space(20.0);
 1571|       |
 1572|       |                        // Supported formats
 1573|      1|                        ui.label(
 1574|      1|                            RichText::new("Supported: .md, .markdown, .mdown, .mkd, .txt")
 1575|      1|                                .size(18.0)
 1576|      1|                                .color(egui::Color32::LIGHT_GRAY),
 1577|       |                        );
 1578|       |
 1579|      1|                        ui.add_space(10.0);
 1580|       |
 1581|       |                        // Additional hint
 1582|      1|                        ui.label(
 1583|      1|                            RichText::new("Drop multiple files to open them in sequence")
 1584|      1|                                .size(14.0)
 1585|      1|                                .color(egui::Color32::from_rgb(150, 150, 150))
 1586|      1|                                .italics(),
 1587|       |                        );
 1588|      1|                    });
 1589|      1|                });
 1590|      1|            });
 1591|      4|    }
 1592|       |}
 1593|       |
 1594|       |impl eframe::App for MarkdownViewerApp {
 1595|       |    /// Update function called every frame
 1596|      0|    fn update(&mut self, ctx: &Context, _frame: &mut eframe::Frame) {
 1597|      0|        self.update_inner(ctx);
 1598|      0|    }
 1599|       |
 1600|      0|    fn auto_save_interval(&self) -> std::time::Duration {
 1601|      0|        std::time::Duration::from_secs(30)
 1602|      0|    }
 1603|       |
 1604|      0|    fn save(&mut self, _storage: &mut dyn eframe::Storage) {
 1605|       |        // Persist window position and size on app save/exit
 1606|      0|        self.persist_window_state();
 1607|      0|    }
 1608|       |}
 1609|       |
 1610|       |impl MarkdownViewerApp {
 1611|      3|    fn update_inner(&mut self, ctx: &Context) {
 1612|       |        // Handle drag-drop events
 1613|      3|        self.handle_drag_drop_events(ctx);
 1614|       |
 1615|       |        // Handle keyboard shortcuts
 1616|      3|        self.handle_shortcuts(ctx);
 1617|       |
 1618|       |        // Keep native window title in sync with the current document
 1619|      3|        ctx.send_viewport_cmd(egui::ViewportCommand::Title(self.title.clone()));
 1620|       |
 1621|      3|        let (monitor_size, outer_rect, inner_rect, is_fullscreen, is_maximized) = ctx.input(|i| {
 1622|      3|            let vp = i.viewport();
 1623|      3|            (
 1624|      3|                vp.monitor_size,
 1625|      3|                vp.outer_rect,
 1626|      3|                vp.inner_rect,
 1627|      3|                vp.fullscreen.unwrap_or(false),
 1628|      3|                vp.maximized.unwrap_or(false),
 1629|      3|            )
 1630|      3|        });
 1631|       |
 1632|      3|        let mut adjusted = false;
 1633|      3|        if !is_fullscreen {
 1634|      3|            if let Some((pos, size)) = Self::compute_window_adjustment(outer_rect, monitor_size) {
                                       ^0   ^0
 1635|      0|                adjusted = true;
 1636|      0|                ctx.send_viewport_cmd(egui::ViewportCommand::OuterPosition(pos));
 1637|      0|                ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(size));
 1638|      0|                self.last_window_pos = Some([pos.x, pos.y]);
 1639|      0|                self.last_window_size = Some([size.x, size.y]);
 1640|      3|            }
 1641|      0|        }
 1642|       |
 1643|      3|        if !adjusted {
 1644|      3|            if let Some(outer) = outer_rect {
                                      ^0
 1645|      0|                self.last_window_pos = Some([outer.left(), outer.top()]);
 1646|      3|            }
 1647|      3|            if !is_fullscreen {
 1648|      3|                if let Some(inner) = inner_rect {
                                          ^0
 1649|      0|                    self.last_window_size = Some([inner.width(), inner.height()]);
 1650|      3|                }
 1651|      0|            }
 1652|      0|        }
 1653|      3|        self.last_window_maximized = is_maximized;
 1654|       |
 1655|       |        // Opportunistically persist window state if it changed, throttled to once per second
 1656|      3|        if self.should_persist_window_state() {
 1657|      0|            self.persist_window_state();
 1658|      0|            self.last_persist_instant = std::time::Instant::now();
 1659|      3|        }
 1660|       |
 1661|       |        // Handle fullscreen toggle outside input context to avoid deadlocks
 1662|      3|        if self.toggle_fullscreen {
 1663|      0|            self.toggle_fullscreen = false;
 1664|      0|            let current_fullscreen = ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
 1665|      0|            ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(!current_fullscreen));
 1666|      3|        }
 1667|       |
 1668|       |        // Handle deferred view toggle outside of input context
 1669|      3|        if self.view_toggle_requested {
 1670|      0|            self.view_toggle_requested = false;
 1671|      0|            self.toggle_view_mode(ctx);
 1672|      3|        }
 1673|       |
 1674|       |        // Handle deferred write toggle outside of input context
 1675|      3|        if self.write_toggle_requested {
 1676|      0|            self.write_toggle_requested = false;
 1677|      0|            self.toggle_write_mode(ctx);
 1678|      3|        }
 1679|       |
 1680|       |        // Handle deferred caret movement for raw editor
 1681|      3|        if let Some(delta) = self.pending_raw_cursor_line_move.take() {
                                  ^1
 1682|      1|            self.move_raw_cursor_lines(ctx, delta);
 1683|      2|        }
 1684|       |
 1685|       |        // Handle reload request outside input context to avoid blocking within input handling
 1686|      3|        if self.reload_requested {
 1687|      0|            self.reload_requested = false;
 1688|      0|            if let Err(e) = self.reload_current_file() {
 1689|      0|                self.error_message = Some(format!("Failed to reload file: {}", e));
 1690|      0|            }
 1691|      3|        }
 1692|       |
 1693|       |        // Render menu bar
 1694|      3|        self.render_menu_bar(ctx);
 1695|       |
 1696|       |        // Main content area
 1697|      3|        let central_response = CentralPanel::default().show(ctx, |ui| {
 1698|       |            // Show error message if any
 1699|      3|            if let Some(ref error) = self.error_message {
                                      ^0
 1700|      0|                ui.colored_label(Color32::RED, format!("Error: {}", error));
 1701|      0|                ui.separator();
 1702|      3|            }
 1703|       |
 1704|       |            // Render markdown content in a scrollable area
 1705|      3|            let scroll_delta = if let Some(nav) = self.nav_request.take() {
                                                         ^1
 1706|      1|                match nav {
 1707|       |                    NavigationRequest::Top => {
 1708|       |                        // Scroll to top: use a large POSITIVE delta to reach the beginning
 1709|      1|                        egui::Vec2::new(0.0, 100000.0)
 1710|       |                    }
 1711|       |                    NavigationRequest::Bottom => {
 1712|       |                        // Scroll to bottom: use a large NEGATIVE delta to reach the end
 1713|      0|                        egui::Vec2::new(0.0, -100000.0)
 1714|       |                    }
 1715|       |                    NavigationRequest::PageUp => {
 1716|      0|                        let viewport_height = ui.available_height();
 1717|      0|                        let page_size = viewport_height * 0.8;
 1718|      0|                        egui::Vec2::new(0.0, page_size) // Positive = scroll up (show earlier content)
 1719|       |                    }
 1720|       |                    NavigationRequest::PageDown => {
 1721|      0|                        let viewport_height = ui.available_height();
 1722|      0|                        let page_size = viewport_height * 0.8;
 1723|      0|                        egui::Vec2::new(0.0, -page_size) // Negative = scroll down (show later content)
 1724|       |                    }
 1725|       |                    NavigationRequest::ScrollUp => {
 1726|      0|                        egui::Vec2::new(0.0, 40.0) // Positive = fine scroll up
 1727|       |                    }
 1728|       |                    NavigationRequest::ScrollDown => {
 1729|      0|                        egui::Vec2::new(0.0, -40.0) // Negative = fine scroll down
 1730|       |                    }
 1731|       |                }
 1732|       |            } else {
 1733|      2|                egui::Vec2::ZERO
 1734|       |            };
 1735|       |
 1736|      3|            egui::ScrollArea::vertical()
 1737|      3|                .id_source(self.scroll_area_id)
 1738|      3|                .auto_shrink([false, false])
 1739|      3|                .scroll_bar_visibility(egui::scroll_area::ScrollBarVisibility::VisibleWhenNeeded)
 1740|      3|                .show(ui, |ui| {
 1741|       |                    // Apply scroll delta if we have navigation
 1742|      3|                    if scroll_delta != egui::Vec2::ZERO {
 1743|      1|                        ui.scroll_with_delta(scroll_delta);
 1744|      2|                    }
 1745|       |
 1746|      3|                    ui.spacing_mut().item_spacing.y = 8.0;
 1747|       |
 1748|      3|                    if self.parsed_elements.is_empty() && self.error_message.is_none() {
                                                                        ^0                 ^0
 1749|      0|                        ui.vertical_centered(|ui| {
 1750|      0|                            ui.add_space(50.0);
 1751|      0|                            ui.label(RichText::new("Welcome to MarkdownView").size(24.0).strong());
 1752|      0|                            ui.add_space(20.0);
 1753|      0|                            ui.label("Open a markdown file or select a sample to get started.");
 1754|      0|                            ui.add_space(20.0);
 1755|       |
 1756|      0|                            if ui.button("Open File").clicked() {
 1757|      0|                                self.open_file_dialog();
 1758|      0|                            }
 1759|      0|                        });
 1760|       |                    } else {
 1761|      3|                        match self.view_mode {
 1762|       |                            ViewMode::Rendered => {
 1763|       |                                // Update highlight phrase: prefer live input, else last executed
 1764|      1|                                if self.show_search && !self.search_query.is_empty() {
 1765|      1|                                    self.renderer.set_highlight_phrase(Some(&self.search_query));
 1766|      1|                                } else if !self.last_query.is_empty() {
                                                        ^0
 1767|      0|                                    self.renderer.set_highlight_phrase(Some(&self.last_query));
 1768|      0|                                } else {
 1769|      0|                                    self.renderer.set_highlight_phrase(None);
 1770|      0|                                }
 1771|       |
 1772|      1|                                self.renderer.render_to_ui(ui, &self.parsed_elements);
 1773|       |                                // If a header anchor was clicked, scroll to it
 1774|      1|                                if let Some(anchor) = self.renderer.take_pending_anchor() {
                                                          ^0
 1775|      0|                                    if let Some(rect) = self.renderer.header_rect_for(&anchor) {
 1776|      0|                                        // Align target header to the top of the visible area
 1777|      0|                                        ui.scroll_to_rect(rect, Some(egui::Align::Min));
 1778|      0|                                    }
 1779|      1|                                }
 1780|       |                                // If a search requested a scroll, align to top of visible area
 1781|      1|                                if let Some(idx) = self.pending_scroll_to_element.take() {
 1782|      1|                                    if let Some(rect) = self.renderer.element_rect_at(idx) {
 1783|      1|                                        ui.scroll_to_rect(rect, Some(egui::Align::Min));
 1784|      1|                                    }
                                                  ^0
 1785|      0|                                }
 1786|       |                            }
 1787|       |                            ViewMode::Raw => {
 1788|       |                                // Raw markdown view; editable when write mode is enabled
 1789|      2|                                if self.write_enabled {
 1790|      2|                                    let editor_id = egui::Id::new("raw_editor");
 1791|       |                                    // If we have a remembered cursor, restore it (clamped)
 1792|      2|                                    if let Some(mut idx) = self.raw_cursor.take() {
 1793|      2|                                        idx = idx.min(self.raw_buffer.len());
 1794|      0|                                        if let Some(mut state) =
 1795|      2|                                            egui::text_edit::TextEditState::load(
 1796|      2|                                                ui.ctx(),
 1797|      2|                                                editor_id,
 1798|      2|                                            )
 1799|      0|                                        {
 1800|      0|                                            let cr = egui::text::CCursorRange::one(
 1801|      0|                                                egui::text::CCursor::new(idx),
 1802|      0|                                            );
 1803|      0|                                            state.cursor.set_char_range(Some(cr));
 1804|      0|                                            state.store(ui.ctx(), editor_id);
 1805|      2|                                        } else {
 1806|      2|                                            let mut state =
 1807|      2|                                                egui::text_edit::TextEditState::default();
 1808|      2|                                            let cr = egui::text::CCursorRange::one(
 1809|      2|                                                egui::text::CCursor::new(idx),
 1810|      2|                                            );
 1811|      2|                                            state.cursor.set_char_range(Some(cr));
 1812|      2|                                            state.store(ui.ctx(), editor_id);
 1813|      2|                                        }
 1814|      0|                                    }
 1815|      2|                                    let before = self.raw_buffer.clone();
 1816|      2|                                    let resp = ui.add(
 1817|      2|                                        TextEdit::multiline(&mut self.raw_buffer)
 1818|      2|                                            .font(TextStyle::Monospace)
 1819|      2|                                            .code_editor()
 1820|      2|                                            .lock_focus(false)
 1821|      2|                                            .interactive(true)
 1822|      2|                                            .desired_width(f32::INFINITY)
 1823|      2|                                            .desired_rows(24)
 1824|      2|                                            .id_source(editor_id),
 1825|       |                                    );
 1826|      2|                                    if self.raw_focus_requested {
 1827|      1|                                        resp.request_focus();
 1828|      1|                                        self.raw_focus_requested = false;
 1829|      1|                                    }
 1830|       |                                    // Remember cursor position for next time
 1831|      2|                                    if let Some(state) =
 1832|      2|                                        egui::text_edit::TextEditState::load(ui.ctx(), editor_id)
 1833|       |                                    {
 1834|      2|                                        if let Some(range) = state.cursor.char_range() {
 1835|      2|                                            let idx = range.primary.index;
 1836|      2|                                            self.raw_cursor = Some(idx);
 1837|      2|                                        }
                                                      ^0
 1838|      0|                                    }
 1839|      2|                                    if self.raw_buffer != before {
 1840|      0|                                        self.current_content = self.raw_buffer.clone();
 1841|      0|                                        match self.renderer.parse(&self.current_content) {
 1842|      0|                                            Ok(elements) => {
 1843|      0|                                                self.parsed_elements = elements;
 1844|      0|                                                self.error_message = None;
 1845|      0|                                            }
 1846|      0|                                            Err(e) => {
 1847|      0|                                                self.error_message = Some(format!(
 1848|      0|                                                    "Failed to parse markdown: {}",
 1849|      0|                                                    e
 1850|      0|                                                ));
 1851|      0|                                            }
 1852|       |                                        }
 1853|      2|                                    }
 1854|      0|                                } else {
 1855|      0|                                    // Read-only
 1856|      0|                                    let mut tmp = self.raw_buffer.clone();
 1857|      0|                                    ui.add(
 1858|      0|                                        TextEdit::multiline(&mut tmp)
 1859|      0|                                            .font(TextStyle::Monospace)
 1860|      0|                                            .code_editor()
 1861|      0|                                            .lock_focus(false)
 1862|      0|                                            .interactive(false)
 1863|      0|                                            .desired_width(f32::INFINITY)
 1864|      0|                                            .desired_rows(24),
 1865|      0|                                    );
 1866|      0|                                }
 1867|       |                            }
 1868|       |                        }
 1869|       |                    }
 1870|      3|                });
 1871|      3|        });
 1872|       |
 1873|       |        // Add context menu for the main panel
 1874|      3|        central_response.response.context_menu(|ui| {
                                                                  ^0
 1875|      0|            self.render_main_context_menu(ui);
 1876|      0|        });
 1877|       |
 1878|       |        // Render floating search dialog (non-modal, always on top)
 1879|      3|        self.render_search_dialog(ctx);
 1880|       |
 1881|       |        // Render status bar
 1882|      3|        self.render_status_bar(ctx);
 1883|       |
 1884|       |        // Render drag-and-drop overlay (must be last to appear on top)
 1885|      3|        self.render_drag_overlay(ctx);
 1886|      3|        }
 1887|       |
 1888|       |    // Build a rich-text label with only the mnemonic character underlined (visual cue only).
 1889|     14|    fn menu_text_with_mnemonic(
 1890|     14|        prefix: Option<&str>,
 1891|     14|        label: &str,
 1892|     14|        mnemonic: char,
 1893|     14|        underline: bool,
 1894|     14|        text_color: Color32,
 1895|     14|    ) -> LayoutJob {
 1896|     14|        let mut job = LayoutJob::default();
 1897|     14|        let default_fmt = TextFormat {
 1898|     14|            color: text_color,
 1899|     14|            ..TextFormat::default()
 1900|     14|        };
 1901|     14|        if let Some(p) = prefix {
                                  ^0
 1902|      0|            job.append(p, 0.0, default_fmt.clone());
 1903|     14|        }
 1904|     14|        let m = mnemonic.to_ascii_lowercase();
 1905|     14|        let mut applied = false;
 1906|     82|        for c in label.chars() {
                               ^14   ^14
 1907|     82|            let mut fmt = default_fmt.clone();
 1908|     82|            if underline && !applied && c.to_ascii_lowercase() == m {
                                          ^0          ^0
 1909|      0|                // Use a subtle underline color; white works well on dark theme
 1910|      0|                fmt.underline = egui::Stroke::new(1.0, text_color);
 1911|      0|                applied = true;
 1912|     82|            }
 1913|     82|            let s = c.to_string();
 1914|     82|            job.append(&s, 0.0, fmt);
 1915|       |        }
 1916|     14|        job
 1917|     14|    }
 1918|      0|    fn persist_window_state(&mut self) {
 1919|      0|        if let Some(state) = self.current_window_state() {
 1920|      0|            if !self.window_state_changed(&state) {
 1921|      0|                return;
 1922|      0|            }
 1923|      0|            if crate::save_window_state(&state).is_ok() {
 1924|      0|                self.last_persist_instant = std::time::Instant::now();
 1925|      0|                self.last_persisted_state = Some(state);
 1926|      0|            }
 1927|      0|        }
 1928|      0|    }
 1929|       |
 1930|      3|    fn should_persist_window_state(&self) -> bool {
 1931|      3|        if self.last_persist_instant.elapsed() < std::time::Duration::from_secs(1) {
 1932|      3|            return false;
 1933|      0|        }
 1934|      0|        if let Some(state) = self.current_window_state() {
 1935|      0|            self.window_state_changed(&state)
 1936|       |        } else {
 1937|      0|            false
 1938|       |        }
 1939|      3|    }
 1940|       |
 1941|       |    /// Save current document. If no file is associated, prompts for a path.
 1942|      2|    fn save_current_document(&mut self) -> Result<()> {
 1943|      2|        if let Some(path) = self.current_file.clone() {
 1944|      2|            std::fs::write(&path, &self.current_content)?;
                                                                      ^0
 1945|      2|            let parent = path.parent();
 1946|      2|            self.renderer.set_base_dir(parent);
 1947|      2|            Ok(())
 1948|      0|        } else if let Some(path) = self.prompt_save_path() {
 1949|      0|            std::fs::write(&path, &self.current_content)?;
 1950|      0|            let filename = path
 1951|      0|                .file_name()
 1952|      0|                .and_then(|n| n.to_str())
 1953|      0|                .unwrap_or("Unknown")
 1954|      0|                .to_string();
 1955|      0|            self.current_file = Some(path);
 1956|      0|            if let Some(parent) = self.current_file.as_ref().and_then(|p| p.parent()) {
 1957|      0|                self.renderer.set_base_dir(Some(parent));
 1958|      0|            } else {
 1959|      0|                self.renderer.set_base_dir(None);
 1960|      0|            }
 1961|      0|            self.title = format!("{APP_TITLE_PREFIX} - {}", filename);
 1962|      0|            Ok(())
 1963|       |        } else {
 1964|      0|            Ok(())
 1965|       |        }
 1966|      2|    }
 1967|       |
 1968|       |    #[cfg(not(test))]
 1969|       |    fn prompt_save_path(&self) -> Option<PathBuf> {
 1970|       |        FileDialog::new()
 1971|       |            .set_title("Save Markdown File")
 1972|       |            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
 1973|       |            .save_file()
 1974|       |    }
 1975|       |
 1976|       |    #[cfg(test)]
 1977|      1|    fn prompt_save_path(&self) -> Option<PathBuf> {
 1978|      1|        None
 1979|      1|    }
 1980|       |
 1981|       |    /// Render the floating non-modal search dialog
 1982|      3|    fn render_search_dialog(&mut self, ctx: &Context) {
 1983|      3|        if !self.show_search {
 1984|      2|            return;
 1985|      1|        }
 1986|      1|        let prev_open = self.show_search;
 1987|      1|        let mut open = self.show_search;
 1988|      1|        let prev_query = self.search_query.clone();
 1989|      1|        egui::Window::new("Find")
 1990|      1|            .collapsible(false)
 1991|      1|            .resizable(false)
 1992|      1|            .default_pos(egui::pos2(80.0, 80.0))
 1993|      1|            .open(&mut open)
 1994|      1|            .show(ctx, |ui| {
 1995|      1|                let mut submitted_next = false;
 1996|      1|                ui.horizontal(|ui| {
 1997|      1|                    let text_edit = egui::TextEdit::singleline(&mut self.search_query)
 1998|      1|                        .hint_text("Search text...")
 1999|      1|                        .desired_width(240.0);
 2000|      1|                    let resp = ui.add(text_edit);
 2001|      1|                    if self.search_focus_requested {
 2002|      0|                        resp.request_focus();
 2003|      0|                        self.search_focus_requested = false;
 2004|      1|                    }
 2005|      1|                    if resp.lost_focus() && ui.input(|i| i.key_pressed(egui::Key::Enter)) {
                                                          ^0 ^0        ^0^0          ^0
 2006|      0|                        submitted_next = true;
 2007|      1|                    }
 2008|      1|                    if ui.button("Next (F3)").clicked() || submitted_next {
 2009|      0|                        self.find_next();
 2010|      1|                    }
 2011|      1|                    if ui.button("Prev (Shift+F3)").clicked() {
 2012|      0|                        self.find_previous();
 2013|      1|                    }
 2014|      1|                });
 2015|      1|            });
 2016|       |        // Dynamic search: scroll to first match from anchor whenever the input changes
 2017|      1|        if self.search_query != prev_query {
 2018|      0|            if self.search_query.is_empty() {
 2019|      0|                self.last_query.clear();
 2020|      0|                self.renderer.set_highlight_phrase(None);
 2021|      0|            } else {
 2022|      0|                self.last_query = self.search_query.clone();
 2023|       |                // Use current last match as baseline if set, else start of doc
 2024|      0|                let baseline = self.last_match_index.unwrap_or(0);
 2025|      0|                let needle = Self::fold_for_search(&self.search_query);
 2026|      0|                let total = self.parsed_elements.len();
 2027|      0|                let mut found: Option<usize> = None;
 2028|      0|                for pass in 0..2 {
 2029|      0|                    let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
 2030|      0|                        Box::new(baseline..total)
 2031|       |                    } else {
 2032|      0|                        Box::new(0..baseline.min(total))
 2033|       |                    };
 2034|      0|                    for idx in range {
 2035|      0|                        let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
 2036|      0|                            &self.parsed_elements[idx],
 2037|       |                        );
 2038|      0|                        if Self::fold_for_search(&text).contains(&needle) {
 2039|      0|                            found = Some(idx);
 2040|      0|                            break;
 2041|      0|                        }
 2042|       |                    }
 2043|      0|                    if found.is_some() {
 2044|      0|                        break;
 2045|      0|                    }
 2046|       |                }
 2047|      0|                if let Some(idx) = found {
 2048|      0|                    self.last_match_index = Some(idx);
 2049|      0|                    self.pending_scroll_to_element = Some(idx);
 2050|      0|                }
 2051|       |            }
 2052|      1|        }
 2053|       |        // If dialog closed via close button, clear before hiding
 2054|      1|        if prev_open && !open {
 2055|      0|            self.clear_search_state();
 2056|      1|        }
 2057|      1|        self.show_search = open;
 2058|      3|    }
 2059|       |
 2060|       |    // No overlay menu helpers; we only render egui's built-in menus.
 2061|       |}
 2062|       |
 2063|       |impl Default for MarkdownViewerApp {
 2064|      1|    fn default() -> Self {
 2065|      1|        Self::new()
 2066|      1|    }
 2067|       |}
 2068|       |
 2069|       |#[cfg(test)]
 2070|       |mod tests {
 2071|       |    use super::*;
 2072|       |    use std::io::Write;
 2073|       |    use tempfile::{NamedTempFile, TempDir};
 2074|       |
 2075|     10|    fn test_input() -> egui::RawInput {
 2076|     10|        let mut input = egui::RawInput::default();
 2077|     10|        input.screen_rect = Some(egui::Rect::from_min_size(
 2078|     10|            egui::pos2(0.0, 0.0),
 2079|     10|            egui::vec2(1024.0, 768.0),
 2080|     10|        ));
 2081|     10|        input
 2082|     10|    }
 2083|       |
 2084|      1|    fn with_test_ui<F>(f: F)
 2085|      1|    where
 2086|      1|        F: FnOnce(&egui::Context, &mut egui::Ui),
 2087|       |    {
 2088|      1|        let ctx = egui::Context::default();
 2089|      1|        let input = test_input();
 2090|      1|        ctx.begin_frame(input);
 2091|      1|        egui::CentralPanel::default().show(&ctx, |ui| {
 2092|      1|            f(&ctx, ui);
 2093|      1|        });
 2094|      1|        let _ = ctx.end_frame();
 2095|      1|    }
 2096|       |
 2097|      3|    fn run_update(app: &mut MarkdownViewerApp, input: egui::RawInput) {
 2098|      3|        let ctx = egui::Context::default();
 2099|      3|        ctx.begin_frame(input);
 2100|      3|        app.update_inner(&ctx);
 2101|      3|        let _ = ctx.end_frame();
 2102|      3|    }
 2103|       |
 2104|       |    #[test]
 2105|      1|    fn test_normalize_line_endings() {
 2106|       |        // Windows style (\r\n)
 2107|      1|        assert_eq!(
 2108|      1|            MarkdownViewerApp::normalize_line_endings("Hello\r\nWorld"),
 2109|       |            "Hello\nWorld"
 2110|       |        );
 2111|       |
 2112|       |        // Unix style (\n) - no change
 2113|      1|        assert_eq!(
 2114|      1|            MarkdownViewerApp::normalize_line_endings("Hello\nWorld"),
 2115|       |            "Hello\nWorld"
 2116|       |        );
 2117|       |
 2118|       |        // Old Mac style (\r)
 2119|      1|        assert_eq!(
 2120|      1|            MarkdownViewerApp::normalize_line_endings("Hello\rWorld"),
 2121|       |            "Hello\nWorld"
 2122|       |        );
 2123|       |
 2124|       |        // Mixed line endings
 2125|      1|        assert_eq!(
 2126|      1|            MarkdownViewerApp::normalize_line_endings("A\r\nB\nC\rD"),
 2127|       |            "A\nB\nC\nD"
 2128|       |        );
 2129|       |
 2130|       |        // Multiple blank lines with Windows endings
 2131|      1|        assert_eq!(
 2132|      1|            MarkdownViewerApp::normalize_line_endings("A\r\n\r\nB"),
 2133|       |            "A\n\nB"
 2134|       |        );
 2135|       |
 2136|       |        // Empty string
 2137|      1|        assert_eq!(MarkdownViewerApp::normalize_line_endings(""), "");
 2138|       |
 2139|       |        // No line endings
 2140|      1|        assert_eq!(
 2141|      1|            MarkdownViewerApp::normalize_line_endings("Single line"),
 2142|       |            "Single line"
 2143|       |        );
 2144|      1|    }
 2145|       |
 2146|       |    #[test]
 2147|      1|    fn test_load_file_with_windows_line_endings() -> Result<()> {
 2148|      1|        let mut app = MarkdownViewerApp::new();
 2149|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2150|       |
 2151|       |        // Write content with explicit Windows line endings
 2152|      1|        temp_file.write_all(b"Line 1\r\nLine 2\r\n\r\nParagraph text")?;
                                                                                    ^0
 2153|      1|        temp_file.flush()?;
                                       ^0
 2154|       |
 2155|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 2156|       |
 2157|       |        // Should not contain any \r characters after normalization
 2158|      1|        assert!(!app.current_content.contains('\r'));
 2159|      1|        assert!(app.current_content.contains("Line 1\nLine 2"));
 2160|      1|        assert!(app.current_content.contains("\n\nParagraph"));
 2161|      1|        Ok(())
 2162|      1|    }
 2163|       |
 2164|       |    #[test]
 2165|      1|    fn test_load_file_with_mixed_line_endings() -> Result<()> {
 2166|      1|        let mut app = MarkdownViewerApp::new();
 2167|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2168|       |
 2169|       |        // Mix of \r\n (Windows), \n (Unix), and \r (old Mac)
 2170|      1|        temp_file.write_all(b"Line 1\r\nLine 2\nLine 3\rLine 4")?;
                                                                              ^0
 2171|      1|        temp_file.flush()?;
                                       ^0
 2172|       |
 2173|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 2174|       |
 2175|       |        // All should be normalized to \n
 2176|      1|        assert!(!app.current_content.contains('\r'));
 2177|      1|        assert_eq!(app.current_content.lines().count(), 4);
 2178|      1|        let lines: Vec<&str> = app.current_content.lines().collect();
 2179|      1|        assert_eq!(lines[0], "Line 1");
 2180|      1|        assert_eq!(lines[1], "Line 2");
 2181|      1|        assert_eq!(lines[2], "Line 3");
 2182|      1|        assert_eq!(lines[3], "Line 4");
 2183|      1|        Ok(())
 2184|      1|    }
 2185|       |
 2186|       |    #[test]
 2187|      1|    fn test_app_creation() {
 2188|      1|        let app = MarkdownViewerApp::new();
 2189|      1|        assert!(!app.parsed_elements.is_empty()); // Should load welcome content
 2190|      1|        assert!(app.title.contains(APP_TITLE_PREFIX));
 2191|      1|        assert!(app.error_message.is_none());
 2192|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 2193|      1|    }
 2194|       |
 2195|       |    #[test]
 2196|      1|    fn test_load_content() {
 2197|      1|        let mut app = MarkdownViewerApp::new();
 2198|      1|        let content = "# Test Header\n\nThis is test content.";
 2199|       |
 2200|      1|        app.load_content(content, Some("Test".to_string()));
 2201|       |
 2202|      1|        assert_eq!(app.current_content, content);
 2203|      1|        assert_eq!(app.raw_buffer, content);
 2204|      1|        assert!(app.title.contains("Test"));
 2205|      1|        assert!(!app.parsed_elements.is_empty());
 2206|      1|        assert!(app.error_message.is_none());
 2207|      1|    }
 2208|       |
 2209|       |    #[test]
 2210|      1|    fn test_toggle_view_mode() {
 2211|      1|        let mut app = MarkdownViewerApp::new();
 2212|      1|        let ctx = egui::Context::default();
 2213|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 2214|      1|        app.toggle_view_mode(&ctx);
 2215|      1|        assert!(matches!(app.view_mode, ViewMode::Raw));
                              ^0
 2216|      1|        app.toggle_view_mode(&ctx);
 2217|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 2218|      1|    }
 2219|       |
 2220|       |    #[test]
 2221|      1|    fn test_load_sample() {
 2222|      1|        let mut app = MarkdownViewerApp::new();
 2223|      1|        let sample = &SAMPLE_FILES[0]; // First sample file
 2224|       |
 2225|      1|        app.load_sample(sample);
 2226|       |
 2227|      1|        assert_eq!(app.current_content, sample.content);
 2228|      1|        assert!(app.title.contains(sample.title));
 2229|      1|        assert!(!app.parsed_elements.is_empty());
 2230|      1|        assert!(app.current_file.is_none()); // Sample files don't set file path
 2231|      1|    }
 2232|       |
 2233|       |    #[test]
 2234|      1|    fn test_load_file() -> Result<()> {
 2235|      1|        let mut app = MarkdownViewerApp::new();
 2236|       |
 2237|       |        // Create a temporary markdown file
 2238|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2239|      1|        let content = "# Temporary File\n\nThis is a test markdown file.";
 2240|      1|        temp_file.write_all(content.as_bytes())?;
                                                             ^0
 2241|      1|        temp_file.flush()?;
                                       ^0
 2242|       |
 2243|      1|        let path = temp_file.path().to_path_buf();
 2244|      1|        app.load_file(path.clone(), true)?;
                                                       ^0
 2245|       |
 2246|      1|        assert_eq!(app.current_content, content);
 2247|      1|        assert_eq!(app.current_file, Some(path));
 2248|      1|        assert!(!app.parsed_elements.is_empty());
 2249|      1|        assert!(app.error_message.is_none());
 2250|       |
 2251|      1|        Ok(())
 2252|      1|    }
 2253|       |
 2254|       |    #[test]
 2255|      1|    fn test_load_invalid_markdown() {
 2256|      1|        let mut app = MarkdownViewerApp::new();
 2257|       |        // Even "invalid" markdown should parse successfully with pulldown-cmark
 2258|       |        // as it's very permissive
 2259|      1|        let content = "This is just plain text with some <invalid> HTML tags";
 2260|       |
 2261|      1|        app.load_content(content, Some("Invalid".to_string()));
 2262|       |
 2263|       |        // Should still work - pulldown-cmark is very permissive
 2264|      1|        assert_eq!(app.current_content, content);
 2265|      1|        assert!(app.error_message.is_none() || app.error_message.is_some()); // Either is ok
                                                             ^0                ^0
 2266|      1|    }
 2267|       |
 2268|       |    #[test]
 2269|      1|    fn test_load_empty_content() {
 2270|      1|        let mut app = MarkdownViewerApp::new();
 2271|      1|        app.load_content("", Some("Empty".to_string()));
 2272|       |
 2273|      1|        assert_eq!(app.current_content, "");
 2274|      1|        assert!(app.title.contains("Empty"));
 2275|      1|        assert!(app.error_message.is_none());
 2276|      1|    }
 2277|       |
 2278|       |    #[test]
 2279|      1|    fn test_load_nonexistent_file() {
 2280|      1|        let mut app = MarkdownViewerApp::new();
 2281|      1|        let fake_path = PathBuf::from("/nonexistent/file.md");
 2282|       |
 2283|      1|        let result = app.load_file(fake_path, true);
 2284|      1|        assert!(result.is_err());
 2285|      1|    }
 2286|       |
 2287|       |    #[test]
 2288|      1|    fn test_reload_current_file() -> Result<()> {
 2289|      1|        let mut app = MarkdownViewerApp::new();
 2290|       |
 2291|       |        // Create a temporary markdown file
 2292|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2293|      1|        let content1 = "# Title\n\nVersion 1";
 2294|      1|        temp_file.write_all(content1.as_bytes())?;
                                                              ^0
 2295|      1|        temp_file.flush()?;
                                       ^0
 2296|       |
 2297|      1|        let path = temp_file.path().to_path_buf();
 2298|      1|        app.load_file(path.clone(), true)?;
                                                       ^0
 2299|      1|        assert!(app.current_content.contains("Version 1"));
 2300|       |
 2301|       |        // Update file content
 2302|      1|        let content2 = "# Title\n\nVersion 2";
 2303|      1|        temp_file.as_file_mut().set_len(0)?; // clear
                                                        ^0
 2304|      1|        temp_file.write_all(content2.as_bytes())?;
                                                              ^0
 2305|      1|        temp_file.flush()?;
                                       ^0
 2306|       |
 2307|       |        // Reload and verify
 2308|      1|        app.reload_current_file()?;
                                               ^0
 2309|      1|        assert!(app.current_content.contains("Version 2"));
 2310|      1|        Ok(())
 2311|      1|    }
 2312|       |
 2313|       |    #[test]
 2314|      1|    fn test_load_file_with_invalid_utf8() -> Result<()> {
 2315|      1|        let mut app = MarkdownViewerApp::new();
 2316|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2317|      1|        let bytes = b"Hello\xFFWorld";
 2318|      1|        temp_file.write_all(bytes)?;
                                                ^0
 2319|      1|        temp_file.flush()?;
                                       ^0
 2320|       |
 2321|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 2322|       |
 2323|      1|        assert!(app.current_content.contains('\u{FFFD}'));
 2324|      1|        assert!(!app.parsed_elements.is_empty());
 2325|      1|        assert!(app.error_message.is_none());
 2326|      1|        Ok(())
 2327|      1|    }
 2328|       |
 2329|       |    #[test]
 2330|      1|    fn test_reload_without_file() {
 2331|      1|        let mut app = MarkdownViewerApp::new();
 2332|      1|        assert!(app.current_file.is_none());
 2333|      1|        let result = app.reload_current_file();
 2334|      1|        assert!(result.is_err());
 2335|      1|    }
 2336|       |
 2337|       |    #[test]
 2338|      1|    fn test_window_state_change_detection() {
 2339|      1|        let mut app = MarkdownViewerApp::new();
 2340|      1|        app.last_window_pos = Some([10.0, 10.0]);
 2341|      1|        app.last_window_size = Some([800.0, 600.0]);
 2342|      1|        app.last_window_maximized = false;
 2343|       |
 2344|      1|        let state = app.current_window_state().expect("state");
 2345|      1|        assert!(app.window_state_changed(&state));
 2346|      1|        app.last_persisted_state = Some(state);
 2347|      1|        assert!(!app.window_state_changed(&state));
 2348|       |
 2349|      1|        let mut moved = state;
 2350|      1|        moved.pos = [12.0, 10.0];
 2351|      1|        assert!(app.window_state_changed(&moved));
 2352|      1|    }
 2353|       |
 2354|       |    #[test]
 2355|      1|    fn test_fold_for_search_handles_case_and_accents() {
 2356|      1|        assert_eq!(
 2357|      1|            MarkdownViewerApp::fold_for_search("\u{00C4}\u{00DF}"),
 2358|      1|            MarkdownViewerApp::fold_for_search("\u{00E4}SS")
 2359|       |        );
 2360|      1|        assert_eq!(
 2361|      1|            MarkdownViewerApp::fold_for_search("To\u{0301}m"),
 2362|      1|            MarkdownViewerApp::fold_for_search("T\u{00D3}m")
 2363|       |        );
 2364|      1|    }
 2365|       |
 2366|       |    #[test]
 2367|      1|    fn test_title_updates() {
 2368|      1|        let mut app = MarkdownViewerApp::new();
 2369|       |
 2370|       |        // Test with custom title
 2371|      1|        app.load_content("# Test", Some("Custom Title".to_string()));
 2372|      1|        assert!(app.title.contains("Custom Title"));
 2373|       |
 2374|       |        // Test with no title (should keep existing)
 2375|      1|        let old_title = app.title.clone();
 2376|      1|        app.load_content("# Another Test", None);
 2377|      1|        assert_eq!(app.title, old_title); // Should remain unchanged
 2378|      1|    }
 2379|       |
 2380|       |    #[test]
 2381|      1|    fn test_complex_markdown_loading() {
 2382|      1|        let mut app = MarkdownViewerApp::new();
 2383|      1|        let complex_content = r#"# Complex Document
 2384|      1|
 2385|      1|## With Multiple Sections
 2386|      1|
 2387|      1|This has **bold** and *italic* text.
 2388|      1|
 2389|      1|```rust
 2390|      1|fn main() {
 2391|      1|    println!("Hello, world!");
 2392|      1|}
 2393|      1|```
 2394|      1|
 2395|      1|- List item 1
 2396|      1|- List item 2
 2397|      1|
 2398|      1|> A blockquote
 2399|      1|
 2400|      1|[A link](https://example.com)
 2401|      1|
 2402|      1|---
 2403|      1|
 2404|      1|The end.
 2405|      1|"#;
 2406|       |
 2407|      1|        app.load_content(complex_content, Some("Complex".to_string()));
 2408|       |
 2409|      1|        assert_eq!(app.current_content, complex_content);
 2410|      1|        assert!(app.title.contains("Complex"));
 2411|      1|        assert!(!app.parsed_elements.is_empty());
 2412|      1|        assert!(app.error_message.is_none());
 2413|       |
 2414|       |        // Should have parsed various element types
 2415|      1|        assert!(app.parsed_elements.len() > 5); // Complex document should have many elements
 2416|      1|    }
 2417|       |
 2418|       |    #[test]
 2419|      1|    fn test_error_handling() {
 2420|      1|        let app = MarkdownViewerApp::new();
 2421|       |
 2422|       |        // Test that app starts without errors
 2423|      1|        assert!(app.error_message.is_none());
 2424|       |
 2425|       |        // Even with the welcome content loaded, should be error-free
 2426|      1|        assert!(!app.parsed_elements.is_empty());
 2427|      1|    }
 2428|       |
 2429|       |    #[test]
 2430|      1|    fn test_default_state() {
 2431|      1|        let app = MarkdownViewerApp::default();
 2432|       |
 2433|       |        // Default should be same as new()
 2434|      1|        assert!(!app.parsed_elements.is_empty());
 2435|      1|        assert!(app.title.contains(APP_TITLE_PREFIX));
 2436|      1|        assert!(app.error_message.is_none());
 2437|      1|        assert!(app.current_file.is_none());
 2438|      1|    }
 2439|       |
 2440|       |    #[test]
 2441|      1|    fn test_sample_files_integration() {
 2442|      1|        let mut app = MarkdownViewerApp::new();
 2443|       |
 2444|       |        // Test loading each sample file
 2445|      7|        for sample in SAMPLE_FILES {
                          ^6
 2446|      6|            app.load_sample(sample);
 2447|       |
 2448|      6|            assert_eq!(app.current_content, sample.content);
 2449|      6|            assert!(app.title.contains(sample.title));
 2450|      6|            assert!(app.current_file.is_none());
 2451|      6|            assert!(app.error_message.is_none());
 2452|       |        }
 2453|      1|    }
 2454|       |
 2455|       |    #[test]
 2456|      1|    fn test_close_current_file() {
 2457|      1|        let mut app = MarkdownViewerApp::new();
 2458|       |
 2459|       |        // Load some content first
 2460|      1|        app.load_content("# Test Content", Some("Test File".to_string()));
 2461|      1|        assert!(app.title.contains("Test File"));
 2462|       |
 2463|       |        // Close the file
 2464|      1|        app.close_current_file();
 2465|       |
 2466|       |        // Should return to welcome screen
 2467|      1|        assert!(app.title.contains("Welcome"));
 2468|      1|        assert!(app.current_file.is_none());
 2469|      1|        assert!(!app.parsed_elements.is_empty()); // Should have welcome content
 2470|      1|        assert!(app.error_message.is_none());
 2471|      1|    }
 2472|       |
 2473|       |    #[test]
 2474|      1|    fn test_navigation_request_enum() {
 2475|       |        // Test that the enum values exist and are correct
 2476|      1|        let _top = NavigationRequest::Top;
 2477|      1|        let _bottom = NavigationRequest::Bottom;
 2478|      1|        let _page_up = NavigationRequest::PageUp;
 2479|      1|        let _page_down = NavigationRequest::PageDown;
 2480|      1|        let _scroll_up = NavigationRequest::ScrollUp;
 2481|      1|        let _scroll_down = NavigationRequest::ScrollDown;
 2482|       |
 2483|       |        // Ensure it's cloneable and debuggable
 2484|      1|        let nav = NavigationRequest::Top;
 2485|      1|        let _cloned = nav.clone();
 2486|      1|        let _debug = format!("{:?}", nav);
 2487|       |
 2488|       |        // Basic compilation test performed by using the enum and Debug/Clone
 2489|      1|    }
 2490|       |
 2491|       |    #[test]
 2492|      1|    fn test_navigation_state_initialization() {
 2493|      1|        let app = MarkdownViewerApp::new();
 2494|       |        // Test that nav_request is initialized to None
 2495|      1|        assert!(app.nav_request.is_none());
 2496|       |        // Test that fullscreen toggle flag is initialized to false
 2497|      1|        assert!(!app.toggle_fullscreen);
 2498|      1|    }
 2499|       |
 2500|       |    #[test]
 2501|      1|    fn test_fullscreen_toggle_flag() {
 2502|      1|        let mut app = MarkdownViewerApp::new();
 2503|       |
 2504|       |        // Initially should be false
 2505|      1|        assert!(!app.toggle_fullscreen);
 2506|       |
 2507|       |        // Simulate F11 key press (this would be set in handle_shortcuts)
 2508|      1|        app.toggle_fullscreen = true;
 2509|      1|        assert!(app.toggle_fullscreen);
 2510|       |
 2511|       |        // After handling, it should be reset to false
 2512|      1|        app.toggle_fullscreen = false;
 2513|      1|        assert!(!app.toggle_fullscreen);
 2514|      1|    }
 2515|       |
 2516|       |    #[test]
 2517|      1|    fn test_navigation_state_reset_on_load() {
 2518|      1|        let mut app = MarkdownViewerApp::new();
 2519|       |
 2520|       |        // Set a navigation request
 2521|      1|        app.nav_request = Some(NavigationRequest::Top);
 2522|      1|        assert!(app.nav_request.is_some());
 2523|       |
 2524|       |        // Load content should reset navigation state
 2525|      1|        app.load_content("# Test Content", Some("Test".to_string()));
 2526|      1|        assert!(app.nav_request.is_none());
 2527|      1|    }
 2528|       |
 2529|       |    #[test]
 2530|      1|    fn test_page_navigation_calculations() {
 2531|       |        // Test the page size calculation logic used in navigation
 2532|      1|        let viewport_height = 800.0f32;
 2533|      1|        let page_size = viewport_height * 0.8;
 2534|      1|        assert_eq!(page_size, 640.0);
 2535|       |
 2536|       |        // Test boundary conditions for Page Up
 2537|      1|        let current_offset = 100.0f32;
 2538|      1|        let new_offset_up = (current_offset - page_size).max(0.0);
 2539|      1|        assert_eq!(new_offset_up, 0.0); // Should clamp to 0
 2540|       |
 2541|       |        // Test Page Down calculation
 2542|      1|        let new_offset_down = current_offset + page_size;
 2543|      1|        assert_eq!(new_offset_down, 740.0);
 2544|       |
 2545|       |        // Test that Page Up from near top goes to 0
 2546|      1|        let near_top = 300.0f32;
 2547|      1|        let from_near_top = (near_top - page_size).max(0.0);
 2548|      1|        assert_eq!(from_near_top, 0.0);
 2549|      1|    }
 2550|       |
 2551|       |    #[test]
 2552|      1|    fn test_compute_window_adjustment_clamps_offscreen_window() {
 2553|      1|        let outer = egui::Rect::from_min_size(egui::pos2(1200.0, 900.0), egui::vec2(800.0, 600.0));
 2554|      1|        let monitor = egui::vec2(1024.0, 768.0);
 2555|      1|        let (pos, size) = MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(monitor))
 2556|      1|            .expect("should adjust window geometry");
 2557|      1|        assert!(pos.x <= monitor.x - size.x + 1.0);
 2558|      1|        assert!(pos.y <= monitor.y - size.y + 1.0);
 2559|      1|    }
 2560|       |
 2561|       |    #[test]
 2562|      1|    fn test_compute_window_adjustment_respects_min_size() {
 2563|      1|        let outer = egui::Rect::from_min_size(egui::pos2(-200.0, -100.0), egui::vec2(200.0, 100.0));
 2564|      1|        let monitor = egui::vec2(1920.0, 1080.0);
 2565|      1|        let (pos, size) = MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(monitor))
 2566|      1|            .expect("should enforce minimum window size");
 2567|      1|        assert!(size.x >= 600.0);
 2568|      1|        assert!(size.y >= 400.0);
 2569|      1|        assert!(pos.x >= 0.0);
 2570|      1|        assert!(pos.y >= 0.0);
 2571|      1|    }
 2572|       |
 2573|       |    #[test]
 2574|      1|    fn test_is_valid_markdown_file() {
 2575|      1|        let app = MarkdownViewerApp::new();
 2576|       |
 2577|       |        // Valid markdown extensions
 2578|      1|        assert!(app.is_valid_markdown_file(Path::new("test.md")));
 2579|      1|        assert!(app.is_valid_markdown_file(Path::new("test.markdown")));
 2580|      1|        assert!(app.is_valid_markdown_file(Path::new("test.mdown")));
 2581|      1|        assert!(app.is_valid_markdown_file(Path::new("test.mkd")));
 2582|      1|        assert!(app.is_valid_markdown_file(Path::new("test.txt")));
 2583|       |
 2584|       |        // Case insensitive
 2585|      1|        assert!(app.is_valid_markdown_file(Path::new("test.MD")));
 2586|      1|        assert!(app.is_valid_markdown_file(Path::new("test.Markdown")));
 2587|       |
 2588|       |        // Invalid extensions
 2589|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.pdf")));
 2590|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.docx")));
 2591|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.html")));
 2592|       |
 2593|       |        // No extension
 2594|      1|        assert!(!app.is_valid_markdown_file(Path::new("test")));
 2595|      1|    }
 2596|       |
 2597|       |    #[test]
 2598|      1|    fn test_scan_directory() -> Result<()> {
 2599|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2600|      1|        let dir_path = temp_dir.path();
 2601|       |
 2602|       |        // Create test files
 2603|      1|        std::fs::write(dir_path.join("zebra.md"), "# Z")?;
                                                                      ^0
 2604|      1|        std::fs::write(dir_path.join("alpha.md"), "# A")?;
                                                                      ^0
 2605|      1|        std::fs::write(dir_path.join("image.png"), "fake")?;
                                                                        ^0
 2606|      1|        std::fs::write(dir_path.join("beta.markdown"), "# B")?;
                                                                           ^0
 2607|       |
 2608|       |        // Create subdirectory (should be ignored)
 2609|      1|        std::fs::create_dir(dir_path.join("subdir"))?;
                                                                  ^0
 2610|      1|        std::fs::write(dir_path.join("subdir/nested.md"), "# N")?;
                                                                              ^0
 2611|       |
 2612|      1|        let app = MarkdownViewerApp::new();
 2613|      1|        let files = app.scan_directory(dir_path)?;
                                                              ^0
 2614|       |
 2615|       |        // Should find 3 markdown files (alpha, beta, zebra)
 2616|       |        // Should NOT find image.png or nested.md
 2617|      1|        assert_eq!(files.len(), 3);
 2618|       |
 2619|       |        // Should be sorted alphabetically
 2620|      1|        assert!(files[0].ends_with("alpha.md"));
 2621|      1|        assert!(files[1].ends_with("beta.markdown"));
 2622|      1|        assert!(files[2].ends_with("zebra.md"));
 2623|       |
 2624|      1|        Ok(())
 2625|      1|    }
 2626|       |
 2627|       |    #[test]
 2628|      1|    fn test_scan_empty_directory() -> Result<()> {
 2629|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2630|      1|        let app = MarkdownViewerApp::new();
 2631|      1|        let files = app.scan_directory(temp_dir.path())?;
                                                                     ^0
 2632|       |
 2633|      1|        assert_eq!(files.len(), 0);
 2634|      1|        Ok(())
 2635|      1|    }
 2636|       |
 2637|       |    #[test]
 2638|      1|    fn test_single_file_drop() -> Result<()> {
 2639|      1|        let mut app = MarkdownViewerApp::new();
 2640|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2641|      1|        let file = temp_dir.path().join("test.md");
 2642|      1|        std::fs::write(&file, "# Test")?;
                                                     ^0
 2643|       |
 2644|      1|        app.handle_file_drop(vec![file.clone()]);
 2645|       |
 2646|      1|        assert_eq!(app.current_file, Some(file));
 2647|      1|        assert!(app.pending_files.is_empty());
 2648|      1|        assert!(app.error_message.is_none());
 2649|      1|        Ok(())
 2650|      1|    }
 2651|       |
 2652|       |    #[test]
 2653|      1|    fn test_multiple_files_drop() -> Result<()> {
 2654|      1|        let mut app = MarkdownViewerApp::new();
 2655|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2656|       |
 2657|      1|        let files: Vec<PathBuf> = (0..5)
 2658|      5|            .map(|i| {
                           ^1
 2659|      5|                let path = temp_dir.path().join(format!("file{}.md", i));
 2660|      5|                std::fs::write(&path, format!("# File {}", i)).unwrap();
 2661|      5|                path
 2662|      5|            })
 2663|      1|            .collect();
 2664|       |
 2665|      1|        app.handle_file_drop(files.clone());
 2666|       |
 2667|      1|        assert_eq!(app.current_file, Some(files[0].clone()));
 2668|      1|        assert_eq!(app.pending_files.len(), 4);
 2669|      1|        Ok(())
 2670|      1|    }
 2671|       |
 2672|       |    #[test]
 2673|      1|    fn test_directory_drop() -> Result<()> {
 2674|      1|        let mut app = MarkdownViewerApp::new();
 2675|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2676|       |
 2677|       |        // Create files in directory
 2678|      1|        std::fs::write(temp_dir.path().join("a.md"), "# A")?;
                                                                         ^0
 2679|      1|        std::fs::write(temp_dir.path().join("b.md"), "# B")?;
                                                                         ^0
 2680|      1|        std::fs::write(temp_dir.path().join("c.md"), "# C")?;
                                                                         ^0
 2681|       |
 2682|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 2683|       |
 2684|      1|        assert!(app.current_file.is_some());
 2685|      1|        assert_eq!(app.pending_files.len(), 2);
 2686|      1|        Ok(())
 2687|      1|    }
 2688|       |
 2689|       |    #[test]
 2690|      1|    fn test_invalid_file_drop() {
 2691|      1|        let mut app = MarkdownViewerApp::new();
 2692|      1|        let temp_dir = tempfile::TempDir::new().unwrap();
 2693|      1|        let file = temp_dir.path().join("test.pdf");
 2694|      1|        std::fs::write(&file, "fake pdf").unwrap();
 2695|       |
 2696|      1|        app.handle_file_drop(vec![file]);
 2697|       |
 2698|       |        // Current file should remain None (or welcome sample)
 2699|      1|        assert!(app.error_message.is_some());
 2700|      1|        assert!(app
 2701|      1|            .error_message
 2702|      1|            .as_ref()
 2703|      1|            .unwrap()
 2704|      1|            .contains("Not a markdown file"));
 2705|      1|    }
 2706|       |
 2707|       |    #[test]
 2708|      1|    fn test_too_many_files() {
 2709|      1|        let mut app = MarkdownViewerApp::new();
 2710|      1|        let temp_dir = tempfile::TempDir::new().unwrap();
 2711|       |
 2712|      1|        let files: Vec<PathBuf> = (0..60)
 2713|     60|            .map(|i| {
                           ^1
 2714|     60|                let path = temp_dir.path().join(format!("file{}.md", i));
 2715|     60|                std::fs::write(&path, format!("# File {}", i)).unwrap();
 2716|     60|                path
 2717|     60|            })
 2718|      1|            .collect();
 2719|       |
 2720|      1|        app.handle_file_drop(files);
 2721|       |
 2722|      1|        assert!(app.error_message.is_some());
 2723|      1|        assert!(app
 2724|      1|            .error_message
 2725|      1|            .as_ref()
 2726|      1|            .unwrap()
 2727|      1|            .contains("Too many files"));
 2728|      1|    }
 2729|       |
 2730|       |    #[test]
 2731|      1|    fn test_queue_navigation() -> Result<()> {
 2732|      1|        let mut app = MarkdownViewerApp::new();
 2733|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2734|       |
 2735|      1|        let file1 = temp_dir.path().join("file1.md");
 2736|      1|        let file2 = temp_dir.path().join("file2.md");
 2737|       |
 2738|      1|        std::fs::write(&file1, "# File 1")?;
                                                        ^0
 2739|      1|        std::fs::write(&file2, "# File 2")?;
                                                        ^0
 2740|       |
 2741|       |        // Load first file and queue second
 2742|      1|        app.load_file(file1.clone(), true)?;
                                                        ^0
 2743|      1|        app.pending_files.push_back(file2.clone());
 2744|       |
 2745|      1|        assert!(app.can_navigate_forward());
 2746|      1|        app.navigate_forward();
 2747|      1|        assert_eq!(app.current_file, Some(file2));
 2748|      1|        assert!(app.pending_files.is_empty());
 2749|       |
 2750|      1|        Ok(())
 2751|      1|    }
 2752|       |
 2753|       |    #[test]
 2754|      1|    fn test_mixed_valid_invalid_files() -> Result<()> {
 2755|      1|        let mut app = MarkdownViewerApp::new();
 2756|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2757|       |
 2758|      1|        let md_file = temp_dir.path().join("test.md");
 2759|      1|        let pdf_file = temp_dir.path().join("test.pdf");
 2760|       |
 2761|      1|        std::fs::write(&md_file, "# Test")?;
                                                        ^0
 2762|      1|        std::fs::write(&pdf_file, "fake pdf")?;
                                                           ^0
 2763|       |
 2764|      1|        app.handle_file_drop(vec![md_file.clone(), pdf_file]);
 2765|       |
 2766|       |        // Should open the valid markdown file
 2767|      1|        assert_eq!(app.current_file, Some(md_file));
 2768|       |        // Should show error about the invalid file
 2769|      1|        assert!(app.error_message.is_some());
 2770|      1|        Ok(())
 2771|      1|    }
 2772|       |
 2773|       |    #[test]
 2774|      1|    fn test_empty_directory_drop() -> Result<()> {
 2775|      1|        let mut app = MarkdownViewerApp::new();
 2776|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2777|       |
 2778|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 2779|       |
 2780|      1|        assert!(app.error_message.is_some());
 2781|      1|        assert!(app
 2782|      1|            .error_message
 2783|      1|            .as_ref()
 2784|      1|            .unwrap()
 2785|      1|            .contains("No markdown files"));
 2786|      1|        Ok(())
 2787|      1|    }
 2788|       |
 2789|       |    #[test]
 2790|      1|    fn test_open_file_dialog_stub_sets_error() {
 2791|      1|        let mut app = MarkdownViewerApp::new();
 2792|      1|        app.open_file_dialog();
 2793|      1|        assert_eq!(
 2794|      1|            app.error_message.as_deref(),
 2795|       |            Some("File dialog disabled in tests")
 2796|       |        );
 2797|      1|    }
 2798|       |
 2799|       |    #[test]
 2800|      1|    fn test_prompt_save_path_stub_returns_none() {
 2801|      1|        let app = MarkdownViewerApp::new();
 2802|      1|        assert!(app.prompt_save_path().is_none());
 2803|      1|    }
 2804|       |
 2805|       |    #[test]
 2806|      1|    fn test_save_current_document_writes_file() -> Result<()> {
 2807|      1|        let mut app = MarkdownViewerApp::new();
 2808|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2809|      1|        let file_path = temp_dir.path().join("doc.md");
 2810|      1|        app.current_file = Some(file_path.clone());
 2811|      1|        app.current_content = "Hello world".to_string();
 2812|       |
 2813|      1|        app.save_current_document()?;
                                                 ^0
 2814|      1|        let saved = std::fs::read_to_string(&file_path)?;
                                                                     ^0
 2815|      1|        assert_eq!(saved, "Hello world");
 2816|      1|        Ok(())
 2817|      1|    }
 2818|       |
 2819|       |    #[test]
 2820|      1|    fn test_render_menu_and_context_helpers() {
 2821|      1|        let mut app = MarkdownViewerApp::new();
 2822|      1|        app.current_content = "content".to_string();
 2823|      1|        app.current_file = Some(PathBuf::from("doc.md"));
 2824|      1|        app.history = vec![
 2825|      1|            HistoryEntry {
 2826|      1|                file_path: None,
 2827|      1|                title: "first".to_string(),
 2828|      1|                content: "one".to_string(),
 2829|      1|            },
 2830|      1|            HistoryEntry {
 2831|      1|                file_path: None,
 2832|      1|                title: "second".to_string(),
 2833|      1|                content: "two".to_string(),
 2834|      1|            },
 2835|       |        ];
 2836|      1|        app.history_index = 1;
 2837|       |
 2838|      1|        with_test_ui(|ctx, ui| {
 2839|      1|            app.render_file_menu(ui, false, Color32::WHITE);
 2840|      1|            app.render_view_menu(ui, ctx, false, Color32::WHITE);
 2841|      1|            app.render_help_menu(ui);
 2842|      1|            app.render_main_context_menu(ui);
 2843|      1|        });
 2844|      1|    }
 2845|       |
 2846|       |    #[test]
 2847|      1|    fn test_update_inner_rendered_mode_smoke() {
 2848|      1|        let mut app = MarkdownViewerApp::new();
 2849|      1|        app.load_content("# Title\n\nParagraph text", Some("Doc".to_string()));
 2850|      1|        app.pending_scroll_to_element = Some(0);
 2851|      1|        app.nav_request = Some(NavigationRequest::Top);
 2852|      1|        app.show_search = true;
 2853|      1|        app.search_query = "Paragraph".to_string();
 2854|       |
 2855|      1|        run_update(&mut app, test_input());
 2856|      1|        assert!(app.pending_scroll_to_element.is_none());
 2857|      1|    }
 2858|       |
 2859|       |    #[test]
 2860|      1|    fn test_update_inner_raw_mode_smoke() {
 2861|      1|        let mut app = MarkdownViewerApp::new();
 2862|      1|        app.load_content("Line1\nLine2\nLine3\n", Some("Doc".to_string()));
 2863|      1|        app.view_mode = ViewMode::Raw;
 2864|      1|        app.write_enabled = true;
 2865|      1|        app.raw_buffer = app.current_content.clone();
 2866|      1|        app.raw_cursor = Some(0);
 2867|      1|        app.raw_focus_requested = true;
 2868|       |
 2869|      1|        run_update(&mut app, test_input());
 2870|       |
 2871|      1|        app.pending_raw_cursor_line_move = Some(1);
 2872|      1|        run_update(&mut app, test_input());
 2873|      1|    }
 2874|       |
 2875|       |    #[test]
 2876|      1|    fn test_handle_shortcuts_save_and_flags() -> Result<()> {
 2877|      1|        let mut app = MarkdownViewerApp::new();
 2878|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2879|      1|        let file_path = temp_dir.path().join("save.md");
 2880|      1|        app.current_file = Some(file_path.clone());
 2881|      1|        app.current_content = "Saved content".to_string();
 2882|       |
 2883|      1|        let mut input = test_input();
 2884|      1|        input.events = vec![
 2885|      1|            egui::Event::Key {
 2886|      1|                key: egui::Key::F,
 2887|      1|                physical_key: None,
 2888|      1|                pressed: true,
 2889|      1|                modifiers: egui::Modifiers::CTRL,
 2890|      1|                repeat: false,
 2891|      1|            },
 2892|      1|            egui::Event::Key {
 2893|      1|                key: egui::Key::R,
 2894|      1|                physical_key: None,
 2895|      1|                pressed: true,
 2896|      1|                modifiers: egui::Modifiers::CTRL,
 2897|      1|                repeat: false,
 2898|      1|            },
 2899|      1|            egui::Event::Key {
 2900|      1|                key: egui::Key::E,
 2901|      1|                physical_key: None,
 2902|      1|                pressed: true,
 2903|      1|                modifiers: egui::Modifiers::CTRL,
 2904|      1|                repeat: false,
 2905|      1|            },
 2906|      1|            egui::Event::Key {
 2907|      1|                key: egui::Key::S,
 2908|      1|                physical_key: None,
 2909|      1|                pressed: true,
 2910|      1|                modifiers: egui::Modifiers::CTRL,
 2911|      1|                repeat: false,
 2912|      1|            },
 2913|      1|            egui::Event::Key {
 2914|      1|                key: egui::Key::F11,
 2915|      1|                physical_key: None,
 2916|      1|                pressed: true,
 2917|      1|                modifiers: egui::Modifiers::NONE,
 2918|      1|                repeat: false,
 2919|      1|            },
 2920|      1|            egui::Event::Key {
 2921|      1|                key: egui::Key::F5,
 2922|      1|                physical_key: None,
 2923|      1|                pressed: true,
 2924|      1|                modifiers: egui::Modifiers::NONE,
 2925|      1|                repeat: false,
 2926|      1|            },
 2927|      1|            egui::Event::Key {
 2928|      1|                key: egui::Key::PageUp,
 2929|      1|                physical_key: None,
 2930|      1|                pressed: true,
 2931|      1|                modifiers: egui::Modifiers::NONE,
 2932|      1|                repeat: false,
 2933|      1|            },
 2934|      1|            egui::Event::Key {
 2935|      1|                key: egui::Key::ArrowDown,
 2936|      1|                physical_key: None,
 2937|      1|                pressed: true,
 2938|      1|                modifiers: egui::Modifiers::NONE,
 2939|      1|                repeat: false,
 2940|      1|            },
 2941|       |        ];
 2942|       |
 2943|      1|        let ctx = egui::Context::default();
 2944|      1|        ctx.begin_frame(input);
 2945|      1|        app.handle_shortcuts(&ctx);
 2946|      1|        let _ = ctx.end_frame();
 2947|       |
 2948|      1|        assert!(app.show_search);
 2949|      1|        assert!(app.view_toggle_requested);
 2950|      1|        assert!(app.write_toggle_requested);
 2951|      1|        assert!(app.toggle_fullscreen);
 2952|      1|        assert!(app.reload_requested);
 2953|      1|        assert!(app.nav_request.is_some());
 2954|       |
 2955|      1|        let saved = std::fs::read_to_string(&file_path)?;
                                                                     ^0
 2956|      1|        assert_eq!(saved, "Saved content");
 2957|      1|        Ok(())
 2958|      1|    }
 2959|       |
 2960|       |    #[test]
 2961|      1|    fn test_handle_shortcuts_open_and_close() {
 2962|      1|        let mut app = MarkdownViewerApp::new();
 2963|      1|        app.load_content("Content", Some("Doc".to_string()));
 2964|       |
 2965|      1|        let mut input = test_input();
 2966|      1|        input.events = vec![
 2967|      1|            egui::Event::Key {
 2968|      1|                key: egui::Key::O,
 2969|      1|                physical_key: None,
 2970|      1|                pressed: true,
 2971|      1|                modifiers: egui::Modifiers::CTRL,
 2972|      1|                repeat: false,
 2973|      1|            },
 2974|      1|            egui::Event::Key {
 2975|      1|                key: egui::Key::O,
 2976|      1|                physical_key: None,
 2977|      1|                pressed: true,
 2978|      1|                modifiers: egui::Modifiers::ALT,
 2979|      1|                repeat: false,
 2980|      1|            },
 2981|      1|            egui::Event::Key {
 2982|      1|                key: egui::Key::W,
 2983|      1|                physical_key: None,
 2984|      1|                pressed: true,
 2985|      1|                modifiers: egui::Modifiers::CTRL,
 2986|      1|                repeat: false,
 2987|      1|            },
 2988|      1|            egui::Event::Key {
 2989|      1|                key: egui::Key::W,
 2990|      1|                physical_key: None,
 2991|      1|                pressed: true,
 2992|      1|                modifiers: egui::Modifiers::ALT,
 2993|      1|                repeat: false,
 2994|      1|            },
 2995|       |        ];
 2996|       |
 2997|      1|        let ctx = egui::Context::default();
 2998|      1|        ctx.begin_frame(input);
 2999|      1|        app.handle_shortcuts(&ctx);
 3000|      1|        let _ = ctx.end_frame();
 3001|       |
 3002|      1|        assert!(app.current_file.is_none());
 3003|      1|    }
 3004|       |
 3005|       |    #[test]
 3006|      1|    fn test_handle_shortcuts_ctrl_mousewheel_zoom() {
 3007|      1|        let mut app = MarkdownViewerApp::new();
 3008|      1|        let original = app.renderer.font_sizes().body;
 3009|       |
 3010|      1|        let mut input = test_input();
 3011|      1|        input.modifiers = egui::Modifiers::CTRL;
 3012|      1|        input.events = vec![egui::Event::MouseWheel {
 3013|      1|            unit: egui::MouseWheelUnit::Point,
 3014|      1|            delta: egui::vec2(0.0, 1.0),
 3015|      1|            modifiers: egui::Modifiers::CTRL,
 3016|      1|        }];
 3017|       |
 3018|      1|        let ctx = egui::Context::default();
 3019|      1|        ctx.begin_frame(input);
 3020|      1|        app.handle_shortcuts(&ctx);
 3021|      1|        let _ = ctx.end_frame();
 3022|       |
 3023|      1|        assert!(app.renderer.font_sizes().body > original);
 3024|      1|    }
 3025|       |
 3026|       |    #[test]
 3027|      1|    fn test_handle_shortcuts_raw_edit_page_navigation() {
 3028|      1|        let mut app = MarkdownViewerApp::new();
 3029|      1|        app.view_mode = ViewMode::Raw;
 3030|      1|        app.write_enabled = true;
 3031|       |
 3032|      1|        let mut input = test_input();
 3033|      1|        input.events = vec![egui::Event::Key {
 3034|      1|            key: egui::Key::PageDown,
 3035|      1|            physical_key: None,
 3036|      1|            pressed: true,
 3037|      1|            modifiers: egui::Modifiers::NONE,
 3038|      1|            repeat: false,
 3039|      1|        }];
 3040|       |
 3041|      1|        let ctx = egui::Context::default();
 3042|      1|        ctx.begin_frame(input);
 3043|      1|        app.handle_shortcuts(&ctx);
 3044|      1|        let _ = ctx.end_frame();
 3045|       |
 3046|      1|        assert_eq!(app.pending_raw_cursor_line_move, Some(24));
 3047|      1|    }
 3048|       |
 3049|       |    #[test]
 3050|      1|    fn test_handle_drag_drop_events_and_overlay() -> Result<()> {
 3051|      1|        let mut app = MarkdownViewerApp::new();
 3052|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3053|      1|        let file_path = temp_dir.path().join("drop.md");
 3054|      1|        std::fs::write(&file_path, "# Temp")?;
                                                          ^0
 3055|       |
 3056|      1|        let mut input = test_input();
 3057|      1|        input.hovered_files = vec![egui::HoveredFile {
 3058|      1|            path: Some(file_path.clone()),
 3059|      1|            ..Default::default()
 3060|      1|        }];
 3061|      1|        input.dropped_files = vec![egui::DroppedFile {
 3062|      1|            path: Some(file_path.clone()),
 3063|      1|            ..Default::default()
 3064|      1|        }];
 3065|       |
 3066|      1|        let ctx = egui::Context::default();
 3067|      1|        ctx.begin_frame(input);
 3068|      1|        app.handle_drag_drop_events(&ctx);
 3069|      1|        app.render_drag_overlay(&ctx);
 3070|      1|        let _ = ctx.end_frame();
 3071|       |
 3072|      1|        assert!(app.drag_hover);
 3073|      1|        assert_eq!(app.current_file, Some(file_path));
 3074|      1|        Ok(())
 3075|      1|    }
 3076|       |
 3077|       |    #[test]
 3078|      1|    fn test_render_status_bar_smoke() {
 3079|      1|        let mut app = MarkdownViewerApp::new();
 3080|      1|        app.load_content("Body text", Some("Doc".to_string()));
 3081|      1|        app.pending_files.push_back(PathBuf::from("next.md"));
 3082|       |
 3083|      1|        let ctx = egui::Context::default();
 3084|      1|        ctx.begin_frame(test_input());
 3085|      1|        app.render_status_bar(&ctx);
 3086|      1|        let _ = ctx.end_frame();
 3087|      1|    }
 3088|       |}

C:\language\mdmdview\src\emoji_assets.rs:
    1|       |use egui::Color32 as C;
    2|       |
    3|       |// Draw simple vector fallback icons for a subset of emoji.
    4|      8|pub fn make_image(emoji: &str, size: usize) -> Option<egui::ColorImage> {
    5|      8|    let mut img = egui::ColorImage::new([size, size], C::TRANSPARENT);
    6|      8|    match emoji {
    7|      8|        "\u{2705}" => {
    8|      1|            draw_circle(&mut img, size, C::from_rgb(34, 139, 34));
    9|      1|            draw_check(&mut img, size, C::WHITE);
   10|      1|            Some(img)
   11|       |        }
   12|      7|        "\u{1f389}" => {
   13|      1|            draw_circle(&mut img, size, C::from_rgb(255, 215, 0));
   14|      1|            confetti(&mut img, size);
   15|      1|            Some(img)
   16|       |        }
   17|      6|        "\u{1f680}" => {
   18|      1|            draw_circle(&mut img, size, C::from_rgb(60, 60, 170));
   19|      1|            rocket(
   20|      1|                &mut img,
   21|      1|                size,
   22|      1|                C::from_rgb(230, 230, 230),
   23|      1|                C::from_rgb(255, 110, 60),
   24|       |            );
   25|      1|            Some(img)
   26|       |        }
   27|      5|        "\u{2764}" | "\u{1f496}" => {
                                   ^4
   28|      2|            heart(&mut img, size, C::from_rgb(220, 20, 60));
   29|      2|            Some(img)
   30|       |        }
   31|      3|        "\u{2b50}" => {
   32|      1|            star(&mut img, size, C::from_rgb(255, 215, 0));
   33|      1|            Some(img)
   34|       |        }
   35|      2|        "\u{1f525}" => {
   36|      1|            flame(&mut img, size);
   37|      1|            Some(img)
   38|       |        }
   39|      1|        _ => None,
   40|       |    }
   41|      8|}
   42|       |
   43|      3|fn draw_circle(img: &mut egui::ColorImage, size: usize, color: C) {
   44|      3|    let cx = (size as i32) / 2;
   45|      3|    let cy = cx;
   46|      3|    let r = (size as i32) / 2 - 2;
   47|     72|    for y in 0..size as i32 {
                              ^3
   48|  1.72k|        for x in 0..size as i32 {
                                  ^72
   49|  1.72k|            let dx = x - cx;
   50|  1.72k|            let dy = y - cy;
   51|  1.72k|            if dx * dx + dy * dy <= r * r {
   52|    951|                img[(x as usize, y as usize)] = color;
   53|    951|            }
                          ^777
   54|       |        }
   55|       |    }
   56|      3|}
   57|       |
   58|      1|fn draw_check(img: &mut egui::ColorImage, size: usize, color: C) {
   59|      1|    let s = size as i32;
   60|     40|    let mut plot = |x: i32, y: i32| {
                      ^1
   61|     40|        if x >= 0 && y >= 0 && x < s && y < s {
   62|     40|            img[(x as usize, y as usize)] = color;
   63|     40|        }
                      ^0
   64|     40|    };
   65|       |    // simple check mark
   66|      8|    for i in 0..s / 3 {
                              ^1
   67|      8|        plot(s / 3 - i, s * 2 / 3 + i);
   68|      8|        plot(s / 3 - i + 1, s * 2 / 3 + i);
   69|      8|    }
   70|     12|    for i in 0..s / 2 {
                              ^1
   71|     12|        plot(s / 3 + i, s * 2 / 3 - i);
   72|     12|        plot(s / 3 + i + 1, s * 2 / 3 - i);
   73|     12|    }
   74|      1|}
   75|       |
   76|      1|fn confetti(img: &mut egui::ColorImage, size: usize) {
   77|      1|    let dots = [
   78|      1|        C::from_rgb(255, 80, 80),
   79|      1|        C::from_rgb(80, 180, 255),
   80|      1|        C::from_rgb(120, 220, 120),
   81|      1|        C::from_rgb(220, 120, 220),
   82|      1|    ];
   83|      1|    let s = size as i32;
   84|      4|    for (i, col) in dots.iter().enumerate() {
                                  ^1   ^1     ^1
   85|      4|        let x = (s / 4) * ((i as i32) + 1);
   86|      4|        let y = (s / 5) * ((i as i32) + 1);
   87|      4|        if x < s && y < s {
                                  ^3
   88|      3|            img[(x as usize, y as usize)] = *col;
   89|      3|        }
                      ^1
   90|       |    }
   91|      1|}
   92|       |
   93|      1|fn rocket(img: &mut egui::ColorImage, size: usize, body: C, flame: C) {
   94|      1|    let s = size as i32;
   95|       |    // body
   96|     12|    for y in s / 4..s * 3 / 4 {
                           ^1     ^1
   97|     96|        for x in s / 3..s * 2 / 3 {
                               ^12    ^12
   98|     96|            img[(x as usize, y as usize)] = body;
   99|     96|        }
  100|       |    }
  101|       |    // nose
  102|      4|    for i in 0..s / 6 {
                              ^1
  103|     16|        for x in s / 2 - i..=s / 2 + i {
                               ^4          ^4
  104|     16|            let y = s / 4 - i;
  105|     16|            if y >= 0 {
  106|     16|                img[(x as usize, y as usize)] = body;
  107|     16|            }
                          ^0
  108|       |        }
  109|       |    }
  110|       |    // flame
  111|      4|    for i in 0..s / 6 {
                              ^1
  112|     16|        for x in s / 2 - i..=s / 2 + i {
                               ^4          ^4
  113|     16|            let y = s * 3 / 4 + i;
  114|     16|            if y < s {
  115|     16|                img[(x as usize, y as usize)] = flame;
  116|     16|            }
                          ^0
  117|       |        }
  118|       |    }
  119|      1|}
  120|       |
  121|      2|fn heart(img: &mut egui::ColorImage, size: usize, color: C) {
  122|      2|    let s = size as i32;
  123|     48|    for y in 0..s {
                              ^2
  124|  1.15k|        for x in 0..s {
                                  ^48
  125|  1.15k|            let dx = x - s / 2;
  126|  1.15k|            let dy = y - s / 3;
  127|  1.15k|            let a = (dx * dx + dy * dy - s * s / 16) < 0;
  128|  1.15k|            let b = x > s / 4 && x < 3 * s / 4 && y > s / 3 && y < s * 3 / 4;
                                               ^816             ^528         ^330
  129|  1.15k|            if a || b {
                                  ^934
  130|    318|                img[(x as usize, y as usize)] = color;
  131|    834|            }
  132|       |        }
  133|       |    }
  134|      2|}
  135|       |
  136|      1|fn star(img: &mut egui::ColorImage, size: usize, color: C) {
  137|      1|    let s = size as i32;
  138|     24|    for i in 0..s {
                              ^1
  139|     24|        let y = i;
  140|     24|        let x1 = s / 2;
  141|     24|        let x2 = s / 2 - i / 2;
  142|     24|        let x3 = s / 2 + i / 2;
  143|     24|        if x2 >= 0 {
  144|     24|            img[(x2 as usize, y as usize)] = color;
  145|     24|        }
                      ^0
  146|     24|        img[(x1 as usize, y as usize)] = color;
  147|     24|        if x3 < s {
  148|     24|            img[(x3 as usize, y as usize)] = color;
  149|     24|        }
                      ^0
  150|       |    }
  151|      1|}
  152|       |
  153|      1|fn flame(img: &mut egui::ColorImage, size: usize) {
  154|      1|    let s = size as i32;
  155|      1|    let base = C::from_rgb(255, 140, 0);
  156|      1|    let tip = C::from_rgb(255, 220, 120);
  157|     24|    for y in 0..s {
                              ^1
  158|    576|        for x in 0..s {
                                  ^24
  159|    576|            let dx = (x - s / 2) as f32 / (s as f32 / 3.5);
  160|    576|            let dy = (y - s) as f32 / (s as f32 / 1.5);
  161|    576|            let v = (dx * dx + dy * dy).sqrt();
  162|    576|            if v < 1.0 {
  163|    161|                let t = 1.0 - v;
  164|    161|                img[(x as usize, y as usize)] = C::from_rgb(
  165|    161|                    (base.r() as f32 * t + tip.r() as f32 * (1.0 - t)) as u8,
  166|    161|                    (base.g() as f32 * t + tip.g() as f32 * (1.0 - t)) as u8,
  167|    161|                    (base.b() as f32 * t + tip.b() as f32 * (1.0 - t)) as u8,
  168|    161|                );
  169|    415|            }
  170|       |        }
  171|       |    }
  172|      1|}
  173|       |
  174|       |#[cfg(test)]
  175|       |mod tests {
  176|       |    use super::*;
  177|       |
  178|      7|    fn has_non_transparent_pixel(img: &egui::ColorImage) -> bool {
  179|    587|        img.pixels.iter().any(|p| p.a() != 0)
                      ^7                ^7
  180|      7|    }
  181|       |
  182|       |    #[test]
  183|      1|    fn test_make_image_known_emojis_produce_pixels() {
  184|      1|        let emojis = [
  185|      1|            "\u{2705}",
  186|      1|            "\u{1f389}",
  187|      1|            "\u{1f680}",
  188|      1|            "\u{2764}",
  189|      1|            "\u{1f496}",
  190|      1|            "\u{2b50}",
  191|      1|            "\u{1f525}",
  192|      1|        ];
  193|       |
  194|      8|        for emoji in emojis {
                          ^7
  195|      7|            let img = make_image(emoji, 24).expect("expected fallback image");
  196|      7|            assert!(has_non_transparent_pixel(&img));
  197|       |        }
  198|      1|    }
  199|       |
  200|       |    #[test]
  201|      1|    fn test_make_image_unknown_returns_none() {
  202|      1|        assert!(make_image("\u{1f47d}", 24).is_none());
  203|      1|    }
  204|       |}

C:\language\mdmdview\src\emoji_catalog.rs:
    1|       |use std::collections::HashMap;
    2|       |
    3|       |// Return embedded emoji sprites keyed by real Unicode emoji characters.
    4|    154|pub fn image_bytes_for(emoji: &str) -> Option<&'static [u8]> {
    5|    154|    match emoji {
    6|    154|        "\u{1f389}" => Some(include_bytes!(concat!(
    7|      2|            env!("CARGO_MANIFEST_DIR"),
    8|      2|            "/assets/emoji/1f389.png"
    9|      2|        ))),
   10|    152|        "\u{2705}" => Some(include_bytes!(concat!(
   11|      1|            env!("CARGO_MANIFEST_DIR"),
   12|      1|            "/assets/emoji/2705.png"
   13|      1|        ))),
   14|    151|        "\u{1f680}" => Some(include_bytes!(concat!(
   15|      3|            env!("CARGO_MANIFEST_DIR"),
   16|      3|            "/assets/emoji/1f680.png"
   17|      3|        ))),
   18|    148|        "\u{1f642}" => Some(include_bytes!(concat!(
   19|      1|            env!("CARGO_MANIFEST_DIR"),
   20|      1|            "/assets/emoji/1f642.png"
   21|      1|        ))),
   22|    147|        "\u{1f600}" => Some(include_bytes!(concat!(
   23|      1|            env!("CARGO_MANIFEST_DIR"),
   24|      1|            "/assets/emoji/1f600.png"
   25|      1|        ))),
   26|    146|        "\u{1f609}" => Some(include_bytes!(concat!(
   27|      1|            env!("CARGO_MANIFEST_DIR"),
   28|      1|            "/assets/emoji/1f609.png"
   29|      1|        ))),
   30|    145|        "\u{2b50}" => Some(include_bytes!(concat!(
   31|      1|            env!("CARGO_MANIFEST_DIR"),
   32|      1|            "/assets/emoji/2b50.png"
   33|      1|        ))),
   34|    144|        "\u{1f525}" => Some(include_bytes!(concat!(
   35|      1|            env!("CARGO_MANIFEST_DIR"),
   36|      1|            "/assets/emoji/1f525.png"
   37|      1|        ))),
   38|    143|        "\u{1f44d}" => Some(include_bytes!(concat!(
   39|      1|            env!("CARGO_MANIFEST_DIR"),
   40|      1|            "/assets/emoji/1f44d.png"
   41|      1|        ))),
   42|    142|        "\u{1f44e}" => Some(include_bytes!(concat!(
   43|      1|            env!("CARGO_MANIFEST_DIR"),
   44|      1|            "/assets/emoji/1f44e.png"
   45|      1|        ))),
   46|    141|        "\u{1f4a1}" => Some(include_bytes!(concat!(
   47|      1|            env!("CARGO_MANIFEST_DIR"),
   48|      1|            "/assets/emoji/1f4a1.png"
   49|      1|        ))),
   50|    140|        "\u{2753}" => Some(include_bytes!(concat!(
   51|      1|            env!("CARGO_MANIFEST_DIR"),
   52|      1|            "/assets/emoji/2753.png"
   53|      1|        ))),
   54|    139|        "\u{2757}" => Some(include_bytes!(concat!(
   55|      1|            env!("CARGO_MANIFEST_DIR"),
   56|      1|            "/assets/emoji/2757.png"
   57|      1|        ))),
   58|    138|        "\u{1f4dd}" => Some(include_bytes!(concat!(
   59|      1|            env!("CARGO_MANIFEST_DIR"),
   60|      1|            "/assets/emoji/1f4dd.png"
   61|      1|        ))),
   62|    137|        "\u{1f9e0}" => Some(include_bytes!(concat!(
   63|      1|            env!("CARGO_MANIFEST_DIR"),
   64|      1|            "/assets/emoji/1f9e0.png"
   65|      1|        ))),
   66|    136|        "\u{1f9ea}" => Some(include_bytes!(concat!(
   67|      1|            env!("CARGO_MANIFEST_DIR"),
   68|      1|            "/assets/emoji/1f9ea.png"
   69|      1|        ))),
   70|    135|        "\u{1f4e6}" => Some(include_bytes!(concat!(
   71|      1|            env!("CARGO_MANIFEST_DIR"),
   72|      1|            "/assets/emoji/1f4e6.png"
   73|      1|        ))),
   74|    134|        "\u{1f527}" => Some(include_bytes!(concat!(
   75|      1|            env!("CARGO_MANIFEST_DIR"),
   76|      1|            "/assets/emoji/1f527.png"
   77|      1|        ))),
   78|    133|        _ => None,
   79|       |    }
   80|    154|}
   81|       |
   82|      6|pub fn shortcode_map() -> &'static HashMap<&'static str, &'static str> {
   83|       |    use std::sync::OnceLock;
   84|       |    static MAP: OnceLock<HashMap<&'static str, &'static str>> = OnceLock::new();
   85|      6|    MAP.get_or_init(|| {
                                     ^1
   86|      1|        HashMap::from([
   87|      1|            (":tada:", "\u{1f389}"),
   88|      1|            (":white_check_mark:", "\u{2705}"),
   89|      1|            (":check_mark:", "\u{2705}"),
   90|      1|            (":rocket:", "\u{1f680}"),
   91|      1|            (":slightly_smiling_face:", "\u{1f642}"),
   92|      1|            (":grinning:", "\u{1f600}"),
   93|      1|            (":wink:", "\u{1f609}"),
   94|      1|            (":star:", "\u{2b50}"),
   95|      1|            (":fire:", "\u{1f525}"),
   96|      1|            (":thumbsup:", "\u{1f44d}"),
   97|      1|            (":thumbsdown:", "\u{1f44e}"),
   98|      1|            (":bulb:", "\u{1f4a1}"),
   99|      1|            (":question:", "\u{2753}"),
  100|      1|            (":exclamation:", "\u{2757}"),
  101|      1|            (":memo:", "\u{1f4dd}"),
  102|      1|            (":brain:", "\u{1f9e0}"),
  103|      1|            (":test_tube:", "\u{1f9ea}"),
  104|      1|            (":package:", "\u{1f4e6}"),
  105|      1|            (":wrench:", "\u{1f527}"),
  106|      1|        ])
  107|      1|    })
  108|      6|}
  109|       |
  110|       |#[cfg(test)]
  111|       |mod tests {
  112|       |    use super::*;
  113|       |
  114|       |    #[test]
  115|      1|    fn test_image_bytes_for_known_emojis() {
  116|      1|        let emojis = [
  117|      1|            "\u{1f389}",
  118|      1|            "\u{2705}",
  119|      1|            "\u{1f680}",
  120|      1|            "\u{1f642}",
  121|      1|            "\u{1f600}",
  122|      1|            "\u{1f609}",
  123|      1|            "\u{2b50}",
  124|      1|            "\u{1f525}",
  125|      1|            "\u{1f44d}",
  126|      1|            "\u{1f44e}",
  127|      1|            "\u{1f4a1}",
  128|      1|            "\u{2753}",
  129|      1|            "\u{2757}",
  130|      1|            "\u{1f4dd}",
  131|      1|            "\u{1f9e0}",
  132|      1|            "\u{1f9ea}",
  133|      1|            "\u{1f4e6}",
  134|      1|            "\u{1f527}",
  135|      1|        ];
  136|       |
  137|     19|        for emoji in emojis {
                          ^18
  138|     18|            let bytes = image_bytes_for(emoji).expect("expected embedded emoji bytes");
  139|     18|            assert!(!bytes.is_empty());
  140|       |        }
  141|      1|    }
  142|       |
  143|       |    #[test]
  144|      1|    fn test_image_bytes_for_unknown_emoji() {
  145|      1|        assert!(image_bytes_for("\u{1f47d}").is_none());
  146|      1|    }
  147|       |
  148|       |    #[test]
  149|      1|    fn test_shortcode_map_contains_expected_entries() {
  150|      1|        let map = shortcode_map();
  151|      1|        assert_eq!(map.get(":tada:"), Some(&"\u{1f389}"));
  152|      1|        assert_eq!(map.get(":white_check_mark:"), Some(&"\u{2705}"));
  153|      1|        assert_eq!(map.get(":rocket:"), Some(&"\u{1f680}"));
  154|      1|        assert_eq!(map.get(":fire:"), Some(&"\u{1f525}"));
  155|      1|        assert_eq!(map.get(":wrench:"), Some(&"\u{1f527}"));
  156|      1|        assert!(map.get(":does_not_exist:").is_none());
  157|      1|    }
  158|       |}

C:\language\mdmdview\src\main.rs:
    1|       |#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")] // Hide console in release mode
    2|       |
    3|       |/// Main entry point for the MarkdownView application
    4|       |///
    5|       |/// A simple, standalone markdown viewer for Windows built with Rust and egui.
    6|       |/// This application provides a clean interface for viewing markdown files with
    7|       |/// syntax highlighting, embedded samples, and essential viewing features.
    8|       |use mdmdview::{load_window_state, sanitize_window_state, MarkdownViewerApp, APP_TITLE_PREFIX};
    9|       |
   10|       |/// Application entry point
   11|      0|fn main() -> Result<(), eframe::Error> {
   12|       |    // Configure logging for debugging (only in debug builds)
   13|       |    #[cfg(debug_assertions)]
   14|      0|    env_logger::init();
   15|       |
   16|       |    // Parse command line arguments
   17|      0|    let mut initial_file: Option<std::path::PathBuf> = None;
   18|      0|    let mut table_wrap_cli: Option<bool> = None;
   19|      0|    for arg in std::env::args().skip(1) {
   20|      0|        match arg.as_str() {
   21|      0|            "--table-wrap" => table_wrap_cli = Some(true),
   22|      0|            "--no-table-wrap" => table_wrap_cli = Some(false),
   23|      0|            _ if initial_file.is_none() => initial_file = Some(std::path::PathBuf::from(&arg)),
   24|      0|            _ => {}
   25|       |        }
   26|       |    }
   27|      0|    let table_wrap_env = std::env::var("MDMDVIEW_TABLE_WRAP_OVERHAUL")
   28|      0|        .ok()
   29|      0|        .and_then(|value| parse_bool_flag(&value));
   30|      0|    let table_wrap_enabled = table_wrap_cli.or(table_wrap_env).unwrap_or(true);
   31|       |
   32|       |    // Set up eframe options for the native window
   33|      0|    let mut viewport = egui::ViewportBuilder::default()
   34|      0|        .with_title(format!("{APP_TITLE_PREFIX} - A Simple Markdown Viewer"))
   35|      0|        .with_inner_size(egui::Vec2::new(1000.0, 700.0))
   36|      0|        .with_min_inner_size(egui::Vec2::new(600.0, 400.0))
   37|      0|        .with_icon(create_app_icon())
   38|      0|        .with_resizable(true)
   39|      0|        .with_maximize_button(true)
   40|      0|        .with_minimize_button(true)
   41|      0|        .with_drag_and_drop(true);
   42|       |
   43|       |    // Restore previous window position/size if available
   44|      0|    if let Some(ws) = load_window_state() {
   45|      0|        if let Some(ws) = sanitize_window_state(ws) {
   46|      0|            viewport = viewport
   47|      0|                .with_inner_size(egui::Vec2::new(ws.size[0], ws.size[1]))
   48|      0|                .with_position(egui::pos2(ws.pos[0], ws.pos[1]))
   49|      0|                .with_maximized(ws.maximized);
   50|      0|        }
   51|      0|    }
   52|       |
   53|      0|    let native_options = eframe::NativeOptions {
   54|      0|        viewport,
   55|      0|        // Keep native persist as well; our explicit file handles crossplatform dirs
   56|      0|        persist_window: true,
   57|      0|        ..Default::default()
   58|      0|    };
   59|       |
   60|       |    // Launch the application
   61|      0|    eframe::run_native(
   62|      0|        APP_TITLE_PREFIX,
   63|      0|        native_options,
   64|      0|        Box::new(move |cc| {
   65|       |            // Configure egui styling for better markdown display
   66|      0|            configure_egui_style(&cc.egui_ctx);
   67|       |
   68|      0|            let mut app = MarkdownViewerApp::new();
   69|      0|            app.set_table_wrap_overhaul_enabled(table_wrap_enabled);
   70|       |
   71|       |            // Load initial file if provided via command line
   72|      0|            if let Some(file_path) = initial_file {
   73|      0|                if file_path.exists() && file_path.is_file() {
   74|      0|                    if let Err(e) = app.load_file(file_path, true) {
   75|      0|                        eprintln!("Failed to load file: {}", e);
   76|      0|                        // Continue with default welcome screen
   77|      0|                    }
   78|      0|                } else {
   79|      0|                    eprintln!("File not found: {}", file_path.display());
   80|      0|                    // Continue with default welcome screen
   81|      0|                }
   82|      0|            }
   83|       |
   84|      0|            Box::new(app)
   85|      0|        }),
   86|       |    )
   87|      0|}
   88|       |
   89|       |/// Create an application icon from embedded data
   90|      2|fn create_app_icon() -> egui::IconData {
   91|       |    // Create a 32x32 markdown-style document icon
   92|      2|    let size = 32;
   93|      2|    let mut rgba_data = Vec::with_capacity(size * size * 4);
   94|       |
   95|     64|    for y in 0..size {
                              ^2
   96|  2.04k|        for x in 0..size {
                                  ^64
   97|  2.04k|            let (r, g, b, a) = if x == 0 || x == size - 1 || y == 0 || y == size - 1 {
                                                          ^1.98k           ^1.92k    ^1.86k
   98|       |                // Border
   99|    248|                (60, 60, 60, 255)
  100|  1.80k|            } else if x == 1 || x == size - 2 || y == 1 || y == size - 2 {
                                              ^1.74k           ^1.68k    ^1.62k
  101|       |                // Inner border for depth
  102|    232|                (80, 80, 80, 255)
  103|  1.56k|            } else if (4..=8).contains(&y) && (4..=28).contains(&x) {
                                                            ^280     ^280     ^280
  104|       |                // Header area (title bar)
  105|    250|                if (6..=12).contains(&x) {
  106|     70|                    (100, 150, 255, 255) // Blue for # header
  107|    180|                } else if (14..=26).contains(&x) {
  108|    130|                    (200, 200, 200, 255) // Light text
  109|       |                } else {
  110|     50|                    (250, 250, 250, 255) // Background
  111|       |                }
  112|  1.31k|            } else if (11..=13).contains(&y) && (4..=28).contains(&x) {
                                                              ^168     ^168     ^168
  113|       |                // Text line 1
  114|    150|                if (6..=8).contains(&x) {
  115|     18|                    (150, 150, 150, 255) // Bullet point
  116|    132|                } else if (10..=24).contains(&x) {
  117|     90|                    (180, 180, 180, 255) // Text
  118|       |                } else {
  119|     42|                    (250, 250, 250, 255) // Background
  120|       |                }
  121|  1.16k|            } else if (15..=17).contains(&y) && (4..=28).contains(&x) {
                                                              ^168     ^168     ^168
  122|       |                // Text line 2
  123|    150|                if (6..=8).contains(&x) {
  124|     18|                    (150, 150, 150, 255) // Bullet point
  125|    132|                } else if (10..=22).contains(&x) {
  126|     78|                    (180, 180, 180, 255) // Text
  127|       |                } else {
  128|     54|                    (250, 250, 250, 255) // Background
  129|       |                }
  130|  1.01k|            } else if (20..=22).contains(&y) && (6..=26).contains(&x) {
                                                              ^168     ^168     ^168
  131|       |                // Code block area
  132|    126|                if (8..=24).contains(&x) {
  133|    102|                    (100, 255, 100, 255) // Green code text
  134|       |                } else {
  135|     24|                    (40, 40, 40, 255) // Dark background
  136|       |                }
  137|    892|            } else if (25..=27).contains(&y) && (4..=28).contains(&x) {
                                                              ^168     ^168     ^168
  138|       |                // Text line 3
  139|    150|                if (6..=20).contains(&x) {
  140|     90|                    (180, 180, 180, 255) // Text
  141|       |                } else {
  142|     60|                    (250, 250, 250, 255) // Background
  143|       |                }
  144|       |            } else {
  145|       |                // Document background
  146|    742|                (250, 250, 250, 255)
  147|       |            };
  148|       |
  149|  2.04k|            rgba_data.extend_from_slice(&[r, g, b, a]);
  150|       |        }
  151|       |    }
  152|       |
  153|      2|    egui::IconData {
  154|      2|        rgba: rgba_data,
  155|      2|        width: size as u32,
  156|      2|        height: size as u32,
  157|      2|    }
  158|      2|}
  159|       |
  160|       |/// Configure egui styling for optimal markdown display
  161|      1|fn configure_egui_style(ctx: &egui::Context) {
  162|      1|    let mut style = (*ctx.style()).clone();
  163|       |
  164|       |    // Configure spacing for better readability
  165|      1|    style.spacing.item_spacing = egui::Vec2::new(8.0, 8.0);
  166|      1|    style.spacing.window_margin = egui::Margin::same(8.0);
  167|      1|    style.spacing.menu_margin = egui::Margin::same(6.0);
  168|       |
  169|       |    // Configure interaction settings
  170|      1|    style.interaction.resize_grab_radius_side = 8.0;
  171|      1|    style.interaction.resize_grab_radius_corner = 12.0;
  172|       |
  173|       |    // Configure visuals for better contrast with black background
  174|      1|    style.visuals.window_rounding = egui::Rounding::same(4.0);
  175|      1|    style.visuals.menu_rounding = egui::Rounding::same(4.0);
  176|       |
  177|       |    // Set to true black background for maximum contrast
  178|      1|    if style.visuals.dark_mode {
  179|      1|        style.visuals.window_fill = egui::Color32::BLACK;
  180|      1|        style.visuals.panel_fill = egui::Color32::BLACK;
  181|      1|        style.visuals.faint_bg_color = egui::Color32::from_gray(20);
  182|      1|        style.visuals.extreme_bg_color = egui::Color32::BLACK;
  183|      1|        // The text color will be handled by egui's theme system
  184|      1|    }
                  ^0
  185|       |
  186|      1|    ctx.set_style(style);
  187|       |
  188|       |    // Use default fonts - egui has good built-in font support
  189|       |    // Custom fonts could be added here if needed
  190|      1|}
  191|       |
  192|      5|fn parse_bool_flag(value: &str) -> Option<bool> {
  193|      5|    match value.trim().to_ascii_lowercase().as_str() {
  194|      5|        "1" | "true" | "yes" | "on" => Some(true),
                            ^4       ^3      ^3      ^2
  195|      3|        "0" | "false" | "no" | "off" => Some(false),
                            ^2        ^1     ^1       ^2
  196|      1|        _ => None,
  197|       |    }
  198|      5|}
  199|       |
  200|       |#[cfg(test)]
  201|       |mod tests {
  202|       |    use super::*;
  203|       |
  204|       |    #[test]
  205|      1|    fn test_app_icon_creation() {
  206|      1|        let icon = create_app_icon();
  207|      1|        assert_eq!(icon.width, 32);
  208|      1|        assert_eq!(icon.height, 32);
  209|      1|        assert_eq!(icon.rgba.len(), 32 * 32 * 4); // RGBA format
  210|      1|    }
  211|       |
  212|       |    #[test]
  213|      1|    fn test_main_function_setup() {
  214|       |        // Test that the main function components work
  215|       |        // This is a basic smoke test
  216|      1|        let icon = create_app_icon();
  217|      1|        assert!(!icon.rgba.is_empty());
  218|      1|    }
  219|       |
  220|       |    #[test]
  221|      1|    fn test_parse_bool_flag() {
  222|      1|        assert_eq!(parse_bool_flag("true"), Some(true));
  223|      1|        assert_eq!(parse_bool_flag("FALSE"), Some(false));
  224|      1|        assert_eq!(parse_bool_flag("1"), Some(true));
  225|      1|        assert_eq!(parse_bool_flag("0"), Some(false));
  226|      1|        assert_eq!(parse_bool_flag("unknown"), None);
  227|      1|    }
  228|       |
  229|       |    #[test]
  230|      1|    fn test_configure_egui_style_dark_mode() {
  231|      1|        let ctx = egui::Context::default();
  232|      1|        let mut style = (*ctx.style()).clone();
  233|      1|        style.visuals.dark_mode = true;
  234|      1|        ctx.set_style(style);
  235|       |
  236|      1|        configure_egui_style(&ctx);
  237|       |
  238|      1|        let style = ctx.style();
  239|      1|        assert_eq!(style.spacing.item_spacing, egui::Vec2::new(8.0, 8.0));
  240|      1|        assert_eq!(style.spacing.window_margin, egui::Margin::same(8.0));
  241|      1|        assert_eq!(style.spacing.menu_margin, egui::Margin::same(6.0));
  242|      1|        assert_eq!(style.visuals.window_rounding, egui::Rounding::same(4.0));
  243|      1|        assert_eq!(style.visuals.menu_rounding, egui::Rounding::same(4.0));
  244|      1|        assert_eq!(style.visuals.window_fill, egui::Color32::BLACK);
  245|      1|        assert_eq!(style.visuals.panel_fill, egui::Color32::BLACK);
  246|      1|        assert_eq!(style.visuals.faint_bg_color, egui::Color32::from_gray(20));
  247|      1|        assert_eq!(style.visuals.extreme_bg_color, egui::Color32::BLACK);
  248|      1|    }
  249|       |}

C:\language\mdmdview\src\markdown_renderer.rs:
    1|       |use crate::table_support::{
    2|       |    compute_column_stats, derive_column_specs, ColumnPolicy, ColumnSpec, ColumnStat,
    3|       |    TableColumnContext, TableMetrics, WidthChange,
    4|       |};
    5|       |use crate::{emoji_assets, emoji_catalog};
    6|       |use anyhow::Result;
    7|       |use crossbeam_channel::{
    8|       |    bounded, Receiver as KrokiJobReceiver, Sender as KrokiJobSender, TrySendError,
    9|       |};
   10|       |use egui::{
   11|       |    text::{Galley, LayoutJob, TextWrapping},
   12|       |    Align, Color32, Context, FontSelection, Painter, RichText, Stroke, Vec2, Visuals,
   13|       |};
   14|       |use egui_extras::TableBuilder;
   15|       |use pulldown_cmark::{Event, LinkType, Options, Parser, Tag};
   16|       |use std::cell::RefCell;
   17|       |use std::collections::{hash_map::DefaultHasher, HashMap, HashSet, VecDeque};
   18|       |use std::hash::{Hash, Hasher};
   19|       |use std::ops::Range;
   20|       |use std::path::{Path, PathBuf};
   21|       |use std::sync::{mpsc::Receiver, Arc};
   22|       |use std::time::{Duration, SystemTime};
   23|       |use syntect::easy::HighlightLines;
   24|       |use syntect::highlighting::ThemeSet;
   25|       |use syntect::parsing::SyntaxSet;
   26|       |use syntect::util::LinesWithEndings;
   27|       |use unicode_casefold::UnicodeCaseFold;
   28|       |use unicode_normalization::UnicodeNormalization;
   29|       |use unicode_segmentation::UnicodeSegmentation;
   30|       |
   31|       |// Embedded Mermaid JS bytes are generated in build.rs into OUT_DIR.
   32|       |// Place mermaid.min.js at assets/vendor/mermaid.min.js to embed it.
   33|       |#[cfg(feature = "mermaid-quickjs")]
   34|       |mod mermaid_embed {
   35|       |    include!(concat!(env!("OUT_DIR"), "/mermaid_js.rs"));
   36|       |}
   37|       |
   38|       |#[cfg(feature = "mermaid-quickjs")]
   39|       |struct MermaidEngine {
   40|       |    #[allow(dead_code)]
   41|       |    rt: rquickjs::Runtime,
   42|       |    ctx: rquickjs::Context,
   43|       |}
   44|       |
   45|       |#[derive(Clone, Copy, Default)]
   46|       |struct InlineStyle {
   47|       |    strong: bool,
   48|       |    italics: bool,
   49|       |    strike: bool,
   50|       |    color: Option<Color32>,
   51|       |}
   52|       |
   53|       |/// Font size configuration
   54|       |#[derive(Debug, Clone)]
   55|       |pub struct FontSizes {
   56|       |    pub body: f32,
   57|       |    pub h1: f32,
   58|       |    pub h2: f32,
   59|       |    pub h3: f32,
   60|       |    pub h4: f32,
   61|       |    pub h5: f32,
   62|       |    pub h6: f32,
   63|       |    pub code: f32,
   64|       |}
   65|       |
   66|       |impl Default for FontSizes {
   67|     77|    fn default() -> Self {
   68|     77|        Self {
   69|     77|            body: 14.0,
   70|     77|            h1: 28.0,
   71|     77|            h2: 24.0,
   72|     77|            h3: 20.0,
   73|     77|            h4: 18.0,
   74|     77|            h5: 16.0,
   75|     77|            h6: 14.0,
   76|     77|            code: 12.0,
   77|     77|        }
   78|     77|    }
   79|       |}
   80|       |
   81|       |/// Represents an inline text span with formatting
   82|       |#[derive(Debug, Clone)]
   83|       |pub enum InlineSpan {
   84|       |    Text(String),
   85|       |    Code(String),
   86|       |    Strong(String),
   87|       |    Emphasis(String),
   88|       |    Strikethrough(String),
   89|       |    Link {
   90|       |        text: String,
   91|       |        url: String,
   92|       |    },
   93|       |    Image {
   94|       |        src: String,
   95|       |        alt: String,
   96|       |        title: Option<String>,
   97|       |    },
   98|       |}
   99|       |
  100|       |impl InlineSpan {
  101|     12|    fn text_content(&self) -> Option<&str> {
  102|     12|        match self {
  103|     10|            InlineSpan::Text(t)
  104|      0|            | InlineSpan::Code(t)
  105|      1|            | InlineSpan::Strong(t)
  106|      0|            | InlineSpan::Emphasis(t)
  107|     11|            | InlineSpan::Strikethrough(t) => Some(t.as_str()),
                                                      ^0
  108|      0|            InlineSpan::Link { text, .. } => Some(text.as_str()),
  109|      1|            InlineSpan::Image { .. } => None,
  110|       |        }
  111|     12|    }
  112|       |
  113|     10|    fn is_text_like(&self) -> bool {
  114|     10|        !matches!(self, InlineSpan::Image { .. })
  115|     10|    }
  116|       |}
  117|       |
  118|       |#[cfg_attr(not(test), allow(dead_code))]
  119|       |#[derive(Debug, Clone)]
  120|       |enum CellFragment<'a> {
  121|       |    Text(&'a [InlineSpan]),
  122|       |    Emoji(String),
  123|       |    Image(&'a InlineSpan),
  124|       |}
  125|       |
  126|       |#[cfg_attr(not(test), allow(dead_code))]
  127|       |#[derive(Debug, Clone)]
  128|       |struct LayoutJobBuild {
  129|       |    job: LayoutJob,
  130|       |    #[allow(dead_code)]
  131|       |    plain_text: String,
  132|       |    #[cfg_attr(not(test), allow(dead_code))]
  133|       |    link_ranges: Vec<LinkRange>,
  134|       |}
  135|       |
  136|       |#[cfg_attr(not(test), allow(dead_code))]
  137|       |#[derive(Debug, Clone)]
  138|       |struct LinkRange {
  139|       |    char_range: Range<usize>,
  140|       |    url: String,
  141|       |}
  142|       |
  143|       |const TABLE_LAYOUT_CACHE_CAPACITY: usize = 512;
  144|       |const COLUMN_STATS_SAMPLE_ROWS: usize = 128;
  145|       |
  146|       |#[derive(Debug, Clone, Hash, PartialEq, Eq)]
  147|       |struct CellLayoutKey {
  148|       |    row: Option<usize>,
  149|       |    col: usize,
  150|       |    width: u32,
  151|       |    strong: bool,
  152|       |    highlight_hash: u64,
  153|       |    content_hash: u64,
  154|       |}
  155|       |
  156|       |struct CellLayoutCache {
  157|       |    entries: HashMap<CellLayoutKey, LayoutJobBuild>,
  158|       |    order: VecDeque<CellLayoutKey>,
  159|       |    hits: u64,
  160|       |    misses: u64,
  161|       |    capacity: usize,
  162|       |}
  163|       |
  164|       |#[derive(Clone)]
  165|       |struct ColumnStatsCacheEntry {
  166|       |    content_hash: u64,
  167|       |    stats: Vec<ColumnStat>,
  168|       |}
  169|       |
  170|       |impl CellLayoutCache {
  171|     73|    fn new(capacity: usize) -> Self {
  172|     73|        Self {
  173|     73|            entries: HashMap::new(),
  174|     73|            order: VecDeque::new(),
  175|     73|            hits: 0,
  176|     73|            misses: 0,
  177|     73|            capacity,
  178|     73|        }
  179|     73|    }
  180|       |
  181|     10|    fn get(&mut self, key: &CellLayoutKey) -> Option<LayoutJobBuild> {
  182|     10|        if let Some(build) = self.entries.get(key) {
                                  ^1
  183|      1|            self.hits += 1;
  184|      1|            Some(build.clone())
  185|       |        } else {
  186|      9|            self.misses += 1;
  187|      9|            None
  188|       |        }
  189|     10|    }
  190|       |
  191|      9|    fn insert(&mut self, key: CellLayoutKey, build: LayoutJobBuild) {
  192|      9|        if self.entries.len() >= self.capacity && !self.entries.contains_key(&key) {
                                                                ^0^0
  193|      0|            while self.entries.len() >= self.capacity {
  194|      0|                if let Some(old) = self.order.pop_front() {
  195|      0|                    self.entries.remove(&old);
  196|      0|                } else {
  197|      0|                    break;
  198|       |                }
  199|       |            }
  200|      9|        }
  201|     28|        self.order.retain(|existing| existing != &key);
                      ^9         ^9
  202|      9|        self.order.push_back(key.clone());
  203|      9|        self.entries.insert(key, build);
  204|      9|    }
  205|       |
  206|    137|    fn clear(&mut self) {
  207|    137|        self.entries.clear();
  208|    137|        self.order.clear();
  209|    137|        self.hits = 0;
  210|    137|        self.misses = 0;
  211|    137|    }
  212|       |
  213|      7|    fn stats(&self) -> (u64, u64) {
  214|      7|        (self.hits, self.misses)
  215|      7|    }
  216|       |}
  217|       |
  218|       |/// Represents a rendered markdown element
  219|       |#[derive(Debug, Clone)]
  220|       |pub enum MarkdownElement {
  221|       |    Paragraph(Vec<InlineSpan>),
  222|       |    Header {
  223|       |        level: u8,
  224|       |        spans: Vec<InlineSpan>,
  225|       |        id: String,
  226|       |    },
  227|       |    CodeBlock {
  228|       |        language: Option<String>,
  229|       |        text: String,
  230|       |    },
  231|       |    List {
  232|       |        ordered: bool,
  233|       |        items: Vec<Vec<InlineSpan>>,
  234|       |    }, // List items are also inline spans
  235|       |    Quote {
  236|       |        depth: u8,
  237|       |        lines: Vec<Vec<InlineSpan>>,
  238|       |    },
  239|       |    HorizontalRule,
  240|       |    Table {
  241|       |        headers: Vec<Vec<InlineSpan>>,   // header cells as inline spans
  242|       |        rows: Vec<Vec<Vec<InlineSpan>>>, // rows -> cells -> spans
  243|       |    },
  244|       |}
  245|       |
  246|       |/// Type alias for table parsing result
  247|       |type TableParseResult = (Vec<Vec<InlineSpan>>, Vec<Vec<Vec<InlineSpan>>>, usize);
  248|       |
  249|       |/// Type alias for quote lines (each line is a sequence of inline spans)
  250|       |type QuoteLines = Vec<Vec<InlineSpan>>;
  251|       |
  252|       |struct ImageCacheEntry {
  253|       |    texture: egui::TextureHandle,
  254|       |    size: [u32; 2],
  255|       |    modified: Option<SystemTime>,
  256|       |}
  257|       |
  258|       |struct KrokiRequest {
  259|       |    key: u64,
  260|       |    url: String,
  261|       |    payload: String,
  262|       |}
  263|       |
  264|       |#[derive(Debug, PartialEq, Eq)]
  265|       |enum KrokiEnqueueError {
  266|       |    QueueFull,
  267|       |    Disconnected,
  268|       |}
  269|       |
  270|       |/// Markdown renderer with proper inline element handling
  271|       |pub struct MarkdownRenderer {
  272|       |    font_sizes: FontSizes,
  273|       |    syntax_set: SyntaxSet,
  274|       |    theme_set: ThemeSet,
  275|       |    emoji_textures: RefCell<HashMap<String, egui::TextureHandle>>,
  276|       |    image_textures: RefCell<HashMap<String, ImageCacheEntry>>,
  277|       |    // Mapping of header id -> last rendered rect (for in-document navigation)
  278|       |    header_rects: RefCell<HashMap<String, egui::Rect>>,
  279|       |    // Last clicked internal anchor (e.g., "getting-started") for the app to consume
  280|       |    pending_anchor: RefCell<Option<String>>,
  281|       |    // Unique counter to avoid egui Id collisions for repeated links
  282|       |    link_counter: RefCell<u64>,
  283|       |    // Per-frame rect for each top-level element in render order
  284|       |    element_rects: RefCell<Vec<egui::Rect>>,
  285|       |    // Optional highlight phrase (lowercased) for in-text highlighting
  286|       |    highlight_phrase: RefCell<Option<String>>,
  287|       |    // Cache for image/diagram textures
  288|       |    // Base directory used to resolve relative image paths
  289|       |    base_dir: RefCell<Option<PathBuf>>,
  290|       |    // Kroki (default Mermaid path) state
  291|       |    kroki_pending: RefCell<HashSet<u64>>, // code_hashes in flight
  292|       |    kroki_svg_cache: RefCell<HashMap<u64, Vec<u8>>>, // code_hash -> image bytes (PNG preferred)
  293|       |    kroki_errors: RefCell<HashMap<u64, String>>, // code_hash -> last error
  294|       |    kroki_job_tx: KrokiJobSender<KrokiRequest>, // UI -> worker queue
  295|       |    kroki_rx: Receiver<(u64, Result<Vec<u8>, String>)>, // background -> UI thread
  296|       |    #[cfg(feature = "mermaid-quickjs")]
  297|       |    mermaid_engine: RefCell<Option<MermaidEngine>>,
  298|       |    #[cfg(feature = "mermaid-quickjs")]
  299|       |    mermaid_svg_cache: RefCell<HashMap<u64, String>>, // code_hash -> SVG string
  300|       |    #[cfg(feature = "mermaid-quickjs")]
  301|       |    mermaid_failed: RefCell<HashSet<u64>>, // hashes that failed rendering; skip reattempts
  302|       |    #[cfg(feature = "mermaid-quickjs")]
  303|       |    mermaid_init_logged: RefCell<bool>,
  304|       |    #[cfg(feature = "mermaid-quickjs")]
  305|       |    mermaid_last_error: RefCell<Option<String>>,
  306|       |    table_wrap_overhaul_enabled: bool,
  307|       |    table_layout_cache: RefCell<CellLayoutCache>,
  308|       |    table_metrics: RefCell<TableMetrics>,
  309|       |    column_stats_cache: RefCell<HashMap<u64, ColumnStatsCacheEntry>>,
  310|       |}
  311|       |
  312|       |impl Default for MarkdownRenderer {
  313|      0|    fn default() -> Self {
  314|      0|        Self::new()
  315|      0|    }
  316|       |}
  317|       |
  318|       |impl MarkdownRenderer {
  319|       |    #[cfg_attr(not(test), allow(dead_code))]
  320|      8|    fn cell_fragments<'a>(&'a self, spans: &'a [InlineSpan]) -> Vec<CellFragment<'a>> {
  321|      8|        let mut fragments = Vec::new();
  322|      8|        let mut run_start: Option<usize> = None;
  323|      8|        let flush_run =
  324|      2|            |start: &mut Option<usize>, end: usize, fragments: &mut Vec<CellFragment<'a>>| {
  325|      2|                if let Some(run_begin) = start.take() {
                                          ^1
  326|      1|                    if run_begin < end {
  327|      1|                        fragments.push(CellFragment::Text(&spans[run_begin..end]));
  328|      1|                    }
                                  ^0
  329|      1|                }
  330|      2|            };
  331|       |
  332|     12|        for (idx, span) in spans.iter().enumerate() {
                                         ^8    ^8     ^8
  333|     12|            if let Some(emoji_key) = self.span_is_single_emoji(span) {
                                      ^1
  334|      1|                flush_run(&mut run_start, idx, &mut fragments);
  335|      1|                fragments.push(CellFragment::Emoji(emoji_key));
  336|      1|                continue;
  337|     11|            }
  338|       |
  339|     11|            if matches!(span, InlineSpan::Image { .. }) {
                             ^10
  340|      1|                flush_run(&mut run_start, idx, &mut fragments);
  341|      1|                fragments.push(CellFragment::Image(span));
  342|      1|                continue;
  343|     10|            }
  344|       |
  345|     10|            if span.is_text_like() && run_start.is_none() {
  346|      9|                run_start = Some(idx);
  347|      9|            }
                          ^1
  348|       |        }
  349|       |
  350|      8|        if let Some(start) = run_start {
  351|      8|            fragments.push(CellFragment::Text(&spans[start..]));
  352|      8|        }
                      ^0
  353|       |
  354|      8|        fragments
  355|      8|    }
  356|       |
  357|     12|    fn span_is_single_emoji(&self, span: &InlineSpan) -> Option<String> {
  358|     12|        let text = span.text_content()?;
                          ^11                       ^1
  359|     11|        let trimmed = text.trim();
  360|     11|        if trimmed.is_empty() {
  361|      0|            return None;
  362|     11|        }
  363|     11|        let mut graphemes = trimmed.graphemes(true);
  364|     11|        let first = graphemes.next()?;
                                                  ^0
  365|     11|        if graphemes.next().is_some() {
  366|     10|            return None;
  367|      1|        }
  368|      1|        if first != trimmed {
  369|      0|            return None;
  370|      1|        }
  371|      1|        self.emoji_key_for_grapheme(first)
  372|     12|    }
  373|       |
  374|     27|    fn highlight_segments(&self, text: &str, highlight: Option<&str>) -> Vec<(Range<usize>, bool)> {
  375|     27|        if text.is_empty() {
  376|      0|            return Vec::new();
  377|     27|        }
  378|     27|        let Some(needle) = highlight.filter(|h| !h.is_empty()) else {
                               ^24                             ^24^24
  379|      3|            return vec![(0..text.len(), false)];
  380|       |        };
  381|       |
  382|     24|        let mut folded = String::new();
  383|     24|        let mut folded_to_char: Vec<usize> = Vec::new();
  384|     24|        let mut char_ranges: Vec<(usize, usize)> = Vec::new();
  385|    177|        for (char_idx, (byte_idx, ch)) in text.char_indices().enumerate() {
                                                        ^24  ^24            ^24
  386|    177|            let folded_piece: String = ch.to_string().case_fold().nfkc().collect();
  387|    177|            let before = folded.len();
  388|    177|            folded.push_str(&folded_piece);
  389|    177|            let after = folded.len();
  390|    180|            for _ in before..after {
                                   ^177    ^177
  391|    180|                folded_to_char.push(char_idx);
  392|    180|            }
  393|    177|            char_ranges.push((byte_idx, byte_idx + ch.len_utf8()));
  394|       |        }
  395|       |
  396|     24|        if folded.is_empty() {
  397|      0|            return vec![(0..text.len(), false)];
  398|     24|        }
  399|       |
  400|     24|        let mut segments = Vec::new();
  401|     24|        let mut rendered_until = 0usize;
  402|     24|        let mut search_at = 0usize;
  403|     29|        while let Some(pos) = folded[search_at..].find(needle) {
                                     ^5
  404|      5|            let abs = search_at + pos;
  405|      5|            if abs >= folded_to_char.len() {
  406|      0|                break;
  407|      5|            }
  408|      5|            let start_char_idx = folded_to_char[abs];
  409|      5|            let (start_byte, _) = char_ranges[start_char_idx];
  410|      5|            if start_byte > rendered_until {
  411|      1|                segments.push((rendered_until..start_byte, false));
  412|      4|            }
  413|      5|            let match_end = abs + needle.len();
  414|      5|            let end_char_idx = if match_end == 0 {
  415|      0|                start_char_idx
  416|       |            } else {
  417|      5|                folded_to_char[match_end.saturating_sub(1)]
  418|       |            };
  419|      5|            let (_, end_byte) = char_ranges[end_char_idx];
  420|      5|            segments.push((start_byte..end_byte, true));
  421|      5|            rendered_until = end_byte;
  422|      5|            search_at = match_end;
  423|       |        }
  424|       |
  425|     24|        if rendered_until < text.len() {
  426|     24|            segments.push((rendered_until..text.len(), false));
  427|     24|        }
                      ^0
  428|       |
  429|     24|        if segments.is_empty() {
  430|      0|            segments.push((0..text.len(), false));
  431|     24|        }
  432|     24|        segments
  433|     27|    }
  434|       |
  435|       |    #[cfg_attr(not(test), allow(dead_code))]
  436|     12|    fn build_layout_job(
  437|     12|        &self,
  438|     12|        style: &egui::Style,
  439|     12|        spans: &[InlineSpan],
  440|     12|        wrap_width: f32,
  441|     12|        strong_override: bool,
  442|     12|    ) -> LayoutJobBuild {
  443|     12|        let mut job = LayoutJob {
  444|     12|            wrap: TextWrapping {
  445|     12|                max_width: wrap_width.max(1.0),
  446|     12|                ..Default::default()
  447|     12|            },
  448|     12|            break_on_newline: true,
  449|     12|            halign: Align::LEFT,
  450|     12|            ..Default::default()
  451|     12|        };
  452|       |
  453|     12|        let highlight = self
  454|     12|            .highlight_phrase
  455|     12|            .borrow()
  456|     12|            .clone()
  457|     12|            .filter(|s| !s.is_empty());
                                       ^9^9
  458|       |
  459|     12|        let mut plain_text = String::new();
  460|     12|        let mut link_ranges = Vec::new();
  461|     12|        let mut job_char_offset = 0usize;
  462|       |
  463|     24|        for span in spans {
                          ^12
  464|     12|            match span {
  465|      0|                InlineSpan::Image { .. } => {}
  466|      0|                InlineSpan::Code(code) => {
  467|      0|                    job_char_offset +=
  468|      0|                        self.append_code_span(style, &mut job, &mut plain_text, code);
  469|      0|                }
  470|      1|                InlineSpan::Link { text, url } => {
  471|      1|                    let inline_style = InlineStyle {
  472|      1|                        strong: strong_override,
  473|      1|                        color: Some(if Self::is_external_url(url) {
  474|      1|                            Color32::from_rgb(120, 190, 255)
  475|       |                        } else {
  476|      0|                            Color32::LIGHT_BLUE
  477|       |                        }),
  478|      1|                        ..Default::default()
  479|       |                    };
  480|      1|                    let mut normalized = self.fix_unicode_chars(text);
  481|      1|                    normalized = Self::expand_shortcodes(&normalized);
  482|      1|                    normalized = Self::expand_superscripts(&normalized);
  483|      1|                    let appended = self.append_text_sections(
  484|      1|                        style,
  485|      1|                        &mut job,
  486|      1|                        &mut plain_text,
  487|      1|                        &normalized,
  488|      1|                        self.font_sizes.body,
  489|      1|                        inline_style,
  490|      1|                        highlight.as_deref(),
  491|       |                    );
  492|      1|                    if appended > 0 {
  493|      1|                        let start_char = job_char_offset;
  494|      1|                        job_char_offset += appended;
  495|      1|                        link_ranges.push(LinkRange {
  496|      1|                            char_range: start_char..job_char_offset,
  497|      1|                            url: url.clone(),
  498|      1|                        });
  499|      1|                    }
                                  ^0
  500|       |                }
  501|      0|                InlineSpan::Strong(text) => {
  502|      0|                    job_char_offset += self.append_plain_span(
  503|      0|                        style,
  504|      0|                        &mut job,
  505|      0|                        &mut plain_text,
  506|      0|                        text,
  507|      0|                        InlineStyle {
  508|      0|                            strong: true,
  509|      0|                            ..Default::default()
  510|      0|                        },
  511|      0|                        highlight.as_deref(),
  512|      0|                    );
  513|      0|                }
  514|      0|                InlineSpan::Emphasis(text) => {
  515|      0|                    job_char_offset += self.append_plain_span(
  516|      0|                        style,
  517|      0|                        &mut job,
  518|      0|                        &mut plain_text,
  519|      0|                        text,
  520|      0|                        InlineStyle {
  521|      0|                            italics: true,
  522|      0|                            strong: strong_override,
  523|      0|                            ..Default::default()
  524|      0|                        },
  525|      0|                        highlight.as_deref(),
  526|      0|                    );
  527|      0|                }
  528|      0|                InlineSpan::Strikethrough(text) => {
  529|      0|                    job_char_offset += self.append_plain_span(
  530|      0|                        style,
  531|      0|                        &mut job,
  532|      0|                        &mut plain_text,
  533|      0|                        text,
  534|      0|                        InlineStyle {
  535|      0|                            strike: true,
  536|      0|                            strong: strong_override,
  537|      0|                            ..Default::default()
  538|      0|                        },
  539|      0|                        highlight.as_deref(),
  540|      0|                    );
  541|      0|                }
  542|     11|                InlineSpan::Text(text) => {
  543|     11|                    job_char_offset += self.append_plain_span(
  544|     11|                        style,
  545|     11|                        &mut job,
  546|     11|                        &mut plain_text,
  547|     11|                        text,
  548|     11|                        InlineStyle {
  549|     11|                            strong: strong_override,
  550|     11|                            ..Default::default()
  551|     11|                        },
  552|     11|                        highlight.as_deref(),
  553|     11|                    );
  554|     11|                }
  555|       |            }
  556|       |        }
  557|       |
  558|     12|        LayoutJobBuild {
  559|     12|            job,
  560|     12|            plain_text,
  561|     12|            link_ranges,
  562|     12|        }
  563|     12|    }
  564|       |
  565|     11|    fn append_plain_span(
  566|     11|        &self,
  567|     11|        style: &egui::Style,
  568|     11|        job: &mut LayoutJob,
  569|     11|        plain_text: &mut String,
  570|     11|        text: &str,
  571|     11|        inline_style: InlineStyle,
  572|     11|        highlight: Option<&str>,
  573|     11|    ) -> usize {
  574|     11|        if text.is_empty() {
  575|      0|            return 0;
  576|     11|        }
  577|     11|        let mut normalized = self.fix_unicode_chars(text);
  578|     11|        normalized = Self::expand_shortcodes(&normalized);
  579|     11|        normalized = Self::expand_superscripts(&normalized);
  580|     11|        if normalized.is_empty() {
  581|      0|            return 0;
  582|     11|        }
  583|     11|        self.append_text_sections(
  584|     11|            style,
  585|     11|            job,
  586|     11|            plain_text,
  587|     11|            &normalized,
  588|     11|            self.font_sizes.body,
  589|     11|            inline_style,
  590|     11|            highlight,
  591|       |        )
  592|     11|    }
  593|       |
  594|      0|    fn append_code_span(
  595|      0|        &self,
  596|      0|        style: &egui::Style,
  597|      0|        job: &mut LayoutJob,
  598|      0|        plain_text: &mut String,
  599|      0|        code: &str,
  600|      0|    ) -> usize {
  601|      0|        if code.is_empty() {
  602|      0|            return 0;
  603|      0|        }
  604|      0|        plain_text.push_str(code);
  605|      0|        let visuals = &style.visuals;
  606|      0|        let (bg, fg) = if visuals.dark_mode {
  607|      0|            (
  608|      0|                Color32::from_rgb(30, 30, 30),
  609|      0|                Color32::from_rgb(180, 255, 180),
  610|      0|            )
  611|       |        } else {
  612|      0|            (Color32::WHITE, Color32::from_rgb(60, 80, 150))
  613|       |        };
  614|      0|        let rich = RichText::new(code.to_string())
  615|      0|            .size(self.font_sizes.code)
  616|      0|            .monospace()
  617|      0|            .background_color(bg)
  618|      0|            .color(fg);
  619|      0|        rich.append_to(job, style, FontSelection::Default, Align::LEFT);
  620|      0|        code.chars().count()
  621|      0|    }
  622|       |
  623|       |    #[allow(clippy::too_many_arguments)]
  624|     12|    fn append_text_sections(
  625|     12|        &self,
  626|     12|        style: &egui::Style,
  627|     12|        job: &mut LayoutJob,
  628|     12|        plain_text: &mut String,
  629|     12|        text: &str,
  630|     12|        font_size: f32,
  631|     12|        inline_style: InlineStyle,
  632|     12|        highlight: Option<&str>,
  633|     12|    ) -> usize {
  634|     12|        if text.is_empty() {
  635|      0|            return 0;
  636|     12|        }
  637|     12|        plain_text.push_str(text);
  638|     12|        let char_count = text.chars().count();
  639|     12|        let visuals = &style.visuals;
  640|     12|        let segments = self.highlight_segments(text, highlight);
  641|     27|        for (range, highlighted) in segments {
                           ^15    ^15
  642|     15|            if range.is_empty() {
  643|      0|                continue;
  644|     15|            }
  645|     15|            let slice = &text[range];
  646|     15|            let mut rich = RichText::new(slice.to_string()).size(font_size);
  647|     15|            if inline_style.strong {
  648|      4|                rich = rich.strong();
  649|     11|            }
  650|     15|            if inline_style.italics {
  651|      0|                rich = rich.italics();
  652|     15|            }
  653|     15|            if inline_style.strike {
  654|      0|                rich = rich.strikethrough();
  655|     15|            }
  656|     15|            let mut text_color = inline_style.color;
  657|     15|            if highlighted {
  658|      2|                rich = rich.background_color(visuals.selection.bg_fill);
  659|      2|                if text_color.is_none() {
  660|      2|                    text_color = Some(visuals.selection.stroke.color);
  661|      2|                }
                              ^0
  662|     13|            }
  663|     15|            if let Some(color) = text_color {
                                      ^3
  664|      3|                rich = rich.color(color);
  665|     12|            }
  666|     15|            rich.append_to(job, style, FontSelection::Default, Align::LEFT);
  667|       |        }
  668|     12|        char_count
  669|     12|    }
  670|       |
  671|       |    const MAX_KROKI_JOBS: usize = 4;
  672|       |
  673|       |    /// Create a new markdown renderer
  674|     73|    pub fn new() -> Self {
  675|     73|        let (tx, rx) = std::sync::mpsc::channel();
  676|     73|        let (job_tx, job_rx): (KrokiJobSender<KrokiRequest>, KrokiJobReceiver<KrokiRequest>) =
  677|     73|            bounded(Self::MAX_KROKI_JOBS * 4);
  678|    365|        for worker_idx in 0..Self::MAX_KROKI_JOBS {
                          ^292
  679|    292|            let worker_rx = job_rx.clone();
  680|    292|            let result_tx = tx.clone();
  681|    292|            if let Err(err) = std::thread::Builder::new()
                                     ^0
  682|    292|                .name(format!("mdmdview-kroki-{worker_idx}"))
  683|    292|                .spawn(move || {
  684|    292|                    let agent = ureq::AgentBuilder::new()
  685|    292|                        .timeout_connect(Duration::from_secs(5))
  686|    292|                        .timeout_read(Duration::from_secs(10))
  687|    292|                        .timeout_write(Duration::from_secs(10))
  688|    292|                        .build();
  689|    292|                    for job in worker_rx.iter() {
                                      ^0
  690|      0|                        let result = MarkdownRenderer::perform_kroki_with_agent(
  691|      0|                            &agent,
  692|      0|                            &job.url,
  693|      0|                            &job.payload,
  694|      0|                        );
  695|      0|                        let _ = result_tx.send((job.key, result));
  696|      0|                    }
  697|    292|                })
  698|      0|            {
  699|      0|                eprintln!("Failed to start Kroki worker thread: {}", err);
  700|    292|            }
  701|       |        }
  702|     73|        drop(job_rx);
  703|     73|        Self {
  704|     73|            font_sizes: FontSizes::default(),
  705|     73|            syntax_set: SyntaxSet::load_defaults_newlines(),
  706|     73|            theme_set: ThemeSet::load_defaults(),
  707|     73|            emoji_textures: RefCell::new(HashMap::new()),
  708|     73|            image_textures: RefCell::new(HashMap::new()),
  709|     73|            header_rects: RefCell::new(HashMap::new()),
  710|     73|            pending_anchor: RefCell::new(None),
  711|     73|            link_counter: RefCell::new(0),
  712|     73|            element_rects: RefCell::new(Vec::new()),
  713|     73|            highlight_phrase: RefCell::new(None),
  714|     73|            base_dir: RefCell::new(None),
  715|     73|            kroki_pending: RefCell::new(HashSet::new()),
  716|     73|            kroki_svg_cache: RefCell::new(HashMap::new()),
  717|     73|            kroki_errors: RefCell::new(HashMap::new()),
  718|     73|            kroki_job_tx: job_tx,
  719|     73|            kroki_rx: rx,
  720|     73|            #[cfg(feature = "mermaid-quickjs")]
  721|     73|            mermaid_engine: RefCell::new(None),
  722|     73|            #[cfg(feature = "mermaid-quickjs")]
  723|     73|            mermaid_svg_cache: RefCell::new(HashMap::new()),
  724|     73|            #[cfg(feature = "mermaid-quickjs")]
  725|     73|            mermaid_failed: RefCell::new(HashSet::new()),
  726|     73|            #[cfg(feature = "mermaid-quickjs")]
  727|     73|            mermaid_init_logged: RefCell::new(false),
  728|     73|            #[cfg(feature = "mermaid-quickjs")]
  729|     73|            mermaid_last_error: RefCell::new(None),
  730|     73|            table_wrap_overhaul_enabled: true,
  731|     73|            table_layout_cache: RefCell::new(CellLayoutCache::new(TABLE_LAYOUT_CACHE_CAPACITY)),
  732|     73|            table_metrics: RefCell::new(TableMetrics::default()),
  733|     73|            column_stats_cache: RefCell::new(HashMap::new()),
  734|     73|        }
  735|     73|    }
  736|       |
  737|       |    /// UI scale factor derived from body font size relative to default.
  738|       |    /// Used to scale non-text elements (e.g., images) consistently with zoom.
  739|      2|    fn ui_scale(&self) -> f32 {
  740|      2|        let default_body = FontSizes::default().body;
  741|      2|        (self.font_sizes.body / default_body).clamp(0.5, 4.0)
  742|      2|    }
  743|       |
  744|       |    /// Get current font sizes
  745|      2|    pub fn font_sizes(&self) -> &FontSizes {
  746|      2|        &self.font_sizes
  747|      2|    }
  748|       |
  749|       |    /// Parse markdown content into elements with proper inline handling
  750|     91|    pub fn parse(&self, markdown: &str) -> Result<Vec<MarkdownElement>, anyhow::Error> {
  751|     91|        let mut options = Options::empty();
  752|     91|        options.insert(Options::ENABLE_STRIKETHROUGH);
  753|     91|        options.insert(Options::ENABLE_TABLES);
  754|     91|        options.insert(Options::ENABLE_TASKLISTS);
  755|       |
  756|     91|        let parser = Parser::new_ext(markdown, options);
  757|     91|        let mut elements = Vec::new();
  758|     91|        let events = parser.collect::<Vec<_>>();
  759|       |
  760|     91|        let mut i = 0;
  761|       |        // Track header slug occurrences for stable de-duplication
  762|     91|        let mut slug_counts: HashMap<String, usize> = HashMap::new();
  763|    760|        while i < events.len() {
  764|    669|            i = self.parse_element(&events, i, &mut elements, &mut slug_counts)?;
                                                                                             ^0
  765|       |        }
  766|       |
  767|     91|        Ok(elements)
  768|     91|    }
  769|       |
  770|       |    /// Parse a single element from the event stream
  771|    669|    fn parse_element(
  772|    669|        &self,
  773|    669|        events: &[Event],
  774|    669|        start: usize,
  775|    669|        elements: &mut Vec<MarkdownElement>,
  776|    669|        slug_counts: &mut HashMap<String, usize>,
  777|    669|    ) -> Result<usize, anyhow::Error> {
  778|    669|        match &events[start] {
  779|       |            Event::Start(Tag::Paragraph) => {
  780|       |                // Always preserve line breaks in paragraphs (consistent with blockquotes)
  781|       |                // This allows poetry, lyrics, and structured content to render correctly
  782|    216|                let (spans, next_idx) =
  783|    216|                    self.parse_inline_spans_with_breaks(events, start + 1, Tag::Paragraph, true)?;
                                                                                                              ^0
  784|    216|                if !spans.is_empty() {
  785|    216|                    elements.push(MarkdownElement::Paragraph(spans));
  786|    216|                }
                              ^0
  787|    216|                Ok(next_idx)
  788|       |            }
  789|       |            // Images encountered outside paragraphs: treat as a single paragraph with an inline image
  790|      0|            Event::Start(Tag::Image(_, url, title)) => {
  791|      0|                let (alt, next_idx) = self.collect_until_tag_end(
  792|      0|                    events,
  793|      0|                    start + 1,
  794|      0|                    Tag::Image(LinkType::Inline, "".into(), "".into()),
  795|      0|                )?;
  796|      0|                let mut spans: Vec<InlineSpan> = Vec::new();
  797|      0|                spans.push(InlineSpan::Image {
  798|      0|                    src: url.to_string(),
  799|      0|                    alt,
  800|      0|                    title: if title.is_empty() {
  801|      0|                        None
  802|       |                    } else {
  803|      0|                        Some(title.to_string())
  804|       |                    },
  805|       |                });
  806|      0|                elements.push(MarkdownElement::Paragraph(spans));
  807|      0|                Ok(next_idx)
  808|       |            }
  809|    245|            Event::Start(Tag::Heading(level, _, _)) => {
  810|    245|                let (spans, next_idx) =
  811|    245|                    self.parse_inline_spans(events, start + 1, Tag::Heading(*level, None, vec![]))?;
                                                                                                                ^0
  812|    245|                let title_text = Self::spans_plain_text(&spans);
  813|    245|                let base = Self::slugify(&title_text);
  814|    245|                let count = slug_counts.entry(base.clone()).or_insert(0);
  815|    245|                let id = if *count == 0 {
  816|    243|                    base.clone()
  817|       |                } else {
  818|      2|                    format!("{}-{}", base, *count)
  819|       |                };
  820|    245|                *count += 1;
  821|    245|                elements.push(MarkdownElement::Header {
  822|    245|                    level: *level as u8,
  823|    245|                    spans,
  824|    245|                    id,
  825|    245|                });
  826|    245|                Ok(next_idx)
  827|       |            }
  828|       |            Event::Start(Tag::CodeBlock(_)) => {
  829|      7|                let (code_text, language, next_idx) = self.parse_code_block(events, start)?;
                                                                                                        ^0
  830|      7|                elements.push(MarkdownElement::CodeBlock {
  831|      7|                    language,
  832|      7|                    text: code_text,
  833|      7|                });
  834|      7|                Ok(next_idx)
  835|       |            }
  836|    129|            Event::Start(Tag::List(first_item)) => {
  837|    129|                let (items, next_idx) = self.parse_list(events, start + 1, *first_item, 0)?;
                                                                                                        ^0
  838|    129|                elements.push(MarkdownElement::List {
  839|    129|                    ordered: first_item.is_some(),
  840|    129|                    items,
  841|    129|                });
  842|    129|                Ok(next_idx)
  843|       |            }
  844|       |            Event::Rule => {
  845|     59|                elements.push(MarkdownElement::HorizontalRule);
  846|     59|                Ok(start + 1)
  847|       |            }
  848|       |            Event::Start(Tag::BlockQuote) => {
  849|      5|                let (quotes, next_idx) = self.collect_blockquotes(events, start + 1, 1)?;
                                                                                                     ^0
  850|     12|                for (depth, lines) in quotes {
                                   ^7     ^7
  851|      7|                    if !lines.is_empty() {
  852|      7|                        elements.push(MarkdownElement::Quote { depth, lines });
  853|      7|                    }
                                  ^0
  854|       |                }
  855|      5|                Ok(next_idx)
  856|       |            }
  857|       |            Event::Start(Tag::Table(_)) => {
  858|      8|                let (headers, rows, next_idx) = self.parse_table(events, start + 1)?;
                                                                                                 ^0
  859|      8|                elements.push(MarkdownElement::Table { headers, rows });
  860|      8|                Ok(next_idx)
  861|       |            }
  862|       |            _ => {
  863|       |                // Skip other events
  864|      0|                Ok(start + 1)
  865|       |            }
  866|       |        }
  867|    669|    }
  868|       |
  869|       |    // Build a slug from text similar to GitHub: lowercase, spaces->dashes, strip punctuation
  870|    245|    fn slugify(text: &str) -> String {
  871|    245|        let mut out = String::with_capacity(text.len());
  872|    245|        let mut last_dash = false;
  873|  3.23k|        for ch in text.chars() {
                                ^245 ^245
  874|  3.23k|            let c = ch.to_ascii_lowercase();
  875|  3.23k|            if c.is_ascii_alphanumeric() {
  876|  2.98k|                out.push(c);
  877|  2.98k|                last_dash = false;
  878|  2.98k|            } else if c.is_whitespace() || c == '-' {
                                    ^248^248               ^8
  879|    242|                if !last_dash && !out.is_empty() {
                                               ^238
  880|    238|                    out.push('-');
  881|    238|                    last_dash = true;
  882|    238|                }
                              ^4
  883|      6|            } else {
  884|      6|                // drop punctuation/symbols
  885|      6|            }
  886|       |        }
  887|       |        // Trim trailing dash if any
  888|    245|        if out.ends_with('-') {
  889|      0|            out.pop();
  890|    245|        }
  891|    245|        out
  892|    245|    }
  893|       |
  894|    251|    fn spans_plain_text(spans: &[InlineSpan]) -> String {
  895|    251|        let mut s = String::new();
  896|    506|        for span in spans {
                          ^255
  897|    255|            match span {
  898|    252|                InlineSpan::Text(t)
  899|      1|                | InlineSpan::Strong(t)
  900|      0|                | InlineSpan::Emphasis(t)
  901|    253|                | InlineSpan::Strikethrough(t) => s.push_str(t),
                                                          ^0
  902|      0|                InlineSpan::Code(t) => s.push_str(t),
  903|      1|                InlineSpan::Link { text, .. } => s.push_str(text),
  904|      1|                InlineSpan::Image { alt, title, .. } => {
  905|      1|                    if !alt.is_empty() {
  906|      1|                        s.push_str(alt);
  907|      1|                    }
                                  ^0
  908|      1|                    if let Some(t) = title {
  909|      1|                        if !t.is_empty() {
  910|      1|                            if !s.is_empty() {
  911|      1|                                s.push(' ');
  912|      1|                            }
                                          ^0
  913|      1|                            s.push_str(t);
  914|      0|                        }
  915|      0|                    }
  916|       |                }
  917|       |            }
  918|       |        }
  919|    251|        s
  920|    251|    }
  921|       |
  922|       |    /// Extract plain text from all markdown elements
  923|      3|    pub fn elements_to_plain_text(elements: &[MarkdownElement]) -> String {
  924|      3|        let mut result = String::new();
  925|      4|        for element in elements.iter() {
                                     ^3       ^3
  926|      4|            match element {
  927|      2|                MarkdownElement::Paragraph(spans) | MarkdownElement::Header { spans, .. } => {
                                                                                            ^1
  928|      3|                    if !result.is_empty() {
  929|      1|                        result.push('\n');
  930|      2|                    }
  931|      3|                    result.push_str(&Self::spans_plain_text(spans));
  932|       |                }
  933|      1|                MarkdownElement::CodeBlock { text, .. } => {
  934|      1|                    if !result.is_empty() {
  935|      0|                        result.push('\n');
  936|      1|                    }
  937|      1|                    result.push_str(text);
  938|       |                }
  939|      0|                MarkdownElement::List { items, .. } => {
  940|      0|                    for item in items {
  941|      0|                        if !result.is_empty() {
  942|      0|                            result.push('\n');
  943|      0|                        }
  944|      0|                        result.push_str(&Self::spans_plain_text(item));
  945|       |                    }
  946|       |                }
  947|      0|                MarkdownElement::Quote { lines, .. } => {
  948|      0|                    for line in lines {
  949|      0|                        if !result.is_empty() {
  950|      0|                            result.push('\n');
  951|      0|                        }
  952|      0|                        result.push_str(&Self::spans_plain_text(line));
  953|       |                    }
  954|       |                }
  955|      0|                MarkdownElement::Table { headers, rows } => {
  956|       |                    // Headers
  957|      0|                    for header in headers {
  958|      0|                        if !result.is_empty() {
  959|      0|                            result.push('\n');
  960|      0|                        }
  961|      0|                        result.push_str(&Self::spans_plain_text(header));
  962|       |                    }
  963|       |                    // Rows
  964|      0|                    for row in rows {
  965|      0|                        for cell in row {
  966|      0|                            if !result.is_empty() {
  967|      0|                                result.push('\n');
  968|      0|                            }
  969|      0|                            result.push_str(&Self::spans_plain_text(cell));
  970|       |                        }
  971|       |                    }
  972|       |                }
  973|       |                MarkdownElement::HorizontalRule => {
  974|      0|                    if !result.is_empty() {
  975|      0|                        result.push_str("\n---\n");
  976|      0|                    }
  977|       |                }
  978|       |            }
  979|       |        }
  980|      3|        result
  981|      3|    }
  982|       |
  983|       |    /// Collect blockquotes into (depth, lines) entries; supports nesting and multi-line content
  984|      7|    fn collect_blockquotes(
  985|      7|        &self,
  986|      7|        events: &[Event],
  987|      7|        start: usize,
  988|      7|        depth: u8,
  989|      7|    ) -> Result<(Vec<(u8, QuoteLines)>, usize), anyhow::Error> {
  990|      7|        let mut i = start;
  991|      7|        let mut result: Vec<(u8, QuoteLines)> = Vec::new();
  992|      7|        let mut lines: QuoteLines = Vec::new();
  993|      7|        let mut current: Vec<InlineSpan> = Vec::new();
  994|       |
  995|     10|        let push_line = |current: &mut Vec<InlineSpan>, lines: &mut QuoteLines| {
                          ^7
  996|     10|            lines.push(std::mem::take(current));
  997|     10|        };
  998|       |
  999|     16|        while i < events.len() {
 1000|     16|            match &events[i] {
 1001|       |                Event::Start(Tag::Paragraph) => {
 1002|      7|                    let (mut para, next) =
 1003|      7|                        self.parse_inline_spans_with_breaks(events, i + 1, Tag::Paragraph, true)?;
                                                                                                              ^0
 1004|       |                    // Split para into lines on explicit "\n"
 1005|      7|                    let mut line: Vec<InlineSpan> = Vec::new();
 1006|     24|                    while let Some(span) = para.first().cloned() {
                                                 ^17
 1007|     17|                        para.remove(0);
 1008|     15|                        match span {
 1009|     15|                            InlineSpan::Text(t) if t.contains('\n') => {
                                                           ^3                   ^3
 1010|      3|                                let parts: Vec<&str> = t.split('\n').collect();
 1011|      6|                                for (pi, part) in parts.iter().enumerate() {
                                                                ^3           ^3
 1012|      6|                                    if !part.is_empty() {
 1013|      0|                                        line.push(InlineSpan::Text(part.to_string()));
 1014|      6|                                    }
 1015|      6|                                    if pi < parts.len() - 1 {
 1016|      3|                                        push_line(&mut line, &mut lines);
 1017|      3|                                        line = Vec::new();
 1018|      3|                                    }
 1019|       |                                }
 1020|       |                            }
 1021|     14|                            other => line.push(other),
 1022|       |                        }
 1023|       |                    }
 1024|      7|                    if !line.is_empty() {
 1025|      7|                        push_line(&mut line, &mut lines);
 1026|      7|                    }
                                  ^0
 1027|      7|                    i = next;
 1028|       |                }
 1029|      0|                Event::SoftBreak | Event::HardBreak => {
 1030|      0|                    push_line(&mut current, &mut lines);
 1031|      0|                    i += 1;
 1032|      0|                }
 1033|       |                Event::Start(Tag::BlockQuote) => {
 1034|       |                    // flush current collected lines for this depth
 1035|      2|                    if !current.is_empty() {
 1036|      0|                        push_line(&mut current, &mut lines);
 1037|      2|                    }
 1038|      2|                    if !lines.is_empty() {
 1039|      2|                        result.push((depth, std::mem::take(&mut lines)));
 1040|      2|                    }
                                  ^0
 1041|       |                    // collect nested
 1042|      2|                    let (nested, next) = self.collect_blockquotes(events, i + 1, depth + 1)?;
                                                                                                         ^0
 1043|      2|                    result.extend(nested);
 1044|      2|                    i = next;
 1045|       |                }
 1046|       |                Event::End(Tag::BlockQuote) => {
 1047|      7|                    if !current.is_empty() {
 1048|      0|                        push_line(&mut current, &mut lines);
 1049|      7|                    }
 1050|      7|                    if !lines.is_empty() {
 1051|      5|                        result.push((depth, lines));
 1052|      5|                    }
                                  ^2
 1053|      7|                    return Ok((result, i + 1));
 1054|       |                }
 1055|      0|                _ => {
 1056|      0|                    i += 1;
 1057|      0|                }
 1058|       |            }
 1059|       |        }
 1060|      0|        if !current.is_empty() {
 1061|      0|            push_line(&mut current, &mut lines);
 1062|      0|        }
 1063|      0|        if !lines.is_empty() {
 1064|      0|            result.push((depth, lines));
 1065|      0|        }
 1066|      0|        Ok((result, i))
 1067|      7|    }
 1068|       |
 1069|       |    /// Parse inline spans until reaching the end tag
 1070|    556|    fn parse_inline_spans_with_breaks(
 1071|    556|        &self,
 1072|    556|        events: &[Event],
 1073|    556|        start: usize,
 1074|    556|        end_tag: Tag,
 1075|    556|        keep_breaks: bool,
 1076|    556|    ) -> Result<(Vec<InlineSpan>, usize), anyhow::Error> {
 1077|    556|        let mut spans = Vec::new();
 1078|    556|        let mut i = start;
 1079|    556|        let mut text_buffer = String::new();
 1080|       |
 1081|  1.23k|        while i < events.len() {
 1082|  1.23k|            match &events[i] {
 1083|    556|                Event::End(tag)
 1084|    556|                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
 1085|       |                {
 1086|    556|                    if !text_buffer.is_empty() {
 1087|    470|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1088|    470|                        text_buffer.clear();
 1089|    470|                    }
                                  ^86
 1090|    556|                    return Ok((spans, i + 1));
 1091|       |                }
 1092|    538|                Event::Text(text) => {
 1093|    538|                    text_buffer.push_str(text);
 1094|    538|                    i += 1;
 1095|    538|                }
 1096|       |                Event::SoftBreak | Event::HardBreak => {
 1097|     17|                    if keep_breaks {
 1098|     17|                        if !text_buffer.is_empty() {
 1099|     12|                            spans.push(InlineSpan::Text(text_buffer.clone()));
 1100|     12|                            text_buffer.clear();
 1101|     12|                        }
                                      ^5
 1102|     17|                        spans.push(InlineSpan::Text("\n".to_string()));
 1103|      0|                    } else {
 1104|      0|                        text_buffer.push(' ');
 1105|      0|                    }
 1106|     17|                    i += 1;
 1107|       |                }
 1108|     32|                Event::Code(code) => {
 1109|     32|                    if !text_buffer.is_empty() {
 1110|     15|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1111|     15|                        text_buffer.clear();
 1112|     17|                    }
 1113|     32|                    spans.push(InlineSpan::Code(code.to_string()));
 1114|     32|                    i += 1;
 1115|       |                }
 1116|       |                Event::Start(Tag::Strong) => {
 1117|      8|                    if !text_buffer.is_empty() {
 1118|      2|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1119|      2|                        text_buffer.clear();
 1120|      6|                    }
 1121|      8|                    let (inner_text, next_i) =
 1122|      8|                        self.collect_until_tag_end(events, i + 1, Tag::Strong)?;
                                                                                            ^0
 1123|      8|                    spans.push(InlineSpan::Strong(inner_text));
 1124|      8|                    i = next_i;
 1125|       |                }
 1126|       |                Event::Start(Tag::Emphasis) => {
 1127|     60|                    if !text_buffer.is_empty() {
 1128|      5|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1129|      5|                        text_buffer.clear();
 1130|     55|                    }
 1131|     60|                    let (inner_text, next_i) =
 1132|     60|                        self.collect_until_tag_end(events, i + 1, Tag::Emphasis)?;
                                                                                              ^0
 1133|     60|                    spans.push(InlineSpan::Emphasis(inner_text));
 1134|     60|                    i = next_i;
 1135|       |                }
 1136|       |                Event::Start(Tag::Strikethrough) => {
 1137|      2|                    if !text_buffer.is_empty() {
 1138|      2|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1139|      2|                        text_buffer.clear();
 1140|      2|                    }
                                  ^0
 1141|      2|                    let (inner_text, next_i) =
 1142|      2|                        self.collect_until_tag_end(events, i + 1, Tag::Strikethrough)?;
                                                                                                   ^0
 1143|      2|                    spans.push(InlineSpan::Strikethrough(inner_text));
 1144|      2|                    i = next_i;
 1145|       |                }
 1146|     11|                Event::Start(Tag::Link(_, url, _)) => {
 1147|     11|                    if !text_buffer.is_empty() {
 1148|      6|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1149|      6|                        text_buffer.clear();
 1150|      6|                    }
                                  ^5
 1151|     11|                    let url_str = url.to_string();
 1152|     11|                    let (link_text, next_i) = self.collect_until_tag_end(
 1153|     11|                        events,
 1154|     11|                        i + 1,
 1155|     11|                        Tag::Link(LinkType::Inline, "".into(), "".into()),
 1156|      0|                    )?;
 1157|     11|                    spans.push(InlineSpan::Link {
 1158|     11|                        text: link_text,
 1159|     11|                        url: url_str,
 1160|     11|                    });
 1161|     11|                    i = next_i;
 1162|       |                }
 1163|     10|                Event::Start(Tag::Image(_, url, title)) => {
 1164|     10|                    if !text_buffer.is_empty() {
 1165|      2|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1166|      2|                        text_buffer.clear();
 1167|      8|                    }
 1168|     10|                    let url_str = url.to_string();
 1169|     10|                    let (alt_text, next_i) = self.collect_until_tag_end(
 1170|     10|                        events,
 1171|     10|                        i + 1,
 1172|     10|                        Tag::Image(LinkType::Inline, "".into(), "".into()),
 1173|      0|                    )?;
 1174|     10|                    spans.push(InlineSpan::Image {
 1175|     10|                        src: url_str,
 1176|     10|                        alt: alt_text,
 1177|     10|                        title: if title.is_empty() {
 1178|      1|                            None
 1179|       |                        } else {
 1180|      9|                            Some(title.to_string())
 1181|       |                        },
 1182|       |                    });
 1183|     10|                    i = next_i;
 1184|       |                }
 1185|      1|                _ => {
 1186|      1|                    i += 1;
 1187|      1|                }
 1188|       |            }
 1189|       |        }
 1190|       |
 1191|      0|        if !text_buffer.is_empty() {
 1192|      0|            spans.push(InlineSpan::Text(text_buffer));
 1193|      0|        }
 1194|       |
 1195|      0|        Ok((spans, i))
 1196|    556|    }
 1197|       |
 1198|       |    /// Default inline parsing without preserving explicit line breaks
 1199|    245|    fn parse_inline_spans(
 1200|    245|        &self,
 1201|    245|        events: &[Event],
 1202|    245|        start: usize,
 1203|    245|        end_tag: Tag,
 1204|    245|    ) -> Result<(Vec<InlineSpan>, usize), anyhow::Error> {
 1205|    245|        self.parse_inline_spans_with_breaks(events, start, end_tag, false)
 1206|    245|    }
 1207|       |
 1208|       |    /// Collect text until a specific end tag
 1209|    534|    fn collect_until_tag_end(
 1210|    534|        &self,
 1211|    534|        events: &[Event],
 1212|    534|        start: usize,
 1213|    534|        end_tag: Tag,
 1214|    534|    ) -> Result<(String, usize), anyhow::Error> {
 1215|    534|        let mut text = String::new();
 1216|    534|        let mut i = start;
 1217|       |
 1218|  1.07k|        while i < events.len() {
 1219|  1.07k|            match &events[i] {
 1220|    536|                Event::End(tag)
 1221|    536|                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
                                                                                                   ^534
 1222|       |                {
 1223|    534|                    return Ok((text, i + 1));
 1224|       |                }
 1225|    534|                Event::Text(t) => {
 1226|    534|                    text.push_str(t);
 1227|    534|                }
 1228|      0|                Event::Code(code) => {
 1229|      0|                    text.push_str(code);
 1230|      0|                }
 1231|      4|                _ => {}
 1232|       |            }
 1233|    538|            i += 1;
 1234|       |        }
 1235|       |
 1236|      0|        Ok((text, i))
 1237|    534|    }
 1238|       |
 1239|       |    /// Parse a code block
 1240|      7|    fn parse_code_block(
 1241|      7|        &self,
 1242|      7|        events: &[Event],
 1243|      7|        start: usize,
 1244|      7|    ) -> Result<(String, Option<String>, usize), anyhow::Error> {
 1245|      7|        let mut language = None;
 1246|      7|        let mut code_text = String::new();
 1247|      7|        let mut i = start;
 1248|       |
 1249|       |        // Extract language from the start tag
 1250|      7|        if let Event::Start(Tag::CodeBlock(kind)) = &events[start] {
 1251|      7|            if let pulldown_cmark::CodeBlockKind::Fenced(lang) = kind {
 1252|      7|                if !lang.is_empty() {
 1253|      7|                    language = Some(lang.to_string());
 1254|      7|                }
                              ^0
 1255|      0|            }
 1256|      7|            i += 1;
 1257|      0|        }
 1258|       |
 1259|     14|        while i < events.len() {
 1260|     14|            match &events[i] {
 1261|       |                Event::End(Tag::CodeBlock(_)) => {
 1262|      7|                    return Ok((code_text, language, i + 1));
 1263|       |                }
 1264|      7|                Event::Text(text) => {
 1265|      7|                    code_text.push_str(text);
 1266|      7|                }
 1267|      0|                _ => {}
 1268|       |            }
 1269|      7|            i += 1;
 1270|       |        }
 1271|       |
 1272|      0|        Ok((code_text, language, i))
 1273|      7|    }
 1274|       |
 1275|       |    /// Parse a list with basic nested-list flattening
 1276|    133|    fn parse_list(
 1277|    133|        &self,
 1278|    133|        events: &[Event],
 1279|    133|        start: usize,
 1280|    133|        first_item: Option<u64>,
 1281|    133|        depth: usize,
 1282|    133|    ) -> Result<(Vec<Vec<InlineSpan>>, usize), anyhow::Error> {
 1283|    133|        let mut items: Vec<Vec<InlineSpan>> = Vec::new();
 1284|    133|        let mut i = start;
 1285|    133|        let _is_ordered = first_item.is_some();
 1286|       |
 1287|    643|        while i < events.len() {
 1288|    643|            match &events[i] {
 1289|    133|                Event::End(Tag::List(_)) => return Ok((items, i + 1)),
 1290|       |                Event::Start(Tag::Item) => {
 1291|    510|                    i += 1;
 1292|    510|                    let mut spans: Vec<InlineSpan> = Vec::new();
 1293|       |                    loop {
 1294|  1.82k|                        if i >= events.len() {
 1295|      0|                            break;
 1296|  1.82k|                        }
 1297|  1.82k|                        match &events[i] {
 1298|       |                            Event::End(Tag::Item) => {
 1299|    510|                                i += 1;
 1300|    510|                                break;
 1301|       |                            }
 1302|       |                            Event::Start(Tag::Paragraph) => {
 1303|      0|                                let (ps, next) =
 1304|      0|                                    self.parse_inline_spans(events, i + 1, Tag::Paragraph)?;
 1305|      0|                                spans.extend(ps);
 1306|      0|                                i = next;
 1307|       |                            }
 1308|    189|                            Event::Code(code) => {
 1309|    189|                                spans.push(InlineSpan::Code(code.to_string()));
 1310|    189|                                i += 1;
 1311|    189|                            }
 1312|       |                            Event::Start(Tag::Emphasis) => {
 1313|      3|                                let (inner_text, next) =
 1314|      3|                                    self.collect_until_tag_end(events, i + 1, Tag::Emphasis)?;
                                                                                                          ^0
 1315|      3|                                spans.push(InlineSpan::Emphasis(inner_text));
 1316|      3|                                i = next;
 1317|       |                            }
 1318|       |                            Event::Start(Tag::Strong) => {
 1319|    415|                                let (inner_text, next) =
 1320|    415|                                    self.collect_until_tag_end(events, i + 1, Tag::Strong)?;
                                                                                                        ^0
 1321|    415|                                spans.push(InlineSpan::Strong(inner_text));
 1322|    415|                                i = next;
 1323|       |                            }
 1324|       |                            Event::Start(Tag::Strikethrough) => {
 1325|      3|                                let (inner_text, next) =
 1326|      3|                                    self.collect_until_tag_end(events, i + 1, Tag::Strikethrough)?;
                                                                                                               ^0
 1327|      3|                                spans.push(InlineSpan::Strikethrough(inner_text));
 1328|      3|                                i = next;
 1329|       |                            }
 1330|     22|                            Event::Start(Tag::Link(_, url, _)) => {
 1331|     22|                                let url_str = url.to_string();
 1332|     22|                                let (link_text, next) = self.collect_until_tag_end(
 1333|     22|                                    events,
 1334|     22|                                    i + 1,
 1335|     22|                                    Tag::Link(LinkType::Inline, "".into(), "".into()),
 1336|      0|                                )?;
 1337|     22|                                spans.push(InlineSpan::Link {
 1338|     22|                                    text: link_text,
 1339|     22|                                    url: url_str,
 1340|     22|                                });
 1341|     22|                                i = next;
 1342|       |                            }
 1343|      0|                            Event::Start(Tag::Image(_, url, title)) => {
 1344|      0|                                let url_str = url.to_string();
 1345|      0|                                let (alt_text, next) = self.collect_until_tag_end(
 1346|      0|                                    events,
 1347|      0|                                    i + 1,
 1348|      0|                                    Tag::Image(LinkType::Inline, "".into(), "".into()),
 1349|      0|                                )?;
 1350|      0|                                spans.push(InlineSpan::Image {
 1351|      0|                                    src: url_str,
 1352|      0|                                    alt: alt_text,
 1353|      0|                                    title: if title.is_empty() {
 1354|      0|                                        None
 1355|       |                                    } else {
 1356|      0|                                        Some(title.to_string())
 1357|       |                                    },
 1358|       |                                });
 1359|      0|                                i = next;
 1360|       |                            }
 1361|      4|                            Event::Start(Tag::List(child_first)) => {
 1362|      4|                                let (child_items, next) =
 1363|      4|                                    self.parse_list(events, i + 1, *child_first, depth + 1)?;
                                                                                                         ^0
 1364|      4|                                i = next;
 1365|      4|                                let ordered_child = child_first.is_some();
 1366|      8|                                for (idx, child) in child_items.into_iter().enumerate() {
                                                                  ^4          ^4          ^4
 1367|      8|                                    spans.push(InlineSpan::Text("\n".to_string()));
 1368|       |                                    // Indentation: 4 spaces per nested level
 1369|      8|                                    let indent = " ".repeat(4 * (depth + 1));
 1370|      8|                                    let marker = if ordered_child {
 1371|      4|                                        format!("{}.", idx + 1)
 1372|       |                                    } else {
 1373|      4|                                        "-".to_string()
 1374|       |                                    };
 1375|      8|                                    spans.push(InlineSpan::Text(format!("{}{} ", indent, marker)));
 1376|      8|                                    spans.extend(child);
 1377|       |                                }
 1378|       |                            }
 1379|    675|                            Event::Text(t) => {
 1380|    675|                                spans.push(InlineSpan::Text(t.to_string()));
 1381|    675|                                i += 1;
 1382|    675|                            }
 1383|      0|                            Event::SoftBreak | Event::HardBreak => {
 1384|      0|                                spans.push(InlineSpan::Text(" ".into()));
 1385|      0|                                i += 1;
 1386|      0|                            }
 1387|      0|                            _ => {
 1388|      0|                                i += 1;
 1389|      0|                            }
 1390|       |                        }
 1391|       |                    }
 1392|    510|                    items.push(spans);
 1393|       |                }
 1394|      0|                _ => i += 1,
 1395|       |            }
 1396|       |        }
 1397|       |
 1398|      0|        Ok((items, i))
 1399|    133|    }
 1400|       |
 1401|       |    /// Parse a table with headers and rows
 1402|      8|    fn parse_table(
 1403|      8|        &self,
 1404|      8|        events: &[Event],
 1405|      8|        start: usize,
 1406|      8|    ) -> Result<TableParseResult, anyhow::Error> {
 1407|      8|        let mut headers: Vec<Vec<InlineSpan>> = Vec::new();
 1408|      8|        let mut rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
 1409|      8|        let mut i = start;
 1410|       |
 1411|     48|        while i < events.len() {
 1412|     48|            match &events[i] {
 1413|       |                Event::Start(Tag::TableHead) => {
 1414|      8|                    i += 1;
 1415|     24|                    while i < events.len() {
 1416|     24|                        match &events[i] {
 1417|       |                            Event::Start(Tag::TableCell) => {
 1418|     16|                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
 1419|     16|                                    events,
 1420|     16|                                    i + 1,
 1421|     16|                                    Tag::TableCell,
 1422|       |                                    true,
 1423|      0|                                )?;
 1424|     16|                                headers.push(spans);
 1425|     16|                                i = next_idx;
 1426|       |                            }
 1427|       |                            Event::End(Tag::TableHead) => {
 1428|      8|                                i += 1;
 1429|      8|                                break;
 1430|       |                            }
 1431|      0|                            _ => i += 1,
 1432|       |                        }
 1433|       |                    }
 1434|       |                }
 1435|       |                Event::Start(Tag::TableRow) => {
 1436|     32|                    i += 1;
 1437|     32|                    let mut row: Vec<Vec<InlineSpan>> = Vec::new();
 1438|    104|                    while i < events.len() {
 1439|    104|                        match &events[i] {
 1440|       |                            Event::Start(Tag::TableCell) => {
 1441|     72|                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
 1442|     72|                                    events,
 1443|     72|                                    i + 1,
 1444|     72|                                    Tag::TableCell,
 1445|       |                                    true,
 1446|      0|                                )?;
 1447|     72|                                row.push(spans);
 1448|     72|                                i = next_idx;
 1449|       |                            }
 1450|       |                            Event::End(Tag::TableRow) => {
 1451|     32|                                i += 1;
 1452|     32|                                if !row.is_empty() {
 1453|     32|                                    rows.push(row);
 1454|     32|                                }
                                              ^0
 1455|     32|                                break;
 1456|       |                            }
 1457|      0|                            _ => i += 1,
 1458|       |                        }
 1459|       |                    }
 1460|       |                }
 1461|      8|                Event::End(Tag::Table(_)) => return Ok((headers, rows, i + 1)),
 1462|      0|                _ => i += 1,
 1463|       |            }
 1464|       |        }
 1465|      0|        Ok((headers, rows, i))
 1466|      8|    }
 1467|       |
 1468|       |    /// Render parsed markdown elements to egui UI
 1469|      2|    pub fn render_to_ui(&self, ui: &mut egui::Ui, elements: &[MarkdownElement]) {
 1470|       |        // Clear header rects before rendering a new frame
 1471|      2|        self.header_rects.borrow_mut().clear();
 1472|       |        // Reset per-frame link counter to ensure link IDs are stable across frames
 1473|      2|        *self.link_counter.borrow_mut() = 0;
 1474|       |        // Reset per-frame element rects
 1475|      2|        self.element_rects.borrow_mut().clear();
 1476|     10|        for (element_idx, element) in elements.iter().enumerate() {
                                                    ^2       ^2     ^2
 1477|       |            // Wrap each element in a no-op frame to capture its rect
 1478|     10|            let ir = egui::Frame::none().show(ui, |ui| {
 1479|     10|                match element {
 1480|      3|                    MarkdownElement::Paragraph(spans) => {
 1481|      3|                        self.render_inline_spans(ui, spans);
 1482|      3|                        ui.add_space(4.0);
 1483|      3|                    }
 1484|      1|                    MarkdownElement::Quote { depth, lines } => {
 1485|      1|                        ui.add_space(4.0);
 1486|      1|                        let bar_width = 3.0;
 1487|      1|                        let bar_gap = 6.0;
 1488|      1|                        let left_pad = 10.0 + (*depth as f32) * (bar_width + bar_gap);
 1489|       |                        // Substack-like styling: dark grey block with orange accent bars and white text
 1490|      1|                        let bg = Color32::from_rgb(24, 24, 24);
 1491|       |
 1492|      1|                        let resp = egui::Frame::none()
 1493|      1|                            .fill(bg)
 1494|      1|                            .stroke(Stroke::new(1.0, Color32::from_rgb(40, 40, 40)))
 1495|      1|                            .rounding(egui::Rounding::same(6.0))
 1496|      1|                            .inner_margin(egui::Margin {
 1497|      1|                                left: left_pad,
 1498|      1|                                right: 10.0,
 1499|      1|                                top: 8.0,
 1500|      1|                                bottom: 8.0,
 1501|      1|                            })
 1502|      1|                            .show(ui, |ui| {
 1503|      2|                                for (li, line) in lines.iter().enumerate() {
                                                                ^1           ^1
 1504|       |                                    // White text for quote content
 1505|      2|                                    ui.style_mut().visuals.override_text_color =
 1506|      2|                                        Some(Color32::WHITE);
 1507|      2|                                    self.render_inline_spans(ui, line);
 1508|      2|                                    ui.style_mut().visuals.override_text_color = None;
 1509|      2|                                    if li + 1 < lines.len() {
 1510|      1|                                        ui.add_space(3.0);
 1511|      1|                                    }
 1512|       |                                }
 1513|      1|                            });
 1514|       |
 1515|       |                        // Draw vertical orange quote bars on the left of the frame
 1516|      1|                        let rect = resp.response.rect;
 1517|      1|                        let top = rect.top() + 6.0;
 1518|      1|                        let bottom = rect.bottom() - 6.0;
 1519|      1|                        let bar_color = Color32::from_rgb(255, 103, 25); // Substack-like orange
 1520|      1|                        for d in 0..*depth {
 1521|      1|                            let x = rect.left() + 6.0 + (d as f32) * (bar_width + bar_gap);
 1522|      1|                            let bar_rect = egui::Rect::from_min_max(
 1523|      1|                                egui::pos2(x, top),
 1524|      1|                                egui::pos2(x + bar_width, bottom),
 1525|      1|                            );
 1526|      1|                            ui.painter().rect_filled(bar_rect, 2.0, bar_color);
 1527|      1|                        }
 1528|       |
 1529|      1|                        ui.add_space(6.0);
 1530|       |                    }
 1531|      2|                    MarkdownElement::Header { level, spans, id } => {
 1532|      2|                        let font_size = match level {
 1533|      2|                            1 => self.font_sizes.h1,
 1534|      0|                            2 => self.font_sizes.h2,
 1535|      0|                            3 => self.font_sizes.h3,
 1536|      0|                            4 => self.font_sizes.h4,
 1537|      0|                            5 => self.font_sizes.h5,
 1538|      0|                            6 => self.font_sizes.h6,
 1539|      0|                            _ => self.font_sizes.body,
 1540|       |                        };
 1541|       |
 1542|      2|                        ui.add_space(8.0);
 1543|      2|                        let resp = ui.horizontal_wrapped(|ui| {
 1544|       |                            // Avoid artificial gaps between header fragments
 1545|      2|                            ui.spacing_mut().item_spacing.x = 0.0;
 1546|      4|                            for span in spans {
                                              ^2
 1547|      2|                                self.render_inline_span(ui, span, Some(font_size), Some(true));
 1548|      2|                            }
 1549|      2|                        });
 1550|       |                        // Record the header rect for in-document navigation
 1551|      2|                        self.header_rects
 1552|      2|                            .borrow_mut()
 1553|      2|                            .insert(id.clone(), resp.response.rect);
 1554|      2|                        ui.add_space(6.0);
 1555|       |                    }
 1556|      1|                    MarkdownElement::CodeBlock { language, text } => {
 1557|      1|                        self.render_code_block(ui, language.as_deref(), text);
 1558|      1|                    }
 1559|      1|                    MarkdownElement::List { ordered, items } => {
 1560|      1|                        self.render_list(ui, *ordered, items);
 1561|      1|                    }
 1562|      1|                    MarkdownElement::HorizontalRule => {
 1563|      1|                        ui.add_space(8.0);
 1564|      1|                        ui.separator();
 1565|      1|                        ui.add_space(8.0);
 1566|      1|                    }
 1567|      1|                    MarkdownElement::Table { headers, rows } => {
 1568|      1|                        self.render_table(ui, headers, rows, element_idx);
 1569|      1|                    }
 1570|       |                }
 1571|     10|            });
 1572|     10|            self.element_rects.borrow_mut().push(ir.response.rect);
 1573|       |        }
 1574|       |        // Add a little extra breathing room at the end so
 1575|       |        // the final line doesn't sit flush under the status bar.
 1576|      2|        ui.add_space(16.0);
 1577|      2|    }
 1578|       |
 1579|       |    /// Render inline spans in a wrapped horizontal layout
 1580|      5|    fn render_inline_spans(&self, ui: &mut egui::Ui, spans: &[InlineSpan]) {
 1581|      5|        ui.horizontal_wrapped(|ui| {
 1582|       |            // Avoid adding UI spacing between inline fragments
 1583|      5|            ui.spacing_mut().item_spacing.x = 0.0;
 1584|     20|            for span in spans {
                              ^15
 1585|     15|                self.render_inline_span(ui, span, None, None);
 1586|     15|            }
 1587|      5|        });
 1588|      5|    }
 1589|       |
 1590|       |    /// Fix Unicode characters that may not render properly in the default font
 1591|     30|    fn fix_unicode_chars(&self, text: &str) -> String {
 1592|     30|        let normalized: String = text.nfc().collect();
 1593|    274|        if !normalized.chars().any(|c| {
                          ^30                ^30
 1594|    272|            matches!(
 1595|    274|                c,
 1596|       |                '\u{2011}'
 1597|       |                    | '\u{00AD}'
 1598|       |                    | '\u{2010}'
 1599|       |                    | '\u{2212}'
 1600|       |                    | '\u{2013}'
 1601|       |                    | '\u{2014}'
 1602|       |                    | '\u{00A0}'
 1603|       |                    | '\u{202F}'
 1604|       |                    | '\u{2190}'
 1605|       |                    | '\u{2192}'
 1606|       |                    | '\u{2191}'
 1607|       |                    | '\u{2193}'
 1608|       |            )
 1609|    274|        }) {
 1610|     28|            return normalized;
 1611|      2|        }
 1612|       |
 1613|      2|        let mut out = String::with_capacity(normalized.len());
 1614|     12|        for ch in normalized.chars() {
                                ^2         ^2
 1615|     12|            match ch {
 1616|       |                '\u{2011}' | '\u{00AD}' | '\u{2010}' | '\u{2212}' | '\u{2013}' | '\u{2014}' => {
 1617|      1|                    out.push('-')
 1618|       |                }
 1619|      1|                '\u{00A0}' | '\u{202F}' => out.push(' '),
 1620|      1|                '\u{2190}' => {
 1621|      1|                    out.push('<');
 1622|      1|                    out.push('-');
 1623|      1|                }
 1624|      1|                '\u{2192}' => {
 1625|      1|                    out.push('-');
 1626|      1|                    out.push('>');
 1627|      1|                }
 1628|      1|                '\u{2191}' => {
 1629|      1|                    out.push('^');
 1630|      1|                }
 1631|      1|                '\u{2193}' => {
 1632|      1|                    out.push('v');
 1633|      1|                }
 1634|      6|                _ => out.push(ch),
 1635|       |            }
 1636|       |        }
 1637|      2|        out
 1638|     30|    }
 1639|       |
 1640|       |    #[cfg(test)]
 1641|      3|    pub(crate) fn normalize_text_for_test(&self, text: &str) -> String {
 1642|      3|        self.fix_unicode_chars(text)
 1643|      3|    }
 1644|       |
 1645|       |    /// Render a single inline span    /// Render a single inline span
 1646|     19|    fn render_inline_span(
 1647|     19|        &self,
 1648|     19|        ui: &mut egui::Ui,
 1649|     19|        span: &InlineSpan,
 1650|     19|        font_size: Option<f32>,
 1651|     19|        strong: Option<bool>,
 1652|     19|    ) {
 1653|     19|        let size = font_size.unwrap_or(self.font_sizes.body);
 1654|     19|        let is_strong = strong.unwrap_or(false);
 1655|       |
 1656|     19|        match span {
 1657|     13|            InlineSpan::Text(text) => {
 1658|     13|                let fixed_text = self.fix_unicode_chars(text);
 1659|     13|                let style = InlineStyle {
 1660|     13|                    strong: is_strong,
 1661|     13|                    ..Default::default()
 1662|     13|                };
 1663|     13|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 1664|     13|            }
 1665|      0|            InlineSpan::Code(code) => {
 1666|       |                // Inline code: adapt style to theme (light vs dark)
 1667|      0|                ui.spacing_mut().item_spacing.x = 0.0;
 1668|      0|                let is_dark = ui.visuals().dark_mode;
 1669|      0|                let (bg, fg) = if is_dark {
 1670|      0|                    (
 1671|      0|                        Color32::from_rgb(30, 30, 30),
 1672|      0|                        Color32::from_rgb(180, 255, 180),
 1673|      0|                    )
 1674|       |                } else {
 1675|       |                    // Light theme: white background with readable code color
 1676|      0|                    (Color32::WHITE, Color32::from_rgb(60, 80, 150))
 1677|       |                };
 1678|      0|                let response = ui.add(
 1679|      0|                    egui::Label::new(
 1680|      0|                        RichText::new(code.clone())
 1681|      0|                            .size(self.font_sizes.code)
 1682|      0|                            .family(egui::FontFamily::Monospace)
 1683|      0|                            .background_color(bg)
 1684|      0|                            .color(fg),
 1685|       |                    )
 1686|      0|                    .wrap(false),
 1687|       |                );
 1688|       |
 1689|       |                // Add context menu for code
 1690|      0|                response.context_menu(|ui| {
 1691|      0|                    self.render_inline_code_context_menu(ui, code);
 1692|      0|                });
 1693|       |            }
 1694|      1|            InlineSpan::Strong(text) => {
 1695|      1|                let fixed_text = self.fix_unicode_chars(text);
 1696|      1|                let style = InlineStyle {
 1697|      1|                    strong: true,
 1698|      1|                    ..Default::default()
 1699|      1|                };
 1700|      1|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 1701|      1|            }
 1702|      0|            InlineSpan::Emphasis(text) => {
 1703|      0|                let fixed_text = self.fix_unicode_chars(text);
 1704|      0|                let style = InlineStyle {
 1705|      0|                    italics: true,
 1706|      0|                    strong: is_strong,
 1707|      0|                    ..Default::default()
 1708|      0|                };
 1709|      0|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 1710|      0|            }
 1711|      0|            InlineSpan::Strikethrough(text) => {
 1712|      0|                let fixed_text = self.fix_unicode_chars(text);
 1713|      0|                let style = InlineStyle {
 1714|      0|                    strike: true,
 1715|      0|                    strong: is_strong,
 1716|      0|                    ..Default::default()
 1717|      0|                };
 1718|      0|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 1719|      0|            }
 1720|      1|            InlineSpan::Link { text, url } => {
 1721|      1|                let fixed_text = self.fix_unicode_chars(text);
 1722|      1|                let group = ui.horizontal_wrapped(|ui| {
 1723|       |                    // Render link-like styled text with emoji expansion
 1724|      1|                    let color = if Self::is_external_url(url) {
 1725|       |                        // Slightly different color to indicate external website links
 1726|      0|                        Color32::from_rgb(120, 190, 255)
 1727|       |                    } else {
 1728|      1|                        Color32::LIGHT_BLUE
 1729|       |                    };
 1730|      1|                    let style = InlineStyle {
 1731|      1|                        strong: is_strong,
 1732|      1|                        color: Some(color),
 1733|      1|                        ..Default::default()
 1734|      1|                    };
 1735|      1|                    self.render_text_with_emojis(ui, &fixed_text, size, style);
 1736|      1|                });
 1737|       |                // Use a unique id per link occurrence to avoid collisions when the same URL appears multiple times
 1738|      1|                let mut counter = self.link_counter.borrow_mut();
 1739|      1|                let id = egui::Id::new(format!("link:{}:{}", *counter, url));
 1740|      1|                *counter += 1;
 1741|      1|                let r = ui.interact(group.response.rect, id, egui::Sense::click());
 1742|      1|                if r.hovered() {
 1743|      0|                    ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
 1744|      1|                }
 1745|      1|                if r.clicked() {
 1746|      0|                    self.trigger_link(url);
 1747|      1|                }
 1748|       |
 1749|       |                // Add context menu for links
 1750|      1|                r.context_menu(|ui| {
                                                  ^0
 1751|      0|                    self.render_link_context_menu(ui, text, url);
 1752|      0|                });
 1753|       |            }
 1754|      4|            InlineSpan::Image { src, alt, title } => {
 1755|       |                // Resolve path
 1756|      4|                let resolved = self.resolve_image_path(src);
 1757|      4|                let available_w = ui.available_width().max(1.0);
 1758|       |                // Try to get or load texture
 1759|      4|                if let Some((tex, w, h)) = self.get_or_load_image_texture(ui, &resolved) {
                                           ^2   ^2 ^2
 1760|      2|                    let (tw, th) = (w as f32, h as f32);
 1761|       |                    // Scale logic:
 1762|       |                    // - Start at UI scale (e.g., 1.0 for 100%, 1.1 for 110%).
 1763|       |                    // - Only downscale further if it would exceed available width.
 1764|      2|                    let base_scale = self.ui_scale();
 1765|      2|                    let scaled_w = tw * base_scale;
 1766|      2|                    let scale = if scaled_w > available_w {
 1767|      0|                        (available_w / tw).clamp(0.01, 4.0)
 1768|       |                    } else {
 1769|      2|                        base_scale
 1770|       |                    };
 1771|      2|                    let size = egui::vec2((tw * scale).round(), (th * scale).round());
 1772|      2|                    let image = egui::Image::new(&tex).fit_to_exact_size(size);
 1773|      2|                    let resp = ui.add(image);
 1774|      2|                    if let Some(t) = title {
 1775|      2|                        if !t.is_empty() {
 1776|      2|                            if resp.hovered() {
 1777|      0|                                resp.on_hover_text(t.clone());
 1778|      2|                            }
 1779|       |                            // Subtle caption below image
 1780|      2|                            ui.add_space(2.0);
 1781|      2|                            ui.label(
 1782|      2|                                RichText::new(t.clone())
 1783|      2|                                    .size(self.font_sizes.body - 2.0)
 1784|      2|                                    .color(Color32::from_rgb(140, 140, 140)),
 1785|       |                            );
 1786|      0|                        }
 1787|      0|                    }
 1788|      2|                    ui.add_space(6.0);
 1789|       |                } else {
 1790|       |                    // Placeholder with alt and error info
 1791|      2|                    egui::Frame::none()
 1792|      2|                        .fill(Color32::from_rgb(30, 30, 30))
 1793|      2|                        .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 1794|      2|                        .inner_margin(8.0)
 1795|      2|                        .show(ui, |ui| {
 1796|      2|                            let msg = if src.starts_with("http://") || src.starts_with("https://") {
 1797|      1|                                "Remote images are disabled"
 1798|       |                            } else {
 1799|      1|                                "Image not found or unsupported"
 1800|       |                            };
 1801|      2|                            let label = if alt.is_empty() {
 1802|      0|                                src.as_str()
 1803|       |                            } else {
 1804|      2|                                alt.as_str()
 1805|       |                            };
 1806|      2|                            ui.label(
 1807|      2|                                RichText::new(format!("{}\n{}", label, msg))
 1808|      2|                                    .size(self.font_sizes.body),
 1809|       |                            );
 1810|      2|                        });
 1811|      2|                    ui.add_space(6.0);
 1812|       |                }
 1813|       |            }
 1814|       |        }
 1815|     19|    }
 1816|       |
 1817|      4|    fn extract_fragment(url: &str) -> Option<String> {
 1818|      4|        if let Some(stripped) = url.strip_prefix('#') {
                                  ^1
 1819|       |            // Already a fragment within current document
 1820|      1|            return Some(stripped.to_ascii_lowercase());
 1821|      3|        }
 1822|      3|        None
 1823|      4|    }
 1824|       |
 1825|      2|    fn is_external_url(url: &str) -> bool {
 1826|      2|        let lower = url.to_ascii_lowercase();
 1827|      2|        lower.starts_with("http://")
 1828|      2|            || lower.starts_with("https://")
 1829|      1|            || lower.starts_with("mailto:")
 1830|      1|            || lower.starts_with("www.")
 1831|      2|    }
 1832|       |
 1833|     15|    fn render_text_with_emojis(
 1834|     15|        &self,
 1835|     15|        ui: &mut egui::Ui,
 1836|     15|        text: &str,
 1837|     15|        size: f32,
 1838|     15|        style: InlineStyle,
 1839|     15|    ) {
 1840|     15|        let mut buffer = String::new();
 1841|    132|        for g in text.graphemes(true) {
                               ^15  ^15
 1842|    132|            if let Some(key) = self.emoji_key_for_grapheme(g) {
                                      ^0
 1843|       |                // Flush buffered text first (with highlighting if active)
 1844|      0|                if !buffer.is_empty() {
 1845|      0|                    self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
 1846|      0|                    buffer.clear();
 1847|      0|                }
 1848|      0|                let handle = self.get_or_make_emoji_texture(ui, &key);
 1849|      0|                let sz = size * 1.2;
 1850|      0|                ui.add(egui::Image::new(&handle).max_width(sz).max_height(sz));
 1851|    132|            } else {
 1852|    132|                buffer.push_str(g);
 1853|    132|            }
 1854|       |        }
 1855|     15|        if !buffer.is_empty() {
 1856|     15|            self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
 1857|     15|        }
                      ^0
 1858|     15|    }
 1859|       |
 1860|     15|    fn render_text_segment_with_optional_highlight(
 1861|     15|        &self,
 1862|     15|        ui: &mut egui::Ui,
 1863|     15|        segment: &str,
 1864|     15|        size: f32,
 1865|     15|        style: InlineStyle,
 1866|     15|    ) {
 1867|       |        // First expand emoji shortcodes, then superscript ^...^ notation
 1868|     15|        let expanded = Self::expand_shortcodes(segment);
 1869|     15|        let expanded = Self::expand_superscripts(&expanded);
 1870|     15|        if let Some(h) = self
 1871|     15|            .highlight_phrase
 1872|     15|            .borrow()
 1873|     15|            .as_ref()
 1874|     15|            .filter(|s| !s.is_empty())
 1875|       |        {
 1876|     18|            for (range, highlighted) in self.highlight_segments(&expanded, Some(h)) {
                                                      ^15  ^15                ^15        ^15
 1877|     18|                if range.is_empty() {
 1878|      0|                    continue;
 1879|     18|                }
 1880|     18|                let slice = &expanded[range];
 1881|     18|                if highlighted {
 1882|      3|                    self.render_highlighted_segment(ui, slice, size, style);
 1883|     15|                } else {
 1884|     15|                    self.render_plain_segment(ui, slice, size, style);
 1885|     15|                }
 1886|       |            }
 1887|     15|            return;
 1888|      0|        }
 1889|      0|        self.render_plain_segment(ui, &expanded, size, style);
 1890|     15|    }
 1891|       |
 1892|     15|    fn render_plain_segment(&self, ui: &mut egui::Ui, text: &str, size: f32, style: InlineStyle) {
 1893|     15|        if text.is_empty() {
 1894|      0|            return;
 1895|     15|        }
 1896|     15|        let mut rich = RichText::new(text).size(size);
 1897|     15|        if style.strong {
 1898|      3|            rich = rich.strong();
 1899|     12|        }
 1900|     15|        if style.italics {
 1901|      0|            rich = rich.italics();
 1902|     15|        }
 1903|     15|        if style.strike {
 1904|      0|            rich = rich.strikethrough();
 1905|     15|        }
 1906|     15|        if let Some(color) = style.color {
                                  ^1
 1907|      1|            rich = rich.color(color);
 1908|     14|        }
 1909|     15|        let response = ui.add(egui::Label::new(rich).wrap(true));
 1910|       |
 1911|       |        // Add context menu for text
 1912|       |        // Note: Due to egui limitations, selection is cleared on right-click
 1913|       |        // As a workaround, we provide "Copy Text" for the segment
 1914|     15|        response.context_menu(|ui| {
                                                 ^0
 1915|      0|            self.render_text_context_menu(ui, text);
 1916|      0|        });
 1917|     15|    }
 1918|       |
 1919|      3|    fn render_highlighted_segment(
 1920|      3|        &self,
 1921|      3|        ui: &mut egui::Ui,
 1922|      3|        text: &str,
 1923|      3|        size: f32,
 1924|      3|        style: InlineStyle,
 1925|      3|    ) {
 1926|      3|        if text.is_empty() {
 1927|      0|            return;
 1928|      3|        }
 1929|      3|        let visuals = ui.visuals();
 1930|      3|        let bg = visuals.selection.bg_fill;
 1931|      3|        let mut text_color = style.color;
 1932|      3|        let fallback_color = visuals.selection.stroke.color;
 1933|      3|        if text_color.is_none() {
 1934|      3|            text_color = Some(fallback_color);
 1935|      3|        }
                      ^0
 1936|       |
 1937|      3|        let mut rich = RichText::new(text).size(size).background_color(bg);
 1938|      3|        if style.strong {
 1939|      0|            rich = rich.strong();
 1940|      3|        }
 1941|      3|        if style.italics {
 1942|      0|            rich = rich.italics();
 1943|      3|        }
 1944|      3|        if style.strike {
 1945|      0|            rich = rich.strikethrough();
 1946|      3|        }
 1947|      3|        if let Some(color) = text_color {
 1948|      3|            rich = rich.color(color);
 1949|      3|        }
                      ^0
 1950|      3|        let response = ui.add(egui::Label::new(rich).wrap(true));
 1951|       |
 1952|       |        // Add context menu for highlighted text
 1953|      3|        response.context_menu(|ui| {
                                                 ^0
 1954|      0|            self.render_text_context_menu(ui, text);
 1955|      0|        });
 1956|      3|    }
 1957|       |
 1958|      1|    fn render_text_context_menu(&self, ui: &mut egui::Ui, text: &str) {
 1959|      1|        if ui.button("Copy Text").clicked() {
 1960|      0|            self.copy_text_and_close(ui, text);
 1961|      1|        }
 1962|      1|        ui.label("Tip: Use Ctrl+C to copy selected text");
 1963|      1|    }
 1964|       |
 1965|      1|    fn render_inline_code_context_menu(&self, ui: &mut egui::Ui, code: &str) {
 1966|      1|        if ui.button("Copy Code").clicked() {
 1967|      0|            self.copy_text_and_close(ui, code);
 1968|      1|        }
 1969|      1|    }
 1970|       |
 1971|      1|    fn render_code_block_context_menu(
 1972|      1|        &self,
 1973|      1|        ui: &mut egui::Ui,
 1974|      1|        code: &str,
 1975|      1|        language: Option<&str>,
 1976|      1|    ) {
 1977|      1|        if ui.button("Copy Code").clicked() {
 1978|      0|            self.copy_text_and_close(ui, code);
 1979|      1|        }
 1980|      1|        if let Some(lang) = language {
 1981|      1|            if ui.button(format!("Copy as {}", lang)).clicked() {
 1982|      0|                self.copy_text_and_close(ui, &format!("```{}\n{}\n```", lang, code));
 1983|      1|            }
 1984|      0|        }
 1985|      1|    }
 1986|       |
 1987|      1|    fn render_link_context_menu(&self, ui: &mut egui::Ui, text: &str, url: &str) {
 1988|      1|        if ui.button("Open Link").clicked() {
 1989|      0|            self.trigger_link(url);
 1990|      0|            ui.close_menu();
 1991|      1|        }
 1992|      1|        ui.separator();
 1993|      1|        if ui.button("Copy Link Text").clicked() {
 1994|      0|            self.copy_text_and_close(ui, text);
 1995|      1|        }
 1996|      1|        if ui.button("Copy Link URL").clicked() {
 1997|      0|            self.copy_text_and_close(ui, url);
 1998|      1|        }
 1999|      1|    }
 2000|       |
 2001|      1|    fn render_cell_context_menu(&self, ui: &mut egui::Ui, text: &str) {
 2002|      1|        if ui.button("Copy Cell Text").clicked() {
 2003|      0|            self.copy_text_and_close(ui, text);
 2004|      1|        }
 2005|      1|    }
 2006|       |
 2007|      1|    fn copy_text_and_close(&self, ui: &mut egui::Ui, text: &str) {
 2008|      1|        ui.ctx().copy_text(text.to_string());
 2009|      1|        ui.close_menu();
 2010|      1|    }
 2011|       |
 2012|       |    /// Map a grapheme cluster to an emoji image key if available.
 2013|    133|    fn emoji_key_for_grapheme(&self, g: &str) -> Option<String> {
 2014|    133|        if crate::emoji_catalog::image_bytes_for(g).is_some() {
 2015|      1|            return Some(g.to_string());
 2016|    132|        }
 2017|    132|        let stripped: String = g.chars().filter(|&c| c != '\u{FE0F}').collect();
 2018|    132|        if stripped != g && crate::emoji_catalog::image_bytes_for(&stripped).is_some() {
                                          ^0                                               ^0
 2019|      0|            return Some(stripped);
 2020|    132|        }
 2021|       |        // If the grapheme explicitly requests emoji presentation (contains VS16),
 2022|       |        // treat it as an emoji even if we don't have a sprite; fall back to a
 2023|       |        // generated placeholder via emoji_assets to avoid stray tofu.
 2024|    132|        if g.chars().any(|c| c == '\u{FE0F}') {
 2025|      0|            return Some(stripped); // prefer stripped as the texture key
 2026|    132|        }
 2027|    132|        None
 2028|    133|    }
 2029|       |
 2030|      0|    fn get_or_make_emoji_texture(&self, ui: &mut egui::Ui, emoji: &str) -> egui::TextureHandle {
 2031|      0|        if let Some(tex) = self.emoji_textures.borrow().get(emoji) {
 2032|      0|            return tex.clone();
 2033|      0|        }
 2034|       |
 2035|      0|        let img = if let Some(bytes) = emoji_catalog::image_bytes_for(emoji) {
 2036|      0|            match image::load_from_memory(bytes) {
 2037|      0|                Ok(dyn_img) => {
 2038|      0|                    let rgba = dyn_img.to_rgba8();
 2039|      0|                    let (w, h) = rgba.dimensions();
 2040|      0|                    let pixels = rgba.into_vec();
 2041|      0|                    egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &pixels)
 2042|       |                }
 2043|      0|                Err(_) => emoji_assets::make_image(emoji, 64)
 2044|      0|                    .unwrap_or_else(|| self.generate_emoji_image(emoji, 64)),
 2045|       |            }
 2046|       |        } else {
 2047|      0|            emoji_assets::make_image(emoji, 64)
 2048|      0|                .unwrap_or_else(|| self.generate_emoji_image(emoji, 64))
 2049|       |        };
 2050|      0|        let handle = ui.ctx().load_texture(
 2051|      0|            format!("emoji:{}", emoji),
 2052|      0|            img,
 2053|       |            egui::TextureOptions::LINEAR,
 2054|       |        );
 2055|      0|        self.emoji_textures
 2056|      0|            .borrow_mut()
 2057|      0|            .insert(emoji.to_string(), handle.clone());
 2058|      0|        handle
 2059|      0|    }
 2060|       |
 2061|       |    // Rough width measurement for inline spans without wrapping
 2062|      0|    fn measure_inline_spans(&self, ui: &egui::Ui, spans: &[InlineSpan]) -> f32 {
 2063|      0|        let mut width = 0.0f32;
 2064|      0|        ui.fonts(|fonts| {
 2065|      0|            for span in spans {
 2066|      0|                match span {
 2067|      0|                    InlineSpan::Text(t)
 2068|      0|                    | InlineSpan::Strong(t)
 2069|      0|                    | InlineSpan::Emphasis(t)
 2070|      0|                    | InlineSpan::Strikethrough(t)
 2071|      0|                    | InlineSpan::Link { text: t, .. } => {
 2072|      0|                        let body = egui::FontId::proportional(self.font_sizes.body);
 2073|       |                        // Expand shortcodes to better estimate width and count emojis
 2074|      0|                        let expanded = Self::expand_shortcodes(t);
 2075|      0|                        let galley = fonts.layout_no_wrap(expanded.clone(), body, Color32::WHITE);
 2076|      0|                        width += galley.size().x;
 2077|       |                        // Add a small extra width for emoji images (drawn larger than text)
 2078|      0|                        let emoji_extra = expanded
 2079|      0|                            .chars()
 2080|      0|                            .filter(|c| Self::is_known_emoji(*c))
 2081|      0|                            .count() as f32
 2082|      0|                            * (self.font_sizes.body * 0.2);
 2083|      0|                        width += emoji_extra;
 2084|       |                    }
 2085|      0|                    InlineSpan::Code(code) => {
 2086|      0|                        let mono = egui::FontId::monospace(self.font_sizes.code);
 2087|      0|                        let galley = fonts.layout_no_wrap(code.to_string(), mono, Color32::WHITE);
 2088|      0|                        width += galley.size().x + 6.0; // small padding for code background
 2089|      0|                    }
 2090|      0|                    InlineSpan::Image { src, .. } => {
 2091|       |                        // Use cached texture size if available; otherwise a conservative thumbnail.
 2092|      0|                        let cap = (ui.available_width() * 0.6).max(48.0);
 2093|      0|                        let cached = self
 2094|      0|                            .image_textures
 2095|      0|                            .borrow()
 2096|      0|                            .get(src)
 2097|      0|                            .map(|entry| entry.size[0] as f32 * self.ui_scale());
 2098|      0|                        let approx = cached.unwrap_or(self.font_sizes.body * 12.0);
 2099|      0|                        width += approx.min(cap);
 2100|       |                    }
 2101|       |                }
 2102|      0|                width += 4.0; // spacing between spans
 2103|       |            }
 2104|      0|        });
 2105|      0|        width
 2106|      0|    }
 2107|       |
 2108|      0|    fn is_known_emoji(c: char) -> bool {
 2109|      0|        matches!(
 2110|      0|            c,
 2111|       |            '\u{1f389}' // 
 2112|       |                | '\u{2705}' // 
 2113|       |                | '\u{1f680}' // 
 2114|       |                | '\u{1f642}' // 
 2115|       |                | '\u{1f600}' // 
 2116|       |                | '\u{1f609}' // 
 2117|       |                | '\u{2b50}'  // 
 2118|       |                | '\u{1f525}' // 
 2119|       |                | '\u{1f44d}' // 
 2120|       |                | '\u{1f44e}' // 
 2121|       |                | '\u{1f4a1}' // 
 2122|       |                | '\u{2753}'  // 
 2123|       |                | '\u{2757}'  // 
 2124|       |                | '\u{1f4dd}' // 
 2125|       |                | '\u{1f9e0}' // 
 2126|       |                | '\u{1f9ea}' // 
 2127|       |                | '\u{1f4e6}' // 
 2128|       |                | '\u{1f527}' // 
 2129|       |        )
 2130|      0|    }
 2131|       |
 2132|     30|    fn expand_shortcodes(s: &str) -> String {
 2133|       |        use crate::emoji_catalog::shortcode_map;
 2134|     30|        if !s.contains(':') {
 2135|     26|            return s.to_string();
 2136|      4|        }
 2137|      4|        let mut out = String::new();
 2138|      4|        let map = shortcode_map();
 2139|      4|        let mut i = 0;
 2140|      4|        let bytes = s.as_bytes();
 2141|     41|        while i < s.len() {
 2142|     37|            if bytes[i] == b':' {
 2143|     22|                if let Some(end_rel) = bytes[i + 1..].iter().position(|&b| b == b':') {
                                          ^4         ^4                    ^4
 2144|      4|                    let end = i + 1 + end_rel;
 2145|      4|                    let code = &s[i..=end];
 2146|      4|                    if let Some(&emoji) = map.get(code) {
 2147|      4|                        out.push_str(emoji);
 2148|      4|                        i = end + 1;
 2149|      4|                        continue;
 2150|      0|                    }
 2151|      0|                }
 2152|     33|            }
 2153|       |            // advance by one UTF-8 character
 2154|     33|            let ch = s[i..].chars().next().unwrap();
 2155|     33|            out.push(ch);
 2156|     33|            i += ch.len_utf8();
 2157|       |        }
 2158|      4|        out
 2159|     30|    }
 2160|       |
 2161|       |    // Expand ^...^ segments into Unicode superscript characters when available.
 2162|       |    // Example: "5^th^" -> "5??"
 2163|     31|    fn expand_superscripts(s: &str) -> String {
 2164|     31|        if !s.contains('^') {
 2165|     27|            return s.to_string();
 2166|      4|        }
 2167|      4|        let mut out = String::new();
 2168|      4|        let mut chars = s.chars().peekable();
 2169|    160|        while let Some(c) = chars.next() {
                                     ^156
 2170|    156|            if c == '^' {
 2171|       |                // Look ahead to see if there's a matching closing caret within reasonable bounds
 2172|      6|                let mut buf = String::new();
 2173|      6|                let mut found_closing = false;
 2174|      6|                let mut temp_chars = chars.clone();
 2175|      6|                let mut char_count = 0;
 2176|       |
 2177|     17|                while let Some(&nc) = temp_chars.peek() {
 2178|     17|                    if nc == '^' {
 2179|      3|                        found_closing = true;
 2180|      3|                        break;
 2181|     14|                    }
 2182|     14|                    if !nc.is_alphanumeric() && !matches!(nc, '+' | '-' | '=' | '(' | ')') {
                                                               ^3       ^3
 2183|      3|                        break;
 2184|     11|                    }
 2185|     11|                    if char_count >= 10 {
 2186|      0|                        break;
 2187|     11|                    }
 2188|     11|                    temp_chars.next();
 2189|     11|                    char_count += 1;
 2190|       |                }
 2191|       |
 2192|      6|                if found_closing && char_count > 0 {
                                                  ^3
 2193|      3|                    for _ in 0..char_count {
 2194|      5|                        if let Some(nc) = chars.next() {
 2195|      5|                            buf.push(nc);
 2196|      5|                        }
                                      ^0
 2197|       |                    }
 2198|       |                    // Skip the closing caret
 2199|      3|                    chars.next();
 2200|      3|                    out.push_str(&Self::to_superscript(&buf));
 2201|      3|                } else {
 2202|      3|                    out.push('^');
 2203|      3|                }
 2204|    150|            } else {
 2205|    150|                out.push(c);
 2206|    150|            }
 2207|       |        }
 2208|      4|        out
 2209|     31|    }
 2210|       |
 2211|      3|    fn to_superscript(s: &str) -> String {
 2212|      3|        s.chars()
 2213|      5|            .map(|c| match c {
                           ^3
 2214|      0|                '0' => '\u{2070}',
 2215|      0|                '1' => '\u{00b9}',
 2216|      1|                '2' => '\u{00b2}',
 2217|      0|                '3' => '\u{00b3}',
 2218|      0|                '4' => '\u{2074}',
 2219|      0|                '5' => '\u{2075}',
 2220|      0|                '6' => '\u{2076}',
 2221|      0|                '7' => '\u{2077}',
 2222|      0|                '8' => '\u{2078}',
 2223|      0|                '9' => '\u{2079}',
 2224|      0|                '+' => '\u{207a}',
 2225|      0|                '-' => '\u{207b}',
 2226|      0|                '=' => '\u{207c}',
 2227|      0|                '(' => '\u{207d}',
 2228|      0|                ')' => '\u{207e}',
 2229|      0|                'a' | 'A' => '\u{1d43}',
 2230|      0|                'b' | 'B' => '\u{1d47}',
 2231|      0|                'c' | 'C' => '\u{1d9c}',
 2232|      0|                'd' | 'D' => '\u{1d48}',
 2233|      0|                'e' | 'E' => '\u{1d49}',
 2234|      0|                'f' | 'F' => '\u{1da0}',
 2235|      0|                'g' | 'G' => '\u{1d4d}',
 2236|      2|                'h' | 'H' => '\u{02b0}',
 2237|      0|                'i' | 'I' => '\u{2071}',
 2238|      0|                'j' | 'J' => '\u{02b2}',
 2239|      0|                'k' | 'K' => '\u{1d4f}',
 2240|      0|                'l' | 'L' => '\u{02e1}',
 2241|      0|                'm' | 'M' => '\u{1d50}',
 2242|      0|                'n' | 'N' => '\u{207f}',
 2243|      0|                'o' | 'O' => '\u{1d52}',
 2244|      0|                'p' | 'P' => '\u{1d56}',
 2245|      0|                'q' | 'Q' => '\u{1d56}',
 2246|      0|                'r' | 'R' => '\u{02b3}',
 2247|      0|                's' | 'S' => '\u{02e2}',
 2248|      2|                't' | 'T' => '\u{1d57}',
 2249|      0|                'u' | 'U' => '\u{1d58}',
 2250|      0|                'v' | 'V' => '\u{1d5b}',
 2251|      0|                'w' | 'W' => '\u{02b7}',
 2252|      0|                'x' | 'X' => '\u{02e3}',
 2253|      0|                'y' | 'Y' => '\u{02b8}',
 2254|      0|                'z' | 'Z' => '\u{1dbb}',
 2255|      0|                other => other,
 2256|      5|            })
 2257|      3|            .collect()
 2258|      3|    }
 2259|       |
 2260|      0|    fn generate_emoji_image(&self, emoji: &str, size: usize) -> egui::ColorImage {
 2261|       |        // Simple procedural placeholder icons to keep binary small and avoid external assets
 2262|       |        use egui::Color32 as C;
 2263|      0|        let mut img = egui::ColorImage::new([size, size], C::TRANSPARENT);
 2264|      0|        let cx = (size as i32) / 2;
 2265|      0|        let cy = cx;
 2266|      0|        let r = (size as i32) / 2 - 2;
 2267|       |
 2268|      0|        let (base, accent) = match emoji {
 2269|      0|            "\u{1f389}" => (C::from_rgb(255, 215, 0), C::from_rgb(255, 80, 80)),
 2270|      0|            "\u{2705}" => (C::from_rgb(30, 150, 30), C::WHITE),
 2271|      0|            "\u{1f680}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 100, 100)),
 2272|      0|            "\u{1f642}" | "\u{1f600}" | "\u{1f609}" => {
 2273|      0|                (C::from_rgb(255, 205, 64), C::from_rgb(90, 60, 10))
 2274|       |            }
 2275|      0|            "\u{2b50}" => (C::from_rgb(255, 215, 0), C::WHITE),
 2276|      0|            "\u{1f525}" => (C::from_rgb(255, 120, 50), C::from_rgb(255, 200, 120)),
 2277|      0|            "\u{1f44d}" | "\u{1f44e}" => (C::from_rgb(200, 200, 200), C::from_rgb(80, 80, 80)),
 2278|      0|            "\u{1f4a1}" => (C::from_rgb(255, 240, 120), C::from_rgb(255, 255, 255)),
 2279|      0|            "\u{2753}" | "\u{2757}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 255, 255)),
 2280|      0|            "\u{1f4dd}" => (C::from_rgb(240, 240, 200), C::from_rgb(140, 140, 140)),
 2281|      0|            "\u{1f9e0}" => (C::from_rgb(220, 160, 200), C::from_rgb(255, 255, 255)),
 2282|      0|            "\u{1f9ea}" => (C::from_rgb(180, 220, 255), C::from_rgb(120, 160, 240)),
 2283|      0|            "\u{1f4e6}" => (C::from_rgb(205, 170, 125), C::from_rgb(150, 110, 70)),
 2284|      0|            "\u{1f527}" => (C::from_rgb(160, 170, 180), C::from_rgb(220, 220, 220)),
 2285|      0|            _ => (C::from_rgb(180, 180, 180), C::WHITE),
 2286|       |        };
 2287|       |
 2288|       |        // draw filled circle
 2289|      0|        for y in 0..size as i32 {
 2290|      0|            for x in 0..size as i32 {
 2291|      0|                let dx = x - cx;
 2292|      0|                let dy = y - cy;
 2293|      0|                if dx * dx + dy * dy <= r * r {
 2294|      0|                    img[(x as usize, y as usize)] = base;
 2295|      0|                }
 2296|       |            }
 2297|       |        }
 2298|       |
 2299|       |        // add a simple accent (diagonal highlight)
 2300|      0|        for t in 0..size {
 2301|      0|            let x = t as i32;
 2302|      0|            let y = (t as i32) / 2;
 2303|      0|            let xx = (x / 2 + 6).clamp(0, size as i32 - 1) as usize;
 2304|      0|            let yy = (y + 6).clamp(0, size as i32 - 1) as usize;
 2305|      0|            img[(xx, yy)] = accent;
 2306|      0|        }
 2307|       |
 2308|      0|        img
 2309|      0|    }
 2310|       |
 2311|       |    /// Render a list with proper inline formatting, including simple nested lines
 2312|       |    /// Render a list with proper inline formatting, including simple nested lines
 2313|      1|    fn render_list(&self, ui: &mut egui::Ui, ordered: bool, items: &[Vec<InlineSpan>]) {
 2314|      1|        if items.is_empty() {
 2315|      0|            return;
 2316|      1|        }
 2317|       |
 2318|      1|        ui.add_space(4.0);
 2319|       |
 2320|      2|        for (index, spans) in items.iter().enumerate() {
                                            ^1    ^1     ^1
 2321|       |            // Split into lines on embedded '\n'
 2322|      2|            let mut lines: Vec<Vec<InlineSpan>> = vec![Vec::new()];
 2323|      2|            for s in spans.clone() {
 2324|      2|                match s {
 2325|      2|                    InlineSpan::Text(t) if t.contains('\n') => {
                                                   ^0                   ^0
 2326|      0|                        let parts: Vec<&str> = t.split('\n').collect();
 2327|      0|                        for (pi, part) in parts.iter().enumerate() {
 2328|      0|                            if !part.is_empty() {
 2329|      0|                                lines
 2330|      0|                                    .last_mut()
 2331|      0|                                    .unwrap()
 2332|      0|                                    .push(InlineSpan::Text(part.to_string()));
 2333|      0|                            }
 2334|      0|                            if pi < parts.len() - 1 {
 2335|      0|                                lines.push(Vec::new());
 2336|      0|                            }
 2337|       |                        }
 2338|       |                    }
 2339|      2|                    other => lines.last_mut().unwrap().push(other),
 2340|       |                }
 2341|       |            }
 2342|       |
 2343|      2|            for (li, mut line) in lines.into_iter().enumerate() {
 2344|      2|                ui.horizontal_wrapped(|ui| {
 2345|      2|                    if li == 0 {
 2346|      2|                        let marker = if ordered {
 2347|      0|                            format!("{}.", index + 1)
 2348|       |                        } else {
 2349|      2|                            "-".to_string()
 2350|       |                        };
 2351|      2|                        let marker_color = if ui.visuals().dark_mode {
 2352|      2|                            Color32::from_rgb(180, 180, 180)
 2353|       |                        } else {
 2354|      0|                            Color32::BLACK
 2355|       |                        };
 2356|      2|                        ui.label(
 2357|      2|                            RichText::new(format!("{} ", marker))
 2358|      2|                                .size(self.font_sizes.body)
 2359|      2|                                .color(marker_color),
 2360|       |                        );
 2361|       |                    } else {
 2362|       |                        // Determine additional indentation from leading spaces in this line
 2363|      0|                        let mut leading_spaces = 0usize;
 2364|      0|                        if let Some(InlineSpan::Text(t0)) = line.first() {
 2365|      0|                            leading_spaces = t0.chars().take_while(|c| *c == ' ').count();
 2366|      0|                        }
 2367|      0|                        if leading_spaces > 0 {
 2368|      0|                            if let Some(InlineSpan::Text(t0)) = line.get_mut(0) {
 2369|      0|                                let trimmed = t0.trim_start_matches(' ').to_string();
 2370|      0|                                *t0 = trimmed;
 2371|      0|                            }
 2372|      0|                        }
 2373|      0|                        let indent_px = 18.0 + (leading_spaces as f32) * 6.0;
 2374|      0|                        ui.add_space(indent_px);
 2375|       |                    }
 2376|      2|                    ui.spacing_mut().item_spacing.x = 0.0;
 2377|      4|                    for span in &line {
                                      ^2
 2378|      2|                        self.render_inline_span(ui, span, None, None);
 2379|      2|                    }
 2380|      2|                });
 2381|       |            }
 2382|       |        }
 2383|       |
 2384|      1|        ui.add_space(4.0);
 2385|      1|    }
 2386|       |
 2387|       |    /// Render a code block with syntax highlighting
 2388|      1|    fn render_code_block(&self, ui: &mut egui::Ui, language: Option<&str>, code: &str) {
 2389|      1|        ui.add_space(8.0);
 2390|       |
 2391|       |        // Special handling for Mermaid diagrams
 2392|      1|        if let Some(lang) = language {
 2393|      1|            if lang.eq_ignore_ascii_case("mermaid") && self.render_mermaid_block(ui, code) {
                                                                     ^0   ^0                   ^0  ^0
 2394|      0|                ui.add_space(8.0);
 2395|      0|                return;
 2396|      1|            }
 2397|      0|        }
 2398|       |
 2399|      1|        let frame_response = egui::Frame::none()
 2400|      1|            .fill(Color32::from_rgb(25, 25, 25))
 2401|      1|            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2402|      1|            .inner_margin(8.0)
 2403|      1|            .show(ui, |ui| {
 2404|      1|                ui.with_layout(egui::Layout::top_down(egui::Align::LEFT), |ui| {
 2405|      1|                    if let Some(lang) = language {
 2406|      1|                        ui.label(
 2407|      1|                            RichText::new(lang)
 2408|      1|                                .size(self.font_sizes.code - 1.0)
 2409|      1|                                .color(Color32::from_rgb(150, 150, 150))
 2410|      1|                                .family(egui::FontFamily::Monospace),
 2411|      1|                        );
 2412|      1|                        ui.add_space(2.0);
 2413|      1|                    }
                                  ^0
 2414|       |
 2415|       |                    // Try syntax highlighting
 2416|      1|                    if let Some(lang) = language {
 2417|      1|                        if let Some(syntax) = self
 2418|      1|                            .find_syntax_for_language(lang)
 2419|      1|                            .or_else(|| self.syntax_set.find_syntax_by_first_line(code))
                                                      ^0              ^0                        ^0
 2420|       |                        {
 2421|      1|                            let theme = &self.theme_set.themes["base16-ocean.dark"];
 2422|      1|                            let mut h = HighlightLines::new(syntax, theme);
 2423|       |
 2424|      1|                            for line in LinesWithEndings::from(code) {
 2425|      1|                                let ranges =
 2426|      1|                                    h.highlight_line(line, &self.syntax_set).unwrap_or_default();
 2427|       |
 2428|      1|                                ui.horizontal_wrapped(|ui| {
 2429|       |                                    // Remove spacing between tokens to avoid visual gaps
 2430|      1|                                    ui.spacing_mut().item_spacing.x = 0.0;
 2431|     10|                                    for (style, text) in ranges {
                                                       ^9     ^9
 2432|       |                                        // Drop newline characters completely; they're handled by the outer line loop
 2433|      9|                                        let cleaned = text.replace(['\n', '\r'], "");
 2434|       |
 2435|      9|                                        if cleaned.is_empty() {
 2436|      1|                                            continue;
 2437|      8|                                        }
 2438|       |
 2439|       |                                        // Check if this token is pure whitespace (spaces or tabs only)
 2440|      8|                                        if cleaned.chars().all(|c| c == ' ' || c == '\t') {
                                                                                             ^6
 2441|      2|                                            // Render whitespace as transparent to preserve layout without visual gaps
 2442|      2|                                            ui.label(
 2443|      2|                                                RichText::new(cleaned)
 2444|      2|                                                    .size(self.font_sizes.code)
 2445|      2|                                                    .color(Color32::TRANSPARENT)
 2446|      2|                                                    .family(egui::FontFamily::Monospace),
 2447|      2|                                            );
 2448|      2|                                        } else {
 2449|       |                                            // For non-whitespace, use normal highlighting but replace spaces with transparent ones
 2450|      6|                                            let color = Color32::from_rgb(
 2451|      6|                                                style.foreground.r,
 2452|      6|                                                style.foreground.g,
 2453|      6|                                                style.foreground.b,
 2454|       |                                            );
 2455|       |
 2456|       |                                            // Split by spaces and handle separately
 2457|      6|                                            let parts: Vec<&str> = cleaned.split(' ').collect();
 2458|      6|                                            for (i, part) in parts.iter().enumerate() {
 2459|      6|                                                if !part.is_empty() {
 2460|      6|                                                    let mut rich_text = RichText::new(*part)
 2461|      6|                                                        .size(self.font_sizes.code)
 2462|      6|                                                        .color(color)
 2463|      6|                                                        .family(egui::FontFamily::Monospace);
 2464|       |
 2465|      6|                                                    if style.font_style.contains(
 2466|       |                                                        syntect::highlighting::FontStyle::BOLD,
 2467|      0|                                                    ) {
 2468|      0|                                                        rich_text = rich_text.strong();
 2469|      6|                                                    }
 2470|      6|                                                    if style.font_style.contains(
 2471|       |                                                        syntect::highlighting::FontStyle::ITALIC,
 2472|      0|                                                    ) {
 2473|      0|                                                        rich_text = rich_text.italics();
 2474|      6|                                                    }
 2475|       |
 2476|      6|                                                    ui.label(rich_text);
 2477|      0|                                                }
 2478|       |
 2479|       |                                                // Add transparent space between parts (except after last part)
 2480|      6|                                                if i < parts.len() - 1 {
 2481|      0|                                                    ui.label(
 2482|      0|                                                        RichText::new(" ")
 2483|      0|                                                            .size(self.font_sizes.code)
 2484|      0|                                                            .color(Color32::TRANSPARENT)
 2485|      0|                                                            .family(egui::FontFamily::Monospace),
 2486|      0|                                                    );
 2487|      6|                                                }
 2488|       |                                            }
 2489|       |                                        }
 2490|       |                                    }
 2491|      1|                                });
 2492|       |                            }
 2493|      1|                            return; // Early return if highlighting succeeded
 2494|      0|                        }
 2495|      0|                    }
 2496|       |
 2497|       |                    // Fallback: render as plain text
 2498|      0|                    ui.label(
 2499|      0|                        RichText::new(code)
 2500|      0|                            .size(self.font_sizes.code)
 2501|      0|                            .color(Color32::from_rgb(220, 220, 220))
 2502|      0|                            .family(egui::FontFamily::Monospace),
 2503|       |                    );
 2504|      1|                });
 2505|      1|            });
 2506|       |
 2507|       |        // Add context menu for code blocks
 2508|      1|        frame_response.response.context_menu(|ui| {
                                                                ^0
 2509|      0|            self.render_code_block_context_menu(ui, code, language.as_deref());
 2510|      0|        });
 2511|       |
 2512|      1|        ui.add_space(8.0);
 2513|      1|    }
 2514|       |
 2515|       |    /// Try to render a Mermaid diagram. Returns true if handled (rendered or placeholder drawn).
 2516|      0|    fn render_mermaid_block(&self, ui: &mut egui::Ui, code: &str) -> bool {
 2517|       |        // First, drain any completed Kroki jobs into local caches.
 2518|      0|        self.poll_kroki_results();
 2519|       |
 2520|       |        // If QuickJS feature is enabled, attempt rendering to SVG then rasterize like normal SVG.
 2521|       |        #[cfg(feature = "mermaid-quickjs")]
 2522|       |        {
 2523|       |            let key = Self::hash_str(code);
 2524|       |            if self.mermaid_failed.borrow().contains(&key) {
 2525|       |                // Previously failed; show brief diagnostics and bail
 2526|       |                let bytes = mermaid_embed::MERMAID_JS.len();
 2527|       |                let last = self.mermaid_last_error.borrow().clone().unwrap_or_default();
 2528|       |                egui::Frame::none().inner_margin(4.0).show(ui, |ui| {
 2529|       |                    ui.label(
 2530|       |                        RichText::new(format!(
 2531|       |                            "Mermaid skipped (prev fail). Bytes:{} Hash:{:016x}\n{}",
 2532|       |                            bytes, key, last
 2533|       |                        ))
 2534|       |                        .family(egui::FontFamily::Monospace)
 2535|       |                        .size(self.font_sizes.code),
 2536|       |                    );
 2537|       |                });
 2538|       |                return true;
 2539|       |            } else if let Some(tex) = self.get_or_load_mermaid_texture(ui, code) {
 2540|       |                let size = tex.size();
 2541|       |                let (tw, th) = (size[0] as f32, size[1] as f32);
 2542|       |                let available_w = ui.available_width().max(1.0);
 2543|       |                let base_scale = self.ui_scale();
 2544|       |                let scaled_w = tw * base_scale;
 2545|       |                let scale = if scaled_w > available_w {
 2546|       |                    (available_w / tw).clamp(0.01, 4.0)
 2547|       |                } else {
 2548|       |                    base_scale
 2549|       |                };
 2550|       |                let size = egui::vec2((tw * scale).round(), (th * scale).round());
 2551|       |                ui.add(egui::Image::new(&tex).fit_to_exact_size(size));
 2552|       |                return true;
 2553|       |            } else {
 2554|       |                // Mark as failed to avoid repeated attempts causing jank
 2555|       |                self.mermaid_failed.borrow_mut().insert(key);
 2556|       |                let bytes = mermaid_embed::MERMAID_JS.len();
 2557|       |                let last = self
 2558|       |                    .mermaid_last_error
 2559|       |                    .borrow()
 2560|       |                    .clone()
 2561|       |                    .unwrap_or_else(|| "unknown error".to_string());
 2562|       |                egui::Frame::none()
 2563|       |                    .fill(Color32::from_rgb(25, 25, 25))
 2564|       |                    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2565|       |                    .inner_margin(8.0)
 2566|       |                    .show(ui, |ui| {
 2567|       |                        ui.label(
 2568|       |                            RichText::new("Mermaid render failed; showing source.")
 2569|       |                                .color(Color32::from_rgb(200, 160, 80)),
 2570|       |                        );
 2571|       |                        ui.label(
 2572|       |                            RichText::new(format!(
 2573|       |                                "Embedded bytes:{}\nHash:{:016x}\nError:{}",
 2574|       |                                bytes, key, last
 2575|       |                            ))
 2576|       |                            .family(egui::FontFamily::Monospace)
 2577|       |                            .size(self.font_sizes.code)
 2578|       |                            .color(Color32::from_rgb(180, 180, 180)),
 2579|       |                        );
 2580|       |                    });
 2581|       |                // fall through to code block rendering
 2582|       |            }
 2583|       |        }
 2584|       |
 2585|       |        // Default path: render via Kroki service (non-blocking)
 2586|      0|        let key = Self::hash_str(code);
 2587|       |
 2588|      0|        if !Self::kroki_enabled() {
 2589|      0|            egui::Frame::none()
 2590|      0|                .fill(Color32::from_rgb(25, 25, 25))
 2591|      0|                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2592|      0|                .inner_margin(8.0)
 2593|      0|                .show(ui, |ui| {
 2594|      0|                    ui.label(
 2595|      0|                        RichText::new("Mermaid rendering via Kroki is disabled. Set MDMDVIEW_ENABLE_KROKI=1 to enable network rendering.")
 2596|      0|                            .color(Color32::from_rgb(200, 160, 80))
 2597|      0|                            .family(egui::FontFamily::Monospace)
 2598|      0|                            .size(self.font_sizes.code),
 2599|       |                    );
 2600|      0|                });
 2601|      0|            return false;
 2602|      0|        }
 2603|       |        // If we already have an SVG for this diagram, rasterize to a texture and draw it
 2604|      0|        if let Some(img_bytes) = self.kroki_svg_cache.borrow().get(&key) {
 2605|       |            // Use a width-bucketed texture cache key to avoid re-rasterizing too often
 2606|      0|            let width_bucket = (ui.available_width().ceil() as u32) / 32 * 32;
 2607|      0|            let cache_key = format!("mermaid:{}:w{}", key, width_bucket);
 2608|      0|            if let Some(entry) = self.image_textures.borrow().get(&cache_key) {
 2609|      0|                let tex = entry.texture.clone();
 2610|      0|                let (tw, th) = (entry.size[0] as f32, entry.size[1] as f32);
 2611|      0|                let available_w = ui.available_width().max(1.0);
 2612|      0|                let base_scale = self.ui_scale();
 2613|      0|                let scaled_w = tw * base_scale;
 2614|      0|                let scale = if scaled_w > available_w {
 2615|      0|                    (available_w / tw).clamp(0.01, 4.0)
 2616|       |                } else {
 2617|      0|                    base_scale
 2618|       |                };
 2619|      0|                let size = egui::vec2((tw * scale).round(), (th * scale).round());
 2620|      0|                ui.add(egui::Image::new(&tex).fit_to_exact_size(size));
 2621|      0|                return true;
 2622|      0|            }
 2623|       |
 2624|       |            // Decode image bytes (prefer PNG). Fallback to SVG if not raster.
 2625|      0|            if let Some((img, w, h)) =
 2626|      0|                Self::bytes_to_color_image_guess(img_bytes, Self::mermaid_bg_fill())
 2627|       |            {
 2628|      0|                let tex =
 2629|      0|                    ui.ctx()
 2630|      0|                        .load_texture(cache_key.clone(), img, egui::TextureOptions::LINEAR);
 2631|      0|                self.store_image_texture(&cache_key, tex.clone(), [w, h], None);
 2632|       |                // Draw now
 2633|      0|                let (tw, th) = (w as f32, h as f32);
 2634|      0|                let available_w = ui.available_width().max(1.0);
 2635|      0|                let base_scale = self.ui_scale();
 2636|      0|                let scaled_w = tw * base_scale;
 2637|      0|                let scale = if scaled_w > available_w {
 2638|      0|                    (available_w / tw).clamp(0.01, 4.0)
 2639|       |                } else {
 2640|      0|                    base_scale
 2641|       |                };
 2642|      0|                let size = egui::vec2((tw * scale).round(), (th * scale).round());
 2643|      0|                ui.add(egui::Image::new(&tex).fit_to_exact_size(size));
 2644|      0|                return true;
 2645|      0|            } else {
 2646|      0|                // Decode failed; record error and fall through to message/source
 2647|      0|                self.kroki_errors
 2648|      0|                    .borrow_mut()
 2649|      0|                    .insert(key, "Failed to decode diagram bytes".to_string());
 2650|      0|            }
 2651|      0|        }
 2652|       |
 2653|       |        // If there was a prior error, show diagnostics and let caller show source
 2654|      0|        if let Some(err) = self.kroki_errors.borrow().get(&key) {
 2655|      0|            egui::Frame::none()
 2656|      0|                .fill(Color32::from_rgb(25, 25, 25))
 2657|      0|                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2658|      0|                .inner_margin(8.0)
 2659|      0|                .show(ui, |ui| {
 2660|      0|                    ui.label(
 2661|      0|                        RichText::new(format!(
 2662|      0|                            "Mermaid render failed via Kroki; showing source.\n{}",
 2663|       |                            err
 2664|       |                        ))
 2665|      0|                        .color(Color32::from_rgb(200, 160, 80)),
 2666|       |                    );
 2667|      0|                });
 2668|      0|            return false; // let caller render the source block
 2669|      0|        }
 2670|       |
 2671|       |        // If no job is pending, enqueue one for the worker pool
 2672|      0|        let should_schedule = {
 2673|      0|            let pending = self.kroki_pending.borrow();
 2674|      0|            !pending.contains(&key)
 2675|       |        };
 2676|      0|        let waiting_for_slot = if should_schedule {
 2677|      0|            let inflight_before = {
 2678|      0|                let pending = self.kroki_pending.borrow();
 2679|      0|                pending.len()
 2680|       |            };
 2681|      0|            match self.spawn_kroki_job(key, code) {
 2682|       |                Ok(()) => {
 2683|      0|                    self.kroki_pending.borrow_mut().insert(key);
 2684|      0|                    ui.ctx().request_repaint();
 2685|      0|                    inflight_before >= Self::MAX_KROKI_JOBS
 2686|       |                }
 2687|       |                Err(KrokiEnqueueError::QueueFull) => {
 2688|      0|                    ui.ctx().request_repaint();
 2689|      0|                    true
 2690|       |                }
 2691|       |                Err(KrokiEnqueueError::Disconnected) => {
 2692|      0|                    self.kroki_errors
 2693|      0|                        .borrow_mut()
 2694|      0|                        .insert(key, "Mermaid worker pool unavailable".to_string());
 2695|      0|                    return false;
 2696|       |                }
 2697|       |            }
 2698|       |        } else {
 2699|      0|            let pending = self.kroki_pending.borrow();
 2700|      0|            pending.len() >= Self::MAX_KROKI_JOBS
 2701|       |        };
 2702|       |
 2703|      0|        let inflight_count = self.kroki_pending.borrow().len();
 2704|       |
 2705|       |        // Show placeholder while rendering or waiting for an available worker
 2706|      0|        egui::Frame::none()
 2707|      0|            .fill(Color32::from_rgb(25, 25, 25))
 2708|      0|            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2709|      0|            .inner_margin(8.0)
 2710|      0|            .show(ui, |ui| {
 2711|      0|                let url = self.kroki_base_url();
 2712|      0|                if waiting_for_slot {
 2713|      0|                    ui.label(
 2714|      0|                        RichText::new(format!(
 2715|      0|                            "Mermaid workers busy ({}/{}) - request queued.",
 2716|      0|                            inflight_count,
 2717|      0|                            Self::MAX_KROKI_JOBS
 2718|      0|                        ))
 2719|      0|                        .color(Color32::from_rgb(200, 160, 80))
 2720|      0|                        .family(egui::FontFamily::Monospace)
 2721|      0|                        .size(self.font_sizes.code),
 2722|      0|                    );
 2723|      0|                    ui.label(
 2724|      0|                        RichText::new(format!("Queue target: {}", url))
 2725|      0|                            .color(Color32::from_rgb(160, 200, 240)),
 2726|      0|                    );
 2727|      0|                } else {
 2728|      0|                    ui.label(
 2729|      0|                        RichText::new(format!("Rendering diagram via Kroki...\n{}", url))
 2730|      0|                            .color(Color32::from_rgb(160, 200, 240)),
 2731|      0|                    );
 2732|      0|                }
 2733|      0|            });
 2734|      0|        true
 2735|      0|    }
 2736|       |
 2737|       |    #[cfg(feature = "mermaid-quickjs")]
 2738|       |    fn render_mermaid_to_svg_string(&self, code: &str) -> Option<String> {
 2739|       |        use rquickjs::{Context, Function, Runtime};
 2740|       |        // Quick check
 2741|       |        if mermaid_embed::MERMAID_JS.is_empty() {
 2742|       |            self.mermaid_last_error
 2743|       |                .borrow_mut()
 2744|       |                .replace("No embedded Mermaid JS".to_string());
 2745|       |            return None;
 2746|       |        }
 2747|       |        // Initialize engine once
 2748|       |        if self.mermaid_engine.borrow().is_none() {
 2749|       |            let rt = Runtime::new().ok()?;
 2750|       |            let ctx = Context::full(&rt).ok()?;
 2751|       |            let engine = MermaidEngine { rt, ctx };
 2752|       |            // Load library and shim
 2753|       |            let _ = engine.ctx.with(|ctx| {
 2754|       |                let shim = r#"
 2755|       |                    var window = globalThis;
 2756|       |                    var document = {
 2757|       |                      body: {},
 2758|       |                      createElement: function(tag){
 2759|       |                        return {
 2760|       |                          innerHTML: '',
 2761|       |                          setAttribute: function(){},
 2762|       |                          getAttribute: function(){ return null; },
 2763|       |                          appendChild: function(){},
 2764|       |                          querySelector: function(){ return null; },
 2765|       |                        };
 2766|       |                      },
 2767|       |                      createElementNS: function(ns, tag){ return this.createElement(tag); },
 2768|       |                      getElementById: function(){ return null; },
 2769|       |                      querySelector: function(){ return null; },
 2770|       |                    };
 2771|       |                    window.document = document;
 2772|       |                    // Minimal timers and raf
 2773|       |                    window.setTimeout = function(fn, ms){ fn(); return 1; };
 2774|       |                    window.clearTimeout = function(id){};
 2775|       |                    window.requestAnimationFrame = function(fn){ fn(0); return 1; };
 2776|       |                    window.performance = { now: function(){ return 0; } };
 2777|       |                "#;
 2778|       |                if let Err(e) = ctx.eval::<(), _>(shim) {
 2779|       |                    self.mermaid_last_error
 2780|       |                        .borrow_mut()
 2781|       |                        .replace(format!("Shim error: {}", e));
 2782|       |                }
 2783|       |                if let Ok(js) = std::str::from_utf8(mermaid_embed::MERMAID_JS) {
 2784|       |                    if let Err(e) = ctx.eval::<(), _>(js) {
 2785|       |                        self.mermaid_last_error
 2786|       |                            .borrow_mut()
 2787|       |                            .replace(format!("Mermaid eval error: {}", e));
 2788|       |                    }
 2789|       |                    if let Err(e) = ctx.eval::<(), _>(
 2790|       |                        r#"if (window.mermaid && mermaid.mermaidAPI) {
 2791|       |                               mermaid.mermaidAPI.initialize({startOnLoad: false, securityLevel: 'loose'});
 2792|       |                           } else { throw new Error('Mermaid not available'); }
 2793|       |                        "#,
 2794|       |                    ) {
 2795|       |                        self.mermaid_last_error
 2796|       |                            .borrow_mut()
 2797|       |                            .replace(format!("Mermaid init error: {}", e));
 2798|       |                    }
 2799|       |                }
 2800|       |                Ok::<(), ()>(())
 2801|       |            });
 2802|       |            self.mermaid_engine.borrow_mut().replace(engine);
 2803|       |            // One-time log for diagnostics
 2804|       |            if !*self.mermaid_init_logged.borrow() {
 2805|       |                eprintln!(
 2806|       |                    "Mermaid embedded bytes: {}",
 2807|       |                    mermaid_embed::MERMAID_JS.len()
 2808|       |                );
 2809|       |                *self.mermaid_init_logged.borrow_mut() = true;
 2810|       |            }
 2811|       |        }
 2812|       |
 2813|       |        // Use cache if available
 2814|       |        let key = Self::hash_str(code);
 2815|       |        if let Some(svg) = self.mermaid_svg_cache.borrow().get(&key) {
 2816|       |            return Some(svg.clone());
 2817|       |        }
 2818|       |
 2819|       |        // Render fresh
 2820|       |        let svg = self.mermaid_engine.borrow().as_ref().and_then(|engine| {
 2821|       |            engine.ctx.with(|ctx| {
 2822|       |                // Minimal DOM shim sufficient for mermaid.mermaidAPI.render
 2823|       |                let wrapper = r#"
 2824|       |                (function(id, code){
 2825|       |                    var svgOut = null;
 2826|       |                    mermaid.mermaidAPI.render(id, code, function(svg){ svgOut = svg; });
 2827|       |                    if (typeof svgOut !== 'string' || svgOut.length === 0) {
 2828|       |                        throw new Error('Mermaid render returned empty');
 2829|       |                    }
 2830|       |                    return svgOut;
 2831|       |                })
 2832|       |            "#;
 2833|       |                let func: Function = match ctx.eval(wrapper) {
 2834|       |                    Ok(f) => f,
 2835|       |                    Err(e) => {
 2836|       |                        self.mermaid_last_error
 2837|       |                            .borrow_mut()
 2838|       |                            .replace(format!("Wrapper eval error: {}", e));
 2839|       |                        return None;
 2840|       |                    }
 2841|       |                };
 2842|       |                let id = format!("m{:016x}", key);
 2843|       |                let svg: String = match func.call((id.as_str(), code)) {
 2844|       |                    Ok(s) => s,
 2845|       |                    Err(e) => {
 2846|       |                        self.mermaid_last_error
 2847|       |                            .borrow_mut()
 2848|       |                            .replace(format!("Mermaid call error: {}", e));
 2849|       |                        return None;
 2850|       |                    }
 2851|       |                };
 2852|       |                Some(svg)
 2853|       |            })
 2854|       |        });
 2855|       |        if let Some(svg) = svg {
 2856|       |            self.mermaid_svg_cache.borrow_mut().insert(key, svg.clone());
 2857|       |            self.mermaid_last_error.borrow_mut().take();
 2858|       |            return Some(svg);
 2859|       |        }
 2860|       |        self.mermaid_last_error
 2861|       |            .borrow_mut()
 2862|       |            .replace("Mermaid render produced no SVG".to_string());
 2863|       |        None
 2864|       |    }
 2865|       |
 2866|       |    #[cfg(feature = "mermaid-quickjs")]
 2867|       |    fn get_or_load_mermaid_texture(
 2868|       |        &self,
 2869|       |        ui: &egui::Ui,
 2870|       |        code: &str,
 2871|       |    ) -> Option<egui::TextureHandle> {
 2872|       |        let key = Self::hash_str(code);
 2873|       |        let width_bucket = (ui.available_width().ceil() as u32).saturating_sub(0) / 16 * 16;
 2874|       |        let cache_key = format!("mermaid:{}:w{}", key, width_bucket);
 2875|       |        if let Some(entry) = self.image_textures.borrow().get(&cache_key) {
 2876|       |            return Some(entry.texture.clone());
 2877|       |        }
 2878|       |        let svg = self.render_mermaid_to_svg_string(code)?;
 2879|       |        let (img, w, h) = Self::svg_bytes_to_color_image(svg.as_bytes())?;
 2880|       |        let tex = ui
 2881|       |            .ctx()
 2882|       |            .load_texture(cache_key.clone(), img, egui::TextureOptions::LINEAR);
 2883|       |        self.store_image_texture(&cache_key, tex.clone(), [w, h], None);
 2884|       |        Some(tex)
 2885|       |    }
 2886|       |
 2887|      8|    fn hash_str(s: &str) -> u64 {
 2888|      8|        let mut h = DefaultHasher::new();
 2889|      8|        s.hash(&mut h);
 2890|      8|        h.finish()
 2891|      8|    }
 2892|       |
 2893|     26|    fn hash_inline_spans(spans: &[InlineSpan]) -> u64 {
 2894|     26|        let mut h = DefaultHasher::new();
 2895|     52|        for span in spans {
                          ^26
 2896|     26|            match span {
 2897|     26|                InlineSpan::Text(t) => {
 2898|     26|                    0u8.hash(&mut h);
 2899|     26|                    t.hash(&mut h);
 2900|     26|                }
 2901|      0|                InlineSpan::Code(t) => {
 2902|      0|                    1u8.hash(&mut h);
 2903|      0|                    t.hash(&mut h);
 2904|      0|                }
 2905|      0|                InlineSpan::Strong(t) => {
 2906|      0|                    2u8.hash(&mut h);
 2907|      0|                    t.hash(&mut h);
 2908|      0|                }
 2909|      0|                InlineSpan::Emphasis(t) => {
 2910|      0|                    3u8.hash(&mut h);
 2911|      0|                    t.hash(&mut h);
 2912|      0|                }
 2913|      0|                InlineSpan::Strikethrough(t) => {
 2914|      0|                    4u8.hash(&mut h);
 2915|      0|                    t.hash(&mut h);
 2916|      0|                }
 2917|      0|                InlineSpan::Link { text, url } => {
 2918|      0|                    5u8.hash(&mut h);
 2919|      0|                    text.hash(&mut h);
 2920|      0|                    url.hash(&mut h);
 2921|      0|                }
 2922|      0|                InlineSpan::Image { src, alt, title } => {
 2923|      0|                    6u8.hash(&mut h);
 2924|      0|                    src.hash(&mut h);
 2925|      0|                    alt.hash(&mut h);
 2926|      0|                    title.hash(&mut h);
 2927|      0|                }
 2928|       |            }
 2929|       |        }
 2930|     26|        h.finish()
 2931|     26|    }
 2932|       |
 2933|      3|    fn compute_table_id(
 2934|      3|        &self,
 2935|      3|        headers: &[Vec<InlineSpan>],
 2936|      3|        rows: &[Vec<Vec<InlineSpan>>],
 2937|      3|        element_index: usize,
 2938|      3|    ) -> u64 {
 2939|      3|        let mut hasher = DefaultHasher::new();
 2940|      3|        if let Some(base) = self.base_dir.borrow().as_ref() {
                                  ^0
 2941|      0|            base.hash(&mut hasher);
 2942|      3|        }
 2943|      3|        hasher.write_usize(element_index);
 2944|      3|        hasher.write_u64(self.compute_table_content_hash(headers, rows));
 2945|      3|        hasher.finish()
 2946|      3|    }
 2947|       |
 2948|      4|    fn compute_table_content_hash(
 2949|      4|        &self,
 2950|      4|        headers: &[Vec<InlineSpan>],
 2951|      4|        rows: &[Vec<Vec<InlineSpan>>],
 2952|      4|    ) -> u64 {
 2953|      4|        let mut hasher = DefaultHasher::new();
 2954|      4|        hasher.write_usize(headers.len());
 2955|     10|        for header in headers {
                          ^6
 2956|      6|            hasher.write_u64(Self::hash_inline_spans(header));
 2957|      6|        }
 2958|      4|        let mut counted = 0usize;
 2959|     10|        for row in rows {
                          ^6
 2960|     16|            for cell in row {
                              ^10
 2961|     10|                hasher.write_u64(Self::hash_inline_spans(cell));
 2962|     10|            }
 2963|      6|            counted += 1;
 2964|      6|            if counted >= COLUMN_STATS_SAMPLE_ROWS {
 2965|      0|                break;
 2966|      6|            }
 2967|       |        }
 2968|      4|        hasher.finish()
 2969|      4|    }
 2970|       |
 2971|      1|    fn column_stats_for_table(
 2972|      1|        &self,
 2973|      1|        table_id: u64,
 2974|      1|        headers: &[Vec<InlineSpan>],
 2975|      1|        rows: &[Vec<Vec<InlineSpan>>],
 2976|      1|    ) -> Vec<ColumnStat> {
 2977|      1|        let content_hash = self.compute_table_content_hash(headers, rows);
 2978|      1|        if let Some(entry) = self
                                  ^0
 2979|      1|            .column_stats_cache
 2980|      1|            .borrow()
 2981|      1|            .get(&table_id)
 2982|      1|            .filter(|entry| entry.content_hash == content_hash)
                                          ^0                    ^0
 2983|       |        {
 2984|      0|            return entry.stats.clone();
 2985|      1|        }
 2986|      1|        let stats = compute_column_stats(headers, rows, COLUMN_STATS_SAMPLE_ROWS);
 2987|      1|        self.column_stats_cache.borrow_mut().insert(
 2988|      1|            table_id,
 2989|      1|            ColumnStatsCacheEntry {
 2990|      1|                content_hash,
 2991|      1|                stats: stats.clone(),
 2992|      1|            },
 2993|      1|        );
 2994|      1|        stats
 2995|      1|    }
 2996|       |
 2997|       |    // Drain any completed Kroki jobs and cache their results
 2998|      0|    fn poll_kroki_results(&self) {
 2999|       |        loop {
 3000|      0|            match self.kroki_rx.try_recv() {
 3001|      0|                Ok((key, Ok(svg))) => {
 3002|      0|                    self.kroki_svg_cache.borrow_mut().insert(key, svg);
 3003|      0|                    self.kroki_pending.borrow_mut().remove(&key);
 3004|      0|                }
 3005|      0|                Ok((key, Err(err))) => {
 3006|      0|                    self.kroki_errors.borrow_mut().insert(key, err);
 3007|      0|                    self.kroki_pending.borrow_mut().remove(&key);
 3008|      0|                }
 3009|      0|                Err(std::sync::mpsc::TryRecvError::Empty) => break,
 3010|      0|                Err(std::sync::mpsc::TryRecvError::Disconnected) => break,
 3011|       |            }
 3012|       |        }
 3013|      0|    }
 3014|       |
 3015|      3|    fn kroki_enabled() -> bool {
 3016|      3|        match std::env::var("MDMDVIEW_ENABLE_KROKI") {
 3017|      2|            Ok(value) => {
 3018|      2|                let normalized = value.trim().to_ascii_lowercase();
 3019|      2|                matches!(normalized.as_str(), "1" | "true" | "yes" | "on")
                              ^1                                           ^1      ^1
 3020|       |            }
 3021|      1|            Err(_) => false,
 3022|       |        }
 3023|      3|    }
 3024|       |
 3025|       |    #[cfg(test)]
 3026|      3|    pub(crate) fn kroki_enabled_for_tests() -> bool {
 3027|      3|        Self::kroki_enabled()
 3028|      3|    }
 3029|       |
 3030|      2|    fn kroki_base_url(&self) -> String {
 3031|      2|        std::env::var("MDMDVIEW_KROKI_URL").unwrap_or_else(|_| "https://kroki.io".to_string())
 3032|      2|    }
 3033|       |
 3034|      0|    fn perform_kroki_with_agent(
 3035|      0|        agent: &ureq::Agent,
 3036|      0|        url: &str,
 3037|      0|        payload: &str,
 3038|      0|    ) -> Result<Vec<u8>, String> {
 3039|      0|        let resp = agent
 3040|      0|            .post(url)
 3041|      0|            .set("Content-Type", "text/plain")
 3042|      0|            .send_string(payload)
 3043|      0|            .map_err(|e| format!("ureq error: {}", e))?;
 3044|      0|        if resp.status() >= 200 && resp.status() < 300 {
 3045|      0|            let mut bytes: Vec<u8> = Vec::new();
 3046|      0|            let mut reader = resp.into_reader();
 3047|       |            use std::io::Read as _;
 3048|      0|            reader
 3049|      0|                .read_to_end(&mut bytes)
 3050|      0|                .map_err(|e| format!("read body: {}", e))?;
 3051|      0|            if bytes.is_empty() {
 3052|      0|                return Err("Empty SVG from Kroki".to_string());
 3053|      0|            }
 3054|      0|            Ok(bytes)
 3055|       |        } else {
 3056|      0|            Err(format!("HTTP {} from Kroki", resp.status()))
 3057|       |        }
 3058|      0|    }
 3059|       |
 3060|      2|    fn spawn_kroki_job(&self, key: u64, code: &str) -> Result<(), KrokiEnqueueError> {
 3061|       |        // Prefer PNG to avoid client-side SVG CSS/foreignObject limitations
 3062|      2|        let url = format!("{}/mermaid/png", self.kroki_base_url());
 3063|      2|        let payload = self.wrap_mermaid_theme(code);
 3064|      2|        match self
 3065|      2|            .kroki_job_tx
 3066|      2|            .try_send(KrokiRequest { key, url, payload })
 3067|       |        {
 3068|      0|            Ok(()) => Ok(()),
 3069|      1|            Err(TrySendError::Full(_)) => Err(KrokiEnqueueError::QueueFull),
 3070|      1|            Err(TrySendError::Disconnected(_)) => Err(KrokiEnqueueError::Disconnected),
 3071|       |        }
 3072|      2|    }
 3073|       |
 3074|      2|    fn wrap_mermaid_theme(&self, code: &str) -> String {
 3075|       |        // If user already provided an init block, respect it
 3076|      2|        if code.contains("%%{") && code.contains("}%%") && code.contains("init") {
                                                 ^0   ^0                 ^0   ^0
 3077|      0|            return code.to_string();
 3078|      2|        }
 3079|       |        // Pastel palette defaults (nice contrast on dark/light UIs)
 3080|      2|        let def_main_bkg = "#FFF8DB"; // soft warm yellow
 3081|      2|        let def_primary = "#D7EEFF"; // pastel blue (nodes)
 3082|      2|        let def_primary_border = "#9BB2C8"; // muted blue border
 3083|      2|        let def_primary_text = "#1C2430"; // dark slate text
 3084|      2|        let def_secondary = "#DFF5E1"; // pastel green
 3085|      2|        let def_tertiary = "#E9E2FF"; // pastel lavender
 3086|      2|        let def_line = "#6B7A90"; // slate lines/arrows
 3087|      2|        let def_text = "#1C2430"; // general text
 3088|      2|        let def_cluster_bkg = "#FFF1C1"; // soft yellow, slightly deeper
 3089|      2|        let def_cluster_border = "#E5C07B"; // golden
 3090|      2|        let def_default_link = def_line;
 3091|      2|        let def_title = def_text;
 3092|      2|        let def_label_bg = def_main_bkg;
 3093|      2|        let def_edge_label_bg = def_main_bkg;
 3094|       |
 3095|       |        // Allow overrides via env vars (keep defaults above if absent)
 3096|      2|        let theme_name =
 3097|      2|            std::env::var("MDMDVIEW_MERMAID_THEME").unwrap_or_else(|_| "base".to_string());
 3098|      2|        let main_bkg =
 3099|      2|            std::env::var("MDMDVIEW_MERMAID_MAIN_BKG").unwrap_or_else(|_| def_main_bkg.to_string());
 3100|      2|        let primary = std::env::var("MDMDVIEW_MERMAID_PRIMARY_COLOR")
 3101|      2|            .unwrap_or_else(|_| def_primary.to_string());
 3102|      2|        let primary_border = std::env::var("MDMDVIEW_MERMAID_PRIMARY_BORDER")
 3103|      2|            .unwrap_or_else(|_| def_primary_border.to_string());
 3104|      2|        let primary_text = std::env::var("MDMDVIEW_MERMAID_PRIMARY_TEXT")
 3105|      2|            .unwrap_or_else(|_| def_primary_text.to_string());
 3106|      2|        let secondary = std::env::var("MDMDVIEW_MERMAID_SECONDARY_COLOR")
 3107|      2|            .unwrap_or_else(|_| def_secondary.to_string());
 3108|      2|        let tertiary = std::env::var("MDMDVIEW_MERMAID_TERTIARY_COLOR")
 3109|      2|            .unwrap_or_else(|_| def_tertiary.to_string());
 3110|      2|        let line =
 3111|      2|            std::env::var("MDMDVIEW_MERMAID_LINE_COLOR").unwrap_or_else(|_| def_line.to_string());
 3112|      2|        let text =
 3113|      2|            std::env::var("MDMDVIEW_MERMAID_TEXT_COLOR").unwrap_or_else(|_| def_text.to_string());
 3114|      2|        let cluster_bkg = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BKG")
 3115|      2|            .unwrap_or_else(|_| def_cluster_bkg.to_string());
 3116|      2|        let cluster_border = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BORDER")
 3117|      2|            .unwrap_or_else(|_| def_cluster_border.to_string());
 3118|      2|        let default_link = std::env::var("MDMDVIEW_MERMAID_LINK_COLOR")
 3119|      2|            .unwrap_or_else(|_| def_default_link.to_string());
 3120|      2|        let title =
 3121|      2|            std::env::var("MDMDVIEW_MERMAID_TITLE_COLOR").unwrap_or_else(|_| def_title.to_string());
 3122|      2|        let label_bg =
 3123|      2|            std::env::var("MDMDVIEW_MERMAID_LABEL_BG").unwrap_or_else(|_| def_label_bg.to_string());
 3124|      2|        let edge_label_bg = std::env::var("MDMDVIEW_MERMAID_EDGE_LABEL_BG")
 3125|      2|            .unwrap_or_else(|_| def_edge_label_bg.to_string());
 3126|       |
 3127|      2|        let theme = format!(
 3128|      2|            concat!(
 3129|       |                "%%{{init: {{\"theme\": \"{}\", \"themeVariables\": {{",
 3130|       |                "\"background\": \"{}\", ",
 3131|       |                "\"mainBkg\": \"{}\", ",
 3132|       |                "\"textColor\": \"{}\", ",
 3133|       |                "\"titleColor\": \"{}\", ",
 3134|       |                "\"primaryColor\": \"{}\", ",
 3135|       |                "\"primaryBorderColor\": \"{}\", ",
 3136|       |                "\"primaryTextColor\": \"{}\", ",
 3137|       |                "\"secondaryColor\": \"{}\", ",
 3138|       |                "\"tertiaryColor\": \"{}\", ",
 3139|       |                "\"lineColor\": \"{}\", ",
 3140|       |                "\"defaultLinkColor\": \"{}\", ",
 3141|       |                "\"clusterBkg\": \"{}\", ",
 3142|       |                "\"clusterBorder\": \"{}\", ",
 3143|       |                "\"labelBackground\": \"{}\", ",
 3144|       |                "\"edgeLabelBackground\": \"{}\"",
 3145|       |                "}} }}%%\n"
 3146|       |            ),
 3147|       |            theme_name,
 3148|       |            main_bkg,
 3149|       |            main_bkg,
 3150|       |            text,
 3151|       |            title,
 3152|       |            primary,
 3153|       |            primary_border,
 3154|       |            primary_text,
 3155|       |            secondary,
 3156|       |            tertiary,
 3157|       |            line,
 3158|       |            default_link,
 3159|       |            cluster_bkg,
 3160|       |            cluster_border,
 3161|       |            label_bg,
 3162|       |            edge_label_bg
 3163|       |        );
 3164|      2|        format!("{}{}", theme, code)
 3165|      2|    }
 3166|       |
 3167|       |    // Choose background fill for Mermaid rasterization, based on env
 3168|      0|    fn mermaid_bg_fill() -> Option<[u8; 4]> {
 3169|       |        // Preferred: explicit color
 3170|      0|        if let Ok(hex) = std::env::var("MDMDVIEW_MERMAID_BG_COLOR") {
 3171|      0|            if let Some(rgba) = Self::parse_hex_color(&hex) {
 3172|      0|                return Some(rgba);
 3173|      0|            }
 3174|      0|        }
 3175|       |        // Mode selector; default to the theme's main background
 3176|      0|        let mode = std::env::var("MDMDVIEW_MERMAID_BG").unwrap_or_else(|_| "theme".to_string());
 3177|      0|        match mode.as_str() {
 3178|      0|            "transparent" => None,
 3179|      0|            "dark" => Some([20, 20, 20, 255]),
 3180|      0|            "light" => Some([255, 255, 255, 255]),
 3181|       |            _ /* theme */ => {
 3182|      0|                let hex = std::env::var("MDMDVIEW_MERMAID_MAIN_BKG").unwrap_or_else(|_| "#FFF8DB".to_string());
 3183|      0|                Self::parse_hex_color(&hex).or(Some([255, 248, 219, 255]))
 3184|       |            }
 3185|       |        }
 3186|      0|    }
 3187|       |
 3188|      0|    fn parse_hex_color(s: &str) -> Option<[u8; 4]> {
 3189|      0|        let t = s.trim();
 3190|      0|        let hex = t.strip_prefix('#').unwrap_or(t);
 3191|      0|        let (r, g, b, a) = match hex.len() {
 3192|       |            6 => (
 3193|      0|                u8::from_str_radix(&hex[0..2], 16).ok()?,
 3194|      0|                u8::from_str_radix(&hex[2..4], 16).ok()?,
 3195|      0|                u8::from_str_radix(&hex[4..6], 16).ok()?,
 3196|       |                255,
 3197|       |            ),
 3198|       |            8 => (
 3199|      0|                u8::from_str_radix(&hex[0..2], 16).ok()?,
 3200|      0|                u8::from_str_radix(&hex[2..4], 16).ok()?,
 3201|      0|                u8::from_str_radix(&hex[4..6], 16).ok()?,
 3202|      0|                u8::from_str_radix(&hex[6..8], 16).ok()?,
 3203|       |            ),
 3204|      0|            _ => return None,
 3205|       |        };
 3206|      0|        Some([r, g, b, a])
 3207|      0|    }
 3208|       |
 3209|       |    /// Render a table using an egui Grid
 3210|      1|    fn render_table(
 3211|      1|        &self,
 3212|      1|        ui: &mut egui::Ui,
 3213|      1|        headers: &[Vec<InlineSpan>],
 3214|      1|        rows: &[Vec<Vec<InlineSpan>>],
 3215|      1|        element_index: usize,
 3216|      1|    ) {
 3217|      1|        if headers.is_empty() {
 3218|      0|            return;
 3219|      1|        }
 3220|       |
 3221|      1|        if self.table_wrap_overhaul_enabled {
 3222|      1|            self.render_table_tablebuilder(ui, headers, rows, element_index);
 3223|      1|            ui.add_space(8.0);
 3224|      1|            return;
 3225|      0|        }
 3226|       |
 3227|      0|        ui.add_space(8.0);
 3228|       |
 3229|       |        const MIN_COL_MULTIPLIER: f32 = 6.0;
 3230|       |        const HARD_MIN_COL_WIDTH: f32 = 48.0;
 3231|       |        const MAX_WRAP_MULTIPLIER: f32 = 30.0;
 3232|       |
 3233|      0|        let min_floor = (self.font_sizes.body * MIN_COL_MULTIPLIER).max(HARD_MIN_COL_WIDTH);
 3234|      0|        let wrap_cap = (self.font_sizes.body * MAX_WRAP_MULTIPLIER).min(640.0);
 3235|       |
 3236|       |        // 1) Establish baseline widths from headers so small columns don't collapse
 3237|      0|        let min_widths: Vec<f32> = headers
 3238|      0|            .iter()
 3239|      0|            .map(|h| self.measure_inline_spans(ui, h).max(min_floor))
 3240|      0|            .collect();
 3241|      0|        if min_widths.is_empty() {
 3242|      0|            return;
 3243|      0|        }
 3244|       |
 3245|       |        // 2) Allow body cells to request more width (capped so single verbose cells don't dominate)
 3246|      0|        let mut desired_widths = min_widths.clone();
 3247|      0|        for row in rows {
 3248|      0|            for (ci, cell) in row.iter().enumerate() {
 3249|      0|                if ci >= desired_widths.len() {
 3250|      0|                    break;
 3251|      0|                }
 3252|      0|                let measured = self.measure_inline_spans(ui, cell).max(min_floor);
 3253|      0|                desired_widths[ci] = desired_widths[ci].max(measured.min(wrap_cap));
 3254|       |            }
 3255|       |        }
 3256|       |
 3257|      0|        let available = ui.available_width().max(100.0);
 3258|      0|        let widths = Self::resolve_table_widths(available, &min_widths, &desired_widths);
 3259|       |
 3260|      0|        self.render_table_legacy(ui, headers, rows, &widths);
 3261|      0|        ui.add_space(8.0);
 3262|      1|    }
 3263|       |
 3264|      0|    fn render_table_legacy(
 3265|      0|        &self,
 3266|      0|        ui: &mut egui::Ui,
 3267|      0|        headers: &[Vec<InlineSpan>],
 3268|      0|        rows: &[Vec<Vec<InlineSpan>>],
 3269|      0|        widths: &[f32],
 3270|      0|    ) {
 3271|      0|        egui::Frame::none()
 3272|      0|            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 3273|      0|            .show(ui, |ui| {
 3274|      0|                egui::Grid::new("md_table").striped(true).show(ui, |ui| {
 3275|      0|                    for (ci, h) in headers.iter().enumerate() {
 3276|      0|                        let w = widths.get(ci).copied().unwrap_or(120.0);
 3277|      0|                        ui.push_id(("header", ci), |ui| {
 3278|      0|                            ui.allocate_ui_with_layout(
 3279|      0|                                Vec2::new(w, 0.0),
 3280|      0|                                egui::Layout::top_down(egui::Align::LEFT),
 3281|      0|                                |ui| {
 3282|      0|                                    ui.set_width(w);
 3283|      0|                                    ui.set_max_width(w);
 3284|      0|                                    self.render_table_cell_spans(ui, h, w, true);
 3285|      0|                                },
 3286|       |                            );
 3287|      0|                        });
 3288|       |                    }
 3289|      0|                    ui.end_row();
 3290|       |
 3291|      0|                    for (ri, row) in rows.iter().enumerate() {
 3292|      0|                        for (ci, cell) in row.iter().enumerate() {
 3293|      0|                            if ci < headers.len() {
 3294|      0|                                let w = widths.get(ci).copied().unwrap_or(120.0);
 3295|      0|                                ui.push_id(("cell", ri, ci), |ui| {
 3296|      0|                                    ui.allocate_ui_with_layout(
 3297|      0|                                        Vec2::new(w, 0.0),
 3298|      0|                                        egui::Layout::top_down(egui::Align::LEFT),
 3299|      0|                                        |ui| {
 3300|      0|                                            ui.set_width(w);
 3301|      0|                                            ui.set_max_width(w);
 3302|      0|                                            self.render_table_cell_spans(ui, cell, w, false);
 3303|      0|                                        },
 3304|       |                                    );
 3305|      0|                                });
 3306|      0|                            }
 3307|       |                        }
 3308|      0|                        ui.end_row();
 3309|       |                    }
 3310|      0|                });
 3311|      0|            });
 3312|      0|    }
 3313|       |
 3314|      6|    fn extend_table_rect(target: &mut Option<egui::Rect>, rect: egui::Rect) {
 3315|      6|        if rect.min.x.is_nan() || rect.min.y.is_nan() || rect.max.x.is_nan() || rect.max.y.is_nan()
 3316|       |        {
 3317|      0|            return;
 3318|      6|        }
 3319|      6|        if let Some(existing) = target {
                                  ^4
 3320|      4|            existing.min.x = existing.min.x.min(rect.min.x);
 3321|      4|            existing.min.y = existing.min.y.min(rect.min.y);
 3322|      4|            existing.max.x = existing.max.x.max(rect.max.x);
 3323|      4|            existing.max.y = existing.max.y.max(rect.max.y);
 3324|      4|        } else {
 3325|      2|            *target = Some(rect);
 3326|      2|        }
 3327|      6|    }
 3328|       |
 3329|      1|    fn render_table_tablebuilder(
 3330|      1|        &self,
 3331|      1|        ui: &mut egui::Ui,
 3332|      1|        headers: &[Vec<InlineSpan>],
 3333|      1|        rows: &[Vec<Vec<InlineSpan>>],
 3334|      1|        element_index: usize,
 3335|      1|    ) {
 3336|      1|        let table_id = self.compute_table_id(headers, rows, element_index);
 3337|      1|        let column_stats = self.column_stats_for_table(table_id, headers, rows);
 3338|      1|        let ctx =
 3339|      1|            TableColumnContext::new(headers, rows, &column_stats, self.font_sizes.body, table_id);
 3340|      1|        let mut column_specs = derive_column_specs(&ctx);
 3341|      2|        let row_max = rows.iter().map(|r| r.len()).max().unwrap_or(0);
                          ^1        ^1   ^1     ^1               ^1    ^1
 3342|      1|        let target_cols = column_specs.len().max(row_max).max(1);
 3343|      1|        while column_specs.len() < target_cols {
 3344|      0|            column_specs.push(ColumnSpec::new(
 3345|      0|                format!("Column {}", column_specs.len() + 1),
 3346|      0|                crate::table_support::ColumnPolicy::Remainder { clip: false },
 3347|      0|                None,
 3348|      0|            ));
 3349|      0|        }
 3350|      1|        self.begin_table_pass(table_id, rows.len());
 3351|      1|        self.apply_persisted_widths(table_id, &mut column_specs);
 3352|       |
 3353|      1|        let prev_spacing = ui.spacing().item_spacing;
 3354|      1|        if prev_spacing.x < 6.0 {
 3355|      0|            ui.spacing_mut().item_spacing.x = 6.0;
 3356|      1|        }
 3357|       |
 3358|       |        // Rough header height estimation using equally divided width; refines on next frame via cache.
 3359|      1|        let mut header_height = self.row_height_fallback();
 3360|      1|        if !column_specs.is_empty() {
 3361|      1|            let approx_width = (ui.available_width() / column_specs.len() as f32)
 3362|      1|                .max(self.font_sizes.body * 6.0)
 3363|      1|                .max(48.0);
 3364|      1|            let style = ui.style().clone();
 3365|      1|            header_height = headers
 3366|      1|                .iter()
 3367|      1|                .enumerate()
 3368|      2|                .map(|(ci, spans)| {
                               ^1
 3369|      2|                    let build = self.cached_layout_job(&style, None, ci, spans, approx_width, true);
 3370|      2|                    ui.fonts(|f| f.layout_job(build.job.clone()).size().y + 6.0)
 3371|      2|                })
 3372|      2|                .fold(header_height, |acc, h| acc.max(h));
                               ^1   ^1
 3373|      1|            header_height = header_height.min(self.row_height_fallback() * 3.0);
 3374|      0|        }
 3375|       |
 3376|      1|        let mut table = TableBuilder::new(ui).striped(true);
 3377|      3|        for spec in &column_specs {
                          ^2
 3378|      2|            table = table.column(spec.as_column());
 3379|      2|        }
 3380|       |
 3381|      1|        let fallback_row_height = self.row_height_fallback();
 3382|      1|        let row_heights: Vec<f32> = (0..rows.len())
 3383|      2|            .map(|idx| self.row_height_hint(table_id, idx))
                           ^1
 3384|      1|            .collect();
 3385|       |
 3386|       |        // Use RefCell to allow capturing widths from body closure.
 3387|       |        // BUG FIX: Previously captured ui.min_rect().width() which is the cell *content* width.
 3388|       |        // Now we capture body.widths() which gives the actual *allocated* column widths.
 3389|       |        // See: https://docs.rs/egui_extras/latest/egui_extras/struct.TableBody.html#method.widths
 3390|      1|        let column_widths: RefCell<Vec<f32>> = RefCell::new(vec![0.0f32; column_specs.len()]);
 3391|       |        // Track header and body rects separately for accurate table bounds calculation.
 3392|       |        // The header rect captures the header row bounds, body_rect captures body row bounds.
 3393|       |        // These are combined after rendering to get the full table rect.
 3394|      1|        let mut header_rect: Option<egui::Rect> = None;
 3395|      1|        let mut body_rect: Option<egui::Rect> = None;
 3396|       |        // body_layout_rect captures the allocated layout region from body.max_rect(),
 3397|       |        // which is more accurate than union of cell min_rects for table width.
 3398|      1|        let body_layout_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);
 3399|       |        // Track clip rects separately for header and body, then union them.
 3400|       |        // This ensures dividers respect scroll boundaries for both regions.
 3401|      1|        let mut header_clip_rect: Option<egui::Rect> = None;
 3402|      1|        let body_clip_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);
 3403|      1|        let mut painter: Option<Painter> = None;
 3404|      1|        let mut visuals: Option<Visuals> = None;
 3405|      1|        let mut ctx_snapshot: Option<Context> = None;
 3406|       |
 3407|      1|        let mut height_growth = false;
 3408|      1|        table
 3409|      1|            .header(header_height, |mut header| {
 3410|      2|                for (ci, _) in column_specs.iter().enumerate() {
                                             ^1                  ^1
 3411|      2|                    header.col(|ui| {
 3412|      2|                        let width = ui.available_width().max(1.0);
 3413|      2|                        let spans = headers.get(ci).map(|v| v.as_slice()).unwrap_or(&[]);
 3414|      2|                        let _ = self.render_overhauled_cell(ui, spans, width, true, None, ci);
 3415|       |                        // NOTE: Do NOT capture ui.min_rect().width() here - that's the content width,
 3416|       |                        // not the column width. Column widths are captured from body.widths() below.
 3417|       |                        // Extend header_rect (not body_rect) for accurate header bounds.
 3418|      2|                        Self::extend_table_rect(&mut header_rect, ui.min_rect());
 3419|      2|                        if header_clip_rect.is_none() {
 3420|      1|                            header_clip_rect = Some(ui.clip_rect());
 3421|      1|                            painter = Some(ui.painter().clone());
 3422|      1|                            visuals = Some(ui.visuals().clone());
 3423|      1|                            ctx_snapshot = Some(ui.ctx().clone());
 3424|      1|                        }
 3425|      2|                    });
 3426|       |                }
 3427|      1|            })
 3428|      1|            .body(|body| {
 3429|       |                // Capture the actual allocated column widths from the table layout system.
 3430|       |                // This MUST be done before heterogeneous_rows() consumes the body.
 3431|      1|                *column_widths.borrow_mut() = body.widths().to_vec();
 3432|       |
 3433|       |                // Capture body's layout rect for accurate table width calculation.
 3434|       |                // This is the allocated region, not the content bounds.
 3435|      1|                *body_layout_rect.borrow_mut() = Some(body.max_rect());
 3436|       |
 3437|      1|                let row_height_hints = row_heights.clone();
 3438|      2|                body.heterogeneous_rows(row_height_hints.into_iter(), |mut row| {
                              ^1   ^1                 ^1               ^1
 3439|      2|                    let idx = row.index();
 3440|      2|                    let row_cells = rows.get(idx);
 3441|      2|                    let mut row_height = fallback_row_height;
 3442|      4|                    for (ci, _) in column_specs.iter().enumerate() {
                                                 ^2                  ^2
 3443|      4|                        let mut cell_height = fallback_row_height;
 3444|      4|                        row.col(|ui| {
 3445|      4|                            let width = ui.available_width().max(1.0);
 3446|      4|                            let spans = row_cells
 3447|      4|                                .and_then(|cells| cells.get(ci))
 3448|      4|                                .map(|cell| cell.as_slice())
 3449|      4|                                .unwrap_or(&[]);
 3450|      4|                            cell_height =
 3451|      4|                                self.render_overhauled_cell(ui, spans, width, false, Some(idx), ci);
 3452|       |                            // Extend body_rect (not header_rect) for accurate body bounds.
 3453|      4|                            Self::extend_table_rect(&mut body_rect, ui.min_rect());
 3454|      4|                            if body_clip_rect.borrow().is_none() {
 3455|      1|                                *body_clip_rect.borrow_mut() = Some(ui.clip_rect());
 3456|       |                                // Also capture painter/visuals/ctx if not already captured from header
 3457|      1|                                if painter.is_none() {
 3458|      0|                                    painter = Some(ui.painter().clone());
 3459|      0|                                    visuals = Some(ui.visuals().clone());
 3460|      0|                                    ctx_snapshot = Some(ui.ctx().clone());
 3461|      1|                                }
 3462|      3|                            }
 3463|      4|                        });
 3464|      4|                        row_height = row_height.max(cell_height);
 3465|      4|                        if cell_height > row_heights[idx] + 0.5 {
 3466|      0|                            height_growth = true;
 3467|      4|                        }
 3468|       |                    }
 3469|      2|                    self.update_row_height(table_id, idx, row_height);
 3470|      2|                    self.note_row_rendered(table_id);
 3471|      2|                });
 3472|      1|            });
 3473|       |
 3474|      1|        ui.spacing_mut().item_spacing = prev_spacing;
 3475|       |
 3476|       |        // Extract column widths from RefCell for use in divider painting
 3477|      1|        let widths = column_widths.into_inner();
 3478|      1|        let layout_rect = body_layout_rect.into_inner();
 3479|      1|        let body_clip = body_clip_rect.into_inner();
 3480|       |
 3481|       |        // Combine header and body clip rects to ensure dividers respect scroll bounds.
 3482|      1|        let clip_rect = match (header_clip_rect, body_clip) {
 3483|      1|            (Some(h), Some(b)) => Some(h.union(b)),
 3484|      0|            (Some(h), None) => Some(h),
 3485|      0|            (None, Some(b)) => Some(b),
 3486|      0|            (None, None) => None,
 3487|       |        };
 3488|       |
 3489|       |        // Calculate accurate table width from column widths.
 3490|       |        // This is more accurate than union of cell min_rects which may be smaller
 3491|       |        // than the allocated column space.
 3492|      1|        let calculated_width: f32 = widths.iter().sum();
 3493|       |
 3494|       |        // Combine header and body rects into the full table rect.
 3495|       |        // Use calculated width for accuracy when column widths are available.
 3496|      1|        let table_rect = match (header_rect, body_rect, layout_rect) {
 3497|       |            // Best case: use header for top/left, body for bottom, calculated width for right
 3498|      1|            (Some(h), Some(b), _) if calculated_width > 0.0 => {
 3499|      1|                let left = h.left().min(b.left());
 3500|      1|                let top = h.top();
 3501|      1|                let bottom = b.bottom();
 3502|      1|                let right = left + calculated_width;
 3503|      1|                Some(egui::Rect::from_min_max(
 3504|      1|                    egui::pos2(left, top),
 3505|      1|                    egui::pos2(right, bottom),
 3506|      1|                ))
 3507|       |            }
 3508|       |            // Fallback: use union of header and body
 3509|      0|            (Some(h), Some(b), _) => Some(h.union(b)),
 3510|       |            // Header only with layout rect
 3511|      0|            (Some(h), None, Some(layout)) if calculated_width > 0.0 => {
 3512|      0|                let left = h.left().min(layout.left());
 3513|      0|                let right = left + calculated_width;
 3514|      0|                Some(egui::Rect::from_min_max(
 3515|      0|                    egui::pos2(left, h.top()),
 3516|      0|                    egui::pos2(right, h.bottom()),
 3517|      0|                ))
 3518|       |            }
 3519|      0|            (Some(h), None, _) => Some(h),
 3520|      0|            (None, Some(b), _) => Some(b),
 3521|      0|            (None, None, Some(layout)) => Some(layout),
 3522|      0|            (None, None, None) => None,
 3523|       |        };
 3524|       |
 3525|      1|        if let (Some(rect), Some(clip_rect), Some(painter), Some(visuals), Some(ctx)) =
 3526|      1|            (table_rect, clip_rect, painter, visuals, ctx_snapshot)
 3527|       |        {
 3528|      1|            if column_specs.len() == widths.len() && widths.iter().any(|w| *w > 0.0) {
 3529|      1|                let frame_id = ctx.frame_nr();
 3530|      1|                let change = self.record_resolved_widths(table_id, frame_id, &widths);
 3531|      1|                self.persist_resizable_widths(table_id, &column_specs, &widths);
 3532|      1|                self.handle_width_change(&ctx, table_id, change);
 3533|      1|                self.paint_table_dividers(
 3534|      1|                    &painter,
 3535|      1|                    &visuals,
 3536|      1|                    rect,
 3537|      1|                    clip_rect,
 3538|      1|                    &widths,
 3539|      1|                    header_height,
 3540|       |                );
 3541|      1|                if height_growth {
 3542|      0|                    ctx.request_repaint();
 3543|      1|                }
 3544|      0|            }
 3545|      0|        }
 3546|      1|    }
 3547|       |
 3548|     13|    fn row_height_fallback(&self) -> f32 {
 3549|     13|        self.font_sizes.body * 1.6
 3550|     13|    }
 3551|       |
 3552|      2|    fn row_height_hint(&self, table_id: u64, idx: usize) -> f32 {
 3553|      2|        let fallback = self.row_height_fallback();
 3554|      2|        self.table_metrics
 3555|      2|            .borrow()
 3556|      2|            .entry(table_id)
 3557|      2|            .and_then(|entry| entry.row(idx))
 3558|      2|            .map(|m| {
                                   ^0
 3559|      0|                if m.max_height > 0.0 {
 3560|      0|                    m.max_height
 3561|       |                } else {
 3562|      0|                    fallback
 3563|       |                }
 3564|      0|            })
 3565|      2|            .unwrap_or(fallback)
 3566|      2|    }
 3567|       |
 3568|      2|    fn update_row_height(&self, table_id: u64, idx: usize, height: f32) {
 3569|      2|        let clamped = height.max(self.row_height_fallback());
 3570|      2|        let mut metrics = self.table_metrics.borrow_mut();
 3571|      2|        let entry = metrics.entry_mut(table_id);
 3572|      2|        let row = entry.ensure_row(idx);
 3573|      2|        row.max_height = clamped;
 3574|      2|        row.dirty = false;
 3575|      2|    }
 3576|       |
 3577|      1|    fn begin_table_pass(&self, table_id: u64, total_rows: usize) {
 3578|      1|        let mut metrics = self.table_metrics.borrow_mut();
 3579|      1|        metrics.entry_mut(table_id).begin_pass(total_rows);
 3580|      1|    }
 3581|       |
 3582|      2|    fn note_row_rendered(&self, table_id: u64) {
 3583|      2|        let mut metrics = self.table_metrics.borrow_mut();
 3584|      2|        metrics.entry_mut(table_id).note_row_rendered();
 3585|      2|    }
 3586|       |
 3587|      1|    fn apply_persisted_widths(&self, table_id: u64, specs: &mut [ColumnSpec]) {
 3588|      1|        if specs.is_empty() {
 3589|      0|            return;
 3590|      1|        }
 3591|      1|        let mut metrics = self.table_metrics.borrow_mut();
 3592|      1|        let entry = metrics.entry_mut(table_id);
 3593|      2|        for spec in specs.iter_mut() {
                                  ^1    ^1
 3594|      2|            if let Some(width) = entry.persisted_width(spec.policy_hash) {
                                      ^0
 3595|      0|                spec.apply_preferred_width(width);
 3596|      2|            }
 3597|       |        }
 3598|      1|    }
 3599|       |
 3600|      4|    fn persist_resizable_widths(&self, table_id: u64, specs: &[ColumnSpec], widths: &[f32]) {
 3601|      4|        if specs.is_empty() || widths.is_empty() {
 3602|      0|            return;
 3603|      4|        }
 3604|      4|        let mut metrics = self.table_metrics.borrow_mut();
 3605|      4|        let entry = metrics.entry_mut(table_id);
 3606|       |
 3607|       |        // Check if font size changed since last persist - if so, clear old widths
 3608|       |        // to prevent size mismatch after zoom changes. Skip persisting in this
 3609|       |        // frame so the next layout can compute fresh widths before we store them.
 3610|      4|        if entry.check_font_size_change(self.font_sizes.body) {
 3611|      1|            return;
 3612|      3|        }
 3613|       |
 3614|      4|        for (spec, width) in specs.iter().zip(widths.iter()) {
                                           ^3    ^3     ^3  ^3     ^3
 3615|      4|            if let ColumnPolicy::Resizable { .. } = spec.policy {
 3616|      2|                let stored = entry.persisted_width(spec.policy_hash).unwrap_or(-1.0);
 3617|      2|                if stored < 0.0 || (stored - width).abs() > 0.5 {
                                                 ^0
 3618|      2|                    entry.set_persisted_width(spec.policy_hash, *width);
 3619|      2|                }
                              ^0
 3620|      2|            }
 3621|       |        }
 3622|      4|    }
 3623|       |
 3624|      1|    fn record_resolved_widths(&self, table_id: u64, frame_id: u64, widths: &[f32]) -> WidthChange {
 3625|      1|        if widths.is_empty() {
 3626|      0|            return WidthChange::None;
 3627|      1|        }
 3628|      1|        let mut metrics = self.table_metrics.borrow_mut();
 3629|      1|        metrics.entry_mut(table_id).update_widths(widths, frame_id)
 3630|      1|    }
 3631|       |
 3632|      1|    fn handle_width_change(&self, ctx: &Context, table_id: u64, change: WidthChange) {
 3633|      1|        if matches!(change, WidthChange::Large) {
 3634|      0|            let frame_id = ctx.frame_nr();
 3635|      0|            let mut metrics = self.table_metrics.borrow_mut();
 3636|      0|            let entry = metrics.entry_mut(table_id);
 3637|      0|            if entry.last_discard_frame != Some(frame_id) {
 3638|      0|                ctx.request_repaint();
 3639|      0|                entry.last_discard_frame = Some(frame_id);
 3640|      0|            }
 3641|      1|        }
 3642|      1|    }
 3643|       |
 3644|       |    /// Paint vertical dividers between table columns, a horizontal header separator,
 3645|       |    /// and an outer border.
 3646|       |    ///
 3647|       |    /// # Arguments
 3648|       |    /// * `widths` - The actual allocated column widths from `TableBody::widths()`.
 3649|       |    ///   IMPORTANT: These must NOT be cell content widths from `ui.min_rect()`,
 3650|       |    ///   which would cause dividers to be misaligned.
 3651|       |    /// * `header_height` - The height of the header row. A horizontal separator is
 3652|       |    ///   drawn at this y-offset to visually separate header from body rows.
 3653|      1|    fn paint_table_dividers(
 3654|      1|        &self,
 3655|      1|        painter: &Painter,
 3656|      1|        visuals: &Visuals,
 3657|      1|        rect: egui::Rect,
 3658|      1|        clip_rect: egui::Rect,
 3659|      1|        widths: &[f32],
 3660|      1|        header_height: f32,
 3661|      1|    ) {
 3662|      1|        if widths.len() <= 1 {
 3663|      0|            return;
 3664|      1|        }
 3665|      1|        let separator_color = visuals
 3666|      1|            .widgets
 3667|      1|            .noninteractive
 3668|      1|            .bg_stroke
 3669|      1|            .color
 3670|      1|            .gamma_multiply(0.9);
 3671|      1|        let separator_stroke = Stroke::new(1.0, separator_color);
 3672|      1|        let border_stroke = visuals.window_stroke();
 3673|      1|        let painter = painter.with_clip_rect(clip_rect);
 3674|       |
 3675|       |        // Draw vertical dividers between columns
 3676|      1|        let mut x = rect.left();
 3677|      1|        for width in widths.iter().take(widths.len().saturating_sub(1)) {
 3678|      1|            x += *width;
 3679|      1|            let x_pos = (x.round() + 0.5).clamp(rect.left(), rect.right());
 3680|      1|            painter.vline(x_pos, rect.y_range(), separator_stroke);
 3681|      1|        }
 3682|       |
 3683|       |        // Draw horizontal separator below header row
 3684|      1|        if header_height > 0.0 {
 3685|      1|            let header_y = rect.top() + header_height;
 3686|      1|            if header_y > rect.top() && header_y < rect.bottom() {
 3687|      1|                painter.hline(rect.x_range(), header_y.round() + 0.5, separator_stroke);
 3688|      1|            }
                          ^0
 3689|      0|        }
 3690|       |
 3691|       |        // Draw outer border
 3692|      1|        painter.rect_stroke(rect, 0.0, border_stroke);
 3693|      1|    }
 3694|       |
 3695|      6|    fn render_overhauled_cell(
 3696|      6|        &self,
 3697|      6|        ui: &mut egui::Ui,
 3698|      6|        spans: &[InlineSpan],
 3699|      6|        width: f32,
 3700|      6|        is_header: bool,
 3701|      6|        row_idx: Option<usize>,
 3702|      6|        col_idx: usize,
 3703|      6|    ) -> f32 {
 3704|      6|        let fallback_height = self.row_height_fallback();
 3705|      6|        let fragments = self.cell_fragments(spans);
 3706|      6|        let inner = ui.allocate_ui_with_layout(
 3707|      6|            Vec2::new(width, 0.0),
 3708|      6|            egui::Layout::top_down(egui::Align::LEFT),
 3709|      6|            |ui| {
 3710|      6|                ui.set_width(width);
 3711|      6|                ui.set_max_width(width);
 3712|      6|                ui.spacing_mut().item_spacing = egui::vec2(4.0, 2.0);
 3713|      6|                if fragments.is_empty() {
 3714|      0|                    ui.allocate_exact_size(
 3715|      0|                        Vec2::new(width, self.font_sizes.body * 1.2),
 3716|      0|                        egui::Sense::hover(),
 3717|       |                    );
 3718|      0|                    return;
 3719|      6|                }
 3720|     12|                for fragment in fragments {
                                  ^6
 3721|      6|                    match fragment {
 3722|      6|                        CellFragment::Text(slice) => {
 3723|      6|                            let build = self.cached_layout_job(
 3724|      6|                                ui.style(),
 3725|      6|                                row_idx,
 3726|      6|                                col_idx,
 3727|      6|                                slice,
 3728|      6|                                width,
 3729|      6|                                is_header,
 3730|      6|                            );
 3731|      6|                            self.paint_table_text_job(ui, width, build);
 3732|      6|                        }
 3733|      0|                        CellFragment::Emoji(key) => {
 3734|      0|                            self.render_table_emoji(ui, &key);
 3735|      0|                        }
 3736|      0|                        CellFragment::Image(span) => {
 3737|      0|                            self.render_inline_span(ui, span, None, Some(is_header));
 3738|      0|                        }
 3739|       |                    }
 3740|       |                }
 3741|      6|            },
 3742|       |        );
 3743|      6|        inner.response.rect.height().max(fallback_height)
 3744|      6|    }
 3745|       |
 3746|      6|    fn paint_table_text_job(
 3747|      6|        &self,
 3748|      6|        ui: &mut egui::Ui,
 3749|      6|        width: f32,
 3750|      6|        build: LayoutJobBuild,
 3751|      6|    ) -> egui::Response {
 3752|      6|        let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
 3753|      6|        let height = galley.size().y;
 3754|      6|        let (rect, mut response) =
 3755|      6|            ui.allocate_exact_size(Vec2::new(width, height), egui::Sense::click());
 3756|      6|        let text_color = ui.visuals().text_color();
 3757|      6|        ui.painter_at(rect)
 3758|      6|            .galley(rect.left_top(), galley.clone(), text_color);
 3759|      6|        if galley.rows.len() > 1 {
 3760|      0|            response = response.on_hover_text(build.plain_text.clone());
 3761|      6|        }
 3762|      6|        response.context_menu(|ui| {
                                                 ^0
 3763|      0|            self.render_cell_context_menu(ui, &build.plain_text);
 3764|      0|        });
 3765|       |
 3766|      6|        if let Some(link) = self.link_at_pointer(&response, &galley, &build) {
                                  ^0
 3767|      0|            ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
 3768|      0|            response = response.on_hover_text(link.url.clone());
 3769|      0|            if response.clicked() {
 3770|      0|                self.trigger_link(&link.url);
 3771|      0|            }
 3772|      6|        }
 3773|       |
 3774|      6|        response
 3775|      6|    }
 3776|       |
 3777|     10|    fn cached_layout_job(
 3778|     10|        &self,
 3779|     10|        style: &egui::Style,
 3780|     10|        row_idx: Option<usize>,
 3781|     10|        col_idx: usize,
 3782|     10|        spans: &[InlineSpan],
 3783|     10|        width: f32,
 3784|     10|        is_header: bool,
 3785|     10|    ) -> LayoutJobBuild {
 3786|     10|        if !self.table_wrap_overhaul_enabled {
 3787|      0|            return self.build_layout_job(style, spans, width, is_header);
 3788|     10|        }
 3789|     10|        let highlight_hash = self
 3790|     10|            .highlight_phrase
 3791|     10|            .borrow()
 3792|     10|            .as_ref()
 3793|     10|            .map(|s| Self::hash_str(s))
                                   ^8             ^8
 3794|     10|            .unwrap_or(0);
 3795|     10|        let content_hash = Self::hash_inline_spans(spans);
 3796|     10|        let key = CellLayoutKey {
 3797|     10|            row: row_idx,
 3798|     10|            col: col_idx,
 3799|     10|            width: width.round() as u32,
 3800|     10|            strong: is_header,
 3801|     10|            highlight_hash,
 3802|     10|            content_hash,
 3803|     10|        };
 3804|     10|        if let Some(build) = self.table_layout_cache.borrow_mut().get(&key) {
                                  ^1
 3805|      1|            return build;
 3806|      9|        }
 3807|      9|        let build = self.build_layout_job(style, spans, width, is_header);
 3808|      9|        self.table_layout_cache
 3809|      9|            .borrow_mut()
 3810|      9|            .insert(key, build.clone());
 3811|      9|        build
 3812|     10|    }
 3813|       |
 3814|      6|    fn link_at_pointer<'a>(
 3815|      6|        &self,
 3816|      6|        response: &egui::Response,
 3817|      6|        galley: &Arc<Galley>,
 3818|      6|        build: &'a LayoutJobBuild,
 3819|      6|    ) -> Option<&'a LinkRange> {
 3820|      6|        let pointer = response.hover_pos()?;
                          ^0
 3821|      0|        let local = pointer - response.rect.left_top();
 3822|      0|        let cursor = galley.cursor_from_pos(local);
 3823|      0|        let idx = cursor.ccursor.index;
 3824|      0|        build
 3825|      0|            .link_ranges
 3826|      0|            .iter()
 3827|      0|            .find(|range| range.char_range.contains(&idx))
 3828|      6|    }
 3829|       |
 3830|      0|    fn render_table_emoji(&self, ui: &mut egui::Ui, emoji: &str) {
 3831|      0|        let handle = self.get_or_make_emoji_texture(ui, emoji);
 3832|      0|        let size = self.font_sizes.body * 1.2;
 3833|      0|        ui.add(
 3834|      0|            egui::Image::new(&handle)
 3835|      0|                .max_size(Vec2::splat(size))
 3836|      0|                .sense(egui::Sense::hover()),
 3837|       |        );
 3838|      0|    }
 3839|       |
 3840|       |    /// Render table cell spans with proper text wrapping within the given width
 3841|      0|    fn render_table_cell_spans(
 3842|      0|        &self,
 3843|      0|        ui: &mut egui::Ui,
 3844|      0|        spans: &[InlineSpan],
 3845|      0|        max_width: f32,
 3846|      0|        is_header: bool,
 3847|      0|    ) {
 3848|       |        // Render content with wrapping, forcing exact width to ensure wrapping occurs
 3849|      0|        ui.vertical(|ui| {
 3850|      0|            ui.set_width(max_width); // Force exact width
 3851|      0|            ui.set_max_width(max_width);
 3852|      0|            ui.spacing_mut().item_spacing.y = 0.0;
 3853|       |
 3854|       |            // Render all spans in a wrapped horizontal layout
 3855|      0|            ui.horizontal_wrapped(|ui| {
 3856|      0|                ui.spacing_mut().item_spacing.x = 0.0;
 3857|      0|                ui.set_width(max_width);
 3858|      0|                for span in spans {
 3859|      0|                    self.render_inline_span(ui, span, None, Some(is_header));
 3860|      0|                }
 3861|      0|            });
 3862|      0|        });
 3863|      0|    }
 3864|       |
 3865|      2|    fn resolve_table_widths(available: f32, mins: &[f32], desired: &[f32]) -> Vec<f32> {
 3866|      2|        debug_assert_eq!(mins.len(), desired.len());
 3867|      2|        if mins.is_empty() {
 3868|      0|            return Vec::new();
 3869|      2|        }
 3870|      2|        let clamped_available = available.max(1.0);
 3871|      2|        let desired_total: f32 = desired.iter().sum();
 3872|      2|        let min_total: f32 = mins.iter().sum();
 3873|       |
 3874|      2|        let mut widths = if desired_total <= clamped_available {
 3875|      0|            desired.to_vec()
 3876|      2|        } else if min_total >= clamped_available {
 3877|      1|            if min_total <= f32::EPSILON {
 3878|      0|                vec![clamped_available / mins.len() as f32; mins.len()]
 3879|       |            } else {
 3880|      1|                mins.iter()
 3881|      4|                    .map(|m| m * (clamped_available / min_total))
                                   ^1
 3882|      1|                    .collect()
 3883|       |            }
 3884|       |        } else {
 3885|      1|            let mut widths = mins.to_vec();
 3886|      1|            let extra = clamped_available - min_total;
 3887|      1|            let slack: Vec<f32> = desired
 3888|      1|                .iter()
 3889|      1|                .zip(mins.iter())
 3890|      4|                .map(|(d, m)| (d - m).max(0.0))
                               ^1
 3891|      1|                .collect();
 3892|      1|            let total_slack: f32 = slack.iter().sum();
 3893|      1|            if total_slack <= f32::EPSILON {
 3894|      0|                let bonus = extra / widths.len() as f32;
 3895|      0|                for w in &mut widths {
 3896|      0|                    *w += bonus;
 3897|      0|                }
 3898|       |            } else {
 3899|      4|                for (w, s) in widths.iter_mut().zip(slack.iter()) {
                                            ^1                ^1  ^1
 3900|      4|                    *w += extra * (*s / total_slack);
 3901|      4|                }
 3902|       |            }
 3903|      1|            widths
 3904|       |        };
 3905|       |
 3906|      2|        let sum: f32 = widths.iter().sum();
 3907|      2|        if sum > clamped_available + 0.5 {
 3908|      0|            let ratio = clamped_available / sum;
 3909|      0|            for w in &mut widths {
 3910|      0|                *w *= ratio;
 3911|      0|            }
 3912|      2|        }
 3913|      2|        widths
 3914|      2|    }
 3915|       |
 3916|       |    /// Open URL in default browser
 3917|       |    #[cfg(not(test))]
 3918|       |    fn open_url(&self, url: &str) {
 3919|       |        if let Err(e) = webbrowser::open(url) {
 3920|       |            eprintln!("Failed to open URL {}: {}", url, e);
 3921|       |        }
 3922|       |    }
 3923|       |
 3924|       |    #[cfg(test)]
 3925|      2|    fn open_url(&self, _url: &str) {}
 3926|       |
 3927|      4|    fn trigger_link(&self, url: &str) {
 3928|      4|        if let Some(fragment) = Self::extract_fragment(url) {
                                  ^1
 3929|      1|            *self.pending_anchor.borrow_mut() = Some(fragment);
 3930|      3|        } else if Self::is_allowed_scheme(url) {
 3931|      2|            self.open_url(url);
 3932|      2|        } else {
 3933|      1|            eprintln!("Blocked link with unsupported scheme: {}", url);
 3934|      1|        }
 3935|      4|    }
 3936|       |
 3937|      3|    fn is_allowed_scheme(url: &str) -> bool {
 3938|      3|        url.starts_with("http://") || url.starts_with("https://") || url.starts_with("mailto:")
                                                                                   ^2  ^2
 3939|      3|    }
 3940|       |
 3941|       |    /// Consume and return the last clicked internal anchor, if any
 3942|      6|    pub fn take_pending_anchor(&self) -> Option<String> {
 3943|      6|        self.pending_anchor.borrow_mut().take()
 3944|      6|    }
 3945|       |
 3946|       |    /// Lookup a header rect by its id (slug)
 3947|      1|    pub fn header_rect_for(&self, id: &str) -> Option<egui::Rect> {
 3948|      1|        self.header_rects.borrow().get(id).copied()
 3949|      1|    }
 3950|       |
 3951|       |    /// Lookup the rect for the n-th top-level element rendered in the last frame
 3952|      2|    pub fn element_rect_at(&self, index: usize) -> Option<egui::Rect> {
 3953|      2|        self.element_rects.borrow().get(index).copied()
 3954|      2|    }
 3955|       |
 3956|       |    /// Set or clear the highlight phrase (case-insensitive)
 3957|      3|    pub fn set_highlight_phrase(&self, phrase: Option<&str>) {
 3958|      3|        if let Some(p) = phrase {
 3959|      3|            self.highlight_phrase
 3960|      3|                .borrow_mut()
 3961|      3|                .replace(p.case_fold().nfkc().collect());
 3962|      3|        } else {
 3963|      0|            self.highlight_phrase.borrow_mut().take();
 3964|      0|        }
 3965|      3|        self.clear_table_layout_cache();
 3966|      3|    }
 3967|       |
 3968|     48|    pub fn set_table_wrap_overhaul_enabled(&mut self, enabled: bool) {
 3969|     48|        self.table_wrap_overhaul_enabled = enabled;
 3970|     48|        self.clear_table_layout_cache();
 3971|     48|    }
 3972|       |
 3973|      3|    pub fn table_wrap_overhaul_enabled(&self) -> bool {
 3974|      3|        self.table_wrap_overhaul_enabled
 3975|      3|    }
 3976|       |
 3977|    137|    pub fn clear_table_layout_cache(&self) {
 3978|    137|        self.table_layout_cache.borrow_mut().clear();
 3979|    137|        self.table_metrics.borrow_mut().clear();
 3980|    137|        self.column_stats_cache.borrow_mut().clear();
 3981|    137|    }
 3982|       |
 3983|      7|    pub fn table_layout_cache_stats(&self) -> (u64, u64) {
 3984|      7|        self.table_layout_cache.borrow().stats()
 3985|      7|    }
 3986|       |
 3987|      5|    pub fn table_render_stats(&self) -> (usize, usize) {
 3988|      5|        self.table_metrics.borrow().totals()
 3989|      5|    }
 3990|       |
 3991|       |    /// Get a plain-text representation of a markdown element (for search)
 3992|      3|    pub fn element_plain_text(element: &MarkdownElement) -> String {
 3993|      3|        match element {
 3994|      3|            MarkdownElement::Paragraph(spans) => Self::spans_plain_text(spans),
 3995|      0|            MarkdownElement::Header { spans, .. } => Self::spans_plain_text(spans),
 3996|      0|            MarkdownElement::CodeBlock { text, .. } => text.clone(),
 3997|      0|            MarkdownElement::List { items, .. } => {
 3998|      0|                let mut out = String::new();
 3999|      0|                for item in items {
 4000|      0|                    if !out.is_empty() {
 4001|      0|                        out.push('\n');
 4002|      0|                    }
 4003|      0|                    out.push_str(&Self::spans_plain_text(item));
 4004|       |                }
 4005|      0|                out
 4006|       |            }
 4007|      0|            MarkdownElement::Quote { lines, .. } => {
 4008|      0|                let mut out = String::new();
 4009|      0|                for line in lines {
 4010|      0|                    if !out.is_empty() {
 4011|      0|                        out.push('\n');
 4012|      0|                    }
 4013|      0|                    out.push_str(&Self::spans_plain_text(line));
 4014|       |                }
 4015|      0|                out
 4016|       |            }
 4017|      0|            MarkdownElement::HorizontalRule => String::from("---"),
 4018|      0|            MarkdownElement::Table { headers, rows } => {
 4019|      0|                let mut out = String::new();
 4020|      0|                for h in headers {
 4021|      0|                    if !out.is_empty() {
 4022|      0|                        out.push(' ');
 4023|      0|                    }
 4024|      0|                    out.push_str(&Self::spans_plain_text(h));
 4025|       |                }
 4026|      0|                for row in rows {
 4027|      0|                    for cell in row {
 4028|      0|                        out.push(' ');
 4029|      0|                        out.push_str(&Self::spans_plain_text(cell));
 4030|      0|                    }
 4031|       |                }
 4032|      0|                out
 4033|       |            }
 4034|       |        }
 4035|      3|    }
 4036|       |
 4037|       |    /// Set the base directory for resolving relative image paths
 4038|     28|    pub fn set_base_dir(&self, dir: Option<&Path>) {
 4039|     28|        if let Some(d) = dir {
                                  ^17
 4040|     17|            self.base_dir.borrow_mut().replace(d.to_path_buf());
 4041|     17|        } else {
 4042|     11|            self.base_dir.borrow_mut().take();
 4043|     11|        }
 4044|     28|    }
 4045|       |
 4046|      8|    fn resolve_image_path(&self, src: &str) -> String {
 4047|      8|        if src.starts_with("http://") || src.starts_with("https://") || src.starts_with("data:") {
                                                                                      ^7  ^7
 4048|       |            // Keep as-is; we don't fetch remote or parse data URIs yet
 4049|      1|            return src.to_string();
 4050|      7|        }
 4051|      7|        let p = Path::new(src);
 4052|      7|        if p.is_absolute() {
 4053|      1|            return src.to_string();
 4054|      6|        }
 4055|      6|        if let Some(base) = self.base_dir.borrow().as_ref() {
                                  ^2
 4056|      2|            let joined = base.join(p);
 4057|      2|            return joined.to_string_lossy().into_owned();
 4058|      4|        }
 4059|      4|        src.to_string()
 4060|      8|    }
 4061|       |
 4062|      5|    fn get_or_load_image_texture(
 4063|      5|        &self,
 4064|      5|        ui: &egui::Ui,
 4065|      5|        resolved_src: &str,
 4066|      5|    ) -> Option<(egui::TextureHandle, u32, u32)> {
 4067|       |        // Reject remote for now
 4068|      5|        if resolved_src.starts_with("http://") || resolved_src.starts_with("https://") {
 4069|      1|            return None;
 4070|      4|        }
 4071|       |
 4072|      4|        let path = Path::new(resolved_src);
 4073|       |
 4074|      4|        if let Some(entry) = self.image_textures.borrow().get(resolved_src) {
                                  ^0
 4075|      0|            let stale = Self::image_source_stale(entry.modified, path);
 4076|      0|            if !stale {
 4077|      0|                return Some((entry.texture.clone(), entry.size[0], entry.size[1]));
 4078|      0|            }
 4079|      4|        }
 4080|       |
 4081|       |        // Try embedded assets first
 4082|      4|        if let Some(bytes) = Self::embedded_image_bytes(resolved_src) {
                                  ^2
 4083|      2|            if let Some((color_image, w, h)) = Self::bytes_to_color_image_guess(bytes, None) {
 4084|      2|                let tex = ui.ctx().load_texture(
 4085|      2|                    format!("img:{}", resolved_src),
 4086|      2|                    color_image,
 4087|       |                    egui::TextureOptions::LINEAR,
 4088|       |                );
 4089|      2|                self.store_image_texture(resolved_src, tex.clone(), [w, h], None);
 4090|      2|                return Some((tex, w, h));
 4091|      0|            }
 4092|      2|        }
 4093|       |
 4094|      2|        if !path.exists() {
 4095|      1|            return None;
 4096|      1|        }
 4097|       |
 4098|      1|        let bytes = std::fs::read(path).ok()?;
                                                          ^0
 4099|      1|        let (color_image, w, h) = if Self::is_svg_path(resolved_src) {
 4100|      0|            match Self::svg_bytes_to_color_image(&bytes) {
 4101|      0|                Some((ci, w, h)) => (ci, w, h),
 4102|      0|                None => return None,
 4103|       |            }
 4104|       |        } else {
 4105|      1|            let img = image::load_from_memory(&bytes).ok()?;
                                                                        ^0
 4106|      1|            let rgba = img.to_rgba8();
 4107|      1|            let (w, h) = rgba.dimensions();
 4108|      1|            let ci = egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &rgba);
 4109|      1|            (ci, w, h)
 4110|       |        };
 4111|      1|        let tex = ui.ctx().load_texture(
 4112|      1|            format!("img:{}", resolved_src),
 4113|      1|            color_image,
 4114|       |            egui::TextureOptions::LINEAR,
 4115|       |        );
 4116|      1|        let modified = Self::disk_image_timestamp(path);
 4117|      1|        self.store_image_texture(resolved_src, tex.clone(), [w, h], modified);
 4118|      1|        Some((tex, w, h))
 4119|      5|    }
 4120|       |
 4121|      4|    fn disk_image_timestamp(path: &Path) -> Option<SystemTime> {
 4122|      4|        std::fs::metadata(path).ok()?.modified().ok()
                                                  ^0
 4123|      4|    }
 4124|       |
 4125|      2|    fn image_source_stale(cached_modified: Option<SystemTime>, path: &Path) -> bool {
 4126|      2|        if !path.exists() {
 4127|      0|            return false;
 4128|      2|        }
 4129|      2|        let current = Self::disk_image_timestamp(path);
 4130|      2|        match (cached_modified, current) {
 4131|      2|            (Some(prev), Some(cur)) => prev != cur,
 4132|      0|            (Some(_), None) => true,
 4133|      0|            (None, Some(_)) => true,
 4134|      0|            (None, None) => false,
 4135|       |        }
 4136|      2|    }
 4137|       |
 4138|      3|    fn store_image_texture(
 4139|      3|        &self,
 4140|      3|        key: &str,
 4141|      3|        texture: egui::TextureHandle,
 4142|      3|        size: [u32; 2],
 4143|      3|        modified: Option<SystemTime>,
 4144|      3|    ) {
 4145|      3|        self.image_textures.borrow_mut().insert(
 4146|      3|            key.to_string(),
 4147|      3|            ImageCacheEntry {
 4148|      3|                texture,
 4149|      3|                size,
 4150|      3|                modified,
 4151|      3|            },
 4152|      3|        );
 4153|      3|    }
 4154|       |
 4155|       |    /// Return embedded image bytes for known assets used in sample files
 4156|      4|    fn embedded_image_bytes(path: &str) -> Option<&'static [u8]> {
 4157|      4|        match path.replace('\\', "/").as_str() {
 4158|       |            // Smiley PNG
 4159|      4|            "assets/emoji/1f600.png" => Some(include_bytes!("../assets/emoji/1f600.png")),
                                                      ^0
 4160|       |            // SVG logo and WEBP sample used by images.md
 4161|      4|            "assets/samples/logo.svg" => Some(include_bytes!("../assets/samples/logo.svg")),
                                                       ^1
 4162|      3|            "assets/samples/webp_sample.webp" => {
 4163|      1|                Some(include_bytes!("../assets/samples/webp_sample.webp"))
 4164|       |            }
 4165|      2|            _ => None,
 4166|       |        }
 4167|      4|    }
 4168|       |
 4169|      1|    fn is_svg_path(p: &str) -> bool {
 4170|      1|        p.rsplit('.')
 4171|      1|            .next()
 4172|      1|            .map(|e| e.eq_ignore_ascii_case("svg"))
 4173|      1|            .unwrap_or(false)
 4174|      1|    }
 4175|       |
 4176|      0|    fn svg_bytes_to_color_image(bytes: &[u8]) -> Option<(egui::ColorImage, u32, u32)> {
 4177|      0|        Self::svg_bytes_to_color_image_with_bg(bytes, None)
 4178|      0|    }
 4179|       |
 4180|      1|    fn svg_bytes_to_color_image_with_bg(
 4181|      1|        bytes: &[u8],
 4182|      1|        bg: Option<[u8; 4]>,
 4183|      1|    ) -> Option<(egui::ColorImage, u32, u32)> {
 4184|       |        // Parse SVG
 4185|      1|        let mut opt = usvg::Options::default();
 4186|       |        // Load system fonts so <text> elements render via resvg
 4187|      1|        let mut db = usvg::fontdb::Database::new();
 4188|      1|        db.load_system_fonts();
 4189|      1|        opt.fontdb = std::sync::Arc::new(db);
 4190|      1|        let tree = usvg::Tree::from_data(bytes, &opt).ok()?;
                                                                        ^0
 4191|       |        // Determine output size in pixels
 4192|      1|        let sz = tree.size();
 4193|      1|        let pix = sz.to_int_size();
 4194|      1|        let (mut w, mut h) = (pix.width(), pix.height());
 4195|      1|        if w == 0 || h == 0 {
 4196|      0|            // Fallback if unspecified
 4197|      0|            w = 256;
 4198|      0|            h = 256;
 4199|      1|        }
 4200|       |        // Clamp to a reasonable texture size
 4201|      1|        let max_side: u32 = 4096;
 4202|      1|        if w > max_side || h > max_side {
 4203|      0|            let scale = (max_side as f32 / w as f32).min(max_side as f32 / h as f32);
 4204|      0|            w = (w as f32 * scale) as u32;
 4205|      0|            h = (h as f32 * scale) as u32;
 4206|      1|        }
 4207|      1|        let mut pixmap = tiny_skia::Pixmap::new(w, h)?;
                                                                   ^0
 4208|       |        // Optional background fill for better contrast against dark UI
 4209|      1|        if let Some([r, g, b, a]) = bg {
                                   ^0 ^0 ^0 ^0
 4210|      0|            let color = tiny_skia::Color::from_rgba8(r, g, b, a);
 4211|      0|            pixmap.fill(color);
 4212|      1|        }
 4213|      1|        let mut pmut = pixmap.as_mut();
 4214|      1|        resvg::render(&tree, tiny_skia::Transform::identity(), &mut pmut);
 4215|      1|        let data = pixmap.data();
 4216|      1|        let img = egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], data);
 4217|      1|        Some((img, w, h))
 4218|      1|    }
 4219|       |
 4220|       |    // Try decode as raster image first (PNG/JPEG/WEBP). If that fails, try SVG.
 4221|      2|    fn bytes_to_color_image_guess(
 4222|      2|        bytes: &[u8],
 4223|      2|        bg: Option<[u8; 4]>,
 4224|      2|    ) -> Option<(egui::ColorImage, u32, u32)> {
 4225|      2|        if let Ok(img) = image::load_from_memory(bytes) {
                                ^1
 4226|      1|            let rgba = img.to_rgba8();
 4227|      1|            let (w, h) = rgba.dimensions();
 4228|      1|            let mut ci = egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &rgba);
 4229|      1|            if let Some([br, bgc, bb, ba]) = bg {
                                       ^0  ^0   ^0  ^0
 4230|       |                // Composite over solid bg
 4231|      0|                for p in ci.pixels.iter_mut() {
 4232|      0|                    let a = p[3] as f32 / 255.0;
 4233|      0|                    let inv = 1.0 - a;
 4234|      0|                    p[0] = (a * p[0] as f32 + inv * br as f32) as u8;
 4235|      0|                    p[1] = (a * p[1] as f32 + inv * bgc as f32) as u8;
 4236|      0|                    p[2] = (a * p[2] as f32 + inv * bb as f32) as u8;
 4237|      0|                    p[3] = ba; // fully opaque output
 4238|      0|                }
 4239|      1|            }
 4240|      1|            return Some((ci, w, h));
 4241|      1|        }
 4242|       |        // Fallback to SVG
 4243|      1|        Self::svg_bytes_to_color_image_with_bg(bytes, bg)
 4244|      2|    }
 4245|       |
 4246|       |    /// Find syntax definition for a given language name
 4247|       |    /// Maps common language names to their syntax definitions
 4248|      1|    fn find_syntax_for_language(&self, lang: &str) -> Option<&syntect::parsing::SyntaxReference> {
 4249|       |        // Create a mapping of common language names to their syntect equivalents
 4250|      1|        let lang_lower = lang.to_lowercase();
 4251|       |
 4252|       |        // Try direct name match first
 4253|      1|        if let Some(syntax) = self.syntax_set.find_syntax_by_name(&lang_lower) {
                                  ^0
 4254|      0|            return Some(syntax);
 4255|      1|        }
 4256|       |
 4257|       |        // Try extension-based matching
 4258|      1|        if let Some(syntax) = self.syntax_set.find_syntax_by_extension(&lang_lower) {
                                  ^0
 4259|      0|            return Some(syntax);
 4260|      1|        }
 4261|       |
 4262|       |        // Handle common language mappings
 4263|      1|        let mapped_lang = match lang_lower.as_str() {
 4264|      1|            "rust" => "rs",
 4265|      0|            "python" => "py",
 4266|      0|            "javascript" => "js",
 4267|      0|            "typescript" => "ts",
 4268|      0|            "c++" | "cpp" => "cpp",
 4269|      0|            "c#" | "csharp" => "cs",
 4270|      0|            "shell" | "bash" => "sh",
 4271|      0|            "powershell" => "ps1",
 4272|      0|            "yaml" => "yml",
 4273|      0|            "markdown" => "md",
 4274|      0|            "html" => "html",
 4275|      0|            "css" => "css",
 4276|      0|            "java" => "java",
 4277|      0|            "go" => "go",
 4278|      0|            "php" => "php",
 4279|      0|            "ruby" => "rb",
 4280|      0|            "xml" => "xml",
 4281|      0|            "json" => "json",
 4282|      0|            "sql" => "sql",
 4283|      0|            "toml" => "toml",
 4284|      0|            _ => &lang_lower,
 4285|       |        };
 4286|       |
 4287|       |        // Try mapped extension
 4288|      1|        self.syntax_set
 4289|      1|            .find_syntax_by_extension(mapped_lang)
 4290|      1|            .or_else(|| self.syntax_set.find_syntax_by_name(mapped_lang))
                                      ^0              ^0                  ^0
 4291|      1|    }
 4292|       |
 4293|       |    /// Zoom in (increase font sizes)
 4294|      2|    pub fn zoom_in(&mut self) {
 4295|      2|        self.font_sizes.body = (self.font_sizes.body * 1.1).min(32.0);
 4296|      2|        self.font_sizes.h1 = (self.font_sizes.h1 * 1.1).min(48.0);
 4297|      2|        self.font_sizes.h2 = (self.font_sizes.h2 * 1.1).min(42.0);
 4298|      2|        self.font_sizes.h3 = (self.font_sizes.h3 * 1.1).min(36.0);
 4299|      2|        self.font_sizes.h4 = (self.font_sizes.h4 * 1.1).min(32.0);
 4300|      2|        self.font_sizes.h5 = (self.font_sizes.h5 * 1.1).min(28.0);
 4301|      2|        self.font_sizes.h6 = (self.font_sizes.h6 * 1.1).min(24.0);
 4302|      2|        self.font_sizes.code = (self.font_sizes.code * 1.1).min(20.0);
 4303|      2|        self.clear_table_layout_cache();
 4304|      2|    }
 4305|       |
 4306|       |    /// Zoom out (decrease font sizes)
 4307|      1|    pub fn zoom_out(&mut self) {
 4308|      1|        self.font_sizes.body = (self.font_sizes.body * 0.9).max(8.0);
 4309|      1|        self.font_sizes.h1 = (self.font_sizes.h1 * 0.9).max(16.0);
 4310|      1|        self.font_sizes.h2 = (self.font_sizes.h2 * 0.9).max(14.0);
 4311|      1|        self.font_sizes.h3 = (self.font_sizes.h3 * 0.9).max(12.0);
 4312|      1|        self.font_sizes.h4 = (self.font_sizes.h4 * 0.9).max(11.0);
 4313|      1|        self.font_sizes.h5 = (self.font_sizes.h5 * 0.9).max(10.0);
 4314|      1|        self.font_sizes.h6 = (self.font_sizes.h6 * 0.9).max(9.0);
 4315|      1|        self.font_sizes.code = (self.font_sizes.code * 0.9).max(8.0);
 4316|      1|        self.clear_table_layout_cache();
 4317|      1|    }
 4318|       |
 4319|       |    /// Reset zoom to default
 4320|      1|    pub fn reset_zoom(&mut self) {
 4321|      1|        self.font_sizes = FontSizes::default();
 4322|      1|        self.clear_table_layout_cache();
 4323|      1|    }
 4324|       |}
 4325|       |
 4326|       |#[cfg(test)]
 4327|       |mod tests {
 4328|       |    use super::*;
 4329|       |    use crate::SAMPLE_FILES;
 4330|       |    use tempfile::tempdir;
 4331|       |
 4332|      3|    fn with_test_ui<F>(f: F)
 4333|      3|    where
 4334|      3|        F: FnOnce(&egui::Context, &mut egui::Ui),
 4335|       |    {
 4336|      3|        let ctx = egui::Context::default();
 4337|      3|        let mut input = egui::RawInput::default();
 4338|      3|        input.screen_rect = Some(egui::Rect::from_min_size(
 4339|      3|            egui::pos2(0.0, 0.0),
 4340|      3|            egui::vec2(1024.0, 768.0),
 4341|      3|        ));
 4342|      3|        ctx.begin_frame(input);
 4343|      3|        egui::CentralPanel::default().show(&ctx, |ui| {
 4344|      3|            f(&ctx, ui);
 4345|      3|        });
 4346|      3|        let _ = ctx.end_frame();
 4347|      3|    }
 4348|       |
 4349|       |    #[test]
 4350|      1|    fn test_markdown_renderer_creation() {
 4351|      1|        let renderer = MarkdownRenderer::new();
 4352|      1|        assert_eq!(renderer.font_sizes.body, 14.0);
 4353|      1|        assert_eq!(renderer.font_sizes.h1, 28.0);
 4354|      1|    }
 4355|       |
 4356|       |    #[test]
 4357|      1|    fn test_superscript_expansion_basic() {
 4358|      1|        let s = "5^th^ and m^2^";
 4359|      1|        let out = MarkdownRenderer::expand_superscripts(s);
 4360|      1|        assert!(out.contains("5"));
 4361|      1|        assert!(out.contains("m"));
 4362|      1|    }
 4363|       |
 4364|       |    #[test]
 4365|      1|    fn test_superscript_expansion_single_caret() {
 4366|       |        // Test that single carets (not paired) are left as-is
 4367|      1|        let s = "2^32 = 4,294,967,296";
 4368|      1|        let out = MarkdownRenderer::expand_superscripts(s);
 4369|      1|        assert_eq!(
 4370|       |            out, "2^32 = 4,294,967,296",
 4371|      0|            "Single caret should be preserved"
 4372|       |        );
 4373|       |
 4374|       |        // Test the problematic line from the bug report
 4375|      1|        let problematic = "A 32-bit address bus would provide 2^32 = 4,294,967,296 bytes (4 GB) of addressable memory.";
 4376|      1|        let fixed = MarkdownRenderer::expand_superscripts(problematic);
 4377|      1|        assert_eq!(
 4378|       |            fixed, problematic,
 4379|      0|            "Text should remain unchanged when no paired carets exist"
 4380|       |        );
 4381|       |
 4382|       |        // Test mixed cases
 4383|      1|        let mixed = "Use 2^32 for math and 5^th^ for ordinal";
 4384|      1|        let result = MarkdownRenderer::expand_superscripts(mixed);
 4385|      1|        assert!(result.contains("2^32"), "Single caret should be preserved");
                                                       ^0
 4386|      1|        assert!(result.contains("5"), "Paired carets should be converted");
                                                         ^0
 4387|      1|    }
 4388|       |
 4389|       |    #[test]
 4390|      1|    fn test_font_sizes_default() {
 4391|      1|        let sizes = FontSizes::default();
 4392|      1|        assert_eq!(sizes.body, 14.0);
 4393|      1|        assert_eq!(sizes.h1, 28.0);
 4394|      1|        assert_eq!(sizes.code, 12.0);
 4395|      1|    }
 4396|       |
 4397|       |    #[test]
 4398|      1|    fn test_zoom_functionality() {
 4399|      1|        let mut renderer = MarkdownRenderer::new();
 4400|      1|        let original_body = renderer.font_sizes.body;
 4401|       |
 4402|      1|        renderer.zoom_in();
 4403|      1|        assert!(renderer.font_sizes.body > original_body);
 4404|       |
 4405|      1|        renderer.zoom_out();
 4406|      1|        assert!(renderer.font_sizes.body < original_body * 1.1);
 4407|       |
 4408|      1|        renderer.reset_zoom();
 4409|      1|        assert_eq!(renderer.font_sizes.body, original_body);
 4410|      1|    }
 4411|       |
 4412|       |    #[test]
 4413|      1|    fn font_size_change_does_not_repersist_stale_widths() {
 4414|      1|        let mut renderer = MarkdownRenderer::new();
 4415|      1|        let table_id = 7u64;
 4416|      1|        let specs = vec![ColumnSpec::new(
 4417|       |            "A",
 4418|      1|            ColumnPolicy::Resizable {
 4419|      1|                min: 20.0,
 4420|      1|                preferred: 100.0,
 4421|      1|                clip: false,
 4422|      1|            },
 4423|      1|            None,
 4424|       |        )];
 4425|      1|        let widths = vec![100.0f32];
 4426|       |
 4427|       |        // Initial persist at default font size.
 4428|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
 4429|      1|        let policy_hash = specs[0].policy_hash;
 4430|       |        {
 4431|      1|            let metrics = renderer.table_metrics.borrow();
 4432|      1|            let entry = metrics.entry(table_id).expect("entry created");
 4433|      1|            assert_eq!(entry.persisted_width(policy_hash), Some(100.0));
 4434|      1|            assert_eq!(entry.persisted_font_size, Some(renderer.font_sizes.body));
 4435|       |        }
 4436|       |
 4437|       |        // Simulate zoom: font size changes but widths captured are still the old ones.
 4438|      1|        renderer.font_sizes.body = 16.0;
 4439|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
 4440|       |        {
 4441|      1|            let metrics = renderer.table_metrics.borrow();
 4442|      1|            let entry = metrics.entry(table_id).expect("entry exists");
 4443|       |            // Cleared and NOT re-saved in the same frame.
 4444|      1|            assert_eq!(entry.persisted_width(policy_hash), None);
 4445|      1|            assert_eq!(entry.persisted_font_size, Some(16.0));
 4446|       |        }
 4447|       |
 4448|       |        // Next frame with new layout widths should persist again.
 4449|      1|        let new_widths = vec![80.0f32];
 4450|      1|        renderer.persist_resizable_widths(table_id, &specs, &new_widths);
 4451|      1|        let metrics = renderer.table_metrics.borrow();
 4452|      1|        let entry = metrics.entry(table_id).expect("entry exists");
 4453|      1|        assert_eq!(entry.persisted_width(policy_hash), Some(80.0));
 4454|      1|        assert_eq!(entry.persisted_font_size, Some(16.0));
 4455|      1|    }
 4456|       |
 4457|       |    #[test]
 4458|      1|    fn test_tight_list_inline_code_and_styles() {
 4459|      1|        let renderer = MarkdownRenderer::new();
 4460|      1|        let md = "- Use `code` and **bold** and *italic* and ~~strike~~\\n";
 4461|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4462|      1|        assert_eq!(parsed.len(), 1);
 4463|      1|        match &parsed[0] {
 4464|      1|            MarkdownElement::List { ordered, items } => {
 4465|      1|                assert!(!ordered);
 4466|      1|                assert_eq!(items.len(), 1);
 4467|      1|                let spans = &items[0];
 4468|      1|                assert!(spans
 4469|      1|                    .iter()
 4470|      1|                    .any(|s| matches!(s, InlineSpan::Code(c) if c == "code")));
 4471|      1|                assert!(spans
 4472|      1|                    .iter()
 4473|      1|                    .any(|s| matches!(s, InlineSpan::Strong(t) if t.contains("bold"))));
 4474|      1|                assert!(spans
 4475|      1|                    .iter()
 4476|      1|                    .any(|s| matches!(s, InlineSpan::Emphasis(t) if t.contains("italic"))));
 4477|      1|                assert!(spans
 4478|      1|                    .iter()
 4479|      1|                    .any(|s| matches!(s, InlineSpan::Strikethrough(t) if t.contains("strike"))));
 4480|       |            }
 4481|      0|            other => panic!("Expected List, got {:?}", other),
 4482|       |        }
 4483|      1|    }
 4484|       |
 4485|       |    #[test]
 4486|      1|    fn test_expand_shortcodes_basic() {
 4487|      1|        let rocket = MarkdownRenderer::expand_shortcodes(":rocket:");
 4488|      1|        assert_ne!(rocket, ":rocket:");
 4489|      1|        assert!(crate::emoji_catalog::image_bytes_for(&rocket).is_some());
 4490|       |
 4491|      1|        let tada = MarkdownRenderer::expand_shortcodes(":tada:");
 4492|      1|        assert_ne!(tada, ":tada:");
 4493|      1|        assert!(crate::emoji_catalog::image_bytes_for(&tada).is_some());
 4494|       |
 4495|      1|        assert_eq!(
 4496|      1|            MarkdownRenderer::expand_shortcodes("Hello :tada:!"),
 4497|      1|            format!("Hello {}!", tada)
 4498|       |        );
 4499|      1|    }
 4500|       |
 4501|       |    #[test]
 4502|      1|    fn test_fix_unicode_chars_normalizes_basic_cases() {
 4503|      1|        let renderer = MarkdownRenderer::new();
 4504|      1|        let input = "A\u{00A0}B\u{2013}C";
 4505|      1|        let normalized = renderer.normalize_text_for_test(input);
 4506|      1|        assert_eq!(normalized, "A B-C");
 4507|       |
 4508|      1|        let arrows = renderer.normalize_text_for_test("   ");
 4509|      1|        assert_eq!(arrows, "<- -> ^ v");
 4510|       |
 4511|      1|        let untouched = renderer.normalize_text_for_test("Plain text");
 4512|      1|        assert_eq!(untouched, "Plain text");
 4513|      1|    }
 4514|       |
 4515|       |    #[test]
 4516|      1|    fn test_elements_to_plain_text_basic() {
 4517|      1|        let elements = vec![
 4518|      1|            MarkdownElement::Header {
 4519|      1|                level: 1,
 4520|      1|                spans: vec![InlineSpan::Text("Test Header".to_string())],
 4521|      1|                id: "test-header".to_string(),
 4522|      1|            },
 4523|      1|            MarkdownElement::Paragraph(vec![
 4524|      1|                InlineSpan::Text("This is a ".to_string()),
 4525|      1|                InlineSpan::Strong("bold".to_string()),
 4526|      1|                InlineSpan::Text(" paragraph.".to_string()),
 4527|      1|            ]),
 4528|       |        ];
 4529|       |
 4530|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 4531|      1|        assert!(plain_text.contains("Test Header"));
 4532|      1|        assert!(plain_text.contains("This is a bold paragraph."));
 4533|      1|    }
 4534|       |
 4535|       |    #[test]
 4536|      1|    fn test_elements_to_plain_text_code_block() {
 4537|      1|        let elements = vec![MarkdownElement::CodeBlock {
 4538|      1|            language: Some("rust".to_string()),
 4539|      1|            text: "fn main() {\n    println!(\"Hello\");\n}".to_string(),
 4540|      1|        }];
 4541|       |
 4542|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 4543|      1|        assert_eq!(plain_text, "fn main() {\n    println!(\"Hello\");\n}");
 4544|      1|    }
 4545|       |
 4546|       |    #[test]
 4547|      1|    fn test_elements_to_plain_text_with_links() {
 4548|      1|        let elements = vec![MarkdownElement::Paragraph(vec![
 4549|      1|            InlineSpan::Text("Visit ".to_string()),
 4550|      1|            InlineSpan::Link {
 4551|      1|                text: "GitHub".to_string(),
 4552|      1|                url: "https://github.com".to_string(),
 4553|      1|            },
 4554|      1|            InlineSpan::Text(" for more.".to_string()),
 4555|      1|        ])];
 4556|       |
 4557|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 4558|      1|        assert_eq!(plain_text, "Visit GitHub for more.");
 4559|      1|    }
 4560|       |
 4561|       |    #[test]
 4562|      1|    fn test_image_source_stale_detects_file_changes() {
 4563|       |        use std::time::Duration as StdDuration;
 4564|       |
 4565|      1|        let dir = tempfile::tempdir().expect("temp dir");
 4566|      1|        let file_path = dir.path().join("image.bin");
 4567|      1|        std::fs::write(&file_path, [1u8, 2, 3, 4]).expect("write image");
 4568|      1|        let initial = MarkdownRenderer::disk_image_timestamp(&file_path);
 4569|      1|        assert!(!MarkdownRenderer::image_source_stale(initial, &file_path));
 4570|       |
 4571|      1|        std::thread::sleep(StdDuration::from_millis(5));
 4572|      1|        std::fs::write(&file_path, [4u8, 3, 2, 1]).expect("rewrite image");
 4573|       |
 4574|      1|        assert!(MarkdownRenderer::image_source_stale(initial, &file_path));
 4575|      1|    }
 4576|       |
 4577|       |    #[test]
 4578|      1|    fn test_inline_code_preserves_whitespace() {
 4579|      1|        let renderer = MarkdownRenderer::new();
 4580|      1|        let md = "Start `code` end";
 4581|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4582|      1|        match &parsed[0] {
 4583|      1|            MarkdownElement::Paragraph(spans) => {
 4584|      2|                let code_span = spans.iter().find_map(|span| match span {
                                  ^1          ^1           ^1
 4585|      1|                    InlineSpan::Code(t) => Some(t),
 4586|      1|                    _ => None,
 4587|      2|                });
 4588|      1|                assert_eq!(code_span, Some(&"code".to_string()));
 4589|       |            }
 4590|      0|            other => panic!("Expected Paragraph, got {:?}", other),
 4591|       |        }
 4592|      1|    }
 4593|       |
 4594|       |    #[test]
 4595|      1|    fn test_kroki_enabled_env_flag() {
 4596|      1|        std::env::remove_var("MDMDVIEW_ENABLE_KROKI");
 4597|      1|        assert!(!MarkdownRenderer::kroki_enabled_for_tests());
 4598|       |
 4599|      1|        std::env::set_var("MDMDVIEW_ENABLE_KROKI", "true");
 4600|      1|        assert!(MarkdownRenderer::kroki_enabled_for_tests());
 4601|       |
 4602|      1|        std::env::set_var("MDMDVIEW_ENABLE_KROKI", "0");
 4603|      1|        assert!(!MarkdownRenderer::kroki_enabled_for_tests());
 4604|       |
 4605|      1|        std::env::remove_var("MDMDVIEW_ENABLE_KROKI");
 4606|      1|    }
 4607|       |
 4608|       |    #[test]
 4609|      1|    fn test_spawn_kroki_job_reports_queue_disconnect() {
 4610|      1|        let mut renderer = MarkdownRenderer::new();
 4611|      1|        let (temp_tx, temp_rx) = crossbeam_channel::bounded::<KrokiRequest>(1);
 4612|      1|        drop(temp_rx);
 4613|      1|        renderer.kroki_job_tx = temp_tx;
 4614|      1|        let result = renderer.spawn_kroki_job(1, "graph TD; A-->B;");
 4615|      1|        assert!(matches!(result, Err(KrokiEnqueueError::Disconnected)));
                              ^0
 4616|      1|    }
 4617|       |
 4618|       |    #[test]
 4619|      1|    fn test_spawn_kroki_job_reports_queue_full() {
 4620|      1|        let mut renderer = MarkdownRenderer::new();
 4621|      1|        let (temp_tx, temp_rx) = crossbeam_channel::bounded::<KrokiRequest>(1);
 4622|       |        // Fill the bounded channel so subsequent sends report Full
 4623|      1|        temp_tx
 4624|      1|            .try_send(KrokiRequest {
 4625|      1|                key: 99,
 4626|      1|                url: "https://example.invalid/diagram".to_string(),
 4627|      1|                payload: "graph TD; A-->B;".to_string(),
 4628|      1|            })
 4629|      1|            .expect("pre-fill queue");
 4630|      1|        renderer.kroki_job_tx = temp_tx.clone();
 4631|       |        // Keep receiver alive (unused) to avoid disconnecting the channel
 4632|      1|        let _guard = temp_rx;
 4633|      1|        let result = renderer.spawn_kroki_job(42, "graph TD; B-->C;");
 4634|      1|        assert!(matches!(result, Err(KrokiEnqueueError::QueueFull)));
                              ^0
 4635|      1|    }
 4636|       |
 4637|       |    #[test]
 4638|      1|    fn test_footnote_markers_render_as_visible_text() {
 4639|      1|        let renderer = MarkdownRenderer::new();
 4640|      1|        let md = "Paragraph with footnote[^1].\n\n[^1]: footnote body.";
 4641|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4642|      1|        assert_eq!(parsed.len(), 2);
 4643|      1|        let first_plain = MarkdownRenderer::element_plain_text(&parsed[0]);
 4644|      1|        assert!(
 4645|      1|            first_plain.contains("footnote[^1]"),
 4646|      0|            "footnote marker should remain visible, got {first_plain}"
 4647|       |        );
 4648|      1|        let second_plain = MarkdownRenderer::element_plain_text(&parsed[1]);
 4649|      1|        assert!(
 4650|      1|            second_plain.contains("[^1]: footnote body."),
 4651|      0|            "footnote definition should remain visible, got {second_plain}"
 4652|       |        );
 4653|      1|    }
 4654|       |
 4655|       |    #[test]
 4656|      1|    fn test_parse_headers_assign_ids_and_dedupe() {
 4657|      1|        let renderer = MarkdownRenderer::new();
 4658|      1|        let md = "# Getting Started\n\n## Getting Started\n\n### API & Usage\n\n## API & Usage\n";
 4659|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4660|       |
 4661|      1|        let mut ids = vec![];
 4662|      5|        for el in parsed {
                          ^4
 4663|      4|            if let MarkdownElement::Header { id, .. } = el {
 4664|      4|                ids.push(id);
 4665|      4|            }
                          ^0
 4666|       |        }
 4667|      1|        assert_eq!(ids.len(), 4);
 4668|      1|        assert_eq!(ids[0], "getting-started");
 4669|      1|        assert_eq!(ids[1], "getting-started-1");
 4670|      1|        assert_eq!(ids[2], "api-usage");
 4671|      1|        assert_eq!(ids[3], "api-usage-1");
 4672|      1|    }
 4673|       |
 4674|       |    #[test]
 4675|      1|    fn test_formatting_sample_contains_expected_header_ids() {
 4676|      1|        let renderer = MarkdownRenderer::new();
 4677|      1|        let formatting = SAMPLE_FILES
 4678|      1|            .iter()
 4679|      2|            .find(|f| f.name == "formatting.md")
                           ^1
 4680|      1|            .expect("formatting sample present");
 4681|      1|        let parsed = renderer.parse(formatting.content).expect("parse ok");
 4682|      1|        let ids: Vec<String> = parsed
 4683|      1|            .into_iter()
 4684|     37|            .filter_map(|el| match el {
                           ^1
 4685|     18|                MarkdownElement::Header { id, .. } => Some(id),
 4686|     19|                _ => None,
 4687|     37|            })
 4688|      1|            .collect();
 4689|       |
 4690|     10|        for expected in [
 4691|       |            "markdown-formatting-guide",
 4692|      1|            "table-of-contents",
 4693|      1|            "text-formatting",
 4694|      1|            "headers",
 4695|      1|            "lists",
 4696|      1|            "links-and-images",
 4697|      1|            "emojis",
 4698|      1|            "blockquotes",
 4699|      1|            "horizontal-rules",
 4700|      1|            "tables",
 4701|       |        ] {
 4702|    101|            assert!(ids.iter().any(|id| id == expected), "missing id {expected}");
                          ^10     ^10        ^10                       ^0
 4703|       |        }
 4704|      1|    }
 4705|       |
 4706|       |    #[test]
 4707|      1|    fn test_inline_image_parsing() {
 4708|      1|        let renderer = MarkdownRenderer::new();
 4709|      1|        let md = "Here is an image: ![Alt text](images/pic.webp \"Title\") end.";
 4710|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4711|      1|        assert_eq!(parsed.len(), 1);
 4712|      1|        match &parsed[0] {
 4713|      1|            MarkdownElement::Paragraph(spans) => {
 4714|      2|                let img = spans.iter().find(|s| matches!(s, InlineSpan::Image { .. }));
                                  ^1    ^1           ^1
 4715|      1|                assert!(img.is_some(), "image inline span present");
                                                     ^0
 4716|      1|                if let InlineSpan::Image { src, alt, title } = img.unwrap() {
 4717|      1|                    assert_eq!(src, "images/pic.webp");
 4718|      1|                    assert_eq!(alt, "Alt text");
 4719|      1|                    assert_eq!(title.as_deref(), Some("Title"));
 4720|      0|                }
 4721|       |            }
 4722|      0|            other => panic!("Expected Paragraph, got {:?}", other),
 4723|       |        }
 4724|      1|    }
 4725|       |
 4726|       |    #[test]
 4727|      1|    fn test_image_text_in_plain_text_index() {
 4728|      1|        let renderer = MarkdownRenderer::new();
 4729|      1|        let md = "![Diagram](./a.png \"Flow\")";
 4730|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4731|      1|        let text = MarkdownRenderer::element_plain_text(&parsed[0]);
 4732|      1|        assert!(text.contains("Diagram"));
 4733|      1|        assert!(text.contains("Flow"));
 4734|      1|    }
 4735|       |
 4736|       |    #[test]
 4737|      1|    fn test_cell_fragments_split_text_and_images() {
 4738|      1|        let renderer = MarkdownRenderer::new();
 4739|      1|        let spans = vec![
 4740|      1|            InlineSpan::Text("alpha".into()),
 4741|      1|            InlineSpan::Strong("beta".into()),
 4742|      1|            InlineSpan::Image {
 4743|      1|                src: "img.png".into(),
 4744|      1|                alt: "img".into(),
 4745|      1|                title: None,
 4746|      1|            },
 4747|      1|            InlineSpan::Text("gamma".into()),
 4748|       |        ];
 4749|      1|        let fragments = renderer.cell_fragments(&spans);
 4750|      1|        assert_eq!(fragments.len(), 3);
 4751|      1|        match &fragments[0] {
 4752|      1|            CellFragment::Text(slice) => assert_eq!(slice.len(), 2),
 4753|      0|            other => panic!("expected text fragment, got {:?}", other),
 4754|       |        }
 4755|      1|        match &fragments[1] {
 4756|      1|            CellFragment::Image(span) => {
 4757|      1|                if let InlineSpan::Image { src, .. } = span {
 4758|      1|                    assert_eq!(src, "img.png");
 4759|       |                } else {
 4760|      0|                    panic!("image fragment should point to inline image span");
 4761|       |                }
 4762|       |            }
 4763|      0|            other => panic!("second fragment should be image, got {:?}", other),
 4764|       |        }
 4765|      1|        match &fragments[2] {
 4766|      1|            CellFragment::Text(slice) => {
 4767|      1|                assert_eq!(slice.len(), 1);
 4768|      1|                if let InlineSpan::Text(content) = &slice[0] {
 4769|      1|                    assert_eq!(content, "gamma");
 4770|       |                } else {
 4771|      0|                    panic!("expected trailing text span");
 4772|       |                }
 4773|       |            }
 4774|      0|            other => panic!("expected trailing text fragment, got {:?}", other),
 4775|       |        }
 4776|      1|    }
 4777|       |
 4778|       |    #[test]
 4779|      1|    fn test_cell_fragments_detect_single_emoji_span() {
 4780|      1|        let renderer = MarkdownRenderer::new();
 4781|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 4782|      1|            .get(":rocket:")
 4783|      1|            .expect("rocket shortcode");
 4784|      1|        let spans = vec![
 4785|      1|            InlineSpan::Text((*rocket).to_string()),
 4786|      1|            InlineSpan::Text("tail".into()),
 4787|       |        ];
 4788|      1|        let fragments = renderer.cell_fragments(&spans);
 4789|      1|        assert_eq!(fragments.len(), 2);
 4790|      1|        assert!(matches!(
                              ^0
 4791|      1|            &fragments[0],
 4792|      1|            CellFragment::Emoji(e) if !e.is_empty()
 4793|       |        ));
 4794|      1|        assert!(matches!(fragments[1], CellFragment::Text(_)));
                              ^0
 4795|      1|    }
 4796|       |
 4797|       |    #[test]
 4798|      1|    fn test_layout_job_builder_respects_wrap_width() {
 4799|      1|        let renderer = MarkdownRenderer::new();
 4800|      1|        let spans = vec![InlineSpan::Text(
 4801|      1|            "A long column entry that should wrap neatly within the supplied width.".into(),
 4802|      1|        )];
 4803|      1|        let style = egui::Style::default();
 4804|      1|        let build = renderer.build_layout_job(&style, &spans, 180.0, false);
 4805|      1|        assert_eq!(build.job.wrap.max_width, 180.0);
 4806|      1|        assert!(
 4807|      1|            build.job.text.contains("column entry"),
 4808|      0|            "plain text should be preserved"
 4809|       |        );
 4810|      1|    }
 4811|       |
 4812|       |    #[test]
 4813|      1|    fn test_layout_job_builder_highlights_matches() {
 4814|      1|        let renderer = MarkdownRenderer::new();
 4815|      1|        renderer.set_highlight_phrase(Some("wrap"));
 4816|      1|        let spans = vec![InlineSpan::Text("wrap me, wrap me again".into())];
 4817|      1|        let style = egui::Style::default();
 4818|      1|        let build = renderer.build_layout_job(&style, &spans, 200.0, false);
 4819|      1|        let highlight_bg = style.visuals.selection.bg_fill;
 4820|      1|        assert!(
 4821|      1|            build
 4822|      1|                .job
 4823|      1|                .sections
 4824|      1|                .iter()
 4825|      1|                .any(|s| s.format.background == highlight_bg),
 4826|      0|            "at least one section should carry highlight background"
 4827|       |        );
 4828|      1|    }
 4829|       |
 4830|       |    #[test]
 4831|      1|    fn test_layout_job_builder_tracks_link_ranges() {
 4832|      1|        let renderer = MarkdownRenderer::new();
 4833|      1|        let spans = vec![InlineSpan::Link {
 4834|      1|            text: "Docs".into(),
 4835|      1|            url: "https://example.org/docs".into(),
 4836|      1|        }];
 4837|      1|        let style = egui::Style::default();
 4838|      1|        let build = renderer.build_layout_job(&style, &spans, 220.0, false);
 4839|      1|        assert_eq!(build.link_ranges.len(), 1);
 4840|      1|        let link = &build.link_ranges[0];
 4841|      1|        assert_eq!(link.url, "https://example.org/docs");
 4842|      1|        let char_len = link.char_range.end - link.char_range.start;
 4843|      1|        let linked_text: String = build
 4844|      1|            .job
 4845|      1|            .text
 4846|      1|            .chars()
 4847|      1|            .skip(link.char_range.start)
 4848|      1|            .take(char_len)
 4849|      1|            .collect();
 4850|      1|        assert_eq!(linked_text, "Docs");
 4851|      1|    }
 4852|       |
 4853|       |    #[test]
 4854|      1|    fn test_table_width_solver_keeps_short_columns_readable() {
 4855|      1|        let mins = vec![90.0, 90.0, 90.0, 90.0];
 4856|      1|        let desired = vec![120.0, 120.0, 360.0, 160.0];
 4857|      1|        let widths = MarkdownRenderer::resolve_table_widths(420.0, &mins, &desired);
 4858|      1|        assert_eq!(widths.len(), 4);
 4859|       |        // Narrow columns should stay near their minimums even when a wide column exists
 4860|      1|        assert!(
 4861|      1|            widths[0] >= 85.0,
 4862|      0|            "Version column shrank too far: {}",
 4863|      0|            widths[0]
 4864|       |        );
 4865|      1|        assert!(
 4866|      1|            widths[2] > widths[0],
 4867|      0|            "Wide column should retain more width"
 4868|       |        );
 4869|      1|        let sum: f32 = widths.iter().sum();
 4870|      1|        assert!(
 4871|      1|            (sum - 420.0).abs() < 0.5,
 4872|      0|            "Widths should consume available space, got {sum}"
 4873|       |        );
 4874|      1|    }
 4875|       |
 4876|       |    #[test]
 4877|      1|    fn test_table_width_solver_handles_constrained_space() {
 4878|      1|        let mins = vec![100.0, 100.0, 100.0, 100.0];
 4879|      1|        let desired = vec![200.0, 240.0, 360.0, 160.0];
 4880|      1|        let widths = MarkdownRenderer::resolve_table_widths(260.0, &mins, &desired);
 4881|      1|        assert_eq!(widths.len(), 4);
 4882|      1|        assert!(
 4883|      4|            widths.iter().all(|w| *w > 0.0),
                          ^1            ^1
 4884|      0|            "Widths must stay positive even when clamped hard"
 4885|       |        );
 4886|      1|        let sum: f32 = widths.iter().sum();
 4887|      1|        assert!(
 4888|      1|            (sum - 260.0).abs() < 0.5,
 4889|      0|            "Widths should sum to available space even under tight constraints"
 4890|       |        );
 4891|      1|    }
 4892|       |
 4893|       |    #[test]
 4894|      1|    fn table_cells_keep_images_and_formatting() {
 4895|      1|        let renderer = MarkdownRenderer::new();
 4896|      1|        let md = "\
 4897|      1|| H1 | H2 |
 4898|      1|| --- | --- |
 4899|      1|| text ![Alt](img.png) | **bold** and [link](https://example.com) |";
 4900|      1|        let elements = renderer.parse(md).expect("parse ok");
 4901|      1|        let table = elements
 4902|      1|            .iter()
 4903|      1|            .find_map(|el| match el {
 4904|      1|                MarkdownElement::Table { headers: _, rows } => Some(rows),
 4905|      0|                _ => None,
 4906|      1|            })
 4907|      1|            .expect("table present");
 4908|      1|        assert_eq!(table.len(), 1);
 4909|      1|        let row = &table[0];
 4910|      1|        assert!(row[0]
 4911|      1|            .iter()
 4912|      1|            .any(|span| matches!(span, InlineSpan::Image { src, .. } if src == "img.png")));
 4913|      1|        assert!(row[1]
 4914|      1|            .iter()
 4915|      1|            .any(|span| matches!(span, InlineSpan::Strong(text) if text.contains("bold"))));
 4916|      1|        assert!(row[1].iter().any(|span| matches!(
 4917|      1|            span,
 4918|      1|            InlineSpan::Link { url, .. } if url == "https://example.com"
 4919|       |        )));
 4920|      1|    }
 4921|       |
 4922|       |    #[test]
 4923|      1|    fn table_ids_are_unique_per_position() {
 4924|      1|        let renderer = MarkdownRenderer::new();
 4925|      1|        let md = "\
 4926|      1|| H |
 4927|      1|| - |
 4928|      1|| a |
 4929|      1|
 4930|      1|| H |
 4931|      1|| - |
 4932|      1|| a |";
 4933|      1|        let elements = renderer.parse(md).expect("parse ok");
 4934|      1|        let tables: Vec<_> = elements
 4935|      1|            .iter()
 4936|      1|            .enumerate()
 4937|      2|            .filter_map(|(idx, el)| match el {
                           ^1
 4938|      2|                MarkdownElement::Table { headers, rows } => {
 4939|      2|                    Some(renderer.compute_table_id(headers, rows, idx))
 4940|       |                }
 4941|      0|                _ => None,
 4942|      2|            })
 4943|      1|            .collect();
 4944|      1|        assert_eq!(tables.len(), 2);
 4945|      1|        assert_ne!(tables[0], tables[1], "table ids should differ by position");
                                                       ^0
 4946|      1|    }
 4947|       |
 4948|       |    #[test]
 4949|      1|    fn test_render_to_ui_rich_document_populates_rects_and_table_stats() {
 4950|      1|        let renderer = MarkdownRenderer::new();
 4951|      1|        let md = "\
 4952|      1|# Coverage Demo
 4953|      1|
 4954|      1|Paragraph with :tada: emoji and **bold** text and a [link](#target).
 4955|      1|
 4956|      1|> Quote line one
 4957|      1|> Quote line two
 4958|      1|
 4959|      1|- item one
 4960|      1|- item two
 4961|      1|
 4962|      1|---
 4963|      1|
 4964|      1|```rust
 4965|      1|fn main() {}
 4966|      1|```
 4967|      1|
 4968|      1|| Col A | Col B |
 4969|      1|| --- | --- |
 4970|      1|| A1 | B1 |
 4971|      1|| A2 | B2 |
 4972|      1|
 4973|      1|![Logo](assets/samples/logo.svg \"Logo\")
 4974|      1|![Sample](assets/samples/webp_sample.webp \"Sample\")
 4975|      1|![Missing](missing_test_image.png \"Missing\")
 4976|      1|![Remote](https://example.com/image.png \"Remote\")
 4977|      1|";
 4978|       |
 4979|      1|        let elements = renderer.parse(md).expect("parse ok");
 4980|      1|        renderer.set_highlight_phrase(Some("item"));
 4981|       |
 4982|      1|        with_test_ui(|_, ui| {
 4983|      1|            renderer.render_to_ui(ui, &elements);
 4984|      1|        });
 4985|       |
 4986|      1|        assert!(renderer.element_rect_at(0).is_some());
 4987|      1|        assert!(renderer.header_rect_for("coverage-demo").is_some());
 4988|      1|        let (rendered, total) = renderer.table_render_stats();
 4989|      1|        assert!(total > 0);
 4990|      1|        assert!(rendered > 0);
 4991|      1|        let (_hits, misses) = renderer.table_layout_cache_stats();
 4992|      1|        assert!(misses > 0);
 4993|      1|    }
 4994|       |
 4995|       |    #[test]
 4996|      1|    fn test_table_layout_cache_records_hits() {
 4997|      1|        let renderer = MarkdownRenderer::new();
 4998|      1|        let spans = vec![InlineSpan::Text("alpha".to_string())];
 4999|      1|        let style = egui::Style::default();
 5000|       |
 5001|      1|        let _ = renderer.cached_layout_job(&style, Some(0), 0, &spans, 120.0, false);
 5002|      1|        let _ = renderer.cached_layout_job(&style, Some(0), 0, &spans, 120.0, false);
 5003|       |
 5004|      1|        let (hits, misses) = renderer.table_layout_cache_stats();
 5005|      1|        assert!(hits >= 1);
 5006|      1|        assert!(misses >= 1);
 5007|       |
 5008|      1|        renderer.clear_table_layout_cache();
 5009|      1|        assert_eq!(renderer.table_layout_cache_stats(), (0, 0));
 5010|      1|    }
 5011|       |
 5012|       |    #[test]
 5013|      1|    fn test_trigger_link_handles_fragments_and_schemes() {
 5014|      1|        let renderer = MarkdownRenderer::new();
 5015|       |
 5016|      1|        renderer.trigger_link("#Section-One");
 5017|      1|        assert_eq!(
 5018|      1|            renderer.take_pending_anchor(),
 5019|      1|            Some("section-one".to_string())
 5020|       |        );
 5021|      1|        assert!(renderer.take_pending_anchor().is_none());
 5022|       |
 5023|      1|        renderer.trigger_link("ftp://example.com");
 5024|      1|        assert!(renderer.take_pending_anchor().is_none());
 5025|       |
 5026|      1|        renderer.trigger_link("https://example.com");
 5027|      1|        assert!(renderer.take_pending_anchor().is_none());
 5028|       |
 5029|      1|        renderer.trigger_link("mailto:hello@example.com");
 5030|      1|        assert!(renderer.take_pending_anchor().is_none());
 5031|      1|    }
 5032|       |
 5033|       |    #[test]
 5034|      1|    fn test_resolve_image_path_with_base_dir() {
 5035|      1|        let renderer = MarkdownRenderer::new();
 5036|      1|        let temp = tempdir().expect("temp dir");
 5037|      1|        renderer.set_base_dir(Some(temp.path()));
 5038|       |
 5039|      1|        let resolved = renderer.resolve_image_path("sample.png");
 5040|      1|        assert!(resolved.contains("sample.png"));
 5041|       |
 5042|      1|        let abs = temp.path().join("abs.png");
 5043|      1|        let abs_str = abs.to_string_lossy().into_owned();
 5044|      1|        assert_eq!(renderer.resolve_image_path(&abs_str), abs_str);
 5045|       |
 5046|      1|        renderer.set_base_dir(None);
 5047|      1|        assert_eq!(renderer.resolve_image_path("relative.png"), "relative.png");
 5048|      1|    }
 5049|       |
 5050|       |    #[test]
 5051|      1|    fn test_disk_image_loads_and_caches() {
 5052|      1|        let renderer = MarkdownRenderer::new();
 5053|      1|        let temp = tempdir().expect("temp dir");
 5054|      1|        let image_path = temp.path().join("disk.png");
 5055|       |
 5056|      1|        let mut img = image::RgbaImage::new(2, 2);
 5057|      4|        for pixel in img.pixels_mut() {
                                   ^1  ^1
 5058|      4|            *pixel = image::Rgba([10, 20, 30, 255]);
 5059|      4|        }
 5060|      1|        img.save(&image_path).expect("save png");
 5061|       |
 5062|      1|        renderer.set_base_dir(Some(temp.path()));
 5063|      1|        let resolved = renderer.resolve_image_path("disk.png");
 5064|      1|        with_test_ui(|_, ui| {
 5065|      1|            let loaded = renderer.get_or_load_image_texture(ui, &resolved);
 5066|      1|            assert!(loaded.is_some());
 5067|      1|        });
 5068|       |
 5069|      1|        assert!(renderer.image_textures.borrow().contains_key(&resolved));
 5070|      1|    }
 5071|       |
 5072|       |    #[test]
 5073|      1|    fn test_context_menu_helpers_execute() {
 5074|      1|        let renderer = MarkdownRenderer::new();
 5075|      1|        with_test_ui(|_, ui| {
 5076|      1|            renderer.render_text_context_menu(ui, "text");
 5077|      1|            renderer.render_inline_code_context_menu(ui, "code");
 5078|      1|            renderer.render_code_block_context_menu(ui, "fn main() {}", Some("rust"));
 5079|      1|            renderer.render_link_context_menu(ui, "label", "#anchor");
 5080|      1|            renderer.render_cell_context_menu(ui, "cell");
 5081|      1|            renderer.copy_text_and_close(ui, "direct-copy");
 5082|      1|        });
 5083|      1|    }
 5084|       |
 5085|       |    #[test]
 5086|      1|    fn test_table_wrap_overhaul_toggle() {
 5087|      1|        let mut renderer = MarkdownRenderer::new();
 5088|      1|        assert!(renderer.table_wrap_overhaul_enabled());
 5089|      1|        renderer.set_table_wrap_overhaul_enabled(false);
 5090|      1|        assert!(!renderer.table_wrap_overhaul_enabled());
 5091|      1|        renderer.set_table_wrap_overhaul_enabled(true);
 5092|      1|        assert!(renderer.table_wrap_overhaul_enabled());
 5093|      1|    }
 5094|       |}

C:\language\mdmdview\src\sample_files.rs:
    1|       |//! Sample markdown files embedded in the application
    2|       |//!
    3|       |//! These files demonstrate the markdown viewer capabilities and provide
    4|       |//! usage instructions. They are built into the executable for easy access.
    5|       |
    6|       |/// Represents a sample markdown file with metadata
    7|       |#[derive(Debug, Clone)]
    8|       |pub struct SampleFile {
    9|       |    pub name: &'static str,
   10|       |    pub title: &'static str,
   11|       |    pub content: &'static str,
   12|       |}
   13|       |
   14|       |/// Collection of all embedded sample files
   15|       |pub const SAMPLE_FILES: &[SampleFile] = &[
   16|       |    SampleFile {
   17|       |        name: "welcome.md",
   18|       |        title: "Welcome to MarkdownView",
   19|       |        content: WELCOME_CONTENT,
   20|       |    },
   21|       |    SampleFile {
   22|       |        name: "formatting.md",
   23|       |        title: "Formatting Examples",
   24|       |        content: FORMATTING_CONTENT,
   25|       |    },
   26|       |    SampleFile {
   27|       |        name: "code.md",
   28|       |        title: "Code Examples",
   29|       |        content: CODE_CONTENT,
   30|       |    },
   31|       |    SampleFile {
   32|       |        name: "usage.md",
   33|       |        title: "Usage Instructions",
   34|       |        content: USAGE_CONTENT,
   35|       |    },
   36|       |    SampleFile {
   37|       |        name: "search.md",
   38|       |        title: "Search Tips & Examples",
   39|       |        content: SEARCH_GUIDE_CONTENT,
   40|       |    },
   41|       |    SampleFile {
   42|       |        name: "images.md",
   43|       |        title: "Inline Images & Diagrams",
   44|       |        content: IMAGES_CONTENT,
   45|       |    },
   46|       |];
   47|       |
   48|       |/// Welcome content with basic introduction
   49|       |const WELCOME_CONTENT: &str = r#"# Welcome to MarkdownView
   50|       |
   51|       |A simple, fast markdown viewer for Windows built with Rust and egui.
   52|       |
   53|       |## Features
   54|       |
   55|       |- **Pure Rust Implementation** - Single executable, no dependencies
   56|       |- **Fast Rendering** - Efficient markdown parsing with pulldown-cmark
   57|       |- **Syntax Highlighting** - Code blocks with proper syntax coloring
   58|       |- **Native File Dialogs** - Seamless Windows integration
   59|       |- **Embedded Examples** - Built-in sample files to explore
   60|       |
   61|       |## Quick Start
   62|       |
   63|       |1. **Open a File**: Use `File  Open` or `Ctrl+O` to load a markdown file
   64|       |2. **Browse Samples**: Use `File  Samples` to explore built-in examples
   65|       |3. **Navigate**: Scroll to read through documents
   66|       |
   67|       |Enjoy reading your markdown files with this lightweight, efficient viewer!
   68|       |
   69|       |---
   70|       |
   71|       |*Built with  using Rust, egui, and pulldown-cmark*
   72|       |"#;
   73|       |
   74|       |const FORMATTING_CONTENT: &str = r#"# Markdown Formatting Guide
   75|       |
   76|       |This document demonstrates the various formatting options supported by MarkdownView.
   77|       |
   78|       |## Table of Contents
   79|       |
   80|       |- [Text Formatting](#text-formatting)
   81|       |- [Headers](#headers)
   82|       |- [Lists](#lists)
   83|       |- [Links and Images](#links-and-images)
   84|       |- [Emojis](#emojis)
   85|       |- [Blockquotes](#blockquotes)
   86|       |- [Horizontal Rules](#horizontal-rules)
   87|       |- [Tables](#tables)
   88|       |
   89|       |Quick jump: [Go to Lists](#lists)  [Go to Tables](#tables)
   90|       |
   91|       |## Text Formatting
   92|       |
   93|       |**Bold text** and *italic text* are supported, as well as ***bold italic***.
   94|       |
   95|       |You can also use `inline code` and ~~strikethrough~~ text.
   96|       |
   97|       |## Headers
   98|       |
   99|       |# Header 1
  100|       |## Header 2  
  101|       |### Header 3
  102|       |#### Header 4
  103|       |##### Header 5
  104|       |###### Header 6
  105|       |
  106|       |## Lists
  107|       |
  108|       |### Unordered Lists
  109|       |
  110|       |- First item
  111|       |- Second item
  112|       |  - Nested item
  113|       |  - Another nested item
  114|       |- Third item
  115|       |- Inline code in bullets works: use `--help` or `cargo run`
  116|       |- Styled + emoji in bullets: **:rocket:** launch, *:tada:* celebration, and ~~:fire:~~ warning
  117|       |- Tight list check: this item has :rocket: and `code` without blank lines between items
  118|       |
  119|       |### Ordered Lists
  120|       |
  121|       |1. First item
  122|       |2. Second item
  123|       |   1. Nested numbered item
  124|       |   2. Another nested item
  125|       |3. Third item
  126|       |
  127|       |## Links and Images
  128|       |
  129|       |[Visit Rust's website](https://rust-lang.org)
  130|       |
  131|       |Internal anchors let you jump within this document:
  132|       |- [Jump to Headers](#headers)
  133|       |- [Jump to Tables](#tables)
  134|       |- [Back to top](#markdown-formatting-guide)
  135|       |
  136|       |Links are clickable and will open in your default browser.
  137|       |
  138|       |## Emojis
  139|       |
  140|       |Unicode emojis render as normal text if your font supports them.
  141|       |Examples: Thanks!   Status:   Ship it 
  142|       |
  143|       |Shortcodes like `:rocket:` and `:tada:` are expanded to emoji images in normal text, headers, and list items.
  144|       |
  145|       |## Blockquotes
  146|       |
  147|       |> This is a blockquote.
  148|       |> It can span multiple lines.
  149|       |> 
  150|       |> > Nested blockquotes are also supported.
  151|       |
  152|       |## Horizontal Rules
  153|       |
  154|       |---
  155|       |
  156|       |## Tables
  157|       |
  158|       || Feature | Supported | Notes |
  159|       ||---------|-----------|-------|
  160|       || Headers |  | All levels 1-6 |
  161|       || Lists |  | Ordered and unordered |
  162|       || Code blocks |  | With syntax highlighting |
  163|       || Tables |  | Basic table support |
  164|       || Links |  | Opens in browser; internal anchors scroll indocument |
  165|       |
  166|       |---
  167|       |
  168|       |*This covers most of the formatting features available in MarkdownView.*  
  169|       |[Back to top](#markdown-formatting-guide)
  170|       |"#;
  171|       |
  172|       |/// Code examples with syntax highlighting
  173|       |const SEARCH_GUIDE_CONTENT: &str = concat!(
  174|       |    "# Search Tips & Examples\n\n",
  175|       |    "MarkdownView's search panel is accent-aware and case-insensitive. A single query matches multiple spellings automatically.\n\n",
  176|       |    "## Accent Folding\n\n",
  177|       |    "- Typing `resume` highlights `r\u{00e9}sum\u{00e9}`, `RESUME`, and `re\u{0301}sume` (precomposed vs. combining accent).\n",
  178|       |    "- `istanbul` matches both `\u{0130}stanbul` (Turkish dotted capital I) and `ISTANBUL`.\n",
  179|       |    "- `sao` finds `S\u{00e3}o`, `SAO`, and `Sao` regardless of combining marks.\n",
  180|       |    "- `nino` finds `Ni\u{00f1}o`, `NINO`, and `nin\u{0303}o`.\n\n",
  181|       |    "Try opening this sample, pressing `Ctrl+F`, and searching for the words below:\n\n",
  182|       |    "| Query | Matches in this document |\n",
  183|       |    "|-------|-------------------------|\n",
  184|       |    "| `resume` | r\u{00e9}sum\u{00e9}, RESUME, re\u{0301}sume |\n",
  185|       |    "| `istanbul` | \u{0130}stanbul, ISTANBUL |\n",
  186|       |    "| `sao` | S\u{00e3}o, SAO, Sao |\n",
  187|       |    "| `nino` | Ni\u{00f1}o, NINO, nin\u{0303}o |\n\n",
  188|       |    "> Tip: Use `Enter` / `Shift+Enter` to cycle through matches. The highlight respects grapheme clusters, so emoji and combined characters stay intact.\n\n",
  189|       |);
  190|       |const IMAGES_CONTENT: &str = r#"# Inline Images & Diagrams
  191|       |
  192|       |This sample demonstrates inline images and Mermaid code blocks.
  193|       |
  194|       |## PNG Image
  195|       |
  196|       |Below is a PNG image using an embedded emoji asset.
  197|       |
  198|       |![Smiley PNG](assets/emoji/1f600.png "PNG emoji sample")
  199|       |
  200|       |## SVG Image
  201|       |
  202|       |An SVG logo rendered via resvg/tiny-skia.
  203|       |
  204|       |![SVG Logo](assets/samples/logo.svg "SVG sample logo")
  205|       |
  206|       |## WEBP Image
  207|       |
  208|       |A small WEBP sample is bundled for testing.
  209|       |
  210|       |![WEBP Sample](assets/samples/webp_sample.webp "WEBP sample")
  211|       |
  212|       |## Mermaid Diagram (feature-gated)
  213|       |
  214|       |When the `mermaid-quickjs` feature is enabled, Mermaid code blocks are rendered as diagrams.
  215|       |Otherwise, the source is shown with an informational note.
  216|       |
  217|       |```mermaid
  218|       |graph TD;
  219|       |    A[Start] --> B{Is SVG supported?};
  220|       |    B -- Yes --> C[Rasterize via resvg];
  221|       |    B -- No  --> D[Show placeholder];
  222|       |    C --> E[Display egui texture];
  223|       |    D --> E;
  224|       |```
  225|       |
  226|       |## Notes
  227|       |
  228|       |- The WEBP sample is at `assets/samples/webp_sample.webp`. See `examples/webp_test.md` for a standalone test file.
  229|       |
  230|       |"#;
  231|       |
  232|       |const CODE_CONTENT: &str = r#"# Code Examples
  233|       |
  234|       |MarkdownView supports syntax highlighting for many programming languages.
  235|       |
  236|       |## Rust Code
  237|       |
  238|       |```rust
  239|       |fn main() {
  240|       |    println!("Hello, world!");
  241|       |    
  242|       |    let mut vector = vec![1, 2, 3, 4, 5];
  243|       |    vector.iter()
  244|       |        .filter(|&x| x % 2 == 0)
  245|       |        .for_each(|x| println!("Even number: {}", x));
  246|       |}
  247|       |
  248|       |// Struct definition with lifetimes
  249|       |struct Config<'a> {
  250|       |    name: &'a str,
  251|       |    version: u32,
  252|       |}
  253|       |
  254|       |impl<'a> Config<'a> {
  255|       |    fn new(name: &'a str) -> Self {
  256|       |        Config { name, version: 1 }
  257|       |    }
  258|       |}
  259|       |```
  260|       |
  261|       |## Python Code
  262|       |
  263|       |```python
  264|       |def fibonacci(n):
  265|       |    """Generate fibonacci sequence up to n"""
  266|       |    if n <= 0:
  267|       |        return []
  268|       |    elif n == 1:
  269|       |        return [0]
  270|       |    
  271|       |    sequence = [0, 1]
  272|       |    while len(sequence) < n:
  273|       |        sequence.append(sequence[-1] + sequence[-2])
  274|       |    
  275|       |    return sequence
  276|       |
  277|       |# List comprehension example
  278|       |squares = [x**2 for x in range(10) if x % 2 == 0]
  279|       |print(f"Even squares: {squares}")
  280|       |```
  281|       |
  282|       |## JavaScript Code
  283|       |
  284|       |```javascript
  285|       |// Modern JavaScript with async/await
  286|       |async function fetchUserData(userId) {
  287|       |    try {
  288|       |        const response = await fetch(`/api/users/${userId}`);
  289|       |        const userData = await response.json();
  290|       |        
  291|       |        return {
  292|       |            ...userData,
  293|       |            lastUpdated: new Date().toISOString()
  294|       |        };
  295|       |    } catch (error) {
  296|       |        console.error('Failed to fetch user data:', error);
  297|       |        throw error;
  298|       |    }
  299|       |}
  300|       |
  301|       |// Arrow functions and destructuring
  302|       |const processData = ({ name, age, email }) => ({
  303|       |    displayName: name.toUpperCase(),
  304|       |    isAdult: age >= 18,
  305|       |    emailDomain: email.split('@')[1]
  306|       |});
  307|       |```
  308|       |
  309|       |## SQL Code
  310|       |
  311|       |```sql
  312|       |-- Complex query with joins and aggregation
  313|       |SELECT 
  314|       |    u.username,
  315|       |    u.email,
  316|       |    COUNT(o.id) as total_orders,
  317|       |    SUM(oi.price * oi.quantity) as total_spent
  318|       |FROM users u
  319|       |LEFT JOIN orders o ON u.id = o.user_id
  320|       |LEFT JOIN order_items oi ON o.id = oi.order_id
  321|       |WHERE u.created_at >= '2023-01-01'
  322|       |GROUP BY u.id, u.username, u.email
  323|       |HAVING COUNT(o.id) > 5
  324|       |ORDER BY total_spent DESC
  325|       |LIMIT 20;
  326|       |```
  327|       |
  328|       |## Inline Code
  329|       |
  330|       |You can also use `inline code` within paragraphs, like `let x = 42;` or `print("hello")`.
  331|       |
  332|       |---
  333|       |
  334|       |*Syntax highlighting is powered by the syntect library, supporting dozens of languages.*
  335|       |"#;
  336|       |
  337|       |/// Usage instructions and tips
  338|       |const USAGE_CONTENT: &str = r#"# Usage Instructions
  339|       |
  340|       |## Opening Files
  341|       |
  342|       |### File Menu
  343|       |- Use `File  Open` from the menu bar
  344|       |- Keyboard shortcut: `Ctrl+O`
  345|       |- Select any `.md` or `.markdown` file from your system
  346|       |
  347|       |### Drag and Drop
  348|       |- Drag markdown files directly into the application window
  349|       |- Multiple files can be opened in sequence
  350|       |
  351|       |## Viewing Sample Files
  352|       |
  353|       |### Built-in Examples
  354|       |- Use `File  Samples` to browse embedded examples
  355|       |- These files demonstrate various markdown features
  356|       |- Perfect for testing and learning
  357|       |
  358|       |### Sample File List
  359|       |- **welcome.md** - Introduction and overview
  360|       |- **formatting.md** - Text formatting examples  
  361|       |- **code.md** - Syntax highlighting examples
  362|       |- **usage.md** - This usage guide
  363|       |
  364|       |## Navigation
  365|       |
  366|       |### Scrolling
  367|       |- Use mouse wheel or trackpad to scroll
  368|       |- Keyboard arrows for line-by-line navigation
  369|       |- Page Up/Page Down for faster scrolling
  370|       |
  371|       |### Window Controls
  372|       |- Resize the window as needed
  373|       |- Content automatically reflows
  374|       |- Minimum window size is enforced
  375|       |
  376|       |## Keyboard Shortcuts
  377|       |
  378|       || Shortcut | Action |
  379|       ||----------|--------|
  380|       || `Ctrl+O` | Open file |
  381|       || `Ctrl+W` | Close current file |
  382|       || `F5` | Reload current file |
  383|       || `Ctrl+Q` | Quit application |
  384|       || `F11` | Toggle fullscreen |
  385|       || `Ctrl++` | Zoom in (increase font size) |
  386|       || `Ctrl+-` | Zoom out (decrease font size) |
  387|       || `Ctrl` + Mouse Wheel | Zoom in/out |
  388|       || `Ctrl+0` | Reset zoom to default size |
  389|       || `Home` | Go to top of document |
  390|       || `End` | Go to bottom of document |
  391|       || `Page Up` | Scroll up one page |
  392|       || `Page Down` | Scroll down one page |
  393|       |
  394|       |## File Associations
  395|       |
  396|       |### Windows Integration
  397|       |To make MarkdownView the default for `.md` files:
  398|       |
  399|       |1. Right-click any `.md` file
  400|       |2. Select "Open with  Choose another app"
  401|       |3. Browse to the MarkdownView executable
  402|       |4. Check "Always use this app"
  403|       |
  404|       |### Supported Extensions
  405|       |- `.md` - Standard markdown files
  406|       |- `.markdown` - Alternative markdown extension
  407|       |- `.mdown` - Another common variation
  408|       |- `.mkd` - Short markdown extension
  409|       |
  410|       |## Performance
  411|       |
  412|       |### Large Files
  413|       |- Files up to several MB render efficiently
  414|       |- Very large files (>10MB) may take a moment to parse
  415|       |- Consider breaking up extremely large documents
  416|       |
  417|       |### Memory Usage
  418|       |- Minimal memory footprint
  419|       |- Parsed content is cached for fast scrolling
  420|       |- No memory leaks during normal operation
  421|       |
  422|       |## Troubleshooting
  423|       |
  424|       |### Common Issues
  425|       |
  426|       |**File won't open**
  427|       |- Check file extension is `.md` or `.markdown`
  428|       |- Ensure file isn't locked by another application
  429|       |- Verify file contains valid UTF-8 text
  430|       |
  431|       |**Display issues**
  432|       |- Try resizing the window
  433|       |- Restart the application
  434|       |- Check if file contains very long lines
  435|       |
  436|       |**Performance problems**
  437|       |- Close and reopen large files
  438|       |- Ensure adequate system memory
  439|       |- Consider breaking up large documents
  440|       |
  441|       |### Getting Help
  442|       |
  443|       |For bugs or feature requests:
  444|       |1. Check the application works with sample files
  445|       |2. Try reproducing with a minimal markdown file
  446|       |3. Note your Windows version and system specs
  447|       |
  448|       |---
  449|       |
  450|       |*Thank you for using MarkdownView! We hope it serves your markdown reading needs well.*
  451|       |"#;
  452|       |
  453|       |#[cfg(test)]
  454|       |mod tests {
  455|       |    use super::*;
  456|       |
  457|       |    #[test]
  458|      1|    fn test_sample_files_exist() {
  459|      1|        assert_eq!(SAMPLE_FILES.len(), 6);
  460|       |
  461|      1|        let names: Vec<&str> = SAMPLE_FILES.iter().map(|f| f.name).collect();
  462|      1|        assert!(names.contains(&"welcome.md"));
  463|      1|        assert!(names.contains(&"formatting.md"));
  464|      1|        assert!(names.contains(&"code.md"));
  465|      1|        assert!(names.contains(&"usage.md"));
  466|      1|        assert!(names.contains(&"search.md"));
  467|      1|        assert!(names.contains(&"images.md"));
  468|      1|    }
  469|       |
  470|       |    #[test]
  471|      1|    fn test_sample_files_content_not_empty() {
  472|      7|        for file in SAMPLE_FILES {
                          ^6
  473|      6|            assert!(
  474|      6|                !file.content.is_empty(),
  475|      0|                "File {} has empty content",
  476|       |                file.name
  477|       |            );
  478|      6|            assert!(!file.title.is_empty(), "File {} has empty title", file.name);
                                                          ^0
  479|      6|            assert!(!file.name.is_empty(), "File has empty name");
                                                         ^0
  480|       |        }
  481|      1|    }
  482|       |
  483|       |    #[test]
  484|      1|    fn test_sample_files_are_valid_markdown() {
  485|       |        use pulldown_cmark::{Options, Parser};
  486|       |
  487|      7|        for file in SAMPLE_FILES {
                          ^6
  488|      6|            let parser = Parser::new_ext(file.content, Options::all());
  489|      6|            let events: Vec<_> = parser.collect();
  490|      6|            assert!(
  491|      6|                !events.is_empty(),
  492|      0|                "File {} produces no markdown events",
  493|       |                file.name
  494|       |            );
  495|       |        }
  496|      1|    }
  497|       |
  498|       |    #[test]
  499|      1|    fn test_welcome_content_structure() {
  500|      1|        assert!(WELCOME_CONTENT.contains("# Welcome"));
  501|      1|        assert!(WELCOME_CONTENT.contains("## Features"));
  502|      1|        assert!(WELCOME_CONTENT.contains("## Quick Start"));
  503|      1|    }
  504|       |
  505|       |    #[test]
  506|      1|    fn test_formatting_content_examples() {
  507|      1|        assert!(FORMATTING_CONTENT.contains("**Bold text**"));
  508|      1|        assert!(FORMATTING_CONTENT.contains("*italic text*"));
  509|      1|        assert!(FORMATTING_CONTENT.contains("`inline code`"));
  510|      1|        assert!(FORMATTING_CONTENT.contains("| Feature | Supported |"));
  511|      1|    }
  512|       |
  513|       |    #[test]
  514|      1|    fn test_code_content_languages() {
  515|      1|        assert!(CODE_CONTENT.contains("```rust"));
  516|      1|        assert!(CODE_CONTENT.contains("```python"));
  517|      1|        assert!(CODE_CONTENT.contains("```javascript"));
  518|      1|        assert!(CODE_CONTENT.contains("```sql"));
  519|      1|    }
  520|       |
  521|       |    #[test]
  522|      1|    fn test_usage_content_sections() {
  523|      1|        assert!(USAGE_CONTENT.contains("## Opening Files"));
  524|      1|        assert!(USAGE_CONTENT.contains("## Keyboard Shortcuts"));
  525|      1|        assert!(USAGE_CONTENT.contains("## Troubleshooting"));
  526|      1|    }
  527|       |
  528|       |    #[test]
  529|      1|    fn test_search_guide_examples_present() {
  530|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("rsum"));
  531|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("stanbul"));
  532|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("So"));
  533|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("Nio"));
  534|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("Ctrl+F"));
  535|      1|    }
  536|       |}

C:\language\mdmdview\src\table_support\column_spec.rs:
    1|       |use std::cmp::max;
    2|       |use std::hash::{Hash, Hasher};
    3|       |
    4|       |use egui_extras::Column;
    5|       |use unicode_segmentation::UnicodeSegmentation;
    6|       |use unicode_width::UnicodeWidthStr;
    7|       |
    8|       |use crate::markdown_renderer::InlineSpan;
    9|       |
   10|       |const MAX_REMAINDER_COLUMNS: usize = 2;
   11|       |
   12|     20|fn normalize_body_font_px(body: f32) -> f32 {
   13|     20|    if body.is_finite() && body > 4.0 {
   14|     20|        body
   15|       |    } else {
   16|      0|        14.0
   17|       |    }
   18|     20|}
   19|       |
   20|     20|fn px(body_px: f32, factor: f32) -> f32 {
   21|     20|    normalize_body_font_px(body_px) * factor
   22|     20|}
   23|       |
   24|       |#[derive(Debug, Clone, PartialEq)]
   25|       |pub enum ColumnPolicy {
   26|       |    Auto,
   27|       |    Fixed {
   28|       |        width: f32,
   29|       |        clip: bool,
   30|       |    },
   31|       |    Remainder {
   32|       |        clip: bool,
   33|       |    },
   34|       |    Resizable {
   35|       |        min: f32,
   36|       |        preferred: f32,
   37|       |        clip: bool,
   38|       |    },
   39|       |}
   40|       |
   41|       |impl ColumnPolicy {
   42|      2|    pub fn to_column(&self) -> Column {
   43|      2|        match self {
   44|      0|            ColumnPolicy::Auto => Column::auto(),
   45|      1|            ColumnPolicy::Fixed { width, clip } => {
   46|      1|                let mut col = Column::exact(*width);
   47|      1|                if *clip {
   48|      1|                    col = col.clip(true);
   49|      1|                }
                              ^0
   50|      1|                col
   51|       |            }
   52|      1|            ColumnPolicy::Remainder { clip } => {
   53|      1|                let mut col = Column::remainder();
   54|      1|                if *clip {
   55|      0|                    col = col.clip(true);
   56|      1|                }
   57|      1|                col
   58|       |            }
   59|       |            ColumnPolicy::Resizable {
   60|      0|                min,
   61|      0|                preferred,
   62|      0|                clip,
   63|       |            } => {
   64|      0|                let mut col = Column::initial(*preferred).at_least(*min).resizable(true);
   65|      0|                if *clip {
   66|      0|                    col = col.clip(true);
   67|      0|                }
   68|      0|                col
   69|       |            }
   70|       |        }
   71|      2|    }
   72|       |}
   73|       |
   74|       |impl Hash for ColumnPolicy {
   75|     21|    fn hash<H: Hasher>(&self, state: &mut H) {
   76|     21|        std::mem::discriminant(self).hash(state);
   77|     21|        match self {
   78|      0|            ColumnPolicy::Auto => {}
   79|      4|            ColumnPolicy::Fixed { width, clip } => {
   80|      4|                width.to_bits().hash(state);
   81|      4|                clip.hash(state);
   82|      4|            }
   83|      8|            ColumnPolicy::Remainder { clip } => {
   84|      8|                clip.hash(state);
   85|      8|            }
   86|       |            ColumnPolicy::Resizable {
   87|      9|                min,
   88|      9|                preferred,
   89|      9|                clip,
   90|      9|            } => {
   91|      9|                min.to_bits().hash(state);
   92|      9|                preferred.to_bits().hash(state);
   93|      9|                clip.hash(state);
   94|      9|            }
   95|       |        }
   96|     21|    }
   97|       |}
   98|       |
   99|       |#[derive(Debug, Clone)]
  100|       |pub struct ColumnSpec {
  101|       |    pub ident: String,
  102|       |    pub policy: ColumnPolicy,
  103|       |    pub tooltip: Option<String>,
  104|       |    pub policy_hash: u64,
  105|       |}
  106|       |
  107|       |impl ColumnSpec {
  108|     18|    pub fn new(ident: impl Into<String>, policy: ColumnPolicy, tooltip: Option<String>) -> Self {
  109|     18|        let ident = ident.into();
  110|     18|        let policy_hash = calculate_policy_hash(&ident, &policy);
  111|     18|        Self {
  112|     18|            ident,
  113|     18|            policy,
  114|     18|            tooltip,
  115|     18|            policy_hash,
  116|     18|        }
  117|     18|    }
  118|       |
  119|      2|    pub fn as_column(&self) -> Column {
  120|      2|        self.policy.to_column()
  121|      2|    }
  122|       |
  123|      3|    pub fn set_policy(&mut self, policy: ColumnPolicy) {
  124|      3|        self.policy = policy;
  125|      3|        self.policy_hash = calculate_policy_hash(&self.ident, &self.policy);
  126|      3|    }
  127|       |
  128|      0|    pub fn apply_preferred_width(&mut self, width: f32) {
  129|       |        if let ColumnPolicy::Resizable {
  130|      0|            min,
  131|      0|            ref mut preferred,
  132|       |            ..
  133|      0|        } = self.policy
  134|      0|        {
  135|      0|            let clamped = width.max(min);
  136|      0|            *preferred = clamped;
  137|      0|            self.policy_hash = calculate_policy_hash(&self.ident, &self.policy);
  138|      0|        }
  139|      0|    }
  140|       |}
  141|       |
  142|       |#[derive(Debug, Clone, Copy, Default)]
  143|       |pub struct RichContentFlags {
  144|       |    pub has_link: bool,
  145|       |    pub has_image: bool,
  146|       |    pub has_emoji_like: bool,
  147|       |}
  148|       |
  149|       |#[derive(Debug, Clone, Default)]
  150|       |pub struct ColumnStat {
  151|       |    pub max_graphemes: usize,
  152|       |    pub longest_word: usize,
  153|       |    pub rich_content: RichContentFlags,
  154|       |}
  155|       |
  156|       |pub struct TableColumnContext<'a> {
  157|       |    pub headers: &'a [Vec<InlineSpan>],
  158|       |    pub rows: &'a [Vec<Vec<InlineSpan>>],
  159|       |    pub stats: &'a [ColumnStat],
  160|       |    pub body_font_px: f32,
  161|       |    pub table_id: u64,
  162|       |}
  163|       |
  164|       |impl<'a> TableColumnContext<'a> {
  165|      7|    pub fn new(
  166|      7|        headers: &'a [Vec<InlineSpan>],
  167|      7|        rows: &'a [Vec<Vec<InlineSpan>>],
  168|      7|        stats: &'a [ColumnStat],
  169|      7|        body_font_px: f32,
  170|      7|        table_id: u64,
  171|      7|    ) -> Self {
  172|      7|        Self {
  173|      7|            headers,
  174|      7|            rows,
  175|      7|            stats,
  176|      7|            body_font_px,
  177|      7|            table_id,
  178|      7|        }
  179|      7|    }
  180|       |
  181|     22|    pub fn column_stat(&self, idx: usize) -> Option<&ColumnStat> {
  182|     22|        self.stats.get(idx)
  183|     22|    }
  184|       |}
  185|       |
  186|     21|fn calculate_policy_hash(ident: &str, policy: &ColumnPolicy) -> u64 {
  187|     21|    let mut hasher = std::collections::hash_map::DefaultHasher::new();
  188|     21|    ident.hash(&mut hasher);
  189|     21|    policy.hash(&mut hasher);
  190|     21|    hasher.finish()
  191|     21|}
  192|       |
  193|      7|pub fn derive_column_specs(ctx: &TableColumnContext) -> Vec<ColumnSpec> {
  194|      7|    let mut remainder_assigned = 0usize;
  195|      7|    let mut fallback_idx: Option<usize> = None;
  196|      7|    let mut fallback_score: usize = 0;
  197|      7|    let column_count = ctx
  198|      7|        .stats
  199|      7|        .len()
  200|      7|        .max(ctx.headers.len())
  201|      7|        .max(ctx.rows.iter().map(|r| r.len()).max().unwrap_or(0));
                                                   ^4^4
  202|       |
  203|      7|    let mut scored_indices: Vec<(usize, usize)> = Vec::with_capacity(column_count);
  204|       |
  205|      7|    let mut specs: Vec<ColumnSpec> = (0..column_count)
  206|     17|        .map(|idx| {
                       ^7
  207|     17|            let spans = ctx.headers.get(idx).map(|v| v.as_slice()).unwrap_or(&[]);
  208|     17|            let label = header_text(spans);
  209|     17|            let stat = ctx.column_stat(idx);
  210|       |
  211|     17|            let candidate_score = stat
  212|     17|                .map(|s| {
  213|     17|                    let mut score = s.max_graphemes + s.longest_word * 2;
  214|     17|                    if s.rich_content.has_image {
  215|      0|                        score += 50;
  216|     17|                    }
  217|     17|                    if s.rich_content.has_link {
  218|      0|                        score += 25;
  219|     17|                    }
  220|     17|                    score
  221|     17|                })
  222|     17|                .unwrap_or_else(|| label.len());
                                                 ^0    ^0
  223|     17|            if candidate_score > fallback_score {
  224|     13|                fallback_score = candidate_score;
  225|     13|                fallback_idx = Some(idx);
  226|     13|            }
                          ^4
  227|     17|            scored_indices.push((idx, candidate_score));
  228|       |
  229|     17|            let policy =
  230|     17|                classify_column(&label, idx, &mut remainder_assigned, stat, ctx.body_font_px);
  231|     17|            let tooltip = column_tooltip(&label, &policy);
  232|     17|            ColumnSpec::new(label, policy, tooltip)
  233|     17|        })
  234|      7|        .collect();
  235|       |
  236|       |    // Ensure at least one remainder if none assigned and available
  237|      7|    if remainder_assigned == 0 {
  238|      2|        let mut candidate = fallback_idx;
  239|      2|        if let Some(idx) = candidate {
  240|      2|            if matches!(specs[idx].policy, ColumnPolicy::Fixed { .. }) {
                             ^0
  241|      2|                candidate = None;
  242|      2|            }
                          ^0
  243|      0|        }
  244|      2|        if candidate.is_none() {
  245|      2|            candidate = specs
  246|      2|                .iter()
  247|      2|                .enumerate()
  248|      4|                .find(|(_, spec)| !matches!(spec.policy, ColumnPolicy::Fixed { .. }))
                               ^2                ^2
  249|      2|                .map(|(idx, _)| idx);
  250|      0|        }
  251|      2|        if let Some(idx) = candidate {
  252|      2|            if let Some(spec) = specs.get_mut(idx) {
  253|      2|                spec.set_policy(ColumnPolicy::Remainder { clip: false });
  254|      2|                remainder_assigned += 1;
  255|      2|            }
                          ^0
  256|      0|        }
  257|      5|    }
  258|       |
  259|       |    // Promote additional wide columns to remainder up to the cap
  260|     14|    scored_indices.sort_by(|a, b| b.1.cmp(&a.1));
                  ^7             ^7
  261|     23|    for (idx, _) in scored_indices {
                       ^17
  262|     17|        if remainder_assigned >= MAX_REMAINDER_COLUMNS {
  263|      1|            break;
  264|     16|        }
  265|     16|        if let Some(spec) = specs.get_mut(idx) {
  266|     16|            if matches!(spec.policy, ColumnPolicy::Resizable { .. })
                             ^11
  267|      5|                && column_needs_remainder(ctx.column_stat(idx))
  268|      1|            {
  269|      1|                spec.set_policy(ColumnPolicy::Remainder { clip: false });
  270|      1|                remainder_assigned += 1;
  271|     15|            }
  272|      0|        }
  273|       |    }
  274|       |
  275|      7|    specs
  276|      7|}
  277|       |
  278|     18|fn header_text(spans: &[InlineSpan]) -> String {
  279|     18|    let mut text = String::new();
  280|     36|    for span in spans {
                      ^18
  281|     18|        match span {
  282|     18|            InlineSpan::Text(t)
  283|      0|            | InlineSpan::Strong(t)
  284|      0|            | InlineSpan::Emphasis(t)
  285|      0|            | InlineSpan::Strikethrough(t)
  286|      0|            | InlineSpan::Code(t) => {
  287|     18|                if !text.is_empty() {
  288|      0|                    text.push(' ');
  289|     18|                }
  290|     18|                text.push_str(t.trim());
  291|       |            }
  292|      0|            InlineSpan::Link { text: t, .. } => {
  293|      0|                if !text.is_empty() {
  294|      0|                    text.push(' ');
  295|      0|                }
  296|      0|                text.push_str(t.trim());
  297|       |            }
  298|      0|            InlineSpan::Image { alt, .. } => {
  299|      0|                if !text.is_empty() {
  300|      0|                    text.push(' ');
  301|      0|                }
  302|      0|                text.push_str(alt.trim());
  303|       |            }
  304|       |        }
  305|       |    }
  306|     18|    if text.trim().is_empty() {
  307|      0|        "Column".to_string()
  308|       |    } else {
  309|     18|        text.trim().to_string()
  310|       |    }
  311|     18|}
  312|       |
  313|     17|fn classify_column(
  314|     17|    label: &str,
  315|     17|    index: usize,
  316|     17|    remainder_assigned: &mut usize,
  317|     17|    stat: Option<&ColumnStat>,
  318|     17|    body_font_px: f32,
  319|     17|) -> ColumnPolicy {
  320|     17|    let lower = label.to_ascii_lowercase();
  321|     17|    if matches_any(&lower, &["version", "rev", "#", "id"]) {
  322|      1|        return ColumnPolicy::Fixed {
  323|      1|            width: px(body_font_px, 5.8).clamp(80.0, 160.0),
  324|      1|            clip: true,
  325|      1|        };
  326|     16|    }
  327|     16|    if matches_any(&lower, &["date", "time", "timestamp"]) {
  328|      0|        return ColumnPolicy::Fixed {
  329|      0|            width: px(body_font_px, 8.5).clamp(110.0, 200.0),
  330|      0|            clip: false,
  331|      0|        };
  332|     16|    }
  333|     16|    if matches_any(&lower, &["author", "owner", "assignee", "user"]) {
  334|      1|        return ColumnPolicy::Resizable {
  335|      1|            min: px(body_font_px, 7.5),
  336|      1|            preferred: px(body_font_px, 10.0),
  337|      1|            clip: false,
  338|      1|        };
  339|     15|    }
  340|     15|    if matches_any(&lower, &["status", "state"]) {
  341|      0|        return ColumnPolicy::Fixed {
  342|      0|            width: px(body_font_px, 7.0).clamp(90.0, 180.0),
  343|      0|            clip: true,
  344|      0|        };
  345|     15|    }
  346|     15|    if matches_any(
  347|     15|        &lower,
  348|     15|        &["notes", "changes", "description", "details", "summary"],
  349|       |    ) {
  350|      5|        return ColumnPolicy::Resizable {
  351|      5|            min: px(body_font_px, 10.5),
  352|      5|            preferred: px(body_font_px, 14.5),
  353|      5|            clip: false,
  354|      5|        };
  355|     10|    }
  356|     10|    if matches_any(
  357|     10|        &lower,
  358|     10|        &["example", "examples", "sample", "use case", "use cases"],
  359|       |    ) {
  360|      4|        *remainder_assigned += 1;
  361|      4|        return ColumnPolicy::Remainder { clip: false };
  362|      6|    }
  363|      6|    if index == 0 {
  364|       |        // First column typically identifiers; keep fixed only for short labels.
  365|      3|        if stat
  366|      3|            .map(|s| s.max_graphemes <= 18 && s.longest_word <= 12)
  367|      3|            .unwrap_or_else(|| label.len() <= 12)
                                             ^0    ^0
  368|       |        {
  369|      3|            return ColumnPolicy::Fixed {
  370|      3|                width: px(body_font_px, 7.0).clamp(80.0, 180.0),
  371|      3|                clip: true,
  372|      3|            };
  373|      0|        }
  374|      3|    }
  375|      3|    if *remainder_assigned < MAX_REMAINDER_COLUMNS && column_needs_remainder(stat) {
  376|      1|        *remainder_assigned += 1;
  377|      1|        return ColumnPolicy::Remainder { clip: false };
  378|      2|    }
  379|      2|    ColumnPolicy::Resizable {
  380|      2|        min: px(body_font_px, 7.0),
  381|      2|        preferred: px(body_font_px, 9.5),
  382|      2|        clip: false,
  383|      2|    }
  384|     17|}
  385|       |
  386|      8|fn column_needs_remainder(stat: Option<&ColumnStat>) -> bool {
  387|      8|    if let Some(stat) = stat {
  388|      8|        stat.rich_content.has_image
  389|      8|            || stat.longest_word > 18
  390|      8|            || stat.max_graphemes > 60
  391|      6|            || stat.rich_content.has_link
  392|       |    } else {
  393|      0|        false
  394|       |    }
  395|      8|}
  396|       |
  397|     89|fn matches_any(label: &str, needles: &[&str]) -> bool {
  398|    305|    needles.iter().any(|needle| label.contains(needle))
                  ^89            ^89
  399|     89|}
  400|       |
  401|     17|fn column_tooltip(label: &str, policy: &ColumnPolicy) -> Option<String> {
  402|     17|    let description = match policy {
  403|      0|        ColumnPolicy::Auto => "Auto-sized column".to_string(),
  404|      4|        ColumnPolicy::Fixed { width, clip } => format!(
  405|      4|            "Fixed width {:.0}px{}",
  406|       |            width,
  407|      4|            if *clip { " (clipped)" } else { "" }
                                                           ^0
  408|       |        ),
  409|      5|        ColumnPolicy::Remainder { clip } => format!(
  410|      5|            "Shared remainder width{}",
  411|      5|            if *clip { " (clipped)" } else { "" }
                                     ^0
  412|       |        ),
  413|       |        ColumnPolicy::Resizable {
  414|      8|            min,
  415|      8|            preferred,
  416|      8|            clip,
  417|      8|        } => format!(
  418|      8|            "Resizable (min {:.0}px, start {:.0}px{})",
  419|       |            min,
  420|       |            preferred,
  421|      8|            if *clip { ", clipped" } else { "" }
                                     ^0
  422|       |        ),
  423|       |    };
  424|     17|    Some(format!("{label}: {description}"))
  425|     17|}
  426|       |
  427|      9|pub fn compute_column_stats(
  428|      9|    headers: &[Vec<InlineSpan>],
  429|      9|    rows: &[Vec<Vec<InlineSpan>>],
  430|      9|    max_samples: usize,
  431|      9|) -> Vec<ColumnStat> {
  432|      9|    let column_count = max(
  433|      9|        headers.len(),
  434|      9|        rows.iter().map(|row| row.len()).max().unwrap_or(0),
                                            ^6  ^6
  435|       |    );
  436|      9|    if column_count == 0 {
  437|      0|        return Vec::new();
  438|      9|    }
  439|       |
  440|      9|    let mut stats = vec![ColumnStat::default(); column_count];
  441|       |
  442|     20|    for (idx, header) in headers.iter().enumerate() {
                                       ^9      ^9     ^9
  443|     20|        accumulate_stats_for_cell(header, &mut stats[idx]);
  444|     20|    }
  445|       |
  446|      9|    let mut sampled_rows = 0;
  447|      9|    for row in rows.iter() {
                      ^6
  448|     12|        for (idx, cell) in row.iter().enumerate().take(column_count) {
                                         ^6         ^6          ^6   ^6
  449|     12|            accumulate_stats_for_cell(cell, &mut stats[idx]);
  450|     12|        }
  451|      6|        sampled_rows += 1;
  452|      6|        if sampled_rows >= max_samples {
  453|      0|            break;
  454|      6|        }
  455|       |    }
  456|       |
  457|      9|    stats
  458|      9|}
  459|       |
  460|     32|fn accumulate_stats_for_cell(spans: &[InlineSpan], stat: &mut ColumnStat) {
  461|     32|    if stat.rich_content.has_image {
  462|      0|        // rich-content flags persist; skip repeated scans for pure images.
  463|     32|    }
  464|     32|    let mut has_link = stat.rich_content.has_link;
  465|     32|    let mut has_image = stat.rich_content.has_image;
  466|     32|    let mut has_emoji_like = stat.rich_content.has_emoji_like;
  467|       |
  468|     64|    for span in spans {
                      ^32
  469|     32|        match span {
  470|      0|            InlineSpan::Link { .. } => has_link = true,
  471|      0|            InlineSpan::Image { .. } => has_image = true,
  472|     32|            _ => {}
  473|       |        }
  474|       |    }
  475|       |
  476|     32|    let text = spans_to_text(spans);
  477|     32|    if !text.is_empty() {
  478|     32|        let graphemes = text.graphemes(true).count();
  479|     32|        let display_width = UnicodeWidthStr::width(text.as_str());
  480|     32|        stat.max_graphemes = stat.max_graphemes.max(display_width.max(graphemes));
  481|       |
  482|     68|        for word in text.split_whitespace() {
                                  ^32  ^32
  483|     68|            let word_len = UnicodeWidthStr::width(word).max(word.graphemes(true).count());
  484|     68|            stat.longest_word = stat.longest_word.max(word_len);
  485|     68|        }
  486|       |
  487|     32|        if !has_emoji_like {
  488|    392|            has_emoji_like = text.chars().any(|c| matches!(c as u32, 0x1F300..=0x1FAFF));
                                           ^32          ^32                        ^1
  489|      0|        }
  490|      0|    }
  491|       |
  492|     32|    stat.rich_content = RichContentFlags {
  493|     32|        has_link,
  494|     32|        has_image,
  495|     32|        has_emoji_like,
  496|     32|    };
  497|     32|}
  498|       |
  499|     32|fn spans_to_text(spans: &[InlineSpan]) -> String {
  500|     32|    let mut text = String::new();
  501|     64|    for span in spans {
                      ^32
  502|     32|        match span {
  503|     32|            InlineSpan::Text(t)
  504|      0|            | InlineSpan::Code(t)
  505|      0|            | InlineSpan::Strong(t)
  506|      0|            | InlineSpan::Emphasis(t)
  507|      0|            | InlineSpan::Strikethrough(t) => {
  508|     32|                if !text.is_empty() {
  509|      0|                    text.push(' ');
  510|     32|                }
  511|     32|                text.push_str(t);
  512|       |            }
  513|      0|            InlineSpan::Link { text: t, .. } => {
  514|      0|                if !text.is_empty() {
  515|      0|                    text.push(' ');
  516|      0|                }
  517|      0|                text.push_str(t);
  518|       |            }
  519|      0|            InlineSpan::Image { alt, .. } => {
  520|      0|                if !text.is_empty() {
  521|      0|                    text.push(' ');
  522|      0|                }
  523|      0|                text.push_str(alt);
  524|       |            }
  525|       |        }
  526|       |    }
  527|     32|    text.trim().to_string()
  528|     32|}
  529|       |
  530|       |#[cfg(test)]
  531|       |mod tests {
  532|       |    use super::*;
  533|       |
  534|     26|    fn span(text: &str) -> InlineSpan {
  535|     26|        InlineSpan::Text(text.to_string())
  536|     26|    }
  537|       |
  538|       |    #[test]
  539|      1|    fn classify_version_column() {
  540|      1|        let headers = vec![vec![span("Version")], vec![span("Changes")]];
  541|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  542|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  543|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  544|      1|        let specs = derive_column_specs(&ctx);
  545|      1|        assert!(
  546|      1|            matches!(specs[0].policy, ColumnPolicy::Fixed { .. }),
                          ^0
  547|      0|            "policy = {:?}",
  548|      0|            specs[0].policy
  549|       |        );
  550|      1|        assert!(
  551|      1|            matches!(specs[1].policy, ColumnPolicy::Remainder { .. }),
                          ^0
  552|      0|            "policy = {:?}",
  553|      0|            specs[1].policy
  554|       |        );
  555|      1|    }
  556|       |
  557|       |    #[test]
  558|      1|    fn classify_author_column() {
  559|      1|        let headers = vec![vec![span("Author")], vec![span("Examples")]];
  560|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  561|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  562|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  563|      1|        let specs = derive_column_specs(&ctx);
  564|      1|        assert!(
  565|      1|            matches!(specs[0].policy, ColumnPolicy::Resizable { .. }),
                          ^0
  566|      0|            "policy = {:?}",
  567|      0|            specs[0].policy
  568|       |        );
  569|      1|        assert!(
  570|      1|            matches!(specs[1].policy, ColumnPolicy::Remainder { .. }),
                          ^0
  571|      0|            "policy = {:?}",
  572|      0|            specs[1].policy
  573|       |        );
  574|      1|    }
  575|       |
  576|       |    #[test]
  577|      1|    fn classify_examples_column() {
  578|      1|        let headers = vec![
  579|      1|            vec![span("Element")],
  580|      1|            vec![span("Symbol")],
  581|      1|            vec![span("Description")],
  582|      1|            vec![span("Examples")],
  583|       |        ];
  584|      1|        assert_eq!(header_text(&headers[3]), "Examples");
  585|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  586|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  587|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  588|      1|        let specs = derive_column_specs(&ctx);
  589|      1|        assert!(
  590|      1|            matches!(specs[3].policy, ColumnPolicy::Remainder { .. }),
                          ^0
  591|      0|            "policy = {:?}",
  592|      0|            specs[3].policy
  593|       |        );
  594|      1|        assert!(
  595|      1|            matches!(specs[2].policy, ColumnPolicy::Resizable { .. }),
                          ^0
  596|      0|            "policy = {:?}",
  597|      0|            specs[2].policy
  598|       |        );
  599|      1|    }
  600|       |
  601|       |    #[test]
  602|      1|    fn compute_stats_counts_text() {
  603|      1|        let headers = vec![vec![span("Head")]];
  604|      1|        let rows = vec![vec![vec![span("Emoji  test")]]];
  605|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  606|      1|        assert_eq!(stats.len(), 1);
  607|      1|        assert!(stats[0].max_graphemes >= 4);
  608|      1|        assert!(stats[0].longest_word >= 5);
  609|      1|        assert!(stats[0].rich_content.has_emoji_like);
  610|      1|    }
  611|       |
  612|       |    #[test]
  613|      1|    fn fallback_assigns_remainder_based_on_stats() {
  614|      1|        let headers = vec![vec![span("Foo")], vec![span("Bar")]];
  615|      1|        let rows = vec![vec![
  616|      1|            vec![span("Short")],
  617|      1|            vec![span(
  618|      1|                "This column contains a very long sentence that should force remainder selection.",
  619|       |            )],
  620|       |        ]];
  621|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  622|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  623|      1|        let specs = derive_column_specs(&ctx);
  624|      1|        assert!(matches!(specs[1].policy, ColumnPolicy::Remainder { .. }));
                              ^0
  625|      1|    }
  626|       |
  627|       |    #[test]
  628|      1|    fn examples_header_prefers_remainder() {
  629|      1|        let headers = vec![vec![span("Examples")], vec![span("Description")]];
  630|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  631|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  632|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 16.0, 0);
  633|      1|        let specs = derive_column_specs(&ctx);
  634|      1|        assert!(matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
                              ^0
  635|      1|        assert!(matches!(specs[1].policy, ColumnPolicy::Resizable { .. }));
                              ^0
  636|      1|    }
  637|       |
  638|       |    #[test]
  639|      1|    fn multiple_remainder_columns_allowed() {
  640|      1|        let headers = vec![
  641|      1|            vec![span("Summary")],
  642|      1|            vec![span("Details")],
  643|      1|            vec![span("Examples")],
  644|       |        ];
  645|      1|        let rows = vec![vec![
  646|      1|            vec![span("short")],
  647|      1|            vec![span(
  648|      1|                "Long content that should trigger a remainder column due to its width and words.",
  649|       |            )],
  650|      1|            vec![span(
  651|      1|                "Another large column with links https://example.com and more text.",
  652|       |            )],
  653|       |        ]];
  654|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  655|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  656|      1|        let specs = derive_column_specs(&ctx);
  657|      1|        let remainder_count = specs
  658|      1|            .iter()
  659|      3|            .filter(|s| matches!(s.policy, ColumnPolicy::Remainder { .. }))
                           ^1
  660|      1|            .count();
  661|      1|        assert!(
  662|      1|            remainder_count >= 2,
  663|      0|            "should allow multiple remainder columns, got {remainder_count}"
  664|       |        );
  665|      1|    }
  666|       |
  667|       |    #[test]
  668|      1|    fn cjk_widths_increase_stat_estimates() {
  669|      1|        let headers = vec![vec![span("")], vec![span("Column")]];
  670|      1|        let rows = vec![vec![vec![span("")], vec![span("short")]]];
  671|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  672|      1|        assert!(stats[0].max_graphemes > stats[1].max_graphemes);
  673|      1|    }
  674|       |}

C:\language\mdmdview\src\table_support\metrics.rs:
    1|       |use std::collections::HashMap;
    2|       |
    3|       |#[allow(dead_code)]
    4|       |#[derive(Debug, Default, Clone)]
    5|       |pub struct RowMetrics {
    6|       |    pub max_height: f32,
    7|       |    pub dirty: bool,
    8|       |}
    9|       |
   10|       |#[allow(dead_code)]
   11|       |#[derive(Debug, Default, Clone)]
   12|       |pub struct TableMetricEntry {
   13|       |    pub rows: Vec<RowMetrics>,
   14|       |    pub rendered_rows: usize,
   15|       |    pub total_rows: usize,
   16|       |    pub resolved_widths: Vec<f32>,
   17|       |    pub last_width_frame: u64,
   18|       |    pub last_discard_frame: Option<u64>,
   19|       |    pub persisted_column_widths: HashMap<u64, f32>,
   20|       |    pub pending_user_resize: Option<PendingResize>,
   21|       |    /// Font size when widths were last persisted. Used to invalidate
   22|       |    /// persisted widths when zoom level changes.
   23|       |    pub persisted_font_size: Option<f32>,
   24|       |}
   25|       |
   26|       |#[derive(Debug, Clone, Copy)]
   27|       |pub struct PendingResize {
   28|       |    pub column_hash: u64,
   29|       |    pub width: f32,
   30|       |}
   31|       |
   32|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   33|       |pub enum WidthChange {
   34|       |    None,
   35|       |    Small,
   36|       |    Large,
   37|       |}
   38|       |
   39|       |const WIDTH_EPSILON: f32 = 0.15;
   40|       |const WIDTH_LARGE_DELTA: f32 = 0.75;
   41|       |
   42|       |impl TableMetricEntry {
   43|      3|    pub fn ensure_row(&mut self, index: usize) -> &mut RowMetrics {
   44|      3|        if index >= self.rows.len() {
   45|      3|            self.rows.resize_with(index + 1, RowMetrics::default);
   46|      3|        }
                      ^0
   47|      3|        &mut self.rows[index]
   48|      3|    }
   49|       |
   50|      5|    pub fn row(&self, index: usize) -> Option<&RowMetrics> {
   51|      5|        self.rows.get(index)
   52|      5|    }
   53|       |
   54|      4|    pub fn begin_pass(&mut self, total_rows: usize) {
   55|      4|        self.total_rows = total_rows;
   56|      4|        self.rendered_rows = 0;
   57|      4|    }
   58|       |
   59|      7|    pub fn note_row_rendered(&mut self) {
   60|      7|        self.rendered_rows += 1;
   61|      7|    }
   62|       |
   63|     15|    pub fn persisted_width(&self, key: u64) -> Option<f32> {
   64|     15|        self.persisted_column_widths.get(&key).copied()
   65|     15|    }
   66|       |
   67|      5|    pub fn set_persisted_width(&mut self, key: u64, width: f32) {
   68|      5|        self.persisted_column_widths.insert(key, width);
   69|      5|    }
   70|       |
   71|      1|    pub fn remove_persisted_width(&mut self, key: u64) {
   72|      1|        self.persisted_column_widths.remove(&key);
   73|      1|    }
   74|       |
   75|      7|    pub fn update_widths(&mut self, widths: &[f32], frame_id: u64) -> WidthChange {
   76|      7|        if widths.is_empty() {
   77|      1|            self.resolved_widths.clear();
   78|      1|            self.last_width_frame = frame_id;
   79|      1|            return WidthChange::None;
   80|      6|        }
   81|       |
   82|      6|        let first_update = self.resolved_widths.is_empty();
   83|      6|        let mut change = WidthChange::None;
   84|      6|        if !first_update && self.resolved_widths.len() != widths.len() {
                                          ^3                   ^3
   85|      1|            change = WidthChange::Large;
   86|      1|        } else {
   87|      5|            for (old, new) in self.resolved_widths.iter().zip(widths.iter()) {
                               ^3   ^3
   88|      3|                let delta = (old - new).abs();
   89|      3|                if delta > WIDTH_LARGE_DELTA {
   90|      1|                    change = WidthChange::Large;
   91|      1|                    break;
   92|      2|                }
   93|      2|                if delta > WIDTH_EPSILON {
   94|      2|                    change = WidthChange::Small;
   95|      2|                }
                              ^0
   96|       |            }
   97|       |        }
   98|       |
   99|      6|        self.resolved_widths.clear();
  100|      6|        self.resolved_widths.extend_from_slice(widths);
  101|      6|        self.last_width_frame = frame_id;
  102|       |
  103|      6|        change
  104|      7|    }
  105|       |
  106|      1|    pub fn current_widths(&self) -> &[f32] {
  107|      1|        &self.resolved_widths
  108|      1|    }
  109|       |
  110|       |    /// Check if font size has changed since widths were last persisted.
  111|       |    /// If so, clear all persisted widths and update the stored font size.
  112|       |    /// Returns true if widths were cleared.
  113|      7|    pub fn check_font_size_change(&mut self, current_font_size: f32) -> bool {
  114|       |        const FONT_SIZE_EPSILON: f32 = 0.5;
  115|      7|        if let Some(stored_font) = self.persisted_font_size {
                                  ^4
  116|      4|            if (stored_font - current_font_size).abs() > FONT_SIZE_EPSILON {
  117|      2|                self.persisted_column_widths.clear();
  118|      2|                self.persisted_font_size = Some(current_font_size);
  119|      2|                return true;
  120|      2|            }
  121|      3|        } else {
  122|      3|            self.persisted_font_size = Some(current_font_size);
  123|      3|        }
  124|      5|        false
  125|      7|    }
  126|       |}
  127|       |
  128|       |#[allow(dead_code)]
  129|       |#[derive(Debug, Default, Clone)]
  130|       |pub struct TableMetrics {
  131|       |    tables: HashMap<u64, TableMetricEntry>,
  132|       |}
  133|       |
  134|       |impl TableMetrics {
  135|     16|    pub fn entry_mut(&mut self, table_id: u64) -> &mut TableMetricEntry {
  136|     16|        self.tables.entry(table_id).or_default()
  137|     16|    }
  138|       |
  139|      6|    pub fn entry(&self, table_id: u64) -> Option<&TableMetricEntry> {
  140|      6|        self.tables.get(&table_id)
  141|      6|    }
  142|       |
  143|      6|    pub fn totals(&self) -> (usize, usize) {
  144|      6|        self.tables
  145|      6|            .values()
  146|      6|            .fold((0, 0), |(rendered, total), entry| {
                                                                   ^3
  147|      3|                (rendered + entry.rendered_rows, total + entry.total_rows)
  148|      3|            })
  149|      6|    }
  150|       |
  151|    138|    pub fn clear(&mut self) {
  152|    138|        self.tables.clear();
  153|    138|    }
  154|       |}
  155|       |
  156|       |#[allow(dead_code)]
  157|       |#[derive(Debug, Default, Clone)]
  158|       |pub struct CacheStats {
  159|       |    pub hits: u64,
  160|       |    pub misses: u64,
  161|       |}
  162|       |
  163|       |impl CacheStats {
  164|      2|    pub fn record_hit(&mut self) {
  165|      2|        self.hits += 1;
  166|      2|    }
  167|       |
  168|      1|    pub fn record_miss(&mut self) {
  169|      1|        self.misses += 1;
  170|      1|    }
  171|       |}
  172|       |
  173|       |#[cfg(test)]
  174|       |mod tests {
  175|       |    use super::*;
  176|       |
  177|       |    #[test]
  178|      1|    fn update_widths_detects_large_change() {
  179|      1|        let mut entry = TableMetricEntry::default();
  180|      1|        assert_eq!(entry.update_widths(&[100.0, 120.0], 1), WidthChange::None);
  181|      1|        assert_eq!(entry.update_widths(&[100.2, 120.6], 2), WidthChange::Small);
  182|      1|        assert_eq!(entry.update_widths(&[140.0, 120.6], 3), WidthChange::Large);
  183|      1|    }
  184|       |
  185|       |    #[test]
  186|      1|    fn font_size_change_clears_persisted_widths() {
  187|      1|        let mut entry = TableMetricEntry::default();
  188|       |
  189|       |        // Set some persisted widths at font size 14.0
  190|      1|        entry.set_persisted_width(1, 100.0);
  191|      1|        entry.set_persisted_width(2, 150.0);
  192|      1|        assert!(!entry.check_font_size_change(14.0)); // First call sets baseline
  193|      1|        assert_eq!(entry.persisted_width(1), Some(100.0));
  194|      1|        assert_eq!(entry.persisted_width(2), Some(150.0));
  195|       |
  196|       |        // Small font size change (within epsilon) should NOT clear
  197|      1|        assert!(!entry.check_font_size_change(14.3));
  198|      1|        assert_eq!(entry.persisted_width(1), Some(100.0));
  199|       |
  200|       |        // Large font size change should clear all persisted widths
  201|      1|        assert!(entry.check_font_size_change(16.0));
  202|      1|        assert_eq!(entry.persisted_width(1), None);
  203|      1|        assert_eq!(entry.persisted_width(2), None);
  204|      1|        assert_eq!(entry.persisted_font_size, Some(16.0));
  205|      1|    }
  206|       |
  207|       |    #[test]
  208|      1|    fn row_management_tracks_rows_and_rendered_counts() {
  209|      1|        let mut entry = TableMetricEntry::default();
  210|      1|        entry.begin_pass(3);
  211|      1|        assert_eq!(entry.total_rows, 3);
  212|      1|        assert_eq!(entry.rendered_rows, 0);
  213|       |
  214|      1|        let row = entry.ensure_row(2);
  215|      1|        row.max_height = 12.0;
  216|      1|        row.dirty = true;
  217|       |
  218|      1|        assert_eq!(entry.row(2).map(|r| r.max_height), Some(12.0));
  219|      1|        assert_eq!(entry.row(2).map(|r| r.dirty), Some(true));
  220|      1|        assert!(entry.row(5).is_none());
  221|       |
  222|      1|        entry.note_row_rendered();
  223|      1|        entry.note_row_rendered();
  224|      1|        assert_eq!(entry.rendered_rows, 2);
  225|      1|    }
  226|       |
  227|       |    #[test]
  228|      1|    fn persisted_widths_can_be_added_and_removed() {
  229|      1|        let mut entry = TableMetricEntry::default();
  230|      1|        assert!(entry.persisted_width(10).is_none());
  231|      1|        entry.set_persisted_width(10, 123.0);
  232|      1|        assert_eq!(entry.persisted_width(10), Some(123.0));
  233|      1|        entry.remove_persisted_width(10);
  234|      1|        assert!(entry.persisted_width(10).is_none());
  235|      1|    }
  236|       |
  237|       |    #[test]
  238|      1|    fn update_widths_handles_empty_and_length_change() {
  239|      1|        let mut entry = TableMetricEntry::default();
  240|      1|        assert_eq!(entry.update_widths(&[], 1), WidthChange::None);
  241|      1|        assert!(entry.current_widths().is_empty());
  242|       |
  243|      1|        assert_eq!(entry.update_widths(&[50.0, 60.0], 2), WidthChange::None);
  244|      1|        assert_eq!(entry.update_widths(&[50.0], 3), WidthChange::Large);
  245|      1|    }
  246|       |
  247|       |    #[test]
  248|      1|    fn table_metrics_totals_and_clear() {
  249|      1|        let mut metrics = TableMetrics::default();
  250|      1|        metrics.entry_mut(1).begin_pass(2);
  251|      1|        metrics.entry_mut(1).note_row_rendered();
  252|      1|        metrics.entry_mut(2).begin_pass(3);
  253|      1|        metrics.entry_mut(2).note_row_rendered();
  254|      1|        metrics.entry_mut(2).note_row_rendered();
  255|       |
  256|      1|        assert_eq!(metrics.totals(), (3, 5));
  257|      1|        metrics.clear();
  258|      1|        assert!(metrics.entry(1).is_none());
  259|      1|    }
  260|       |
  261|       |    #[test]
  262|      1|    fn cache_stats_counts_hits_and_misses() {
  263|      1|        let mut stats = CacheStats::default();
  264|      1|        stats.record_hit();
  265|      1|        stats.record_hit();
  266|      1|        stats.record_miss();
  267|      1|        assert_eq!(stats.hits, 2);
  268|      1|        assert_eq!(stats.misses, 1);
  269|      1|    }
  270|       |}

C:\language\mdmdview\src\window_state.rs:
    1|       |use std::fs;
    2|       |use std::io::{Read, Write};
    3|       |use std::path::PathBuf;
    4|       |
    5|       |#[derive(Debug, Clone, Copy)]
    6|       |pub struct WindowState {
    7|       |    pub pos: [f32; 2],
    8|       |    pub size: [f32; 2],
    9|       |    pub maximized: bool,
   10|       |}
   11|       |
   12|      3|fn config_dir() -> Option<PathBuf> {
   13|       |    // Crossplatform config dir without extra deps
   14|       |    #[cfg(target_os = "windows")]
   15|       |    {
   16|      3|        if let Ok(appdata) = std::env::var("APPDATA") {
   17|      3|            let mut p = PathBuf::from(appdata);
   18|      3|            p.push("MarkdownView");
   19|      3|            return Some(p);
   20|      0|        }
   21|       |    }
   22|       |
   23|       |    #[cfg(target_os = "macos")]
   24|       |    {
   25|       |        if let Ok(home) = std::env::var("HOME") {
   26|       |            let mut p = PathBuf::from(home);
   27|       |            p.push("Library/Application Support/MarkdownView");
   28|       |            return Some(p);
   29|       |        }
   30|       |    }
   31|       |
   32|       |    // Linux / others: XDG or ~/.config
   33|      0|    if let Ok(xdg) = std::env::var("XDG_CONFIG_HOME") {
   34|      0|        let mut p = PathBuf::from(xdg);
   35|      0|        p.push("mdmdview");
   36|      0|        return Some(p);
   37|      0|    }
   38|      0|    if let Ok(home) = std::env::var("HOME") {
   39|      0|        let mut p = PathBuf::from(home);
   40|      0|        p.push(".config/mdmdview");
   41|      0|        return Some(p);
   42|      0|    }
   43|      0|    None
   44|      3|}
   45|       |
   46|      2|fn state_path() -> Option<PathBuf> {
   47|      2|    config_dir().map(|mut dir| {
   48|      2|        dir.push("window_state.txt");
   49|      2|        dir
   50|      2|    })
   51|      2|}
   52|       |
   53|      2|pub fn load_window_state() -> Option<WindowState> {
   54|       |    #[cfg(windows)]
   55|       |    {
   56|      2|        if let Some(ws) = load_window_state_registry() {
                                  ^0
   57|      0|            return Some(ws);
   58|      2|        }
   59|       |    }
   60|      2|    let path = state_path()?;
                                         ^0
   61|      2|    let mut f = fs::File::open(path).ok()?;
                                                       ^0
   62|      2|    let mut s = String::new();
   63|      2|    f.read_to_string(&mut s).ok()?;
                                               ^0
   64|       |    // expected format: "x y w h max"
   65|      2|    let parts: Vec<&str> = s.split_whitespace().collect();
   66|      2|    if parts.len() < 5 {
   67|      1|        return None;
   68|      1|    }
   69|      1|    let x = parts[0].parse::<f32>().ok()?;
                                                      ^0
   70|      1|    let y = parts[1].parse::<f32>().ok()?;
                                                      ^0
   71|      1|    let w = parts[2].parse::<f32>().ok()?;
                                                      ^0
   72|      1|    let h = parts[3].parse::<f32>().ok()?;
                                                      ^0
   73|      1|    let max = matches!(parts[4], "1" | "true" | "True");
                            ^0
   74|      1|    Some(WindowState {
   75|      1|        pos: [x, y],
   76|      1|        size: [w, h],
   77|      1|        maximized: max,
   78|      1|    })
   79|      2|}
   80|       |
   81|      1|pub fn save_window_state(state: &WindowState) -> std::io::Result<()> {
   82|       |    #[cfg(windows)]
   83|       |    {
   84|      1|        if let Err(e) = save_window_state_registry(state) {
                                 ^0
   85|      0|            eprintln!("Failed to write window state to registry: {e}");
   86|      1|        }
   87|       |    }
   88|      1|    if let Some(mut dir) = config_dir() {
   89|      1|        if !dir.exists() {
   90|      1|            fs::create_dir_all(&dir)?;
                                                  ^0
   91|      0|        }
   92|      1|        dir.push("window_state.txt");
   93|      1|        let mut f = fs::File::create(&dir)?;
                                                        ^0
   94|       |        // simple whitespace separated format
   95|      1|        writeln!(
   96|      1|            f,
   97|      1|            "{} {} {} {} {}",
   98|      1|            state.pos[0], state.pos[1], state.size[0], state.size[1], state.maximized as u8
   99|      0|        )?;
  100|      0|    }
  101|      1|    Ok(())
  102|      1|}
  103|       |
  104|      2|pub fn sanitize_window_state(ws: WindowState) -> Option<WindowState> {
  105|       |    // Basic sanity: finite values
  106|      2|    if !ws.pos[0].is_finite()
  107|      1|        || !ws.pos[1].is_finite()
  108|      1|        || !ws.size[0].is_finite()
  109|      1|        || !ws.size[1].is_finite()
  110|       |    {
  111|      1|        return None;
  112|      1|    }
  113|       |
  114|       |    // Clamp to reasonable ranges
  115|      1|    let min_w = 600.0f32;
  116|      1|    let min_h = 400.0f32;
  117|      1|    let max_w = 10000.0f32;
  118|      1|    let max_h = 10000.0f32;
  119|      1|    let max_pos = 20000.0f32; // avoid absurdly large coordinates
  120|       |
  121|      1|    let w = ws.size[0].clamp(min_w, max_w);
  122|      1|    let h = ws.size[1].clamp(min_h, max_h);
  123|      1|    let x = ws.pos[0].max(0.0).min(max_pos);
  124|      1|    let y = ws.pos[1].max(0.0).min(max_pos);
  125|       |
  126|      1|    Some(WindowState {
  127|      1|        pos: [x, y],
  128|      1|        size: [w, h],
  129|      1|        maximized: ws.maximized,
  130|      1|    })
  131|      2|}
  132|       |
  133|       |#[cfg(all(windows, not(test)))]
  134|       |fn load_window_state_registry() -> Option<WindowState> {
  135|       |    use winreg::enums::HKEY_CURRENT_USER;
  136|       |    use winreg::RegKey;
  137|       |    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  138|       |    let key = hkcu.open_subkey("Software\\MarkdownView").ok()?;
  139|       |    let x: u32 = key.get_value("PosX").ok()?;
  140|       |    let y: u32 = key.get_value("PosY").ok()?;
  141|       |    let w: u32 = key.get_value("Width").ok()?;
  142|       |    let h: u32 = key.get_value("Height").ok()?;
  143|       |    let maximized: u32 = key.get_value("Maximized").unwrap_or(0);
  144|       |    Some(WindowState {
  145|       |        pos: [x as f32, y as f32],
  146|       |        size: [w as f32, h as f32],
  147|       |        maximized: maximized != 0,
  148|       |    })
  149|       |}
  150|       |
  151|       |#[cfg(all(windows, not(test)))]
  152|       |fn save_window_state_registry(state: &WindowState) -> std::io::Result<()> {
  153|       |    use winreg::enums::{HKEY_CURRENT_USER, KEY_READ, KEY_WRITE};
  154|       |    use winreg::RegKey;
  155|       |    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  156|       |    let (key, _disp) =
  157|       |        hkcu.create_subkey_with_flags("Software\\MarkdownView", KEY_READ | KEY_WRITE)?;
  158|       |    let to_u32 = |v: f32| -> u32 {
  159|       |        if v.is_finite() {
  160|       |            v.max(0.0).min(u32::MAX as f32).round() as u32
  161|       |        } else {
  162|       |            0
  163|       |        }
  164|       |    };
  165|       |    key.set_value("PosX", &to_u32(state.pos[0]))?;
  166|       |    key.set_value("PosY", &to_u32(state.pos[1]))?;
  167|       |    key.set_value("Width", &to_u32(state.size[0]))?;
  168|       |    key.set_value("Height", &to_u32(state.size[1]))?;
  169|       |    key.set_value("Maximized", &(state.maximized as u32))?;
  170|       |    Ok(())
  171|       |}
  172|       |
  173|       |#[cfg(all(windows, test))]
  174|      2|fn load_window_state_registry() -> Option<WindowState> {
  175|      2|    None
  176|      2|}
  177|       |
  178|       |#[cfg(all(windows, test))]
  179|      1|fn save_window_state_registry(_state: &WindowState) -> std::io::Result<()> {
  180|      1|    Ok(())
  181|      1|}
  182|       |
  183|       |#[cfg(test)]
  184|       |mod tests {
  185|       |    use super::*;
  186|       |    use tempfile::TempDir;
  187|       |
  188|       |    struct EnvGuard {
  189|       |        key: &'static str,
  190|       |        original: Option<String>,
  191|       |    }
  192|       |
  193|       |    impl EnvGuard {
  194|      2|        fn set(key: &'static str, value: &str) -> Self {
  195|      2|            let original = std::env::var(key).ok();
  196|      2|            std::env::set_var(key, value);
  197|      2|            Self { key, original }
  198|      2|        }
  199|       |    }
  200|       |
  201|       |    impl Drop for EnvGuard {
  202|      2|        fn drop(&mut self) {
  203|      2|            if let Some(value) = &self.original {
  204|      2|                std::env::set_var(self.key, value);
  205|      2|            } else {
  206|      0|                std::env::remove_var(self.key);
  207|      0|            }
  208|      2|        }
  209|       |    }
  210|       |
  211|       |    #[test]
  212|      1|    fn test_sanitize_window_state_clamps_and_rejects_invalid() {
  213|      1|        let invalid = WindowState {
  214|      1|            pos: [f32::NAN, 10.0],
  215|      1|            size: [800.0, 600.0],
  216|      1|            maximized: false,
  217|      1|        };
  218|      1|        assert!(sanitize_window_state(invalid).is_none());
  219|       |
  220|      1|        let input = WindowState {
  221|      1|            pos: [-50.0, 25000.0],
  222|      1|            size: [100.0, 200.0],
  223|      1|            maximized: true,
  224|      1|        };
  225|      1|        let sanitized = sanitize_window_state(input).expect("expected sanitized state");
  226|      1|        assert_eq!(sanitized.pos[0], 0.0);
  227|      1|        assert_eq!(sanitized.pos[1], 20000.0);
  228|      1|        assert_eq!(sanitized.size[0], 600.0);
  229|      1|        assert_eq!(sanitized.size[1], 400.0);
  230|      1|        assert!(sanitized.maximized);
  231|      1|    }
  232|       |
  233|       |    #[test]
  234|      1|    fn test_save_and_load_window_state_from_file() {
  235|      1|        let temp = TempDir::new().expect("temp dir");
  236|      1|        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  237|       |
  238|      1|        let state = WindowState {
  239|      1|            pos: [120.0, 80.0],
  240|      1|            size: [1024.0, 768.0],
  241|      1|            maximized: false,
  242|      1|        };
  243|      1|        save_window_state(&state).expect("save");
  244|       |
  245|      1|        let loaded = load_window_state().expect("load");
  246|      1|        assert_eq!(loaded.pos, state.pos);
  247|      1|        assert_eq!(loaded.size, state.size);
  248|      1|        assert_eq!(loaded.maximized, state.maximized);
  249|      1|    }
  250|       |
  251|       |    #[test]
  252|      1|    fn test_load_window_state_rejects_bad_file() {
  253|      1|        let temp = TempDir::new().expect("temp dir");
  254|      1|        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  255|       |
  256|      1|        let mut config = temp.path().join("MarkdownView");
  257|      1|        std::fs::create_dir_all(&config).expect("create config dir");
  258|      1|        config.push("window_state.txt");
  259|      1|        std::fs::write(&config, "10 20 30").expect("write bad data");
  260|       |
  261|      1|        assert!(load_window_state().is_none());
  262|      1|    }
  263|       |}

c:\language\mdmdview\target\llvm-cov-target\debug\build\glutin_egl_sys-dcef47d8a173377f\out\egl_bindings.rs:
    1|       |
    2|       |        mod __gl_imports {
    3|       |            pub use std::mem;
    4|       |            pub use std::marker::Send;
    5|       |            pub use std::os::raw;
    6|       |        }
    7|       |    
    8|       |
    9|       |        pub mod types {
   10|       |            #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)]
   11|       |    
   12|       |// platform-specific aliases are unknown
   13|       |// IMPORTANT: these are alises to the same level of the bindings
   14|       |// the values must be defined by the user
   15|       |#[allow(dead_code)]
   16|       |pub type khronos_utime_nanoseconds_t = super::khronos_utime_nanoseconds_t;
   17|       |#[allow(dead_code)]
   18|       |pub type khronos_uint64_t = super::khronos_uint64_t;
   19|       |#[allow(dead_code)]
   20|       |pub type khronos_ssize_t = super::khronos_ssize_t;
   21|       |pub type EGLNativeDisplayType = super::EGLNativeDisplayType;
   22|       |#[allow(dead_code)]
   23|       |pub type EGLNativePixmapType = super::EGLNativePixmapType;
   24|       |#[allow(dead_code)]
   25|       |pub type EGLNativeWindowType = super::EGLNativeWindowType;
   26|       |pub type EGLint = super::EGLint;
   27|       |#[allow(dead_code)]
   28|       |pub type NativeDisplayType = super::NativeDisplayType;
   29|       |#[allow(dead_code)]
   30|       |pub type NativePixmapType = super::NativePixmapType;
   31|       |#[allow(dead_code)]
   32|       |pub type NativeWindowType = super::NativeWindowType;
   33|       |
   34|       |// EGL alises
   35|       |pub type Bool = EGLBoolean; // TODO: not sure
   36|       |pub type EGLBoolean = super::__gl_imports::raw::c_uint;
   37|       |pub type EGLenum = super::__gl_imports::raw::c_uint;
   38|       |pub type EGLAttribKHR = isize;
   39|       |pub type EGLAttrib = isize;
   40|       |pub type EGLConfig = *const super::__gl_imports::raw::c_void;
   41|       |pub type EGLContext = *const super::__gl_imports::raw::c_void;
   42|       |pub type EGLDeviceEXT = *const super::__gl_imports::raw::c_void;
   43|       |pub type EGLDisplay = *const super::__gl_imports::raw::c_void;
   44|       |pub type EGLSurface = *const super::__gl_imports::raw::c_void;
   45|       |pub type EGLClientBuffer = *const super::__gl_imports::raw::c_void;
   46|       |pub enum __eglMustCastToProperFunctionPointerType_fn {}
   47|       |pub type __eglMustCastToProperFunctionPointerType =
   48|       |    *mut __eglMustCastToProperFunctionPointerType_fn;
   49|       |pub type EGLImageKHR = *const super::__gl_imports::raw::c_void;
   50|       |pub type EGLImage = *const super::__gl_imports::raw::c_void;
   51|       |pub type EGLOutputLayerEXT = *const super::__gl_imports::raw::c_void;
   52|       |pub type EGLOutputPortEXT = *const super::__gl_imports::raw::c_void;
   53|       |pub type EGLSyncKHR = *const super::__gl_imports::raw::c_void;
   54|       |pub type EGLSync = *const super::__gl_imports::raw::c_void;
   55|       |pub type EGLTimeKHR = khronos_utime_nanoseconds_t;
   56|       |pub type EGLTime = khronos_utime_nanoseconds_t;
   57|       |pub type EGLSyncNV = *const super::__gl_imports::raw::c_void;
   58|       |pub type EGLTimeNV = khronos_utime_nanoseconds_t;
   59|       |pub type EGLuint64NV = khronos_utime_nanoseconds_t;
   60|       |pub type EGLStreamKHR = *const super::__gl_imports::raw::c_void;
   61|       |pub type EGLuint64KHR = khronos_uint64_t;
   62|       |pub type EGLNativeFileDescriptorKHR = super::__gl_imports::raw::c_int;
   63|       |pub type EGLsizeiANDROID = khronos_ssize_t;
   64|       |pub type EGLSetBlobFuncANDROID = extern "system" fn(*const super::__gl_imports::raw::c_void,
   65|       |                                                    EGLsizeiANDROID,
   66|       |                                                    *const super::__gl_imports::raw::c_void,
   67|       |                                                    EGLsizeiANDROID)
   68|       |                                                    -> ();
   69|       |pub type EGLGetBlobFuncANDROID = extern "system" fn(*const super::__gl_imports::raw::c_void,
   70|       |                                                    EGLsizeiANDROID,
   71|       |                                                    *mut super::__gl_imports::raw::c_void,
   72|       |                                                    EGLsizeiANDROID)
   73|       |                                                    -> EGLsizeiANDROID;
   74|       |
   75|       |#[repr(C)]
   76|       |pub struct EGLClientPixmapHI {
   77|       |    pData: *const super::__gl_imports::raw::c_void,
   78|       |    iWidth: EGLint,
   79|       |    iHeight: EGLint,
   80|       |    iStride: EGLint,
   81|       |}
   82|       |
   83|       |}
   84|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT: types::EGLenum = 0x3088;
   85|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT_NONPRE: types::EGLenum = 0x308B;
   86|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT_PRE: types::EGLenum = 0x308C;
   87|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_MASK_SIZE: types::EGLenum = 0x303E;
   88|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_SIZE: types::EGLenum = 0x3021;
   89|       |#[allow(dead_code, non_upper_case_globals)] pub const BACK_BUFFER: types::EGLenum = 0x3084;
   90|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_ACCESS: types::EGLenum = 0x3002;
   91|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_ALLOC: types::EGLenum = 0x3003;
   92|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_ATTRIBUTE: types::EGLenum = 0x3004;
   93|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_CONFIG: types::EGLenum = 0x3005;
   94|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_CONTEXT: types::EGLenum = 0x3006;
   95|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_CURRENT_SURFACE: types::EGLenum = 0x3007;
   96|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_DEVICE_EXT: types::EGLenum = 0x322B;
   97|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_DISPLAY: types::EGLenum = 0x3008;
   98|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_MATCH: types::EGLenum = 0x3009;
   99|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_NATIVE_PIXMAP: types::EGLenum = 0x300A;
  100|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_NATIVE_WINDOW: types::EGLenum = 0x300B;
  101|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_PARAMETER: types::EGLenum = 0x300C;
  102|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_SURFACE: types::EGLenum = 0x300D;
  103|       |#[allow(dead_code, non_upper_case_globals)] pub const BIND_TO_TEXTURE_RGB: types::EGLenum = 0x3039;
  104|       |#[allow(dead_code, non_upper_case_globals)] pub const BIND_TO_TEXTURE_RGBA: types::EGLenum = 0x303A;
  105|       |#[allow(dead_code, non_upper_case_globals)] pub const BLUE_SIZE: types::EGLenum = 0x3022;
  106|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_AGE_EXT: types::EGLenum = 0x313D;
  107|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_DESTROYED: types::EGLenum = 0x3095;
  108|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_PRESERVED: types::EGLenum = 0x3094;
  109|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_SIZE: types::EGLenum = 0x3020;
  110|       |#[allow(dead_code, non_upper_case_globals)] pub const CLIENT_APIS: types::EGLenum = 0x308D;
  111|       |#[allow(dead_code, non_upper_case_globals)] pub const CL_EVENT_HANDLE: types::EGLenum = 0x309C;
  112|       |#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE: types::EGLenum = 0x3087;
  113|       |#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE_LINEAR: types::EGLenum = 0x308A;
  114|       |#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE_sRGB: types::EGLenum = 0x3089;
  115|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_BUFFER_TYPE: types::EGLenum = 0x303F;
  116|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_EXT: types::EGLenum = 0x3339;
  117|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_FIXED_EXT: types::EGLenum = 0x333A;
  118|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_FLOAT_EXT: types::EGLenum = 0x333B;
  119|       |#[allow(dead_code, non_upper_case_globals)] pub const CONDITION_SATISFIED: types::EGLenum = 0x30F6;
  120|       |#[allow(dead_code, non_upper_case_globals)] pub const CONFIG_CAVEAT: types::EGLenum = 0x3027;
  121|       |#[allow(dead_code, non_upper_case_globals)] pub const CONFIG_ID: types::EGLenum = 0x3028;
  122|       |#[allow(dead_code, non_upper_case_globals)] pub const CONFORMANT: types::EGLenum = 0x3042;
  123|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CLIENT_TYPE: types::EGLenum = 0x3097;
  124|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CLIENT_VERSION: types::EGLenum = 0x3098;
  125|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FLAGS_KHR: types::EGLenum = 0x30FC;
  126|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_LOST: types::EGLenum = 0x300E;
  127|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION: types::EGLenum = 0x3098;
  128|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION_KHR: types::EGLenum = 0x3098;
  129|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION: types::EGLenum = 0x30FB;
  130|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION_KHR: types::EGLenum = 0x30FB;
  131|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT: types::EGLenum = 0x00000002;
  132|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR: types::EGLenum = 0x00000002;
  133|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_CORE_PROFILE_BIT: types::EGLenum = 0x00000001;
  134|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR: types::EGLenum = 0x00000001;
  135|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_DEBUG: types::EGLenum = 0x31B0;
  136|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_DEBUG_BIT_KHR: types::EGLenum = 0x00000001;
  137|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_FORWARD_COMPATIBLE: types::EGLenum = 0x31B1;
  138|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR: types::EGLenum = 0x00000002;
  139|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_NO_ERROR_KHR: types::EGLenum = 0x31B3;
  140|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_PROFILE_MASK: types::EGLenum = 0x30FD;
  141|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_PROFILE_MASK_KHR: types::EGLenum = 0x30FD;
  142|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY: types::EGLenum = 0x31BD;
  143|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT: types::EGLenum = 0x3138;
  144|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR: types::EGLenum = 0x31BD;
  145|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS: types::EGLenum = 0x31B2;
  146|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR: types::EGLenum = 0x00000004;
  147|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS_EXT: types::EGLenum = 0x30BF;
  148|       |#[allow(dead_code, non_upper_case_globals)] pub const CORE_NATIVE_ENGINE: types::EGLenum = 0x305B;
  149|       |#[allow(dead_code, non_upper_case_globals)] pub const DEFAULT_DISPLAY: types::EGLNativeDisplayType = 0 as types::EGLNativeDisplayType;
  150|       |#[allow(dead_code, non_upper_case_globals)] pub const DEPTH_SIZE: types::EGLenum = 0x3025;
  151|       |#[allow(dead_code, non_upper_case_globals)] pub const DEVICE_EXT: types::EGLenum = 0x322C;
  152|       |#[allow(dead_code, non_upper_case_globals)] pub const DISPLAY_SCALING: types::EGLenum = 10000;
  153|       |#[allow(dead_code, non_upper_case_globals)] pub const DONT_CARE: types::EGLint = -1 as types::EGLint;
  154|       |#[allow(dead_code, non_upper_case_globals)] pub const DRAW: types::EGLenum = 0x3059;
  155|       |#[allow(dead_code, non_upper_case_globals)] pub const DRM_DEVICE_FILE_EXT: types::EGLenum = 0x3233;
  156|       |#[allow(dead_code, non_upper_case_globals)] pub const DRM_MASTER_FD_EXT: types::EGLenum = 0x333C;
  157|       |#[allow(dead_code, non_upper_case_globals)] pub const EXTENSIONS: types::EGLenum = 0x3055;
  158|       |#[allow(dead_code, non_upper_case_globals)] pub const FALSE: types::EGLBoolean = 0;
  159|       |#[allow(dead_code, non_upper_case_globals)] pub const FOREVER: types::EGLuint64KHR = 0xFFFFFFFFFFFFFFFF;
  160|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE: types::EGLenum = 0x309D;
  161|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE_LINEAR: types::EGLenum = 0x308A;
  162|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE_SRGB: types::EGLenum = 0x3089;
  163|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_RENDERBUFFER: types::EGLenum = 0x30B9;
  164|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_2D: types::EGLenum = 0x30B1;
  165|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_3D: types::EGLenum = 0x30B2;
  166|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_X: types::EGLenum = 0x30B4;
  167|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: types::EGLenum = 0x30B6;
  168|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: types::EGLenum = 0x30B8;
  169|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_X: types::EGLenum = 0x30B3;
  170|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Y: types::EGLenum = 0x30B5;
  171|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Z: types::EGLenum = 0x30B7;
  172|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_LEVEL: types::EGLenum = 0x30BC;
  173|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_ZOFFSET: types::EGLenum = 0x30BD;
  174|       |#[allow(dead_code, non_upper_case_globals)] pub const GREEN_SIZE: types::EGLenum = 0x3023;
  175|       |#[allow(dead_code, non_upper_case_globals)] pub const HEIGHT: types::EGLenum = 0x3056;
  176|       |#[allow(dead_code, non_upper_case_globals)] pub const HORIZONTAL_RESOLUTION: types::EGLenum = 0x3090;
  177|       |#[allow(dead_code, non_upper_case_globals)] pub const IMAGE_PRESERVED: types::EGLenum = 0x30D2;
  178|       |#[allow(dead_code, non_upper_case_globals)] pub const LARGEST_PBUFFER: types::EGLenum = 0x3058;
  179|       |#[allow(dead_code, non_upper_case_globals)] pub const LEVEL: types::EGLenum = 0x3029;
  180|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET: types::EGLenum = 0x31BF;
  181|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_EXT: types::EGLenum = 0x31BF;
  182|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_KHR: types::EGLenum = 0x31BF;
  183|       |#[allow(dead_code, non_upper_case_globals)] pub const LUMINANCE_BUFFER: types::EGLenum = 0x308F;
  184|       |#[allow(dead_code, non_upper_case_globals)] pub const LUMINANCE_SIZE: types::EGLenum = 0x303D;
  185|       |#[allow(dead_code, non_upper_case_globals)] pub const MATCH_NATIVE_PIXMAP: types::EGLenum = 0x3041;
  186|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_HEIGHT: types::EGLenum = 0x302A;
  187|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_PIXELS: types::EGLenum = 0x302B;
  188|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_WIDTH: types::EGLenum = 0x302C;
  189|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_SWAP_INTERVAL: types::EGLenum = 0x303C;
  190|       |#[allow(dead_code, non_upper_case_globals)] pub const MIN_SWAP_INTERVAL: types::EGLenum = 0x303B;
  191|       |#[allow(dead_code, non_upper_case_globals)] pub const MIPMAP_LEVEL: types::EGLenum = 0x3083;
  192|       |#[allow(dead_code, non_upper_case_globals)] pub const MIPMAP_TEXTURE: types::EGLenum = 0x3082;
  193|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE: types::EGLenum = 0x3099;
  194|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_BOX: types::EGLenum = 0x309B;
  195|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_BOX_BIT: types::EGLenum = 0x0200;
  196|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_DEFAULT: types::EGLenum = 0x309A;
  197|       |#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_RENDERABLE: types::EGLenum = 0x302D;
  198|       |#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_VISUAL_ID: types::EGLenum = 0x302E;
  199|       |#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_VISUAL_TYPE: types::EGLenum = 0x302F;
  200|       |#[allow(dead_code, non_upper_case_globals)] pub const NONE: types::EGLenum = 0x3038;
  201|       |#[allow(dead_code, non_upper_case_globals)] pub const NON_CONFORMANT_CONFIG: types::EGLenum = 0x3051;
  202|       |#[allow(dead_code, non_upper_case_globals)] pub const NOT_INITIALIZED: types::EGLenum = 0x3001;
  203|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_CONTEXT: types::EGLContext = 0 as types::EGLContext;
  204|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_DEVICE_EXT: types::EGLDeviceEXT = 0 as types::EGLDeviceEXT;
  205|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_DISPLAY: types::EGLDisplay = 0 as types::EGLDisplay;
  206|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_IMAGE: types::EGLImage = 0 as types::EGLImage;
  207|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_NATIVE_FENCE_FD_ANDROID: types::EGLint = -1;
  208|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION: types::EGLenum = 0x31BE;
  209|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_EXT: types::EGLenum = 0x31BE;
  210|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_KHR: types::EGLenum = 0x31BE;
  211|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_SURFACE: types::EGLSurface = 0 as types::EGLSurface;
  212|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_SYNC: types::EGLSync = 0 as types::EGLSync;
  213|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_TEXTURE: types::EGLenum = 0x305C;
  214|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_API: types::EGLenum = 0x30A2;
  215|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_BIT: types::EGLenum = 0x0008;
  216|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES2_BIT: types::EGLenum = 0x0004;
  217|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES3_BIT: types::EGLenum = 0x00000040;
  218|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES3_BIT_KHR: types::EGLenum = 0x00000040;
  219|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES_API: types::EGLenum = 0x30A0;
  220|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES_BIT: types::EGLenum = 0x0001;
  221|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_API: types::EGLenum = 0x30A1;
  222|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_BIT: types::EGLenum = 0x0002;
  223|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_IMAGE: types::EGLenum = 0x3096;
  224|       |#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER_BIT: types::EGLenum = 0x0001;
  225|       |#[allow(dead_code, non_upper_case_globals)] pub const PIXEL_ASPECT_RATIO: types::EGLenum = 0x3092;
  226|       |#[allow(dead_code, non_upper_case_globals)] pub const PIXMAP_BIT: types::EGLenum = 0x0002;
  227|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_ANDROID_KHR: types::EGLenum = 0x3141;
  228|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_DEVICE_EXT: types::EGLenum = 0x313F;
  229|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_GBM_KHR: types::EGLenum = 0x31D7;
  230|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_GBM_MESA: types::EGLenum = 0x31D7;
  231|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_WAYLAND_EXT: types::EGLenum = 0x31D8;
  232|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_WAYLAND_KHR: types::EGLenum = 0x31D8;
  233|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_EXT: types::EGLenum = 0x31D5;
  234|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_KHR: types::EGLenum = 0x31D5;
  235|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_SCREEN_EXT: types::EGLenum = 0x31D6;
  236|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_SCREEN_KHR: types::EGLenum = 0x31D6;
  237|       |#[allow(dead_code, non_upper_case_globals)] pub const READ: types::EGLenum = 0x305A;
  238|       |#[allow(dead_code, non_upper_case_globals)] pub const RED_SIZE: types::EGLenum = 0x3024;
  239|       |#[allow(dead_code, non_upper_case_globals)] pub const RENDERABLE_TYPE: types::EGLenum = 0x3040;
  240|       |#[allow(dead_code, non_upper_case_globals)] pub const RENDER_BUFFER: types::EGLenum = 0x3086;
  241|       |#[allow(dead_code, non_upper_case_globals)] pub const RGB_BUFFER: types::EGLenum = 0x308E;
  242|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLES: types::EGLenum = 0x3031;
  243|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLE_BUFFERS: types::EGLenum = 0x3032;
  244|       |#[allow(dead_code, non_upper_case_globals)] pub const SIGNALED: types::EGLenum = 0x30F2;
  245|       |#[allow(dead_code, non_upper_case_globals)] pub const SINGLE_BUFFER: types::EGLenum = 0x3085;
  246|       |#[allow(dead_code, non_upper_case_globals)] pub const SLOW_CONFIG: types::EGLenum = 0x3050;
  247|       |#[allow(dead_code, non_upper_case_globals)] pub const STENCIL_SIZE: types::EGLenum = 0x3026;
  248|       |#[allow(dead_code, non_upper_case_globals)] pub const SUCCESS: types::EGLenum = 0x3000;
  249|       |#[allow(dead_code, non_upper_case_globals)] pub const SURFACE_TYPE: types::EGLenum = 0x3033;
  250|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_BEHAVIOR: types::EGLenum = 0x3093;
  251|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_BEHAVIOR_PRESERVED_BIT: types::EGLenum = 0x0400;
  252|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CL_EVENT: types::EGLenum = 0x30FE;
  253|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CL_EVENT_COMPLETE: types::EGLenum = 0x30FF;
  254|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CONDITION: types::EGLenum = 0x30F8;
  255|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CONDITION_KHR: types::EGLenum = 0x30F8;
  256|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FENCE: types::EGLenum = 0x30F9;
  257|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FENCE_KHR: types::EGLenum = 0x30F9;
  258|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FLUSH_COMMANDS_BIT: types::EGLenum = 0x0001;
  259|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_ANDROID: types::EGLenum = 0x3144;
  260|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_FD_ANDROID: types::EGLenum = 0x3145;
  261|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_SIGNALED_ANDROID: types::EGLenum = 0x3146;
  262|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_PRIOR_COMMANDS_COMPLETE: types::EGLenum = 0x30F0;
  263|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_PRIOR_COMMANDS_COMPLETE_KHR: types::EGLenum = 0x30F0;
  264|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_STATUS: types::EGLenum = 0x30F1;
  265|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_TYPE: types::EGLenum = 0x30F7;
  266|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_2D: types::EGLenum = 0x305F;
  267|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_FORMAT: types::EGLenum = 0x3080;
  268|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_RGB: types::EGLenum = 0x305D;
  269|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_RGBA: types::EGLenum = 0x305E;
  270|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_TARGET: types::EGLenum = 0x3081;
  271|       |#[allow(dead_code, non_upper_case_globals)] pub const TIMEOUT_EXPIRED: types::EGLenum = 0x30F5;
  272|       |#[allow(dead_code, non_upper_case_globals)] pub const TRACK_REFERENCES_KHR: types::EGLenum = 0x3352;
  273|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_BLUE_VALUE: types::EGLenum = 0x3035;
  274|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_GREEN_VALUE: types::EGLenum = 0x3036;
  275|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RED_VALUE: types::EGLenum = 0x3037;
  276|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RGB: types::EGLenum = 0x3052;
  277|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_TYPE: types::EGLenum = 0x3034;
  278|       |#[allow(dead_code, non_upper_case_globals)] pub const TRUE: types::EGLBoolean = 1;
  279|       |#[allow(dead_code, non_upper_case_globals)] pub const UNKNOWN: types::EGLint = -1 as types::EGLint;
  280|       |#[allow(dead_code, non_upper_case_globals)] pub const UNSIGNALED: types::EGLenum = 0x30F3;
  281|       |#[allow(dead_code, non_upper_case_globals)] pub const VENDOR: types::EGLenum = 0x3053;
  282|       |#[allow(dead_code, non_upper_case_globals)] pub const VERSION: types::EGLenum = 0x3054;
  283|       |#[allow(dead_code, non_upper_case_globals)] pub const VERTICAL_RESOLUTION: types::EGLenum = 0x3091;
  284|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT: types::EGLenum = 0x3088;
  285|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_NONPRE: types::EGLenum = 0x308B;
  286|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_PRE: types::EGLenum = 0x308C;
  287|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_PRE_BIT: types::EGLenum = 0x0040;
  288|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE: types::EGLenum = 0x3087;
  289|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_LINEAR: types::EGLenum = 0x308A;
  290|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_LINEAR_BIT: types::EGLenum = 0x0020;
  291|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_sRGB: types::EGLenum = 0x3089;
  292|       |#[allow(dead_code, non_upper_case_globals)] pub const WIDTH: types::EGLenum = 0x3057;
  293|       |#[allow(dead_code, non_upper_case_globals)] pub const WINDOW_BIT: types::EGLenum = 0x0004;
  294|       |
  295|       |        #[allow(dead_code, missing_copy_implementations)]
  296|       |        #[derive(Clone)]
  297|       |        pub struct FnPtr {
  298|       |            /// The function pointer that will be used when calling the function.
  299|       |            f: *const __gl_imports::raw::c_void,
  300|       |            /// True if the pointer points to a real function, false if points to a `panic!` fn.
  301|       |            is_loaded: bool,
  302|       |        }
  303|       |
  304|       |        impl FnPtr {
  305|       |            /// Creates a `FnPtr` from a load attempt.
  306|      0|            fn new(ptr: *const __gl_imports::raw::c_void) -> FnPtr {
  307|      0|                if ptr.is_null() {
  308|      0|                    FnPtr {
  309|      0|                        f: missing_fn_panic as *const __gl_imports::raw::c_void,
  310|      0|                        is_loaded: false
  311|      0|                    }
  312|       |                } else {
  313|      0|                    FnPtr { f: ptr, is_loaded: true }
  314|       |                }
  315|      0|            }
  316|       |
  317|       |            /// Returns `true` if the function has been successfully loaded.
  318|       |            ///
  319|       |            /// If it returns `false`, calling the corresponding function will fail.
  320|       |            #[inline]
  321|       |            #[allow(dead_code)]
  322|      0|            pub fn is_loaded(&self) -> bool {
  323|      0|                self.is_loaded
  324|      0|            }
  325|       |        }
  326|       |    
  327|       |#[inline(never)]
  328|      0|        fn missing_fn_panic() -> ! {
  329|      0|            panic!("egl function was not loaded")
  330|       |        }
  331|       |
  332|       |        #[allow(non_camel_case_types, non_snake_case, dead_code)]
  333|       |        #[derive(Clone)]
  334|       |        pub struct Egl {
  335|       |pub BindAPI: FnPtr,
  336|       |pub BindTexImage: FnPtr,
  337|       |pub ChooseConfig: FnPtr,
  338|       |/// Fallbacks: ClientWaitSyncKHR
  339|       |pub ClientWaitSync: FnPtr,
  340|       |pub ClientWaitSyncKHR: FnPtr,
  341|       |pub CopyBuffers: FnPtr,
  342|       |pub CreateContext: FnPtr,
  343|       |pub CreateImage: FnPtr,
  344|       |pub CreatePbufferFromClientBuffer: FnPtr,
  345|       |pub CreatePbufferSurface: FnPtr,
  346|       |pub CreatePixmapSurface: FnPtr,
  347|       |pub CreatePlatformPixmapSurface: FnPtr,
  348|       |pub CreatePlatformPixmapSurfaceEXT: FnPtr,
  349|       |pub CreatePlatformWindowSurface: FnPtr,
  350|       |pub CreatePlatformWindowSurfaceEXT: FnPtr,
  351|       |/// Fallbacks: CreateSync64KHR
  352|       |pub CreateSync: FnPtr,
  353|       |pub CreateSyncKHR: FnPtr,
  354|       |pub CreateWindowSurface: FnPtr,
  355|       |pub DestroyContext: FnPtr,
  356|       |/// Fallbacks: DestroyImageKHR
  357|       |pub DestroyImage: FnPtr,
  358|       |pub DestroySurface: FnPtr,
  359|       |/// Fallbacks: DestroySyncKHR
  360|       |pub DestroySync: FnPtr,
  361|       |pub DestroySyncKHR: FnPtr,
  362|       |pub DupNativeFenceFDANDROID: FnPtr,
  363|       |pub GetConfigAttrib: FnPtr,
  364|       |pub GetConfigs: FnPtr,
  365|       |pub GetCurrentContext: FnPtr,
  366|       |pub GetCurrentDisplay: FnPtr,
  367|       |pub GetCurrentSurface: FnPtr,
  368|       |pub GetDisplay: FnPtr,
  369|       |pub GetError: FnPtr,
  370|       |pub GetPlatformDisplay: FnPtr,
  371|       |pub GetPlatformDisplayEXT: FnPtr,
  372|       |pub GetProcAddress: FnPtr,
  373|       |pub GetSyncAttrib: FnPtr,
  374|       |pub GetSyncAttribKHR: FnPtr,
  375|       |pub Initialize: FnPtr,
  376|       |pub MakeCurrent: FnPtr,
  377|       |pub QueryAPI: FnPtr,
  378|       |pub QueryContext: FnPtr,
  379|       |pub QueryDeviceAttribEXT: FnPtr,
  380|       |pub QueryDeviceStringEXT: FnPtr,
  381|       |pub QueryDevicesEXT: FnPtr,
  382|       |pub QueryDisplayAttribEXT: FnPtr,
  383|       |/// Fallbacks: QueryDisplayAttribEXT, QueryDisplayAttribNV
  384|       |pub QueryDisplayAttribKHR: FnPtr,
  385|       |pub QueryString: FnPtr,
  386|       |pub QuerySurface: FnPtr,
  387|       |pub ReleaseTexImage: FnPtr,
  388|       |pub ReleaseThread: FnPtr,
  389|       |pub SurfaceAttrib: FnPtr,
  390|       |pub SwapBuffers: FnPtr,
  391|       |pub SwapBuffersWithDamageEXT: FnPtr,
  392|       |pub SwapBuffersWithDamageKHR: FnPtr,
  393|       |pub SwapInterval: FnPtr,
  394|       |pub Terminate: FnPtr,
  395|       |pub WaitClient: FnPtr,
  396|       |pub WaitGL: FnPtr,
  397|       |pub WaitNative: FnPtr,
  398|       |pub WaitSync: FnPtr,
  399|       |pub WaitSyncKHR: FnPtr,
  400|       |_priv: ()
  401|       |}
  402|       |impl Egl {
  403|       |            /// Load each OpenGL symbol using a custom load function. This allows for the
  404|       |            /// use of functions like `glfwGetProcAddress` or `SDL_GL_GetProcAddress`.
  405|       |            ///
  406|       |            /// ~~~ignore
  407|       |            /// let gl = Gl::load_with(|s| glfw.get_proc_address(s));
  408|       |            /// ~~~
  409|       |            #[allow(dead_code, unused_variables)]
  410|      0|            pub fn load_with<F>(mut loadfn: F) -> Egl where F: FnMut(&'static str) -> *const __gl_imports::raw::c_void {
  411|       |                #[inline(never)]
  412|      0|                fn do_metaloadfn(loadfn: &mut dyn FnMut(&'static str) -> *const __gl_imports::raw::c_void,
  413|      0|                                 symbol: &'static str,
  414|      0|                                 symbols: &[&'static str])
  415|      0|                                 -> *const __gl_imports::raw::c_void {
  416|      0|                    let mut ptr = loadfn(symbol);
  417|      0|                    if ptr.is_null() {
  418|      0|                        for &sym in symbols {
  419|      0|                            ptr = loadfn(sym);
  420|      0|                            if !ptr.is_null() { break; }
  421|       |                        }
  422|      0|                    }
  423|      0|                    ptr
  424|      0|                }
  425|      0|                let mut metaloadfn = |symbol: &'static str, symbols: &[&'static str]| {
  426|      0|                    do_metaloadfn(&mut loadfn, symbol, symbols)
  427|      0|                };
  428|      0|                Egl {
  429|      0|BindAPI: FnPtr::new(metaloadfn("eglBindAPI", &[])),
  430|      0|BindTexImage: FnPtr::new(metaloadfn("eglBindTexImage", &[])),
  431|      0|ChooseConfig: FnPtr::new(metaloadfn("eglChooseConfig", &[])),
  432|      0|ClientWaitSync: FnPtr::new(metaloadfn("eglClientWaitSync", &["eglClientWaitSyncKHR"])),
  433|      0|ClientWaitSyncKHR: FnPtr::new(metaloadfn("eglClientWaitSyncKHR", &[])),
  434|      0|CopyBuffers: FnPtr::new(metaloadfn("eglCopyBuffers", &[])),
  435|      0|CreateContext: FnPtr::new(metaloadfn("eglCreateContext", &[])),
  436|      0|CreateImage: FnPtr::new(metaloadfn("eglCreateImage", &[])),
  437|      0|CreatePbufferFromClientBuffer: FnPtr::new(metaloadfn("eglCreatePbufferFromClientBuffer", &[])),
  438|      0|CreatePbufferSurface: FnPtr::new(metaloadfn("eglCreatePbufferSurface", &[])),
  439|      0|CreatePixmapSurface: FnPtr::new(metaloadfn("eglCreatePixmapSurface", &[])),
  440|      0|CreatePlatformPixmapSurface: FnPtr::new(metaloadfn("eglCreatePlatformPixmapSurface", &[])),
  441|      0|CreatePlatformPixmapSurfaceEXT: FnPtr::new(metaloadfn("eglCreatePlatformPixmapSurfaceEXT", &[])),
  442|      0|CreatePlatformWindowSurface: FnPtr::new(metaloadfn("eglCreatePlatformWindowSurface", &[])),
  443|      0|CreatePlatformWindowSurfaceEXT: FnPtr::new(metaloadfn("eglCreatePlatformWindowSurfaceEXT", &[])),
  444|      0|CreateSync: FnPtr::new(metaloadfn("eglCreateSync", &["eglCreateSync64KHR"])),
  445|      0|CreateSyncKHR: FnPtr::new(metaloadfn("eglCreateSyncKHR", &[])),
  446|      0|CreateWindowSurface: FnPtr::new(metaloadfn("eglCreateWindowSurface", &[])),
  447|      0|DestroyContext: FnPtr::new(metaloadfn("eglDestroyContext", &[])),
  448|      0|DestroyImage: FnPtr::new(metaloadfn("eglDestroyImage", &["eglDestroyImageKHR"])),
  449|      0|DestroySurface: FnPtr::new(metaloadfn("eglDestroySurface", &[])),
  450|      0|DestroySync: FnPtr::new(metaloadfn("eglDestroySync", &["eglDestroySyncKHR"])),
  451|      0|DestroySyncKHR: FnPtr::new(metaloadfn("eglDestroySyncKHR", &[])),
  452|      0|DupNativeFenceFDANDROID: FnPtr::new(metaloadfn("eglDupNativeFenceFDANDROID", &[])),
  453|      0|GetConfigAttrib: FnPtr::new(metaloadfn("eglGetConfigAttrib", &[])),
  454|      0|GetConfigs: FnPtr::new(metaloadfn("eglGetConfigs", &[])),
  455|      0|GetCurrentContext: FnPtr::new(metaloadfn("eglGetCurrentContext", &[])),
  456|      0|GetCurrentDisplay: FnPtr::new(metaloadfn("eglGetCurrentDisplay", &[])),
  457|      0|GetCurrentSurface: FnPtr::new(metaloadfn("eglGetCurrentSurface", &[])),
  458|      0|GetDisplay: FnPtr::new(metaloadfn("eglGetDisplay", &[])),
  459|      0|GetError: FnPtr::new(metaloadfn("eglGetError", &[])),
  460|      0|GetPlatformDisplay: FnPtr::new(metaloadfn("eglGetPlatformDisplay", &[])),
  461|      0|GetPlatformDisplayEXT: FnPtr::new(metaloadfn("eglGetPlatformDisplayEXT", &[])),
  462|      0|GetProcAddress: FnPtr::new(metaloadfn("eglGetProcAddress", &[])),
  463|      0|GetSyncAttrib: FnPtr::new(metaloadfn("eglGetSyncAttrib", &[])),
  464|      0|GetSyncAttribKHR: FnPtr::new(metaloadfn("eglGetSyncAttribKHR", &[])),
  465|      0|Initialize: FnPtr::new(metaloadfn("eglInitialize", &[])),
  466|      0|MakeCurrent: FnPtr::new(metaloadfn("eglMakeCurrent", &[])),
  467|      0|QueryAPI: FnPtr::new(metaloadfn("eglQueryAPI", &[])),
  468|      0|QueryContext: FnPtr::new(metaloadfn("eglQueryContext", &[])),
  469|      0|QueryDeviceAttribEXT: FnPtr::new(metaloadfn("eglQueryDeviceAttribEXT", &[])),
  470|      0|QueryDeviceStringEXT: FnPtr::new(metaloadfn("eglQueryDeviceStringEXT", &[])),
  471|      0|QueryDevicesEXT: FnPtr::new(metaloadfn("eglQueryDevicesEXT", &[])),
  472|      0|QueryDisplayAttribEXT: FnPtr::new(metaloadfn("eglQueryDisplayAttribEXT", &[])),
  473|      0|QueryDisplayAttribKHR: FnPtr::new(metaloadfn("eglQueryDisplayAttribKHR", &["eglQueryDisplayAttribEXT", "eglQueryDisplayAttribNV"])),
  474|      0|QueryString: FnPtr::new(metaloadfn("eglQueryString", &[])),
  475|      0|QuerySurface: FnPtr::new(metaloadfn("eglQuerySurface", &[])),
  476|      0|ReleaseTexImage: FnPtr::new(metaloadfn("eglReleaseTexImage", &[])),
  477|      0|ReleaseThread: FnPtr::new(metaloadfn("eglReleaseThread", &[])),
  478|      0|SurfaceAttrib: FnPtr::new(metaloadfn("eglSurfaceAttrib", &[])),
  479|      0|SwapBuffers: FnPtr::new(metaloadfn("eglSwapBuffers", &[])),
  480|      0|SwapBuffersWithDamageEXT: FnPtr::new(metaloadfn("eglSwapBuffersWithDamageEXT", &[])),
  481|      0|SwapBuffersWithDamageKHR: FnPtr::new(metaloadfn("eglSwapBuffersWithDamageKHR", &[])),
  482|      0|SwapInterval: FnPtr::new(metaloadfn("eglSwapInterval", &[])),
  483|      0|Terminate: FnPtr::new(metaloadfn("eglTerminate", &[])),
  484|      0|WaitClient: FnPtr::new(metaloadfn("eglWaitClient", &[])),
  485|      0|WaitGL: FnPtr::new(metaloadfn("eglWaitGL", &[])),
  486|      0|WaitNative: FnPtr::new(metaloadfn("eglWaitNative", &[])),
  487|      0|WaitSync: FnPtr::new(metaloadfn("eglWaitSync", &[])),
  488|      0|WaitSyncKHR: FnPtr::new(metaloadfn("eglWaitSyncKHR", &[])),
  489|      0|_priv: ()
  490|      0|}
  491|      0|        }
  492|       |#[allow(non_snake_case, unused_variables, dead_code)]
  493|      0|            #[inline] pub unsafe fn BindAPI(&self, api: types::EGLenum) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLenum) -> types::EGLBoolean>(self.BindAPI.f)(api) }
  494|       |#[allow(non_snake_case, unused_variables, dead_code)]
  495|      0|            #[inline] pub unsafe fn BindTexImage(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, buffer: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint) -> types::EGLBoolean>(self.BindTexImage.f)(dpy, surface, buffer) }
  496|       |#[allow(non_snake_case, unused_variables, dead_code)]
  497|      0|            #[inline] pub unsafe fn ChooseConfig(&self, dpy: types::EGLDisplay, attrib_list: *const types::EGLint, configs: *mut types::EGLConfig, config_size: types::EGLint, num_config: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, *const types::EGLint, *mut types::EGLConfig, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.ChooseConfig.f)(dpy, attrib_list, configs, config_size, num_config) }
  498|       |#[allow(non_snake_case, unused_variables, dead_code)]
  499|      0|            #[inline] pub unsafe fn ClientWaitSync(&self, dpy: types::EGLDisplay, sync: types::EGLSync, flags: types::EGLint, timeout: types::EGLTime) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync, types::EGLint, types::EGLTime) -> types::EGLint>(self.ClientWaitSync.f)(dpy, sync, flags, timeout) }
  500|       |#[allow(non_snake_case, unused_variables, dead_code)]
  501|      0|            #[inline] pub unsafe fn ClientWaitSyncKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, flags: types::EGLint, timeout: types::EGLTimeKHR) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint, types::EGLTimeKHR) -> types::EGLint>(self.ClientWaitSyncKHR.f)(dpy, sync, flags, timeout) }
  502|       |#[allow(non_snake_case, unused_variables, dead_code)]
  503|      0|            #[inline] pub unsafe fn CopyBuffers(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, target: types::EGLNativePixmapType) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLNativePixmapType) -> types::EGLBoolean>(self.CopyBuffers.f)(dpy, surface, target) }
  504|       |#[allow(non_snake_case, unused_variables, dead_code)]
  505|      0|            #[inline] pub unsafe fn CreateContext(&self, dpy: types::EGLDisplay, config: types::EGLConfig, share_context: types::EGLContext, attrib_list: *const types::EGLint) -> types::EGLContext { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLContext, *const types::EGLint) -> types::EGLContext>(self.CreateContext.f)(dpy, config, share_context, attrib_list) }
  506|       |#[allow(non_snake_case, unused_variables, dead_code)]
  507|      0|            #[inline] pub unsafe fn CreateImage(&self, dpy: types::EGLDisplay, ctx: types::EGLContext, target: types::EGLenum, buffer: types::EGLClientBuffer, attrib_list: *const types::EGLAttrib) -> types::EGLImage { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLContext, types::EGLenum, types::EGLClientBuffer, *const types::EGLAttrib) -> types::EGLImage>(self.CreateImage.f)(dpy, ctx, target, buffer, attrib_list) }
  508|       |#[allow(non_snake_case, unused_variables, dead_code)]
  509|      0|            #[inline] pub unsafe fn CreatePbufferFromClientBuffer(&self, dpy: types::EGLDisplay, buftype: types::EGLenum, buffer: types::EGLClientBuffer, config: types::EGLConfig, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLenum, types::EGLClientBuffer, types::EGLConfig, *const types::EGLint) -> types::EGLSurface>(self.CreatePbufferFromClientBuffer.f)(dpy, buftype, buffer, config, attrib_list) }
  510|       |#[allow(non_snake_case, unused_variables, dead_code)]
  511|      0|            #[inline] pub unsafe fn CreatePbufferSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *const types::EGLint) -> types::EGLSurface>(self.CreatePbufferSurface.f)(dpy, config, attrib_list) }
  512|       |#[allow(non_snake_case, unused_variables, dead_code)]
  513|      0|            #[inline] pub unsafe fn CreatePixmapSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, pixmap: types::EGLNativePixmapType, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLNativePixmapType, *const types::EGLint) -> types::EGLSurface>(self.CreatePixmapSurface.f)(dpy, config, pixmap, attrib_list) }
  514|       |#[allow(non_snake_case, unused_variables, dead_code)]
  515|      0|            #[inline] pub unsafe fn CreatePlatformPixmapSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_pixmap: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -> types::EGLSurface>(self.CreatePlatformPixmapSurface.f)(dpy, config, native_pixmap, attrib_list) }
  516|       |#[allow(non_snake_case, unused_variables, dead_code)]
  517|      0|            #[inline] pub unsafe fn CreatePlatformPixmapSurfaceEXT(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_pixmap: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLint) -> types::EGLSurface>(self.CreatePlatformPixmapSurfaceEXT.f)(dpy, config, native_pixmap, attrib_list) }
  518|       |#[allow(non_snake_case, unused_variables, dead_code)]
  519|      0|            #[inline] pub unsafe fn CreatePlatformWindowSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_window: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -> types::EGLSurface>(self.CreatePlatformWindowSurface.f)(dpy, config, native_window, attrib_list) }
  520|       |#[allow(non_snake_case, unused_variables, dead_code)]
  521|      0|            #[inline] pub unsafe fn CreatePlatformWindowSurfaceEXT(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_window: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLint) -> types::EGLSurface>(self.CreatePlatformWindowSurfaceEXT.f)(dpy, config, native_window, attrib_list) }
  522|       |#[allow(non_snake_case, unused_variables, dead_code)]
  523|      0|            #[inline] pub unsafe fn CreateSync(&self, dpy: types::EGLDisplay, type_: types::EGLenum, attrib_list: *const types::EGLAttrib) -> types::EGLSync { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLenum, *const types::EGLAttrib) -> types::EGLSync>(self.CreateSync.f)(dpy, type_, attrib_list) }
  524|       |#[allow(non_snake_case, unused_variables, dead_code)]
  525|      0|            #[inline] pub unsafe fn CreateSyncKHR(&self, dpy: types::EGLDisplay, type_: types::EGLenum, attrib_list: *const types::EGLint) -> types::EGLSyncKHR { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLenum, *const types::EGLint) -> types::EGLSyncKHR>(self.CreateSyncKHR.f)(dpy, type_, attrib_list) }
  526|       |#[allow(non_snake_case, unused_variables, dead_code)]
  527|      0|            #[inline] pub unsafe fn CreateWindowSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, win: types::EGLNativeWindowType, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLNativeWindowType, *const types::EGLint) -> types::EGLSurface>(self.CreateWindowSurface.f)(dpy, config, win, attrib_list) }
  528|       |#[allow(non_snake_case, unused_variables, dead_code)]
  529|      0|            #[inline] pub unsafe fn DestroyContext(&self, dpy: types::EGLDisplay, ctx: types::EGLContext) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLContext) -> types::EGLBoolean>(self.DestroyContext.f)(dpy, ctx) }
  530|       |#[allow(non_snake_case, unused_variables, dead_code)]
  531|      0|            #[inline] pub unsafe fn DestroyImage(&self, dpy: types::EGLDisplay, image: types::EGLImage) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLImage) -> types::EGLBoolean>(self.DestroyImage.f)(dpy, image) }
  532|       |#[allow(non_snake_case, unused_variables, dead_code)]
  533|      0|            #[inline] pub unsafe fn DestroySurface(&self, dpy: types::EGLDisplay, surface: types::EGLSurface) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface) -> types::EGLBoolean>(self.DestroySurface.f)(dpy, surface) }
  534|       |#[allow(non_snake_case, unused_variables, dead_code)]
  535|      0|            #[inline] pub unsafe fn DestroySync(&self, dpy: types::EGLDisplay, sync: types::EGLSync) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync) -> types::EGLBoolean>(self.DestroySync.f)(dpy, sync) }
  536|       |#[allow(non_snake_case, unused_variables, dead_code)]
  537|      0|            #[inline] pub unsafe fn DestroySyncKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR) -> types::EGLBoolean>(self.DestroySyncKHR.f)(dpy, sync) }
  538|       |#[allow(non_snake_case, unused_variables, dead_code)]
  539|      0|            #[inline] pub unsafe fn DupNativeFenceFDANDROID(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR) -> types::EGLint>(self.DupNativeFenceFDANDROID.f)(dpy, sync) }
  540|       |#[allow(non_snake_case, unused_variables, dead_code)]
  541|      0|            #[inline] pub unsafe fn GetConfigAttrib(&self, dpy: types::EGLDisplay, config: types::EGLConfig, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.GetConfigAttrib.f)(dpy, config, attribute, value) }
  542|       |#[allow(non_snake_case, unused_variables, dead_code)]
  543|      0|            #[inline] pub unsafe fn GetConfigs(&self, dpy: types::EGLDisplay, configs: *mut types::EGLConfig, config_size: types::EGLint, num_config: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, *mut types::EGLConfig, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.GetConfigs.f)(dpy, configs, config_size, num_config) }
  544|       |#[allow(non_snake_case, unused_variables, dead_code)]
  545|      0|            #[inline] pub unsafe fn GetCurrentContext(&self, ) -> types::EGLContext { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLContext>(self.GetCurrentContext.f)() }
  546|       |#[allow(non_snake_case, unused_variables, dead_code)]
  547|      0|            #[inline] pub unsafe fn GetCurrentDisplay(&self, ) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLDisplay>(self.GetCurrentDisplay.f)() }
  548|       |#[allow(non_snake_case, unused_variables, dead_code)]
  549|      0|            #[inline] pub unsafe fn GetCurrentSurface(&self, readdraw: types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLint) -> types::EGLSurface>(self.GetCurrentSurface.f)(readdraw) }
  550|       |#[allow(non_snake_case, unused_variables, dead_code)]
  551|      0|            #[inline] pub unsafe fn GetDisplay(&self, display_id: types::EGLNativeDisplayType) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLNativeDisplayType) -> types::EGLDisplay>(self.GetDisplay.f)(display_id) }
  552|       |#[allow(non_snake_case, unused_variables, dead_code)]
  553|      0|            #[inline] pub unsafe fn GetError(&self, ) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLint>(self.GetError.f)() }
  554|       |#[allow(non_snake_case, unused_variables, dead_code)]
  555|      0|            #[inline] pub unsafe fn GetPlatformDisplay(&self, platform: types::EGLenum, native_display: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLenum, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -> types::EGLDisplay>(self.GetPlatformDisplay.f)(platform, native_display, attrib_list) }
  556|       |#[allow(non_snake_case, unused_variables, dead_code)]
  557|      0|            #[inline] pub unsafe fn GetPlatformDisplayEXT(&self, platform: types::EGLenum, native_display: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLenum, *mut __gl_imports::raw::c_void, *const types::EGLint) -> types::EGLDisplay>(self.GetPlatformDisplayEXT.f)(platform, native_display, attrib_list) }
  558|       |#[allow(non_snake_case, unused_variables, dead_code)]
  559|      0|            #[inline] pub unsafe fn GetProcAddress(&self, procname: *const __gl_imports::raw::c_char) -> types::__eglMustCastToProperFunctionPointerType { __gl_imports::mem::transmute::<_, extern "system" fn(*const __gl_imports::raw::c_char) -> types::__eglMustCastToProperFunctionPointerType>(self.GetProcAddress.f)(procname) }
  560|       |#[allow(non_snake_case, unused_variables, dead_code)]
  561|      0|            #[inline] pub unsafe fn GetSyncAttrib(&self, dpy: types::EGLDisplay, sync: types::EGLSync, attribute: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.GetSyncAttrib.f)(dpy, sync, attribute, value) }
  562|       |#[allow(non_snake_case, unused_variables, dead_code)]
  563|      0|            #[inline] pub unsafe fn GetSyncAttribKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.GetSyncAttribKHR.f)(dpy, sync, attribute, value) }
  564|       |#[allow(non_snake_case, unused_variables, dead_code)]
  565|      0|            #[inline] pub unsafe fn Initialize(&self, dpy: types::EGLDisplay, major: *mut types::EGLint, minor: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, *mut types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.Initialize.f)(dpy, major, minor) }
  566|       |#[allow(non_snake_case, unused_variables, dead_code)]
  567|      0|            #[inline] pub unsafe fn MakeCurrent(&self, dpy: types::EGLDisplay, draw: types::EGLSurface, read: types::EGLSurface, ctx: types::EGLContext) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLSurface, types::EGLContext) -> types::EGLBoolean>(self.MakeCurrent.f)(dpy, draw, read, ctx) }
  568|       |#[allow(non_snake_case, unused_variables, dead_code)]
  569|      0|            #[inline] pub unsafe fn QueryAPI(&self, ) -> types::EGLenum { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLenum>(self.QueryAPI.f)() }
  570|       |#[allow(non_snake_case, unused_variables, dead_code)]
  571|      0|            #[inline] pub unsafe fn QueryContext(&self, dpy: types::EGLDisplay, ctx: types::EGLContext, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLContext, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.QueryContext.f)(dpy, ctx, attribute, value) }
  572|       |#[allow(non_snake_case, unused_variables, dead_code)]
  573|      0|            #[inline] pub unsafe fn QueryDeviceAttribEXT(&self, device: types::EGLDeviceEXT, attribute: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDeviceEXT, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.QueryDeviceAttribEXT.f)(device, attribute, value) }
  574|       |#[allow(non_snake_case, unused_variables, dead_code)]
  575|      0|            #[inline] pub unsafe fn QueryDeviceStringEXT(&self, device: types::EGLDeviceEXT, name: types::EGLint) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDeviceEXT, types::EGLint) -> *const __gl_imports::raw::c_char>(self.QueryDeviceStringEXT.f)(device, name) }
  576|       |#[allow(non_snake_case, unused_variables, dead_code)]
  577|      0|            #[inline] pub unsafe fn QueryDevicesEXT(&self, max_devices: types::EGLint, devices: *mut types::EGLDeviceEXT, num_devices: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLint, *mut types::EGLDeviceEXT, *mut types::EGLint) -> types::EGLBoolean>(self.QueryDevicesEXT.f)(max_devices, devices, num_devices) }
  578|       |#[allow(non_snake_case, unused_variables, dead_code)]
  579|      0|            #[inline] pub unsafe fn QueryDisplayAttribEXT(&self, dpy: types::EGLDisplay, attribute: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.QueryDisplayAttribEXT.f)(dpy, attribute, value) }
  580|       |#[allow(non_snake_case, unused_variables, dead_code)]
  581|      0|            #[inline] pub unsafe fn QueryDisplayAttribKHR(&self, dpy: types::EGLDisplay, name: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.QueryDisplayAttribKHR.f)(dpy, name, value) }
  582|       |#[allow(non_snake_case, unused_variables, dead_code)]
  583|      0|            #[inline] pub unsafe fn QueryString(&self, dpy: types::EGLDisplay, name: types::EGLint) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint) -> *const __gl_imports::raw::c_char>(self.QueryString.f)(dpy, name) }
  584|       |#[allow(non_snake_case, unused_variables, dead_code)]
  585|      0|            #[inline] pub unsafe fn QuerySurface(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.QuerySurface.f)(dpy, surface, attribute, value) }
  586|       |#[allow(non_snake_case, unused_variables, dead_code)]
  587|      0|            #[inline] pub unsafe fn ReleaseTexImage(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, buffer: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint) -> types::EGLBoolean>(self.ReleaseTexImage.f)(dpy, surface, buffer) }
  588|       |#[allow(non_snake_case, unused_variables, dead_code)]
  589|      0|            #[inline] pub unsafe fn ReleaseThread(&self, ) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLBoolean>(self.ReleaseThread.f)() }
  590|       |#[allow(non_snake_case, unused_variables, dead_code)]
  591|      0|            #[inline] pub unsafe fn SurfaceAttrib(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, attribute: types::EGLint, value: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint, types::EGLint) -> types::EGLBoolean>(self.SurfaceAttrib.f)(dpy, surface, attribute, value) }
  592|       |#[allow(non_snake_case, unused_variables, dead_code)]
  593|      0|            #[inline] pub unsafe fn SwapBuffers(&self, dpy: types::EGLDisplay, surface: types::EGLSurface) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface) -> types::EGLBoolean>(self.SwapBuffers.f)(dpy, surface) }
  594|       |#[allow(non_snake_case, unused_variables, dead_code)]
  595|      0|            #[inline] pub unsafe fn SwapBuffersWithDamageEXT(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, rects: *mut types::EGLint, n_rects: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, *mut types::EGLint, types::EGLint) -> types::EGLBoolean>(self.SwapBuffersWithDamageEXT.f)(dpy, surface, rects, n_rects) }
  596|       |#[allow(non_snake_case, unused_variables, dead_code)]
  597|      0|            #[inline] pub unsafe fn SwapBuffersWithDamageKHR(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, rects: *mut types::EGLint, n_rects: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, *mut types::EGLint, types::EGLint) -> types::EGLBoolean>(self.SwapBuffersWithDamageKHR.f)(dpy, surface, rects, n_rects) }
  598|       |#[allow(non_snake_case, unused_variables, dead_code)]
  599|      0|            #[inline] pub unsafe fn SwapInterval(&self, dpy: types::EGLDisplay, interval: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint) -> types::EGLBoolean>(self.SwapInterval.f)(dpy, interval) }
  600|       |#[allow(non_snake_case, unused_variables, dead_code)]
  601|      0|            #[inline] pub unsafe fn Terminate(&self, dpy: types::EGLDisplay) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay) -> types::EGLBoolean>(self.Terminate.f)(dpy) }
  602|       |#[allow(non_snake_case, unused_variables, dead_code)]
  603|      0|            #[inline] pub unsafe fn WaitClient(&self, ) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLBoolean>(self.WaitClient.f)() }
  604|       |#[allow(non_snake_case, unused_variables, dead_code)]
  605|      0|            #[inline] pub unsafe fn WaitGL(&self, ) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLBoolean>(self.WaitGL.f)() }
  606|       |#[allow(non_snake_case, unused_variables, dead_code)]
  607|      0|            #[inline] pub unsafe fn WaitNative(&self, engine: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLint) -> types::EGLBoolean>(self.WaitNative.f)(engine) }
  608|       |#[allow(non_snake_case, unused_variables, dead_code)]
  609|      0|            #[inline] pub unsafe fn WaitSync(&self, dpy: types::EGLDisplay, sync: types::EGLSync, flags: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync, types::EGLint) -> types::EGLBoolean>(self.WaitSync.f)(dpy, sync, flags) }
  610|       |#[allow(non_snake_case, unused_variables, dead_code)]
  611|      0|            #[inline] pub unsafe fn WaitSyncKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, flags: types::EGLint) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint) -> types::EGLint>(self.WaitSyncKHR.f)(dpy, sync, flags) }
  612|       |}
  613|       |
  614|       |        unsafe impl __gl_imports::Send for Egl {}

c:\language\mdmdview\target\llvm-cov-target\debug\build\glutin_wgl_sys-10af08ee4ccaf0a2\out\wgl_extra_bindings.rs:
    1|       |
    2|       |        mod __gl_imports {
    3|       |            pub use std::mem;
    4|       |            pub use std::marker::Send;
    5|       |            pub use std::os::raw;
    6|       |        }
    7|       |    
    8|       |
    9|       |        pub mod types {
   10|       |            #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)]
   11|       |    
   12|       |// Common types from OpenGL 1.1
   13|       |pub type GLenum = super::__gl_imports::raw::c_uint;
   14|       |pub type GLboolean = super::__gl_imports::raw::c_uchar;
   15|       |pub type GLbitfield = super::__gl_imports::raw::c_uint;
   16|       |pub type GLvoid = super::__gl_imports::raw::c_void;
   17|       |pub type GLbyte = super::__gl_imports::raw::c_char;
   18|       |pub type GLshort = super::__gl_imports::raw::c_short;
   19|       |pub type GLint = super::__gl_imports::raw::c_int;
   20|       |pub type GLclampx = super::__gl_imports::raw::c_int;
   21|       |pub type GLubyte = super::__gl_imports::raw::c_uchar;
   22|       |pub type GLushort = super::__gl_imports::raw::c_ushort;
   23|       |pub type GLuint = super::__gl_imports::raw::c_uint;
   24|       |pub type GLsizei = super::__gl_imports::raw::c_int;
   25|       |pub type GLfloat = super::__gl_imports::raw::c_float;
   26|       |pub type GLclampf = super::__gl_imports::raw::c_float;
   27|       |pub type GLdouble = super::__gl_imports::raw::c_double;
   28|       |pub type GLclampd = super::__gl_imports::raw::c_double;
   29|       |pub type GLeglImageOES = *const super::__gl_imports::raw::c_void;
   30|       |pub type GLchar = super::__gl_imports::raw::c_char;
   31|       |pub type GLcharARB = super::__gl_imports::raw::c_char;
   32|       |
   33|       |#[cfg(target_os = "macos")]
   34|       |pub type GLhandleARB = *const super::__gl_imports::raw::c_void;
   35|       |#[cfg(not(target_os = "macos"))]
   36|       |pub type GLhandleARB = super::__gl_imports::raw::c_uint;
   37|       |
   38|       |pub type GLhalfARB = super::__gl_imports::raw::c_ushort;
   39|       |pub type GLhalf = super::__gl_imports::raw::c_ushort;
   40|       |
   41|       |// Must be 32 bits
   42|       |pub type GLfixed = GLint;
   43|       |
   44|       |pub type GLintptr = isize;
   45|       |pub type GLsizeiptr = isize;
   46|       |pub type GLint64 = i64;
   47|       |pub type GLuint64 = u64;
   48|       |pub type GLintptrARB = isize;
   49|       |pub type GLsizeiptrARB = isize;
   50|       |pub type GLint64EXT = i64;
   51|       |pub type GLuint64EXT = u64;
   52|       |
   53|       |pub enum __GLsync {}
   54|       |pub type GLsync = *const __GLsync;
   55|       |
   56|       |// compatible with OpenCL cl_context
   57|       |pub enum _cl_context {}
   58|       |pub enum _cl_event {}
   59|       |
   60|       |pub type GLDEBUGPROC = Option<extern "system" fn(source: GLenum,
   61|       |                                                 gltype: GLenum,
   62|       |                                                 id: GLuint,
   63|       |                                                 severity: GLenum,
   64|       |                                                 length: GLsizei,
   65|       |                                                 message: *const GLchar,
   66|       |                                                 userParam: *mut super::__gl_imports::raw::c_void)>;
   67|       |pub type GLDEBUGPROCARB = Option<extern "system" fn(source: GLenum,
   68|       |                                                    gltype: GLenum,
   69|       |                                                    id: GLuint,
   70|       |                                                    severity: GLenum,
   71|       |                                                    length: GLsizei,
   72|       |                                                    message: *const GLchar,
   73|       |                                                    userParam: *mut super::__gl_imports::raw::c_void)>;
   74|       |pub type GLDEBUGPROCKHR = Option<extern "system" fn(source: GLenum,
   75|       |                                                    gltype: GLenum,
   76|       |                                                    id: GLuint,
   77|       |                                                    severity: GLenum,
   78|       |                                                    length: GLsizei,
   79|       |                                                    message: *const GLchar,
   80|       |                                                    userParam: *mut super::__gl_imports::raw::c_void)>;
   81|       |
   82|       |// GLES 1 types
   83|       |// "pub type GLclampx = i32;",
   84|       |
   85|       |// GLES 1/2 types (tagged for GLES 1)
   86|       |// "pub type GLbyte = i8;",
   87|       |// "pub type GLubyte = u8;",
   88|       |// "pub type GLfloat = GLfloat;",
   89|       |// "pub type GLclampf = GLfloat;",
   90|       |// "pub type GLfixed = i32;",
   91|       |// "pub type GLint64 = i64;",
   92|       |// "pub type GLuint64 = u64;",
   93|       |// "pub type GLintptr = intptr_t;",
   94|       |// "pub type GLsizeiptr = ssize_t;",
   95|       |
   96|       |// GLES 1/2 types (tagged for GLES 2 - attribute syntax is limited)
   97|       |// "pub type GLbyte = i8;",
   98|       |// "pub type GLubyte = u8;",
   99|       |// "pub type GLfloat = GLfloat;",
  100|       |// "pub type GLclampf = GLfloat;",
  101|       |// "pub type GLfixed = i32;",
  102|       |// "pub type GLint64 = i64;",
  103|       |// "pub type GLuint64 = u64;",
  104|       |// "pub type GLint64EXT = i64;",
  105|       |// "pub type GLuint64EXT = u64;",
  106|       |// "pub type GLintptr = intptr_t;",
  107|       |// "pub type GLsizeiptr = ssize_t;",
  108|       |
  109|       |// GLES 2 types (none currently)
  110|       |
  111|       |// Vendor extension types
  112|       |pub type GLDEBUGPROCAMD = Option<extern "system" fn(id: GLuint,
  113|       |                                                    category: GLenum,
  114|       |                                                    severity: GLenum,
  115|       |                                                    length: GLsizei,
  116|       |                                                    message: *const GLchar,
  117|       |                                                    userParam: *mut super::__gl_imports::raw::c_void)>;
  118|       |pub type GLhalfNV = super::__gl_imports::raw::c_ushort;
  119|       |pub type GLvdpauSurfaceNV = GLintptr;
  120|       |
  121|       |// From WinNT.h
  122|       |
  123|       |pub type CHAR = super::__gl_imports::raw::c_char;
  124|       |pub type HANDLE = PVOID;
  125|       |pub type LONG = super::__gl_imports::raw::c_long;
  126|       |pub type LPCSTR = *const super::__gl_imports::raw::c_char;
  127|       |pub type VOID = ();
  128|       |// #define DECLARE_HANDLE(name) struct name##__{int unused;}; typedef struct name##__ *name
  129|       |pub type HPBUFFERARB = *const super::__gl_imports::raw::c_void;
  130|       |pub type HPBUFFEREXT = *const super::__gl_imports::raw::c_void;
  131|       |pub type HVIDEOOUTPUTDEVICENV = *const super::__gl_imports::raw::c_void;
  132|       |pub type HPVIDEODEV = *const super::__gl_imports::raw::c_void;
  133|       |pub type HPGPUNV = *const super::__gl_imports::raw::c_void;
  134|       |pub type HGPUNV = *const super::__gl_imports::raw::c_void;
  135|       |pub type HVIDEOINPUTDEVICENV = *const super::__gl_imports::raw::c_void;
  136|       |
  137|       |// From Windef.h
  138|       |
  139|       |pub type BOOL = super::__gl_imports::raw::c_int;
  140|       |pub type BYTE = super::__gl_imports::raw::c_uchar;
  141|       |pub type COLORREF = DWORD;
  142|       |pub type FLOAT = super::__gl_imports::raw::c_float;
  143|       |pub type HDC = HANDLE;
  144|       |pub type HENHMETAFILE = HANDLE;
  145|       |pub type HGLRC = *const super::__gl_imports::raw::c_void;
  146|       |pub type INT = super::__gl_imports::raw::c_int;
  147|       |pub type PVOID = *const super::__gl_imports::raw::c_void;
  148|       |pub type LPVOID = *const super::__gl_imports::raw::c_void;
  149|       |pub enum __PROC_fn {}
  150|       |pub type PROC = *mut __PROC_fn;
  151|       |
  152|       |#[repr(C)]
  153|       |pub struct RECT {
  154|       |    left: LONG,
  155|       |    top: LONG,
  156|       |    right: LONG,
  157|       |    bottom: LONG,
  158|       |}
  159|       |
  160|       |pub type UINT = super::__gl_imports::raw::c_uint;
  161|       |pub type USHORT = super::__gl_imports::raw::c_ushort;
  162|       |pub type WORD = super::__gl_imports::raw::c_ushort;
  163|       |
  164|       |// From BaseTsd.h
  165|       |
  166|       |pub type INT32 = i32;
  167|       |pub type INT64 = i64;
  168|       |
  169|       |// From IntSafe.h
  170|       |
  171|       |pub type DWORD = super::__gl_imports::raw::c_ulong;
  172|       |
  173|       |// From Wingdi.h
  174|       |
  175|       |#[repr(C)]
  176|       |pub struct POINTFLOAT {
  177|       |    pub x: FLOAT,
  178|       |    pub y: FLOAT,
  179|       |}
  180|       |
  181|       |#[repr(C)]
  182|       |pub struct GLYPHMETRICSFLOAT {
  183|       |    pub gmfBlackBoxX: FLOAT,
  184|       |    pub gmfBlackBoxY: FLOAT,
  185|       |    pub gmfptGlyphOrigin: POINTFLOAT,
  186|       |    pub gmfCellIncX: FLOAT,
  187|       |    pub gmfCellIncY: FLOAT,
  188|       |}
  189|       |pub type LPGLYPHMETRICSFLOAT = *const GLYPHMETRICSFLOAT;
  190|       |
  191|       |#[repr(C)]
  192|       |pub struct LAYERPLANEDESCRIPTOR {
  193|       |    pub nSize: WORD,
  194|       |    pub nVersion: WORD,
  195|       |    pub dwFlags: DWORD,
  196|       |    pub iPixelType: BYTE,
  197|       |    pub cColorBits: BYTE,
  198|       |    pub cRedBits: BYTE,
  199|       |    pub cRedShift: BYTE,
  200|       |    pub cGreenBits: BYTE,
  201|       |    pub cGreenShift: BYTE,
  202|       |    pub cBlueBits: BYTE,
  203|       |    pub cBlueShift: BYTE,
  204|       |    pub cAlphaBits: BYTE,
  205|       |    pub cAlphaShift: BYTE,
  206|       |    pub cAccumBits: BYTE,
  207|       |    pub cAccumRedBits: BYTE,
  208|       |    pub cAccumGreenBits: BYTE,
  209|       |    pub cAccumBlueBits: BYTE,
  210|       |    pub cAccumAlphaBits: BYTE,
  211|       |    pub cDepthBits: BYTE,
  212|       |    pub cStencilBits: BYTE,
  213|       |    pub cAuxBuffers: BYTE,
  214|       |    pub iLayerType: BYTE,
  215|       |    pub bReserved: BYTE,
  216|       |    pub crTransparent: COLORREF,
  217|       |}
  218|       |
  219|       |#[repr(C)]
  220|       |pub struct PIXELFORMATDESCRIPTOR {
  221|       |    pub nSize: WORD,
  222|       |    pub nVersion: WORD,
  223|       |    pub dwFlags: DWORD,
  224|       |    pub iPixelType: BYTE,
  225|       |    pub cColorBits: BYTE,
  226|       |    pub cRedBits: BYTE,
  227|       |    pub cRedShift: BYTE,
  228|       |    pub cGreenBits: BYTE,
  229|       |    pub cGreenShift: BYTE,
  230|       |    pub cBlueBits: BYTE,
  231|       |    pub cBlueShift: BYTE,
  232|       |    pub cAlphaBits: BYTE,
  233|       |    pub cAlphaShift: BYTE,
  234|       |    pub cAccumBits: BYTE,
  235|       |    pub cAccumRedBits: BYTE,
  236|       |    pub cAccumGreenBits: BYTE,
  237|       |    pub cAccumBlueBits: BYTE,
  238|       |    pub cAccumAlphaBits: BYTE,
  239|       |    pub cDepthBits: BYTE,
  240|       |    pub cStencilBits: BYTE,
  241|       |    pub cAuxBuffers: BYTE,
  242|       |    pub iLayerType: BYTE,
  243|       |    pub bReserved: BYTE,
  244|       |    pub dwLayerMask: DWORD,
  245|       |    pub dwVisibleMask: DWORD,
  246|       |    pub dwDamageMask: DWORD,
  247|       |}
  248|       |
  249|       |#[repr(C)]
  250|       |pub struct _GPU_DEVICE {
  251|       |    cb: DWORD,
  252|       |    DeviceName: [CHAR; 32],
  253|       |    DeviceString: [CHAR; 128],
  254|       |    Flags: DWORD,
  255|       |    rcVirtualScreen: RECT,
  256|       |}
  257|       |
  258|       |pub struct GPU_DEVICE(_GPU_DEVICE);
  259|       |pub struct PGPU_DEVICE(*const _GPU_DEVICE);
  260|       |
  261|       |}
  262|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCELERATION_ARB: types::GLenum = 0x2003;
  263|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_ALPHA_BITS_ARB: types::GLenum = 0x2021;
  264|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_BITS_ARB: types::GLenum = 0x201D;
  265|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_BLUE_BITS_ARB: types::GLenum = 0x2020;
  266|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_GREEN_BITS_ARB: types::GLenum = 0x201F;
  267|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_RED_BITS_ARB: types::GLenum = 0x201E;
  268|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_BITS_ARB: types::GLenum = 0x201B;
  269|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_SHIFT_ARB: types::GLenum = 0x201C;
  270|       |#[allow(dead_code, non_upper_case_globals)] pub const AUX_BUFFERS_ARB: types::GLenum = 0x2024;
  271|       |#[allow(dead_code, non_upper_case_globals)] pub const BLUE_BITS_ARB: types::GLenum = 0x2019;
  272|       |#[allow(dead_code, non_upper_case_globals)] pub const BLUE_SHIFT_ARB: types::GLenum = 0x201A;
  273|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_BITS_ARB: types::GLenum = 0x2014;
  274|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB: types::GLenum = 0x00000002;
  275|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CORE_PROFILE_BIT_ARB: types::GLenum = 0x00000001;
  276|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_DEBUG_BIT_ARB: types::GLenum = 0x00000001;
  277|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_ES2_PROFILE_BIT_EXT: types::GLenum = 0x00000004;
  278|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FLAGS_ARB: types::GLenum = 0x2094;
  279|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FORWARD_COMPATIBLE_BIT_ARB: types::GLenum = 0x00000002;
  280|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_LAYER_PLANE_ARB: types::GLenum = 0x2093;
  281|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION_ARB: types::GLenum = 0x2091;
  282|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION_ARB: types::GLenum = 0x2092;
  283|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_NO_ERROR_ARB: types::GLenum = 0x31B3;
  284|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_PROFILE_MASK_ARB: types::GLenum = 0x9126;
  285|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_ARB: types::GLenum = 0x2097;
  286|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB: types::GLenum = 0x2098;
  287|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_NONE_ARB: types::GLenum = 0;
  288|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB: types::GLenum = 0x8256;
  289|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_ROBUST_ACCESS_BIT_ARB: types::GLenum = 0x00000004;
  290|       |#[allow(dead_code, non_upper_case_globals)] pub const DEPTH_BITS_ARB: types::GLenum = 0x2022;
  291|       |#[allow(dead_code, non_upper_case_globals)] pub const DOUBLE_BUFFER_ARB: types::GLenum = 0x2011;
  292|       |#[allow(dead_code, non_upper_case_globals)] pub const DRAW_TO_BITMAP_ARB: types::GLenum = 0x2002;
  293|       |#[allow(dead_code, non_upper_case_globals)] pub const DRAW_TO_WINDOW_ARB: types::GLenum = 0x2001;
  294|       |#[allow(dead_code, non_upper_case_globals)] pub const FONT_LINES: types::GLenum = 0;
  295|       |#[allow(dead_code, non_upper_case_globals)] pub const FONT_POLYGONS: types::GLenum = 1;
  296|       |#[allow(dead_code, non_upper_case_globals)] pub const FRAMEBUFFER_SRGB_CAPABLE_ARB: types::GLenum = 0x20A9;
  297|       |#[allow(dead_code, non_upper_case_globals)] pub const FRAMEBUFFER_SRGB_CAPABLE_EXT: types::GLenum = 0x20A9;
  298|       |#[allow(dead_code, non_upper_case_globals)] pub const FULL_ACCELERATION_ARB: types::GLenum = 0x2027;
  299|       |#[allow(dead_code, non_upper_case_globals)] pub const GENERIC_ACCELERATION_ARB: types::GLenum = 0x2026;
  300|       |#[allow(dead_code, non_upper_case_globals)] pub const GREEN_BITS_ARB: types::GLenum = 0x2017;
  301|       |#[allow(dead_code, non_upper_case_globals)] pub const GREEN_SHIFT_ARB: types::GLenum = 0x2018;
  302|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_ARB: types::GLenum = 0x8252;
  303|       |#[allow(dead_code, non_upper_case_globals)] pub const NEED_PALETTE_ARB: types::GLenum = 0x2004;
  304|       |#[allow(dead_code, non_upper_case_globals)] pub const NEED_SYSTEM_PALETTE_ARB: types::GLenum = 0x2005;
  305|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_ACCELERATION_ARB: types::GLenum = 0x2025;
  306|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_ARB: types::GLenum = 0x8261;
  307|       |#[allow(dead_code, non_upper_case_globals)] pub const NUMBER_OVERLAYS_ARB: types::GLenum = 0x2008;
  308|       |#[allow(dead_code, non_upper_case_globals)] pub const NUMBER_PIXEL_FORMATS_ARB: types::GLenum = 0x2000;
  309|       |#[allow(dead_code, non_upper_case_globals)] pub const NUMBER_UNDERLAYS_ARB: types::GLenum = 0x2009;
  310|       |#[allow(dead_code, non_upper_case_globals)] pub const PIXEL_TYPE_ARB: types::GLenum = 0x2013;
  311|       |#[allow(dead_code, non_upper_case_globals)] pub const RED_BITS_ARB: types::GLenum = 0x2015;
  312|       |#[allow(dead_code, non_upper_case_globals)] pub const RED_SHIFT_ARB: types::GLenum = 0x2016;
  313|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLES_ARB: types::GLenum = 0x2042;
  314|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLE_BUFFERS_ARB: types::GLenum = 0x2041;
  315|       |#[allow(dead_code, non_upper_case_globals)] pub const SHARE_ACCUM_ARB: types::GLenum = 0x200E;
  316|       |#[allow(dead_code, non_upper_case_globals)] pub const SHARE_DEPTH_ARB: types::GLenum = 0x200C;
  317|       |#[allow(dead_code, non_upper_case_globals)] pub const SHARE_STENCIL_ARB: types::GLenum = 0x200D;
  318|       |#[allow(dead_code, non_upper_case_globals)] pub const STENCIL_BITS_ARB: types::GLenum = 0x2023;
  319|       |#[allow(dead_code, non_upper_case_globals)] pub const STEREO_ARB: types::GLenum = 0x2012;
  320|       |#[allow(dead_code, non_upper_case_globals)] pub const SUPPORT_GDI_ARB: types::GLenum = 0x200F;
  321|       |#[allow(dead_code, non_upper_case_globals)] pub const SUPPORT_OPENGL_ARB: types::GLenum = 0x2010;
  322|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_COPY_ARB: types::GLenum = 0x2029;
  323|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_EXCHANGE_ARB: types::GLenum = 0x2028;
  324|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_LAYER_BUFFERS_ARB: types::GLenum = 0x2006;
  325|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_MAIN_PLANE: types::GLenum = 0x00000001;
  326|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_METHOD_ARB: types::GLenum = 0x2007;
  327|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY1: types::GLenum = 0x00000002;
  328|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY10: types::GLenum = 0x00000400;
  329|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY11: types::GLenum = 0x00000800;
  330|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY12: types::GLenum = 0x00001000;
  331|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY13: types::GLenum = 0x00002000;
  332|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY14: types::GLenum = 0x00004000;
  333|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY15: types::GLenum = 0x00008000;
  334|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY2: types::GLenum = 0x00000004;
  335|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY3: types::GLenum = 0x00000008;
  336|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY4: types::GLenum = 0x00000010;
  337|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY5: types::GLenum = 0x00000020;
  338|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY6: types::GLenum = 0x00000040;
  339|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY7: types::GLenum = 0x00000080;
  340|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY8: types::GLenum = 0x00000100;
  341|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY9: types::GLenum = 0x00000200;
  342|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDEFINED_ARB: types::GLenum = 0x202A;
  343|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY1: types::GLenum = 0x00010000;
  344|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY10: types::GLenum = 0x02000000;
  345|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY11: types::GLenum = 0x04000000;
  346|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY12: types::GLenum = 0x08000000;
  347|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY13: types::GLenum = 0x10000000;
  348|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY14: types::GLenum = 0x20000000;
  349|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY15: types::GLenum = 0x40000000;
  350|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY2: types::GLenum = 0x00020000;
  351|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY3: types::GLenum = 0x00040000;
  352|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY4: types::GLenum = 0x00080000;
  353|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY5: types::GLenum = 0x00100000;
  354|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY6: types::GLenum = 0x00200000;
  355|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY7: types::GLenum = 0x00400000;
  356|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY8: types::GLenum = 0x00800000;
  357|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY9: types::GLenum = 0x01000000;
  358|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_ALPHA_VALUE_ARB: types::GLenum = 0x203A;
  359|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_ARB: types::GLenum = 0x200A;
  360|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_BLUE_VALUE_ARB: types::GLenum = 0x2039;
  361|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_GREEN_VALUE_ARB: types::GLenum = 0x2038;
  362|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_INDEX_VALUE_ARB: types::GLenum = 0x203B;
  363|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RED_VALUE_ARB: types::GLenum = 0x2037;
  364|       |#[allow(dead_code, non_upper_case_globals)] pub const TYPE_COLORINDEX_ARB: types::GLenum = 0x202C;
  365|       |#[allow(dead_code, non_upper_case_globals)] pub const TYPE_RGBA_ARB: types::GLenum = 0x202B;
  366|       |#[allow(dead_code, non_upper_case_globals)] pub const TYPE_RGBA_FLOAT_ARB: types::GLenum = 0x21A0;
  367|       |
  368|       |        #[allow(dead_code, missing_copy_implementations)]
  369|       |        #[derive(Clone)]
  370|       |        pub struct FnPtr {
  371|       |            /// The function pointer that will be used when calling the function.
  372|       |            f: *const __gl_imports::raw::c_void,
  373|       |            /// True if the pointer points to a real function, false if points to a `panic!` fn.
  374|       |            is_loaded: bool,
  375|       |        }
  376|       |
  377|       |        impl FnPtr {
  378|       |            /// Creates a `FnPtr` from a load attempt.
  379|      0|            fn new(ptr: *const __gl_imports::raw::c_void) -> FnPtr {
  380|      0|                if ptr.is_null() {
  381|      0|                    FnPtr {
  382|      0|                        f: missing_fn_panic as *const __gl_imports::raw::c_void,
  383|      0|                        is_loaded: false
  384|      0|                    }
  385|       |                } else {
  386|      0|                    FnPtr { f: ptr, is_loaded: true }
  387|       |                }
  388|      0|            }
  389|       |
  390|       |            /// Returns `true` if the function has been successfully loaded.
  391|       |            ///
  392|       |            /// If it returns `false`, calling the corresponding function will fail.
  393|       |            #[inline]
  394|       |            #[allow(dead_code)]
  395|      0|            pub fn is_loaded(&self) -> bool {
  396|      0|                self.is_loaded
  397|      0|            }
  398|       |        }
  399|       |    
  400|       |#[inline(never)]
  401|      0|        fn missing_fn_panic() -> ! {
  402|      0|            panic!("wgl function was not loaded")
  403|       |        }
  404|       |
  405|       |        #[allow(non_camel_case_types, non_snake_case, dead_code)]
  406|       |        #[derive(Clone)]
  407|       |        pub struct Wgl {
  408|       |pub ChoosePixelFormatARB: FnPtr,
  409|       |pub CopyContext: FnPtr,
  410|       |pub CreateContext: FnPtr,
  411|       |pub CreateContextAttribsARB: FnPtr,
  412|       |pub CreateLayerContext: FnPtr,
  413|       |pub DeleteContext: FnPtr,
  414|       |pub DescribeLayerPlane: FnPtr,
  415|       |pub GetCurrentContext: FnPtr,
  416|       |pub GetCurrentDC: FnPtr,
  417|       |pub GetExtensionsStringARB: FnPtr,
  418|       |pub GetExtensionsStringEXT: FnPtr,
  419|       |pub GetLayerPaletteEntries: FnPtr,
  420|       |pub GetPixelFormatAttribfvARB: FnPtr,
  421|       |pub GetPixelFormatAttribivARB: FnPtr,
  422|       |pub GetProcAddress: FnPtr,
  423|       |pub GetSwapIntervalEXT: FnPtr,
  424|       |pub MakeCurrent: FnPtr,
  425|       |pub RealizeLayerPalette: FnPtr,
  426|       |pub SetLayerPaletteEntries: FnPtr,
  427|       |pub ShareLists: FnPtr,
  428|       |pub SwapIntervalEXT: FnPtr,
  429|       |pub SwapLayerBuffers: FnPtr,
  430|       |pub UseFontBitmaps: FnPtr,
  431|       |pub UseFontBitmapsA: FnPtr,
  432|       |pub UseFontBitmapsW: FnPtr,
  433|       |pub UseFontOutlines: FnPtr,
  434|       |pub UseFontOutlinesA: FnPtr,
  435|       |pub UseFontOutlinesW: FnPtr,
  436|       |_priv: ()
  437|       |}
  438|       |impl Wgl {
  439|       |            /// Load each OpenGL symbol using a custom load function. This allows for the
  440|       |            /// use of functions like `glfwGetProcAddress` or `SDL_GL_GetProcAddress`.
  441|       |            ///
  442|       |            /// ~~~ignore
  443|       |            /// let gl = Gl::load_with(|s| glfw.get_proc_address(s));
  444|       |            /// ~~~
  445|       |            #[allow(dead_code, unused_variables)]
  446|      0|            pub fn load_with<F>(mut loadfn: F) -> Wgl where F: FnMut(&'static str) -> *const __gl_imports::raw::c_void {
  447|       |                #[inline(never)]
  448|      0|                fn do_metaloadfn(loadfn: &mut dyn FnMut(&'static str) -> *const __gl_imports::raw::c_void,
  449|      0|                                 symbol: &'static str,
  450|      0|                                 symbols: &[&'static str])
  451|      0|                                 -> *const __gl_imports::raw::c_void {
  452|      0|                    let mut ptr = loadfn(symbol);
  453|      0|                    if ptr.is_null() {
  454|      0|                        for &sym in symbols {
  455|      0|                            ptr = loadfn(sym);
  456|      0|                            if !ptr.is_null() { break; }
  457|       |                        }
  458|      0|                    }
  459|      0|                    ptr
  460|      0|                }
  461|      0|                let mut metaloadfn = |symbol: &'static str, symbols: &[&'static str]| {
  462|      0|                    do_metaloadfn(&mut loadfn, symbol, symbols)
  463|      0|                };
  464|      0|                Wgl {
  465|      0|ChoosePixelFormatARB: FnPtr::new(metaloadfn("wglChoosePixelFormatARB", &[])),
  466|      0|CopyContext: FnPtr::new(metaloadfn("wglCopyContext", &[])),
  467|      0|CreateContext: FnPtr::new(metaloadfn("wglCreateContext", &[])),
  468|      0|CreateContextAttribsARB: FnPtr::new(metaloadfn("wglCreateContextAttribsARB", &[])),
  469|      0|CreateLayerContext: FnPtr::new(metaloadfn("wglCreateLayerContext", &[])),
  470|      0|DeleteContext: FnPtr::new(metaloadfn("wglDeleteContext", &[])),
  471|      0|DescribeLayerPlane: FnPtr::new(metaloadfn("wglDescribeLayerPlane", &[])),
  472|      0|GetCurrentContext: FnPtr::new(metaloadfn("wglGetCurrentContext", &[])),
  473|      0|GetCurrentDC: FnPtr::new(metaloadfn("wglGetCurrentDC", &[])),
  474|      0|GetExtensionsStringARB: FnPtr::new(metaloadfn("wglGetExtensionsStringARB", &[])),
  475|      0|GetExtensionsStringEXT: FnPtr::new(metaloadfn("wglGetExtensionsStringEXT", &[])),
  476|      0|GetLayerPaletteEntries: FnPtr::new(metaloadfn("wglGetLayerPaletteEntries", &[])),
  477|      0|GetPixelFormatAttribfvARB: FnPtr::new(metaloadfn("wglGetPixelFormatAttribfvARB", &[])),
  478|      0|GetPixelFormatAttribivARB: FnPtr::new(metaloadfn("wglGetPixelFormatAttribivARB", &[])),
  479|      0|GetProcAddress: FnPtr::new(metaloadfn("wglGetProcAddress", &[])),
  480|      0|GetSwapIntervalEXT: FnPtr::new(metaloadfn("wglGetSwapIntervalEXT", &[])),
  481|      0|MakeCurrent: FnPtr::new(metaloadfn("wglMakeCurrent", &[])),
  482|      0|RealizeLayerPalette: FnPtr::new(metaloadfn("wglRealizeLayerPalette", &[])),
  483|      0|SetLayerPaletteEntries: FnPtr::new(metaloadfn("wglSetLayerPaletteEntries", &[])),
  484|      0|ShareLists: FnPtr::new(metaloadfn("wglShareLists", &[])),
  485|      0|SwapIntervalEXT: FnPtr::new(metaloadfn("wglSwapIntervalEXT", &[])),
  486|      0|SwapLayerBuffers: FnPtr::new(metaloadfn("wglSwapLayerBuffers", &[])),
  487|      0|UseFontBitmaps: FnPtr::new(metaloadfn("wglUseFontBitmaps", &[])),
  488|      0|UseFontBitmapsA: FnPtr::new(metaloadfn("wglUseFontBitmapsA", &[])),
  489|      0|UseFontBitmapsW: FnPtr::new(metaloadfn("wglUseFontBitmapsW", &[])),
  490|      0|UseFontOutlines: FnPtr::new(metaloadfn("wglUseFontOutlines", &[])),
  491|      0|UseFontOutlinesA: FnPtr::new(metaloadfn("wglUseFontOutlinesA", &[])),
  492|      0|UseFontOutlinesW: FnPtr::new(metaloadfn("wglUseFontOutlinesW", &[])),
  493|      0|_priv: ()
  494|      0|}
  495|      0|        }
  496|       |#[allow(non_snake_case, unused_variables, dead_code)]
  497|      0|            #[inline] pub unsafe fn ChoosePixelFormatARB(&self, hdc: types::HDC, piAttribIList: *const __gl_imports::raw::c_int, pfAttribFList: *const types::FLOAT, nMaxFormats: types::UINT, piFormats: *mut __gl_imports::raw::c_int, nNumFormats: *mut types::UINT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, *const __gl_imports::raw::c_int, *const types::FLOAT, types::UINT, *mut __gl_imports::raw::c_int, *mut types::UINT) -> types::BOOL>(self.ChoosePixelFormatARB.f)(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats) }
  498|       |#[allow(non_snake_case, unused_variables, dead_code)]
  499|      0|            #[inline] pub unsafe fn CopyContext(&self, hglrcSrc: types::HGLRC, hglrcDst: types::HGLRC, mask: types::UINT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HGLRC, types::HGLRC, types::UINT) -> types::BOOL>(self.CopyContext.f)(hglrcSrc, hglrcDst, mask) }
  500|       |#[allow(non_snake_case, unused_variables, dead_code)]
  501|      0|            #[inline] pub unsafe fn CreateContext(&self, hDc: types::HDC) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC) -> types::HGLRC>(self.CreateContext.f)(hDc) }
  502|       |#[allow(non_snake_case, unused_variables, dead_code)]
  503|      0|            #[inline] pub unsafe fn CreateContextAttribsARB(&self, hDC: types::HDC, hShareContext: types::HGLRC, attribList: *const __gl_imports::raw::c_int) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::HGLRC, *const __gl_imports::raw::c_int) -> types::HGLRC>(self.CreateContextAttribsARB.f)(hDC, hShareContext, attribList) }
  504|       |#[allow(non_snake_case, unused_variables, dead_code)]
  505|      0|            #[inline] pub unsafe fn CreateLayerContext(&self, hDc: types::HDC, level: __gl_imports::raw::c_int) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int) -> types::HGLRC>(self.CreateLayerContext.f)(hDc, level) }
  506|       |#[allow(non_snake_case, unused_variables, dead_code)]
  507|      0|            #[inline] pub unsafe fn DeleteContext(&self, oldContext: types::HGLRC) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HGLRC) -> types::BOOL>(self.DeleteContext.f)(oldContext) }
  508|       |#[allow(non_snake_case, unused_variables, dead_code)]
  509|      0|            #[inline] pub unsafe fn DescribeLayerPlane(&self, hDc: types::HDC, pixelFormat: __gl_imports::raw::c_int, layerPlane: __gl_imports::raw::c_int, nBytes: types::UINT, plpd: *const types::LAYERPLANEDESCRIPTOR) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, types::UINT, *const types::LAYERPLANEDESCRIPTOR) -> types::BOOL>(self.DescribeLayerPlane.f)(hDc, pixelFormat, layerPlane, nBytes, plpd) }
  510|       |#[allow(non_snake_case, unused_variables, dead_code)]
  511|      0|            #[inline] pub unsafe fn GetCurrentContext(&self, ) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::HGLRC>(self.GetCurrentContext.f)() }
  512|       |#[allow(non_snake_case, unused_variables, dead_code)]
  513|      0|            #[inline] pub unsafe fn GetCurrentDC(&self, ) -> types::HDC { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::HDC>(self.GetCurrentDC.f)() }
  514|       |#[allow(non_snake_case, unused_variables, dead_code)]
  515|      0|            #[inline] pub unsafe fn GetExtensionsStringARB(&self, hdc: types::HDC) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC) -> *const __gl_imports::raw::c_char>(self.GetExtensionsStringARB.f)(hdc) }
  516|       |#[allow(non_snake_case, unused_variables, dead_code)]
  517|      0|            #[inline] pub unsafe fn GetExtensionsStringEXT(&self, ) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn() -> *const __gl_imports::raw::c_char>(self.GetExtensionsStringEXT.f)() }
  518|       |#[allow(non_snake_case, unused_variables, dead_code)]
  519|      0|            #[inline] pub unsafe fn GetLayerPaletteEntries(&self, hdc: types::HDC, iLayerPlane: __gl_imports::raw::c_int, iStart: __gl_imports::raw::c_int, cEntries: __gl_imports::raw::c_int, pcr: *const types::COLORREF) -> __gl_imports::raw::c_int { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, __gl_imports::raw::c_int, *const types::COLORREF) -> __gl_imports::raw::c_int>(self.GetLayerPaletteEntries.f)(hdc, iLayerPlane, iStart, cEntries, pcr) }
  520|       |#[allow(non_snake_case, unused_variables, dead_code)]
  521|      0|            #[inline] pub unsafe fn GetPixelFormatAttribfvARB(&self, hdc: types::HDC, iPixelFormat: __gl_imports::raw::c_int, iLayerPlane: __gl_imports::raw::c_int, nAttributes: types::UINT, piAttributes: *const __gl_imports::raw::c_int, pfValues: *mut types::FLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, types::UINT, *const __gl_imports::raw::c_int, *mut types::FLOAT) -> types::BOOL>(self.GetPixelFormatAttribfvARB.f)(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues) }
  522|       |#[allow(non_snake_case, unused_variables, dead_code)]
  523|      0|            #[inline] pub unsafe fn GetPixelFormatAttribivARB(&self, hdc: types::HDC, iPixelFormat: __gl_imports::raw::c_int, iLayerPlane: __gl_imports::raw::c_int, nAttributes: types::UINT, piAttributes: *const __gl_imports::raw::c_int, piValues: *mut __gl_imports::raw::c_int) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, types::UINT, *const __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -> types::BOOL>(self.GetPixelFormatAttribivARB.f)(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues) }
  524|       |#[allow(non_snake_case, unused_variables, dead_code)]
  525|      0|            #[inline] pub unsafe fn GetProcAddress(&self, lpszProc: types::LPCSTR) -> types::PROC { __gl_imports::mem::transmute::<_, extern "system" fn(types::LPCSTR) -> types::PROC>(self.GetProcAddress.f)(lpszProc) }
  526|       |#[allow(non_snake_case, unused_variables, dead_code)]
  527|      0|            #[inline] pub unsafe fn GetSwapIntervalEXT(&self, ) -> __gl_imports::raw::c_int { __gl_imports::mem::transmute::<_, extern "system" fn() -> __gl_imports::raw::c_int>(self.GetSwapIntervalEXT.f)() }
  528|       |#[allow(non_snake_case, unused_variables, dead_code)]
  529|      0|            #[inline] pub unsafe fn MakeCurrent(&self, hDc: types::HDC, newContext: types::HGLRC) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::HGLRC) -> types::BOOL>(self.MakeCurrent.f)(hDc, newContext) }
  530|       |#[allow(non_snake_case, unused_variables, dead_code)]
  531|      0|            #[inline] pub unsafe fn RealizeLayerPalette(&self, hdc: types::HDC, iLayerPlane: __gl_imports::raw::c_int, bRealize: types::BOOL) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, types::BOOL) -> types::BOOL>(self.RealizeLayerPalette.f)(hdc, iLayerPlane, bRealize) }
  532|       |#[allow(non_snake_case, unused_variables, dead_code)]
  533|      0|            #[inline] pub unsafe fn SetLayerPaletteEntries(&self, hdc: types::HDC, iLayerPlane: __gl_imports::raw::c_int, iStart: __gl_imports::raw::c_int, cEntries: __gl_imports::raw::c_int, pcr: *const types::COLORREF) -> __gl_imports::raw::c_int { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, __gl_imports::raw::c_int, *const types::COLORREF) -> __gl_imports::raw::c_int>(self.SetLayerPaletteEntries.f)(hdc, iLayerPlane, iStart, cEntries, pcr) }
  534|       |#[allow(non_snake_case, unused_variables, dead_code)]
  535|      0|            #[inline] pub unsafe fn ShareLists(&self, hrcSrvShare: types::HGLRC, hrcSrvSource: types::HGLRC) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HGLRC, types::HGLRC) -> types::BOOL>(self.ShareLists.f)(hrcSrvShare, hrcSrvSource) }
  536|       |#[allow(non_snake_case, unused_variables, dead_code)]
  537|      0|            #[inline] pub unsafe fn SwapIntervalEXT(&self, interval: __gl_imports::raw::c_int) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(__gl_imports::raw::c_int) -> types::BOOL>(self.SwapIntervalEXT.f)(interval) }
  538|       |#[allow(non_snake_case, unused_variables, dead_code)]
  539|      0|            #[inline] pub unsafe fn SwapLayerBuffers(&self, hdc: types::HDC, fuFlags: types::UINT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::UINT) -> types::BOOL>(self.SwapLayerBuffers.f)(hdc, fuFlags) }
  540|       |#[allow(non_snake_case, unused_variables, dead_code)]
  541|      0|            #[inline] pub unsafe fn UseFontBitmaps(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD) -> types::BOOL>(self.UseFontBitmaps.f)(hDC, first, count, listBase) }
  542|       |#[allow(non_snake_case, unused_variables, dead_code)]
  543|      0|            #[inline] pub unsafe fn UseFontBitmapsA(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD) -> types::BOOL>(self.UseFontBitmapsA.f)(hDC, first, count, listBase) }
  544|       |#[allow(non_snake_case, unused_variables, dead_code)]
  545|      0|            #[inline] pub unsafe fn UseFontBitmapsW(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD) -> types::BOOL>(self.UseFontBitmapsW.f)(hDC, first, count, listBase) }
  546|       |#[allow(non_snake_case, unused_variables, dead_code)]
  547|      0|            #[inline] pub unsafe fn UseFontOutlines(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD, deviation: types::FLOAT, extrusion: types::FLOAT, format: __gl_imports::raw::c_int, lpgmf: types::LPGLYPHMETRICSFLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD, types::FLOAT, types::FLOAT, __gl_imports::raw::c_int, types::LPGLYPHMETRICSFLOAT) -> types::BOOL>(self.UseFontOutlines.f)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf) }
  548|       |#[allow(non_snake_case, unused_variables, dead_code)]
  549|      0|            #[inline] pub unsafe fn UseFontOutlinesA(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD, deviation: types::FLOAT, extrusion: types::FLOAT, format: __gl_imports::raw::c_int, lpgmf: types::LPGLYPHMETRICSFLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD, types::FLOAT, types::FLOAT, __gl_imports::raw::c_int, types::LPGLYPHMETRICSFLOAT) -> types::BOOL>(self.UseFontOutlinesA.f)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf) }
  550|       |#[allow(non_snake_case, unused_variables, dead_code)]
  551|      0|            #[inline] pub unsafe fn UseFontOutlinesW(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD, deviation: types::FLOAT, extrusion: types::FLOAT, format: __gl_imports::raw::c_int, lpgmf: types::LPGLYPHMETRICSFLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD, types::FLOAT, types::FLOAT, __gl_imports::raw::c_int, types::LPGLYPHMETRICSFLOAT) -> types::BOOL>(self.UseFontOutlinesW.f)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf) }
  552|       |}
  553|       |
  554|       |        unsafe impl __gl_imports::Send for Wgl {}
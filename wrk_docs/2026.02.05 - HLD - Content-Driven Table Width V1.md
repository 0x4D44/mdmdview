# HLD: Content-Driven Table Width

**Date**: 2026-02-05
**Status**: Design
**Authors**: Arthur + Claude

## 1. Problem Statement

Tables currently stretch to fill the full viewport width. A 2-column table with
short content (e.g., "Authentication Module" / "Complete") expands to ~1100px on
a typical display, with one column absorbing ~90% of the space as empty padding.

The root cause: `Column::remainder()` greedily fills all remaining space, and
the rendering pipeline unconditionally allocates `ui.available_width()` as the
table container width.

## 2. Design Goal

Tables should size to their content, capped at the viewport width. A 2-column
table with short text might be 300px wide; a 5-column data table might be 900px;
a table with long descriptions might fill the viewport. The table should never be
wider than the viewport (horizontal scroll aside), but also should never stretch
beyond what its content demands.

## 3. Current Pipeline (Relevant Steps)

```
MarkdownElement::Table { headers, rows, alignments }
       │
       ▼
column_stats_for_table()        → Vec<ColumnStat>     (content metrics)
       │
       ▼
derive_column_specs()           → Vec<ColumnSpec>      (Fixed/Resizable/Remainder/Auto)
       │
       ▼
resolve_table_column_widths()   → Vec<f32>             (per-column desired widths)
       │
       ▼
┌─ Layout calculations in render_table_tablebuilder() ─┐
│                                                       │
│  available_width = ui.available_width()     ◄── PROBLEM: always full viewport │
│  content_width = max(desired_total, available_width)                          │
│  use_hscroll = (fixed_total > available) OR (flex_mins > remaining)           │
│                                                       │
│  if !use_hscroll:                                     │
│    adjusted_widths = scale flex columns to fit         │
│    Column::remainder() fills ALL remaining  ◄── PROBLEM: greedy expansion    │
│  else:                                                │
│    render in horizontal scroll area                   │
│                                                       │
│  render_table(ui, max_width)                          │
│    ui.allocate_ui_with_layout(max_width, ...)         │
│    ui.set_width(max_width)              ◄── PROBLEM: forces full width       │
│    TableBuilder::new(ui)...                           │
└───────────────────────────────────────────────────────┘
```

There are three places where width is forced too wide:

1. **`available_width`** is always `ui.available_width()` (full viewport)
2. **`content_width`** uses `max(desired, available)` — always >= viewport
3. **`Column::remainder()`** expands greedily to fill its container

## 4. Proposed Pipeline

Insert a **content-width estimation step** between column spec resolution and
layout, and use it to cap the table container width.

```
MarkdownElement::Table { headers, rows, alignments }
       │
       ▼
column_stats_for_table()           → Vec<ColumnStat>
       │
       ▼
derive_column_specs()              → Vec<ColumnSpec>
       │
       ▼
resolve_table_column_widths()      → Vec<f32>
       │
       ▼
┌─ NEW: estimate_natural_table_width() ─────────────────┐
│                                                        │
│  natural_width = sum(resolved_widths) + spacing        │
│  table_width = min(natural_width, available_width)     │
│                                                        │
└────────────────────────────────────────────────────────┘
       │
       ▼
┌─ MODIFIED: render_table_tablebuilder() ───────────────┐
│                                                        │
│  table_width replaces available_width as the budget    │
│  Remainder columns share (table_width - fixed_total)   │
│  No column expands beyond its resolved width           │
│                                                        │
│  render_table(ui, table_width)                         │
│  ui.allocate_ui_with_layout(table_width, ...)          │
│                                                        │
└────────────────────────────────────────────────────────┘
```

## 5. Detailed Design

### 5.1 New Function: `estimate_natural_table_width`

There is already a test-only function `estimate_table_total_width` that computes
`sum(resolved_widths) + spacing`. However, that function uses `resolved_widths`
which are based on the column *policies* (Fixed width, Resizable preferred, etc.)
rather than on the actual *content*.

The new function differs in that it estimates each column's width from its
content statistics, independent of the classification policy.

```rust
/// Compute the natural width this table needs based on content.
///
/// For each column, estimates pixel width from content statistics
/// (grapheme count, longest word, rich content flags) and font size.
/// Returns the sum of column widths + inter-column spacing, which
/// represents the width the table "wants" to be before any viewport
/// capping or scaling.
fn estimate_natural_table_width(
    &self,
    column_specs: &[ColumnSpec],
    column_stats: &[ColumnStat],
    headers: &[Vec<InlineSpan>],
    column_spacing: f32,
) -> f32
```

**Algorithm:**

```
for each column i:
    // Start with header text width
    header_width = grapheme_width(header_text[i]) * char_width_estimate

    // Content width from stats
    if stats[i] exists:
        content_width = max(stats[i].max_graphemes, stats[i].longest_word)
                        * char_width_estimate
        if stats[i].has_image:
            content_width = max(content_width, IMAGE_MIN_WIDTH)
        if stats[i].has_link:
            content_width = max(content_width, LINK_MIN_WIDTH)
    else:
        content_width = header_width

    // Use the wider of header vs content, with padding
    column_width = max(header_width, content_width) + cell_padding

    // Clamp to sane bounds
    column_width = clamp(column_width, MIN_COL_WIDTH, MAX_COL_WIDTH)

    natural_widths[i] = column_width

natural_table_width = sum(natural_widths) + spacing * (n - 1)
```

**Constants** (all relative to `body_font_px` for zoom support):

| Constant | Formula | At 14px | Purpose |
|----------|---------|---------|---------|
| `char_width_estimate` | `body_font_px * 0.6` | 8.4px | Approximate average character width |
| `cell_padding` | `body_font_px * 1.5` | 21px | Horizontal padding inside cell |
| `MIN_COL_WIDTH` | `body_font_px * 4.0` | 56px | Minimum column width |
| `MAX_COL_WIDTH` | `body_font_px * 35.0` | 490px | Maximum single column width |
| `IMAGE_MIN_WIDTH` | `body_font_px * 12.0` | 168px | Minimum for image columns |
| `LINK_MIN_WIDTH` | `body_font_px * 10.0` | 140px | Minimum for link columns |

### 5.2 Modified: `render_table_tablebuilder`

**Change 1**: Compute effective table width

Replace the current:
```rust
let available_width = ui.available_width().max(1.0);
```

With:
```rust
let viewport_width = ui.available_width().max(1.0);
let natural_width = self.estimate_natural_table_width(
    &column_specs, &column_stats, headers, column_spacing,
);
let effective_width = natural_width.min(viewport_width);
```

Then use `effective_width` instead of `available_width` throughout the
layout calculations. The variable `available_width` should be renamed to
`viewport_width` for clarity; a new `effective_width` becomes the actual
space budget for the table.

**Change 2**: Replace Remainder with proportional sharing

When the table's natural width exceeds `effective_width`, the flexible
columns need to share the shortfall proportionally. When natural width is
*less* than effective width, columns should keep their natural widths -
no expansion.

Current code (lines 4104-4126) scales flexible columns down when they
exceed remaining space. This logic stays, but operates on `effective_width`
rather than `viewport_width`.

The key change is: when `natural_width < viewport_width`, the table
container itself is narrower, so `Column::remainder()` only absorbs
space within the (smaller) container, not the whole viewport.

**Change 3**: Pass `effective_width` to `render_table` closure

The `render_table` closure at line 4179 currently receives `max_width`
which is either `content_width` (hscroll) or `available_width`. Change
the non-hscroll path:

Current:
```rust
} else {
    render_table(ui, available_width);
}
```

Proposed:
```rust
} else {
    render_table(ui, effective_width);
}
```

Inside `render_table`, the `ui.allocate_ui_with_layout` and
`ui.set_width` calls will use this capped width, constraining the
`TableBuilder` to the natural content width.

### 5.3 Impact on `use_hscroll` Decision

The `use_hscroll` check currently compares against `available_width`
(viewport). With the new design, `effective_width` is always ≤ viewport,
so horizontal scroll is triggered when the fixed column total alone
exceeds the viewport - which is unchanged behaviour. The only change is
that the no-scroll path uses a tighter width.

```rust
// use_hscroll is still decided against viewport (not effective_width)
// because scroll should trigger when content can't fit the VIEWPORT
let use_hscroll = viewport_width_for_columns <= 0.0
    || fixed_total > viewport_width_for_columns + 0.5
    || remaining_for_flex < min_flex_total - 0.5;
```

No change to hscroll logic.

### 5.4 Impact on Column Policy System

The `derive_column_specs` function and `ColumnPolicy` enum remain
unchanged. The key insight is: we don't need to fix column *policies*
because the problem is in the *container width*, not in how columns
distribute space within that container.

- `Column::remainder()` still works correctly - it fills the remaining
  space. But now "remaining space" is `effective_width - fixed_total`
  instead of `viewport_width - fixed_total`.
- The all-Fixed-columns bug is also resolved: even if no column is
  Remainder, the table container is sized to content so the Fixed
  columns appear at their correct widths without empty space to the
  right.

### 5.5 Impact on Persisted Widths

User-resizable columns store their widths in `persisted_column_widths`.
These widths were captured from `body.widths()` and represent pixel
values. Under the new design, the same persistence mechanism works
because:

1. `apply_persisted_widths` is called before width estimation, updating
   Resizable specs with user-chosen widths
2. `estimate_natural_table_width` considers the resolved widths (which
   include persisted values)
3. If a user widens a column, the natural width grows, the effective
   width grows (up to viewport), and the table accommodates

No changes needed.

### 5.6 Zoom Behaviour

All constants in §5.1 are relative to `body_font_px`, so zoom in/out
automatically scales the natural width estimates. At 2× zoom,
`char_width_estimate` doubles, so natural widths double, and the table
grows proportionally.

No changes needed.

## 6. Worked Examples

### Example A: 2-Column Short Content (The Bug Case)

```markdown
| Name | Status |
|------|--------|
| Authentication Module | Complete |
| Database Layer | In Progress |
```

**Column stats**:
- Column 0: max_graphemes=21 ("Authentication Module"), longest_word=14 ("Authentication")
- Column 1: max_graphemes=11 ("In Progress"), longest_word=8 ("Progress")

**Natural width calculation** (at 14px font):
- char_width = 14 × 0.6 = 8.4px
- padding = 14 × 1.5 = 21px
- Col 0: max(4 × 8.4, 21 × 8.4) + 21 = 176.4 + 21 = 197px
- Col 1: max(6 × 8.4, 11 × 8.4) + 21 = 92.4 + 21 = 113px
- spacing: 6px × 1 = 6px
- **natural_width = 197 + 113 + 6 = 316px**

**Viewport**: 1100px

**effective_width = min(316, 1100) = 316px**

Table renders at 316px wide, left-aligned. Content fits naturally.

### Example B: 5-Column Data Table

```markdown
| Operation | Time (ms) | Memory (MB) | CPU (%) | Status |
|-----------|-----------|-------------|---------|--------|
| File Load | 12.5 | 45.2 | 15 | Pass |
| Syntax Highlight | 45.7 | 89.4 | 78 | Slow |
```

**Column stats**:
- Col 0: max_graphemes=16 ("Syntax Highlight"), longest_word=9
- Col 1: max_graphemes=9 ("Time (ms)"), longest_word=4
- Col 2: max_graphemes=11 ("Memory (MB)"), longest_word=6
- Col 3: max_graphemes=7 ("CPU (%)"), longest_word=3
- Col 4: max_graphemes=6 ("Status"), longest_word=6

**Natural width** (at 14px):
- Col 0: max(9, 16) × 8.4 + 21 = 134 + 21 = 155px
- Col 1: max(9, 9) × 8.4 + 21 = 76 + 21 = 97px
- Col 2: max(11, 11) × 8.4 + 21 = 92 + 21 = 113px
- Col 3: max(7, 7) × 8.4 + 21 = 59 + 21 = 80px
- Col 4: max(6, 6) × 8.4 + 21 = 50 + 21 = 71px
- spacing: 6 × 4 = 24px
- **natural_width = 155 + 97 + 113 + 80 + 71 + 24 = 540px**

**effective_width = min(540, 1100) = 540px**

Table renders at 540px. Compact, readable, not stretched.

### Example C: Table With Long Description

```markdown
| ID | Description |
|----|-------------|
| 1 | This module handles all authentication flows including OAuth2, SAML, and JWT token validation with automatic refresh |
```

**Column stats**:
- Col 0: max_graphemes=2, longest_word=2
- Col 1: max_graphemes=109, longest_word=14 ("authentication")

**Natural width** (at 14px):
- Col 0: max(2, 2) × 8.4 + 21 = 17 + 21 = 56px (clamped to MIN_COL_WIDTH=56px)
- Col 1: max(109, 14) × 8.4 + 21 = 916 + 21 = 937px → clamped to MAX_COL_WIDTH=490px
- spacing: 6px
- **natural_width = 56 + 490 + 6 = 552px**

**effective_width = min(552, 1100) = 552px**

Description column wraps at 490px. The long text wraps into multiple
lines within the cell. Table doesn't stretch to viewport.

### Example D: Wide Table That Needs Scroll

```markdown
| ID | Name | Type | Status | Priority | Created | Updated | Author | Tags |
```

With 9 columns of moderate content:
- Each column ≈ 100-150px natural
- natural_width ≈ 1100px + 48px spacing = ~1148px
- viewport = 1100px
- **effective_width = min(1148, 1100) = 1100px**

Columns scale down slightly to fit. If fixed columns alone exceed
viewport, horizontal scroll kicks in (unchanged from current behaviour).

### Example E: All-Fixed Columns (Original Bug)

```markdown
| Name | Status |
|------|--------|
| Widget | Active |
```

With the current policy logic, both columns are classified `Fixed`:
- Col 0 "Name" (index 0, short) → Fixed ~98px
- Col 1 "Status" → Fixed ~98px

**natural_width = 98 + 98 + 6 = 202px**

**effective_width = min(202, 1100) = 202px**

Table renders at 202px. Both columns at their Fixed widths. No extra
space to the right, no squishing. The "squished left" problem is
eliminated because the table container is only 202px, not 1100px —
there is no gap between table and surrounding content flow.

This means the original all-Fixed bug is **also resolved without
needing the Remainder fallback fix**. We can delete that fallback
entirely.

## 7. Edge Cases

### 7.1 Single Column

- natural_width = one column width + 0 spacing
- Table is narrow (maybe 100-200px), left-aligned
- Correct: single column shouldn't stretch

### 7.2 Empty Table (Headers Only)

- Stats come from headers only
- natural_width from header text widths
- Renders as header-width table with no body rows

### 7.3 Very Narrow Viewport (e.g. 300px)

- effective_width = min(natural_width, 300)
- If natural_width > 300, columns scale down or hscroll activates
- Same behaviour as current for narrow viewports

### 7.4 User Has Resized Columns

- `apply_persisted_widths` updates Resizable column preferred widths
- `resolve_table_column_widths` uses those persisted values
- `estimate_natural_table_width` picks up the wider resolved values
- Table widens to accommodate user's choice, up to viewport

### 7.5 Table With Images

- `has_image` flag sets column minimum to IMAGE_MIN_WIDTH (168px)
- Image columns are wide enough to display meaningful content
- natural_width accounts for this

### 7.6 Zoom In/Out

- All constants scale with `body_font_px`
- At 2× zoom, char_width_estimate doubles
- natural_width doubles → effective_width grows (capped at viewport)
- Columns scale proportionally

## 8. Files to Modify

### 8.1 `src/table_support/column_spec.rs`

No changes required. Column policies remain as-is. The previous
Remainder-fallback fix should remain reverted.

### 8.2 `src/markdown_renderer.rs`

**Remove `#[cfg(test)]`** from `estimate_table_total_width` (or replace
with new function).

**New function**: `estimate_natural_table_width` (~40 lines)
- Input: column specs, column stats, headers, column spacing
- Output: natural table width in pixels
- Location: near existing `estimate_table_*` functions

**Modified function**: `render_table_tablebuilder` (~15 lines changed)
- Compute `effective_width = min(natural_width, viewport_width)`
- Replace `available_width` with `effective_width` in layout calcs
- Pass `effective_width` to `render_table` closure in no-scroll path
- Rename `available_width` → `viewport_width` for clarity

Estimated diff: ~60 lines added/changed, 0 deleted.

### 8.3 Tests

**New tests**:
- `test_natural_width_two_short_columns` — verifies 2-col table << viewport
- `test_natural_width_scales_with_content` — longer content → wider table
- `test_natural_width_capped_at_viewport` — natural width never exceeds viewport
- `test_natural_width_respects_max_col_width` — single long column is capped
- `test_effective_width_all_fixed_columns` — original bug case resolved

**Updated tests**:
- Any tests that assert on table width should be checked against new behaviour

## 9. Migration / Backward Compatibility

- Column policies unchanged — user's existing column resize state is preserved
- No serialised state changes — `persisted_column_widths` format unchanged
- Visual change: tables will be narrower on wide viewports (intended)
- No API changes — internal-only refactoring

## 10. Risks

| Risk | Mitigation |
|------|------------|
| `char_width_estimate` is inaccurate for CJK/emoji | Use `unicode_width` for content stats (already done); estimate is a multiplier on grapheme count which accounts for double-width chars |
| Two-pass overhead on large tables | The estimation is arithmetic on already-computed `ColumnStat` values — negligible cost |
| Tables look "too narrow" compared to before | The constants (cell_padding, char_width_estimate) can be tuned; `MAX_COL_WIDTH` provides upper bound |
| Regression in hscroll behaviour | hscroll decision still uses viewport width, not effective width |

## 11. Summary

The fix is localised to `render_table_tablebuilder`: compute a
content-driven `effective_width` and use it as the table container's
width budget instead of the full viewport width. Columns distribute
space within this tighter budget using the same policy logic as today.

This resolves both the original "squished left" bug (table container
matches content width, no empty gap) and the overcorrection "stretched
full width" bug (container never exceeds content needs).

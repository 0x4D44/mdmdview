# Table Width Sizing Analysis

**Date**: 2026-02-05
**Status**: Design Analysis (Pre-Implementation)

## Problem Statement

The current fix for 2-column tables that were "squished to the left" has overcorrected: tables now stretch to full viewport width even when content is short. This creates excessive whitespace and looks unnatural.

**Screenshot observation**: A table like `| Name | Status |` with content like "Authentication Module" / "Complete" stretches to fill ~1100px viewport width, with the "Name" column taking ~1000px while "Status" gets ~100px.

## Current Architecture

### Column Policy Types

```rust
enum ColumnPolicy {
    Auto,                          // Content-driven, shrinks to fit
    Fixed { width, clip },         // Exact pixel width
    Remainder { clip },            // Fill ALL remaining space
    Resizable { min, preferred, clip }, // Start at preferred, user-resizable
}
```

### Current Classification Logic

1. **First column (index 0)** with short content → `Fixed`
2. **Special headers** (Status, Date, ID, Version, etc.) → `Fixed`
3. **Description-like headers** (Notes, Summary) → `Resizable`
4. **Wide content** (>60 graphemes, links, images) → `Remainder`
5. **Default** → `Resizable`
6. **Fallback** (recent fix): If no `Remainder`, convert last column → `Remainder`

### The Core Issue

`Column::remainder()` in egui_extras fills **ALL** remaining space. When the table is allocated full viewport width:
- Fixed columns get their exact widths
- Remainder column gets `viewport_width - fixed_total`
- This makes sense for 5+ column tables with long content
- This looks terrible for 2-column tables with short content

## Test Scenario Analysis

### Scenario 1: Two Short Columns

**Table**: `| Name | Status |` with "Widget A" / "Active"

| Policy | Current Behavior | Ideal Behavior |
|--------|------------------|----------------|
| Both Fixed | Squished left (original bug) | - |
| First Fixed, Second Remainder | Second column fills 90% of screen | Columns size to content |

**Current result**: ~100px + ~900px = ugly
**Ideal result**: ~100px + ~80px = ~180px total, left-aligned

### Scenario 2: Two Columns, One Long

**Table**: `| ID | Description |` with "001" / "A very long description..."

| Policy | Current Behavior | Ideal Behavior |
|--------|------------------|----------------|
| First Fixed, Second Remainder | Works well - description uses space | Same |

**Current result**: Works reasonably
**Ideal result**: Same - this is the happy path

### Scenario 3: Single Column

**Table**: `| Item |` with "Apple", "Banana"

| Policy | Current Behavior | Ideal Behavior |
|--------|------------------|----------------|
| Remainder (from fix) | Column fills entire width | Size to content (~100px) |

**Current result**: Full width single column = looks broken
**Ideal result**: Compact column, maybe 100-150px

### Scenario 4: Five+ Columns, Mixed Content

**Table**: Large data table with ID, Name, Status, Created, Notes

| Policy | Current Behavior | Ideal Behavior |
|--------|------------------|----------------|
| Mix of Fixed + Remainder | Usually works | Same |

**Current result**: Generally acceptable
**Ideal result**: Same

### Scenario 5: All Short Content, Many Columns

**Table**: `| A | B | C | D | E |` with tiny values

| Policy | Current Behavior | Ideal Behavior |
|--------|------------------|----------------|
| Mostly Fixed + 1-2 Remainder | Remainder columns stretch excessively | Compact table |

**Current result**: Remainder columns waste space
**Ideal result**: Table ~300px wide, not ~1100px

## Root Cause Analysis

The fundamental assumption is flawed:

> **Current assumption**: Tables should fill available width, with one or more columns expanding to absorb extra space.

> **Better assumption**: Tables should size to content, with a maximum width cap, only expanding when content demands it.

### Why Remainder Doesn't Work for Short Content

```
Available width: 1000px
Fixed columns: 150px total
Remainder gets: 850px (way too much for "Active" text)
```

### Why the Original Bug Occurred

All columns were Fixed, so total table width = sum of fixed widths. Table was left-aligned at maybe 300px total, leaving 700px of empty space to the right. This looked "squished" but was actually closer to correct than full-width.

## Proposed Design Philosophy

### Principle 1: Content-First Sizing

Tables should size to their content, not to available space. Extra viewport space should remain empty (or table centered), not absorbed into columns.

### Principle 2: Maximum Width Caps

Even with long content, tables should have a maximum width (e.g., 80% of viewport or 1200px) to prevent excessive stretching on ultra-wide displays.

### Principle 3: Smart Column Flex

When a table IS wider than content needs:
- Don't expand columns with short content
- Only expand "description-like" columns that benefit from wrapping
- Provide visual breathing room proportionally, not greedily

### Principle 4: Minimum Readability

Columns should have minimums to remain legible, but not artificially expand beyond content needs.

## Proposed Solution Approaches

### Approach A: Replace Remainder with Auto

**Concept**: Use `Column::auto()` instead of `Column::remainder()` for most cases.

**Pros**:
- Auto sizes to content naturally
- Won't stretch excessively

**Cons**:
- May cause layout instability as content changes
- egui's auto sizing may not be predictable enough

**Implementation**: Change fallback at line 285 to use `Auto` instead of `Remainder`

### Approach B: Table Max-Width Container

**Concept**: Wrap table in a container with max-width, let columns size naturally within that constraint.

**Pros**:
- Simple conceptual model
- Works for all column counts

**Cons**:
- Requires changes to table rendering, not just column spec
- May not integrate well with current horizontal scroll logic

**Implementation**:
```rust
let max_table_width = (available_width * 0.85).min(1200.0);
let content_width = estimate_content_width(&specs);
let actual_width = content_width.min(max_table_width);
```

### Approach C: Capped Remainder

**Concept**: Remainder columns have a maximum expansion based on content statistics.

**Pros**:
- Keeps current architecture
- Targeted fix

**Cons**:
- Complex heuristics
- May still look off in edge cases

**Implementation**:
```rust
ColumnPolicy::CappedRemainder {
    min: f32,
    max: f32,  // Based on max content width in column
    clip: bool
}
```

### Approach D: Content-Driven Table Width

**Concept**: Calculate table width from column content first, then allocate to columns.

**Pros**:
- Most accurate to content
- Handles all scenarios well

**Cons**:
- Requires two-pass layout (measure, then render)
- More complex implementation

**Implementation**:
1. Measure preferred width for each column based on content
2. Sum to get natural table width
3. Clamp to viewport (with scroll if needed)
4. Allocate back to columns proportionally

## Recommendation

**Approach D (Content-Driven Table Width)** is the most correct solution, but **Approach B (Table Max-Width Container)** is simpler to implement and solves most issues.

### Quick Fix (Approach B Simplified)

For the immediate problem, modify the table rendering to:

1. Estimate total content width from column stats
2. Use `min(content_width * 1.2, available_width)` as table width
3. Don't use `Remainder` - use `Resizable` with max based on content

This prevents tables from stretching beyond their natural content width plus some padding.

## Test Scenarios for Validation

Before implementing, the solution should be validated against:

| Scenario | Expected Width | Notes |
|----------|----------------|-------|
| 2 col, short content | ~200-300px | Should NOT fill viewport |
| 2 col, long description | ~600-800px | Description wraps |
| 5 col data table | ~800-1000px | Fills most of viewport |
| Single column | ~150px | Definitely not full width |
| 10+ columns | Horizontal scroll | Don't cramp columns |
| Empty columns | Minimum ~40px each | Remain visible |

## Files to Modify

1. `src/table_support/column_spec.rs` - Column policy logic
2. `src/markdown_renderer.rs` - Table rendering (lines 4044-4449)
3. Potentially new module for content width estimation

## Next Steps

1. [ ] Decide on approach (recommend B or D)
2. [ ] Prototype in branch
3. [ ] Test against all scenarios above
4. [ ] Measure performance impact (two-pass may be slower)
5. [ ] Refine heuristics based on real-world documents

---

## Appendix: Current Code Flow

```
derive_column_specs()
  → classify_column() for each column
  → fallback logic ensures ≥1 Remainder

render_table_tablebuilder()
  → resolve_table_column_widths()
  → build column_layout with Column::remainder() etc.
  → TableBuilder::new(ui).column(col)...
  → ui.allocate_ui_with_layout(Vec2::new(max_width, 0.0), ...)

Key issue: max_width = available_width (full viewport)
          Remainder fills (max_width - fixed_total)
```

## Appendix: Reverting the Overcorrection

If needed, the immediate fix can be reverted by removing lines 285-293 in column_spec.rs. This brings back the "squished" bug but avoids the "stretched" bug. Neither is correct; a proper redesign is needed.

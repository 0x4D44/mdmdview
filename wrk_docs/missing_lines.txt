C:\language\mdmdview\src\app.rs:
    1|       |/// Main application logic for the markdown viewer
    2|       |///
    3|       |/// This module contains the primary app state, UI logic, and event handling
    4|       |/// for the markdown viewer application built with egui.
    5|       |use crate::{MarkdownElement, MarkdownRenderer, SampleFile, WindowState, SAMPLE_FILES};
    6|       |use anyhow::{bail, Result};
    7|       |use crossbeam_channel::{unbounded, Receiver, Sender};
    8|       |use egui::text::LayoutJob;
    9|       |use egui::text::TextFormat;
   10|       |use egui::{menu, CentralPanel, Color32, Context, RichText, TopBottomPanel};
   11|       |use egui::{TextEdit, TextStyle};
   12|       |use image::{imageops, RgbaImage};
   13|       |#[cfg(not(test))]
   14|       |use rfd::FileDialog;
   15|       |#[cfg(test)]
   16|       |use std::cell::RefCell;
   17|       |#[cfg(test)]
   18|       |use std::collections::HashSet;
   19|       |use std::collections::VecDeque;
   20|       |use std::io::ErrorKind;
   21|       |use std::path::{Path, PathBuf};
   22|       |#[cfg(test)]
   23|       |use std::sync::atomic::{AtomicBool, Ordering};
   24|       |use std::time::{Duration, Instant};
   25|       |use unicode_casefold::UnicodeCaseFold;
   26|       |use unicode_normalization::UnicodeNormalization;
   27|       |
   28|       |/// Prefix used for application/window titles.
   29|       |pub const APP_TITLE_PREFIX: &str = "mdmdview";
   30|       |const BUILD_VERSION: &str = env!("CARGO_PKG_VERSION");
   31|       |const BUILD_TIMESTAMP: &str = env!("MDMDVIEW_BUILD_TIMESTAMP");
   32|       |const ASYNC_LOAD_THRESHOLD_BYTES: u64 = 2 * 1024 * 1024;
   33|       |
   34|       |#[cfg(test)]
   35|       |thread_local! {
   36|       |    static FORCED_APP_ACTIONS: RefCell<HashSet<&'static str>> = RefCell::new(HashSet::new());
   37|       |    static FORCED_OPEN_PATH: RefCell<Option<PathBuf>> = const { RefCell::new(None) };
   38|       |    static FORCED_SAVE_PATH: RefCell<Option<PathBuf>> = const { RefCell::new(None) };
   39|       |    static FORCED_LOAD_ERROR: RefCell<bool> = const { RefCell::new(false) };
   40|       |    static FORCED_SCAN_ERROR: RefCell<bool> = const { RefCell::new(false) };
   41|       |    static FORCED_SCAN_ENTRY_ERROR: RefCell<bool> = const { RefCell::new(false) };
   42|       |    static FORCED_READ_LOSSY_ERROR: RefCell<bool> = const { RefCell::new(false) };
   43|       |}
   44|       |
   45|       |#[cfg(test)]
   46|       |static FORCE_THREAD_SPAWN_ERROR: AtomicBool = AtomicBool::new(false);
   47|       |
   48|       |#[cfg(test)]
   49|    975|fn app_action_triggered(triggered: bool, action: &'static str) -> bool {
   50|    975|    triggered || FORCED_APP_ACTIONS.with(|actions| actions.borrow().contains(action))
                               ^974               ^974           ^974             ^974     ^974
   51|    975|}
   52|       |
   53|       |#[cfg(not(test))]
   54|       |fn app_action_triggered(triggered: bool, _action: &'static str) -> bool {
   55|       |    triggered
   56|       |}
   57|       |
   58|       |#[cfg(test)]
   59|      8|fn take_forced_open_path() -> Option<PathBuf> {
   60|      8|    FORCED_OPEN_PATH.with(|slot| slot.borrow_mut().take())
   61|      8|}
   62|       |
   63|       |#[cfg(test)]
   64|      6|fn take_forced_save_path() -> Option<PathBuf> {
   65|      6|    FORCED_SAVE_PATH.with(|slot| slot.borrow_mut().take())
   66|      6|}
   67|       |
   68|       |#[cfg(test)]
   69|     27|fn take_forced_load_error() -> bool {
   70|     27|    FORCED_LOAD_ERROR.with(|flag| flag.replace(false))
   71|     27|}
   72|       |
   73|       |#[cfg(test)]
   74|      8|fn take_forced_scan_error() -> bool {
   75|      8|    FORCED_SCAN_ERROR.with(|flag| flag.replace(false))
   76|      8|}
   77|       |
   78|       |#[cfg(test)]
   79|     10|fn take_forced_scan_entry_error() -> bool {
   80|     10|    FORCED_SCAN_ENTRY_ERROR.with(|flag| flag.replace(false))
   81|     10|}
   82|       |
   83|       |#[cfg(test)]
   84|      3|fn take_forced_read_lossy_error() -> bool {
   85|      3|    FORCED_READ_LOSSY_ERROR.with(|flag| flag.replace(false))
   86|      3|}
   87|       |
   88|       |/// Entry in navigation history for back/forward navigation
   89|       |#[derive(Clone, Debug)]
   90|       |struct HistoryEntry {
   91|       |    file_path: Option<PathBuf>,
   92|       |    title: String,
   93|       |    content: String,
   94|       |}
   95|       |
   96|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
   97|       |pub enum ScreenshotTheme {
   98|       |    Light,
   99|       |    Dark,
  100|       |}
  101|       |
  102|       |impl ScreenshotTheme {
  103|     14|    fn as_str(self) -> &'static str {
  104|     14|        match self {
  105|     11|            ScreenshotTheme::Light => "light",
  106|      3|            ScreenshotTheme::Dark => "dark",
  107|       |        }
  108|     14|    }
  109|       |}
  110|       |
  111|       |#[derive(Clone, Debug)]
  112|       |pub struct ScreenshotConfig {
  113|       |    pub output_path: PathBuf,
  114|       |    pub viewport_width: f32,
  115|       |    pub viewport_height: f32,
  116|       |    pub content_only: bool,
  117|       |    pub scroll_ratio: Option<f32>,
  118|       |    pub wait_ms: u64,
  119|       |    pub settle_frames: u32,
  120|       |    pub zoom: f32,
  121|       |    pub theme: ScreenshotTheme,
  122|       |    pub font_source: Option<String>,
  123|       |}
  124|       |
  125|       |impl ScreenshotConfig {
  126|     13|    fn metadata_path(&self) -> PathBuf {
  127|     13|        self.output_path.with_extension("json")
  128|     13|    }
  129|       |}
  130|       |
  131|       |#[derive(Clone, Copy, Debug)]
  132|       |struct ScrollSnapshot {
  133|       |    content_size: egui::Vec2,
  134|       |    inner_rect: egui::Rect,
  135|       |    offset_y: f32,
  136|       |}
  137|       |
  138|       |#[derive(Debug, Clone, Copy)]
  139|       |struct WindowAdjustment {
  140|       |    pos: Option<egui::Pos2>,
  141|       |    size: Option<egui::Vec2>,
  142|       |}
  143|       |
  144|       |struct FileLoadRequest {
  145|       |    id: u64,
  146|       |    path: PathBuf,
  147|       |}
  148|       |
  149|       |struct FileLoadResult {
  150|       |    id: u64,
  151|       |    content: Result<(String, bool), String>,
  152|       |}
  153|       |
  154|       |#[derive(Clone)]
  155|       |struct PendingFileLoad {
  156|       |    id: u64,
  157|       |    path: PathBuf,
  158|       |}
  159|       |
  160|       |#[derive(Debug)]
  161|       |struct ScreenshotState {
  162|       |    config: ScreenshotConfig,
  163|       |    started: Instant,
  164|       |    stable_frames: u32,
  165|       |    last_layout_hash: Option<u64>,
  166|       |    last_scroll_offset: Option<f32>,
  167|       |    scroll_offset: Option<f32>,
  168|       |    content_rect: Option<egui::Rect>,
  169|       |    last_content_size: Option<egui::Vec2>,
  170|       |    last_inner_rect: Option<egui::Rect>,
  171|       |    pixels_per_point: f32,
  172|       |    viewport_adjusted: bool,
  173|       |    requested: bool,
  174|       |    done: bool,
  175|       |    timed_out: bool,
  176|       |    pending_renders: bool,
  177|       |}
  178|       |
  179|       |#[derive(Clone, Debug)]
  180|       |struct ScreenshotSnapshot {
  181|       |    config: ScreenshotConfig,
  182|       |    content_rect: Option<egui::Rect>,
  183|       |    pixels_per_point: f32,
  184|       |    stable_frames: u32,
  185|       |    timed_out: bool,
  186|       |    pending_renders: bool,
  187|       |    last_scroll_offset: Option<f32>,
  188|       |    started: Instant,
  189|       |}
  190|       |
  191|       |impl ScreenshotState {
  192|     14|    fn new(config: ScreenshotConfig) -> Self {
  193|     14|        Self {
  194|     14|            config,
  195|     14|            started: Instant::now(),
  196|     14|            stable_frames: 0,
  197|     14|            last_layout_hash: None,
  198|     14|            last_scroll_offset: None,
  199|     14|            scroll_offset: None,
  200|     14|            content_rect: None,
  201|     14|            last_content_size: None,
  202|     14|            last_inner_rect: None,
  203|     14|            pixels_per_point: 1.0,
  204|     14|            viewport_adjusted: false,
  205|     14|            requested: false,
  206|     14|            done: false,
  207|     14|            timed_out: false,
  208|     14|            pending_renders: false,
  209|     14|        }
  210|     14|    }
  211|       |
  212|      6|    fn record_scroll(&mut self, snapshot: ScrollSnapshot) -> bool {
  213|      6|        self.last_content_size = Some(snapshot.content_size);
  214|      6|        self.last_inner_rect = Some(snapshot.inner_rect);
  215|      6|        self.last_scroll_offset = Some(snapshot.offset_y);
  216|       |
  217|      6|        if self.scroll_offset.is_none() {
  218|      3|            if let Some(ratio) = self.config.scroll_ratio {
                                      ^2
  219|      2|                let max_scroll = (snapshot.content_size.y - snapshot.inner_rect.height()).max(0.0);
  220|      2|                self.scroll_offset = Some((max_scroll * ratio).round());
  221|      2|                return true;
  222|      1|            }
  223|      3|        }
  224|      4|        false
  225|      6|    }
  226|       |
  227|      9|    fn scroll_ready(&self) -> bool {
  228|       |        match (
  229|      9|            self.config.scroll_ratio,
  230|      9|            self.scroll_offset,
  231|      9|            self.last_scroll_offset,
  232|       |        ) {
  233|      3|            (None, _, _) => true,
  234|      3|            (Some(_), Some(target), Some(actual)) => (actual - target).abs() <= 0.5,
  235|      3|            _ => false,
  236|       |        }
  237|      9|    }
  238|       |
  239|      9|    fn update_stability(&mut self, layout_hash: Option<u64>, scroll_offset: Option<f32>) {
  240|      9|        let mut changed = false;
  241|      9|        if let Some(hash) = layout_hash {
                                  ^5
  242|      5|            if self.last_layout_hash != Some(hash) {
  243|      4|                changed = true;
  244|      4|            }
                          ^1
  245|      5|            self.last_layout_hash = Some(hash);
  246|      4|        } else {
  247|      4|            changed = true;
  248|      4|        }
  249|       |
  250|      9|        if let (Some(prev), Some(current)) = (self.last_scroll_offset, scroll_offset) {
                                   ^4          ^4
  251|      4|            if (prev - current).abs() > 0.5 {
  252|      1|                changed = true;
  253|      3|            }
  254|      5|        }
  255|       |
  256|      9|        if changed {
  257|      8|            self.stable_frames = 0;
  258|      8|        } else {
  259|      1|            self.stable_frames = self.stable_frames.saturating_add(1);
  260|      1|        }
  261|      9|    }
  262|       |}
  263|       |
  264|       |impl From<&ScreenshotState> for ScreenshotSnapshot {
  265|      2|    fn from(state: &ScreenshotState) -> Self {
  266|      2|        Self {
  267|      2|            config: state.config.clone(),
  268|      2|            content_rect: state.content_rect,
  269|      2|            pixels_per_point: state.pixels_per_point,
  270|      2|            stable_frames: state.stable_frames,
  271|      2|            timed_out: state.timed_out,
  272|      2|            pending_renders: state.pending_renders,
  273|      2|            last_scroll_offset: state.last_scroll_offset,
  274|      2|            started: state.started,
  275|      2|        }
  276|      2|    }
  277|       |}
  278|       |
  279|       |/// Main application state and logic
  280|       |pub struct MarkdownViewerApp {
  281|       |    /// Markdown renderer instance
  282|       |    renderer: MarkdownRenderer,
  283|       |    /// Currently loaded file path
  284|       |    current_file: Option<PathBuf>,
  285|       |    /// Current markdown content as string
  286|       |    current_content: String,
  287|       |    /// Buffer for raw view (read-only for now)
  288|       |    raw_buffer: String,
  289|       |    /// Parsed markdown elements ready for rendering
  290|       |    parsed_elements: Vec<MarkdownElement>,
  291|       |    /// Application title for window
  292|       |    title: String,
  293|       |    /// Error message to display if any
  294|       |    error_message: Option<String>,
  295|       |    /// Navigation request for keyboard shortcuts
  296|       |    nav_request: Option<NavigationRequest>,
  297|       |    /// Scroll area ID for state management
  298|       |    scroll_area_id: egui::Id,
  299|       |    /// Flag to request fullscreen toggle
  300|       |    toggle_fullscreen: bool,
  301|       |    /// Current view mode
  302|       |    view_mode: ViewMode,
  303|       |    /// Wrap long lines in raw view
  304|       |    wrap_raw: bool,
  305|       |    /// Write mode: allow editing in Raw view
  306|       |    write_enabled: bool,
  307|       |    /// Remember caret position in raw editor (byte index)
  308|       |    raw_cursor: Option<usize>,
  309|       |    /// Request focus for raw editor on next render
  310|       |    raw_focus_requested: bool,
  311|       |    /// Flag to request reload of current file (handled outside input context)
  312|       |    reload_requested: bool,
  313|       |    /// Defer toggling view mode to outside input context
  314|       |    view_toggle_requested: bool,
  315|       |    /// Defer toggling write mode to outside input context
  316|       |    write_toggle_requested: bool,
  317|       |    /// Last known window position (for persistence)
  318|       |    last_window_pos: Option<[f32; 2]>,
  319|       |    /// Last known window size (for persistence)
  320|       |    last_window_size: Option<[f32; 2]>,
  321|       |    /// Last known maximized state
  322|       |    last_window_maximized: bool,
  323|       |    /// Last persisted window snapshot to avoid redundant disk writes
  324|       |    last_persisted_state: Option<WindowState>,
  325|       |    /// Throttle saving window state
  326|       |    last_persist_instant: std::time::Instant,
  327|       |    file_load_tx: Sender<FileLoadRequest>,
  328|       |    file_load_rx: Receiver<FileLoadResult>,
  329|       |    pending_file_load: Option<PendingFileLoad>,
  330|       |    next_file_load_id: u64,
  331|       |    // Search state
  332|       |    show_search: bool,
  333|       |    search_query: String,
  334|       |    last_query: String,
  335|       |    last_match_index: Option<usize>,
  336|       |    pending_scroll_to_element: Option<usize>,
  337|       |    search_focus_requested: bool,
  338|       |    /// Deferred caret movement (in lines) for raw editor
  339|       |    pending_raw_cursor_line_move: Option<i32>,
  340|       |    // Navigation history
  341|       |    /// History of visited files and samples for back/forward navigation
  342|       |    history: Vec<HistoryEntry>,
  343|       |    /// Current position in history
  344|       |    history_index: usize,
  345|       |    /// Maximum history entries to keep
  346|       |    max_history: usize,
  347|       |    // Drag and drop state
  348|       |    /// Visual state: file is being dragged over window
  349|       |    drag_hover: bool,
  350|       |    /// Queue of files waiting to be opened (from multi-file drop)
  351|       |    pending_files: VecDeque<PathBuf>,
  352|       |    screenshot: Option<ScreenshotState>,
  353|       |}
  354|       |
  355|       |/// Navigation request for keyboard-triggered scrolling
  356|       |#[derive(Debug, Clone)]
  357|       |enum NavigationRequest {
  358|       |    Top,
  359|       |    Bottom,
  360|       |    PageUp,
  361|       |    PageDown,
  362|       |    ScrollUp,   // Arrow up - fine scrolling
  363|       |    ScrollDown, // Arrow down - fine scrolling
  364|       |}
  365|       |
  366|       |/// Which view the user is in
  367|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
  368|       |enum ViewMode {
  369|       |    Rendered,
  370|       |    Raw,
  371|       |}
  372|       |
  373|       |impl MarkdownViewerApp {
  374|     10|    fn toggle_write_mode(&mut self, ctx: &Context) {
  375|     10|        if self.write_enabled {
  376|       |            // About to disable; capture current cursor if in Raw view
  377|      5|            if matches!(self.view_mode, ViewMode::Raw) {
                             ^1
  378|      4|                let editor_id = egui::Id::new("raw_editor");
  379|      4|                if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
                                          ^3
  380|      3|                    if let Some(range) = state.cursor.char_range() {
                                              ^2
  381|      2|                        self.raw_cursor = Some(range.primary.index);
  382|      2|                    }
                                  ^1
  383|      1|                }
  384|      1|            }
  385|      5|            self.write_enabled = false;
  386|       |        } else {
  387|       |            // Enabling write mode: ensure the raw editor will gain focus
  388|      5|            self.write_enabled = true;
  389|      5|            if matches!(self.view_mode, ViewMode::Raw) {
                             ^1
  390|      4|                self.raw_focus_requested = true;
  391|      4|            }
                          ^1
  392|       |        }
  393|     10|    }
  394|       |
  395|     15|    fn move_raw_cursor_lines(&mut self, ctx: &Context, delta_lines: i32) {
  396|     15|        if !matches!(self.view_mode, ViewMode::Raw) || !self.write_enabled {
                          ^2                                         ^13
  397|      3|            return;
  398|     12|        }
  399|     12|        let editor_id = egui::Id::new("raw_editor");
  400|     12|        if let Some(mut state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
                                  ^11
  401|     11|            let mut idx = state
  402|     11|                .cursor
  403|     11|                .char_range()
  404|     11|                .map(|r| r.primary.index)
  405|     11|                .unwrap_or_else(|| self.raw_cursor.unwrap_or(0))
                                                 ^1              ^1
  406|     11|                .min(self.raw_buffer.len());
  407|       |
  408|     11|            let s = self.raw_buffer.as_str();
  409|     11|            match delta_lines.cmp(&0) {
  410|       |                std::cmp::Ordering::Less => {
  411|      3|                    let mut lines = -delta_lines;
  412|       |                    // Move to start of current line
  413|      3|                    idx = s[..idx].rfind('\n').map(|p| p + 1).unwrap_or(0);
                                                                     ^2
  414|      6|                    while lines > 0 && idx > 0 {
                                                     ^4
  415|      3|                        if let Some(prev_nl) = s[..idx.saturating_sub(1)].rfind('\n') {
                                                  ^1
  416|      1|                            idx = prev_nl + 1;
  417|      2|                        } else {
  418|      2|                            idx = 0;
  419|      2|                        }
  420|      3|                        lines -= 1;
  421|       |                    }
  422|       |                }
  423|       |                std::cmp::Ordering::Greater => {
  424|      7|                    let mut lines = delta_lines;
  425|       |                    // Move to start of next line
  426|      7|                    if let Some(nl) = s[idx..].find('\n') {
                                              ^5
  427|      5|                        idx = (idx + nl + 1).min(s.len());
  428|      5|                        lines -= 1;
  429|      5|                    }
                                  ^2
  430|     10|                    while lines > 0 && idx < s.len() {
                                                     ^4
  431|      3|                        if let Some(nl) = s[idx..].find('\n') {
                                                  ^1
  432|      1|                            idx = (idx + nl + 1).min(s.len());
  433|      2|                        } else {
  434|      2|                            idx = s.len();
  435|      2|                        }
  436|      3|                        lines -= 1;
  437|       |                    }
  438|       |                }
  439|      1|                std::cmp::Ordering::Equal => {}
  440|       |            }
  441|     11|            let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(idx));
  442|     11|            state.cursor.set_char_range(Some(cr));
  443|     11|            state.store(ctx, editor_id);
  444|     11|            self.raw_cursor = Some(idx);
  445|     11|            self.raw_focus_requested = true; // keep focus and make caret visible
  446|      1|        }
  447|     15|    }
  448|      3|    fn clear_search_state(&mut self) {
  449|      3|        self.search_query.clear();
  450|      3|        self.last_query.clear();
  451|      3|        self.last_match_index = None;
  452|      3|        self.pending_scroll_to_element = None;
  453|      3|        self.renderer.set_highlight_phrase(None);
  454|      3|    }
  455|      6|    fn find_next(&mut self) {
  456|      6|        if self.search_query.is_empty() && self.last_query.is_empty() {
                                                         ^2              ^2
  457|      1|            return;
  458|      5|        }
  459|      5|        let needle = if !self.search_query.is_empty() {
  460|      4|            self.last_query = self.search_query.clone();
  461|      4|            Self::fold_for_search(&self.search_query)
  462|       |        } else {
  463|      1|            Self::fold_for_search(&self.last_query)
  464|       |        };
  465|      5|        let mut start = self.last_match_index.unwrap_or(usize::MAX);
  466|      5|        if start == usize::MAX {
  467|      4|            start = 0;
  468|      4|        } else {
  469|      1|            start = start.saturating_add(1);
  470|      1|        }
  471|       |        // Wrap-around search forward
  472|      5|        let total = self.parsed_elements.len();
  473|      6|        for pass in 0..2 {
  474|      6|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
  475|      5|                Box::new(start..total)
  476|       |            } else {
  477|      1|                Box::new(0..start.min(total))
  478|       |            };
  479|      9|            for idx in range {
                              ^8
  480|      8|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
  481|      8|                    &self.parsed_elements[idx],
  482|       |                );
  483|      8|                if Self::fold_for_search(&text).contains(&needle) {
  484|      5|                    self.last_match_index = Some(idx);
  485|      5|                    self.pending_scroll_to_element = Some(idx);
  486|      5|                    return;
  487|      3|                }
  488|       |            }
  489|       |        }
  490|      6|    }
  491|       |
  492|      6|    fn find_previous(&mut self) {
  493|      6|        if self.search_query.is_empty() && self.last_query.is_empty() {
                                                         ^2              ^2
  494|      1|            return;
  495|      5|        }
  496|      5|        let needle = if !self.search_query.is_empty() {
  497|      4|            self.last_query = self.search_query.clone();
  498|      4|            Self::fold_for_search(&self.search_query)
  499|       |        } else {
  500|      1|            Self::fold_for_search(&self.last_query)
  501|       |        };
  502|      5|        let total = self.parsed_elements.len();
  503|      5|        let mut start = self.last_match_index.unwrap_or(0);
  504|      5|        if start == 0 {
  505|      3|            start = total.saturating_sub(1);
  506|      3|        } else {
  507|      2|            start = start.saturating_sub(1);
  508|      2|        }
  509|       |        // Wrap-around search backward
  510|      6|        for pass in 0..2 {
  511|      6|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
  512|      5|                Box::new((0..=start).rev())
  513|       |            } else {
  514|      1|                Box::new(((start + 1)..total).rev())
  515|       |            };
  516|     10|            for idx in range {
                              ^9
  517|      9|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
  518|      9|                    &self.parsed_elements[idx],
  519|       |                );
  520|      9|                if Self::fold_for_search(&text).contains(&needle) {
  521|      5|                    self.last_match_index = Some(idx);
  522|      5|                    self.pending_scroll_to_element = Some(idx);
  523|      5|                    return;
  524|      4|                }
  525|       |            }
  526|       |        }
  527|      6|    }
  528|       |    /// Create a new application instance
  529|    164|    pub fn new() -> Self {
  530|    164|        let (file_load_tx, file_load_rx) = Self::spawn_file_loader();
  531|    164|        let mut app = Self {
  532|    164|            renderer: MarkdownRenderer::new(),
  533|    164|            current_file: None,
  534|    164|            current_content: String::new(),
  535|    164|            raw_buffer: String::new(),
  536|    164|            parsed_elements: Vec::new(),
  537|    164|            title: APP_TITLE_PREFIX.to_string(),
  538|    164|            error_message: None,
  539|    164|            nav_request: None,
  540|    164|            scroll_area_id: egui::Id::new("main_scroll_area"),
  541|    164|            toggle_fullscreen: false,
  542|    164|            view_mode: ViewMode::Rendered,
  543|    164|            wrap_raw: false,
  544|    164|            write_enabled: false,
  545|    164|            raw_cursor: None,
  546|    164|            raw_focus_requested: false,
  547|    164|            reload_requested: false,
  548|    164|            view_toggle_requested: false,
  549|    164|            write_toggle_requested: false,
  550|    164|            last_window_pos: None,
  551|    164|            last_window_size: None,
  552|    164|            last_window_maximized: false,
  553|    164|            last_persisted_state: None,
  554|    164|            last_persist_instant: std::time::Instant::now(),
  555|    164|            file_load_tx,
  556|    164|            file_load_rx,
  557|    164|            pending_file_load: None,
  558|    164|            next_file_load_id: 0,
  559|    164|            show_search: false,
  560|    164|            search_query: String::new(),
  561|    164|            last_query: String::new(),
  562|    164|            last_match_index: None,
  563|    164|            pending_scroll_to_element: None,
  564|    164|            search_focus_requested: false,
  565|    164|            pending_raw_cursor_line_move: None,
  566|    164|            history: Vec::new(),
  567|    164|            history_index: 0,
  568|    164|            max_history: 50,
  569|    164|            drag_hover: false,
  570|    164|            pending_files: VecDeque::new(),
  571|    164|            screenshot: None,
  572|    164|        };
  573|       |        // Load welcome content by default
  574|    164|        app.load_welcome_from_samples(SAMPLE_FILES, false);
  575|       |
  576|    164|        app
  577|    164|    }
  578|       |
  579|      1|    pub fn set_zoom_scale(&mut self, scale: f32) {
  580|      1|        self.renderer.set_zoom_scale(scale);
  581|      1|    }
  582|       |
  583|      3|    pub fn set_screenshot_mode(&mut self, config: ScreenshotConfig) {
  584|      3|        self.screenshot = Some(ScreenshotState::new(config));
  585|      3|        self.view_mode = ViewMode::Rendered;
  586|      3|        self.write_enabled = false;
  587|      3|        self.show_search = false;
  588|      3|        self.search_focus_requested = false;
  589|      3|        self.nav_request = None;
  590|      3|    }
  591|       |
  592|       |    /// Check if file has valid markdown extension
  593|    143|    fn is_valid_markdown_file(&self, path: &Path) -> bool {
  594|    143|        if let Some(ext) = path.extension() {
                                  ^142
  595|    142|            let ext = ext.to_string_lossy().to_lowercase();
  596|    142|            matches!(ext.as_str(), "md" | "markdown" | "mdown" | "mkd" | "txt")
                          ^135                          ^13          ^10       ^9      ^8
  597|       |        } else {
  598|      1|            false
  599|       |        }
  600|    143|    }
  601|       |
  602|       |    /// Handle dropped files from drag-and-drop operation
  603|     16|    fn handle_file_drop(&mut self, paths: Vec<PathBuf>) {
  604|     16|        if paths.is_empty() {
  605|      1|            return;
  606|     15|        }
  607|       |
  608|     15|        let mut valid_files = Vec::new();
  609|     15|        let mut errors = Vec::new();
  610|       |
  611|       |        // Validate all dropped files
  612|    147|        for path in paths {
                          ^132
  613|    132|            if !path.exists() {
  614|      3|                errors.push(format!("File not found: {}", path.display()));
  615|      3|                continue;
  616|    129|            }
  617|       |
  618|    129|            if path.is_dir() {
  619|       |                // Handle directory by scanning for markdown files
  620|      4|                match self.scan_directory(&path) {
  621|      3|                    Ok(dir_files) => {
  622|      3|                        if dir_files.is_empty() {
  623|      2|                            errors.push(format!(
  624|      2|                                "No markdown files in directory: {}",
  625|      2|                                path.display()
  626|      2|                            ));
  627|      2|                        } else {
  628|      1|                            valid_files.extend(dir_files);
  629|      1|                        }
  630|       |                    }
  631|      1|                    Err(e) => {
  632|      1|                        errors.push(format!("Cannot read directory {}: {}", path.display(), e));
  633|      1|                    }
  634|       |                }
  635|      4|                continue;
  636|    125|            }
  637|       |
  638|    125|            if !self.is_valid_markdown_file(&path) {
  639|      3|                errors.push(format!(
  640|      3|                    "Not a markdown file: {}",
  641|      3|                    path.file_name().unwrap_or_default().to_string_lossy()
  642|       |                ));
  643|      3|                continue;
  644|    122|            }
  645|       |
  646|    122|            valid_files.push(path);
  647|       |        }
  648|       |
  649|       |        // Limit to prevent memory issues
  650|       |        const MAX_FILES: usize = 50;
  651|     15|        if valid_files.len() > MAX_FILES {
  652|      2|            self.error_message = Some(format!(
  653|      2|                "Too many files ({}). Maximum is {}.\n\
  654|      2|                 Please drop files in smaller batches.",
  655|      2|                valid_files.len(),
  656|      2|                MAX_FILES
  657|      2|            ));
  658|      2|            return;
  659|     13|        }
  660|       |
  661|       |        // Handle valid files
  662|     13|        if !valid_files.is_empty() {
  663|       |            // Open first file immediately
  664|      7|            let first_file = valid_files.remove(0);
  665|      7|            if let Err(e) = self.load_file(first_file, true) {
                                     ^1
  666|      1|                self.error_message = Some(format!("Failed to load file: {}", e));
  667|      1|                return;
  668|      6|            }
  669|       |
  670|       |            // Queue remaining files
  671|      6|            self.pending_files.extend(valid_files.iter().cloned());
  672|       |
  673|       |            // Show info message if multiple files
  674|      6|            if !self.pending_files.is_empty() {
  675|      3|                eprintln!(
  676|      3|                    "Queued {} files. Use Alt+Right to navigate to the next file.",
  677|      3|                    self.pending_files.len()
  678|      3|                );
  679|      3|            }
  680|      6|        }
  681|       |
  682|       |        // Show errors if any
  683|     12|        if !errors.is_empty() {
  684|      8|            let valid_count = if valid_files.is_empty() {
  685|      7|                0
  686|       |            } else {
  687|      1|                valid_files.len() + 1
  688|       |            };
  689|      8|            let error_msg = if errors.len() == 1 && valid_count == 0 {
                                                                  ^7
  690|      6|                errors[0].clone()
  691|      2|            } else if valid_count == 0 {
  692|       |                // All files failed
  693|      1|                format!("No valid files:\n{}", errors.join("\n"))
  694|       |            } else {
  695|       |                // Some succeeded, some failed
  696|      1|                format!(
  697|      1|                    "Opened {} files. Skipped {}:\n{}",
  698|       |                    valid_count,
  699|      1|                    errors.len(),
  700|      1|                    errors.join("\n")
  701|       |                )
  702|       |            };
  703|      8|            self.error_message = Some(error_msg);
  704|      4|        }
  705|     16|    }
  706|       |
  707|       |    /// Resolve a directory entry result, allowing test hooks to force failures.
  708|     10|    fn resolve_scan_entry(entry: std::io::Result<std::fs::DirEntry>) -> Result<std::fs::DirEntry> {
  709|       |        #[cfg(test)]
  710|     10|        if take_forced_scan_entry_error() {
  711|      1|            bail!("Forced scan entry error");
  712|      9|        }
  713|      9|        Ok(entry?)
                              ^1
  714|     10|    }
  715|       |
  716|       |    /// Scan directory for markdown files (non-recursive)
  717|      8|    fn scan_directory(&self, dir: &Path) -> Result<Vec<PathBuf>> {
  718|       |        #[cfg(test)]
  719|      8|        if take_forced_scan_error() {
  720|      1|            bail!("Forced scan error");
  721|      7|        }
  722|       |
  723|      7|        let mut files = Vec::new();
  724|       |
  725|      7|        let entries = std::fs::read_dir(dir)?;
                          ^6                              ^1
  726|       |
  727|     14|        for entry in entries {
                          ^9
  728|      9|            let entry = Self::resolve_scan_entry(entry)?;
                              ^8                                     ^1
  729|      8|            let path = entry.path();
  730|       |
  731|       |            // Only include files (not subdirectories)
  732|      8|            if path.is_file() && self.is_valid_markdown_file(&path) {
                                               ^7   ^7                     ^7
  733|      6|                files.push(path);
  734|      6|            }
                          ^2
  735|       |        }
  736|       |
  737|       |        // Sort alphabetically for predictable order
  738|      5|        files.sort();
  739|       |
  740|      5|        Ok(files)
  741|      8|    }
  742|       |
  743|       |    /// Load markdown content from a string
  744|    234|    pub fn load_content(&mut self, content: &str, title: Option<String>) {
  745|    234|        self.pending_file_load = None;
  746|    234|        self.current_content = content.to_string();
  747|    234|        self.raw_buffer = self.current_content.clone();
  748|    234|        self.error_message = None;
  749|    234|        self.nav_request = None; // Reset any pending navigation
  750|       |                                 // Ensure scroll resets to top on new content
  751|    234|        self.pending_scroll_to_element = Some(0);
  752|    234|        self.renderer.clear_table_layout_cache();
  753|       |
  754|    234|        match self.renderer.parse(content) {
  755|    233|            Ok(elements) => {
  756|    233|                self.parsed_elements = elements;
  757|    233|                if let Some(title) = title {
                                          ^232
  758|    232|                    self.title = format!("{APP_TITLE_PREFIX} - {}", title);
  759|    232|                }
                              ^1
  760|       |            }
  761|      1|            Err(e) => {
  762|      1|                self.error_message = Some(format!("Failed to parse markdown: {}", e));
  763|      1|                self.parsed_elements.clear();
  764|      1|            }
  765|       |        }
  766|    234|    }
  767|       |
  768|       |    /// Load markdown content from a file path
  769|     27|    pub fn load_file(&mut self, path: PathBuf, record_history: bool) -> Result<()> {
  770|       |        #[cfg(test)]
  771|     27|        if take_forced_load_error() {
  772|      3|            bail!("Forced load error");
  773|     24|        }
  774|       |
  775|       |        // Push current state to history before loading new file
  776|     24|        if record_history && !self.current_content.is_empty() {
                                           ^19
  777|     18|            self.push_history();
  778|     18|        }
                      ^6
  779|       |
  780|     24|        let file_size = std::fs::metadata(&path).ok().map(|m| m.len());
                                                                            ^23^23
  781|     24|        let use_async = self.screenshot.is_none()
  782|     23|            && file_size.is_some_and(|size| size >= ASYNC_LOAD_THRESHOLD_BYTES);
                                                          ^22
  783|     24|        if use_async {
  784|      2|            let load_id = self.next_file_load_id;
  785|      2|            self.next_file_load_id = self.next_file_load_id.wrapping_add(1);
  786|      2|            let request = FileLoadRequest {
  787|      2|                id: load_id,
  788|      2|                path: path.clone(),
  789|      2|            };
  790|      2|            if self.file_load_tx.send(request).is_ok() {
  791|      1|                self.pending_file_load = Some(PendingFileLoad { id: load_id, path });
  792|      1|                return Ok(());
  793|      1|            }
  794|     22|        }
  795|       |
  796|     23|        let (content, lossy) = Self::read_file_lossy(&path)?;
                           ^22      ^22                                  ^1
  797|     22|        let filename = path
  798|     22|            .file_name()
  799|     22|            .and_then(|n| n.to_str())
  800|     22|            .unwrap_or("Unknown")
  801|     22|            .to_string();
  802|       |
  803|     22|        let base = path.parent().map(|p| p.to_path_buf());
  804|     22|        self.renderer.set_base_dir(base.as_deref());
  805|     22|        self.current_file = Some(path);
  806|     22|        self.load_content(&content, Some(filename));
  807|     22|        if lossy {
  808|      1|            eprintln!("Loaded file with invalid UTF-8; replaced invalid sequences.");
  809|     21|        }
  810|     22|        Ok(())
  811|     27|    }
  812|       |
  813|       |    /// Normalize all line endings to Unix style (\n)
  814|       |    /// Handles Windows (\r\n), Unix (\n), and old Mac (\r) formats
  815|     32|    fn normalize_line_endings(s: &str) -> String {
  816|       |        // Order matters: replace \r\n first (Windows), then remaining \r (old Mac)
  817|     32|        let normalized = s.replace("\r\n", "\n").replace('\r', "\n");
  818|     32|        if let Some(stripped) = normalized.strip_prefix('\u{FEFF}') {
                                  ^1
  819|      1|            stripped.to_string()
  820|       |        } else {
  821|     31|            normalized
  822|       |        }
  823|     32|    }
  824|       |
  825|      3|    fn read_lossy_bytes(path: &Path) -> std::io::Result<Vec<u8>> {
  826|       |        #[cfg(test)]
  827|      3|        if take_forced_read_lossy_error() {
  828|      1|            return Err(std::io::Error::new(
  829|      1|                ErrorKind::Other,
  830|      1|                "forced lossy read failure",
  831|      1|            ));
  832|      2|        }
  833|      2|        std::fs::read(path)
  834|      3|    }
  835|       |
  836|     28|    fn read_file_lossy(path: &Path) -> Result<(String, bool)> {
  837|     28|        match std::fs::read_to_string(path) {
  838|     23|            Ok(s) => Ok((Self::normalize_line_endings(&s), false)),
  839|      5|            Err(e) if e.kind() == ErrorKind::InvalidData => {
                              ^3                                     ^3
  840|      3|                let bytes = Self::read_lossy_bytes(path)?;
                                  ^2                                  ^1
  841|      2|                let s = String::from_utf8_lossy(&bytes).into_owned();
  842|      2|                Ok((Self::normalize_line_endings(&s), true))
  843|       |            }
  844|      2|            Err(e) => Err(e.into()),
  845|       |        }
  846|     28|    }
  847|       |
  848|    167|    fn spawn_named_thread(
  849|    167|        name: &str,
  850|    167|        f: impl FnOnce() + Send + 'static,
  851|    167|    ) -> std::io::Result<std::thread::JoinHandle<()>> {
  852|       |        #[cfg(test)]
  853|    167|        if FORCE_THREAD_SPAWN_ERROR.swap(false, Ordering::Relaxed) {
  854|      1|            return Err(std::io::Error::new(
  855|      1|                ErrorKind::Other,
  856|      1|                "forced thread spawn failure",
  857|      1|            ));
  858|    166|        }
  859|    166|        std::thread::Builder::new().name(name.to_string()).spawn(f)
  860|    167|    }
  861|       |
  862|       |    #[cfg(test)]
  863|      1|    fn force_thread_spawn_error_for_test() {
  864|      1|        FORCE_THREAD_SPAWN_ERROR.store(true, Ordering::Relaxed);
  865|      1|    }
  866|       |
  867|    167|    fn spawn_file_loader() -> (Sender<FileLoadRequest>, Receiver<FileLoadResult>) {
  868|    167|        let (request_tx, request_rx) = unbounded::<FileLoadRequest>();
  869|    167|        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
  870|    167|        if let Err(err) = Self::spawn_named_thread("mdmdview-file-loader", move || {
                                 ^1                                                              ^166
  871|    166|            for request in request_rx.iter() {
                              ^3
  872|      3|                let content = MarkdownViewerApp::read_file_lossy(&request.path)
  873|      3|                    .map_err(|err| err.to_string());
                                                 ^1  ^1
  874|      3|                let _ = result_tx.send(FileLoadResult {
  875|      3|                    id: request.id,
  876|      3|                    content,
  877|      3|                });
  878|       |            }
  879|    166|        }) {
  880|      1|            eprintln!("Failed to start file loader thread: {err}");
  881|    166|        }
  882|    167|        (request_tx, result_rx)
  883|    167|    }
  884|       |
  885|     35|    fn poll_file_loads(&mut self) {
  886|     39|        while let Ok(result) = self.file_load_rx.try_recv() {
                                   ^4
  887|      4|            let pending = match &self.pending_file_load {
                              ^3
  888|      4|                Some(pending) if pending.id == result.id => pending.clone(),
                                                                     ^3   ^3      ^3
  889|      1|                _ => continue,
  890|       |            };
  891|      3|            self.pending_file_load = None;
  892|      3|            match result.content {
  893|      2|                Ok((content, lossy)) => {
  894|      2|                    let filename = pending
  895|      2|                        .path
  896|      2|                        .file_name()
  897|      2|                        .and_then(|n| n.to_str())
  898|      2|                        .unwrap_or("Unknown")
  899|      2|                        .to_string();
  900|      2|                    let base = pending.path.parent().map(|p| p.to_path_buf());
  901|      2|                    self.renderer.set_base_dir(base.as_deref());
  902|      2|                    self.current_file = Some(pending.path);
  903|      2|                    self.load_content(&content, Some(filename));
  904|      2|                    if lossy {
  905|      1|                        eprintln!("Loaded file with invalid UTF-8; replaced invalid sequences.");
  906|      1|                    }
  907|       |                }
  908|      1|                Err(err) => {
  909|      1|                    self.error_message = Some(format!("Failed to load file: {err}"));
  910|      1|                }
  911|       |            }
  912|       |        }
  913|     35|    }
  914|       |
  915|     11|    fn current_window_state(&self) -> Option<WindowState> {
  916|     11|        let pos = self.last_window_pos?;
                          ^9                        ^2
  917|      9|        let size = self.last_window_size?;
                          ^8                          ^1
  918|      8|        Some(WindowState {
  919|      8|            pos,
  920|      8|            size,
  921|      8|            maximized: self.last_window_maximized,
  922|      8|        })
  923|     11|    }
  924|       |
  925|     41|    fn compute_window_adjustment(
  926|     41|        outer_rect: Option<egui::Rect>,
  927|     41|        inner_rect: Option<egui::Rect>,
  928|     41|        monitor_size: Option<egui::Vec2>,
  929|     41|    ) -> Option<WindowAdjustment> {
  930|     41|        let outer = outer_rect?;
                          ^15               ^26
  931|     15|        let inner = inner_rect.unwrap_or(outer);
  932|     15|        let monitor = monitor_size?;
                          ^14                   ^1
  933|       |
  934|     14|        if monitor.x <= 0.0 || monitor.y <= 0.0 {
                                             ^13
  935|      2|            return None;
  936|     12|        }
  937|       |
  938|       |        const MIN_WIDTH: f32 = 600.0;
  939|       |        const MIN_HEIGHT: f32 = 400.0;
  940|       |        const OFFSCREEN_TOLERANCE: f32 = 32.0;
  941|       |
  942|     12|        let mut pos = outer.min;
  943|     12|        let mut size = inner.size();
  944|     12|        let mut pos_adjusted = false;
  945|     12|        let mut size_adjusted = false;
  946|       |
  947|     12|        if !pos.x.is_finite() || !pos.y.is_finite() {
                                               ^10
  948|      3|            pos = egui::pos2(0.0, 0.0);
  949|      3|            pos_adjusted = true;
  950|      9|        }
  951|     12|        if !size.x.is_finite() || !size.y.is_finite() {
                                                ^11
  952|      2|            size = egui::vec2(MIN_WIDTH, MIN_HEIGHT);
  953|      2|            size_adjusted = true;
  954|     10|        }
  955|       |
  956|     12|        let outer_size = outer.size();
  957|     12|        let inner_size = inner.size();
  958|     12|        let frame = egui::vec2(
  959|     12|            (outer_size.x - inner_size.x).max(0.0),
  960|     12|            (outer_size.y - inner_size.y).max(0.0),
  961|       |        );
  962|       |
  963|     12|        let available_width = (monitor.x - frame.x).max(MIN_WIDTH);
  964|     12|        let available_height = (monitor.y - frame.y).max(MIN_HEIGHT);
  965|       |
  966|     12|        if size.x < MIN_WIDTH {
  967|      3|            size.x = MIN_WIDTH.min(available_width);
  968|      3|            size_adjusted = true;
  969|      9|        }
  970|     12|        if size.y < MIN_HEIGHT {
  971|      3|            size.y = MIN_HEIGHT.min(available_height);
  972|      3|            size_adjusted = true;
  973|      9|        }
  974|     12|        if size.x > available_width {
  975|      1|            size.x = available_width;
  976|      1|            size_adjusted = true;
  977|     11|        }
  978|     12|        if size.y > available_height {
  979|      1|            size.y = available_height;
  980|      1|            size_adjusted = true;
  981|     11|        }
  982|       |
  983|     12|        let outer_size_for_bounds = size + frame;
  984|     12|        let max_pos = egui::pos2(
  985|     12|            (monitor.x - outer_size_for_bounds.x).max(0.0),
  986|     12|            (monitor.y - outer_size_for_bounds.y).max(0.0),
  987|       |        );
  988|       |
  989|     12|        if pos.x <= -0.25 * outer_size_for_bounds.x {
  990|      1|            pos.x = 0.0;
  991|      1|            pos_adjusted = true;
  992|     11|        }
  993|     12|        if pos.y <= -0.25 * outer_size_for_bounds.y {
  994|      2|            pos.y = 0.0;
  995|      2|            pos_adjusted = true;
  996|     10|        }
  997|     12|        if pos.x > max_pos.x + OFFSCREEN_TOLERANCE {
  998|      2|            pos.x = max_pos.x;
  999|      2|            pos_adjusted = true;
 1000|     10|        }
 1001|     12|        if pos.y > max_pos.y + OFFSCREEN_TOLERANCE {
 1002|      2|            pos.y = max_pos.y;
 1003|      2|            pos_adjusted = true;
 1004|     10|        }
 1005|       |
 1006|     12|        if pos_adjusted || size_adjusted {
                                         ^5
 1007|     10|            size.x = size.x.max(MIN_WIDTH.min(available_width));
 1008|     10|            size.y = size.y.max(MIN_HEIGHT.min(available_height));
 1009|     10|            Some(WindowAdjustment {
 1010|     10|                pos: pos_adjusted.then_some(pos),
 1011|     10|                size: size_adjusted.then_some(size),
 1012|     10|            })
 1013|       |        } else {
 1014|      2|            None
 1015|       |        }
 1016|     41|    }
 1017|       |
 1018|     12|    fn window_state_changed(&self, new_state: &WindowState) -> bool {
 1019|     12|        match &self.last_persisted_state {
 1020|      5|            Some(prev) => {
 1021|      5|                let pos_changed = (prev.pos[0] - new_state.pos[0]).abs() > 0.5
 1022|      4|                    || (prev.pos[1] - new_state.pos[1]).abs() > 0.5;
 1023|      5|                let size_changed = (prev.size[0] - new_state.size[0]).abs() > 0.5
 1024|      4|                    || (prev.size[1] - new_state.size[1]).abs() > 0.5;
 1025|      5|                let maximized_changed = prev.maximized != new_state.maximized;
 1026|      5|                pos_changed || size_changed || maximized_changed
                                             ^4              ^3
 1027|       |            }
 1028|      7|            None => true,
 1029|       |        }
 1030|     12|    }
 1031|       |
 1032|     39|    fn fold_for_search(input: &str) -> String {
 1033|     39|        input.case_fold().nfkc().collect()
 1034|     39|    }
 1035|       |
 1036|       |    /// Push current state to navigation history
 1037|     48|    fn push_history(&mut self) {
 1038|       |        // Truncate forward history if we're not at the end
 1039|     48|        if self.history_index < self.history.len() {
 1040|      2|            self.history.truncate(self.history_index);
 1041|     46|        }
 1042|       |
 1043|       |        // Create entry for current state
 1044|     48|        let entry = HistoryEntry {
 1045|     48|            file_path: self.current_file.clone(),
 1046|     48|            title: self.title.clone(),
 1047|     48|            content: self.current_content.clone(),
 1048|     48|        };
 1049|       |
 1050|     48|        self.history.push(entry);
 1051|       |
 1052|       |        // Limit history size
 1053|     48|        if self.history.len() > self.max_history {
 1054|      1|            self.history.remove(0);
 1055|     47|        } else {
 1056|     47|            self.history_index = self.history.len();
 1057|     47|        }
 1058|     48|    }
 1059|       |
 1060|       |    /// Navigate back in history
 1061|      4|    fn navigate_back(&mut self) -> bool {
 1062|      4|        if self.history_index > 0 {
 1063|      3|            self.history_index -= 1;
 1064|      3|            self.restore_from_history();
 1065|      3|            true
 1066|       |        } else {
 1067|      1|            false
 1068|       |        }
 1069|      4|    }
 1070|       |
 1071|       |    /// Navigate forward in history
 1072|      7|    fn navigate_forward(&mut self) -> bool {
 1073|       |        // First try pending files queue
 1074|      7|        if let Some(next_file) = self.pending_files.pop_front() {
                                  ^2
 1075|       |            // Load next file from queue
 1076|      2|            if let Err(e) = self.load_file(next_file, true) {
                                     ^1
 1077|      1|                self.error_message = Some(format!("Failed to load file: {}", e));
 1078|      1|            }
 1079|      2|            return true;
 1080|      5|        }
 1081|       |
 1082|       |        // Otherwise use history navigation (existing code)
 1083|      5|        if self.history_index < self.history.len().saturating_sub(1) {
 1084|      2|            self.history_index += 1;
 1085|      2|            self.restore_from_history();
 1086|      2|            true
 1087|       |        } else {
 1088|      3|            false
 1089|       |        }
 1090|      7|    }
 1091|       |
 1092|       |    /// Restore state from history at current index
 1093|      8|    fn restore_from_history(&mut self) {
 1094|      8|        if let Some(entry) = self.history.get(self.history_index) {
                                  ^7
 1095|      7|            self.current_file = entry.file_path.clone();
 1096|      7|            self.title = entry.title.clone();
 1097|      7|            self.current_content = entry.content.clone();
 1098|      7|            self.raw_buffer = self.current_content.clone();
 1099|       |
 1100|       |            // Re-parse content
 1101|      7|            match self.renderer.parse(&self.current_content) {
 1102|      6|                Ok(elements) => {
 1103|      6|                    self.parsed_elements = elements;
 1104|      6|                    self.error_message = None;
 1105|      6|                }
 1106|      1|                Err(e) => {
 1107|      1|                    self.error_message = Some(format!("Failed to parse: {}", e));
 1108|      1|                }
 1109|       |            }
 1110|       |
 1111|       |            // Set base dir for images
 1112|      7|            if let Some(ref path) = self.current_file {
                                      ^1
 1113|      1|                self.renderer.set_base_dir(path.parent());
 1114|      6|            } else {
 1115|      6|                self.renderer.set_base_dir(None);
 1116|      6|            }
 1117|       |
 1118|       |            // Scroll to top
 1119|      7|            self.pending_scroll_to_element = Some(0);
 1120|      1|        }
 1121|      8|    }
 1122|       |
 1123|       |    /// Check if we can navigate back
 1124|     34|    fn can_navigate_back(&self) -> bool {
 1125|     34|        self.history_index > 0
 1126|     34|    }
 1127|       |
 1128|       |    /// Check if we can navigate forward
 1129|     35|    fn can_navigate_forward(&self) -> bool {
 1130|     35|        !self.pending_files.is_empty() || self.history_index < self.history.len().saturating_sub(1)
                                                        ^33                  ^33
 1131|     35|    }
 1132|       |
 1133|       |    /// Request a reload of the current file (processed outside of input context)
 1134|      4|    fn request_reload(&mut self) {
 1135|      4|        if self.current_file.is_some() {
 1136|      1|            self.reload_requested = true;
 1137|      3|        } else {
 1138|      3|            self.error_message = Some("No file loaded to reload".to_string());
 1139|      3|        }
 1140|      4|    }
 1141|       |
 1142|       |    /// Reload the currently opened file from disk
 1143|      4|    pub fn reload_current_file(&mut self) -> Result<()> {
 1144|      4|        let path = if let Some(p) = self.current_file.clone() {
                          ^2                 ^2
 1145|      2|            p
 1146|       |        } else {
 1147|      2|            bail!("No file loaded to reload");
 1148|       |        };
 1149|      2|        self.load_file(path, false)
 1150|      4|    }
 1151|       |
 1152|       |    /// Load a sample file by name
 1153|     27|    pub fn load_sample(&mut self, sample: &SampleFile) {
 1154|       |        // Push current state to history before loading sample
 1155|     27|        if !self.current_content.is_empty() {
 1156|     26|            self.push_history();
 1157|     26|        }
                      ^1
 1158|       |
 1159|     27|        self.current_file = None;
 1160|       |        // Samples have no file base-dir
 1161|     27|        self.renderer.set_base_dir(None);
 1162|     27|        self.load_content(sample.content, Some(sample.title.to_string()));
 1163|       |        // Scroll to top for new sample
 1164|     27|        self.pending_scroll_to_element = Some(0);
 1165|     27|    }
 1166|       |
 1167|      8|    fn load_sample_by_name(&mut self, samples: &[SampleFile], name: &str) -> bool {
 1168|     16|        if let Some(sample) = samples.iter().find(|sample| sample.name == name) {
                                  ^7        ^8             ^8
 1169|      7|            self.load_sample(sample);
 1170|      7|            return true;
 1171|      1|        }
 1172|      1|        false
 1173|      8|    }
 1174|       |
 1175|    172|    fn load_welcome_from_samples(&mut self, samples: &[SampleFile], scroll_to_top: bool) {
 1176|    172|        if let Some(welcome) = samples.iter().find(|sample| sample.name == "welcome.md") {
                                  ^171                                    ^171           ^171
 1177|    171|            self.load_content(welcome.content, Some("Welcome".to_string()));
 1178|    171|            if scroll_to_top {
 1179|      7|                self.pending_scroll_to_element = Some(0);
 1180|    164|            }
 1181|      1|        } else {
 1182|      1|            // Fallback if welcome file is missing
 1183|      1|            self.current_content.clear();
 1184|      1|            self.parsed_elements.clear();
 1185|      1|            self.title = APP_TITLE_PREFIX.to_string();
 1186|      1|            self.error_message = None;
 1187|      1|        }
 1188|    172|    }
 1189|       |
 1190|       |    /// Close the current file and return to welcome screen
 1191|      6|    pub fn close_current_file(&mut self) {
 1192|      6|        self.current_file = None;
 1193|      6|        self.renderer.set_base_dir(None);
 1194|      6|        self.load_welcome_from_samples(SAMPLE_FILES, true);
 1195|      6|    }
 1196|       |
 1197|       |    #[cfg(not(test))]
 1198|       |    fn request_close(&self, ctx: &Context) {
 1199|       |        ctx.send_viewport_cmd(egui::ViewportCommand::Close);
 1200|       |    }
 1201|       |
 1202|       |    #[cfg(test)]
 1203|      2|    fn request_close(&self, _ctx: &Context) {}
 1204|       |
 1205|       |    #[cfg(not(test))]
 1206|       |    fn pick_open_path(&self) -> Option<PathBuf> {
 1207|       |        FileDialog::new()
 1208|       |            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
 1209|       |            .add_filter("All files", &["*"])
 1210|       |            .set_title("Open Markdown File")
 1211|       |            .pick_file()
 1212|       |    }
 1213|       |
 1214|       |    #[cfg(test)]
 1215|      8|    fn pick_open_path(&self) -> Option<PathBuf> {
 1216|      8|        take_forced_open_path()
 1217|      8|    }
 1218|       |
 1219|       |    #[cfg(not(test))]
 1220|       |    fn pick_save_path(&self) -> Option<PathBuf> {
 1221|       |        FileDialog::new()
 1222|       |            .set_title("Save Markdown File")
 1223|       |            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
 1224|       |            .save_file()
 1225|       |    }
 1226|       |
 1227|       |    #[cfg(test)]
 1228|      6|    fn pick_save_path(&self) -> Option<PathBuf> {
 1229|      6|        take_forced_save_path()
 1230|      6|    }
 1231|       |
 1232|       |    /// Open file dialog to select a markdown file
 1233|      8|    fn open_file_dialog(&mut self) {
 1234|      8|        if let Some(path) = self.pick_open_path() {
                                  ^5
 1235|      5|            if let Err(e) = self.load_file(path, true) {
                                     ^1
 1236|      1|                self.error_message = Some(format!("Failed to open file: {}", e));
 1237|      4|            }
 1238|      3|        }
 1239|      8|    }
 1240|       |
 1241|       |    /// Toggle between Rendered and Raw view
 1242|      9|    fn toggle_view_mode(&mut self, ctx: &Context) {
 1243|       |        // If leaving Raw view while editing, capture cursor before switching
 1244|      9|        if matches!(self.view_mode, ViewMode::Raw) && self.write_enabled {
                         ^4                                         ^5
 1245|      4|            let editor_id = egui::Id::new("raw_editor");
 1246|      4|            if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
                                      ^2
 1247|      2|                if let Some(range) = state.cursor.char_range() {
                                          ^1
 1248|      1|                    self.raw_cursor = Some(range.primary.index);
 1249|      1|                }
 1250|      2|            }
 1251|      5|        }
 1252|      9|        self.view_mode = match self.view_mode {
 1253|       |            ViewMode::Rendered => {
 1254|      4|                self.raw_focus_requested = true;
 1255|      4|                ViewMode::Raw
 1256|       |            }
 1257|      5|            ViewMode::Raw => ViewMode::Rendered,
 1258|       |        };
 1259|      9|    }
 1260|       |
 1261|       |    /// Handle keyboard shortcuts
 1262|     53|    fn handle_shortcuts(&mut self, ctx: &Context) {
 1263|     53|        ctx.input_mut(|i| {
 1264|     53|            let in_raw_edit = matches!(self.view_mode, ViewMode::Raw) && self.write_enabled;
                                            ^44                                        ^9
 1265|       |            // Ctrl+O - Open file
 1266|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1267|     53|                egui::Modifiers::CTRL,
 1268|     53|                egui::Key::O,
 1269|     53|            )) {
 1270|      1|                self.open_file_dialog();
 1271|     52|            }
 1272|       |
 1273|       |            // Alt-based accelerators for common actions (mnemonics)
 1274|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1275|     53|                egui::Modifiers::ALT,
 1276|     53|                egui::Key::O,
 1277|     53|            )) {
 1278|      1|                self.open_file_dialog();
 1279|     52|            }
 1280|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1281|     53|                egui::Modifiers::ALT,
 1282|     53|                egui::Key::W,
 1283|     53|            )) {
 1284|      1|                self.close_current_file();
 1285|     52|            }
 1286|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1287|     53|                egui::Modifiers::ALT,
 1288|     53|                egui::Key::Q,
 1289|     53|            )) {
 1290|      1|                self.request_close(ctx);
 1291|     52|            }
 1292|       |
 1293|       |            // Ctrl+Q - Quit application
 1294|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1295|     53|                egui::Modifiers::CTRL,
 1296|     53|                egui::Key::Q,
 1297|     53|            )) {
 1298|      1|                self.request_close(ctx);
 1299|     52|            }
 1300|       |
 1301|       |            // Ctrl+W - Close current file
 1302|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1303|     53|                egui::Modifiers::CTRL,
 1304|     53|                egui::Key::W,
 1305|     53|            )) {
 1306|      1|                self.close_current_file();
 1307|     52|            }
 1308|       |
 1309|       |            // Ctrl+F - Open search dialog
 1310|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1311|     53|                egui::Modifiers::CTRL,
 1312|     53|                egui::Key::F,
 1313|     53|            )) {
 1314|      3|                self.show_search = true;
 1315|      3|                if self.last_match_index.is_none() {
 1316|      2|                    self.last_match_index = Some(0);
 1317|      2|                }
                              ^1
 1318|      3|                self.search_focus_requested = true;
 1319|     50|            }
 1320|       |
 1321|       |            // F3 navigation: next / previous
 1322|     53|            let prev_shift = i.consume_shortcut(&egui::KeyboardShortcut::new(
 1323|     53|                egui::Modifiers::SHIFT,
 1324|     53|                egui::Key::F3,
 1325|     53|            ));
 1326|     53|            let prev_alt = i.consume_shortcut(&egui::KeyboardShortcut::new(
 1327|     53|                egui::Modifiers::ALT,
 1328|     53|                egui::Key::F3,
 1329|     53|            ));
 1330|     53|            if prev_shift || prev_alt {
                                           ^51
 1331|      3|                self.find_previous();
 1332|     50|            } else if i.consume_key(egui::Modifiers::NONE, egui::Key::F3) {
 1333|      1|                self.find_next();
 1334|     49|            }
 1335|       |
 1336|       |            // Ctrl+Plus - Zoom in
 1337|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1338|     53|                egui::Modifiers::CTRL,
 1339|     53|                egui::Key::Plus,
 1340|     53|            )) {
 1341|      1|                self.renderer.zoom_in();
 1342|     52|            }
 1343|       |
 1344|       |            // Ctrl+Minus - Zoom out
 1345|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1346|     53|                egui::Modifiers::CTRL,
 1347|     53|                egui::Key::Minus,
 1348|     53|            )) {
 1349|      1|                self.renderer.zoom_out();
 1350|     52|            }
 1351|       |
 1352|       |            // Ctrl+0 - Reset zoom
 1353|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1354|     53|                egui::Modifiers::CTRL,
 1355|     53|                egui::Key::Num0,
 1356|     53|            )) {
 1357|      1|                self.renderer.reset_zoom();
 1358|     52|            }
 1359|       |
 1360|       |            // Alt+Left - Navigate back
 1361|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1362|     53|                egui::Modifiers::ALT,
 1363|     53|                egui::Key::ArrowLeft,
 1364|     53|            )) {
 1365|      1|                self.navigate_back();
 1366|     52|            }
 1367|       |
 1368|       |            // Alt+Right - Navigate forward
 1369|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1370|     53|                egui::Modifiers::ALT,
 1371|     53|                egui::Key::ArrowRight,
 1372|     53|            )) {
 1373|      1|                self.navigate_forward();
 1374|     52|            }
 1375|       |
 1376|       |            // Ctrl + Mouse Wheel - Zoom
 1377|     53|            if i.modifiers.ctrl {
 1378|      6|                let mut total = 0.0f32;
 1379|     11|                for ev in &i.events {
                                  ^5
 1380|      5|                    if let egui::Event::MouseWheel { delta, .. } = ev {
                                                                   ^4
 1381|      4|                        total += delta.y;
 1382|      4|                    }
                                  ^1
 1383|       |                }
 1384|      6|                if total.abs() > 0.0 {
 1385|      4|                    if total > 0.0 {
 1386|      2|                        self.renderer.zoom_in();
 1387|      2|                    } else {
 1388|      2|                        self.renderer.zoom_out();
 1389|      2|                    }
 1390|      2|                }
 1391|     47|            }
 1392|       |
 1393|       |            // Ctrl+R - Toggle raw view
 1394|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1395|     53|                egui::Modifiers::CTRL,
 1396|     53|                egui::Key::R,
 1397|     53|            )) {
 1398|      1|                // Defer to avoid acting inside input context
 1399|      1|                self.view_toggle_requested = true;
 1400|     52|            }
 1401|       |            // Ctrl+E - Toggle write mode (deferred)
 1402|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1403|     53|                egui::Modifiers::CTRL,
 1404|     53|                egui::Key::E,
 1405|     53|            )) {
 1406|      1|                self.write_toggle_requested = true;
 1407|     52|            }
 1408|       |            // Ctrl+S - Save document
 1409|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1410|     53|                egui::Modifiers::CTRL,
 1411|     53|                egui::Key::S,
 1412|     53|            )) {
 1413|      2|                if let Err(e) = self.save_current_document() {
                                         ^1
 1414|      1|                    self.error_message = Some(format!("Failed to save: {}", e));
 1415|      1|                }
 1416|     51|            }
 1417|       |            // Note: No global Alt+R to avoid conflict (File > Reload vs View > Raw)
 1418|       |
 1419|       |            // F11 - Toggle fullscreen (set flag to handle outside input context)
 1420|     53|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F11) {
 1421|      1|                self.toggle_fullscreen = true;
 1422|     52|            }
 1423|       |
 1424|       |            // F5 - Reload current file (set flag; actual IO handled outside input context)
 1425|     53|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F5) {
 1426|      1|                self.request_reload();
 1427|     52|            }
 1428|       |
 1429|       |            // Esc - dismiss search dialog if visible
 1430|     53|            if self.show_search && i.consume_key(egui::Modifiers::NONE, egui::Key::Escape) {
                                                 ^6^6                                 ^6
 1431|      1|                self.clear_search_state();
 1432|      1|                self.show_search = false;
 1433|     52|            }
 1434|       |
 1435|       |            // Only consume navigation keys when not editing in raw view
 1436|     53|            if !in_raw_edit {
 1437|     45|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
 1438|      1|                    self.nav_request = Some(NavigationRequest::PageUp);
 1439|     44|                }
 1440|     45|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
 1441|      1|                    self.nav_request = Some(NavigationRequest::PageDown);
 1442|     44|                }
 1443|       |                // Home - Go to top of document
 1444|     45|                if i.consume_key(egui::Modifiers::NONE, egui::Key::Home) {
 1445|      1|                    self.nav_request = Some(NavigationRequest::Top);
 1446|     44|                }
 1447|       |
 1448|       |                // End - Go to bottom of document
 1449|     45|                if i.consume_key(egui::Modifiers::NONE, egui::Key::End) {
 1450|      1|                    self.nav_request = Some(NavigationRequest::Bottom);
 1451|     44|                }
 1452|       |
 1453|       |                // Arrow Up - Fine scroll up
 1454|     45|                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowUp) {
 1455|      1|                    self.nav_request = Some(NavigationRequest::ScrollUp);
 1456|     44|                }
 1457|       |
 1458|       |                // Arrow Down - Fine scroll down
 1459|     45|                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowDown) {
 1460|      1|                    self.nav_request = Some(NavigationRequest::ScrollDown);
 1461|     44|                }
 1462|       |            } else {
 1463|       |                // In raw edit mode: implement PageUp/PageDown by moving caret by ~a page of lines
 1464|       |                const PAGE_LINES: i32 = 24; // match desired_rows for the editor
 1465|      8|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
 1466|      1|                    self.pending_raw_cursor_line_move = Some(-PAGE_LINES);
 1467|      1|                    self.raw_focus_requested = true;
 1468|      7|                }
 1469|      8|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
 1470|      1|                    self.pending_raw_cursor_line_move = Some(PAGE_LINES);
 1471|      1|                    self.raw_focus_requested = true;
 1472|      7|                }
 1473|       |            }
 1474|     53|        });
 1475|     53|    }
 1476|       |
 1477|     35|    fn render_file_menu_contents(
 1478|     35|        &mut self,
 1479|     35|        ui: &mut egui::Ui,
 1480|     35|        alt_pressed: bool,
 1481|     35|        menu_text_color: Color32,
 1482|     35|    ) {
 1483|     35|        ui.horizontal(|ui| {
 1484|     35|            let clicked = ui
 1485|     35|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1486|     35|                    None,
 1487|     35|                    "Open...",
 1488|     35|                    'O',
 1489|     35|                    alt_pressed,
 1490|     35|                    menu_text_color,
 1491|     35|                )))
 1492|     35|                .clicked();
 1493|     35|            if app_action_triggered(clicked, "menu_open") {
 1494|      3|                self.open_file_dialog();
 1495|      3|                ui.close_menu();
 1496|     32|            }
 1497|     35|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1498|     35|                ui.label(RichText::new("Ctrl+O").color(menu_text_color));
 1499|     35|            });
 1500|     35|        });
 1501|       |
 1502|     35|        ui.horizontal(|ui| {
 1503|     35|            let enabled = !self.current_content.is_empty();
 1504|     35|            let button = ui.add_enabled(
 1505|     35|                enabled,
 1506|     35|                egui::Button::new(Self::menu_text_with_mnemonic(
 1507|     35|                    None,
 1508|     35|                    "Save",
 1509|       |                    'S',
 1510|     35|                    alt_pressed,
 1511|     35|                    menu_text_color,
 1512|       |                )),
 1513|       |            );
 1514|     35|            if app_action_triggered(button.clicked(), "menu_save") {
 1515|      4|                if let Err(e) = self.save_current_document() {
                                         ^1
 1516|      1|                    self.error_message = Some(format!("Failed to save: {}", e));
 1517|      3|                }
 1518|      4|                ui.close_menu();
 1519|     31|            }
 1520|     35|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1521|     35|                ui.label(RichText::new("Ctrl+S").color(menu_text_color));
 1522|     35|            });
 1523|     35|        });
 1524|       |
 1525|     35|        ui.horizontal(|ui| {
 1526|     35|            let clicked = ui
 1527|     35|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1528|     35|                    None,
 1529|     35|                    "Close",
 1530|     35|                    'C',
 1531|     35|                    alt_pressed,
 1532|     35|                    menu_text_color,
 1533|     35|                )))
 1534|     35|                .clicked();
 1535|     35|            if app_action_triggered(clicked, "menu_close") {
 1536|      3|                self.close_current_file();
 1537|      3|                ui.close_menu();
 1538|     32|            }
 1539|     35|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1540|     35|                ui.label(RichText::new("Ctrl+W").color(menu_text_color));
 1541|     35|            });
 1542|     35|        });
 1543|       |
 1544|     35|        ui.horizontal(|ui| {
 1545|     35|            let enabled = self.current_file.is_some();
 1546|     35|            let button = ui.add_enabled(
 1547|     35|                enabled,
 1548|     35|                egui::Button::new(Self::menu_text_with_mnemonic(
 1549|     35|                    None,
 1550|     35|                    "Reload",
 1551|       |                    'R',
 1552|     35|                    alt_pressed,
 1553|     35|                    menu_text_color,
 1554|       |                )),
 1555|       |            );
 1556|     35|            if app_action_triggered(button.clicked(), "menu_reload") {
 1557|      3|                self.request_reload();
 1558|      3|                ui.close_menu();
 1559|     32|            }
 1560|     35|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1561|     35|                ui.label(RichText::new("F5").color(menu_text_color));
 1562|     35|            });
 1563|     35|        });
 1564|       |
 1565|     35|        ui.horizontal(|ui| {
 1566|     35|            let clicked = ui
 1567|     35|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1568|     35|                    None,
 1569|     35|                    "Find...",
 1570|     35|                    'F',
 1571|     35|                    alt_pressed,
 1572|     35|                    menu_text_color,
 1573|     35|                )))
 1574|     35|                .clicked();
 1575|     35|            if app_action_triggered(clicked, "menu_find") {
 1576|      3|                self.show_search = true;
 1577|      3|                self.search_focus_requested = true;
 1578|      3|                ui.close_menu();
 1579|     32|            }
 1580|     35|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1581|     35|                ui.label(RichText::new("Ctrl+F").color(menu_text_color));
 1582|     35|            });
 1583|     35|        });
 1584|       |
 1585|     35|        ui.separator();
 1586|       |
 1587|       |        #[cfg(not(test))]
 1588|       |        ui.menu_button(
 1589|       |            Self::menu_text_with_mnemonic(None, "Samples", 'S', alt_pressed, menu_text_color),
 1590|       |            |ui| {
 1591|       |                self.render_samples_menu_contents(ui);
 1592|       |            },
 1593|       |        );
 1594|       |        #[cfg(test)]
 1595|     35|        self.render_samples_menu_contents(ui);
 1596|     35|        if app_action_triggered(false, "menu_samples") {
 1597|      3|            self.render_samples_menu_contents(ui);
 1598|     32|        }
 1599|     35|    }
 1600|       |
 1601|     38|    fn render_samples_menu_contents(&mut self, ui: &mut egui::Ui) {
 1602|    266|        for sample in SAMPLE_FILES {
                          ^228
 1603|    228|            if app_action_triggered(ui.button(sample.title).clicked(), sample.name) {
 1604|     12|                self.load_sample(sample);
 1605|     12|                ui.close_menu();
 1606|    216|            }
 1607|       |        }
 1608|     38|    }
 1609|       |
 1610|     34|    fn render_view_menu_contents(
 1611|     34|        &mut self,
 1612|     34|        ui: &mut egui::Ui,
 1613|     34|        ctx: &Context,
 1614|     34|        alt_pressed: bool,
 1615|     34|        menu_text_color: Color32,
 1616|     34|    ) {
 1617|     34|        ui.horizontal(|ui| {
 1618|     34|            let enabled = self.can_navigate_back();
 1619|     34|            let clicked = ui
 1620|     34|                .add_enabled(enabled, egui::Button::new("<- Back"))
 1621|     34|                .clicked();
 1622|     34|            if app_action_triggered(clicked, "menu_back") {
 1623|      3|                self.navigate_back();
 1624|      3|                ui.close_menu();
 1625|     31|            }
 1626|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1627|     34|                ui.label(RichText::new("Alt+Left").color(menu_text_color));
 1628|     34|            });
 1629|     34|        });
 1630|       |
 1631|     34|        ui.horizontal(|ui| {
 1632|     34|            let enabled = self.can_navigate_forward();
 1633|     34|            let clicked = ui
 1634|     34|                .add_enabled(enabled, egui::Button::new("Forward ->"))
 1635|     34|                .clicked();
 1636|     34|            if app_action_triggered(clicked, "menu_forward") {
 1637|      3|                self.navigate_forward();
 1638|      3|                ui.close_menu();
 1639|     31|            }
 1640|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1641|     34|                ui.label(RichText::new("Alt+Right").color(menu_text_color));
 1642|     34|            });
 1643|     34|        });
 1644|       |
 1645|     34|        ui.separator();
 1646|       |
 1647|     34|        ui.horizontal(|ui| {
 1648|     34|            let selected = matches!(self.view_mode, ViewMode::Raw);
                                         ^24
 1649|     34|            let clicked = ui
 1650|     34|                .add(egui::SelectableLabel::new(
 1651|     34|                    selected,
 1652|     34|                    Self::menu_text_with_mnemonic(
 1653|     34|                        None,
 1654|     34|                        "Raw Markdown",
 1655|     34|                        'R',
 1656|     34|                        alt_pressed,
 1657|     34|                        menu_text_color,
 1658|     34|                    ),
 1659|     34|                ))
 1660|     34|                .clicked();
 1661|     34|            if app_action_triggered(clicked, "menu_raw") {
 1662|      3|                self.toggle_view_mode(ctx);
 1663|      3|                ui.close_menu();
 1664|     31|            }
 1665|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1666|     34|                ui.label(RichText::new("Ctrl+R").color(menu_text_color));
 1667|     34|            });
 1668|     34|        });
 1669|       |
 1670|     34|        ui.horizontal(|ui| {
 1671|     34|            let selected = self.write_enabled;
 1672|     34|            let clicked = ui
 1673|     34|                .add(egui::SelectableLabel::new(
 1674|     34|                    selected,
 1675|     34|                    Self::menu_text_with_mnemonic(
 1676|     34|                        None,
 1677|     34|                        "Write Mode",
 1678|     34|                        'W',
 1679|     34|                        alt_pressed,
 1680|     34|                        menu_text_color,
 1681|     34|                    ),
 1682|     34|                ))
 1683|     34|                .clicked();
 1684|     34|            if app_action_triggered(clicked, "menu_write") {
 1685|      3|                self.toggle_write_mode(ctx);
 1686|      3|                ui.close_menu();
 1687|     31|            }
 1688|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1689|     34|                ui.label(RichText::new("Ctrl+E").color(menu_text_color));
 1690|     34|            });
 1691|     34|        });
 1692|       |
 1693|     34|        ui.horizontal(|ui| {
 1694|     34|            let clicked = ui
 1695|     34|                .add(egui::SelectableLabel::new(
 1696|     34|                    self.wrap_raw,
 1697|     34|                    Self::menu_text_with_mnemonic(
 1698|     34|                        None,
 1699|     34|                        "Wrap Raw Lines",
 1700|     34|                        'L',
 1701|     34|                        alt_pressed,
 1702|     34|                        menu_text_color,
 1703|     34|                    ),
 1704|     34|                ))
 1705|     34|                .clicked();
 1706|     34|            if app_action_triggered(clicked, "menu_wrap_raw") {
 1707|      3|                self.wrap_raw = !self.wrap_raw;
 1708|     31|            }
 1709|     34|        });
 1710|       |
 1711|     34|        ui.horizontal(|ui| {
 1712|     34|            let clicked = ui
 1713|     34|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1714|     34|                    None,
 1715|     34|                    "Zoom In",
 1716|     34|                    'I',
 1717|     34|                    alt_pressed,
 1718|     34|                    menu_text_color,
 1719|     34|                )))
 1720|     34|                .clicked();
 1721|     34|            if app_action_triggered(clicked, "menu_zoom_in") {
 1722|      3|                self.renderer.zoom_in();
 1723|      3|                ui.close_menu();
 1724|     31|            }
 1725|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1726|     34|                ui.label(RichText::new("Ctrl++").color(menu_text_color));
 1727|     34|            });
 1728|     34|        });
 1729|       |
 1730|     34|        ui.horizontal(|ui| {
 1731|     34|            let clicked = ui
 1732|     34|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1733|     34|                    None,
 1734|     34|                    "Zoom Out",
 1735|     34|                    'O',
 1736|     34|                    alt_pressed,
 1737|     34|                    menu_text_color,
 1738|     34|                )))
 1739|     34|                .clicked();
 1740|     34|            if app_action_triggered(clicked, "menu_zoom_out") {
 1741|      3|                self.renderer.zoom_out();
 1742|      3|                ui.close_menu();
 1743|     31|            }
 1744|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1745|     34|                ui.label(RichText::new("Ctrl+-").color(menu_text_color));
 1746|     34|            });
 1747|     34|        });
 1748|       |
 1749|     34|        ui.horizontal(|ui| {
 1750|     34|            let clicked = ui
 1751|     34|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1752|     34|                    None,
 1753|     34|                    "Reset Zoom",
 1754|     34|                    'Z',
 1755|     34|                    alt_pressed,
 1756|     34|                    menu_text_color,
 1757|     34|                )))
 1758|     34|                .clicked();
 1759|     34|            if app_action_triggered(clicked, "menu_zoom_reset") {
 1760|      3|                self.renderer.reset_zoom();
 1761|      3|                ui.close_menu();
 1762|     31|            }
 1763|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1764|     34|                ui.label(RichText::new("Ctrl+0").color(menu_text_color));
 1765|     34|            });
 1766|     34|        });
 1767|       |
 1768|     34|        ui.separator();
 1769|       |
 1770|     34|        ui.horizontal(|ui| {
 1771|     34|            let clicked = ui
 1772|     34|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1773|     34|                    None,
 1774|     34|                    "Toggle Fullscreen",
 1775|     34|                    'T',
 1776|     34|                    alt_pressed,
 1777|     34|                    menu_text_color,
 1778|     34|                )))
 1779|     34|                .clicked();
 1780|     34|            if app_action_triggered(clicked, "menu_fullscreen") {
 1781|      3|                let is_fullscreen = ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
 1782|      3|                ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(!is_fullscreen));
 1783|      3|                ui.close_menu();
 1784|     31|            }
 1785|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1786|     34|                ui.label(RichText::new("F11").color(menu_text_color));
 1787|     34|            });
 1788|     34|        });
 1789|     34|    }
 1790|       |
 1791|     34|    fn render_help_menu_contents(
 1792|     34|        &mut self,
 1793|     34|        ui: &mut egui::Ui,
 1794|     34|        alt_pressed: bool,
 1795|     34|        menu_text_color: Color32,
 1796|     34|    ) {
 1797|     34|        ui.horizontal(|ui| {
 1798|     34|            let clicked = ui
 1799|     34|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1800|     34|                    None,
 1801|     34|                    "Usage Instructions",
 1802|     34|                    'U',
 1803|     34|                    alt_pressed,
 1804|     34|                    menu_text_color,
 1805|     34|                )))
 1806|     34|                .clicked();
 1807|     34|            if app_action_triggered(clicked, "menu_help_usage") {
 1808|      3|                let _ = self.load_sample_by_name(SAMPLE_FILES, "usage.md");
 1809|      3|                ui.close_menu();
 1810|     31|            }
 1811|     34|        });
 1812|       |
 1813|     34|        ui.horizontal(|ui| {
 1814|     34|            let clicked = ui
 1815|     34|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1816|     34|                    None,
 1817|     34|                    "About",
 1818|     34|                    'A',
 1819|     34|                    alt_pressed,
 1820|     34|                    menu_text_color,
 1821|     34|                )))
 1822|     34|                .clicked();
 1823|     34|            if app_action_triggered(clicked, "menu_help_about") {
 1824|      3|                let _ = self.load_sample_by_name(SAMPLE_FILES, "welcome.md");
 1825|      3|                ui.close_menu();
 1826|     31|            }
 1827|     34|        });
 1828|     34|    }
 1829|       |
 1830|       |    /// Render the menu bar
 1831|     31|    fn render_menu_bar(&mut self, ctx: &Context) {
 1832|     31|        TopBottomPanel::top("menu_bar").show(ctx, |ui| {
 1833|     31|            let alt_pressed = ui.input(|i| i.modifiers.alt);
 1834|     31|            let menu_text_color = if ui.visuals().dark_mode {
 1835|     30|                Color32::WHITE
 1836|       |            } else {
 1837|      1|                Color32::BLACK
 1838|       |            };
 1839|     31|            menu::bar(ui, |ui| {
 1840|       |                // File menu (Alt+F mnemonic visual)
 1841|       |                #[cfg(not(test))]
 1842|       |                ui.menu_button(
 1843|       |                    Self::menu_text_with_mnemonic(None, "File", 'F', alt_pressed, menu_text_color),
 1844|       |                    |ui| {
 1845|       |                        self.render_file_menu_contents(ui, alt_pressed, menu_text_color);
 1846|       |                    },
 1847|       |                );
 1848|       |                #[cfg(test)]
 1849|     31|                self.render_file_menu_contents(ui, alt_pressed, menu_text_color);
 1850|     31|                if app_action_triggered(false, "menu_bar_file") {
 1851|      1|                    self.render_file_menu_contents(ui, alt_pressed, menu_text_color);
 1852|     30|                }
 1853|       |
 1854|       |                // View menu
 1855|       |                #[cfg(not(test))]
 1856|       |                ui.menu_button(
 1857|       |                    Self::menu_text_with_mnemonic(None, "View", 'V', alt_pressed, menu_text_color),
 1858|       |                    |ui| {
 1859|       |                        self.render_view_menu_contents(ui, ctx, alt_pressed, menu_text_color);
 1860|       |                    },
 1861|       |                );
 1862|       |                #[cfg(test)]
 1863|     31|                self.render_view_menu_contents(ui, ctx, alt_pressed, menu_text_color);
 1864|     31|                if app_action_triggered(false, "menu_bar_view") {
 1865|      1|                    self.render_view_menu_contents(ui, ctx, alt_pressed, menu_text_color);
 1866|     30|                }
 1867|       |
 1868|       |                #[cfg(not(test))]
 1869|       |                ui.menu_button(
 1870|       |                    Self::menu_text_with_mnemonic(None, "Help", 'H', alt_pressed, menu_text_color),
 1871|       |                    |ui| {
 1872|       |                        self.render_help_menu_contents(ui, alt_pressed, menu_text_color);
 1873|       |                    },
 1874|       |                );
 1875|       |                #[cfg(test)]
 1876|     31|                self.render_help_menu_contents(ui, alt_pressed, menu_text_color);
 1877|     31|                if app_action_triggered(false, "menu_bar_help") {
 1878|      1|                    self.render_help_menu_contents(ui, alt_pressed, menu_text_color);
 1879|     30|                }
 1880|     31|            });
 1881|     31|        });
 1882|       |
 1883|       |        // No programmatic overlay menus; rely on pointer to open egui menus.
 1884|     31|    }
 1885|       |
 1886|      2|    fn render_main_context_menu(&mut self, ui: &mut egui::Ui) {
 1887|      2|        ui.label("Select text, then use Ctrl+C to copy");
 1888|      2|        ui.separator();
 1889|       |
 1890|       |        // Copy All Text option
 1891|      2|        if app_action_triggered(ui.button("Copy All Text").clicked(), "ctx_copy_all") {
 1892|      1|            let all_text = MarkdownRenderer::elements_to_plain_text(&self.parsed_elements);
 1893|      1|            ui.ctx().copy_text(all_text);
 1894|      1|            ui.close_menu();
 1895|      1|        }
 1896|       |
 1897|       |        // Copy as Markdown (Raw) option
 1898|      2|        if app_action_triggered(ui.button("Copy as Markdown").clicked(), "ctx_copy_markdown") {
 1899|      1|            ui.ctx().copy_text(self.current_content.clone());
 1900|      1|            ui.close_menu();
 1901|      1|        }
 1902|       |
 1903|      2|        ui.separator();
 1904|       |
 1905|       |        // Navigation shortcuts
 1906|      2|        if app_action_triggered(ui.button("Go to Top").clicked(), "ctx_nav_top") {
 1907|      1|            self.nav_request = Some(NavigationRequest::Top);
 1908|      1|            ui.close_menu();
 1909|      1|        }
 1910|       |
 1911|      2|        if app_action_triggered(ui.button("Go to Bottom").clicked(), "ctx_nav_bottom") {
 1912|      1|            self.nav_request = Some(NavigationRequest::Bottom);
 1913|      1|            ui.close_menu();
 1914|      1|        }
 1915|      2|    }
 1916|       |    /// Render the status bar
 1917|     34|    fn render_status_bar(&self, ctx: &Context) {
 1918|     34|        TopBottomPanel::bottom("status_bar").show(ctx, |ui| {
 1919|     34|            ui.horizontal(|ui| {
 1920|       |                // Current file info
 1921|     34|                if let Some(path) = &self.current_file {
                                          ^2
 1922|      2|                    ui.label(format!("File: {}", path.display()));
 1923|     32|                } else if !self.parsed_elements.is_empty() {
 1924|     28|                    ui.label("Sample file");
 1925|     28|                } else {
 1926|      4|                    ui.label("No file loaded");
 1927|      4|                }
 1928|       |
 1929|     34|                if let Some(pending) = &self.pending_file_load {
                                          ^1
 1930|      1|                    ui.separator();
 1931|      1|                    ui.label(
 1932|      1|                        RichText::new(format!("Loading {}", pending.path.display()))
 1933|      1|                            .color(Color32::from_rgb(120, 200, 255)),
 1934|      1|                    );
 1935|     33|                }
 1936|       |
 1937|       |                // Show pending file count if files are queued
 1938|     34|                if !self.pending_files.is_empty() {
 1939|      2|                    ui.separator();
 1940|      2|                    ui.label(
 1941|      2|                        RichText::new(format!("{} files in queue", self.pending_files.len()))
 1942|      2|                            .color(egui::Color32::from_rgb(100, 150, 255)),
 1943|      2|                    );
 1944|      2|
 1945|      2|                    ui.label(
 1946|      2|                        RichText::new("(Alt+Right for next)")
 1947|      2|                            .color(egui::Color32::GRAY)
 1948|      2|                            .italics(),
 1949|      2|                    );
 1950|     32|                }
 1951|       |
 1952|     34|                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1953|       |                    // Document stats
 1954|     34|                    let element_count = self.parsed_elements.len();
 1955|     34|                    let char_count = self.current_content.len();
 1956|     34|                    let mode = match self.view_mode {
 1957|     24|                        ViewMode::Rendered => "Rendered",
 1958|     10|                        ViewMode::Raw => "Raw",
 1959|       |                    };
 1960|     34|                    let status = format!(
 1961|     34|                        "Mode: {} | Elements: {} | Characters: {}",
 1962|       |                        mode, element_count, char_count
 1963|       |                    );
 1964|       |                    #[cfg(test)]
 1965|     34|                    {
 1966|     34|                        ui.label(status);
 1967|     34|                        self.render_status_tooltip(ui);
 1968|     34|                    }
 1969|       |                    #[cfg(not(test))]
 1970|       |                    {
 1971|       |                        ui.label(status)
 1972|       |                            .on_hover_ui(|ui| self.render_status_tooltip(ui));
 1973|       |                    }
 1974|     34|                    if app_action_triggered(false, "status_hover") {
 1975|      2|                        self.render_status_tooltip(ui);
 1976|     32|                    }
 1977|     34|                });
 1978|     34|            });
 1979|     34|        });
 1980|     34|    }
 1981|       |
 1982|     36|    fn render_status_tooltip(&self, ui: &mut egui::Ui) {
 1983|     36|        ui.label(format!("Version: {}", BUILD_VERSION));
 1984|     36|        ui.label(format!("Built: {}", BUILD_TIMESTAMP));
 1985|     36|    }
 1986|       |    /// Handle drag-drop events from egui
 1987|     29|    fn handle_drag_drop_events(&mut self, ctx: &Context) {
 1988|     29|        ctx.input(|i| {
 1989|       |            // Check if files are being hovered
 1990|     29|            self.drag_hover = !i.raw.hovered_files.is_empty();
 1991|       |
 1992|       |            // Check if files were dropped
 1993|     29|            if !i.raw.dropped_files.is_empty() {
 1994|      1|                let paths: Vec<PathBuf> = i
 1995|      1|                    .raw
 1996|      1|                    .dropped_files
 1997|      1|                    .iter()
 1998|      1|                    .filter_map(|f| f.path.clone())
 1999|      1|                    .collect();
 2000|       |
 2001|      1|                self.handle_file_drop(paths);
 2002|     28|            }
 2003|     29|        });
 2004|     29|    }
 2005|       |
 2006|       |    /// Render drag-and-drop overlay when files are hovered
 2007|     30|    fn render_drag_overlay(&self, ctx: &Context) {
 2008|     30|        if !self.drag_hover {
 2009|     28|            return;
 2010|      2|        }
 2011|       |
 2012|       |        // Full-screen overlay
 2013|      2|        egui::Area::new(egui::Id::new("drag_overlay"))
 2014|      2|            .fixed_pos(egui::pos2(0.0, 0.0))
 2015|      2|            .order(egui::Order::Foreground)
 2016|      2|            .show(ctx, |ui| {
 2017|      2|                let screen_rect = ctx.screen_rect();
 2018|       |
 2019|       |                // Semi-transparent dark background
 2020|      2|                ui.painter()
 2021|      2|                    .rect_filled(screen_rect, 0.0, egui::Color32::from_black_alpha(180));
 2022|       |
 2023|       |                // Dashed border effect using rounded rect with stroke
 2024|      2|                let border_rect = screen_rect.shrink(20.0);
 2025|      2|                let border_color = egui::Color32::from_rgb(100, 150, 255);
 2026|       |
 2027|       |                // Draw border
 2028|      2|                ui.painter()
 2029|      2|                    .rect_stroke(border_rect, 8.0, egui::Stroke::new(4.0, border_color));
 2030|       |
 2031|       |                // Center text
 2032|      2|                ui.allocate_ui_at_rect(screen_rect, |ui| {
 2033|      2|                    ui.vertical_centered(|ui| {
 2034|      2|                        ui.add_space(screen_rect.height() / 2.0 - 80.0);
 2035|       |
 2036|       |                        // Main message
 2037|      2|                        ui.label(
 2038|      2|                            RichText::new("Drop files to open")
 2039|      2|                                .size(36.0)
 2040|      2|                                .color(egui::Color32::WHITE)
 2041|      2|                                .strong(),
 2042|       |                        );
 2043|       |
 2044|      2|                        ui.add_space(20.0);
 2045|       |
 2046|       |                        // Supported formats
 2047|      2|                        ui.label(
 2048|      2|                            RichText::new("Supported: .md, .markdown, .mdown, .mkd, .txt")
 2049|      2|                                .size(18.0)
 2050|      2|                                .color(egui::Color32::LIGHT_GRAY),
 2051|       |                        );
 2052|       |
 2053|      2|                        ui.add_space(10.0);
 2054|       |
 2055|       |                        // Additional hint
 2056|      2|                        ui.label(
 2057|      2|                            RichText::new("Drop multiple files to open them in sequence")
 2058|      2|                                .size(14.0)
 2059|      2|                                .color(egui::Color32::from_rgb(150, 150, 150))
 2060|      2|                                .italics(),
 2061|       |                        );
 2062|      2|                    });
 2063|      2|                });
 2064|      2|            });
 2065|     30|    }
 2066|       |
 2067|     31|    fn update_impl(&mut self, ctx: &Context) {
 2068|     31|        self.handle_screenshot_events(ctx);
 2069|     31|        self.poll_file_loads();
 2070|     31|        if self.screenshot.as_ref().is_some_and(|state| state.done) {
 2071|      1|            return;
 2072|     30|        }
 2073|       |
 2074|     30|        let screenshot_active = self.screenshot.is_some();
 2075|     30|        let hide_chrome = screenshot_active;
 2076|       |
 2077|       |        // Handle drag-drop events
 2078|     30|        if !screenshot_active {
 2079|     29|            self.handle_drag_drop_events(ctx);
 2080|     29|        }
                      ^1
 2081|       |
 2082|       |        // Handle keyboard shortcuts
 2083|     30|        if !screenshot_active {
 2084|     29|            self.handle_shortcuts(ctx);
 2085|     29|        }
                      ^1
 2086|       |
 2087|       |        // Keep native window title in sync with the current document
 2088|     30|        ctx.send_viewport_cmd(egui::ViewportCommand::Title(self.title.clone()));
 2089|       |
 2090|     30|        let (monitor_size, outer_rect, inner_rect, is_fullscreen, is_maximized) = ctx.input(|i| {
 2091|     30|            let vp = i.viewport();
 2092|     30|            (
 2093|     30|                vp.monitor_size,
 2094|     30|                vp.outer_rect,
 2095|     30|                vp.inner_rect,
 2096|     30|                vp.fullscreen.unwrap_or(false),
 2097|     30|                vp.maximized.unwrap_or(false),
 2098|     30|            )
 2099|     30|        });
 2100|       |
 2101|     30|        let mut pos_adjusted = false;
 2102|     30|        let mut size_adjusted = false;
 2103|     30|        if !is_fullscreen {
 2104|      2|            if let Some(adjustment) =
 2105|     29|                Self::compute_window_adjustment(outer_rect, inner_rect, monitor_size)
 2106|       |            {
 2107|      2|                if let Some(pos) = adjustment.pos {
                                          ^1
 2108|      1|                    pos_adjusted = true;
 2109|      1|                    ctx.send_viewport_cmd(egui::ViewportCommand::OuterPosition(pos));
 2110|      1|                    self.last_window_pos = Some([pos.x, pos.y]);
 2111|      1|                }
 2112|      2|                if let Some(size) = adjustment.size {
                                          ^1
 2113|      1|                    size_adjusted = true;
 2114|      1|                    ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(size));
 2115|      1|                    self.last_window_size = Some([size.x, size.y]);
 2116|      1|                }
 2117|     27|            }
 2118|      1|        }
 2119|       |
 2120|     30|        if !pos_adjusted {
 2121|     29|            if let Some(outer) = outer_rect {
                                      ^3
 2122|      3|                self.last_window_pos = Some([outer.left(), outer.top()]);
 2123|     26|            }
 2124|      1|        }
 2125|     30|        if !size_adjusted && !is_fullscreen {
                                           ^29
 2126|     28|            if let Some(inner) = inner_rect {
                                      ^2
 2127|      2|                self.last_window_size = Some([inner.width(), inner.height()]);
 2128|     26|            }
 2129|      2|        }
 2130|     30|        self.last_window_maximized = is_maximized;
 2131|       |
 2132|       |        // Opportunistically persist window state if it changed, throttled to once per second
 2133|     30|        if self.should_persist_window_state() {
 2134|      1|            self.persist_window_state();
 2135|      1|            self.last_persist_instant = std::time::Instant::now();
 2136|     29|        }
 2137|       |
 2138|       |        // Handle fullscreen toggle outside input context to avoid deadlocks
 2139|     30|        if self.toggle_fullscreen {
 2140|      1|            self.toggle_fullscreen = false;
 2141|      1|            let current_fullscreen = ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
 2142|      1|            ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(!current_fullscreen));
 2143|     29|        }
 2144|       |
 2145|       |        // Handle deferred view toggle outside of input context
 2146|     30|        if self.view_toggle_requested {
 2147|      1|            self.view_toggle_requested = false;
 2148|      1|            self.toggle_view_mode(ctx);
 2149|     29|        }
 2150|       |
 2151|       |        // Handle deferred write toggle outside of input context
 2152|     30|        if self.write_toggle_requested {
 2153|      1|            self.write_toggle_requested = false;
 2154|      1|            self.toggle_write_mode(ctx);
 2155|     29|        }
 2156|       |
 2157|       |        // Handle deferred caret movement for raw editor
 2158|     30|        if let Some(delta) = self.pending_raw_cursor_line_move.take() {
                                  ^1
 2159|      1|            self.move_raw_cursor_lines(ctx, delta);
 2160|     29|        }
 2161|       |
 2162|       |        // Handle reload request outside input context to avoid blocking within input handling
 2163|     30|        if self.reload_requested {
 2164|      2|            self.reload_requested = false;
 2165|      2|            if let Err(e) = self.reload_current_file() {
                                     ^1
 2166|      1|                self.error_message = Some(format!("Failed to reload file: {}", e));
 2167|      1|            }
 2168|     28|        }
 2169|       |
 2170|       |        // Render chrome panels before the central area so they reserve space.
 2171|     30|        if !hide_chrome {
 2172|     29|            self.render_menu_bar(ctx);
 2173|     29|            self.render_status_bar(ctx);
 2174|     29|        }
                      ^1
 2175|       |
 2176|     30|        let mut layout_signature: Option<u64> = None;
 2177|     30|        let mut scroll_snapshot: Option<ScrollSnapshot> = None;
 2178|     30|        let screenshot_scroll_offset = self
 2179|     30|            .screenshot
 2180|     30|            .as_ref()
 2181|     30|            .and_then(|state| state.scroll_offset);
 2182|       |
 2183|       |        // Main content area
 2184|     30|        let central_response = CentralPanel::default().show(ctx, |ui| {
 2185|       |            // Show error message if any
 2186|     30|            if let Some(ref error) = self.error_message {
                                      ^2
 2187|      2|                ui.colored_label(Color32::RED, format!("Error: {}", error));
 2188|      2|                ui.separator();
 2189|     28|            }
 2190|       |
 2191|       |            // Render markdown content in a scrollable area
 2192|     30|            let scroll_delta = if let Some(nav) = self.nav_request.take() {
                                                         ^6
 2193|      6|                match nav {
 2194|       |                    NavigationRequest::Top => {
 2195|       |                        // Scroll to top: use a large POSITIVE delta to reach the beginning
 2196|      1|                        egui::Vec2::new(0.0, 100000.0)
 2197|       |                    }
 2198|       |                    NavigationRequest::Bottom => {
 2199|       |                        // Scroll to bottom: use a large NEGATIVE delta to reach the end
 2200|      1|                        egui::Vec2::new(0.0, -100000.0)
 2201|       |                    }
 2202|       |                    NavigationRequest::PageUp => {
 2203|      1|                        let viewport_height = ui.available_height();
 2204|      1|                        let page_size = viewport_height * 0.8;
 2205|      1|                        egui::Vec2::new(0.0, page_size) // Positive = scroll up (show earlier content)
 2206|       |                    }
 2207|       |                    NavigationRequest::PageDown => {
 2208|      1|                        let viewport_height = ui.available_height();
 2209|      1|                        let page_size = viewport_height * 0.8;
 2210|      1|                        egui::Vec2::new(0.0, -page_size) // Negative = scroll down (show later content)
 2211|       |                    }
 2212|       |                    NavigationRequest::ScrollUp => {
 2213|      1|                        egui::Vec2::new(0.0, 40.0) // Positive = fine scroll up
 2214|       |                    }
 2215|       |                    NavigationRequest::ScrollDown => {
 2216|      1|                        egui::Vec2::new(0.0, -40.0) // Negative = fine scroll down
 2217|       |                    }
 2218|       |                }
 2219|       |            } else {
 2220|     24|                egui::Vec2::ZERO
 2221|       |            };
 2222|       |
 2223|       |            // Use AlwaysVisible to prevent scrollbar appearance/disappearance from
 2224|       |            // changing the available width, which would cause Mermaid diagrams to
 2225|       |            // re-render at different widths and create layout oscillation/flickering.
 2226|     30|            let mut scroll_area = egui::ScrollArea::vertical()
 2227|     30|                .id_source(self.scroll_area_id)
 2228|     30|                .auto_shrink([false, false])
 2229|     30|                .scroll_bar_visibility(egui::scroll_area::ScrollBarVisibility::AlwaysVisible);
 2230|     30|            if let Some(offset) = screenshot_scroll_offset {
                                      ^1
 2231|      1|                scroll_area = scroll_area.vertical_scroll_offset(offset);
 2232|     29|            }
 2233|     30|            if screenshot_active {
 2234|      1|                scroll_area = scroll_area.enable_scrolling(false);
 2235|     29|            }
 2236|     30|            let scroll_output = scroll_area.show(ui, |ui| {
 2237|       |                // Apply scroll delta if we have navigation
 2238|     30|                if scroll_delta != egui::Vec2::ZERO {
 2239|      6|                    ui.scroll_with_delta(scroll_delta);
 2240|     24|                }
 2241|       |
 2242|     30|                ui.spacing_mut().item_spacing.y = 8.0;
 2243|       |
 2244|     30|                if self.parsed_elements.is_empty() && self.error_message.is_none() {
                                                                    ^3                 ^3
 2245|      2|                    ui.vertical_centered(|ui| {
 2246|      2|                        ui.add_space(50.0);
 2247|      2|                        ui.label(RichText::new("Welcome to MarkdownView").size(24.0).strong());
 2248|      2|                        ui.add_space(20.0);
 2249|      2|                        ui.label("Open a markdown file or select a sample to get started.");
 2250|      2|                        ui.add_space(20.0);
 2251|       |
 2252|      2|                        if app_action_triggered(ui.button("Open File").clicked(), "welcome_open") {
 2253|      1|                            self.open_file_dialog();
 2254|      1|                        }
 2255|      2|                    });
 2256|       |                } else {
 2257|     28|                    match self.view_mode {
 2258|       |                        ViewMode::Rendered => {
 2259|       |                            // Update highlight phrase: prefer live input, else last executed
 2260|     19|                            if self.show_search && !self.search_query.is_empty() {
                                                                 ^2
 2261|      1|                                self.renderer.set_highlight_phrase(Some(&self.search_query));
 2262|     18|                            } else if !self.last_query.is_empty() {
 2263|      2|                                self.renderer.set_highlight_phrase(Some(&self.last_query));
 2264|     16|                            } else {
 2265|     16|                                self.renderer.set_highlight_phrase(None);
 2266|     16|                            }
 2267|       |
 2268|     19|                            self.renderer.render_to_ui(ui, &self.parsed_elements);
 2269|       |                            // If a header anchor was clicked, scroll to it
 2270|     19|                            if let Some(anchor) = self.renderer.take_pending_anchor() {
                                                      ^2
 2271|      2|                                if let Some(rect) = self.renderer.header_rect_for(&anchor) {
                                                          ^1
 2272|      1|                                    // Align target header to the top of the visible area
 2273|      1|                                    ui.scroll_to_rect(rect, Some(egui::Align::Min));
 2274|      1|                                }
 2275|     17|                            }
 2276|       |                            // If a search requested a scroll, align to top of visible area
 2277|     19|                            if let Some(idx) = self.pending_scroll_to_element.take() {
                                                      ^13
 2278|     13|                                if let Some(rect) = self.renderer.element_rect_at(idx) {
                                                          ^11
 2279|     11|                                    ui.scroll_to_rect(rect, Some(egui::Align::Min));
 2280|     11|                                }
                                              ^2
 2281|      6|                            }
 2282|     19|                            layout_signature = Some(self.renderer.layout_signature());
 2283|       |                        }
 2284|       |                        ViewMode::Raw => {
 2285|       |                            // Raw markdown view; editable when write mode is enabled
 2286|      9|                            if self.write_enabled {
 2287|      8|                                let editor_id = egui::Id::new("raw_editor");
 2288|       |                                // If we have a remembered cursor, restore it (clamped)
 2289|      8|                                if let Some(mut idx) = self.raw_cursor.take() {
                                                          ^2
 2290|      2|                                    idx = idx.min(self.raw_buffer.len());
 2291|      1|                                    if let Some(mut state) =
 2292|      2|                                        egui::text_edit::TextEditState::load(ui.ctx(), editor_id)
 2293|      1|                                    {
 2294|      1|                                        let cr = egui::text::CCursorRange::one(
 2295|      1|                                            egui::text::CCursor::new(idx),
 2296|      1|                                        );
 2297|      1|                                        state.cursor.set_char_range(Some(cr));
 2298|      1|                                        state.store(ui.ctx(), editor_id);
 2299|      1|                                    } else {
 2300|      1|                                        let mut state = egui::text_edit::TextEditState::default();
 2301|      1|                                        let cr = egui::text::CCursorRange::one(
 2302|      1|                                            egui::text::CCursor::new(idx),
 2303|      1|                                        );
 2304|      1|                                        state.cursor.set_char_range(Some(cr));
 2305|      1|                                        state.store(ui.ctx(), editor_id);
 2306|      1|                                    }
 2307|      6|                                }
 2308|      8|                                let before = self.raw_buffer.clone();
 2309|      8|                                let resp = ui.add(
 2310|      8|                                    TextEdit::multiline(&mut self.raw_buffer)
 2311|      8|                                        .font(TextStyle::Monospace)
 2312|      8|                                        .code_editor()
 2313|      8|                                        .lock_focus(false)
 2314|      8|                                        .interactive(true)
 2315|      8|                                        .desired_width(f32::INFINITY)
 2316|      8|                                        .desired_rows(24)
 2317|      8|                                        .id_source(editor_id),
 2318|       |                                );
 2319|      8|                                if self.raw_focus_requested {
 2320|      4|                                    resp.request_focus();
 2321|      4|                                    self.raw_focus_requested = false;
 2322|      4|                                }
 2323|       |                                // Remember cursor position for next time
 2324|      3|                                if let Some(state) =
 2325|      8|                                    egui::text_edit::TextEditState::load(ui.ctx(), editor_id)
 2326|       |                                {
 2327|      3|                                    if let Some(range) = state.cursor.char_range() {
                                                              ^2
 2328|      2|                                        let idx = range.primary.index;
 2329|      2|                                        self.raw_cursor = Some(idx);
 2330|      2|                                    }
                                                  ^1
 2331|      5|                                }
 2332|      8|                                if self.raw_buffer != before {
 2333|      2|                                    self.current_content = self.raw_buffer.clone();
 2334|      2|                                    match self.renderer.parse(&self.current_content) {
 2335|      1|                                        Ok(elements) => {
 2336|      1|                                            self.parsed_elements = elements;
 2337|      1|                                            self.error_message = None;
 2338|      1|                                        }
 2339|      1|                                        Err(e) => {
 2340|      1|                                            self.error_message =
 2341|      1|                                                Some(format!("Failed to parse markdown: {}", e));
 2342|      1|                                        }
 2343|       |                                    }
 2344|      6|                                }
 2345|      1|                            } else {
 2346|      1|                                // Read-only
 2347|      1|                                let mut tmp = self.raw_buffer.clone();
 2348|      1|                                ui.add(
 2349|      1|                                    TextEdit::multiline(&mut tmp)
 2350|      1|                                        .font(TextStyle::Monospace)
 2351|      1|                                        .code_editor()
 2352|      1|                                        .lock_focus(false)
 2353|      1|                                        .interactive(false)
 2354|      1|                                        .desired_width(f32::INFINITY)
 2355|      1|                                        .desired_rows(24),
 2356|      1|                                );
 2357|      1|                            }
 2358|       |                        }
 2359|       |                    }
 2360|       |                }
 2361|     30|            });
 2362|     30|            scroll_snapshot = Some(ScrollSnapshot {
 2363|     30|                content_size: scroll_output.content_size,
 2364|     30|                inner_rect: scroll_output.inner_rect,
 2365|     30|                offset_y: scroll_output.state.offset.y,
 2366|     30|            });
 2367|     30|        });
 2368|       |
 2369|       |        // Add context menu for the main panel
 2370|       |        #[cfg(not(test))]
 2371|       |        central_response
 2372|       |            .response
 2373|       |            .context_menu(|ui| self.render_main_context_menu(ui));
 2374|       |
 2375|     30|        if let Some(state) = self.screenshot.as_mut() {
                                  ^1
 2376|      1|            state.content_rect = Some(central_response.response.rect);
 2377|     29|        }
 2378|     30|        self.update_screenshot_state(ctx, layout_signature, scroll_snapshot);
 2379|       |
 2380|     30|        if !hide_chrome {
 2381|     29|            // Render floating search dialog (non-modal, always on top)
 2382|     29|            self.render_search_dialog(ctx);
 2383|     29|
 2384|     29|            // Render drag-and-drop overlay (must be last to appear on top)
 2385|     29|            self.render_drag_overlay(ctx);
 2386|     29|        }
                      ^1
 2387|     31|    }
 2388|       |}
 2389|       |
 2390|       |impl eframe::App for MarkdownViewerApp {
 2391|       |    /// Update function called every frame
 2392|      1|    fn update(&mut self, ctx: &Context, _frame: &mut eframe::Frame) {
 2393|      1|        self.update_impl(ctx);
 2394|      1|    }
 2395|       |
 2396|      1|    fn auto_save_interval(&self) -> std::time::Duration {
 2397|      1|        std::time::Duration::from_secs(30)
 2398|      1|    }
 2399|       |
 2400|      2|    fn save(&mut self, _storage: &mut dyn eframe::Storage) {
 2401|       |        // Persist window position and size on app save/exit
 2402|      2|        if self.screenshot.is_none() {
 2403|      1|            self.persist_window_state();
 2404|      1|        }
 2405|      2|    }
 2406|       |}
 2407|       |
 2408|       |impl MarkdownViewerApp {
 2409|       |    // Build a rich-text label with only the mnemonic character underlined (visual cue only).
 2410|    484|    fn menu_text_with_mnemonic(
 2411|    484|        prefix: Option<&str>,
 2412|    484|        label: &str,
 2413|    484|        mnemonic: char,
 2414|    484|        underline: bool,
 2415|    484|        text_color: Color32,
 2416|    484|    ) -> LayoutJob {
 2417|    484|        let mut job = LayoutJob::default();
 2418|    484|        let default_fmt = TextFormat {
 2419|    484|            color: text_color,
 2420|    484|            ..TextFormat::default()
 2421|    484|        };
 2422|    484|        if let Some(p) = prefix {
                                  ^1
 2423|      1|            job.append(p, 0.0, default_fmt.clone());
 2424|    483|        }
 2425|    484|        let m = mnemonic.to_ascii_lowercase();
 2426|    484|        let mut applied = false;
 2427|  4.46k|        for c in label.chars() {
                               ^484  ^484
 2428|  4.46k|            let mut fmt = default_fmt.clone();
 2429|  4.46k|            if underline && !applied && c.to_ascii_lowercase() == m {
                                          ^8          ^5
 2430|      1|                // Use a subtle underline color; white works well on dark theme
 2431|      1|                fmt.underline = egui::Stroke::new(1.0, text_color);
 2432|      1|                applied = true;
 2433|  4.46k|            }
 2434|  4.46k|            let s = c.to_string();
 2435|  4.46k|            job.append(&s, 0.0, fmt);
 2436|       |        }
 2437|    484|        job
 2438|    484|    }
 2439|      6|    fn persist_window_state(&mut self) {
 2440|      6|        if let Some(state) = self.current_window_state() {
                                  ^5
 2441|      5|            if !self.window_state_changed(&state) {
 2442|      1|                return;
 2443|      4|            }
 2444|      4|            if crate::save_window_state(&state).is_ok() {
 2445|      3|                self.last_persist_instant = std::time::Instant::now();
 2446|      3|                self.last_persisted_state = Some(state);
 2447|      3|            }
                          ^1
 2448|      1|        }
 2449|      6|    }
 2450|       |
 2451|     34|    fn should_persist_window_state(&self) -> bool {
 2452|     34|        if self.screenshot.is_some() {
 2453|      2|            return false;
 2454|     32|        }
 2455|     32|        if self.last_persist_instant.elapsed() < std::time::Duration::from_secs(1) {
 2456|     29|            return false;
 2457|      3|        }
 2458|      3|        if let Some(state) = self.current_window_state() {
                                  ^2
 2459|      2|            self.window_state_changed(&state)
 2460|       |        } else {
 2461|      1|            false
 2462|       |        }
 2463|     34|    }
 2464|       |
 2465|       |    /// Save current document. If no file is associated, prompts for a path.
 2466|     11|    fn save_current_document(&mut self) -> Result<()> {
 2467|     11|        if let Some(path) = self.current_file.clone() {
                                  ^5
 2468|      5|            std::fs::write(&path, &self.current_content)?;
                                                                      ^2
 2469|      3|            let parent = path.parent();
 2470|      3|            self.renderer.set_base_dir(parent);
 2471|      3|            Ok(())
 2472|      6|        } else if let Some(path) = self.pick_save_path() {
                                         ^4
 2473|      4|            std::fs::write(&path, &self.current_content)?;
                                                                      ^1
 2474|      3|            let filename = path
 2475|      3|                .file_name()
 2476|      3|                .and_then(|n| n.to_str())
 2477|      3|                .unwrap_or("Unknown")
 2478|      3|                .to_string();
 2479|      3|            self.current_file = Some(path);
 2480|      3|            let parent = self.current_file.as_ref().and_then(|p| p.parent());
 2481|      3|            self.renderer.set_base_dir(parent);
 2482|      3|            self.title = format!("{APP_TITLE_PREFIX} - {}", filename);
 2483|      3|            Ok(())
 2484|       |        } else {
 2485|      2|            Ok(())
 2486|       |        }
 2487|     11|    }
 2488|       |
 2489|       |    /// Render the floating non-modal search dialog
 2490|     35|    fn render_search_dialog(&mut self, ctx: &Context) {
 2491|     35|        if !self.show_search {
 2492|     27|            return;
 2493|      8|        }
 2494|      8|        let mut open = self.show_search;
 2495|      8|        let prev_query = self.search_query.clone();
 2496|      8|        egui::Window::new("Find")
 2497|      8|            .collapsible(false)
 2498|      8|            .resizable(false)
 2499|      8|            .default_pos(egui::pos2(80.0, 80.0))
 2500|      8|            .open(&mut open)
 2501|      8|            .show(ctx, |ui| {
 2502|      8|                let mut submitted_next = false;
 2503|      8|                ui.horizontal(|ui| {
 2504|      8|                    let text_edit = egui::TextEdit::singleline(&mut self.search_query)
 2505|      8|                        .hint_text("Search text...")
 2506|      8|                        .desired_width(240.0);
 2507|      8|                    let resp = ui.add(text_edit);
 2508|      8|                    if self.search_focus_requested {
 2509|      2|                        resp.request_focus();
 2510|      2|                        self.search_focus_requested = false;
 2511|      6|                    }
 2512|      8|                    if Self::should_submit_search(
 2513|      8|                        resp.lost_focus(),
 2514|      8|                        ui.input(|i| i.key_pressed(egui::Key::Enter)),
 2515|      1|                    ) {
 2516|      1|                        submitted_next = true;
 2517|      7|                    }
 2518|      8|                    let next_clicked = ui.button("Next (F3)").clicked();
 2519|      8|                    if app_action_triggered(next_clicked, "search_next") || submitted_next {
                                                                                          ^7
 2520|      2|                        self.find_next();
 2521|      6|                    }
 2522|      8|                    let prev_clicked = ui.button("Prev (Shift+F3)").clicked();
 2523|      8|                    if app_action_triggered(prev_clicked, "search_prev") {
 2524|      1|                        self.find_previous();
 2525|      7|                    }
 2526|      8|                });
 2527|      8|            });
 2528|      8|        if app_action_triggered(false, "search_close") {
 2529|      2|            open = false;
 2530|      6|        }
 2531|      8|        self.update_search_results(&prev_query);
 2532|       |        // If dialog closed via close button, clear before hiding
 2533|      8|        if !open {
 2534|      2|            self.clear_search_state();
 2535|      6|        }
 2536|      8|        self.show_search = open;
 2537|     35|    }
 2538|       |
 2539|     11|    fn should_submit_search(lost_focus: bool, enter_pressed: bool) -> bool {
 2540|     11|        lost_focus && enter_pressed
                                    ^3
 2541|     11|    }
 2542|       |
 2543|     12|    fn update_search_results(&mut self, prev_query: &str) {
 2544|     12|        if self.search_query == prev_query {
 2545|      8|            return;
 2546|      4|        }
 2547|      4|        if self.search_query.is_empty() {
 2548|      1|            self.last_query.clear();
 2549|      1|            self.renderer.set_highlight_phrase(None);
 2550|      1|            return;
 2551|      3|        }
 2552|      3|        self.last_query = self.search_query.clone();
 2553|       |        // Use current last match as baseline if set, else start of doc
 2554|      3|        let baseline = self.last_match_index.unwrap_or(0);
 2555|      3|        let needle = Self::fold_for_search(&self.search_query);
 2556|      3|        let total = self.parsed_elements.len();
 2557|      3|        let mut found: Option<usize> = None;
 2558|      6|        for pass in 0..2 {
                          ^5
 2559|      5|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
 2560|      3|                Box::new(baseline..total)
 2561|       |            } else {
 2562|      2|                Box::new(0..baseline.min(total))
 2563|       |            };
 2564|      8|            for idx in range {
                              ^5
 2565|      5|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
 2566|      5|                    &self.parsed_elements[idx],
 2567|       |                );
 2568|      5|                if Self::fold_for_search(&text).contains(&needle) {
 2569|      2|                    found = Some(idx);
 2570|      2|                    break;
 2571|      3|                }
 2572|       |            }
 2573|      5|            if found.is_some() {
 2574|      2|                break;
 2575|      3|            }
 2576|       |        }
 2577|      3|        if let Some(idx) = found {
                                  ^2
 2578|      2|            self.last_match_index = Some(idx);
 2579|      2|            self.pending_scroll_to_element = Some(idx);
 2580|      2|        }
                      ^1
 2581|     12|    }
 2582|       |
 2583|     35|    fn handle_screenshot_events(&mut self, ctx: &Context) {
 2584|     35|        let screenshot = ctx.input(|i| {
 2585|     35|            i.events.iter().find_map(|event| {
                                                           ^7
 2586|      7|                if let egui::Event::Screenshot { image, .. } = event {
                                                               ^4
 2587|      4|                    Some(std::sync::Arc::clone(image))
 2588|       |                } else {
 2589|      3|                    None
 2590|       |                }
 2591|      7|            })
 2592|     35|        });
 2593|     35|        let Some(image) = screenshot else {
                               ^4
 2594|     31|            return;
 2595|       |        };
 2596|      2|        let snapshot = {
 2597|      4|            let Some(state) = self.screenshot.as_ref() else {
                                   ^3
 2598|      1|                return;
 2599|       |            };
 2600|      3|            if state.done {
 2601|      1|                return;
 2602|      2|            }
 2603|      2|            ScreenshotSnapshot::from(state)
 2604|       |        };
 2605|      2|        if let Err(err) = Self::save_screenshot_image(&image, &snapshot) {
                                 ^1
 2606|      1|            eprintln!("Failed to save screenshot: {err}");
 2607|      1|        }
 2608|      2|        let state = self.screenshot.as_mut().expect("screenshot state");
 2609|      2|        state.done = true;
 2610|      2|        ctx.send_viewport_cmd(egui::ViewportCommand::Close);
 2611|     35|    }
 2612|       |
 2613|     36|    fn update_screenshot_state(
 2614|     36|        &mut self,
 2615|     36|        ctx: &Context,
 2616|     36|        layout_signature: Option<u64>,
 2617|     36|        scroll_snapshot: Option<ScrollSnapshot>,
 2618|     36|    ) {
 2619|     36|        let Some(state) = self.screenshot.as_mut() else {
                               ^7
 2620|     29|            return;
 2621|       |        };
 2622|      7|        let native_ppp = ctx
 2623|      7|            .input(|i| i.viewport().native_pixels_per_point)
 2624|      7|            .unwrap_or(1.0);
 2625|      7|        ctx.set_pixels_per_point(1.0);
 2626|      7|        state.pixels_per_point = ctx.input(|i| i.pixels_per_point);
 2627|       |
 2628|      7|        if !state.viewport_adjusted {
 2629|      6|            let width_points = (state.config.viewport_width / native_ppp).max(1.0);
 2630|      6|            let height_points = (state.config.viewport_height / native_ppp).max(1.0);
 2631|      6|            ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(egui::vec2(
 2632|      6|                width_points,
 2633|      6|                height_points,
 2634|      6|            )));
 2635|      6|            state.viewport_adjusted = true;
 2636|      6|            ctx.request_repaint();
 2637|      6|        }
                      ^1
 2638|       |
 2639|      7|        let mut scroll_offset = None;
 2640|      7|        let mut scroll_changed = false;
 2641|      7|        if let Some(snapshot) = scroll_snapshot {
                                  ^3
 2642|      3|            scroll_offset = Some(snapshot.offset_y);
 2643|      3|            scroll_changed = state.record_scroll(snapshot);
 2644|      4|        }
 2645|       |
 2646|      7|        state.update_stability(layout_signature, scroll_offset);
 2647|       |
 2648|      7|        let pending = self.renderer.has_pending_renders();
 2649|      7|        state.pending_renders = pending;
 2650|      7|        let elapsed = state.started.elapsed();
 2651|      7|        let timed_out = elapsed >= Duration::from_millis(state.config.wait_ms);
 2652|      7|        let stable = Self::screenshot_is_stable(
 2653|      7|            state.scroll_ready(),
 2654|      7|            state.stable_frames,
 2655|      7|            state.config.settle_frames,
 2656|      7|            pending,
 2657|       |        );
 2658|       |
 2659|      7|        if stable || timed_out {
                                   ^3
 2660|      6|            if timed_out && !stable {
                                          ^4
 2661|      2|                state.timed_out = true;
 2662|      4|            }
 2663|      6|            if !state.requested {
 2664|      4|                ctx.send_viewport_cmd(egui::ViewportCommand::Screenshot);
 2665|      4|                state.requested = true;
 2666|      4|            }
                          ^2
 2667|      1|        } else {
 2668|      1|            ctx.request_repaint_after(Duration::from_millis(16));
 2669|      1|        }
 2670|       |
 2671|      7|        if scroll_changed {
 2672|      1|            ctx.request_repaint();
 2673|      6|        }
 2674|      7|        if state.requested && !state.done {
                                            ^6
 2675|      5|            ctx.request_repaint();
 2676|      5|        }
                      ^2
 2677|     36|    }
 2678|       |
 2679|     11|    fn screenshot_is_stable(
 2680|     11|        scroll_ready: bool,
 2681|     11|        stable_frames: u32,
 2682|     11|        settle_frames: u32,
 2683|     11|        pending: bool,
 2684|     11|    ) -> bool {
 2685|     11|        scroll_ready && stable_frames >= settle_frames && !pending
                                      ^7                                ^6
 2686|     11|    }
 2687|       |
 2688|     15|    fn save_screenshot_image(image: &egui::ColorImage, state: &ScreenshotSnapshot) -> Result<()> {
 2689|     15|        let full_width = image.size[0] as u32;
 2690|     15|        let full_height = image.size[1] as u32;
 2691|     15|        let mut rgba = Self::color_image_to_rgba(image);
 2692|       |
 2693|     15|        let mut crop_x = 0u32;
 2694|     15|        let mut crop_y = 0u32;
 2695|     15|        let mut crop_w = full_width;
 2696|     15|        let mut crop_h = full_height;
 2697|       |
 2698|     15|        if state.config.content_only {
 2699|      8|            if let Some(rect) = state.content_rect {
                                      ^7
 2700|      7|                let pixels_per_point = state.pixels_per_point.max(0.1);
 2701|      7|                let min_x = (rect.min.x * pixels_per_point).round() as i32;
 2702|      7|                let min_y = (rect.min.y * pixels_per_point).round() as i32;
 2703|      7|                let max_x = (rect.max.x * pixels_per_point).round() as i32;
 2704|      7|                let max_y = (rect.max.y * pixels_per_point).round() as i32;
 2705|       |
 2706|      7|                let min_x = min_x.clamp(0, full_width as i32);
 2707|      7|                let min_y = min_y.clamp(0, full_height as i32);
 2708|      7|                let max_x = max_x.clamp(min_x, full_width as i32);
 2709|      7|                let max_y = max_y.clamp(min_y, full_height as i32);
 2710|       |
 2711|      7|                let width = (max_x - min_x) as u32;
 2712|      7|                let height = (max_y - min_y) as u32;
 2713|      7|                if width > 0 && height > 0 {
                                              ^6
 2714|      5|                    crop_x = min_x as u32;
 2715|      5|                    crop_y = min_y as u32;
 2716|      5|                    crop_w = width;
 2717|      5|                    crop_h = height;
 2718|      5|                }
                              ^2
 2719|      1|            }
 2720|      7|        }
 2721|       |
 2722|     15|        if crop_x != 0 || crop_y != 0 || crop_w != full_width || crop_h != full_height {
                                        ^13            ^12                     ^11
 2723|      5|            rgba = imageops::crop_imm(&rgba, crop_x, crop_y, crop_w, crop_h).to_image();
 2724|     10|        }
 2725|       |
 2726|     15|        if let Some(parent) = state.config.output_path.parent() {
                                  ^14
 2727|     14|            std::fs::create_dir_all(parent)?;
                                                         ^1
 2728|      1|        }
 2729|     14|        rgba.save(&state.config.output_path)?;
                                                          ^2
 2730|       |
 2731|     12|        let metadata = Self::screenshot_metadata(state, full_width, full_height, crop_w, crop_h);
 2732|     12|        std::fs::write(state.config.metadata_path(), metadata)?;
                                                                            ^1
 2733|     11|        Ok(())
 2734|     15|    }
 2735|       |
 2736|     12|    fn screenshot_metadata(
 2737|     12|        state: &ScreenshotSnapshot,
 2738|     12|        full_width: u32,
 2739|     12|        full_height: u32,
 2740|     12|        crop_width: u32,
 2741|     12|        crop_height: u32,
 2742|     12|    ) -> String {
 2743|     12|        let output_path = Self::json_escape(&state.config.output_path.to_string_lossy());
 2744|     12|        let font_source = state
 2745|     12|            .config
 2746|     12|            .font_source
 2747|     12|            .as_ref()
 2748|     12|            .map(|value| format!("\"{}\"", Self::json_escape(value)))
                                       ^1      ^1        ^1                ^1
 2749|     12|            .unwrap_or_else(|| "null".to_string());
                                             ^11    ^11
 2750|     12|        let scroll_ratio = Self::json_opt_f32(state.config.scroll_ratio);
 2751|     12|        let scroll_offset = Self::json_opt_f32(state.last_scroll_offset);
 2752|     12|        let elapsed_ms = state.started.elapsed().as_millis();
 2753|       |
 2754|     12|        format!(
 2755|     12|            "{{\n  \"version\": \"{}\",\n  \"build_timestamp\": \"{}\",\n  \"output\": \"{}\",\n  \"theme\": \"{}\",\n  \"zoom\": {:.3},\n  \"content_only\": {},\n  \"scroll_ratio\": {},\n  \"scroll_offset\": {},\n  \"viewport_px\": {{\"width\": {}, \"height\": {}}},\n  \"content_px\": {{\"width\": {}, \"height\": {}}},\n  \"pixels_per_point\": {:.3},\n  \"wait_ms\": {},\n  \"settle_frames\": {},\n  \"stable_frames\": {},\n  \"timed_out\": {},\n  \"pending_renders\": {},\n  \"font_source\": {},\n  \"elapsed_ms\": {}\n}}\n",
 2756|       |            BUILD_VERSION,
 2757|       |            BUILD_TIMESTAMP,
 2758|       |            output_path,
 2759|     12|            state.config.theme.as_str(),
 2760|       |            state.config.zoom,
 2761|       |            state.config.content_only,
 2762|       |            scroll_ratio,
 2763|       |            scroll_offset,
 2764|       |            full_width,
 2765|       |            full_height,
 2766|       |            crop_width,
 2767|       |            crop_height,
 2768|       |            state.pixels_per_point,
 2769|       |            state.config.wait_ms,
 2770|       |            state.config.settle_frames,
 2771|       |            state.stable_frames,
 2772|       |            state.timed_out,
 2773|       |            state.pending_renders,
 2774|       |            font_source,
 2775|       |            elapsed_ms
 2776|       |        )
 2777|     12|    }
 2778|       |
 2779|     16|    fn color_image_to_rgba(image: &egui::ColorImage) -> RgbaImage {
 2780|     16|        let width = image.size[0] as u32;
 2781|     16|        let height = image.size[1] as u32;
 2782|     16|        let mut data = Vec::with_capacity(image.pixels.len() * 4);
 2783|  10.6k|        for pixel in &image.pixels {
                          ^10.6k
 2784|  10.6k|            data.extend_from_slice(&[pixel.r(), pixel.g(), pixel.b(), pixel.a()]);
 2785|  10.6k|        }
 2786|     16|        RgbaImage::from_raw(width, height, data).unwrap_or_else(|| RgbaImage::new(width, height))
                                                                                 ^1             ^1     ^1
 2787|     16|    }
 2788|       |
 2789|     14|    fn json_escape(value: &str) -> String {
 2790|     14|        let mut out = String::with_capacity(value.len() + 8);
 2791|    701|        for ch in value.chars() {
                                ^14   ^14
 2792|    701|            match ch {
 2793|     86|                '\\' => out.push_str("\\\\"),
 2794|      1|                '"' => out.push_str("\\\""),
 2795|      1|                '\n' => out.push_str("\\n"),
 2796|      1|                '\r' => out.push_str("\\r"),
 2797|      1|                '\t' => out.push_str("\\t"),
 2798|    611|                _ => out.push(ch),
 2799|       |            }
 2800|       |        }
 2801|     14|        out
 2802|     14|    }
 2803|       |
 2804|     26|    fn json_opt_f32(value: Option<f32>) -> String {
 2805|     26|        value
 2806|     26|            .map(|v| format!("{v:.3}"))
                                   ^3      ^3
 2807|     26|            .unwrap_or_else(|| "null".to_string())
                                             ^23    ^23
 2808|     26|    }
 2809|       |
 2810|       |    // No overlay menu helpers; we only render egui's built-in menus.
 2811|       |}
 2812|       |
 2813|       |impl Default for MarkdownViewerApp {
 2814|      1|    fn default() -> Self {
 2815|      1|        Self::new()
 2816|      1|    }
 2817|       |}
 2818|       |
 2819|       |#[cfg(test)]
 2820|       |#[cfg_attr(coverage_nightly, coverage(off))]
 2821|       |mod tests {
 2822|       |    use super::*;
 2823|       |    use crate::markdown_renderer::InlineSpan;
 2824|       |    use eframe::{App, Storage};
 2825|       |    use std::io::Write;
 2826|       |    use std::sync::{Arc, Mutex, OnceLock};
 2827|       |    use tempfile::{NamedTempFile, TempDir};
 2828|       |
 2829|       |    fn run_app_frame(app: &mut MarkdownViewerApp, ctx: &egui::Context, input: egui::RawInput) {
 2830|       |        let _ = ctx.run(input, |ctx| {
 2831|       |            app.update_impl(ctx);
 2832|       |        });
 2833|       |    }
 2834|       |
 2835|       |    fn default_input() -> egui::RawInput {
 2836|       |        egui::RawInput {
 2837|       |            screen_rect: Some(egui::Rect::from_min_size(
 2838|       |                egui::pos2(0.0, 0.0),
 2839|       |                egui::vec2(960.0, 640.0),
 2840|       |            )),
 2841|       |            ..Default::default()
 2842|       |        }
 2843|       |    }
 2844|       |
 2845|       |    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
 2846|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
 2847|       |        ENV_LOCK
 2848|       |            .get_or_init(|| Mutex::new(()))
 2849|       |            .lock()
 2850|       |            .expect("env lock")
 2851|       |    }
 2852|       |
 2853|       |    struct EnvGuard {
 2854|       |        key: &'static str,
 2855|       |        original: Option<String>,
 2856|       |    }
 2857|       |
 2858|       |    impl EnvGuard {
 2859|       |        fn set(key: &'static str, value: &str) -> Self {
 2860|       |            let original = std::env::var(key).ok();
 2861|       |            std::env::set_var(key, value);
 2862|       |            Self { key, original }
 2863|       |        }
 2864|       |    }
 2865|       |
 2866|       |    impl Drop for EnvGuard {
 2867|       |        fn drop(&mut self) {
 2868|       |            if let Some(value) = &self.original {
 2869|       |                std::env::set_var(self.key, value);
 2870|       |            } else {
 2871|       |                std::env::remove_var(self.key);
 2872|       |            }
 2873|       |        }
 2874|       |    }
 2875|       |
 2876|       |    #[derive(Default)]
 2877|       |    struct DummyStorage;
 2878|       |
 2879|       |    impl eframe::Storage for DummyStorage {
 2880|       |        fn get_string(&self, _key: &str) -> Option<String> {
 2881|       |            None
 2882|       |        }
 2883|       |
 2884|       |        fn set_string(&mut self, _key: &str, _value: String) {}
 2885|       |
 2886|       |        fn flush(&mut self) {}
 2887|       |    }
 2888|       |
 2889|       |    #[test]
 2890|       |    fn test_dummy_storage_methods_cover_noops() {
 2891|       |        let mut storage = DummyStorage;
 2892|       |        assert!(storage.get_string("missing").is_none());
 2893|       |        storage.set_string("key", "value".to_string());
 2894|       |        storage.flush();
 2895|       |    }
 2896|       |
 2897|       |    #[test]
 2898|       |    fn test_app_auto_save_interval_is_30_seconds() {
 2899|       |        let app = MarkdownViewerApp::new();
 2900|       |        assert_eq!(app.auto_save_interval(), std::time::Duration::from_secs(30));
 2901|       |    }
 2902|       |
 2903|       |    #[test]
 2904|       |    fn test_app_update_calls_update_impl() {
 2905|       |        let mut app = MarkdownViewerApp::new();
 2906|       |        let ctx = egui::Context::default();
 2907|       |        let _ = ctx.run(default_input(), |_| {});
 2908|       |        // SAFETY: eframe::Frame is unused by update(), so a dummy value is sufficient here.
 2909|       |        let mut frame = std::mem::MaybeUninit::<eframe::Frame>::zeroed();
 2910|       |        let frame = unsafe { frame.assume_init_mut() };
 2911|       |        app.update(&ctx, frame);
 2912|       |    }
 2913|       |
 2914|       |    struct ForcedAppActions {
 2915|       |        actions: Vec<&'static str>,
 2916|       |    }
 2917|       |
 2918|       |    impl ForcedAppActions {
 2919|       |        fn new(actions: &[&'static str]) -> Self {
 2920|       |            FORCED_APP_ACTIONS.with(|set| {
 2921|       |                let mut set = set.borrow_mut();
 2922|       |                for action in actions {
 2923|       |                    set.insert(*action);
 2924|       |                }
 2925|       |            });
 2926|       |            Self {
 2927|       |                actions: actions.to_vec(),
 2928|       |            }
 2929|       |        }
 2930|       |    }
 2931|       |
 2932|       |    impl Drop for ForcedAppActions {
 2933|       |        fn drop(&mut self) {
 2934|       |            FORCED_APP_ACTIONS.with(|set| {
 2935|       |                let mut set = set.borrow_mut();
 2936|       |                for action in &self.actions {
 2937|       |                    set.remove(action);
 2938|       |                }
 2939|       |            });
 2940|       |        }
 2941|       |    }
 2942|       |
 2943|       |    struct ForcedDialogPaths;
 2944|       |
 2945|       |    impl ForcedDialogPaths {
 2946|       |        fn new(open: Option<PathBuf>, save: Option<PathBuf>) -> Self {
 2947|       |            FORCED_OPEN_PATH.with(|slot| {
 2948|       |                *slot.borrow_mut() = open;
 2949|       |            });
 2950|       |            FORCED_SAVE_PATH.with(|slot| {
 2951|       |                *slot.borrow_mut() = save;
 2952|       |            });
 2953|       |            Self
 2954|       |        }
 2955|       |    }
 2956|       |
 2957|       |    impl Drop for ForcedDialogPaths {
 2958|       |        fn drop(&mut self) {
 2959|       |            FORCED_OPEN_PATH.with(|slot| {
 2960|       |                slot.borrow_mut().take();
 2961|       |            });
 2962|       |            FORCED_SAVE_PATH.with(|slot| {
 2963|       |                slot.borrow_mut().take();
 2964|       |            });
 2965|       |        }
 2966|       |    }
 2967|       |
 2968|       |    struct ForcedLoadError;
 2969|       |
 2970|       |    impl ForcedLoadError {
 2971|       |        fn new() -> Self {
 2972|       |            FORCED_LOAD_ERROR.with(|flag| {
 2973|       |                *flag.borrow_mut() = true;
 2974|       |            });
 2975|       |            Self
 2976|       |        }
 2977|       |    }
 2978|       |
 2979|       |    impl Drop for ForcedLoadError {
 2980|       |        fn drop(&mut self) {
 2981|       |            FORCED_LOAD_ERROR.with(|flag| {
 2982|       |                *flag.borrow_mut() = false;
 2983|       |            });
 2984|       |        }
 2985|       |    }
 2986|       |
 2987|       |    struct ForcedScanError;
 2988|       |
 2989|       |    impl ForcedScanError {
 2990|       |        fn new() -> Self {
 2991|       |            FORCED_SCAN_ERROR.with(|flag| {
 2992|       |                *flag.borrow_mut() = true;
 2993|       |            });
 2994|       |            Self
 2995|       |        }
 2996|       |    }
 2997|       |
 2998|       |    impl Drop for ForcedScanError {
 2999|       |        fn drop(&mut self) {
 3000|       |            FORCED_SCAN_ERROR.with(|flag| {
 3001|       |                *flag.borrow_mut() = false;
 3002|       |            });
 3003|       |        }
 3004|       |    }
 3005|       |
 3006|       |    struct ForcedScanEntryError;
 3007|       |
 3008|       |    impl ForcedScanEntryError {
 3009|       |        fn new() -> Self {
 3010|       |            FORCED_SCAN_ENTRY_ERROR.with(|flag| {
 3011|       |                *flag.borrow_mut() = true;
 3012|       |            });
 3013|       |            Self
 3014|       |        }
 3015|       |    }
 3016|       |
 3017|       |    impl Drop for ForcedScanEntryError {
 3018|       |        fn drop(&mut self) {
 3019|       |            FORCED_SCAN_ENTRY_ERROR.with(|flag| {
 3020|       |                *flag.borrow_mut() = false;
 3021|       |            });
 3022|       |        }
 3023|       |    }
 3024|       |
 3025|       |    struct ForcedLossyReadError;
 3026|       |
 3027|       |    impl ForcedLossyReadError {
 3028|       |        fn new() -> Self {
 3029|       |            FORCED_READ_LOSSY_ERROR.with(|flag| {
 3030|       |                *flag.borrow_mut() = true;
 3031|       |            });
 3032|       |            Self
 3033|       |        }
 3034|       |    }
 3035|       |
 3036|       |    impl Drop for ForcedLossyReadError {
 3037|       |        fn drop(&mut self) {
 3038|       |            FORCED_READ_LOSSY_ERROR.with(|flag| {
 3039|       |                *flag.borrow_mut() = false;
 3040|       |            });
 3041|       |        }
 3042|       |    }
 3043|       |
 3044|       |    #[test]
 3045|       |    fn test_app_action_triggered_with_forced_action() {
 3046|       |        let _guard = ForcedAppActions::new(&["menu_open"]);
 3047|       |        assert!(app_action_triggered(false, "menu_open"));
 3048|       |        assert!(app_action_triggered(true, "menu_open"));
 3049|       |    }
 3050|       |
 3051|       |    #[test]
 3052|       |    fn test_normalize_line_endings() {
 3053|       |        // Windows style (\r\n)
 3054|       |        assert_eq!(
 3055|       |            MarkdownViewerApp::normalize_line_endings("Hello\r\nWorld"),
 3056|       |            "Hello\nWorld"
 3057|       |        );
 3058|       |
 3059|       |        // Unix style (\n) - no change
 3060|       |        assert_eq!(
 3061|       |            MarkdownViewerApp::normalize_line_endings("Hello\nWorld"),
 3062|       |            "Hello\nWorld"
 3063|       |        );
 3064|       |
 3065|       |        // Old Mac style (\r)
 3066|       |        assert_eq!(
 3067|       |            MarkdownViewerApp::normalize_line_endings("Hello\rWorld"),
 3068|       |            "Hello\nWorld"
 3069|       |        );
 3070|       |
 3071|       |        // Mixed line endings
 3072|       |        assert_eq!(
 3073|       |            MarkdownViewerApp::normalize_line_endings("A\r\nB\nC\rD"),
 3074|       |            "A\nB\nC\nD"
 3075|       |        );
 3076|       |
 3077|       |        // Multiple blank lines with Windows endings
 3078|       |        assert_eq!(
 3079|       |            MarkdownViewerApp::normalize_line_endings("A\r\n\r\nB"),
 3080|       |            "A\n\nB"
 3081|       |        );
 3082|       |
 3083|       |        // Empty string
 3084|       |        assert_eq!(MarkdownViewerApp::normalize_line_endings(""), "");
 3085|       |
 3086|       |        // No line endings
 3087|       |        assert_eq!(
 3088|       |            MarkdownViewerApp::normalize_line_endings("Single line"),
 3089|       |            "Single line"
 3090|       |        );
 3091|       |    }
 3092|       |
 3093|       |    #[test]
 3094|       |    fn test_load_file_with_windows_line_endings() -> Result<()> {
 3095|       |        let mut app = MarkdownViewerApp::new();
 3096|       |        let mut temp_file = NamedTempFile::new()?;
 3097|       |
 3098|       |        // Write content with explicit Windows line endings
 3099|       |        temp_file.write_all(b"Line 1\r\nLine 2\r\n\r\nParagraph text")?;
 3100|       |        temp_file.flush()?;
 3101|       |
 3102|       |        app.load_file(temp_file.path().to_path_buf(), true)?;
 3103|       |
 3104|       |        // Should not contain any \r characters after normalization
 3105|       |        assert!(!app.current_content.contains('\r'));
 3106|       |        assert!(app.current_content.contains("Line 1\nLine 2"));
 3107|       |        assert!(app.current_content.contains("\n\nParagraph"));
 3108|       |        Ok(())
 3109|       |    }
 3110|       |
 3111|       |    #[test]
 3112|       |    fn test_load_file_with_mixed_line_endings() -> Result<()> {
 3113|       |        let mut app = MarkdownViewerApp::new();
 3114|       |        let mut temp_file = NamedTempFile::new()?;
 3115|       |
 3116|       |        // Mix of \r\n (Windows), \n (Unix), and \r (old Mac)
 3117|       |        temp_file.write_all(b"Line 1\r\nLine 2\nLine 3\rLine 4")?;
 3118|       |        temp_file.flush()?;
 3119|       |
 3120|       |        app.load_file(temp_file.path().to_path_buf(), true)?;
 3121|       |
 3122|       |        // All should be normalized to \n
 3123|       |        assert!(!app.current_content.contains('\r'));
 3124|       |        assert_eq!(app.current_content.lines().count(), 4);
 3125|       |        let lines: Vec<&str> = app.current_content.lines().collect();
 3126|       |        assert_eq!(lines[0], "Line 1");
 3127|       |        assert_eq!(lines[1], "Line 2");
 3128|       |        assert_eq!(lines[2], "Line 3");
 3129|       |        assert_eq!(lines[3], "Line 4");
 3130|       |        Ok(())
 3131|       |    }
 3132|       |
 3133|       |    #[test]
 3134|       |    fn test_load_file_strips_bom() -> Result<()> {
 3135|       |        let mut app = MarkdownViewerApp::new();
 3136|       |        let mut temp_file = NamedTempFile::new()?;
 3137|       |
 3138|       |        temp_file.write_all(b"\xEF\xBB\xBF# Heading\nContent")?;
 3139|       |        temp_file.flush()?;
 3140|       |
 3141|       |        app.load_file(temp_file.path().to_path_buf(), true)?;
 3142|       |
 3143|       |        assert!(!app.current_content.starts_with('\u{FEFF}'));
 3144|       |        assert!(app.current_content.starts_with("# Heading"));
 3145|       |        Ok(())
 3146|       |    }
 3147|       |
 3148|       |    #[test]
 3149|       |    fn test_app_creation() {
 3150|       |        let app = MarkdownViewerApp::new();
 3151|       |        assert!(!app.parsed_elements.is_empty()); // Should load welcome content
 3152|       |        assert!(app.title.contains(APP_TITLE_PREFIX));
 3153|       |        assert!(app.error_message.is_none());
 3154|       |        assert!(matches!(app.view_mode, ViewMode::Rendered));
 3155|       |    }
 3156|       |
 3157|       |    #[test]
 3158|       |    fn test_load_content() {
 3159|       |        let mut app = MarkdownViewerApp::new();
 3160|       |        let content = "# Test Header\n\nThis is test content.";
 3161|       |
 3162|       |        app.load_content(content, Some("Test".to_string()));
 3163|       |
 3164|       |        assert_eq!(app.current_content, content);
 3165|       |        assert_eq!(app.raw_buffer, content);
 3166|       |        assert!(app.title.contains("Test"));
 3167|       |        assert!(!app.parsed_elements.is_empty());
 3168|       |        assert!(app.error_message.is_none());
 3169|       |    }
 3170|       |
 3171|       |    #[test]
 3172|       |    fn test_toggle_view_mode() {
 3173|       |        let mut app = MarkdownViewerApp::new();
 3174|       |        let ctx = egui::Context::default();
 3175|       |        assert!(matches!(app.view_mode, ViewMode::Rendered));
 3176|       |        app.toggle_view_mode(&ctx);
 3177|       |        assert!(matches!(app.view_mode, ViewMode::Raw));
 3178|       |        app.toggle_view_mode(&ctx);
 3179|       |        assert!(matches!(app.view_mode, ViewMode::Rendered));
 3180|       |    }
 3181|       |
 3182|       |    #[test]
 3183|       |    fn test_toggle_view_mode_without_text_state() {
 3184|       |        let mut app = MarkdownViewerApp::new();
 3185|       |        app.view_mode = ViewMode::Raw;
 3186|       |        app.write_enabled = true;
 3187|       |        let ctx = egui::Context::default();
 3188|       |        app.toggle_view_mode(&ctx);
 3189|       |        assert!(matches!(app.view_mode, ViewMode::Rendered));
 3190|       |        assert!(app.raw_cursor.is_none());
 3191|       |    }
 3192|       |
 3193|       |    #[test]
 3194|       |    fn test_toggle_view_mode_with_state_without_cursor_range() {
 3195|       |        let mut app = MarkdownViewerApp::new();
 3196|       |        app.view_mode = ViewMode::Raw;
 3197|       |        app.write_enabled = true;
 3198|       |        let ctx = egui::Context::default();
 3199|       |        let editor_id = egui::Id::new("raw_editor");
 3200|       |        let mut state = egui::text_edit::TextEditState::default();
 3201|       |        state.cursor.set_char_range(None);
 3202|       |        state.store(&ctx, editor_id);
 3203|       |
 3204|       |        app.toggle_view_mode(&ctx);
 3205|       |
 3206|       |        assert!(matches!(app.view_mode, ViewMode::Rendered));
 3207|       |        assert!(app.raw_cursor.is_none());
 3208|       |    }
 3209|       |
 3210|       |    #[test]
 3211|       |    fn test_load_sample() {
 3212|       |        let mut app = MarkdownViewerApp::new();
 3213|       |        let sample = &SAMPLE_FILES[0]; // First sample file
 3214|       |
 3215|       |        app.load_sample(sample);
 3216|       |
 3217|       |        assert_eq!(app.current_content, sample.content);
 3218|       |        assert!(app.title.contains(sample.title));
 3219|       |        assert!(!app.parsed_elements.is_empty());
 3220|       |        assert!(app.current_file.is_none()); // Sample files don't set file path
 3221|       |    }
 3222|       |
 3223|       |    #[test]
 3224|       |    fn test_load_sample_by_name_reports_missing() {
 3225|       |        let mut app = MarkdownViewerApp::new();
 3226|       |        app.current_content = "keep".to_string();
 3227|       |
 3228|       |        let loaded = app.load_sample_by_name(&[], "missing.md");
 3229|       |
 3230|       |        assert!(!loaded);
 3231|       |        assert_eq!(app.current_content, "keep");
 3232|       |    }
 3233|       |
 3234|       |    #[test]
 3235|       |    fn test_load_sample_by_name_loads_content() {
 3236|       |        let mut app = MarkdownViewerApp::new();
 3237|       |        let sample = SAMPLE_FILES
 3238|       |            .iter()
 3239|       |            .find(|sample| sample.name == "welcome.md")
 3240|       |            .expect("welcome sample");
 3241|       |
 3242|       |        let loaded = app.load_sample_by_name(SAMPLE_FILES, "welcome.md");
 3243|       |
 3244|       |        assert!(loaded);
 3245|       |        assert_eq!(app.current_content, sample.content);
 3246|       |        assert_eq!(app.pending_scroll_to_element, Some(0));
 3247|       |    }
 3248|       |
 3249|       |    #[test]
 3250|       |    fn test_load_welcome_from_samples_missing_clears_state() {
 3251|       |        let mut app = MarkdownViewerApp::new();
 3252|       |        app.current_content = "content".to_string();
 3253|       |        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 3254|       |            "content".to_string(),
 3255|       |        )])];
 3256|       |        app.title = "Custom".to_string();
 3257|       |        app.error_message = Some("error".to_string());
 3258|       |
 3259|       |        app.load_welcome_from_samples(&[], false);
 3260|       |
 3261|       |        assert!(app.current_content.is_empty());
 3262|       |        assert!(app.parsed_elements.is_empty());
 3263|       |        assert_eq!(app.title, APP_TITLE_PREFIX);
 3264|       |        assert!(app.error_message.is_none());
 3265|       |    }
 3266|       |
 3267|       |    #[test]
 3268|       |    fn test_load_welcome_from_samples_sets_scroll_when_requested() {
 3269|       |        let mut app = MarkdownViewerApp::new();
 3270|       |        app.pending_scroll_to_element = None;
 3271|       |
 3272|       |        app.load_welcome_from_samples(SAMPLE_FILES, true);
 3273|       |
 3274|       |        assert_eq!(app.pending_scroll_to_element, Some(0));
 3275|       |    }
 3276|       |
 3277|       |    #[test]
 3278|       |    fn test_spawn_file_loader_handles_error_path() {
 3279|       |        MarkdownViewerApp::force_thread_spawn_error_for_test();
 3280|       |        let _ = MarkdownViewerApp::spawn_file_loader();
 3281|       |    }
 3282|       |
 3283|       |    #[test]
 3284|       |    fn test_spawn_file_loader_processes_request() -> Result<()> {
 3285|       |        let temp = NamedTempFile::new()?;
 3286|       |        writeln!(&temp, "hello")?;
 3287|       |
 3288|       |        let (request_tx, result_rx) = MarkdownViewerApp::spawn_file_loader();
 3289|       |        request_tx
 3290|       |            .send(FileLoadRequest {
 3291|       |                id: 99,
 3292|       |                path: temp.path().to_path_buf(),
 3293|       |            })
 3294|       |            .expect("send");
 3295|       |        let result = result_rx
 3296|       |            .recv_timeout(std::time::Duration::from_secs(1))
 3297|       |            .expect("result");
 3298|       |        let (content, lossy) = result.content.expect("content");
 3299|       |        assert!(content.contains("hello"));
 3300|       |        assert!(!lossy);
 3301|       |        drop(request_tx);
 3302|       |        Ok(())
 3303|       |    }
 3304|       |
 3305|       |    #[test]
 3306|       |    fn test_spawn_file_loader_reports_missing_file() {
 3307|       |        let temp_dir = TempDir::new().expect("temp dir");
 3308|       |        let missing_path = temp_dir.path().join("missing.md");
 3309|       |
 3310|       |        let (request_tx, result_rx) = MarkdownViewerApp::spawn_file_loader();
 3311|       |        request_tx
 3312|       |            .send(FileLoadRequest {
 3313|       |                id: 101,
 3314|       |                path: missing_path,
 3315|       |            })
 3316|       |            .expect("send");
 3317|       |        let result = result_rx
 3318|       |            .recv_timeout(std::time::Duration::from_secs(1))
 3319|       |            .expect("result");
 3320|       |        assert!(result.content.is_err());
 3321|       |        drop(request_tx);
 3322|       |    }
 3323|       |
 3324|       |    #[test]
 3325|       |    fn test_load_sample_without_existing_content_skips_history() {
 3326|       |        let mut app = MarkdownViewerApp::new();
 3327|       |        app.current_content.clear();
 3328|       |        app.raw_buffer.clear();
 3329|       |        app.history.clear();
 3330|       |        app.history_index = 0;
 3331|       |        let sample = &SAMPLE_FILES[0];
 3332|       |
 3333|       |        app.load_sample(sample);
 3334|       |
 3335|       |        assert!(app.history.is_empty());
 3336|       |    }
 3337|       |
 3338|       |    #[test]
 3339|       |    fn test_load_file() -> Result<()> {
 3340|       |        let mut app = MarkdownViewerApp::new();
 3341|       |
 3342|       |        // Create a temporary markdown file
 3343|       |        let mut temp_file = NamedTempFile::new()?;
 3344|       |        let content = "# Temporary File\n\nThis is a test markdown file.";
 3345|       |        temp_file.write_all(content.as_bytes())?;
 3346|       |        temp_file.flush()?;
 3347|       |
 3348|       |        let path = temp_file.path().to_path_buf();
 3349|       |        app.load_file(path.clone(), true)?;
 3350|       |
 3351|       |        assert_eq!(app.current_content, content);
 3352|       |        assert_eq!(app.current_file, Some(path));
 3353|       |        assert!(!app.parsed_elements.is_empty());
 3354|       |        assert!(app.error_message.is_none());
 3355|       |
 3356|       |        Ok(())
 3357|       |    }
 3358|       |
 3359|       |    #[test]
 3360|       |    fn test_load_file_async_sends_request() -> Result<()> {
 3361|       |        let mut app = MarkdownViewerApp::new();
 3362|       |        let mut temp_file = NamedTempFile::new()?;
 3363|       |        let payload = vec![b'a'; ASYNC_LOAD_THRESHOLD_BYTES as usize];
 3364|       |        temp_file.write_all(&payload)?;
 3365|       |        temp_file.flush()?;
 3366|       |
 3367|       |        let path = temp_file.path().to_path_buf();
 3368|       |        app.load_file(path.clone(), false)?;
 3369|       |        assert!(app.pending_file_load.is_some());
 3370|       |        assert_eq!(app.pending_file_load.as_ref().expect("pending").path, path);
 3371|       |        Ok(())
 3372|       |    }
 3373|       |
 3374|       |    #[test]
 3375|       |    fn test_load_file_skips_async_when_screenshot_active() -> Result<()> {
 3376|       |        let mut app = MarkdownViewerApp::new();
 3377|       |        let mut temp_file = NamedTempFile::new()?;
 3378|       |        let payload = vec![b'a'; ASYNC_LOAD_THRESHOLD_BYTES as usize];
 3379|       |        temp_file.write_all(&payload)?;
 3380|       |        temp_file.flush()?;
 3381|       |
 3382|       |        let config = ScreenshotConfig {
 3383|       |            output_path: temp_file.path().with_extension("png"),
 3384|       |            viewport_width: 120.0,
 3385|       |            viewport_height: 80.0,
 3386|       |            content_only: false,
 3387|       |            scroll_ratio: None,
 3388|       |            wait_ms: 0,
 3389|       |            settle_frames: 0,
 3390|       |            zoom: 1.0,
 3391|       |            theme: ScreenshotTheme::Light,
 3392|       |            font_source: None,
 3393|       |        };
 3394|       |        app.screenshot = Some(ScreenshotState::new(config));
 3395|       |
 3396|       |        let path = temp_file.path().to_path_buf();
 3397|       |        app.load_file(path.clone(), false)?;
 3398|       |
 3399|       |        assert!(app.pending_file_load.is_none());
 3400|       |        assert_eq!(app.current_file, Some(path));
 3401|       |        Ok(())
 3402|       |    }
 3403|       |
 3404|       |    #[test]
 3405|       |    fn test_load_file_async_falls_back_when_channel_closed() -> Result<()> {
 3406|       |        let mut app = MarkdownViewerApp::new();
 3407|       |        let (tx, rx) = unbounded::<FileLoadRequest>();
 3408|       |        drop(rx);
 3409|       |        app.file_load_tx = tx;
 3410|       |
 3411|       |        let mut temp_file = NamedTempFile::new()?;
 3412|       |        let payload = vec![b'a'; ASYNC_LOAD_THRESHOLD_BYTES as usize];
 3413|       |        temp_file.write_all(&payload)?;
 3414|       |        temp_file.flush()?;
 3415|       |
 3416|       |        let path = temp_file.path().to_path_buf();
 3417|       |        app.load_file(path.clone(), false)?;
 3418|       |        assert_eq!(app.current_file, Some(path));
 3419|       |        assert!(app.pending_file_load.is_none());
 3420|       |        Ok(())
 3421|       |    }
 3422|       |
 3423|       |    #[test]
 3424|       |    fn test_poll_file_loads_handles_mismatch_and_lossy() {
 3425|       |        let mut app = MarkdownViewerApp::new();
 3426|       |        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
 3427|       |        app.file_load_rx = result_rx;
 3428|       |
 3429|       |        let temp = NamedTempFile::new().expect("temp");
 3430|       |        let path = temp.path().to_path_buf();
 3431|       |        app.pending_file_load = Some(PendingFileLoad {
 3432|       |            id: 1,
 3433|       |            path: path.clone(),
 3434|       |        });
 3435|       |
 3436|       |        result_tx
 3437|       |            .send(FileLoadResult {
 3438|       |                id: 2,
 3439|       |                content: Ok(("ignored".to_string(), false)),
 3440|       |            })
 3441|       |            .expect("send mismatch");
 3442|       |        app.poll_file_loads();
 3443|       |        assert!(app.pending_file_load.is_some());
 3444|       |
 3445|       |        result_tx
 3446|       |            .send(FileLoadResult {
 3447|       |                id: 1,
 3448|       |                content: Ok(("loaded".to_string(), true)),
 3449|       |            })
 3450|       |            .expect("send match");
 3451|       |        app.poll_file_loads();
 3452|       |        assert!(app.pending_file_load.is_none());
 3453|       |        assert_eq!(app.current_file, Some(path));
 3454|       |    }
 3455|       |
 3456|       |    #[test]
 3457|       |    fn test_poll_file_loads_handles_match_non_lossy() {
 3458|       |        let mut app = MarkdownViewerApp::new();
 3459|       |        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
 3460|       |        app.file_load_rx = result_rx;
 3461|       |
 3462|       |        let temp = NamedTempFile::new().expect("temp");
 3463|       |        let path = temp.path().to_path_buf();
 3464|       |        app.pending_file_load = Some(PendingFileLoad {
 3465|       |            id: 1,
 3466|       |            path: path.clone(),
 3467|       |        });
 3468|       |
 3469|       |        result_tx
 3470|       |            .send(FileLoadResult {
 3471|       |                id: 1,
 3472|       |                content: Ok(("loaded".to_string(), false)),
 3473|       |            })
 3474|       |            .expect("send match");
 3475|       |        app.poll_file_loads();
 3476|       |        assert!(app.pending_file_load.is_none());
 3477|       |        assert_eq!(app.current_file, Some(path));
 3478|       |    }
 3479|       |
 3480|       |    #[test]
 3481|       |    fn test_poll_file_loads_sets_error_on_failure() {
 3482|       |        let mut app = MarkdownViewerApp::new();
 3483|       |        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
 3484|       |        app.file_load_rx = result_rx;
 3485|       |
 3486|       |        let temp = NamedTempFile::new().expect("temp");
 3487|       |        let path = temp.path().to_path_buf();
 3488|       |        app.pending_file_load = Some(PendingFileLoad { id: 1, path });
 3489|       |
 3490|       |        result_tx
 3491|       |            .send(FileLoadResult {
 3492|       |                id: 1,
 3493|       |                content: Err("boom".to_string()),
 3494|       |            })
 3495|       |            .expect("send match");
 3496|       |        app.poll_file_loads();
 3497|       |        assert!(app.pending_file_load.is_none());
 3498|       |        assert!(app.error_message.as_deref().unwrap_or("").contains("boom"));
 3499|       |    }
 3500|       |
 3501|       |    #[test]
 3502|       |    fn test_load_invalid_markdown() {
 3503|       |        let mut app = MarkdownViewerApp::new();
 3504|       |        // Even "invalid" markdown should parse successfully with pulldown-cmark
 3505|       |        // as it's very permissive
 3506|       |        let content = "This is just plain text with some <invalid> HTML tags";
 3507|       |
 3508|       |        app.load_content(content, Some("Invalid".to_string()));
 3509|       |
 3510|       |        // Should still work - pulldown-cmark is very permissive
 3511|       |        assert_eq!(app.current_content, content);
 3512|       |        assert!(app.error_message.is_none());
 3513|       |    }
 3514|       |
 3515|       |    #[test]
 3516|       |    fn test_load_content_parse_error_sets_message() {
 3517|       |        let mut app = MarkdownViewerApp::new();
 3518|       |        crate::markdown_renderer::force_parse_error_once();
 3519|       |
 3520|       |        app.load_content("# Bad Parse", Some("Bad".to_string()));
 3521|       |
 3522|       |        assert!(app
 3523|       |            .error_message
 3524|       |            .as_ref()
 3525|       |            .is_some_and(|msg| msg.contains("Failed to parse markdown")));
 3526|       |        assert!(app.parsed_elements.is_empty());
 3527|       |    }
 3528|       |
 3529|       |    #[test]
 3530|       |    fn test_load_empty_content() {
 3531|       |        let mut app = MarkdownViewerApp::new();
 3532|       |        app.load_content("", Some("Empty".to_string()));
 3533|       |
 3534|       |        assert_eq!(app.current_content, "");
 3535|       |        assert!(app.title.contains("Empty"));
 3536|       |        assert!(app.error_message.is_none());
 3537|       |    }
 3538|       |
 3539|       |    #[test]
 3540|       |    fn test_load_nonexistent_file() {
 3541|       |        let mut app = MarkdownViewerApp::new();
 3542|       |        let fake_path = PathBuf::from("/nonexistent/file.md");
 3543|       |
 3544|       |        let result = app.load_file(fake_path, true);
 3545|       |        assert!(result.is_err());
 3546|       |    }
 3547|       |
 3548|       |    #[test]
 3549|       |    fn test_reload_current_file() -> Result<()> {
 3550|       |        let mut app = MarkdownViewerApp::new();
 3551|       |
 3552|       |        // Create a temporary markdown file
 3553|       |        let mut temp_file = NamedTempFile::new()?;
 3554|       |        let content1 = "# Title\n\nVersion 1";
 3555|       |        temp_file.write_all(content1.as_bytes())?;
 3556|       |        temp_file.flush()?;
 3557|       |
 3558|       |        let path = temp_file.path().to_path_buf();
 3559|       |        app.load_file(path.clone(), true)?;
 3560|       |        assert!(app.current_content.contains("Version 1"));
 3561|       |
 3562|       |        // Update file content
 3563|       |        let content2 = "# Title\n\nVersion 2";
 3564|       |        temp_file.as_file_mut().set_len(0)?; // clear
 3565|       |        temp_file.write_all(content2.as_bytes())?;
 3566|       |        temp_file.flush()?;
 3567|       |
 3568|       |        // Reload and verify
 3569|       |        app.reload_current_file()?;
 3570|       |        assert!(app.current_content.contains("Version 2"));
 3571|       |        Ok(())
 3572|       |    }
 3573|       |
 3574|       |    #[test]
 3575|       |    fn test_load_file_with_invalid_utf8() -> Result<()> {
 3576|       |        let mut app = MarkdownViewerApp::new();
 3577|       |        let mut temp_file = NamedTempFile::new()?;
 3578|       |        let bytes = b"Hello\xFFWorld";
 3579|       |        temp_file.write_all(bytes)?;
 3580|       |        temp_file.flush()?;
 3581|       |
 3582|       |        app.load_file(temp_file.path().to_path_buf(), true)?;
 3583|       |
 3584|       |        assert!(app.current_content.contains('\u{FFFD}'));
 3585|       |        assert!(!app.parsed_elements.is_empty());
 3586|       |        assert!(app.error_message.is_none());
 3587|       |        Ok(())
 3588|       |    }
 3589|       |
 3590|       |    #[test]
 3591|       |    fn test_read_file_lossy_invalid_utf8_returns_lossy() -> Result<()> {
 3592|       |        let temp_file = NamedTempFile::new()?;
 3593|       |        std::fs::write(temp_file.path(), b"Hello\xFFWorld")?;
 3594|       |
 3595|       |        let (content, lossy) = MarkdownViewerApp::read_file_lossy(temp_file.path())?;
 3596|       |        assert!(lossy);
 3597|       |        assert!(content.contains("Hello"));
 3598|       |        assert!(content.contains("World"));
 3599|       |        Ok(())
 3600|       |    }
 3601|       |
 3602|       |    #[test]
 3603|       |    fn test_read_file_lossy_forced_read_error() -> Result<()> {
 3604|       |        let temp_file = NamedTempFile::new()?;
 3605|       |        std::fs::write(temp_file.path(), b"Hello\xFFWorld")?;
 3606|       |
 3607|       |        let _guard = ForcedLossyReadError::new();
 3608|       |        assert!(MarkdownViewerApp::read_file_lossy(temp_file.path()).is_err());
 3609|       |        Ok(())
 3610|       |    }
 3611|       |
 3612|       |    #[test]
 3613|       |    fn test_reload_without_file() {
 3614|       |        let mut app = MarkdownViewerApp::new();
 3615|       |        assert!(app.current_file.is_none());
 3616|       |        let result = app.reload_current_file();
 3617|       |        assert!(result.is_err());
 3618|       |    }
 3619|       |
 3620|       |    #[test]
 3621|       |    fn test_window_state_change_detection() {
 3622|       |        let mut app = MarkdownViewerApp::new();
 3623|       |        app.last_window_pos = Some([10.0, 10.0]);
 3624|       |        app.last_window_size = Some([800.0, 600.0]);
 3625|       |        app.last_window_maximized = false;
 3626|       |
 3627|       |        let state = app.current_window_state().expect("state");
 3628|       |        assert!(app.window_state_changed(&state));
 3629|       |        app.last_persisted_state = Some(state);
 3630|       |        assert!(!app.window_state_changed(&state));
 3631|       |
 3632|       |        let mut moved = state;
 3633|       |        moved.pos = [12.0, 10.0];
 3634|       |        assert!(app.window_state_changed(&moved));
 3635|       |
 3636|       |        let mut resized = state;
 3637|       |        resized.size = [820.0, 610.0];
 3638|       |        assert!(app.window_state_changed(&resized));
 3639|       |
 3640|       |        let mut maximized = state;
 3641|       |        maximized.maximized = true;
 3642|       |        assert!(app.window_state_changed(&maximized));
 3643|       |    }
 3644|       |
 3645|       |    #[test]
 3646|       |    fn test_current_window_state_requires_size() {
 3647|       |        let mut app = MarkdownViewerApp::new();
 3648|       |        app.last_window_pos = Some([10.0, 10.0]);
 3649|       |        app.last_window_size = None;
 3650|       |        assert!(app.current_window_state().is_none());
 3651|       |    }
 3652|       |
 3653|       |    #[test]
 3654|       |    fn test_fold_for_search_handles_case_and_accents() {
 3655|       |        assert_eq!(
 3656|       |            MarkdownViewerApp::fold_for_search("\u{00C4}\u{00DF}"),
 3657|       |            MarkdownViewerApp::fold_for_search("\u{00E4}SS")
 3658|       |        );
 3659|       |        assert_eq!(
 3660|       |            MarkdownViewerApp::fold_for_search("To\u{0301}m"),
 3661|       |            MarkdownViewerApp::fold_for_search("T\u{00D3}m")
 3662|       |        );
 3663|       |    }
 3664|       |
 3665|       |    #[test]
 3666|       |    fn test_title_updates() {
 3667|       |        let mut app = MarkdownViewerApp::new();
 3668|       |
 3669|       |        // Test with custom title
 3670|       |        app.load_content("# Test", Some("Custom Title".to_string()));
 3671|       |        assert!(app.title.contains("Custom Title"));
 3672|       |
 3673|       |        // Test with no title (should keep existing)
 3674|       |        let old_title = app.title.clone();
 3675|       |        app.load_content("# Another Test", None);
 3676|       |        assert_eq!(app.title, old_title); // Should remain unchanged
 3677|       |    }
 3678|       |
 3679|       |    #[test]
 3680|       |    fn test_complex_markdown_loading() {
 3681|       |        let mut app = MarkdownViewerApp::new();
 3682|       |        let complex_content = r#"# Complex Document
 3683|       |
 3684|       |## With Multiple Sections
 3685|       |
 3686|       |This has **bold** and *italic* text.
 3687|       |
 3688|       |```rust
 3689|       |fn main() {
 3690|       |    println!("Hello, world!");
 3691|       |}
 3692|       |```
 3693|       |
 3694|       |- List item 1
 3695|       |- List item 2
 3696|       |
 3697|       |> A blockquote
 3698|       |
 3699|       |[A link](https://example.com)
 3700|       |
 3701|       |---
 3702|       |
 3703|       |The end.
 3704|       |"#;
 3705|       |
 3706|       |        app.load_content(complex_content, Some("Complex".to_string()));
 3707|       |
 3708|       |        assert_eq!(app.current_content, complex_content);
 3709|       |        assert!(app.title.contains("Complex"));
 3710|       |        assert!(!app.parsed_elements.is_empty());
 3711|       |        assert!(app.error_message.is_none());
 3712|       |
 3713|       |        // Should have parsed various element types
 3714|       |        assert!(app.parsed_elements.len() > 5); // Complex document should have many elements
 3715|       |    }
 3716|       |
 3717|       |    #[test]
 3718|       |    fn test_error_handling() {
 3719|       |        let app = MarkdownViewerApp::new();
 3720|       |
 3721|       |        // Test that app starts without errors
 3722|       |        assert!(app.error_message.is_none());
 3723|       |
 3724|       |        // Even with the welcome content loaded, should be error-free
 3725|       |        assert!(!app.parsed_elements.is_empty());
 3726|       |    }
 3727|       |
 3728|       |    #[test]
 3729|       |    fn test_default_state() {
 3730|       |        let app = MarkdownViewerApp::default();
 3731|       |
 3732|       |        // Default should be same as new()
 3733|       |        assert!(!app.parsed_elements.is_empty());
 3734|       |        assert!(app.title.contains(APP_TITLE_PREFIX));
 3735|       |        assert!(app.error_message.is_none());
 3736|       |        assert!(app.current_file.is_none());
 3737|       |    }
 3738|       |
 3739|       |    #[test]
 3740|       |    fn test_sample_files_integration() {
 3741|       |        let mut app = MarkdownViewerApp::new();
 3742|       |
 3743|       |        // Test loading each sample file
 3744|       |        for sample in SAMPLE_FILES {
 3745|       |            app.load_sample(sample);
 3746|       |
 3747|       |            assert_eq!(app.current_content, sample.content);
 3748|       |            assert!(app.title.contains(sample.title));
 3749|       |            assert!(app.current_file.is_none());
 3750|       |            assert!(app.error_message.is_none());
 3751|       |        }
 3752|       |    }
 3753|       |
 3754|       |    #[test]
 3755|       |    fn test_close_current_file() {
 3756|       |        let mut app = MarkdownViewerApp::new();
 3757|       |
 3758|       |        // Load some content first
 3759|       |        app.load_content("# Test Content", Some("Test File".to_string()));
 3760|       |        assert!(app.title.contains("Test File"));
 3761|       |
 3762|       |        // Close the file
 3763|       |        app.close_current_file();
 3764|       |
 3765|       |        // Should return to welcome screen
 3766|       |        assert!(app.title.contains("Welcome"));
 3767|       |        assert!(app.current_file.is_none());
 3768|       |        assert!(!app.parsed_elements.is_empty()); // Should have welcome content
 3769|       |        assert!(app.error_message.is_none());
 3770|       |    }
 3771|       |
 3772|       |    #[test]
 3773|       |    fn test_navigation_request_enum() {
 3774|       |        // Test that the enum values exist and are correct
 3775|       |        let _top = NavigationRequest::Top;
 3776|       |        let _bottom = NavigationRequest::Bottom;
 3777|       |        let _page_up = NavigationRequest::PageUp;
 3778|       |        let _page_down = NavigationRequest::PageDown;
 3779|       |        let _scroll_up = NavigationRequest::ScrollUp;
 3780|       |        let _scroll_down = NavigationRequest::ScrollDown;
 3781|       |
 3782|       |        // Ensure it's cloneable and debuggable
 3783|       |        let nav = NavigationRequest::Top;
 3784|       |        let _cloned = nav.clone();
 3785|       |        let _debug = format!("{:?}", nav);
 3786|       |
 3787|       |        // Basic compilation test performed by using the enum and Debug/Clone
 3788|       |    }
 3789|       |
 3790|       |    #[test]
 3791|       |    fn test_navigation_state_initialization() {
 3792|       |        let app = MarkdownViewerApp::new();
 3793|       |        // Test that nav_request is initialized to None
 3794|       |        assert!(app.nav_request.is_none());
 3795|       |        // Test that fullscreen toggle flag is initialized to false
 3796|       |        assert!(!app.toggle_fullscreen);
 3797|       |    }
 3798|       |
 3799|       |    #[test]
 3800|       |    fn test_fullscreen_toggle_flag() {
 3801|       |        let mut app = MarkdownViewerApp::new();
 3802|       |
 3803|       |        // Initially should be false
 3804|       |        assert!(!app.toggle_fullscreen);
 3805|       |
 3806|       |        // Simulate F11 key press (this would be set in handle_shortcuts)
 3807|       |        app.toggle_fullscreen = true;
 3808|       |        assert!(app.toggle_fullscreen);
 3809|       |
 3810|       |        // After handling, it should be reset to false
 3811|       |        app.toggle_fullscreen = false;
 3812|       |        assert!(!app.toggle_fullscreen);
 3813|       |    }
 3814|       |
 3815|       |    #[test]
 3816|       |    fn test_navigation_state_reset_on_load() {
 3817|       |        let mut app = MarkdownViewerApp::new();
 3818|       |
 3819|       |        // Set a navigation request
 3820|       |        app.nav_request = Some(NavigationRequest::Top);
 3821|       |        assert!(app.nav_request.is_some());
 3822|       |
 3823|       |        // Load content should reset navigation state
 3824|       |        app.load_content("# Test Content", Some("Test".to_string()));
 3825|       |        assert!(app.nav_request.is_none());
 3826|       |    }
 3827|       |
 3828|       |    #[test]
 3829|       |    fn test_page_navigation_calculations() {
 3830|       |        // Test the page size calculation logic used in navigation
 3831|       |        let viewport_height = 800.0f32;
 3832|       |        let page_size = viewport_height * 0.8;
 3833|       |        assert_eq!(page_size, 640.0);
 3834|       |
 3835|       |        // Test boundary conditions for Page Up
 3836|       |        let current_offset = 100.0f32;
 3837|       |        let new_offset_up = (current_offset - page_size).max(0.0);
 3838|       |        assert_eq!(new_offset_up, 0.0); // Should clamp to 0
 3839|       |
 3840|       |        // Test Page Down calculation
 3841|       |        let new_offset_down = current_offset + page_size;
 3842|       |        assert_eq!(new_offset_down, 740.0);
 3843|       |
 3844|       |        // Test that Page Up from near top goes to 0
 3845|       |        let near_top = 300.0f32;
 3846|       |        let from_near_top = (near_top - page_size).max(0.0);
 3847|       |        assert_eq!(from_near_top, 0.0);
 3848|       |    }
 3849|       |
 3850|       |    #[test]
 3851|       |    fn test_compute_window_adjustment_clamps_offscreen_window() {
 3852|       |        let outer = egui::Rect::from_min_size(egui::pos2(1200.0, 900.0), egui::vec2(800.0, 600.0));
 3853|       |        let monitor = egui::vec2(1024.0, 768.0);
 3854|       |        let adjustment =
 3855|       |            MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), Some(monitor))
 3856|       |                .expect("should adjust window geometry");
 3857|       |        let pos = adjustment.pos.expect("expected position adjustment");
 3858|       |        let size = adjustment.size.unwrap_or_else(|| outer.size());
 3859|       |        assert!(pos.x <= monitor.x - size.x + 1.0);
 3860|       |        assert!(pos.y <= monitor.y - size.y + 1.0);
 3861|       |        assert!(adjustment.size.is_none());
 3862|       |    }
 3863|       |
 3864|       |    #[test]
 3865|       |    fn test_compute_window_adjustment_respects_min_size() {
 3866|       |        let outer = egui::Rect::from_min_size(egui::pos2(-200.0, -100.0), egui::vec2(200.0, 100.0));
 3867|       |        let monitor = egui::vec2(1920.0, 1080.0);
 3868|       |        let adjustment =
 3869|       |            MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), Some(monitor))
 3870|       |                .expect("should enforce minimum window size");
 3871|       |        let pos = adjustment.pos.unwrap_or(outer.min);
 3872|       |        let size = adjustment.size.expect("expected size adjustment");
 3873|       |        assert!(size.x >= 600.0);
 3874|       |        assert!(size.y >= 400.0);
 3875|       |        assert!(pos.x >= 0.0);
 3876|       |        assert!(pos.y >= 0.0);
 3877|       |    }
 3878|       |
 3879|       |    #[test]
 3880|       |    fn test_is_valid_markdown_file() {
 3881|       |        let app = MarkdownViewerApp::new();
 3882|       |
 3883|       |        // Valid markdown extensions
 3884|       |        assert!(app.is_valid_markdown_file(Path::new("test.md")));
 3885|       |        assert!(app.is_valid_markdown_file(Path::new("test.markdown")));
 3886|       |        assert!(app.is_valid_markdown_file(Path::new("test.mdown")));
 3887|       |        assert!(app.is_valid_markdown_file(Path::new("test.mkd")));
 3888|       |        assert!(app.is_valid_markdown_file(Path::new("test.txt")));
 3889|       |
 3890|       |        // Case insensitive
 3891|       |        assert!(app.is_valid_markdown_file(Path::new("test.MD")));
 3892|       |        assert!(app.is_valid_markdown_file(Path::new("test.Markdown")));
 3893|       |
 3894|       |        // Invalid extensions
 3895|       |        assert!(!app.is_valid_markdown_file(Path::new("test.pdf")));
 3896|       |        assert!(!app.is_valid_markdown_file(Path::new("test.docx")));
 3897|       |        assert!(!app.is_valid_markdown_file(Path::new("test.html")));
 3898|       |
 3899|       |        // No extension
 3900|       |        assert!(!app.is_valid_markdown_file(Path::new("test")));
 3901|       |    }
 3902|       |
 3903|       |    #[test]
 3904|       |    fn test_scan_directory() -> Result<()> {
 3905|       |        let temp_dir = tempfile::TempDir::new()?;
 3906|       |        let dir_path = temp_dir.path();
 3907|       |
 3908|       |        // Create test files
 3909|       |        std::fs::write(dir_path.join("zebra.md"), "# Z")?;
 3910|       |        std::fs::write(dir_path.join("alpha.md"), "# A")?;
 3911|       |        std::fs::write(dir_path.join("image.png"), "fake")?;
 3912|       |        std::fs::write(dir_path.join("beta.markdown"), "# B")?;
 3913|       |
 3914|       |        // Create subdirectory (should be ignored)
 3915|       |        std::fs::create_dir(dir_path.join("subdir"))?;
 3916|       |        std::fs::write(dir_path.join("subdir/nested.md"), "# N")?;
 3917|       |
 3918|       |        let app = MarkdownViewerApp::new();
 3919|       |        let files = app.scan_directory(dir_path)?;
 3920|       |
 3921|       |        // Should find 3 markdown files (alpha, beta, zebra)
 3922|       |        // Should NOT find image.png or nested.md
 3923|       |        assert_eq!(files.len(), 3);
 3924|       |
 3925|       |        // Should be sorted alphabetically
 3926|       |        assert!(files[0].ends_with("alpha.md"));
 3927|       |        assert!(files[1].ends_with("beta.markdown"));
 3928|       |        assert!(files[2].ends_with("zebra.md"));
 3929|       |
 3930|       |        Ok(())
 3931|       |    }
 3932|       |
 3933|       |    #[test]
 3934|       |    fn test_scan_empty_directory() -> Result<()> {
 3935|       |        let temp_dir = tempfile::TempDir::new()?;
 3936|       |        let app = MarkdownViewerApp::new();
 3937|       |        let files = app.scan_directory(temp_dir.path())?;
 3938|       |
 3939|       |        assert_eq!(files.len(), 0);
 3940|       |        Ok(())
 3941|       |    }
 3942|       |
 3943|       |    #[test]
 3944|       |    fn test_scan_directory_missing_dir_returns_error() -> Result<()> {
 3945|       |        let temp_dir = tempfile::TempDir::new()?;
 3946|       |        let missing = temp_dir.path().join("missing");
 3947|       |        let app = MarkdownViewerApp::new();
 3948|       |        assert!(app.scan_directory(&missing).is_err());
 3949|       |        Ok(())
 3950|       |    }
 3951|       |
 3952|       |    #[test]
 3953|       |    fn test_scan_directory_entry_error() -> Result<()> {
 3954|       |        let temp_dir = tempfile::TempDir::new()?;
 3955|       |        std::fs::write(temp_dir.path().join("doc.md"), "# Doc")?;
 3956|       |        let _guard = ForcedScanEntryError::new();
 3957|       |        let app = MarkdownViewerApp::new();
 3958|       |        assert!(app.scan_directory(temp_dir.path()).is_err());
 3959|       |        Ok(())
 3960|       |    }
 3961|       |
 3962|       |    #[test]
 3963|       |    fn test_resolve_scan_entry_propagates_error() {
 3964|       |        let err = std::io::Error::new(std::io::ErrorKind::Other, "forced entry error");
 3965|       |        let result = MarkdownViewerApp::resolve_scan_entry(Err(err));
 3966|       |        assert!(result.is_err());
 3967|       |    }
 3968|       |
 3969|       |    #[test]
 3970|       |    fn test_single_file_drop() -> Result<()> {
 3971|       |        let mut app = MarkdownViewerApp::new();
 3972|       |        let temp_dir = tempfile::TempDir::new()?;
 3973|       |        let file = temp_dir.path().join("test.md");
 3974|       |        std::fs::write(&file, "# Test")?;
 3975|       |
 3976|       |        app.handle_file_drop(vec![file.clone()]);
 3977|       |
 3978|       |        assert_eq!(app.current_file, Some(file));
 3979|       |        assert!(app.pending_files.is_empty());
 3980|       |        assert!(app.error_message.is_none());
 3981|       |        Ok(())
 3982|       |    }
 3983|       |
 3984|       |    #[test]
 3985|       |    fn test_multiple_files_drop() -> Result<()> {
 3986|       |        let mut app = MarkdownViewerApp::new();
 3987|       |        let temp_dir = tempfile::TempDir::new()?;
 3988|       |
 3989|       |        let files: Vec<PathBuf> = (0..5)
 3990|       |            .map(|i| {
 3991|       |                let path = temp_dir.path().join(format!("file{}.md", i));
 3992|       |                std::fs::write(&path, format!("# File {}", i)).unwrap();
 3993|       |                path
 3994|       |            })
 3995|       |            .collect();
 3996|       |
 3997|       |        app.handle_file_drop(files.clone());
 3998|       |
 3999|       |        assert_eq!(app.current_file, Some(files[0].clone()));
 4000|       |        assert_eq!(app.pending_files.len(), 4);
 4001|       |        Ok(())
 4002|       |    }
 4003|       |
 4004|       |    #[test]
 4005|       |    fn test_directory_drop() -> Result<()> {
 4006|       |        let mut app = MarkdownViewerApp::new();
 4007|       |        let temp_dir = tempfile::TempDir::new()?;
 4008|       |
 4009|       |        // Create files in directory
 4010|       |        std::fs::write(temp_dir.path().join("a.md"), "# A")?;
 4011|       |        std::fs::write(temp_dir.path().join("b.md"), "# B")?;
 4012|       |        std::fs::write(temp_dir.path().join("c.md"), "# C")?;
 4013|       |
 4014|       |        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 4015|       |
 4016|       |        assert!(app.current_file.is_some());
 4017|       |        assert_eq!(app.pending_files.len(), 2);
 4018|       |        Ok(())
 4019|       |    }
 4020|       |
 4021|       |    #[test]
 4022|       |    fn test_invalid_file_drop() {
 4023|       |        let mut app = MarkdownViewerApp::new();
 4024|       |        let temp_dir = tempfile::TempDir::new().unwrap();
 4025|       |        let file = temp_dir.path().join("test.pdf");
 4026|       |        std::fs::write(&file, "fake pdf").unwrap();
 4027|       |
 4028|       |        app.handle_file_drop(vec![file]);
 4029|       |
 4030|       |        // Current file should remain None (or welcome sample)
 4031|       |        assert!(app.error_message.is_some());
 4032|       |        assert!(app
 4033|       |            .error_message
 4034|       |            .as_ref()
 4035|       |            .unwrap()
 4036|       |            .contains("Not a markdown file"));
 4037|       |    }
 4038|       |
 4039|       |    #[test]
 4040|       |    fn test_too_many_files() {
 4041|       |        let mut app = MarkdownViewerApp::new();
 4042|       |        let temp_dir = tempfile::TempDir::new().unwrap();
 4043|       |
 4044|       |        let files: Vec<PathBuf> = (0..60)
 4045|       |            .map(|i| {
 4046|       |                let path = temp_dir.path().join(format!("file{}.md", i));
 4047|       |                std::fs::write(&path, format!("# File {}", i)).unwrap();
 4048|       |                path
 4049|       |            })
 4050|       |            .collect();
 4051|       |
 4052|       |        app.handle_file_drop(files);
 4053|       |
 4054|       |        assert!(app.error_message.is_some());
 4055|       |        assert!(app
 4056|       |            .error_message
 4057|       |            .as_ref()
 4058|       |            .unwrap()
 4059|       |            .contains("Too many files"));
 4060|       |    }
 4061|       |
 4062|       |    #[test]
 4063|       |    fn test_queue_navigation() -> Result<()> {
 4064|       |        let mut app = MarkdownViewerApp::new();
 4065|       |        let temp_dir = tempfile::TempDir::new()?;
 4066|       |
 4067|       |        let file1 = temp_dir.path().join("file1.md");
 4068|       |        let file2 = temp_dir.path().join("file2.md");
 4069|       |
 4070|       |        std::fs::write(&file1, "# File 1")?;
 4071|       |        std::fs::write(&file2, "# File 2")?;
 4072|       |
 4073|       |        // Load first file and queue second
 4074|       |        app.load_file(file1.clone(), true)?;
 4075|       |        app.pending_files.push_back(file2.clone());
 4076|       |
 4077|       |        assert!(app.can_navigate_forward());
 4078|       |        app.navigate_forward();
 4079|       |        assert_eq!(app.current_file, Some(file2));
 4080|       |        assert!(app.pending_files.is_empty());
 4081|       |
 4082|       |        Ok(())
 4083|       |    }
 4084|       |
 4085|       |    #[test]
 4086|       |    fn test_mixed_valid_invalid_files() -> Result<()> {
 4087|       |        let mut app = MarkdownViewerApp::new();
 4088|       |        let temp_dir = tempfile::TempDir::new()?;
 4089|       |
 4090|       |        let md_file = temp_dir.path().join("test.md");
 4091|       |        let pdf_file = temp_dir.path().join("test.pdf");
 4092|       |
 4093|       |        std::fs::write(&md_file, "# Test")?;
 4094|       |        std::fs::write(&pdf_file, "fake pdf")?;
 4095|       |
 4096|       |        app.handle_file_drop(vec![md_file.clone(), pdf_file]);
 4097|       |
 4098|       |        // Should open the valid markdown file
 4099|       |        assert_eq!(app.current_file, Some(md_file));
 4100|       |        // Should show error about the invalid file
 4101|       |        assert!(app.error_message.is_some());
 4102|       |        Ok(())
 4103|       |    }
 4104|       |
 4105|       |    #[test]
 4106|       |    fn test_empty_directory_drop() -> Result<()> {
 4107|       |        let mut app = MarkdownViewerApp::new();
 4108|       |        let temp_dir = tempfile::TempDir::new()?;
 4109|       |
 4110|       |        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 4111|       |
 4112|       |        assert!(app.error_message.is_some());
 4113|       |        assert!(app
 4114|       |            .error_message
 4115|       |            .as_ref()
 4116|       |            .unwrap()
 4117|       |            .contains("No markdown files"));
 4118|       |        Ok(())
 4119|       |    }
 4120|       |
 4121|       |    #[test]
 4122|       |    fn test_toggle_write_mode_tracks_cursor_and_focus() {
 4123|       |        let mut app = MarkdownViewerApp::new();
 4124|       |        app.view_mode = ViewMode::Raw;
 4125|       |        app.write_enabled = false;
 4126|       |        app.raw_focus_requested = false;
 4127|       |
 4128|       |        let ctx = egui::Context::default();
 4129|       |        let editor_id = egui::Id::new("raw_editor");
 4130|       |        let mut state = egui::text_edit::TextEditState::default();
 4131|       |        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(3));
 4132|       |        state.cursor.set_char_range(Some(cr));
 4133|       |        state.store(&ctx, editor_id);
 4134|       |
 4135|       |        app.toggle_write_mode(&ctx);
 4136|       |        assert!(app.write_enabled);
 4137|       |        assert!(app.raw_focus_requested);
 4138|       |
 4139|       |        app.toggle_write_mode(&ctx);
 4140|       |        assert!(!app.write_enabled);
 4141|       |        assert_eq!(app.raw_cursor, Some(3));
 4142|       |    }
 4143|       |
 4144|       |    #[test]
 4145|       |    fn test_toggle_write_mode_rendered_does_not_request_focus() {
 4146|       |        let mut app = MarkdownViewerApp::new();
 4147|       |        app.view_mode = ViewMode::Rendered;
 4148|       |        app.write_enabled = false;
 4149|       |        app.raw_focus_requested = false;
 4150|       |
 4151|       |        let ctx = egui::Context::default();
 4152|       |        app.toggle_write_mode(&ctx);
 4153|       |
 4154|       |        assert!(app.write_enabled);
 4155|       |        assert!(!app.raw_focus_requested);
 4156|       |    }
 4157|       |
 4158|       |    #[test]
 4159|       |    fn test_find_next_and_previous_wraps() {
 4160|       |        let mut app = MarkdownViewerApp::new();
 4161|       |        app.load_content("Alpha\n\nBeta\n\nGamma", Some("Search".to_string()));
 4162|       |        app.search_query = "beta".to_string();
 4163|       |
 4164|       |        app.find_next();
 4165|       |        assert_eq!(app.last_match_index, Some(1));
 4166|       |        assert_eq!(app.pending_scroll_to_element, Some(1));
 4167|       |
 4168|       |        app.find_next();
 4169|       |        assert_eq!(app.last_match_index, Some(1));
 4170|       |
 4171|       |        app.find_previous();
 4172|       |        assert_eq!(app.last_match_index, Some(1));
 4173|       |    }
 4174|       |
 4175|       |    #[test]
 4176|       |    fn test_update_impl_rendered_view_runs() -> Result<()> {
 4177|       |        let mut app = MarkdownViewerApp::new();
 4178|       |        app.nav_request = Some(NavigationRequest::PageDown);
 4179|       |        app.toggle_fullscreen = true;
 4180|       |
 4181|       |        let mut temp_file = tempfile::Builder::new().suffix(".md").tempfile()?;
 4182|       |        temp_file.write_all(b"# Dropped\nContent")?;
 4183|       |        temp_file.flush()?;
 4184|       |
 4185|       |        let ctx = egui::Context::default();
 4186|       |        let mut input = default_input();
 4187|       |        let vp = input
 4188|       |            .viewports
 4189|       |            .get_mut(&egui::ViewportId::ROOT)
 4190|       |            .expect("root viewport");
 4191|       |        vp.monitor_size = Some(egui::vec2(1024.0, 768.0));
 4192|       |        vp.outer_rect = Some(egui::Rect::from_min_size(
 4193|       |            egui::pos2(1200.0, 900.0),
 4194|       |            egui::vec2(800.0, 600.0),
 4195|       |        ));
 4196|       |        vp.inner_rect = Some(egui::Rect::from_min_size(
 4197|       |            egui::pos2(0.0, 0.0),
 4198|       |            egui::vec2(800.0, 600.0),
 4199|       |        ));
 4200|       |        vp.fullscreen = Some(false);
 4201|       |        vp.maximized = Some(false);
 4202|       |        input.hovered_files.push(egui::HoveredFile {
 4203|       |            path: Some(temp_file.path().to_path_buf()),
 4204|       |            ..Default::default()
 4205|       |        });
 4206|       |        input.dropped_files.push(egui::DroppedFile {
 4207|       |            path: Some(temp_file.path().to_path_buf()),
 4208|       |            ..Default::default()
 4209|       |        });
 4210|       |
 4211|       |        run_app_frame(&mut app, &ctx, input);
 4212|       |
 4213|       |        assert!(app.drag_hover);
 4214|       |        assert!(app.current_file.is_some());
 4215|       |        assert!(app.last_window_pos.is_some());
 4216|       |        assert!(app.last_window_size.is_some());
 4217|       |        Ok(())
 4218|       |    }
 4219|       |
 4220|       |    #[test]
 4221|       |    fn test_update_impl_applies_size_adjustment() {
 4222|       |        let mut app = MarkdownViewerApp::new();
 4223|       |        let ctx = egui::Context::default();
 4224|       |        let mut input = default_input();
 4225|       |        let vp = input
 4226|       |            .viewports
 4227|       |            .get_mut(&egui::ViewportId::ROOT)
 4228|       |            .expect("root viewport");
 4229|       |        vp.monitor_size = Some(egui::vec2(800.0, 600.0));
 4230|       |        vp.outer_rect = Some(egui::Rect::from_min_size(
 4231|       |            egui::pos2(10.0, 10.0),
 4232|       |            egui::vec2(800.0, 600.0),
 4233|       |        ));
 4234|       |        vp.inner_rect = Some(egui::Rect::from_min_size(
 4235|       |            egui::pos2(0.0, 0.0),
 4236|       |            egui::vec2(200.0, 100.0),
 4237|       |        ));
 4238|       |        vp.fullscreen = Some(false);
 4239|       |        vp.maximized = Some(false);
 4240|       |
 4241|       |        run_app_frame(&mut app, &ctx, input);
 4242|       |
 4243|       |        assert!(app.last_window_size.is_some());
 4244|       |        assert!(app.last_window_pos.is_some());
 4245|       |    }
 4246|       |
 4247|       |    #[test]
 4248|       |    fn test_update_impl_applies_deferred_toggles() {
 4249|       |        let mut app = MarkdownViewerApp::new();
 4250|       |        app.view_toggle_requested = true;
 4251|       |        app.write_toggle_requested = true;
 4252|       |
 4253|       |        let ctx = egui::Context::default();
 4254|       |        run_app_frame(&mut app, &ctx, default_input());
 4255|       |
 4256|       |        assert_eq!(app.view_mode, ViewMode::Raw);
 4257|       |        assert!(app.write_enabled);
 4258|       |    }
 4259|       |
 4260|       |    #[test]
 4261|       |    fn test_update_impl_reload_without_file_sets_error() {
 4262|       |        let mut app = MarkdownViewerApp::new();
 4263|       |        app.reload_requested = true;
 4264|       |
 4265|       |        let ctx = egui::Context::default();
 4266|       |        let input = default_input();
 4267|       |        run_app_frame(&mut app, &ctx, input);
 4268|       |
 4269|       |        assert!(app.error_message.is_some());
 4270|       |    }
 4271|       |
 4272|       |    #[test]
 4273|       |    fn test_update_impl_raw_read_only_renders() {
 4274|       |        let mut app = MarkdownViewerApp::new();
 4275|       |        app.view_mode = ViewMode::Raw;
 4276|       |        app.write_enabled = false;
 4277|       |        app.raw_buffer = "Line 1\nLine 2".to_string();
 4278|       |        app.current_content = app.raw_buffer.clone();
 4279|       |
 4280|       |        let ctx = egui::Context::default();
 4281|       |        let input = default_input();
 4282|       |        run_app_frame(&mut app, &ctx, input);
 4283|       |
 4284|       |        assert_eq!(app.raw_buffer, "Line 1\nLine 2");
 4285|       |    }
 4286|       |
 4287|       |    #[test]
 4288|       |    fn test_update_impl_moves_raw_cursor() {
 4289|       |        let mut app = MarkdownViewerApp::new();
 4290|       |        app.view_mode = ViewMode::Raw;
 4291|       |        app.write_enabled = true;
 4292|       |        app.raw_buffer = "Line 1\nLine 2\nLine 3".to_string();
 4293|       |        app.current_content = app.raw_buffer.clone();
 4294|       |        app.pending_raw_cursor_line_move = Some(1);
 4295|       |
 4296|       |        let ctx = egui::Context::default();
 4297|       |        let editor_id = egui::Id::new("raw_editor");
 4298|       |        let mut state = egui::text_edit::TextEditState::default();
 4299|       |        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 4300|       |        state.cursor.set_char_range(Some(cr));
 4301|       |        state.store(&ctx, editor_id);
 4302|       |
 4303|       |        let input = default_input();
 4304|       |        run_app_frame(&mut app, &ctx, input);
 4305|       |
 4306|       |        assert!(app.raw_cursor.unwrap_or(0) > 0);
 4307|       |    }
 4308|       |
 4309|       |    #[test]
 4310|       |    fn test_json_helpers_escape_and_opt() {
 4311|       |        assert_eq!(
 4312|       |            MarkdownViewerApp::json_escape("a\"b\\c\n\t\r"),
 4313|       |            "a\\\"b\\\\c\\n\\t\\r"
 4314|       |        );
 4315|       |        assert_eq!(MarkdownViewerApp::json_opt_f32(Some(1.23456)), "1.235");
 4316|       |        assert_eq!(MarkdownViewerApp::json_opt_f32(None), "null");
 4317|       |    }
 4318|       |
 4319|       |    #[test]
 4320|       |    fn test_color_image_to_rgba_falls_back_on_invalid_buffer() {
 4321|       |        let image = egui::ColorImage {
 4322|       |            size: [1, 1],
 4323|       |            pixels: Vec::new(),
 4324|       |        };
 4325|       |        let rgba = MarkdownViewerApp::color_image_to_rgba(&image);
 4326|       |        assert_eq!(rgba.width(), 1);
 4327|       |        assert_eq!(rgba.height(), 1);
 4328|       |    }
 4329|       |
 4330|       |    #[test]
 4331|       |    fn test_save_screenshot_image_crops_and_writes_metadata() -> Result<()> {
 4332|       |        let temp_dir = tempfile::TempDir::new()?;
 4333|       |        let output_path = temp_dir.path().join("shot.png");
 4334|       |        let config = ScreenshotConfig {
 4335|       |            output_path: output_path.clone(),
 4336|       |            viewport_width: 80.0,
 4337|       |            viewport_height: 60.0,
 4338|       |            content_only: true,
 4339|       |            scroll_ratio: Some(0.5),
 4340|       |            wait_ms: 0,
 4341|       |            settle_frames: 0,
 4342|       |            zoom: 1.0,
 4343|       |            theme: ScreenshotTheme::Light,
 4344|       |            font_source: Some("TestFont".to_string()),
 4345|       |        };
 4346|       |        let snapshot = ScreenshotSnapshot {
 4347|       |            config,
 4348|       |            content_rect: Some(egui::Rect::from_min_size(
 4349|       |                egui::pos2(10.0, 5.0),
 4350|       |                egui::vec2(20.0, 10.0),
 4351|       |            )),
 4352|       |            pixels_per_point: 1.0,
 4353|       |            stable_frames: 3,
 4354|       |            timed_out: false,
 4355|       |            pending_renders: false,
 4356|       |            last_scroll_offset: Some(12.0),
 4357|       |            started: Instant::now(),
 4358|       |        };
 4359|       |
 4360|       |        let mut image = egui::ColorImage::new([80, 60], Color32::BLACK);
 4361|       |        image.pixels[0] = Color32::from_rgb(10, 20, 30);
 4362|       |
 4363|       |        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
 4364|       |
 4365|       |        let saved = image::open(&output_path)?;
 4366|       |        assert_eq!(saved.width(), 20);
 4367|       |        assert_eq!(saved.height(), 10);
 4368|       |
 4369|       |        let metadata = std::fs::read_to_string(output_path.with_extension("json"))?;
 4370|       |        assert!(metadata.contains("\"content_only\": true"));
 4371|       |        assert!(metadata.contains("\"font_source\": \"TestFont\""));
 4372|       |        Ok(())
 4373|       |    }
 4374|       |
 4375|       |    #[test]
 4376|       |    fn test_update_screenshot_state_requests_and_scrolls() {
 4377|       |        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 4378|       |        let config = ScreenshotConfig {
 4379|       |            output_path: temp_dir.path().join("shot.png"),
 4380|       |            viewport_width: 100.0,
 4381|       |            viewport_height: 80.0,
 4382|       |            content_only: false,
 4383|       |            scroll_ratio: Some(0.5),
 4384|       |            wait_ms: 0,
 4385|       |            settle_frames: 0,
 4386|       |            zoom: 1.0,
 4387|       |            theme: ScreenshotTheme::Dark,
 4388|       |            font_source: None,
 4389|       |        };
 4390|       |
 4391|       |        let mut app = MarkdownViewerApp::new();
 4392|       |        app.set_screenshot_mode(config);
 4393|       |
 4394|       |        let ctx = egui::Context::default();
 4395|       |        let snapshot = ScrollSnapshot {
 4396|       |            content_size: egui::vec2(100.0, 200.0),
 4397|       |            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(100.0, 100.0)),
 4398|       |            offset_y: 0.0,
 4399|       |        };
 4400|       |        app.update_screenshot_state(&ctx, Some(1), Some(snapshot));
 4401|       |
 4402|       |        let target_offset = app
 4403|       |            .screenshot
 4404|       |            .as_ref()
 4405|       |            .and_then(|state| state.scroll_offset)
 4406|       |            .unwrap_or(0.0);
 4407|       |        let snapshot_ready = ScrollSnapshot {
 4408|       |            content_size: egui::vec2(100.0, 200.0),
 4409|       |            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(100.0, 100.0)),
 4410|       |            offset_y: target_offset,
 4411|       |        };
 4412|       |        app.update_screenshot_state(&ctx, Some(1), Some(snapshot_ready));
 4413|       |
 4414|       |        let state = app.screenshot.as_ref().expect("screenshot state");
 4415|       |        assert!(state.viewport_adjusted);
 4416|       |        assert!(state.requested);
 4417|       |        assert!(state.scroll_ready());
 4418|       |    }
 4419|       |
 4420|       |    #[test]
 4421|       |    fn test_update_screenshot_state_stable_without_timeout() {
 4422|       |        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 4423|       |        let config = ScreenshotConfig {
 4424|       |            output_path: temp_dir.path().join("shot.png"),
 4425|       |            viewport_width: 120.0,
 4426|       |            viewport_height: 80.0,
 4427|       |            content_only: false,
 4428|       |            scroll_ratio: None,
 4429|       |            wait_ms: 10_000,
 4430|       |            settle_frames: 0,
 4431|       |            zoom: 1.0,
 4432|       |            theme: ScreenshotTheme::Light,
 4433|       |            font_source: None,
 4434|       |        };
 4435|       |        let mut app = MarkdownViewerApp::new();
 4436|       |        app.screenshot = Some(ScreenshotState::new(config));
 4437|       |
 4438|       |        let ctx = egui::Context::default();
 4439|       |        app.update_screenshot_state(&ctx, Some(1), None);
 4440|       |
 4441|       |        let state = app.screenshot.as_ref().expect("screenshot state");
 4442|       |        assert!(state.requested);
 4443|       |        assert!(!state.timed_out);
 4444|       |    }
 4445|       |
 4446|       |    #[test]
 4447|       |    fn test_update_screenshot_state_times_out_before_stable() {
 4448|       |        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 4449|       |        let config = ScreenshotConfig {
 4450|       |            output_path: temp_dir.path().join("shot.png"),
 4451|       |            viewport_width: 120.0,
 4452|       |            viewport_height: 80.0,
 4453|       |            content_only: false,
 4454|       |            scroll_ratio: Some(0.5),
 4455|       |            wait_ms: 0,
 4456|       |            settle_frames: 5,
 4457|       |            zoom: 1.0,
 4458|       |            theme: ScreenshotTheme::Light,
 4459|       |            font_source: None,
 4460|       |        };
 4461|       |        let mut app = MarkdownViewerApp::new();
 4462|       |        app.screenshot = Some(ScreenshotState::new(config));
 4463|       |
 4464|       |        let ctx = egui::Context::default();
 4465|       |        app.update_screenshot_state(&ctx, None, None);
 4466|       |
 4467|       |        let state = app.screenshot.as_ref().expect("screenshot state");
 4468|       |        assert!(state.timed_out);
 4469|       |    }
 4470|       |
 4471|       |    #[test]
 4472|       |    fn test_save_persists_window_state_when_no_screenshot() {
 4473|       |        let _lock = env_lock();
 4474|       |        let temp_dir = TempDir::new().expect("temp dir");
 4475|       |        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());
 4476|       |
 4477|       |        let mut app = MarkdownViewerApp::new();
 4478|       |        app.last_window_pos = Some([10.0, 20.0]);
 4479|       |        app.last_window_size = Some([800.0, 600.0]);
 4480|       |        let mut storage = DummyStorage::default();
 4481|       |        app.save(&mut storage);
 4482|       |
 4483|       |        let path = temp_dir
 4484|       |            .path()
 4485|       |            .join("MarkdownView")
 4486|       |            .join("window_state.txt");
 4487|       |        assert!(path.exists());
 4488|       |    }
 4489|       |
 4490|       |    #[test]
 4491|       |    fn test_save_skips_persist_when_screenshot_active() {
 4492|       |        let _lock = env_lock();
 4493|       |        let temp_dir = TempDir::new().expect("temp dir");
 4494|       |        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());
 4495|       |
 4496|       |        let mut app = MarkdownViewerApp::new();
 4497|       |        let config = ScreenshotConfig {
 4498|       |            output_path: temp_dir.path().join("shot.png"),
 4499|       |            viewport_width: 10.0,
 4500|       |            viewport_height: 10.0,
 4501|       |            content_only: false,
 4502|       |            scroll_ratio: None,
 4503|       |            wait_ms: 0,
 4504|       |            settle_frames: 0,
 4505|       |            zoom: 1.0,
 4506|       |            theme: ScreenshotTheme::Light,
 4507|       |            font_source: None,
 4508|       |        };
 4509|       |        app.set_screenshot_mode(config);
 4510|       |        let mut storage = DummyStorage::default();
 4511|       |        app.save(&mut storage);
 4512|       |
 4513|       |        let path = temp_dir
 4514|       |            .path()
 4515|       |            .join("MarkdownView")
 4516|       |            .join("window_state.txt");
 4517|       |        assert!(!path.exists());
 4518|       |    }
 4519|       |
 4520|       |    #[test]
 4521|       |    fn test_save_screenshot_image_crops_content_rect() -> Result<()> {
 4522|       |        let temp_dir = TempDir::new()?;
 4523|       |        let output_path = temp_dir.path().join("shot.png");
 4524|       |        let config = ScreenshotConfig {
 4525|       |            output_path: output_path.clone(),
 4526|       |            viewport_width: 100.0,
 4527|       |            viewport_height: 80.0,
 4528|       |            content_only: true,
 4529|       |            scroll_ratio: None,
 4530|       |            wait_ms: 0,
 4531|       |            settle_frames: 0,
 4532|       |            zoom: 1.0,
 4533|       |            theme: ScreenshotTheme::Dark,
 4534|       |            font_source: None,
 4535|       |        };
 4536|       |        let snapshot = ScreenshotSnapshot {
 4537|       |            config,
 4538|       |            content_rect: Some(egui::Rect::from_min_max(
 4539|       |                egui::pos2(2.0, 2.0),
 4540|       |                egui::pos2(8.0, 8.0),
 4541|       |            )),
 4542|       |            pixels_per_point: 1.0,
 4543|       |            stable_frames: 0,
 4544|       |            timed_out: false,
 4545|       |            pending_renders: false,
 4546|       |            last_scroll_offset: None,
 4547|       |            started: std::time::Instant::now(),
 4548|       |        };
 4549|       |        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4550|       |        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
 4551|       |        assert!(output_path.exists());
 4552|       |        assert!(output_path.with_extension("json").exists());
 4553|       |        Ok(())
 4554|       |    }
 4555|       |
 4556|       |    #[test]
 4557|       |    fn test_save_screenshot_image_no_crop() -> Result<()> {
 4558|       |        let temp_dir = TempDir::new()?;
 4559|       |        let output_path = temp_dir.path().join("shot.png");
 4560|       |        let config = ScreenshotConfig {
 4561|       |            output_path: output_path.clone(),
 4562|       |            viewport_width: 100.0,
 4563|       |            viewport_height: 80.0,
 4564|       |            content_only: false,
 4565|       |            scroll_ratio: None,
 4566|       |            wait_ms: 0,
 4567|       |            settle_frames: 0,
 4568|       |            zoom: 1.0,
 4569|       |            theme: ScreenshotTheme::Light,
 4570|       |            font_source: None,
 4571|       |        };
 4572|       |        let snapshot = ScreenshotSnapshot {
 4573|       |            config,
 4574|       |            content_rect: None,
 4575|       |            pixels_per_point: 1.0,
 4576|       |            stable_frames: 0,
 4577|       |            timed_out: false,
 4578|       |            pending_renders: false,
 4579|       |            last_scroll_offset: None,
 4580|       |            started: std::time::Instant::now(),
 4581|       |        };
 4582|       |        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4583|       |        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
 4584|       |        assert!(output_path.exists());
 4585|       |        Ok(())
 4586|       |    }
 4587|       |
 4588|       |    #[test]
 4589|       |    fn test_save_screenshot_image_zero_content_rect_ignored() -> Result<()> {
 4590|       |        let temp_dir = TempDir::new()?;
 4591|       |        let output_path = temp_dir.path().join("shot.png");
 4592|       |        let config = ScreenshotConfig {
 4593|       |            output_path: output_path.clone(),
 4594|       |            viewport_width: 100.0,
 4595|       |            viewport_height: 80.0,
 4596|       |            content_only: true,
 4597|       |            scroll_ratio: None,
 4598|       |            wait_ms: 0,
 4599|       |            settle_frames: 0,
 4600|       |            zoom: 1.0,
 4601|       |            theme: ScreenshotTheme::Dark,
 4602|       |            font_source: None,
 4603|       |        };
 4604|       |        let snapshot = ScreenshotSnapshot {
 4605|       |            config,
 4606|       |            content_rect: Some(egui::Rect::from_min_max(
 4607|       |                egui::pos2(5.0, 5.0),
 4608|       |                egui::pos2(5.0, 5.0),
 4609|       |            )),
 4610|       |            pixels_per_point: 1.0,
 4611|       |            stable_frames: 0,
 4612|       |            timed_out: false,
 4613|       |            pending_renders: false,
 4614|       |            last_scroll_offset: None,
 4615|       |            started: std::time::Instant::now(),
 4616|       |        };
 4617|       |        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4618|       |        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
 4619|       |        let saved = image::open(&output_path)?;
 4620|       |        assert_eq!(saved.width(), 10);
 4621|       |        assert_eq!(saved.height(), 10);
 4622|       |        Ok(())
 4623|       |    }
 4624|       |
 4625|       |    #[test]
 4626|       |    fn test_save_screenshot_image_content_only_without_rect() -> Result<()> {
 4627|       |        let temp_dir = TempDir::new()?;
 4628|       |        let output_path = temp_dir.path().join("shot.png");
 4629|       |        let config = ScreenshotConfig {
 4630|       |            output_path: output_path.clone(),
 4631|       |            viewport_width: 100.0,
 4632|       |            viewport_height: 80.0,
 4633|       |            content_only: true,
 4634|       |            scroll_ratio: None,
 4635|       |            wait_ms: 0,
 4636|       |            settle_frames: 0,
 4637|       |            zoom: 1.0,
 4638|       |            theme: ScreenshotTheme::Light,
 4639|       |            font_source: None,
 4640|       |        };
 4641|       |        let snapshot = ScreenshotSnapshot {
 4642|       |            config,
 4643|       |            content_rect: None,
 4644|       |            pixels_per_point: 1.0,
 4645|       |            stable_frames: 0,
 4646|       |            timed_out: false,
 4647|       |            pending_renders: false,
 4648|       |            last_scroll_offset: None,
 4649|       |            started: std::time::Instant::now(),
 4650|       |        };
 4651|       |        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4652|       |        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
 4653|       |        assert!(output_path.exists());
 4654|       |        Ok(())
 4655|       |    }
 4656|       |
 4657|       |    #[test]
 4658|       |    fn test_save_screenshot_image_height_zero_skips_crop() -> Result<()> {
 4659|       |        let temp_dir = TempDir::new()?;
 4660|       |        let output_path = temp_dir.path().join("shot.png");
 4661|       |        let config = ScreenshotConfig {
 4662|       |            output_path: output_path.clone(),
 4663|       |            viewport_width: 100.0,
 4664|       |            viewport_height: 80.0,
 4665|       |            content_only: true,
 4666|       |            scroll_ratio: None,
 4667|       |            wait_ms: 0,
 4668|       |            settle_frames: 0,
 4669|       |            zoom: 1.0,
 4670|       |            theme: ScreenshotTheme::Light,
 4671|       |            font_source: None,
 4672|       |        };
 4673|       |        let snapshot = ScreenshotSnapshot {
 4674|       |            config,
 4675|       |            content_rect: Some(egui::Rect::from_min_max(
 4676|       |                egui::pos2(2.0, 2.0),
 4677|       |                egui::pos2(8.0, 2.0),
 4678|       |            )),
 4679|       |            pixels_per_point: 1.0,
 4680|       |            stable_frames: 0,
 4681|       |            timed_out: false,
 4682|       |            pending_renders: false,
 4683|       |            last_scroll_offset: None,
 4684|       |            started: std::time::Instant::now(),
 4685|       |        };
 4686|       |        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4687|       |        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
 4688|       |        let saved = image::open(&output_path)?;
 4689|       |        assert_eq!(saved.width(), 10);
 4690|       |        assert_eq!(saved.height(), 10);
 4691|       |        Ok(())
 4692|       |    }
 4693|       |
 4694|       |    #[test]
 4695|       |    fn test_save_screenshot_image_empty_output_path_errors() {
 4696|       |        let config = ScreenshotConfig {
 4697|       |            output_path: PathBuf::new(),
 4698|       |            viewport_width: 100.0,
 4699|       |            viewport_height: 80.0,
 4700|       |            content_only: false,
 4701|       |            scroll_ratio: None,
 4702|       |            wait_ms: 0,
 4703|       |            settle_frames: 0,
 4704|       |            zoom: 1.0,
 4705|       |            theme: ScreenshotTheme::Light,
 4706|       |            font_source: None,
 4707|       |        };
 4708|       |        let snapshot = ScreenshotSnapshot {
 4709|       |            config,
 4710|       |            content_rect: None,
 4711|       |            pixels_per_point: 1.0,
 4712|       |            stable_frames: 0,
 4713|       |            timed_out: false,
 4714|       |            pending_renders: false,
 4715|       |            last_scroll_offset: None,
 4716|       |            started: std::time::Instant::now(),
 4717|       |        };
 4718|       |        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4719|       |        assert!(MarkdownViewerApp::save_screenshot_image(&image, &snapshot).is_err());
 4720|       |    }
 4721|       |
 4722|       |    #[test]
 4723|       |    fn test_save_screenshot_image_crop_condition_variants() -> Result<()> {
 4724|       |        let temp_dir = TempDir::new()?;
 4725|       |        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4726|       |
 4727|       |        let make_config = |name: &str| ScreenshotConfig {
 4728|       |            output_path: temp_dir.path().join(name),
 4729|       |            viewport_width: 100.0,
 4730|       |            viewport_height: 80.0,
 4731|       |            content_only: true,
 4732|       |            scroll_ratio: None,
 4733|       |            wait_ms: 0,
 4734|       |            settle_frames: 0,
 4735|       |            zoom: 1.0,
 4736|       |            theme: ScreenshotTheme::Light,
 4737|       |            font_source: None,
 4738|       |        };
 4739|       |
 4740|       |        let snapshot_y = ScreenshotSnapshot {
 4741|       |            config: make_config("shot_y.png"),
 4742|       |            content_rect: Some(egui::Rect::from_min_max(
 4743|       |                egui::pos2(0.0, 2.0),
 4744|       |                egui::pos2(10.0, 9.0),
 4745|       |            )),
 4746|       |            pixels_per_point: 1.0,
 4747|       |            stable_frames: 0,
 4748|       |            timed_out: false,
 4749|       |            pending_renders: false,
 4750|       |            last_scroll_offset: None,
 4751|       |            started: std::time::Instant::now(),
 4752|       |        };
 4753|       |        MarkdownViewerApp::save_screenshot_image(&image, &snapshot_y)?;
 4754|       |
 4755|       |        let snapshot_w = ScreenshotSnapshot {
 4756|       |            config: make_config("shot_w.png"),
 4757|       |            content_rect: Some(egui::Rect::from_min_max(
 4758|       |                egui::pos2(0.0, 0.0),
 4759|       |                egui::pos2(6.0, 10.0),
 4760|       |            )),
 4761|       |            pixels_per_point: 1.0,
 4762|       |            stable_frames: 0,
 4763|       |            timed_out: false,
 4764|       |            pending_renders: false,
 4765|       |            last_scroll_offset: None,
 4766|       |            started: std::time::Instant::now(),
 4767|       |        };
 4768|       |        MarkdownViewerApp::save_screenshot_image(&image, &snapshot_w)?;
 4769|       |
 4770|       |        let snapshot_h = ScreenshotSnapshot {
 4771|       |            config: make_config("shot_h.png"),
 4772|       |            content_rect: Some(egui::Rect::from_min_max(
 4773|       |                egui::pos2(0.0, 0.0),
 4774|       |                egui::pos2(10.0, 6.0),
 4775|       |            )),
 4776|       |            pixels_per_point: 1.0,
 4777|       |            stable_frames: 0,
 4778|       |            timed_out: false,
 4779|       |            pending_renders: false,
 4780|       |            last_scroll_offset: None,
 4781|       |            started: std::time::Instant::now(),
 4782|       |        };
 4783|       |        MarkdownViewerApp::save_screenshot_image(&image, &snapshot_h)?;
 4784|       |
 4785|       |        assert!(temp_dir.path().join("shot_y.png").exists());
 4786|       |        assert!(temp_dir.path().join("shot_w.png").exists());
 4787|       |        assert!(temp_dir.path().join("shot_h.png").exists());
 4788|       |        Ok(())
 4789|       |    }
 4790|       |
 4791|       |    #[test]
 4792|       |    fn test_handle_screenshot_event_saves_file() -> Result<()> {
 4793|       |        let temp_dir = tempfile::TempDir::new()?;
 4794|       |        let output_path = temp_dir.path().join("shot.png");
 4795|       |        let config = ScreenshotConfig {
 4796|       |            output_path: output_path.clone(),
 4797|       |            viewport_width: 40.0,
 4798|       |            viewport_height: 30.0,
 4799|       |            content_only: false,
 4800|       |            scroll_ratio: None,
 4801|       |            wait_ms: 0,
 4802|       |            settle_frames: 0,
 4803|       |            zoom: 1.0,
 4804|       |            theme: ScreenshotTheme::Light,
 4805|       |            font_source: None,
 4806|       |        };
 4807|       |
 4808|       |        let mut app = MarkdownViewerApp::new();
 4809|       |        app.set_screenshot_mode(config);
 4810|       |
 4811|       |        let mut input = default_input();
 4812|       |        let image = egui::ColorImage::new([40, 30], Color32::WHITE);
 4813|       |        input.events.push(egui::Event::Screenshot {
 4814|       |            viewport_id: egui::ViewportId::ROOT,
 4815|       |            image: Arc::new(image),
 4816|       |        });
 4817|       |
 4818|       |        let ctx = egui::Context::default();
 4819|       |        run_app_frame(&mut app, &ctx, input);
 4820|       |
 4821|       |        assert!(output_path.exists());
 4822|       |        assert!(output_path.with_extension("json").exists());
 4823|       |        assert!(app.screenshot.as_ref().is_some_and(|state| state.done));
 4824|       |        Ok(())
 4825|       |    }
 4826|       |
 4827|       |    #[test]
 4828|       |    fn test_handle_shortcuts_sets_flags() {
 4829|       |        let mut app = MarkdownViewerApp::new();
 4830|       |        app.load_content("Alpha\n\nBeta\n\nGamma", Some("Search".to_string()));
 4831|       |        app.search_query = "beta".to_string();
 4832|       |        app.current_file = Some(PathBuf::from("dummy.md"));
 4833|       |
 4834|       |        let mut input = default_input();
 4835|       |        input.events.extend([
 4836|       |            egui::Event::Key {
 4837|       |                key: egui::Key::F,
 4838|       |                physical_key: None,
 4839|       |                pressed: true,
 4840|       |                repeat: false,
 4841|       |                modifiers: egui::Modifiers::CTRL,
 4842|       |            },
 4843|       |            egui::Event::Key {
 4844|       |                key: egui::Key::R,
 4845|       |                physical_key: None,
 4846|       |                pressed: true,
 4847|       |                repeat: false,
 4848|       |                modifiers: egui::Modifiers::CTRL,
 4849|       |            },
 4850|       |            egui::Event::Key {
 4851|       |                key: egui::Key::E,
 4852|       |                physical_key: None,
 4853|       |                pressed: true,
 4854|       |                repeat: false,
 4855|       |                modifiers: egui::Modifiers::CTRL,
 4856|       |            },
 4857|       |            egui::Event::Key {
 4858|       |                key: egui::Key::Plus,
 4859|       |                physical_key: None,
 4860|       |                pressed: true,
 4861|       |                repeat: false,
 4862|       |                modifiers: egui::Modifiers::CTRL,
 4863|       |            },
 4864|       |            egui::Event::Key {
 4865|       |                key: egui::Key::Minus,
 4866|       |                physical_key: None,
 4867|       |                pressed: true,
 4868|       |                repeat: false,
 4869|       |                modifiers: egui::Modifiers::CTRL,
 4870|       |            },
 4871|       |            egui::Event::Key {
 4872|       |                key: egui::Key::Num0,
 4873|       |                physical_key: None,
 4874|       |                pressed: true,
 4875|       |                repeat: false,
 4876|       |                modifiers: egui::Modifiers::CTRL,
 4877|       |            },
 4878|       |            egui::Event::Key {
 4879|       |                key: egui::Key::ArrowLeft,
 4880|       |                physical_key: None,
 4881|       |                pressed: true,
 4882|       |                repeat: false,
 4883|       |                modifiers: egui::Modifiers::ALT,
 4884|       |            },
 4885|       |            egui::Event::Key {
 4886|       |                key: egui::Key::ArrowRight,
 4887|       |                physical_key: None,
 4888|       |                pressed: true,
 4889|       |                repeat: false,
 4890|       |                modifiers: egui::Modifiers::ALT,
 4891|       |            },
 4892|       |            egui::Event::Key {
 4893|       |                key: egui::Key::F3,
 4894|       |                physical_key: None,
 4895|       |                pressed: true,
 4896|       |                repeat: false,
 4897|       |                modifiers: egui::Modifiers::NONE,
 4898|       |            },
 4899|       |            egui::Event::Key {
 4900|       |                key: egui::Key::F3,
 4901|       |                physical_key: None,
 4902|       |                pressed: true,
 4903|       |                repeat: false,
 4904|       |                modifiers: egui::Modifiers::SHIFT,
 4905|       |            },
 4906|       |            egui::Event::Key {
 4907|       |                key: egui::Key::F11,
 4908|       |                physical_key: None,
 4909|       |                pressed: true,
 4910|       |                repeat: false,
 4911|       |                modifiers: egui::Modifiers::NONE,
 4912|       |            },
 4913|       |            egui::Event::Key {
 4914|       |                key: egui::Key::F5,
 4915|       |                physical_key: None,
 4916|       |                pressed: true,
 4917|       |                repeat: false,
 4918|       |                modifiers: egui::Modifiers::NONE,
 4919|       |            },
 4920|       |        ]);
 4921|       |
 4922|       |        let ctx = egui::Context::default();
 4923|       |        let _ = ctx.run(input, |ctx| {
 4924|       |            app.handle_shortcuts(ctx);
 4925|       |        });
 4926|       |
 4927|       |        assert!(app.show_search);
 4928|       |        assert!(app.search_focus_requested);
 4929|       |        assert!(app.view_toggle_requested);
 4930|       |        assert!(app.write_toggle_requested);
 4931|       |        assert!(app.toggle_fullscreen);
 4932|       |        assert!(app.reload_requested);
 4933|       |        assert!(app.last_match_index.is_some());
 4934|       |    }
 4935|       |
 4936|       |    #[test]
 4937|       |    fn test_handle_shortcuts_navigation_keys() {
 4938|       |        let mut app = MarkdownViewerApp::new();
 4939|       |        let ctx = egui::Context::default();
 4940|       |
 4941|       |        let mut input = default_input();
 4942|       |        input.events.push(egui::Event::Key {
 4943|       |            key: egui::Key::PageUp,
 4944|       |            physical_key: None,
 4945|       |            pressed: true,
 4946|       |            repeat: false,
 4947|       |            modifiers: egui::Modifiers::NONE,
 4948|       |        });
 4949|       |        let _ = ctx.run(input, |ctx| {
 4950|       |            app.handle_shortcuts(ctx);
 4951|       |        });
 4952|       |        assert!(matches!(app.nav_request, Some(NavigationRequest::PageUp)));
 4953|       |
 4954|       |        app.nav_request = None;
 4955|       |        let mut input = default_input();
 4956|       |        input.events.push(egui::Event::Key {
 4957|       |            key: egui::Key::PageDown,
 4958|       |            physical_key: None,
 4959|       |            pressed: true,
 4960|       |            repeat: false,
 4961|       |            modifiers: egui::Modifiers::NONE,
 4962|       |        });
 4963|       |        let _ = ctx.run(input, |ctx| {
 4964|       |            app.handle_shortcuts(ctx);
 4965|       |        });
 4966|       |        assert!(matches!(app.nav_request, Some(NavigationRequest::PageDown)));
 4967|       |
 4968|       |        app.nav_request = None;
 4969|       |        let mut input = default_input();
 4970|       |        input.events.push(egui::Event::Key {
 4971|       |            key: egui::Key::Home,
 4972|       |            physical_key: None,
 4973|       |            pressed: true,
 4974|       |            repeat: false,
 4975|       |            modifiers: egui::Modifiers::NONE,
 4976|       |        });
 4977|       |        let _ = ctx.run(input, |ctx| {
 4978|       |            app.handle_shortcuts(ctx);
 4979|       |        });
 4980|       |        assert!(matches!(app.nav_request, Some(NavigationRequest::Top)));
 4981|       |
 4982|       |        app.nav_request = None;
 4983|       |        let mut input = default_input();
 4984|       |        input.events.push(egui::Event::Key {
 4985|       |            key: egui::Key::End,
 4986|       |            physical_key: None,
 4987|       |            pressed: true,
 4988|       |            repeat: false,
 4989|       |            modifiers: egui::Modifiers::NONE,
 4990|       |        });
 4991|       |        let _ = ctx.run(input, |ctx| {
 4992|       |            app.handle_shortcuts(ctx);
 4993|       |        });
 4994|       |        assert!(matches!(app.nav_request, Some(NavigationRequest::Bottom)));
 4995|       |
 4996|       |        app.nav_request = None;
 4997|       |        let mut input = default_input();
 4998|       |        input.events.push(egui::Event::Key {
 4999|       |            key: egui::Key::ArrowUp,
 5000|       |            physical_key: None,
 5001|       |            pressed: true,
 5002|       |            repeat: false,
 5003|       |            modifiers: egui::Modifiers::NONE,
 5004|       |        });
 5005|       |        let _ = ctx.run(input, |ctx| {
 5006|       |            app.handle_shortcuts(ctx);
 5007|       |        });
 5008|       |        assert!(matches!(app.nav_request, Some(NavigationRequest::ScrollUp)));
 5009|       |
 5010|       |        app.nav_request = None;
 5011|       |        let mut input = default_input();
 5012|       |        input.events.push(egui::Event::Key {
 5013|       |            key: egui::Key::ArrowDown,
 5014|       |            physical_key: None,
 5015|       |            pressed: true,
 5016|       |            repeat: false,
 5017|       |            modifiers: egui::Modifiers::NONE,
 5018|       |        });
 5019|       |        let _ = ctx.run(input, |ctx| {
 5020|       |            app.handle_shortcuts(ctx);
 5021|       |        });
 5022|       |        assert!(matches!(
 5023|       |            app.nav_request,
 5024|       |            Some(NavigationRequest::ScrollDown)
 5025|       |        ));
 5026|       |    }
 5027|       |
 5028|       |    #[test]
 5029|       |    fn test_handle_shortcuts_escape_clears_search() {
 5030|       |        let mut app = MarkdownViewerApp::new();
 5031|       |        app.show_search = true;
 5032|       |        app.search_query = "alpha".to_string();
 5033|       |        app.last_query = "alpha".to_string();
 5034|       |        app.last_match_index = Some(0);
 5035|       |        app.pending_scroll_to_element = Some(1);
 5036|       |
 5037|       |        let mut input = default_input();
 5038|       |        input.events.push(egui::Event::Key {
 5039|       |            key: egui::Key::Escape,
 5040|       |            physical_key: None,
 5041|       |            pressed: true,
 5042|       |            repeat: false,
 5043|       |            modifiers: egui::Modifiers::NONE,
 5044|       |        });
 5045|       |
 5046|       |        let ctx = egui::Context::default();
 5047|       |        let _ = ctx.run(input, |ctx| {
 5048|       |            app.handle_shortcuts(ctx);
 5049|       |        });
 5050|       |
 5051|       |        assert!(!app.show_search);
 5052|       |        assert!(app.search_query.is_empty());
 5053|       |        assert!(app.last_query.is_empty());
 5054|       |        assert!(app.last_match_index.is_none());
 5055|       |        assert!(app.pending_scroll_to_element.is_none());
 5056|       |    }
 5057|       |
 5058|       |    #[test]
 5059|       |    fn test_update_search_results_updates_matches() {
 5060|       |        let mut app = MarkdownViewerApp::new();
 5061|       |        app.load_content("Alpha\n\nBeta\n\nGamma", Some("Search".to_string()));
 5062|       |
 5063|       |        app.search_query = "beta".to_string();
 5064|       |        app.update_search_results("");
 5065|       |        assert_eq!(app.last_query, "beta");
 5066|       |        assert_eq!(app.last_match_index, Some(1));
 5067|       |        assert_eq!(app.pending_scroll_to_element, Some(1));
 5068|       |
 5069|       |        app.search_query.clear();
 5070|       |        app.update_search_results("beta");
 5071|       |        assert!(app.last_query.is_empty());
 5072|       |    }
 5073|       |
 5074|       |    #[test]
 5075|       |    fn test_update_search_results_no_match_leaves_index_clear() {
 5076|       |        let mut app = MarkdownViewerApp::new();
 5077|       |        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5078|       |            "Alpha".to_string(),
 5079|       |        )])];
 5080|       |        app.search_query = "Beta".to_string();
 5081|       |        app.pending_scroll_to_element = None;
 5082|       |
 5083|       |        app.update_search_results("");
 5084|       |
 5085|       |        assert!(app.last_match_index.is_none());
 5086|       |        assert!(app.pending_scroll_to_element.is_none());
 5087|       |    }
 5088|       |
 5089|       |    #[test]
 5090|       |    fn test_handle_shortcuts_ctrl_mouse_wheel_zoom() {
 5091|       |        let mut app = MarkdownViewerApp::new();
 5092|       |        let ctx = egui::Context::default();
 5093|       |        for delta in [20.0, -20.0] {
 5094|       |            let mut input = default_input();
 5095|       |            input.modifiers = egui::Modifiers::CTRL;
 5096|       |            input.events.push(egui::Event::MouseWheel {
 5097|       |                unit: egui::MouseWheelUnit::Point,
 5098|       |                delta: egui::vec2(0.0, delta),
 5099|       |                modifiers: egui::Modifiers::CTRL,
 5100|       |            });
 5101|       |            let _ = ctx.run(input, |ctx| {
 5102|       |                app.handle_shortcuts(ctx);
 5103|       |            });
 5104|       |        }
 5105|       |    }
 5106|       |
 5107|       |    #[test]
 5108|       |    fn test_handle_shortcuts_ctrl_mouse_wheel_no_wheel_events() {
 5109|       |        let mut app = MarkdownViewerApp::new();
 5110|       |        let mut input = default_input();
 5111|       |        input.modifiers = egui::Modifiers::CTRL;
 5112|       |        input.events.push(egui::Event::Key {
 5113|       |            key: egui::Key::A,
 5114|       |            physical_key: None,
 5115|       |            pressed: true,
 5116|       |            repeat: false,
 5117|       |            modifiers: egui::Modifiers::CTRL,
 5118|       |        });
 5119|       |
 5120|       |        let ctx = egui::Context::default();
 5121|       |        let _ = ctx.run(input, |ctx| {
 5122|       |            app.handle_shortcuts(ctx);
 5123|       |        });
 5124|       |    }
 5125|       |
 5126|       |    #[test]
 5127|       |    fn test_handle_shortcuts_raw_page_moves() {
 5128|       |        let mut app = MarkdownViewerApp::new();
 5129|       |        app.view_mode = ViewMode::Raw;
 5130|       |        app.write_enabled = true;
 5131|       |
 5132|       |        let mut input = default_input();
 5133|       |        input.events.extend([
 5134|       |            egui::Event::Key {
 5135|       |                key: egui::Key::PageUp,
 5136|       |                physical_key: None,
 5137|       |                pressed: true,
 5138|       |                repeat: false,
 5139|       |                modifiers: egui::Modifiers::NONE,
 5140|       |            },
 5141|       |            egui::Event::Key {
 5142|       |                key: egui::Key::PageDown,
 5143|       |                physical_key: None,
 5144|       |                pressed: true,
 5145|       |                repeat: false,
 5146|       |                modifiers: egui::Modifiers::NONE,
 5147|       |            },
 5148|       |        ]);
 5149|       |
 5150|       |        let ctx = egui::Context::default();
 5151|       |        let _ = ctx.run(input, |ctx| {
 5152|       |            app.handle_shortcuts(ctx);
 5153|       |        });
 5154|       |
 5155|       |        assert!(app.pending_raw_cursor_line_move.is_some());
 5156|       |        assert!(app.raw_focus_requested);
 5157|       |    }
 5158|       |
 5159|       |    #[test]
 5160|       |    fn test_render_helpers_cover_ui_paths() {
 5161|       |        let mut app = MarkdownViewerApp::new();
 5162|       |        app.current_content = "Hello".to_string();
 5163|       |        app.pending_files.push_back(PathBuf::from("queued.md"));
 5164|       |        app.drag_hover = true;
 5165|       |        app.show_search = true;
 5166|       |        app.search_query = "welcome".to_string();
 5167|       |
 5168|       |        let ctx = egui::Context::default();
 5169|       |        let _ = ctx.run(default_input(), |ctx| {
 5170|       |            CentralPanel::default().show(ctx, |ui| {
 5171|       |                app.render_file_menu_contents(ui, false, Color32::WHITE);
 5172|       |                app.render_view_menu_contents(ui, ctx, false, Color32::WHITE);
 5173|       |                app.render_help_menu_contents(ui, false, Color32::WHITE);
 5174|       |            });
 5175|       |            app.render_status_bar(ctx);
 5176|       |            app.render_search_dialog(ctx);
 5177|       |            app.render_drag_overlay(ctx);
 5178|       |        });
 5179|       |
 5180|       |        assert!(app.show_search);
 5181|       |    }
 5182|       |
 5183|       |    #[test]
 5184|       |    fn test_screenshot_config_helpers() {
 5185|       |        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 5186|       |        let output_path = temp_dir.path().join("shot.png");
 5187|       |        let config = ScreenshotConfig {
 5188|       |            output_path: output_path.clone(),
 5189|       |            viewport_width: 100.0,
 5190|       |            viewport_height: 80.0,
 5191|       |            content_only: true,
 5192|       |            scroll_ratio: None,
 5193|       |            wait_ms: 0,
 5194|       |            settle_frames: 0,
 5195|       |            zoom: 1.0,
 5196|       |            theme: ScreenshotTheme::Light,
 5197|       |            font_source: None,
 5198|       |        };
 5199|       |
 5200|       |        assert_eq!(config.metadata_path(), output_path.with_extension("json"));
 5201|       |        assert_eq!(config.theme.as_str(), "light");
 5202|       |        assert_eq!(ScreenshotTheme::Dark.as_str(), "dark");
 5203|       |    }
 5204|       |
 5205|       |    #[test]
 5206|       |    fn test_open_file_dialog_forced_path() -> Result<()> {
 5207|       |        let mut app = MarkdownViewerApp::new();
 5208|       |        let temp_dir = tempfile::TempDir::new()?;
 5209|       |        let file_path = temp_dir.path().join("open.md");
 5210|       |        std::fs::write(&file_path, "# Open")?;
 5211|       |        let _forced = ForcedDialogPaths::new(Some(file_path.clone()), None);
 5212|       |
 5213|       |        app.open_file_dialog();
 5214|       |
 5215|       |        assert_eq!(app.current_file, Some(file_path));
 5216|       |        assert!(app.error_message.is_none());
 5217|       |        Ok(())
 5218|       |    }
 5219|       |
 5220|       |    #[test]
 5221|       |    fn test_save_current_document_existing_path() -> Result<()> {
 5222|       |        let mut app = MarkdownViewerApp::new();
 5223|       |        let temp_dir = tempfile::TempDir::new()?;
 5224|       |        let file_path = temp_dir.path().join("save.md");
 5225|       |        app.current_file = Some(file_path.clone());
 5226|       |        app.current_content = "Saved content".to_string();
 5227|       |
 5228|       |        app.save_current_document()?;
 5229|       |
 5230|       |        let saved = std::fs::read_to_string(&file_path)?;
 5231|       |        assert_eq!(saved, "Saved content");
 5232|       |        Ok(())
 5233|       |    }
 5234|       |
 5235|       |    #[test]
 5236|       |    fn test_save_current_document_forced_path() -> Result<()> {
 5237|       |        let mut app = MarkdownViewerApp::new();
 5238|       |        let temp_dir = tempfile::TempDir::new()?;
 5239|       |        let file_path = temp_dir.path().join("save_forced.md");
 5240|       |        let _forced = ForcedDialogPaths::new(None, Some(file_path.clone()));
 5241|       |        app.current_content = "Forced save".to_string();
 5242|       |
 5243|       |        app.save_current_document()?;
 5244|       |
 5245|       |        assert_eq!(app.current_file, Some(file_path.clone()));
 5246|       |        assert!(app.title.contains("save_forced.md"));
 5247|       |        let saved = std::fs::read_to_string(&file_path)?;
 5248|       |        assert_eq!(saved, "Forced save");
 5249|       |        Ok(())
 5250|       |    }
 5251|       |
 5252|       |    #[test]
 5253|       |    fn test_save_current_document_forced_path_write_error() -> Result<()> {
 5254|       |        let mut app = MarkdownViewerApp::new();
 5255|       |        let temp_dir = tempfile::TempDir::new()?;
 5256|       |        let save_dir = temp_dir.path().join("save_dir");
 5257|       |        std::fs::create_dir_all(&save_dir)?;
 5258|       |        let _forced = ForcedDialogPaths::new(None, Some(save_dir));
 5259|       |        app.current_content = "Data".to_string();
 5260|       |
 5261|       |        assert!(app.save_current_document().is_err());
 5262|       |        assert!(app.current_file.is_none());
 5263|       |        Ok(())
 5264|       |    }
 5265|       |
 5266|       |    #[test]
 5267|       |    fn test_save_current_document_no_path_no_dialog() -> Result<()> {
 5268|       |        let mut app = MarkdownViewerApp::new();
 5269|       |        let _forced = ForcedDialogPaths::new(None, None);
 5270|       |        app.current_content = "No save".to_string();
 5271|       |
 5272|       |        app.save_current_document()?;
 5273|       |
 5274|       |        assert!(app.current_file.is_none());
 5275|       |        Ok(())
 5276|       |    }
 5277|       |
 5278|       |    #[test]
 5279|       |    fn test_restore_from_history_sets_state() {
 5280|       |        let mut app = MarkdownViewerApp::new();
 5281|       |        app.current_content = "first".to_string();
 5282|       |        app.current_file = Some(PathBuf::from("first.md"));
 5283|       |        app.title = "mdmdview - first".to_string();
 5284|       |        app.push_history();
 5285|       |
 5286|       |        app.current_content = "second".to_string();
 5287|       |        app.current_file = None;
 5288|       |        app.title = "mdmdview - second".to_string();
 5289|       |        app.push_history();
 5290|       |
 5291|       |        app.history_index = 0;
 5292|       |        app.restore_from_history();
 5293|       |
 5294|       |        assert_eq!(app.current_file, Some(PathBuf::from("first.md")));
 5295|       |        assert_eq!(app.current_content, "first");
 5296|       |        assert_eq!(app.pending_scroll_to_element, Some(0));
 5297|       |    }
 5298|       |
 5299|       |    #[test]
 5300|       |    fn test_restore_from_history_out_of_range_no_change() {
 5301|       |        let mut app = MarkdownViewerApp::new();
 5302|       |        app.current_content = "current".to_string();
 5303|       |        app.history_index = 3;
 5304|       |
 5305|       |        app.restore_from_history();
 5306|       |
 5307|       |        assert_eq!(app.current_content, "current");
 5308|       |        assert!(app.current_file.is_none());
 5309|       |    }
 5310|       |
 5311|       |    #[test]
 5312|       |    fn test_handle_file_drop_mixed_files() -> Result<()> {
 5313|       |        let mut app = MarkdownViewerApp::new();
 5314|       |        let temp_dir = tempfile::TempDir::new()?;
 5315|       |        let good1 = temp_dir.path().join("good1.md");
 5316|       |        let good2 = temp_dir.path().join("good2.md");
 5317|       |        let bad = temp_dir.path().join("bad.pdf");
 5318|       |        std::fs::write(&good1, "# Good1")?;
 5319|       |        std::fs::write(&good2, "# Good2")?;
 5320|       |        std::fs::write(&bad, "nope")?;
 5321|       |
 5322|       |        app.handle_file_drop(vec![bad, good1.clone(), good2.clone()]);
 5323|       |
 5324|       |        assert_eq!(app.current_file, Some(good1));
 5325|       |        assert!(app.pending_files.contains(&good2));
 5326|       |        assert!(app.error_message.is_some());
 5327|       |        Ok(())
 5328|       |    }
 5329|       |
 5330|       |    #[test]
 5331|       |    fn test_handle_file_drop_directory_no_markdown() -> Result<()> {
 5332|       |        let mut app = MarkdownViewerApp::new();
 5333|       |        let temp_dir = tempfile::TempDir::new()?;
 5334|       |        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 5335|       |        assert!(app.error_message.is_some());
 5336|       |        Ok(())
 5337|       |    }
 5338|       |
 5339|       |    #[test]
 5340|       |    fn test_handle_file_drop_too_many_files() -> Result<()> {
 5341|       |        let mut app = MarkdownViewerApp::new();
 5342|       |        let temp_dir = tempfile::TempDir::new()?;
 5343|       |        let mut files = Vec::new();
 5344|       |        for idx in 0..51 {
 5345|       |            let path = temp_dir.path().join(format!("file{}.md", idx));
 5346|       |            std::fs::write(&path, "# Test")?;
 5347|       |            files.push(path);
 5348|       |        }
 5349|       |
 5350|       |        app.handle_file_drop(files);
 5351|       |
 5352|       |        assert!(app.error_message.is_some());
 5353|       |        Ok(())
 5354|       |    }
 5355|       |
 5356|       |    #[test]
 5357|       |    fn test_move_raw_cursor_lines_up_and_down() {
 5358|       |        let mut app = MarkdownViewerApp::new();
 5359|       |        app.view_mode = ViewMode::Raw;
 5360|       |        app.write_enabled = true;
 5361|       |        app.raw_buffer = "Line 1\nLine 2\nLine 3".to_string();
 5362|       |        app.current_content = app.raw_buffer.clone();
 5363|       |
 5364|       |        let ctx = egui::Context::default();
 5365|       |        let editor_id = egui::Id::new("raw_editor");
 5366|       |        let mut state = egui::text_edit::TextEditState::default();
 5367|       |        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 5368|       |        state.cursor.set_char_range(Some(cr));
 5369|       |        state.store(&ctx, editor_id);
 5370|       |
 5371|       |        app.move_raw_cursor_lines(&ctx, 1);
 5372|       |        let down_idx = app.raw_cursor.unwrap_or(0);
 5373|       |        assert!(down_idx > 0);
 5374|       |
 5375|       |        app.move_raw_cursor_lines(&ctx, -1);
 5376|       |        let up_idx = app.raw_cursor.unwrap_or(0);
 5377|       |        assert!(up_idx <= down_idx);
 5378|       |    }
 5379|       |
 5380|       |    #[test]
 5381|       |    fn test_move_raw_cursor_lines_early_return_when_not_raw() {
 5382|       |        let mut app = MarkdownViewerApp::new();
 5383|       |        app.view_mode = ViewMode::Rendered;
 5384|       |        app.write_enabled = true;
 5385|       |        app.raw_cursor = Some(2);
 5386|       |
 5387|       |        let ctx = egui::Context::default();
 5388|       |        app.move_raw_cursor_lines(&ctx, 1);
 5389|       |
 5390|       |        assert_eq!(app.raw_cursor, Some(2));
 5391|       |    }
 5392|       |
 5393|       |    #[test]
 5394|       |    fn test_move_raw_cursor_lines_write_disabled_returns() {
 5395|       |        let mut app = MarkdownViewerApp::new();
 5396|       |        app.view_mode = ViewMode::Raw;
 5397|       |        app.write_enabled = false;
 5398|       |        app.raw_cursor = Some(1);
 5399|       |
 5400|       |        let ctx = egui::Context::default();
 5401|       |        app.move_raw_cursor_lines(&ctx, 1);
 5402|       |
 5403|       |        assert_eq!(app.raw_cursor, Some(1));
 5404|       |    }
 5405|       |
 5406|       |    #[test]
 5407|       |    fn test_move_raw_cursor_lines_without_text_state() {
 5408|       |        let mut app = MarkdownViewerApp::new();
 5409|       |        app.view_mode = ViewMode::Raw;
 5410|       |        app.write_enabled = true;
 5411|       |        app.raw_buffer = "Line".to_string();
 5412|       |        app.current_content = app.raw_buffer.clone();
 5413|       |
 5414|       |        let ctx = egui::Context::default();
 5415|       |        app.move_raw_cursor_lines(&ctx, 1);
 5416|       |
 5417|       |        assert!(app.raw_cursor.is_none());
 5418|       |    }
 5419|       |
 5420|       |    #[test]
 5421|       |    fn test_move_raw_cursor_lines_uses_raw_cursor_when_char_range_missing() {
 5422|       |        let mut app = MarkdownViewerApp::new();
 5423|       |        app.view_mode = ViewMode::Raw;
 5424|       |        app.write_enabled = true;
 5425|       |        app.raw_buffer = "Line 1\nLine 2\nLine 3".to_string();
 5426|       |        app.current_content = app.raw_buffer.clone();
 5427|       |        app.raw_cursor = Some(7);
 5428|       |
 5429|       |        let ctx = egui::Context::default();
 5430|       |        let editor_id = egui::Id::new("raw_editor");
 5431|       |        let mut state = egui::text_edit::TextEditState::default();
 5432|       |        state.cursor.set_char_range(None);
 5433|       |        state.store(&ctx, editor_id);
 5434|       |
 5435|       |        app.move_raw_cursor_lines(&ctx, 1);
 5436|       |
 5437|       |        assert_eq!(app.raw_cursor, Some(14));
 5438|       |    }
 5439|       |
 5440|       |    #[test]
 5441|       |    fn test_move_raw_cursor_lines_negative_at_start_no_loop() {
 5442|       |        let mut app = MarkdownViewerApp::new();
 5443|       |        app.view_mode = ViewMode::Raw;
 5444|       |        app.write_enabled = true;
 5445|       |        app.raw_buffer = "Line 1\nLine 2".to_string();
 5446|       |        app.current_content = app.raw_buffer.clone();
 5447|       |
 5448|       |        let ctx = egui::Context::default();
 5449|       |        let editor_id = egui::Id::new("raw_editor");
 5450|       |        let mut state = egui::text_edit::TextEditState::default();
 5451|       |        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 5452|       |        state.cursor.set_char_range(Some(cr));
 5453|       |        state.store(&ctx, editor_id);
 5454|       |
 5455|       |        app.move_raw_cursor_lines(&ctx, -1);
 5456|       |        assert_eq!(app.raw_cursor, Some(0));
 5457|       |    }
 5458|       |
 5459|       |    #[test]
 5460|       |    fn test_move_raw_cursor_lines_down_without_newline() {
 5461|       |        let mut app = MarkdownViewerApp::new();
 5462|       |        app.view_mode = ViewMode::Raw;
 5463|       |        app.write_enabled = true;
 5464|       |        app.raw_buffer = "Line".to_string();
 5465|       |        app.current_content = app.raw_buffer.clone();
 5466|       |
 5467|       |        let ctx = egui::Context::default();
 5468|       |        let editor_id = egui::Id::new("raw_editor");
 5469|       |        let mut state = egui::text_edit::TextEditState::default();
 5470|       |        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 5471|       |        state.cursor.set_char_range(Some(cr));
 5472|       |        state.store(&ctx, editor_id);
 5473|       |
 5474|       |        app.move_raw_cursor_lines(&ctx, 1);
 5475|       |        assert_eq!(app.raw_cursor, Some(app.raw_buffer.len()));
 5476|       |    }
 5477|       |
 5478|       |    #[test]
 5479|       |    fn test_move_raw_cursor_lines_down_at_end_no_loop() {
 5480|       |        let mut app = MarkdownViewerApp::new();
 5481|       |        app.view_mode = ViewMode::Raw;
 5482|       |        app.write_enabled = true;
 5483|       |        app.raw_buffer = "Line 1\nLine 2".to_string();
 5484|       |        app.current_content = app.raw_buffer.clone();
 5485|       |
 5486|       |        let ctx = egui::Context::default();
 5487|       |        let editor_id = egui::Id::new("raw_editor");
 5488|       |        let mut state = egui::text_edit::TextEditState::default();
 5489|       |        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(app.raw_buffer.len()));
 5490|       |        state.cursor.set_char_range(Some(cr));
 5491|       |        state.store(&ctx, editor_id);
 5492|       |
 5493|       |        app.move_raw_cursor_lines(&ctx, 1);
 5494|       |        assert_eq!(app.raw_cursor, Some(app.raw_buffer.len()));
 5495|       |    }
 5496|       |
 5497|       |    #[test]
 5498|       |    fn test_handle_shortcuts_open_accelerators() -> Result<()> {
 5499|       |        let mut app = MarkdownViewerApp::new();
 5500|       |        let temp_dir = tempfile::TempDir::new()?;
 5501|       |        let open_path = temp_dir.path().join("open.md");
 5502|       |        std::fs::write(&open_path, "# Open")?;
 5503|       |        let _forced = ForcedDialogPaths::new(Some(open_path.clone()), None);
 5504|       |
 5505|       |        let mut input = default_input();
 5506|       |        input.events.extend([
 5507|       |            egui::Event::Key {
 5508|       |                key: egui::Key::O,
 5509|       |                physical_key: None,
 5510|       |                pressed: true,
 5511|       |                repeat: false,
 5512|       |                modifiers: egui::Modifiers::CTRL,
 5513|       |            },
 5514|       |            egui::Event::Key {
 5515|       |                key: egui::Key::O,
 5516|       |                physical_key: None,
 5517|       |                pressed: true,
 5518|       |                repeat: false,
 5519|       |                modifiers: egui::Modifiers::ALT,
 5520|       |            },
 5521|       |        ]);
 5522|       |
 5523|       |        let ctx = egui::Context::default();
 5524|       |        let _ = ctx.run(input, |ctx| {
 5525|       |            app.handle_shortcuts(ctx);
 5526|       |        });
 5527|       |
 5528|       |        assert_eq!(app.current_file, Some(open_path));
 5529|       |        Ok(())
 5530|       |    }
 5531|       |
 5532|       |    #[test]
 5533|       |    fn test_handle_shortcuts_close_accelerators() {
 5534|       |        let mut app = MarkdownViewerApp::new();
 5535|       |        app.current_file = Some(PathBuf::from("dummy.md"));
 5536|       |        app.current_content = "# Dummy".to_string();
 5537|       |
 5538|       |        let mut input = default_input();
 5539|       |        input.events.extend([
 5540|       |            egui::Event::Key {
 5541|       |                key: egui::Key::W,
 5542|       |                physical_key: None,
 5543|       |                pressed: true,
 5544|       |                repeat: false,
 5545|       |                modifiers: egui::Modifiers::ALT,
 5546|       |            },
 5547|       |            egui::Event::Key {
 5548|       |                key: egui::Key::W,
 5549|       |                physical_key: None,
 5550|       |                pressed: true,
 5551|       |                repeat: false,
 5552|       |                modifiers: egui::Modifiers::CTRL,
 5553|       |            },
 5554|       |            egui::Event::Key {
 5555|       |                key: egui::Key::Q,
 5556|       |                physical_key: None,
 5557|       |                pressed: true,
 5558|       |                repeat: false,
 5559|       |                modifiers: egui::Modifiers::ALT,
 5560|       |            },
 5561|       |            egui::Event::Key {
 5562|       |                key: egui::Key::Q,
 5563|       |                physical_key: None,
 5564|       |                pressed: true,
 5565|       |                repeat: false,
 5566|       |                modifiers: egui::Modifiers::CTRL,
 5567|       |            },
 5568|       |        ]);
 5569|       |
 5570|       |        let ctx = egui::Context::default();
 5571|       |        let _ = ctx.run(input, |ctx| {
 5572|       |            app.handle_shortcuts(ctx);
 5573|       |        });
 5574|       |
 5575|       |        assert!(app.current_file.is_none());
 5576|       |    }
 5577|       |
 5578|       |    #[test]
 5579|       |    fn test_handle_shortcuts_ctrl_save() -> Result<()> {
 5580|       |        let mut app = MarkdownViewerApp::new();
 5581|       |        let temp_dir = tempfile::TempDir::new()?;
 5582|       |        let file_path = temp_dir.path().join("save.md");
 5583|       |        app.current_file = Some(file_path.clone());
 5584|       |        app.current_content = "Saved".to_string();
 5585|       |
 5586|       |        let mut input = default_input();
 5587|       |        input.events.push(egui::Event::Key {
 5588|       |            key: egui::Key::S,
 5589|       |            physical_key: None,
 5590|       |            pressed: true,
 5591|       |            repeat: false,
 5592|       |            modifiers: egui::Modifiers::CTRL,
 5593|       |        });
 5594|       |
 5595|       |        let ctx = egui::Context::default();
 5596|       |        let _ = ctx.run(input, |ctx| {
 5597|       |            app.handle_shortcuts(ctx);
 5598|       |        });
 5599|       |
 5600|       |        let saved = std::fs::read_to_string(&file_path)?;
 5601|       |        assert_eq!(saved, "Saved");
 5602|       |        Ok(())
 5603|       |    }
 5604|       |
 5605|       |    #[test]
 5606|       |    fn test_compute_window_adjustment_clamps() {
 5607|       |        let outer = egui::Rect::from_min_size(egui::pos2(-100.0, -100.0), egui::vec2(200.0, 100.0));
 5608|       |        let monitor = egui::vec2(800.0, 600.0);
 5609|       |        let adjusted =
 5610|       |            MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), Some(monitor));
 5611|       |        assert!(adjusted.is_some());
 5612|       |
 5613|       |        let outer_ok = egui::Rect::from_min_size(egui::pos2(10.0, 10.0), egui::vec2(800.0, 600.0));
 5614|       |        let unchanged = MarkdownViewerApp::compute_window_adjustment(
 5615|       |            Some(outer_ok),
 5616|       |            Some(outer_ok),
 5617|       |            Some(monitor),
 5618|       |        );
 5619|       |        assert!(unchanged.is_none());
 5620|       |    }
 5621|       |
 5622|       |    #[test]
 5623|       |    fn test_persist_window_state_updates_cache() {
 5624|       |        let _lock = env_lock();
 5625|       |        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 5626|       |        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());
 5627|       |        let mut app = MarkdownViewerApp::new();
 5628|       |        app.last_window_pos = Some([10.0, 20.0]);
 5629|       |        app.last_window_size = Some([800.0, 600.0]);
 5630|       |        app.last_window_maximized = true;
 5631|       |
 5632|       |        app.persist_window_state();
 5633|       |
 5634|       |        assert!(app.last_persisted_state.is_some());
 5635|       |    }
 5636|       |
 5637|       |    #[test]
 5638|       |    fn test_render_actions_trigger_menu_and_context() {
 5639|       |        let mut app = MarkdownViewerApp::new();
 5640|       |        app.current_content = "Hello".to_string();
 5641|       |        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5642|       |            "Hello".to_string(),
 5643|       |        )])];
 5644|       |        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 5645|       |        let open_path = temp_dir.path().join("open.md");
 5646|       |        std::fs::write(&open_path, "# Open").expect("write");
 5647|       |        let save_path = temp_dir.path().join("save.md");
 5648|       |        let _forced = ForcedDialogPaths::new(Some(open_path), Some(save_path));
 5649|       |        let _actions = ForcedAppActions::new(&[
 5650|       |            "menu_open",
 5651|       |            "menu_save",
 5652|       |            "menu_close",
 5653|       |            "menu_reload",
 5654|       |            "menu_find",
 5655|       |            "menu_samples",
 5656|       |            "menu_bar_file",
 5657|       |            "menu_bar_view",
 5658|       |            "menu_bar_help",
 5659|       |            "menu_help_usage",
 5660|       |            "menu_help_about",
 5661|       |            "menu_back",
 5662|       |            "menu_forward",
 5663|       |            "menu_raw",
 5664|       |            "menu_write",
 5665|       |            "menu_wrap_raw",
 5666|       |            "menu_zoom_in",
 5667|       |            "menu_zoom_out",
 5668|       |            "menu_zoom_reset",
 5669|       |            "menu_fullscreen",
 5670|       |            "ctx_copy_all",
 5671|       |            "ctx_copy_markdown",
 5672|       |            "ctx_nav_top",
 5673|       |            "ctx_nav_bottom",
 5674|       |            "search_next",
 5675|       |            "search_prev",
 5676|       |            "search_close",
 5677|       |            "status_hover",
 5678|       |            "welcome_open",
 5679|       |            "welcome.md",
 5680|       |            "usage.md",
 5681|       |        ]);
 5682|       |
 5683|       |        let ctx = egui::Context::default();
 5684|       |        let _ = ctx.run(default_input(), |ctx| {
 5685|       |            CentralPanel::default().show(ctx, |ui| {
 5686|       |                app.render_file_menu_contents(ui, false, Color32::WHITE);
 5687|       |                app.render_view_menu_contents(ui, ctx, false, Color32::WHITE);
 5688|       |                app.render_help_menu_contents(ui, false, Color32::WHITE);
 5689|       |                app.render_main_context_menu(ui);
 5690|       |            });
 5691|       |            app.show_search = true;
 5692|       |            app.render_search_dialog(ctx);
 5693|       |            app.render_menu_bar(ctx);
 5694|       |            app.render_status_bar(ctx);
 5695|       |        });
 5696|       |    }
 5697|       |
 5698|       |    #[test]
 5699|       |    fn test_render_search_dialog_stays_open() {
 5700|       |        let mut app = MarkdownViewerApp::new();
 5701|       |        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5702|       |            "Alpha".to_string(),
 5703|       |        )])];
 5704|       |        app.show_search = true;
 5705|       |        app.search_query = "Alpha".to_string();
 5706|       |
 5707|       |        let ctx = egui::Context::default();
 5708|       |        let _ = ctx.run(default_input(), |ctx| {
 5709|       |            app.render_search_dialog(ctx);
 5710|       |        });
 5711|       |
 5712|       |        assert!(app.show_search);
 5713|       |        assert_eq!(app.search_query, "Alpha");
 5714|       |    }
 5715|       |
 5716|       |    #[test]
 5717|       |    fn test_render_search_dialog_close_clears_state() {
 5718|       |        let mut app = MarkdownViewerApp::new();
 5719|       |        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5720|       |            "Alpha".to_string(),
 5721|       |        )])];
 5722|       |        app.show_search = true;
 5723|       |        app.search_query = "Alpha".to_string();
 5724|       |        app.last_query = "Alpha".to_string();
 5725|       |        app.last_match_index = Some(0);
 5726|       |        app.pending_scroll_to_element = Some(1);
 5727|       |        let _actions = ForcedAppActions::new(&["search_close"]);
 5728|       |
 5729|       |        let ctx = egui::Context::default();
 5730|       |        let _ = ctx.run(default_input(), |ctx| {
 5731|       |            app.render_search_dialog(ctx);
 5732|       |        });
 5733|       |
 5734|       |        assert!(!app.show_search);
 5735|       |        assert!(app.search_query.is_empty());
 5736|       |        assert!(app.last_query.is_empty());
 5737|       |        assert!(app.last_match_index.is_none());
 5738|       |        assert!(app.pending_scroll_to_element.is_none());
 5739|       |    }
 5740|       |
 5741|       |    #[test]
 5742|       |    fn test_render_search_dialog_submitted_next_on_enter() {
 5743|       |        let mut app = MarkdownViewerApp::new();
 5744|       |        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5745|       |            "Alpha".to_string(),
 5746|       |        )])];
 5747|       |        app.show_search = true;
 5748|       |        app.search_query = "Alpha".to_string();
 5749|       |        app.search_focus_requested = true;
 5750|       |
 5751|       |        let ctx = egui::Context::default();
 5752|       |        let _ = ctx.run(default_input(), |ctx| {
 5753|       |            app.render_search_dialog(ctx);
 5754|       |        });
 5755|       |
 5756|       |        let mut input = default_input();
 5757|       |        input.events.push(egui::Event::Key {
 5758|       |            key: egui::Key::Enter,
 5759|       |            physical_key: None,
 5760|       |            pressed: true,
 5761|       |            repeat: false,
 5762|       |            modifiers: egui::Modifiers::NONE,
 5763|       |        });
 5764|       |        let _ = ctx.run(input, |ctx| {
 5765|       |            app.render_search_dialog(ctx);
 5766|       |        });
 5767|       |
 5768|       |        assert!(app.last_match_index.is_some());
 5769|       |    }
 5770|       |
 5771|       |    #[test]
 5772|       |    fn test_should_submit_search_requires_focus_and_enter() {
 5773|       |        assert!(MarkdownViewerApp::should_submit_search(true, true));
 5774|       |        assert!(!MarkdownViewerApp::should_submit_search(false, true));
 5775|       |        assert!(!MarkdownViewerApp::should_submit_search(true, false));
 5776|       |    }
 5777|       |
 5778|       |    #[test]
 5779|       |    fn test_render_main_context_menu_no_actions() {
 5780|       |        let mut app = MarkdownViewerApp::new();
 5781|       |        app.current_content = "Hello".to_string();
 5782|       |        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5783|       |            "Hello".to_string(),
 5784|       |        )])];
 5785|       |
 5786|       |        let ctx = egui::Context::default();
 5787|       |        let _ = ctx.run(default_input(), |ctx| {
 5788|       |            CentralPanel::default().show(ctx, |ui| {
 5789|       |                app.render_main_context_menu(ui);
 5790|       |            });
 5791|       |        });
 5792|       |
 5793|       |        assert!(app.nav_request.is_none());
 5794|       |    }
 5795|       |
 5796|       |    #[test]
 5797|       |    fn test_render_menu_bar_light_mode() {
 5798|       |        let mut app = MarkdownViewerApp::new();
 5799|       |        let ctx = egui::Context::default();
 5800|       |        ctx.set_visuals(egui::Visuals::light());
 5801|       |
 5802|       |        let _ = ctx.run(default_input(), |ctx| {
 5803|       |            app.render_menu_bar(ctx);
 5804|       |        });
 5805|       |    }
 5806|       |
 5807|       |    #[test]
 5808|       |    fn test_handle_file_drop_empty_and_missing() {
 5809|       |        let mut app = MarkdownViewerApp::new();
 5810|       |        app.handle_file_drop(Vec::new());
 5811|       |
 5812|       |        app.handle_file_drop(vec![PathBuf::from("missing.md")]);
 5813|       |        assert!(app
 5814|       |            .error_message
 5815|       |            .as_ref()
 5816|       |            .is_some_and(|msg| msg.contains("File not found")));
 5817|       |    }
 5818|       |
 5819|       |    #[test]
 5820|       |    fn test_handle_file_drop_scan_error() -> Result<()> {
 5821|       |        let mut app = MarkdownViewerApp::new();
 5822|       |        let temp_dir = tempfile::TempDir::new()?;
 5823|       |        let _forced = ForcedScanError::new();
 5824|       |
 5825|       |        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 5826|       |
 5827|       |        assert!(app.error_message.is_some());
 5828|       |        Ok(())
 5829|       |    }
 5830|       |
 5831|       |    #[test]
 5832|       |    fn test_handle_file_drop_load_failure() -> Result<()> {
 5833|       |        let mut app = MarkdownViewerApp::new();
 5834|       |        let temp_dir = tempfile::TempDir::new()?;
 5835|       |        let file_path = temp_dir.path().join("fail.md");
 5836|       |        std::fs::write(&file_path, "# Fail")?;
 5837|       |        let _forced = ForcedLoadError::new();
 5838|       |
 5839|       |        app.handle_file_drop(vec![file_path]);
 5840|       |
 5841|       |        assert!(app
 5842|       |            .error_message
 5843|       |            .as_ref()
 5844|       |            .is_some_and(|msg| msg.contains("Failed to load file")));
 5845|       |        Ok(())
 5846|       |    }
 5847|       |
 5848|       |    #[test]
 5849|       |    fn test_handle_shortcuts_ctrl_f_sets_match_index() {
 5850|       |        let mut app = MarkdownViewerApp::new();
 5851|       |        app.last_match_index = None;
 5852|       |
 5853|       |        let mut input = default_input();
 5854|       |        input.events.push(egui::Event::Key {
 5855|       |            key: egui::Key::F,
 5856|       |            physical_key: None,
 5857|       |            pressed: true,
 5858|       |            repeat: false,
 5859|       |            modifiers: egui::Modifiers::CTRL,
 5860|       |        });
 5861|       |
 5862|       |        let ctx = egui::Context::default();
 5863|       |        let _ = ctx.run(input, |ctx| {
 5864|       |            app.handle_shortcuts(ctx);
 5865|       |        });
 5866|       |
 5867|       |        assert_eq!(app.last_match_index, Some(0));
 5868|       |    }
 5869|       |
 5870|       |    #[test]
 5871|       |    fn test_handle_shortcuts_ctrl_f_preserves_match_index() {
 5872|       |        let mut app = MarkdownViewerApp::new();
 5873|       |        app.last_match_index = Some(2);
 5874|       |
 5875|       |        let mut input = default_input();
 5876|       |        input.events.push(egui::Event::Key {
 5877|       |            key: egui::Key::F,
 5878|       |            physical_key: None,
 5879|       |            pressed: true,
 5880|       |            repeat: false,
 5881|       |            modifiers: egui::Modifiers::CTRL,
 5882|       |        });
 5883|       |
 5884|       |        let ctx = egui::Context::default();
 5885|       |        let _ = ctx.run(input, |ctx| {
 5886|       |            app.handle_shortcuts(ctx);
 5887|       |        });
 5888|       |
 5889|       |        assert_eq!(app.last_match_index, Some(2));
 5890|       |    }
 5891|       |
 5892|       |    #[test]
 5893|       |    fn test_handle_shortcuts_ctrl_mouse_wheel_zoom_directions() {
 5894|       |        let mut app = MarkdownViewerApp::new();
 5895|       |        let ctx = egui::Context::default();
 5896|       |
 5897|       |        let mut input = default_input();
 5898|       |        input.modifiers = egui::Modifiers::CTRL;
 5899|       |        input.events.push(egui::Event::MouseWheel {
 5900|       |            unit: egui::MouseWheelUnit::Point,
 5901|       |            delta: egui::vec2(0.0, 20.0),
 5902|       |            modifiers: egui::Modifiers::CTRL,
 5903|       |        });
 5904|       |        let _ = ctx.run(input, |ctx| {
 5905|       |            app.handle_shortcuts(ctx);
 5906|       |        });
 5907|       |
 5908|       |        let mut input = default_input();
 5909|       |        input.modifiers = egui::Modifiers::CTRL;
 5910|       |        input.events.push(egui::Event::MouseWheel {
 5911|       |            unit: egui::MouseWheelUnit::Point,
 5912|       |            delta: egui::vec2(0.0, -20.0),
 5913|       |            modifiers: egui::Modifiers::CTRL,
 5914|       |        });
 5915|       |        let _ = ctx.run(input, |ctx| {
 5916|       |            app.handle_shortcuts(ctx);
 5917|       |        });
 5918|       |    }
 5919|       |
 5920|       |    #[test]
 5921|       |    fn test_handle_shortcuts_ctrl_mouse_wheel_without_events() {
 5922|       |        let mut app = MarkdownViewerApp::new();
 5923|       |        let ctx = egui::Context::default();
 5924|       |        let mut input = default_input();
 5925|       |        input.modifiers = egui::Modifiers::CTRL;
 5926|       |        let _ = ctx.run(input, |ctx| {
 5927|       |            app.handle_shortcuts(ctx);
 5928|       |        });
 5929|       |    }
 5930|       |
 5931|       |    #[test]
 5932|       |    fn test_handle_shortcuts_ctrl_save_error() {
 5933|       |        let mut app = MarkdownViewerApp::new();
 5934|       |        app.current_file = Some(PathBuf::from("missing_dir\\save.md"));
 5935|       |        app.current_content = "Data".to_string();
 5936|       |
 5937|       |        let mut input = default_input();
 5938|       |        input.events.push(egui::Event::Key {
 5939|       |            key: egui::Key::S,
 5940|       |            physical_key: None,
 5941|       |            pressed: true,
 5942|       |            repeat: false,
 5943|       |            modifiers: egui::Modifiers::CTRL,
 5944|       |        });
 5945|       |
 5946|       |        let ctx = egui::Context::default();
 5947|       |        let _ = ctx.run(input, |ctx| {
 5948|       |            app.handle_shortcuts(ctx);
 5949|       |        });
 5950|       |
 5951|       |        assert!(app.error_message.is_some());
 5952|       |    }
 5953|       |
 5954|       |    #[test]
 5955|       |    fn test_move_raw_cursor_lines_edge_cases() {
 5956|       |        let mut app = MarkdownViewerApp::new();
 5957|       |        app.raw_buffer = "Line 1\nLine 2\nLine 3\nLine 4".to_string();
 5958|       |        app.current_content = app.raw_buffer.clone();
 5959|       |
 5960|       |        let ctx = egui::Context::default();
 5961|       |        app.move_raw_cursor_lines(&ctx, 1);
 5962|       |
 5963|       |        app.view_mode = ViewMode::Raw;
 5964|       |        app.write_enabled = true;
 5965|       |        let editor_id = egui::Id::new("raw_editor");
 5966|       |        let mut state = egui::text_edit::TextEditState::default();
 5967|       |        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(3));
 5968|       |        state.cursor.set_char_range(Some(cr));
 5969|       |        state.store(&ctx, editor_id);
 5970|       |
 5971|       |        app.move_raw_cursor_lines(&ctx, 0);
 5972|       |        app.move_raw_cursor_lines(&ctx, 2);
 5973|       |        app.move_raw_cursor_lines(&ctx, -2);
 5974|       |    }
 5975|       |
 5976|       |    #[test]
 5977|       |    fn test_render_status_bar_no_file_and_tooltip() {
 5978|       |        let mut app = MarkdownViewerApp::new();
 5979|       |        app.current_file = None;
 5980|       |        app.parsed_elements.clear();
 5981|       |
 5982|       |        let _actions = ForcedAppActions::new(&["status_hover"]);
 5983|       |        let ctx = egui::Context::default();
 5984|       |        let _ = ctx.run(default_input(), |ctx| {
 5985|       |            app.render_status_bar(ctx);
 5986|       |        });
 5987|       |    }
 5988|       |
 5989|       |    #[test]
 5990|       |    fn test_render_status_bar_table_stats() {
 5991|       |        let mut app = MarkdownViewerApp::new();
 5992|       |        app.current_file = None;
 5993|       |        app.parsed_elements = vec![MarkdownElement::Table {
 5994|       |            headers: vec![vec![InlineSpan::Text("H".to_string())]],
 5995|       |            rows: vec![vec![vec![InlineSpan::Text("C".to_string())]]],
 5996|       |            alignments: vec![pulldown_cmark::Alignment::Left],
 5997|       |        }];
 5998|       |
 5999|       |        let ctx = egui::Context::default();
 6000|       |        let _ = ctx.run(default_input(), |ctx| {
 6001|       |            CentralPanel::default().show(ctx, |ui| {
 6002|       |                app.renderer.render_to_ui(ui, &app.parsed_elements);
 6003|       |            });
 6004|       |            app.render_status_bar(ctx);
 6005|       |        });
 6006|       |    }
 6007|       |
 6008|       |    #[test]
 6009|       |    fn test_render_status_bar_pending_load_and_queue() {
 6010|       |        let mut app = MarkdownViewerApp::new();
 6011|       |        app.pending_file_load = Some(PendingFileLoad {
 6012|       |            id: 1,
 6013|       |            path: PathBuf::from("pending.md"),
 6014|       |        });
 6015|       |        app.pending_files.push_back(PathBuf::from("queued.md"));
 6016|       |
 6017|       |        let ctx = egui::Context::default();
 6018|       |        let _ = ctx.run(default_input(), |ctx| {
 6019|       |            app.render_status_bar(ctx);
 6020|       |        });
 6021|       |    }
 6022|       |
 6023|       |    #[test]
 6024|       |    fn test_update_impl_welcome_open_button() -> Result<()> {
 6025|       |        let mut app = MarkdownViewerApp::new();
 6026|       |        app.parsed_elements.clear();
 6027|       |        app.current_content.clear();
 6028|       |        app.error_message = None;
 6029|       |
 6030|       |        let temp_dir = tempfile::TempDir::new()?;
 6031|       |        let file_path = temp_dir.path().join("welcome.md");
 6032|       |        std::fs::write(&file_path, "# Welcome")?;
 6033|       |        let _forced = ForcedDialogPaths::new(Some(file_path.clone()), None);
 6034|       |        let _actions = ForcedAppActions::new(&["welcome_open"]);
 6035|       |
 6036|       |        let ctx = egui::Context::default();
 6037|       |        run_app_frame(&mut app, &ctx, default_input());
 6038|       |
 6039|       |        assert_eq!(app.current_file, Some(file_path));
 6040|       |        Ok(())
 6041|       |    }
 6042|       |
 6043|       |    #[test]
 6044|       |    fn test_update_impl_welcome_screen_no_open() {
 6045|       |        let mut app = MarkdownViewerApp::new();
 6046|       |        app.parsed_elements.clear();
 6047|       |        app.current_content.clear();
 6048|       |        app.error_message = None;
 6049|       |
 6050|       |        let ctx = egui::Context::default();
 6051|       |        run_app_frame(&mut app, &ctx, default_input());
 6052|       |
 6053|       |        assert!(app.current_file.is_none());
 6054|       |    }
 6055|       |
 6056|       |    #[test]
 6057|       |    fn test_update_impl_welcome_screen_with_error_message() {
 6058|       |        let mut app = MarkdownViewerApp::new();
 6059|       |        app.parsed_elements.clear();
 6060|       |        app.current_content.clear();
 6061|       |        app.error_message = Some("Load failed".to_string());
 6062|       |
 6063|       |        let ctx = egui::Context::default();
 6064|       |        run_app_frame(&mut app, &ctx, default_input());
 6065|       |
 6066|       |        assert!(app.error_message.is_some());
 6067|       |    }
 6068|       |
 6069|       |    #[test]
 6070|       |    fn test_update_impl_navigation_requests() {
 6071|       |        let mut app = MarkdownViewerApp::new();
 6072|       |        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6073|       |            "Nav".to_string(),
 6074|       |        )])];
 6075|       |        let ctx = egui::Context::default();
 6076|       |        let input = default_input();
 6077|       |        let navs = [
 6078|       |            NavigationRequest::Top,
 6079|       |            NavigationRequest::Bottom,
 6080|       |            NavigationRequest::PageUp,
 6081|       |            NavigationRequest::PageDown,
 6082|       |            NavigationRequest::ScrollUp,
 6083|       |            NavigationRequest::ScrollDown,
 6084|       |        ];
 6085|       |        for nav in navs {
 6086|       |            app.nav_request = Some(nav);
 6087|       |            run_app_frame(&mut app, &ctx, input.clone());
 6088|       |        }
 6089|       |    }
 6090|       |
 6091|       |    #[test]
 6092|       |    fn test_update_impl_anchor_and_search_highlight() {
 6093|       |        let mut app = MarkdownViewerApp::new();
 6094|       |        app.parsed_elements = vec![MarkdownElement::Header {
 6095|       |            level: 1,
 6096|       |            spans: vec![InlineSpan::Text("Section".to_string())],
 6097|       |            id: "section".to_string(),
 6098|       |        }];
 6099|       |        app.current_content = "# Section".to_string();
 6100|       |        app.show_search = true;
 6101|       |        app.search_query = "Section".to_string();
 6102|       |        app.pending_scroll_to_element = Some(0);
 6103|       |        app.renderer.trigger_link("#section");
 6104|       |
 6105|       |        let ctx = egui::Context::default();
 6106|       |        run_app_frame(&mut app, &ctx, default_input());
 6107|       |
 6108|       |        app.show_search = false;
 6109|       |        app.search_query.clear();
 6110|       |        app.last_query = "Section".to_string();
 6111|       |        run_app_frame(&mut app, &ctx, default_input());
 6112|       |    }
 6113|       |
 6114|       |    #[test]
 6115|       |    fn test_update_impl_search_highlight_empty_query_prefers_last() {
 6116|       |        let mut app = MarkdownViewerApp::new();
 6117|       |        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6118|       |            "Find me".to_string(),
 6119|       |        )])];
 6120|       |        app.current_content = "Find me".to_string();
 6121|       |        app.show_search = true;
 6122|       |        app.search_query.clear();
 6123|       |        app.last_query = "Find".to_string();
 6124|       |
 6125|       |        let ctx = egui::Context::default();
 6126|       |        run_app_frame(&mut app, &ctx, default_input());
 6127|       |    }
 6128|       |
 6129|       |    #[test]
 6130|       |    fn test_update_impl_missing_anchor_and_scroll_target() {
 6131|       |        let mut app = MarkdownViewerApp::new();
 6132|       |        app.parsed_elements = vec![MarkdownElement::Header {
 6133|       |            level: 1,
 6134|       |            spans: vec![InlineSpan::Text("Known".to_string())],
 6135|       |            id: "known".to_string(),
 6136|       |        }];
 6137|       |        app.current_content = "# Known".to_string();
 6138|       |        app.renderer.trigger_link("#missing");
 6139|       |        app.pending_scroll_to_element = Some(99);
 6140|       |
 6141|       |        let ctx = egui::Context::default();
 6142|       |        run_app_frame(&mut app, &ctx, default_input());
 6143|       |
 6144|       |        assert!(app.pending_scroll_to_element.is_none());
 6145|       |    }
 6146|       |
 6147|       |    #[test]
 6148|       |    fn test_update_impl_raw_cursor_restore_without_state() {
 6149|       |        let mut app = MarkdownViewerApp::new();
 6150|       |        app.view_mode = ViewMode::Raw;
 6151|       |        app.write_enabled = true;
 6152|       |        app.raw_buffer = "Line 1\nLine 2".to_string();
 6153|       |        app.current_content = app.raw_buffer.clone();
 6154|       |        app.raw_cursor = Some(3);
 6155|       |
 6156|       |        let ctx = egui::Context::default();
 6157|       |        run_app_frame(&mut app, &ctx, default_input());
 6158|       |    }
 6159|       |
 6160|       |    #[test]
 6161|       |    fn test_update_impl_raw_cursor_without_char_range() {
 6162|       |        let mut app = MarkdownViewerApp::new();
 6163|       |        app.view_mode = ViewMode::Raw;
 6164|       |        app.write_enabled = true;
 6165|       |        app.raw_buffer = "Line".to_string();
 6166|       |        app.current_content = app.raw_buffer.clone();
 6167|       |
 6168|       |        let ctx = egui::Context::default();
 6169|       |        let editor_id = egui::Id::new("raw_editor");
 6170|       |        let mut state = egui::text_edit::TextEditState::default();
 6171|       |        state.cursor.set_char_range(None);
 6172|       |        state.store(&ctx, editor_id);
 6173|       |
 6174|       |        run_app_frame(&mut app, &ctx, default_input());
 6175|       |
 6176|       |        assert!(app.raw_cursor.is_none());
 6177|       |    }
 6178|       |
 6179|       |    #[test]
 6180|       |    fn test_update_impl_raw_edit_updates_content() {
 6181|       |        let mut app = MarkdownViewerApp::new();
 6182|       |        app.view_mode = ViewMode::Raw;
 6183|       |        app.write_enabled = true;
 6184|       |        app.raw_focus_requested = true;
 6185|       |        app.raw_buffer = "Line".to_string();
 6186|       |        app.current_content = app.raw_buffer.clone();
 6187|       |
 6188|       |        let ctx = egui::Context::default();
 6189|       |        let mut input = default_input();
 6190|       |        input.focused = true;
 6191|       |        run_app_frame(&mut app, &ctx, input);
 6192|       |
 6193|       |        let mut input = default_input();
 6194|       |        input.focused = true;
 6195|       |        input.events.push(egui::Event::Text("X".to_string()));
 6196|       |        run_app_frame(&mut app, &ctx, input);
 6197|       |
 6198|       |        assert!(app.current_content.contains('X'));
 6199|       |    }
 6200|       |
 6201|       |    #[test]
 6202|       |    fn test_update_impl_raw_edit_parse_error_sets_message() {
 6203|       |        let mut app = MarkdownViewerApp::new();
 6204|       |        app.view_mode = ViewMode::Raw;
 6205|       |        app.write_enabled = true;
 6206|       |        app.raw_focus_requested = true;
 6207|       |        app.raw_buffer = "Line".to_string();
 6208|       |        app.current_content = app.raw_buffer.clone();
 6209|       |        crate::markdown_renderer::force_parse_error_once();
 6210|       |
 6211|       |        let ctx = egui::Context::default();
 6212|       |        let mut input = default_input();
 6213|       |        input.focused = true;
 6214|       |        run_app_frame(&mut app, &ctx, input);
 6215|       |
 6216|       |        let mut input = default_input();
 6217|       |        input.focused = true;
 6218|       |        input.events.push(egui::Event::Text("X".to_string()));
 6219|       |        run_app_frame(&mut app, &ctx, input);
 6220|       |
 6221|       |        assert!(app.error_message.is_some());
 6222|       |    }
 6223|       |
 6224|       |    #[test]
 6225|       |    fn test_update_impl_screenshot_scroll_offset() {
 6226|       |        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 6227|       |        let config = ScreenshotConfig {
 6228|       |            output_path: temp_dir.path().join("shot.png"),
 6229|       |            viewport_width: 80.0,
 6230|       |            viewport_height: 60.0,
 6231|       |            content_only: false,
 6232|       |            scroll_ratio: None,
 6233|       |            wait_ms: 0,
 6234|       |            settle_frames: 0,
 6235|       |            zoom: 1.0,
 6236|       |            theme: ScreenshotTheme::Light,
 6237|       |            font_source: None,
 6238|       |        };
 6239|       |        let mut app = MarkdownViewerApp::new();
 6240|       |        app.screenshot = Some(ScreenshotState::new(config));
 6241|       |        let state = app.screenshot.as_mut().expect("screenshot state");
 6242|       |        state.scroll_offset = Some(10.0);
 6243|       |
 6244|       |        let ctx = egui::Context::default();
 6245|       |        run_app_frame(&mut app, &ctx, default_input());
 6246|       |    }
 6247|       |
 6248|       |    #[test]
 6249|       |    fn test_save_screenshot_image_creates_parent_dir() -> Result<()> {
 6250|       |        let temp_dir = tempfile::TempDir::new()?;
 6251|       |        let nested = temp_dir.path().join("nested").join("shot.png");
 6252|       |        let config = ScreenshotConfig {
 6253|       |            output_path: nested.clone(),
 6254|       |            viewport_width: 40.0,
 6255|       |            viewport_height: 30.0,
 6256|       |            content_only: false,
 6257|       |            scroll_ratio: None,
 6258|       |            wait_ms: 0,
 6259|       |            settle_frames: 0,
 6260|       |            zoom: 1.0,
 6261|       |            theme: ScreenshotTheme::Light,
 6262|       |            font_source: None,
 6263|       |        };
 6264|       |        let snapshot = ScreenshotSnapshot {
 6265|       |            config,
 6266|       |            content_rect: None,
 6267|       |            pixels_per_point: 1.0,
 6268|       |            stable_frames: 0,
 6269|       |            timed_out: false,
 6270|       |            pending_renders: false,
 6271|       |            last_scroll_offset: None,
 6272|       |            started: Instant::now(),
 6273|       |        };
 6274|       |        let image = egui::ColorImage::new([40, 30], Color32::WHITE);
 6275|       |        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
 6276|       |        assert!(nested.exists());
 6277|       |        assert!(nested.with_extension("json").exists());
 6278|       |        Ok(())
 6279|       |    }
 6280|       |
 6281|       |    #[test]
 6282|       |    fn test_save_screenshot_image_parent_dir_error() -> Result<()> {
 6283|       |        let temp_dir = tempfile::TempDir::new()?;
 6284|       |        let parent_file = temp_dir.path().join("parent_file");
 6285|       |        std::fs::write(&parent_file, "data")?;
 6286|       |        let output_path = parent_file.join("shot.png");
 6287|       |        let config = ScreenshotConfig {
 6288|       |            output_path,
 6289|       |            viewport_width: 40.0,
 6290|       |            viewport_height: 30.0,
 6291|       |            content_only: false,
 6292|       |            scroll_ratio: None,
 6293|       |            wait_ms: 0,
 6294|       |            settle_frames: 0,
 6295|       |            zoom: 1.0,
 6296|       |            theme: ScreenshotTheme::Light,
 6297|       |            font_source: None,
 6298|       |        };
 6299|       |        let snapshot = ScreenshotSnapshot {
 6300|       |            config,
 6301|       |            content_rect: None,
 6302|       |            pixels_per_point: 1.0,
 6303|       |            stable_frames: 0,
 6304|       |            timed_out: false,
 6305|       |            pending_renders: false,
 6306|       |            last_scroll_offset: None,
 6307|       |            started: Instant::now(),
 6308|       |        };
 6309|       |        let image = egui::ColorImage::new([40, 30], Color32::WHITE);
 6310|       |        assert!(MarkdownViewerApp::save_screenshot_image(&image, &snapshot).is_err());
 6311|       |        Ok(())
 6312|       |    }
 6313|       |
 6314|       |    #[test]
 6315|       |    fn test_save_screenshot_image_metadata_write_error() -> Result<()> {
 6316|       |        let temp_dir = tempfile::TempDir::new()?;
 6317|       |        let output_path = temp_dir.path().join("shot.png");
 6318|       |        std::fs::create_dir(output_path.with_extension("json"))?;
 6319|       |        let config = ScreenshotConfig {
 6320|       |            output_path: output_path.clone(),
 6321|       |            viewport_width: 40.0,
 6322|       |            viewport_height: 30.0,
 6323|       |            content_only: false,
 6324|       |            scroll_ratio: None,
 6325|       |            wait_ms: 0,
 6326|       |            settle_frames: 0,
 6327|       |            zoom: 1.0,
 6328|       |            theme: ScreenshotTheme::Light,
 6329|       |            font_source: None,
 6330|       |        };
 6331|       |        let snapshot = ScreenshotSnapshot {
 6332|       |            config,
 6333|       |            content_rect: None,
 6334|       |            pixels_per_point: 1.0,
 6335|       |            stable_frames: 0,
 6336|       |            timed_out: false,
 6337|       |            pending_renders: false,
 6338|       |            last_scroll_offset: None,
 6339|       |            started: Instant::now(),
 6340|       |        };
 6341|       |        let image = egui::ColorImage::new([40, 30], Color32::WHITE);
 6342|       |        assert!(MarkdownViewerApp::save_screenshot_image(&image, &snapshot).is_err());
 6343|       |        assert!(output_path.exists());
 6344|       |        Ok(())
 6345|       |    }
 6346|       |
 6347|       |    #[test]
 6348|       |    fn test_handle_screenshot_events_branches() {
 6349|       |        let mut app = MarkdownViewerApp::new();
 6350|       |        let ctx = egui::Context::default();
 6351|       |
 6352|       |        let mut input = default_input();
 6353|       |        input.events.push(egui::Event::Key {
 6354|       |            key: egui::Key::A,
 6355|       |            physical_key: None,
 6356|       |            pressed: true,
 6357|       |            repeat: false,
 6358|       |            modifiers: egui::Modifiers::NONE,
 6359|       |        });
 6360|       |        let _ = ctx.run(input, |ctx| {
 6361|       |            app.handle_screenshot_events(ctx);
 6362|       |        });
 6363|       |
 6364|       |        let image = egui::ColorImage::new([10, 10], Color32::WHITE);
 6365|       |        let mut input = default_input();
 6366|       |        input.events.push(egui::Event::Screenshot {
 6367|       |            viewport_id: egui::ViewportId::ROOT,
 6368|       |            image: std::sync::Arc::new(image),
 6369|       |        });
 6370|       |        let _ = ctx.run(input, |ctx| {
 6371|       |            app.handle_screenshot_events(ctx);
 6372|       |        });
 6373|       |
 6374|       |        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 6375|       |        let config = ScreenshotConfig {
 6376|       |            output_path: temp_dir.path().to_path_buf(),
 6377|       |            viewport_width: 40.0,
 6378|       |            viewport_height: 30.0,
 6379|       |            content_only: false,
 6380|       |            scroll_ratio: None,
 6381|       |            wait_ms: 0,
 6382|       |            settle_frames: 0,
 6383|       |            zoom: 1.0,
 6384|       |            theme: ScreenshotTheme::Light,
 6385|       |            font_source: None,
 6386|       |        };
 6387|       |        app.screenshot = Some(ScreenshotState::new(config));
 6388|       |        let state = app.screenshot.as_mut().expect("screenshot state");
 6389|       |        state.done = true;
 6390|       |        let image = egui::ColorImage::new([10, 10], Color32::WHITE);
 6391|       |        let mut input = default_input();
 6392|       |        input.events.push(egui::Event::Screenshot {
 6393|       |            viewport_id: egui::ViewportId::ROOT,
 6394|       |            image: std::sync::Arc::new(image),
 6395|       |        });
 6396|       |        let _ = ctx.run(input, |ctx| {
 6397|       |            app.handle_screenshot_events(ctx);
 6398|       |        });
 6399|       |    }
 6400|       |
 6401|       |    #[test]
 6402|       |    fn test_screenshot_state_helpers() {
 6403|       |        let config = ScreenshotConfig {
 6404|       |            output_path: PathBuf::from("dummy.png"),
 6405|       |            viewport_width: 120.0,
 6406|       |            viewport_height: 80.0,
 6407|       |            content_only: false,
 6408|       |            scroll_ratio: Some(0.5),
 6409|       |            wait_ms: 500,
 6410|       |            settle_frames: 2,
 6411|       |            zoom: 1.0,
 6412|       |            theme: ScreenshotTheme::Light,
 6413|       |            font_source: None,
 6414|       |        };
 6415|       |        let mut state = ScreenshotState::new(config);
 6416|       |        assert!(!state.scroll_ready());
 6417|       |
 6418|       |        let snapshot = ScrollSnapshot {
 6419|       |            content_size: egui::vec2(200.0, 400.0),
 6420|       |            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 200.0)),
 6421|       |            offset_y: 0.0,
 6422|       |        };
 6423|       |        assert!(state.record_scroll(snapshot));
 6424|       |        assert!(!state.record_scroll(snapshot));
 6425|       |
 6426|       |        state.update_stability(None, None);
 6427|       |        state.last_scroll_offset = Some(0.0);
 6428|       |        state.update_stability(Some(1), Some(10.0));
 6429|       |    }
 6430|       |
 6431|       |    #[test]
 6432|       |    fn test_screenshot_is_stable_requires_no_pending() {
 6433|       |        assert!(MarkdownViewerApp::screenshot_is_stable(true, 2, 2, false));
 6434|       |        assert!(!MarkdownViewerApp::screenshot_is_stable(true, 2, 2, true));
 6435|       |        assert!(!MarkdownViewerApp::screenshot_is_stable(false, 2, 2, false));
 6436|       |        assert!(!MarkdownViewerApp::screenshot_is_stable(true, 1, 2, false));
 6437|       |    }
 6438|       |
 6439|       |    #[test]
 6440|       |    fn test_record_scroll_without_ratio_returns_false() {
 6441|       |        let config = ScreenshotConfig {
 6442|       |            output_path: PathBuf::from("dummy.png"),
 6443|       |            viewport_width: 120.0,
 6444|       |            viewport_height: 80.0,
 6445|       |            content_only: false,
 6446|       |            scroll_ratio: None,
 6447|       |            wait_ms: 500,
 6448|       |            settle_frames: 2,
 6449|       |            zoom: 1.0,
 6450|       |            theme: ScreenshotTheme::Light,
 6451|       |            font_source: None,
 6452|       |        };
 6453|       |        let mut state = ScreenshotState::new(config);
 6454|       |        let snapshot = ScrollSnapshot {
 6455|       |            content_size: egui::vec2(200.0, 400.0),
 6456|       |            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 200.0)),
 6457|       |            offset_y: 0.0,
 6458|       |        };
 6459|       |        assert!(!state.record_scroll(snapshot));
 6460|       |        assert!(state.scroll_offset.is_none());
 6461|       |    }
 6462|       |
 6463|       |    #[test]
 6464|       |    fn test_toggle_write_mode_captures_cursor() {
 6465|       |        let mut app = MarkdownViewerApp::new();
 6466|       |        app.view_mode = ViewMode::Raw;
 6467|       |        app.write_enabled = true;
 6468|       |
 6469|       |        let ctx = egui::Context::default();
 6470|       |        let editor_id = egui::Id::new("raw_editor");
 6471|       |        let mut state = egui::text_edit::TextEditState::default();
 6472|       |        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(2));
 6473|       |        state.cursor.set_char_range(Some(cr));
 6474|       |        state.store(&ctx, editor_id);
 6475|       |
 6476|       |        app.toggle_write_mode(&ctx);
 6477|       |        assert!(!app.write_enabled);
 6478|       |        assert_eq!(app.raw_cursor, Some(2));
 6479|       |    }
 6480|       |
 6481|       |    #[test]
 6482|       |    fn test_toggle_write_mode_without_text_state() {
 6483|       |        let mut app = MarkdownViewerApp::new();
 6484|       |        app.view_mode = ViewMode::Raw;
 6485|       |        app.write_enabled = true;
 6486|       |
 6487|       |        let ctx = egui::Context::default();
 6488|       |        app.toggle_write_mode(&ctx);
 6489|       |        assert!(!app.write_enabled);
 6490|       |        assert!(app.raw_cursor.is_none());
 6491|       |    }
 6492|       |
 6493|       |    #[test]
 6494|       |    fn test_toggle_write_mode_without_cursor_range() {
 6495|       |        let mut app = MarkdownViewerApp::new();
 6496|       |        app.view_mode = ViewMode::Raw;
 6497|       |        app.write_enabled = true;
 6498|       |
 6499|       |        let ctx = egui::Context::default();
 6500|       |        let editor_id = egui::Id::new("raw_editor");
 6501|       |        let mut state = egui::text_edit::TextEditState::default();
 6502|       |        state.cursor.set_char_range(None);
 6503|       |        state.store(&ctx, editor_id);
 6504|       |
 6505|       |        app.toggle_write_mode(&ctx);
 6506|       |        assert!(!app.write_enabled);
 6507|       |        assert!(app.raw_cursor.is_none());
 6508|       |    }
 6509|       |
 6510|       |    #[test]
 6511|       |    fn test_move_raw_cursor_lines_moves_to_end() {
 6512|       |        let mut app = MarkdownViewerApp::new();
 6513|       |        app.view_mode = ViewMode::Raw;
 6514|       |        app.write_enabled = true;
 6515|       |        app.raw_buffer = "Line 1\nLine 2".to_string();
 6516|       |        app.current_content = app.raw_buffer.clone();
 6517|       |
 6518|       |        let ctx = egui::Context::default();
 6519|       |        let editor_id = egui::Id::new("raw_editor");
 6520|       |        let mut state = egui::text_edit::TextEditState::default();
 6521|       |        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 6522|       |        state.cursor.set_char_range(Some(cr));
 6523|       |        state.store(&ctx, editor_id);
 6524|       |
 6525|       |        app.move_raw_cursor_lines(&ctx, 2);
 6526|       |        assert_eq!(app.raw_cursor, Some(app.raw_buffer.len()));
 6527|       |    }
 6528|       |
 6529|       |    #[test]
 6530|       |    fn test_find_next_uses_last_query() {
 6531|       |        let mut app = MarkdownViewerApp::new();
 6532|       |        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6533|       |            "Hello".to_string(),
 6534|       |        )])];
 6535|       |        app.search_query.clear();
 6536|       |        app.last_query = "Hello".to_string();
 6537|       |
 6538|       |        app.find_next();
 6539|       |        assert_eq!(app.last_match_index, Some(0));
 6540|       |    }
 6541|       |
 6542|       |    #[test]
 6543|       |    fn test_find_previous_wraps_from_start() {
 6544|       |        let mut app = MarkdownViewerApp::new();
 6545|       |        app.parsed_elements = vec![
 6546|       |            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
 6547|       |            MarkdownElement::Paragraph(vec![InlineSpan::Text("Other".to_string())]),
 6548|       |        ];
 6549|       |        app.search_query.clear();
 6550|       |        app.last_query = "Match".to_string();
 6551|       |        app.last_match_index = Some(0);
 6552|       |
 6553|       |        app.find_previous();
 6554|       |        assert_eq!(app.last_match_index, Some(0));
 6555|       |    }
 6556|       |
 6557|       |    #[test]
 6558|       |    fn test_set_zoom_scale_on_app() {
 6559|       |        let mut app = MarkdownViewerApp::new();
 6560|       |        let before = app.renderer.font_sizes().body;
 6561|       |        app.set_zoom_scale(1.5);
 6562|       |        assert_ne!(app.renderer.font_sizes().body, before);
 6563|       |    }
 6564|       |
 6565|       |    #[test]
 6566|       |    fn test_handle_file_drop_no_valid_files() {
 6567|       |        let mut app = MarkdownViewerApp::new();
 6568|       |        app.handle_file_drop(vec![
 6569|       |            PathBuf::from("missing1.md"),
 6570|       |            PathBuf::from("missing2.md"),
 6571|       |        ]);
 6572|       |        assert!(app
 6573|       |            .error_message
 6574|       |            .as_ref()
 6575|       |            .is_some_and(|msg| msg.contains("No valid files")));
 6576|       |    }
 6577|       |
 6578|       |    #[test]
 6579|       |    fn test_compute_window_adjustment_missing_monitor_returns_none() {
 6580|       |        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 100.0));
 6581|       |        let adjusted = MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), None);
 6582|       |        assert!(adjusted.is_none());
 6583|       |    }
 6584|       |
 6585|       |    #[test]
 6586|       |    fn test_compute_window_adjustment_invalid_monitor_returns_none() {
 6587|       |        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 100.0));
 6588|       |        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6589|       |            Some(outer),
 6590|       |            Some(outer),
 6591|       |            Some(egui::vec2(0.0, 0.0)),
 6592|       |        );
 6593|       |        assert!(adjusted.is_none());
 6594|       |    }
 6595|       |
 6596|       |    #[test]
 6597|       |    fn test_compute_window_adjustment_invalid_monitor_height_returns_none() {
 6598|       |        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 100.0));
 6599|       |        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6600|       |            Some(outer),
 6601|       |            Some(outer),
 6602|       |            Some(egui::vec2(800.0, 0.0)),
 6603|       |        );
 6604|       |        assert!(adjusted.is_none());
 6605|       |    }
 6606|       |
 6607|       |    #[test]
 6608|       |    fn test_compute_window_adjustment_handles_nan_and_clamps() {
 6609|       |        let outer = egui::Rect::from_min_size(
 6610|       |            egui::pos2(f32::NAN, f32::NAN),
 6611|       |            egui::vec2(f32::NAN, f32::NAN),
 6612|       |        );
 6613|       |        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6614|       |            Some(outer),
 6615|       |            Some(outer),
 6616|       |            Some(egui::vec2(800.0, 600.0)),
 6617|       |        );
 6618|       |        assert!(adjusted.is_some());
 6619|       |
 6620|       |        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(5000.0, 4000.0));
 6621|       |        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6622|       |            Some(outer),
 6623|       |            Some(outer),
 6624|       |            Some(egui::vec2(800.0, 600.0)),
 6625|       |        );
 6626|       |        assert!(adjusted.is_some());
 6627|       |    }
 6628|       |
 6629|       |    #[test]
 6630|       |    fn test_compute_window_adjustment_invalid_pos_only() {
 6631|       |        let outer = egui::Rect::from_min_size(egui::pos2(f32::NAN, 0.0), egui::vec2(800.0, 600.0));
 6632|       |        let inner = egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(800.0, 600.0));
 6633|       |        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6634|       |            Some(outer),
 6635|       |            Some(inner),
 6636|       |            Some(egui::vec2(1200.0, 900.0)),
 6637|       |        )
 6638|       |        .expect("adjustment");
 6639|       |        assert!(adjusted.pos.is_some());
 6640|       |        assert!(adjusted.size.is_none());
 6641|       |    }
 6642|       |
 6643|       |    #[test]
 6644|       |    fn test_compute_window_adjustment_invalid_pos_y_only() {
 6645|       |        let outer = egui::Rect::from_min_size(egui::pos2(0.0, f32::NAN), egui::vec2(800.0, 600.0));
 6646|       |        let inner = egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(800.0, 600.0));
 6647|       |        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6648|       |            Some(outer),
 6649|       |            Some(inner),
 6650|       |            Some(egui::vec2(1200.0, 900.0)),
 6651|       |        )
 6652|       |        .expect("adjustment");
 6653|       |        assert!(adjusted.pos.is_some());
 6654|       |        assert!(adjusted.size.is_none());
 6655|       |    }
 6656|       |
 6657|       |    #[test]
 6658|       |    fn test_compute_window_adjustment_invalid_size_only() {
 6659|       |        let outer = egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(800.0, f32::NAN));
 6660|       |        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6661|       |            Some(outer),
 6662|       |            Some(outer),
 6663|       |            Some(egui::vec2(1200.0, 900.0)),
 6664|       |        )
 6665|       |        .expect("adjustment");
 6666|       |        assert!(adjusted.pos.is_none());
 6667|       |        assert!(adjusted.size.is_some());
 6668|       |    }
 6669|       |
 6670|       |    #[test]
 6671|       |    fn test_push_history_caps_max() {
 6672|       |        let mut app = MarkdownViewerApp::new();
 6673|       |        app.max_history = 1;
 6674|       |        app.current_content = "First".to_string();
 6675|       |        app.title = "First".to_string();
 6676|       |        app.push_history();
 6677|       |
 6678|       |        app.current_content = "Second".to_string();
 6679|       |        app.title = "Second".to_string();
 6680|       |        app.push_history();
 6681|       |
 6682|       |        assert_eq!(app.history.len(), 1);
 6683|       |        assert_eq!(app.history[0].content, "Second");
 6684|       |    }
 6685|       |
 6686|       |    #[test]
 6687|       |    fn test_navigate_forward_pending_error() {
 6688|       |        let mut app = MarkdownViewerApp::new();
 6689|       |        let _forced = ForcedLoadError::new();
 6690|       |        app.pending_files.push_back(PathBuf::from("missing.md"));
 6691|       |
 6692|       |        assert!(app.navigate_forward());
 6693|       |        assert!(app.error_message.is_some());
 6694|       |    }
 6695|       |
 6696|       |    #[test]
 6697|       |    fn test_navigate_forward_history() {
 6698|       |        let mut app = MarkdownViewerApp::new();
 6699|       |        app.history = vec![
 6700|       |            HistoryEntry {
 6701|       |                file_path: None,
 6702|       |                title: "One".to_string(),
 6703|       |                content: "One".to_string(),
 6704|       |            },
 6705|       |            HistoryEntry {
 6706|       |                file_path: None,
 6707|       |                title: "Two".to_string(),
 6708|       |                content: "Two".to_string(),
 6709|       |            },
 6710|       |        ];
 6711|       |        app.history_index = 0;
 6712|       |
 6713|       |        assert!(app.navigate_forward());
 6714|       |        assert_eq!(app.history_index, 1);
 6715|       |        assert_eq!(app.current_content, "Two");
 6716|       |    }
 6717|       |
 6718|       |    #[test]
 6719|       |    fn test_restore_from_history_parse_error() {
 6720|       |        let mut app = MarkdownViewerApp::new();
 6721|       |        app.history = vec![HistoryEntry {
 6722|       |            file_path: None,
 6723|       |            title: "Bad".to_string(),
 6724|       |            content: "Bad".to_string(),
 6725|       |        }];
 6726|       |        app.history_index = 0;
 6727|       |        crate::markdown_renderer::force_parse_error_once();
 6728|       |
 6729|       |        app.restore_from_history();
 6730|       |        assert!(app.error_message.is_some());
 6731|       |    }
 6732|       |
 6733|       |    #[test]
 6734|       |    fn test_open_file_dialog_load_error() -> Result<()> {
 6735|       |        let mut app = MarkdownViewerApp::new();
 6736|       |        let temp_dir = tempfile::TempDir::new()?;
 6737|       |        let open_path = temp_dir.path().join("open.md");
 6738|       |        std::fs::write(&open_path, "# Open")?;
 6739|       |        let _forced_path = ForcedDialogPaths::new(Some(open_path), None);
 6740|       |        let _forced_load = ForcedLoadError::new();
 6741|       |
 6742|       |        app.open_file_dialog();
 6743|       |        assert!(app
 6744|       |            .error_message
 6745|       |            .as_ref()
 6746|       |            .is_some_and(|msg| msg.contains("Failed to open file")));
 6747|       |        Ok(())
 6748|       |    }
 6749|       |
 6750|       |    #[test]
 6751|       |    fn test_toggle_view_mode_captures_cursor() {
 6752|       |        let mut app = MarkdownViewerApp::new();
 6753|       |        app.view_mode = ViewMode::Raw;
 6754|       |        app.write_enabled = true;
 6755|       |
 6756|       |        let ctx = egui::Context::default();
 6757|       |        let editor_id = egui::Id::new("raw_editor");
 6758|       |        let mut state = egui::text_edit::TextEditState::default();
 6759|       |        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(4));
 6760|       |        state.cursor.set_char_range(Some(cr));
 6761|       |        state.store(&ctx, editor_id);
 6762|       |
 6763|       |        app.toggle_view_mode(&ctx);
 6764|       |        assert_eq!(app.raw_cursor, Some(4));
 6765|       |        assert_eq!(app.view_mode, ViewMode::Rendered);
 6766|       |    }
 6767|       |
 6768|       |    #[test]
 6769|       |    fn test_handle_shortcuts_shift_f3_triggers_previous() {
 6770|       |        let mut app = MarkdownViewerApp::new();
 6771|       |        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6772|       |            "Nav".to_string(),
 6773|       |        )])];
 6774|       |        app.search_query = "Nav".to_string();
 6775|       |
 6776|       |        let mut input = default_input();
 6777|       |        input.modifiers = egui::Modifiers::SHIFT;
 6778|       |        input.events.push(egui::Event::Key {
 6779|       |            key: egui::Key::F3,
 6780|       |            physical_key: None,
 6781|       |            pressed: true,
 6782|       |            repeat: false,
 6783|       |            modifiers: egui::Modifiers::SHIFT,
 6784|       |        });
 6785|       |
 6786|       |        let ctx = egui::Context::default();
 6787|       |        let _ = ctx.run(input, |ctx| {
 6788|       |            app.handle_shortcuts(ctx);
 6789|       |        });
 6790|       |
 6791|       |        assert_eq!(app.last_match_index, Some(0));
 6792|       |    }
 6793|       |
 6794|       |    #[test]
 6795|       |    fn test_handle_shortcuts_f3_triggers_next() {
 6796|       |        let mut app = MarkdownViewerApp::new();
 6797|       |        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6798|       |            "Nav".to_string(),
 6799|       |        )])];
 6800|       |        app.search_query = "Nav".to_string();
 6801|       |
 6802|       |        let mut input = default_input();
 6803|       |        input.events.push(egui::Event::Key {
 6804|       |            key: egui::Key::F3,
 6805|       |            physical_key: None,
 6806|       |            pressed: true,
 6807|       |            repeat: false,
 6808|       |            modifiers: egui::Modifiers::NONE,
 6809|       |        });
 6810|       |
 6811|       |        let ctx = egui::Context::default();
 6812|       |        let _ = ctx.run(input, |ctx| {
 6813|       |            app.handle_shortcuts(ctx);
 6814|       |        });
 6815|       |
 6816|       |        assert_eq!(app.last_match_index, Some(0));
 6817|       |    }
 6818|       |
 6819|       |    #[test]
 6820|       |    fn test_handle_shortcuts_alt_f3_triggers_previous() {
 6821|       |        let mut app = MarkdownViewerApp::new();
 6822|       |        app.parsed_elements = vec![
 6823|       |            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
 6824|       |            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
 6825|       |            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
 6826|       |        ];
 6827|       |        app.search_query = "Match".to_string();
 6828|       |        app.last_match_index = Some(1);
 6829|       |        app.pending_scroll_to_element = None;
 6830|       |
 6831|       |        let mut input = default_input();
 6832|       |        input.modifiers = egui::Modifiers::ALT;
 6833|       |        input.events.push(egui::Event::Key {
 6834|       |            key: egui::Key::F3,
 6835|       |            physical_key: None,
 6836|       |            pressed: true,
 6837|       |            repeat: false,
 6838|       |            modifiers: egui::Modifiers::ALT,
 6839|       |        });
 6840|       |
 6841|       |        let ctx = egui::Context::default();
 6842|       |        let _ = ctx.run(input, |ctx| {
 6843|       |            app.handle_shortcuts(ctx);
 6844|       |        });
 6845|       |
 6846|       |        assert_eq!(app.last_match_index, Some(0));
 6847|       |        assert_eq!(app.pending_scroll_to_element, Some(0));
 6848|       |    }
 6849|       |
 6850|       |    #[test]
 6851|       |    fn test_render_file_menu_save_error_sets_message() {
 6852|       |        let mut app = MarkdownViewerApp::new();
 6853|       |        app.current_file = Some(PathBuf::from("missing_dir\\save.md"));
 6854|       |        app.current_content = "Data".to_string();
 6855|       |        let _actions = ForcedAppActions::new(&["menu_save"]);
 6856|       |
 6857|       |        let ctx = egui::Context::default();
 6858|       |        let _ = ctx.run(default_input(), |ctx| {
 6859|       |            egui::CentralPanel::default().show(ctx, |ui| {
 6860|       |                app.render_file_menu_contents(ui, false, Color32::WHITE);
 6861|       |            });
 6862|       |        });
 6863|       |
 6864|       |        assert!(app.error_message.is_some());
 6865|       |    }
 6866|       |
 6867|       |    #[test]
 6868|       |    fn test_menu_text_with_mnemonic_prefix_and_underline() {
 6869|       |        let job = MarkdownViewerApp::menu_text_with_mnemonic(
 6870|       |            Some("Alt+"),
 6871|       |            "Open",
 6872|       |            'O',
 6873|       |            true,
 6874|       |            Color32::WHITE,
 6875|       |        );
 6876|       |        assert!(!job.sections.is_empty());
 6877|       |    }
 6878|       |
 6879|       |    #[test]
 6880|       |    fn test_menu_text_with_mnemonic_no_underline() {
 6881|       |        let job =
 6882|       |            MarkdownViewerApp::menu_text_with_mnemonic(None, "Save", 'S', false, Color32::WHITE);
 6883|       |        assert!(!job.sections.is_empty());
 6884|       |    }
 6885|       |
 6886|       |    #[test]
 6887|       |    fn test_menu_text_with_mnemonic_missing_character() {
 6888|       |        let job =
 6889|       |            MarkdownViewerApp::menu_text_with_mnemonic(None, "Save", 'Z', true, Color32::WHITE);
 6890|       |        assert!(!job.sections.is_empty());
 6891|       |    }
 6892|       |
 6893|       |    #[test]
 6894|       |    fn test_persist_window_state_no_change_returns_early() {
 6895|       |        let mut app = MarkdownViewerApp::new();
 6896|       |        app.last_window_pos = Some([10.0, 10.0]);
 6897|       |        app.last_window_size = Some([800.0, 600.0]);
 6898|       |        app.last_window_maximized = false;
 6899|       |        app.last_persisted_state = Some(WindowState {
 6900|       |            pos: [10.0, 10.0],
 6901|       |            size: [800.0, 600.0],
 6902|       |            maximized: false,
 6903|       |        });
 6904|       |
 6905|       |        app.persist_window_state();
 6906|       |        assert!(app.last_persisted_state.is_some());
 6907|       |    }
 6908|       |
 6909|       |    #[test]
 6910|       |    fn test_persist_window_state_without_window_state() {
 6911|       |        let mut app = MarkdownViewerApp::new();
 6912|       |        app.last_window_pos = None;
 6913|       |        app.last_window_size = None;
 6914|       |
 6915|       |        app.persist_window_state();
 6916|       |        assert!(app.last_persisted_state.is_none());
 6917|       |    }
 6918|       |
 6919|       |    #[test]
 6920|       |    fn test_persist_window_state_save_failure() {
 6921|       |        let _lock = env_lock();
 6922|       |        let temp_file = NamedTempFile::new().expect("temp file");
 6923|       |        let _guard = EnvGuard::set("APPDATA", temp_file.path().to_string_lossy().as_ref());
 6924|       |
 6925|       |        let mut app = MarkdownViewerApp::new();
 6926|       |        app.last_window_pos = Some([10.0, 10.0]);
 6927|       |        app.last_window_size = Some([800.0, 600.0]);
 6928|       |        app.last_window_maximized = false;
 6929|       |
 6930|       |        app.persist_window_state();
 6931|       |        assert!(app.last_persisted_state.is_none());
 6932|       |    }
 6933|       |
 6934|       |    #[test]
 6935|       |    fn test_should_persist_window_state_screenshot_blocks() {
 6936|       |        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 6937|       |        let config = ScreenshotConfig {
 6938|       |            output_path: temp_dir.path().join("shot.png"),
 6939|       |            viewport_width: 80.0,
 6940|       |            viewport_height: 60.0,
 6941|       |            content_only: false,
 6942|       |            scroll_ratio: None,
 6943|       |            wait_ms: 0,
 6944|       |            settle_frames: 0,
 6945|       |            zoom: 1.0,
 6946|       |            theme: ScreenshotTheme::Light,
 6947|       |            font_source: None,
 6948|       |        };
 6949|       |        let mut app = MarkdownViewerApp::new();
 6950|       |        app.screenshot = Some(ScreenshotState::new(config));
 6951|       |        assert!(!app.should_persist_window_state());
 6952|       |    }
 6953|       |
 6954|       |    #[test]
 6955|       |    fn test_should_persist_window_state_recently_persisted() {
 6956|       |        let mut app = MarkdownViewerApp::new();
 6957|       |        app.last_window_pos = Some([10.0, 10.0]);
 6958|       |        app.last_window_size = Some([800.0, 600.0]);
 6959|       |        app.last_persist_instant = std::time::Instant::now();
 6960|       |        assert!(!app.should_persist_window_state());
 6961|       |    }
 6962|       |
 6963|       |    #[test]
 6964|       |    fn test_should_persist_window_state_without_window_state() {
 6965|       |        let mut app = MarkdownViewerApp::new();
 6966|       |        app.last_persist_instant = std::time::Instant::now() - std::time::Duration::from_secs(2);
 6967|       |        assert!(!app.should_persist_window_state());
 6968|       |    }
 6969|       |
 6970|       |    #[test]
 6971|       |    fn test_should_persist_window_state_when_changed() {
 6972|       |        let mut app = MarkdownViewerApp::new();
 6973|       |        app.last_window_pos = Some([10.0, 10.0]);
 6974|       |        app.last_window_size = Some([800.0, 600.0]);
 6975|       |        app.last_persist_instant = std::time::Instant::now() - std::time::Duration::from_secs(2);
 6976|       |
 6977|       |        assert!(app.should_persist_window_state());
 6978|       |    }
 6979|       |
 6980|       |    #[test]
 6981|       |    fn test_update_impl_persists_window_state_when_due() {
 6982|       |        let _lock = env_lock();
 6983|       |        let temp_dir = TempDir::new().expect("temp dir");
 6984|       |        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());
 6985|       |
 6986|       |        let mut app = MarkdownViewerApp::new();
 6987|       |        app.last_persist_instant = std::time::Instant::now() - std::time::Duration::from_secs(2);
 6988|       |
 6989|       |        let ctx = egui::Context::default();
 6990|       |        let mut input = default_input();
 6991|       |        let vp = input
 6992|       |            .viewports
 6993|       |            .get_mut(&egui::ViewportId::ROOT)
 6994|       |            .expect("root viewport");
 6995|       |        vp.monitor_size = Some(egui::vec2(1024.0, 768.0));
 6996|       |        vp.outer_rect = Some(egui::Rect::from_min_size(
 6997|       |            egui::pos2(10.0, 10.0),
 6998|       |            egui::vec2(800.0, 600.0),
 6999|       |        ));
 7000|       |        vp.inner_rect = Some(egui::Rect::from_min_size(
 7001|       |            egui::pos2(20.0, 20.0),
 7002|       |            egui::vec2(780.0, 580.0),
 7003|       |        ));
 7004|       |        vp.fullscreen = Some(false);
 7005|       |        vp.maximized = Some(false);
 7006|       |
 7007|       |        run_app_frame(&mut app, &ctx, input);
 7008|       |
 7009|       |        let path = temp_dir
 7010|       |            .path()
 7011|       |            .join("MarkdownView")
 7012|       |            .join("window_state.txt");
 7013|       |        assert!(path.exists());
 7014|       |        assert!(app.last_persisted_state.is_some());
 7015|       |    }
 7016|       |
 7017|       |    #[test]
 7018|       |    fn test_update_impl_fullscreen_skips_size_persist() {
 7019|       |        let mut app = MarkdownViewerApp::new();
 7020|       |        app.last_window_size = None;
 7021|       |
 7022|       |        let ctx = egui::Context::default();
 7023|       |        let mut input = default_input();
 7024|       |        let vp = input
 7025|       |            .viewports
 7026|       |            .get_mut(&egui::ViewportId::ROOT)
 7027|       |            .expect("root viewport");
 7028|       |        vp.monitor_size = Some(egui::vec2(1024.0, 768.0));
 7029|       |        vp.outer_rect = Some(egui::Rect::from_min_size(
 7030|       |            egui::pos2(10.0, 10.0),
 7031|       |            egui::vec2(800.0, 600.0),
 7032|       |        ));
 7033|       |        vp.inner_rect = Some(egui::Rect::from_min_size(
 7034|       |            egui::pos2(20.0, 20.0),
 7035|       |            egui::vec2(780.0, 580.0),
 7036|       |        ));
 7037|       |        vp.fullscreen = Some(true);
 7038|       |        vp.maximized = Some(false);
 7039|       |
 7040|       |        run_app_frame(&mut app, &ctx, input);
 7041|       |
 7042|       |        assert!(app.last_window_size.is_none());
 7043|       |    }
 7044|       |
 7045|       |    #[test]
 7046|       |    fn test_update_impl_reload_with_file_succeeds() -> Result<()> {
 7047|       |        let mut app = MarkdownViewerApp::new();
 7048|       |        let mut temp_file = tempfile::Builder::new().suffix(".md").tempfile()?;
 7049|       |        temp_file.write_all(b"# Reloaded")?;
 7050|       |        temp_file.flush()?;
 7051|       |        app.current_file = Some(temp_file.path().to_path_buf());
 7052|       |        app.reload_requested = true;
 7053|       |
 7054|       |        let ctx = egui::Context::default();
 7055|       |        let input = default_input();
 7056|       |        run_app_frame(&mut app, &ctx, input);
 7057|       |
 7058|       |        assert!(app.error_message.is_none());
 7059|       |        Ok(())
 7060|       |    }
 7061|       |
 7062|       |    #[test]
 7063|       |    fn test_save_current_document_parentless_path() -> Result<()> {
 7064|       |        let mut app = MarkdownViewerApp::new();
 7065|       |        app.current_content = "Saved".to_string();
 7066|       |        let filename = format!("save_parentless_{}.md", std::process::id());
 7067|       |        let _forced = ForcedDialogPaths::new(None, Some(PathBuf::from(&filename)));
 7068|       |
 7069|       |        app.save_current_document()?;
 7070|       |        assert_eq!(app.current_file, Some(PathBuf::from(&filename)));
 7071|       |        std::fs::remove_file(&filename)?;
 7072|       |        Ok(())
 7073|       |    }
 7074|       |
 7075|       |    #[test]
 7076|       |    fn test_update_search_results_wraps() {
 7077|       |        let mut app = MarkdownViewerApp::new();
 7078|       |        app.parsed_elements = vec![
 7079|       |            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
 7080|       |            MarkdownElement::Paragraph(vec![InlineSpan::Text("Other".to_string())]),
 7081|       |        ];
 7082|       |        app.search_query = "Match".to_string();
 7083|       |        app.last_match_index = Some(1);
 7084|       |
 7085|       |        app.update_search_results("");
 7086|       |        assert_eq!(app.last_match_index, Some(0));
 7087|       |    }
 7088|       |
 7089|       |    #[test]
 7090|       |    fn test_handle_screenshot_events_save_error() {
 7091|       |        let mut app = MarkdownViewerApp::new();
 7092|       |        let ctx = egui::Context::default();
 7093|       |        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 7094|       |        let config = ScreenshotConfig {
 7095|       |            output_path: temp_dir.path().to_path_buf(),
 7096|       |            viewport_width: 40.0,
 7097|       |            viewport_height: 30.0,
 7098|       |            content_only: false,
 7099|       |            scroll_ratio: None,
 7100|       |            wait_ms: 0,
 7101|       |            settle_frames: 0,
 7102|       |            zoom: 1.0,
 7103|       |            theme: ScreenshotTheme::Light,
 7104|       |            font_source: None,
 7105|       |        };
 7106|       |        app.screenshot = Some(ScreenshotState::new(config));
 7107|       |
 7108|       |        let image = egui::ColorImage::new([10, 10], Color32::WHITE);
 7109|       |        let mut input = default_input();
 7110|       |        input.events.push(egui::Event::Screenshot {
 7111|       |            viewport_id: egui::ViewportId::ROOT,
 7112|       |            image: std::sync::Arc::new(image),
 7113|       |        });
 7114|       |        let _ = ctx.run(input, |ctx| {
 7115|       |            app.handle_screenshot_events(ctx);
 7116|       |        });
 7117|       |
 7118|       |        assert!(app.screenshot.as_ref().is_some_and(|state| state.done));
 7119|       |    }
 7120|       |
 7121|       |    #[test]
 7122|       |    fn test_update_screenshot_state_requests_repaint() {
 7123|       |        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 7124|       |        let config = ScreenshotConfig {
 7125|       |            output_path: temp_dir.path().join("shot.png"),
 7126|       |            viewport_width: 200.0,
 7127|       |            viewport_height: 100.0,
 7128|       |            content_only: false,
 7129|       |            scroll_ratio: Some(0.5),
 7130|       |            wait_ms: 1000,
 7131|       |            settle_frames: 5,
 7132|       |            zoom: 1.0,
 7133|       |            theme: ScreenshotTheme::Light,
 7134|       |            font_source: None,
 7135|       |        };
 7136|       |        let mut app = MarkdownViewerApp::new();
 7137|       |        app.screenshot = Some(ScreenshotState::new(config));
 7138|       |
 7139|       |        let ctx = egui::Context::default();
 7140|       |        app.update_screenshot_state(&ctx, None, None);
 7141|       |    }
 7142|       |
 7143|       |    #[test]
 7144|       |    fn test_update_screenshot_state_requested_done_skips_repaint() {
 7145|       |        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 7146|       |        let config = ScreenshotConfig {
 7147|       |            output_path: temp_dir.path().join("shot.png"),
 7148|       |            viewport_width: 200.0,
 7149|       |            viewport_height: 100.0,
 7150|       |            content_only: false,
 7151|       |            scroll_ratio: None,
 7152|       |            wait_ms: 1000,
 7153|       |            settle_frames: 0,
 7154|       |            zoom: 1.0,
 7155|       |            theme: ScreenshotTheme::Light,
 7156|       |            font_source: None,
 7157|       |        };
 7158|       |        let mut state = ScreenshotState::new(config);
 7159|       |        state.requested = true;
 7160|       |        state.done = true;
 7161|       |
 7162|       |        let mut app = MarkdownViewerApp::new();
 7163|       |        app.screenshot = Some(state);
 7164|       |
 7165|       |        let ctx = egui::Context::default();
 7166|       |        app.update_screenshot_state(&ctx, None, None);
 7167|       |
 7168|       |        let state = app.screenshot.as_ref().expect("screenshot state");
 7169|       |        assert!(state.requested);
 7170|       |        assert!(state.done);
 7171|       |    }
 7172|       |
 7173|       |    #[test]
 7174|       |    fn test_env_guard_removes_unset_key() {
 7175|       |        let _lock = env_lock();
 7176|       |        std::env::remove_var("MDMDVIEW_TMP_ENV");
 7177|       |        {
 7178|       |            let _guard = EnvGuard::set("MDMDVIEW_TMP_ENV", "value");
 7179|       |        }
 7180|       |        assert!(std::env::var("MDMDVIEW_TMP_ENV").is_err());
 7181|       |    }
 7182|       |}

C:\language\mdmdview\src\emoji_assets.rs:
    1|       |use egui::Color32 as C;
    2|       |
    3|       |// Draw simple vector fallback icons for a subset of emoji.
    4|     19|pub fn make_image(emoji: &str, size: usize) -> Option<egui::ColorImage> {
    5|     19|    let mut img = egui::ColorImage::new([size, size], C::TRANSPARENT);
    6|     19|    match emoji {
    7|     19|        "\u{2705}" => {
    8|      1|            draw_circle(&mut img, size, C::from_rgb(34, 139, 34));
    9|      1|            draw_check(&mut img, size, C::WHITE);
   10|      1|            Some(img)
   11|       |        }
   12|     18|        "\u{1f389}" => {
   13|      1|            draw_circle(&mut img, size, C::from_rgb(255, 215, 0));
   14|      1|            confetti(&mut img, size);
   15|      1|            Some(img)
   16|       |        }
   17|     17|        "\u{1f680}" => {
   18|      2|            draw_circle(&mut img, size, C::from_rgb(60, 60, 170));
   19|      2|            rocket(
   20|      2|                &mut img,
   21|      2|                size,
   22|      2|                C::from_rgb(230, 230, 230),
   23|      2|                C::from_rgb(255, 110, 60),
   24|       |            );
   25|      2|            Some(img)
   26|       |        }
   27|     15|        "\u{2764}" | "\u{1f496}" => {
                                   ^8
   28|      8|            heart(&mut img, size, C::from_rgb(220, 20, 60));
   29|      8|            Some(img)
   30|       |        }
   31|      7|        "\u{2b50}" => {
   32|      1|            star(&mut img, size, C::from_rgb(255, 215, 0));
   33|      1|            Some(img)
   34|       |        }
   35|      6|        "\u{1f525}" => {
   36|      1|            flame(&mut img, size);
   37|      1|            Some(img)
   38|       |        }
   39|      5|        _ => None,
   40|       |    }
   41|     19|}
   42|       |
   43|      4|fn draw_circle(img: &mut egui::ColorImage, size: usize, color: C) {
   44|      4|    let cx = (size as i32) / 2;
   45|      4|    let cy = cx;
   46|      4|    let r = (size as i32) / 2 - 2;
   47|    136|    for y in 0..size as i32 {
                              ^4
   48|  5.82k|        for x in 0..size as i32 {
                                  ^136
   49|  5.82k|            let dx = x - cx;
   50|  5.82k|            let dy = y - cy;
   51|  5.82k|            if dx * dx + dy * dy <= r * r {
   52|  3.77k|                img[(x as usize, y as usize)] = color;
   53|  3.77k|            }
                          ^2.05k
   54|       |        }
   55|       |    }
   56|      4|}
   57|       |
   58|      1|fn draw_check(img: &mut egui::ColorImage, size: usize, color: C) {
   59|      1|    let s = size as i32;
   60|     40|    let mut plot = |x: i32, y: i32| {
                      ^1
   61|     40|        img[(x as usize, y as usize)] = color;
   62|     40|    };
   63|       |    // simple check mark
   64|      8|    for i in 0..s / 3 {
                              ^1
   65|      8|        plot(s / 3 - i, s * 2 / 3 + i);
   66|      8|        plot(s / 3 - i + 1, s * 2 / 3 + i);
   67|      8|    }
   68|     12|    for i in 0..s / 2 {
                              ^1
   69|     12|        plot(s / 3 + i, s * 2 / 3 - i);
   70|     12|        plot(s / 3 + i + 1, s * 2 / 3 - i);
   71|     12|    }
   72|      1|}
   73|       |
   74|      1|fn confetti(img: &mut egui::ColorImage, size: usize) {
   75|      1|    let dots = [
   76|      1|        C::from_rgb(255, 80, 80),
   77|      1|        C::from_rgb(80, 180, 255),
   78|      1|        C::from_rgb(120, 220, 120),
   79|      1|        C::from_rgb(220, 120, 220),
   80|      1|    ];
   81|      1|    let s = size as i32;
   82|      4|    for (i, col) in dots.iter().enumerate() {
                                  ^1   ^1     ^1
   83|      4|        let x = (s / 4) * ((i as i32) + 1);
   84|      4|        let y = (s / 5) * ((i as i32) + 1);
   85|      4|        if x < s {
   86|      3|            img[(x as usize, y as usize)] = *col;
   87|      3|        }
                      ^1
   88|       |    }
   89|      1|}
   90|       |
   91|      2|fn rocket(img: &mut egui::ColorImage, size: usize, body: C, flame: C) {
   92|      2|    let s = size as i32;
   93|       |    // body
   94|     44|    for y in s / 4..s * 3 / 4 {
                           ^2     ^2
   95|    768|        for x in s / 3..s * 2 / 3 {
                               ^44    ^44
   96|    768|            img[(x as usize, y as usize)] = body;
   97|    768|        }
   98|       |    }
   99|       |    // nose
  100|     14|    for i in 0..s / 6 {
                              ^2
  101|    116|        for x in s / 2 - i..=s / 2 + i {
                               ^14         ^14
  102|    116|            let y = s / 4 - i;
  103|    116|            img[(x as usize, y as usize)] = body;
  104|    116|        }
  105|       |    }
  106|       |    // flame
  107|     14|    for i in 0..s / 6 {
                              ^2
  108|    116|        for x in s / 2 - i..=s / 2 + i {
                               ^14         ^14
  109|    116|            let y = s * 3 / 4 + i;
  110|    116|            img[(x as usize, y as usize)] = flame;
  111|    116|        }
  112|       |    }
  113|      2|}
  114|       |
  115|      8|fn heart(img: &mut egui::ColorImage, size: usize, color: C) {
  116|      8|    let s = size as i32;
  117|    432|    for y in 0..s {
                              ^8
  118|  25.7k|        for x in 0..s {
                                  ^432
  119|  25.7k|            let dx = x - s / 2;
  120|  25.7k|            let dy = y - s / 3;
  121|  25.7k|            let a = (dx * dx + dy * dy - s * s / 16) < 0;
  122|  25.7k|            let b = x > s / 4 && x < 3 * s / 4 && y > s / 3 && y < s * 3 / 4;
                                               ^18.8k           ^12.4k       ^8.14k
  123|  25.7k|            if a || b {
                                  ^20.7k
  124|  7.62k|                img[(x as usize, y as usize)] = color;
  125|  18.1k|            }
  126|       |        }
  127|       |    }
  128|      8|}
  129|       |
  130|      1|fn star(img: &mut egui::ColorImage, size: usize, color: C) {
  131|      1|    let s = size as i32;
  132|     24|    for i in 0..s {
                              ^1
  133|     24|        let y = i;
  134|     24|        let x1 = s / 2;
  135|     24|        let x2 = s / 2 - i / 2;
  136|     24|        let x3 = s / 2 + i / 2;
  137|     24|        img[(x2 as usize, y as usize)] = color;
  138|     24|        img[(x1 as usize, y as usize)] = color;
  139|     24|        img[(x3 as usize, y as usize)] = color;
  140|     24|    }
  141|      1|}
  142|       |
  143|      1|fn flame(img: &mut egui::ColorImage, size: usize) {
  144|      1|    let s = size as i32;
  145|      1|    let base = C::from_rgb(255, 140, 0);
  146|      1|    let tip = C::from_rgb(255, 220, 120);
  147|     24|    for y in 0..s {
                              ^1
  148|    576|        for x in 0..s {
                                  ^24
  149|    576|            let dx = (x - s / 2) as f32 / (s as f32 / 3.5);
  150|    576|            let dy = (y - s) as f32 / (s as f32 / 1.5);
  151|    576|            let v = (dx * dx + dy * dy).sqrt();
  152|    576|            if v < 1.0 {
  153|    161|                let t = 1.0 - v;
  154|    161|                img[(x as usize, y as usize)] = C::from_rgb(
  155|    161|                    (base.r() as f32 * t + tip.r() as f32 * (1.0 - t)) as u8,
  156|    161|                    (base.g() as f32 * t + tip.g() as f32 * (1.0 - t)) as u8,
  157|    161|                    (base.b() as f32 * t + tip.b() as f32 * (1.0 - t)) as u8,
  158|    161|                );
  159|    415|            }
  160|       |        }
  161|       |    }
  162|      1|}
  163|       |
  164|       |#[cfg(test)]
  165|       |#[cfg_attr(coverage_nightly, coverage(off))]
  166|       |mod tests {
  167|       |    use super::*;
  168|       |
  169|       |    fn has_non_transparent_pixel(img: &egui::ColorImage) -> bool {
  170|       |        img.pixels.iter().any(|p| p.a() != 0)
  171|       |    }
  172|       |
  173|       |    #[test]
  174|       |    fn test_make_image_known_emojis_produce_pixels() {
  175|       |        let emojis = [
  176|       |            "\u{2705}",
  177|       |            "\u{1f389}",
  178|       |            "\u{1f680}",
  179|       |            "\u{2764}",
  180|       |            "\u{1f496}",
  181|       |            "\u{2b50}",
  182|       |            "\u{1f525}",
  183|       |        ];
  184|       |
  185|       |        for emoji in emojis {
  186|       |            let img = make_image(emoji, 24).expect("expected fallback image");
  187|       |            assert!(has_non_transparent_pixel(&img));
  188|       |        }
  189|       |    }
  190|       |
  191|       |    #[test]
  192|       |    fn test_make_image_unknown_returns_none() {
  193|       |        assert!(make_image("\u{1f47d}", 24).is_none());
  194|       |    }
  195|       |}

C:\language\mdmdview\src\emoji_catalog.rs:
    1|       |use std::collections::HashMap;
    2|       |
    3|       |// Return embedded emoji sprites keyed by real Unicode emoji characters.
    4|  4.36k|pub fn image_bytes_for(emoji: &str) -> Option<&'static [u8]> {
    5|  4.36k|    match emoji {
    6|  4.36k|        "\u{1f389}" => Some(include_bytes!(concat!(
    7|      2|            env!("CARGO_MANIFEST_DIR"),
    8|      2|            "/assets/emoji/1f389.png"
    9|      2|        ))),
   10|  4.35k|        "\u{2705}" => Some(include_bytes!(concat!(
   11|      2|            env!("CARGO_MANIFEST_DIR"),
   12|      2|            "/assets/emoji/2705.png"
   13|      2|        ))),
   14|  4.35k|        "\u{1f680}" => Some(include_bytes!(concat!(
   15|      8|            env!("CARGO_MANIFEST_DIR"),
   16|      8|            "/assets/emoji/1f680.png"
   17|      8|        ))),
   18|  4.34k|        "\u{1f642}" => Some(include_bytes!(concat!(
   19|      3|            env!("CARGO_MANIFEST_DIR"),
   20|      3|            "/assets/emoji/1f642.png"
   21|      3|        ))),
   22|  4.34k|        "\u{1f600}" => Some(include_bytes!(concat!(
   23|      8|            env!("CARGO_MANIFEST_DIR"),
   24|      8|            "/assets/emoji/1f600.png"
   25|      8|        ))),
   26|  4.33k|        "\u{1f609}" => Some(include_bytes!(concat!(
   27|      1|            env!("CARGO_MANIFEST_DIR"),
   28|      1|            "/assets/emoji/1f609.png"
   29|      1|        ))),
   30|  4.33k|        "\u{2b50}" => Some(include_bytes!(concat!(
   31|      1|            env!("CARGO_MANIFEST_DIR"),
   32|      1|            "/assets/emoji/2b50.png"
   33|      1|        ))),
   34|  4.33k|        "\u{1f525}" => Some(include_bytes!(concat!(
   35|      1|            env!("CARGO_MANIFEST_DIR"),
   36|      1|            "/assets/emoji/1f525.png"
   37|      1|        ))),
   38|  4.33k|        "\u{1f44d}" => Some(include_bytes!(concat!(
   39|      1|            env!("CARGO_MANIFEST_DIR"),
   40|      1|            "/assets/emoji/1f44d.png"
   41|      1|        ))),
   42|  4.33k|        "\u{1f44e}" => Some(include_bytes!(concat!(
   43|      1|            env!("CARGO_MANIFEST_DIR"),
   44|      1|            "/assets/emoji/1f44e.png"
   45|      1|        ))),
   46|  4.33k|        "\u{1f4a1}" => Some(include_bytes!(concat!(
   47|      1|            env!("CARGO_MANIFEST_DIR"),
   48|      1|            "/assets/emoji/1f4a1.png"
   49|      1|        ))),
   50|  4.33k|        "\u{2753}" => Some(include_bytes!(concat!(
   51|      1|            env!("CARGO_MANIFEST_DIR"),
   52|      1|            "/assets/emoji/2753.png"
   53|      1|        ))),
   54|  4.33k|        "\u{2757}" => Some(include_bytes!(concat!(
   55|      1|            env!("CARGO_MANIFEST_DIR"),
   56|      1|            "/assets/emoji/2757.png"
   57|      1|        ))),
   58|  4.32k|        "\u{1f4dd}" => Some(include_bytes!(concat!(
   59|      1|            env!("CARGO_MANIFEST_DIR"),
   60|      1|            "/assets/emoji/1f4dd.png"
   61|      1|        ))),
   62|  4.32k|        "\u{1f9e0}" => Some(include_bytes!(concat!(
   63|      1|            env!("CARGO_MANIFEST_DIR"),
   64|      1|            "/assets/emoji/1f9e0.png"
   65|      1|        ))),
   66|  4.32k|        "\u{1f9ea}" => Some(include_bytes!(concat!(
   67|      1|            env!("CARGO_MANIFEST_DIR"),
   68|      1|            "/assets/emoji/1f9ea.png"
   69|      1|        ))),
   70|  4.32k|        "\u{1f4e6}" => Some(include_bytes!(concat!(
   71|      1|            env!("CARGO_MANIFEST_DIR"),
   72|      1|            "/assets/emoji/1f4e6.png"
   73|      1|        ))),
   74|  4.32k|        "\u{1f527}" => Some(include_bytes!(concat!(
   75|      1|            env!("CARGO_MANIFEST_DIR"),
   76|      1|            "/assets/emoji/1f527.png"
   77|      1|        ))),
   78|  4.32k|        _ => None,
   79|       |    }
   80|  4.36k|}
   81|       |
   82|     33|pub fn shortcode_map() -> &'static HashMap<&'static str, &'static str> {
   83|       |    use std::sync::OnceLock;
   84|       |    static MAP: OnceLock<HashMap<&'static str, &'static str>> = OnceLock::new();
   85|     33|    MAP.get_or_init(|| {
                                     ^1
   86|      1|        HashMap::from([
   87|      1|            (":tada:", "\u{1f389}"),
   88|      1|            (":white_check_mark:", "\u{2705}"),
   89|      1|            (":check_mark:", "\u{2705}"),
   90|      1|            (":rocket:", "\u{1f680}"),
   91|      1|            (":slightly_smiling_face:", "\u{1f642}"),
   92|      1|            (":grinning:", "\u{1f600}"),
   93|      1|            (":wink:", "\u{1f609}"),
   94|      1|            (":star:", "\u{2b50}"),
   95|      1|            (":fire:", "\u{1f525}"),
   96|      1|            (":thumbsup:", "\u{1f44d}"),
   97|      1|            (":thumbsdown:", "\u{1f44e}"),
   98|      1|            (":bulb:", "\u{1f4a1}"),
   99|      1|            (":question:", "\u{2753}"),
  100|      1|            (":exclamation:", "\u{2757}"),
  101|      1|            (":memo:", "\u{1f4dd}"),
  102|      1|            (":brain:", "\u{1f9e0}"),
  103|      1|            (":test_tube:", "\u{1f9ea}"),
  104|      1|            (":package:", "\u{1f4e6}"),
  105|      1|            (":wrench:", "\u{1f527}"),
  106|      1|        ])
  107|      1|    })
  108|     33|}
  109|       |
  110|       |#[cfg(test)]
  111|       |#[cfg_attr(coverage_nightly, coverage(off))]
  112|       |mod tests {
  113|       |    use super::*;
  114|       |
  115|       |    #[test]
  116|       |    fn test_image_bytes_for_known_emojis() {
  117|       |        let emojis = [
  118|       |            "\u{1f389}",
  119|       |            "\u{2705}",
  120|       |            "\u{1f680}",
  121|       |            "\u{1f642}",
  122|       |            "\u{1f600}",
  123|       |            "\u{1f609}",
  124|       |            "\u{2b50}",
  125|       |            "\u{1f525}",
  126|       |            "\u{1f44d}",
  127|       |            "\u{1f44e}",
  128|       |            "\u{1f4a1}",
  129|       |            "\u{2753}",
  130|       |            "\u{2757}",
  131|       |            "\u{1f4dd}",
  132|       |            "\u{1f9e0}",
  133|       |            "\u{1f9ea}",
  134|       |            "\u{1f4e6}",
  135|       |            "\u{1f527}",
  136|       |        ];
  137|       |
  138|       |        for emoji in emojis {
  139|       |            let bytes = image_bytes_for(emoji).expect("expected embedded emoji bytes");
  140|       |            assert!(!bytes.is_empty());
  141|       |        }
  142|       |    }
  143|       |
  144|       |    #[test]
  145|       |    fn test_image_bytes_for_unknown_emoji() {
  146|       |        assert!(image_bytes_for("\u{1f47d}").is_none());
  147|       |    }
  148|       |
  149|       |    #[test]
  150|       |    fn test_shortcode_map_contains_expected_entries() {
  151|       |        let map = shortcode_map();
  152|       |        assert_eq!(map.get(":tada:"), Some(&"\u{1f389}"));
  153|       |        assert_eq!(map.get(":white_check_mark:"), Some(&"\u{2705}"));
  154|       |        assert_eq!(map.get(":rocket:"), Some(&"\u{1f680}"));
  155|       |        assert_eq!(map.get(":fire:"), Some(&"\u{1f525}"));
  156|       |        assert_eq!(map.get(":wrench:"), Some(&"\u{1f527}"));
  157|       |        assert!(map.get(":does_not_exist:").is_none());
  158|       |    }
  159|       |}

C:\language\mdmdview\src\image_decode.rs:
    1|       |use egui::ColorImage;
    2|       |#[cfg(test)]
    3|       |use std::cell::RefCell;
    4|       |use std::io::Cursor;
    5|       |
    6|       |#[cfg(test)]
    7|       |thread_local! {
    8|       |    static FORCED_ZERO_SVG_DIMENSIONS: RefCell<bool> = const { RefCell::new(false) };
    9|       |    static FORCED_RASTER_DIMENSIONS: RefCell<Option<(u32, u32)>> = const { RefCell::new(None) };
   10|       |    static FORCED_SVG_DIMENSIONS: RefCell<Option<(u32, u32)>> = const { RefCell::new(None) };
   11|       |    static FORCED_PIXMAP_ALLOC_FAIL: RefCell<bool> = const { RefCell::new(false) };
   12|       |    static FORCED_GUESS_FORMAT_ERROR: RefCell<bool> = const { RefCell::new(false) };
   13|       |}
   14|       |
   15|       |#[cfg(test)]
   16|      9|fn take_forced_zero_svg_dimensions() -> bool {
   17|      9|    FORCED_ZERO_SVG_DIMENSIONS.with(|flag| flag.replace(false))
   18|      9|}
   19|       |
   20|       |#[cfg(test)]
   21|     12|fn take_forced_raster_dimensions() -> Option<(u32, u32)> {
   22|     12|    FORCED_RASTER_DIMENSIONS.with(|dims| dims.borrow_mut().take())
   23|     12|}
   24|       |
   25|       |#[cfg(test)]
   26|      9|fn take_forced_svg_dimensions() -> Option<(u32, u32)> {
   27|      9|    FORCED_SVG_DIMENSIONS.with(|dims| dims.borrow_mut().take())
   28|      9|}
   29|       |
   30|       |#[cfg(test)]
   31|      9|fn take_forced_pixmap_alloc_fail() -> bool {
   32|      9|    FORCED_PIXMAP_ALLOC_FAIL.with(|flag| flag.replace(false))
   33|      9|}
   34|       |
   35|       |#[cfg(test)]
   36|     21|fn take_forced_guess_format_error() -> bool {
   37|     21|    FORCED_GUESS_FORMAT_ERROR.with(|flag| flag.replace(false))
   38|     21|}
   39|       |
   40|       |const MAX_IMAGE_SIDE: u32 = 4096;
   41|       |const MAX_IMAGE_PIXELS: u64 = MAX_IMAGE_SIDE as u64 * MAX_IMAGE_SIDE as u64;
   42|       |const MAX_IMAGE_BYTES: usize = 64 * 1024 * 1024;
   43|       |
   44|       |#[cfg(test)]
   45|      1|pub(crate) fn svg_bytes_to_color_image(bytes: &[u8]) -> Option<(ColorImage, u32, u32)> {
   46|      1|    svg_bytes_to_color_image_with_bg(bytes, None)
   47|      1|}
   48|       |
   49|     21|fn guessed_format_for_test(
   50|     21|    bytes: &[u8],
   51|     21|) -> std::io::Result<image::io::Reader<Cursor<&[u8]>>> {
   52|       |    #[cfg(test)]
   53|     21|    if take_forced_guess_format_error() {
   54|      1|        return Err(std::io::Error::new(
   55|      1|            std::io::ErrorKind::Other,
   56|      1|            "forced guess format error",
   57|      1|        ));
   58|     20|    }
   59|     20|    image::io::Reader::new(Cursor::new(bytes)).with_guessed_format()
   60|     21|}
   61|       |
   62|     21|fn raster_dimensions(bytes: &[u8]) -> Option<(u32, u32)> {
   63|     21|    let reader = guessed_format_for_test(bytes).ok()?;
                      ^20                                         ^1
   64|     20|    reader.into_dimensions().ok()
   65|     21|}
   66|       |
   67|     30|fn raster_exceeds_limits(w: u32, h: u32) -> bool {
   68|     30|    if w == 0 || h == 0 {
                               ^29
   69|      2|        return true;
   70|     28|    }
   71|     28|    if w > MAX_IMAGE_SIDE || h > MAX_IMAGE_SIDE {
                                           ^25
   72|      4|        return true;
   73|     24|    }
   74|     24|    let pixels = (w as u64).saturating_mul(h as u64);
   75|     24|    pixels > MAX_IMAGE_PIXELS
   76|     30|}
   77|       |
   78|      9|fn pixmap_new_for_test(w: u32, h: u32) -> Option<tiny_skia::Pixmap> {
   79|       |    #[cfg(test)]
   80|      9|    if take_forced_pixmap_alloc_fail() {
   81|      1|        return None;
   82|      8|    }
   83|      8|    tiny_skia::Pixmap::new(w, h)
   84|      9|}
   85|       |
   86|     19|pub(crate) fn raster_bytes_to_color_image_with_bg(
   87|     19|    bytes: &[u8],
   88|     19|    bg: Option<[u8; 4]>,
   89|     19|) -> Option<(ColorImage, u32, u32)> {
   90|     19|    if bytes.len() > MAX_IMAGE_BYTES {
   91|      1|        return None;
   92|     18|    }
   93|     18|    if let Some((w, h)) = raster_dimensions(bytes) {
                               ^13^13
   94|     13|        if raster_exceeds_limits(w, h) {
   95|      1|            return None;
   96|     12|        }
   97|      5|    }
   98|     17|    let img = image::load_from_memory(bytes).ok()?;
                      ^12                                      ^5
   99|     12|    let rgba = img.to_rgba8();
  100|     12|    let (w, h) = rgba.dimensions();
  101|       |    #[cfg(test)]
  102|     12|    let (w, h) = if let Some((forced_w, forced_h)) = take_forced_raster_dimensions() {
                                            ^1        ^1
  103|      1|        (forced_w, forced_h)
  104|       |    } else {
  105|     11|        (w, h)
  106|       |    };
  107|     12|    if raster_exceeds_limits(w, h) {
  108|      1|        return None;
  109|     11|    }
  110|     11|    let mut ci = ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &rgba);
  111|     11|    if let Some([br, bgc, bb, ba]) = bg {
                               ^1  ^1   ^1  ^1
  112|      1|        for p in ci.pixels.iter_mut() {
  113|      1|            let a = p[3] as f32 / 255.0;
  114|      1|            let inv = 1.0 - a;
  115|      1|            p[0] = (a * p[0] as f32 + inv * br as f32) as u8;
  116|      1|            p[1] = (a * p[1] as f32 + inv * bgc as f32) as u8;
  117|      1|            p[2] = (a * p[2] as f32 + inv * bb as f32) as u8;
  118|      1|            p[3] = ba;
  119|      1|        }
  120|     10|    }
  121|     11|    Some((ci, w, h))
  122|     19|}
  123|       |
  124|     12|pub(crate) fn svg_bytes_to_color_image_with_bg(
  125|     12|    bytes: &[u8],
  126|     12|    bg: Option<[u8; 4]>,
  127|     12|) -> Option<(ColorImage, u32, u32)> {
  128|     12|    let mut opt = usvg::Options::default();
  129|     12|    let mut db = usvg::fontdb::Database::new();
  130|     12|    db.load_system_fonts();
  131|     12|    opt.fontdb = std::sync::Arc::new(db);
  132|     12|    let tree = usvg::Tree::from_data(bytes, &opt).ok()?;
                      ^9                                            ^3
  133|      9|    let sz = tree.size();
  134|      9|    let pix = sz.to_int_size();
  135|      9|    let (mut w, mut h) = (pix.width(), pix.height());
  136|       |    #[cfg(test)]
  137|      9|    if take_forced_zero_svg_dimensions() {
  138|      1|        w = 0;
  139|      1|        h = 0;
  140|      8|    }
  141|       |    #[cfg(test)]
  142|      9|    if let Some((forced_w, forced_h)) = take_forced_svg_dimensions() {
                               ^1        ^1
  143|      1|        w = forced_w;
  144|      1|        h = forced_h;
  145|      8|    }
  146|      9|    if w == 0 || h == 0 {
                               ^8
  147|      2|        w = 256;
  148|      2|        h = 256;
  149|      7|    }
  150|      9|    let max_side: u32 = MAX_IMAGE_SIDE;
  151|      9|    if w > max_side || h > max_side {
                                     ^7
  152|      3|        let scale = (max_side as f32 / w as f32).min(max_side as f32 / h as f32);
  153|      3|        w = (w as f32 * scale) as u32;
  154|      3|        h = (h as f32 * scale) as u32;
  155|      6|    }
  156|      9|    let mut pixmap = pixmap_new_for_test(w, h)?;
                      ^8                                    ^1
  157|      8|    if let Some([r, g, b, a]) = bg {
                               ^1 ^1 ^1 ^1
  158|      1|        let color = tiny_skia::Color::from_rgba8(r, g, b, a);
  159|      1|        pixmap.fill(color);
  160|      7|    }
  161|      8|    let mut pmut = pixmap.as_mut();
  162|      8|    resvg::render(&tree, tiny_skia::Transform::identity(), &mut pmut);
  163|      8|    let data = pixmap.data();
  164|      8|    let img = ColorImage::from_rgba_unmultiplied([w as usize, h as usize], data);
  165|      8|    Some((img, w, h))
  166|     12|}
  167|       |
  168|     16|pub(crate) fn bytes_to_color_image_guess(
  169|     16|    bytes: &[u8],
  170|     16|    bg: Option<[u8; 4]>,
  171|     16|) -> Option<(ColorImage, u32, u32)> {
  172|     16|    if let Some(img) = raster_bytes_to_color_image_with_bg(bytes, bg) {
                              ^11
  173|     11|        return Some(img);
  174|      5|    }
  175|      5|    svg_bytes_to_color_image_with_bg(bytes, bg)
  176|     16|}
  177|       |
  178|       |#[cfg(test)]
  179|       |#[cfg_attr(coverage_nightly, coverage(off))]
  180|       |mod tests {
  181|       |    use super::*;
  182|       |    use image::{ImageOutputFormat, RgbaImage};
  183|       |    use std::io::Cursor;
  184|       |
  185|       |    struct ForcedZeroSvgDimensions;
  186|       |
  187|       |    impl ForcedZeroSvgDimensions {
  188|       |        fn new() -> Self {
  189|       |            FORCED_ZERO_SVG_DIMENSIONS.with(|flag| flag.replace(true));
  190|       |            Self
  191|       |        }
  192|       |    }
  193|       |
  194|       |    struct ForcedRasterDimensions;
  195|       |
  196|       |    impl ForcedRasterDimensions {
  197|       |        fn new(w: u32, h: u32) -> Self {
  198|       |            FORCED_RASTER_DIMENSIONS.with(|dims| {
  199|       |                *dims.borrow_mut() = Some((w, h));
  200|       |            });
  201|       |            Self
  202|       |        }
  203|       |    }
  204|       |
  205|       |    impl Drop for ForcedRasterDimensions {
  206|       |        fn drop(&mut self) {
  207|       |            FORCED_RASTER_DIMENSIONS.with(|dims| {
  208|       |                dims.borrow_mut().take();
  209|       |            });
  210|       |        }
  211|       |    }
  212|       |
  213|       |    struct ForcedSvgDimensions;
  214|       |
  215|       |    impl ForcedSvgDimensions {
  216|       |        fn new(w: u32, h: u32) -> Self {
  217|       |            FORCED_SVG_DIMENSIONS.with(|dims| {
  218|       |                *dims.borrow_mut() = Some((w, h));
  219|       |            });
  220|       |            Self
  221|       |        }
  222|       |    }
  223|       |
  224|       |    impl Drop for ForcedSvgDimensions {
  225|       |        fn drop(&mut self) {
  226|       |            FORCED_SVG_DIMENSIONS.with(|dims| {
  227|       |                dims.borrow_mut().take();
  228|       |            });
  229|       |        }
  230|       |    }
  231|       |
  232|       |    struct ForcedPixmapAllocFail;
  233|       |
  234|       |    impl ForcedPixmapAllocFail {
  235|       |        fn new() -> Self {
  236|       |            FORCED_PIXMAP_ALLOC_FAIL.with(|flag| flag.replace(true));
  237|       |            Self
  238|       |        }
  239|       |    }
  240|       |
  241|       |    impl Drop for ForcedPixmapAllocFail {
  242|       |        fn drop(&mut self) {
  243|       |            FORCED_PIXMAP_ALLOC_FAIL.with(|flag| flag.replace(false));
  244|       |        }
  245|       |    }
  246|       |
  247|       |    struct ForcedGuessFormatError;
  248|       |
  249|       |    impl ForcedGuessFormatError {
  250|       |        fn new() -> Self {
  251|       |            FORCED_GUESS_FORMAT_ERROR.with(|flag| flag.replace(true));
  252|       |            Self
  253|       |        }
  254|       |    }
  255|       |
  256|       |    impl Drop for ForcedGuessFormatError {
  257|       |        fn drop(&mut self) {
  258|       |            FORCED_GUESS_FORMAT_ERROR.with(|flag| flag.replace(false));
  259|       |        }
  260|       |    }
  261|       |
  262|       |    fn encode_png(rgba: &RgbaImage) -> Vec<u8> {
  263|       |        let mut bytes = Vec::new();
  264|       |        let mut cursor = Cursor::new(&mut bytes);
  265|       |        image::DynamicImage::ImageRgba8(rgba.clone())
  266|       |            .write_to(&mut cursor, ImageOutputFormat::Png)
  267|       |            .expect("encode png");
  268|       |        bytes
  269|       |    }
  270|       |
  271|       |    #[test]
  272|       |    fn test_raster_dimensions_invalid_bytes_returns_none() {
  273|       |        assert!(raster_dimensions(&[]).is_none());
  274|       |    }
  275|       |
  276|       |    #[test]
  277|       |    fn test_raster_dimensions_valid_png_returns_some() {
  278|       |        let mut rgba = RgbaImage::new(2, 1);
  279|       |        rgba.put_pixel(0, 0, image::Rgba([0, 0, 0, 255]));
  280|       |        rgba.put_pixel(1, 0, image::Rgba([255, 255, 255, 255]));
  281|       |        let bytes = encode_png(&rgba);
  282|       |        assert_eq!(raster_dimensions(&bytes), Some((2, 1)));
  283|       |    }
  284|       |
  285|       |    #[test]
  286|       |    fn test_raster_dimensions_forced_guess_error_returns_none() {
  287|       |        let _guard = ForcedGuessFormatError::new();
  288|       |        let mut rgba = RgbaImage::new(1, 1);
  289|       |        rgba.put_pixel(0, 0, image::Rgba([0, 0, 0, 255]));
  290|       |        let bytes = encode_png(&rgba);
  291|       |        assert!(raster_dimensions(&bytes).is_none());
  292|       |    }
  293|       |
  294|       |    #[test]
  295|       |    fn test_bytes_to_color_image_guess_png_blends_background() {
  296|       |        let mut rgba = RgbaImage::new(1, 1);
  297|       |        rgba.put_pixel(0, 0, image::Rgba([255, 0, 0, 255]));
  298|       |        let bytes = encode_png(&rgba);
  299|       |
  300|       |        let bg = [0, 0, 255, 200];
  301|       |        let (img, w, h) = bytes_to_color_image_guess(&bytes, Some(bg)).expect("png decode");
  302|       |        assert_eq!((w, h), (1, 1));
  303|       |
  304|       |        let px = img.pixels[0];
  305|       |        assert_eq!(px[0], 255);
  306|       |        assert_eq!(px[1], 0);
  307|       |        assert_eq!(px[2], 0);
  308|       |        assert_eq!(px[3], bg[3]);
  309|       |    }
  310|       |
  311|       |    #[test]
  312|       |    fn test_svg_bytes_to_color_image_scales_and_fills_bg() {
  313|       |        let svg = r#"<svg width="5000" height="3000" xmlns="http://www.w3.org/2000/svg">
  314|       | <rect width="5000" height="3000" fill="red"/>
  315|       | </svg>"#;
  316|       |        let bg = Some([1, 2, 3, 255]);
  317|       |        let (_img, w, h) =
  318|       |            svg_bytes_to_color_image_with_bg(svg.as_bytes(), bg).expect("svg decode");
  319|       |        assert!(w > 0);
  320|       |        assert!(h > 0);
  321|       |        assert!(w <= 4096);
  322|       |        assert!(h <= 4096);
  323|       |    }
  324|       |
  325|       |    #[test]
  326|       |    fn test_svg_bytes_to_color_image_forced_pixmap_fail_returns_none() {
  327|       |        let _guard = ForcedPixmapAllocFail::new();
  328|       |        let svg = r#"<svg width="10" height="10" xmlns="http://www.w3.org/2000/svg">
  329|       | <rect width="10" height="10" fill="red"/>
  330|       |</svg>"#;
  331|       |        assert!(svg_bytes_to_color_image_with_bg(svg.as_bytes(), None).is_none());
  332|       |    }
  333|       |
  334|       |    #[test]
  335|       |    fn test_svg_bytes_to_color_image_invalid_returns_none() {
  336|       |        assert!(svg_bytes_to_color_image(b"not svg").is_none());
  337|       |    }
  338|       |
  339|       |    #[test]
  340|       |    fn test_raster_bytes_rejects_large_dimensions() {
  341|       |        let mut rgba = RgbaImage::new(5000, 1);
  342|       |        rgba.put_pixel(0, 0, image::Rgba([0, 0, 0, 255]));
  343|       |        let bytes = encode_png(&rgba);
  344|       |        assert!(raster_bytes_to_color_image_with_bg(&bytes, None).is_none());
  345|       |    }
  346|       |
  347|       |    #[test]
  348|       |    fn test_raster_bytes_rejects_forced_post_decode_limits() {
  349|       |        let mut rgba = RgbaImage::new(1, 1);
  350|       |        rgba.put_pixel(0, 0, image::Rgba([0, 0, 0, 255]));
  351|       |        let bytes = encode_png(&rgba);
  352|       |        let _forced = ForcedRasterDimensions::new(MAX_IMAGE_SIDE + 1, 1);
  353|       |        assert!(raster_bytes_to_color_image_with_bg(&bytes, None).is_none());
  354|       |    }
  355|       |
  356|       |    #[test]
  357|       |    fn test_bytes_to_color_image_guess_svg_fallback() {
  358|       |        let svg = r#"<svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">
  359|       |<circle cx="32" cy="32" r="20" fill="blue"/>
  360|       |</svg>"#;
  361|       |        let (_img, w, h) = bytes_to_color_image_guess(svg.as_bytes(), None).expect("svg fallback");
  362|       |        assert_eq!((w, h), (64, 64));
  363|       |    }
  364|       |
  365|       |    #[test]
  366|       |    fn test_raster_exceeds_limits_zero_dimensions() {
  367|       |        assert!(raster_exceeds_limits(0, 10));
  368|       |        assert!(raster_exceeds_limits(10, 0));
  369|       |    }
  370|       |
  371|       |    #[test]
  372|       |    fn test_raster_exceeds_limits_large_sides() {
  373|       |        assert!(raster_exceeds_limits(MAX_IMAGE_SIDE + 1, 1));
  374|       |        assert!(raster_exceeds_limits(1, MAX_IMAGE_SIDE + 1));
  375|       |    }
  376|       |
  377|       |    #[test]
  378|       |    fn test_raster_exceeds_limits_within_bounds() {
  379|       |        assert!(!raster_exceeds_limits(MAX_IMAGE_SIDE, MAX_IMAGE_SIDE));
  380|       |    }
  381|       |
  382|       |    #[test]
  383|       |    fn test_raster_bytes_rejects_large_buffer() {
  384|       |        let bytes = vec![0u8; MAX_IMAGE_BYTES + 1];
  385|       |        assert!(raster_bytes_to_color_image_with_bg(&bytes, None).is_none());
  386|       |    }
  387|       |
  388|       |    #[test]
  389|       |    fn test_svg_zero_dimensions_defaults_to_256() {
  390|       |        let _forced = ForcedZeroSvgDimensions::new();
  391|       |        let svg = r#"<svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">
  392|       |<rect width="64" height="64" fill="red"/>
  393|       |</svg>"#;
  394|       |        let (_img, w, h) =
  395|       |            svg_bytes_to_color_image_with_bg(svg.as_bytes(), None).expect("svg decode");
  396|       |        assert_eq!((w, h), (256, 256));
  397|       |    }
  398|       |
  399|       |    #[test]
  400|       |    fn test_svg_zero_height_defaults_to_256() {
  401|       |        let _forced = ForcedSvgDimensions::new(64, 0);
  402|       |        let svg = r#"<svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">
  403|       |<rect width="64" height="64" fill="red"/>
  404|       |</svg>"#;
  405|       |        let (_img, w, h) =
  406|       |            svg_bytes_to_color_image_with_bg(svg.as_bytes(), None).expect("svg decode");
  407|       |        assert_eq!((w, h), (256, 256));
  408|       |    }
  409|       |
  410|       |    #[test]
  411|       |    fn test_svg_bytes_to_color_image_scales_large_dimensions() {
  412|       |        let svg = r#"<svg width="8192" height="8192" xmlns="http://www.w3.org/2000/svg">
  413|       |<rect width="8192" height="8192" fill="red"/>
  414|       |</svg>"#;
  415|       |        let (_img, w, h) =
  416|       |            svg_bytes_to_color_image_with_bg(svg.as_bytes(), None).expect("svg decode");
  417|       |        assert!(w <= 4096);
  418|       |        assert!(h <= 4096);
  419|       |        assert!(w > 0);
  420|       |        assert!(h > 0);
  421|       |    }
  422|       |
  423|       |    #[test]
  424|       |    fn test_svg_bytes_to_color_image_scales_tall_dimensions() {
  425|       |        let svg = r#"<svg width="64" height="8192" xmlns="http://www.w3.org/2000/svg">
  426|       |<rect width="64" height="8192" fill="red"/>
  427|       |</svg>"#;
  428|       |        let (_img, w, h) =
  429|       |            svg_bytes_to_color_image_with_bg(svg.as_bytes(), None).expect("svg decode");
  430|       |        assert!(w <= 4096);
  431|       |        assert!(h <= 4096);
  432|       |        assert!(w > 0);
  433|       |        assert!(h > 0);
  434|       |    }
  435|       |}

C:\language\mdmdview\src\main.rs:
    1|       |#![cfg_attr(coverage_nightly, feature(coverage_attribute))]
    2|       |#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")] // Hide console in release mode
    3|       |
    4|       |#[cfg(not(test))]
    5|       |use mdmdview::app::{ScreenshotConfig, ScreenshotTheme};
    6|       |/// Main entry point for the MarkdownView application
    7|       |///
    8|       |/// A simple, standalone markdown viewer for Windows built with Rust and egui.
    9|       |/// This application provides a clean interface for viewing markdown files with
   10|       |/// syntax highlighting, embedded samples, and essential viewing features.
   11|       |#[cfg(not(test))]
   12|       |use mdmdview::{load_window_state, sanitize_window_state, MarkdownViewerApp, APP_TITLE_PREFIX};
   13|       |#[cfg(not(test))]
   14|       |use std::path::Path;
   15|       |use std::path::PathBuf;
   16|       |
   17|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
   18|       |enum ThemeChoice {
   19|       |    Light,
   20|       |    Dark,
   21|       |}
   22|       |
   23|       |#[derive(Default)]
   24|       |struct CliOptions {
   25|       |    initial_file: Option<PathBuf>,
   26|       |    screenshot: bool,
   27|       |    screenshot_output: Option<PathBuf>,
   28|       |    width: Option<f32>,
   29|       |    height: Option<f32>,
   30|       |    theme: Option<ThemeChoice>,
   31|       |    zoom: Option<f32>,
   32|       |    content_only: bool,
   33|       |    scroll: Option<f32>,
   34|       |    wait_ms: Option<u64>,
   35|       |    settle_frames: Option<u32>,
   36|       |    test_fonts: Option<PathBuf>,
   37|       |}
   38|       |
   39|       |#[cfg(not(test))]
   40|       |fn parse_cli_args() -> Result<CliOptions, String> {
   41|       |    parse_cli_from(std::env::args().skip(1))
   42|       |}
   43|       |
   44|     23|fn parse_cli_from<I>(args: I) -> Result<CliOptions, String>
   45|     23|where
   46|     23|    I: IntoIterator<Item = String>,
   47|       |{
   48|     23|    let mut opts = CliOptions::default();
   49|     23|    let mut iter = args.into_iter();
   50|       |
   51|     43|    while let Some(arg) = iter.next() {
                                 ^37
   52|     37|        match arg.as_str() {
   53|     37|            "--screenshot" => {
   54|      4|                opts.screenshot = true;
   55|      4|                let value = next_value(&mut iter, "--screenshot")?;
                                  ^3                                           ^1
   56|      3|                opts.initial_file = Some(PathBuf::from(value));
   57|       |            }
   58|     33|            "--output" => {
   59|      3|                let value = next_value(&mut iter, "--output")?;
                                  ^2                                       ^1
   60|      2|                opts.screenshot_output = Some(PathBuf::from(value));
   61|       |            }
   62|     30|            "--width" => {
   63|      3|                let value = next_value(&mut iter, "--width")?;
                                  ^2                                      ^1
   64|      2|                opts.width = Some(parse_f32("--width", &value)?);
                                                                            ^1
   65|       |            }
   66|     27|            "--height" => {
   67|      3|                let value = next_value(&mut iter, "--height")?;
                                  ^2                                       ^1
   68|      2|                opts.height = Some(parse_f32("--height", &value)?);
                                                                              ^1
   69|       |            }
   70|     24|            "--theme" => {
   71|      4|                let value = next_value(&mut iter, "--theme")?;
                                  ^3                                      ^1
   72|      3|                opts.theme = Some(parse_theme(&value)?);
                                                                   ^1
   73|       |            }
   74|     20|            "--zoom" => {
   75|      3|                let value = next_value(&mut iter, "--zoom")?;
                                  ^2                                     ^1
   76|      2|                opts.zoom = Some(parse_f32("--zoom", &value)?);
                                                                          ^1
   77|       |            }
   78|     17|            "--content-only" => opts.content_only = true,
                                              ^1
   79|     16|            "--scroll" => {
   80|      4|                let value = next_value(&mut iter, "--scroll")?;
                                  ^3                                       ^1
   81|      3|                let ratio = parse_f32("--scroll", &value)?.clamp(0.0, 1.0);
                                  ^2                                   ^1^2
   82|      2|                opts.scroll = Some(ratio);
   83|       |            }
   84|     12|            "--wait-ms" => {
   85|      3|                let value = next_value(&mut iter, "--wait-ms")?;
                                  ^2                                        ^1
   86|      2|                opts.wait_ms = Some(parse_u64("--wait-ms", &value)?);
                                                                                ^1
   87|       |            }
   88|      9|            "--settle-frames" => {
   89|      3|                let value = next_value(&mut iter, "--settle-frames")?;
                                  ^2                                              ^1
   90|      2|                opts.settle_frames = Some(parse_u32("--settle-frames", &value)?);
                                                                                            ^1
   91|       |            }
   92|      6|            "--test-fonts" => {
   93|      2|                let value = next_value(&mut iter, "--test-fonts")?;
                                  ^1                                           ^1
   94|      1|                opts.test_fonts = Some(PathBuf::from(value));
   95|       |            }
   96|      4|            _ if opts.initial_file.is_none() => opts.initial_file = Some(PathBuf::from(arg)),
                                                         ^3   ^3
   97|      1|            _ => {}
   98|       |        }
   99|       |    }
  100|       |
  101|      6|    if opts.screenshot && opts.screenshot_output.is_none() {
                                        ^3                     ^3
  102|      1|        return Err("Missing --output for screenshot mode".to_string());
  103|      5|    }
  104|       |
  105|      5|    Ok(opts)
  106|     23|}
  107|       |
  108|     32|fn next_value<I>(iter: &mut I, flag: &str) -> Result<String, String>
  109|     32|where
  110|     32|    I: Iterator<Item = String>,
  111|       |{
  112|     32|    iter.next()
  113|     32|        .ok_or_else(|| format!("{flag} requires a value"))
                                     ^10     ^10
  114|     32|}
  115|       |
  116|      3|fn parse_theme(value: &str) -> Result<ThemeChoice, String> {
  117|      3|    match value.trim().to_ascii_lowercase().as_str() {
  118|      3|        "light" => Ok(ThemeChoice::Light),
                                 ^1
  119|      2|        "dark" => Ok(ThemeChoice::Dark),
                                ^1
  120|      1|        _ => Err(format!("Unsupported theme: {value}")),
  121|       |    }
  122|      3|}
  123|       |
  124|      7|fn parse_hex_color32(value: &str) -> Option<egui::Color32> {
  125|      7|    let hex = value.trim().trim_start_matches('#');
  126|      7|    if hex.len() != 6 {
  127|      2|        return None;
  128|      5|    }
  129|      5|    let r = u8::from_str_radix(&hex[0..2], 16).ok()?;
                      ^4                                         ^1
  130|      4|    let g = u8::from_str_radix(&hex[2..4], 16).ok()?;
                      ^3                                         ^1
  131|      3|    let b = u8::from_str_radix(&hex[4..6], 16).ok()?;
                      ^2                                         ^1
  132|      2|    Some(egui::Color32::from_rgb(r, g, b))
  133|      7|}
  134|       |
  135|      3|fn screenshot_background_color() -> egui::Color32 {
  136|      3|    if let Ok(hex) = std::env::var("MDMDVIEW_MERMAID_MAIN_BKG") {
                            ^2
  137|      2|        if let Some(color) = parse_hex_color32(&hex) {
                                  ^1
  138|      1|            return color;
  139|      1|        }
  140|      1|    }
  141|      2|    egui::Color32::from_rgb(255, 248, 219)
  142|      3|}
  143|       |
  144|      9|fn parse_f32(flag: &str, value: &str) -> Result<f32, String> {
  145|      9|    value
  146|      9|        .parse::<f32>()
  147|      9|        .map_err(|_| format!("Invalid {flag} value: {value}"))
                                   ^4      ^4
  148|      9|}
  149|       |
  150|      4|fn parse_u32(flag: &str, value: &str) -> Result<u32, String> {
  151|      4|    value
  152|      4|        .parse::<u32>()
  153|      4|        .map_err(|_| format!("Invalid {flag} value: {value}"))
                                   ^2      ^2
  154|      4|}
  155|       |
  156|      4|fn parse_u64(flag: &str, value: &str) -> Result<u64, String> {
  157|      4|    value
  158|      4|        .parse::<u64>()
  159|      4|        .map_err(|_| format!("Invalid {flag} value: {value}"))
                                   ^2      ^2
  160|      4|}
  161|       |
  162|       |#[cfg(not(test))]
  163|       |fn load_fonts_from_dir(ctx: &egui::Context, dir: &Path) -> Result<(), String> {
  164|       |    let mut font_paths: Vec<PathBuf> = std::fs::read_dir(dir)
  165|       |        .map_err(|e| format!("Failed to read font dir {dir:?}: {e}"))?
  166|       |        .filter_map(|entry| entry.ok().map(|e| e.path()))
  167|       |        .filter(|path| {
  168|       |            path.extension()
  169|       |                .and_then(|ext| ext.to_str())
  170|       |                .map(|ext| matches!(ext.to_ascii_lowercase().as_str(), "ttf" | "otf"))
  171|       |                .unwrap_or(false)
  172|       |        })
  173|       |        .collect();
  174|       |
  175|       |    if font_paths.is_empty() {
  176|       |        return Err(format!("No font files found in {dir:?}"));
  177|       |    }
  178|       |
  179|       |    font_paths.sort_by(|a, b| a.to_string_lossy().cmp(&b.to_string_lossy()));
  180|       |
  181|       |    let mut fonts = egui::FontDefinitions::default();
  182|       |    let mut prop_names = Vec::new();
  183|       |    let mut mono_names = Vec::new();
  184|       |    let mut used_names = std::collections::HashSet::new();
  185|       |
  186|       |    for path in font_paths {
  187|       |        let bytes =
  188|       |            std::fs::read(&path).map_err(|e| format!("Failed to read font {path:?}: {e}"))?;
  189|       |        let name = path
  190|       |            .file_stem()
  191|       |            .and_then(|stem| stem.to_str())
  192|       |            .map(|stem| stem.to_string())
  193|       |            .unwrap_or_else(|| format!("font-{}", prop_names.len() + mono_names.len()));
  194|       |        let base = format!("test-{name}");
  195|       |        let mut name = base.clone();
  196|       |        let mut counter = 1usize;
  197|       |        while used_names.contains(&name) {
  198|       |            name = format!("{base}-{counter}");
  199|       |            counter += 1;
  200|       |        }
  201|       |        used_names.insert(name.clone());
  202|       |
  203|       |        fonts
  204|       |            .font_data
  205|       |            .insert(name.clone(), egui::FontData::from_owned(bytes));
  206|       |
  207|       |        let lower = name.to_ascii_lowercase();
  208|       |        if lower.contains("mono") || lower.contains("code") {
  209|       |            mono_names.push(name);
  210|       |        } else {
  211|       |            prop_names.push(name);
  212|       |        }
  213|       |    }
  214|       |
  215|       |    if prop_names.is_empty() {
  216|       |        prop_names = mono_names.clone();
  217|       |    }
  218|       |    if mono_names.is_empty() {
  219|       |        mono_names = prop_names.clone();
  220|       |    }
  221|       |
  222|       |    if let Some(family) = fonts.families.get_mut(&egui::FontFamily::Proportional) {
  223|       |        for name in prop_names.iter().rev() {
  224|       |            family.insert(0, name.clone());
  225|       |        }
  226|       |    }
  227|       |    if let Some(family) = fonts.families.get_mut(&egui::FontFamily::Monospace) {
  228|       |        for name in mono_names.iter().rev() {
  229|       |            family.insert(0, name.clone());
  230|       |        }
  231|       |    }
  232|       |
  233|       |    ctx.set_fonts(fonts);
  234|       |    Ok(())
  235|       |}
  236|       |
  237|       |/// Application entry point
  238|       |#[cfg(not(test))]
  239|       |fn main() -> Result<(), eframe::Error> {
  240|       |    // Configure logging for debugging (only in debug builds)
  241|       |    #[cfg(debug_assertions)]
  242|       |    env_logger::init();
  243|       |
  244|       |    let cli = match parse_cli_args() {
  245|       |        Ok(opts) => opts,
  246|       |        Err(err) => {
  247|       |            eprintln!("{err}");
  248|       |            return Ok(());
  249|       |        }
  250|       |    };
  251|       |
  252|       |    let screenshot_enabled = cli.screenshot;
  253|       |    let resolved_theme = if screenshot_enabled {
  254|       |        Some(cli.theme.unwrap_or(ThemeChoice::Light))
  255|       |    } else {
  256|       |        cli.theme
  257|       |    };
  258|       |    let screenshot_zoom = cli.zoom.unwrap_or(1.0);
  259|       |
  260|       |    let default_width = if screenshot_enabled { 1280.0 } else { 1000.0 };
  261|       |    let default_height = if screenshot_enabled { 720.0 } else { 700.0 };
  262|       |    let window_width = cli.width.unwrap_or(default_width);
  263|       |    let window_height = cli.height.unwrap_or(default_height);
  264|       |
  265|       |    // Set up eframe options for the native window
  266|       |    let mut viewport = egui::ViewportBuilder::default()
  267|       |        .with_title(format!("{APP_TITLE_PREFIX} - A Simple Markdown Viewer"))
  268|       |        .with_inner_size(egui::Vec2::new(window_width, window_height))
  269|       |        .with_min_inner_size(egui::Vec2::new(
  270|       |            if screenshot_enabled { 100.0 } else { 600.0 },
  271|       |            if screenshot_enabled { 100.0 } else { 400.0 },
  272|       |        ))
  273|       |        .with_icon(create_app_icon())
  274|       |        .with_resizable(!screenshot_enabled)
  275|       |        .with_maximize_button(!screenshot_enabled)
  276|       |        .with_minimize_button(!screenshot_enabled)
  277|       |        .with_drag_and_drop(!screenshot_enabled);
  278|       |
  279|       |    // Restore previous window position/size if available
  280|       |    if !screenshot_enabled {
  281|       |        if let Some(ws) = load_window_state() {
  282|       |            if let Some(ws) = sanitize_window_state(ws) {
  283|       |                viewport = viewport
  284|       |                    .with_inner_size(egui::Vec2::new(ws.size[0], ws.size[1]))
  285|       |                    .with_position(egui::pos2(ws.pos[0], ws.pos[1]))
  286|       |                    .with_maximized(ws.maximized);
  287|       |            }
  288|       |        }
  289|       |    }
  290|       |
  291|       |    let native_options = eframe::NativeOptions {
  292|       |        viewport,
  293|       |        // Disable eframe's built-in window persistence - we handle it ourselves via
  294|       |        // load_window_state/save_window_state to avoid conflicts
  295|       |        persist_window: false,
  296|       |        ..Default::default()
  297|       |    };
  298|       |
  299|       |    let initial_file = cli.initial_file.clone();
  300|       |    let test_fonts = cli.test_fonts.clone();
  301|       |    let screenshot_config = if screenshot_enabled {
  302|       |        let theme = match resolved_theme.unwrap_or(ThemeChoice::Light) {
  303|       |            ThemeChoice::Light => ScreenshotTheme::Light,
  304|       |            ThemeChoice::Dark => ScreenshotTheme::Dark,
  305|       |        };
  306|       |        Some(ScreenshotConfig {
  307|       |            output_path: cli
  308|       |                .screenshot_output
  309|       |                .clone()
  310|       |                .expect("screenshot output required"),
  311|       |            viewport_width: window_width,
  312|       |            viewport_height: window_height,
  313|       |            content_only: cli.content_only,
  314|       |            scroll_ratio: cli.scroll,
  315|       |            wait_ms: cli.wait_ms.unwrap_or(2000),
  316|       |            settle_frames: cli.settle_frames.unwrap_or(3),
  317|       |            zoom: screenshot_zoom,
  318|       |            theme,
  319|       |            font_source: test_fonts
  320|       |                .as_ref()
  321|       |                .map(|path| path.to_string_lossy().to_string()),
  322|       |        })
  323|       |    } else {
  324|       |        None
  325|       |    };
  326|       |
  327|       |    // Launch the application
  328|       |    eframe::run_native(
  329|       |        APP_TITLE_PREFIX,
  330|       |        native_options,
  331|       |        Box::new(move |cc| {
  332|       |            if let Some(theme) = resolved_theme {
  333|       |                let mut visuals = match theme {
  334|       |                    ThemeChoice::Light => egui::Visuals::light(),
  335|       |                    ThemeChoice::Dark => egui::Visuals::dark(),
  336|       |                };
  337|       |                if screenshot_enabled {
  338|       |                    let bg = screenshot_background_color();
  339|       |                    visuals.panel_fill = bg;
  340|       |                    visuals.window_fill = bg;
  341|       |                    visuals.extreme_bg_color = bg;
  342|       |                    visuals.faint_bg_color = bg;
  343|       |                }
  344|       |                cc.egui_ctx.set_visuals(visuals);
  345|       |            }
  346|       |
  347|       |            // Configure egui styling for better markdown display
  348|       |            configure_egui_style(&cc.egui_ctx);
  349|       |            if let Some(font_dir) = test_fonts.as_ref() {
  350|       |                if let Err(err) = load_fonts_from_dir(&cc.egui_ctx, font_dir) {
  351|       |                    eprintln!("{err}");
  352|       |                }
  353|       |            }
  354|       |
  355|       |            let mut app = MarkdownViewerApp::new();
  356|       |            if screenshot_zoom != 1.0 {
  357|       |                app.set_zoom_scale(screenshot_zoom);
  358|       |            }
  359|       |            if let Some(config) = screenshot_config {
  360|       |                app.set_screenshot_mode(config);
  361|       |            }
  362|       |
  363|       |            // Load initial file if provided via command line
  364|       |            if let Some(file_path) = initial_file {
  365|       |                if file_path.exists() && file_path.is_file() {
  366|       |                    if let Err(e) = app.load_file(file_path, true) {
  367|       |                        eprintln!("Failed to load file: {}", e);
  368|       |                        // Continue with default welcome screen
  369|       |                    }
  370|       |                } else {
  371|       |                    eprintln!("File not found: {}", file_path.display());
  372|       |                    // Continue with default welcome screen
  373|       |                }
  374|       |            }
  375|       |
  376|       |            Box::new(app)
  377|       |        }),
  378|       |    )
  379|       |}
  380|       |
  381|       |#[cfg(test)]
  382|      1|fn main() {}
  383|       |
  384|       |/// Create an application icon from embedded data
  385|      2|fn create_app_icon() -> egui::IconData {
  386|       |    // Create a 32x32 markdown-style document icon
  387|      2|    let size = 32;
  388|      2|    let mut rgba_data = Vec::with_capacity(size * size * 4);
  389|       |
  390|     64|    for y in 0..size {
                              ^2
  391|  2.04k|        for x in 0..size {
                                  ^64
  392|  2.04k|            let (r, g, b, a) = if x == 0 || x == size - 1 || y == 0 || y == size - 1 {
                                                          ^1.98k           ^1.92k    ^1.86k
  393|       |                // Border
  394|    248|                (60, 60, 60, 255)
  395|  1.80k|            } else if x == 1 || x == size - 2 || y == 1 || y == size - 2 {
                                              ^1.74k           ^1.68k    ^1.62k
  396|       |                // Inner border for depth
  397|    232|                (80, 80, 80, 255)
  398|  1.56k|            } else if (4..=8).contains(&y) && (4..=28).contains(&x) {
                                                             ^280    ^280     ^280
  399|       |                // Header area (title bar)
  400|    250|                if (6..=12).contains(&x) {
  401|     70|                    (100, 150, 255, 255) // Blue for # header
  402|    180|                } else if (14..=26).contains(&x) {
  403|    130|                    (200, 200, 200, 255) // Light text
  404|       |                } else {
  405|     50|                    (250, 250, 250, 255) // Background
  406|       |                }
  407|  1.31k|            } else if (11..=13).contains(&y) && (4..=28).contains(&x) {
                                                               ^168    ^168     ^168
  408|       |                // Text line 1
  409|    150|                if (6..=8).contains(&x) {
  410|     18|                    (150, 150, 150, 255) // Bullet point
  411|    132|                } else if (10..=24).contains(&x) {
  412|     90|                    (180, 180, 180, 255) // Text
  413|       |                } else {
  414|     42|                    (250, 250, 250, 255) // Background
  415|       |                }
  416|  1.16k|            } else if (15..=17).contains(&y) && (4..=28).contains(&x) {
                                                               ^168    ^168     ^168
  417|       |                // Text line 2
  418|    150|                if (6..=8).contains(&x) {
  419|     18|                    (150, 150, 150, 255) // Bullet point
  420|    132|                } else if (10..=22).contains(&x) {
  421|     78|                    (180, 180, 180, 255) // Text
  422|       |                } else {
  423|     54|                    (250, 250, 250, 255) // Background
  424|       |                }
  425|  1.01k|            } else if (20..=22).contains(&y) && (6..=26).contains(&x) {
                                                               ^168    ^168     ^168
  426|       |                // Code block area
  427|    126|                if (8..=24).contains(&x) {
  428|    102|                    (100, 255, 100, 255) // Green code text
  429|       |                } else {
  430|     24|                    (40, 40, 40, 255) // Dark background
  431|       |                }
  432|    892|            } else if (25..=27).contains(&y) && (4..=28).contains(&x) {
                                                               ^168    ^168     ^168
  433|       |                // Text line 3
  434|    150|                if (6..=20).contains(&x) {
  435|     90|                    (180, 180, 180, 255) // Text
  436|       |                } else {
  437|     60|                    (250, 250, 250, 255) // Background
  438|       |                }
  439|       |            } else {
  440|       |                // Document background
  441|    742|                (250, 250, 250, 255)
  442|       |            };
  443|       |
  444|  2.04k|            rgba_data.extend_from_slice(&[r, g, b, a]);
  445|       |        }
  446|       |    }
  447|       |
  448|      2|    egui::IconData {
  449|      2|        rgba: rgba_data,
  450|      2|        width: size as u32,
  451|      2|        height: size as u32,
  452|      2|    }
  453|      2|}
  454|       |
  455|       |/// Configure egui styling for optimal markdown display
  456|      2|fn configure_egui_style(ctx: &egui::Context) {
  457|      2|    let mut style = (*ctx.style()).clone();
  458|       |
  459|       |    // Configure spacing for better readability
  460|      2|    style.spacing.item_spacing = egui::Vec2::new(8.0, 8.0);
  461|      2|    style.spacing.window_margin = egui::Margin::same(8.0);
  462|      2|    style.spacing.menu_margin = egui::Margin::same(6.0);
  463|       |
  464|       |    // Configure interaction settings
  465|      2|    style.interaction.resize_grab_radius_side = 8.0;
  466|      2|    style.interaction.resize_grab_radius_corner = 12.0;
  467|       |
  468|       |    // Configure visuals for better contrast with black background
  469|      2|    style.visuals.window_rounding = egui::Rounding::same(4.0);
  470|      2|    style.visuals.menu_rounding = egui::Rounding::same(4.0);
  471|       |
  472|       |    // Set to true black background for maximum contrast
  473|      2|    if style.visuals.dark_mode {
  474|      1|        style.visuals.window_fill = egui::Color32::BLACK;
  475|      1|        style.visuals.panel_fill = egui::Color32::BLACK;
  476|      1|        style.visuals.faint_bg_color = egui::Color32::from_gray(20);
  477|      1|        style.visuals.extreme_bg_color = egui::Color32::BLACK;
  478|      1|        // The text color will be handled by egui's theme system
  479|      1|    }
  480|       |
  481|      2|    ctx.set_style(style);
  482|       |
  483|       |    // Use default fonts - egui has good built-in font support
  484|       |    // Custom fonts could be added here if needed
  485|      2|}
  486|       |
  487|       |#[cfg(test)]
  488|       |#[cfg_attr(coverage_nightly, coverage(off))]
  489|       |mod tests {
  490|       |    use super::*;
  491|       |    use std::sync::{Mutex, OnceLock};
  492|       |
  493|       |    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
  494|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
  495|       |        ENV_LOCK
  496|       |            .get_or_init(|| Mutex::new(()))
  497|       |            .lock()
  498|       |            .expect("env lock")
  499|       |    }
  500|       |
  501|       |    struct EnvGuard {
  502|       |        key: &'static str,
  503|       |        original: Option<String>,
  504|       |        _lock: std::sync::MutexGuard<'static, ()>,
  505|       |    }
  506|       |
  507|       |    impl EnvGuard {
  508|       |        fn set(key: &'static str, value: &str) -> Self {
  509|       |            let lock = env_lock();
  510|       |            let original = std::env::var(key).ok();
  511|       |            std::env::set_var(key, value);
  512|       |            Self {
  513|       |                key,
  514|       |                original,
  515|       |                _lock: lock,
  516|       |            }
  517|       |        }
  518|       |
  519|       |        fn unset(key: &'static str) -> Self {
  520|       |            let lock = env_lock();
  521|       |            let original = std::env::var(key).ok();
  522|       |            std::env::remove_var(key);
  523|       |            Self {
  524|       |                key,
  525|       |                original,
  526|       |                _lock: lock,
  527|       |            }
  528|       |        }
  529|       |    }
  530|       |
  531|       |    impl Drop for EnvGuard {
  532|       |        fn drop(&mut self) {
  533|       |            if let Some(prev) = &self.original {
  534|       |                std::env::set_var(self.key, prev);
  535|       |            } else {
  536|       |                std::env::remove_var(self.key);
  537|       |            }
  538|       |        }
  539|       |    }
  540|       |
  541|       |    #[test]
  542|       |    fn test_app_icon_creation() {
  543|       |        let icon = create_app_icon();
  544|       |        assert_eq!(icon.width, 32);
  545|       |        assert_eq!(icon.height, 32);
  546|       |        assert_eq!(icon.rgba.len(), 32 * 32 * 4); // RGBA format
  547|       |    }
  548|       |
  549|       |    #[test]
  550|       |    fn test_main_function_setup() {
  551|       |        // Test that the main function components work
  552|       |        // This is a basic smoke test
  553|       |        let icon = create_app_icon();
  554|       |        assert!(!icon.rgba.is_empty());
  555|       |    }
  556|       |
  557|       |    #[test]
  558|       |    fn test_configure_egui_style_dark_mode() {
  559|       |        let ctx = egui::Context::default();
  560|       |        let mut style = (*ctx.style()).clone();
  561|       |        style.visuals.dark_mode = true;
  562|       |        ctx.set_style(style);
  563|       |
  564|       |        configure_egui_style(&ctx);
  565|       |
  566|       |        let style = ctx.style();
  567|       |        assert_eq!(style.spacing.item_spacing, egui::Vec2::new(8.0, 8.0));
  568|       |        assert_eq!(style.spacing.window_margin, egui::Margin::same(8.0));
  569|       |        assert_eq!(style.spacing.menu_margin, egui::Margin::same(6.0));
  570|       |        assert_eq!(style.visuals.window_rounding, egui::Rounding::same(4.0));
  571|       |        assert_eq!(style.visuals.menu_rounding, egui::Rounding::same(4.0));
  572|       |        assert_eq!(style.visuals.window_fill, egui::Color32::BLACK);
  573|       |        assert_eq!(style.visuals.panel_fill, egui::Color32::BLACK);
  574|       |        assert_eq!(style.visuals.faint_bg_color, egui::Color32::from_gray(20));
  575|       |        assert_eq!(style.visuals.extreme_bg_color, egui::Color32::BLACK);
  576|       |    }
  577|       |
  578|       |    #[test]
  579|       |    fn test_configure_egui_style_light_mode() {
  580|       |        let ctx = egui::Context::default();
  581|       |        let mut style = (*ctx.style()).clone();
  582|       |        style.visuals.dark_mode = false;
  583|       |        style.visuals.window_fill = egui::Color32::from_rgb(1, 2, 3);
  584|       |        style.visuals.panel_fill = egui::Color32::from_rgb(4, 5, 6);
  585|       |        style.visuals.faint_bg_color = egui::Color32::from_rgb(7, 8, 9);
  586|       |        style.visuals.extreme_bg_color = egui::Color32::from_rgb(10, 11, 12);
  587|       |        ctx.set_style(style);
  588|       |
  589|       |        configure_egui_style(&ctx);
  590|       |
  591|       |        let style = ctx.style();
  592|       |        assert_eq!(style.spacing.item_spacing, egui::Vec2::new(8.0, 8.0));
  593|       |        assert_eq!(style.spacing.window_margin, egui::Margin::same(8.0));
  594|       |        assert_eq!(style.spacing.menu_margin, egui::Margin::same(6.0));
  595|       |        assert_eq!(style.visuals.window_rounding, egui::Rounding::same(4.0));
  596|       |        assert_eq!(style.visuals.menu_rounding, egui::Rounding::same(4.0));
  597|       |        assert_eq!(style.visuals.window_fill, egui::Color32::from_rgb(1, 2, 3));
  598|       |        assert_eq!(style.visuals.panel_fill, egui::Color32::from_rgb(4, 5, 6));
  599|       |        assert_eq!(
  600|       |            style.visuals.faint_bg_color,
  601|       |            egui::Color32::from_rgb(7, 8, 9)
  602|       |        );
  603|       |        assert_eq!(
  604|       |            style.visuals.extreme_bg_color,
  605|       |            egui::Color32::from_rgb(10, 11, 12)
  606|       |        );
  607|       |    }
  608|       |
  609|       |    #[test]
  610|       |    fn test_parse_cli_sets_initial_file_from_arg() {
  611|       |        let opts = parse_cli_from(vec!["readme.md".to_string()]).expect("parse");
  612|       |        assert_eq!(opts.initial_file, Some(PathBuf::from("readme.md")));
  613|       |    }
  614|       |
  615|       |    #[test]
  616|       |    fn test_parse_cli_screenshot_args() {
  617|       |        let args = vec![
  618|       |            "--screenshot".to_string(),
  619|       |            "doc.md".to_string(),
  620|       |            "--output".to_string(),
  621|       |            "out.png".to_string(),
  622|       |            "--width".to_string(),
  623|       |            "800".to_string(),
  624|       |            "--height".to_string(),
  625|       |            "600".to_string(),
  626|       |            "--theme".to_string(),
  627|       |            "dark".to_string(),
  628|       |            "--scroll".to_string(),
  629|       |            "0.5".to_string(),
  630|       |        ];
  631|       |        let opts = parse_cli_from(args).expect("parse");
  632|       |        assert!(opts.screenshot);
  633|       |        assert_eq!(opts.initial_file, Some(PathBuf::from("doc.md")));
  634|       |        assert_eq!(opts.screenshot_output, Some(PathBuf::from("out.png")));
  635|       |        assert_eq!(opts.width, Some(800.0));
  636|       |        assert_eq!(opts.height, Some(600.0));
  637|       |        assert_eq!(opts.theme, Some(ThemeChoice::Dark));
  638|       |        assert_eq!(opts.scroll, Some(0.5));
  639|       |    }
  640|       |
  641|       |    #[test]
  642|       |    fn test_parse_cli_missing_screenshot_input() {
  643|       |        let args = vec!["--screenshot".to_string()];
  644|       |        let err = parse_cli_from(args)
  645|       |            .err()
  646|       |            .expect("expected missing screenshot input error");
  647|       |        assert!(err.contains("--screenshot requires a value"));
  648|       |    }
  649|       |
  650|       |    #[test]
  651|       |    fn test_parse_cli_missing_screenshot_output() {
  652|       |        let args = vec!["--screenshot".to_string(), "doc.md".to_string()];
  653|       |        let err = parse_cli_from(args)
  654|       |            .err()
  655|       |            .expect("expected missing output error");
  656|       |        assert!(err.contains("Missing --output"));
  657|       |    }
  658|       |
  659|       |    #[test]
  660|       |    fn test_parse_cli_invalid_values() {
  661|       |        let args = vec!["--width".to_string(), "nope".to_string()];
  662|       |        let err = parse_cli_from(args)
  663|       |            .err()
  664|       |            .expect("expected invalid width error");
  665|       |        assert!(err.contains("Invalid --width"));
  666|       |
  667|       |        let args = vec!["--height".to_string(), "nope".to_string()];
  668|       |        let err = parse_cli_from(args)
  669|       |            .err()
  670|       |            .expect("expected invalid height error");
  671|       |        assert!(err.contains("Invalid --height"));
  672|       |
  673|       |        let args = vec!["--zoom".to_string(), "nope".to_string()];
  674|       |        let err = parse_cli_from(args)
  675|       |            .err()
  676|       |            .expect("expected invalid zoom error");
  677|       |        assert!(err.contains("Invalid --zoom"));
  678|       |
  679|       |        let args = vec!["--scroll".to_string(), "nope".to_string()];
  680|       |        let err = parse_cli_from(args)
  681|       |            .err()
  682|       |            .expect("expected invalid scroll error");
  683|       |        assert!(err.contains("Invalid --scroll"));
  684|       |
  685|       |        let args = vec!["--wait-ms".to_string(), "nope".to_string()];
  686|       |        let err = parse_cli_from(args)
  687|       |            .err()
  688|       |            .expect("expected invalid wait-ms error");
  689|       |        assert!(err.contains("Invalid --wait-ms"));
  690|       |
  691|       |        let args = vec!["--settle-frames".to_string(), "nope".to_string()];
  692|       |        let err = parse_cli_from(args)
  693|       |            .err()
  694|       |            .expect("expected invalid settle-frames error");
  695|       |        assert!(err.contains("Invalid --settle-frames"));
  696|       |
  697|       |        let args = vec!["--theme".to_string(), "blue".to_string()];
  698|       |        let err = parse_cli_from(args)
  699|       |            .err()
  700|       |            .expect("expected invalid theme error");
  701|       |        assert!(err.contains("Unsupported theme"));
  702|       |    }
  703|       |
  704|       |    #[test]
  705|       |    fn test_parse_cli_missing_flag_values() {
  706|       |        let flags = [
  707|       |            "--output",
  708|       |            "--width",
  709|       |            "--height",
  710|       |            "--theme",
  711|       |            "--zoom",
  712|       |            "--scroll",
  713|       |            "--wait-ms",
  714|       |            "--settle-frames",
  715|       |            "--test-fonts",
  716|       |        ];
  717|       |        for flag in flags {
  718|       |            let err = parse_cli_from(vec![flag.to_string()])
  719|       |                .err()
  720|       |                .expect("expected missing flag value error");
  721|       |            assert!(err.contains(&format!("{flag} requires a value")));
  722|       |        }
  723|       |    }
  724|       |
  725|       |    #[test]
  726|       |    fn test_parse_cli_scroll_clamps() {
  727|       |        let args = vec![
  728|       |            "--scroll".to_string(),
  729|       |            "2.5".to_string(),
  730|       |            "doc.md".to_string(),
  731|       |        ];
  732|       |        let opts = parse_cli_from(args).expect("parse");
  733|       |        assert_eq!(opts.scroll, Some(1.0));
  734|       |        assert_eq!(opts.initial_file, Some(PathBuf::from("doc.md")));
  735|       |    }
  736|       |
  737|       |    #[test]
  738|       |    fn test_parse_cli_additional_flags() {
  739|       |        let args = vec![
  740|       |            "--screenshot".to_string(),
  741|       |            "doc.md".to_string(),
  742|       |            "--output".to_string(),
  743|       |            "out.png".to_string(),
  744|       |            "--content-only".to_string(),
  745|       |            "--wait-ms".to_string(),
  746|       |            "1200".to_string(),
  747|       |            "--settle-frames".to_string(),
  748|       |            "3".to_string(),
  749|       |            "--zoom".to_string(),
  750|       |            "1.5".to_string(),
  751|       |            "--theme".to_string(),
  752|       |            "light".to_string(),
  753|       |            "--test-fonts".to_string(),
  754|       |            "fonts".to_string(),
  755|       |        ];
  756|       |        let opts = parse_cli_from(args).expect("parse");
  757|       |        assert!(opts.screenshot);
  758|       |        assert!(opts.content_only);
  759|       |        assert_eq!(opts.wait_ms, Some(1200));
  760|       |        assert_eq!(opts.settle_frames, Some(3));
  761|       |        assert_eq!(opts.zoom, Some(1.5));
  762|       |        assert_eq!(opts.theme, Some(ThemeChoice::Light));
  763|       |        assert_eq!(opts.test_fonts, Some(PathBuf::from("fonts")));
  764|       |    }
  765|       |
  766|       |    #[test]
  767|       |    fn test_parse_cli_ignores_extra_args() {
  768|       |        let args = vec!["doc.md".to_string(), "extra.md".to_string()];
  769|       |        let opts = parse_cli_from(args).expect("parse");
  770|       |        assert_eq!(opts.initial_file, Some(PathBuf::from("doc.md")));
  771|       |    }
  772|       |
  773|       |    #[test]
  774|       |    fn test_parse_hex_color32() {
  775|       |        let color = parse_hex_color32("#FFF8DB").expect("color");
  776|       |        assert_eq!(color, egui::Color32::from_rgb(255, 248, 219));
  777|       |        assert!(parse_hex_color32("#XYZ").is_none());
  778|       |        assert!(parse_hex_color32("#GG0000").is_none());
  779|       |        assert!(parse_hex_color32("#00GG00").is_none());
  780|       |        assert!(parse_hex_color32("#0000GG").is_none());
  781|       |    }
  782|       |
  783|       |    #[test]
  784|       |    fn test_parse_unsigned_helpers() {
  785|       |        assert_eq!(parse_u32("--width", "12").expect("u32"), 12);
  786|       |        assert!(parse_u32("--width", "nope").is_err());
  787|       |        assert_eq!(parse_u64("--timeout", "42").expect("u64"), 42);
  788|       |        assert!(parse_u64("--timeout", "-1").is_err());
  789|       |    }
  790|       |
  791|       |    #[test]
  792|       |    fn test_screenshot_background_color_env() {
  793|       |        {
  794|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "#112233");
  795|       |            let color = screenshot_background_color();
  796|       |            assert_eq!(color, egui::Color32::from_rgb(17, 34, 51));
  797|       |        }
  798|       |        {
  799|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "bad");
  800|       |            let color = screenshot_background_color();
  801|       |            assert_eq!(color, egui::Color32::from_rgb(255, 248, 219));
  802|       |        }
  803|       |    }
  804|       |
  805|       |    #[test]
  806|       |    fn test_screenshot_background_color_default_when_unset() {
  807|       |        let _guard = EnvGuard::unset("MDMDVIEW_MERMAID_MAIN_BKG");
  808|       |        let color = screenshot_background_color();
  809|       |        assert_eq!(color, egui::Color32::from_rgb(255, 248, 219));
  810|       |    }
  811|       |
  812|       |    #[test]
  813|       |    fn test_env_guard_restores_previous_value() {
  814|       |        let key = "MDMDVIEW_MERMAID_MAIN_BKG";
  815|       |        let _lock = env_lock();
  816|       |        std::env::set_var(key, "preexisting");
  817|       |        let previous = std::env::var(key).ok();
  818|       |        {
  819|       |            std::env::set_var(key, "orig");
  820|       |            let guard = EnvGuard {
  821|       |                key,
  822|       |                original: Some("orig".to_string()),
  823|       |                _lock,
  824|       |            };
  825|       |            std::env::set_var(key, "new");
  826|       |            drop(guard);
  827|       |        }
  828|       |        assert_eq!(std::env::var(key).ok().as_deref(), Some("orig"));
  829|       |        let _lock = env_lock();
  830|       |        for previous in [previous, None] {
  831|       |            match previous {
  832|       |                Some(value) => std::env::set_var(key, value),
  833|       |                None => std::env::remove_var(key),
  834|       |            }
  835|       |        }
  836|       |        let missing_key = "MDMDVIEW_MERMAID_MAIN_BKG_MISSING";
  837|       |        std::env::remove_var(missing_key);
  838|       |        let previous = std::env::var(missing_key).ok();
  839|       |        for previous in [previous, Some("temp".to_string())] {
  840|       |            match previous {
  841|       |                Some(value) => std::env::set_var(missing_key, value),
  842|       |                None => std::env::remove_var(missing_key),
  843|       |            }
  844|       |        }
  845|       |    }
  846|       |
  847|       |    #[test]
  848|       |    fn test_env_guard_drop_removes_unset_key() {
  849|       |        let key = "MDMDVIEW_MERMAID_MAIN_BKG";
  850|       |        std::env::remove_var(key);
  851|       |        {
  852|       |            let _guard = EnvGuard::unset(key);
  853|       |            std::env::set_var(key, "temp");
  854|       |        }
  855|       |        assert!(std::env::var(key).is_err());
  856|       |    }
  857|       |
  858|       |    #[test]
  859|       |    fn test_main_stub_executes() {
  860|       |        super::main();
  861|       |    }
  862|       |}

C:\language\mdmdview\src\markdown_renderer.rs:
    1|       |use crate::image_decode;
    2|       |use crate::mermaid_renderer::MermaidRenderer;
    3|       |use crate::table_support::{
    4|       |    compute_column_stats, derive_column_specs, ColumnPolicy, ColumnSpec, ColumnStat,
    5|       |    TableColumnContext, TableMetrics, WidthChange,
    6|       |};
    7|       |use crate::{emoji_assets, emoji_catalog};
    8|       |use anyhow::Result;
    9|       |use crossbeam_channel::{bounded, Receiver, Sender, TrySendError};
   10|       |use egui::{
   11|       |    text::{Galley, LayoutJob, TextWrapping},
   12|       |    Align, Color32, Context, FontSelection, Painter, RichText, Stroke, Vec2, Visuals,
   13|       |};
   14|       |use egui_extras::{Column, TableBuilder};
   15|       |use pulldown_cmark::{Alignment, Event, LinkType, Options, Parser, Tag};
   16|       |use std::cell::{Cell, RefCell};
   17|       |use std::collections::{hash_map::DefaultHasher, HashMap, HashSet, VecDeque};
   18|       |use std::hash::{Hash, Hasher};
   19|       |use std::ops::Range;
   20|       |use std::path::{Path, PathBuf};
   21|       |#[cfg(test)]
   22|       |use std::sync::atomic::{AtomicBool, Ordering};
   23|       |use std::sync::Arc;
   24|       |use std::time::{Duration, Instant, SystemTime};
   25|       |use syntect::easy::HighlightLines;
   26|       |use syntect::highlighting::ThemeSet;
   27|       |use syntect::parsing::SyntaxSet;
   28|       |use syntect::util::LinesWithEndings;
   29|       |use unicode_casefold::UnicodeCaseFold;
   30|       |use unicode_normalization::UnicodeNormalization;
   31|       |use unicode_segmentation::UnicodeSegmentation;
   32|       |
   33|       |#[derive(Clone, Copy, Default)]
   34|       |struct InlineStyle {
   35|       |    strong: bool,
   36|       |    italics: bool,
   37|       |    strike: bool,
   38|       |    color: Option<Color32>,
   39|       |}
   40|       |
   41|       |#[cfg(test)]
   42|       |thread_local! {
   43|       |    static FORCED_RENDER_ACTIONS: RefCell<HashSet<&'static str>> = RefCell::new(HashSet::new());
   44|       |    static FORCED_TABLE_POLICIES: RefCell<Option<Vec<ColumnPolicy>>> = const { RefCell::new(None) };
   45|       |    static FORCED_PARSE_ERROR: RefCell<bool> = const { RefCell::new(false) };
   46|       |}
   47|       |
   48|       |#[cfg(test)]
   49|       |static FORCE_THREAD_SPAWN_ERROR: AtomicBool = AtomicBool::new(false);
   50|       |
   51|       |#[cfg(test)]
   52|       |static FORCE_EMOJI_DECODE_ERROR: AtomicBool = AtomicBool::new(false);
   53|       |
   54|       |#[cfg(test)]
   55|    451|fn render_action_triggered(triggered: bool, action: &'static str) -> bool {
   56|    451|    triggered || FORCED_RENDER_ACTIONS.with(|actions| actions.borrow().contains(action))
                               ^449                  ^449           ^449             ^449     ^449
   57|    451|}
   58|       |
   59|       |#[cfg(not(test))]
   60|       |fn render_action_triggered(triggered: bool, _action: &'static str) -> bool {
   61|       |    triggered
   62|       |}
   63|       |
   64|       |#[cfg(test)]
   65|     19|fn take_forced_table_policies() -> Option<Vec<ColumnPolicy>> {
   66|     19|    FORCED_TABLE_POLICIES.with(|policies| policies.borrow_mut().take())
   67|     19|}
   68|       |
   69|       |#[cfg(test)]
   70|      4|pub(crate) fn force_parse_error_once() {
   71|      4|    FORCED_PARSE_ERROR.with(|flag| flag.replace(true));
   72|      4|}
   73|       |
   74|       |#[cfg(test)]
   75|      2|fn force_emoji_decode_error_once() {
   76|      2|    FORCE_EMOJI_DECODE_ERROR.store(true, Ordering::Relaxed);
   77|      2|}
   78|       |
   79|       |#[cfg(test)]
   80|    272|fn take_forced_parse_error() -> bool {
   81|    272|    FORCED_PARSE_ERROR.with(|flag| flag.replace(false))
   82|    272|}
   83|       |
   84|       |/// Font size configuration
   85|       |#[derive(Debug, Clone)]
   86|       |pub struct FontSizes {
   87|       |    pub body: f32,
   88|       |    pub h1: f32,
   89|       |    pub h2: f32,
   90|       |    pub h3: f32,
   91|       |    pub h4: f32,
   92|       |    pub h5: f32,
   93|       |    pub h6: f32,
   94|       |    pub code: f32,
   95|       |}
   96|       |
   97|       |impl Default for FontSizes {
   98|    397|    fn default() -> Self {
   99|    397|        Self {
  100|    397|            body: 14.0,
  101|    397|            h1: 28.0,
  102|    397|            h2: 24.0,
  103|    397|            h3: 20.0,
  104|    397|            h4: 18.0,
  105|    397|            h5: 16.0,
  106|    397|            h6: 14.0,
  107|    397|            code: 12.0,
  108|    397|        }
  109|    397|    }
  110|       |}
  111|       |
  112|       |/// Represents an inline text span with formatting
  113|       |#[derive(Debug, Clone)]
  114|       |pub enum InlineSpan {
  115|       |    Text(String),
  116|       |    Code(String),
  117|       |    Strong(String),
  118|       |    Emphasis(String),
  119|       |    Strikethrough(String),
  120|       |    Link {
  121|       |        text: String,
  122|       |        url: String,
  123|       |    },
  124|       |    Image {
  125|       |        src: String,
  126|       |        alt: String,
  127|       |        title: Option<String>,
  128|       |    },
  129|       |}
  130|       |
  131|       |#[cfg_attr(not(test), allow(dead_code))]
  132|       |#[derive(Debug, Clone)]
  133|       |enum CellFragment<'a> {
  134|       |    Text(&'a [InlineSpan]),
  135|       |    Emoji(String),
  136|       |    Image(&'a InlineSpan),
  137|       |}
  138|       |
  139|       |#[cfg_attr(not(test), allow(dead_code))]
  140|       |#[derive(Debug, Clone)]
  141|       |struct LayoutJobBuild {
  142|       |    job: LayoutJob,
  143|       |    #[allow(dead_code)]
  144|       |    plain_text: String,
  145|       |    #[cfg_attr(not(test), allow(dead_code))]
  146|       |    link_ranges: Vec<LinkRange>,
  147|       |}
  148|       |
  149|       |#[cfg_attr(not(test), allow(dead_code))]
  150|       |#[derive(Debug, Clone)]
  151|       |struct LinkRange {
  152|       |    char_range: Range<usize>,
  153|       |    url: String,
  154|       |}
  155|       |
  156|       |const TABLE_LAYOUT_CACHE_CAPACITY: usize = 512;
  157|       |const COLUMN_STATS_SAMPLE_ROWS: usize = 128;
  158|       |const PIPE_SENTINEL: char = '\u{1F}';
  159|       |const IMAGE_TEXTURE_CACHE_CAPACITY: usize = 256;
  160|       |const IMAGE_MAX_PENDING: usize = 64;
  161|       |const IMAGE_FAILURE_BACKOFF: Duration = Duration::from_secs(5);
  162|       |
  163|       |#[derive(Debug, Clone, Hash, PartialEq, Eq)]
  164|       |struct CellLayoutKey {
  165|       |    row: Option<usize>,
  166|       |    col: usize,
  167|       |    width: u32,
  168|       |    align: u8,
  169|       |    strong: bool,
  170|       |    text_color: [u8; 4],
  171|       |    highlight_hash: u64,
  172|       |    content_hash: u64,
  173|       |}
  174|       |
  175|       |struct CellLayoutCache {
  176|       |    entries: HashMap<CellLayoutKey, LayoutJobBuild>,
  177|       |    order: VecDeque<CellLayoutKey>,
  178|       |    hits: u64,
  179|       |    misses: u64,
  180|       |    capacity: usize,
  181|       |}
  182|       |
  183|       |#[derive(Clone)]
  184|       |struct ColumnStatsCacheEntry {
  185|       |    content_hash: u64,
  186|       |    stats: Vec<ColumnStat>,
  187|       |}
  188|       |
  189|       |impl CellLayoutCache {
  190|    376|    fn new(capacity: usize) -> Self {
  191|    376|        Self {
  192|    376|            entries: HashMap::new(),
  193|    376|            order: VecDeque::new(),
  194|    376|            hits: 0,
  195|    376|            misses: 0,
  196|    376|            capacity,
  197|    376|        }
  198|    376|    }
  199|       |
  200|    180|    fn get(&mut self, key: &CellLayoutKey) -> Option<LayoutJobBuild> {
  201|    180|        if let Some(build) = self.entries.get(key) {
                                  ^16
  202|     16|            self.hits += 1;
  203|     16|            Some(build.clone())
  204|       |        } else {
  205|    164|            self.misses += 1;
  206|    164|            None
  207|       |        }
  208|    180|    }
  209|       |
  210|    170|    fn insert(&mut self, key: CellLayoutKey, build: LayoutJobBuild) {
  211|    170|        if self.entries.len() >= self.capacity && !self.entries.contains_key(&key) {
                                                                ^3^3
  212|      3|            while self.entries.len() >= self.capacity {
  213|      2|                if let Some(old) = self.order.pop_front() {
                                          ^1
  214|      1|                    self.entries.remove(&old);
  215|      1|                } else {
  216|      1|                    break;
  217|       |                }
  218|       |            }
  219|    168|        }
  220|    977|        self.order.retain(|existing| existing != &key);
                      ^170       ^170
  221|    170|        self.order.push_back(key.clone());
  222|    170|        self.entries.insert(key, build);
  223|    170|    }
  224|       |
  225|    266|    fn clear(&mut self) {
  226|    266|        self.entries.clear();
  227|    266|        self.order.clear();
  228|    266|        self.hits = 0;
  229|    266|        self.misses = 0;
  230|    266|    }
  231|       |
  232|      4|    fn stats(&self) -> (u64, u64) {
  233|      4|        (self.hits, self.misses)
  234|      4|    }
  235|       |}
  236|       |
  237|       |#[derive(Debug, Clone)]
  238|       |pub struct ListItem {
  239|       |    pub blocks: Vec<MarkdownElement>,
  240|       |}
  241|       |
  242|       |/// Represents a rendered markdown element
  243|       |#[derive(Debug, Clone)]
  244|       |pub enum MarkdownElement {
  245|       |    Paragraph(Vec<InlineSpan>),
  246|       |    Header {
  247|       |        level: u8,
  248|       |        spans: Vec<InlineSpan>,
  249|       |        id: String,
  250|       |    },
  251|       |    CodeBlock {
  252|       |        language: Option<String>,
  253|       |        text: String,
  254|       |    },
  255|       |    List {
  256|       |        ordered: bool,
  257|       |        items: Vec<ListItem>,
  258|       |    }, // List items can contain block elements
  259|       |    Quote {
  260|       |        depth: u8,
  261|       |        blocks: Vec<MarkdownElement>,
  262|       |    },
  263|       |    HorizontalRule,
  264|       |    Table {
  265|       |        headers: Vec<Vec<InlineSpan>>,   // header cells as inline spans
  266|       |        rows: Vec<Vec<Vec<InlineSpan>>>, // rows -> cells -> spans
  267|       |        alignments: Vec<Alignment>,
  268|       |    },
  269|       |}
  270|       |
  271|       |/// Type alias for table parsing result
  272|       |type TableParseResult = (Vec<Vec<InlineSpan>>, Vec<Vec<Vec<InlineSpan>>>, usize);
  273|       |
  274|       |/// Type alias for quote blocks (nested markdown elements)
  275|       |type QuoteBlocks = Vec<MarkdownElement>;
  276|       |
  277|       |#[derive(Clone)]
  278|       |struct ImageCacheEntry {
  279|       |    texture: egui::TextureHandle,
  280|       |    size: [u32; 2],
  281|       |    modified: Option<SystemTime>,
  282|       |}
  283|       |
  284|       |struct ImageCache {
  285|       |    entries: HashMap<String, ImageCacheEntry>,
  286|       |    order: VecDeque<String>,
  287|       |    capacity: usize,
  288|       |}
  289|       |
  290|       |impl ImageCache {
  291|    376|    fn new(capacity: usize) -> Self {
  292|    376|        Self {
  293|    376|            entries: HashMap::new(),
  294|    376|            order: VecDeque::new(),
  295|    376|            capacity: capacity.max(1),
  296|    376|        }
  297|    376|    }
  298|       |
  299|     49|    fn get(&mut self, key: &str) -> Option<ImageCacheEntry> {
  300|     49|        let entry = self.entries.get(key).cloned();
  301|     49|        if entry.is_some() {
  302|     18|            self.touch(key);
  303|     31|        }
  304|     49|        entry
  305|     49|    }
  306|       |
  307|     17|    fn insert(&mut self, key: String, entry: ImageCacheEntry) {
  308|     17|        if self.entries.contains_key(&key) {
  309|      1|            self.entries.insert(key.clone(), entry);
  310|      1|            self.touch(&key);
  311|      1|            return;
  312|     16|        }
  313|     17|        while self.entries.len() >= self.capacity {
  314|      2|            if let Some(old) = self.order.pop_front() {
                                      ^1
  315|      1|                self.entries.remove(&old);
  316|      1|            } else {
  317|      1|                break;
  318|       |            }
  319|       |        }
  320|     16|        self.order.push_back(key.clone());
  321|     16|        self.entries.insert(key, entry);
  322|     17|    }
  323|       |
  324|      1|    fn remove(&mut self, key: &str) {
  325|      1|        self.entries.remove(key);
  326|      1|        self.order.retain(|entry| entry != key);
  327|      1|    }
  328|       |
  329|       |    #[cfg(test)]
  330|      5|    fn contains_key(&self, key: &str) -> bool {
  331|      5|        self.entries.contains_key(key)
  332|      5|    }
  333|       |
  334|     19|    fn touch(&mut self, key: &str) {
  335|     19|        self.order.retain(|entry| entry != key);
  336|     19|        self.order.push_back(key.to_string());
  337|     19|    }
  338|       |}
  339|       |
  340|       |struct ImageFailure {
  341|       |    last_attempt: Instant,
  342|       |}
  343|       |
  344|       |enum ImageLoadSource {
  345|       |    Embedded(&'static [u8]),
  346|       |    File(PathBuf),
  347|       |}
  348|       |
  349|       |struct ImageLoadRequest {
  350|       |    key: String,
  351|       |    source: ImageLoadSource,
  352|       |}
  353|       |
  354|       |enum ImageLoadResult {
  355|       |    Loaded {
  356|       |        key: String,
  357|       |        image: egui::ColorImage,
  358|       |        size: [u32; 2],
  359|       |        modified: Option<SystemTime>,
  360|       |    },
  361|       |    Failed {
  362|       |        key: String,
  363|       |    },
  364|       |}
  365|       |
  366|       |/// Markdown renderer with proper inline element handling
  367|       |pub struct MarkdownRenderer {
  368|       |    font_sizes: FontSizes,
  369|       |    syntax_set: SyntaxSet,
  370|       |    theme_set: ThemeSet,
  371|       |    emoji_textures: RefCell<HashMap<String, egui::TextureHandle>>,
  372|       |    image_textures: RefCell<ImageCache>,
  373|       |    image_pending: RefCell<HashSet<String>>,
  374|       |    image_failures: RefCell<HashMap<String, ImageFailure>>,
  375|       |    image_job_tx: Sender<ImageLoadRequest>,
  376|       |    image_result_rx: Receiver<ImageLoadResult>,
  377|       |    // Mapping of header id -> last rendered rect (for in-document navigation)
  378|       |    header_rects: RefCell<HashMap<String, egui::Rect>>,
  379|       |    // Last clicked internal anchor (e.g., "getting-started") for the app to consume
  380|       |    pending_anchor: RefCell<Option<String>>,
  381|       |    // Unique counter to avoid egui Id collisions for repeated links
  382|       |    link_counter: RefCell<u64>,
  383|       |    // Per-frame table counter to build stable table ids in render order
  384|       |    table_counter: RefCell<u64>,
  385|       |    // Per-frame rect for each top-level element in render order
  386|       |    element_rects: RefCell<Vec<egui::Rect>>,
  387|       |    // Optional highlight phrase (lowercased) for in-text highlighting
  388|       |    highlight_phrase: RefCell<Option<String>>,
  389|       |    // Cache for image/diagram textures
  390|       |    // Base directory used to resolve relative image paths
  391|       |    base_dir: RefCell<Option<PathBuf>>,
  392|       |    mermaid: MermaidRenderer,
  393|       |    table_layout_cache: RefCell<CellLayoutCache>,
  394|       |    table_metrics: RefCell<TableMetrics>,
  395|       |    column_stats_cache: RefCell<HashMap<u64, ColumnStatsCacheEntry>>,
  396|       |}
  397|       |
  398|       |impl Default for MarkdownRenderer {
  399|      1|    fn default() -> Self {
  400|      1|        Self::new()
  401|      1|    }
  402|       |}
  403|       |
  404|       |impl MarkdownRenderer {
  405|       |    #[cfg_attr(not(test), allow(dead_code))]
  406|    160|    fn cell_fragments<'a>(&'a self, spans: &'a [InlineSpan]) -> Vec<CellFragment<'a>> {
  407|    160|        if let Some(emoji) = self.cell_single_emoji(spans) {
                                  ^3
  408|      3|            return vec![CellFragment::Emoji(emoji)];
  409|    157|        }
  410|    157|        let mut fragments = Vec::new();
  411|    157|        let mut run_start: Option<usize> = None;
  412|    157|        let flush_run =
  413|      7|            |start: &mut Option<usize>, end: usize, fragments: &mut Vec<CellFragment<'a>>| {
  414|      7|                if let Some(run_begin) = start.take() {
                                          ^3
  415|      3|                    fragments.push(CellFragment::Text(&spans[run_begin..end]));
  416|      4|                }
  417|      7|            };
  418|       |
  419|    190|        for (idx, span) in spans.iter().enumerate() {
                                         ^157  ^157   ^157
  420|    190|            if matches!(span, InlineSpan::Image { .. }) {
                             ^183
  421|      7|                flush_run(&mut run_start, idx, &mut fragments);
  422|      7|                fragments.push(CellFragment::Image(span));
  423|      7|                continue;
  424|    183|            }
  425|       |
  426|    183|            if run_start.is_none() {
  427|    151|                run_start = Some(idx);
  428|    151|            }
                          ^32
  429|       |        }
  430|       |
  431|    157|        if let Some(start) = run_start {
                                  ^148
  432|    148|            fragments.push(CellFragment::Text(&spans[start..]));
  433|    148|        }
                      ^9
  434|       |
  435|    157|        fragments
  436|    160|    }
  437|       |
  438|    166|    fn cell_single_emoji(&self, spans: &[InlineSpan]) -> Option<String> {
  439|    166|        let mut text = String::new();
  440|    349|        for span in spans {
                          ^197
  441|    197|            match span {
  442|    173|                InlineSpan::Text(t)
  443|      8|                | InlineSpan::Strong(t)
  444|      1|                | InlineSpan::Emphasis(t)
  445|    183|                | InlineSpan::Strikethrough(t) => text.push_str(t),
                                                          ^1
  446|       |                InlineSpan::Code(_) | InlineSpan::Link { .. } | InlineSpan::Image { .. } => {
  447|     14|                    return None;
  448|       |                }
  449|       |            }
  450|       |        }
  451|       |
  452|    152|        let trimmed = text.trim();
  453|    152|        let mut graphemes = trimmed.graphemes(true);
  454|    152|        let Some(first) = graphemes.next() else {
                               ^147
  455|      5|            return None;
  456|       |        };
  457|    147|        if graphemes.next().is_some() {
  458|    111|            return None;
  459|     36|        }
  460|     36|        self.emoji_key_for_grapheme(first)
  461|    166|    }
  462|       |
  463|    267|    fn highlight_segments(&self, text: &str, highlight: Option<&str>) -> Vec<(Range<usize>, bool)> {
  464|    267|        if text.is_empty() {
  465|      1|            return Vec::new();
  466|    266|        }
  467|    266|        let Some(needle) = highlight.filter(|h| !h.is_empty()) else {
                               ^39                             ^40^40
  468|    227|            return vec![(0..text.len(), false)];
  469|       |        };
  470|       |
  471|     39|        let mut folded = String::new();
  472|     39|        let mut folded_to_char: Vec<usize> = Vec::new();
  473|     39|        let mut char_ranges: Vec<(usize, usize)> = Vec::new();
  474|    234|        for (char_idx, (byte_idx, ch)) in text.char_indices().enumerate() {
                                                        ^39  ^39            ^39
  475|    234|            let folded_piece: String = ch.to_string().case_fold().nfkc().collect();
  476|    234|            let before = folded.len();
  477|    234|            folded.push_str(&folded_piece);
  478|    234|            let after = folded.len();
  479|    237|            for _ in before..after {
                                   ^234    ^234
  480|    237|                folded_to_char.push(char_idx);
  481|    237|            }
  482|    234|            char_ranges.push((byte_idx, byte_idx + ch.len_utf8()));
  483|       |        }
  484|       |
  485|     39|        let mut segments = Vec::new();
  486|     39|        let mut rendered_until = 0usize;
  487|     39|        let mut search_at = 0usize;
  488|     53|        while let Some(pos) = folded[search_at..].find(needle) {
                                     ^14
  489|     14|            let abs = search_at + pos;
  490|     14|            let start_char_idx = folded_to_char[abs];
  491|     14|            let (start_byte, _) = char_ranges[start_char_idx];
  492|     14|            if start_byte > rendered_until {
  493|      2|                segments.push((rendered_until..start_byte, false));
  494|     12|            }
  495|     14|            let match_end = abs + needle.len();
  496|     14|            let end_char_idx = folded_to_char[match_end.saturating_sub(1)];
  497|     14|            let (_, end_byte) = char_ranges[end_char_idx];
  498|     14|            segments.push((start_byte..end_byte, true));
  499|     14|            rendered_until = end_byte;
  500|     14|            search_at = match_end;
  501|       |        }
  502|       |
  503|     39|        if rendered_until < text.len() {
  504|     33|            segments.push((rendered_until..text.len(), false));
  505|     33|        }
                      ^6
  506|       |
  507|     39|        segments
  508|    267|    }
  509|       |
  510|       |    #[cfg_attr(not(test), allow(dead_code))]
  511|    207|    fn build_layout_job(
  512|    207|        &self,
  513|    207|        style: &egui::Style,
  514|    207|        spans: &[InlineSpan],
  515|    207|        wrap_width: f32,
  516|    207|        strong_override: bool,
  517|    207|        halign: Align,
  518|    207|    ) -> LayoutJobBuild {
  519|    207|        let mut job = LayoutJob {
  520|    207|            wrap: TextWrapping {
  521|    207|                max_width: wrap_width.max(1.0),
  522|    207|                ..Default::default()
  523|    207|            },
  524|    207|            break_on_newline: true,
  525|    207|            halign,
  526|    207|            ..Default::default()
  527|    207|        };
  528|       |
  529|    207|        let highlight = self
  530|    207|            .highlight_phrase
  531|    207|            .borrow()
  532|    207|            .clone()
  533|    207|            .filter(|s| !s.is_empty());
                                       ^10^10
  534|       |
  535|    207|        let mut plain_text = String::new();
  536|    207|        let mut link_ranges = Vec::new();
  537|    207|        let mut job_char_offset = 0usize;
  538|       |
  539|    450|        for span in spans {
                          ^243
  540|    243|            match span {
  541|      1|                InlineSpan::Image { .. } => {}
  542|      1|                InlineSpan::Code(code) => {
  543|      1|                    job_char_offset +=
  544|      1|                        self.append_code_span(style, &mut job, &mut plain_text, code);
  545|      1|                }
  546|     18|                InlineSpan::Link { text, url } => {
  547|     18|                    let inline_style = InlineStyle {
  548|     18|                        strong: strong_override,
  549|     18|                        color: Some(if Self::is_external_url(url) {
  550|     11|                            Color32::from_rgb(120, 190, 255)
  551|       |                        } else {
  552|      7|                            Color32::LIGHT_BLUE
  553|       |                        }),
  554|     18|                        ..Default::default()
  555|       |                    };
  556|     18|                    let mut normalized = self.fix_unicode_chars(text);
  557|     18|                    normalized = Self::expand_shortcodes(&normalized);
  558|     18|                    normalized = Self::expand_superscripts(&normalized);
  559|     18|                    let appended = self.append_text_sections(
  560|     18|                        style,
  561|     18|                        &mut job,
  562|     18|                        &mut plain_text,
  563|     18|                        &normalized,
  564|     18|                        self.font_sizes.body,
  565|     18|                        inline_style,
  566|     18|                        highlight.as_deref(),
  567|       |                    );
  568|     18|                    if appended > 0 {
  569|     17|                        let start_char = job_char_offset;
  570|     17|                        job_char_offset += appended;
  571|     17|                        link_ranges.push(LinkRange {
  572|     17|                            char_range: start_char..job_char_offset,
  573|     17|                            url: url.clone(),
  574|     17|                        });
  575|     17|                    }
                                  ^1
  576|       |                }
  577|      7|                InlineSpan::Strong(text) => {
  578|      7|                    job_char_offset += self.append_plain_span(
  579|      7|                        style,
  580|      7|                        &mut job,
  581|      7|                        &mut plain_text,
  582|      7|                        text,
  583|      7|                        InlineStyle {
  584|      7|                            strong: true,
  585|      7|                            ..Default::default()
  586|      7|                        },
  587|      7|                        highlight.as_deref(),
  588|      7|                    );
  589|      7|                }
  590|      1|                InlineSpan::Emphasis(text) => {
  591|      1|                    job_char_offset += self.append_plain_span(
  592|      1|                        style,
  593|      1|                        &mut job,
  594|      1|                        &mut plain_text,
  595|      1|                        text,
  596|      1|                        InlineStyle {
  597|      1|                            italics: true,
  598|      1|                            strong: strong_override,
  599|      1|                            ..Default::default()
  600|      1|                        },
  601|      1|                        highlight.as_deref(),
  602|      1|                    );
  603|      1|                }
  604|      1|                InlineSpan::Strikethrough(text) => {
  605|      1|                    job_char_offset += self.append_plain_span(
  606|      1|                        style,
  607|      1|                        &mut job,
  608|      1|                        &mut plain_text,
  609|      1|                        text,
  610|      1|                        InlineStyle {
  611|      1|                            strike: true,
  612|      1|                            strong: strong_override,
  613|      1|                            ..Default::default()
  614|      1|                        },
  615|      1|                        highlight.as_deref(),
  616|      1|                    );
  617|      1|                }
  618|    214|                InlineSpan::Text(text) => {
  619|    214|                    job_char_offset += self.append_plain_span(
  620|    214|                        style,
  621|    214|                        &mut job,
  622|    214|                        &mut plain_text,
  623|    214|                        text,
  624|    214|                        InlineStyle {
  625|    214|                            strong: strong_override,
  626|    214|                            ..Default::default()
  627|    214|                        },
  628|    214|                        highlight.as_deref(),
  629|    214|                    );
  630|    214|                }
  631|       |            }
  632|       |        }
  633|       |
  634|    207|        LayoutJobBuild {
  635|    207|            job,
  636|    207|            plain_text,
  637|    207|            link_ranges,
  638|    207|        }
  639|    207|    }
  640|       |
  641|    224|    fn append_plain_span(
  642|    224|        &self,
  643|    224|        style: &egui::Style,
  644|    224|        job: &mut LayoutJob,
  645|    224|        plain_text: &mut String,
  646|    224|        text: &str,
  647|    224|        inline_style: InlineStyle,
  648|    224|        highlight: Option<&str>,
  649|    224|    ) -> usize {
  650|    224|        if text.is_empty() {
  651|      1|            return 0;
  652|    223|        }
  653|    223|        let mut normalized = self.fix_unicode_chars(text);
  654|    223|        normalized = Self::expand_shortcodes(&normalized);
  655|    223|        normalized = Self::expand_superscripts(&normalized);
  656|    223|        self.append_text_sections(
  657|    223|            style,
  658|    223|            job,
  659|    223|            plain_text,
  660|    223|            &normalized,
  661|    223|            self.font_sizes.body,
  662|    223|            inline_style,
  663|    223|            highlight,
  664|       |        )
  665|    224|    }
  666|       |
  667|      3|    fn append_code_span(
  668|      3|        &self,
  669|      3|        style: &egui::Style,
  670|      3|        job: &mut LayoutJob,
  671|      3|        plain_text: &mut String,
  672|      3|        code: &str,
  673|      3|    ) -> usize {
  674|      3|        if code.is_empty() {
  675|      1|            return 0;
  676|      2|        }
  677|      2|        plain_text.push_str(code);
  678|      2|        let visuals = &style.visuals;
  679|      2|        let (bg, fg) = if visuals.dark_mode {
  680|      1|            (
  681|      1|                Color32::from_rgb(30, 30, 30),
  682|      1|                Color32::from_rgb(180, 255, 180),
  683|      1|            )
  684|       |        } else {
  685|      1|            (Color32::WHITE, Color32::from_rgb(60, 80, 150))
  686|       |        };
  687|      2|        let rich = RichText::new(code.to_string())
  688|      2|            .size(self.font_sizes.code)
  689|      2|            .monospace()
  690|      2|            .background_color(bg)
  691|      2|            .color(fg);
  692|      2|        rich.append_to(job, style, FontSelection::Default, Align::LEFT);
  693|      2|        code.chars().count()
  694|      3|    }
  695|       |
  696|       |    #[allow(clippy::too_many_arguments)]
  697|    243|    fn append_text_sections(
  698|    243|        &self,
  699|    243|        style: &egui::Style,
  700|    243|        job: &mut LayoutJob,
  701|    243|        plain_text: &mut String,
  702|    243|        text: &str,
  703|    243|        font_size: f32,
  704|    243|        inline_style: InlineStyle,
  705|    243|        highlight: Option<&str>,
  706|    243|    ) -> usize {
  707|    243|        if text.is_empty() {
  708|      2|            return 0;
  709|    241|        }
  710|    241|        plain_text.push_str(text);
  711|    241|        let char_count = text.chars().count();
  712|    241|        let visuals = &style.visuals;
  713|    241|        let segments = self.highlight_segments(text, highlight);
  714|    485|        for (range, highlighted) in segments {
                           ^244   ^244
  715|    244|            let slice = &text[range];
  716|    244|            let mut rich = RichText::new(slice.to_string()).size(font_size);
  717|    244|            if inline_style.strong {
  718|    100|                rich = rich.strong();
  719|    144|            }
  720|    244|            if inline_style.italics {
  721|      1|                rich = rich.italics();
  722|    243|            }
  723|    244|            if inline_style.strike {
  724|      1|                rich = rich.strikethrough();
  725|    243|            }
  726|    244|            let mut text_color = inline_style.color;
  727|    244|            if highlighted {
  728|      3|                rich = rich.background_color(visuals.selection.bg_fill);
  729|      3|                if text_color.is_none() {
  730|      2|                    text_color = Some(visuals.selection.stroke.color);
  731|      2|                }
                              ^1
  732|    241|            } else if text_color.is_none() && inline_style.strong {
                                                            ^224
  733|    100|                if let Some(override_color) = visuals.override_text_color {
                                          ^1
  734|      1|                    text_color = Some(override_color);
  735|     99|                }
  736|    141|            }
  737|    244|            if let Some(color) = text_color {
                                      ^21
  738|     21|                rich = rich.color(color);
  739|    223|            }
  740|    244|            rich.append_to(job, style, FontSelection::Default, Align::LEFT);
  741|       |        }
  742|    241|        char_count
  743|    243|    }
  744|       |
  745|       |    /// Create a new markdown renderer
  746|    373|    pub fn new() -> Self {
  747|    373|        let mermaid = MermaidRenderer::new();
  748|    373|        let (image_job_tx, image_job_rx) = bounded(IMAGE_MAX_PENDING.max(1));
  749|    373|        let (image_result_tx, image_result_rx) = bounded(IMAGE_MAX_PENDING.max(1) * 2);
  750|    373|        Self::spawn_image_loader(image_job_rx, image_result_tx);
  751|    373|        Self {
  752|    373|            font_sizes: FontSizes::default(),
  753|    373|            syntax_set: SyntaxSet::load_defaults_newlines(),
  754|    373|            theme_set: ThemeSet::load_defaults(),
  755|    373|            emoji_textures: RefCell::new(HashMap::new()),
  756|    373|            image_textures: RefCell::new(ImageCache::new(IMAGE_TEXTURE_CACHE_CAPACITY)),
  757|    373|            image_pending: RefCell::new(HashSet::new()),
  758|    373|            image_failures: RefCell::new(HashMap::new()),
  759|    373|            image_job_tx,
  760|    373|            image_result_rx,
  761|    373|            header_rects: RefCell::new(HashMap::new()),
  762|    373|            pending_anchor: RefCell::new(None),
  763|    373|            link_counter: RefCell::new(0),
  764|    373|            table_counter: RefCell::new(0),
  765|    373|            element_rects: RefCell::new(Vec::new()),
  766|    373|            highlight_phrase: RefCell::new(None),
  767|    373|            base_dir: RefCell::new(None),
  768|    373|            mermaid,
  769|    373|            table_layout_cache: RefCell::new(CellLayoutCache::new(TABLE_LAYOUT_CACHE_CAPACITY)),
  770|    373|            table_metrics: RefCell::new(TableMetrics::default()),
  771|    373|            column_stats_cache: RefCell::new(HashMap::new()),
  772|    373|        }
  773|    373|    }
  774|       |
  775|    378|    fn spawn_image_loader(job_rx: Receiver<ImageLoadRequest>, result_tx: Sender<ImageLoadResult>) {
  776|    378|        if let Err(err) = Self::spawn_named_thread("mdmdview-image-loader", move || {
                                 ^1                                                               ^377
  777|    377|            for request in job_rx.iter() {
                              ^16
  778|     16|                let ImageLoadRequest { key, source } = request;
  779|     16|                let result = match source {
  780|      9|                    ImageLoadSource::Embedded(bytes) => {
  781|      9|                        match image_decode::bytes_to_color_image_guess(bytes, None) {
  782|      8|                            Some((image, w, h)) => ImageLoadResult::Loaded {
  783|      8|                                key,
  784|      8|                                image,
  785|      8|                                size: [w, h],
  786|      8|                                modified: None,
  787|      8|                            },
  788|      1|                            None => ImageLoadResult::Failed { key },
  789|       |                        }
  790|       |                    }
  791|      7|                    ImageLoadSource::File(path) => {
  792|      7|                        if !path.exists() {
  793|      1|                            ImageLoadResult::Failed { key }
  794|       |                        } else {
  795|      6|                            match std::fs::read(&path) {
  796|      5|                                Ok(bytes) => {
  797|      5|                                    let modified = Self::disk_image_timestamp(&path);
  798|      5|                                    match image_decode::bytes_to_color_image_guess(&bytes, None) {
  799|      4|                                        Some((image, w, h)) => ImageLoadResult::Loaded {
  800|      4|                                            key,
  801|      4|                                            image,
  802|      4|                                            size: [w, h],
  803|      4|                                            modified,
  804|      4|                                        },
  805|      1|                                        None => ImageLoadResult::Failed { key },
  806|       |                                    }
  807|       |                                }
  808|      1|                                Err(_) => ImageLoadResult::Failed { key },
  809|       |                            }
  810|       |                        }
  811|       |                    }
  812|       |                };
  813|     16|                let _ = result_tx.send(result);
  814|       |            }
  815|    377|        }) {
  816|      1|            eprintln!("Failed to start image loader thread: {err}");
  817|    377|        }
  818|    378|    }
  819|       |
  820|    378|    fn spawn_named_thread(
  821|    378|        name: &str,
  822|    378|        f: impl FnOnce() + Send + 'static,
  823|    378|    ) -> std::io::Result<std::thread::JoinHandle<()>> {
  824|       |        #[cfg(test)]
  825|    378|        if FORCE_THREAD_SPAWN_ERROR.swap(false, Ordering::Relaxed) {
  826|      1|            return Err(std::io::Error::new(
  827|      1|                std::io::ErrorKind::Other,
  828|      1|                "forced thread spawn failure",
  829|      1|            ));
  830|    377|        }
  831|    377|        std::thread::Builder::new().name(name.to_string()).spawn(f)
  832|    378|    }
  833|       |
  834|       |    #[cfg(test)]
  835|      1|    fn force_thread_spawn_error_for_test() {
  836|      1|        FORCE_THREAD_SPAWN_ERROR.store(true, Ordering::Relaxed);
  837|      1|    }
  838|       |
  839|       |    /// UI scale factor derived from body font size relative to default.
  840|       |    /// Used to scale non-text elements (e.g., images) consistently with zoom.
  841|     13|    fn ui_scale(&self) -> f32 {
  842|     13|        let default_body = FontSizes::default().body;
  843|     13|        (self.font_sizes.body / default_body).clamp(0.5, 4.0)
  844|     13|    }
  845|       |
  846|       |    /// Get current font sizes
  847|      2|    pub fn font_sizes(&self) -> &FontSizes {
  848|      2|        &self.font_sizes
  849|      2|    }
  850|       |
  851|    317|    fn escape_table_pipes_in_inline_code(markdown: &str) -> String {
  852|    317|        let mut out = String::with_capacity(markdown.len());
  853|    317|        let mut in_table = false;
  854|    317|        let mut table_blockquote_level: Option<usize> = None;
  855|    317|        let mut table_list_indent: Option<usize> = None;
  856|    317|        let mut in_fenced_block = false;
  857|    317|        let mut fence_char = '\0';
  858|    317|        let mut fence_len = 0usize;
  859|    317|        let mut fence_blockquote_level: Option<usize> = None;
  860|       |
  861|    317|        let lines: Vec<&str> = markdown.split_inclusive('\n').collect();
  862|    317|        let mut i = 0;
  863|  6.66k|        while i < lines.len() {
  864|  6.34k|            let line = lines[i];
  865|  6.34k|            let (blockquote_level, rest) = Self::table_line_info(line);
  866|  6.34k|            let list_info = Self::list_marker_info(rest);
  867|  6.34k|            let mut list_indent = list_info.map(|(_, _, content_indent)| content_indent);
  868|  6.34k|            let mut list_stripped = list_info.map(|(content, _, _)| content).unwrap_or(rest);
  869|  6.34k|            let mut list_marker_present = list_info.is_some();
  870|  6.34k|            if !list_marker_present && i > 0 {
                                                     ^4.25k
  871|  3.97k|                let parent_list_indent =
  872|  3.97k|                    Self::parent_list_indent_for_line(&lines, i, blockquote_level, rest);
  873|  3.97k|                if let Some(parent_indent) = parent_list_indent {
                                          ^89
  874|     18|                    if let Some((content, _indent_after, content_indent, leading_spaces)) =
  875|     89|                        Self::list_marker_info_any_indent(rest)
  876|       |                    {
  877|     18|                        if leading_spaces < parent_indent + 4 {
  878|     13|                            list_marker_present = true;
  879|     13|                            list_indent = Some(content_indent);
  880|     13|                            list_stripped = content;
  881|     13|                        }
                                      ^5
  882|     71|                    }
  883|     89|                    if list_indent.is_none() {
  884|     76|                        let code_strip = Self::strip_indent_columns(rest, parent_indent + 4);
  885|     76|                        if code_strip.is_none() {
  886|     57|                            list_indent = Some(parent_indent);
  887|     57|                        }
                                      ^19
  888|     13|                    }
  889|  3.88k|                }
  890|  2.37k|            }
  891|  6.34k|            let (fence_line_level, fence_line_rest) = if list_marker_present {
  892|  2.10k|                let (nested_level, nested_rest) = Self::table_line_info(list_stripped);
  893|  2.10k|                (blockquote_level + nested_level, nested_rest)
  894|       |            } else {
  895|  4.23k|                Self::table_line_info_with_list(line, list_indent)
  896|       |            };
  897|  6.34k|            let trimmed_fence = fence_line_rest.trim_start();
  898|       |
  899|  6.34k|            if in_fenced_block {
  900|    120|                let fence_end = fence_blockquote_level == Some(fence_line_level)
  901|    119|                    && Self::is_fence_end(trimmed_fence, fence_char, fence_len);
  902|    120|                if fence_end {
  903|     16|                    in_fenced_block = false;
  904|     16|                    fence_char = '\0';
  905|     16|                    fence_len = 0;
  906|     16|                    fence_blockquote_level = None;
  907|    104|                }
  908|    120|                out.push_str(line);
  909|    120|                i += 1;
  910|    120|                continue;
  911|  6.22k|            }
  912|       |
  913|  6.22k|            if let Some((ch, len)) = Self::fence_start(trimmed_fence) {
                                       ^16 ^16
  914|     16|                in_fenced_block = true;
  915|     16|                fence_char = ch;
  916|     16|                fence_len = len;
  917|     16|                fence_blockquote_level = Some(fence_line_level);
  918|     16|                out.push_str(line);
  919|     16|                i += 1;
  920|     16|                continue;
  921|  6.20k|            }
  922|       |
  923|  6.20k|            if in_table {
  924|    264|                if let Some((level, rest)) = Self::table_line_info_in_list(line, table_list_indent)
                                           ^260   ^260
  925|       |                {
  926|    260|                    if table_blockquote_level == Some(level) {
  927|    259|                        let candidate = Some(rest);
  928|    259|                        if candidate.is_some_and(Self::is_table_row_candidate) {
  929|    236|                            out.push_str(&Self::escape_pipes_in_inline_code_line(line));
  930|    236|                            i += 1;
  931|    236|                            continue;
  932|     23|                        }
  933|      1|                    }
  934|      4|                }
  935|     28|                in_table = false;
  936|     28|                table_blockquote_level = None;
  937|     28|                table_list_indent = None;
  938|     28|                out.push_str(line);
  939|     28|                i += 1;
  940|     28|                continue;
  941|  5.94k|            }
  942|       |
  943|  5.94k|            if i + 1 < lines.len() {
  944|  5.67k|                let header_from_list_marker = list_marker_present;
  945|  5.67k|                let (level, rest) = if list_marker_present {
  946|  2.10k|                    let (nested_level, nested_rest) = Self::table_line_info(list_stripped);
  947|  2.10k|                    (blockquote_level + nested_level, nested_rest)
  948|       |                } else {
  949|  3.57k|                    Self::table_line_info_with_list(line, list_indent)
  950|       |                };
  951|  5.67k|                let next_info = if list_indent.is_some() {
  952|  2.11k|                    Self::table_line_info_in_list(lines[i + 1], list_indent)
  953|       |                } else {
  954|  3.56k|                    Some(Self::table_line_info(lines[i + 1]))
  955|       |                };
  956|  5.67k|                let header_line = if header_from_list_marker {
  957|  2.10k|                    let (_, stripped) = Self::table_line_info(list_stripped);
  958|  2.10k|                    stripped
  959|       |                } else {
  960|  3.57k|                    rest
  961|       |                };
  962|       |
  963|  5.67k|                if let Some((next_level, next_rest)) = next_info {
                                           ^3.63k      ^3.63k
  964|  3.63k|                    if level == next_level && Self::is_table_row_candidate(header_line) {
                                                            ^3.61k                       ^3.61k
  965|     74|                        let delimiter_line = Some(next_rest);
  966|     74|                        if delimiter_line.is_some_and(Self::is_table_delimiter_line) {
  967|     68|                            if !header_from_list_marker && i > 0 {
                                                                         ^51
  968|     43|                                let (prev_level, prev_rest) =
  969|     43|                                    Self::table_line_info_with_list(lines[i - 1], list_indent);
  970|     43|                                if prev_level == level && !prev_rest.trim().is_empty() {
                                                                        ^42
  971|     10|                                    let prefix_len = line.len().saturating_sub(rest.len());
  972|     10|                                    out.push_str(&line[..prefix_len]);
  973|     10|                                    let newline =
  974|     10|                                        if line.ends_with("\r\n") { "\r\n" } else { "\n" };
                                                                                  ^1              ^9
  975|     10|                                    out.push_str(newline);
  976|     33|                                }
  977|     25|                            }
  978|     68|                            out.push_str(&Self::escape_pipes_in_inline_code_line(line));
  979|     68|                            out.push_str(lines[i + 1]);
  980|     68|                            in_table = true;
  981|     68|                            table_blockquote_level = Some(level);
  982|     68|                            table_list_indent = list_indent;
  983|     68|                            i += 2;
  984|     68|                            continue;
  985|      6|                        }
  986|  3.56k|                    }
  987|  2.04k|                }
  988|    264|            }
  989|       |
  990|  5.87k|            out.push_str(line);
  991|  5.87k|            i += 1;
  992|       |        }
  993|       |
  994|    317|        out
  995|    317|    }
  996|       |
  997|    308|    fn escape_pipes_in_inline_code_line(line: &str) -> String {
  998|    308|        if !line.contains('|') || !line.contains('`') {
                                                ^307
  999|    127|            return line.to_string();
 1000|    181|        }
 1001|    181|        let mut out: Vec<char> = Vec::with_capacity(line.len());
 1002|    181|        let mut in_code = false;
 1003|    181|        let mut delimiter_len = 0usize;
 1004|    181|        let mut pending_pipes: Vec<usize> = Vec::new();
 1005|    181|        let mut backslash_run = 0usize;
 1006|    181|        let mut chars = line.chars().peekable();
 1007|       |
 1008|  6.14k|        while let Some(ch) = chars.next() {
                                     ^5.96k
 1009|  5.96k|            if ch == '\\' {
 1010|      2|                backslash_run += 1;
 1011|      2|                out.push(ch);
 1012|      2|                continue;
 1013|  5.95k|            }
 1014|       |
 1015|  5.95k|            let escaped = !in_code && backslash_run % 2 == 1;
                                                    ^4.85k
 1016|  5.95k|            backslash_run = 0;
 1017|       |
 1018|  5.95k|            if ch == '`' {
 1019|    361|                if escaped {
 1020|      2|                    out.push('`');
 1021|      2|                    continue;
 1022|    359|                }
 1023|    359|                let mut run_len = 1usize;
 1024|    363|                while matches!(chars.peek(), Some('`')) {
                                    ^359
 1025|      4|                    chars.next();
 1026|      4|                    run_len += 1;
 1027|      4|                }
 1028|    359|                if in_code {
 1029|    179|                    if run_len == delimiter_len {
 1030|    178|                        in_code = false;
 1031|    178|                        delimiter_len = 0;
 1032|    178|                        pending_pipes.clear();
 1033|    178|                    }
                                  ^1
 1034|    180|                } else {
 1035|    180|                    in_code = true;
 1036|    180|                    delimiter_len = run_len;
 1037|    180|                    pending_pipes.clear();
 1038|    180|                }
 1039|    359|                out.extend(std::iter::repeat_n('`', run_len));
 1040|    359|                continue;
 1041|  5.59k|            }
 1042|       |
 1043|  5.59k|            if in_code && ch == '|' {
                                        ^927
 1044|     54|                pending_pipes.push(out.len());
 1045|     54|                out.push(PIPE_SENTINEL);
 1046|  5.54k|            } else {
 1047|  5.54k|                out.push(ch);
 1048|  5.54k|            }
 1049|       |        }
 1050|       |
 1051|    181|        if in_code {
 1052|      5|            for idx in pending_pipes {
                              ^3
 1053|      3|                out[idx] = '|';
 1054|      3|            }
 1055|    179|        }
 1056|       |
 1057|    181|        out.into_iter().collect()
 1058|    308|    }
 1059|       |
 1060|     39|    fn is_html_line_break(html: &str) -> bool {
 1061|     39|        let trimmed = html.trim();
 1062|     39|        if trimmed.len() < 4 {
 1063|      3|            return false;
 1064|     36|        }
 1065|     36|        let normalized = trimmed.to_ascii_lowercase();
 1066|     36|        if !normalized.starts_with("<br") || !normalized.ends_with('>') {
                                                           ^31
 1067|      6|            return false;
 1068|     30|        }
 1069|     30|        let rest = &normalized[3..];
 1070|     30|        let first = rest.chars().next();
 1071|      7|        match first {
 1072|     19|            Some('>') => true,
 1073|      4|            Some('/') => rest[1..].trim_start().starts_with('>'),
 1074|      7|            Some(ch) if ch.is_whitespace() => true,
                               ^6                      ^6   ^6
 1075|      1|            _ => false,
 1076|       |        }
 1077|     39|    }
 1078|       |
 1079|     35|    fn tab_advance(col: usize) -> usize {
 1080|     35|        let rem = col % 4;
 1081|     35|        if rem == 0 {
 1082|     32|            4
 1083|       |        } else {
 1084|      3|            4 - rem
 1085|       |        }
 1086|     35|    }
 1087|       |
 1088|  3.95k|    fn is_indented_code_line(line: &str) -> bool {
 1089|  3.95k|        let mut col = 0usize;
 1090|  4.00k|        for ch in line.chars() {
                                ^3.95k^3.95k
 1091|  4.00k|            match ch {
 1092|       |                ' ' => {
 1093|     76|                    col += 1;
 1094|     76|                    if col >= 4 {
 1095|     17|                        return true;
 1096|     59|                    }
 1097|       |                }
 1098|       |                '\t' => {
 1099|      1|                    col += Self::tab_advance(col);
 1100|      1|                    return col >= 4;
 1101|       |                }
 1102|  3.93k|                _ => break,
 1103|       |            }
 1104|       |        }
 1105|  3.93k|        col >= 4
 1106|  3.95k|    }
 1107|       |
 1108|  37.4k|    fn table_line_info(line: &str) -> (usize, &str) {
 1109|  37.4k|        let mut rest = line;
 1110|  37.4k|        let mut level = 0usize;
 1111|       |        loop {
 1112|  37.8k|            let bytes = rest.as_bytes();
 1113|  37.8k|            let mut idx = 0usize;
 1114|  40.0k|            while idx < bytes.len() && idx < 3 && bytes[idx] == b' ' {
                                                     ^40.0k     ^39.4k
 1115|  2.25k|                idx += 1;
 1116|  2.25k|            }
 1117|  37.8k|            if idx < bytes.len() && bytes[idx] == b'>' {
                                                  ^37.8k
 1118|    392|                idx += 1;
 1119|    392|                if idx < bytes.len() && (bytes[idx] == b' ' || bytes[idx] == b'\t') {
                                                       ^391                  ^40
 1120|    361|                    idx += 1;
 1121|    361|                }
                              ^31
 1122|    392|                level += 1;
 1123|    392|                rest = &rest[idx..];
 1124|    392|                continue;
 1125|  37.4k|            }
 1126|  37.4k|            break;
 1127|       |        }
 1128|  37.4k|        (level, rest)
 1129|  37.4k|    }
 1130|       |
 1131|  7.86k|    fn table_line_info_with_list(line: &str, list_indent: Option<usize>) -> (usize, &str) {
 1132|  7.86k|        let (level, rest) = Self::table_line_info(line);
 1133|  7.86k|        if let Some(indent) = list_indent {
                                  ^81
 1134|     81|            if let Some(stripped) = Self::strip_indent_columns(rest, indent) {
                                      ^72
 1135|     72|                let (nested_level, nested_rest) = Self::table_line_info(stripped);
 1136|     72|                return (level + nested_level, nested_rest);
 1137|      9|            }
 1138|      9|            if let Some(stripped) = Self::strip_indent_columns(line, indent) {
                                      ^1
 1139|      1|                return Self::table_line_info(stripped);
 1140|      8|            }
 1141|  7.77k|        }
 1142|  7.78k|        (level, rest)
 1143|  7.86k|    }
 1144|       |
 1145|  2.37k|    fn table_line_info_in_list(line: &str, list_indent: Option<usize>) -> Option<(usize, &str)> {
 1146|  2.37k|        let (level, rest) = Self::table_line_info(line);
 1147|  2.37k|        if let Some(indent) = list_indent {
                                  ^2.14k
 1148|  2.14k|            if let Some(stripped) = Self::strip_indent_columns(rest, indent) {
                                      ^94
 1149|     94|                let (nested_level, nested_rest) = Self::table_line_info(stripped);
 1150|     94|                return Some((level + nested_level, nested_rest));
 1151|  2.05k|            }
 1152|  2.05k|            let stripped = Self::strip_indent_columns(line, indent)?;
                              ^2                                                 ^2.04k
 1153|      2|            return Some(Self::table_line_info(stripped));
 1154|    233|        }
 1155|    233|        Some((level, rest))
 1156|  2.37k|    }
 1157|       |
 1158|  14.7k|    fn list_marker_info(line: &str) -> Option<(&str, usize, usize)> {
 1159|  14.7k|        let bytes = line.as_bytes();
 1160|  14.7k|        let mut idx = 0usize;
 1161|  14.7k|        let mut spaces = 0usize;
 1162|  16.0k|        while idx < bytes.len() && spaces < 3 && bytes[idx] == b' ' {
                                                 ^16.0k        ^15.6k
 1163|  1.34k|            idx += 1;
 1164|  1.34k|            spaces += 1;
 1165|  1.34k|        }
 1166|  14.7k|        if idx < bytes.len() && bytes[idx] == b'\t' {
                                              ^14.7k
 1167|     15|            return None;
 1168|  14.6k|        }
 1169|  14.6k|        if idx >= bytes.len() {
 1170|      2|            return None;
 1171|  14.6k|        }
 1172|  14.6k|        let marker_start = idx;
 1173|  14.6k|        match bytes[idx] {
 1174|  5.25k|            b'-' | b'+' | b'*' => {
 1175|  5.25k|                idx += 1;
 1176|  5.25k|            }
 1177|  4.14k|            b'0'..=b'9' => {
 1178|  3.95k|                while idx < bytes.len() && bytes[idx].is_ascii_digit() {
                                                         ^3.95k     ^3.95k
 1179|  1.98k|                    idx += 1;
 1180|  1.98k|                }
 1181|  1.97k|                if idx < bytes.len() && (bytes[idx] == b'.' || bytes[idx] == b')') {
                                                       ^1.96k                ^10
 1182|  1.96k|                    idx += 1;
 1183|  1.96k|                } else {
 1184|      9|                    return None;
 1185|       |                }
 1186|       |            }
 1187|  7.46k|            _ => return None,
 1188|       |        }
 1189|  7.21k|        let marker_width = idx.saturating_sub(marker_start);
 1190|  7.21k|        let mut indent = 0usize;
 1191|  7.21k|        let mut has_ws = false;
 1192|  7.21k|        let mut col = spaces + marker_width;
 1193|  13.5k|        while idx < bytes.len() {
 1194|  13.4k|            match bytes[idx] {
 1195|  6.28k|                b' ' => {
 1196|  6.28k|                    indent += 1;
 1197|  6.28k|                    col += 1;
 1198|  6.28k|                    idx += 1;
 1199|  6.28k|                    has_ws = true;
 1200|  6.28k|                }
 1201|      1|                b'\t' => {
 1202|      1|                    let advance = Self::tab_advance(col);
 1203|      1|                    indent += advance;
 1204|      1|                    col += advance;
 1205|      1|                    idx += 1;
 1206|      1|                    has_ws = true;
 1207|      1|                }
 1208|  7.21k|                _ => break,
 1209|       |            }
 1210|       |        }
 1211|  7.21k|        if !has_ws {
 1212|    937|            return None;
 1213|  6.27k|        }
 1214|  6.27k|        let content_indent = col;
 1215|  6.27k|        Some((&line[idx..], indent, content_indent))
 1216|  14.7k|    }
 1217|       |
 1218|  4.26k|    fn list_marker_info_any_indent(line: &str) -> Option<(&str, usize, usize, usize)> {
 1219|  4.26k|        let bytes = line.as_bytes();
 1220|  4.26k|        let mut idx = 0usize;
 1221|  4.26k|        let mut leading_cols = 0usize;
 1222|  6.29k|        while idx < bytes.len() {
 1223|  6.29k|            match bytes[idx] {
 1224|  2.00k|                b' ' => {
 1225|  2.00k|                    idx += 1;
 1226|  2.00k|                    leading_cols += 1;
 1227|  2.00k|                }
 1228|     15|                b'\t' => {
 1229|     15|                    let advance = Self::tab_advance(leading_cols);
 1230|     15|                    idx += 1;
 1231|     15|                    leading_cols += advance;
 1232|     15|                }
 1233|  4.26k|                _ => break,
 1234|       |            }
 1235|       |        }
 1236|  4.26k|        if idx >= bytes.len() {
 1237|      2|            return None;
 1238|  4.26k|        }
 1239|  4.26k|        let marker_start = idx;
 1240|  4.26k|        match bytes[idx] {
 1241|    536|            b'-' | b'+' | b'*' => {
 1242|    536|                idx += 1;
 1243|    536|            }
 1244|  1.63k|            b'0'..=b'9' => {
 1245|     27|                while idx < bytes.len() && bytes[idx].is_ascii_digit() {
                                                         ^26        ^26
 1246|     16|                    idx += 1;
 1247|     16|                }
 1248|     11|                if idx < bytes.len() && (bytes[idx] == b'.' || bytes[idx] == b')') {
                                                       ^10                   ^7
 1249|      5|                    idx += 1;
 1250|      5|                } else {
 1251|      6|                    return None;
 1252|       |                }
 1253|       |            }
 1254|  3.72k|            _ => return None,
 1255|       |        }
 1256|    541|        let marker_width = idx.saturating_sub(marker_start);
 1257|    541|        let mut indent = 0usize;
 1258|    541|        let mut has_ws = false;
 1259|    541|        let mut col = leading_cols + marker_width;
 1260|    591|        while idx < bytes.len() {
 1261|    589|            match bytes[idx] {
 1262|     49|                b' ' => {
 1263|     49|                    indent += 1;
 1264|     49|                    col += 1;
 1265|     49|                    idx += 1;
 1266|     49|                    has_ws = true;
 1267|     49|                }
 1268|      1|                b'\t' => {
 1269|      1|                    let advance = Self::tab_advance(col);
 1270|      1|                    indent += advance;
 1271|      1|                    col += advance;
 1272|      1|                    idx += 1;
 1273|      1|                    has_ws = true;
 1274|      1|                }
 1275|    539|                _ => break,
 1276|       |            }
 1277|       |        }
 1278|    541|        if !has_ws {
 1279|    491|            return None;
 1280|     50|        }
 1281|     50|        let content_indent = col;
 1282|     50|        Some((&line[idx..], indent, content_indent, leading_cols))
 1283|  4.26k|    }
 1284|       |
 1285|  3.97k|    fn parent_list_indent_for_line(
 1286|  3.97k|        lines: &[&str],
 1287|  3.97k|        idx: usize,
 1288|  3.97k|        level: usize,
 1289|  3.97k|        line_rest: &str,
 1290|  3.97k|    ) -> Option<usize> {
 1291|  3.97k|        if idx == 0 {
 1292|      1|            return None;
 1293|  3.97k|        }
 1294|  10.7k|        for back_idx in (0..idx).rev() {
                                       ^3.97k  ^3.97k
 1295|  10.7k|            let (prev_level, prev_rest) = Self::table_line_info(lines[back_idx]);
 1296|  10.7k|            if prev_level < level {
 1297|     15|                break;
 1298|  10.7k|            }
 1299|  10.7k|            if prev_level > level {
 1300|     33|                continue;
 1301|  10.7k|            }
 1302|  10.7k|            if prev_rest.trim().is_empty() {
 1303|  2.38k|                continue;
 1304|  8.34k|            }
 1305|  8.34k|            if let Some((_, _, content_indent)) = Self::list_marker_info(prev_rest) {
                                             ^4.18k
 1306|  4.18k|                if Self::strip_indent_columns(line_rest, content_indent).is_some() {
 1307|     77|                    return Some(content_indent);
 1308|  4.10k|                }
 1309|     27|            } else if let Some((_, _, content_indent, _)) =
 1310|  4.16k|                Self::list_marker_info_any_indent(prev_rest)
 1311|       |            {
 1312|     27|                if Self::strip_indent_columns(line_rest, content_indent).is_some() {
 1313|     17|                    return Some(content_indent);
 1314|     10|                }
 1315|  4.13k|            } else if !prev_rest.starts_with(' ') && !prev_rest.starts_with('\t') {
                                                                   ^3.86k
 1316|  3.85k|                break;
 1317|    279|            }
 1318|       |        }
 1319|  3.88k|        None
 1320|  3.97k|    }
 1321|       |
 1322|  8.58k|    fn strip_indent_columns(line: &str, indent: usize) -> Option<&str> {
 1323|  8.58k|        if indent == 0 {
 1324|      1|            return Some(line);
 1325|  8.57k|        }
 1326|  8.57k|        let mut col = 0usize;
 1327|  8.57k|        let mut cut = 0usize;
 1328|  9.80k|        for (idx, ch) in line.char_indices() {
                                       ^8.57k^8.57k
 1329|  9.80k|            if col >= indent {
 1330|    286|                break;
 1331|  9.51k|            }
 1332|  9.51k|            match ch {
 1333|  1.20k|                ' ' => {
 1334|  1.20k|                    col += 1;
 1335|  1.20k|                    cut = idx + ch.len_utf8();
 1336|  1.20k|                }
 1337|     17|                '\t' => {
 1338|     17|                    col += Self::tab_advance(col);
 1339|     17|                    cut = idx + ch.len_utf8();
 1340|     17|                }
 1341|  8.29k|                _ => return None,
 1342|       |            }
 1343|       |        }
 1344|    287|        if col >= indent {
 1345|    286|            Some(&line[cut..])
 1346|       |        } else {
 1347|      1|            None
 1348|       |        }
 1349|  8.58k|    }
 1350|       |
 1351|  1.91k|    fn has_pipe_outside_inline_code(line: &str) -> bool {
 1352|  1.91k|        if !line.contains('|') {
 1353|  1.60k|            return false;
 1354|    315|        }
 1355|    315|        let mut in_code = false;
 1356|    315|        let mut delimiter_len = 0usize;
 1357|    315|        let mut backslash_run = 0usize;
 1358|    315|        let mut chars = line.chars().peekable();
 1359|       |
 1360|    510|        while let Some(ch) = chars.next() {
                                     ^506
 1361|    506|            if ch == '\\' {
 1362|      2|                backslash_run += 1;
 1363|      2|                continue;
 1364|    504|            }
 1365|       |
 1366|    504|            let escaped = !in_code && backslash_run % 2 == 1;
                                                    ^471
 1367|    504|            backslash_run = 0;
 1368|       |
 1369|    504|            if ch == '`' {
 1370|      9|                if escaped {
 1371|      1|                    continue;
 1372|      8|                }
 1373|      8|                let mut run_len = 1usize;
 1374|     11|                while matches!(chars.peek(), Some('`')) {
                                    ^8
 1375|      3|                    chars.next();
 1376|      3|                    run_len += 1;
 1377|      3|                }
 1378|      8|                if in_code {
 1379|      4|                    if run_len == delimiter_len {
 1380|      3|                        in_code = false;
 1381|      3|                        delimiter_len = 0;
 1382|      3|                    }
                                  ^1
 1383|      4|                } else {
 1384|      4|                    in_code = true;
 1385|      4|                    delimiter_len = run_len;
 1386|      4|                }
 1387|      8|                continue;
 1388|    495|            }
 1389|       |
 1390|    495|            if ch == '|' && !in_code && !escaped {
                                          ^316        ^312
 1391|    311|                return true;
 1392|    184|            }
 1393|       |        }
 1394|       |
 1395|      4|        false
 1396|  1.91k|    }
 1397|       |
 1398|  3.87k|    fn is_table_row_candidate(line: &str) -> bool {
 1399|  3.87k|        if Self::is_indented_code_line(line) {
 1400|     16|            return false;
 1401|  3.85k|        }
 1402|  3.85k|        let trimmed_line = line.trim_end_matches(['\r', '\n']);
 1403|  3.85k|        if trimmed_line.trim().is_empty() {
 1404|  1.94k|            return false;
 1405|  1.91k|        }
 1406|  1.91k|        Self::has_pipe_outside_inline_code(trimmed_line)
 1407|  3.87k|    }
 1408|       |
 1409|     76|    fn is_table_delimiter_line(line: &str) -> bool {
 1410|     76|        if Self::is_indented_code_line(line) {
 1411|      1|            return false;
 1412|     75|        }
 1413|     75|        let trimmed = line.trim_end_matches(['\r', '\n']).trim();
 1414|     75|        if trimmed.is_empty() {
 1415|      2|            return false;
 1416|     73|        }
 1417|     73|        let mut has_dash = false;
 1418|     73|        let mut has_pipe = false;
 1419|  1.07k|        for ch in trimmed.chars() {
                                ^73     ^73
 1420|  1.07k|            match ch {
 1421|    613|                '-' => has_dash = true,
 1422|    208|                '|' => has_pipe = true,
 1423|    251|                ':' | ' ' | '\t' => {}
 1424|      2|                _ => return false,
 1425|       |            }
 1426|       |        }
 1427|     71|        has_dash && has_pipe
                                  ^70
 1428|     76|    }
 1429|       |
 1430|  6.22k|    fn fence_start(line: &str) -> Option<(char, usize)> {
 1431|  6.22k|        let trimmed = line.trim_start();
 1432|  6.22k|        let mut chars = trimmed.chars();
 1433|  6.22k|        let first = chars.next()?;
                          ^4.26k              ^1.95k
 1434|  4.26k|        if first != '`' && first != '~' {
                                         ^4.20k
 1435|  4.20k|            return None;
 1436|     67|        }
 1437|     67|        let mut count = 1usize;
 1438|    104|        for ch in chars {
                          ^101
 1439|    101|            if ch == first {
 1440|     37|                count += 1;
 1441|     37|            } else {
 1442|     64|                break;
 1443|       |            }
 1444|       |        }
 1445|     67|        if count >= 3 {
 1446|     18|            Some((first, count))
 1447|       |        } else {
 1448|     49|            None
 1449|       |        }
 1450|  6.22k|    }
 1451|       |
 1452|    122|    fn is_fence_end(line: &str, fence_char: char, fence_len: usize) -> bool {
 1453|    122|        let trimmed = line.trim_start();
 1454|    122|        let mut count = 0usize;
 1455|    161|        for ch in trimmed.chars() {
                                ^122    ^122
 1456|    161|            if ch == fence_char {
 1457|     56|                count += 1;
 1458|     56|            } else {
 1459|    105|                break;
 1460|       |            }
 1461|       |        }
 1462|    122|        count >= fence_len
 1463|    122|    }
 1464|       |
 1465|  4.07k|    fn restore_pipe_sentinel(text: &str) -> String {
 1466|  4.07k|        if text.contains(PIPE_SENTINEL) {
 1467|      2|            text.chars()
 1468|      8|                .map(|ch| if ch == PIPE_SENTINEL { '|' } else { ch })
                               ^2                                ^3           ^5
 1469|      2|                .collect()
 1470|       |        } else {
 1471|  4.06k|            text.to_string()
 1472|       |        }
 1473|  4.07k|    }
 1474|       |
 1475|       |    /// Parse markdown content into elements with proper inline handling
 1476|    272|    pub fn parse(&self, markdown: &str) -> Result<Vec<MarkdownElement>, anyhow::Error> {
 1477|       |        #[cfg(test)]
 1478|    272|        if take_forced_parse_error() {
 1479|      4|            return Err(anyhow::anyhow!("forced parse error"));
 1480|    268|        }
 1481|       |
 1482|    268|        let mut options = Options::empty();
 1483|    268|        options.insert(Options::ENABLE_STRIKETHROUGH);
 1484|    268|        options.insert(Options::ENABLE_TABLES);
 1485|    268|        options.insert(Options::ENABLE_TASKLISTS);
 1486|       |
 1487|    268|        let prepared = Self::escape_table_pipes_in_inline_code(markdown);
 1488|    268|        let parser = Parser::new_ext(&prepared, options);
 1489|    268|        let mut elements = Vec::new();
 1490|    268|        let events = parser.collect::<Vec<_>>();
 1491|       |
 1492|    268|        let mut i = 0;
 1493|       |        // Track header slug occurrences for stable de-duplication
 1494|    268|        let mut slug_counts: HashMap<String, usize> = HashMap::new();
 1495|  2.64k|        while i < events.len() {
 1496|  2.37k|            i = self.parse_element(&events, i, &mut elements, &mut slug_counts);
 1497|  2.37k|        }
 1498|       |
 1499|    268|        Ok(elements)
 1500|    272|    }
 1501|       |
 1502|       |    /// Parse a single element from the event stream
 1503|  2.39k|    fn parse_element(
 1504|  2.39k|        &self,
 1505|  2.39k|        events: &[Event],
 1506|  2.39k|        start: usize,
 1507|  2.39k|        elements: &mut Vec<MarkdownElement>,
 1508|  2.39k|        slug_counts: &mut HashMap<String, usize>,
 1509|  2.39k|    ) -> usize {
 1510|  2.39k|        match &events[start] {
 1511|       |            Event::Start(Tag::Paragraph) => {
 1512|       |                // Always preserve line breaks in paragraphs (consistent with blockquotes)
 1513|       |                // This allows poetry, lyrics, and structured content to render correctly
 1514|    718|                let (spans, next_idx) =
 1515|    718|                    self.parse_inline_spans_with_breaks(events, start + 1, Tag::Paragraph, true);
 1516|    718|                if !spans.is_empty() {
 1517|    717|                    elements.push(MarkdownElement::Paragraph(spans));
 1518|    717|                }
                              ^1
 1519|    718|                next_idx
 1520|       |            }
 1521|       |            // Images encountered outside paragraphs: treat as a single paragraph with an inline image
 1522|      2|            Event::Start(Tag::Image(_, url, title)) => {
 1523|      2|                let (alt, next_idx) = self.collect_until_tag_end(
 1524|      2|                    events,
 1525|      2|                    start + 1,
 1526|      2|                    Tag::Image(LinkType::Inline, "".into(), "".into()),
 1527|      2|                    false,
 1528|      2|                );
 1529|      2|                let mut spans: Vec<InlineSpan> = Vec::new();
 1530|      2|                spans.push(InlineSpan::Image {
 1531|      2|                    src: url.to_string(),
 1532|      2|                    alt,
 1533|      2|                    title: if title.is_empty() {
 1534|      1|                        None
 1535|       |                    } else {
 1536|      1|                        Some(title.to_string())
 1537|       |                    },
 1538|       |                });
 1539|      2|                elements.push(MarkdownElement::Paragraph(spans));
 1540|      2|                next_idx
 1541|       |            }
 1542|    864|            Event::Start(Tag::Heading(level, _, _)) => {
 1543|    864|                let (spans, next_idx) =
 1544|    864|                    self.parse_inline_spans(events, start + 1, Tag::Heading(*level, None, vec![]));
 1545|    864|                let title_text = Self::spans_plain_text(&spans);
 1546|    864|                let base = Self::slugify(&title_text);
 1547|    864|                let count = slug_counts.entry(base.clone()).or_insert(0);
 1548|    864|                let id = if *count == 0 {
 1549|    862|                    base.clone()
 1550|       |                } else {
 1551|      2|                    format!("{}-{}", base, *count)
 1552|       |                };
 1553|    864|                *count += 1;
 1554|    864|                elements.push(MarkdownElement::Header {
 1555|    864|                    level: *level as u8,
 1556|    864|                    spans,
 1557|    864|                    id,
 1558|    864|                });
 1559|    864|                next_idx
 1560|       |            }
 1561|       |            Event::Start(Tag::CodeBlock(_)) => {
 1562|      9|                let (code_text, language, next_idx) = self.parse_code_block(events, start);
 1563|      9|                elements.push(MarkdownElement::CodeBlock {
 1564|      9|                    language,
 1565|      9|                    text: code_text,
 1566|      9|                });
 1567|      9|                next_idx
 1568|       |            }
 1569|    546|            Event::Start(Tag::List(first_item)) => {
 1570|    546|                let (items, next_idx) = self.parse_list(events, start + 1, slug_counts);
 1571|    546|                elements.push(MarkdownElement::List {
 1572|    546|                    ordered: first_item.is_some(),
 1573|    546|                    items,
 1574|    546|                });
 1575|    546|                next_idx
 1576|       |            }
 1577|       |            Event::Rule => {
 1578|    208|                elements.push(MarkdownElement::HorizontalRule);
 1579|    208|                start + 1
 1580|       |            }
 1581|       |            Event::Start(Tag::BlockQuote) => {
 1582|     12|                let (quotes, next_idx) = self.collect_blockquotes(events, start + 1, 1, slug_counts);
 1583|     28|                for (depth, blocks) in quotes {
                                   ^16    ^16
 1584|     16|                    elements.push(MarkdownElement::Quote { depth, blocks });
 1585|     16|                }
 1586|     12|                next_idx
 1587|       |            }
 1588|     31|            Event::Start(Tag::Table(alignments)) => {
 1589|     31|                let (headers, rows, next_idx) = self.parse_table(events, start + 1);
 1590|     31|                elements.push(MarkdownElement::Table {
 1591|     31|                    headers,
 1592|     31|                    rows,
 1593|     31|                    alignments: alignments.to_vec(),
 1594|     31|                });
 1595|     31|                next_idx
 1596|       |            }
 1597|       |            _ => {
 1598|       |                // Skip other events
 1599|      1|                start + 1
 1600|       |            }
 1601|       |        }
 1602|  2.39k|    }
 1603|       |
 1604|       |    // Build a slug from text similar to GitHub: lowercase, spaces->dashes, strip punctuation
 1605|    876|    fn slugify(text: &str) -> String {
 1606|    876|        let mut out = String::with_capacity(text.len());
 1607|    876|        let mut last_dash = false;
 1608|  12.0k|        for ch in text.chars() {
                                ^876 ^876
 1609|  12.0k|            let c = ch.to_ascii_lowercase();
 1610|  12.0k|            if c.is_ascii_alphanumeric() {
 1611|  11.1k|                out.push(c);
 1612|  11.1k|                last_dash = false;
 1613|  11.1k|            } else if c.is_whitespace() || c == '-' {
                                    ^877^877               ^18
 1614|    871|                if !last_dash && !out.is_empty() {
                                               ^863
 1615|    861|                    out.push('-');
 1616|    861|                    last_dash = true;
 1617|    861|                }
                              ^10
 1618|      6|            } else {
 1619|      6|                // drop punctuation/symbols
 1620|      6|            }
 1621|       |        }
 1622|       |        // Trim trailing dash if any
 1623|    876|        if out.ends_with('-') {
 1624|      2|            out.pop();
 1625|    874|        }
 1626|    876|        out
 1627|    876|    }
 1628|       |
 1629|    972|    fn spans_plain_text(spans: &[InlineSpan]) -> String {
 1630|    972|        let mut s = String::new();
 1631|  1.98k|        for span in spans {
                          ^1.00k
 1632|  1.00k|            match span {
 1633|    984|                InlineSpan::Text(t)
 1634|     12|                | InlineSpan::Strong(t)
 1635|      1|                | InlineSpan::Emphasis(t)
 1636|    998|                | InlineSpan::Strikethrough(t) => s.push_str(t),
                                                          ^1
 1637|      4|                InlineSpan::Code(t) => s.push_str(t),
 1638|      1|                InlineSpan::Link { text, .. } => s.push_str(text),
 1639|      6|                InlineSpan::Image { alt, title, .. } => {
 1640|      6|                    if !alt.is_empty() {
 1641|      3|                        s.push_str(alt);
 1642|      3|                    }
 1643|      6|                    if let Some(t) = title {
                                              ^5
 1644|      5|                        if !t.is_empty() {
 1645|      4|                            if !s.is_empty() {
 1646|      2|                                s.push(' ');
 1647|      2|                            }
 1648|      4|                            s.push_str(t);
 1649|      1|                        }
 1650|      1|                    }
 1651|       |                }
 1652|       |            }
 1653|       |        }
 1654|    972|        s
 1655|    972|    }
 1656|       |
 1657|       |    /// Extract plain text from all markdown elements
 1658|     14|    pub fn elements_to_plain_text(elements: &[MarkdownElement]) -> String {
 1659|     14|        let mut result = String::new();
 1660|     35|        for element in elements.iter() {
                                     ^14      ^14
 1661|     35|            match element {
 1662|      9|                MarkdownElement::Paragraph(spans) | MarkdownElement::Header { spans, .. } => {
                                                                                            ^6
 1663|     15|                    if !result.is_empty() {
 1664|      7|                        result.push('\n');
 1665|      8|                    }
 1666|     15|                    result.push_str(&Self::spans_plain_text(spans));
 1667|       |                }
 1668|      2|                MarkdownElement::CodeBlock { text, .. } => {
 1669|      2|                    if !result.is_empty() {
 1670|      1|                        result.push('\n');
 1671|      1|                    }
 1672|      2|                    result.push_str(text);
 1673|       |                }
 1674|      5|                MarkdownElement::List { items, .. } => {
 1675|     16|                    for item in items {
                                      ^11
 1676|     22|                        for block in &item.blocks {
                                          ^11
 1677|     11|                            if !result.is_empty() {
 1678|     10|                                result.push('\n');
 1679|     10|                            }
                                          ^1
 1680|     11|                            result.push_str(&Self::element_plain_text(block));
 1681|       |                        }
 1682|       |                    }
 1683|       |                }
 1684|      3|                MarkdownElement::Quote { blocks, .. } => {
 1685|      6|                    for block in blocks {
                                      ^3
 1686|      3|                        if !result.is_empty() {
 1687|      2|                            result.push('\n');
 1688|      2|                        }
                                      ^1
 1689|      3|                        result.push_str(&Self::element_plain_text(block));
 1690|       |                    }
 1691|       |                }
 1692|       |                MarkdownElement::Table {
 1693|      5|                    headers,
 1694|      5|                    rows,
 1695|       |                    alignments: _,
 1696|       |                } => {
 1697|       |                    // Headers
 1698|     11|                    for header in headers {
                                      ^6
 1699|      6|                        if !result.is_empty() {
 1700|      5|                            result.push('\n');
 1701|      5|                        }
                                      ^1
 1702|      6|                        result.push_str(&Self::spans_plain_text(header));
 1703|       |                    }
 1704|       |                    // Rows
 1705|     15|                    for row in rows {
                                      ^10
 1706|     27|                        for cell in row {
                                          ^17
 1707|     17|                            if !result.is_empty() {
 1708|     16|                                result.push('\n');
 1709|     16|                            }
                                          ^1
 1710|     17|                            result.push_str(&Self::spans_plain_text(cell));
 1711|       |                        }
 1712|       |                    }
 1713|       |                }
 1714|       |                MarkdownElement::HorizontalRule => {
 1715|      5|                    if !result.is_empty() {
 1716|      4|                        result.push_str("\n---\n");
 1717|      4|                    }
                                  ^1
 1718|       |                }
 1719|       |            }
 1720|       |        }
 1721|     14|        result
 1722|     14|    }
 1723|       |
 1724|       |    /// Collect blockquotes into (depth, blocks) entries; supports nesting and block elements.
 1725|     26|    fn collect_blockquotes(
 1726|     26|        &self,
 1727|     26|        events: &[Event],
 1728|     26|        start: usize,
 1729|     26|        depth: u8,
 1730|     26|        slug_counts: &mut HashMap<String, usize>,
 1731|     26|    ) -> (Vec<(u8, QuoteBlocks)>, usize) {
 1732|     26|        let mut i = start;
 1733|     26|        let mut result: Vec<(u8, QuoteBlocks)> = Vec::new();
 1734|     26|        let mut blocks: QuoteBlocks = Vec::new();
 1735|     26|        let mut spans: Vec<InlineSpan> = Vec::new();
 1736|       |
 1737|     73|        let flush_inline = |blocks: &mut QuoteBlocks, spans: &mut Vec<InlineSpan>| {
                          ^26
 1738|     73|            if !spans.is_empty() {
 1739|      4|                blocks.push(MarkdownElement::Paragraph(std::mem::take(spans)));
 1740|     69|            }
 1741|     73|        };
 1742|       |
 1743|     89|        while i < events.len() {
 1744|     87|            match &events[i] {
 1745|       |                Event::Start(Tag::Paragraph) => {
 1746|     22|                    flush_inline(&mut blocks, &mut spans);
 1747|     22|                    let (ps, next) =
 1748|     22|                        self.parse_inline_spans_with_breaks(events, i + 1, Tag::Paragraph, true);
 1749|     22|                    if !ps.is_empty() {
 1750|     21|                        blocks.push(MarkdownElement::Paragraph(ps));
 1751|     21|                    }
                                  ^1
 1752|     22|                    i = next;
 1753|       |                }
 1754|      5|                Event::Start(Tag::Heading(level, _, _)) => {
 1755|      5|                    flush_inline(&mut blocks, &mut spans);
 1756|      5|                    let (ps, next) =
 1757|      5|                        self.parse_inline_spans(events, i + 1, Tag::Heading(*level, None, vec![]));
 1758|      5|                    let title_text = Self::spans_plain_text(&ps);
 1759|      5|                    let base = Self::slugify(&title_text);
 1760|      5|                    let count = slug_counts.entry(base.clone()).or_insert(0);
 1761|      5|                    let id = if *count == 0 {
 1762|      4|                        base.clone()
 1763|       |                    } else {
 1764|      1|                        format!("{}-{}", base, *count)
 1765|       |                    };
 1766|      5|                    *count += 1;
 1767|      5|                    blocks.push(MarkdownElement::Header {
 1768|      5|                        level: *level as u8,
 1769|      5|                        spans: ps,
 1770|      5|                        id,
 1771|      5|                    });
 1772|      5|                    i = next;
 1773|       |                }
 1774|      4|                Event::Start(Tag::Table(alignments)) => {
 1775|      4|                    flush_inline(&mut blocks, &mut spans);
 1776|      4|                    let (headers, rows, next_idx) = self.parse_table(events, i + 1);
 1777|      4|                    blocks.push(MarkdownElement::Table {
 1778|      4|                        headers,
 1779|      4|                        rows,
 1780|      4|                        alignments: alignments.to_vec(),
 1781|      4|                    });
 1782|      4|                    i = next_idx;
 1783|      4|                }
 1784|      4|                Event::Start(Tag::List(first_item)) => {
 1785|      4|                    flush_inline(&mut blocks, &mut spans);
 1786|      4|                    let (items, next_idx) = self.parse_list(events, i + 1, slug_counts);
 1787|      4|                    blocks.push(MarkdownElement::List {
 1788|      4|                        ordered: first_item.is_some(),
 1789|      4|                        items,
 1790|      4|                    });
 1791|      4|                    i = next_idx;
 1792|      4|                }
 1793|      3|                Event::Start(Tag::CodeBlock(_)) => {
 1794|      3|                    flush_inline(&mut blocks, &mut spans);
 1795|      3|                    let (code_text, language, next_idx) = self.parse_code_block(events, i);
 1796|      3|                    blocks.push(MarkdownElement::CodeBlock {
 1797|      3|                        language,
 1798|      3|                        text: code_text,
 1799|      3|                    });
 1800|      3|                    i = next_idx;
 1801|      3|                }
 1802|      2|                Event::Rule => {
 1803|      2|                    flush_inline(&mut blocks, &mut spans);
 1804|      2|                    blocks.push(MarkdownElement::HorizontalRule);
 1805|      2|                    i += 1;
 1806|      2|                }
 1807|       |                Event::Start(Tag::BlockQuote) => {
 1808|      7|                    flush_inline(&mut blocks, &mut spans);
 1809|      7|                    if !blocks.is_empty() {
 1810|      6|                        result.push((depth, std::mem::take(&mut blocks)));
 1811|      6|                    }
                                  ^1
 1812|      7|                    let (nested, next) =
 1813|      7|                        self.collect_blockquotes(events, i + 1, depth + 1, slug_counts);
 1814|      7|                    result.extend(nested);
 1815|      7|                    i = next;
 1816|       |                }
 1817|       |                Event::End(Tag::BlockQuote) => {
 1818|     24|                    flush_inline(&mut blocks, &mut spans);
 1819|     24|                    if !blocks.is_empty() {
 1820|     16|                        result.push((depth, blocks));
 1821|     16|                    }
                                  ^8
 1822|     24|                    return (result, i + 1);
 1823|       |                }
 1824|      1|                Event::Text(t) => {
 1825|      1|                    spans.push(InlineSpan::Text(Self::restore_pipe_sentinel(t)));
 1826|      1|                    i += 1;
 1827|      1|                }
 1828|      2|                Event::Code(code) => {
 1829|      2|                    spans.push(InlineSpan::Code(Self::restore_pipe_sentinel(code)));
 1830|      2|                    i += 1;
 1831|      2|                }
 1832|      1|                Event::Start(Tag::Emphasis) => {
 1833|      1|                    let (inner_text, next) =
 1834|      1|                        self.collect_until_tag_end(events, i + 1, Tag::Emphasis, true);
 1835|      1|                    spans.push(InlineSpan::Emphasis(inner_text));
 1836|      1|                    i = next;
 1837|      1|                }
 1838|      1|                Event::Start(Tag::Strong) => {
 1839|      1|                    let (inner_text, next) =
 1840|      1|                        self.collect_until_tag_end(events, i + 1, Tag::Strong, true);
 1841|      1|                    spans.push(InlineSpan::Strong(inner_text));
 1842|      1|                    i = next;
 1843|      1|                }
 1844|      1|                Event::Start(Tag::Strikethrough) => {
 1845|      1|                    let (inner_text, next) =
 1846|      1|                        self.collect_until_tag_end(events, i + 1, Tag::Strikethrough, true);
 1847|      1|                    spans.push(InlineSpan::Strikethrough(inner_text));
 1848|      1|                    i = next;
 1849|      1|                }
 1850|      2|                Event::Start(Tag::Link(_, url, _)) => {
 1851|      2|                    let url_str = url.to_string();
 1852|      2|                    let (link_text, next) = self.collect_until_tag_end(
 1853|      2|                        events,
 1854|      2|                        i + 1,
 1855|      2|                        Tag::Link(LinkType::Inline, "".into(), "".into()),
 1856|      2|                        true,
 1857|      2|                    );
 1858|      2|                    spans.push(InlineSpan::Link {
 1859|      2|                        text: link_text,
 1860|      2|                        url: url_str,
 1861|      2|                    });
 1862|      2|                    i = next;
 1863|      2|                }
 1864|      2|                Event::Start(Tag::Image(_, url, title)) => {
 1865|      2|                    let url_str = url.to_string();
 1866|      2|                    let (alt_text, next) = self.collect_until_tag_end(
 1867|      2|                        events,
 1868|      2|                        i + 1,
 1869|      2|                        Tag::Image(LinkType::Inline, "".into(), "".into()),
 1870|      2|                        true,
 1871|      2|                    );
 1872|      2|                    spans.push(InlineSpan::Image {
 1873|      2|                        src: url_str,
 1874|      2|                        alt: alt_text,
 1875|      2|                        title: if title.is_empty() {
 1876|      1|                            None
 1877|       |                        } else {
 1878|      1|                            Some(title.to_string())
 1879|       |                        },
 1880|       |                    });
 1881|      2|                    i = next;
 1882|       |                }
 1883|      3|                Event::SoftBreak | Event::HardBreak => {
 1884|      3|                    spans.push(InlineSpan::Text("\n".to_string()));
 1885|      3|                    i += 1;
 1886|      3|                }
 1887|      2|                Event::Html(html) => {
 1888|      2|                    if Self::is_html_line_break(html) {
 1889|      1|                        spans.push(InlineSpan::Text("\n".to_string()));
 1890|      1|                    }
 1891|      2|                    i += 1;
 1892|       |                }
 1893|      1|                _ => {
 1894|      1|                    i += 1;
 1895|      1|                }
 1896|       |            }
 1897|       |        }
 1898|       |
 1899|      2|        flush_inline(&mut blocks, &mut spans);
 1900|      2|        if !blocks.is_empty() {
 1901|      1|            result.push((depth, blocks));
 1902|      1|        }
 1903|      2|        (result, i)
 1904|     26|    }
 1905|       |
 1906|       |    /// Parse inline spans until reaching the end tag
 1907|  2.14k|    fn parse_inline_spans_with_breaks(
 1908|  2.14k|        &self,
 1909|  2.14k|        events: &[Event],
 1910|  2.14k|        start: usize,
 1911|  2.14k|        end_tag: Tag,
 1912|  2.14k|        keep_breaks: bool,
 1913|  2.14k|    ) -> (Vec<InlineSpan>, usize) {
 1914|  2.14k|        let mut spans = Vec::new();
 1915|  2.14k|        let mut i = start;
 1916|  2.14k|        let mut text_buffer = String::new();
 1917|       |
 1918|  4.64k|        while i < events.len() {
 1919|  4.64k|            match &events[i] {
 1920|  2.14k|                Event::End(tag)
 1921|  2.14k|                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
                                                                                                   ^2.14k
 1922|       |                {
 1923|  2.14k|                    if !text_buffer.is_empty() {
 1924|  1.74k|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1925|  1.74k|                        text_buffer.clear();
 1926|  1.74k|                    }
                                  ^400
 1927|  2.14k|                    return (spans, i + 1);
 1928|       |                }
 1929|  1.97k|                Event::Text(text) => {
 1930|  1.97k|                    let restored = Self::restore_pipe_sentinel(text);
 1931|  1.97k|                    text_buffer.push_str(&restored);
 1932|  1.97k|                    i += 1;
 1933|  1.97k|                }
 1934|       |                Event::SoftBreak | Event::HardBreak => {
 1935|     19|                    if keep_breaks {
 1936|     18|                        if !text_buffer.is_empty() {
 1937|     11|                            spans.push(InlineSpan::Text(text_buffer.clone()));
 1938|     11|                            text_buffer.clear();
 1939|     11|                        }
                                      ^7
 1940|     18|                        spans.push(InlineSpan::Text("\n".to_string()));
 1941|      1|                    } else {
 1942|      1|                        text_buffer.push(' ');
 1943|      1|                    }
 1944|     19|                    i += 1;
 1945|       |                }
 1946|    177|                Event::Code(code) => {
 1947|    177|                    if !text_buffer.is_empty() {
 1948|     29|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1949|     29|                        text_buffer.clear();
 1950|    148|                    }
 1951|    177|                    spans.push(InlineSpan::Code(Self::restore_pipe_sentinel(code)));
 1952|    177|                    i += 1;
 1953|       |                }
 1954|     20|                Event::Html(html) => {
 1955|     20|                    if Self::is_html_line_break(html) {
 1956|     19|                        if keep_breaks {
 1957|     18|                            if !text_buffer.is_empty() {
 1958|     16|                                spans.push(InlineSpan::Text(text_buffer.clone()));
 1959|     16|                                text_buffer.clear();
 1960|     16|                            }
                                          ^2
 1961|     18|                            spans.push(InlineSpan::Text("\n".to_string()));
 1962|      1|                        } else {
 1963|      1|                            text_buffer.push(' ');
 1964|      1|                        }
 1965|      1|                    }
 1966|     20|                    i += 1;
 1967|       |                }
 1968|       |                Event::Start(Tag::Strong) => {
 1969|     51|                    if !text_buffer.is_empty() {
 1970|      7|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1971|      7|                        text_buffer.clear();
 1972|     44|                    }
 1973|     51|                    let (inner_text, next_i) =
 1974|     51|                        self.collect_until_tag_end(events, i + 1, Tag::Strong, keep_breaks);
 1975|     51|                    spans.push(InlineSpan::Strong(inner_text));
 1976|     51|                    i = next_i;
 1977|       |                }
 1978|       |                Event::Start(Tag::Emphasis) => {
 1979|    209|                    if !text_buffer.is_empty() {
 1980|      7|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1981|      7|                        text_buffer.clear();
 1982|    202|                    }
 1983|    209|                    let (inner_text, next_i) =
 1984|    209|                        self.collect_until_tag_end(events, i + 1, Tag::Emphasis, keep_breaks);
 1985|    209|                    spans.push(InlineSpan::Emphasis(inner_text));
 1986|    209|                    i = next_i;
 1987|       |                }
 1988|       |                Event::Start(Tag::Strikethrough) => {
 1989|      5|                    if !text_buffer.is_empty() {
 1990|      4|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1991|      4|                        text_buffer.clear();
 1992|      4|                    }
                                  ^1
 1993|      5|                    let (inner_text, next_i) =
 1994|      5|                        self.collect_until_tag_end(events, i + 1, Tag::Strikethrough, keep_breaks);
 1995|      5|                    spans.push(InlineSpan::Strikethrough(inner_text));
 1996|      5|                    i = next_i;
 1997|       |                }
 1998|     17|                Event::Start(Tag::Link(_, url, _)) => {
 1999|     17|                    if !text_buffer.is_empty() {
 2000|      8|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 2001|      8|                        text_buffer.clear();
 2002|      9|                    }
 2003|     17|                    let url_str = url.to_string();
 2004|     17|                    let (link_text, next_i) = self.collect_until_tag_end(
 2005|     17|                        events,
 2006|     17|                        i + 1,
 2007|     17|                        Tag::Link(LinkType::Inline, "".into(), "".into()),
 2008|     17|                        keep_breaks,
 2009|     17|                    );
 2010|     17|                    spans.push(InlineSpan::Link {
 2011|     17|                        text: link_text,
 2012|     17|                        url: url_str,
 2013|     17|                    });
 2014|     17|                    i = next_i;
 2015|       |                }
 2016|     20|                Event::Start(Tag::Image(_, url, title)) => {
 2017|     20|                    if !text_buffer.is_empty() {
 2018|      3|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 2019|      3|                        text_buffer.clear();
 2020|     17|                    }
 2021|     20|                    let url_str = url.to_string();
 2022|     20|                    let (alt_text, next_i) = self.collect_until_tag_end(
 2023|     20|                        events,
 2024|     20|                        i + 1,
 2025|     20|                        Tag::Image(LinkType::Inline, "".into(), "".into()),
 2026|     20|                        keep_breaks,
 2027|     20|                    );
 2028|     20|                    spans.push(InlineSpan::Image {
 2029|     20|                        src: url_str,
 2030|     20|                        alt: alt_text,
 2031|     20|                        title: if title.is_empty() {
 2032|      3|                            None
 2033|       |                        } else {
 2034|     17|                            Some(title.to_string())
 2035|       |                        },
 2036|       |                    });
 2037|     20|                    i = next_i;
 2038|       |                }
 2039|      2|                _ => {
 2040|      2|                    i += 1;
 2041|      2|                }
 2042|       |            }
 2043|       |        }
 2044|       |
 2045|      3|        if !text_buffer.is_empty() {
 2046|      2|            spans.push(InlineSpan::Text(text_buffer));
 2047|      2|        }
                      ^1
 2048|       |
 2049|      3|        (spans, i)
 2050|  2.14k|    }
 2051|       |
 2052|       |    /// Default inline parsing without preserving explicit line breaks
 2053|    880|    fn parse_inline_spans(
 2054|    880|        &self,
 2055|    880|        events: &[Event],
 2056|    880|        start: usize,
 2057|    880|        end_tag: Tag,
 2058|    880|    ) -> (Vec<InlineSpan>, usize) {
 2059|    880|        self.parse_inline_spans_with_breaks(events, start, end_tag, false)
 2060|    880|    }
 2061|       |
 2062|       |    /// Collect text until a specific end tag
 2063|  1.90k|    fn collect_until_tag_end(
 2064|  1.90k|        &self,
 2065|  1.90k|        events: &[Event],
 2066|  1.90k|        start: usize,
 2067|  1.90k|        end_tag: Tag,
 2068|  1.90k|        keep_breaks: bool,
 2069|  1.90k|    ) -> (String, usize) {
 2070|  1.90k|        let mut text = String::new();
 2071|  1.90k|        let mut i = start;
 2072|       |
 2073|  3.83k|        while i < events.len() {
 2074|  3.83k|            match &events[i] {
 2075|  1.90k|                Event::End(tag)
 2076|  1.90k|                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
                                                                                                   ^1.90k
 2077|       |                {
 2078|  1.90k|                    return (text, i + 1);
 2079|       |                }
 2080|  1.90k|                Event::Text(t) => {
 2081|  1.90k|                    let restored = Self::restore_pipe_sentinel(t);
 2082|  1.90k|                    text.push_str(&restored);
 2083|  1.90k|                }
 2084|      2|                Event::Code(code) => {
 2085|      2|                    let restored = Self::restore_pipe_sentinel(code);
 2086|      2|                    text.push_str(&restored);
 2087|      2|                }
 2088|       |                Event::SoftBreak | Event::HardBreak => {
 2089|      5|                    if keep_breaks {
 2090|      3|                        text.push('\n');
 2091|      3|                    } else {
 2092|      2|                        text.push(' ');
 2093|      2|                    }
 2094|       |                }
 2095|      8|                Event::Html(html) => {
 2096|      8|                    if Self::is_html_line_break(html) {
 2097|      6|                        if keep_breaks {
 2098|      4|                            text.push('\n');
 2099|      4|                        } else {
 2100|      2|                            text.push(' ');
 2101|      2|                        }
 2102|      2|                    }
 2103|       |                }
 2104|      4|                _ => {}
 2105|       |            }
 2106|  1.92k|            i += 1;
 2107|       |        }
 2108|       |
 2109|      1|        (text, i)
 2110|  1.90k|    }
 2111|       |
 2112|       |    /// Parse a code block
 2113|     18|    fn parse_code_block(
 2114|     18|        &self,
 2115|     18|        events: &[Event],
 2116|     18|        start: usize,
 2117|     18|    ) -> (String, Option<String>, usize) {
 2118|     18|        let mut language = None;
 2119|     18|        let mut code_text = String::new();
 2120|     18|        let mut i = start;
 2121|       |
 2122|       |        // Extract language from the start tag
 2123|     18|        if let Event::Start(Tag::CodeBlock(kind)) = &events[start] {
                                                         ^17
 2124|     17|            if let pulldown_cmark::CodeBlockKind::Fenced(lang) = kind {
                                                                       ^16
 2125|     16|                if !lang.is_empty() {
 2126|     15|                    language = Some(lang.to_string());
 2127|     15|                }
                              ^1
 2128|      1|            }
 2129|     17|            i += 1;
 2130|      1|        }
 2131|       |
 2132|     39|        while i < events.len() {
 2133|     38|            match &events[i] {
 2134|       |                Event::End(Tag::CodeBlock(_)) => {
 2135|     17|                    return (code_text, language, i + 1);
 2136|       |                }
 2137|     20|                Event::Text(text) => {
 2138|     20|                    code_text.push_str(text);
 2139|     20|                }
 2140|      1|                _ => {}
 2141|       |            }
 2142|     21|            i += 1;
 2143|       |        }
 2144|       |
 2145|      1|        (code_text, language, i)
 2146|     18|    }
 2147|       |
 2148|       |    /// Parse a list item into block-level markdown elements.
 2149|    564|    fn parse_list(
 2150|    564|        &self,
 2151|    564|        events: &[Event],
 2152|    564|        start: usize,
 2153|    564|        slug_counts: &mut HashMap<String, usize>,
 2154|    564|    ) -> (Vec<ListItem>, usize) {
 2155|    564|        let mut items: Vec<ListItem> = Vec::new();
 2156|    564|        let mut i = start;
 2157|       |
 2158|  2.62k|        while i < events.len() {
 2159|  2.62k|            match &events[i] {
 2160|    563|                Event::End(Tag::List(_)) => return (items, i + 1),
 2161|       |                Event::Start(Tag::Item) => {
 2162|  2.06k|                    i += 1;
 2163|  2.06k|                    let mut blocks: Vec<MarkdownElement> = Vec::new();
 2164|  2.06k|                    let mut spans: Vec<InlineSpan> = Vec::new();
 2165|  2.06k|                    let flush_inline =
 2166|  2.08k|                        |blocks: &mut Vec<MarkdownElement>, spans: &mut Vec<InlineSpan>| {
 2167|  2.08k|                            if !spans.is_empty() {
 2168|  2.05k|                                blocks.push(MarkdownElement::Paragraph(std::mem::take(spans)));
 2169|  2.05k|                            }
                                          ^29
 2170|  2.08k|                        };
 2171|       |
 2172|       |                    loop {
 2173|  7.09k|                        if i >= events.len() {
 2174|      1|                            break;
 2175|  7.09k|                        }
 2176|  7.09k|                        match &events[i] {
 2177|       |                            Event::End(Tag::Item) => {
 2178|  2.06k|                                i += 1;
 2179|  2.06k|                                break;
 2180|       |                            }
 2181|       |                            Event::Start(Tag::Paragraph) => {
 2182|      2|                                flush_inline(&mut blocks, &mut spans);
 2183|      2|                                let (ps, next) =
 2184|      2|                                    self.parse_inline_spans(events, i + 1, Tag::Paragraph);
 2185|      2|                                if !ps.is_empty() {
 2186|      1|                                    blocks.push(MarkdownElement::Paragraph(ps));
 2187|      1|                                }
 2188|      2|                                i = next;
 2189|       |                            }
 2190|      5|                            Event::Start(Tag::Heading(level, _, _)) => {
 2191|      5|                                flush_inline(&mut blocks, &mut spans);
 2192|      5|                                let (ps, next) = self.parse_inline_spans(
 2193|      5|                                    events,
 2194|      5|                                    i + 1,
 2195|      5|                                    Tag::Heading(*level, None, vec![]),
 2196|      5|                                );
 2197|      5|                                let title_text = Self::spans_plain_text(&ps);
 2198|      5|                                let base = Self::slugify(&title_text);
 2199|      5|                                let count = slug_counts.entry(base.clone()).or_insert(0);
 2200|      5|                                let id = if *count == 0 {
 2201|      4|                                    base.clone()
 2202|       |                                } else {
 2203|      1|                                    format!("{}-{}", base, *count)
 2204|       |                                };
 2205|      5|                                *count += 1;
 2206|      5|                                blocks.push(MarkdownElement::Header {
 2207|      5|                                    level: *level as u8,
 2208|      5|                                    spans: ps,
 2209|      5|                                    id,
 2210|      5|                                });
 2211|      5|                                i = next;
 2212|       |                            }
 2213|      3|                            Event::Start(Tag::Table(alignments)) => {
 2214|      3|                                flush_inline(&mut blocks, &mut spans);
 2215|      3|                                let (headers, rows, next_idx) = self.parse_table(events, i + 1);
 2216|      3|                                blocks.push(MarkdownElement::Table {
 2217|      3|                                    headers,
 2218|      3|                                    rows,
 2219|      3|                                    alignments: alignments.to_vec(),
 2220|      3|                                });
 2221|      3|                                i = next_idx;
 2222|      3|                            }
 2223|      2|                            Event::Start(Tag::CodeBlock(_)) => {
 2224|      2|                                flush_inline(&mut blocks, &mut spans);
 2225|      2|                                let (code_text, language, next_idx) =
 2226|      2|                                    self.parse_code_block(events, i);
 2227|      2|                                blocks.push(MarkdownElement::CodeBlock {
 2228|      2|                                    language,
 2229|      2|                                    text: code_text,
 2230|      2|                                });
 2231|      2|                                i = next_idx;
 2232|      2|                            }
 2233|       |                            Event::Start(Tag::BlockQuote) => {
 2234|      2|                                flush_inline(&mut blocks, &mut spans);
 2235|      2|                                let (quotes, next_idx) =
 2236|      2|                                    self.collect_blockquotes(events, i + 1, 1, slug_counts);
 2237|      4|                                for (depth, quote_blocks) in quotes {
                                                   ^2     ^2
 2238|      2|                                    blocks.push(MarkdownElement::Quote {
 2239|      2|                                        depth,
 2240|      2|                                        blocks: quote_blocks,
 2241|      2|                                    });
 2242|      2|                                }
 2243|      2|                                i = next_idx;
 2244|       |                            }
 2245|      8|                            Event::Start(Tag::List(child_first)) => {
 2246|      8|                                flush_inline(&mut blocks, &mut spans);
 2247|      8|                                let (child_items, next) = self.parse_list(events, i + 1, slug_counts);
 2248|      8|                                blocks.push(MarkdownElement::List {
 2249|      8|                                    ordered: child_first.is_some(),
 2250|      8|                                    items: child_items,
 2251|      8|                                });
 2252|      8|                                i = next;
 2253|      8|                            }
 2254|      1|                            Event::Rule => {
 2255|      1|                                flush_inline(&mut blocks, &mut spans);
 2256|      1|                                blocks.push(MarkdownElement::HorizontalRule);
 2257|      1|                                i += 1;
 2258|      1|                            }
 2259|    720|                            Event::Code(code) => {
 2260|    720|                                spans.push(InlineSpan::Code(code.to_string()));
 2261|    720|                                i += 1;
 2262|    720|                            }
 2263|      7|                            Event::Start(Tag::Emphasis) => {
 2264|      7|                                let (inner_text, next) = self.collect_until_tag_end(
 2265|      7|                                    events,
 2266|      7|                                    i + 1,
 2267|      7|                                    Tag::Emphasis,
 2268|      7|                                    false,
 2269|      7|                                );
 2270|      7|                                spans.push(InlineSpan::Emphasis(inner_text));
 2271|      7|                                i = next;
 2272|      7|                            }
 2273|  1.54k|                            Event::Start(Tag::Strong) => {
 2274|  1.54k|                                let (inner_text, next) =
 2275|  1.54k|                                    self.collect_until_tag_end(events, i + 1, Tag::Strong, false);
 2276|  1.54k|                                spans.push(InlineSpan::Strong(inner_text));
 2277|  1.54k|                                i = next;
 2278|  1.54k|                            }
 2279|      7|                            Event::Start(Tag::Strikethrough) => {
 2280|      7|                                let (inner_text, next) = self.collect_until_tag_end(
 2281|      7|                                    events,
 2282|      7|                                    i + 1,
 2283|      7|                                    Tag::Strikethrough,
 2284|      7|                                    false,
 2285|      7|                                );
 2286|      7|                                spans.push(InlineSpan::Strikethrough(inner_text));
 2287|      7|                                i = next;
 2288|      7|                            }
 2289|     26|                            Event::Start(Tag::Link(_, url, _)) => {
 2290|     26|                                let url_str = url.to_string();
 2291|     26|                                let (link_text, next) = self.collect_until_tag_end(
 2292|     26|                                    events,
 2293|     26|                                    i + 1,
 2294|     26|                                    Tag::Link(LinkType::Inline, "".into(), "".into()),
 2295|     26|                                    false,
 2296|     26|                                );
 2297|     26|                                spans.push(InlineSpan::Link {
 2298|     26|                                    text: link_text,
 2299|     26|                                    url: url_str,
 2300|     26|                                });
 2301|     26|                                i = next;
 2302|     26|                            }
 2303|      4|                            Event::Start(Tag::Image(_, url, title)) => {
 2304|      4|                                let url_str = url.to_string();
 2305|      4|                                let (alt_text, next) = self.collect_until_tag_end(
 2306|      4|                                    events,
 2307|      4|                                    i + 1,
 2308|      4|                                    Tag::Image(LinkType::Inline, "".into(), "".into()),
 2309|      4|                                    false,
 2310|      4|                                );
 2311|      4|                                spans.push(InlineSpan::Image {
 2312|      4|                                    src: url_str,
 2313|      4|                                    alt: alt_text,
 2314|      4|                                    title: if title.is_empty() {
 2315|      1|                                        None
 2316|       |                                    } else {
 2317|      3|                                        Some(title.to_string())
 2318|       |                                    },
 2319|       |                                });
 2320|      4|                                i = next;
 2321|       |                            }
 2322|  2.69k|                            Event::Text(t) => {
 2323|  2.69k|                                spans.push(InlineSpan::Text(t.to_string()));
 2324|  2.69k|                                i += 1;
 2325|  2.69k|                            }
 2326|      4|                            Event::SoftBreak | Event::HardBreak => {
 2327|      4|                                spans.push(InlineSpan::Text(" ".into()));
 2328|      4|                                i += 1;
 2329|      4|                            }
 2330|      1|                            _ => {
 2331|      1|                                i += 1;
 2332|      1|                            }
 2333|       |                        }
 2334|       |                    }
 2335|       |
 2336|  2.06k|                    flush_inline(&mut blocks, &mut spans);
 2337|  2.06k|                    items.push(ListItem { blocks });
 2338|       |                }
 2339|      1|                _ => i += 1,
 2340|       |            }
 2341|       |        }
 2342|       |
 2343|      1|        (items, i)
 2344|    564|    }
 2345|       |
 2346|       |    /// Parse a table with headers and rows
 2347|     44|    fn parse_table(
 2348|     44|        &self,
 2349|     44|        events: &[Event],
 2350|     44|        start: usize,
 2351|     44|    ) -> TableParseResult {
 2352|     44|        let mut headers: Vec<Vec<InlineSpan>> = Vec::new();
 2353|     44|        let mut rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
 2354|     44|        let mut i = start;
 2355|       |
 2356|    298|        while i < events.len() {
 2357|    295|            match &events[i] {
 2358|       |                Event::Start(Tag::TableHead) => {
 2359|     42|                    i += 1;
 2360|    134|                    while i < events.len() {
 2361|    133|                        match &events[i] {
 2362|     81|                            Event::Start(Tag::TableCell) => {
 2363|     81|                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
 2364|     81|                                    events,
 2365|     81|                                    i + 1,
 2366|     81|                                    Tag::TableCell,
 2367|     81|                                    true,
 2368|     81|                                );
 2369|     81|                                headers.push(spans);
 2370|     81|                                i = next_idx;
 2371|     81|                            }
 2372|       |                            Event::End(Tag::TableHead) => {
 2373|     41|                                i += 1;
 2374|     41|                                break;
 2375|       |                            }
 2376|     11|                            _ => i += 1,
 2377|       |                        }
 2378|       |                    }
 2379|       |                }
 2380|       |                Event::Start(Tag::TableRow) => {
 2381|    211|                    i += 1;
 2382|    211|                    let mut row: Vec<Vec<InlineSpan>> = Vec::new();
 2383|    646|                    while i < events.len() {
 2384|    645|                        match &events[i] {
 2385|    434|                            Event::Start(Tag::TableCell) => {
 2386|    434|                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
 2387|    434|                                    events,
 2388|    434|                                    i + 1,
 2389|    434|                                    Tag::TableCell,
 2390|    434|                                    true,
 2391|    434|                                );
 2392|    434|                                row.push(spans);
 2393|    434|                                i = next_idx;
 2394|    434|                            }
 2395|       |                            Event::End(Tag::TableRow) => {
 2396|    210|                                i += 1;
 2397|    210|                                if !row.is_empty() {
 2398|    209|                                    rows.push(row);
 2399|    209|                                }
                                              ^1
 2400|    210|                                break;
 2401|       |                            }
 2402|      1|                            _ => i += 1,
 2403|       |                        }
 2404|       |                    }
 2405|       |                }
 2406|     41|                Event::End(Tag::Table(_)) => return (headers, rows, i + 1),
 2407|      1|                _ => i += 1,
 2408|       |            }
 2409|       |        }
 2410|      3|        (headers, rows, i)
 2411|     44|    }
 2412|       |
 2413|     90|    fn render_element_body(&self, ui: &mut egui::Ui, element: &MarkdownElement) {
 2414|     90|        match element {
 2415|     29|            MarkdownElement::Paragraph(spans) => {
 2416|     29|                self.render_inline_spans(ui, spans);
 2417|     29|                ui.add_space(4.0);
 2418|     29|            }
 2419|      1|            MarkdownElement::Quote { depth, blocks } => {
 2420|      1|                ui.add_space(4.0);
 2421|      1|                let bar_width = 3.0;
 2422|      1|                let bar_gap = 6.0;
 2423|      1|                let left_pad = 10.0 + (*depth as f32) * (bar_width + bar_gap);
 2424|       |                // Substack-like styling: dark grey block with orange accent bars and white text
 2425|      1|                let bg = Color32::from_rgb(24, 24, 24);
 2426|       |
 2427|      1|                let resp = egui::Frame::none()
 2428|      1|                    .fill(bg)
 2429|      1|                    .stroke(Stroke::new(1.0, Color32::from_rgb(40, 40, 40)))
 2430|      1|                    .rounding(egui::Rounding::same(6.0))
 2431|      1|                    .inner_margin(egui::Margin {
 2432|      1|                        left: left_pad,
 2433|      1|                        right: 10.0,
 2434|      1|                        top: 8.0,
 2435|      1|                        bottom: 8.0,
 2436|      1|                    })
 2437|      1|                    .show(ui, |ui| {
 2438|      1|                        let prev_override = ui.style().visuals.override_text_color;
 2439|       |                        // White text for quote content
 2440|      1|                        ui.style_mut().visuals.override_text_color = Some(Color32::WHITE);
 2441|      2|                        for block in blocks {
                                          ^1
 2442|      1|                            self.render_element_body(ui, block);
 2443|      1|                        }
 2444|      1|                        ui.style_mut().visuals.override_text_color = prev_override;
 2445|      1|                    });
 2446|       |
 2447|       |                // Draw vertical orange quote bars on the left of the frame
 2448|      1|                let rect = resp.response.rect;
 2449|      1|                let top = rect.top() + 6.0;
 2450|      1|                let bottom = rect.bottom() - 6.0;
 2451|      1|                let bar_color = Color32::from_rgb(255, 103, 25); // Substack-like orange
 2452|      1|                for d in 0..*depth {
 2453|      1|                    let x = rect.left() + 6.0 + (d as f32) * (bar_width + bar_gap);
 2454|      1|                    let bar_rect = egui::Rect::from_min_max(
 2455|      1|                        egui::pos2(x, top),
 2456|      1|                        egui::pos2(x + bar_width, bottom),
 2457|      1|                    );
 2458|      1|                    ui.painter().rect_filled(bar_rect, 2.0, bar_color);
 2459|      1|                }
 2460|       |
 2461|      1|                ui.add_space(6.0);
 2462|       |            }
 2463|     32|            MarkdownElement::Header { level, spans, id } => {
 2464|     32|                let font_size = match level {
 2465|     13|                    1 => self.font_sizes.h1,
 2466|     14|                    2 => self.font_sizes.h2,
 2467|      1|                    3 => self.font_sizes.h3,
 2468|      1|                    4 => self.font_sizes.h4,
 2469|      1|                    5 => self.font_sizes.h5,
 2470|      1|                    6 => self.font_sizes.h6,
 2471|      1|                    _ => self.font_sizes.body,
 2472|       |                };
 2473|       |
 2474|     32|                ui.add_space(8.0);
 2475|     32|                let resp = ui.horizontal_wrapped(|ui| {
 2476|       |                    // Avoid artificial gaps between header fragments
 2477|     32|                    ui.spacing_mut().item_spacing.x = 0.0;
 2478|     64|                    for span in spans {
                                      ^32
 2479|     32|                        self.render_inline_span(ui, span, Some(font_size), Some(true));
 2480|     32|                    }
 2481|     32|                });
 2482|       |                // Record the header rect for in-document navigation
 2483|     32|                self.header_rects
 2484|     32|                    .borrow_mut()
 2485|     32|                    .insert(id.clone(), resp.response.rect);
 2486|     32|                ui.add_space(6.0);
 2487|       |            }
 2488|      4|            MarkdownElement::CodeBlock { language, text } => {
 2489|      4|                self.render_code_block(ui, language.as_deref(), text);
 2490|      4|            }
 2491|     13|            MarkdownElement::List { ordered, items } => {
 2492|     13|                self.render_list(ui, *ordered, items);
 2493|     13|            }
 2494|      7|            MarkdownElement::HorizontalRule => {
 2495|      7|                ui.add_space(8.0);
 2496|      7|                ui.separator();
 2497|      7|                ui.add_space(8.0);
 2498|      7|            }
 2499|       |            MarkdownElement::Table {
 2500|      4|                headers,
 2501|      4|                rows,
 2502|      4|                alignments,
 2503|      4|            } => {
 2504|      4|                self.render_table(ui, headers, rows, alignments);
 2505|      4|            }
 2506|       |        }
 2507|     90|    }
 2508|       |
 2509|       |    /// Render parsed markdown elements to egui UI
 2510|     23|    pub fn render_to_ui(&self, ui: &mut egui::Ui, elements: &[MarkdownElement]) {
 2511|     23|        self.poll_image_results(ui.ctx());
 2512|     23|        self.mermaid.begin_frame();
 2513|       |        // Clear header rects before rendering a new frame
 2514|     23|        self.header_rects.borrow_mut().clear();
 2515|       |        // Reset per-frame link counter to ensure link IDs are stable across frames
 2516|     23|        *self.link_counter.borrow_mut() = 0;
 2517|       |        // Reset per-frame table counter
 2518|     23|        *self.table_counter.borrow_mut() = 0;
 2519|       |        // Reset per-frame element rects
 2520|     23|        self.element_rects.borrow_mut().clear();
 2521|     79|        for element in elements.iter() {
                                     ^23      ^23
 2522|       |            // Wrap each element in a no-op frame to capture its rect
 2523|     79|            let ir = egui::Frame::none().show(ui, |ui| {
 2524|     79|                self.render_element_body(ui, element);
 2525|     79|            });
 2526|     79|            self.element_rects.borrow_mut().push(ir.response.rect);
 2527|       |        }
 2528|       |        // Add a little extra breathing room at the end so
 2529|       |        // the final line doesn't sit flush under the status bar.
 2530|     23|        ui.add_space(16.0);
 2531|     23|    }
 2532|       |
 2533|       |    /// Render inline spans in a wrapped horizontal layout
 2534|     29|    fn render_inline_spans(&self, ui: &mut egui::Ui, spans: &[InlineSpan]) {
 2535|     29|        ui.horizontal_wrapped(|ui| {
 2536|       |            // Avoid adding UI spacing between inline fragments
 2537|     29|            ui.spacing_mut().item_spacing.x = 0.0;
 2538|     70|            for span in spans {
                              ^41
 2539|     41|                self.render_inline_span(ui, span, None, None);
 2540|     41|            }
 2541|     29|        });
 2542|     29|    }
 2543|       |
 2544|       |    /// Fix Unicode characters that may not render properly in the default font
 2545|    463|    fn fix_unicode_chars(&self, text: &str) -> String {
 2546|    463|        let normalized: String = text.nfc().collect();
 2547|  5.73k|        if !normalized.chars().any(|c| {
                          ^463               ^463
 2548|  5.73k|            matches!(
 2549|  5.73k|                c,
 2550|       |                '\u{2011}'
 2551|       |                    | '\u{00AD}'
 2552|       |                    | '\u{2010}'
 2553|       |                    | '\u{2212}'
 2554|       |                    | '\u{2013}'
 2555|       |                    | '\u{2014}'
 2556|       |                    | '\u{00A0}'
 2557|       |                    | '\u{202F}'
 2558|       |                    | '\u{2190}'
 2559|       |                    | '\u{2192}'
 2560|       |                    | '\u{2191}'
 2561|       |                    | '\u{2193}'
 2562|       |            )
 2563|  5.73k|        }) {
 2564|    460|            return normalized;
 2565|      3|        }
 2566|       |
 2567|      3|        let mut out = String::with_capacity(normalized.len());
 2568|     15|        for ch in normalized.chars() {
                                ^3         ^3
 2569|     15|            match ch {
 2570|       |                '\u{2011}' | '\u{00AD}' | '\u{2010}' | '\u{2212}' | '\u{2013}' | '\u{2014}' => {
 2571|      1|                    out.push('-')
 2572|       |                }
 2573|      1|                '\u{00A0}' | '\u{202F}' => out.push(' '),
 2574|      1|                '\u{2190}' => {
 2575|      1|                    out.push('<');
 2576|      1|                    out.push('-');
 2577|      1|                }
 2578|      2|                '\u{2192}' => {
 2579|      2|                    out.push('-');
 2580|      2|                    out.push('>');
 2581|      2|                }
 2582|      1|                '\u{2191}' => {
 2583|      1|                    out.push('^');
 2584|      1|                }
 2585|      1|                '\u{2193}' => {
 2586|      1|                    out.push('v');
 2587|      1|                }
 2588|      8|                _ => out.push(ch),
 2589|       |            }
 2590|       |        }
 2591|      3|        out
 2592|    463|    }
 2593|       |
 2594|       |    #[cfg(test)]
 2595|      3|    pub(crate) fn normalize_text_for_test(&self, text: &str) -> String {
 2596|      3|        self.fix_unicode_chars(text)
 2597|      3|    }
 2598|       |
 2599|       |    /// Render a single inline span    /// Render a single inline span
 2600|    248|    fn render_inline_span(
 2601|    248|        &self,
 2602|    248|        ui: &mut egui::Ui,
 2603|    248|        span: &InlineSpan,
 2604|    248|        font_size: Option<f32>,
 2605|    248|        strong: Option<bool>,
 2606|    248|    ) {
 2607|    248|        let size = font_size.unwrap_or(self.font_sizes.body);
 2608|    248|        let is_strong = strong.unwrap_or(false);
 2609|       |
 2610|    248|        match span {
 2611|    141|            InlineSpan::Text(text) => {
 2612|    141|                let fixed_text = self.fix_unicode_chars(text);
 2613|    141|                let style = InlineStyle {
 2614|    141|                    strong: is_strong,
 2615|    141|                    ..Default::default()
 2616|    141|                };
 2617|    141|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 2618|    141|            }
 2619|     22|            InlineSpan::Code(code) => {
 2620|       |                // Inline code: adapt style to theme (light vs dark)
 2621|     22|                ui.spacing_mut().item_spacing.x = 0.0;
 2622|     22|                let is_dark = ui.visuals().dark_mode;
 2623|     22|                let (bg, fg) = if is_dark {
 2624|     21|                    (
 2625|     21|                        Color32::from_rgb(30, 30, 30),
 2626|     21|                        Color32::from_rgb(180, 255, 180),
 2627|     21|                    )
 2628|       |                } else {
 2629|       |                    // Light theme: white background with readable code color
 2630|      1|                    (Color32::WHITE, Color32::from_rgb(60, 80, 150))
 2631|       |                };
 2632|     22|                let response = ui.add(
 2633|     22|                    egui::Label::new(
 2634|     22|                        RichText::new(code.clone())
 2635|     22|                            .size(self.font_sizes.code)
 2636|     22|                            .family(egui::FontFamily::Monospace)
 2637|     22|                            .background_color(bg)
 2638|     22|                            .color(fg),
 2639|       |                    )
 2640|     22|                    .wrap(true),
 2641|       |                );
 2642|       |
 2643|       |                // Add context menu for code
 2644|       |                #[cfg(test)]
 2645|     22|                {
 2646|     22|                    let _ = &response;
 2647|     22|                    self.render_inline_code_context_menu(ui, code);
 2648|     22|                }
 2649|       |                #[cfg(not(test))]
 2650|       |                response.context_menu(|ui| {
 2651|       |                    self.render_inline_code_context_menu(ui, code);
 2652|       |                });
 2653|       |            }
 2654|     51|            InlineSpan::Strong(text) => {
 2655|     51|                let fixed_text = self.fix_unicode_chars(text);
 2656|     51|                let style = InlineStyle {
 2657|     51|                    strong: true,
 2658|     51|                    ..Default::default()
 2659|     51|                };
 2660|     51|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 2661|     51|            }
 2662|      8|            InlineSpan::Emphasis(text) => {
 2663|      8|                let fixed_text = self.fix_unicode_chars(text);
 2664|      8|                let style = InlineStyle {
 2665|      8|                    italics: true,
 2666|      8|                    strong: is_strong,
 2667|      8|                    ..Default::default()
 2668|      8|                };
 2669|      8|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 2670|      8|            }
 2671|      2|            InlineSpan::Strikethrough(text) => {
 2672|      2|                let fixed_text = self.fix_unicode_chars(text);
 2673|      2|                let style = InlineStyle {
 2674|      2|                    strike: true,
 2675|      2|                    strong: is_strong,
 2676|      2|                    ..Default::default()
 2677|      2|                };
 2678|      2|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 2679|      2|            }
 2680|      6|            InlineSpan::Link { text, url } => {
 2681|      6|                let fixed_text = self.fix_unicode_chars(text);
 2682|      6|                let group = ui.horizontal_wrapped(|ui| {
 2683|       |                    // Render link-like styled text with emoji expansion
 2684|      6|                    let color = if Self::is_external_url(url) {
 2685|       |                        // Slightly different color to indicate external website links
 2686|      4|                        Color32::from_rgb(120, 190, 255)
 2687|       |                    } else {
 2688|      2|                        Color32::LIGHT_BLUE
 2689|       |                    };
 2690|      6|                    let style = InlineStyle {
 2691|      6|                        strong: is_strong,
 2692|      6|                        color: Some(color),
 2693|      6|                        ..Default::default()
 2694|      6|                    };
 2695|      6|                    self.render_text_with_emojis(ui, &fixed_text, size, style);
 2696|      6|                });
 2697|       |                // Use a unique id per link occurrence to avoid collisions when the same URL appears multiple times
 2698|      6|                let mut counter = self.link_counter.borrow_mut();
 2699|      6|                let id = egui::Id::new(format!("link:{}:{}", *counter, url));
 2700|      6|                *counter += 1;
 2701|      6|                let r = ui.interact(group.response.rect, id, egui::Sense::click());
 2702|      6|                if render_action_triggered(r.hovered(), "link_hover") {
 2703|      3|                    ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
 2704|      3|                }
 2705|      6|                if render_action_triggered(r.clicked(), "link_click") {
 2706|      3|                    self.trigger_link(url);
 2707|      3|                }
 2708|       |
 2709|       |                // Add context menu for links
 2710|       |                #[cfg(test)]
 2711|      6|                self.render_link_context_menu(ui, text, url);
 2712|       |                #[cfg(not(test))]
 2713|       |                r.context_menu(|ui| {
 2714|       |                    self.render_link_context_menu(ui, text, url);
 2715|       |                });
 2716|       |            }
 2717|     18|            InlineSpan::Image { src, alt, title } => {
 2718|       |                // Resolve path
 2719|     18|                let resolved = self.resolve_image_path(src);
 2720|     18|                let available_w = ui.available_width().max(1.0);
 2721|       |                // Try to get or load texture
 2722|     18|                if let Some((tex, w, h)) = self.get_or_load_image_texture(ui, &resolved) {
                                           ^7   ^7 ^7
 2723|      7|                    let (tw, th) = (w as f32, h as f32);
 2724|       |                    // Scale logic:
 2725|       |                    // - Start at UI scale (e.g., 1.0 for 100%, 1.1 for 110%).
 2726|       |                    // - Only downscale further if it would exceed available width.
 2727|      7|                    let base_scale = self.ui_scale();
 2728|      7|                    let scaled_w = tw * base_scale;
 2729|      7|                    let scale = if scaled_w > available_w {
 2730|      1|                        (available_w / tw).clamp(0.01, 4.0)
 2731|       |                    } else {
 2732|      6|                        base_scale
 2733|       |                    };
 2734|      7|                    let size = egui::vec2((tw * scale).round(), (th * scale).round());
 2735|      7|                    let image = egui::Image::new(&tex).fit_to_exact_size(size);
 2736|      7|                    let resp = ui.add(image);
 2737|      7|                    if let Some(t) = title {
                                              ^6
 2738|      6|                        if !t.is_empty() {
 2739|      5|                            if render_action_triggered(resp.hovered(), "image_hover") {
 2740|      2|                                resp.on_hover_text(t.clone());
 2741|      3|                            }
 2742|       |                            // Subtle caption below image
 2743|      5|                            ui.add_space(2.0);
 2744|      5|                            ui.label(
 2745|      5|                                RichText::new(t.clone())
 2746|      5|                                    .size(self.font_sizes.body - 2.0)
 2747|      5|                                    .color(Color32::from_rgb(140, 140, 140)),
 2748|       |                            );
 2749|      1|                        }
 2750|      1|                    }
 2751|      7|                    ui.add_space(6.0);
 2752|       |                } else {
 2753|       |                    // Placeholder with alt and error info
 2754|     11|                    egui::Frame::none()
 2755|     11|                        .fill(Color32::from_rgb(30, 30, 30))
 2756|     11|                        .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2757|     11|                        .inner_margin(8.0)
 2758|     11|                        .show(ui, |ui| {
 2759|     11|                            let pending = self.image_pending.borrow().contains(&resolved);
 2760|     11|                            let msg = if pending {
 2761|      5|                                "Loading image..."
 2762|      6|                            } else if src.starts_with("http://") || src.starts_with("https://") {
                                                                                  ^5
 2763|      3|                                "Remote images are disabled"
 2764|       |                            } else {
 2765|      3|                                "Image not found or unsupported"
 2766|       |                            };
 2767|     11|                            let label = if alt.is_empty() {
 2768|      1|                                src.as_str()
 2769|       |                            } else {
 2770|     10|                                alt.as_str()
 2771|       |                            };
 2772|     11|                            ui.label(
 2773|     11|                                RichText::new(format!("{}\n{}", label, msg))
 2774|     11|                                    .size(self.font_sizes.body),
 2775|       |                            );
 2776|     11|                        });
 2777|     11|                    ui.add_space(6.0);
 2778|       |                }
 2779|       |            }
 2780|       |        }
 2781|    248|    }
 2782|       |
 2783|     12|    fn extract_fragment(url: &str) -> Option<String> {
 2784|     12|        if let Some(stripped) = url.strip_prefix('#') {
                                  ^6
 2785|       |            // Already a fragment within current document
 2786|      6|            return Some(stripped.to_ascii_lowercase());
 2787|      6|        }
 2788|      6|        None
 2789|     12|    }
 2790|       |
 2791|     29|    fn is_external_url(url: &str) -> bool {
 2792|     29|        let lower = url.to_ascii_lowercase();
 2793|     29|        lower.starts_with("http://")
 2794|     28|            || lower.starts_with("https://")
 2795|     12|            || lower.starts_with("mailto:")
 2796|     11|            || lower.starts_with("www.")
 2797|     29|    }
 2798|       |
 2799|    209|    fn render_text_with_emojis(
 2800|    209|        &self,
 2801|    209|        ui: &mut egui::Ui,
 2802|    209|        text: &str,
 2803|    209|        size: f32,
 2804|    209|        style: InlineStyle,
 2805|    209|    ) {
 2806|    209|        let mut buffer = String::new();
 2807|  4.27k|        for g in text.graphemes(true) {
                               ^209 ^209
 2808|  4.27k|            if let Some(key) = self.emoji_key_for_grapheme(g) {
                                      ^8
 2809|       |                // Flush buffered text first (with highlighting if active)
 2810|      8|                if !buffer.is_empty() {
 2811|      7|                    self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
 2812|      7|                    buffer.clear();
 2813|      7|                }
                              ^1
 2814|      8|                let handle = self.get_or_make_emoji_texture(ui, &key);
 2815|      8|                let sz = size * 1.2;
 2816|      8|                ui.add(egui::Image::new(&handle).max_width(sz).max_height(sz));
 2817|  4.27k|            } else {
 2818|  4.27k|                buffer.push_str(g);
 2819|  4.27k|            }
 2820|       |        }
 2821|    209|        if !buffer.is_empty() {
 2822|    208|            self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
 2823|    208|        }
                      ^1
 2824|    209|    }
 2825|       |
 2826|    215|    fn render_text_segment_with_optional_highlight(
 2827|    215|        &self,
 2828|    215|        ui: &mut egui::Ui,
 2829|    215|        segment: &str,
 2830|    215|        size: f32,
 2831|    215|        style: InlineStyle,
 2832|    215|    ) {
 2833|       |        // First expand emoji shortcodes, then superscript ^...^ notation
 2834|    215|        let expanded = Self::expand_shortcodes(segment);
 2835|    215|        let expanded = Self::expand_superscripts(&expanded);
 2836|    215|        if let Some(h) = self
                                  ^22
 2837|    215|            .highlight_phrase
 2838|    215|            .borrow()
 2839|    215|            .as_ref()
 2840|    215|            .filter(|s| !s.is_empty())
                                       ^22^22
 2841|       |        {
 2842|     27|            for (range, highlighted) in self.highlight_segments(&expanded, Some(h)) {
                                                      ^22  ^22                ^22        ^22
 2843|     27|                let slice = &expanded[range];
 2844|     27|                if highlighted {
 2845|     10|                    self.render_highlighted_segment(ui, slice, size, style);
 2846|     17|                } else {
 2847|     17|                    self.render_plain_segment(ui, slice, size, style);
 2848|     17|                }
 2849|       |            }
 2850|     22|            return;
 2851|    193|        }
 2852|    193|        self.render_plain_segment(ui, &expanded, size, style);
 2853|    215|    }
 2854|       |
 2855|    213|    fn render_plain_segment(&self, ui: &mut egui::Ui, text: &str, size: f32, style: InlineStyle) {
 2856|    213|        if text.is_empty() {
 2857|      1|            return;
 2858|    212|        }
 2859|    212|        let mut rich = RichText::new(text).size(size);
 2860|    212|        if style.strong {
 2861|     81|            rich = rich.strong();
 2862|    131|        }
 2863|    212|        if style.italics {
 2864|     13|            rich = rich.italics();
 2865|    199|        }
 2866|    212|        if style.strike {
 2867|      1|            rich = rich.strikethrough();
 2868|    211|        }
 2869|    212|        let mut text_color = style.color;
 2870|    212|        if text_color.is_none() && style.strong {
                                                 ^206
 2871|     81|            if let Some(override_color) = ui.visuals().override_text_color {
                                      ^1
 2872|      1|                text_color = Some(override_color);
 2873|     80|            }
 2874|    131|        }
 2875|    212|        if let Some(color) = text_color {
                                  ^7
 2876|      7|            rich = rich.color(color);
 2877|    205|        }
 2878|    212|        let response = ui.add(egui::Label::new(rich).wrap(true));
 2879|       |
 2880|       |        // Add context menu for text
 2881|       |        // Note: Due to egui limitations, selection is cleared on right-click
 2882|       |        // As a workaround, we provide "Copy Text" for the segment
 2883|       |        #[cfg(test)]
 2884|    212|        {
 2885|    212|            let _ = &response;
 2886|    212|            self.render_text_context_menu(ui, text);
 2887|    212|        }
 2888|       |        #[cfg(not(test))]
 2889|       |        response.context_menu(|ui| {
 2890|       |            self.render_text_context_menu(ui, text);
 2891|       |        });
 2892|    213|    }
 2893|       |
 2894|     11|    fn render_highlighted_segment(
 2895|     11|        &self,
 2896|     11|        ui: &mut egui::Ui,
 2897|     11|        text: &str,
 2898|     11|        size: f32,
 2899|     11|        style: InlineStyle,
 2900|     11|    ) {
 2901|     11|        if text.is_empty() {
 2902|      1|            return;
 2903|     10|        }
 2904|     10|        let visuals = ui.visuals();
 2905|     10|        let bg = visuals.selection.bg_fill;
 2906|     10|        let fallback_color = visuals.selection.stroke.color;
 2907|     10|        let text_color = style.color.unwrap_or(fallback_color);
 2908|       |
 2909|     10|        let mut rich = RichText::new(text)
 2910|     10|            .size(size)
 2911|     10|            .background_color(bg)
 2912|     10|            .color(text_color);
 2913|     10|        if style.strong {
 2914|      3|            rich = rich.strong();
 2915|      7|        }
 2916|     10|        if style.italics {
 2917|      1|            rich = rich.italics();
 2918|      9|        }
 2919|     10|        if style.strike {
 2920|      1|            rich = rich.strikethrough();
 2921|      9|        }
 2922|     10|        let response = ui.add(egui::Label::new(rich).wrap(true));
 2923|       |
 2924|       |        // Add context menu for highlighted text
 2925|       |        #[cfg(test)]
 2926|     10|        {
 2927|     10|            let _ = &response;
 2928|     10|            self.render_text_context_menu(ui, text);
 2929|     10|        }
 2930|       |        #[cfg(not(test))]
 2931|       |        response.context_menu(|ui| {
 2932|       |            self.render_text_context_menu(ui, text);
 2933|       |        });
 2934|     11|    }
 2935|       |
 2936|    224|    fn render_text_context_menu(&self, ui: &mut egui::Ui, text: &str) {
 2937|    224|        if render_action_triggered(ui.button("Copy Text").clicked(), "copy_text") {
 2938|      1|            self.copy_text_and_close(ui, text);
 2939|    223|        }
 2940|    224|        ui.label("Tip: Use Ctrl+C to copy selected text");
 2941|    224|    }
 2942|       |
 2943|     24|    fn render_inline_code_context_menu(&self, ui: &mut egui::Ui, code: &str) {
 2944|     24|        if render_action_triggered(ui.button("Copy Code").clicked(), "copy_inline_code") {
 2945|      1|            self.copy_text_and_close(ui, code);
 2946|     23|        }
 2947|     24|    }
 2948|       |
 2949|     14|    fn render_code_block_context_menu(
 2950|     14|        &self,
 2951|     14|        ui: &mut egui::Ui,
 2952|     14|        code: &str,
 2953|     14|        language: Option<&str>,
 2954|     14|    ) {
 2955|     14|        if render_action_triggered(ui.button("Copy Code").clicked(), "copy_code_block") {
 2956|      1|            self.copy_text_and_close(ui, code);
 2957|     13|        }
 2958|     14|        if let Some(lang) = language {
                                  ^10
 2959|     10|            if render_action_triggered(
 2960|     10|                ui.button(format!("Copy as {}", lang)).clicked(),
 2961|       |                "copy_code_block_lang",
 2962|      2|            ) {
 2963|      2|                self.copy_text_and_close(ui, &format!("```{}\n{}\n```", lang, code));
 2964|      8|            }
 2965|      4|        }
 2966|     14|    }
 2967|       |
 2968|      8|    fn render_link_context_menu(&self, ui: &mut egui::Ui, text: &str, url: &str) {
 2969|      8|        if render_action_triggered(ui.button("Open Link").clicked(), "open_link") {
 2970|      1|            self.trigger_link(url);
 2971|      1|            ui.close_menu();
 2972|      7|        }
 2973|      8|        ui.separator();
 2974|      8|        if render_action_triggered(ui.button("Copy Link Text").clicked(), "copy_link_text") {
 2975|      1|            self.copy_text_and_close(ui, text);
 2976|      7|        }
 2977|      8|        if render_action_triggered(ui.button("Copy Link URL").clicked(), "copy_link_url") {
 2978|      1|            self.copy_text_and_close(ui, url);
 2979|      7|        }
 2980|      8|    }
 2981|       |
 2982|    135|    fn render_cell_context_menu(&self, ui: &mut egui::Ui, text: &str) {
 2983|    135|        if render_action_triggered(ui.button("Copy Cell Text").clicked(), "copy_cell_text") {
 2984|      1|            self.copy_text_and_close(ui, text);
 2985|    134|        }
 2986|    135|    }
 2987|       |
 2988|      9|    fn copy_text_and_close(&self, ui: &mut egui::Ui, text: &str) {
 2989|      9|        ui.ctx().copy_text(text.to_string());
 2990|      9|        ui.close_menu();
 2991|      9|    }
 2992|       |
 2993|       |    /// Map a grapheme cluster to an emoji image key if available.
 2994|  4.31k|    fn emoji_key_for_grapheme(&self, g: &str) -> Option<String> {
 2995|  4.31k|        if crate::emoji_catalog::image_bytes_for(g).is_some() {
 2996|      7|            return Some(g.to_string());
 2997|  4.30k|        }
 2998|  4.31k|        let stripped: String = g.chars().filter(|&c| c != '\u{FE0F}').collect();
                          ^4.30k    ^4.30k   ^4.30k^4.30k  ^4.30k                       ^4.30k
 2999|  4.30k|        if stripped != g && crate::emoji_catalog::image_bytes_for(&stripped).is_some() {
                                          ^7                                               ^7
 3000|      1|            return Some(stripped);
 3001|  4.30k|        }
 3002|       |        // If the grapheme explicitly requests emoji presentation (contains VS16),
 3003|       |        // treat it as an emoji even if we don't have a sprite; fall back to a
 3004|       |        // generated placeholder via emoji_assets to avoid stray tofu.
 3005|  4.31k|        if g.chars().any(|c| c == '\u{FE0F}') {
                         ^4.30k    ^4.30k
 3006|      6|            return Some(stripped); // prefer stripped as the texture key
 3007|  4.30k|        }
 3008|  4.30k|        None
 3009|  4.31k|    }
 3010|       |
 3011|     16|    fn get_or_make_emoji_texture(&self, ui: &mut egui::Ui, emoji: &str) -> egui::TextureHandle {
 3012|     16|        if let Some(tex) = self.emoji_textures.borrow().get(emoji) {
                                  ^1
 3013|      1|            return tex.clone();
 3014|     15|        }
 3015|       |
 3016|     15|        let img = if let Some(bytes) = emoji_catalog::image_bytes_for(emoji) {
                                            ^7
 3017|      7|            let bytes = {
 3018|       |                #[cfg(test)]
 3019|       |                {
 3020|      7|                    if FORCE_EMOJI_DECODE_ERROR.swap(false, Ordering::Relaxed) {
 3021|      2|                        b"mdmdview"
 3022|       |                    } else {
 3023|      5|                        bytes
 3024|       |                    }
 3025|       |                }
 3026|       |                #[cfg(not(test))]
 3027|       |                {
 3028|       |                    bytes
 3029|       |                }
 3030|       |            };
 3031|      7|            match image::load_from_memory(bytes) {
 3032|      5|                Ok(dyn_img) => {
 3033|      5|                    let rgba = dyn_img.to_rgba8();
 3034|      5|                    let (w, h) = rgba.dimensions();
 3035|      5|                    let pixels = rgba.into_vec();
 3036|      5|                    egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &pixels)
 3037|       |                }
 3038|      2|                Err(_) => match emoji_assets::make_image(emoji, 64) {
 3039|      1|                    Some(img) => img,
 3040|      1|                    None => self.generate_emoji_image(emoji, 64),
 3041|       |                },
 3042|       |            }
 3043|       |        } else {
 3044|      8|            match emoji_assets::make_image(emoji, 64) {
 3045|      6|                Some(img) => img,
 3046|      2|                None => self.generate_emoji_image(emoji, 64),
 3047|       |            }
 3048|       |        };
 3049|     15|        let handle = ui.ctx().load_texture(
 3050|     15|            format!("emoji:{}", emoji),
 3051|     15|            img,
 3052|       |            egui::TextureOptions::LINEAR,
 3053|       |        );
 3054|     15|        self.emoji_textures
 3055|     15|            .borrow_mut()
 3056|     15|            .insert(emoji.to_string(), handle.clone());
 3057|     15|        handle
 3058|     16|    }
 3059|       |
 3060|       |    #[cfg(test)]
 3061|       |    // Rough width measurement for inline spans without wrapping
 3062|      8|    fn measure_inline_spans(&self, ui: &egui::Ui, spans: &[InlineSpan]) -> f32 {
 3063|      8|        let mut max_line_width = 0.0f32;
 3064|      8|        let mut current_line_width = 0.0f32;
 3065|      8|        ui.fonts(|fonts| {
 3066|      8|            let body = egui::FontId::proportional(self.font_sizes.body);
 3067|      8|            let mono = egui::FontId::monospace(self.font_sizes.code);
 3068|     23|            for span in spans {
                              ^15
 3069|     15|                match span {
 3070|      7|                    InlineSpan::Text(t)
 3071|      1|                    | InlineSpan::Strong(t)
 3072|      1|                    | InlineSpan::Emphasis(t)
 3073|      1|                    | InlineSpan::Strikethrough(t)
 3074|      1|                    | InlineSpan::Link { text: t, .. } => {
 3075|       |                        // Normalize to match render path before measuring.
 3076|     11|                        let mut normalized = self.fix_unicode_chars(t);
 3077|     11|                        normalized = Self::expand_shortcodes(&normalized);
 3078|     11|                        normalized = Self::expand_superscripts(&normalized);
 3079|     16|                        for (line_idx, line) in normalized.split('\n').enumerate() {
                                                              ^11                    ^11
 3080|     16|                            if line_idx > 0 {
 3081|      5|                                max_line_width = max_line_width.max(current_line_width);
 3082|      5|                                current_line_width = 0.0;
 3083|     11|                            }
 3084|     16|                            if line.is_empty() {
 3085|      3|                                continue;
 3086|     13|                            }
 3087|     13|                            let galley = fonts.layout_no_wrap(
 3088|     13|                                line.to_string(),
 3089|     13|                                body.clone(),
 3090|       |                                Color32::WHITE,
 3091|       |                            );
 3092|     13|                            let mut line_width = galley.size().x;
 3093|       |                            // Add a small extra width for emoji images (drawn larger than text).
 3094|     13|                            let emoji_extra =
 3095|    102|                                line.chars().filter(|c| Self::is_known_emoji(*c)).count() as f32
                                              ^13  ^13     ^13                                  ^13
 3096|     13|                                    * (self.font_sizes.body * 0.2);
 3097|     13|                            line_width += emoji_extra;
 3098|     13|                            if current_line_width > 0.0 {
 3099|      3|                                current_line_width += 4.0;
 3100|     10|                            }
 3101|     13|                            current_line_width += line_width;
 3102|       |                        }
 3103|       |                    }
 3104|      2|                    InlineSpan::Code(code) => {
 3105|      5|                        for (line_idx, line) in code.split('\n').enumerate() {
                                                              ^2               ^2
 3106|      5|                            if line_idx > 0 {
 3107|      3|                                max_line_width = max_line_width.max(current_line_width);
 3108|      3|                                current_line_width = 0.0;
 3109|      3|                            }
                                          ^2
 3110|      5|                            if line.is_empty() {
 3111|      1|                                continue;
 3112|      4|                            }
 3113|      4|                            let galley = fonts.layout_no_wrap(
 3114|      4|                                line.to_string(),
 3115|      4|                                mono.clone(),
 3116|       |                                Color32::WHITE,
 3117|       |                            );
 3118|      4|                            let line_width = galley.size().x + 6.0; // padding for code background
 3119|      4|                            if current_line_width > 0.0 {
 3120|      1|                                current_line_width += 4.0;
 3121|      3|                            }
 3122|      4|                            current_line_width += line_width;
 3123|       |                        }
 3124|       |                    }
 3125|      2|                    InlineSpan::Image { src, .. } => {
 3126|       |                        // Use cached texture size if available; otherwise a conservative thumbnail.
 3127|      2|                        let cap = (ui.available_width() * 0.6).max(48.0);
 3128|      2|                        let cached = self
 3129|      2|                            .image_textures
 3130|      2|                            .borrow_mut()
 3131|      2|                            .get(src)
 3132|      2|                            .map(|entry| entry.size[0] as f32 * self.ui_scale());
                                                       ^1                     ^1   ^1
 3133|      2|                        let approx = cached.unwrap_or(self.font_sizes.body * 12.0);
 3134|      2|                        let line_width = approx.min(cap);
 3135|      2|                        if current_line_width > 0.0 {
 3136|      1|                            current_line_width += 4.0;
 3137|      1|                        }
 3138|      2|                        current_line_width += line_width;
 3139|       |                    }
 3140|       |                }
 3141|       |            }
 3142|      8|        });
 3143|      8|        max_line_width.max(current_line_width)
 3144|      8|    }
 3145|       |
 3146|       |    #[cfg(test)]
 3147|    102|    fn is_known_emoji(c: char) -> bool {
 3148|    101|        matches!(
 3149|    102|            c,
 3150|       |            '\u{1f389}' // 
 3151|       |                | '\u{2705}' // 
 3152|       |                | '\u{1f680}' // 
 3153|       |                | '\u{1f642}' // 
 3154|       |                | '\u{1f600}' // 
 3155|       |                | '\u{1f609}' // 
 3156|       |                | '\u{2b50}'  // 
 3157|       |                | '\u{1f525}' // 
 3158|       |                | '\u{1f44d}' // 
 3159|       |                | '\u{1f44e}' // 
 3160|       |                | '\u{1f4a1}' // 
 3161|       |                | '\u{2753}'  // 
 3162|       |                | '\u{2757}'  // 
 3163|       |                | '\u{1f4dd}' // 
 3164|       |                | '\u{1f9e0}' // 
 3165|       |                | '\u{1f9ea}' // 
 3166|       |                | '\u{1f4e6}' // 
 3167|       |                | '\u{1f527}' // 
 3168|       |        )
 3169|    102|    }
 3170|       |
 3171|    471|    fn expand_shortcodes(s: &str) -> String {
 3172|       |        use crate::emoji_catalog::shortcode_map;
 3173|    471|        if !s.contains(':') {
 3174|    448|            return s.to_string();
 3175|     23|        }
 3176|     23|        let mut out = String::new();
 3177|     23|        let map = shortcode_map();
 3178|     23|        let mut i = 0;
 3179|     23|        let bytes = s.as_bytes();
 3180|    370|        while i < s.len() {
 3181|    347|            if bytes[i] == b':' {
 3182|    305|                if let Some(end_rel) = bytes[i + 1..].iter().position(|&b| b == b':') {
                                          ^5         ^24                   ^24
 3183|      5|                    let end = i + 1 + end_rel;
 3184|      5|                    let code = &s[i..=end];
 3185|      5|                    if let Some(&emoji) = map.get(code) {
                                               ^4
 3186|      4|                        out.push_str(emoji);
 3187|      4|                        i = end + 1;
 3188|      4|                        continue;
 3189|      1|                    }
 3190|     19|                }
 3191|    323|            }
 3192|       |            // advance by one UTF-8 character
 3193|    343|            let ch = s[i..].chars().next().unwrap();
 3194|    343|            out.push(ch);
 3195|    343|            i += ch.len_utf8();
 3196|       |        }
 3197|     23|        out
 3198|    471|    }
 3199|       |
 3200|       |    // Expand ^...^ segments into Unicode superscript characters when available.
 3201|       |    // Example: "5^th^" -> "5??"
 3202|    475|    fn expand_superscripts(s: &str) -> String {
 3203|    475|        if !s.contains('^') {
 3204|    467|            return s.to_string();
 3205|      8|        }
 3206|      8|        let mut out = String::new();
 3207|      8|        let mut chars = s.chars().peekable();
 3208|    203|        while let Some(c) = chars.next() {
                                     ^195
 3209|    195|            if c == '^' {
 3210|       |                // Look ahead to see if there's a matching closing caret within reasonable bounds
 3211|     14|                let mut buf = String::new();
 3212|     14|                let mut found_closing = false;
 3213|     14|                let mut temp_chars = chars.clone();
 3214|     14|                let mut char_count = 0;
 3215|       |
 3216|     41|                while let Some(&nc) = temp_chars.peek() {
                                              ^38
 3217|     38|                    if nc == '^' {
 3218|      5|                        found_closing = true;
 3219|      5|                        break;
 3220|     33|                    }
 3221|     33|                    if !nc.is_alphanumeric() && !matches!(nc, '+' | '-' | '=' | '(' | ')') {
                                                               ^5       ^6
 3222|      5|                        break;
 3223|     28|                    }
 3224|     28|                    if char_count >= 10 {
 3225|      1|                        break;
 3226|     27|                    }
 3227|     27|                    temp_chars.next();
 3228|     27|                    char_count += 1;
 3229|       |                }
 3230|       |
 3231|     14|                if found_closing && char_count > 0 {
                                                  ^5
 3232|      6|                    for nc in chars.by_ref().take(char_count) {
                                            ^4             ^4   ^4
 3233|      6|                        buf.push(nc);
 3234|      6|                    }
 3235|       |                    // Skip the closing caret
 3236|      4|                    chars.next();
 3237|      4|                    out.push_str(&Self::to_superscript(&buf));
 3238|     10|                } else {
 3239|     10|                    out.push('^');
 3240|     10|                }
 3241|    181|            } else {
 3242|    181|                out.push(c);
 3243|    181|            }
 3244|       |        }
 3245|      8|        out
 3246|    475|    }
 3247|       |
 3248|      6|    fn to_superscript(s: &str) -> String {
 3249|      6|        s.chars()
 3250|     81|            .map(|c| match c {
                           ^6
 3251|      1|                '0' => '\u{2070}',
 3252|      2|                '1' => '\u{00b9}',
 3253|      3|                '2' => '\u{00b2}',
 3254|      2|                '3' => '\u{00b3}',
 3255|      1|                '4' => '\u{2074}',
 3256|      1|                '5' => '\u{2075}',
 3257|      1|                '6' => '\u{2076}',
 3258|      1|                '7' => '\u{2077}',
 3259|      1|                '8' => '\u{2078}',
 3260|      1|                '9' => '\u{2079}',
 3261|      2|                '+' => '\u{207a}',
 3262|      1|                '-' => '\u{207b}',
 3263|      1|                '=' => '\u{207c}',
 3264|      1|                '(' => '\u{207d}',
 3265|      1|                ')' => '\u{207e}',
 3266|      3|                'a' | 'A' => '\u{1d43}',
 3267|      3|                'b' | 'B' => '\u{1d47}',
 3268|      3|                'c' | 'C' => '\u{1d9c}',
 3269|      2|                'd' | 'D' => '\u{1d48}',
 3270|      2|                'e' | 'E' => '\u{1d49}',
 3271|      2|                'f' | 'F' => '\u{1da0}',
 3272|      2|                'g' | 'G' => '\u{1d4d}',
 3273|      4|                'h' | 'H' => '\u{02b0}',
 3274|      2|                'i' | 'I' => '\u{2071}',
 3275|      2|                'j' | 'J' => '\u{02b2}',
 3276|      2|                'k' | 'K' => '\u{1d4f}',
 3277|      2|                'l' | 'L' => '\u{02e1}',
 3278|      2|                'm' | 'M' => '\u{1d50}',
 3279|      2|                'n' | 'N' => '\u{207f}',
 3280|      2|                'o' | 'O' => '\u{1d52}',
 3281|      2|                'p' | 'P' => '\u{1d56}',
 3282|      2|                'q' | 'Q' => '\u{1d56}',
 3283|      2|                'r' | 'R' => '\u{02b3}',
 3284|      2|                's' | 'S' => '\u{02e2}',
 3285|      4|                't' | 'T' => '\u{1d57}',
 3286|      2|                'u' | 'U' => '\u{1d58}',
 3287|      2|                'v' | 'V' => '\u{1d5b}',
 3288|      2|                'w' | 'W' => '\u{02b7}',
 3289|      2|                'x' | 'X' => '\u{02e3}',
 3290|      2|                'y' | 'Y' => '\u{02b8}',
 3291|      2|                'z' | 'Z' => '\u{1dbb}',
 3292|      2|                other => other,
 3293|     81|            })
 3294|      6|            .collect()
 3295|      6|    }
 3296|       |
 3297|     23|    fn generate_emoji_image(&self, emoji: &str, size: usize) -> egui::ColorImage {
 3298|       |        // Simple procedural placeholder icons to keep binary small and avoid external assets
 3299|       |        use egui::Color32 as C;
 3300|     23|        let mut img = egui::ColorImage::new([size, size], C::TRANSPARENT);
 3301|     23|        let cx = (size as i32) / 2;
 3302|     23|        let cy = cx;
 3303|     23|        let r = (size as i32) / 2 - 2;
 3304|       |
 3305|     23|        let (base, accent) = match emoji {
 3306|     23|            "\u{1f389}" => (C::from_rgb(255, 215, 0), C::from_rgb(255, 80, 80)),
                                         ^1
 3307|     22|            "\u{2705}" => (C::from_rgb(30, 150, 30), C::WHITE),
                                        ^1
 3308|     21|            "\u{1f680}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 100, 100)),
                                         ^1
 3309|     20|            "\u{1f642}" | "\u{1f600}" | "\u{1f609}" => {
                                        ^18           ^17
 3310|      4|                (C::from_rgb(255, 205, 64), C::from_rgb(90, 60, 10))
 3311|       |            }
 3312|     16|            "\u{2b50}" => (C::from_rgb(255, 215, 0), C::WHITE),
                                        ^1
 3313|     15|            "\u{1f525}" => (C::from_rgb(255, 120, 50), C::from_rgb(255, 200, 120)),
                                         ^1
 3314|     14|            "\u{1f44d}" | "\u{1f44e}" => (C::from_rgb(200, 200, 200), C::from_rgb(80, 80, 80)),
                                        ^13            ^2
 3315|     12|            "\u{1f4a1}" => (C::from_rgb(255, 240, 120), C::from_rgb(255, 255, 255)),
                                         ^1
 3316|     11|            "\u{2753}" | "\u{2757}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 255, 255)),
                                       ^10           ^2
 3317|      9|            "\u{1f4dd}" => (C::from_rgb(240, 240, 200), C::from_rgb(140, 140, 140)),
                                         ^1
 3318|      8|            "\u{1f9e0}" => (C::from_rgb(220, 160, 200), C::from_rgb(255, 255, 255)),
                                         ^1
 3319|      7|            "\u{1f9ea}" => (C::from_rgb(180, 220, 255), C::from_rgb(120, 160, 240)),
                                         ^1
 3320|      6|            "\u{1f4e6}" => (C::from_rgb(205, 170, 125), C::from_rgb(150, 110, 70)),
                                         ^1
 3321|      5|            "\u{1f527}" => (C::from_rgb(160, 170, 180), C::from_rgb(220, 220, 220)),
                                         ^1
 3322|      4|            _ => (C::from_rgb(180, 180, 180), C::WHITE),
 3323|       |        };
 3324|       |
 3325|       |        // draw filled circle
 3326|    360|        for y in 0..size as i32 {
                                  ^23
 3327|  13.7k|            for x in 0..size as i32 {
                                      ^360
 3328|  13.7k|                let dx = x - cx;
 3329|  13.7k|                let dy = y - cy;
 3330|  13.7k|                if dx * dx + dy * dy <= r * r {
 3331|  8.82k|                    img[(x as usize, y as usize)] = base;
 3332|  8.82k|                }
                              ^4.93k
 3333|       |            }
 3334|       |        }
 3335|       |
 3336|       |        // add a simple accent (diagonal highlight)
 3337|    360|        for t in 0..size {
                                  ^23
 3338|    360|            let x = t as i32;
 3339|    360|            let y = (t as i32) / 2;
 3340|    360|            let xx = (x / 2 + 6).clamp(0, size as i32 - 1) as usize;
 3341|    360|            let yy = (y + 6).clamp(0, size as i32 - 1) as usize;
 3342|    360|            img[(xx, yy)] = accent;
 3343|    360|        }
 3344|       |
 3345|     23|        img
 3346|     23|    }
 3347|       |
 3348|     57|    fn render_list_paragraph(
 3349|     57|        &self,
 3350|     57|        ui: &mut egui::Ui,
 3351|     57|        marker: Option<&str>,
 3352|     57|        marker_color: Color32,
 3353|     57|        indent_px: f32,
 3354|     57|        spans: &[InlineSpan],
 3355|     57|    ) {
 3356|       |        // Split into lines on embedded '\n'
 3357|     57|        let mut lines: Vec<Vec<InlineSpan>> = vec![Vec::new()];
 3358|    142|        for s in spans.iter().cloned() {
                               ^57   ^57    ^57
 3359|     75|            match s {
 3360|     75|                InlineSpan::Text(t) if t.contains('\n') => {
                                               ^3                   ^3
 3361|      3|                    let parts: Vec<&str> = t.split('\n').collect();
 3362|      7|                    for (pi, part) in parts.iter().enumerate() {
                                                    ^3           ^3
 3363|      7|                        if !part.is_empty() {
 3364|      6|                            lines
 3365|      6|                                .last_mut()
 3366|      6|                                .unwrap()
 3367|      6|                                .push(InlineSpan::Text(part.to_string()));
 3368|      6|                        }
                                      ^1
 3369|      7|                        if pi < parts.len() - 1 {
 3370|      4|                            lines.push(Vec::new());
 3371|      4|                        }
                                      ^3
 3372|       |                    }
 3373|       |                }
 3374|    139|                other => lines.last_mut().unwrap().push(other),
 3375|       |            }
 3376|       |        }
 3377|       |
 3378|     61|        for (li, mut line) in lines.into_iter().enumerate() {
                                            ^57   ^57         ^57
 3379|     61|            ui.horizontal_wrapped(|ui| {
 3380|     61|                if li == 0 {
 3381|     57|                    if let Some(marker) = marker {
                                              ^53
 3382|     53|                        ui.label(
 3383|     53|                            RichText::new(format!("{} ", marker))
 3384|     53|                                .size(self.font_sizes.body)
 3385|     53|                                .color(marker_color),
 3386|     53|                        );
 3387|     53|                    } else {
 3388|      4|                        ui.add_space(indent_px);
 3389|      4|                    }
 3390|       |                } else {
 3391|       |                    // Determine additional indentation from leading spaces in this line
 3392|      4|                    let mut leading_spaces = 0usize;
 3393|      4|                    if let Some(InlineSpan::Text(t0)) = line.first_mut() {
                                                               ^3
 3394|      7|                        leading_spaces = t0.chars().take_while(|c| *c == ' ').count();
                                                       ^3         ^3                        ^3
 3395|      3|                        if leading_spaces > 0 {
 3396|      2|                            let trimmed = t0.trim_start_matches(' ').to_string();
 3397|      2|                            *t0 = trimmed;
 3398|      2|                        }
                                      ^1
 3399|      1|                    }
 3400|      4|                    let indent = indent_px + (leading_spaces as f32) * 6.0;
 3401|      4|                    ui.add_space(indent);
 3402|       |                }
 3403|     61|                ui.spacing_mut().item_spacing.x = 0.0;
 3404|    206|                for span in &line {
                                  ^145
 3405|    145|                    self.render_inline_span(ui, span, None, None);
 3406|    145|                }
 3407|     61|            });
 3408|       |        }
 3409|     57|    }
 3410|       |
 3411|       |    /// Render a list with proper inline formatting, including nested block content
 3412|     18|    fn render_list(&self, ui: &mut egui::Ui, ordered: bool, items: &[ListItem]) {
 3413|     18|        if items.is_empty() {
 3414|      2|            return;
 3415|     16|        }
 3416|       |
 3417|     16|        ui.add_space(4.0);
 3418|     16|        let marker_color = ui.visuals().text_color();
 3419|     16|        let indent_px = 18.0;
 3420|       |
 3421|     57|        for (index, item) in items.iter().enumerate() {
                                           ^16   ^16    ^16
 3422|     57|            let marker = if ordered {
 3423|     22|                format!("{}.", index + 1)
 3424|       |            } else {
 3425|     35|                "-".to_string()
 3426|       |            };
 3427|       |
 3428|     57|            let mut blocks = item.blocks.iter();
 3429|     57|            if let Some(first_block) = blocks.next() {
                                      ^55
 3430|     55|                match first_block {
 3431|     53|                    MarkdownElement::Paragraph(spans) => {
 3432|     53|                        self.render_list_paragraph(
 3433|     53|                            ui,
 3434|     53|                            Some(&marker),
 3435|     53|                            marker_color,
 3436|     53|                            indent_px,
 3437|     53|                            spans,
 3438|     53|                        );
 3439|     53|                    }
 3440|       |                    _ => {
 3441|      2|                        ui.horizontal_wrapped(|ui| {
 3442|      2|                            ui.label(
 3443|      2|                                RichText::new(format!("{} ", marker))
 3444|      2|                                    .size(self.font_sizes.body)
 3445|      2|                                    .color(marker_color),
 3446|       |                            );
 3447|      2|                        });
 3448|      2|                        self.render_list_block(ui, first_block, indent_px, marker_color);
 3449|       |                    }
 3450|       |                }
 3451|       |            } else {
 3452|      2|                ui.horizontal_wrapped(|ui| {
 3453|      2|                    ui.label(
 3454|      2|                        RichText::new(format!("{} ", marker))
 3455|      2|                            .size(self.font_sizes.body)
 3456|      2|                            .color(marker_color),
 3457|       |                    );
 3458|      2|                });
 3459|       |            }
 3460|       |
 3461|     61|            for block in blocks {
                              ^4
 3462|      4|                self.render_list_block(ui, block, indent_px, marker_color);
 3463|      4|            }
 3464|       |        }
 3465|       |
 3466|     16|        ui.add_space(4.0);
 3467|     18|    }
 3468|       |
 3469|      7|    fn render_list_block(
 3470|      7|        &self,
 3471|      7|        ui: &mut egui::Ui,
 3472|      7|        block: &MarkdownElement,
 3473|      7|        indent_px: f32,
 3474|      7|        marker_color: Color32,
 3475|      7|    ) {
 3476|      7|        match block {
 3477|      2|            MarkdownElement::Paragraph(spans) => {
 3478|      2|                self.render_list_paragraph(ui, None, marker_color, indent_px, spans);
 3479|      2|            }
 3480|       |            _ => {
 3481|      5|                ui.horizontal(|ui| {
 3482|      5|                    ui.add_space(indent_px);
 3483|      5|                    ui.vertical(|ui| {
 3484|      5|                        self.render_element_body(ui, block);
 3485|      5|                    });
 3486|      5|                });
 3487|       |            }
 3488|       |        }
 3489|      7|    }
 3490|       |
 3491|       |    /// Render a code block with syntax highlighting
 3492|     11|    fn render_code_block(&self, ui: &mut egui::Ui, language: Option<&str>, code: &str) {
 3493|     11|        ui.add_space(8.0);
 3494|       |
 3495|       |        // Special handling for Mermaid diagrams
 3496|     11|        if let Some(lang) = language {
                                  ^8
 3497|      8|            if lang.eq_ignore_ascii_case("mermaid") {
 3498|      1|                let _ = self.render_mermaid_block(ui, code);
 3499|      1|                ui.add_space(8.0);
 3500|      1|                return;
 3501|      7|            }
 3502|      3|        }
 3503|       |
 3504|     10|        let frame_response = egui::Frame::none()
 3505|     10|            .fill(Color32::from_rgb(25, 25, 25))
 3506|     10|            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 3507|     10|            .inner_margin(8.0)
 3508|     10|            .show(ui, |ui| {
 3509|     10|                ui.with_layout(egui::Layout::top_down(egui::Align::LEFT), |ui| {
 3510|     10|                    if let Some(lang) = language {
                                              ^7
 3511|      7|                        ui.label(
 3512|      7|                            RichText::new(lang)
 3513|      7|                                .size(self.font_sizes.code - 1.0)
 3514|      7|                                .color(Color32::from_rgb(150, 150, 150))
 3515|      7|                                .family(egui::FontFamily::Monospace),
 3516|      7|                        );
 3517|      7|                        ui.add_space(2.0);
 3518|      7|                    }
                                  ^3
 3519|       |
 3520|       |                    // Try syntax highlighting
 3521|     10|                    if let Some(lang) = language {
                                              ^7
 3522|      7|                        if let Some(syntax) = self
                                                  ^6
 3523|      7|                            .find_syntax_for_language(lang)
 3524|      7|                            .or_else(|| self.syntax_set.find_syntax_by_first_line(code))
                                                      ^1              ^1                        ^1
 3525|       |                        {
 3526|      6|                            let theme = &self.theme_set.themes["base16-ocean.dark"];
 3527|      6|                            let mut h = HighlightLines::new(syntax, theme);
 3528|       |
 3529|     10|                            for line in LinesWithEndings::from(code) {
                                                      ^6                     ^6
 3530|     10|                                let ranges =
 3531|     10|                                    h.highlight_line(line, &self.syntax_set).unwrap_or_default();
 3532|       |
 3533|     10|                                ui.horizontal_wrapped(|ui| {
 3534|       |                                    // Remove spacing between tokens to avoid visual gaps
 3535|     10|                                    ui.spacing_mut().item_spacing.x = 0.0;
 3536|     73|                                    for (style, text) in ranges {
                                                       ^63    ^63
 3537|       |                                        // Drop newline characters completely; they're handled by the outer line loop
 3538|     63|                                        let cleaned = text.replace(['\n', '\r'], "");
 3539|       |
 3540|     63|                                        if cleaned.is_empty() {
 3541|      4|                                            continue;
 3542|     59|                                        }
 3543|       |
 3544|       |                                        // Check if this token is pure whitespace (spaces or tabs only)
 3545|     70|                                        if cleaned.chars().all(|c| c == ' ' || c == '\t') {
                                                         ^59             ^59                 ^43
 3546|     16|                                            // Render whitespace as transparent to preserve layout without visual gaps
 3547|     16|                                            ui.label(
 3548|     16|                                                RichText::new(cleaned)
 3549|     16|                                                    .size(self.font_sizes.code)
 3550|     16|                                                    .color(Color32::TRANSPARENT)
 3551|     16|                                                    .family(egui::FontFamily::Monospace),
 3552|     16|                                            );
 3553|     16|                                        } else {
 3554|       |                                            // For non-whitespace, use normal highlighting but replace spaces with transparent ones
 3555|     43|                                            let color = Color32::from_rgb(
 3556|     43|                                                style.foreground.r,
 3557|     43|                                                style.foreground.g,
 3558|     43|                                                style.foreground.b,
 3559|       |                                            );
 3560|       |
 3561|       |                                            // Split by spaces and handle separately
 3562|     43|                                            let parts: Vec<&str> = cleaned.split(' ').collect();
 3563|     49|                                            for (i, part) in parts.iter().enumerate() {
                                                                           ^43          ^43
 3564|     49|                                                if !part.is_empty() {
 3565|     45|                                                    let mut rich_text = RichText::new(*part)
 3566|     45|                                                        .size(self.font_sizes.code)
 3567|     45|                                                        .color(color)
 3568|     45|                                                        .family(egui::FontFamily::Monospace);
 3569|       |
 3570|     45|                                                    if style.font_style.contains(
 3571|       |                                                        syntect::highlighting::FontStyle::BOLD,
 3572|      6|                                                    ) {
 3573|      6|                                                        rich_text = rich_text.strong();
 3574|     39|                                                    }
 3575|     45|                                                    if style.font_style.contains(
 3576|       |                                                        syntect::highlighting::FontStyle::ITALIC,
 3577|      6|                                                    ) {
 3578|      6|                                                        rich_text = rich_text.italics();
 3579|     39|                                                    }
 3580|       |
 3581|     45|                                                    ui.label(rich_text);
 3582|      4|                                                }
 3583|       |
 3584|       |                                                // Add transparent space between parts (except after last part)
 3585|     49|                                                if i < parts.len() - 1 {
 3586|      6|                                                    ui.label(
 3587|      6|                                                        RichText::new(" ")
 3588|      6|                                                            .size(self.font_sizes.code)
 3589|      6|                                                            .color(Color32::TRANSPARENT)
 3590|      6|                                                            .family(egui::FontFamily::Monospace),
 3591|      6|                                                    );
 3592|     43|                                                }
 3593|       |                                            }
 3594|       |                                        }
 3595|       |                                    }
 3596|     10|                                });
 3597|       |                            }
 3598|      6|                            return; // Early return if highlighting succeeded
 3599|      1|                        }
 3600|      3|                    }
 3601|       |
 3602|       |                    // Fallback: render as plain text
 3603|      4|                    ui.label(
 3604|      4|                        RichText::new(code)
 3605|      4|                            .size(self.font_sizes.code)
 3606|      4|                            .color(Color32::from_rgb(220, 220, 220))
 3607|      4|                            .family(egui::FontFamily::Monospace),
 3608|       |                    );
 3609|     10|                });
 3610|     10|            });
 3611|       |
 3612|       |        // Add context menu for code blocks
 3613|       |        #[cfg(test)]
 3614|     10|        {
 3615|     10|            let _ = &frame_response;
 3616|     10|            self.render_code_block_context_menu(ui, code, language);
 3617|     10|        }
 3618|       |        #[cfg(not(test))]
 3619|       |        frame_response.response.context_menu(|ui| {
 3620|       |            self.render_code_block_context_menu(ui, code, language);
 3621|       |        });
 3622|       |
 3623|     10|        ui.add_space(8.0);
 3624|     11|    }
 3625|       |
 3626|       |    /// Try to render a Mermaid diagram. Returns true if handled (rendered or placeholder drawn).
 3627|      1|    fn render_mermaid_block(&self, ui: &mut egui::Ui, code: &str) -> bool {
 3628|      1|        self.mermaid
 3629|      1|            .render_block(ui, code, self.ui_scale(), self.font_sizes.code)
 3630|      1|    }
 3631|       |
 3632|      8|    fn hash_str(s: &str) -> u64 {
 3633|      8|        let mut h = DefaultHasher::new();
 3634|      8|        s.hash(&mut h);
 3635|      8|        h.finish()
 3636|      8|    }
 3637|       |
 3638|    577|    fn hash_inline_spans(spans: &[InlineSpan]) -> u64 {
 3639|    577|        let mut h = DefaultHasher::new();
 3640|  1.20k|        for span in spans {
                          ^628
 3641|    628|            match span {
 3642|    600|                InlineSpan::Text(t) => {
 3643|    600|                    0u8.hash(&mut h);
 3644|    600|                    t.hash(&mut h);
 3645|    600|                }
 3646|      1|                InlineSpan::Code(t) => {
 3647|      1|                    1u8.hash(&mut h);
 3648|      1|                    t.hash(&mut h);
 3649|      1|                }
 3650|     10|                InlineSpan::Strong(t) => {
 3651|     10|                    2u8.hash(&mut h);
 3652|     10|                    t.hash(&mut h);
 3653|     10|                }
 3654|      1|                InlineSpan::Emphasis(t) => {
 3655|      1|                    3u8.hash(&mut h);
 3656|      1|                    t.hash(&mut h);
 3657|      1|                }
 3658|      1|                InlineSpan::Strikethrough(t) => {
 3659|      1|                    4u8.hash(&mut h);
 3660|      1|                    t.hash(&mut h);
 3661|      1|                }
 3662|     10|                InlineSpan::Link { text, url } => {
 3663|     10|                    5u8.hash(&mut h);
 3664|     10|                    text.hash(&mut h);
 3665|     10|                    url.hash(&mut h);
 3666|     10|                }
 3667|      5|                InlineSpan::Image { src, alt, title } => {
 3668|      5|                    6u8.hash(&mut h);
 3669|      5|                    src.hash(&mut h);
 3670|      5|                    alt.hash(&mut h);
 3671|      5|                    title.hash(&mut h);
 3672|      5|                }
 3673|       |            }
 3674|       |        }
 3675|    577|        h.finish()
 3676|    577|    }
 3677|       |
 3678|     23|    fn alignment_hash(align: Alignment) -> u8 {
 3679|     23|        match align {
 3680|     10|            Alignment::None => 0,
 3681|      7|            Alignment::Left => 1,
 3682|      3|            Alignment::Center => 2,
 3683|      3|            Alignment::Right => 3,
 3684|       |        }
 3685|     23|    }
 3686|       |
 3687|      8|    fn alignment_to_egui(align: Alignment) -> Align {
 3688|      8|        match align {
 3689|      1|            Alignment::Center => Align::Center,
 3690|      1|            Alignment::Right => Align::RIGHT,
 3691|      6|            Alignment::Left | Alignment::None => Align::LEFT,
 3692|       |        }
 3693|      8|    }
 3694|       |
 3695|     55|    fn alignment_for_column(alignments: &[Alignment], col_idx: usize) -> Align {
 3696|     55|        alignments
 3697|     55|            .get(col_idx)
 3698|     55|            .copied()
 3699|     55|            .map(Self::alignment_to_egui)
 3700|     55|            .unwrap_or(Align::LEFT)
 3701|     55|    }
 3702|       |
 3703|    176|    fn align_to_u8(align: Align) -> u8 {
 3704|    176|        if align == Align::LEFT {
 3705|    166|            0
 3706|     10|        } else if align == Align::Center {
 3707|      5|            1
 3708|       |        } else {
 3709|      5|            2
 3710|       |        }
 3711|    176|    }
 3712|       |
 3713|      4|    fn next_table_index(&self) -> u64 {
 3714|      4|        let mut counter = self.table_counter.borrow_mut();
 3715|      4|        let idx = *counter;
 3716|      4|        *counter += 1;
 3717|      4|        idx
 3718|      4|    }
 3719|       |
 3720|     23|    fn compute_table_id(
 3721|     23|        &self,
 3722|     23|        headers: &[Vec<InlineSpan>],
 3723|     23|        rows: &[Vec<Vec<InlineSpan>>],
 3724|     23|        alignments: &[Alignment],
 3725|     23|        table_index: u64,
 3726|     23|    ) -> u64 {
 3727|     23|        let mut hasher = DefaultHasher::new();
 3728|     23|        if let Some(base) = self.base_dir.borrow().as_ref() {
                                  ^1
 3729|      1|            base.hash(&mut hasher);
 3730|     22|        }
 3731|     23|        hasher.write_u64(table_index);
 3732|     23|        hasher.write_u64(self.compute_table_content_hash(headers, rows, alignments));
 3733|     23|        hasher.finish()
 3734|     23|    }
 3735|       |
 3736|     44|    fn compute_table_content_hash(
 3737|     44|        &self,
 3738|     44|        headers: &[Vec<InlineSpan>],
 3739|     44|        rows: &[Vec<Vec<InlineSpan>>],
 3740|     44|        alignments: &[Alignment],
 3741|     44|    ) -> u64 {
 3742|     44|        let mut hasher = DefaultHasher::new();
 3743|     44|        hasher.write_usize(headers.len());
 3744|    156|        for header in headers {
                          ^112
 3745|    112|            hasher.write_u64(Self::hash_inline_spans(header));
 3746|    112|        }
 3747|     44|        hasher.write_usize(alignments.len());
 3748|     67|        for align in alignments {
                          ^23
 3749|     23|            hasher.write_u8(Self::alignment_hash(*align));
 3750|     23|        }
 3751|     44|        let mut counted = 0usize;
 3752|    230|        for row in rows {
                          ^187
 3753|    474|            for cell in row {
                              ^287
 3754|    287|                hasher.write_u64(Self::hash_inline_spans(cell));
 3755|    287|            }
 3756|    187|            counted += 1;
 3757|    187|            if counted >= COLUMN_STATS_SAMPLE_ROWS {
 3758|      1|                break;
 3759|    186|            }
 3760|       |        }
 3761|     44|        hasher.finish()
 3762|     44|    }
 3763|       |
 3764|     20|    fn column_stats_for_table(
 3765|     20|        &self,
 3766|     20|        table_id: u64,
 3767|     20|        headers: &[Vec<InlineSpan>],
 3768|     20|        rows: &[Vec<Vec<InlineSpan>>],
 3769|     20|        alignments: &[Alignment],
 3770|     20|    ) -> Vec<ColumnStat> {
 3771|     20|        let content_hash = self.compute_table_content_hash(headers, rows, alignments);
 3772|     20|        if let Some(entry) = self
                                  ^2
 3773|     20|            .column_stats_cache
 3774|     20|            .borrow()
 3775|     20|            .get(&table_id)
 3776|     20|            .filter(|entry| entry.content_hash == content_hash)
                                          ^2                    ^2
 3777|       |        {
 3778|      2|            return entry.stats.clone();
 3779|     18|        }
 3780|     18|        let stats = compute_column_stats(headers, rows, COLUMN_STATS_SAMPLE_ROWS);
 3781|     18|        self.column_stats_cache.borrow_mut().insert(
 3782|     18|            table_id,
 3783|     18|            ColumnStatsCacheEntry {
 3784|     18|                content_hash,
 3785|     18|                stats: stats.clone(),
 3786|     18|            },
 3787|     18|        );
 3788|     18|        stats
 3789|     20|    }
 3790|       |
 3791|       |    /// Render a table using an egui Grid
 3792|      5|    fn render_table(
 3793|      5|        &self,
 3794|      5|        ui: &mut egui::Ui,
 3795|      5|        headers: &[Vec<InlineSpan>],
 3796|      5|        rows: &[Vec<Vec<InlineSpan>>],
 3797|      5|        alignments: &[Alignment],
 3798|      5|    ) {
 3799|      5|        if headers.is_empty() {
 3800|      1|            return;
 3801|      4|        }
 3802|       |
 3803|      4|        let table_index = self.next_table_index();
 3804|      4|        let table_id = self.compute_table_id(headers, rows, alignments, table_index);
 3805|      4|        self.render_table_tablebuilder(ui, headers, rows, alignments, table_id);
 3806|      4|        ui.add_space(8.0);
 3807|      5|    }
 3808|       |
 3809|    136|    fn extend_table_rect(target: &mut Option<egui::Rect>, rect: egui::Rect) {
 3810|    136|        if rect.min.x.is_nan() || rect.min.y.is_nan() || rect.max.x.is_nan() || rect.max.y.is_nan()
                                                ^135       ^135        ^134       ^134        ^133       ^133
 3811|       |        {
 3812|      4|            return;
 3813|    132|        }
 3814|    132|        if let Some(existing) = target {
                                  ^93
 3815|     93|            existing.min.x = existing.min.x.min(rect.min.x);
 3816|     93|            existing.min.y = existing.min.y.min(rect.min.y);
 3817|     93|            existing.max.x = existing.max.x.max(rect.max.x);
 3818|     93|            existing.max.y = existing.max.y.max(rect.max.y);
 3819|     93|        } else {
 3820|     39|            *target = Some(rect);
 3821|     39|        }
 3822|    136|    }
 3823|       |
 3824|     19|    fn render_table_tablebuilder(
 3825|     19|        &self,
 3826|     19|        ui: &mut egui::Ui,
 3827|     19|        headers: &[Vec<InlineSpan>],
 3828|     19|        rows: &[Vec<Vec<InlineSpan>>],
 3829|     19|        alignments: &[Alignment],
 3830|     19|        table_id: u64,
 3831|     19|    ) {
 3832|     19|        let column_stats = self.column_stats_for_table(table_id, headers, rows, alignments);
 3833|     19|        let ctx =
 3834|     19|            TableColumnContext::new(headers, rows, &column_stats, self.font_sizes.body, table_id);
 3835|     19|        let mut column_specs = derive_column_specs(&ctx);
 3836|       |        #[cfg(test)]
 3837|     19|        if let Some(policies) = take_forced_table_policies() {
                                  ^5
 3838|     14|            for (spec, policy) in column_specs.iter_mut().zip(policies.into_iter()) {
                                                ^5                      ^5  ^5       ^5
 3839|     14|                spec.set_policy(policy);
 3840|     14|            }
 3841|     14|        }
 3842|     19|        self.apply_persisted_widths(table_id, &mut column_specs);
 3843|     19|        let column_aligns: Vec<Align> = (0..column_specs.len())
 3844|     55|            .map(|ci| Self::alignment_for_column(alignments, ci))
                           ^19
 3845|     19|            .collect();
 3846|       |
 3847|     19|        let column_spacing = ui.spacing().item_spacing.x.max(6.0);
 3848|     19|        let available_width = ui.available_width().max(1.0);
 3849|     19|        let min_floor = self.table_min_column_width();
 3850|     19|        let resolved_widths = self.resolve_table_column_widths(table_id, &column_specs, min_floor);
 3851|     19|        let min_widths: Vec<f32> = column_specs
 3852|     19|            .iter()
 3853|     55|            .map(|spec| match spec.policy {
                           ^19
 3854|     16|                ColumnPolicy::Fixed { width, .. } => width,
 3855|     20|                ColumnPolicy::Resizable { min, .. } => min,
 3856|     19|                ColumnPolicy::Remainder { .. } | ColumnPolicy::Auto => min_floor,
 3857|     55|            })
 3858|     19|            .collect();
 3859|     19|        let spacing_total = column_spacing * column_specs.len().saturating_sub(1) as f32;
 3860|     19|        let available_for_columns = available_width - spacing_total;
 3861|     19|        let mut fixed_total = 0.0;
 3862|     19|        let mut flexible_indices: Vec<usize> = Vec::new();
 3863|     19|        let mut remainder_indices: Vec<usize> = Vec::new();
 3864|     55|        for (idx, spec) in column_specs.iter().enumerate() {
                                         ^19                 ^19
 3865|     55|            match spec.policy {
 3866|     16|                ColumnPolicy::Fixed { width, .. } => fixed_total += width,
 3867|     20|                ColumnPolicy::Resizable { .. } => flexible_indices.push(idx),
 3868|     16|                ColumnPolicy::Remainder { .. } => {
 3869|     16|                    flexible_indices.push(idx);
 3870|     16|                    remainder_indices.push(idx);
 3871|     16|                }
 3872|      3|                ColumnPolicy::Auto => flexible_indices.push(idx),
 3873|       |            }
 3874|       |        }
 3875|     39|        let min_flex_total: f32 = flexible_indices.iter().map(|idx| min_widths[*idx]).sum();
                          ^19             ^19   ^19                     ^19                         ^19
 3876|     19|        let desired_total_width = resolved_widths.iter().sum::<f32>() + spacing_total;
 3877|     19|        let content_width = desired_total_width.max(available_width);
 3878|     19|        let remaining_for_flex = available_for_columns - fixed_total;
 3879|     19|        let use_hscroll = available_for_columns <= 0.0
 3880|     18|            || fixed_total > available_for_columns + 0.5
 3881|     17|            || remaining_for_flex < min_flex_total - 0.5;
 3882|     19|        let mut adjusted_widths = resolved_widths.clone();
 3883|     19|        let mut scaled_down = false;
 3884|     19|        if !use_hscroll {
 3885|     14|            let remaining = remaining_for_flex.max(0.0);
 3886|     14|            let flex_total: f32 = flexible_indices
 3887|     14|                .iter()
 3888|     25|                .map(|idx| resolved_widths[*idx])
                               ^14
 3889|     14|                .sum();
 3890|     14|            if flex_total > remaining + 0.5 {
 3891|      2|                if remaining <= min_flex_total + 0.5 {
 3892|      3|                    for idx in &flexible_indices {
                                      ^2
 3893|      2|                        adjusted_widths[*idx] = min_widths[*idx].max(1.0);
 3894|      2|                    }
 3895|       |                } else {
 3896|      1|                    let extra_total = flex_total - min_flex_total;
 3897|      1|                    let extra_scale = ((remaining - min_flex_total) / extra_total).clamp(0.0, 1.0);
 3898|      4|                    for idx in &flexible_indices {
                                      ^3
 3899|      3|                        let min_width = min_widths[*idx];
 3900|      3|                        let desired = resolved_widths[*idx];
 3901|      3|                        let extra = (desired - min_width).max(0.0);
 3902|      3|                        adjusted_widths[*idx] = (min_width + extra * extra_scale).max(1.0);
 3903|      3|                    }
 3904|       |                }
 3905|      2|                scaled_down = true;
 3906|     12|            }
 3907|      5|        }
 3908|     19|        let column_layout: Vec<Column> = if use_hscroll {
 3909|     18|            column_specs.iter().map(|spec| spec.as_column()).collect()
                          ^5                  ^5                           ^5
 3910|       |        } else {
 3911|     14|            column_specs
 3912|     14|                .iter()
 3913|     14|                .enumerate()
 3914|     37|                .map(|(idx, spec)| {
                               ^14
 3915|     37|                    let width = adjusted_widths
 3916|     37|                        .get(idx)
 3917|     37|                        .copied()
 3918|     37|                        .unwrap_or(min_floor)
 3919|     37|                        .max(1.0);
 3920|     37|                    match spec.policy {
 3921|     12|                        ColumnPolicy::Fixed { width, clip } => {
 3922|     12|                            let mut col = Column::exact(width);
 3923|     12|                            if clip {
 3924|     10|                                col = col.clip(true);
 3925|     10|                            }
                                          ^2
 3926|     12|                            col
 3927|       |                        }
 3928|     11|                        ColumnPolicy::Resizable { min, clip, .. } => {
 3929|     11|                            let mut col = Column::initial(width)
 3930|     11|                                .at_least(min.min(width))
 3931|     11|                                .resizable(true);
 3932|     11|                            if clip {
 3933|      1|                                col = col.clip(true);
 3934|     10|                            }
 3935|     11|                            col
 3936|       |                        }
 3937|     12|                        ColumnPolicy::Remainder { clip } => {
 3938|     12|                            let mut col = if scaled_down {
 3939|      1|                                Column::initial(width).at_least(min_floor.min(width))
 3940|       |                            } else {
 3941|     11|                                Column::remainder().at_least(min_floor)
 3942|       |                            };
 3943|     12|                            if clip {
 3944|      1|                                col = col.clip(true);
 3945|     11|                            }
 3946|     12|                            col
 3947|       |                        }
 3948|       |                        ColumnPolicy::Auto => {
 3949|      2|                            if scaled_down {
 3950|      1|                                Column::initial(width).at_least(min_floor.min(width))
 3951|       |                            } else {
 3952|      1|                                Column::auto_with_initial_suggestion(width).at_least(min_floor)
 3953|       |                            }
 3954|       |                        }
 3955|       |                    }
 3956|     37|                })
 3957|     14|                .collect()
 3958|       |        };
 3959|       |
 3960|     19|        let render_table = |ui: &mut egui::Ui, max_width: f32| {
 3961|     19|            let width_bucket = max_width.round() as i32;
 3962|     19|            ui.push_id((table_id, width_bucket), |ui| {
 3963|     19|                let layout = *ui.layout();
 3964|     19|                ui.allocate_ui_with_layout(Vec2::new(max_width, 0.0), layout, |ui| {
 3965|     19|                    ui.set_width(max_width);
 3966|     19|                    let needs_estimate = {
 3967|     19|                        let metrics = self.table_metrics.borrow();
 3968|     19|                        metrics
 3969|     19|                            .entry(table_id)
 3970|     19|                            .is_none_or(|entry| entry.rows.is_empty())
 3971|       |                    };
 3972|     19|                    self.begin_table_pass(table_id, rows.len());
 3973|       |
 3974|     19|                    let prev_spacing = ui.spacing().item_spacing;
 3975|     19|                    if (prev_spacing.x - column_spacing).abs() > f32::EPSILON {
 3976|      2|                        ui.spacing_mut().item_spacing.x = column_spacing;
 3977|     17|                    }
 3978|       |
 3979|     19|                    let cached_header_height = self
 3980|     19|                        .table_metrics
 3981|     19|                        .borrow()
 3982|     19|                        .entry(table_id)
 3983|     19|                        .and_then(|entry| entry.header_height());
 3984|       |                    // Rough header height estimation using equally divided width; refines on next frame via cache.
 3985|     19|                    let header_height = cached_header_height.unwrap_or_else(|| {
                                                                                             ^18
 3986|     18|                        let mut estimate = self.row_height_fallback();
 3987|     18|                        let column_count = column_specs.len().max(1);
 3988|     18|                        let approx_width = (ui.available_width() / column_count as f32)
 3989|     18|                            .max(self.font_sizes.body * 6.0)
 3990|     18|                            .max(48.0);
 3991|     18|                        let style = ui.style().clone();
 3992|     18|                        estimate = headers
 3993|     18|                            .iter()
 3994|     18|                            .enumerate()
 3995|     47|                            .map(|(ci, spans)| {
                                           ^18
 3996|     47|                                let halign = column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
 3997|     47|                                let build = self.cached_layout_job(
 3998|     47|                                    &style,
 3999|     47|                                    None,
 4000|     47|                                    ci,
 4001|     47|                                    spans,
 4002|     47|                                    approx_width,
 4003|       |                                    true,
 4004|     47|                                    halign,
 4005|       |                                );
 4006|     47|                                ui.fonts(|f| f.layout_job(build.job.clone()).size().y + 6.0)
 4007|     47|                            })
 4008|     47|                            .fold(estimate, |acc, h| acc.max(h));
                                           ^18  ^18
 4009|     18|                        estimate.min(self.row_height_fallback() * 3.0)
 4010|     18|                    });
 4011|       |
 4012|     19|                    let fallback_row_height = self.row_height_fallback();
 4013|     19|                    let mut row_heights: Vec<f32> = (0..rows.len())
 4014|     27|                        .map(|idx| self.row_height_hint(table_id, idx))
                                       ^19
 4015|     19|                        .collect();
 4016|     19|                    if needs_estimate {
 4017|     18|                        let approx_widths = self.estimate_table_column_widths(
 4018|     18|                            &column_specs,
 4019|     18|                            max_width,
 4020|     18|                            column_spacing,
 4021|       |                        );
 4022|     18|                        let style = ui.style().clone();
 4023|     26|                        for (idx, row) in rows.iter().enumerate() {
                                                        ^18  ^18    ^18
 4024|     26|                            if self.row_needs_height_estimate(row) {
 4025|      8|                                let estimate = self.estimate_table_row_height(
 4026|      8|                                    ui,
 4027|      8|                                    &style,
 4028|      8|                                    row,
 4029|      8|                                    &column_aligns,
 4030|      8|                                    &approx_widths,
 4031|      8|                                    fallback_row_height,
 4032|      8|                                );
 4033|      8|                                row_heights[idx] = row_heights[idx].max(estimate);
 4034|     18|                            }
 4035|       |                        }
 4036|      1|                    }
 4037|       |
 4038|       |                    // Capture painter from outer UI BEFORE TableBuilder to ensure dividers
 4039|       |                    // paint on top of both header and body (fixes header divider visibility).
 4040|     19|                    let outer_painter = ui.painter().clone();
 4041|     19|                    let outer_visuals = ui.visuals().clone();
 4042|     19|                    let outer_ctx = ui.ctx().clone();
 4043|       |
 4044|     19|                    let mut table = TableBuilder::new(ui).striped(true).vscroll(false);
 4045|     74|                    for column in &column_layout {
                                      ^55
 4046|     55|                        table = table.column(*column);
 4047|     55|                    }
 4048|       |
 4049|       |                    // Use RefCell to allow capturing widths from body closure.
 4050|       |                    // BUG FIX: Previously captured ui.min_rect().width() which is the cell *content* width.
 4051|       |                    // Now we capture body.widths() which gives the actual *allocated* column widths.
 4052|       |                    // See: https://docs.rs/egui_extras/latest/egui_extras/struct.TableBody.html#method.widths
 4053|     19|                    let column_widths: RefCell<Vec<f32>> =
 4054|     19|                        RefCell::new(vec![0.0f32; column_specs.len()]);
 4055|       |                    // Track header and body rects separately for accurate table bounds calculation.
 4056|       |                    // The header rect captures the header row bounds, body_rect captures body row bounds.
 4057|       |                    // These are combined after rendering to get the full table rect.
 4058|     19|                    let mut header_rect: Option<egui::Rect> = None;
 4059|     19|                    let mut body_rect: Option<egui::Rect> = None;
 4060|       |                    // body_layout_rect captures the allocated layout region from body.max_rect(),
 4061|       |                    // which is more accurate than union of cell min_rects for table width.
 4062|     19|                    let body_layout_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);
 4063|       |                    // Track clip rects separately for header and body, then union them.
 4064|       |                    // This ensures dividers respect scroll boundaries for both regions.
 4065|     19|                    let mut header_clip_rect: Option<egui::Rect> = None;
 4066|     19|                    let body_clip_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);
 4067|       |
 4068|     19|                    let mut height_change = false;
 4069|     19|                    let header_height_actual = Cell::new(0.0f32);
 4070|     19|                    table
 4071|     19|                        .header(header_height, |mut header| {
 4072|     55|                            for (ci, _) in column_specs.iter().enumerate() {
                                                         ^19                 ^19
 4073|     55|                                header.col(|ui| {
 4074|     55|                                    let width = ui.available_width().max(1.0);
 4075|     55|                                    let spans =
 4076|     55|                                        headers.get(ci).map(|v| v.as_slice()).unwrap_or(&[]);
                                                                              ^52^52
 4077|     55|                                    let halign =
 4078|     55|                                        column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
 4079|     55|                                    let cell_height = self.render_overhauled_cell(
 4080|     55|                                        ui, spans, width, true, None, ci, halign,
 4081|       |                                    );
 4082|     55|                                    header_height_actual
 4083|     55|                                        .set(header_height_actual.get().max(cell_height));
 4084|       |                                    // NOTE: Do NOT capture ui.min_rect().width() here - that's the content width,
 4085|       |                                    // not the column width. Column widths are captured from body.widths() below.
 4086|       |                                    // Extend header_rect (not body_rect) for accurate header bounds.
 4087|     55|                                    Self::extend_table_rect(&mut header_rect, ui.min_rect());
 4088|     55|                                    if header_clip_rect.is_none() {
 4089|     19|                                        header_clip_rect = Some(ui.clip_rect());
 4090|     36|                                    }
 4091|     55|                                });
 4092|       |                            }
 4093|     19|                        })
 4094|     19|                        .body(|body| {
 4095|       |                            // Capture the actual allocated column widths from the table layout system.
 4096|       |                            // This MUST be done before heterogeneous_rows() consumes the body.
 4097|     19|                            *column_widths.borrow_mut() = body.widths().to_vec();
 4098|       |
 4099|       |                            // Capture body's layout rect for accurate table width calculation.
 4100|       |                            // This is the allocated region, not the content bounds.
 4101|     19|                            *body_layout_rect.borrow_mut() = Some(body.max_rect());
 4102|       |
 4103|     19|                            let row_height_hints = row_heights.clone();
 4104|     27|                            body.heterogeneous_rows(row_height_hints.into_iter(), |mut row| {
                                          ^19  ^19                ^19              ^19
 4105|     27|                                let idx = row.index();
 4106|     27|                                let row_cells = rows.get(idx);
 4107|     27|                                let mut row_height = fallback_row_height;
 4108|     74|                                for (ci, _) in column_specs.iter().enumerate() {
                                                             ^27                 ^27
 4109|     74|                                    let mut cell_height = fallback_row_height;
 4110|     74|                                    row.col(|ui| {
 4111|     74|                                        let width = ui.available_width().max(1.0);
 4112|     74|                                        let spans = row_cells
 4113|     74|                                            .and_then(|cells| cells.get(ci))
 4114|     74|                                            .map(|cell| cell.as_slice())
 4115|     74|                                            .unwrap_or(&[]);
 4116|     74|                                        let halign =
 4117|     74|                                            column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
 4118|     74|                                        cell_height = self.render_overhauled_cell(
 4119|     74|                                            ui,
 4120|     74|                                            spans,
 4121|     74|                                            width,
 4122|     74|                                            false,
 4123|     74|                                            Some(idx),
 4124|     74|                                            ci,
 4125|     74|                                            halign,
 4126|     74|                                        );
 4127|       |                                        // Extend body_rect (not header_rect) for accurate body bounds.
 4128|     74|                                        Self::extend_table_rect(&mut body_rect, ui.min_rect());
 4129|     74|                                        if body_clip_rect.borrow().is_none() {
 4130|     18|                                            *body_clip_rect.borrow_mut() = Some(ui.clip_rect());
 4131|     56|                                        }
 4132|     74|                                    });
 4133|     74|                                    row_height = row_height.max(cell_height);
 4134|       |                                }
 4135|     27|                                if (row_height - row_heights[idx]).abs() > 0.5 {
 4136|     26|                                    height_change = true;
 4137|     26|                                }
                                              ^1
 4138|     27|                                self.update_row_height(table_id, idx, row_height);
 4139|     27|                                self.note_row_rendered(table_id);
 4140|     27|                            });
 4141|     19|                        });
 4142|       |
 4143|     19|                    ui.spacing_mut().item_spacing = prev_spacing;
 4144|       |
 4145|       |                    // Extract column widths from RefCell for use in divider painting
 4146|     19|                    let widths = column_widths.into_inner();
 4147|     19|                    let layout_rect = body_layout_rect.into_inner();
 4148|     19|                    let body_clip = body_clip_rect.into_inner();
 4149|     19|                    let measured_header_height = header_height_actual.get();
 4150|     19|                    if self.update_header_height(table_id, measured_header_height) {
 4151|     18|                        ui.ctx().request_repaint();
 4152|     18|                    }
                                  ^1
 4153|       |
 4154|     19|                    let (rect, clip_rect) = self.resolve_table_rects(
 4155|     19|                        header_rect,
 4156|     19|                        body_rect,
 4157|     19|                        layout_rect,
 4158|     19|                        header_clip_rect,
 4159|     19|                        body_clip,
 4160|     19|                        &widths,
 4161|     19|                        column_spacing,
 4162|     19|                    );
 4163|     19|                    let frame_id = outer_ctx.frame_nr();
 4164|     19|                    let change = self.record_resolved_widths(table_id, frame_id, &widths);
 4165|     19|                    self.persist_resizable_widths(table_id, &column_specs, &widths);
 4166|     19|                    self.handle_width_change(&outer_ctx, table_id, change);
 4167|       |                    // Use outer_painter (captured before TableBuilder) to ensure
 4168|       |                    // dividers paint on top of both header and body.
 4169|     19|                    self.paint_table_dividers(
 4170|     19|                        &outer_painter,
 4171|     19|                        &outer_visuals,
 4172|     19|                        rect,
 4173|     19|                        clip_rect,
 4174|     19|                        &widths,
 4175|     19|                        header_height,
 4176|     19|                        column_spacing,
 4177|       |                    );
 4178|     19|                    if height_change {
 4179|     17|                        ui.ctx().request_repaint();
 4180|     17|                    }
                                  ^2
 4181|     19|                });
 4182|     19|            });
 4183|     19|        };
 4184|       |
 4185|     19|        if use_hscroll {
 4186|      5|            egui::ScrollArea::horizontal()
 4187|      5|                .id_source(("md_table_hscroll_overhaul", table_id))
 4188|      5|                .auto_shrink([false, true])
 4189|      5|                .scroll_bar_visibility(egui::scroll_area::ScrollBarVisibility::VisibleWhenNeeded)
 4190|      5|                .show(ui, |ui| {
 4191|      5|                    ui.set_min_width(content_width);
 4192|      5|                    render_table(ui, content_width);
 4193|      5|                });
 4194|     14|        } else {
 4195|     14|            render_table(ui, available_width);
 4196|     14|        }
 4197|     19|    }
 4198|       |
 4199|     25|    fn resolve_table_rects(
 4200|     25|        &self,
 4201|     25|        header_rect: Option<egui::Rect>,
 4202|     25|        body_rect: Option<egui::Rect>,
 4203|     25|        layout_rect: Option<egui::Rect>,
 4204|     25|        header_clip_rect: Option<egui::Rect>,
 4205|     25|        body_clip: Option<egui::Rect>,
 4206|     25|        widths: &[f32],
 4207|     25|        column_spacing: f32,
 4208|     25|    ) -> (egui::Rect, egui::Rect) {
 4209|       |        // Combine header and body clip rects to ensure dividers respect scroll bounds.
 4210|     25|        let clip_rect = match (header_clip_rect, body_clip) {
 4211|     18|            (Some(h), Some(b)) => Some(h.union(b)),
 4212|      1|            (Some(h), None) => Some(h),
 4213|      1|            (None, Some(b)) => Some(b),
 4214|      5|            (None, None) => None,
 4215|       |        };
 4216|       |
 4217|       |        // Calculate accurate table width from column widths.
 4218|       |        // This is more accurate than union of cell min_rects which may be smaller
 4219|       |        // than the allocated column space.
 4220|     25|        let calculated_width: f32 =
 4221|     25|            widths.iter().sum::<f32>() + column_spacing * widths.len().saturating_sub(1) as f32;
 4222|       |
 4223|       |        // Combine header/body bounds with layout bounds for accurate borders,
 4224|       |        // especially when the first column is centered or right-aligned.
 4225|     25|        let left = layout_rect
 4226|     25|            .map(|rect| rect.left())
                                      ^21  ^21
 4227|     25|            .or_else(|| header_rect.map(|rect| rect.left()))
                                      ^4          ^4         ^1   ^1
 4228|     25|            .or_else(|| body_rect.map(|rect| rect.left()));
                                      ^3        ^3         ^1   ^1
 4229|     25|        let right = left.map(|value| value + calculated_width);
                                                   ^23     ^23
 4230|     25|        let top = header_rect
 4231|     25|            .map(|rect| rect.top())
                                      ^21  ^21
 4232|     25|            .or_else(|| body_rect.map(|rect| rect.top()))
                                      ^4        ^4         ^1   ^1
 4233|     25|            .or_else(|| layout_rect.map(|rect| rect.top()));
                                      ^3          ^3         ^1   ^1
 4234|     25|        let bottom = body_rect
 4235|     25|            .map(|rect| rect.bottom())
                                      ^20  ^20
 4236|     25|            .or_else(|| header_rect.map(|rect| rect.bottom()))
                                      ^5          ^5         ^2   ^2
 4237|     25|            .or_else(|| layout_rect.map(|rect| rect.bottom()));
                                      ^3          ^3         ^1   ^1
 4238|     25|        let table_rect = match (left, right, top, bottom) {
 4239|     23|            (Some(left), Some(right), Some(top), Some(bottom)) => Some(egui::Rect::from_min_max(
 4240|     23|                egui::pos2(left, top),
 4241|     23|                egui::pos2(right, bottom),
 4242|     23|            )),
 4243|      2|            _ => None,
 4244|       |        };
 4245|       |
 4246|     25|        let rect = table_rect.unwrap_or_else(|| {
                                                              ^2
 4247|      2|            layout_rect.unwrap_or_else(|| {
 4248|      2|                egui::Rect::from_min_max(egui::pos2(0.0, 0.0), egui::pos2(0.0, 0.0))
 4249|      2|            })
 4250|      2|        });
 4251|     25|        let clip_rect = clip_rect.unwrap_or(rect);
 4252|     25|        (rect, clip_rect)
 4253|     25|    }
 4254|       |
 4255|     31|    fn row_needs_height_estimate(&self, row: &[Vec<InlineSpan>]) -> bool {
 4256|     72|        row.iter().any(|cell| {
                      ^31        ^31
 4257|     80|            cell.iter().any(|span| match span {
                          ^72         ^72
 4258|      1|                InlineSpan::Image { .. } => true,
 4259|     73|                InlineSpan::Text(text)
 4260|      1|                | InlineSpan::Code(text)
 4261|      1|                | InlineSpan::Strong(text)
 4262|      1|                | InlineSpan::Emphasis(text)
 4263|      1|                | InlineSpan::Strikethrough(text)
 4264|     79|                | InlineSpan::Link { text, .. } => text.contains('\n'),
                                                   ^2
 4265|     80|            })
 4266|     72|        })
 4267|     31|    }
 4268|       |
 4269|     42|    fn table_min_column_width(&self) -> f32 {
 4270|     42|        (self.font_sizes.body * 6.0).max(48.0)
 4271|     42|    }
 4272|       |
 4273|     22|    fn resolve_table_column_widths(
 4274|     22|        &self,
 4275|     22|        table_id: u64,
 4276|     22|        column_specs: &[ColumnSpec],
 4277|     22|        min_floor: f32,
 4278|     22|    ) -> Vec<f32> {
 4279|     22|        if column_specs.is_empty() {
 4280|      1|            return Vec::new();
 4281|     21|        }
 4282|       |
 4283|     21|        let stored_widths = {
 4284|     21|            let metrics = self.table_metrics.borrow();
 4285|     21|            metrics
 4286|     21|                .entry(table_id)
 4287|     21|                .map(|entry| entry.current_widths().to_vec())
                                           ^20                    ^20
 4288|     21|                .unwrap_or_default()
 4289|       |        };
 4290|       |
 4291|     21|        column_specs
 4292|     21|            .iter()
 4293|     21|            .enumerate()
 4294|     60|            .map(|(idx, spec)| {
                           ^21
 4295|     60|                let stored = stored_widths
 4296|     60|                    .get(idx)
 4297|     60|                    .copied()
 4298|     60|                    .filter(|width| width.is_finite() && *width > 0.0);
                                                  ^7    ^7             ^6
 4299|     60|                let width = match spec.policy {
 4300|     16|                    ColumnPolicy::Fixed { width, .. } => width,
 4301|     23|                    ColumnPolicy::Resizable { min, preferred, .. } => {
 4302|     23|                        stored.unwrap_or(preferred.max(min)).max(min)
 4303|       |                    }
 4304|     17|                    ColumnPolicy::Remainder { .. } => min_floor,
 4305|      4|                    ColumnPolicy::Auto => stored.unwrap_or(min_floor).max(min_floor),
 4306|       |                };
 4307|     60|                width.max(1.0)
 4308|     60|            })
 4309|     21|            .collect()
 4310|     22|    }
 4311|       |
 4312|     22|    fn estimate_table_column_widths(
 4313|     22|        &self,
 4314|     22|        column_specs: &[ColumnSpec],
 4315|     22|        max_width: f32,
 4316|     22|        column_spacing: f32,
 4317|     22|    ) -> Vec<f32> {
 4318|     22|        let column_count = column_specs.len().max(1);
 4319|     22|        let spacing_total = column_spacing * column_count.saturating_sub(1) as f32;
 4320|     22|        let available = (max_width - spacing_total).max(1.0);
 4321|     22|        let min_floor = self.table_min_column_width();
 4322|     22|        let mut widths: Vec<f32> = column_specs
 4323|     22|            .iter()
 4324|     56|            .map(|spec| match spec.policy {
                           ^22
 4325|     19|                ColumnPolicy::Fixed { width, .. } => width,
 4326|     20|                ColumnPolicy::Resizable { min, .. } => min,
 4327|     14|                ColumnPolicy::Remainder { .. } => min_floor,
 4328|      3|                ColumnPolicy::Auto => min_floor,
 4329|     56|            })
 4330|     56|            .map(|width| width.max(1.0))
                           ^22
 4331|     22|            .collect();
 4332|       |
 4333|     22|        if widths.is_empty() {
 4334|      1|            return vec![available];
 4335|     21|        }
 4336|     21|        let sum: f32 = widths.iter().sum();
 4337|     21|        if sum > available {
 4338|      2|            let scale = available / sum;
 4339|      6|            for width in &mut widths {
                              ^4
 4340|      4|                *width = (*width * scale).max(1.0);
 4341|      4|            }
 4342|     19|        }
 4343|     21|        widths
 4344|     22|    }
 4345|       |
 4346|       |    #[cfg(test)]
 4347|      2|    fn estimate_table_total_width(
 4348|      2|        &self,
 4349|      2|        table_id: u64,
 4350|      2|        column_specs: &[ColumnSpec],
 4351|      2|        column_spacing: f32,
 4352|      2|    ) -> f32 {
 4353|      2|        if column_specs.is_empty() {
 4354|      1|            return 0.0;
 4355|      1|        }
 4356|      1|        let min_floor = self.table_min_column_width();
 4357|      1|        let widths = self.resolve_table_column_widths(table_id, column_specs, min_floor);
 4358|      1|        let spacing_total = column_spacing * widths.len().saturating_sub(1) as f32;
 4359|      1|        widths.iter().sum::<f32>() + spacing_total
 4360|      2|    }
 4361|       |
 4362|     10|    fn estimate_table_row_height(
 4363|     10|        &self,
 4364|     10|        ui: &egui::Ui,
 4365|     10|        style: &egui::Style,
 4366|     10|        row: &[Vec<InlineSpan>],
 4367|     10|        column_aligns: &[Align],
 4368|     10|        widths: &[f32],
 4369|     10|        fallback: f32,
 4370|     10|    ) -> f32 {
 4371|     10|        let mut max_height = fallback;
 4372|     10|        let column_count = widths.len().max(row.len()).max(1);
 4373|     22|        for ci in 0..column_count {
                                   ^10
 4374|     22|            let spans = row.get(ci).map(|cell| cell.as_slice()).unwrap_or(&[]);
 4375|     22|            if spans.is_empty() {
 4376|      1|                continue;
 4377|     21|            }
 4378|     21|            let width = widths
 4379|     21|                .get(ci)
 4380|     21|                .copied()
 4381|     21|                .or_else(|| widths.last().copied())
                                          ^1     ^1     ^1
 4382|     21|                .unwrap_or(1.0);
 4383|     21|            let halign = column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
 4384|     21|            let height = self.estimate_table_cell_height(style, ui, spans, width, halign, fallback);
 4385|     21|            max_height = max_height.max(height);
 4386|       |        }
 4387|     10|        max_height
 4388|     10|    }
 4389|       |
 4390|     24|    fn estimate_table_cell_height(
 4391|     24|        &self,
 4392|     24|        style: &egui::Style,
 4393|     24|        ui: &egui::Ui,
 4394|     24|        spans: &[InlineSpan],
 4395|     24|        width: f32,
 4396|     24|        halign: Align,
 4397|     24|        fallback: f32,
 4398|     24|    ) -> f32 {
 4399|     24|        if spans.is_empty() {
 4400|      1|            return fallback;
 4401|     23|        }
 4402|     23|        let fragments = self.cell_fragments(spans);
 4403|     23|        let mut total = 0.0;
 4404|     24|        for (idx, fragment) in fragments.into_iter().enumerate() {
                                             ^23       ^23         ^23
 4405|     24|            if idx > 0 {
 4406|      1|                total += 2.0;
 4407|     23|            }
 4408|     24|            match fragment {
 4409|     21|                CellFragment::Text(slice) => {
 4410|     21|                    let build = self.build_layout_job(style, slice, width, false, halign);
 4411|     21|                    let height = ui.fonts(|f| f.layout_job(build.job.clone()).size().y);
 4412|     21|                    total += height;
 4413|       |                }
 4414|      1|                CellFragment::Emoji(_) => {
 4415|      1|                    total += self.font_sizes.body * 1.2;
 4416|      1|                }
 4417|      2|                CellFragment::Image(span) => {
 4418|      2|                    total += self.estimate_table_image_height(ui, span, width);
 4419|      2|                }
 4420|       |            }
 4421|       |        }
 4422|     23|        total.max(fallback)
 4423|     24|    }
 4424|       |
 4425|      5|    fn estimate_table_image_height(
 4426|      5|        &self,
 4427|      5|        ui: &egui::Ui,
 4428|      5|        span: &InlineSpan,
 4429|      5|        available_w: f32,
 4430|      5|    ) -> f32 {
 4431|      5|        let InlineSpan::Image { src, title, .. } = span else {
                                              ^4   ^4
 4432|      1|            return self.font_sizes.body * 1.2;
 4433|       |        };
 4434|      4|        let resolved = self.resolve_image_path(src);
 4435|      4|        let (tw, th) = self
 4436|      4|            .get_or_load_image_texture(ui, &resolved)
 4437|      4|            .map(|(_, w, h)| (w as f32, h as f32))
                                            ^1        ^1
 4438|      4|            .unwrap_or((self.font_sizes.body * 12.0, self.font_sizes.body * 8.0));
 4439|      4|        let base_scale = self.ui_scale();
 4440|      4|        let scaled_w = tw * base_scale;
 4441|      4|        let scale = if scaled_w > available_w {
 4442|      3|            (available_w / tw).clamp(0.01, 4.0)
 4443|       |        } else {
 4444|      1|            base_scale
 4445|       |        };
 4446|      4|        let mut height = (th * scale).round();
 4447|      4|        if let Some(text) = title {
                                  ^3
 4448|      3|            if !text.is_empty() {
 4449|      2|                height += 2.0 + (self.font_sizes.body - 2.0).max(1.0);
 4450|      2|            }
                          ^1
 4451|      1|        }
 4452|      4|        height + 6.0
 4453|      5|    }
 4454|       |
 4455|    243|    fn row_height_fallback(&self) -> f32 {
 4456|    243|        self.font_sizes.body * 1.6
 4457|    243|    }
 4458|       |
 4459|     28|    fn row_height_hint(&self, table_id: u64, idx: usize) -> f32 {
 4460|     28|        let fallback = self.row_height_fallback();
 4461|     28|        self.table_metrics
 4462|     28|            .borrow()
 4463|     28|            .entry(table_id)
 4464|     28|            .and_then(|entry| entry.row(idx))
 4465|     28|            .map(|m| {
                                   ^2
 4466|      2|                if m.max_height > 0.0 {
 4467|      1|                    m.max_height
 4468|       |                } else {
 4469|      1|                    fallback
 4470|       |                }
 4471|      2|            })
 4472|     28|            .unwrap_or(fallback)
 4473|     28|    }
 4474|       |
 4475|     27|    fn update_row_height(&self, table_id: u64, idx: usize, height: f32) {
 4476|     27|        let clamped = height.max(self.row_height_fallback());
 4477|     27|        let mut metrics = self.table_metrics.borrow_mut();
 4478|     27|        let entry = metrics.entry_mut(table_id);
 4479|     27|        let row = entry.ensure_row(idx);
 4480|     27|        row.max_height = clamped;
 4481|     27|        row.dirty = false;
 4482|     27|    }
 4483|       |
 4484|     19|    fn update_header_height(&self, table_id: u64, height: f32) -> bool {
 4485|     19|        let mut metrics = self.table_metrics.borrow_mut();
 4486|     19|        let entry = metrics.entry_mut(table_id);
 4487|     19|        entry.update_header_height(height)
 4488|     19|    }
 4489|       |
 4490|     19|    fn begin_table_pass(&self, table_id: u64, total_rows: usize) {
 4491|     19|        let mut metrics = self.table_metrics.borrow_mut();
 4492|     19|        metrics.entry_mut(table_id).begin_pass(total_rows);
 4493|     19|    }
 4494|       |
 4495|     27|    fn note_row_rendered(&self, table_id: u64) {
 4496|     27|        let mut metrics = self.table_metrics.borrow_mut();
 4497|     27|        metrics.entry_mut(table_id).note_row_rendered();
 4498|     27|    }
 4499|       |
 4500|     20|    fn apply_persisted_widths(&self, table_id: u64, specs: &mut [ColumnSpec]) {
 4501|     20|        if specs.is_empty() {
 4502|      1|            return;
 4503|     19|        }
 4504|     19|        let mut metrics = self.table_metrics.borrow_mut();
 4505|     19|        let entry = metrics.entry_mut(table_id);
 4506|     55|        for spec in specs.iter_mut() {
                                  ^19   ^19
 4507|     55|            if let Some(width) = entry.persisted_width(spec.policy_hash) {
                                      ^2
 4508|      2|                spec.apply_preferred_width(width);
 4509|     53|            }
 4510|       |        }
 4511|     20|    }
 4512|       |
 4513|     32|    fn persist_resizable_widths(&self, table_id: u64, specs: &[ColumnSpec], widths: &[f32]) {
 4514|     32|        if specs.is_empty() || widths.is_empty() {
                                             ^30    ^30
 4515|      3|            return;
 4516|     29|        }
 4517|     29|        let mut metrics = self.table_metrics.borrow_mut();
 4518|     29|        let entry = metrics.entry_mut(table_id);
 4519|       |
 4520|       |        // Check if font size changed since last persist - if so, clear old widths
 4521|       |        // to prevent size mismatch after zoom changes. Skip persisting in this
 4522|       |        // frame so the next layout can compute fresh widths before we store them.
 4523|     29|        if entry.check_font_size_change(self.font_sizes.body) {
 4524|      1|            return;
 4525|     28|        }
 4526|       |
 4527|     64|        for (spec, width) in specs.iter().zip(widths.iter()) {
                                           ^28   ^28    ^28 ^28    ^28
 4528|     64|            if let ColumnPolicy::Resizable { .. } = spec.policy {
 4529|     29|                let stored = entry.persisted_width(spec.policy_hash).unwrap_or(-1.0);
 4530|     29|                if stored < 0.0 || (stored - width).abs() > 0.5 {
                                                 ^4
 4531|     26|                    entry.set_persisted_width(spec.policy_hash, *width);
 4532|     26|                }
                              ^3
 4533|     35|            }
 4534|       |        }
 4535|     32|    }
 4536|       |
 4537|     20|    fn record_resolved_widths(&self, table_id: u64, frame_id: u64, widths: &[f32]) -> WidthChange {
 4538|     20|        if widths.is_empty() {
 4539|      1|            return WidthChange::None;
 4540|     19|        }
 4541|     19|        let mut metrics = self.table_metrics.borrow_mut();
 4542|     19|        metrics.entry_mut(table_id).update_widths(widths, frame_id)
 4543|     20|    }
 4544|       |
 4545|     22|    fn handle_width_change(&self, ctx: &Context, table_id: u64, change: WidthChange) {
 4546|     22|        if matches!(change, WidthChange::Large) {
                         ^19
 4547|      3|            let frame_id = ctx.frame_nr();
 4548|      3|            let mut metrics = self.table_metrics.borrow_mut();
 4549|      3|            let entry = metrics.entry_mut(table_id);
 4550|      3|            if entry.last_discard_frame != Some(frame_id) {
 4551|      2|                ctx.request_repaint();
 4552|      2|                entry.last_discard_frame = Some(frame_id);
 4553|      2|            }
                          ^1
 4554|     19|        }
 4555|     22|    }
 4556|       |
 4557|       |    /// Paint vertical dividers between table columns, a horizontal header separator,
 4558|       |    /// and an outer border.
 4559|       |    ///
 4560|       |    /// # Arguments
 4561|       |    /// * `widths` - The actual allocated column widths from `TableBody::widths()`.
 4562|       |    ///   IMPORTANT: These must NOT be cell content widths from `ui.min_rect()`,
 4563|       |    ///   which would cause dividers to be misaligned.
 4564|       |    /// * `header_height` - The height of the header row. A horizontal separator is
 4565|       |    ///   drawn at this y-offset to visually separate header from body rows.
 4566|       |    #[allow(clippy::too_many_arguments)]
 4567|     23|    fn paint_table_dividers(
 4568|     23|        &self,
 4569|     23|        painter: &Painter,
 4570|     23|        visuals: &Visuals,
 4571|     23|        rect: egui::Rect,
 4572|     23|        clip_rect: egui::Rect,
 4573|     23|        widths: &[f32],
 4574|     23|        header_height: f32,
 4575|     23|        column_spacing: f32,
 4576|     23|    ) {
 4577|     23|        if widths.is_empty() {
 4578|      1|            return;
 4579|     22|        }
 4580|     22|        let separator_color = visuals
 4581|     22|            .widgets
 4582|     22|            .noninteractive
 4583|     22|            .bg_stroke
 4584|     22|            .color
 4585|     22|            .gamma_multiply(0.9);
 4586|     22|        let separator_stroke = Stroke::new(1.0, separator_color);
 4587|     22|        let border_stroke = visuals.window_stroke();
 4588|       |        // Expand clip_rect to include the full table rect so borders aren't clipped.
 4589|       |        // The cell clip_rect may not include the outer border area.
 4590|     22|        let expanded_clip = clip_rect.union(rect);
 4591|     22|        let painter = painter.with_clip_rect(expanded_clip);
 4592|       |
 4593|       |        // Draw vertical dividers between columns
 4594|     22|        if widths.len() > 1 {
 4595|     20|            let mut x = rect.left();
 4596|     39|            for (idx, width) in widths
                                              ^20
 4597|     20|                .iter()
 4598|     20|                .take(widths.len().saturating_sub(1))
 4599|     20|                .enumerate()
 4600|     39|            {
 4601|     39|                x += *width;
 4602|     39|                let divider_x = x + column_spacing * (idx as f32 + 0.5);
 4603|     39|                let x_pos = (divider_x.round() + 0.5).clamp(rect.left(), rect.right());
 4604|     39|                painter.vline(x_pos, rect.y_range(), separator_stroke);
 4605|     39|            }
 4606|      2|        }
 4607|       |
 4608|       |        // Draw horizontal separator below header row
 4609|     22|        if header_height > 0.0 {
 4610|     21|            let header_y = rect.top() + header_height;
 4611|     21|            if header_y < rect.bottom() {
 4612|     20|                painter.hline(rect.x_range(), header_y.round() + 0.5, separator_stroke);
 4613|     20|            }
                          ^1
 4614|      1|        }
 4615|       |
 4616|       |        // Draw outer border
 4617|     22|        painter.rect_stroke(rect, 0.0, border_stroke);
 4618|     23|    }
 4619|       |
 4620|       |    #[allow(clippy::too_many_arguments)]
 4621|    132|    fn render_overhauled_cell(
 4622|    132|        &self,
 4623|    132|        ui: &mut egui::Ui,
 4624|    132|        spans: &[InlineSpan],
 4625|    132|        width: f32,
 4626|    132|        is_header: bool,
 4627|    132|        row_idx: Option<usize>,
 4628|    132|        col_idx: usize,
 4629|    132|        halign: Align,
 4630|    132|    ) -> f32 {
 4631|    132|        let fallback_height = self.row_height_fallback();
 4632|    132|        let fragments = self.cell_fragments(spans);
 4633|    132|        let inner = ui.allocate_ui_with_layout(
 4634|    132|            Vec2::new(width, 0.0),
 4635|    132|            egui::Layout::top_down(halign),
 4636|    132|            |ui| {
 4637|    132|                ui.set_width(width);
 4638|    132|                ui.set_max_width(width);
 4639|    132|                ui.spacing_mut().item_spacing = egui::vec2(4.0, 2.0);
 4640|    132|                if fragments.is_empty() {
 4641|      4|                    ui.allocate_exact_size(
 4642|      4|                        Vec2::new(width, self.font_sizes.body * 1.2),
 4643|      4|                        egui::Sense::hover(),
 4644|       |                    );
 4645|      4|                    return;
 4646|    128|                }
 4647|    257|                for fragment in fragments {
                                  ^129
 4648|    129|                    match fragment {
 4649|    125|                        CellFragment::Text(slice) => {
 4650|    125|                            let build = self.cached_layout_job(
 4651|    125|                                ui.style(),
 4652|    125|                                row_idx,
 4653|    125|                                col_idx,
 4654|    125|                                slice,
 4655|    125|                                width,
 4656|    125|                                is_header,
 4657|    125|                                halign,
 4658|    125|                            );
 4659|    125|                            self.paint_table_text_job(ui, width, build);
 4660|    125|                        }
 4661|      1|                        CellFragment::Emoji(key) => {
 4662|      1|                            self.render_table_emoji(ui, &key);
 4663|      1|                        }
 4664|      3|                        CellFragment::Image(span) => {
 4665|      3|                            self.render_inline_span(ui, span, None, Some(is_header));
 4666|      3|                        }
 4667|       |                    }
 4668|       |                }
 4669|    132|            },
 4670|       |        );
 4671|    132|        inner.response.rect.height().max(fallback_height)
 4672|    132|    }
 4673|       |
 4674|    133|    fn paint_table_text_job(
 4675|    133|        &self,
 4676|    133|        ui: &mut egui::Ui,
 4677|    133|        width: f32,
 4678|    133|        build: LayoutJobBuild,
 4679|    133|    ) -> egui::Response {
 4680|    133|        let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
 4681|    133|        let height = galley.size().y;
 4682|    133|        let (rect, mut response) =
 4683|    133|            ui.allocate_exact_size(Vec2::new(width, height), egui::Sense::click());
 4684|    133|        let text_color = ui.visuals().text_color();
 4685|    133|        let text_origin = Self::aligned_text_origin(rect, &galley, build.job.halign);
 4686|    133|        ui.painter_at(rect)
 4687|    133|            .galley(text_origin, galley.clone(), text_color);
 4688|    133|        if galley.rows.len() > 1 || galley.size().x > width + 0.5 {
                                                  ^115
 4689|     19|            response = response.on_hover_text(build.plain_text.clone());
 4690|    114|        }
 4691|       |        #[cfg(test)]
 4692|    133|        self.render_cell_context_menu(ui, &build.plain_text);
 4693|       |        #[cfg(not(test))]
 4694|       |        response.context_menu(|ui| {
 4695|       |            self.render_cell_context_menu(ui, &build.plain_text);
 4696|       |        });
 4697|       |
 4698|    133|        if let Some(link) = self.link_at_pointer(&response, &galley, &build, text_origin) {
                                  ^3
 4699|      3|            ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
 4700|      3|            response = response.on_hover_text(link.url.clone());
 4701|      3|            if response.clicked() {
 4702|      2|                self.trigger_link(&link.url);
 4703|      2|            }
                          ^1
 4704|    130|        }
 4705|       |
 4706|    133|        response
 4707|    133|    }
 4708|       |
 4709|       |    #[allow(clippy::too_many_arguments)]
 4710|    176|    fn cached_layout_job(
 4711|    176|        &self,
 4712|    176|        style: &egui::Style,
 4713|    176|        row_idx: Option<usize>,
 4714|    176|        col_idx: usize,
 4715|    176|        spans: &[InlineSpan],
 4716|    176|        width: f32,
 4717|    176|        is_header: bool,
 4718|    176|        halign: Align,
 4719|    176|    ) -> LayoutJobBuild {
 4720|    176|        let highlight_hash = self
 4721|    176|            .highlight_phrase
 4722|    176|            .borrow()
 4723|    176|            .as_ref()
 4724|    176|            .map(|s| Self::hash_str(s))
                                   ^8             ^8
 4725|    176|            .unwrap_or(0);
 4726|    176|        let content_hash = Self::hash_inline_spans(spans);
 4727|    176|        let text_color = style.visuals.text_color().to_array();
 4728|    176|        let key = CellLayoutKey {
 4729|    176|            row: row_idx,
 4730|    176|            col: col_idx,
 4731|    176|            width: width.round() as u32,
 4732|    176|            align: Self::align_to_u8(halign),
 4733|    176|            strong: is_header,
 4734|    176|            text_color,
 4735|    176|            highlight_hash,
 4736|    176|            content_hash,
 4737|    176|        };
 4738|    176|        if let Some(build) = self.table_layout_cache.borrow_mut().get(&key) {
                                  ^13
 4739|     13|            return build;
 4740|    163|        }
 4741|    163|        let build = self.build_layout_job(style, spans, width, is_header, halign);
 4742|    163|        self.table_layout_cache
 4743|    163|            .borrow_mut()
 4744|    163|            .insert(key, build.clone());
 4745|    163|        build
 4746|    176|    }
 4747|       |
 4748|    136|    fn link_at_pointer<'a>(
 4749|    136|        &self,
 4750|    136|        response: &egui::Response,
 4751|    136|        galley: &Arc<Galley>,
 4752|    136|        build: &'a LayoutJobBuild,
 4753|    136|        text_origin: egui::Pos2,
 4754|    136|    ) -> Option<&'a LinkRange> {
 4755|    136|        let pointer = response.hover_pos()?;
                          ^5                            ^131
 4756|      5|        let text_rect = galley.rect.translate(text_origin.to_vec2());
 4757|      5|        if !text_rect.contains(pointer) {
 4758|      1|            return None;
 4759|      4|        }
 4760|      4|        let local = pointer - text_origin;
 4761|      4|        let cursor = galley.cursor_from_pos(local);
 4762|      4|        let idx = cursor.ccursor.index;
 4763|      4|        build
 4764|      4|            .link_ranges
 4765|      4|            .iter()
 4766|      4|            .find(|range| range.char_range.contains(&idx))
 4767|    136|    }
 4768|       |
 4769|    142|    fn aligned_text_origin(rect: egui::Rect, galley: &Galley, halign: Align) -> egui::Pos2 {
 4770|    142|        let galley_rect = galley.rect;
 4771|    142|        let x = if halign == Align::RIGHT {
 4772|      5|            rect.right() - galley_rect.right()
 4773|    137|        } else if halign == Align::Center {
 4774|      5|            rect.center().x - galley_rect.center().x
 4775|       |        } else {
 4776|    132|            rect.left() - galley_rect.left()
 4777|       |        };
 4778|    142|        egui::pos2(x, rect.top() - galley_rect.top())
 4779|    142|    }
 4780|       |
 4781|      2|    fn render_table_emoji(&self, ui: &mut egui::Ui, emoji: &str) {
 4782|      2|        let handle = self.get_or_make_emoji_texture(ui, emoji);
 4783|      2|        let size = self.font_sizes.body * 1.2;
 4784|      2|        ui.add(
 4785|      2|            egui::Image::new(&handle)
 4786|      2|                .max_size(Vec2::splat(size))
 4787|      2|                .sense(egui::Sense::hover()),
 4788|       |        );
 4789|      2|    }
 4790|       |
 4791|       |    #[cfg(test)]
 4792|      8|    fn resolve_table_widths(available: f32, mins: &[f32], desired: &[f32]) -> Vec<f32> {
 4793|      8|        debug_assert_eq!(mins.len(), desired.len());
 4794|      8|        if mins.is_empty() {
 4795|      1|            return Vec::new();
 4796|      7|        }
 4797|      7|        let clamped_available = available.max(1.0);
 4798|      7|        let desired_total: f32 = desired.iter().sum();
 4799|      7|        let min_total: f32 = mins.iter().sum();
 4800|       |
 4801|      7|        let widths = if min_total >= clamped_available {
 4802|      2|            mins.iter()
 4803|      6|                .map(|m| m * (clamped_available / min_total))
                               ^2
 4804|      2|                .collect()
 4805|      5|        } else if desired_total <= clamped_available {
 4806|      3|            let slack = desired_total - min_total;
 4807|      3|            if slack <= f32::EPSILON {
 4808|      2|                let bonus = (clamped_available - min_total) / mins.len() as f32;
 4809|      4|                mins.iter().map(|m| m + bonus).collect()
                              ^2   ^2     ^2                 ^2
 4810|       |            } else {
 4811|      1|                desired.to_vec()
 4812|       |            }
 4813|       |        } else {
 4814|      2|            let mut widths = mins.to_vec();
 4815|      2|            let extra = clamped_available - min_total;
 4816|      2|            let slack: Vec<f32> = desired
 4817|      2|                .iter()
 4818|      2|                .zip(mins.iter())
 4819|      6|                .map(|(d, m)| (d - m).max(0.0))
                               ^2
 4820|      2|                .collect();
 4821|      2|            let total_slack: f32 = slack.iter().sum();
 4822|      6|            for (w, s) in widths.iter_mut().zip(slack.iter()) {
                                        ^2                ^2  ^2
 4823|      6|                *w += extra * (*s / total_slack);
 4824|      6|            }
 4825|      2|            widths
 4826|       |        };
 4827|       |
 4828|      7|        widths
 4829|      8|    }
 4830|       |
 4831|       |    /// Open URL in default browser
 4832|       |    #[cfg(not(test))]
 4833|       |    fn open_url(&self, url: &str) {
 4834|       |        if let Err(e) = webbrowser::open(url) {
 4835|       |            eprintln!("Failed to open URL {}: {}", url, e);
 4836|       |        }
 4837|       |    }
 4838|       |
 4839|       |    #[cfg(test)]
 4840|      5|    fn open_url(&self, _url: &str) {}
 4841|       |
 4842|     12|    pub(crate) fn trigger_link(&self, url: &str) {
 4843|     12|        if let Some(fragment) = Self::extract_fragment(url) {
                                  ^6
 4844|      6|            *self.pending_anchor.borrow_mut() = Some(fragment);
 4845|      6|        } else if Self::is_allowed_scheme(url) {
 4846|      5|            self.open_url(url);
 4847|      5|        } else {
 4848|      1|            eprintln!("Blocked link with unsupported scheme: {}", url);
 4849|      1|        }
 4850|     12|    }
 4851|       |
 4852|     10|    fn is_allowed_scheme(url: &str) -> bool {
 4853|     10|        url.starts_with("http://") || url.starts_with("https://") || url.starts_with("mailto:")
                                                    ^9  ^9                         ^4  ^4
 4854|     10|    }
 4855|       |
 4856|       |    /// Consume and return the last clicked internal anchor, if any
 4857|     26|    pub fn take_pending_anchor(&self) -> Option<String> {
 4858|     26|        self.pending_anchor.borrow_mut().take()
 4859|     26|    }
 4860|       |
 4861|       |    /// Lookup a header rect by its id (slug)
 4862|      3|    pub fn header_rect_for(&self, id: &str) -> Option<egui::Rect> {
 4863|      3|        self.header_rects.borrow().get(id).copied()
 4864|      3|    }
 4865|       |
 4866|       |    /// Lookup the rect for the n-th top-level element rendered in the last frame
 4867|     14|    pub fn element_rect_at(&self, index: usize) -> Option<egui::Rect> {
 4868|     14|        self.element_rects.borrow().get(index).copied()
 4869|     14|    }
 4870|       |
 4871|     19|    pub fn layout_signature(&self) -> u64 {
 4872|     19|        let rects = self.element_rects.borrow();
 4873|     19|        let mut h = DefaultHasher::new();
 4874|     19|        rects.len().hash(&mut h);
 4875|     67|        for rect in rects.iter() {
                                  ^19   ^19
 4876|     67|            let min_x = (rect.min.x * 2.0).round() as i32;
 4877|     67|            let min_y = (rect.min.y * 2.0).round() as i32;
 4878|     67|            let max_x = (rect.max.x * 2.0).round() as i32;
 4879|     67|            let max_y = (rect.max.y * 2.0).round() as i32;
 4880|     67|            (min_x, min_y, max_x, max_y).hash(&mut h);
 4881|     67|        }
 4882|     19|        h.finish()
 4883|     19|    }
 4884|       |
 4885|     10|    pub fn has_pending_renders(&self) -> bool {
 4886|     10|        self.mermaid.has_pending() || !self.image_pending.borrow().is_empty()
                                                    ^9
 4887|     10|    }
 4888|       |
 4889|       |    /// Set or clear the highlight phrase (case-insensitive)
 4890|     29|    pub fn set_highlight_phrase(&self, phrase: Option<&str>) {
 4891|     29|        let normalized = phrase
 4892|     29|            .map(|p| p.case_fold().nfkc().collect::<String>())
                                   ^9^9          ^9     ^9
 4893|     29|            .filter(|value| !value.is_empty());
                                           ^9    ^9
 4894|       |        {
 4895|     29|            let mut current = self.highlight_phrase.borrow_mut();
 4896|     29|            if *current == normalized {
 4897|     21|                return;
 4898|      8|            }
 4899|      8|            *current = normalized;
 4900|       |        }
 4901|      8|        self.table_layout_cache.borrow_mut().clear();
 4902|     29|    }
 4903|       |
 4904|    258|    pub fn clear_table_layout_cache(&self) {
 4905|    258|        self.table_layout_cache.borrow_mut().clear();
 4906|    258|        self.table_metrics.borrow_mut().clear();
 4907|    258|        self.column_stats_cache.borrow_mut().clear();
 4908|    258|    }
 4909|       |
 4910|      4|    pub fn table_layout_cache_stats(&self) -> (u64, u64) {
 4911|      4|        self.table_layout_cache.borrow().stats()
 4912|      4|    }
 4913|       |
 4914|      2|    pub fn table_render_stats(&self) -> (usize, usize) {
 4915|      2|        self.table_metrics.borrow().totals()
 4916|      2|    }
 4917|       |
 4918|       |    /// Get a plain-text representation of a markdown element (for search)
 4919|     55|    pub fn element_plain_text(element: &MarkdownElement) -> String {
 4920|     55|        match element {
 4921|     45|            MarkdownElement::Paragraph(spans) => Self::spans_plain_text(spans),
 4922|      1|            MarkdownElement::Header { spans, .. } => Self::spans_plain_text(spans),
 4923|      1|            MarkdownElement::CodeBlock { text, .. } => text.clone(),
 4924|      2|            MarkdownElement::List { items, .. } => {
 4925|      2|                let mut out = String::new();
 4926|      4|                for item in items {
                                  ^2
 4927|      5|                    for block in &item.blocks {
                                      ^3
 4928|      3|                        if !out.is_empty() {
 4929|      1|                            out.push('\n');
 4930|      2|                        }
 4931|      3|                        out.push_str(&Self::element_plain_text(block));
 4932|       |                    }
 4933|       |                }
 4934|      2|                out
 4935|       |            }
 4936|      2|            MarkdownElement::Quote { blocks, .. } => {
 4937|      2|                let mut out = String::new();
 4938|      5|                for block in blocks {
                                  ^3
 4939|      3|                    if !out.is_empty() {
 4940|      1|                        out.push('\n');
 4941|      2|                    }
 4942|      3|                    out.push_str(&Self::element_plain_text(block));
 4943|       |                }
 4944|      2|                out
 4945|       |            }
 4946|      1|            MarkdownElement::HorizontalRule => String::from("---"),
 4947|       |            MarkdownElement::Table {
 4948|      3|                headers,
 4949|      3|                rows,
 4950|       |                alignments: _,
 4951|       |            } => {
 4952|      3|                let mut out = String::new();
 4953|      7|                for h in headers {
                                  ^4
 4954|      4|                    if !out.is_empty() {
 4955|      1|                        out.push(' ');
 4956|      3|                    }
 4957|      4|                    out.push_str(&Self::spans_plain_text(h));
 4958|       |                }
 4959|      6|                for row in rows {
                                  ^3
 4960|      7|                    for cell in row {
                                      ^4
 4961|      4|                        out.push(' ');
 4962|      4|                        out.push_str(&Self::spans_plain_text(cell));
 4963|      4|                    }
 4964|       |                }
 4965|      3|                out
 4966|       |            }
 4967|       |        }
 4968|     55|    }
 4969|       |
 4970|       |    /// Set the base directory for resolving relative image paths
 4971|     74|    pub fn set_base_dir(&self, dir: Option<&Path>) {
 4972|     74|        if let Some(d) = dir {
                                  ^34
 4973|     34|            self.base_dir.borrow_mut().replace(d.to_path_buf());
 4974|     40|        } else {
 4975|     40|            self.base_dir.borrow_mut().take();
 4976|     40|        }
 4977|     74|    }
 4978|       |
 4979|     38|    fn poll_image_results(&self, ctx: &egui::Context) -> bool {
 4980|     38|        let mut changed = false;
 4981|     44|        while let Ok(result) = self.image_result_rx.try_recv() {
                                   ^6
 4982|      6|            match result {
 4983|       |                ImageLoadResult::Loaded {
 4984|      5|                    key,
 4985|      5|                    image,
 4986|      5|                    size,
 4987|      5|                    modified,
 4988|      5|                } => {
 4989|      5|                    let tex =
 4990|      5|                        ctx.load_texture(format!("img:{key}"), image, egui::TextureOptions::LINEAR);
 4991|      5|                    self.store_image_texture(&key, tex.clone(), size, modified);
 4992|      5|                    self.image_failures.borrow_mut().remove(&key);
 4993|      5|                    self.image_pending.borrow_mut().remove(&key);
 4994|      5|                    changed = true;
 4995|      5|                }
 4996|      1|                ImageLoadResult::Failed { key } => {
 4997|      1|                    self.image_pending.borrow_mut().remove(&key);
 4998|      1|                    self.note_image_failure(&key);
 4999|      1|                }
 5000|       |            }
 5001|       |        }
 5002|     38|        if changed {
 5003|      5|            ctx.request_repaint();
 5004|     33|        }
 5005|     38|        changed
 5006|     38|    }
 5007|       |
 5008|     14|    fn enqueue_image_job(&self, request: ImageLoadRequest) -> Result<(), ()> {
 5009|     14|        match self.image_job_tx.try_send(request) {
 5010|     12|            Ok(()) => Ok(()),
 5011|      1|            Err(TrySendError::Full(_)) => Err(()),
 5012|      1|            Err(TrySendError::Disconnected(_)) => Err(()),
 5013|       |        }
 5014|     14|    }
 5015|       |
 5016|     22|    fn should_retry_image(&self, key: &str) -> bool {
 5017|     22|        let mut failures = self.image_failures.borrow_mut();
 5018|     22|        if let Some(failure) = failures.get(key) {
                                  ^3
 5019|      3|            if failure.last_attempt.elapsed() < IMAGE_FAILURE_BACKOFF {
 5020|      2|                return false;
 5021|      1|            }
 5022|     19|        }
 5023|     20|        failures.remove(key);
 5024|     20|        true
 5025|     22|    }
 5026|       |
 5027|      8|    fn note_image_failure(&self, key: &str) {
 5028|      8|        self.image_failures.borrow_mut().insert(
 5029|      8|            key.to_string(),
 5030|      8|            ImageFailure {
 5031|      8|                last_attempt: Instant::now(),
 5032|      8|            },
 5033|      8|        );
 5034|      8|    }
 5035|       |
 5036|     31|    fn resolve_image_path(&self, src: &str) -> String {
 5037|     31|        if src.starts_with("http://") || src.starts_with("https://") || src.starts_with("data:") {
                                                       ^29 ^29                        ^26 ^26
 5038|       |            // Keep as-is; we don't fetch remote or parse data URIs yet
 5039|      7|            return src.to_string();
 5040|     24|        }
 5041|     24|        let p = Path::new(src);
 5042|     24|        if p.is_absolute() {
 5043|      1|            return src.to_string();
 5044|     23|        }
 5045|     23|        if let Some(base) = self.base_dir.borrow().as_ref() {
                                  ^5
 5046|      5|            let joined = base.join(p);
 5047|      5|            return joined.to_string_lossy().into_owned();
 5048|     18|        }
 5049|     18|        src.to_string()
 5050|     31|    }
 5051|       |
 5052|     52|    fn get_or_load_image_texture(
 5053|     52|        &self,
 5054|     52|        _ui: &egui::Ui,
 5055|     52|        resolved_src: &str,
 5056|     52|    ) -> Option<(egui::TextureHandle, u32, u32)> {
 5057|       |        // Reject remote for now
 5058|     52|        if resolved_src.starts_with("http://") || resolved_src.starts_with("https://") {
                                                                ^50          ^50
 5059|      7|            return None;
 5060|     45|        }
 5061|       |
 5062|     45|        let path = Path::new(resolved_src);
 5063|     45|        let embedded = Self::embedded_image_bytes(resolved_src);
 5064|       |
 5065|       |        {
 5066|     45|            let mut cache = self.image_textures.borrow_mut();
 5067|     45|            if let Some(entry) = cache.get(resolved_src) {
                                      ^16
 5068|     16|                let stale = if embedded.is_some() {
 5069|      5|                    false
 5070|       |                } else {
 5071|     11|                    Self::image_source_stale(entry.modified, path)
 5072|       |                };
 5073|     16|                if !stale {
 5074|     15|                    return Some((entry.texture.clone(), entry.size[0], entry.size[1]));
 5075|      1|                }
 5076|      1|                cache.remove(resolved_src);
 5077|     29|            }
 5078|       |        }
 5079|       |
 5080|     30|        if self.image_pending.borrow().contains(resolved_src) {
 5081|     10|            return None;
 5082|     20|        }
 5083|       |
 5084|     20|        if !self.should_retry_image(resolved_src) {
 5085|      1|            return None;
 5086|     19|        }
 5087|       |
 5088|     19|        let source = if let Some(bytes) = embedded {
                          ^13                  ^8
 5089|      8|            ImageLoadSource::Embedded(bytes)
 5090|       |        } else {
 5091|     11|            if !path.exists() {
 5092|      6|                self.note_image_failure(resolved_src);
 5093|      6|                return None;
 5094|      5|            }
 5095|      5|            ImageLoadSource::File(path.to_path_buf())
 5096|       |        };
 5097|       |
 5098|     13|        let request = ImageLoadRequest {
 5099|     13|            key: resolved_src.to_string(),
 5100|     13|            source,
 5101|     13|        };
 5102|     13|        if self.enqueue_image_job(request).is_ok() {
 5103|     12|            self.image_pending
 5104|     12|                .borrow_mut()
 5105|     12|                .insert(resolved_src.to_string());
 5106|     12|        }
                      ^1
 5107|     13|        None
 5108|     52|    }
 5109|       |
 5110|     15|    fn disk_image_timestamp(path: &Path) -> Option<SystemTime> {
 5111|     15|        std::fs::metadata(path).ok()?.modified().ok()
                                                  ^1^14        ^14
 5112|     15|    }
 5113|       |
 5114|     11|    fn image_source_stale_with_timestamp(
 5115|     11|        cached_modified: Option<SystemTime>,
 5116|     11|        current: Option<SystemTime>,
 5117|     11|    ) -> bool {
 5118|     11|        match (cached_modified, current) {
 5119|      8|            (Some(prev), Some(cur)) => prev != cur,
 5120|      1|            (Some(_), None) => true,
 5121|      1|            (None, Some(_)) => true,
 5122|      1|            (None, None) => false,
 5123|       |        }
 5124|     11|    }
 5125|       |
 5126|     14|    fn image_source_stale(cached_modified: Option<SystemTime>, path: &Path) -> bool {
 5127|     14|        if !path.exists() {
 5128|      6|            return cached_modified.is_some();
 5129|      8|        }
 5130|      8|        let current = Self::disk_image_timestamp(path);
 5131|      8|        Self::image_source_stale_with_timestamp(cached_modified, current)
 5132|     14|    }
 5133|       |
 5134|      7|    fn store_image_texture(
 5135|      7|        &self,
 5136|      7|        key: &str,
 5137|      7|        texture: egui::TextureHandle,
 5138|      7|        size: [u32; 2],
 5139|      7|        modified: Option<SystemTime>,
 5140|      7|    ) {
 5141|      7|        self.image_textures.borrow_mut().insert(
 5142|      7|            key.to_string(),
 5143|      7|            ImageCacheEntry {
 5144|      7|                texture,
 5145|      7|                size,
 5146|      7|                modified,
 5147|      7|            },
 5148|      7|        );
 5149|      7|    }
 5150|       |
 5151|       |    /// Return embedded image bytes for known assets used in sample files
 5152|     45|    fn embedded_image_bytes(path: &str) -> Option<&'static [u8]> {
 5153|     45|        match path.replace('\\', "/").as_str() {
 5154|       |            // Smiley PNG
 5155|     45|            "assets/emoji/1f600.png" => Some(include_bytes!("../assets/emoji/1f600.png")),
                                                      ^16
 5156|       |            // SVG logo and WEBP sample used by images.md
 5157|     29|            "assets/samples/logo.svg" => Some(include_bytes!("../assets/samples/logo.svg")),
                                                       ^2
 5158|     27|            "assets/samples/webp_sample.webp" => {
 5159|      1|                Some(include_bytes!("../assets/samples/webp_sample.webp"))
 5160|       |            }
 5161|     26|            _ => None,
 5162|       |        }
 5163|     45|    }
 5164|       |
 5165|       |    /// Find syntax definition for a given language name
 5166|       |    /// Maps common language names to their syntax definitions
 5167|     54|    fn find_syntax_for_language(&self, lang: &str) -> Option<&syntect::parsing::SyntaxReference> {
 5168|       |        // Create a mapping of common language names to their syntect equivalents
 5169|     54|        let lang_lower = lang.to_lowercase();
 5170|       |
 5171|       |        // Try direct name match first
 5172|     54|        if let Some(syntax) = self.syntax_set.find_syntax_by_name(&lang_lower) {
                                  ^1
 5173|      1|            return Some(syntax);
 5174|     53|        }
 5175|       |
 5176|       |        // Try extension-based matching
 5177|     53|        if let Some(syntax) = self.syntax_set.find_syntax_by_extension(&lang_lower) {
                                  ^9
 5178|      9|            return Some(syntax);
 5179|     44|        }
 5180|       |
 5181|       |        // Handle common language mappings
 5182|     44|        let mapped_lang = match lang_lower.as_str() {
 5183|     44|            "rust" => "rs",
                                    ^8
 5184|     36|            "python" => "py",
                                      ^2
 5185|     34|            "javascript" => "js",
                                          ^2
 5186|     32|            "typescript" => "ts",
                                          ^2
 5187|     30|            "c++" | "cpp" => "cpp",
                                  ^29      ^2
 5188|     28|            "c#" | "csharp" => "cs",
                                 ^26         ^4
 5189|     24|            "shell" | "bash" => "sh",
                                    ^21       ^4
 5190|     20|            "powershell" => "ps1",
                                          ^3
 5191|     17|            "yaml" => "yml",
                                    ^1
 5192|     16|            "markdown" => "md",
                                        ^1
 5193|     15|            "html" => "html",
                                    ^1
 5194|     14|            "css" => "css",
                                   ^1
 5195|     13|            "java" => "java",
                                    ^1
 5196|     12|            "go" => "go",
                                  ^1
 5197|     11|            "php" => "php",
                                   ^1
 5198|     10|            "ruby" => "rb",
                                    ^1
 5199|      9|            "xml" => "xml",
                                   ^1
 5200|      8|            "json" => "json",
                                    ^1
 5201|      7|            "sql" => "sql",
                                   ^1
 5202|      6|            "toml" => "toml",
                                    ^2
 5203|      4|            _ => &lang_lower,
 5204|       |        };
 5205|       |
 5206|       |        // Try mapped extension
 5207|     44|        self.syntax_set
 5208|     44|            .find_syntax_by_extension(mapped_lang)
 5209|     44|            .or_else(|| self.syntax_set.find_syntax_by_name(mapped_lang))
                                      ^31             ^31                 ^31
 5210|     54|    }
 5211|       |
 5212|       |    /// Zoom in (increase font sizes)
 5213|      7|    pub fn zoom_in(&mut self) {
 5214|      7|        self.font_sizes.body = (self.font_sizes.body * 1.1).min(32.0);
 5215|      7|        self.font_sizes.h1 = (self.font_sizes.h1 * 1.1).min(48.0);
 5216|      7|        self.font_sizes.h2 = (self.font_sizes.h2 * 1.1).min(42.0);
 5217|      7|        self.font_sizes.h3 = (self.font_sizes.h3 * 1.1).min(36.0);
 5218|      7|        self.font_sizes.h4 = (self.font_sizes.h4 * 1.1).min(32.0);
 5219|      7|        self.font_sizes.h5 = (self.font_sizes.h5 * 1.1).min(28.0);
 5220|      7|        self.font_sizes.h6 = (self.font_sizes.h6 * 1.1).min(24.0);
 5221|      7|        self.font_sizes.code = (self.font_sizes.code * 1.1).min(20.0);
 5222|      7|        self.clear_table_layout_cache();
 5223|      7|    }
 5224|       |
 5225|       |    /// Zoom out (decrease font sizes)
 5226|      7|    pub fn zoom_out(&mut self) {
 5227|      7|        self.font_sizes.body = (self.font_sizes.body * 0.9).max(8.0);
 5228|      7|        self.font_sizes.h1 = (self.font_sizes.h1 * 0.9).max(16.0);
 5229|      7|        self.font_sizes.h2 = (self.font_sizes.h2 * 0.9).max(14.0);
 5230|      7|        self.font_sizes.h3 = (self.font_sizes.h3 * 0.9).max(12.0);
 5231|      7|        self.font_sizes.h4 = (self.font_sizes.h4 * 0.9).max(11.0);
 5232|      7|        self.font_sizes.h5 = (self.font_sizes.h5 * 0.9).max(10.0);
 5233|      7|        self.font_sizes.h6 = (self.font_sizes.h6 * 0.9).max(9.0);
 5234|      7|        self.font_sizes.code = (self.font_sizes.code * 0.9).max(8.0);
 5235|      7|        self.clear_table_layout_cache();
 5236|      7|    }
 5237|       |
 5238|       |    /// Reset zoom to default
 5239|      5|    pub fn reset_zoom(&mut self) {
 5240|      5|        self.font_sizes = FontSizes::default();
 5241|      5|        self.clear_table_layout_cache();
 5242|      5|    }
 5243|       |
 5244|       |    /// Set zoom scale relative to default font sizes.
 5245|      4|    pub fn set_zoom_scale(&mut self, scale: f32) {
 5246|      4|        let scale = scale.clamp(0.5, 4.0);
 5247|      4|        let default = FontSizes::default();
 5248|      4|        self.font_sizes.body = (default.body * scale).clamp(8.0, 32.0);
 5249|      4|        self.font_sizes.h1 = (default.h1 * scale).clamp(16.0, 48.0);
 5250|      4|        self.font_sizes.h2 = (default.h2 * scale).clamp(14.0, 42.0);
 5251|      4|        self.font_sizes.h3 = (default.h3 * scale).clamp(12.0, 36.0);
 5252|      4|        self.font_sizes.h4 = (default.h4 * scale).clamp(11.0, 32.0);
 5253|      4|        self.font_sizes.h5 = (default.h5 * scale).clamp(10.0, 28.0);
 5254|      4|        self.font_sizes.h6 = (default.h6 * scale).clamp(9.0, 24.0);
 5255|      4|        self.font_sizes.code = (default.code * scale).clamp(8.0, 20.0);
 5256|      4|        self.clear_table_layout_cache();
 5257|      4|    }
 5258|       |}
 5259|       |
 5260|       |#[cfg(test)]
 5261|       |#[cfg_attr(coverage_nightly, coverage(off))]
 5262|       |mod tests {
 5263|       |    use super::*;
 5264|       |    use crate::SAMPLE_FILES;
 5265|       |    use image::codecs::png::PngEncoder;
 5266|       |    use image::ColorType;
 5267|       |    use image::ImageEncoder;
 5268|       |    use std::env;
 5269|       |    use std::fs;
 5270|       |    use std::str::FromStr;
 5271|       |    use std::sync::Mutex;
 5272|       |    use std::time::Duration;
 5273|       |    use syntect::highlighting::{Color, FontStyle, ScopeSelectors, StyleModifier, ThemeItem};
 5274|       |    use syntect::parsing::SyntaxDefinition;
 5275|       |    use tempfile::tempdir;
 5276|       |
 5277|       |    static MERMAID_ENV_LOCK: Mutex<()> = Mutex::new(());
 5278|       |
 5279|       |    struct EnvVarGuard {
 5280|       |        key: &'static str,
 5281|       |        previous: Option<String>,
 5282|       |        _lock: std::sync::MutexGuard<'static, ()>,
 5283|       |    }
 5284|       |
 5285|       |    impl EnvVarGuard {
 5286|       |        fn set(key: &'static str, value: &str) -> Self {
 5287|       |            let lock = MERMAID_ENV_LOCK.lock().expect("lock mermaid env");
 5288|       |            let previous = env::var(key).ok();
 5289|       |            env::set_var(key, value);
 5290|       |            Self {
 5291|       |                key,
 5292|       |                previous,
 5293|       |                _lock: lock,
 5294|       |            }
 5295|       |        }
 5296|       |    }
 5297|       |
 5298|       |    impl Drop for EnvVarGuard {
 5299|       |        fn drop(&mut self) {
 5300|       |            if let Some(prev) = &self.previous {
 5301|       |                env::set_var(self.key, prev);
 5302|       |            } else {
 5303|       |                env::remove_var(self.key);
 5304|       |            }
 5305|       |        }
 5306|       |    }
 5307|       |
 5308|       |    #[test]
 5309|       |    fn test_spawn_image_loader_handles_error_path() {
 5310|       |        MarkdownRenderer::force_thread_spawn_error_for_test();
 5311|       |        let (_job_tx, job_rx) = crossbeam_channel::unbounded();
 5312|       |        let (result_tx, _result_rx) = crossbeam_channel::unbounded();
 5313|       |        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);
 5314|       |    }
 5315|       |
 5316|       |    struct ForcedRenderActions {
 5317|       |        actions: Vec<&'static str>,
 5318|       |    }
 5319|       |
 5320|       |    impl ForcedRenderActions {
 5321|       |        fn new(actions: &[&'static str]) -> Self {
 5322|       |            FORCED_RENDER_ACTIONS.with(|set| {
 5323|       |                let mut set = set.borrow_mut();
 5324|       |                for action in actions {
 5325|       |                    set.insert(*action);
 5326|       |                }
 5327|       |            });
 5328|       |            Self {
 5329|       |                actions: actions.to_vec(),
 5330|       |            }
 5331|       |        }
 5332|       |    }
 5333|       |
 5334|       |    impl Drop for ForcedRenderActions {
 5335|       |        fn drop(&mut self) {
 5336|       |            FORCED_RENDER_ACTIONS.with(|set| {
 5337|       |                let mut set = set.borrow_mut();
 5338|       |                for action in &self.actions {
 5339|       |                    set.remove(action);
 5340|       |                }
 5341|       |            });
 5342|       |        }
 5343|       |    }
 5344|       |
 5345|       |    struct ForcedTablePolicies;
 5346|       |
 5347|       |    impl ForcedTablePolicies {
 5348|       |        fn new(policies: Vec<ColumnPolicy>) -> Self {
 5349|       |            FORCED_TABLE_POLICIES.with(|slot| {
 5350|       |                *slot.borrow_mut() = Some(policies);
 5351|       |            });
 5352|       |            Self
 5353|       |        }
 5354|       |    }
 5355|       |
 5356|       |    impl Drop for ForcedTablePolicies {
 5357|       |        fn drop(&mut self) {
 5358|       |            FORCED_TABLE_POLICIES.with(|slot| {
 5359|       |                slot.borrow_mut().take();
 5360|       |            });
 5361|       |        }
 5362|       |    }
 5363|       |
 5364|       |    fn paragraph_spans(element: &MarkdownElement) -> Option<&[InlineSpan]> {
 5365|       |        if let MarkdownElement::Paragraph(spans) = element {
 5366|       |            Some(spans)
 5367|       |        } else {
 5368|       |            None
 5369|       |        }
 5370|       |    }
 5371|       |
 5372|       |    fn image_span_fields(span: &InlineSpan) -> Option<(&str, &str, Option<&str>)> {
 5373|       |        if let InlineSpan::Image { src, alt, title } = span {
 5374|       |            Some((src.as_str(), alt.as_str(), title.as_deref()))
 5375|       |        } else {
 5376|       |            None
 5377|       |        }
 5378|       |    }
 5379|       |
 5380|       |    fn text_span_content(span: &InlineSpan) -> Option<&str> {
 5381|       |        if let InlineSpan::Text(text) = span {
 5382|       |            Some(text.as_str())
 5383|       |        } else {
 5384|       |            None
 5385|       |        }
 5386|       |    }
 5387|       |
 5388|       |    fn emoji_fragment_key<'a>(fragment: &'a CellFragment<'a>) -> Option<&'a str> {
 5389|       |        if let CellFragment::Emoji(key) = fragment {
 5390|       |            Some(key.as_str())
 5391|       |        } else {
 5392|       |            None
 5393|       |        }
 5394|       |    }
 5395|       |
 5396|       |    fn with_test_ui<F>(f: F)
 5397|       |    where
 5398|       |        F: FnOnce(&egui::Context, &mut egui::Ui),
 5399|       |    {
 5400|       |        let ctx = egui::Context::default();
 5401|       |        let input = egui::RawInput {
 5402|       |            screen_rect: Some(egui::Rect::from_min_size(
 5403|       |                egui::pos2(0.0, 0.0),
 5404|       |                egui::vec2(1024.0, 768.0),
 5405|       |            )),
 5406|       |            ..Default::default()
 5407|       |        };
 5408|       |        ctx.begin_frame(input);
 5409|       |        egui::CentralPanel::default().show(&ctx, |ui| {
 5410|       |            f(&ctx, ui);
 5411|       |        });
 5412|       |        let _ = ctx.end_frame();
 5413|       |    }
 5414|       |
 5415|       |    fn wait_for_image(
 5416|       |        renderer: &MarkdownRenderer,
 5417|       |        ctx: &egui::Context,
 5418|       |        ui: &egui::Ui,
 5419|       |        path: &str,
 5420|       |    ) -> Option<(egui::TextureHandle, u32, u32)> {
 5421|       |        wait_for_image_with_limit(renderer, ctx, ui, path, 200)
 5422|       |    }
 5423|       |
 5424|       |    fn wait_for_image_with_limit(
 5425|       |        renderer: &MarkdownRenderer,
 5426|       |        ctx: &egui::Context,
 5427|       |        ui: &egui::Ui,
 5428|       |        path: &str,
 5429|       |        max_iters: usize,
 5430|       |    ) -> Option<(egui::TextureHandle, u32, u32)> {
 5431|       |        for _ in 0..max_iters {
 5432|       |            if let Some(loaded) = renderer.get_or_load_image_texture(ui, path) {
 5433|       |                return Some(loaded);
 5434|       |            }
 5435|       |            renderer.poll_image_results(ctx);
 5436|       |            std::thread::sleep(Duration::from_millis(10));
 5437|       |        }
 5438|       |        renderer.get_or_load_image_texture(ui, path)
 5439|       |    }
 5440|       |
 5441|       |    fn run_frame_with_input<F>(ctx: &egui::Context, input: egui::RawInput, f: F)
 5442|       |    where
 5443|       |        F: FnOnce(&egui::Context, &mut egui::Ui),
 5444|       |    {
 5445|       |        ctx.begin_frame(input);
 5446|       |        egui::CentralPanel::default().show(ctx, |ui| {
 5447|       |            f(ctx, ui);
 5448|       |        });
 5449|       |        let _ = ctx.end_frame();
 5450|       |    }
 5451|       |
 5452|       |    fn input_with_click(pos: egui::Pos2, button: egui::PointerButton) -> egui::RawInput {
 5453|       |        let mut input = egui::RawInput {
 5454|       |            screen_rect: Some(egui::Rect::from_min_size(
 5455|       |                egui::pos2(0.0, 0.0),
 5456|       |                egui::vec2(320.0, 240.0),
 5457|       |            )),
 5458|       |            ..Default::default()
 5459|       |        };
 5460|       |        input.events.push(egui::Event::PointerMoved(pos));
 5461|       |        input.events.push(egui::Event::PointerButton {
 5462|       |            pos,
 5463|       |            button,
 5464|       |            pressed: true,
 5465|       |            modifiers: egui::Modifiers::default(),
 5466|       |        });
 5467|       |        input.events.push(egui::Event::PointerButton {
 5468|       |            pos,
 5469|       |            button,
 5470|       |            pressed: false,
 5471|       |            modifiers: egui::Modifiers::default(),
 5472|       |        });
 5473|       |        input
 5474|       |    }
 5475|       |
 5476|       |    fn tiny_png_bytes() -> Vec<u8> {
 5477|       |        let width = 2u32;
 5478|       |        let height = 2u32;
 5479|       |        let pixels = vec![255u8; (width * height * 4) as usize];
 5480|       |        let mut out = Vec::new();
 5481|       |        let encoder = PngEncoder::new(&mut out);
 5482|       |        encoder
 5483|       |            .write_image(&pixels, width, height, ColorType::Rgba8)
 5484|       |            .expect("encode png");
 5485|       |        out
 5486|       |    }
 5487|       |
 5488|       |    #[test]
 5489|       |    fn test_image_cache_get_missing_and_insert_empty_order() {
 5490|       |        let mut cache = ImageCache::new(1);
 5491|       |        assert!(cache.get("missing").is_none());
 5492|       |
 5493|       |        let mut entry_slot = None;
 5494|       |        with_test_ui(|ctx, _ui| {
 5495|       |            let tex = ctx.load_texture(
 5496|       |                "cache_test",
 5497|       |                egui::ColorImage::new([1, 1], Color32::WHITE),
 5498|       |                egui::TextureOptions::LINEAR,
 5499|       |            );
 5500|       |            entry_slot = Some(ImageCacheEntry {
 5501|       |                texture: tex,
 5502|       |                size: [1, 1],
 5503|       |                modified: None,
 5504|       |            });
 5505|       |        });
 5506|       |        let entry = entry_slot.expect("texture");
 5507|       |        cache.entries.insert(
 5508|       |            "a".to_string(),
 5509|       |            ImageCacheEntry {
 5510|       |                texture: entry.texture.clone(),
 5511|       |                size: entry.size,
 5512|       |                modified: entry.modified,
 5513|       |            },
 5514|       |        );
 5515|       |        cache.order.clear();
 5516|       |        cache.insert(
 5517|       |            "b".to_string(),
 5518|       |            ImageCacheEntry {
 5519|       |                texture: entry.texture.clone(),
 5520|       |                size: entry.size,
 5521|       |                modified: entry.modified,
 5522|       |            },
 5523|       |        );
 5524|       |        assert!(cache.contains_key("b"));
 5525|       |    }
 5526|       |
 5527|       |    #[test]
 5528|       |    fn test_image_cache_insert_existing_key_updates_entry() {
 5529|       |        let mut cache = ImageCache::new(2);
 5530|       |        let mut entry_slot = None;
 5531|       |        with_test_ui(|ctx, _ui| {
 5532|       |            let tex = ctx.load_texture(
 5533|       |                "cache_update",
 5534|       |                egui::ColorImage::new([1, 1], Color32::WHITE),
 5535|       |                egui::TextureOptions::LINEAR,
 5536|       |            );
 5537|       |            entry_slot = Some(ImageCacheEntry {
 5538|       |                texture: tex,
 5539|       |                size: [1, 1],
 5540|       |                modified: None,
 5541|       |            });
 5542|       |        });
 5543|       |        let entry = entry_slot.expect("texture");
 5544|       |        cache.insert(
 5545|       |            "a".to_string(),
 5546|       |            ImageCacheEntry {
 5547|       |                texture: entry.texture.clone(),
 5548|       |                size: [1, 1],
 5549|       |                modified: entry.modified,
 5550|       |            },
 5551|       |        );
 5552|       |        cache.insert(
 5553|       |            "a".to_string(),
 5554|       |            ImageCacheEntry {
 5555|       |                texture: entry.texture.clone(),
 5556|       |                size: [2, 2],
 5557|       |                modified: entry.modified,
 5558|       |            },
 5559|       |        );
 5560|       |        let stored = cache.get("a").expect("stored");
 5561|       |        assert_eq!(stored.size, [2, 2]);
 5562|       |    }
 5563|       |
 5564|       |    #[test]
 5565|       |    fn test_image_cache_evicts_oldest_entry() {
 5566|       |        let mut cache = ImageCache::new(1);
 5567|       |        let mut entry_slot = None;
 5568|       |        with_test_ui(|ctx, _ui| {
 5569|       |            let tex = ctx.load_texture(
 5570|       |                "cache_evict",
 5571|       |                egui::ColorImage::new([1, 1], Color32::WHITE),
 5572|       |                egui::TextureOptions::LINEAR,
 5573|       |            );
 5574|       |            entry_slot = Some(ImageCacheEntry {
 5575|       |                texture: tex,
 5576|       |                size: [1, 1],
 5577|       |                modified: None,
 5578|       |            });
 5579|       |        });
 5580|       |        let entry = entry_slot.expect("texture");
 5581|       |        cache.insert(
 5582|       |            "a".to_string(),
 5583|       |            ImageCacheEntry {
 5584|       |                texture: entry.texture.clone(),
 5585|       |                size: entry.size,
 5586|       |                modified: entry.modified,
 5587|       |            },
 5588|       |        );
 5589|       |        cache.insert(
 5590|       |            "b".to_string(),
 5591|       |            ImageCacheEntry {
 5592|       |                texture: entry.texture.clone(),
 5593|       |                size: entry.size,
 5594|       |                modified: entry.modified,
 5595|       |            },
 5596|       |        );
 5597|       |        assert!(cache.contains_key("b"));
 5598|       |        assert!(!cache.contains_key("a"));
 5599|       |    }
 5600|       |
 5601|       |    #[test]
 5602|       |    fn test_list_marker_info_rejects_empty_and_bad_numeric() {
 5603|       |        assert!(MarkdownRenderer::list_marker_info("").is_none());
 5604|       |        assert!(MarkdownRenderer::list_marker_info("1 abc").is_none());
 5605|       |        assert!(MarkdownRenderer::list_marker_info("   ").is_none());
 5606|       |    }
 5607|       |
 5608|       |    #[test]
 5609|       |    fn test_list_marker_info_rejects_tabs_and_missing_whitespace() {
 5610|       |        assert!(MarkdownRenderer::list_marker_info("\t- item").is_none());
 5611|       |        assert!(MarkdownRenderer::list_marker_info("1.item").is_none());
 5612|       |        assert!(MarkdownRenderer::list_marker_info("1)item").is_none());
 5613|       |        assert!(MarkdownRenderer::list_marker_info("-item").is_none());
 5614|       |    }
 5615|       |
 5616|       |    #[test]
 5617|       |    fn test_list_marker_info_rejects_marker_only() {
 5618|       |        assert!(MarkdownRenderer::list_marker_info("-").is_none());
 5619|       |        assert!(MarkdownRenderer::list_marker_info("1.").is_none());
 5620|       |    }
 5621|       |
 5622|       |    #[test]
 5623|       |    fn test_parse_image_with_title_sets_title() {
 5624|       |        let renderer = MarkdownRenderer::new();
 5625|       |        let parsed = renderer
 5626|       |            .parse("![alt](path/to/img.png \"Title\")")
 5627|       |            .expect("parse");
 5628|       |        let spans = paragraph_spans(&parsed[0]).expect("paragraph spans");
 5629|       |        let (_src, _alt, title) = image_span_fields(&spans[0]).expect("image span");
 5630|       |        assert_eq!(title, Some("Title"));
 5631|       |    }
 5632|       |
 5633|       |    #[test]
 5634|       |    fn test_is_external_url_variants() {
 5635|       |        assert!(MarkdownRenderer::is_external_url("http://example.com"));
 5636|       |        assert!(MarkdownRenderer::is_external_url("https://example.com"));
 5637|       |        assert!(MarkdownRenderer::is_external_url("mailto:test@example.com"));
 5638|       |        assert!(MarkdownRenderer::is_external_url("www.example.com"));
 5639|       |        assert!(!MarkdownRenderer::is_external_url("local/path.png"));
 5640|       |    }
 5641|       |
 5642|       |    #[test]
 5643|       |    fn test_resolve_image_path_keeps_remote() {
 5644|       |        let renderer = MarkdownRenderer::new();
 5645|       |        let src = "https://example.com/image.png";
 5646|       |        let http_src = "http://example.com/image.png";
 5647|       |        assert_eq!(renderer.resolve_image_path(src), src);
 5648|       |        assert_eq!(renderer.resolve_image_path(http_src), http_src);
 5649|       |        let data_src = "data:image/png;base64,AAAA";
 5650|       |        assert_eq!(renderer.resolve_image_path(data_src), data_src);
 5651|       |    }
 5652|       |
 5653|       |    #[test]
 5654|       |    fn test_compute_table_id_includes_base_dir() {
 5655|       |        let renderer = MarkdownRenderer::new();
 5656|       |        let headers = vec![vec![InlineSpan::Text("A".to_string())]];
 5657|       |        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
 5658|       |        let alignments = vec![Alignment::Left];
 5659|       |        let base_id = renderer.compute_table_id(&headers, &rows, &alignments, 0);
 5660|       |
 5661|       |        *renderer.base_dir.borrow_mut() = Some(PathBuf::from("C:\\tmp"));
 5662|       |        let with_base = renderer.compute_table_id(&headers, &rows, &alignments, 0);
 5663|       |        assert_ne!(base_id, with_base);
 5664|       |    }
 5665|       |
 5666|       |    #[test]
 5667|       |    fn test_render_table_early_return_on_empty_headers() {
 5668|       |        let renderer = MarkdownRenderer::new();
 5669|       |        with_test_ui(|_, ui| {
 5670|       |            renderer.render_table(ui, &[], &[], &[]);
 5671|       |        });
 5672|       |    }
 5673|       |
 5674|       |    #[test]
 5675|       |    fn test_extend_table_rect_handles_nan() {
 5676|       |        let mut target = Some(egui::Rect::from_min_size(
 5677|       |            egui::pos2(0.0, 0.0),
 5678|       |            egui::vec2(10.0, 10.0),
 5679|       |        ));
 5680|       |        let nan_rect = egui::Rect::from_min_size(egui::pos2(f32::NAN, 0.0), egui::vec2(1.0, 1.0));
 5681|       |        MarkdownRenderer::extend_table_rect(&mut target, nan_rect);
 5682|       |        let stored = target.expect("target");
 5683|       |        assert!(!stored.min.x.is_nan());
 5684|       |
 5685|       |        let mut target_none = None;
 5686|       |        MarkdownRenderer::extend_table_rect(
 5687|       |            &mut target_none,
 5688|       |            egui::Rect::from_min_size(egui::pos2(5.0, 6.0), egui::vec2(2.0, 2.0)),
 5689|       |        );
 5690|       |        assert!(target_none.is_some());
 5691|       |    }
 5692|       |
 5693|       |    #[test]
 5694|       |    fn test_extend_table_rect_rejects_nan_components() {
 5695|       |        let base = egui::Rect::from_min_size(egui::pos2(1.0, 2.0), egui::vec2(3.0, 4.0));
 5696|       |        let mut target = Some(base);
 5697|       |        let nan_min_y = egui::Rect::from_min_size(egui::pos2(0.0, f32::NAN), egui::vec2(1.0, 1.0));
 5698|       |        MarkdownRenderer::extend_table_rect(&mut target, nan_min_y);
 5699|       |        assert_eq!(target, Some(base));
 5700|       |
 5701|       |        let mut target = Some(base);
 5702|       |        let nan_max_x = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(f32::NAN, 1.0));
 5703|       |        MarkdownRenderer::extend_table_rect(&mut target, nan_max_x);
 5704|       |        assert_eq!(target, Some(base));
 5705|       |
 5706|       |        let mut target = Some(base);
 5707|       |        let nan_max_y = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(1.0, f32::NAN));
 5708|       |        MarkdownRenderer::extend_table_rect(&mut target, nan_max_y);
 5709|       |        assert_eq!(target, Some(base));
 5710|       |    }
 5711|       |
 5712|       |    #[test]
 5713|       |    fn test_persist_resizable_widths_returns_on_empty() {
 5714|       |        let renderer = MarkdownRenderer::new();
 5715|       |        renderer.persist_resizable_widths(1, &[], &[]);
 5716|       |    }
 5717|       |
 5718|       |    #[test]
 5719|       |    fn test_persist_resizable_widths_returns_on_empty_widths() {
 5720|       |        let renderer = MarkdownRenderer::new();
 5721|       |        let spec = ColumnSpec::new(
 5722|       |            0,
 5723|       |            "A",
 5724|       |            ColumnPolicy::Resizable {
 5725|       |                min: 20.0,
 5726|       |                preferred: 80.0,
 5727|       |                clip: false,
 5728|       |            },
 5729|       |            None,
 5730|       |        );
 5731|       |        let table_id = 7u64;
 5732|       |        renderer.persist_resizable_widths(table_id, &[spec], &[]);
 5733|       |        let metrics = renderer.table_metrics.borrow();
 5734|       |        assert!(metrics.entry(table_id).is_none());
 5735|       |    }
 5736|       |
 5737|       |    #[test]
 5738|       |    fn test_link_at_pointer_outside_rect_returns_none() {
 5739|       |        let renderer = MarkdownRenderer::new();
 5740|       |        let spans = vec![InlineSpan::Link {
 5741|       |            text: "Link".to_string(),
 5742|       |            url: "https://example.com".to_string(),
 5743|       |        }];
 5744|       |        let ctx = egui::Context::default();
 5745|       |        let mut input = egui::RawInput {
 5746|       |            screen_rect: Some(egui::Rect::from_min_size(
 5747|       |                egui::pos2(0.0, 0.0),
 5748|       |                egui::vec2(320.0, 240.0),
 5749|       |            )),
 5750|       |            ..Default::default()
 5751|       |        };
 5752|       |        input
 5753|       |            .events
 5754|       |            .push(egui::Event::PointerMoved(egui::pos2(200.0, 200.0)));
 5755|       |        ctx.begin_frame(input);
 5756|       |        let mut found = false;
 5757|       |        egui::CentralPanel::default().show(&ctx, |ui| {
 5758|       |            let response = ui.label("anchor");
 5759|       |            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, false, Align::LEFT);
 5760|       |            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
 5761|       |            found = renderer
 5762|       |                .link_at_pointer(&response, &galley, &build, egui::pos2(0.0, 0.0))
 5763|       |                .is_some();
 5764|       |        });
 5765|       |        let _ = ctx.end_frame();
 5766|       |        assert!(!found);
 5767|       |    }
 5768|       |
 5769|       |    #[test]
 5770|       |    fn test_spawn_image_loader_missing_file_reports_failed() {
 5771|       |        let (job_tx, job_rx) = bounded(1);
 5772|       |        let (result_tx, result_rx) = bounded(1);
 5773|       |        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);
 5774|       |
 5775|       |        let dir = tempdir().expect("temp dir");
 5776|       |        let path = dir.path().join("missing.png");
 5777|       |        job_tx
 5778|       |            .send(ImageLoadRequest {
 5779|       |                key: "missing".to_string(),
 5780|       |                source: ImageLoadSource::File(path),
 5781|       |            })
 5782|       |            .expect("send");
 5783|       |        let result = result_rx
 5784|       |            .recv_timeout(Duration::from_secs(3))
 5785|       |            .expect("result");
 5786|       |        assert!(matches!(
 5787|       |            result,
 5788|       |            ImageLoadResult::Failed { ref key } if key == "missing"
 5789|       |        ));
 5790|       |    }
 5791|       |
 5792|       |    #[test]
 5793|       |    fn test_spawn_image_loader_embedded_invalid_bytes_reports_failed() {
 5794|       |        let (job_tx, job_rx) = bounded(1);
 5795|       |        let (result_tx, result_rx) = bounded(1);
 5796|       |        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);
 5797|       |
 5798|       |        job_tx
 5799|       |            .send(ImageLoadRequest {
 5800|       |                key: "bad-embedded".to_string(),
 5801|       |                source: ImageLoadSource::Embedded(b"not an image"),
 5802|       |            })
 5803|       |            .expect("send");
 5804|       |        let result = result_rx
 5805|       |            .recv_timeout(Duration::from_secs(8))
 5806|       |            .expect("result");
 5807|       |        assert!(matches!(
 5808|       |            result,
 5809|       |            ImageLoadResult::Failed { ref key } if key == "bad-embedded"
 5810|       |        ));
 5811|       |    }
 5812|       |
 5813|       |    #[test]
 5814|       |    fn test_spawn_image_loader_file_invalid_bytes_reports_failed() -> Result<()> {
 5815|       |        let (job_tx, job_rx) = bounded(1);
 5816|       |        let (result_tx, result_rx) = bounded(1);
 5817|       |        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);
 5818|       |
 5819|       |        let dir = tempdir()?;
 5820|       |        let path = dir.path().join("bad.png");
 5821|       |        std::fs::write(&path, b"not an image")?;
 5822|       |        job_tx
 5823|       |            .send(ImageLoadRequest {
 5824|       |                key: "bad-file".to_string(),
 5825|       |                source: ImageLoadSource::File(path),
 5826|       |            })
 5827|       |            .expect("send");
 5828|       |        let result = result_rx
 5829|       |            .recv_timeout(Duration::from_secs(3))
 5830|       |            .expect("result");
 5831|       |        assert!(matches!(
 5832|       |            result,
 5833|       |            ImageLoadResult::Failed { ref key } if key == "bad-file"
 5834|       |        ));
 5835|       |        Ok(())
 5836|       |    }
 5837|       |
 5838|       |    #[test]
 5839|       |    fn test_spawn_image_loader_file_read_error_reports_failed() -> Result<()> {
 5840|       |        let (job_tx, job_rx) = bounded(1);
 5841|       |        let (result_tx, result_rx) = bounded(1);
 5842|       |        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);
 5843|       |
 5844|       |        let dir = tempdir()?;
 5845|       |        let bad_path = dir.path().join("read_error_dir");
 5846|       |        std::fs::create_dir_all(&bad_path)?;
 5847|       |        job_tx
 5848|       |            .send(ImageLoadRequest {
 5849|       |                key: "read-error".to_string(),
 5850|       |                source: ImageLoadSource::File(bad_path),
 5851|       |            })
 5852|       |            .expect("send");
 5853|       |        let result = result_rx
 5854|       |            .recv_timeout(Duration::from_secs(1))
 5855|       |            .expect("result");
 5856|       |        assert!(matches!(
 5857|       |            result,
 5858|       |            ImageLoadResult::Failed { ref key } if key == "read-error"
 5859|       |        ));
 5860|       |        Ok(())
 5861|       |    }
 5862|       |
 5863|       |    #[test]
 5864|       |    fn test_env_var_guard_removes_unset_value() {
 5865|       |        let key = "MDMDVIEW_TEST_ENV_GUARD";
 5866|       |        env::remove_var(key);
 5867|       |        {
 5868|       |            let _guard = EnvVarGuard::set(key, "value");
 5869|       |            assert_eq!(env::var(key).ok().as_deref(), Some("value"));
 5870|       |        }
 5871|       |        assert!(env::var(key).is_err());
 5872|       |    }
 5873|       |
 5874|       |    #[test]
 5875|       |    fn test_parse_forced_error_returns_err_once() {
 5876|       |        let renderer = MarkdownRenderer::new();
 5877|       |        force_parse_error_once();
 5878|       |        assert!(renderer.parse("hello").is_err());
 5879|       |        assert!(renderer.parse("hello").is_ok());
 5880|       |    }
 5881|       |
 5882|       |    #[test]
 5883|       |    fn test_fence_helpers_cover_branches() {
 5884|       |        assert_eq!(MarkdownRenderer::fence_start("```"), Some(('`', 3)));
 5885|       |        assert_eq!(MarkdownRenderer::fence_start("``"), None);
 5886|       |        assert_eq!(MarkdownRenderer::fence_start("~~~"), Some(('~', 3)));
 5887|       |        assert!(MarkdownRenderer::is_fence_end("```", '`', 3));
 5888|       |        assert!(!MarkdownRenderer::is_fence_end("``", '`', 3));
 5889|       |        assert!(MarkdownRenderer::is_fence_end("   ```", '`', 3));
 5890|       |    }
 5891|       |
 5892|       |    #[test]
 5893|       |    fn test_restore_pipe_sentinel_round_trip() {
 5894|       |        let input = format!("a{}b", PIPE_SENTINEL);
 5895|       |        assert_eq!(MarkdownRenderer::restore_pipe_sentinel(&input), "a|b");
 5896|       |        assert_eq!(MarkdownRenderer::restore_pipe_sentinel("a|b"), "a|b");
 5897|       |    }
 5898|       |
 5899|       |    #[test]
 5900|       |    fn test_list_marker_info_numeric_punctuation() {
 5901|       |        let (content, _indent, _content_indent) =
 5902|       |            MarkdownRenderer::list_marker_info("1. item").expect("dot marker");
 5903|       |        assert_eq!(content.trim_start(), "item");
 5904|       |        let (content, _indent, _content_indent) =
 5905|       |            MarkdownRenderer::list_marker_info("2) item").expect("paren marker");
 5906|       |        assert_eq!(content.trim_start(), "item");
 5907|       |    }
 5908|       |
 5909|       |    #[test]
 5910|       |    fn test_table_line_info_blockquote_levels() {
 5911|       |        let (level, rest) = MarkdownRenderer::table_line_info("  >\t| a |");
 5912|       |        assert_eq!(level, 1);
 5913|       |        assert!(rest.trim_start().starts_with('|'));
 5914|       |
 5915|       |        let (level, rest) = MarkdownRenderer::table_line_info("> > | b |");
 5916|       |        assert_eq!(level, 2);
 5917|       |        assert!(rest.trim_start().starts_with('|'));
 5918|       |    }
 5919|       |
 5920|       |    #[test]
 5921|       |    fn test_strip_indent_columns_indent_zero_returns_line() {
 5922|       |        assert_eq!(
 5923|       |            MarkdownRenderer::strip_indent_columns("content", 0),
 5924|       |            Some("content")
 5925|       |        );
 5926|       |    }
 5927|       |
 5928|       |    #[test]
 5929|       |    fn test_parent_list_indent_for_line_zero_index_returns_none() {
 5930|       |        let lines = vec!["- item"];
 5931|       |        let (level, rest) = MarkdownRenderer::table_line_info(lines[0]);
 5932|       |        assert!(MarkdownRenderer::parent_list_indent_for_line(&lines, 0, level, rest).is_none());
 5933|       |    }
 5934|       |
 5935|       |    #[test]
 5936|       |    fn test_should_retry_image_backoff_respected() {
 5937|       |        let renderer = MarkdownRenderer::new();
 5938|       |        renderer.image_failures.borrow_mut().insert(
 5939|       |            "recent".to_string(),
 5940|       |            ImageFailure {
 5941|       |                last_attempt: std::time::Instant::now(),
 5942|       |            },
 5943|       |        );
 5944|       |        assert!(!renderer.should_retry_image("recent"));
 5945|       |
 5946|       |        renderer.image_failures.borrow_mut().insert(
 5947|       |            "old".to_string(),
 5948|       |            ImageFailure {
 5949|       |                last_attempt: std::time::Instant::now()
 5950|       |                    - IMAGE_FAILURE_BACKOFF
 5951|       |                    - Duration::from_millis(1),
 5952|       |            },
 5953|       |        );
 5954|       |        assert!(renderer.should_retry_image("old"));
 5955|       |    }
 5956|       |
 5957|       |    #[test]
 5958|       |    fn test_extend_table_rect_accepts_valid_rect() {
 5959|       |        let mut target = None;
 5960|       |        let rect = egui::Rect::from_min_size(egui::pos2(1.0, 2.0), egui::vec2(3.0, 4.0));
 5961|       |        MarkdownRenderer::extend_table_rect(&mut target, rect);
 5962|       |        assert_eq!(target, Some(rect));
 5963|       |
 5964|       |        let rect2 = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(10.0, 10.0));
 5965|       |        MarkdownRenderer::extend_table_rect(&mut target, rect2);
 5966|       |        let merged = target.expect("merged rect");
 5967|       |        assert!(merged.contains(rect.min));
 5968|       |        assert!(merged.contains(rect2.max));
 5969|       |    }
 5970|       |
 5971|       |    #[test]
 5972|       |    fn test_render_code_block_with_none_language() {
 5973|       |        let renderer = MarkdownRenderer::new();
 5974|       |        with_test_ui(|_, ui| {
 5975|       |            renderer.render_code_block(ui, None, "fn main() {}");
 5976|       |        });
 5977|       |    }
 5978|       |
 5979|       |    #[test]
 5980|       |    fn test_render_action_triggered_forced_paths() {
 5981|       |        let _actions = ForcedRenderActions::new(&["forced_action"]);
 5982|       |        assert!(render_action_triggered(false, "forced_action"));
 5983|       |        assert!(!render_action_triggered(false, "other_action"));
 5984|       |        assert!(render_action_triggered(true, "other_action"));
 5985|       |    }
 5986|       |
 5987|       |    #[test]
 5988|       |    fn test_markdown_renderer_creation() {
 5989|       |        let renderer = MarkdownRenderer::new();
 5990|       |        assert_eq!(renderer.font_sizes.body, 14.0);
 5991|       |        assert_eq!(renderer.font_sizes.h1, 28.0);
 5992|       |    }
 5993|       |
 5994|       |    #[test]
 5995|       |    fn test_markdown_renderer_default_uses_defaults() {
 5996|       |        let renderer = MarkdownRenderer::default();
 5997|       |        let defaults = FontSizes::default();
 5998|       |        assert_eq!(renderer.font_sizes.body, defaults.body);
 5999|       |        assert_eq!(renderer.font_sizes.code, defaults.code);
 6000|       |    }
 6001|       |
 6002|       |    #[test]
 6003|       |    fn test_superscript_expansion_basic() {
 6004|       |        let s = "5^th^ and m^2^";
 6005|       |        let out = MarkdownRenderer::expand_superscripts(s);
 6006|       |        assert!(out.contains("5"));
 6007|       |        assert!(out.contains("m"));
 6008|       |    }
 6009|       |
 6010|       |    #[test]
 6011|       |    fn test_superscript_expansion_allows_plus_symbol() {
 6012|       |        let out = MarkdownRenderer::expand_superscripts("x^+^");
 6013|       |        assert!(out.contains('\u{207a}'));
 6014|       |    }
 6015|       |
 6016|       |    #[test]
 6017|       |    fn test_superscript_expansion_single_caret() {
 6018|       |        // Test that single carets (not paired) are left as-is
 6019|       |        let s = "2^32 = 4,294,967,296";
 6020|       |        let out = MarkdownRenderer::expand_superscripts(s);
 6021|       |        assert_eq!(out, "2^32 = 4,294,967,296");
 6022|       |
 6023|       |        // Test the problematic line from the bug report
 6024|       |        let problematic = "A 32-bit address bus would provide 2^32 = 4,294,967,296 bytes (4 GB) of addressable memory.";
 6025|       |        let fixed = MarkdownRenderer::expand_superscripts(problematic);
 6026|       |        assert_eq!(fixed, problematic);
 6027|       |
 6028|       |        // Test mixed cases
 6029|       |        let mixed = "Use 2^32 for math and 5^th^ for ordinal";
 6030|       |        let result = MarkdownRenderer::expand_superscripts(mixed);
 6031|       |        assert!(result.contains("2^32"));
 6032|       |        assert!(result.contains("5"));
 6033|       |    }
 6034|       |
 6035|       |    #[test]
 6036|       |    fn test_superscript_expansion_rejects_invalid_sequences() {
 6037|       |        let s = "2^ab$^ and ^^";
 6038|       |        let out = MarkdownRenderer::expand_superscripts(s);
 6039|       |        assert_eq!(out, s);
 6040|       |        let no_close = "10^abc";
 6041|       |        let out = MarkdownRenderer::expand_superscripts(no_close);
 6042|       |        assert_eq!(out, no_close);
 6043|       |    }
 6044|       |
 6045|       |    #[test]
 6046|       |    fn test_font_sizes_default() {
 6047|       |        let sizes = FontSizes::default();
 6048|       |        assert_eq!(sizes.body, 14.0);
 6049|       |        assert_eq!(sizes.h1, 28.0);
 6050|       |        assert_eq!(sizes.code, 12.0);
 6051|       |    }
 6052|       |
 6053|       |    #[test]
 6054|       |    fn test_zoom_functionality() {
 6055|       |        let mut renderer = MarkdownRenderer::new();
 6056|       |        let original_body = renderer.font_sizes.body;
 6057|       |
 6058|       |        renderer.zoom_in();
 6059|       |        assert!(renderer.font_sizes.body > original_body);
 6060|       |
 6061|       |        renderer.zoom_out();
 6062|       |        assert!(renderer.font_sizes.body < original_body * 1.1);
 6063|       |
 6064|       |        renderer.reset_zoom();
 6065|       |        assert_eq!(renderer.font_sizes.body, original_body);
 6066|       |    }
 6067|       |
 6068|       |    #[test]
 6069|       |    fn test_set_zoom_scale() {
 6070|       |        let mut renderer = MarkdownRenderer::new();
 6071|       |
 6072|       |        renderer.set_zoom_scale(1.5);
 6073|       |        assert!((renderer.font_sizes.body - 21.0).abs() < 0.1);
 6074|       |
 6075|       |        renderer.set_zoom_scale(10.0);
 6076|       |        assert_eq!(renderer.font_sizes.body, 32.0);
 6077|       |
 6078|       |        renderer.set_zoom_scale(0.1);
 6079|       |        assert_eq!(renderer.font_sizes.body, 8.0);
 6080|       |    }
 6081|       |
 6082|       |    #[test]
 6083|       |    fn font_size_change_does_not_repersist_stale_widths() {
 6084|       |        let mut renderer = MarkdownRenderer::new();
 6085|       |        let table_id = 7u64;
 6086|       |        let specs = vec![ColumnSpec::new(
 6087|       |            0,
 6088|       |            "A",
 6089|       |            ColumnPolicy::Resizable {
 6090|       |                min: 20.0,
 6091|       |                preferred: 100.0,
 6092|       |                clip: false,
 6093|       |            },
 6094|       |            None,
 6095|       |        )];
 6096|       |        let widths = vec![100.0f32];
 6097|       |
 6098|       |        // Initial persist at default font size.
 6099|       |        renderer.persist_resizable_widths(table_id, &specs, &widths);
 6100|       |        let policy_hash = specs[0].policy_hash;
 6101|       |        {
 6102|       |            let metrics = renderer.table_metrics.borrow();
 6103|       |            let entry = metrics.entry(table_id).expect("entry created");
 6104|       |            assert_eq!(entry.persisted_width(policy_hash), Some(100.0));
 6105|       |            assert_eq!(entry.persisted_font_size, Some(renderer.font_sizes.body));
 6106|       |        }
 6107|       |
 6108|       |        // Simulate zoom: font size changes but widths captured are still the old ones.
 6109|       |        renderer.font_sizes.body = 16.0;
 6110|       |        renderer.persist_resizable_widths(table_id, &specs, &widths);
 6111|       |        {
 6112|       |            let metrics = renderer.table_metrics.borrow();
 6113|       |            let entry = metrics.entry(table_id).expect("entry exists");
 6114|       |            // Cleared and NOT re-saved in the same frame.
 6115|       |            assert_eq!(entry.persisted_width(policy_hash), None);
 6116|       |            assert_eq!(entry.persisted_font_size, Some(16.0));
 6117|       |        }
 6118|       |
 6119|       |        // Next frame with new layout widths should persist again.
 6120|       |        let new_widths = vec![80.0f32];
 6121|       |        renderer.persist_resizable_widths(table_id, &specs, &new_widths);
 6122|       |        let metrics = renderer.table_metrics.borrow();
 6123|       |        let entry = metrics.entry(table_id).expect("entry exists");
 6124|       |        assert_eq!(entry.persisted_width(policy_hash), Some(80.0));
 6125|       |        assert_eq!(entry.persisted_font_size, Some(16.0));
 6126|       |    }
 6127|       |
 6128|       |    #[test]
 6129|       |    fn highlight_phrase_keeps_persisted_table_widths() {
 6130|       |        let renderer = MarkdownRenderer::new();
 6131|       |        let table_id = 11u64;
 6132|       |        let specs = vec![ColumnSpec::new(
 6133|       |            0,
 6134|       |            "A",
 6135|       |            ColumnPolicy::Resizable {
 6136|       |                min: 20.0,
 6137|       |                preferred: 100.0,
 6138|       |                clip: false,
 6139|       |            },
 6140|       |            None,
 6141|       |        )];
 6142|       |        let widths = vec![120.0f32];
 6143|       |        let policy_hash = specs[0].policy_hash;
 6144|       |
 6145|       |        renderer.persist_resizable_widths(table_id, &specs, &widths);
 6146|       |        renderer.set_highlight_phrase(Some("alpha"));
 6147|       |        renderer.set_highlight_phrase(Some("beta"));
 6148|       |
 6149|       |        let metrics = renderer.table_metrics.borrow();
 6150|       |        let entry = metrics.entry(table_id).expect("entry exists");
 6151|       |        assert_eq!(entry.persisted_width(policy_hash), Some(120.0));
 6152|       |    }
 6153|       |
 6154|       |    #[test]
 6155|       |    fn test_tight_list_inline_code_and_styles() {
 6156|       |        let renderer = MarkdownRenderer::new();
 6157|       |        let md = "Intro\n\n- Use `code` and **bold** and *italic* and ~~strike~~\n";
 6158|       |        let parsed = renderer.parse(md).expect("parse ok");
 6159|       |        let (ordered, items) = parsed
 6160|       |            .iter()
 6161|       |            .find_map(|el| {
 6162|       |                if let MarkdownElement::List { ordered, items } = el {
 6163|       |                    Some((*ordered, items))
 6164|       |                } else {
 6165|       |                    None
 6166|       |                }
 6167|       |            })
 6168|       |            .expect("list element");
 6169|       |        assert!(!ordered);
 6170|       |        assert_eq!(items.len(), 1);
 6171|       |        let mut blocks = Vec::new();
 6172|       |        blocks.push(MarkdownElement::HorizontalRule);
 6173|       |        blocks.extend(items[0].blocks.clone());
 6174|       |        let spans = blocks
 6175|       |            .iter()
 6176|       |            .find_map(|block| {
 6177|       |                if let MarkdownElement::Paragraph(spans) = block {
 6178|       |                    Some(spans)
 6179|       |                } else {
 6180|       |                    None
 6181|       |                }
 6182|       |            })
 6183|       |            .expect("paragraph block");
 6184|       |        let mut saw_code = false;
 6185|       |        let mut saw_strong = false;
 6186|       |        let mut saw_emphasis = false;
 6187|       |        let mut saw_strike = false;
 6188|       |        let mut saw_other = false;
 6189|       |        for span in spans {
 6190|       |            match span {
 6191|       |                InlineSpan::Code(_) => saw_code = true,
 6192|       |                InlineSpan::Strong(_) => saw_strong = true,
 6193|       |                InlineSpan::Emphasis(_) => saw_emphasis = true,
 6194|       |                InlineSpan::Strikethrough(_) => saw_strike = true,
 6195|       |                _ => saw_other = true,
 6196|       |            }
 6197|       |        }
 6198|       |        assert!(saw_code);
 6199|       |        assert!(saw_strong);
 6200|       |        assert!(saw_emphasis);
 6201|       |        assert!(saw_strike);
 6202|       |        assert!(saw_other);
 6203|       |    }
 6204|       |
 6205|       |    #[test]
 6206|       |    fn test_expand_shortcodes_basic() {
 6207|       |        let rocket = MarkdownRenderer::expand_shortcodes(":rocket:");
 6208|       |        assert_ne!(rocket, ":rocket:");
 6209|       |        assert!(crate::emoji_catalog::image_bytes_for(&rocket).is_some());
 6210|       |
 6211|       |        let tada = MarkdownRenderer::expand_shortcodes(":tada:");
 6212|       |        assert_ne!(tada, ":tada:");
 6213|       |        assert!(crate::emoji_catalog::image_bytes_for(&tada).is_some());
 6214|       |
 6215|       |        assert_eq!(
 6216|       |            MarkdownRenderer::expand_shortcodes("Hello :tada:!"),
 6217|       |            format!("Hello {}!", tada)
 6218|       |        );
 6219|       |    }
 6220|       |
 6221|       |    #[test]
 6222|       |    fn test_expand_shortcodes_unknown_code_keeps_text() {
 6223|       |        let input = "Unknown :notacode: stays the same.";
 6224|       |        let out = MarkdownRenderer::expand_shortcodes(input);
 6225|       |        assert_eq!(out, input);
 6226|       |    }
 6227|       |
 6228|       |    #[test]
 6229|       |    fn test_fix_unicode_chars_normalizes_basic_cases() {
 6230|       |        let renderer = MarkdownRenderer::new();
 6231|       |        let input = "A\u{00A0}B\u{2013}C";
 6232|       |        let normalized = renderer.normalize_text_for_test(input);
 6233|       |        assert_eq!(normalized, "A B-C");
 6234|       |
 6235|       |        let arrows = renderer.normalize_text_for_test("   ");
 6236|       |        assert_eq!(arrows, "<- -> ^ v");
 6237|       |
 6238|       |        let untouched = renderer.normalize_text_for_test("Plain text");
 6239|       |        assert_eq!(untouched, "Plain text");
 6240|       |    }
 6241|       |
 6242|       |    #[test]
 6243|       |    fn test_elements_to_plain_text_basic() {
 6244|       |        let elements = vec![
 6245|       |            MarkdownElement::Header {
 6246|       |                level: 1,
 6247|       |                spans: vec![InlineSpan::Text("Test Header".to_string())],
 6248|       |                id: "test-header".to_string(),
 6249|       |            },
 6250|       |            MarkdownElement::Paragraph(vec![
 6251|       |                InlineSpan::Text("This is a ".to_string()),
 6252|       |                InlineSpan::Strong("bold".to_string()),
 6253|       |                InlineSpan::Text(" paragraph.".to_string()),
 6254|       |            ]),
 6255|       |        ];
 6256|       |
 6257|       |        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6258|       |        assert!(plain_text.contains("Test Header"));
 6259|       |        assert!(plain_text.contains("This is a bold paragraph."));
 6260|       |    }
 6261|       |
 6262|       |    #[test]
 6263|       |    fn test_elements_to_plain_text_code_block() {
 6264|       |        let elements = vec![MarkdownElement::CodeBlock {
 6265|       |            language: Some("rust".to_string()),
 6266|       |            text: "fn main() {\n    println!(\"Hello\");\n}".to_string(),
 6267|       |        }];
 6268|       |
 6269|       |        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6270|       |        assert_eq!(plain_text, "fn main() {\n    println!(\"Hello\");\n}");
 6271|       |    }
 6272|       |
 6273|       |    #[test]
 6274|       |    fn test_elements_to_plain_text_with_links() {
 6275|       |        let elements = vec![MarkdownElement::Paragraph(vec![
 6276|       |            InlineSpan::Text("Visit ".to_string()),
 6277|       |            InlineSpan::Link {
 6278|       |                text: "GitHub".to_string(),
 6279|       |                url: "https://github.com".to_string(),
 6280|       |            },
 6281|       |            InlineSpan::Text(" for more.".to_string()),
 6282|       |        ])];
 6283|       |
 6284|       |        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6285|       |        assert_eq!(plain_text, "Visit GitHub for more.");
 6286|       |    }
 6287|       |
 6288|       |    #[test]
 6289|       |    fn test_elements_to_plain_text_horizontal_rule_after_text() {
 6290|       |        let elements = vec![
 6291|       |            MarkdownElement::Paragraph(vec![InlineSpan::Text("Hello".to_string())]),
 6292|       |            MarkdownElement::HorizontalRule,
 6293|       |        ];
 6294|       |        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6295|       |        assert_eq!(plain_text, "Hello\n---\n");
 6296|       |    }
 6297|       |
 6298|       |    #[test]
 6299|       |    fn test_elements_to_plain_text_mixed_blocks_adds_newlines() {
 6300|       |        let elements = vec![
 6301|       |            MarkdownElement::Paragraph(vec![InlineSpan::Text("First".to_string())]),
 6302|       |            MarkdownElement::List {
 6303|       |                ordered: false,
 6304|       |                items: vec![ListItem {
 6305|       |                    blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6306|       |                        "List".to_string(),
 6307|       |                    )])],
 6308|       |                }],
 6309|       |            },
 6310|       |            MarkdownElement::Quote {
 6311|       |                depth: 1,
 6312|       |                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6313|       |                    "Quote".to_string(),
 6314|       |                )])],
 6315|       |            },
 6316|       |            MarkdownElement::Table {
 6317|       |                headers: vec![
 6318|       |                    vec![InlineSpan::Text("H1".to_string())],
 6319|       |                    vec![InlineSpan::Text("H2".to_string())],
 6320|       |                ],
 6321|       |                rows: vec![vec![vec![InlineSpan::Text("R1".to_string())]]],
 6322|       |                alignments: vec![Alignment::Left, Alignment::Left],
 6323|       |            },
 6324|       |            MarkdownElement::HorizontalRule,
 6325|       |        ];
 6326|       |        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6327|       |        assert_eq!(plain_text, "First\nList\nQuote\nH1\nH2\nR1\n---\n");
 6328|       |    }
 6329|       |
 6330|       |    #[test]
 6331|       |    fn test_elements_to_plain_text_list_only_starts_without_newline() {
 6332|       |        let elements = vec![MarkdownElement::List {
 6333|       |            ordered: false,
 6334|       |            items: vec![ListItem {
 6335|       |                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6336|       |                    "Item".to_string(),
 6337|       |                )])],
 6338|       |            }],
 6339|       |        }];
 6340|       |        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6341|       |        assert_eq!(plain_text, "Item");
 6342|       |    }
 6343|       |
 6344|       |    #[test]
 6345|       |    fn test_elements_to_plain_text_quote_only_starts_without_newline() {
 6346|       |        let elements = vec![MarkdownElement::Quote {
 6347|       |            depth: 1,
 6348|       |            blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6349|       |                "Quote".to_string(),
 6350|       |            )])],
 6351|       |        }];
 6352|       |        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6353|       |        assert_eq!(plain_text, "Quote");
 6354|       |    }
 6355|       |
 6356|       |    #[test]
 6357|       |    fn test_elements_to_plain_text_table_headers_only_starts_without_newline() {
 6358|       |        let elements = vec![MarkdownElement::Table {
 6359|       |            headers: vec![vec![InlineSpan::Text("H".to_string())]],
 6360|       |            rows: Vec::new(),
 6361|       |            alignments: vec![Alignment::Left],
 6362|       |        }];
 6363|       |        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6364|       |        assert_eq!(plain_text, "H");
 6365|       |    }
 6366|       |
 6367|       |    #[test]
 6368|       |    fn test_elements_to_plain_text_table_rows_only_starts_without_newline() {
 6369|       |        let elements = vec![MarkdownElement::Table {
 6370|       |            headers: Vec::new(),
 6371|       |            rows: vec![vec![vec![InlineSpan::Text("R".to_string())]]],
 6372|       |            alignments: vec![Alignment::Left],
 6373|       |        }];
 6374|       |        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6375|       |        assert_eq!(plain_text, "R");
 6376|       |    }
 6377|       |
 6378|       |    #[test]
 6379|       |    fn test_spans_plain_text_image_title_without_alt() {
 6380|       |        let spans = vec![
 6381|       |            InlineSpan::Image {
 6382|       |                src: "img.png".to_string(),
 6383|       |                alt: "".to_string(),
 6384|       |                title: Some("Title".to_string()),
 6385|       |            },
 6386|       |            InlineSpan::Image {
 6387|       |                src: "img.png".to_string(),
 6388|       |                alt: "Alt".to_string(),
 6389|       |                title: Some("Caption".to_string()),
 6390|       |            },
 6391|       |            InlineSpan::Image {
 6392|       |                src: "img.png".to_string(),
 6393|       |                alt: "".to_string(),
 6394|       |                title: Some("".to_string()),
 6395|       |            },
 6396|       |        ];
 6397|       |        let plain_text = MarkdownRenderer::spans_plain_text(&spans);
 6398|       |        assert_eq!(plain_text, "TitleAlt Caption");
 6399|       |    }
 6400|       |
 6401|       |    #[test]
 6402|       |    fn test_spans_plain_text_includes_strikethrough() {
 6403|       |        let spans = vec![
 6404|       |            InlineSpan::Text("alpha ".to_string()),
 6405|       |            InlineSpan::Strikethrough("beta".to_string()),
 6406|       |        ];
 6407|       |        let plain_text = MarkdownRenderer::spans_plain_text(&spans);
 6408|       |        assert_eq!(plain_text, "alpha beta");
 6409|       |    }
 6410|       |
 6411|       |    #[test]
 6412|       |    fn test_image_source_stale_detects_file_changes() {
 6413|       |        use std::time::Duration as StdDuration;
 6414|       |
 6415|       |        let dir = tempfile::tempdir().expect("temp dir");
 6416|       |        let file_path = dir.path().join("image.bin");
 6417|       |        std::fs::write(&file_path, [1u8, 2, 3, 4]).expect("write image");
 6418|       |        let initial = MarkdownRenderer::disk_image_timestamp(&file_path);
 6419|       |        assert!(!MarkdownRenderer::image_source_stale(initial, &file_path));
 6420|       |
 6421|       |        std::thread::sleep(StdDuration::from_millis(5));
 6422|       |        std::fs::write(&file_path, [4u8, 3, 2, 1]).expect("rewrite image");
 6423|       |
 6424|       |        assert!(MarkdownRenderer::image_source_stale(initial, &file_path));
 6425|       |
 6426|       |        std::fs::remove_file(&file_path).expect("remove image");
 6427|       |        assert!(MarkdownRenderer::image_source_stale(initial, &file_path));
 6428|       |    }
 6429|       |
 6430|       |    #[test]
 6431|       |    fn test_disk_image_timestamp_missing_returns_none() {
 6432|       |        let missing = std::path::Path::new("missing_image_timestamp.bin");
 6433|       |        assert!(MarkdownRenderer::disk_image_timestamp(missing).is_none());
 6434|       |    }
 6435|       |
 6436|       |    #[test]
 6437|       |    fn test_image_source_stale_with_timestamp_combinations() {
 6438|       |        let stamp = SystemTime::UNIX_EPOCH;
 6439|       |        assert!(MarkdownRenderer::image_source_stale_with_timestamp(
 6440|       |            Some(stamp),
 6441|       |            None
 6442|       |        ));
 6443|       |        assert!(MarkdownRenderer::image_source_stale_with_timestamp(
 6444|       |            None,
 6445|       |            Some(stamp)
 6446|       |        ));
 6447|       |        assert!(!MarkdownRenderer::image_source_stale_with_timestamp(
 6448|       |            None, None
 6449|       |        ));
 6450|       |    }
 6451|       |
 6452|       |    #[test]
 6453|       |    fn test_inline_code_preserves_whitespace() {
 6454|       |        let renderer = MarkdownRenderer::new();
 6455|       |        let md = "Start `code` end";
 6456|       |        let parsed = renderer.parse(md).expect("parse ok");
 6457|       |        let non_paragraph = MarkdownElement::HorizontalRule;
 6458|       |        let mut saw_paragraph = false;
 6459|       |        for element in [&parsed[0], &non_paragraph] {
 6460|       |            match element {
 6461|       |                MarkdownElement::Paragraph(spans) => {
 6462|       |                    let code_span = spans.iter().find_map(|span| match span {
 6463|       |                        InlineSpan::Code(t) => Some(t),
 6464|       |                        _ => None,
 6465|       |                    });
 6466|       |                    assert_eq!(code_span, Some(&"code".to_string()));
 6467|       |                    saw_paragraph = true;
 6468|       |                }
 6469|       |                _ => {}
 6470|       |            }
 6471|       |        }
 6472|       |        assert!(saw_paragraph);
 6473|       |    }
 6474|       |
 6475|       |    #[test]
 6476|       |    fn test_footnote_markers_render_as_visible_text() {
 6477|       |        let renderer = MarkdownRenderer::new();
 6478|       |        let md = "Paragraph with footnote[^1].\n\n[^1]: footnote body.";
 6479|       |        let parsed = renderer.parse(md).expect("parse ok");
 6480|       |        assert_eq!(parsed.len(), 2);
 6481|       |        let first_plain = MarkdownRenderer::element_plain_text(&parsed[0]);
 6482|       |        assert!(first_plain.contains("footnote[^1]"));
 6483|       |        let second_plain = MarkdownRenderer::element_plain_text(&parsed[1]);
 6484|       |        assert!(second_plain.contains("[^1]: footnote body."));
 6485|       |    }
 6486|       |
 6487|       |    #[test]
 6488|       |    fn test_parse_headers_assign_ids_and_dedupe() {
 6489|       |        let renderer = MarkdownRenderer::new();
 6490|       |        let md = "# Getting Started\n\nParagraph text.\n\n## Getting Started\n\n### API & Usage\n\n## API & Usage\n";
 6491|       |        let parsed = renderer.parse(md).expect("parse ok");
 6492|       |
 6493|       |        let mut ids = vec![];
 6494|       |        for el in parsed {
 6495|       |            if let MarkdownElement::Header { id, .. } = el {
 6496|       |                ids.push(id);
 6497|       |            }
 6498|       |        }
 6499|       |        assert_eq!(ids.len(), 4);
 6500|       |        assert_eq!(ids[0], "getting-started");
 6501|       |        assert_eq!(ids[1], "getting-started-1");
 6502|       |        assert_eq!(ids[2], "api-usage");
 6503|       |        assert_eq!(ids[3], "api-usage-1");
 6504|       |    }
 6505|       |
 6506|       |    #[test]
 6507|       |    fn test_formatting_sample_contains_expected_header_ids() {
 6508|       |        let renderer = MarkdownRenderer::new();
 6509|       |        let formatting = SAMPLE_FILES
 6510|       |            .iter()
 6511|       |            .find(|f| f.name == "formatting.md")
 6512|       |            .expect("formatting sample present");
 6513|       |        let parsed = renderer.parse(formatting.content).expect("parse ok");
 6514|       |        let ids: Vec<String> = parsed
 6515|       |            .into_iter()
 6516|       |            .filter_map(|el| match el {
 6517|       |                MarkdownElement::Header { id, .. } => Some(id),
 6518|       |                _ => None,
 6519|       |            })
 6520|       |            .collect();
 6521|       |
 6522|       |        for expected in [
 6523|       |            "markdown-formatting-guide",
 6524|       |            "table-of-contents",
 6525|       |            "text-formatting",
 6526|       |            "headers",
 6527|       |            "lists",
 6528|       |            "links-and-images",
 6529|       |            "emojis",
 6530|       |            "blockquotes",
 6531|       |            "horizontal-rules",
 6532|       |            "tables",
 6533|       |        ] {
 6534|       |            assert!(ids.iter().any(|id| id == expected));
 6535|       |        }
 6536|       |    }
 6537|       |
 6538|       |    #[test]
 6539|       |    fn test_inline_image_parsing() {
 6540|       |        let renderer = MarkdownRenderer::new();
 6541|       |        let md = "Here is an image: ![Alt text](images/pic.webp \"Title\") end.";
 6542|       |        let parsed = renderer.parse(md).expect("parse ok");
 6543|       |        assert_eq!(parsed.len(), 1);
 6544|       |        assert!(matches!(&parsed[0], MarkdownElement::Paragraph(_)));
 6545|       |        let non_paragraph = MarkdownElement::HorizontalRule;
 6546|       |        let mut saw_paragraph = false;
 6547|       |        for element in [&parsed[0], &non_paragraph] {
 6548|       |            match element {
 6549|       |                MarkdownElement::Paragraph(spans) => {
 6550|       |                    let img = spans.iter().find(|s| matches!(s, InlineSpan::Image { .. }));
 6551|       |                    assert!(img.is_some());
 6552|       |                    let (src, alt, title) = image_span_fields(img.unwrap()).expect("image span");
 6553|       |                    assert_eq!(src, "images/pic.webp");
 6554|       |                    assert_eq!(alt, "Alt text");
 6555|       |                    assert_eq!(title, Some("Title"));
 6556|       |                    saw_paragraph = true;
 6557|       |                }
 6558|       |                _ => {}
 6559|       |            }
 6560|       |        }
 6561|       |        assert!(saw_paragraph);
 6562|       |        assert!(image_span_fields(&InlineSpan::Text("nope".into())).is_none());
 6563|       |    }
 6564|       |
 6565|       |    #[test]
 6566|       |    fn test_image_text_in_plain_text_index() {
 6567|       |        let renderer = MarkdownRenderer::new();
 6568|       |        let md = "![Diagram](./a.png \"Flow\")";
 6569|       |        let parsed = renderer.parse(md).expect("parse ok");
 6570|       |        let text = MarkdownRenderer::element_plain_text(&parsed[0]);
 6571|       |        assert!(text.contains("Diagram"));
 6572|       |        assert!(text.contains("Flow"));
 6573|       |    }
 6574|       |
 6575|       |    #[test]
 6576|       |    fn test_element_plain_text_header_and_code_block() {
 6577|       |        let header = MarkdownElement::Header {
 6578|       |            level: 2,
 6579|       |            spans: vec![InlineSpan::Text("Title".to_string())],
 6580|       |            id: "title".to_string(),
 6581|       |        };
 6582|       |        let code = MarkdownElement::CodeBlock {
 6583|       |            text: "fn main() {}".to_string(),
 6584|       |            language: Some("rust".to_string()),
 6585|       |        };
 6586|       |        assert_eq!(
 6587|       |            MarkdownRenderer::element_plain_text(&header),
 6588|       |            "Title".to_string()
 6589|       |        );
 6590|       |        assert_eq!(
 6591|       |            MarkdownRenderer::element_plain_text(&code),
 6592|       |            "fn main() {}".to_string()
 6593|       |        );
 6594|       |    }
 6595|       |
 6596|       |    #[test]
 6597|       |    fn test_cell_fragments_split_text_and_images() {
 6598|       |        let renderer = MarkdownRenderer::new();
 6599|       |        let spans = vec![
 6600|       |            InlineSpan::Text("alpha".into()),
 6601|       |            InlineSpan::Strong("beta".into()),
 6602|       |            InlineSpan::Image {
 6603|       |                src: "img.png".into(),
 6604|       |                alt: "img".into(),
 6605|       |                title: None,
 6606|       |            },
 6607|       |            InlineSpan::Text("gamma".into()),
 6608|       |        ];
 6609|       |        let fragments = renderer.cell_fragments(&spans);
 6610|       |        assert_eq!(fragments.len(), 3);
 6611|       |        assert!(matches!(fragments[0], CellFragment::Text(_)));
 6612|       |        let mut saw_first_text = false;
 6613|       |        for fragment in [&fragments[0], &fragments[1]] {
 6614|       |            match fragment {
 6615|       |                CellFragment::Text(slice) => {
 6616|       |                    assert_eq!(slice.len(), 2);
 6617|       |                    saw_first_text = true;
 6618|       |                }
 6619|       |                _ => {}
 6620|       |            }
 6621|       |        }
 6622|       |        assert!(saw_first_text);
 6623|       |        assert!(matches!(fragments[1], CellFragment::Image(_)));
 6624|       |        let mut saw_image = false;
 6625|       |        for fragment in [&fragments[1], &fragments[0]] {
 6626|       |            match fragment {
 6627|       |                CellFragment::Image(span) => {
 6628|       |                    let (src, _alt, _title) = image_span_fields(span).expect("image span");
 6629|       |                    assert_eq!(src, "img.png");
 6630|       |                    saw_image = true;
 6631|       |                }
 6632|       |                _ => {}
 6633|       |            }
 6634|       |        }
 6635|       |        assert!(saw_image);
 6636|       |        assert!(matches!(fragments[2], CellFragment::Text(_)));
 6637|       |        let mut saw_last_text = false;
 6638|       |        for fragment in [&fragments[2], &fragments[1]] {
 6639|       |            match fragment {
 6640|       |                CellFragment::Text(slice) => {
 6641|       |                    assert_eq!(slice.len(), 1);
 6642|       |                    let content = text_span_content(&slice[0]).expect("text span");
 6643|       |                    assert_eq!(content, "gamma");
 6644|       |                    saw_last_text = true;
 6645|       |                }
 6646|       |                _ => {}
 6647|       |            }
 6648|       |        }
 6649|       |        assert!(saw_last_text);
 6650|       |        assert!(text_span_content(&InlineSpan::Image {
 6651|       |            src: "img.png".into(),
 6652|       |            alt: "img".into(),
 6653|       |            title: None,
 6654|       |        })
 6655|       |        .is_none());
 6656|       |    }
 6657|       |
 6658|       |    #[test]
 6659|       |    fn test_cell_fragments_leading_image() {
 6660|       |        let renderer = MarkdownRenderer::new();
 6661|       |        let spans = vec![
 6662|       |            InlineSpan::Image {
 6663|       |                src: "cover.png".into(),
 6664|       |                alt: "cover".into(),
 6665|       |                title: None,
 6666|       |            },
 6667|       |            InlineSpan::Text("tail".into()),
 6668|       |        ];
 6669|       |        let fragments = renderer.cell_fragments(&spans);
 6670|       |        assert_eq!(fragments.len(), 2);
 6671|       |        assert!(matches!(fragments[0], CellFragment::Image(_)));
 6672|       |        assert!(matches!(fragments[1], CellFragment::Text(_)));
 6673|       |    }
 6674|       |
 6675|       |    #[test]
 6676|       |    fn test_cell_fragments_detect_single_emoji_cell() {
 6677|       |        let renderer = MarkdownRenderer::new();
 6678|       |        let rocket = crate::emoji_catalog::shortcode_map()
 6679|       |            .get(":rocket:")
 6680|       |            .expect("rocket shortcode");
 6681|       |        let spans = vec![InlineSpan::Strong((*rocket).to_string())];
 6682|       |        let fragments = renderer.cell_fragments(&spans);
 6683|       |        assert_eq!(fragments.len(), 1);
 6684|       |        let key = emoji_fragment_key(&fragments[0]).expect("emoji fragment");
 6685|       |        assert!(!key.is_empty());
 6686|       |        let text_spans = vec![InlineSpan::Text("plain".into())];
 6687|       |        let fragment = CellFragment::Text(&text_spans);
 6688|       |        assert!(emoji_fragment_key(&fragment).is_none());
 6689|       |    }
 6690|       |
 6691|       |    #[test]
 6692|       |    fn test_cell_single_emoji_emphasis() {
 6693|       |        let renderer = MarkdownRenderer::new();
 6694|       |        let rocket = crate::emoji_catalog::shortcode_map()
 6695|       |            .get(":rocket:")
 6696|       |            .expect("rocket shortcode");
 6697|       |        let spans = vec![InlineSpan::Emphasis((*rocket).to_string())];
 6698|       |        assert!(renderer.cell_single_emoji(&spans).is_some());
 6699|       |    }
 6700|       |
 6701|       |    #[test]
 6702|       |    fn test_cell_single_emoji_strikethrough() {
 6703|       |        let renderer = MarkdownRenderer::new();
 6704|       |        let rocket = crate::emoji_catalog::shortcode_map()
 6705|       |            .get(":rocket:")
 6706|       |            .expect("rocket shortcode");
 6707|       |        let spans = vec![InlineSpan::Strikethrough((*rocket).to_string())];
 6708|       |        assert!(renderer.cell_single_emoji(&spans).is_some());
 6709|       |    }
 6710|       |
 6711|       |    #[test]
 6712|       |    fn test_cell_single_emoji_returns_none_for_code_and_link() {
 6713|       |        let renderer = MarkdownRenderer::new();
 6714|       |        let rocket = crate::emoji_catalog::shortcode_map()
 6715|       |            .get(":rocket:")
 6716|       |            .expect("rocket shortcode");
 6717|       |        let code_spans = vec![InlineSpan::Code((*rocket).to_string())];
 6718|       |        assert!(renderer.cell_single_emoji(&code_spans).is_none());
 6719|       |
 6720|       |        let link_spans = vec![InlineSpan::Link {
 6721|       |            text: (*rocket).to_string(),
 6722|       |            url: "https://example.com".to_string(),
 6723|       |        }];
 6724|       |        assert!(renderer.cell_single_emoji(&link_spans).is_none());
 6725|       |    }
 6726|       |
 6727|       |    #[test]
 6728|       |    fn test_cell_single_emoji_multiple_graphemes_returns_none() {
 6729|       |        let renderer = MarkdownRenderer::new();
 6730|       |        let spans = vec![InlineSpan::Text("ab".to_string())];
 6731|       |        assert!(renderer.cell_single_emoji(&spans).is_none());
 6732|       |    }
 6733|       |
 6734|       |    #[test]
 6735|       |    fn test_get_or_make_emoji_texture_falls_back_on_decode_error() {
 6736|       |        let renderer = MarkdownRenderer::new();
 6737|       |        let rocket = crate::emoji_catalog::shortcode_map()
 6738|       |            .get(":rocket:")
 6739|       |            .expect("rocket shortcode");
 6740|       |        force_emoji_decode_error_once();
 6741|       |        with_test_ui(|_, ui| {
 6742|       |            let _ = renderer.get_or_make_emoji_texture(ui, rocket);
 6743|       |        });
 6744|       |    }
 6745|       |
 6746|       |    #[test]
 6747|       |    fn test_get_or_make_emoji_texture_generates_on_decode_error() {
 6748|       |        let renderer = MarkdownRenderer::new();
 6749|       |        let fallback = [
 6750|       |            "\u{2705}",
 6751|       |            "\u{1f389}",
 6752|       |            "\u{1f680}",
 6753|       |            "\u{2764}",
 6754|       |            "\u{1f496}",
 6755|       |            "\u{2b50}",
 6756|       |            "\u{1f525}",
 6757|       |        ];
 6758|       |        let emoji = crate::emoji_catalog::shortcode_map()
 6759|       |            .values()
 6760|       |            .find(|emoji| {
 6761|       |                !fallback.contains(emoji) && emoji_catalog::image_bytes_for(emoji).is_some()
 6762|       |            })
 6763|       |            .expect("emoji outside fallback");
 6764|       |        assert!(emoji_assets::make_image(emoji, 64).is_none());
 6765|       |        force_emoji_decode_error_once();
 6766|       |        with_test_ui(|_, ui| {
 6767|       |            let _ = renderer.get_or_make_emoji_texture(ui, emoji);
 6768|       |        });
 6769|       |    }
 6770|       |
 6771|       |    #[test]
 6772|       |    fn test_cell_fragments_inline_emoji_stays_text() {
 6773|       |        let renderer = MarkdownRenderer::new();
 6774|       |        let rocket = crate::emoji_catalog::shortcode_map()
 6775|       |            .get(":rocket:")
 6776|       |            .expect("rocket shortcode");
 6777|       |        let spans = vec![
 6778|       |            InlineSpan::Text((*rocket).to_string()),
 6779|       |            InlineSpan::Text("tail".into()),
 6780|       |        ];
 6781|       |        let fragments = renderer.cell_fragments(&spans);
 6782|       |        assert_eq!(fragments.len(), 1);
 6783|       |        assert!(matches!(fragments[0], CellFragment::Text(_)));
 6784|       |        let dummy_span = InlineSpan::Image {
 6785|       |            src: "dummy.png".into(),
 6786|       |            alt: "dummy".into(),
 6787|       |            title: None,
 6788|       |        };
 6789|       |        let dummy_fragment = CellFragment::Image(&dummy_span);
 6790|       |        let mut saw_text = false;
 6791|       |        for fragment in [&fragments[0], &dummy_fragment] {
 6792|       |            match fragment {
 6793|       |                CellFragment::Text(slice) => {
 6794|       |                    assert_eq!(slice.len(), 2);
 6795|       |                    saw_text = true;
 6796|       |                }
 6797|       |                _ => {}
 6798|       |            }
 6799|       |        }
 6800|       |        assert!(saw_text);
 6801|       |    }
 6802|       |
 6803|       |    #[test]
 6804|       |    fn test_cell_fragments_keep_link_emoji_interactive() {
 6805|       |        let renderer = MarkdownRenderer::new();
 6806|       |        let rocket = crate::emoji_catalog::shortcode_map()
 6807|       |            .get(":rocket:")
 6808|       |            .expect("rocket shortcode");
 6809|       |        let spans = vec![InlineSpan::Link {
 6810|       |            text: (*rocket).to_string(),
 6811|       |            url: "https://example.com".to_string(),
 6812|       |        }];
 6813|       |        let fragments = renderer.cell_fragments(&spans);
 6814|       |        assert_eq!(fragments.len(), 1);
 6815|       |        assert!(matches!(fragments[0], CellFragment::Text(_)));
 6816|       |        let dummy_span = InlineSpan::Image {
 6817|       |            src: "dummy.png".into(),
 6818|       |            alt: "dummy".into(),
 6819|       |            title: None,
 6820|       |        };
 6821|       |        let dummy_fragment = CellFragment::Image(&dummy_span);
 6822|       |        let mut saw_link = false;
 6823|       |        for fragment in [&fragments[0], &dummy_fragment] {
 6824|       |            match fragment {
 6825|       |                CellFragment::Text(slice) => {
 6826|       |                    assert!(matches!(slice[0], InlineSpan::Link { .. }));
 6827|       |                    saw_link = true;
 6828|       |                }
 6829|       |                _ => {}
 6830|       |            }
 6831|       |        }
 6832|       |        assert!(saw_link);
 6833|       |    }
 6834|       |
 6835|       |    #[test]
 6836|       |    fn test_render_overhauled_cell_handles_emoji_fragment() {
 6837|       |        let renderer = MarkdownRenderer::new();
 6838|       |        let rocket = crate::emoji_catalog::shortcode_map()
 6839|       |            .get(":rocket:")
 6840|       |            .expect("rocket shortcode");
 6841|       |        let spans = vec![InlineSpan::Text((*rocket).to_string())];
 6842|       |        let ctx = egui::Context::default();
 6843|       |        let input = egui::RawInput {
 6844|       |            screen_rect: Some(egui::Rect::from_min_size(
 6845|       |                egui::pos2(0.0, 0.0),
 6846|       |                egui::vec2(240.0, 120.0),
 6847|       |            )),
 6848|       |            ..Default::default()
 6849|       |        };
 6850|       |        run_frame_with_input(&ctx, input, |_, ui| {
 6851|       |            let _ =
 6852|       |                renderer.render_overhauled_cell(ui, &spans, 120.0, false, Some(0), 0, Align::LEFT);
 6853|       |        });
 6854|       |    }
 6855|       |
 6856|       |    #[test]
 6857|       |    fn test_layout_job_builder_respects_wrap_width() {
 6858|       |        let renderer = MarkdownRenderer::new();
 6859|       |        let spans = vec![InlineSpan::Text(
 6860|       |            "A long column entry that should wrap neatly within the supplied width.".into(),
 6861|       |        )];
 6862|       |        let style = egui::Style::default();
 6863|       |        let build = renderer.build_layout_job(&style, &spans, 180.0, false, Align::LEFT);
 6864|       |        assert_eq!(build.job.wrap.max_width, 180.0);
 6865|       |        assert!(build.job.text.contains("column entry"));
 6866|       |    }
 6867|       |
 6868|       |    #[test]
 6869|       |    fn test_layout_job_builder_highlights_matches() {
 6870|       |        let renderer = MarkdownRenderer::new();
 6871|       |        renderer.set_highlight_phrase(Some("wrap"));
 6872|       |        let spans = vec![InlineSpan::Text("wrap me, wrap me again".into())];
 6873|       |        let style = egui::Style::default();
 6874|       |        let build = renderer.build_layout_job(&style, &spans, 200.0, false, Align::LEFT);
 6875|       |        let highlight_bg = style.visuals.selection.bg_fill;
 6876|       |        assert!(build
 6877|       |            .job
 6878|       |            .sections
 6879|       |            .iter()
 6880|       |            .any(|s| s.format.background == highlight_bg));
 6881|       |    }
 6882|       |
 6883|       |    #[test]
 6884|       |    fn test_layout_job_builder_tracks_link_ranges() {
 6885|       |        let renderer = MarkdownRenderer::new();
 6886|       |        let spans = vec![InlineSpan::Link {
 6887|       |            text: "Docs".into(),
 6888|       |            url: "https://example.org/docs".into(),
 6889|       |        }];
 6890|       |        let style = egui::Style::default();
 6891|       |        let build = renderer.build_layout_job(&style, &spans, 220.0, false, Align::LEFT);
 6892|       |        assert_eq!(build.link_ranges.len(), 1);
 6893|       |        let link = &build.link_ranges[0];
 6894|       |        assert_eq!(link.url, "https://example.org/docs");
 6895|       |        let char_len = link.char_range.end - link.char_range.start;
 6896|       |        let linked_text: String = build
 6897|       |            .job
 6898|       |            .text
 6899|       |            .chars()
 6900|       |            .skip(link.char_range.start)
 6901|       |            .take(char_len)
 6902|       |            .collect();
 6903|       |        assert_eq!(linked_text, "Docs");
 6904|       |    }
 6905|       |
 6906|       |    #[test]
 6907|       |    fn test_layout_job_builder_skips_empty_link_text() {
 6908|       |        let renderer = MarkdownRenderer::new();
 6909|       |        let spans = vec![InlineSpan::Link {
 6910|       |            text: String::new(),
 6911|       |            url: "https://example.org/docs".into(),
 6912|       |        }];
 6913|       |        let style = egui::Style::default();
 6914|       |        let build = renderer.build_layout_job(&style, &spans, 220.0, false, Align::LEFT);
 6915|       |        assert!(build.link_ranges.is_empty());
 6916|       |    }
 6917|       |
 6918|       |    #[test]
 6919|       |    fn test_build_layout_job_skips_images() {
 6920|       |        let renderer = MarkdownRenderer::new();
 6921|       |        let style = egui::Style::default();
 6922|       |        let spans = vec![InlineSpan::Image {
 6923|       |            src: "dummy.png".to_string(),
 6924|       |            alt: "alt".to_string(),
 6925|       |            title: None,
 6926|       |        }];
 6927|       |
 6928|       |        let build = renderer.build_layout_job(&style, &spans, 120.0, false, Align::LEFT);
 6929|       |        assert!(build.plain_text.is_empty());
 6930|       |    }
 6931|       |
 6932|       |    #[test]
 6933|       |    fn test_append_spans_empty_and_code_light() {
 6934|       |        let renderer = MarkdownRenderer::new();
 6935|       |        let style = egui::Style::default();
 6936|       |        let mut job = LayoutJob::default();
 6937|       |        let mut plain_text = String::new();
 6938|       |
 6939|       |        assert_eq!(
 6940|       |            renderer.append_plain_span(
 6941|       |                &style,
 6942|       |                &mut job,
 6943|       |                &mut plain_text,
 6944|       |                "",
 6945|       |                InlineStyle::default(),
 6946|       |                None
 6947|       |            ),
 6948|       |            0
 6949|       |        );
 6950|       |        assert_eq!(
 6951|       |            renderer.append_code_span(&style, &mut job, &mut plain_text, ""),
 6952|       |            0
 6953|       |        );
 6954|       |
 6955|       |        let mut light_style = style.clone();
 6956|       |        light_style.visuals.dark_mode = false;
 6957|       |        assert!(renderer.append_code_span(&light_style, &mut job, &mut plain_text, "code") > 0);
 6958|       |
 6959|       |        let mut empty_job = LayoutJob::default();
 6960|       |        let mut empty_plain = String::new();
 6961|       |        assert_eq!(
 6962|       |            renderer.append_text_sections(
 6963|       |                &style,
 6964|       |                &mut empty_job,
 6965|       |                &mut empty_plain,
 6966|       |                "",
 6967|       |                12.0,
 6968|       |                InlineStyle::default(),
 6969|       |                None
 6970|       |            ),
 6971|       |            0
 6972|       |        );
 6973|       |    }
 6974|       |
 6975|       |    #[test]
 6976|       |    fn test_is_html_line_break_and_indented_code_tabs() {
 6977|       |        assert!(!MarkdownRenderer::is_html_line_break("<b"));
 6978|       |        assert!(MarkdownRenderer::is_html_line_break("<br >"));
 6979|       |        assert!(!MarkdownRenderer::is_html_line_break("<brx>"));
 6980|       |        assert!(MarkdownRenderer::is_indented_code_line("\tcode"));
 6981|       |    }
 6982|       |
 6983|       |    #[test]
 6984|       |    fn test_is_html_line_break_rejects_missing_bracket() {
 6985|       |        assert!(!MarkdownRenderer::is_html_line_break("<br"));
 6986|       |        assert!(!MarkdownRenderer::is_html_line_break("<br/"));
 6987|       |    }
 6988|       |
 6989|       |    #[test]
 6990|       |    fn test_is_html_line_break_slash_variants() {
 6991|       |        assert!(MarkdownRenderer::is_html_line_break("<br/>"));
 6992|       |        assert!(!MarkdownRenderer::is_html_line_break("<br/ x>"));
 6993|       |    }
 6994|       |
 6995|       |    #[test]
 6996|       |    fn test_escape_pipes_inline_code_multi_backticks() {
 6997|       |        let out = MarkdownRenderer::escape_pipes_in_inline_code_line("``code|``");
 6998|       |        assert!(out.contains(PIPE_SENTINEL));
 6999|       |    }
 7000|       |
 7001|       |    #[test]
 7002|       |    fn test_escape_pipes_inline_code_line_branches() {
 7003|       |        let plain = "no pipes here";
 7004|       |        assert_eq!(
 7005|       |            MarkdownRenderer::escape_pipes_in_inline_code_line(plain),
 7006|       |            plain
 7007|       |        );
 7008|       |
 7009|       |        let line = "``code`|more``";
 7010|       |        let escaped = MarkdownRenderer::escape_pipes_in_inline_code_line(line);
 7011|       |        assert!(escaped.contains(PIPE_SENTINEL));
 7012|       |    }
 7013|       |
 7014|       |    #[test]
 7015|       |    fn test_escape_table_pipes_list_indent_with_tabs_and_table() {
 7016|       |        let input = "- Parent\n\t- Child\n  | Head | Tail |\n  | --- | --- |\n  | a | b |\n";
 7017|       |        let output = MarkdownRenderer::escape_table_pipes_in_inline_code(input);
 7018|       |        assert!(output.contains("| Head | Tail |"));
 7019|       |    }
 7020|       |
 7021|       |    #[test]
 7022|       |    fn test_escape_pipes_inline_code_line_restores_pending_on_unclosed() {
 7023|       |        let line = "`code|tail";
 7024|       |        let escaped = MarkdownRenderer::escape_pipes_in_inline_code_line(line);
 7025|       |        assert_eq!(escaped, line);
 7026|       |    }
 7027|       |
 7028|       |    #[test]
 7029|       |    fn test_table_width_solver_keeps_short_columns_readable() {
 7030|       |        let mins = vec![90.0, 90.0, 90.0, 90.0];
 7031|       |        let desired = vec![120.0, 120.0, 360.0, 160.0];
 7032|       |        let widths = MarkdownRenderer::resolve_table_widths(420.0, &mins, &desired);
 7033|       |        assert_eq!(widths.len(), 4);
 7034|       |        // Narrow columns should stay near their minimums even when a wide column exists
 7035|       |        assert!(widths[0] >= 85.0);
 7036|       |        assert!(widths[2] > widths[0]);
 7037|       |        let sum: f32 = widths.iter().sum();
 7038|       |        assert!((sum - 420.0).abs() < 0.5);
 7039|       |    }
 7040|       |
 7041|       |    #[test]
 7042|       |    fn test_table_width_solver_handles_constrained_space() {
 7043|       |        let mins = vec![100.0, 100.0, 100.0, 100.0];
 7044|       |        let desired = vec![200.0, 240.0, 360.0, 160.0];
 7045|       |        let widths = MarkdownRenderer::resolve_table_widths(260.0, &mins, &desired);
 7046|       |        assert_eq!(widths.len(), 4);
 7047|       |        assert!(widths.iter().all(|w| *w > 0.0));
 7048|       |        let sum: f32 = widths.iter().sum();
 7049|       |        assert!((sum - 260.0).abs() < 0.5);
 7050|       |    }
 7051|       |
 7052|       |    #[test]
 7053|       |    fn test_row_needs_height_estimate_for_emphasis_and_strike() {
 7054|       |        let renderer = MarkdownRenderer::new();
 7055|       |        let row = vec![vec![
 7056|       |            InlineSpan::Emphasis("alpha".to_string()),
 7057|       |            InlineSpan::Strikethrough("gamma\ndelta".to_string()),
 7058|       |        ]];
 7059|       |        assert!(renderer.row_needs_height_estimate(&row));
 7060|       |    }
 7061|       |
 7062|       |    #[test]
 7063|       |    fn test_row_needs_height_estimate_code_and_link_without_newlines() {
 7064|       |        let renderer = MarkdownRenderer::new();
 7065|       |        let row = vec![vec![
 7066|       |            InlineSpan::Code("code".to_string()),
 7067|       |            InlineSpan::Link {
 7068|       |                text: "link".to_string(),
 7069|       |                url: "https://example.com".to_string(),
 7070|       |            },
 7071|       |        ]];
 7072|       |        assert!(!renderer.row_needs_height_estimate(&row));
 7073|       |    }
 7074|       |
 7075|       |    #[test]
 7076|       |    fn test_resolve_table_rects_clip_rect_fallbacks() {
 7077|       |        let renderer = MarkdownRenderer::new();
 7078|       |        let widths = vec![12.0];
 7079|       |        let body_clip = egui::Rect::from_min_max(egui::pos2(1.0, 2.0), egui::pos2(3.0, 4.0));
 7080|       |        let (rect, clip) =
 7081|       |            renderer.resolve_table_rects(None, None, None, None, Some(body_clip), &widths, 4.0);
 7082|       |        assert_eq!(clip, body_clip);
 7083|       |
 7084|       |        let (rect2, clip2) =
 7085|       |            renderer.resolve_table_rects(None, None, None, None, None, &widths, 4.0);
 7086|       |        assert_eq!(clip2, rect2);
 7087|       |        assert_eq!(rect2.min, egui::pos2(0.0, 0.0));
 7088|       |        assert_eq!(rect2.max, egui::pos2(0.0, 0.0));
 7089|       |        assert_eq!(rect.min, egui::pos2(0.0, 0.0));
 7090|       |    }
 7091|       |
 7092|       |    #[test]
 7093|       |    fn test_resolve_table_rects_prefers_layout_then_header_then_body() {
 7094|       |        let renderer = MarkdownRenderer::new();
 7095|       |        let widths = vec![10.0, 20.0];
 7096|       |        let layout = egui::Rect::from_min_max(egui::pos2(5.0, 6.0), egui::pos2(25.0, 26.0));
 7097|       |        let header = egui::Rect::from_min_max(egui::pos2(1.0, 2.0), egui::pos2(9.0, 12.0));
 7098|       |        let body = egui::Rect::from_min_max(egui::pos2(2.0, 3.0), egui::pos2(14.0, 18.0));
 7099|       |
 7100|       |        let (rect, _) = renderer.resolve_table_rects(
 7101|       |            Some(header),
 7102|       |            Some(body),
 7103|       |            Some(layout),
 7104|       |            None,
 7105|       |            None,
 7106|       |            &widths,
 7107|       |            4.0,
 7108|       |        );
 7109|       |        assert_eq!(rect.min.x, layout.min.x);
 7110|       |
 7111|       |        let (rect, _) =
 7112|       |            renderer.resolve_table_rects(Some(header), None, None, None, None, &widths, 4.0);
 7113|       |        assert_eq!(rect.min.x, header.min.x);
 7114|       |
 7115|       |        let (rect, _) =
 7116|       |            renderer.resolve_table_rects(None, Some(body), None, None, None, &widths, 4.0);
 7117|       |        assert_eq!(rect.min.x, body.min.x);
 7118|       |    }
 7119|       |
 7120|       |    #[test]
 7121|       |    fn test_resolve_table_rects_layout_only_fallbacks() {
 7122|       |        let renderer = MarkdownRenderer::new();
 7123|       |        let widths = vec![12.0];
 7124|       |        let layout = egui::Rect::from_min_max(egui::pos2(4.0, 7.0), egui::pos2(18.0, 21.0));
 7125|       |        let (rect, _) = renderer.resolve_table_rects(
 7126|       |            None,
 7127|       |            None,
 7128|       |            Some(layout),
 7129|       |            None,
 7130|       |            None,
 7131|       |            &widths,
 7132|       |            4.0,
 7133|       |        );
 7134|       |        assert_eq!(rect.min.y, layout.min.y);
 7135|       |        assert_eq!(rect.max.y, layout.max.y);
 7136|       |    }
 7137|       |
 7138|       |    #[test]
 7139|       |    fn table_cells_keep_images_and_formatting() {
 7140|       |        let renderer = MarkdownRenderer::new();
 7141|       |        let md = "\
 7142|       |Intro
 7143|       |
 7144|       || H1 | H2 |
 7145|       || --- | --- |
 7146|       || text **extra** ![Alt](img.png) | **bold** and [link](https://example.com) |";
 7147|       |        let elements = renderer.parse(md).expect("parse ok");
 7148|       |        let table = elements
 7149|       |            .iter()
 7150|       |            .find_map(|el| match el {
 7151|       |                MarkdownElement::Table {
 7152|       |                    headers: _,
 7153|       |                    rows,
 7154|       |                    alignments: _,
 7155|       |                } => Some(rows),
 7156|       |                _ => None,
 7157|       |            })
 7158|       |            .expect("table present");
 7159|       |        assert_eq!(table.len(), 1);
 7160|       |        let row = &table[0];
 7161|       |        let mut saw_image = false;
 7162|       |        let mut saw_text = false;
 7163|       |        for span in &row[0] {
 7164|       |            match span {
 7165|       |                InlineSpan::Image { .. } => saw_image = true,
 7166|       |                InlineSpan::Text(_) => saw_text = true,
 7167|       |                _ => {}
 7168|       |            }
 7169|       |        }
 7170|       |        assert!(saw_image);
 7171|       |        assert!(saw_text);
 7172|       |        let mut saw_strong = false;
 7173|       |        let mut saw_link = false;
 7174|       |        let mut saw_other = false;
 7175|       |        for span in &row[1] {
 7176|       |            match span {
 7177|       |                InlineSpan::Strong(_) => saw_strong = true,
 7178|       |                InlineSpan::Link { .. } => saw_link = true,
 7179|       |                _ => saw_other = true,
 7180|       |            }
 7181|       |        }
 7182|       |        assert!(saw_strong);
 7183|       |        assert!(saw_link);
 7184|       |        assert!(saw_other);
 7185|       |    }
 7186|       |
 7187|       |    #[test]
 7188|       |    fn table_inline_code_keeps_pipes() {
 7189|       |        let renderer = MarkdownRenderer::new();
 7190|       |        let md = "\
 7191|       |Intro
 7192|       |
 7193|       || Col | Notes |
 7194|       || --- | --- |
 7195|       || code | see `a|b|c` |";
 7196|       |        let elements = renderer.parse(md).expect("parse ok");
 7197|       |        let rows = elements
 7198|       |            .iter()
 7199|       |            .find_map(|el| match el {
 7200|       |                MarkdownElement::Table {
 7201|       |                    headers: _,
 7202|       |                    rows,
 7203|       |                    alignments: _,
 7204|       |                } => Some(rows),
 7205|       |                _ => None,
 7206|       |            })
 7207|       |            .expect("table present");
 7208|       |        let code_text = rows[0][1]
 7209|       |            .iter()
 7210|       |            .find_map(|span| match span {
 7211|       |                InlineSpan::Code(text) => Some(text.as_str()),
 7212|       |                _ => None,
 7213|       |            })
 7214|       |            .expect("code span");
 7215|       |        assert_eq!(code_text, "a|b|c");
 7216|       |    }
 7217|       |
 7218|       |    #[test]
 7219|       |    fn indented_code_block_table_like_preserves_pipes() {
 7220|       |        let md = "\
 7221|       |    | Col | Notes |
 7222|       |    | --- | --- |
 7223|       |    | code | `a|b|c` |";
 7224|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7225|       |        assert!(prepared.contains("`a|b|c`"));
 7226|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7227|       |    }
 7228|       |
 7229|       |    #[test]
 7230|       |    fn blockquote_table_inline_code_escapes_pipes() {
 7231|       |        let md = "\
 7232|       |> | Col | Notes |
 7233|       |> | --- | --- |
 7234|       |> | code | `a|b|c` |";
 7235|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7236|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7237|       |        assert!(prepared.contains(&expected));
 7238|       |    }
 7239|       |
 7240|       |    #[test]
 7241|       |    fn blockquote_tab_table_inline_code_escapes_pipes() {
 7242|       |        let md = ">\t| Col | Notes |\n>\t| --- | --- |\n>\t| code | `a|b|c` |";
 7243|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7244|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7245|       |        assert!(prepared.contains(&expected));
 7246|       |    }
 7247|       |
 7248|       |    #[test]
 7249|       |    fn blockquote_table_after_paragraph_parses() -> Result<()> {
 7250|       |        let renderer = MarkdownRenderer::new();
 7251|       |        let md = "\
 7252|       |Prelude
 7253|       |
 7254|       |> Intro line
 7255|       |> | Col | Notes |
 7256|       |> | --- | --- |
 7257|       |> | A | B |";
 7258|       |        let elements = renderer.parse(md)?;
 7259|       |        let blocks = elements
 7260|       |            .iter()
 7261|       |            .find_map(|el| match el {
 7262|       |                MarkdownElement::Quote { blocks, .. } => Some(blocks),
 7263|       |                _ => None,
 7264|       |            })
 7265|       |            .expect("quote block");
 7266|       |        assert!(blocks
 7267|       |            .iter()
 7268|       |            .any(|block| matches!(block, MarkdownElement::Table { .. })));
 7269|       |        Ok(())
 7270|       |    }
 7271|       |
 7272|       |    #[test]
 7273|       |    fn blockquote_list_table_after_paragraph_parses() -> Result<()> {
 7274|       |        let renderer = MarkdownRenderer::new();
 7275|       |        let md = "\
 7276|       |Prelude
 7277|       |
 7278|       |> Note before list
 7279|       |> - Item:
 7280|       |>   | Key | Val |
 7281|       |>   | --- | --- |
 7282|       |>   | A | 1 |";
 7283|       |        let elements = renderer.parse(md)?;
 7284|       |        let blocks = elements
 7285|       |            .iter()
 7286|       |            .find_map(|el| match el {
 7287|       |                MarkdownElement::Quote { blocks, .. } => Some(blocks),
 7288|       |                _ => None,
 7289|       |            })
 7290|       |            .expect("quote block");
 7291|       |        let list = blocks
 7292|       |            .iter()
 7293|       |            .find_map(|block| match block {
 7294|       |                MarkdownElement::List { items, .. } => Some(items),
 7295|       |                _ => None,
 7296|       |            })
 7297|       |            .expect("list block");
 7298|       |        let first = list.first().expect("list item");
 7299|       |        assert!(first
 7300|       |            .blocks
 7301|       |            .iter()
 7302|       |            .any(|block| matches!(block, MarkdownElement::Table { .. })));
 7303|       |        Ok(())
 7304|       |    }
 7305|       |
 7306|       |    #[test]
 7307|       |    fn blockquote_indented_code_block_preserves_pipes() {
 7308|       |        let md = "\
 7309|       |>     | Col | Notes |
 7310|       |>     | --- | --- |
 7311|       |>     | code | `a|b|c` |";
 7312|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7313|       |        assert!(prepared.contains("`a|b|c`"));
 7314|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7315|       |    }
 7316|       |
 7317|       |    #[test]
 7318|       |    fn blockquote_fenced_code_block_preserves_pipes() {
 7319|       |        let md = "\
 7320|       |> ```
 7321|       |> | Col | Notes |
 7322|       |> | --- | --- |
 7323|       |> | code | `a|b|c` |
 7324|       |> ```";
 7325|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7326|       |        assert!(prepared.contains("`a|b|c`"));
 7327|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7328|       |    }
 7329|       |
 7330|       |    #[test]
 7331|       |    fn list_fenced_code_block_preserves_pipes() {
 7332|       |        let md = "\
 7333|       |- ```
 7334|       |  | Col | Notes |
 7335|       |  | --- | --- |
 7336|       |  | code | `a|b|c` |
 7337|       |  ```";
 7338|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7339|       |        assert!(prepared.contains("`a|b|c`"));
 7340|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7341|       |    }
 7342|       |
 7343|       |    #[test]
 7344|       |    fn list_blockquote_fenced_code_block_preserves_pipes() {
 7345|       |        let md = "\
 7346|       |- Item
 7347|       |    > ```
 7348|       |    > | Col | Notes |
 7349|       |    > | --- | --- |
 7350|       |    > | code | `a|b|c` |
 7351|       |    > ```";
 7352|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7353|       |        assert!(prepared.contains("`a|b|c`"));
 7354|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7355|       |    }
 7356|       |
 7357|       |    #[test]
 7358|       |    fn nested_list_fenced_code_block_preserves_pipes() {
 7359|       |        let md = "\
 7360|       |- Outer
 7361|       |    - ```
 7362|       |      | Col | Notes |
 7363|       |      | --- | --- |
 7364|       |      | code | `a|b|c` |
 7365|       |      ```";
 7366|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7367|       |        assert!(prepared.contains("`a|b|c`"));
 7368|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7369|       |    }
 7370|       |
 7371|       |    #[test]
 7372|       |    fn list_item_code_block_preserves_pipes() {
 7373|       |        let md = "\
 7374|       |- Item
 7375|       |      | Col | Notes |
 7376|       |      | --- | --- |
 7377|       |      | code | `a|b|c` |";
 7378|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7379|       |        assert!(prepared.contains("`a|b|c`"));
 7380|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7381|       |    }
 7382|       |
 7383|       |    #[test]
 7384|       |    fn nested_list_table_inline_code_escapes_pipes() {
 7385|       |        let md = "\
 7386|       |- Outer
 7387|       |  - | Col | Notes |
 7388|       |    | --- | --- |
 7389|       |    | code | `a|b|c` |";
 7390|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7391|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7392|       |        assert!(prepared.contains(&expected));
 7393|       |    }
 7394|       |
 7395|       |    #[test]
 7396|       |    fn nested_list_tab_table_inline_code_escapes_pipes() {
 7397|       |        let md = "- Outer\n\t- | Col | Notes |\n\t  | --- | --- |\n\t  | code | `a|b|c` |";
 7398|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7399|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7400|       |        assert!(prepared.contains(&expected));
 7401|       |    }
 7402|       |
 7403|       |    #[test]
 7404|       |    fn nested_list_four_space_table_inline_code_escapes_pipes() {
 7405|       |        let md = "\
 7406|       |- Outer
 7407|       |    - | Col | Notes |
 7408|       |      | --- | --- |
 7409|       |      | code | `a|b|c` |";
 7410|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7411|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7412|       |        assert!(prepared.contains(&expected));
 7413|       |    }
 7414|       |
 7415|       |    #[test]
 7416|       |    fn list_marker_four_space_table_inline_code_escapes_pipes() {
 7417|       |        let md = "\
 7418|       |-    | Col | Notes |
 7419|       |     | --- | --- |
 7420|       |     | code | `a|b|c` |";
 7421|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7422|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7423|       |        assert!(prepared.contains(&expected));
 7424|       |    }
 7425|       |
 7426|       |    #[test]
 7427|       |    fn nested_list_indented_code_block_preserves_pipes() {
 7428|       |        let md = "\
 7429|       |- Outer
 7430|       |      - | Col | Notes |
 7431|       |        | --- | --- |
 7432|       |        | code | `a|b|c` |";
 7433|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7434|       |        assert!(prepared.contains("`a|b|c`"));
 7435|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7436|       |    }
 7437|       |
 7438|       |    #[test]
 7439|       |    fn deeply_nested_list_table_inline_code_escapes_pipes() {
 7440|       |        let md = "\
 7441|       |- Outer
 7442|       |    - Inner
 7443|       |        - | Col | Notes |
 7444|       |          | --- | --- |
 7445|       |          | code | `a|b|c` |";
 7446|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7447|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7448|       |        assert!(prepared.contains(&expected));
 7449|       |    }
 7450|       |
 7451|       |    #[test]
 7452|       |    fn list_blockquote_table_inline_code_escapes_pipes() {
 7453|       |        let md = "\
 7454|       |- Item
 7455|       |    > | Col | Notes |
 7456|       |    > | --- | --- |
 7457|       |    > | code | `a|b|c` |";
 7458|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7459|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7460|       |        assert!(prepared.contains(&expected));
 7461|       |    }
 7462|       |
 7463|       |    #[test]
 7464|       |    fn list_marker_blockquote_table_inline_code_escapes_pipes() {
 7465|       |        let md = "\
 7466|       |- > | Col | Notes |
 7467|       |  > | --- | --- |
 7468|       |  > | code | `a|b|c` |";
 7469|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7470|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7471|       |        assert!(prepared.contains(&expected));
 7472|       |    }
 7473|       |
 7474|       |    #[test]
 7475|       |    fn list_marker_table_dedent_does_not_escape_pipes() {
 7476|       |        let md = "\
 7477|       |- | Col | `a|b|c` |
 7478|       || --- | --- |
 7479|       || row | ok |";
 7480|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7481|       |        assert!(prepared.contains("`a|b|c`"));
 7482|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7483|       |    }
 7484|       |
 7485|       |    #[test]
 7486|       |    fn blockquote_list_table_inline_code_escapes_pipes() {
 7487|       |        let md = "\
 7488|       |> - | Col | Notes |
 7489|       |>   | --- | --- |
 7490|       |>   | code | `a|b|c` |";
 7491|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7492|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7493|       |        assert!(prepared.contains(&expected));
 7494|       |    }
 7495|       |
 7496|       |    #[test]
 7497|       |    fn list_marker_line_table_inline_code_escapes_pipes() {
 7498|       |        let md = "\
 7499|       |10. 
 7500|       |    | Col | Notes |
 7501|       |    | --- | --- |
 7502|       |    | code | `a|b|c` |";
 7503|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7504|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7505|       |        assert!(prepared.contains(&expected));
 7506|       |    }
 7507|       |
 7508|       |    #[test]
 7509|       |    fn list_marker_tab_after_marker_uses_tab_stops() {
 7510|       |        let line = "-\titem";
 7511|       |        let (_content, indent, content_indent) =
 7512|       |            MarkdownRenderer::list_marker_info(line).expect("list marker");
 7513|       |        assert_eq!(indent, 3);
 7514|       |        assert_eq!(content_indent, 4);
 7515|       |    }
 7516|       |
 7517|       |    #[test]
 7518|       |    fn list_marker_any_indent_tab_stops_leading_whitespace() {
 7519|       |        let line = " \t- item";
 7520|       |        let (_content, _indent, _content_indent, leading) =
 7521|       |            MarkdownRenderer::list_marker_info_any_indent(line).expect("list marker");
 7522|       |        assert_eq!(leading, 4);
 7523|       |    }
 7524|       |
 7525|       |    #[test]
 7526|       |    fn table_ends_before_inline_code_paragraph() {
 7527|       |        let md = "\
 7528|       || Col | Notes |
 7529|       || --- | --- |
 7530|       || code | `a|b|c` |
 7531|       |Paragraph with `x|y` inline.";
 7532|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7533|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7534|       |        assert!(prepared.contains(&expected));
 7535|       |        assert!(prepared.contains("`x|y`"));
 7536|       |    }
 7537|       |
 7538|       |    #[test]
 7539|       |    fn table_ends_before_escaped_pipe_paragraph() {
 7540|       |        let md = "\
 7541|       || Col | Notes |
 7542|       || --- | --- |
 7543|       || code | `a|b|c` |
 7544|       |Paragraph with escaped \\| pipe.";
 7545|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7546|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7547|       |        assert!(prepared.contains(&expected));
 7548|       |        assert!(prepared.contains("escaped \\| pipe"));
 7549|       |    }
 7550|       |
 7551|       |    #[test]
 7552|       |    fn list_table_ends_on_dedent_with_pipe_paragraph() {
 7553|       |        let md = "\
 7554|       |- | Col | Notes |
 7555|       |  | --- | --- |
 7556|       |  | code | `a|b|c` |
 7557|       |Paragraph with `x|y` and pipe | outside.";
 7558|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7559|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7560|       |        assert!(prepared.contains(&expected));
 7561|       |        assert!(prepared.contains("`x|y`"));
 7562|       |    }
 7563|       |
 7564|       |    #[test]
 7565|       |    fn nested_list_table_ends_on_dedent_with_pipe_paragraph() {
 7566|       |        let md = "\
 7567|       |- Outer
 7568|       |  - | Col | Notes |
 7569|       |    | --- | --- |
 7570|       |    | code | `a|b|c` |
 7571|       |  Paragraph with `x|y` and pipe | outside.";
 7572|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7573|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7574|       |        assert!(prepared.contains(&expected));
 7575|       |        assert!(prepared.contains("`x|y`"));
 7576|       |    }
 7577|       |
 7578|       |    #[test]
 7579|       |    fn list_table_tab_dedent_keeps_inline_code_unescaped() {
 7580|       |        let md =
 7581|       |            "- Outer\n\t- | Col | Notes |\n\t  | --- | --- |\n\t  | code | `a|b|c` |\nParagraph with `x|y` and pipe | outside.";
 7582|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7583|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7584|       |        assert!(prepared.contains(&expected));
 7585|       |        assert!(prepared.contains("`x|y`"));
 7586|       |    }
 7587|       |
 7588|       |    #[test]
 7589|       |    fn list_blank_line_table_inline_code_escapes_pipes() {
 7590|       |        let md = "\
 7591|       |- Item
 7592|       |
 7593|       |    | Col | Notes |
 7594|       |    | --- | --- |
 7595|       |    | code | `a|b|c` |";
 7596|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7597|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7598|       |        assert!(prepared.contains(&expected));
 7599|       |    }
 7600|       |
 7601|       |    #[test]
 7602|       |    fn table_delimiter_requires_pipe() {
 7603|       |        let md = "\
 7604|       |`a|b` | Header
 7605|       |---
 7606|       |Not a table";
 7607|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7608|       |        assert!(prepared.contains("`a|b`"));
 7609|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7610|       |    }
 7611|       |
 7612|       |    #[test]
 7613|       |    fn table_unmatched_backticks_do_not_escape_pipes() {
 7614|       |        let md = "\
 7615|       || Col | Notes |
 7616|       || --- | --- |
 7617|       || code | `a|b |";
 7618|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7619|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7620|       |    }
 7621|       |
 7622|       |    #[test]
 7623|       |    fn table_escaped_backticks_do_not_escape_pipes() {
 7624|       |        let md = "\
 7625|       || Col | Notes |
 7626|       || --- | --- |
 7627|       || text | \\`a|b\\` |";
 7628|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7629|       |        assert!(prepared.contains("\\`a|b\\`"));
 7630|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7631|       |    }
 7632|       |
 7633|       |    #[test]
 7634|       |    fn list_parent_indent_nested_marker_table_escapes_pipes() {
 7635|       |        let md = "\
 7636|       |- Parent
 7637|       |    - | Col | Notes |
 7638|       |      | --- | --- |
 7639|       |      | code | `a|b|c` |";
 7640|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7641|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7642|       |        assert!(prepared.contains(&expected));
 7643|       |    }
 7644|       |
 7645|       |    #[test]
 7646|       |    fn list_parent_indent_table_without_marker_escapes_pipes() {
 7647|       |        let md = "\
 7648|       |- Parent
 7649|       |  | Col | Notes |
 7650|       |  | --- | --- |
 7651|       |  | code | `a|b|c` |";
 7652|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7653|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7654|       |        assert!(prepared.contains(&expected));
 7655|       |    }
 7656|       |
 7657|       |    #[test]
 7658|       |    fn table_blockquote_level_mismatch_ends_table() {
 7659|       |        let md = "\
 7660|       || Col | Notes |
 7661|       || --- | --- |
 7662|       |> | code | `a|b|c` |";
 7663|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7664|       |        assert!(prepared.contains("`a|b|c`"));
 7665|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7666|       |    }
 7667|       |
 7668|       |    #[test]
 7669|       |    fn table_inserts_blank_line_before_header_with_crlf() {
 7670|       |        let md = "Intro line\r\n| Col | Notes |\r\n| --- | --- |\r\n| code | `a|b|c` |\r\n";
 7671|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7672|       |        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7673|       |        assert!(prepared.contains("\r\n\r\n| Col | Notes |"));
 7674|       |        assert!(prepared.contains(&expected));
 7675|       |    }
 7676|       |
 7677|       |    #[test]
 7678|       |    fn fenced_block_quote_level_mismatch_keeps_block_open() {
 7679|       |        let md = "\
 7680|       |> ```
 7681|       |> | Col | Notes |
 7682|       |```
 7683|       |> | --- | --- |
 7684|       |> | code | `a|b|c` |
 7685|       |> ```";
 7686|       |        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7687|       |        assert!(prepared.contains("`a|b|c`"));
 7688|       |        assert!(!prepared.contains(PIPE_SENTINEL));
 7689|       |    }
 7690|       |
 7691|       |    #[test]
 7692|       |    fn table_ids_are_unique_per_position() {
 7693|       |        let renderer = MarkdownRenderer::new();
 7694|       |        let md = "\
 7695|       |Intro
 7696|       |
 7697|       || H |
 7698|       || - |
 7699|       || a |
 7700|       |
 7701|       || H |
 7702|       || - |
 7703|       || a |";
 7704|       |        let elements = renderer.parse(md).expect("parse ok");
 7705|       |        let tables: Vec<_> = elements
 7706|       |            .iter()
 7707|       |            .enumerate()
 7708|       |            .filter_map(|(idx, el)| match el {
 7709|       |                MarkdownElement::Table {
 7710|       |                    headers,
 7711|       |                    rows,
 7712|       |                    alignments,
 7713|       |                } => Some(renderer.compute_table_id(headers, rows, alignments, idx as u64)),
 7714|       |                _ => None,
 7715|       |            })
 7716|       |            .collect();
 7717|       |        assert_eq!(tables.len(), 2);
 7718|       |        assert_ne!(tables[0], tables[1]);
 7719|       |    }
 7720|       |
 7721|       |    #[test]
 7722|       |    fn test_render_to_ui_rich_document_populates_rects_and_table_stats() {
 7723|       |        let renderer = MarkdownRenderer::new();
 7724|       |        let md = "\
 7725|       |# Coverage Demo
 7726|       |
 7727|       |Paragraph with :tada: emoji and **bold** text and a [link](#target).
 7728|       |
 7729|       |> Quote line one
 7730|       |> Quote line two
 7731|       |
 7732|       |- item one
 7733|       |- item two
 7734|       |
 7735|       |---
 7736|       |
 7737|       |```rust
 7738|       |fn main() {}
 7739|       |```
 7740|       |
 7741|       || Col A | Col B |
 7742|       || --- | --- |
 7743|       || A1 | B1 |
 7744|       || A2 | B2 |
 7745|       |
 7746|       |![Logo](assets/samples/logo.svg \"Logo\")
 7747|       |![Sample](assets/samples/webp_sample.webp \"Sample\")
 7748|       |![Missing](missing_test_image.png \"Missing\")
 7749|       |![Remote](https://example.com/image.png \"Remote\")
 7750|       |";
 7751|       |
 7752|       |        let elements = renderer.parse(md).expect("parse ok");
 7753|       |        renderer.set_highlight_phrase(Some("item"));
 7754|       |
 7755|       |        with_test_ui(|_, ui| {
 7756|       |            renderer.render_to_ui(ui, &elements);
 7757|       |        });
 7758|       |
 7759|       |        assert!(renderer.element_rect_at(0).is_some());
 7760|       |        assert!(renderer.header_rect_for("coverage-demo").is_some());
 7761|       |        let (rendered, total) = renderer.table_render_stats();
 7762|       |        assert!(total > 0);
 7763|       |        assert!(rendered > 0);
 7764|       |        let (_hits, misses) = renderer.table_layout_cache_stats();
 7765|       |        assert!(misses > 0);
 7766|       |    }
 7767|       |
 7768|       |    #[test]
 7769|       |    fn test_table_layout_cache_records_hits() {
 7770|       |        let renderer = MarkdownRenderer::new();
 7771|       |        let spans = vec![InlineSpan::Text("alpha".to_string())];
 7772|       |        let style = egui::Style::default();
 7773|       |
 7774|       |        let _ = renderer.cached_layout_job(&style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
 7775|       |        let _ = renderer.cached_layout_job(&style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
 7776|       |
 7777|       |        let (hits, misses) = renderer.table_layout_cache_stats();
 7778|       |        assert!(hits >= 1);
 7779|       |        assert!(misses >= 1);
 7780|       |
 7781|       |        renderer.clear_table_layout_cache();
 7782|       |        assert_eq!(renderer.table_layout_cache_stats(), (0, 0));
 7783|       |    }
 7784|       |
 7785|       |    #[test]
 7786|       |    fn test_cell_layout_cache_eviction() {
 7787|       |        let mut cache = CellLayoutCache::new(2);
 7788|       |        let build = LayoutJobBuild {
 7789|       |            job: LayoutJob::default(),
 7790|       |            plain_text: String::new(),
 7791|       |            link_ranges: Vec::new(),
 7792|       |        };
 7793|       |        let key = |row, col| CellLayoutKey {
 7794|       |            row: Some(row),
 7795|       |            col,
 7796|       |            width: 120,
 7797|       |            align: 0,
 7798|       |            strong: false,
 7799|       |            text_color: [0, 0, 0, 255],
 7800|       |            highlight_hash: 0,
 7801|       |            content_hash: row as u64,
 7802|       |        };
 7803|       |
 7804|       |        let key_a = key(0, 0);
 7805|       |        let key_b = key(1, 0);
 7806|       |        let key_c = key(2, 0);
 7807|       |
 7808|       |        cache.insert(key_a.clone(), build.clone());
 7809|       |        cache.insert(key_b.clone(), build.clone());
 7810|       |        cache.insert(key_c.clone(), build);
 7811|       |
 7812|       |        assert!(cache.get(&key_a).is_none());
 7813|       |        assert!(cache.get(&key_b).is_some());
 7814|       |        assert!(cache.get(&key_c).is_some());
 7815|       |    }
 7816|       |
 7817|       |    #[test]
 7818|       |    fn test_cell_layout_cache_handles_empty_order() {
 7819|       |        let mut cache = CellLayoutCache::new(1);
 7820|       |        let build = LayoutJobBuild {
 7821|       |            job: LayoutJob::default(),
 7822|       |            plain_text: String::new(),
 7823|       |            link_ranges: Vec::new(),
 7824|       |        };
 7825|       |        let key_a = CellLayoutKey {
 7826|       |            row: Some(0),
 7827|       |            col: 0,
 7828|       |            width: 120,
 7829|       |            align: 0,
 7830|       |            strong: false,
 7831|       |            text_color: [0, 0, 0, 255],
 7832|       |            highlight_hash: 0,
 7833|       |            content_hash: 1,
 7834|       |        };
 7835|       |        let key_b = CellLayoutKey {
 7836|       |            row: Some(1),
 7837|       |            col: 0,
 7838|       |            width: 120,
 7839|       |            align: 0,
 7840|       |            strong: false,
 7841|       |            text_color: [0, 0, 0, 255],
 7842|       |            highlight_hash: 0,
 7843|       |            content_hash: 2,
 7844|       |        };
 7845|       |
 7846|       |        cache.insert(key_a, build.clone());
 7847|       |        cache.order.clear();
 7848|       |        cache.insert(key_b.clone(), build);
 7849|       |
 7850|       |        assert!(cache.get(&key_b).is_some());
 7851|       |    }
 7852|       |
 7853|       |    #[test]
 7854|       |    fn test_cell_layout_cache_reinsert_existing_key() {
 7855|       |        let mut cache = CellLayoutCache::new(1);
 7856|       |        let build = LayoutJobBuild {
 7857|       |            job: LayoutJob::default(),
 7858|       |            plain_text: String::new(),
 7859|       |            link_ranges: Vec::new(),
 7860|       |        };
 7861|       |        let key = CellLayoutKey {
 7862|       |            row: Some(0),
 7863|       |            col: 0,
 7864|       |            width: 120,
 7865|       |            align: 0,
 7866|       |            strong: false,
 7867|       |            text_color: [0, 0, 0, 255],
 7868|       |            highlight_hash: 0,
 7869|       |            content_hash: 42,
 7870|       |        };
 7871|       |        cache.insert(key.clone(), build.clone());
 7872|       |        cache.insert(key.clone(), build);
 7873|       |        assert_eq!(cache.entries.len(), 1);
 7874|       |        assert_eq!(cache.order.len(), 1);
 7875|       |    }
 7876|       |
 7877|       |    #[test]
 7878|       |    fn test_table_layout_cache_separates_text_colors() {
 7879|       |        let renderer = MarkdownRenderer::new();
 7880|       |        let spans = vec![InlineSpan::Text("alpha".to_string())];
 7881|       |        let mut light_style = egui::Style::default();
 7882|       |        let mut dark_style = egui::Style::default();
 7883|       |        light_style.visuals.override_text_color = Some(Color32::WHITE);
 7884|       |        dark_style.visuals.override_text_color = Some(Color32::BLACK);
 7885|       |
 7886|       |        let _ =
 7887|       |            renderer.cached_layout_job(&light_style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
 7888|       |        let _ =
 7889|       |            renderer.cached_layout_job(&dark_style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
 7890|       |
 7891|       |        let (hits, misses) = renderer.table_layout_cache_stats();
 7892|       |        assert_eq!(hits, 0);
 7893|       |        assert_eq!(misses, 2);
 7894|       |    }
 7895|       |
 7896|       |    #[test]
 7897|       |    fn test_table_alignment_center_single_column() -> Result<()> {
 7898|       |        let renderer = MarkdownRenderer::new();
 7899|       |        let md = "Intro\n\n| Item |\n| :---: |\n| Alpha |\n";
 7900|       |        let elements = renderer.parse(md)?;
 7901|       |        let alignments = elements
 7902|       |            .iter()
 7903|       |            .find_map(|el| match el {
 7904|       |                MarkdownElement::Table { alignments, .. } => Some(alignments),
 7905|       |                _ => None,
 7906|       |            })
 7907|       |            .expect("table element");
 7908|       |        assert_eq!(alignments.len(), 1);
 7909|       |        assert_eq!(alignments[0], Alignment::Center);
 7910|       |        Ok(())
 7911|       |    }
 7912|       |
 7913|       |    #[test]
 7914|       |    fn test_single_column_table_parses_one_cell_per_row() -> Result<()> {
 7915|       |        let renderer = MarkdownRenderer::new();
 7916|       |        let md =
 7917|       |            "Intro\n\n| Item |\n| :---: |\n| Alpha |\n| line one<br>line two |\n| **bold** and `code` |\n";
 7918|       |        let elements = renderer.parse(md)?;
 7919|       |        let (headers, rows) = elements
 7920|       |            .iter()
 7921|       |            .find_map(|el| match el {
 7922|       |                MarkdownElement::Table { headers, rows, .. } => Some((headers, rows)),
 7923|       |                _ => None,
 7924|       |            })
 7925|       |            .expect("table element");
 7926|       |        assert_eq!(headers.len(), 1);
 7927|       |        assert!(rows.iter().all(|row| row.len() == 1));
 7928|       |        Ok(())
 7929|       |    }
 7930|       |
 7931|       |    #[test]
 7932|       |    fn test_table_first_column_alignment_parses_three_columns() -> Result<()> {
 7933|       |        let renderer = MarkdownRenderer::new();
 7934|       |        let md = fs::read_to_string("tests/regression/cases/026-table-first-column-align.md")?;
 7935|       |        let elements = renderer.parse(&md)?;
 7936|       |        let tables: Vec<_> = elements
 7937|       |            .iter()
 7938|       |            .filter_map(|el| match el {
 7939|       |                MarkdownElement::Table {
 7940|       |                    headers,
 7941|       |                    rows,
 7942|       |                    alignments,
 7943|       |                } => Some((headers, rows, alignments)),
 7944|       |                _ => None,
 7945|       |            })
 7946|       |            .collect();
 7947|       |        assert!(tables.len() >= 3);
 7948|       |        let (first_headers, first_rows, first_alignments) = tables[0];
 7949|       |        for (headers, rows, alignments) in tables.iter() {
 7950|       |            assert_eq!(headers.len(), 3);
 7951|       |            assert_eq!(alignments.len(), 3);
 7952|       |            assert!(rows.iter().all(|row| row.len() == 3));
 7953|       |        }
 7954|       |        let table_id = renderer.compute_table_id(first_headers, first_rows, first_alignments, 0);
 7955|       |        let available = Cell::new(0.0f32);
 7956|       |        let spacing = Cell::new(0.0f32);
 7957|       |        let _estimated_before = {
 7958|       |            let column_stats = renderer.column_stats_for_table(
 7959|       |                table_id,
 7960|       |                first_headers,
 7961|       |                first_rows,
 7962|       |                first_alignments,
 7963|       |            );
 7964|       |            let ctx = TableColumnContext::new(
 7965|       |                first_headers,
 7966|       |                first_rows,
 7967|       |                &column_stats,
 7968|       |                renderer.font_sizes.body,
 7969|       |                table_id,
 7970|       |            );
 7971|       |            let column_specs = derive_column_specs(&ctx);
 7972|       |            let column_spacing = 6.0f32.max(egui::Style::default().spacing.item_spacing.x);
 7973|       |            renderer.estimate_table_total_width(table_id, &column_specs, column_spacing)
 7974|       |        };
 7975|       |        with_test_ui(|_, ui| {
 7976|       |            available.set(ui.available_width());
 7977|       |            spacing.set(ui.spacing().item_spacing.x.max(6.0));
 7978|       |            renderer.render_table_tablebuilder(
 7979|       |                ui,
 7980|       |                first_headers,
 7981|       |                first_rows,
 7982|       |                first_alignments,
 7983|       |                table_id,
 7984|       |            );
 7985|       |        });
 7986|       |        let widths = renderer
 7987|       |            .table_metrics
 7988|       |            .borrow()
 7989|       |            .entry(table_id)
 7990|       |            .map(|entry| entry.current_widths().to_vec())
 7991|       |            .unwrap_or_default();
 7992|       |        assert_eq!(widths.len(), 3);
 7993|       |        assert!(widths.iter().all(|w| *w > 8.0));
 7994|       |        Ok(())
 7995|       |    }
 7996|       |
 7997|       |    #[test]
 7998|       |    fn test_trigger_link_handles_fragments_and_schemes() {
 7999|       |        let renderer = MarkdownRenderer::new();
 8000|       |
 8001|       |        renderer.trigger_link("#Section-One");
 8002|       |        assert_eq!(
 8003|       |            renderer.take_pending_anchor(),
 8004|       |            Some("section-one".to_string())
 8005|       |        );
 8006|       |        assert!(renderer.take_pending_anchor().is_none());
 8007|       |
 8008|       |        renderer.trigger_link("ftp://example.com");
 8009|       |        assert!(renderer.take_pending_anchor().is_none());
 8010|       |
 8011|       |        renderer.trigger_link("https://example.com");
 8012|       |        assert!(renderer.take_pending_anchor().is_none());
 8013|       |
 8014|       |        renderer.trigger_link("mailto:hello@example.com");
 8015|       |        assert!(renderer.take_pending_anchor().is_none());
 8016|       |    }
 8017|       |
 8018|       |    #[test]
 8019|       |    fn test_resolve_image_path_with_base_dir() {
 8020|       |        let renderer = MarkdownRenderer::new();
 8021|       |        let temp = tempdir().expect("temp dir");
 8022|       |        renderer.set_base_dir(Some(temp.path()));
 8023|       |
 8024|       |        let resolved = renderer.resolve_image_path("sample.png");
 8025|       |        assert!(resolved.contains("sample.png"));
 8026|       |
 8027|       |        let abs = temp.path().join("abs.png");
 8028|       |        let abs_str = abs.to_string_lossy().into_owned();
 8029|       |        assert_eq!(renderer.resolve_image_path(&abs_str), abs_str);
 8030|       |
 8031|       |        renderer.set_base_dir(None);
 8032|       |        assert_eq!(renderer.resolve_image_path("relative.png"), "relative.png");
 8033|       |    }
 8034|       |
 8035|       |    #[test]
 8036|       |    fn test_disk_image_loads_and_caches() {
 8037|       |        let renderer = MarkdownRenderer::new();
 8038|       |        let temp = tempdir().expect("temp dir");
 8039|       |        let image_path = temp.path().join("disk.png");
 8040|       |
 8041|       |        let mut img = image::RgbaImage::new(2, 2);
 8042|       |        for pixel in img.pixels_mut() {
 8043|       |            *pixel = image::Rgba([10, 20, 30, 255]);
 8044|       |        }
 8045|       |        img.save(&image_path).expect("save png");
 8046|       |
 8047|       |        renderer.set_base_dir(Some(temp.path()));
 8048|       |        let resolved = renderer.resolve_image_path("disk.png");
 8049|       |        with_test_ui(|ctx, ui| {
 8050|       |            // Use wait_for_image to handle async image loading
 8051|       |            let loaded = wait_for_image(&renderer, ctx, ui, &resolved);
 8052|       |            assert!(loaded.is_some());
 8053|       |        });
 8054|       |
 8055|       |        assert!(renderer.image_textures.borrow().contains_key(&resolved));
 8056|       |    }
 8057|       |
 8058|       |    #[test]
 8059|       |    fn test_context_menu_helpers_execute() {
 8060|       |        let renderer = MarkdownRenderer::new();
 8061|       |        let _actions = ForcedRenderActions::new(&[
 8062|       |            "copy_text",
 8063|       |            "copy_inline_code",
 8064|       |            "copy_code_block",
 8065|       |            "copy_code_block_lang",
 8066|       |            "open_link",
 8067|       |            "copy_link_text",
 8068|       |            "copy_link_url",
 8069|       |            "copy_cell_text",
 8070|       |        ]);
 8071|       |        with_test_ui(|_, ui| {
 8072|       |            renderer.render_text_context_menu(ui, "text");
 8073|       |            renderer.render_inline_code_context_menu(ui, "code");
 8074|       |            renderer.render_code_block_context_menu(ui, "fn main() {}", Some("rust"));
 8075|       |            renderer.render_link_context_menu(ui, "label", "#anchor");
 8076|       |            renderer.render_cell_context_menu(ui, "cell");
 8077|       |            renderer.copy_text_and_close(ui, "direct-copy");
 8078|       |        });
 8079|       |    }
 8080|       |
 8081|       |    #[test]
 8082|       |    fn test_context_menu_helpers_no_actions() {
 8083|       |        let renderer = MarkdownRenderer::new();
 8084|       |        with_test_ui(|_, ui| {
 8085|       |            renderer.render_text_context_menu(ui, "text");
 8086|       |            renderer.render_inline_code_context_menu(ui, "code");
 8087|       |            renderer.render_code_block_context_menu(ui, "fn main() {}", None);
 8088|       |            renderer.render_link_context_menu(ui, "label", "#anchor");
 8089|       |            renderer.render_cell_context_menu(ui, "cell");
 8090|       |        });
 8091|       |    }
 8092|       |
 8093|       |    #[test]
 8094|       |    fn test_estimate_table_column_widths_scales_down() {
 8095|       |        let renderer = MarkdownRenderer::new();
 8096|       |        let specs = vec![
 8097|       |            ColumnSpec::new(
 8098|       |                0,
 8099|       |                "A",
 8100|       |                ColumnPolicy::Resizable {
 8101|       |                    min: 100.0,
 8102|       |                    preferred: 100.0,
 8103|       |                    clip: false,
 8104|       |                },
 8105|       |                None,
 8106|       |            ),
 8107|       |            ColumnSpec::new(
 8108|       |                1,
 8109|       |                "B",
 8110|       |                ColumnPolicy::Resizable {
 8111|       |                    min: 100.0,
 8112|       |                    preferred: 100.0,
 8113|       |                    clip: false,
 8114|       |                },
 8115|       |                None,
 8116|       |            ),
 8117|       |        ];
 8118|       |
 8119|       |        let widths = renderer.estimate_table_column_widths(&specs, 150.0, 10.0);
 8120|       |        let total = widths.iter().sum::<f32>() + 10.0;
 8121|       |        assert!(total <= 150.5);
 8122|       |    }
 8123|       |
 8124|       |    #[test]
 8125|       |    fn test_estimate_table_image_height_no_scale_or_title() {
 8126|       |        let renderer = MarkdownRenderer::new();
 8127|       |        let span = InlineSpan::Image {
 8128|       |            src: "missing.png".to_string(),
 8129|       |            alt: "Alt".to_string(),
 8130|       |            title: Some(String::new()),
 8131|       |        };
 8132|       |        with_test_ui(|_, ui| {
 8133|       |            let height = renderer.estimate_table_image_height(ui, &span, 2000.0);
 8134|       |            assert!(height > 0.0);
 8135|       |        });
 8136|       |    }
 8137|       |
 8138|       |    #[test]
 8139|       |    fn test_row_height_hint_uses_fallback_for_zero_height() {
 8140|       |        let renderer = MarkdownRenderer::new();
 8141|       |        let table_id = 42u64;
 8142|       |        renderer
 8143|       |            .table_metrics
 8144|       |            .borrow_mut()
 8145|       |            .entry_mut(table_id)
 8146|       |            .ensure_row(0)
 8147|       |            .max_height = 0.0;
 8148|       |        let height = renderer.row_height_hint(table_id, 0);
 8149|       |        assert_eq!(height, renderer.row_height_fallback());
 8150|       |    }
 8151|       |
 8152|       |    #[test]
 8153|       |    fn test_build_layout_job_covers_inline_styles() {
 8154|       |        let renderer = MarkdownRenderer::new();
 8155|       |        renderer.set_highlight_phrase(Some("code"));
 8156|       |        let spans = vec![
 8157|       |            InlineSpan::Text("plain".to_string()),
 8158|       |            InlineSpan::Strong("bold".to_string()),
 8159|       |            InlineSpan::Emphasis("italics".to_string()),
 8160|       |            InlineSpan::Strikethrough("strike".to_string()),
 8161|       |            InlineSpan::Code("code".to_string()),
 8162|       |            InlineSpan::Link {
 8163|       |                text: "ext".to_string(),
 8164|       |                url: "https://example.com".to_string(),
 8165|       |            },
 8166|       |            InlineSpan::Link {
 8167|       |                text: "local".to_string(),
 8168|       |                url: "#anchor".to_string(),
 8169|       |            },
 8170|       |        ];
 8171|       |
 8172|       |        with_test_ui(|_, ui| {
 8173|       |            let style = ui.style().clone();
 8174|       |            let build = renderer.build_layout_job(&style, &spans, 200.0, false, Align::LEFT);
 8175|       |            assert!(build.plain_text.contains("plain"));
 8176|       |            assert_eq!(build.link_ranges.len(), 2);
 8177|       |        });
 8178|       |    }
 8179|       |
 8180|       |    #[test]
 8181|       |    fn test_build_layout_job_strong_uses_override_text_color() {
 8182|       |        let renderer = MarkdownRenderer::new();
 8183|       |        let spans = vec![InlineSpan::Text("Header".to_string())];
 8184|       |        let mut style = egui::Style::default();
 8185|       |        let override_color = Color32::from_rgb(10, 20, 30);
 8186|       |        style.visuals.override_text_color = Some(override_color);
 8187|       |
 8188|       |        let build = renderer.build_layout_job(&style, &spans, 200.0, true, Align::LEFT);
 8189|       |        assert!(!build.job.sections.is_empty());
 8190|       |        assert_eq!(build.job.sections[0].format.color, override_color);
 8191|       |    }
 8192|       |
 8193|       |    #[test]
 8194|       |    fn test_render_inline_span_variants() {
 8195|       |        let renderer = MarkdownRenderer::new();
 8196|       |        let temp = tempdir().expect("temp dir");
 8197|       |        let image_path = temp.path().join("image.png");
 8198|       |        std::fs::write(&image_path, tiny_png_bytes()).expect("write png");
 8199|       |        renderer.set_base_dir(Some(temp.path()));
 8200|       |
 8201|       |        let image_span = InlineSpan::Image {
 8202|       |            src: "image.png".to_string(),
 8203|       |            alt: "Alt".to_string(),
 8204|       |            title: Some("Title".to_string()),
 8205|       |        };
 8206|       |        let missing_span = InlineSpan::Image {
 8207|       |            src: "missing.png".to_string(),
 8208|       |            alt: "".to_string(),
 8209|       |            title: None,
 8210|       |        };
 8211|       |        let remote_span = InlineSpan::Image {
 8212|       |            src: "https://example.com/image.png".to_string(),
 8213|       |            alt: "Remote".to_string(),
 8214|       |            title: None,
 8215|       |        };
 8216|       |        let remote_http_span = InlineSpan::Image {
 8217|       |            src: "http://example.com/image.png".to_string(),
 8218|       |            alt: "RemoteHttp".to_string(),
 8219|       |            title: None,
 8220|       |        };
 8221|       |
 8222|       |        let _guard = ForcedRenderActions::new(&["link_hover", "link_click", "image_hover"]);
 8223|       |        with_test_ui(|ctx, ui| {
 8224|       |            ui.visuals_mut().dark_mode = false;
 8225|       |            renderer.render_inline_span(ui, &InlineSpan::Code("code".to_string()), None, None);
 8226|       |
 8227|       |            ui.visuals_mut().dark_mode = true;
 8228|       |            renderer.render_inline_span(ui, &InlineSpan::Text("text".to_string()), None, None);
 8229|       |            renderer.render_inline_span(ui, &InlineSpan::Strong("bold".to_string()), None, None);
 8230|       |            renderer.render_inline_span(
 8231|       |                ui,
 8232|       |                &InlineSpan::Emphasis("italic".to_string()),
 8233|       |                None,
 8234|       |                None,
 8235|       |            );
 8236|       |            renderer.render_inline_span(
 8237|       |                ui,
 8238|       |                &InlineSpan::Strikethrough("strike".to_string()),
 8239|       |                None,
 8240|       |                None,
 8241|       |            );
 8242|       |            renderer.render_inline_span(
 8243|       |                ui,
 8244|       |                &InlineSpan::Link {
 8245|       |                    text: "ext".to_string(),
 8246|       |                    url: "https://example.com".to_string(),
 8247|       |                },
 8248|       |                None,
 8249|       |                None,
 8250|       |            );
 8251|       |            renderer.render_inline_span(
 8252|       |                ui,
 8253|       |                &InlineSpan::Link {
 8254|       |                    text: "local".to_string(),
 8255|       |                    url: "#anchor".to_string(),
 8256|       |                },
 8257|       |                None,
 8258|       |                None,
 8259|       |            );
 8260|       |            let resolved = renderer.resolve_image_path("image.png");
 8261|       |            let _loaded = wait_for_image(&renderer, ctx, ui, &resolved);
 8262|       |            renderer.render_inline_span(ui, &image_span, None, None);
 8263|       |            renderer.render_inline_span(ui, &missing_span, None, None);
 8264|       |            renderer.render_inline_span(ui, &remote_span, None, None);
 8265|       |            renderer.render_inline_span(ui, &remote_http_span, None, None);
 8266|       |        });
 8267|       |    }
 8268|       |
 8269|       |    #[test]
 8270|       |    fn test_has_pending_renders_with_image_pending() {
 8271|       |        let renderer = MarkdownRenderer::new();
 8272|       |        assert!(!renderer.has_pending_renders());
 8273|       |        renderer
 8274|       |            .image_pending
 8275|       |            .borrow_mut()
 8276|       |            .insert("queued.png".to_string());
 8277|       |        assert!(renderer.has_pending_renders());
 8278|       |    }
 8279|       |
 8280|       |    #[test]
 8281|       |    fn test_has_pending_renders_with_mermaid_pending() {
 8282|       |        let renderer = MarkdownRenderer::new();
 8283|       |        with_test_ui(|_, ui| {
 8284|       |            renderer.mermaid.begin_frame();
 8285|       |            renderer
 8286|       |                .mermaid
 8287|       |                .render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 8288|       |        });
 8289|       |        assert!(renderer.has_pending_renders());
 8290|       |    }
 8291|       |
 8292|       |    #[test]
 8293|       |    fn test_parse_lists_and_blockquotes() {
 8294|       |        let renderer = MarkdownRenderer::new();
 8295|       |        let md = "\
 8296|       |- Item 1
 8297|       |- Item 2
 8298|       |  - Nested
 8299|       |
 8300|       |1. First
 8301|       |2. Second
 8302|       |
 8303|       |> Quote line
 8304|       |> > Nested quote
 8305|       |
 8306|       |---";
 8307|       |
 8308|       |        let elements = renderer.parse(md).expect("parse ok");
 8309|       |        assert!(elements
 8310|       |            .iter()
 8311|       |            .any(|el| matches!(el, MarkdownElement::List { ordered: false, .. })));
 8312|       |        assert!(elements
 8313|       |            .iter()
 8314|       |            .any(|el| matches!(el, MarkdownElement::List { ordered: true, .. })));
 8315|       |        assert!(elements
 8316|       |            .iter()
 8317|       |            .any(|el| matches!(el, MarkdownElement::Quote { .. })));
 8318|       |        assert!(elements
 8319|       |            .iter()
 8320|       |            .any(|el| matches!(el, MarkdownElement::HorizontalRule)));
 8321|       |    }
 8322|       |
 8323|       |    #[test]
 8324|       |    fn test_elements_to_plain_text_variants() {
 8325|       |        let elements = vec![
 8326|       |            MarkdownElement::Header {
 8327|       |                level: 1,
 8328|       |                spans: vec![InlineSpan::Text("Title".to_string())],
 8329|       |                id: "title".to_string(),
 8330|       |            },
 8331|       |            MarkdownElement::Paragraph(vec![
 8332|       |                InlineSpan::Text("Hello".to_string()),
 8333|       |                InlineSpan::Code("code".to_string()),
 8334|       |            ]),
 8335|       |            MarkdownElement::CodeBlock {
 8336|       |                language: Some("rust".to_string()),
 8337|       |                text: "fn main() {}".to_string(),
 8338|       |            },
 8339|       |            MarkdownElement::List {
 8340|       |                ordered: false,
 8341|       |                items: vec![ListItem {
 8342|       |                    blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 8343|       |                        "Item".to_string(),
 8344|       |                    )])],
 8345|       |                }],
 8346|       |            },
 8347|       |            MarkdownElement::Quote {
 8348|       |                depth: 1,
 8349|       |                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 8350|       |                    "Quote".to_string(),
 8351|       |                )])],
 8352|       |            },
 8353|       |            MarkdownElement::HorizontalRule,
 8354|       |            MarkdownElement::Table {
 8355|       |                headers: vec![vec![InlineSpan::Text("H".to_string())]],
 8356|       |                rows: vec![vec![vec![InlineSpan::Image {
 8357|       |                    src: "img.png".to_string(),
 8358|       |                    alt: "Alt".to_string(),
 8359|       |                    title: None,
 8360|       |                }]]],
 8361|       |                alignments: Vec::new(),
 8362|       |            },
 8363|       |        ];
 8364|       |        let text = MarkdownRenderer::elements_to_plain_text(&elements);
 8365|       |        assert!(text.contains("Title"));
 8366|       |        assert!(text.contains("Hello"));
 8367|       |        assert!(text.contains("fn main"));
 8368|       |        assert!(text.contains("Item"));
 8369|       |        assert!(text.contains("Quote"));
 8370|       |        assert!(text.contains("Alt"));
 8371|       |    }
 8372|       |
 8373|       |    #[test]
 8374|       |    fn test_elements_to_plain_text_image_title_and_empty_rule() {
 8375|       |        let elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Image {
 8376|       |            src: "img.png".to_string(),
 8377|       |            alt: "".to_string(),
 8378|       |            title: Some("Diagram Title".to_string()),
 8379|       |        }])];
 8380|       |        let text = MarkdownRenderer::elements_to_plain_text(&elements);
 8381|       |        assert!(text.contains("Diagram Title"));
 8382|       |
 8383|       |        let hr_only = vec![MarkdownElement::HorizontalRule];
 8384|       |        assert_eq!(MarkdownRenderer::elements_to_plain_text(&hr_only), "");
 8385|       |    }
 8386|       |
 8387|       |    #[test]
 8388|       |    fn test_table_rendering_overhaul() {
 8389|       |        let renderer = MarkdownRenderer::new();
 8390|       |        let headers = vec![
 8391|       |            vec![InlineSpan::Text("H1".to_string())],
 8392|       |            vec![InlineSpan::Text("H2".to_string())],
 8393|       |        ];
 8394|       |        let rows = vec![vec![
 8395|       |            vec![InlineSpan::Text("Cell".to_string())],
 8396|       |            vec![InlineSpan::Link {
 8397|       |                text: "Link".to_string(),
 8398|       |                url: "https://example.com".to_string(),
 8399|       |            }],
 8400|       |        ]];
 8401|       |        let elements = vec![MarkdownElement::Table {
 8402|       |            headers,
 8403|       |            rows,
 8404|       |            alignments: Vec::new(),
 8405|       |        }];
 8406|       |
 8407|       |        with_test_ui(|_, ui| {
 8408|       |            renderer.render_to_ui(ui, &elements);
 8409|       |        });
 8410|       |    }
 8411|       |
 8412|       |    #[test]
 8413|       |    fn test_measure_inline_spans_and_emoji_texture() {
 8414|       |        let renderer = MarkdownRenderer::new();
 8415|       |        let spans = vec![
 8416|       |            InlineSpan::Text("Hello".to_string()),
 8417|       |            InlineSpan::Text("".to_string()),
 8418|       |        ];
 8419|       |
 8420|       |        with_test_ui(|_, ui| {
 8421|       |            let width = renderer.measure_inline_spans(ui, &spans);
 8422|       |            assert!(width > 0.0);
 8423|       |            let tex = renderer.get_or_make_emoji_texture(ui, "");
 8424|       |            assert!(tex.size()[0] > 0);
 8425|       |        });
 8426|       |
 8427|       |        let img = renderer.generate_emoji_image("", 16);
 8428|       |        assert_eq!(img.size[0], 16);
 8429|       |    }
 8430|       |
 8431|       |    #[test]
 8432|       |    fn test_measure_inline_spans_respects_line_breaks() {
 8433|       |        let renderer = MarkdownRenderer::new();
 8434|       |        let single_line = vec![InlineSpan::Text(
 8435|       |            "Short This is a much longer line".to_string(),
 8436|       |        )];
 8437|       |        let multi_line = vec![InlineSpan::Text(
 8438|       |            "Short\nThis is a much longer line".to_string(),
 8439|       |        )];
 8440|       |
 8441|       |        with_test_ui(|_, ui| {
 8442|       |            let single = renderer.measure_inline_spans(ui, &single_line);
 8443|       |            let multi = renderer.measure_inline_spans(ui, &multi_line);
 8444|       |            assert!(multi < single);
 8445|       |        });
 8446|       |    }
 8447|       |
 8448|       |    #[test]
 8449|       |    fn test_measure_inline_spans_normalizes_unicode() {
 8450|       |        let renderer = MarkdownRenderer::new();
 8451|       |        let unicode = vec![InlineSpan::Text("A\u{2192}B".to_string())];
 8452|       |        let ascii = vec![InlineSpan::Text("A->B".to_string())];
 8453|       |
 8454|       |        with_test_ui(|_, ui| {
 8455|       |            let unicode_width = renderer.measure_inline_spans(ui, &unicode);
 8456|       |            let ascii_width = renderer.measure_inline_spans(ui, &ascii);
 8457|       |            assert!((unicode_width - ascii_width).abs() < 0.5);
 8458|       |        });
 8459|       |    }
 8460|       |
 8461|       |    #[test]
 8462|       |    fn test_to_superscript_full_mapping() {
 8463|       |        let input = "0123456789+-=()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#";
 8464|       |        let out = MarkdownRenderer::to_superscript(input);
 8465|       |        assert_eq!(out.chars().count(), input.chars().count());
 8466|       |        assert!(out.contains('\u{2070}'));
 8467|       |        assert!(out.contains('\u{00b9}'));
 8468|       |        assert!(out.contains('\u{1d43}'));
 8469|       |        assert!(out.contains('#'));
 8470|       |    }
 8471|       |
 8472|       |    #[test]
 8473|       |    fn test_element_plain_text_variants() {
 8474|       |        let list = MarkdownElement::List {
 8475|       |            ordered: false,
 8476|       |            items: vec![ListItem {
 8477|       |                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 8478|       |                    "Item".to_string(),
 8479|       |                )])],
 8480|       |            }],
 8481|       |        };
 8482|       |        let quote = MarkdownElement::Quote {
 8483|       |            depth: 1,
 8484|       |            blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 8485|       |                "Quote".to_string(),
 8486|       |            )])],
 8487|       |        };
 8488|       |        let table = MarkdownElement::Table {
 8489|       |            headers: vec![vec![InlineSpan::Text("Header".to_string())]],
 8490|       |            rows: vec![vec![vec![InlineSpan::Text("Cell".to_string())]]],
 8491|       |            alignments: Vec::new(),
 8492|       |        };
 8493|       |
 8494|       |        assert!(MarkdownRenderer::element_plain_text(&list).contains("Item"));
 8495|       |        assert!(MarkdownRenderer::element_plain_text(&quote).contains("Quote"));
 8496|       |        assert_eq!(
 8497|       |            MarkdownRenderer::element_plain_text(&MarkdownElement::HorizontalRule),
 8498|       |            "---"
 8499|       |        );
 8500|       |        assert!(MarkdownRenderer::element_plain_text(&table).contains("Header"));
 8501|       |        assert!(MarkdownRenderer::element_plain_text(&table).contains("Cell"));
 8502|       |    }
 8503|       |
 8504|       |    #[test]
 8505|       |    fn test_parse_element_image_outside_paragraph() {
 8506|       |        let renderer = MarkdownRenderer::new();
 8507|       |        let events = vec![
 8508|       |            Event::Start(Tag::Image(
 8509|       |                LinkType::Inline,
 8510|       |                "img.png".into(),
 8511|       |                "Title".into(),
 8512|       |            )),
 8513|       |            Event::Text("Alt".into()),
 8514|       |            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
 8515|       |        ];
 8516|       |        let mut elements = Vec::new();
 8517|       |        let mut slugs = std::collections::HashMap::new();
 8518|       |        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs);
 8519|       |        assert_eq!(next, events.len());
 8520|       |        assert!(matches!(
 8521|       |            elements.first(),
 8522|       |            Some(MarkdownElement::Paragraph(_))
 8523|       |        ));
 8524|       |        let spans = paragraph_spans(elements.first().expect("element")).expect("paragraph spans");
 8525|       |        let (_src, _alt, title) = image_span_fields(&spans[0]).expect("image span");
 8526|       |        assert_eq!(title, Some("Title"));
 8527|       |        assert!(paragraph_spans(&MarkdownElement::HorizontalRule).is_none());
 8528|       |    }
 8529|       |
 8530|       |    #[test]
 8531|       |    fn test_parse_element_empty_paragraph_skips() {
 8532|       |        let renderer = MarkdownRenderer::new();
 8533|       |        let events = vec![Event::Start(Tag::Paragraph), Event::End(Tag::Paragraph)];
 8534|       |        let mut elements = Vec::new();
 8535|       |        let mut slugs = HashMap::new();
 8536|       |        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs);
 8537|       |        assert_eq!(next, events.len());
 8538|       |        assert!(elements.is_empty());
 8539|       |    }
 8540|       |
 8541|       |    #[test]
 8542|       |    fn test_parse_element_empty_blockquote_skips() {
 8543|       |        let renderer = MarkdownRenderer::new();
 8544|       |        let events = vec![
 8545|       |            Event::Start(Tag::BlockQuote),
 8546|       |            Event::Start(Tag::BlockQuote),
 8547|       |            Event::End(Tag::BlockQuote),
 8548|       |            Event::End(Tag::BlockQuote),
 8549|       |        ];
 8550|       |        let mut elements = Vec::new();
 8551|       |        let mut slugs = HashMap::new();
 8552|       |        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs);
 8553|       |        assert_eq!(next, events.len());
 8554|       |        assert!(elements.is_empty());
 8555|       |    }
 8556|       |
 8557|       |    #[test]
 8558|       |    fn test_parse_list_event_variants() -> Result<()> {
 8559|       |        let renderer = MarkdownRenderer::new();
 8560|       |        let events = vec![
 8561|       |            Event::Start(Tag::List(None)),
 8562|       |            Event::Start(Tag::Item),
 8563|       |            Event::Start(Tag::Emphasis),
 8564|       |            Event::Text("em".into()),
 8565|       |            Event::End(Tag::Emphasis),
 8566|       |            Event::Start(Tag::Strong),
 8567|       |            Event::Text("strong".into()),
 8568|       |            Event::End(Tag::Strong),
 8569|       |            Event::Start(Tag::Strikethrough),
 8570|       |            Event::Text("strike".into()),
 8571|       |            Event::End(Tag::Strikethrough),
 8572|       |            Event::Start(Tag::Link(
 8573|       |                LinkType::Inline,
 8574|       |                "https://example.com".into(),
 8575|       |                "".into(),
 8576|       |            )),
 8577|       |            Event::Text("link".into()),
 8578|       |            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
 8579|       |            Event::Start(Tag::Image(
 8580|       |                LinkType::Inline,
 8581|       |                "img.png".into(),
 8582|       |                "Title".into(),
 8583|       |            )),
 8584|       |            Event::Text("alt".into()),
 8585|       |            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
 8586|       |            Event::Code("code".into()),
 8587|       |            Event::Text("text".into()),
 8588|       |            Event::SoftBreak,
 8589|       |            Event::Start(Tag::List(Some(1))),
 8590|       |            Event::Start(Tag::Item),
 8591|       |            Event::Text("nested".into()),
 8592|       |            Event::End(Tag::Item),
 8593|       |            Event::End(Tag::List(Some(1))),
 8594|       |            Event::End(Tag::Item),
 8595|       |            Event::End(Tag::List(None)),
 8596|       |        ];
 8597|       |
 8598|       |        let mut slugs = std::collections::HashMap::new();
 8599|       |        let (items, next) = renderer.parse_list(&events, 1, &mut slugs);
 8600|       |        assert_eq!(next, events.len());
 8601|       |        assert_eq!(items.len(), 1);
 8602|       |        let item = &items[0];
 8603|       |        let mut blocks = Vec::new();
 8604|       |        blocks.push(MarkdownElement::HorizontalRule);
 8605|       |        blocks.extend(item.blocks.clone());
 8606|       |        let spans = blocks
 8607|       |            .iter()
 8608|       |            .find_map(|block| match block {
 8609|       |                MarkdownElement::Paragraph(spans) => Some(spans),
 8610|       |                _ => None,
 8611|       |            })
 8612|       |            .expect("paragraph block");
 8613|       |        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Emphasis(_))));
 8614|       |        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Strong(_))));
 8615|       |        assert!(spans
 8616|       |            .iter()
 8617|       |            .any(|s| matches!(s, InlineSpan::Strikethrough(_))));
 8618|       |        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Link { .. })));
 8619|       |        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Image { .. })));
 8620|       |        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Code(_))));
 8621|       |        assert!(item
 8622|       |            .blocks
 8623|       |            .iter()
 8624|       |            .any(|block| matches!(block, MarkdownElement::List { ordered: true, .. })));
 8625|       |        Ok(())
 8626|       |    }
 8627|       |
 8628|       |    #[test]
 8629|       |    fn test_parse_inline_spans_with_breaks_variants() {
 8630|       |        let renderer = MarkdownRenderer::new();
 8631|       |        let events = vec![
 8632|       |            Event::Start(Tag::Paragraph),
 8633|       |            Event::Text("Hello".into()),
 8634|       |            Event::SoftBreak,
 8635|       |            Event::Code("code".into()),
 8636|       |            Event::Start(Tag::Strong),
 8637|       |            Event::Text("bold".into()),
 8638|       |            Event::End(Tag::Strong),
 8639|       |            Event::Start(Tag::Emphasis),
 8640|       |            Event::Text("em".into()),
 8641|       |            Event::End(Tag::Emphasis),
 8642|       |            Event::Start(Tag::Strikethrough),
 8643|       |            Event::Text("strike".into()),
 8644|       |            Event::End(Tag::Strikethrough),
 8645|       |            Event::Start(Tag::Link(
 8646|       |                LinkType::Inline,
 8647|       |                "https://example.com".into(),
 8648|       |                "".into(),
 8649|       |            )),
 8650|       |            Event::Text("link".into()),
 8651|       |            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
 8652|       |            Event::Start(Tag::Image(
 8653|       |                LinkType::Inline,
 8654|       |                "img.png".into(),
 8655|       |                "Title".into(),
 8656|       |            )),
 8657|       |            Event::Text("alt".into()),
 8658|       |            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
 8659|       |            Event::End(Tag::Paragraph),
 8660|       |        ];
 8661|       |
 8662|       |        let (spans, next) =
 8663|       |            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true);
 8664|       |        assert_eq!(next, events.len());
 8665|       |        let mut saw_code = false;
 8666|       |        let mut saw_strong = false;
 8667|       |        let mut saw_emphasis = false;
 8668|       |        let mut saw_strike = false;
 8669|       |        let mut saw_link = false;
 8670|       |        let mut saw_image = false;
 8671|       |        let mut saw_break_text = false;
 8672|       |        for span in &spans {
 8673|       |            match span {
 8674|       |                InlineSpan::Code(_) => saw_code = true,
 8675|       |                InlineSpan::Strong(_) => saw_strong = true,
 8676|       |                InlineSpan::Emphasis(_) => saw_emphasis = true,
 8677|       |                InlineSpan::Strikethrough(_) => saw_strike = true,
 8678|       |                InlineSpan::Link { .. } => saw_link = true,
 8679|       |                InlineSpan::Image { .. } => saw_image = true,
 8680|       |                InlineSpan::Text(t) if t.contains('\n') => saw_break_text = true,
 8681|       |                _ => {}
 8682|       |            }
 8683|       |        }
 8684|       |        assert!(saw_code);
 8685|       |        assert!(saw_strong);
 8686|       |        assert!(saw_emphasis);
 8687|       |        assert!(saw_strike);
 8688|       |        assert!(saw_link);
 8689|       |        assert!(saw_image);
 8690|       |        assert!(saw_break_text);
 8691|       |    }
 8692|       |
 8693|       |    #[test]
 8694|       |    fn test_parse_inline_spans_html_breaks() {
 8695|       |        let renderer = MarkdownRenderer::new();
 8696|       |        let events = vec![
 8697|       |            Event::Start(Tag::Paragraph),
 8698|       |            Event::Text("one".into()),
 8699|       |            Event::Html("<br>".into()),
 8700|       |            Event::Text("two".into()),
 8701|       |            Event::End(Tag::Paragraph),
 8702|       |        ];
 8703|       |
 8704|       |        let (spans, next) =
 8705|       |            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true);
 8706|       |        assert_eq!(next, events.len());
 8707|       |        assert!(spans
 8708|       |            .iter()
 8709|       |            .any(|s| matches!(s, InlineSpan::Text(t) if t == "\n")));
 8710|       |
 8711|       |        let (spans_no_break, _) = renderer.parse_inline_spans(&events, 1, Tag::Paragraph);
 8712|       |        let text = MarkdownRenderer::spans_plain_text(&spans_no_break);
 8713|       |        assert!(text.contains("one two"));
 8714|       |
 8715|       |        let attr_events = vec![
 8716|       |            Event::Start(Tag::Paragraph),
 8717|       |            Event::Text("alpha".into()),
 8718|       |            Event::Html("<br class=\"tight\">".into()),
 8719|       |            Event::Text("beta".into()),
 8720|       |            Event::End(Tag::Paragraph),
 8721|       |        ];
 8722|       |        let (spans, next) =
 8723|       |            renderer.parse_inline_spans_with_breaks(&attr_events, 1, Tag::Paragraph, true);
 8724|       |        assert_eq!(next, attr_events.len());
 8725|       |        assert!(spans
 8726|       |            .iter()
 8727|       |            .any(|s| matches!(s, InlineSpan::Text(t) if t == "\n")));
 8728|       |
 8729|       |        let strong_events = vec![
 8730|       |            Event::Start(Tag::Paragraph),
 8731|       |            Event::Text("lead ".into()),
 8732|       |            Event::Start(Tag::Strong),
 8733|       |            Event::Text("alpha".into()),
 8734|       |            Event::Html("<br>".into()),
 8735|       |            Event::Text("beta".into()),
 8736|       |            Event::End(Tag::Strong),
 8737|       |            Event::End(Tag::Paragraph),
 8738|       |        ];
 8739|       |        let (_spans, next) =
 8740|       |            renderer.parse_inline_spans_with_breaks(&strong_events, 1, Tag::Paragraph, true);
 8741|       |        assert_eq!(next, strong_events.len());
 8742|       |
 8743|       |        let (spans_no_break, _) = renderer.parse_inline_spans(&strong_events, 1, Tag::Paragraph);
 8744|       |        let mut saw_non_strong = false;
 8745|       |        let mut strong_text = None;
 8746|       |        for span in &spans_no_break {
 8747|       |            if let InlineSpan::Strong(text) = span {
 8748|       |                strong_text = Some(text.as_str());
 8749|       |            } else {
 8750|       |                saw_non_strong = true;
 8751|       |            }
 8752|       |        }
 8753|       |        assert!(saw_non_strong);
 8754|       |        let mut saw_match = false;
 8755|       |        let mut saw_miss = false;
 8756|       |        let mut saw_none = false;
 8757|       |        for candidate in [strong_text, Some("nope"), None] {
 8758|       |            if let Some(text) = candidate {
 8759|       |                if text.contains("alpha beta") {
 8760|       |                    saw_match = true;
 8761|       |                } else {
 8762|       |                    saw_miss = true;
 8763|       |                }
 8764|       |            } else {
 8765|       |                saw_none = true;
 8766|       |            }
 8767|       |        }
 8768|       |        assert!(saw_match);
 8769|       |        assert!(saw_miss);
 8770|       |        assert!(saw_none);
 8771|       |    }
 8772|       |
 8773|       |    #[test]
 8774|       |    fn test_parse_inline_spans_soft_break_without_keep() {
 8775|       |        let renderer = MarkdownRenderer::new();
 8776|       |        let events = vec![
 8777|       |            Event::Start(Tag::Paragraph),
 8778|       |            Event::Text("alpha".into()),
 8779|       |            Event::SoftBreak,
 8780|       |            Event::Text("beta".into()),
 8781|       |            Event::End(Tag::Paragraph),
 8782|       |        ];
 8783|       |
 8784|       |        let (spans, next) = renderer.parse_inline_spans(&events, 1, Tag::Paragraph);
 8785|       |        assert_eq!(next, events.len());
 8786|       |        assert_eq!(MarkdownRenderer::spans_plain_text(&spans), "alpha beta");
 8787|       |    }
 8788|       |
 8789|       |    #[test]
 8790|       |    fn test_collect_blockquotes_nested_and_breaks() {
 8791|       |        let renderer = MarkdownRenderer::new();
 8792|       |        let events = vec![
 8793|       |            Event::Start(Tag::BlockQuote),
 8794|       |            Event::Start(Tag::Paragraph),
 8795|       |            Event::Text("Line1\nLine2".into()),
 8796|       |            Event::End(Tag::Paragraph),
 8797|       |            Event::SoftBreak,
 8798|       |            Event::Start(Tag::BlockQuote),
 8799|       |            Event::Start(Tag::Paragraph),
 8800|       |            Event::Text("Nested".into()),
 8801|       |            Event::End(Tag::Paragraph),
 8802|       |            Event::End(Tag::BlockQuote),
 8803|       |            Event::End(Tag::BlockQuote),
 8804|       |        ];
 8805|       |        let mut slugs = HashMap::new();
 8806|       |        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs);
 8807|       |        assert_eq!(next, events.len());
 8808|       |        assert!(quotes.iter().any(|(depth, _)| *depth == 1));
 8809|       |        assert!(quotes.iter().any(|(depth, _)| *depth == 2));
 8810|       |    }
 8811|       |
 8812|       |    #[test]
 8813|       |    fn test_collect_blockquotes_event_variants() {
 8814|       |        let renderer = MarkdownRenderer::new();
 8815|       |        let events = vec![
 8816|       |            Event::Start(Tag::BlockQuote),
 8817|       |            Event::Start(Tag::Paragraph),
 8818|       |            Event::Text("para".into()),
 8819|       |            Event::End(Tag::Paragraph),
 8820|       |            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 8821|       |            Event::Text("Heading".into()),
 8822|       |            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 8823|       |            Event::Start(Tag::List(None)),
 8824|       |            Event::Start(Tag::Item),
 8825|       |            Event::Text("item".into()),
 8826|       |            Event::End(Tag::Item),
 8827|       |            Event::End(Tag::List(None)),
 8828|       |            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8829|       |                "rust".into(),
 8830|       |            ))),
 8831|       |            Event::Text("fn main() {}\n".into()),
 8832|       |            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8833|       |                "rust".into(),
 8834|       |            ))),
 8835|       |            Event::Start(Tag::Table(vec![Alignment::Left])),
 8836|       |            Event::Start(Tag::TableHead),
 8837|       |            Event::Start(Tag::TableRow),
 8838|       |            Event::Start(Tag::TableCell),
 8839|       |            Event::Text("H".into()),
 8840|       |            Event::End(Tag::TableCell),
 8841|       |            Event::End(Tag::TableRow),
 8842|       |            Event::End(Tag::TableHead),
 8843|       |            Event::Start(Tag::TableRow),
 8844|       |            Event::Start(Tag::TableCell),
 8845|       |            Event::Text("R".into()),
 8846|       |            Event::End(Tag::TableCell),
 8847|       |            Event::End(Tag::TableRow),
 8848|       |            Event::End(Tag::Table(vec![Alignment::Left])),
 8849|       |            Event::Start(Tag::Emphasis),
 8850|       |            Event::Text("em".into()),
 8851|       |            Event::End(Tag::Emphasis),
 8852|       |            Event::Start(Tag::Strong),
 8853|       |            Event::Text("strong".into()),
 8854|       |            Event::End(Tag::Strong),
 8855|       |            Event::Start(Tag::Strikethrough),
 8856|       |            Event::Text("strike".into()),
 8857|       |            Event::End(Tag::Strikethrough),
 8858|       |            Event::Start(Tag::Link(
 8859|       |                LinkType::Inline,
 8860|       |                "https://example.com".into(),
 8861|       |                "".into(),
 8862|       |            )),
 8863|       |            Event::Text("link".into()),
 8864|       |            Event::End(Tag::Link(
 8865|       |                LinkType::Inline,
 8866|       |                "https://example.com".into(),
 8867|       |                "".into(),
 8868|       |            )),
 8869|       |            Event::Start(Tag::Image(
 8870|       |                LinkType::Inline,
 8871|       |                "img.png".into(),
 8872|       |                "Title".into(),
 8873|       |            )),
 8874|       |            Event::Text("alt".into()),
 8875|       |            Event::End(Tag::Image(
 8876|       |                LinkType::Inline,
 8877|       |                "img.png".into(),
 8878|       |                "Title".into(),
 8879|       |            )),
 8880|       |            Event::Code("code".into()),
 8881|       |            Event::SoftBreak,
 8882|       |            Event::HardBreak,
 8883|       |            Event::Html("<br>".into()),
 8884|       |            Event::Rule,
 8885|       |            Event::Start(Tag::BlockQuote),
 8886|       |            Event::Start(Tag::Paragraph),
 8887|       |            Event::Text("Nested".into()),
 8888|       |            Event::End(Tag::Paragraph),
 8889|       |            Event::End(Tag::BlockQuote),
 8890|       |            Event::End(Tag::BlockQuote),
 8891|       |        ];
 8892|       |        let mut slugs = HashMap::new();
 8893|       |        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs);
 8894|       |        assert_eq!(next, events.len());
 8895|       |        assert!(!quotes.is_empty());
 8896|       |    }
 8897|       |
 8898|       |    #[test]
 8899|       |    fn test_collect_blockquotes_empty_paragraph_and_html_ignored() {
 8900|       |        let renderer = MarkdownRenderer::new();
 8901|       |        let events = vec![
 8902|       |            Event::Start(Tag::BlockQuote),
 8903|       |            Event::Start(Tag::Paragraph),
 8904|       |            Event::End(Tag::Paragraph),
 8905|       |            Event::Html("<span>".into()),
 8906|       |            Event::End(Tag::BlockQuote),
 8907|       |        ];
 8908|       |        let mut slugs = HashMap::new();
 8909|       |        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs);
 8910|       |        assert_eq!(next, events.len());
 8911|       |        assert!(quotes.is_empty());
 8912|       |    }
 8913|       |
 8914|       |    #[test]
 8915|       |    fn test_collect_blockquotes_empty_unclosed_returns_empty() {
 8916|       |        let renderer = MarkdownRenderer::new();
 8917|       |        let events = vec![Event::Start(Tag::BlockQuote)];
 8918|       |        let mut slugs = HashMap::new();
 8919|       |        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs);
 8920|       |        assert_eq!(next, events.len());
 8921|       |        assert!(quotes.is_empty());
 8922|       |    }
 8923|       |
 8924|       |    #[test]
 8925|       |    fn test_parse_list_block_elements() -> Result<()> {
 8926|       |        let renderer = MarkdownRenderer::new();
 8927|       |        let events = vec![
 8928|       |            Event::Start(Tag::List(Some(1))),
 8929|       |            Event::Start(Tag::Item),
 8930|       |            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H3, None, vec![])),
 8931|       |            Event::Text("Heading".into()),
 8932|       |            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H3, None, vec![])),
 8933|       |            Event::Start(Tag::Table(vec![Alignment::Left])),
 8934|       |            Event::Start(Tag::TableHead),
 8935|       |            Event::Start(Tag::TableRow),
 8936|       |            Event::Start(Tag::TableCell),
 8937|       |            Event::Text("H".into()),
 8938|       |            Event::End(Tag::TableCell),
 8939|       |            Event::End(Tag::TableRow),
 8940|       |            Event::End(Tag::TableHead),
 8941|       |            Event::Start(Tag::TableRow),
 8942|       |            Event::Start(Tag::TableCell),
 8943|       |            Event::Text("R".into()),
 8944|       |            Event::End(Tag::TableCell),
 8945|       |            Event::End(Tag::TableRow),
 8946|       |            Event::End(Tag::Table(vec![Alignment::Left])),
 8947|       |            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8948|       |                "rust".into(),
 8949|       |            ))),
 8950|       |            Event::Text("fn main() {}\n".into()),
 8951|       |            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8952|       |                "rust".into(),
 8953|       |            ))),
 8954|       |            Event::Start(Tag::BlockQuote),
 8955|       |            Event::Start(Tag::Paragraph),
 8956|       |            Event::Text("Quote".into()),
 8957|       |            Event::End(Tag::Paragraph),
 8958|       |            Event::End(Tag::BlockQuote),
 8959|       |            Event::Rule,
 8960|       |            Event::HardBreak,
 8961|       |            Event::End(Tag::Item),
 8962|       |            Event::End(Tag::List(Some(1))),
 8963|       |        ];
 8964|       |        let mut slugs = HashMap::new();
 8965|       |        let (items, next) = renderer.parse_list(&events, 1, &mut slugs);
 8966|       |        assert_eq!(next, events.len());
 8967|       |        assert_eq!(items.len(), 1);
 8968|       |        Ok(())
 8969|       |    }
 8970|       |
 8971|       |    #[test]
 8972|       |    fn test_parse_element_variants() {
 8973|       |        let renderer = MarkdownRenderer::new();
 8974|       |        let mut slugs = HashMap::new();
 8975|       |        let mut elements = Vec::new();
 8976|       |
 8977|       |        let paragraph = vec![
 8978|       |            Event::Start(Tag::Paragraph),
 8979|       |            Event::Text("para".into()),
 8980|       |            Event::End(Tag::Paragraph),
 8981|       |        ];
 8982|       |        let next = renderer.parse_element(&paragraph, 0, &mut elements, &mut slugs);
 8983|       |        assert_eq!(next, paragraph.len());
 8984|       |
 8985|       |        let heading = vec![
 8986|       |            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 8987|       |            Event::Text("Heading".into()),
 8988|       |            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 8989|       |        ];
 8990|       |        let next = renderer.parse_element(&heading, 0, &mut elements, &mut slugs);
 8991|       |        assert_eq!(next, heading.len());
 8992|       |
 8993|       |        let code_block = vec![
 8994|       |            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8995|       |                "rust".into(),
 8996|       |            ))),
 8997|       |            Event::Text("fn main() {}\n".into()),
 8998|       |            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8999|       |                "rust".into(),
 9000|       |            ))),
 9001|       |        ];
 9002|       |        let next = renderer.parse_element(&code_block, 0, &mut elements, &mut slugs);
 9003|       |        assert_eq!(next, code_block.len());
 9004|       |
 9005|       |        let list = vec![
 9006|       |            Event::Start(Tag::List(None)),
 9007|       |            Event::Start(Tag::Item),
 9008|       |            Event::Text("item".into()),
 9009|       |            Event::End(Tag::Item),
 9010|       |            Event::End(Tag::List(None)),
 9011|       |        ];
 9012|       |        let next = renderer.parse_element(&list, 0, &mut elements, &mut slugs);
 9013|       |        assert_eq!(next, list.len());
 9014|       |
 9015|       |        let quote = vec![
 9016|       |            Event::Start(Tag::BlockQuote),
 9017|       |            Event::Start(Tag::Paragraph),
 9018|       |            Event::Text("quote".into()),
 9019|       |            Event::End(Tag::Paragraph),
 9020|       |            Event::End(Tag::BlockQuote),
 9021|       |        ];
 9022|       |        let next = renderer.parse_element(&quote, 0, &mut elements, &mut slugs);
 9023|       |        assert_eq!(next, quote.len());
 9024|       |
 9025|       |        let table = vec![
 9026|       |            Event::Start(Tag::Table(vec![Alignment::Left])),
 9027|       |            Event::Start(Tag::TableHead),
 9028|       |            Event::Start(Tag::TableRow),
 9029|       |            Event::Start(Tag::TableCell),
 9030|       |            Event::Text("H".into()),
 9031|       |            Event::End(Tag::TableCell),
 9032|       |            Event::End(Tag::TableRow),
 9033|       |            Event::End(Tag::TableHead),
 9034|       |            Event::Start(Tag::TableRow),
 9035|       |            Event::Start(Tag::TableCell),
 9036|       |            Event::Text("R".into()),
 9037|       |            Event::End(Tag::TableCell),
 9038|       |            Event::End(Tag::TableRow),
 9039|       |            Event::End(Tag::Table(vec![Alignment::Left])),
 9040|       |        ];
 9041|       |        let next = renderer.parse_element(&table, 0, &mut elements, &mut slugs);
 9042|       |        assert_eq!(next, table.len());
 9043|       |
 9044|       |        let rule = vec![Event::Rule];
 9045|       |        let next = renderer.parse_element(&rule, 0, &mut elements, &mut slugs);
 9046|       |        assert_eq!(next, rule.len());
 9047|       |    }
 9048|       |
 9049|       |    #[test]
 9050|       |    fn test_parse_code_block_with_language() -> Result<()> {
 9051|       |        let renderer = MarkdownRenderer::new();
 9052|       |        let elements = renderer.parse("Intro\n\n```rust\nfn main() {}\n```")?;
 9053|       |        let mut rust_lang = None;
 9054|       |        for element in &elements {
 9055|       |            if let MarkdownElement::CodeBlock { language, .. } = element {
 9056|       |                rust_lang = language.as_deref();
 9057|       |            }
 9058|       |        }
 9059|       |        assert_eq!(rust_lang, Some("rust"));
 9060|       |        Ok(())
 9061|       |    }
 9062|       |
 9063|       |    #[test]
 9064|       |    fn test_parse_code_block_empty_language() {
 9065|       |        let renderer = MarkdownRenderer::new();
 9066|       |        let events = vec![
 9067|       |            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 9068|       |                "".into(),
 9069|       |            ))),
 9070|       |            Event::Text("fn main() {}".into()),
 9071|       |            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 9072|       |                "".into(),
 9073|       |            ))),
 9074|       |        ];
 9075|       |        let (code, language, next) = renderer.parse_code_block(&events, 0);
 9076|       |        assert_eq!(language, None);
 9077|       |        assert_eq!(code, "fn main() {}");
 9078|       |        assert_eq!(next, events.len());
 9079|       |    }
 9080|       |
 9081|       |    #[test]
 9082|       |    fn test_parse_code_block_indented() {
 9083|       |        let renderer = MarkdownRenderer::new();
 9084|       |        let events = vec![
 9085|       |            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Indented)),
 9086|       |            Event::Text("let x = 1;".into()),
 9087|       |            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Indented)),
 9088|       |        ];
 9089|       |        let (code, language, next) = renderer.parse_code_block(&events, 0);
 9090|       |        assert_eq!(language, None);
 9091|       |        assert_eq!(code, "let x = 1;");
 9092|       |        assert_eq!(next, events.len());
 9093|       |    }
 9094|       |
 9095|       |    #[test]
 9096|       |    fn test_parse_table_from_markdown() -> Result<()> {
 9097|       |        let renderer = MarkdownRenderer::new();
 9098|       |        let md = "| H1 | H2 |\n| --- | --- |\n| A | B |\n| C | D |\n";
 9099|       |        let elements = renderer.parse(md)?;
 9100|       |        assert!(elements
 9101|       |            .iter()
 9102|       |            .any(|el| matches!(el, MarkdownElement::Table { .. })));
 9103|       |        Ok(())
 9104|       |    }
 9105|       |
 9106|       |    #[test]
 9107|       |    fn test_hash_inline_spans_variants() {
 9108|       |        let spans = vec![
 9109|       |            InlineSpan::Text("t".to_string()),
 9110|       |            InlineSpan::Code("c".to_string()),
 9111|       |            InlineSpan::Strong("s".to_string()),
 9112|       |            InlineSpan::Emphasis("e".to_string()),
 9113|       |            InlineSpan::Strikethrough("x".to_string()),
 9114|       |            InlineSpan::Link {
 9115|       |                text: "link".to_string(),
 9116|       |                url: "https://example.com".to_string(),
 9117|       |            },
 9118|       |            InlineSpan::Image {
 9119|       |                src: "img.png".to_string(),
 9120|       |                alt: "alt".to_string(),
 9121|       |                title: Some("title".to_string()),
 9122|       |            },
 9123|       |        ];
 9124|       |        let hash = MarkdownRenderer::hash_inline_spans(&spans);
 9125|       |        let hash2 = MarkdownRenderer::hash_inline_spans(&[InlineSpan::Text("other".to_string())]);
 9126|       |        assert_ne!(hash, hash2);
 9127|       |    }
 9128|       |
 9129|       |    #[test]
 9130|       |    fn test_highlight_segments_edge_cases() {
 9131|       |        let renderer = MarkdownRenderer::new();
 9132|       |        assert!(renderer.highlight_segments("", Some("a")).is_empty());
 9133|       |        assert_eq!(
 9134|       |            renderer.highlight_segments("abc", None),
 9135|       |            vec![(0..3, false)]
 9136|       |        );
 9137|       |        assert_eq!(
 9138|       |            renderer.highlight_segments("abc", Some("")),
 9139|       |            vec![(0..3, false)]
 9140|       |        );
 9141|       |        let segments = renderer.highlight_segments("Hello", Some("ell"));
 9142|       |        assert!(segments.iter().any(|(_, highlighted)| *highlighted));
 9143|       |    }
 9144|       |
 9145|       |    #[test]
 9146|       |    fn test_resolve_table_widths_branches() {
 9147|       |        assert!(MarkdownRenderer::resolve_table_widths(50.0, &[], &[]).is_empty());
 9148|       |        assert_eq!(
 9149|       |            MarkdownRenderer::resolve_table_widths(100.0, &[10.0, 10.0], &[20.0, 30.0]),
 9150|       |            vec![20.0, 30.0]
 9151|       |        );
 9152|       |
 9153|       |        assert_eq!(
 9154|       |            MarkdownRenderer::resolve_table_widths(10.0, &[0.0, 0.0], &[0.0, 0.0]),
 9155|       |            vec![5.0, 5.0]
 9156|       |        );
 9157|       |
 9158|       |        assert_eq!(
 9159|       |            MarkdownRenderer::resolve_table_widths(10.0, &[10.0, 10.0], &[20.0, 20.0]),
 9160|       |            vec![5.0, 5.0]
 9161|       |        );
 9162|       |
 9163|       |        assert_eq!(
 9164|       |            MarkdownRenderer::resolve_table_widths(30.0, &[10.0, 10.0], &[10.0, 10.0]),
 9165|       |            vec![15.0, 15.0]
 9166|       |        );
 9167|       |
 9168|       |        let widths = MarkdownRenderer::resolve_table_widths(30.0, &[10.0, 10.0], &[20.0, 30.0]);
 9169|       |        assert_eq!(widths.len(), 2);
 9170|       |        assert!((widths[0] + widths[1] - 30.0).abs() < 0.1);
 9171|       |    }
 9172|       |
 9173|       |    #[test]
 9174|       |    fn test_table_line_breaks_case_parses_all_rows() -> Result<()> {
 9175|       |        let renderer = MarkdownRenderer::new();
 9176|       |        let md = fs::read_to_string("tests/regression/cases/017-table-line-breaks.md")?;
 9177|       |        let elements = renderer.parse(&md)?;
 9178|       |        let rows = elements.iter().find_map(|el| match el {
 9179|       |            MarkdownElement::Table { rows, .. } => Some(rows),
 9180|       |            _ => None,
 9181|       |        });
 9182|       |        let rows = rows.expect("table present");
 9183|       |        assert_eq!(rows.len(), 7);
 9184|       |        let plain = MarkdownRenderer::elements_to_plain_text(&elements);
 9185|       |        assert!(plain.contains("Strong"));
 9186|       |        assert!(plain.contains("Attr"));
 9187|       |        Ok(())
 9188|       |    }
 9189|       |
 9190|       |    #[test]
 9191|       |    fn test_table_line_breaks_case_renders_all_rows() -> Result<()> {
 9192|       |        let renderer = MarkdownRenderer::new();
 9193|       |        let md = fs::read_to_string("tests/regression/cases/017-table-line-breaks.md")?;
 9194|       |        let elements = renderer.parse(&md)?;
 9195|       |        with_test_ui(|ctx, ui| {
 9196|       |            ctx.set_visuals(egui::Visuals::light());
 9197|       |            renderer.render_to_ui(ui, &elements);
 9198|       |        });
 9199|       |        let (rendered, total) = renderer.table_render_stats();
 9200|       |        assert_eq!(rendered, total);
 9201|       |        assert_eq!(rendered, 7);
 9202|       |        Ok(())
 9203|       |    }
 9204|       |
 9205|       |    #[test]
 9206|       |    fn test_table_first_column_alignment_case_parses_columns() -> Result<()> {
 9207|       |        let renderer = MarkdownRenderer::new();
 9208|       |        let md = fs::read_to_string("tests/regression/cases/026-table-first-column-align.md")?;
 9209|       |        let elements = renderer.parse(&md)?;
 9210|       |        let mut tables = elements.iter().filter_map(|el| match el {
 9211|       |            MarkdownElement::Table {
 9212|       |                headers,
 9213|       |                rows,
 9214|       |                alignments,
 9215|       |            } => Some((headers, rows, alignments)),
 9216|       |            _ => None,
 9217|       |        });
 9218|       |        let (headers, rows, alignments) = tables.next().expect("expected table");
 9219|       |        assert_eq!(headers.len(), 3);
 9220|       |        assert_eq!(alignments.len(), 3);
 9221|       |        assert!(rows.iter().all(|row| row.len() == 3));
 9222|       |        Ok(())
 9223|       |    }
 9224|       |
 9225|       |    #[test]
 9226|       |    fn test_handle_width_change_requests_repaint() {
 9227|       |        let renderer = MarkdownRenderer::new();
 9228|       |        let ctx = egui::Context::default();
 9229|       |        renderer.handle_width_change(&ctx, 42, WidthChange::Large);
 9230|       |        let metrics = renderer.table_metrics.borrow();
 9231|       |        let entry = metrics.entry(42).expect("metrics entry");
 9232|       |        assert!(entry.last_discard_frame.is_some());
 9233|       |    }
 9234|       |
 9235|       |    #[test]
 9236|       |    fn test_handle_width_change_skips_duplicate_frame() {
 9237|       |        let renderer = MarkdownRenderer::new();
 9238|       |        let ctx = egui::Context::default();
 9239|       |        renderer.handle_width_change(&ctx, 42, WidthChange::Large);
 9240|       |        renderer.handle_width_change(&ctx, 42, WidthChange::Large);
 9241|       |        let metrics = renderer.table_metrics.borrow();
 9242|       |        let entry = metrics.entry(42).expect("metrics entry");
 9243|       |        assert_eq!(entry.last_discard_frame, Some(ctx.frame_nr()));
 9244|       |    }
 9245|       |
 9246|       |    #[test]
 9247|       |    fn test_render_list_multiline_indent_and_empty() {
 9248|       |        let renderer = MarkdownRenderer::new();
 9249|       |        let spans = vec![InlineSpan::Text("First\n  Nested".to_string())];
 9250|       |        let item = ListItem {
 9251|       |            blocks: vec![MarkdownElement::Paragraph(spans.clone())],
 9252|       |        };
 9253|       |        with_test_ui(|ctx, ui| {
 9254|       |            ctx.set_visuals(egui::Visuals::light());
 9255|       |            renderer.render_list(ui, false, &[]);
 9256|       |            renderer.render_list(ui, true, std::slice::from_ref(&item));
 9257|       |        });
 9258|       |    }
 9259|       |
 9260|       |    #[test]
 9261|       |    fn test_render_list_paragraph_handles_blank_parts_and_indent() {
 9262|       |        let renderer = MarkdownRenderer::new();
 9263|       |        let spans = vec![
 9264|       |            InlineSpan::Text("Line 1\n\n  indented".to_string()),
 9265|       |            InlineSpan::Image {
 9266|       |                src: "assets/emoji/1f600.png".to_string(),
 9267|       |                alt: "img".to_string(),
 9268|       |                title: None,
 9269|       |            },
 9270|       |        ];
 9271|       |        with_test_ui(|_, ui| {
 9272|       |            renderer.render_list_paragraph(ui, None, Color32::WHITE, 12.0, &spans);
 9273|       |        });
 9274|       |    }
 9275|       |
 9276|       |    #[test]
 9277|       |    fn test_render_list_paragraph_multiline_without_leading_spaces() {
 9278|       |        let renderer = MarkdownRenderer::new();
 9279|       |        let spans = vec![InlineSpan::Text("Line 1\nLine 2".to_string())];
 9280|       |        with_test_ui(|_, ui| {
 9281|       |            renderer.render_list_paragraph(ui, None, Color32::WHITE, 12.0, &spans);
 9282|       |        });
 9283|       |    }
 9284|       |
 9285|       |    #[test]
 9286|       |    fn test_render_inline_span_image_hover_caption_uses_cached_texture() {
 9287|       |        let renderer = MarkdownRenderer::new();
 9288|       |        let span = InlineSpan::Image {
 9289|       |            src: "assets/emoji/1f600.png".to_string(),
 9290|       |            alt: "alt".to_string(),
 9291|       |            title: Some("Caption".to_string()),
 9292|       |        };
 9293|       |        let _guard = ForcedRenderActions::new(&["image_hover"]);
 9294|       |        with_test_ui(|_, ui| {
 9295|       |            let image = egui::ColorImage::new([2, 2], Color32::WHITE);
 9296|       |            let texture = ui.ctx().load_texture(
 9297|       |                "test-inline-image-hover",
 9298|       |                image,
 9299|       |                egui::TextureOptions::LINEAR,
 9300|       |            );
 9301|       |            renderer.store_image_texture("assets/emoji/1f600.png", texture, [2, 2], None);
 9302|       |            renderer.render_inline_span(ui, &span, None, None);
 9303|       |        });
 9304|       |    }
 9305|       |
 9306|       |    #[test]
 9307|       |    fn test_render_inline_span_forced_actions_and_image_title() {
 9308|       |        let renderer = MarkdownRenderer::new();
 9309|       |        renderer.set_highlight_phrase(Some("hi"));
 9310|       |        let image_span = InlineSpan::Image {
 9311|       |            src: "assets/emoji/1f600.png".to_string(),
 9312|       |            alt: "alt".to_string(),
 9313|       |            title: Some("Caption".to_string()),
 9314|       |        };
 9315|       |        let missing_span = InlineSpan::Image {
 9316|       |            src: "missing.png".to_string(),
 9317|       |            alt: "missing".to_string(),
 9318|       |            title: None,
 9319|       |        };
 9320|       |        let link_span = InlineSpan::Link {
 9321|       |            text: "hi link".to_string(),
 9322|       |            url: "https://example.com".to_string(),
 9323|       |        };
 9324|       |        let _guard = ForcedRenderActions::new(&["link_hover", "link_click", "image_hover"]);
 9325|       |        with_test_ui(|_, ui| {
 9326|       |            renderer.render_inline_span(
 9327|       |                ui,
 9328|       |                &InlineSpan::Text("hi \u{1f600}".to_string()),
 9329|       |                None,
 9330|       |                None,
 9331|       |            );
 9332|       |            renderer.render_inline_span(ui, &InlineSpan::Strong("hi".to_string()), None, None);
 9333|       |            renderer.render_inline_span(ui, &InlineSpan::Emphasis("hi".to_string()), None, None);
 9334|       |            renderer.render_inline_span(
 9335|       |                ui,
 9336|       |                &InlineSpan::Strikethrough("hi".to_string()),
 9337|       |                None,
 9338|       |                None,
 9339|       |            );
 9340|       |            renderer.render_inline_span(ui, &InlineSpan::Code("code".to_string()), None, None);
 9341|       |            renderer.render_inline_span(ui, &link_span, None, None);
 9342|       |            renderer.render_inline_span(ui, &image_span, None, None);
 9343|       |            renderer.render_inline_span(ui, &missing_span, None, None);
 9344|       |        });
 9345|       |    }
 9346|       |
 9347|       |    #[test]
 9348|       |    fn test_get_or_load_image_texture_embedded_and_remote() {
 9349|       |        let renderer = MarkdownRenderer::new();
 9350|       |        with_test_ui(|ctx, ui| {
 9351|       |            let embedded = wait_for_image(&renderer, ctx, ui, "assets/emoji/1f600.png");
 9352|       |            assert!(embedded.is_some());
 9353|       |            let remote = renderer.get_or_load_image_texture(ui, "https://example.com/img.png");
 9354|       |            assert!(remote.is_none());
 9355|       |        });
 9356|       |    }
 9357|       |
 9358|       |    #[test]
 9359|       |    fn test_get_or_load_image_texture_embedded_cache_hit() {
 9360|       |        let renderer = MarkdownRenderer::new();
 9361|       |        with_test_ui(|ctx, ui| {
 9362|       |            let tex = ctx.load_texture(
 9363|       |                "embedded-cache",
 9364|       |                egui::ColorImage::new([2, 2], Color32::WHITE),
 9365|       |                Default::default(),
 9366|       |            );
 9367|       |            renderer.store_image_texture("assets/emoji/1f600.png", tex, [2, 2], None);
 9368|       |            let loaded = renderer.get_or_load_image_texture(ui, "assets/emoji/1f600.png");
 9369|       |            assert!(loaded.is_some());
 9370|       |        });
 9371|       |    }
 9372|       |
 9373|       |    #[test]
 9374|       |    fn test_get_or_load_image_texture_skips_recent_failure() {
 9375|       |        let renderer = MarkdownRenderer::new();
 9376|       |        with_test_ui(|_, ui| {
 9377|       |            renderer.note_image_failure("missing.png");
 9378|       |            let loaded = renderer.get_or_load_image_texture(ui, "missing.png");
 9379|       |            assert!(loaded.is_none());
 9380|       |            assert!(renderer.image_failures.borrow().contains_key("missing.png"));
 9381|       |        });
 9382|       |    }
 9383|       |
 9384|       |    #[test]
 9385|       |    fn test_get_or_load_image_texture_skips_pending() {
 9386|       |        let renderer = MarkdownRenderer::new();
 9387|       |        with_test_ui(|_, ui| {
 9388|       |            renderer
 9389|       |                .image_pending
 9390|       |                .borrow_mut()
 9391|       |                .insert("pending.png".to_string());
 9392|       |            let loaded = renderer.get_or_load_image_texture(ui, "pending.png");
 9393|       |            assert!(loaded.is_none());
 9394|       |        });
 9395|       |    }
 9396|       |
 9397|       |    #[test]
 9398|       |    fn test_render_inline_span_loaded_image_without_title() {
 9399|       |        let renderer = MarkdownRenderer::new();
 9400|       |        let span = InlineSpan::Image {
 9401|       |            src: "assets/emoji/1f600.png".to_string(),
 9402|       |            alt: "".to_string(),
 9403|       |            title: None,
 9404|       |        };
 9405|       |        with_test_ui(|ctx, ui| {
 9406|       |            let _ = wait_for_image(&renderer, ctx, ui, "assets/emoji/1f600.png");
 9407|       |            renderer.render_inline_span(ui, &span, None, None);
 9408|       |        });
 9409|       |    }
 9410|       |
 9411|       |    #[test]
 9412|       |    fn test_get_or_make_emoji_texture_cache() {
 9413|       |        let renderer = MarkdownRenderer::new();
 9414|       |        with_test_ui(|_, ui| {
 9415|       |            let tex = renderer.get_or_make_emoji_texture(ui, "\u{1f600}");
 9416|       |            assert!(tex.size()[0] > 0);
 9417|       |            let cached = renderer.get_or_make_emoji_texture(ui, "\u{1f600}");
 9418|       |            assert_eq!(cached.size(), tex.size());
 9419|       |        });
 9420|       |    }
 9421|       |
 9422|       |    #[test]
 9423|       |    fn test_get_or_make_emoji_texture_unknown_fallbacks() {
 9424|       |        let renderer = MarkdownRenderer::new();
 9425|       |        with_test_ui(|_, ui| {
 9426|       |            let tex = renderer.get_or_make_emoji_texture(ui, "not-emoji");
 9427|       |            assert!(tex.size()[0] > 0);
 9428|       |        });
 9429|       |    }
 9430|       |
 9431|       |    #[test]
 9432|       |    fn test_render_overhauled_cell_fragments() {
 9433|       |        let renderer = MarkdownRenderer::new();
 9434|       |        let emoji_span = InlineSpan::Text("\u{1f600}".to_string());
 9435|       |        let image_span = InlineSpan::Image {
 9436|       |            src: "assets/emoji/1f600.png".to_string(),
 9437|       |            alt: "alt".to_string(),
 9438|       |            title: None,
 9439|       |        };
 9440|       |        with_test_ui(|_, ui| {
 9441|       |            renderer.render_overhauled_cell(ui, &[], 120.0, false, Some(0), 0, Align::LEFT);
 9442|       |            renderer.render_overhauled_cell(
 9443|       |                ui,
 9444|       |                &[emoji_span.clone(), image_span.clone()],
 9445|       |                120.0,
 9446|       |                false,
 9447|       |                Some(1),
 9448|       |                1,
 9449|       |                Align::LEFT,
 9450|       |            );
 9451|       |        });
 9452|       |    }
 9453|       |
 9454|       |    #[test]
 9455|       |    fn test_paint_table_text_job_link_interaction() {
 9456|       |        let renderer = MarkdownRenderer::new();
 9457|       |        let spans = vec![InlineSpan::Link {
 9458|       |            text: "Click here for more text".to_string(),
 9459|       |            url: "https://example.com".to_string(),
 9460|       |        }];
 9461|       |        let ctx = egui::Context::default();
 9462|       |        let click_pos = egui::pos2(5.0, 5.0);
 9463|       |
 9464|       |        let input = input_with_click(click_pos, egui::PointerButton::Secondary);
 9465|       |        run_frame_with_input(&ctx, input, |_, ui| {
 9466|       |            ui.allocate_ui_at_rect(
 9467|       |                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
 9468|       |                |ui| {
 9469|       |                    let build =
 9470|       |                        renderer.build_layout_job(ui.style(), &spans, 30.0, false, Align::LEFT);
 9471|       |                    renderer.paint_table_text_job(ui, 120.0, build);
 9472|       |                },
 9473|       |            );
 9474|       |        });
 9475|       |
 9476|       |        let input = input_with_click(click_pos, egui::PointerButton::Primary);
 9477|       |        run_frame_with_input(&ctx, input, |_, ui| {
 9478|       |            ui.allocate_ui_at_rect(
 9479|       |                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
 9480|       |                |ui| {
 9481|       |                    let build =
 9482|       |                        renderer.build_layout_job(ui.style(), &spans, 30.0, false, Align::LEFT);
 9483|       |                    renderer.paint_table_text_job(ui, 120.0, build);
 9484|       |                },
 9485|       |            );
 9486|       |        });
 9487|       |    }
 9488|       |
 9489|       |    #[test]
 9490|       |    fn test_aligned_text_origin_anchors_to_rect() {
 9491|       |        let rect = egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(100.0, 20.0));
 9492|       |        let galley = Arc::new(Galley {
 9493|       |            job: Arc::new(LayoutJob::default()),
 9494|       |            rows: Vec::new(),
 9495|       |            elided: false,
 9496|       |            rect: egui::Rect::from_min_max(egui::pos2(0.0, 0.0), egui::pos2(20.0, 10.0)),
 9497|       |            mesh_bounds: egui::Rect::NOTHING,
 9498|       |            num_vertices: 0,
 9499|       |            num_indices: 0,
 9500|       |            pixels_per_point: 1.0,
 9501|       |        });
 9502|       |        let left_origin = MarkdownRenderer::aligned_text_origin(rect, &galley, Align::LEFT);
 9503|       |        let center_origin = MarkdownRenderer::aligned_text_origin(rect, &galley, Align::Center);
 9504|       |        let right_origin = MarkdownRenderer::aligned_text_origin(rect, &galley, Align::RIGHT);
 9505|       |
 9506|       |        assert_eq!(left_origin.x, rect.left());
 9507|       |        assert_eq!(center_origin.x, rect.center().x - galley.rect.center().x);
 9508|       |        assert_eq!(right_origin.x, rect.right() - galley.rect.right());
 9509|       |        assert_eq!(left_origin.y, rect.top());
 9510|       |    }
 9511|       |
 9512|       |    #[test]
 9513|       |    fn test_layout_job_center_rect_is_origin() {
 9514|       |        let renderer = MarkdownRenderer::new();
 9515|       |        let spans = vec![InlineSpan::Text("Item".to_string())];
 9516|       |        with_test_ui(|_, ui| {
 9517|       |            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, true, Align::Center);
 9518|       |            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
 9519|       |            assert!(galley.rect.center().x.abs() <= 0.01);
 9520|       |        });
 9521|       |    }
 9522|       |
 9523|       |    #[test]
 9524|       |    fn test_render_table_tablebuilder_variants() {
 9525|       |        let renderer = MarkdownRenderer::new();
 9526|       |        let headers = vec![vec![InlineSpan::Text("H1".to_string())]];
 9527|       |        let rows = vec![vec![
 9528|       |            vec![InlineSpan::Text("A".to_string())],
 9529|       |            vec![InlineSpan::Text("B".to_string())],
 9530|       |        ]];
 9531|       |        with_test_ui(|_, ui| {
 9532|       |            let table_id = renderer.compute_table_id(&headers, &rows, &[], 0);
 9533|       |            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
 9534|       |            let empty_id = renderer.compute_table_id(&headers, &[], &[], 1);
 9535|       |            renderer.render_table_tablebuilder(ui, &headers, &[], &[], empty_id);
 9536|       |        });
 9537|       |    }
 9538|       |
 9539|       |    #[test]
 9540|       |    fn test_render_code_block_context_menu_clicks() {
 9541|       |        let renderer = MarkdownRenderer::new();
 9542|       |        let ctx = egui::Context::default();
 9543|       |        let input = input_with_click(egui::pos2(5.0, 5.0), egui::PointerButton::Primary);
 9544|       |        run_frame_with_input(&ctx, input, |_, ui| {
 9545|       |            ui.allocate_ui_at_rect(
 9546|       |                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
 9547|       |                |ui| {
 9548|       |                    renderer.render_code_block_context_menu(ui, "code", Some("rust"));
 9549|       |                },
 9550|       |            );
 9551|       |        });
 9552|       |
 9553|       |        let input = input_with_click(egui::pos2(5.0, 30.0), egui::PointerButton::Primary);
 9554|       |        run_frame_with_input(&ctx, input, |_, ui| {
 9555|       |            ui.allocate_ui_at_rect(
 9556|       |                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
 9557|       |                |ui| {
 9558|       |                    renderer.render_code_block_context_menu(ui, "code", Some("rust"));
 9559|       |                },
 9560|       |            );
 9561|       |        });
 9562|       |    }
 9563|       |
 9564|       |    #[test]
 9565|       |    fn test_find_syntax_for_language() {
 9566|       |        let renderer = MarkdownRenderer::new();
 9567|       |        assert!(renderer.find_syntax_for_language("rust").is_some());
 9568|       |        assert!(renderer.find_syntax_for_language("nonexistent").is_none());
 9569|       |    }
 9570|       |
 9571|       |    #[test]
 9572|       |    fn test_find_syntax_for_language_direct_name_match() -> Result<()> {
 9573|       |        let mut renderer = MarkdownRenderer::new();
 9574|       |        let syntax = SyntaxDefinition::load_from_str(
 9575|       |            r#"
 9576|       |name: testlang
 9577|       |scope: source.testlang
 9578|       |file_extensions: [tst]
 9579|       |contexts:
 9580|       |  main:
 9581|       |    - match: '.'
 9582|       |      scope: source.testlang
 9583|       |"#,
 9584|       |            true,
 9585|       |            None,
 9586|       |        )
 9587|       |        .expect("syntax");
 9588|       |        let mut builder = renderer.syntax_set.clone().into_builder();
 9589|       |        builder.add(syntax);
 9590|       |        renderer.syntax_set = builder.build();
 9591|       |        assert!(renderer.find_syntax_for_language("testlang").is_some());
 9592|       |        Ok(())
 9593|       |    }
 9594|       |
 9595|       |    #[test]
 9596|       |    fn test_find_syntax_for_language_mappings() {
 9597|       |        let renderer = MarkdownRenderer::new();
 9598|       |        assert!(renderer.find_syntax_for_language("markdown").is_some());
 9599|       |        assert!(renderer.find_syntax_for_language("shell").is_some());
 9600|       |        assert!(renderer.find_syntax_for_language("yaml").is_some());
 9601|       |    }
 9602|       |
 9603|       |    #[test]
 9604|       |    fn test_find_syntax_for_language_mapped_names() {
 9605|       |        let renderer = MarkdownRenderer::new();
 9606|       |        let langs = [
 9607|       |            "python",
 9608|       |            "javascript",
 9609|       |            "typescript",
 9610|       |            "c++",
 9611|       |            "cpp",
 9612|       |            "c#",
 9613|       |            "shell",
 9614|       |            "bash",
 9615|       |            "powershell",
 9616|       |            "yaml",
 9617|       |            "markdown",
 9618|       |            "sql",
 9619|       |            "toml",
 9620|       |        ];
 9621|       |        for lang in langs {
 9622|       |            let _ = renderer.find_syntax_for_language(lang);
 9623|       |        }
 9624|       |    }
 9625|       |
 9626|       |    #[test]
 9627|       |    fn test_find_syntax_for_language_aliases_with_empty_syntax_set() {
 9628|       |        let mut renderer = MarkdownRenderer::new();
 9629|       |        renderer.syntax_set = SyntaxSet::new();
 9630|       |        let langs = [
 9631|       |            "rust",
 9632|       |            "python",
 9633|       |            "javascript",
 9634|       |            "typescript",
 9635|       |            "c++",
 9636|       |            "cpp",
 9637|       |            "c#",
 9638|       |            "csharp",
 9639|       |            "shell",
 9640|       |            "bash",
 9641|       |            "powershell",
 9642|       |            "yaml",
 9643|       |            "markdown",
 9644|       |            "html",
 9645|       |            "css",
 9646|       |            "java",
 9647|       |            "go",
 9648|       |            "php",
 9649|       |            "ruby",
 9650|       |            "xml",
 9651|       |            "json",
 9652|       |            "sql",
 9653|       |            "toml",
 9654|       |            "unknownlang",
 9655|       |        ];
 9656|       |        for lang in langs {
 9657|       |            assert!(renderer.find_syntax_for_language(lang).is_none());
 9658|       |        }
 9659|       |    }
 9660|       |
 9661|       |    #[test]
 9662|       |    fn test_estimate_table_image_height_with_title() {
 9663|       |        let renderer = MarkdownRenderer::new();
 9664|       |        let span = InlineSpan::Image {
 9665|       |            src: "assets/samples/logo.svg".to_string(),
 9666|       |            alt: "logo".to_string(),
 9667|       |            title: Some("Caption".to_string()),
 9668|       |        };
 9669|       |        with_test_ui(|_, ui| {
 9670|       |            let height = renderer.estimate_table_image_height(ui, &span, 120.0);
 9671|       |            assert!(height > 0.0);
 9672|       |            let fallback = renderer.estimate_table_image_height(
 9673|       |                ui,
 9674|       |                &InlineSpan::Text("text".to_string()),
 9675|       |                120.0,
 9676|       |            );
 9677|       |            assert!(fallback > 0.0);
 9678|       |        });
 9679|       |    }
 9680|       |
 9681|       |    #[test]
 9682|       |    fn test_render_table_emoji() {
 9683|       |        let renderer = MarkdownRenderer::new();
 9684|       |        with_test_ui(|_, ui| {
 9685|       |            renderer.render_table_emoji(ui, "\u{1f600}");
 9686|       |        });
 9687|       |    }
 9688|       |
 9689|       |    #[test]
 9690|       |    fn test_render_list_block_non_paragraph() {
 9691|       |        let renderer = MarkdownRenderer::new();
 9692|       |        let block = MarkdownElement::CodeBlock {
 9693|       |            language: Some("rust".to_string()),
 9694|       |            text: "fn main() {}".to_string(),
 9695|       |        };
 9696|       |        with_test_ui(|_, ui| {
 9697|       |            renderer.render_list_block(ui, &block, 12.0, Color32::WHITE);
 9698|       |        });
 9699|       |    }
 9700|       |
 9701|       |    #[test]
 9702|       |    fn test_measure_inline_spans_with_image() {
 9703|       |        let renderer = MarkdownRenderer::new();
 9704|       |        let spans = vec![InlineSpan::Image {
 9705|       |            src: "assets/samples/logo.svg".to_string(),
 9706|       |            alt: "logo".to_string(),
 9707|       |            title: None,
 9708|       |        }];
 9709|       |        with_test_ui(|_, ui| {
 9710|       |            let width = renderer.measure_inline_spans(ui, &spans);
 9711|       |            assert!(width > 0.0);
 9712|       |        });
 9713|       |    }
 9714|       |
 9715|       |    #[test]
 9716|       |    fn test_parse_blockquote_with_nested_blocks() {
 9717|       |        let renderer = MarkdownRenderer::new();
 9718|       |        let md = r#"> # Quote Heading
 9719|       |> Paragraph **bold** *em* ~~strike~~ [link](https://example.com)
 9720|       |> ![alt](assets/samples/logo.svg "Logo")
 9721|       |> - Item one
 9722|       |>   - Nested item
 9723|       |> 
 9724|       |> ```rust
 9725|       |> let x = 1;
 9726|       |> ```
 9727|       |> 
 9728|       |> | H1 | H2 |
 9729|       |> | --- | --- |
 9730|       |> |  | ![a](assets/samples/logo.svg "Img") |
 9731|       |"#;
 9732|       |        let elements = renderer.parse(md).expect("parse");
 9733|       |        assert!(elements
 9734|       |            .iter()
 9735|       |            .any(|e| matches!(e, MarkdownElement::Quote { .. })));
 9736|       |    }
 9737|       |
 9738|       |    #[test]
 9739|       |    fn test_parse_list_with_heading_and_table() {
 9740|       |        let renderer = MarkdownRenderer::new();
 9741|       |        let md = r#"- # Item heading
 9742|       |  Paragraph text with `code` and **strong**
 9743|       |  - Nested child
 9744|       |- | A | B |
 9745|       |  | - | - |
 9746|       |  | 1 | 2 |
 9747|       |- ```rust
 9748|       |  fn main() {}
 9749|       |  ```
 9750|       |- > Quote in list
 9751|       |- ---
 9752|       |"#;
 9753|       |        let elements = renderer.parse(md).expect("parse");
 9754|       |        assert!(elements
 9755|       |            .iter()
 9756|       |            .any(|e| matches!(e, MarkdownElement::List { .. })));
 9757|       |    }
 9758|       |
 9759|       |    #[test]
 9760|       |    fn test_parse_list_inline_variants() {
 9761|       |        let renderer = MarkdownRenderer::new();
 9762|       |        let md = r#"- Item with *em* **strong** ~~strike~~ `code` [link](https://example.com) ![alt](assets/emoji/1f600.png "title")  
 9763|       |  next line"#;
 9764|       |        let elements = renderer.parse(md).expect("parse");
 9765|       |        assert!(elements
 9766|       |            .iter()
 9767|       |            .any(|e| matches!(e, MarkdownElement::List { .. })));
 9768|       |    }
 9769|       |
 9770|       |    #[test]
 9771|       |    fn test_parse_blockquote_with_varied_content() -> Result<()> {
 9772|       |        let renderer = MarkdownRenderer::new();
 9773|       |        let md = r#"
 9774|       |> ### Quote Heading
 9775|       |> Paragraph with *em* **strong** ~~strike~~ `code` [link](https://example.com) ![alt](assets/emoji/1f600.png "title")  
 9776|       |> Next line<br>
 9777|       |>
 9778|       |> - item one
 9779|       |> - item two
 9780|       |>
 9781|       |> | h1 | h2 |
 9782|       |> | --- | --- |
 9783|       |> | a | b |
 9784|       |>
 9785|       |> ```rust
 9786|       |> fn main() {
 9787|       |>     // comment
 9788|       |> }
 9789|       |> ```
 9790|       |>
 9791|       |> > Nested quote
 9792|       |>
 9793|       |> ---
 9794|       |"#;
 9795|       |        let elements = renderer.parse(md)?;
 9796|       |        assert!(elements
 9797|       |            .iter()
 9798|       |            .any(|e| matches!(e, MarkdownElement::Quote { .. })));
 9799|       |        Ok(())
 9800|       |    }
 9801|       |
 9802|       |    #[test]
 9803|       |    fn test_find_syntax_for_language_variants() {
 9804|       |        let renderer = MarkdownRenderer::new();
 9805|       |        assert!(renderer.find_syntax_for_language("rs").is_some());
 9806|       |        let cs_ext = renderer.syntax_set.find_syntax_by_extension("cs");
 9807|       |        let cs_lang = renderer.find_syntax_for_language("csharp");
 9808|       |        assert_eq!(cs_lang.is_some(), cs_ext.is_some());
 9809|       |        let ps_ext = renderer.syntax_set.find_syntax_by_extension("ps1");
 9810|       |        let ps_lang = renderer.find_syntax_for_language("powershell");
 9811|       |        assert_eq!(ps_lang.is_some(), ps_ext.is_some());
 9812|       |        assert!(renderer.find_syntax_for_language("madeuplang").is_none());
 9813|       |    }
 9814|       |
 9815|       |    #[test]
 9816|       |    fn test_generate_emoji_image_variants() {
 9817|       |        let renderer = MarkdownRenderer::new();
 9818|       |        let emojis = [
 9819|       |            "\u{1f389}",
 9820|       |            "\u{2705}",
 9821|       |            "\u{1f680}",
 9822|       |            "\u{1f642}",
 9823|       |            "\u{1f600}",
 9824|       |            "\u{1f609}",
 9825|       |            "\u{2b50}",
 9826|       |            "\u{1f525}",
 9827|       |            "\u{1f44d}",
 9828|       |            "\u{1f44e}",
 9829|       |            "\u{1f4a1}",
 9830|       |            "\u{2753}",
 9831|       |            "\u{2757}",
 9832|       |            "\u{1f4dd}",
 9833|       |            "\u{1f9e0}",
 9834|       |            "\u{1f9ea}",
 9835|       |            "\u{1f4e6}",
 9836|       |            "\u{1f527}",
 9837|       |            "x",
 9838|       |        ];
 9839|       |        for emoji in emojis {
 9840|       |            let image = renderer.generate_emoji_image(emoji, 8);
 9841|       |            assert_eq!(image.size, [8, 8]);
 9842|       |        }
 9843|       |    }
 9844|       |
 9845|       |    #[test]
 9846|       |    fn test_measure_inline_spans_code_and_image() {
 9847|       |        let renderer = MarkdownRenderer::new();
 9848|       |        with_test_ui(|ctx, ui| {
 9849|       |            let tex = ctx.load_texture(
 9850|       |                "test-image",
 9851|       |                egui::ColorImage::new([2, 2], Color32::WHITE),
 9852|       |                egui::TextureOptions::LINEAR,
 9853|       |            );
 9854|       |            renderer.image_textures.borrow_mut().insert(
 9855|       |                "image.png".to_string(),
 9856|       |                ImageCacheEntry {
 9857|       |                    texture: tex,
 9858|       |                    size: [64, 32],
 9859|       |                    modified: None,
 9860|       |                },
 9861|       |            );
 9862|       |            let spans = vec![
 9863|       |                InlineSpan::Text("Hello".to_string()),
 9864|       |                InlineSpan::Code("line1\nline2".to_string()),
 9865|       |                InlineSpan::Image {
 9866|       |                    src: "image.png".to_string(),
 9867|       |                    alt: "Alt".to_string(),
 9868|       |                    title: None,
 9869|       |                },
 9870|       |            ];
 9871|       |            let width = renderer.measure_inline_spans(ui, &spans);
 9872|       |            assert!(width > 0.0);
 9873|       |        });
 9874|       |    }
 9875|       |
 9876|       |    #[test]
 9877|       |    fn test_get_or_load_image_texture_cache_and_remote() -> Result<()> {
 9878|       |        let renderer = MarkdownRenderer::new();
 9879|       |        with_test_ui(|_, ui| {
 9880|       |            assert!(renderer
 9881|       |                .get_or_load_image_texture(ui, "https://example.com/logo.png")
 9882|       |                .is_none());
 9883|       |        });
 9884|       |
 9885|       |        let temp = tempdir()?;
 9886|       |        let image_path = temp.path().join("image.png");
 9887|       |        std::fs::write(&image_path, tiny_png_bytes())?;
 9888|       |        let resolved = image_path.to_string_lossy().to_string();
 9889|       |        with_test_ui(|ctx, ui| {
 9890|       |            let first = wait_for_image(&renderer, ctx, ui, &resolved);
 9891|       |            assert!(first.is_some());
 9892|       |            let second = renderer.get_or_load_image_texture(ui, &resolved);
 9893|       |            assert!(second.is_some());
 9894|       |        });
 9895|       |        Ok(())
 9896|       |    }
 9897|       |
 9898|       |    #[test]
 9899|       |    fn test_get_or_load_image_texture_stale_cache_evicted() -> Result<()> {
 9900|       |        let renderer = MarkdownRenderer::new();
 9901|       |        let temp = tempdir()?;
 9902|       |        let image_path = temp.path().join("image.png");
 9903|       |        std::fs::write(&image_path, tiny_png_bytes())?;
 9904|       |        let resolved = image_path.to_string_lossy().to_string();
 9905|       |
 9906|       |        with_test_ui(|ctx, ui| {
 9907|       |            let tex = ctx.load_texture(
 9908|       |                "stale-image",
 9909|       |                egui::ColorImage::new([2, 2], Color32::WHITE),
 9910|       |                egui::TextureOptions::LINEAR,
 9911|       |            );
 9912|       |            renderer.image_textures.borrow_mut().insert(
 9913|       |                resolved.clone(),
 9914|       |                ImageCacheEntry {
 9915|       |                    texture: tex,
 9916|       |                    size: [2, 2],
 9917|       |                    modified: Some(SystemTime::UNIX_EPOCH),
 9918|       |                },
 9919|       |            );
 9920|       |
 9921|       |            let result = renderer.get_or_load_image_texture(ui, &resolved);
 9922|       |            assert!(result.is_none());
 9923|       |            assert!(!renderer.image_textures.borrow().contains_key(&resolved));
 9924|       |            assert!(renderer.image_pending.borrow().contains(&resolved));
 9925|       |        });
 9926|       |
 9927|       |        Ok(())
 9928|       |    }
 9929|       |
 9930|       |    #[test]
 9931|       |    fn test_get_or_load_image_texture_enqueue_failure() -> Result<()> {
 9932|       |        let mut renderer = MarkdownRenderer::new();
 9933|       |        let (image_job_tx, image_job_rx) = bounded(0);
 9934|       |        drop(image_job_rx);
 9935|       |        renderer.image_job_tx = image_job_tx;
 9936|       |
 9937|       |        let temp = tempdir()?;
 9938|       |        let image_path = temp.path().join("image.png");
 9939|       |        std::fs::write(&image_path, tiny_png_bytes())?;
 9940|       |        let resolved = image_path.to_string_lossy().to_string();
 9941|       |
 9942|       |        with_test_ui(|_, ui| {
 9943|       |            let result = renderer.get_or_load_image_texture(ui, &resolved);
 9944|       |            assert!(result.is_none());
 9945|       |            assert!(!renderer.image_pending.borrow().contains(&resolved));
 9946|       |        });
 9947|       |
 9948|       |        Ok(())
 9949|       |    }
 9950|       |
 9951|       |    #[test]
 9952|       |    fn test_poll_image_results_records_failure() {
 9953|       |        let mut renderer = MarkdownRenderer::new();
 9954|       |        let (result_tx, result_rx) = crossbeam_channel::unbounded::<ImageLoadResult>();
 9955|       |        renderer.image_result_rx = result_rx;
 9956|       |        renderer
 9957|       |            .image_pending
 9958|       |            .borrow_mut()
 9959|       |            .insert("failed.png".to_string());
 9960|       |
 9961|       |        result_tx
 9962|       |            .send(ImageLoadResult::Failed {
 9963|       |                key: "failed.png".to_string(),
 9964|       |            })
 9965|       |            .expect("send");
 9966|       |        let ctx = egui::Context::default();
 9967|       |        renderer.poll_image_results(&ctx);
 9968|       |        assert!(renderer.image_failures.borrow().contains_key("failed.png"));
 9969|       |        assert!(!renderer.image_pending.borrow().contains("failed.png"));
 9970|       |    }
 9971|       |
 9972|       |    #[test]
 9973|       |    fn test_enqueue_image_job_full_returns_err() {
 9974|       |        let mut renderer = MarkdownRenderer::new();
 9975|       |        let (job_tx, job_rx) = bounded(1);
 9976|       |        renderer.image_job_tx = job_tx;
 9977|       |        let request = ImageLoadRequest {
 9978|       |            key: "full".to_string(),
 9979|       |            source: ImageLoadSource::Embedded(b"png"),
 9980|       |        };
 9981|       |        renderer.image_job_tx.send(request).expect("fill queue");
 9982|       |        let request = ImageLoadRequest {
 9983|       |            key: "full-2".to_string(),
 9984|       |            source: ImageLoadSource::Embedded(b"png"),
 9985|       |        };
 9986|       |        assert!(renderer.enqueue_image_job(request).is_err());
 9987|       |        drop(job_rx);
 9988|       |    }
 9989|       |
 9990|       |    #[test]
 9991|       |    fn test_wait_for_image_with_limit_returns_none() {
 9992|       |        let renderer = MarkdownRenderer::new();
 9993|       |        let ctx = egui::Context::default();
 9994|       |        let input = egui::RawInput {
 9995|       |            screen_rect: Some(egui::Rect::from_min_size(
 9996|       |                egui::pos2(0.0, 0.0),
 9997|       |                egui::vec2(320.0, 240.0),
 9998|       |            )),
 9999|       |            ..Default::default()
10000|       |        };
10001|       |        run_frame_with_input(&ctx, input, |_, ui| {
10002|       |            let missing = wait_for_image_with_limit(&renderer, &ctx, ui, "missing", 0);
10003|       |            assert!(missing.is_none());
10004|       |        });
10005|       |    }
10006|       |
10007|       |    #[test]
10008|       |    fn test_render_table_tablebuilder_policy_mix() {
10009|       |        let renderer = MarkdownRenderer::new();
10010|       |        let headers = vec![
10011|       |            vec![InlineSpan::Text("Version".to_string())],
10012|       |            vec![InlineSpan::Text("Author".to_string())],
10013|       |            vec![InlineSpan::Text("Notes".to_string())],
10014|       |            vec![InlineSpan::Text("Example".to_string())],
10015|       |            vec![InlineSpan::Text("Misc".to_string())],
10016|       |        ];
10017|       |        let rows = vec![vec![
10018|       |            vec![InlineSpan::Text("1".to_string())],
10019|       |            vec![InlineSpan::Text("Ada".to_string())],
10020|       |            vec![InlineSpan::Text("Line 1\nLine 2".to_string())],
10021|       |            vec![InlineSpan::Image {
10022|       |                src: "image.png".to_string(),
10023|       |                alt: "Alt".to_string(),
10024|       |                title: Some("Title".to_string()),
10025|       |            }],
10026|       |            vec![InlineSpan::Link {
10027|       |                text: "Link".to_string(),
10028|       |                url: "https://example.com".to_string(),
10029|       |            }],
10030|       |        ]];
10031|       |
10032|       |        let ctx = egui::Context::default();
10033|       |        let input = egui::RawInput {
10034|       |            screen_rect: Some(egui::Rect::from_min_size(
10035|       |                egui::pos2(0.0, 0.0),
10036|       |                egui::vec2(1200.0, 720.0),
10037|       |            )),
10038|       |            ..Default::default()
10039|       |        };
10040|       |        run_frame_with_input(&ctx, input, |ctx, ui| {
10041|       |            let tex = ctx.load_texture(
10042|       |                "table-image",
10043|       |                egui::ColorImage::new([2, 2], Color32::WHITE),
10044|       |                egui::TextureOptions::LINEAR,
10045|       |            );
10046|       |            renderer.image_textures.borrow_mut().insert(
10047|       |                "image.png".to_string(),
10048|       |                ImageCacheEntry {
10049|       |                    texture: tex,
10050|       |                    size: [120, 80],
10051|       |                    modified: None,
10052|       |                },
10053|       |            );
10054|       |            let table_id = renderer.compute_table_id(&headers, &rows, &[], 12);
10055|       |            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10056|       |        });
10057|       |        let input = egui::RawInput {
10058|       |            screen_rect: Some(egui::Rect::from_min_size(
10059|       |                egui::pos2(0.0, 0.0),
10060|       |                egui::vec2(1200.0, 720.0),
10061|       |            )),
10062|       |            ..Default::default()
10063|       |        };
10064|       |        run_frame_with_input(&ctx, input, |_, ui| {
10065|       |            let table_id = renderer.compute_table_id(&headers, &rows, &[], 12);
10066|       |            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10067|       |        });
10068|       |    }
10069|       |
10070|       |    #[test]
10071|       |    fn test_render_table_tablebuilder_extra_columns() {
10072|       |        let renderer = MarkdownRenderer::new();
10073|       |        let headers = vec![vec![InlineSpan::Text("H1".to_string())]];
10074|       |        let rows = vec![vec![
10075|       |            vec![InlineSpan::Text("C1".to_string())],
10076|       |            vec![InlineSpan::Text("C2".to_string())],
10077|       |            vec![InlineSpan::Text("C3".to_string())],
10078|       |        ]];
10079|       |        with_test_ui(|_, ui| {
10080|       |            let table_id = renderer.compute_table_id(&headers, &rows, &[], 13);
10081|       |            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10082|       |        });
10083|       |    }
10084|       |
10085|       |    #[test]
10086|       |    fn test_render_table_tablebuilder_forced_policies() {
10087|       |        let renderer = MarkdownRenderer::new();
10088|       |        let _forced = ForcedTablePolicies::new(vec![
10089|       |            ColumnPolicy::Auto,
10090|       |            ColumnPolicy::Fixed {
10091|       |                width: 120.0,
10092|       |                clip: true,
10093|       |            },
10094|       |            ColumnPolicy::Resizable {
10095|       |                min: 60.0,
10096|       |                preferred: 120.0,
10097|       |                clip: true,
10098|       |            },
10099|       |            ColumnPolicy::Remainder { clip: true },
10100|       |        ]);
10101|       |        let headers = vec![
10102|       |            vec![InlineSpan::Text("A".to_string())],
10103|       |            vec![InlineSpan::Text("B".to_string())],
10104|       |            vec![InlineSpan::Text("C".to_string())],
10105|       |            vec![InlineSpan::Text("D".to_string())],
10106|       |        ];
10107|       |        let rows = vec![vec![
10108|       |            vec![InlineSpan::Text("1".to_string())],
10109|       |            vec![InlineSpan::Text("2".to_string())],
10110|       |            vec![InlineSpan::Text("3".to_string())],
10111|       |            vec![InlineSpan::Text("4".to_string())],
10112|       |        ]];
10113|       |        with_test_ui(|_, ui| {
10114|       |            let table_id = renderer.compute_table_id(&headers, &rows, &[], 14);
10115|       |            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10116|       |        });
10117|       |    }
10118|       |
10119|       |    #[test]
10120|       |    fn test_render_table_tablebuilder_fixed_columns_no_clip() {
10121|       |        let renderer = MarkdownRenderer::new();
10122|       |        let _forced = ForcedTablePolicies::new(vec![
10123|       |            ColumnPolicy::Fixed {
10124|       |                width: 80.0,
10125|       |                clip: false,
10126|       |            },
10127|       |            ColumnPolicy::Fixed {
10128|       |                width: 100.0,
10129|       |                clip: false,
10130|       |            },
10131|       |        ]);
10132|       |        let headers = vec![
10133|       |            vec![InlineSpan::Text("Left".to_string())],
10134|       |            vec![InlineSpan::Text("Right".to_string())],
10135|       |        ];
10136|       |        let rows = vec![vec![
10137|       |            vec![InlineSpan::Text("A".to_string())],
10138|       |            vec![InlineSpan::Text("B".to_string())],
10139|       |        ]];
10140|       |        with_test_ui(|_, ui| {
10141|       |            let layout = *ui.layout();
10142|       |            ui.allocate_ui_with_layout(Vec2::new(400.0, 0.0), layout, |ui| {
10143|       |                ui.spacing_mut().item_spacing.x = 6.0;
10144|       |                ui.set_width(400.0);
10145|       |                let table_id = renderer.compute_table_id(&headers, &rows, &[], 16);
10146|       |                renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10147|       |            });
10148|       |        });
10149|       |    }
10150|       |
10151|       |    #[test]
10152|       |    fn test_render_table_tablebuilder_scaled_down_min_flex_forced() {
10153|       |        let renderer = MarkdownRenderer::new();
10154|       |        let _forced = ForcedTablePolicies::new(vec![
10155|       |            ColumnPolicy::Resizable {
10156|       |                min: 50.0,
10157|       |                preferred: 120.0,
10158|       |                clip: false,
10159|       |            },
10160|       |            ColumnPolicy::Resizable {
10161|       |                min: 50.0,
10162|       |                preferred: 120.0,
10163|       |                clip: false,
10164|       |            },
10165|       |        ]);
10166|       |        let headers = vec![
10167|       |            vec![InlineSpan::Text("A".to_string())],
10168|       |            vec![InlineSpan::Text("B".to_string())],
10169|       |        ];
10170|       |        let rows = vec![vec![
10171|       |            vec![InlineSpan::Text("One".to_string())],
10172|       |            vec![InlineSpan::Text("Two".to_string())],
10173|       |        ]];
10174|       |        with_test_ui(|_, ui| {
10175|       |            let layout = *ui.layout();
10176|       |            ui.allocate_ui_with_layout(Vec2::new(106.0, 0.0), layout, |ui| {
10177|       |                ui.spacing_mut().item_spacing.x = 6.0;
10178|       |                ui.set_width(106.0);
10179|       |                let table_id = renderer.compute_table_id(&headers, &rows, &[], 17);
10180|       |                renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10181|       |            });
10182|       |        });
10183|       |    }
10184|       |
10185|       |    #[test]
10186|       |    fn test_render_table_tablebuilder_scaled_down_min_flex() {
10187|       |        let renderer = MarkdownRenderer::new();
10188|       |        let headers = vec![
10189|       |            vec![InlineSpan::Text("Notes".to_string())],
10190|       |            vec![InlineSpan::Text("Summary".to_string())],
10191|       |            vec![InlineSpan::Text("Details".to_string())],
10192|       |        ];
10193|       |        let rows = vec![vec![
10194|       |            vec![InlineSpan::Text("Long text 1".to_string())],
10195|       |            vec![InlineSpan::Text("Long text 2".to_string())],
10196|       |            vec![InlineSpan::Text("Long text 3".to_string())],
10197|       |        ]];
10198|       |        let ctx = egui::Context::default();
10199|       |        let input = egui::RawInput {
10200|       |            screen_rect: Some(egui::Rect::from_min_size(
10201|       |                egui::pos2(0.0, 0.0),
10202|       |                egui::vec2(120.0, 120.0),
10203|       |            )),
10204|       |            ..Default::default()
10205|       |        };
10206|       |        run_frame_with_input(&ctx, input, |_, ui| {
10207|       |            let table_id = renderer.compute_table_id(&headers, &rows, &[], 15);
10208|       |            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10209|       |        });
10210|       |    }
10211|       |
10212|       |    #[test]
10213|       |    fn test_render_list_variants() {
10214|       |        let renderer = MarkdownRenderer::new();
10215|       |        let items = vec![
10216|       |            ListItem {
10217|       |                blocks: vec![
10218|       |                    MarkdownElement::Paragraph(vec![InlineSpan::Text("Paragraph".to_string())]),
10219|       |                    MarkdownElement::Header {
10220|       |                        level: 2,
10221|       |                        spans: vec![InlineSpan::Text("Header".to_string())],
10222|       |                        id: "header".to_string(),
10223|       |                    },
10224|       |                ],
10225|       |            },
10226|       |            ListItem {
10227|       |                blocks: vec![
10228|       |                    MarkdownElement::CodeBlock {
10229|       |                        language: None,
10230|       |                        text: "code".to_string(),
10231|       |                    },
10232|       |                    MarkdownElement::Paragraph(vec![InlineSpan::Text("After".to_string())]),
10233|       |                ],
10234|       |            },
10235|       |            ListItem { blocks: vec![] },
10236|       |        ];
10237|       |        with_test_ui(|_, ui| {
10238|       |            renderer.render_list(ui, false, &items);
10239|       |            renderer.render_list(ui, true, &items);
10240|       |            renderer.render_list(ui, false, &[]);
10241|       |        });
10242|       |    }
10243|       |
10244|       |    #[test]
10245|       |    fn test_render_element_body_header_levels() {
10246|       |        let renderer = MarkdownRenderer::new();
10247|       |        with_test_ui(|_, ui| {
10248|       |            for level in 3..=7 {
10249|       |                let element = MarkdownElement::Header {
10250|       |                    level,
10251|       |                    spans: vec![InlineSpan::Text(format!("H{}", level))],
10252|       |                    id: format!("h{}", level),
10253|       |                };
10254|       |                renderer.render_element_body(ui, &element);
10255|       |            }
10256|       |        });
10257|       |    }
10258|       |
10259|       |    #[test]
10260|       |    fn test_render_table_tablebuilder_hscroll() {
10261|       |        let renderer = MarkdownRenderer::new();
10262|       |        let headers: Vec<Vec<InlineSpan>> = (0..8)
10263|       |            .map(|i| vec![InlineSpan::Text(format!("H{}", i + 1))])
10264|       |            .collect();
10265|       |        let row: Vec<Vec<InlineSpan>> = (0..8)
10266|       |            .map(|i| vec![InlineSpan::Text(format!("col{}", i + 1))])
10267|       |            .collect();
10268|       |        let rows = vec![row];
10269|       |        let ctx = egui::Context::default();
10270|       |        let input = egui::RawInput {
10271|       |            screen_rect: Some(egui::Rect::from_min_size(
10272|       |                egui::pos2(0.0, 0.0),
10273|       |                egui::vec2(200.0, 120.0),
10274|       |            )),
10275|       |            ..Default::default()
10276|       |        };
10277|       |        run_frame_with_input(&ctx, input, |_, ui| {
10278|       |            let table_id = renderer.compute_table_id(&headers, &rows, &[], 10);
10279|       |            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10280|       |        });
10281|       |    }
10282|       |
10283|       |    #[test]
10284|       |    fn test_render_table_tablebuilder_tiny_width_hscroll() {
10285|       |        let renderer = MarkdownRenderer::new();
10286|       |        let headers = vec![
10287|       |            vec![InlineSpan::Text("A".to_string())],
10288|       |            vec![InlineSpan::Text("B".to_string())],
10289|       |        ];
10290|       |        let rows = vec![vec![
10291|       |            vec![InlineSpan::Text("1".to_string())],
10292|       |            vec![InlineSpan::Text("2".to_string())],
10293|       |        ]];
10294|       |        with_test_ui(|_, ui| {
10295|       |            let layout = *ui.layout();
10296|       |            ui.allocate_ui_with_layout(Vec2::new(5.0, 0.0), layout, |ui| {
10297|       |                ui.spacing_mut().item_spacing.x = 6.0;
10298|       |                ui.set_width(5.0);
10299|       |                let table_id = renderer.compute_table_id(&headers, &rows, &[], 18);
10300|       |                renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10301|       |            });
10302|       |        });
10303|       |    }
10304|       |
10305|       |    #[test]
10306|       |    fn test_render_table_tablebuilder_scaled_down() {
10307|       |        let renderer = MarkdownRenderer::new();
10308|       |        let headers = vec![
10309|       |            vec![InlineSpan::Text("Wide Header One".to_string())],
10310|       |            vec![InlineSpan::Text("Wide Header Two".to_string())],
10311|       |        ];
10312|       |        let long_text = "W".repeat(80);
10313|       |        let rows = vec![vec![
10314|       |            vec![InlineSpan::Text(long_text.clone())],
10315|       |            vec![InlineSpan::Text(long_text)],
10316|       |        ]];
10317|       |        let ctx = egui::Context::default();
10318|       |        let input = egui::RawInput {
10319|       |            screen_rect: Some(egui::Rect::from_min_size(
10320|       |                egui::pos2(0.0, 0.0),
10321|       |                egui::vec2(180.0, 120.0),
10322|       |            )),
10323|       |            ..Default::default()
10324|       |        };
10325|       |        run_frame_with_input(&ctx, input, |_, ui| {
10326|       |            let table_id = renderer.compute_table_id(&headers, &rows, &[], 11);
10327|       |            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10328|       |        });
10329|       |    }
10330|       |
10331|       |    #[test]
10332|       |    fn test_list_marker_info_any_indent_variants() {
10333|       |        assert!(MarkdownRenderer::list_marker_info_any_indent("").is_none());
10334|       |        assert!(MarkdownRenderer::list_marker_info_any_indent("   ").is_none());
10335|       |
10336|       |        let (rest, indent, content_indent, leading_cols) =
10337|       |            MarkdownRenderer::list_marker_info_any_indent(" 1. item").expect("marker");
10338|       |        assert_eq!(rest, "item");
10339|       |        assert_eq!(indent, 1);
10340|       |        assert_eq!(content_indent, 4);
10341|       |        assert_eq!(leading_cols, 1);
10342|       |
10343|       |        let (rest, indent, content_indent, leading_cols) =
10344|       |            MarkdownRenderer::list_marker_info_any_indent("2)\titem").expect("marker");
10345|       |        assert_eq!(rest, "item");
10346|       |        assert_eq!(indent, 2);
10347|       |        assert_eq!(content_indent, 4);
10348|       |        assert_eq!(leading_cols, 0);
10349|       |    }
10350|       |
10351|       |    #[test]
10352|       |    fn test_list_marker_info_any_indent_requires_trailing_space() {
10353|       |        assert!(MarkdownRenderer::list_marker_info_any_indent("-").is_none());
10354|       |        assert!(MarkdownRenderer::list_marker_info_any_indent("   -").is_none());
10355|       |    }
10356|       |
10357|       |    #[test]
10358|       |    fn test_list_marker_info_any_indent_rejects_missing_whitespace() {
10359|       |        assert!(MarkdownRenderer::list_marker_info_any_indent("1.item").is_none());
10360|       |        assert!(MarkdownRenderer::list_marker_info_any_indent("1)item").is_none());
10361|       |        assert!(MarkdownRenderer::list_marker_info_any_indent("1item").is_none());
10362|       |    }
10363|       |
10364|       |    #[test]
10365|       |    fn test_collect_until_tag_end_breaks_and_code() {
10366|       |        let renderer = MarkdownRenderer::new();
10367|       |        let events = vec![
10368|       |            Event::Start(Tag::Emphasis),
10369|       |            Event::Text("alpha".into()),
10370|       |            Event::Code("beta".into()),
10371|       |            Event::SoftBreak,
10372|       |            Event::Html("<br>".into()),
10373|       |            Event::HardBreak,
10374|       |            Event::Html("<span>".into()),
10375|       |            Event::End(Tag::Emphasis),
10376|       |        ];
10377|       |        let (text, next) = renderer.collect_until_tag_end(&events, 1, Tag::Emphasis, true);
10378|       |        assert_eq!(next, events.len());
10379|       |        assert_eq!(text, "alphabeta\n\n\n");
10380|       |
10381|       |        let (text, next) = renderer.collect_until_tag_end(&events, 1, Tag::Emphasis, false);
10382|       |        assert_eq!(next, events.len());
10383|       |        assert_eq!(text, "alphabeta   ");
10384|       |
10385|       |        let unclosed = vec![Event::Text("tail".into()), Event::SoftBreak];
10386|       |        let (text, next) = renderer.collect_until_tag_end(&unclosed, 0, Tag::Emphasis, true);
10387|       |        assert_eq!(next, unclosed.len());
10388|       |        assert_eq!(text, "tail\n");
10389|       |    }
10390|       |
10391|       |    #[test]
10392|       |    fn test_parse_inline_spans_with_breaks_link_image_and_unclosed() {
10393|       |        let renderer = MarkdownRenderer::new();
10394|       |        let events = vec![
10395|       |            Event::Start(Tag::Paragraph),
10396|       |            Event::Start(Tag::Link(
10397|       |                LinkType::Inline,
10398|       |                "https://example.com".into(),
10399|       |                "".into(),
10400|       |            )),
10401|       |            Event::Text("link".into()),
10402|       |            Event::End(Tag::Link(
10403|       |                LinkType::Inline,
10404|       |                "https://example.com".into(),
10405|       |                "".into(),
10406|       |            )),
10407|       |            Event::Start(Tag::Image(
10408|       |                LinkType::Inline,
10409|       |                "img.png".into(),
10410|       |                "Title".into(),
10411|       |            )),
10412|       |            Event::Text("alt".into()),
10413|       |            Event::End(Tag::Image(
10414|       |                LinkType::Inline,
10415|       |                "img.png".into(),
10416|       |                "Title".into(),
10417|       |            )),
10418|       |            Event::FootnoteReference("note".into()),
10419|       |            Event::End(Tag::Paragraph),
10420|       |        ];
10421|       |        let (spans, next) =
10422|       |            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true);
10423|       |        assert_eq!(next, events.len());
10424|       |        assert!(spans
10425|       |            .iter()
10426|       |            .any(|span| matches!(span, InlineSpan::Link { .. })));
10427|       |        assert!(spans
10428|       |            .iter()
10429|       |            .any(|span| matches!(span, InlineSpan::Image { .. })));
10430|       |
10431|       |        let unclosed = vec![Event::Text("tail".into())];
10432|       |        let (spans, next) =
10433|       |            renderer.parse_inline_spans_with_breaks(&unclosed, 0, Tag::Paragraph, true);
10434|       |        assert_eq!(next, unclosed.len());
10435|       |        assert_eq!(MarkdownRenderer::spans_plain_text(&spans), "tail");
10436|       |    }
10437|       |
10438|       |    #[test]
10439|       |    fn test_parse_inline_spans_with_breaks_mismatched_end_tag() {
10440|       |        let renderer = MarkdownRenderer::new();
10441|       |        let events = vec![
10442|       |            Event::Text("hello".into()),
10443|       |            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H1, None, vec![])),
10444|       |        ];
10445|       |        let (spans, next) =
10446|       |            renderer.parse_inline_spans_with_breaks(&events, 0, Tag::Paragraph, true);
10447|       |        assert_eq!(next, events.len());
10448|       |        assert_eq!(MarkdownRenderer::spans_plain_text(&spans), "hello");
10449|       |    }
10450|       |
10451|       |    #[test]
10452|       |    fn test_parse_inline_spans_unclosed_image_only() {
10453|       |        let renderer = MarkdownRenderer::new();
10454|       |        let events = vec![
10455|       |            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10456|       |            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10457|       |        ];
10458|       |        let (spans, next) =
10459|       |            renderer.parse_inline_spans_with_breaks(&events, 0, Tag::Paragraph, true);
10460|       |        assert_eq!(next, events.len());
10461|       |        assert!(spans
10462|       |            .iter()
10463|       |            .any(|span| matches!(span, InlineSpan::Image { .. })));
10464|       |    }
10465|       |
10466|       |    #[test]
10467|       |    fn test_parse_inline_spans_image_only_skips_text_buffer() {
10468|       |        let renderer = MarkdownRenderer::new();
10469|       |        let events = vec![
10470|       |            Event::Start(Tag::Paragraph),
10471|       |            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10472|       |            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10473|       |            Event::End(Tag::Paragraph),
10474|       |        ];
10475|       |        let (spans, next) =
10476|       |            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true);
10477|       |        assert_eq!(next, events.len());
10478|       |        assert_eq!(spans.len(), 1);
10479|       |        assert!(matches!(
10480|       |            spans[0],
10481|       |            InlineSpan::Image { ref alt, .. } if alt.is_empty()
10482|       |        ));
10483|       |    }
10484|       |
10485|       |    #[test]
10486|       |    fn test_parse_list_inline_variants_unclosed() -> Result<()> {
10487|       |        let renderer = MarkdownRenderer::new();
10488|       |        let events = vec![
10489|       |            Event::Start(Tag::List(Some(1))),
10490|       |            Event::Text("skip".into()),
10491|       |            Event::Start(Tag::Item),
10492|       |            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10493|       |            Event::Text("Dup".into()),
10494|       |            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10495|       |            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10496|       |            Event::Text("Dup".into()),
10497|       |            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10498|       |            Event::Start(Tag::Emphasis),
10499|       |            Event::Text("em".into()),
10500|       |            Event::End(Tag::Emphasis),
10501|       |            Event::Start(Tag::Strong),
10502|       |            Event::Text("strong".into()),
10503|       |            Event::End(Tag::Strong),
10504|       |            Event::Start(Tag::Strikethrough),
10505|       |            Event::Text("strike".into()),
10506|       |            Event::End(Tag::Strikethrough),
10507|       |            Event::Start(Tag::Link(
10508|       |                LinkType::Inline,
10509|       |                "https://example.com".into(),
10510|       |                "".into(),
10511|       |            )),
10512|       |            Event::Text("link".into()),
10513|       |            Event::End(Tag::Link(
10514|       |                LinkType::Inline,
10515|       |                "https://example.com".into(),
10516|       |                "".into(),
10517|       |            )),
10518|       |            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10519|       |            Event::Text("alt".into()),
10520|       |            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10521|       |            Event::Text("tail".into()),
10522|       |            Event::SoftBreak,
10523|       |            Event::FootnoteReference("note".into()),
10524|       |        ];
10525|       |        let mut slugs = HashMap::new();
10526|       |        let (items, next) = renderer.parse_list(&events, 1, &mut slugs);
10527|       |        assert_eq!(next, events.len());
10528|       |        assert_eq!(items.len(), 1);
10529|       |        Ok(())
10530|       |    }
10531|       |
10532|       |    #[test]
10533|       |    fn test_parse_list_empty_paragraph_skips_block() -> Result<()> {
10534|       |        let renderer = MarkdownRenderer::new();
10535|       |        let events = vec![
10536|       |            Event::Start(Tag::List(Some(1))),
10537|       |            Event::Start(Tag::Item),
10538|       |            Event::Start(Tag::Paragraph),
10539|       |            Event::End(Tag::Paragraph),
10540|       |            Event::End(Tag::Item),
10541|       |            Event::End(Tag::List(Some(1))),
10542|       |        ];
10543|       |        let mut slugs = HashMap::new();
10544|       |        let (items, next) = renderer.parse_list(&events, 1, &mut slugs);
10545|       |        assert_eq!(next, events.len());
10546|       |        assert_eq!(items.len(), 1);
10547|       |        assert!(items[0].blocks.is_empty());
10548|       |        Ok(())
10549|       |    }
10550|       |
10551|       |    #[test]
10552|       |    fn test_collect_blockquotes_unclosed_variants() -> Result<()> {
10553|       |        let renderer = MarkdownRenderer::new();
10554|       |        let events = vec![
10555|       |            Event::Start(Tag::BlockQuote),
10556|       |            Event::Text("plain".into()),
10557|       |            Event::Code("code".into()),
10558|       |            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10559|       |            Event::Text("Dup".into()),
10560|       |            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10561|       |            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10562|       |            Event::Text("Dup".into()),
10563|       |            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10564|       |            Event::Start(Tag::Link(
10565|       |                LinkType::Inline,
10566|       |                "https://example.com".into(),
10567|       |                "".into(),
10568|       |            )),
10569|       |            Event::Text("link".into()),
10570|       |            Event::End(Tag::Link(
10571|       |                LinkType::Inline,
10572|       |                "https://example.com".into(),
10573|       |                "".into(),
10574|       |            )),
10575|       |            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10576|       |            Event::Text("alt".into()),
10577|       |            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10578|       |            Event::FootnoteReference("note".into()),
10579|       |        ];
10580|       |        let mut slugs = HashMap::new();
10581|       |        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs);
10582|       |        assert_eq!(next, events.len());
10583|       |        let mut ids = Vec::new();
10584|       |        for (_, blocks) in &quotes {
10585|       |            for block in blocks {
10586|       |                if let MarkdownElement::Header { id, .. } = block {
10587|       |                    ids.push(id.clone());
10588|       |                }
10589|       |            }
10590|       |        }
10591|       |        assert_eq!(ids.len(), 2);
10592|       |        assert_ne!(ids[0], ids[1]);
10593|       |        Ok(())
10594|       |    }
10595|       |
10596|       |    #[test]
10597|       |    fn test_render_inline_span_context_menus() {
10598|       |        let renderer = MarkdownRenderer::new();
10599|       |        let code_span = InlineSpan::Code("inline".to_string());
10600|       |        let ctx = egui::Context::default();
10601|       |        let click = input_with_click(egui::pos2(12.0, 12.0), egui::PointerButton::Secondary);
10602|       |        run_frame_with_input(&ctx, click, |_, ui| {
10603|       |            renderer.render_inline_span(ui, &code_span, None, None);
10604|       |        });
10605|       |        let input = egui::RawInput {
10606|       |            screen_rect: Some(egui::Rect::from_min_size(
10607|       |                egui::pos2(0.0, 0.0),
10608|       |                egui::vec2(320.0, 240.0),
10609|       |            )),
10610|       |            ..Default::default()
10611|       |        };
10612|       |        run_frame_with_input(&ctx, input, |_, ui| {
10613|       |            renderer.render_inline_span(ui, &code_span, None, None);
10614|       |        });
10615|       |
10616|       |        let link_span = InlineSpan::Link {
10617|       |            text: "Link".to_string(),
10618|       |            url: "https://example.com".to_string(),
10619|       |        };
10620|       |        let ctx = egui::Context::default();
10621|       |        let click = input_with_click(egui::pos2(12.0, 12.0), egui::PointerButton::Secondary);
10622|       |        run_frame_with_input(&ctx, click, |_, ui| {
10623|       |            renderer.render_inline_span(ui, &link_span, None, None);
10624|       |        });
10625|       |        let input = egui::RawInput {
10626|       |            screen_rect: Some(egui::Rect::from_min_size(
10627|       |                egui::pos2(0.0, 0.0),
10628|       |                egui::vec2(320.0, 240.0),
10629|       |            )),
10630|       |            ..Default::default()
10631|       |        };
10632|       |        run_frame_with_input(&ctx, input, |_, ui| {
10633|       |            renderer.render_inline_span(ui, &link_span, None, None);
10634|       |        });
10635|       |    }
10636|       |
10637|       |    #[test]
10638|       |    fn test_render_inline_span_image_scale_and_title() {
10639|       |        let renderer = MarkdownRenderer::new();
10640|       |        let ctx = egui::Context::default();
10641|       |        let input = egui::RawInput {
10642|       |            screen_rect: Some(egui::Rect::from_min_size(
10643|       |                egui::pos2(0.0, 0.0),
10644|       |                egui::vec2(40.0, 240.0),
10645|       |            )),
10646|       |            ..Default::default()
10647|       |        };
10648|       |        run_frame_with_input(&ctx, input, |_, ui| {
10649|       |            let color_image = egui::ColorImage::new([200, 120], Color32::WHITE);
10650|       |            let tex =
10651|       |                ui.ctx()
10652|       |                    .load_texture("img:test.png", color_image, egui::TextureOptions::LINEAR);
10653|       |            renderer.image_textures.borrow_mut().insert(
10654|       |                "test.png".to_string(),
10655|       |                ImageCacheEntry {
10656|       |                    texture: tex,
10657|       |                    size: [200, 120],
10658|       |                    modified: None,
10659|       |                },
10660|       |            );
10661|       |            let span = InlineSpan::Image {
10662|       |                src: "test.png".to_string(),
10663|       |                alt: "Alt".to_string(),
10664|       |                title: Some("Title".to_string()),
10665|       |            };
10666|       |            renderer.render_inline_span(ui, &span, None, None);
10667|       |        });
10668|       |    }
10669|       |
10670|       |    #[test]
10671|       |    fn test_paint_table_text_job_triggers_anchor_on_click() {
10672|       |        let renderer = MarkdownRenderer::new();
10673|       |        let spans = vec![InlineSpan::Link {
10674|       |            text: "Jump".to_string(),
10675|       |            url: "#Section-One".to_string(),
10676|       |        }];
10677|       |        let ctx = egui::Context::default();
10678|       |        let click_pos = std::cell::Cell::new(egui::pos2(1.0, 1.0));
10679|       |        let layout_input = egui::RawInput {
10680|       |            screen_rect: Some(egui::Rect::from_min_size(
10681|       |                egui::pos2(0.0, 0.0),
10682|       |                egui::vec2(220.0, 120.0),
10683|       |            )),
10684|       |            ..Default::default()
10685|       |        };
10686|       |        run_frame_with_input(&ctx, layout_input, |_, ui| {
10687|       |            ui.allocate_ui_at_rect(
10688|       |                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
10689|       |                |ui| {
10690|       |                    let build =
10691|       |                        renderer.build_layout_job(ui.style(), &spans, 60.0, false, Align::LEFT);
10692|       |                    let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
10693|       |                    let (rect, _response) = ui.allocate_exact_size(
10694|       |                        egui::vec2(120.0, galley.size().y),
10695|       |                        egui::Sense::click(),
10696|       |                    );
10697|       |                    let text_origin =
10698|       |                        MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
10699|       |                    click_pos.set(text_origin + egui::vec2(2.0, 2.0));
10700|       |                },
10701|       |            );
10702|       |        });
10703|       |
10704|       |        let input = input_with_click(click_pos.get(), egui::PointerButton::Primary);
10705|       |        run_frame_with_input(&ctx, input, |_, ui| {
10706|       |            ui.allocate_ui_at_rect(
10707|       |                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
10708|       |                |ui| {
10709|       |                    let build =
10710|       |                        renderer.build_layout_job(ui.style(), &spans, 60.0, false, Align::LEFT);
10711|       |                    renderer.paint_table_text_job(ui, 120.0, build);
10712|       |                },
10713|       |            );
10714|       |        });
10715|       |
10716|       |        assert_eq!(
10717|       |            renderer.take_pending_anchor(),
10718|       |            Some("section-one".to_string())
10719|       |        );
10720|       |    }
10721|       |
10722|       |    #[test]
10723|       |    fn test_paint_table_text_job_hover_link_does_not_trigger() {
10724|       |        let renderer = MarkdownRenderer::new();
10725|       |        let spans = vec![InlineSpan::Link {
10726|       |            text: "Jump".to_string(),
10727|       |            url: "#Section-One".to_string(),
10728|       |        }];
10729|       |        let ctx = egui::Context::default();
10730|       |        let hover_pos = std::cell::Cell::new(egui::pos2(1.0, 1.0));
10731|       |        let layout_input = egui::RawInput {
10732|       |            screen_rect: Some(egui::Rect::from_min_size(
10733|       |                egui::pos2(0.0, 0.0),
10734|       |                egui::vec2(220.0, 120.0),
10735|       |            )),
10736|       |            ..Default::default()
10737|       |        };
10738|       |        run_frame_with_input(&ctx, layout_input, |_, ui| {
10739|       |            ui.allocate_ui_at_rect(
10740|       |                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
10741|       |                |ui| {
10742|       |                    let build =
10743|       |                        renderer.build_layout_job(ui.style(), &spans, 60.0, false, Align::LEFT);
10744|       |                    let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
10745|       |                    let (rect, _response) = ui.allocate_exact_size(
10746|       |                        egui::vec2(120.0, galley.size().y),
10747|       |                        egui::Sense::click(),
10748|       |                    );
10749|       |                    let text_origin =
10750|       |                        MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
10751|       |                    hover_pos.set(text_origin + egui::vec2(2.0, 2.0));
10752|       |                },
10753|       |            );
10754|       |        });
10755|       |
10756|       |        let mut input = egui::RawInput {
10757|       |            screen_rect: Some(egui::Rect::from_min_size(
10758|       |                egui::pos2(0.0, 0.0),
10759|       |                egui::vec2(220.0, 120.0),
10760|       |            )),
10761|       |            ..Default::default()
10762|       |        };
10763|       |        input
10764|       |            .events
10765|       |            .push(egui::Event::PointerMoved(hover_pos.get()));
10766|       |        run_frame_with_input(&ctx, input, |_, ui| {
10767|       |            ui.allocate_ui_at_rect(
10768|       |                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
10769|       |                |ui| {
10770|       |                    let build =
10771|       |                        renderer.build_layout_job(ui.style(), &spans, 60.0, false, Align::LEFT);
10772|       |                    renderer.paint_table_text_job(ui, 120.0, build);
10773|       |                },
10774|       |            );
10775|       |        });
10776|       |
10777|       |        assert!(renderer.take_pending_anchor().is_none());
10778|       |    }
10779|       |
10780|       |    #[test]
10781|       |    fn test_render_inline_span_image_empty_title() {
10782|       |        let renderer = MarkdownRenderer::new();
10783|       |        let ctx = egui::Context::default();
10784|       |        let input = egui::RawInput {
10785|       |            screen_rect: Some(egui::Rect::from_min_size(
10786|       |                egui::pos2(0.0, 0.0),
10787|       |                egui::vec2(120.0, 120.0),
10788|       |            )),
10789|       |            ..Default::default()
10790|       |        };
10791|       |        run_frame_with_input(&ctx, input, |_, ui| {
10792|       |            let color_image = egui::ColorImage::new([20, 12], Color32::WHITE);
10793|       |            let tex = ui.ctx().load_texture(
10794|       |                "img:empty-title.png",
10795|       |                color_image,
10796|       |                egui::TextureOptions::LINEAR,
10797|       |            );
10798|       |            renderer.image_textures.borrow_mut().insert(
10799|       |                "empty-title.png".to_string(),
10800|       |                ImageCacheEntry {
10801|       |                    texture: tex,
10802|       |                    size: [20, 12],
10803|       |                    modified: None,
10804|       |                },
10805|       |            );
10806|       |            let span = InlineSpan::Image {
10807|       |                src: "empty-title.png".to_string(),
10808|       |                alt: "Alt".to_string(),
10809|       |                title: Some(String::new()),
10810|       |            };
10811|       |            renderer.render_inline_span(ui, &span, None, None);
10812|       |        });
10813|       |    }
10814|       |
10815|       |    #[test]
10816|       |    fn test_measure_inline_spans_empty_lines_and_styles() {
10817|       |        let renderer = MarkdownRenderer::new();
10818|       |        with_test_ui(|_, ui| {
10819|       |            let spans = vec![
10820|       |                InlineSpan::Strong("Bold\n\nLine".to_string()),
10821|       |                InlineSpan::Emphasis("Em\n".to_string()),
10822|       |                InlineSpan::Strikethrough("Strike".to_string()),
10823|       |                InlineSpan::Link {
10824|       |                    text: "Link\n".to_string(),
10825|       |                    url: "https://example.com".to_string(),
10826|       |                },
10827|       |                InlineSpan::Code("code\n\nmore".to_string()),
10828|       |            ];
10829|       |            let width = renderer.measure_inline_spans(ui, &spans);
10830|       |            assert!(width > 0.0);
10831|       |        });
10832|       |    }
10833|       |
10834|       |    #[test]
10835|       |    fn test_estimate_table_cell_height_variants() {
10836|       |        let renderer = MarkdownRenderer::new();
10837|       |        with_test_ui(|_, ui| {
10838|       |            let style = ui.style().clone();
10839|       |            let empty =
10840|       |                renderer.estimate_table_cell_height(&style, ui, &[], 100.0, Align::LEFT, 18.0);
10841|       |            assert_eq!(empty, 18.0);
10842|       |
10843|       |            let emoji_spans = vec![InlineSpan::Text("".to_string())];
10844|       |            let emoji_height = renderer.estimate_table_cell_height(
10845|       |                &style,
10846|       |                ui,
10847|       |                &emoji_spans,
10848|       |                100.0,
10849|       |                Align::LEFT,
10850|       |                18.0,
10851|       |            );
10852|       |            assert!(emoji_height >= 18.0);
10853|       |
10854|       |            let spans = vec![
10855|       |                InlineSpan::Text("alpha".to_string()),
10856|       |                InlineSpan::Image {
10857|       |                    src: "missing.png".to_string(),
10858|       |                    alt: "Alt".to_string(),
10859|       |                    title: None,
10860|       |                },
10861|       |            ];
10862|       |            let height =
10863|       |                renderer.estimate_table_cell_height(&style, ui, &spans, 40.0, Align::LEFT, 18.0);
10864|       |            assert!(height >= 18.0);
10865|       |        });
10866|       |    }
10867|       |
10868|       |    #[test]
10869|       |    fn test_estimate_table_column_widths_scaling() {
10870|       |        let renderer = MarkdownRenderer::new();
10871|       |        let empty = renderer.estimate_table_column_widths(&[], 120.0, 6.0);
10872|       |        assert_eq!(empty, vec![120.0]);
10873|       |
10874|       |        let specs = vec![
10875|       |            ColumnSpec::new(
10876|       |                0,
10877|       |                "A".to_string(),
10878|       |                ColumnPolicy::Fixed {
10879|       |                    width: 100.0,
10880|       |                    clip: false,
10881|       |                },
10882|       |                None,
10883|       |            ),
10884|       |            ColumnSpec::new(
10885|       |                1,
10886|       |                "B".to_string(),
10887|       |                ColumnPolicy::Fixed {
10888|       |                    width: 100.0,
10889|       |                    clip: false,
10890|       |                },
10891|       |                None,
10892|       |            ),
10893|       |        ];
10894|       |        let widths = renderer.estimate_table_column_widths(&specs, 100.0, 10.0);
10895|       |        assert_eq!(widths.len(), 2);
10896|       |        let sum: f32 = widths.iter().sum();
10897|       |        assert!((sum - 90.0).abs() < 0.5);
10898|       |    }
10899|       |
10900|       |    #[test]
10901|       |    fn test_estimate_table_column_widths_no_scale_when_available() {
10902|       |        let renderer = MarkdownRenderer::new();
10903|       |        let specs = vec![
10904|       |            ColumnSpec::new(
10905|       |                0,
10906|       |                "A",
10907|       |                ColumnPolicy::Fixed {
10908|       |                    width: 80.0,
10909|       |                    clip: false,
10910|       |                },
10911|       |                None,
10912|       |            ),
10913|       |            ColumnSpec::new(
10914|       |                1,
10915|       |                "B",
10916|       |                ColumnPolicy::Fixed {
10917|       |                    width: 60.0,
10918|       |                    clip: false,
10919|       |                },
10920|       |                None,
10921|       |            ),
10922|       |        ];
10923|       |        let widths = renderer.estimate_table_column_widths(&specs, 300.0, 10.0);
10924|       |        assert_eq!(widths, vec![80.0, 60.0]);
10925|       |    }
10926|       |
10927|       |    #[test]
10928|       |    fn test_escape_table_pipes_in_inline_code_nested_lists() {
10929|       |        let md_parent = "\
10930|       | - Parent
10931|       |   | Col | Notes |
10932|       |  | --- | --- |
10933|       |  | code | `a|b` |
10934|       |";
10935|       |        let escaped_parent = MarkdownRenderer::escape_table_pipes_in_inline_code(md_parent);
10936|       |        assert!(escaped_parent.contains(PIPE_SENTINEL));
10937|       |
10938|       |        let md_nested = "\
10939|       |- Parent
10940|       |    - | Col | Notes |
10941|       |      | --- | --- |
10942|       |      | code | `a|b` |
10943|       |";
10944|       |        let escaped_nested = MarkdownRenderer::escape_table_pipes_in_inline_code(md_nested);
10945|       |        assert!(escaped_nested.contains(PIPE_SENTINEL));
10946|       |    }
10947|       |
10948|       |    #[test]
10949|       |    fn test_escape_table_pipes_parent_indent_list_marker_header() {
10950|       |        let md = "\
10951|       |- Parent
10952|       |    - | H | I |
10953|       |      | --- | --- |
10954|       |      | 1 | 2 |";
10955|       |        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
10956|       |        assert_eq!(escaped, md);
10957|       |    }
10958|       |
10959|       |    #[test]
10960|       |    fn test_escape_table_pipes_parent_indent_list_marker_any_indent() {
10961|       |        let md = "\
10962|       |- Parent
10963|       |    - | H | I |
10964|       |      | --- | --- |
10965|       |      | `a|b` | c |
10966|       |";
10967|       |        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
10968|       |        assert!(escaped.contains(PIPE_SENTINEL));
10969|       |    }
10970|       |
10971|       |    #[test]
10972|       |    fn test_escape_table_pipes_parent_indent_marker_within_range() {
10973|       |        let md = "\
10974|       |- Parent
10975|       |    - | H | I |
10976|       |      | --- | --- |
10977|       |      | `a|b` | c |
10978|       |";
10979|       |        let lines: Vec<&str> = md.split_inclusive('\n').collect();
10980|       |        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
10981|       |        let _parent_indent =
10982|       |            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
10983|       |        let _leading_spaces =
10984|       |            MarkdownRenderer::list_marker_info_any_indent(rest).map(|(_, _, _, spaces)| spaces);
10985|       |        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
10986|       |        assert!(escaped.contains(PIPE_SENTINEL));
10987|       |    }
10988|       |
10989|       |    #[test]
10990|       |    fn test_escape_table_pipes_parent_indent_strip_without_code_indent() {
10991|       |        let md = "\
10992|       |- Parent
10993|       |  continuation
10994|       |  | H | I |
10995|       |  | --- | --- |
10996|       |  | `a|b` | c |
10997|       |";
10998|       |        let lines: Vec<&str> = md.split_inclusive('\n').collect();
10999|       |        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
11000|       |        let parent_indent =
11001|       |            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
11002|       |        let strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent);
11003|       |        let code_strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent + 4);
11004|       |        assert!(strip.is_some());
11005|       |        assert!(code_strip.is_none());
11006|       |        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11007|       |        assert!(escaped.contains(PIPE_SENTINEL));
11008|       |    }
11009|       |
11010|       |    #[test]
11011|       |    fn test_escape_table_pipes_parent_indent_strips_non_code_row() {
11012|       |        let md = "\
11013|       |- Parent
11014|       |  | H | I |
11015|       |  | --- | --- |
11016|       |  | 1 | 2 |";
11017|       |        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11018|       |        assert!(escaped.contains("| H | I |"));
11019|       |        assert!(escaped.contains("| --- | --- |"));
11020|       |    }
11021|       |
11022|       |    #[test]
11023|       |    fn test_escape_table_pipes_parent_indent_out_of_range() {
11024|       |        let md = "\
11025|       |- Parent
11026|       |        - Child
11027|       |        continuation
11028|       |";
11029|       |        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11030|       |        assert_eq!(escaped, md);
11031|       |    }
11032|       |
11033|       |    #[test]
11034|       |    fn test_escape_table_pipes_parent_indent_marker_outside_range() {
11035|       |        let md = "\
11036|       |- Parent
11037|       |      - Child
11038|       |      continuation
11039|       |";
11040|       |        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11041|       |        assert_eq!(escaped, md);
11042|       |    }
11043|       |
11044|       |    #[test]
11045|       |    fn test_escape_table_pipes_parent_indent_marker_too_deep() {
11046|       |        let md = "\
11047|       |- Parent
11048|       |      - Child
11049|       |      | H | I |
11050|       |      | --- | --- |
11051|       |      | `a|b` | c |
11052|       |";
11053|       |        let lines: Vec<&str> = md.split_inclusive('\n').collect();
11054|       |        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
11055|       |        let _parent_indent =
11056|       |            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
11057|       |        let _leading_spaces =
11058|       |            MarkdownRenderer::list_marker_info_any_indent(rest).map(|(_, _, _, spaces)| spaces);
11059|       |        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11060|       |        assert_eq!(escaped, md);
11061|       |    }
11062|       |
11063|       |    #[test]
11064|       |    fn test_escape_table_pipes_parent_indent_code_strip_present() {
11065|       |        let md = "\
11066|       | - Parent
11067|       |      continuation
11068|       |      | H | I |
11069|       |      | --- | --- |
11070|       |      | `a|b` | c |
11071|       |";
11072|       |        let lines: Vec<&str> = md.split_inclusive('\n').collect();
11073|       |        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
11074|       |        let parent_indent =
11075|       |            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
11076|       |        let strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent);
11077|       |        let code_strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent + 4);
11078|       |        assert!(strip.is_some());
11079|       |        assert!(code_strip.is_some());
11080|       |        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11081|       |        assert_eq!(escaped, md);
11082|       |    }
11083|       |
11084|       |    #[test]
11085|       |    fn test_escape_table_pipes_parent_indent_strip_only() {
11086|       |        let md = "\
11087|       |- Parent
11088|       |  | H | I |
11089|       |  | --- | --- |
11090|       |  | `a|b` | c |
11091|       |";
11092|       |        let lines: Vec<&str> = md.split_inclusive('\n').collect();
11093|       |        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
11094|       |        let parent_indent =
11095|       |            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
11096|       |        let strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent);
11097|       |        let code_strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent + 4);
11098|       |        assert!(strip.is_some());
11099|       |        assert!(code_strip.is_none());
11100|       |        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11101|       |        assert!(escaped.contains(PIPE_SENTINEL));
11102|       |    }
11103|       |
11104|       |    #[test]
11105|       |    fn test_escape_table_pipes_parent_indent_marker_in_range_any_indent() {
11106|       |        let md = "\
11107|       |  - Parent
11108|       |     - | H | I |
11109|       |        | --- | --- |
11110|       |       | `a|b` | c |
11111|       |";
11112|       |        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11113|       |        assert!(escaped.contains(PIPE_SENTINEL));
11114|       |    }
11115|       |
11116|       |    #[test]
11117|       |    fn test_escape_table_pipes_parent_indent_deep_list_marker_table_like_lines() {
11118|       |        let md = "\
11119|       |- Parent
11120|       |        - | H | I |
11121|       |        | --- | --- |
11122|       |        | `a|b` | c |
11123|       |";
11124|       |        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11125|       |        assert_eq!(escaped, md);
11126|       |    }
11127|       |
11128|       |    #[test]
11129|       |    fn test_parse_table_unclosed_and_noise() -> Result<()> {
11130|       |        let renderer = MarkdownRenderer::new();
11131|       |        let events = vec![
11132|       |            Event::Start(Tag::Table(vec![Alignment::Left])),
11133|       |            Event::Start(Tag::TableHead),
11134|       |            Event::Start(Tag::TableRow),
11135|       |            Event::Start(Tag::TableCell),
11136|       |            Event::Text("H".into()),
11137|       |            Event::End(Tag::TableCell),
11138|       |            Event::End(Tag::TableRow),
11139|       |            Event::End(Tag::TableHead),
11140|       |            Event::Start(Tag::TableRow),
11141|       |            Event::Text("noise".into()),
11142|       |            Event::Start(Tag::TableCell),
11143|       |            Event::Text("R".into()),
11144|       |            Event::End(Tag::TableCell),
11145|       |            Event::End(Tag::TableRow),
11146|       |            Event::Text("after".into()),
11147|       |        ];
11148|       |        let (headers, rows, next) = renderer.parse_table(&events, 1);
11149|       |        assert_eq!(headers.len(), 1);
11150|       |        assert_eq!(rows.len(), 1);
11151|       |        assert_eq!(next, events.len());
11152|       |        Ok(())
11153|       |    }
11154|       |
11155|       |    #[test]
11156|       |    fn test_parse_table_unclosed_head_exits_on_eof() -> Result<()> {
11157|       |        let renderer = MarkdownRenderer::new();
11158|       |        let events = vec![
11159|       |            Event::Start(Tag::Table(vec![Alignment::Left])),
11160|       |            Event::Start(Tag::TableHead),
11161|       |            Event::Start(Tag::TableCell),
11162|       |            Event::Text("H".into()),
11163|       |            Event::End(Tag::TableCell),
11164|       |        ];
11165|       |        let (headers, rows, next) = renderer.parse_table(&events, 1);
11166|       |        assert_eq!(headers.len(), 1);
11167|       |        assert!(rows.is_empty());
11168|       |        assert_eq!(next, events.len());
11169|       |        Ok(())
11170|       |    }
11171|       |
11172|       |    #[test]
11173|       |    fn test_parse_table_unclosed_row_exits_on_eof() -> Result<()> {
11174|       |        let renderer = MarkdownRenderer::new();
11175|       |        let events = vec![
11176|       |            Event::Start(Tag::Table(vec![Alignment::Left])),
11177|       |            Event::Start(Tag::TableRow),
11178|       |            Event::Start(Tag::TableCell),
11179|       |            Event::Text("R".into()),
11180|       |            Event::End(Tag::TableCell),
11181|       |        ];
11182|       |        let (headers, rows, next) = renderer.parse_table(&events, 1);
11183|       |        assert!(headers.is_empty());
11184|       |        assert!(rows.is_empty());
11185|       |        assert_eq!(next, events.len());
11186|       |        Ok(())
11187|       |    }
11188|       |
11189|       |    #[test]
11190|       |    fn test_parse_table_head_skips_noise() -> Result<()> {
11191|       |        let renderer = MarkdownRenderer::new();
11192|       |        let alignments = vec![Alignment::Left];
11193|       |        let events = vec![
11194|       |            Event::Start(Tag::Table(alignments.clone())),
11195|       |            Event::Start(Tag::TableHead),
11196|       |            Event::Text("noise".into()),
11197|       |            Event::Start(Tag::TableCell),
11198|       |            Event::Text("H".into()),
11199|       |            Event::End(Tag::TableCell),
11200|       |            Event::End(Tag::TableHead),
11201|       |            Event::End(Tag::Table(alignments)),
11202|       |        ];
11203|       |        let (headers, rows, next) = renderer.parse_table(&events, 1);
11204|       |        assert_eq!(headers.len(), 1);
11205|       |        assert!(rows.is_empty());
11206|       |        assert_eq!(next, events.len());
11207|       |        Ok(())
11208|       |    }
11209|       |
11210|       |    #[test]
11211|       |    fn test_parse_table_empty_row_skips_row() -> Result<()> {
11212|       |        let renderer = MarkdownRenderer::new();
11213|       |        let alignments = vec![Alignment::Left];
11214|       |        let events = vec![
11215|       |            Event::Start(Tag::Table(alignments.clone())),
11216|       |            Event::Start(Tag::TableRow),
11217|       |            Event::End(Tag::TableRow),
11218|       |            Event::End(Tag::Table(alignments)),
11219|       |        ];
11220|       |        let (headers, rows, next) = renderer.parse_table(&events, 1);
11221|       |        assert!(headers.is_empty());
11222|       |        assert!(rows.is_empty());
11223|       |        assert_eq!(next, events.len());
11224|       |        Ok(())
11225|       |    }
11226|       |
11227|       |    #[test]
11228|       |    fn test_parse_code_block_unclosed() -> Result<()> {
11229|       |        let renderer = MarkdownRenderer::new();
11230|       |        let events = vec![
11231|       |            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
11232|       |                "rust".into(),
11233|       |            ))),
11234|       |            Event::Text("fn main() {}".into()),
11235|       |            Event::Html("<span>".into()),
11236|       |        ];
11237|       |        let (code, language, next) = renderer.parse_code_block(&events, 0);
11238|       |        assert_eq!(language.as_deref(), Some("rust"));
11239|       |        assert_eq!(code, "fn main() {}");
11240|       |        assert_eq!(next, events.len());
11241|       |        Ok(())
11242|       |    }
11243|       |
11244|       |    #[test]
11245|       |    fn test_parse_code_block_without_start_tag() -> Result<()> {
11246|       |        let renderer = MarkdownRenderer::new();
11247|       |        let events = vec![
11248|       |            Event::Text("fn main() {}".into()),
11249|       |            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Indented)),
11250|       |        ];
11251|       |        let (code, language, next) = renderer.parse_code_block(&events, 0);
11252|       |        assert_eq!(language, None);
11253|       |        assert_eq!(code, "fn main() {}");
11254|       |        assert_eq!(next, events.len());
11255|       |        Ok(())
11256|       |    }
11257|       |
11258|       |    #[test]
11259|       |    fn test_has_pipe_outside_inline_code_backticks() {
11260|       |        assert!(MarkdownRenderer::has_pipe_outside_inline_code(r"\`|`"));
11261|       |        assert!(!MarkdownRenderer::has_pipe_outside_inline_code("``a|b``"));
11262|       |    }
11263|       |
11264|       |    #[test]
11265|       |    fn test_row_needs_height_estimate_variants() {
11266|       |        let renderer = MarkdownRenderer::new();
11267|       |        let row_with_image = vec![vec![InlineSpan::Image {
11268|       |            src: "missing.png".to_string(),
11269|       |            alt: "Alt".to_string(),
11270|       |            title: None,
11271|       |        }]];
11272|       |        assert!(renderer.row_needs_height_estimate(&row_with_image));
11273|       |
11274|       |        let row_with_newline = vec![vec![InlineSpan::Text("line1\nline2".to_string())]];
11275|       |        assert!(renderer.row_needs_height_estimate(&row_with_newline));
11276|       |
11277|       |        let row_plain = vec![vec![InlineSpan::Text("plain".to_string())]];
11278|       |        assert!(!renderer.row_needs_height_estimate(&row_plain));
11279|       |    }
11280|       |
11281|       |    #[test]
11282|       |    fn test_is_allowed_scheme_variants() {
11283|       |        assert!(MarkdownRenderer::is_allowed_scheme("http://example.com"));
11284|       |        assert!(MarkdownRenderer::is_allowed_scheme("https://example.com"));
11285|       |        assert!(MarkdownRenderer::is_allowed_scheme(
11286|       |            "mailto:test@example.com"
11287|       |        ));
11288|       |        assert!(!MarkdownRenderer::is_allowed_scheme("ftp://example.com"));
11289|       |    }
11290|       |
11291|       |    #[test]
11292|       |    fn test_render_table_tablebuilder_scaled_down_adjustments() {
11293|       |        let renderer = MarkdownRenderer::new();
11294|       |        let headers = vec![
11295|       |            vec![InlineSpan::Text("A".to_string())],
11296|       |            vec![InlineSpan::Text("B".to_string())],
11297|       |            vec![InlineSpan::Text("C".to_string())],
11298|       |        ];
11299|       |        let rows = vec![vec![
11300|       |            vec![InlineSpan::Text("row1".to_string())],
11301|       |            vec![InlineSpan::Text("row2".to_string())],
11302|       |            vec![InlineSpan::Text("row3".to_string())],
11303|       |        ]];
11304|       |        let ctx = egui::Context::default();
11305|       |        let widths = [220.0, 240.0];
11306|       |        for (idx, width) in widths.iter().enumerate() {
11307|       |            let _forced = ForcedTablePolicies::new(vec![
11308|       |                ColumnPolicy::Resizable {
11309|       |                    min: 40.0,
11310|       |                    preferred: 200.0,
11311|       |                    clip: false,
11312|       |                },
11313|       |                ColumnPolicy::Auto,
11314|       |                ColumnPolicy::Remainder { clip: false },
11315|       |            ]);
11316|       |            let input = egui::RawInput {
11317|       |                screen_rect: Some(egui::Rect::from_min_size(
11318|       |                    egui::pos2(0.0, 0.0),
11319|       |                    egui::vec2(*width, 120.0),
11320|       |                )),
11321|       |                ..Default::default()
11322|       |            };
11323|       |            run_frame_with_input(&ctx, input, |_, ui| {
11324|       |                ui.spacing_mut().item_spacing.x = 2.0;
11325|       |                let table_id = renderer.compute_table_id(&headers, &rows, &[], 90 + idx as u64);
11326|       |                renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
11327|       |            });
11328|       |        }
11329|       |    }
11330|       |
11331|       |    #[test]
11332|       |    fn test_render_code_block_mermaid_and_context_menu() {
11333|       |        let renderer = MarkdownRenderer::new();
11334|       |        let _guard = EnvVarGuard::set("MDMDVIEW_MERMAID_RENDERER", "off");
11335|       |        with_test_ui(|_, ui| {
11336|       |            renderer.render_code_block(ui, Some("mermaid"), "graph TD; A-->B;");
11337|       |        });
11338|       |
11339|       |        let ctx = egui::Context::default();
11340|       |        let click = input_with_click(egui::pos2(12.0, 12.0), egui::PointerButton::Secondary);
11341|       |        run_frame_with_input(&ctx, click, |_, ui| {
11342|       |            renderer.render_code_block(ui, Some("rust"), "fn main() {}");
11343|       |        });
11344|       |        let input = egui::RawInput {
11345|       |            screen_rect: Some(egui::Rect::from_min_size(
11346|       |                egui::pos2(0.0, 0.0),
11347|       |                egui::vec2(320.0, 240.0),
11348|       |            )),
11349|       |            ..Default::default()
11350|       |        };
11351|       |        run_frame_with_input(&ctx, input, |_, ui| {
11352|       |            renderer.render_code_block(ui, Some("rust"), "fn main() {}");
11353|       |        });
11354|       |    }
11355|       |
11356|       |    #[test]
11357|       |    fn test_render_code_block_highlight_styles() {
11358|       |        let mut renderer = MarkdownRenderer::new();
11359|       |        let theme = renderer
11360|       |            .theme_set
11361|       |            .themes
11362|       |            .get_mut("base16-ocean.dark")
11363|       |            .expect("theme");
11364|       |        theme.scopes.clear();
11365|       |        let selector = ScopeSelectors::from_str("source.rust").expect("selector");
11366|       |        theme.scopes.push(ThemeItem {
11367|       |            scope: selector,
11368|       |            style: StyleModifier {
11369|       |                foreground: Some(Color::WHITE),
11370|       |                background: Some(Color::BLACK),
11371|       |                font_style: Some(FontStyle::BOLD | FontStyle::ITALIC),
11372|       |            },
11373|       |        });
11374|       |        with_test_ui(|_, ui| {
11375|       |            renderer.render_code_block(ui, Some("rust"), "fn main() {}");
11376|       |        });
11377|       |    }
11378|       |
11379|       |    #[test]
11380|       |    fn test_render_code_block_highlight_and_fallback() {
11381|       |        let renderer = MarkdownRenderer::new();
11382|       |        let code = "fn main() {\n    let value = 1;\n    // comment with  spaces\n    \n}\n";
11383|       |        with_test_ui(|_, ui| {
11384|       |            renderer.render_code_block(ui, Some("rust"), code);
11385|       |        });
11386|       |
11387|       |        let mut fallback_renderer = MarkdownRenderer::new();
11388|       |        fallback_renderer.syntax_set = SyntaxSet::new();
11389|       |        with_test_ui(|_, ui| {
11390|       |            fallback_renderer.render_code_block(ui, Some("notalanguage"), "code");
11391|       |        });
11392|       |    }
11393|       |
11394|       |    #[test]
11395|       |    fn test_to_superscript_maps_values() {
11396|       |        let mapped = MarkdownRenderer::to_superscript("Abc123!");
11397|       |        assert_ne!(mapped, "Abc123!");
11398|       |    }
11399|       |
11400|       |    #[test]
11401|       |    fn test_cell_single_emoji_whitespace_only() {
11402|       |        let renderer = MarkdownRenderer::new();
11403|       |        let spans = vec![InlineSpan::Text("   ".to_string())];
11404|       |        assert!(renderer.cell_single_emoji(&spans).is_none());
11405|       |    }
11406|       |
11407|       |    #[test]
11408|       |    fn test_table_line_info_with_list_fallback_indent() {
11409|       |        let line = "  >| A |";
11410|       |        let (level, rest) = MarkdownRenderer::table_line_info_with_list(line, Some(2));
11411|       |        assert_eq!(level, 1);
11412|       |        assert!(rest.starts_with('|'));
11413|       |    }
11414|       |
11415|       |    #[test]
11416|       |    fn test_list_marker_info_any_indent_missing_punctuation() {
11417|       |        assert!(MarkdownRenderer::list_marker_info_any_indent("1 item").is_none());
11418|       |    }
11419|       |
11420|       |    #[test]
11421|       |    fn test_strip_indent_columns_rejects_non_whitespace() {
11422|       |        assert!(MarkdownRenderer::strip_indent_columns("x", 1).is_none());
11423|       |    }
11424|       |
11425|       |    #[test]
11426|       |    fn test_parse_element_image_empty_title_outside_paragraph() {
11427|       |        let renderer = MarkdownRenderer::new();
11428|       |        let events = vec![
11429|       |            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
11430|       |            Event::Text("alt".into()),
11431|       |            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
11432|       |        ];
11433|       |        let mut elements = Vec::new();
11434|       |        let mut slugs = HashMap::new();
11435|       |        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs);
11436|       |        assert_eq!(next, events.len());
11437|       |        let spans = paragraph_spans(&elements[0]).expect("paragraph spans");
11438|       |        let (_src, _alt, title) = image_span_fields(&spans[0]).expect("image span");
11439|       |        assert!(title.is_none());
11440|       |    }
11441|       |
11442|       |    #[test]
11443|       |    fn test_slugify_trailing_dash_trimmed() {
11444|       |        let slug = MarkdownRenderer::slugify("Hello - ");
11445|       |        assert_eq!(slug, "hello");
11446|       |    }
11447|       |
11448|       |    #[test]
11449|       |    fn test_slugify_leading_whitespace_and_internal_spaces() {
11450|       |        let slug = MarkdownRenderer::slugify("  Hello   World ");
11451|       |        assert_eq!(slug, "hello-world");
11452|       |    }
11453|       |
11454|       |    #[test]
11455|       |    fn test_render_plain_and_highlight_empty_text() {
11456|       |        let renderer = MarkdownRenderer::new();
11457|       |        with_test_ui(|_, ui| {
11458|       |            ui.visuals_mut().override_text_color = Some(Color32::from_rgb(10, 20, 30));
11459|       |            let style = InlineStyle {
11460|       |                strong: true,
11461|       |                ..Default::default()
11462|       |            };
11463|       |            renderer.render_plain_segment(ui, "", 12.0, style);
11464|       |            renderer.render_plain_segment(ui, "Header", 12.0, style);
11465|       |            renderer.render_highlighted_segment(ui, "", 12.0, style);
11466|       |        });
11467|       |    }
11468|       |
11469|       |    #[test]
11470|       |    fn test_render_plain_segment_without_color_override() {
11471|       |        let renderer = MarkdownRenderer::new();
11472|       |        with_test_ui(|_, ui| {
11473|       |            ui.visuals_mut().override_text_color = None;
11474|       |            renderer.render_plain_segment(ui, "Plain", 12.0, InlineStyle::default());
11475|       |        });
11476|       |    }
11477|       |
11478|       |    #[test]
11479|       |    fn test_emoji_key_for_grapheme_strips_vs16() {
11480|       |        let renderer = MarkdownRenderer::new();
11481|       |        let key = renderer.emoji_key_for_grapheme("\u{2705}\u{fe0f}");
11482|       |        assert_eq!(key, Some("\u{2705}".to_string()));
11483|       |    }
11484|       |
11485|       |    #[test]
11486|       |    fn test_expand_superscripts_long_sequence_no_expand() {
11487|       |        let input = "value^abcdefghijk^";
11488|       |        let out = MarkdownRenderer::expand_superscripts(input);
11489|       |        assert_eq!(out, input);
11490|       |    }
11491|       |
11492|       |    #[test]
11493|       |    fn test_compute_table_content_hash_stops_after_sample_rows() {
11494|       |        let renderer = MarkdownRenderer::new();
11495|       |        let headers = vec![vec![InlineSpan::Text("H".to_string())]];
11496|       |        let rows: Vec<Vec<Vec<InlineSpan>>> = (0..(COLUMN_STATS_SAMPLE_ROWS + 1))
11497|       |            .map(|idx| vec![vec![InlineSpan::Text(format!("R{idx}"))]])
11498|       |            .collect();
11499|       |        let hash = renderer.compute_table_content_hash(&headers, &rows, &[]);
11500|       |        assert_ne!(hash, 0);
11501|       |    }
11502|       |
11503|       |    #[test]
11504|       |    fn test_table_width_helpers_empty_inputs() {
11505|       |        let renderer = MarkdownRenderer::new();
11506|       |        let table_id = 100u64;
11507|       |        let mut specs: Vec<ColumnSpec> = Vec::new();
11508|       |        renderer.apply_persisted_widths(table_id, &mut specs);
11509|       |        renderer.persist_resizable_widths(table_id, &[], &[]);
11510|       |        let change = renderer.record_resolved_widths(table_id, 0, &[]);
11511|       |        assert!(matches!(change, WidthChange::None));
11512|       |        assert!(renderer
11513|       |            .resolve_table_column_widths(table_id, &[], 10.0)
11514|       |            .is_empty());
11515|       |        assert_eq!(renderer.estimate_table_total_width(table_id, &[], 6.0), 0.0);
11516|       |        with_test_ui(|_, ui| {
11517|       |            let style = ui.style().clone();
11518|       |            let row = vec![vec![]];
11519|       |            let height =
11520|       |                renderer.estimate_table_row_height(ui, &style, &row, &[Align::LEFT], &[40.0], 12.0);
11521|       |            assert_eq!(height, 12.0);
11522|       |            let row = vec![
11523|       |                vec![InlineSpan::Text("a".to_string())],
11524|       |                vec![InlineSpan::Text("b".to_string())],
11525|       |            ];
11526|       |            let height =
11527|       |                renderer.estimate_table_row_height(ui, &style, &row, &[Align::LEFT], &[40.0], 12.0);
11528|       |            assert!(height >= 12.0);
11529|       |            let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(10.0, 10.0));
11530|       |            renderer.paint_table_dividers(ui.painter(), ui.visuals(), rect, rect, &[], 0.0, 0.0);
11531|       |        });
11532|       |    }
11533|       |
11534|       |    #[test]
11535|       |    fn test_resolve_table_column_widths_ignores_invalid_stored_widths() {
11536|       |        let renderer = MarkdownRenderer::new();
11537|       |        let table_id = 101u64;
11538|       |        {
11539|       |            let mut metrics = renderer.table_metrics.borrow_mut();
11540|       |            let entry = metrics.entry_mut(table_id);
11541|       |            entry.resolved_widths = vec![f32::NAN, -5.0];
11542|       |        }
11543|       |        let specs = vec![
11544|       |            ColumnSpec::new(
11545|       |                0,
11546|       |                "A",
11547|       |                ColumnPolicy::Resizable {
11548|       |                    min: 20.0,
11549|       |                    preferred: 40.0,
11550|       |                    clip: false,
11551|       |                },
11552|       |                None,
11553|       |            ),
11554|       |            ColumnSpec::new(1, "B", ColumnPolicy::Auto, None),
11555|       |        ];
11556|       |        let widths = renderer.resolve_table_column_widths(table_id, &specs, 30.0);
11557|       |        assert_eq!(widths, vec![40.0, 30.0]);
11558|       |    }
11559|       |
11560|       |    #[test]
11561|       |    fn test_persist_resizable_widths_stores_new_width() {
11562|       |        let renderer = MarkdownRenderer::new();
11563|       |        let table_id = 200u64;
11564|       |        let specs = vec![ColumnSpec::new(
11565|       |            0,
11566|       |            "A",
11567|       |            ColumnPolicy::Resizable {
11568|       |                min: 20.0,
11569|       |                preferred: 100.0,
11570|       |                clip: false,
11571|       |            },
11572|       |            None,
11573|       |        )];
11574|       |        let widths = vec![140.0f32];
11575|       |        renderer.persist_resizable_widths(table_id, &specs, &widths);
11576|       |        let metrics = renderer.table_metrics.borrow();
11577|       |        let entry = metrics.entry(table_id).expect("entry created");
11578|       |        assert_eq!(entry.persisted_width(specs[0].policy_hash), Some(140.0));
11579|       |    }
11580|       |
11581|       |    #[test]
11582|       |    fn test_persist_resizable_widths_skips_small_delta() {
11583|       |        let renderer = MarkdownRenderer::new();
11584|       |        let table_id = 201u64;
11585|       |        let spec = ColumnSpec::new(
11586|       |            0,
11587|       |            "A",
11588|       |            ColumnPolicy::Resizable {
11589|       |                min: 20.0,
11590|       |                preferred: 100.0,
11591|       |                clip: false,
11592|       |            },
11593|       |            None,
11594|       |        );
11595|       |        let hash = spec.policy_hash;
11596|       |        let specs = vec![spec];
11597|       |        renderer.persist_resizable_widths(table_id, &specs, &[120.0]);
11598|       |        renderer.persist_resizable_widths(table_id, &specs, &[120.2]);
11599|       |        let metrics = renderer.table_metrics.borrow();
11600|       |        let entry = metrics.entry(table_id).expect("entry created");
11601|       |        let stored = entry.persisted_width(hash).unwrap_or_default();
11602|       |        assert!((stored - 120.0).abs() < 0.01);
11603|       |    }
11604|       |
11605|       |    #[test]
11606|       |    fn test_persist_resizable_widths_updates_on_large_delta() {
11607|       |        let renderer = MarkdownRenderer::new();
11608|       |        let table_id = 202u64;
11609|       |        let spec = ColumnSpec::new(
11610|       |            0,
11611|       |            "A",
11612|       |            ColumnPolicy::Resizable {
11613|       |                min: 20.0,
11614|       |                preferred: 100.0,
11615|       |                clip: false,
11616|       |            },
11617|       |            None,
11618|       |        );
11619|       |        let hash = spec.policy_hash;
11620|       |        let specs = vec![spec];
11621|       |        renderer.persist_resizable_widths(table_id, &specs, &[120.0]);
11622|       |        renderer.persist_resizable_widths(table_id, &specs, &[130.0]);
11623|       |        let metrics = renderer.table_metrics.borrow();
11624|       |        let entry = metrics.entry(table_id).expect("entry created");
11625|       |        assert_eq!(entry.persisted_width(hash), Some(130.0));
11626|       |    }
11627|       |
11628|       |    #[test]
11629|       |    fn test_paint_table_dividers_draws_header_separator() {
11630|       |        let renderer = MarkdownRenderer::new();
11631|       |        with_test_ui(|_, ui| {
11632|       |            let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(120.0, 40.0));
11633|       |            renderer.paint_table_dividers(
11634|       |                ui.painter(),
11635|       |                ui.visuals(),
11636|       |                rect,
11637|       |                rect,
11638|       |                &[40.0, 60.0],
11639|       |                8.0,
11640|       |                12.0,
11641|       |            );
11642|       |        });
11643|       |    }
11644|       |
11645|       |    #[test]
11646|       |    fn test_paint_table_dividers_no_header_height() {
11647|       |        let renderer = MarkdownRenderer::new();
11648|       |        with_test_ui(|_, ui| {
11649|       |            let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(120.0, 20.0));
11650|       |            renderer.paint_table_dividers(
11651|       |                ui.painter(),
11652|       |                ui.visuals(),
11653|       |                rect,
11654|       |                rect,
11655|       |                &[40.0, 60.0],
11656|       |                0.0,
11657|       |                8.0,
11658|       |            );
11659|       |        });
11660|       |    }
11661|       |
11662|       |    #[test]
11663|       |    fn test_paint_table_dividers_skips_header_separator_out_of_bounds() {
11664|       |        let renderer = MarkdownRenderer::new();
11665|       |        with_test_ui(|_, ui| {
11666|       |            let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(120.0, 20.0));
11667|       |            renderer.paint_table_dividers(
11668|       |                ui.painter(),
11669|       |                ui.visuals(),
11670|       |                rect,
11671|       |                rect,
11672|       |                &[40.0, 60.0],
11673|       |                60.0,
11674|       |                8.0,
11675|       |            );
11676|       |        });
11677|       |    }
11678|       |
11679|       |    #[test]
11680|       |    fn test_paint_table_text_job_adds_hover_for_wrapped_text() {
11681|       |        let renderer = MarkdownRenderer::new();
11682|       |        let spans = vec![InlineSpan::Text(
11683|       |            "This is a long line that should wrap in a narrow cell.".to_string(),
11684|       |        )];
11685|       |        with_test_ui(|_, ui| {
11686|       |            let build = renderer.build_layout_job(ui.style(), &spans, 20.0, false, Align::LEFT);
11687|       |            let _response = renderer.paint_table_text_job(ui, 20.0, build);
11688|       |        });
11689|       |    }
11690|       |
11691|       |    #[test]
11692|       |    fn test_paint_table_text_job_adds_hover_for_multiline_text() {
11693|       |        let renderer = MarkdownRenderer::new();
11694|       |        let spans = vec![InlineSpan::Text("Line 1\nLine 2".to_string())];
11695|       |        with_test_ui(|_, ui| {
11696|       |            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, false, Align::LEFT);
11697|       |            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11698|       |            assert!(galley.rows.len() > 1);
11699|       |            let _response = renderer.paint_table_text_job(ui, 200.0, build);
11700|       |        });
11701|       |    }
11702|       |
11703|       |    #[test]
11704|       |    fn test_paint_table_text_job_skips_hover_for_short_text() {
11705|       |        let renderer = MarkdownRenderer::new();
11706|       |        let spans = vec![InlineSpan::Text("Short".to_string())];
11707|       |        with_test_ui(|_, ui| {
11708|       |            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, false, Align::LEFT);
11709|       |            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11710|       |            assert_eq!(galley.rows.len(), 1);
11711|       |            assert!(galley.size().x < 200.0);
11712|       |            let _response = renderer.paint_table_text_job(ui, 200.0, build);
11713|       |        });
11714|       |    }
11715|       |
11716|       |    #[test]
11717|       |    fn test_paint_table_text_job_adds_hover_for_single_line_overflow() {
11718|       |        let renderer = MarkdownRenderer::new();
11719|       |        let spans = vec![InlineSpan::Text(
11720|       |            "This is a single line that should overflow the render width.".to_string(),
11721|       |        )];
11722|       |        with_test_ui(|_, ui| {
11723|       |            let build = renderer.build_layout_job(ui.style(), &spans, 400.0, false, Align::LEFT);
11724|       |            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11725|       |            assert_eq!(galley.rows.len(), 1);
11726|       |            assert!(galley.size().x > 40.0);
11727|       |            let _response = renderer.paint_table_text_job(ui, 40.0, build);
11728|       |        });
11729|       |    }
11730|       |
11731|       |    #[test]
11732|       |    fn test_link_at_pointer_outside_text_rect() {
11733|       |        let renderer = MarkdownRenderer::new();
11734|       |        let spans = vec![InlineSpan::Link {
11735|       |            text: "link".to_string(),
11736|       |            url: "https://example.com".to_string(),
11737|       |        }];
11738|       |        let ctx = egui::Context::default();
11739|       |        let outside_pos = std::cell::Cell::new(egui::pos2(1.0, 1.0));
11740|       |        let layout_input = egui::RawInput {
11741|       |            screen_rect: Some(egui::Rect::from_min_size(
11742|       |                egui::pos2(0.0, 0.0),
11743|       |                egui::vec2(220.0, 120.0),
11744|       |            )),
11745|       |            ..Default::default()
11746|       |        };
11747|       |        run_frame_with_input(&ctx, layout_input, |_, ui| {
11748|       |            let build = renderer.build_layout_job(ui.style(), &spans, 40.0, false, Align::LEFT);
11749|       |            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11750|       |            let (rect, _response) =
11751|       |                ui.allocate_exact_size(egui::vec2(200.0, galley.size().y), egui::Sense::hover());
11752|       |            let text_origin =
11753|       |                MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
11754|       |            let text_rect = galley.rect.translate(text_origin.to_vec2());
11755|       |            let pos = egui::pos2(rect.right() - 2.0, text_rect.center().y);
11756|       |            assert!(pos.x > text_rect.right());
11757|       |            outside_pos.set(pos);
11758|       |        });
11759|       |
11760|       |        let mut input = egui::RawInput {
11761|       |            screen_rect: Some(egui::Rect::from_min_size(
11762|       |                egui::pos2(0.0, 0.0),
11763|       |                egui::vec2(220.0, 120.0),
11764|       |            )),
11765|       |            ..Default::default()
11766|       |        };
11767|       |        input
11768|       |            .events
11769|       |            .push(egui::Event::PointerMoved(outside_pos.get()));
11770|       |        run_frame_with_input(&ctx, input, |_, ui| {
11771|       |            let build = renderer.build_layout_job(ui.style(), &spans, 40.0, false, Align::LEFT);
11772|       |            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11773|       |            let (rect, response) =
11774|       |                ui.allocate_exact_size(egui::vec2(200.0, galley.size().y), egui::Sense::hover());
11775|       |            let text_origin =
11776|       |                MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
11777|       |            let link = renderer.link_at_pointer(&response, &galley, &build, text_origin);
11778|       |            assert!(link.is_none());
11779|       |        });
11780|       |    }
11781|       |
11782|       |    #[test]
11783|       |    fn test_link_at_pointer_inside_text_rect_returns_link() {
11784|       |        let renderer = MarkdownRenderer::new();
11785|       |        let spans = vec![InlineSpan::Link {
11786|       |            text: "link".to_string(),
11787|       |            url: "#anchor".to_string(),
11788|       |        }];
11789|       |        let ctx = egui::Context::default();
11790|       |        let click_pos = std::cell::Cell::new(egui::pos2(1.0, 1.0));
11791|       |        let layout_input = egui::RawInput {
11792|       |            screen_rect: Some(egui::Rect::from_min_size(
11793|       |                egui::pos2(0.0, 0.0),
11794|       |                egui::vec2(220.0, 120.0),
11795|       |            )),
11796|       |            ..Default::default()
11797|       |        };
11798|       |        run_frame_with_input(&ctx, layout_input, |_, ui| {
11799|       |            let build = renderer.build_layout_job(ui.style(), &spans, 40.0, false, Align::LEFT);
11800|       |            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11801|       |            let (rect, _response) =
11802|       |                ui.allocate_exact_size(egui::vec2(200.0, galley.size().y), egui::Sense::hover());
11803|       |            let text_origin =
11804|       |                MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
11805|       |            click_pos.set(text_origin + egui::vec2(2.0, 2.0));
11806|       |        });
11807|       |
11808|       |        let mut input = egui::RawInput {
11809|       |            screen_rect: Some(egui::Rect::from_min_size(
11810|       |                egui::pos2(0.0, 0.0),
11811|       |                egui::vec2(220.0, 120.0),
11812|       |            )),
11813|       |            ..Default::default()
11814|       |        };
11815|       |        input
11816|       |            .events
11817|       |            .push(egui::Event::PointerMoved(click_pos.get()));
11818|       |        run_frame_with_input(&ctx, input, |_, ui| {
11819|       |            let build = renderer.build_layout_job(ui.style(), &spans, 40.0, false, Align::LEFT);
11820|       |            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11821|       |            let (rect, response) =
11822|       |                ui.allocate_exact_size(egui::vec2(200.0, galley.size().y), egui::Sense::hover());
11823|       |            let text_origin =
11824|       |                MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
11825|       |            let link = renderer.link_at_pointer(&response, &galley, &build, text_origin);
11826|       |            assert!(link.is_some());
11827|       |        });
11828|       |    }
11829|       |
11830|       |    #[test]
11831|       |    fn test_element_plain_text_list_quote_table_spacing() {
11832|       |        let list = MarkdownElement::List {
11833|       |            ordered: false,
11834|       |            items: vec![ListItem {
11835|       |                blocks: vec![
11836|       |                    MarkdownElement::Paragraph(vec![InlineSpan::Text("One".to_string())]),
11837|       |                    MarkdownElement::Paragraph(vec![InlineSpan::Text("Two".to_string())]),
11838|       |                ],
11839|       |            }],
11840|       |        };
11841|       |        let list_text = MarkdownRenderer::element_plain_text(&list);
11842|       |        assert!(list_text.contains('\n'));
11843|       |
11844|       |        let quote = MarkdownElement::Quote {
11845|       |            depth: 1,
11846|       |            blocks: vec![
11847|       |                MarkdownElement::Paragraph(vec![InlineSpan::Text("Alpha".to_string())]),
11848|       |                MarkdownElement::Paragraph(vec![InlineSpan::Text("Beta".to_string())]),
11849|       |            ],
11850|       |        };
11851|       |        let quote_text = MarkdownRenderer::element_plain_text(&quote);
11852|       |        assert!(quote_text.contains('\n'));
11853|       |
11854|       |        let table = MarkdownElement::Table {
11855|       |            headers: vec![
11856|       |                vec![InlineSpan::Text("H1".to_string())],
11857|       |                vec![InlineSpan::Text("H2".to_string())],
11858|       |            ],
11859|       |            rows: vec![vec![
11860|       |                vec![InlineSpan::Text("A".to_string())],
11861|       |                vec![InlineSpan::Text("B".to_string())],
11862|       |            ]],
11863|       |            alignments: vec![],
11864|       |        };
11865|       |        let table_text = MarkdownRenderer::element_plain_text(&table);
11866|       |        assert_eq!(table_text, "H1 H2 A B");
11867|       |    }
11868|       |
11869|       |    #[test]
11870|       |    fn test_resolve_image_path_data_uri_and_remote_texture_reject() {
11871|       |        let renderer = MarkdownRenderer::new();
11872|       |        let data_uri = "data:image/png;base64,AAAA";
11873|       |        assert_eq!(renderer.resolve_image_path(data_uri), data_uri);
11874|       |        with_test_ui(|_, ui| {
11875|       |            assert!(renderer
11876|       |                .get_or_load_image_texture(ui, "https://example.com/image.png")
11877|       |                .is_none());
11878|       |            assert!(renderer
11879|       |                .get_or_load_image_texture(ui, "http://example.com/image.png")
11880|       |                .is_none());
11881|       |        });
11882|       |    }
11883|       |
11884|       |    #[test]
11885|       |    fn test_is_html_line_break_rejects_non_br() {
11886|       |        assert!(!MarkdownRenderer::is_html_line_break("<div>"));
11887|       |        assert!(!MarkdownRenderer::is_html_line_break("br"));
11888|       |    }
11889|       |
11890|       |    #[test]
11891|       |    fn test_table_line_info_variants_cover_edges() {
11892|       |        let (level, rest) = MarkdownRenderer::table_line_info("text");
11893|       |        assert_eq!(level, 0);
11894|       |        assert_eq!(rest, "text");
11895|       |
11896|       |        let (level, rest) = MarkdownRenderer::table_line_info("   text");
11897|       |        assert_eq!(level, 0);
11898|       |        assert_eq!(rest, "   text");
11899|       |
11900|       |        let (level, rest) = MarkdownRenderer::table_line_info(">abc");
11901|       |        assert_eq!(level, 1);
11902|       |        assert_eq!(rest, "abc");
11903|       |
11904|       |        let (level, rest) = MarkdownRenderer::table_line_info(" >\tabc");
11905|       |        assert_eq!(level, 1);
11906|       |        assert_eq!(rest, "abc");
11907|       |
11908|       |        let (level, rest) = MarkdownRenderer::table_line_info(">");
11909|       |        assert_eq!(level, 1);
11910|       |        assert_eq!(rest, "");
11911|       |    }
11912|       |
11913|       |    #[test]
11914|       |    fn test_list_marker_info_rejects_missing_delimiter_or_spacing() {
11915|       |        assert!(MarkdownRenderer::list_marker_info("1 item").is_none());
11916|       |        assert!(MarkdownRenderer::list_marker_info("1.item").is_none());
11917|       |    }
11918|       |
11919|       |    #[test]
11920|       |    fn test_list_marker_info_numeric_missing_punctuation() {
11921|       |        assert!(MarkdownRenderer::list_marker_info("12").is_none());
11922|       |        assert!(MarkdownRenderer::list_marker_info_any_indent("  12").is_none());
11923|       |    }
11924|       |
11925|       |    #[test]
11926|       |    fn test_list_marker_info_any_indent_rejects_missing_delimiter_or_spacing() {
11927|       |        assert!(MarkdownRenderer::list_marker_info_any_indent("   1 item").is_none());
11928|       |        assert!(MarkdownRenderer::list_marker_info_any_indent("  2.item").is_none());
11929|       |    }
11930|       |
11931|       |    #[test]
11932|       |    fn test_strip_indent_columns_insufficient_indent_returns_none() {
11933|       |        assert!(MarkdownRenderer::strip_indent_columns("  text", 4).is_none());
11934|       |    }
11935|       |
11936|       |    #[test]
11937|       |    fn test_strip_indent_columns_whitespace_short_returns_none() {
11938|       |        assert!(MarkdownRenderer::strip_indent_columns("  ", 4).is_none());
11939|       |    }
11940|       |
11941|       |    #[test]
11942|       |    fn test_has_pipe_outside_inline_code_unmatched_backticks() {
11943|       |        let line = "`code`` | still in code";
11944|       |        assert!(!MarkdownRenderer::has_pipe_outside_inline_code(line));
11945|       |    }
11946|       |
11947|       |    #[test]
11948|       |    fn test_is_table_delimiter_line_requires_dash_and_pipe() {
11949|       |        assert!(!MarkdownRenderer::is_table_delimiter_line("----"));
11950|       |        assert!(!MarkdownRenderer::is_table_delimiter_line("| ::: |"));
11951|       |    }
11952|       |
11953|       |    #[test]
11954|       |    fn test_append_text_sections_preserves_color_when_highlighted() {
11955|       |        let renderer = MarkdownRenderer::new();
11956|       |        let style = egui::Style::default();
11957|       |        let mut job = LayoutJob::default();
11958|       |        let mut plain_text = String::new();
11959|       |        let inline_style = InlineStyle {
11960|       |            strong: false,
11961|       |            italics: false,
11962|       |            strike: false,
11963|       |            color: Some(Color32::from_rgb(10, 20, 30)),
11964|       |        };
11965|       |        let count = renderer.append_text_sections(
11966|       |            &style,
11967|       |            &mut job,
11968|       |            &mut plain_text,
11969|       |            "hit",
11970|       |            renderer.font_sizes.body,
11971|       |            inline_style,
11972|       |            Some("hit"),
11973|       |        );
11974|       |        assert_eq!(count, 3);
11975|       |        assert_eq!(plain_text, "hit");
11976|       |    }
11977|       |
11978|       |    #[test]
11979|       |    fn test_render_text_with_emojis_leading_emoji() {
11980|       |        let renderer = MarkdownRenderer::new();
11981|       |        with_test_ui(|_, ui| {
11982|       |            renderer.render_text_with_emojis(ui, " test", 14.0, InlineStyle::default());
11983|       |        });
11984|       |    }
11985|       |
11986|       |    #[test]
11987|       |    fn test_persist_resizable_widths_records_change() {
11988|       |        let renderer = MarkdownRenderer::new();
11989|       |        let spec = ColumnSpec::new(
11990|       |            0,
11991|       |            "col",
11992|       |            ColumnPolicy::Resizable {
11993|       |                min: 40.0,
11994|       |                preferred: 80.0,
11995|       |                clip: false,
11996|       |            },
11997|       |            None,
11998|       |        );
11999|       |        let hash = spec.policy_hash;
12000|       |        renderer.persist_resizable_widths(42, &[spec], &[120.0]);
12001|       |        let metrics = renderer.table_metrics.borrow();
12002|       |        let entry = metrics.entry(42).expect("metrics entry");
12003|       |        assert_eq!(entry.persisted_width(hash), Some(120.0));
12004|       |    }
12005|       |
12006|       |    #[test]
12007|       |    fn test_env_var_guard_restores_previous_value() {
12008|       |        std::env::set_var("MDMDVIEW_TEST_ENV", "before");
12009|       |        {
12010|       |            let _guard = EnvVarGuard::set("MDMDVIEW_TEST_ENV", "after");
12011|       |            assert_eq!(
12012|       |                std::env::var("MDMDVIEW_TEST_ENV").ok().as_deref(),
12013|       |                Some("after")
12014|       |            );
12015|       |        }
12016|       |        assert_eq!(
12017|       |            std::env::var("MDMDVIEW_TEST_ENV").ok().as_deref(),
12018|       |            Some("before")
12019|       |        );
12020|       |        std::env::remove_var("MDMDVIEW_TEST_ENV");
12021|       |    }
12022|       |
12023|       |    #[test]
12024|       |    fn test_parse_element_skips_unhandled_event() {
12025|       |        let renderer = MarkdownRenderer::new();
12026|       |        let events = vec![Event::Text("orphan".into())];
12027|       |        let mut elements = Vec::new();
12028|       |        let mut slugs = std::collections::HashMap::new();
12029|       |        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs);
12030|       |        assert_eq!(next, events.len());
12031|       |        assert!(elements.is_empty());
12032|       |    }
12033|       |
12034|       |    #[test]
12035|       |    fn test_parse_inline_spans_link_and_image() {
12036|       |        let renderer = MarkdownRenderer::new();
12037|       |        let events = vec![
12038|       |            Event::Start(Tag::Paragraph),
12039|       |            Event::Start(Tag::Link(
12040|       |                LinkType::Inline,
12041|       |                "https://example.com".into(),
12042|       |                "".into(),
12043|       |            )),
12044|       |            Event::Text("Link".into()),
12045|       |            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
12046|       |            Event::Start(Tag::Image(
12047|       |                LinkType::Inline,
12048|       |                "img.png".into(),
12049|       |                "Title".into(),
12050|       |            )),
12051|       |            Event::Text("Alt".into()),
12052|       |            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
12053|       |            Event::End(Tag::Paragraph),
12054|       |        ];
12055|       |        let (spans, next) = renderer.parse_inline_spans(&events, 1, Tag::Paragraph);
12056|       |        assert_eq!(next, events.len());
12057|       |        assert!(spans
12058|       |            .iter()
12059|       |            .any(|span| matches!(span, InlineSpan::Link { .. })));
12060|       |        assert!(spans
12061|       |            .iter()
12062|       |            .any(|span| matches!(span, InlineSpan::Image { .. })));
12063|       |    }
12064|       |
12065|       |    #[test]
12066|       |    fn test_parse_inline_spans_with_breaks_link_and_image() {
12067|       |        let renderer = MarkdownRenderer::new();
12068|       |        let events = vec![
12069|       |            Event::Start(Tag::Paragraph),
12070|       |            Event::Start(Tag::Link(
12071|       |                LinkType::Inline,
12072|       |                "https://example.com".into(),
12073|       |                "".into(),
12074|       |            )),
12075|       |            Event::Text("Link".into()),
12076|       |            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
12077|       |            Event::Start(Tag::Image(
12078|       |                LinkType::Inline,
12079|       |                "img.png".into(),
12080|       |                "Title".into(),
12081|       |            )),
12082|       |            Event::Text("Alt".into()),
12083|       |            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
12084|       |            Event::End(Tag::Paragraph),
12085|       |        ];
12086|       |        let (spans, next) =
12087|       |            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, false);
12088|       |        assert_eq!(next, events.len());
12089|       |        assert!(spans
12090|       |            .iter()
12091|       |            .any(|span| matches!(span, InlineSpan::Link { .. })));
12092|       |        assert!(spans
12093|       |            .iter()
12094|       |            .any(|span| matches!(span, InlineSpan::Image { .. })));
12095|       |    }
12096|       |
12097|       |    #[test]
12098|       |    fn test_parse_list_item_heading_builds_header() -> Result<()> {
12099|       |        let renderer = MarkdownRenderer::new();
12100|       |        let events = vec![
12101|       |            Event::Start(Tag::List(None)),
12102|       |            Event::Start(Tag::Item),
12103|       |            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
12104|       |            Event::Text("Title".into()),
12105|       |            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
12106|       |            Event::End(Tag::Item),
12107|       |            Event::End(Tag::List(None)),
12108|       |        ];
12109|       |        let mut slugs = std::collections::HashMap::new();
12110|       |        let (items, next) = renderer.parse_list(&events, 1, &mut slugs);
12111|       |        assert_eq!(next, events.len());
12112|       |        assert!(matches!(items[0].blocks[0], MarkdownElement::Header { .. }));
12113|       |        Ok(())
12114|       |    }
12115|       |
12116|       |    #[test]
12117|       |    fn test_parse_list_inline_formats_without_paragraph() -> Result<()> {
12118|       |        let renderer = MarkdownRenderer::new();
12119|       |        let events = vec![
12120|       |            Event::Start(Tag::List(None)),
12121|       |            Event::Start(Tag::Item),
12122|       |            Event::Start(Tag::Emphasis),
12123|       |            Event::Text("em".into()),
12124|       |            Event::End(Tag::Emphasis),
12125|       |            Event::Start(Tag::Strikethrough),
12126|       |            Event::Text("strike".into()),
12127|       |            Event::End(Tag::Strikethrough),
12128|       |            Event::Start(Tag::Link(
12129|       |                LinkType::Inline,
12130|       |                "https://example.com".into(),
12131|       |                "".into(),
12132|       |            )),
12133|       |            Event::Text("link".into()),
12134|       |            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
12135|       |            Event::Start(Tag::Image(
12136|       |                LinkType::Inline,
12137|       |                "img.png".into(),
12138|       |                "Title".into(),
12139|       |            )),
12140|       |            Event::Text("Alt".into()),
12141|       |            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
12142|       |            Event::End(Tag::Item),
12143|       |            Event::End(Tag::List(None)),
12144|       |        ];
12145|       |        let mut slugs = std::collections::HashMap::new();
12146|       |        let (items, next) = renderer.parse_list(&events, 1, &mut slugs);
12147|       |        assert_eq!(next, events.len());
12148|       |        assert!(matches!(items[0].blocks[0], MarkdownElement::Paragraph(_)));
12149|       |        let dummy = MarkdownElement::HorizontalRule;
12150|       |        let mut saw_paragraph = false;
12151|       |        for element in [&items[0].blocks[0], &dummy] {
12152|       |            match element {
12153|       |                MarkdownElement::Paragraph(spans) => {
12154|       |                    assert!(spans
12155|       |                        .iter()
12156|       |                        .any(|span| matches!(span, InlineSpan::Emphasis(_))));
12157|       |                    assert!(spans
12158|       |                        .iter()
12159|       |                        .any(|span| matches!(span, InlineSpan::Strikethrough(_))));
12160|       |                    assert!(spans
12161|       |                        .iter()
12162|       |                        .any(|span| matches!(span, InlineSpan::Link { .. })));
12163|       |                    assert!(spans
12164|       |                        .iter()
12165|       |                        .any(|span| matches!(span, InlineSpan::Image { .. })));
12166|       |                    saw_paragraph = true;
12167|       |                }
12168|       |                _ => {}
12169|       |            }
12170|       |        }
12171|       |        assert!(saw_paragraph);
12172|       |        Ok(())
12173|       |    }
12174|       |
12175|       |    #[test]
12176|       |    fn test_parse_table_parses_header_and_rows() -> Result<()> {
12177|       |        let renderer = MarkdownRenderer::new();
12178|       |        let alignments = vec![Alignment::Left];
12179|       |        let events = vec![
12180|       |            Event::Start(Tag::Table(alignments.clone())),
12181|       |            Event::Start(Tag::TableHead),
12182|       |            Event::Start(Tag::TableRow),
12183|       |            Event::Start(Tag::TableCell),
12184|       |            Event::Text("H".into()),
12185|       |            Event::End(Tag::TableCell),
12186|       |            Event::End(Tag::TableRow),
12187|       |            Event::End(Tag::TableHead),
12188|       |            Event::Start(Tag::TableRow),
12189|       |            Event::Start(Tag::TableCell),
12190|       |            Event::Text("A".into()),
12191|       |            Event::End(Tag::TableCell),
12192|       |            Event::End(Tag::TableRow),
12193|       |            Event::End(Tag::Table(alignments)),
12194|       |        ];
12195|       |        let (headers, rows, next) = renderer.parse_table(&events, 1);
12196|       |        assert_eq!(next, events.len());
12197|       |        assert_eq!(headers.len(), 1);
12198|       |        assert_eq!(rows.len(), 1);
12199|       |        Ok(())
12200|       |    }
12201|       |}

C:\language\mdmdview\src\mermaid_renderer.rs:
    1|       |#[cfg(feature = "mermaid-quickjs")]
    2|       |use crossbeam_channel::{bounded, Receiver, Sender, TrySendError};
    3|       |use egui::{Color32, RichText, Stroke};
    4|       |#[cfg(feature = "mermaid-quickjs")]
    5|       |use std::cell::{Cell, RefCell};
    6|       |#[cfg(feature = "mermaid-quickjs")]
    7|       |use std::collections::HashSet;
    8|       |#[cfg(any(test, feature = "mermaid-quickjs"))]
    9|       |use std::collections::{hash_map::DefaultHasher, HashMap, VecDeque};
   10|       |#[cfg(any(test, feature = "mermaid-quickjs"))]
   11|       |use std::hash::{Hash, Hasher};
   12|       |
   13|       |#[cfg(feature = "mermaid-quickjs")]
   14|       |use std::path::PathBuf;
   15|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   16|       |use std::sync::atomic::AtomicBool;
   17|       |#[cfg(feature = "mermaid-quickjs")]
   18|       |use std::sync::{
   19|       |    atomic::{AtomicU64, Ordering},
   20|       |    Arc,
   21|       |};
   22|       |#[cfg(feature = "mermaid-quickjs")]
   23|       |use std::thread::JoinHandle;
   24|       |#[cfg(feature = "mermaid-quickjs")]
   25|       |use std::time::{SystemTime, UNIX_EPOCH};
   26|       |
   27|       |#[cfg(feature = "mermaid-quickjs")]
   28|       |mod mermaid_embed {
   29|       |    include!(concat!(env!("OUT_DIR"), "/mermaid_js.rs"));
   30|       |}
   31|       |
   32|       |#[cfg(feature = "mermaid-quickjs")]
   33|       |const MERMAID_JS_EMPTY: bool = mermaid_embed::MERMAID_JS.is_empty();
   34|       |
   35|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   36|       |static MERMAID_JS_EMPTY_OVERRIDE: std::sync::Mutex<Option<std::thread::ThreadId>> =
   37|       |    std::sync::Mutex::new(None);
   38|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   39|       |static FORCE_RAW_TREE_PARSE_FAIL: std::sync::atomic::AtomicBool =
   40|       |    std::sync::atomic::AtomicBool::new(false);
   41|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   42|       |static FORCE_MERMAID_WORKER_INIT_ERROR: AtomicBool = AtomicBool::new(false);
   43|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   44|       |static FORCE_MERMAID_THREAD_SPAWN_ERROR: AtomicBool = AtomicBool::new(false);
   45|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   46|       |static FORCE_MERMAID_INIT_ERROR_STAGE: std::sync::Mutex<Option<(std::thread::ThreadId, usize)>> =
   47|       |    std::sync::Mutex::new(None);
   48|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   49|       |static FORCE_MERMAID_RUNTIME_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
   50|       |    std::sync::Mutex::new(None);
   51|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   52|       |static FORCE_MERMAID_CONTEXT_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
   53|       |    std::sync::Mutex::new(None);
   54|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   55|       |static FORCE_MERMAID_UTF8_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
   56|       |    std::sync::Mutex::new(None);
   57|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   58|       |static FORCE_MERMAID_RENDER_EVAL_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
   59|       |    std::sync::Mutex::new(None);
   60|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   61|       |static FORCE_MERMAID_RENDER_CALL_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
   62|       |    std::sync::Mutex::new(None);
   63|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   64|       |static FORCE_MERMAID_PIXMAP_ALLOC_FAIL: std::sync::Mutex<Option<std::thread::ThreadId>> =
   65|       |    std::sync::Mutex::new(None);
   66|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   67|       |static FORCE_MERMAID_FACE_PARSE_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
   68|       |    std::sync::Mutex::new(None);
   69|       |
   70|       |#[cfg(feature = "mermaid-quickjs")]
   71|  1.57k|fn mermaid_js_empty() -> bool {
   72|       |    #[cfg(test)]
   73|  1.57k|    if let Ok(guard) = MERMAID_JS_EMPTY_OVERRIDE.try_lock() {
                            ^1.57k
   74|  1.57k|        if let Some(id) = guard.as_ref() {
                                  ^5
   75|      5|            if *id == std::thread::current().id() {
   76|      3|                return true;
   77|      2|            }
   78|  1.57k|        }
   79|      1|    }
   80|  1.57k|    MERMAID_JS_EMPTY
   81|  1.57k|}
   82|       |
   83|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   84|      7|fn set_mermaid_js_empty_for_test(value: bool) -> Option<std::thread::ThreadId> {
   85|      7|    let mut guard = MERMAID_JS_EMPTY_OVERRIDE
   86|      7|        .lock()
   87|      7|        .expect("mermaid js override lock");
   88|      7|    let previous = guard.clone();
   89|      7|    *guard = if value {
   90|      5|        Some(std::thread::current().id())
   91|       |    } else {
   92|      2|        None
   93|       |    };
   94|      7|    previous
   95|      7|}
   96|       |
   97|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   98|      1|fn force_raw_tree_parse_fail_for_test() {
   99|      1|    FORCE_RAW_TREE_PARSE_FAIL.store(true, Ordering::Relaxed);
  100|      1|}
  101|       |
  102|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  103|      1|fn force_mermaid_worker_init_error_once() {
  104|      1|    FORCE_MERMAID_WORKER_INIT_ERROR.store(true, Ordering::Relaxed);
  105|      1|}
  106|       |
  107|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  108|      1|fn force_mermaid_thread_spawn_error_once() {
  109|      1|    FORCE_MERMAID_THREAD_SPAWN_ERROR.store(true, Ordering::Relaxed);
  110|      1|}
  111|       |
  112|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  113|      5|fn force_mermaid_init_error_once(stage: usize) {
  114|      5|    let mut guard = FORCE_MERMAID_INIT_ERROR_STAGE
  115|      5|        .lock()
  116|      5|        .expect("mermaid init error lock");
  117|      5|    *guard = Some((std::thread::current().id(), stage));
  118|      5|}
  119|       |
  120|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  121|  4.74k|fn take_mermaid_flag(flag: &std::sync::Mutex<Option<std::thread::ThreadId>>) -> bool {
  122|  4.74k|    let mut guard = flag.lock().expect("mermaid flag lock");
  123|  4.74k|    if let Some(thread_id) = guard.take() {
                              ^9
  124|      9|        if thread_id == std::thread::current().id() {
  125|      7|            return true;
  126|      2|        }
  127|      2|        *guard = Some(thread_id);
  128|  4.74k|    }
  129|  4.74k|    false
  130|  4.74k|}
  131|       |
  132|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  133|      2|fn force_mermaid_runtime_error_once() {
  134|      2|    let mut guard = FORCE_MERMAID_RUNTIME_ERROR
  135|      2|        .lock()
  136|      2|        .expect("mermaid runtime error lock");
  137|      2|    *guard = Some(std::thread::current().id());
  138|      2|}
  139|       |
  140|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  141|      1|fn force_mermaid_context_error_once() {
  142|      1|    let mut guard = FORCE_MERMAID_CONTEXT_ERROR
  143|      1|        .lock()
  144|      1|        .expect("mermaid context error lock");
  145|      1|    *guard = Some(std::thread::current().id());
  146|      1|}
  147|       |
  148|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  149|      1|fn force_mermaid_utf8_error_once() {
  150|      1|    let mut guard = FORCE_MERMAID_UTF8_ERROR
  151|      1|        .lock()
  152|      1|        .expect("mermaid utf8 error lock");
  153|      1|    *guard = Some(std::thread::current().id());
  154|      1|}
  155|       |
  156|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  157|      1|fn force_mermaid_render_eval_error_once() {
  158|      1|    let mut guard = FORCE_MERMAID_RENDER_EVAL_ERROR
  159|      1|        .lock()
  160|      1|        .expect("mermaid render eval error lock");
  161|      1|    *guard = Some(std::thread::current().id());
  162|      1|}
  163|       |
  164|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  165|      1|fn force_mermaid_render_call_error_once() {
  166|      1|    let mut guard = FORCE_MERMAID_RENDER_CALL_ERROR
  167|      1|        .lock()
  168|      1|        .expect("mermaid render call error lock");
  169|      1|    *guard = Some(std::thread::current().id());
  170|      1|}
  171|       |
  172|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  173|      1|fn force_mermaid_pixmap_alloc_fail_once() {
  174|      1|    let mut guard = FORCE_MERMAID_PIXMAP_ALLOC_FAIL
  175|      1|        .lock()
  176|      1|        .expect("mermaid pixmap fail lock");
  177|      1|    *guard = Some(std::thread::current().id());
  178|      1|}
  179|       |
  180|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  181|      1|fn force_mermaid_face_parse_error_once() {
  182|      1|    let mut guard = FORCE_MERMAID_FACE_PARSE_ERROR
  183|      1|        .lock()
  184|      1|        .expect("mermaid face parse error lock");
  185|      1|    *guard = Some(std::thread::current().id());
  186|      1|}
  187|       |
  188|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  189|  7.75k|fn maybe_force_mermaid_init_error<T>(
  190|  7.75k|    stage: usize,
  191|  7.75k|    result: rquickjs::Result<T>,
  192|  7.75k|) -> rquickjs::Result<T> {
  193|  7.75k|    if let Ok(mut guard) = FORCE_MERMAID_INIT_ERROR_STAGE.try_lock() {
                            ^7.75k
  194|  7.75k|        if let Some((thread_id, target_stage)) = guard.take() {
                                   ^121       ^121
  195|    121|            if thread_id == std::thread::current().id() && target_stage == stage {
                                                                         ^15
  196|      5|                return Err(rquickjs::Error::Exception);
  197|    116|            }
  198|    116|            *guard = Some((thread_id, target_stage));
  199|  7.63k|        }
  200|      2|    }
  201|  7.75k|    result
  202|  7.75k|}
  203|       |
  204|       |#[cfg(not(all(test, feature = "mermaid-quickjs")))]
  205|       |fn maybe_force_mermaid_init_error<T>(
  206|       |    _stage: usize,
  207|       |    result: rquickjs::Result<T>,
  208|       |) -> rquickjs::Result<T> {
  209|       |    result
  210|       |}
  211|       |
  212|       |#[cfg(feature = "mermaid-quickjs")]
  213|  1.55k|fn runtime_new_for_test() -> rquickjs::Result<rquickjs::Runtime> {
  214|       |    #[cfg(all(test, feature = "mermaid-quickjs"))]
  215|  1.55k|    if take_mermaid_flag(&FORCE_MERMAID_RUNTIME_ERROR) {
  216|      1|        return Err(rquickjs::Error::Exception);
  217|  1.55k|    }
  218|  1.55k|    rquickjs::Runtime::new()
  219|  1.55k|}
  220|       |
  221|       |#[cfg(feature = "mermaid-quickjs")]
  222|  1.55k|fn context_full_for_test(rt: &rquickjs::Runtime) -> rquickjs::Result<rquickjs::Context> {
  223|       |    #[cfg(all(test, feature = "mermaid-quickjs"))]
  224|  1.55k|    if take_mermaid_flag(&FORCE_MERMAID_CONTEXT_ERROR) {
  225|      1|        return Err(rquickjs::Error::Exception);
  226|  1.55k|    }
  227|  1.55k|    rquickjs::Context::full(rt)
  228|  1.55k|}
  229|       |
  230|       |#[cfg(feature = "mermaid-quickjs")]
  231|  1.55k|fn mermaid_js_str_for_test() -> Result<&'static str, std::str::Utf8Error> {
  232|       |    #[cfg(all(test, feature = "mermaid-quickjs"))]
  233|  1.55k|    if take_mermaid_flag(&FORCE_MERMAID_UTF8_ERROR) {
  234|       |        #[allow(invalid_from_utf8)]
  235|       |        {
  236|       |            static INVALID_UTF8: [u8; 1] = [0xFF];
  237|      1|            return std::str::from_utf8(&INVALID_UTF8);
  238|       |        }
  239|  1.55k|    }
  240|  1.55k|    std::str::from_utf8(mermaid_embed::MERMAID_JS)
  241|  1.55k|}
  242|       |
  243|       |#[cfg(feature = "mermaid-quickjs")]
  244|     40|fn face_parse_for_test(data: &[u8], index: u32) -> Option<ttf_parser::Face<'_>> {
  245|       |    #[cfg(all(test, feature = "mermaid-quickjs"))]
  246|     40|    if take_mermaid_flag(&FORCE_MERMAID_FACE_PARSE_ERROR) {
  247|      1|        return None;
  248|     39|    }
  249|     39|    ttf_parser::Face::parse(data, index).ok()
  250|     40|}
  251|       |
  252|       |#[cfg(feature = "mermaid-quickjs")]
  253|     12|fn eval_mermaid_wrapper<'js>(
  254|     12|    ctx: &rquickjs::Ctx<'js>,
  255|     12|    wrapper: &str,
  256|     12|) -> rquickjs::Result<rquickjs::Function<'js>> {
  257|       |    #[cfg(all(test, feature = "mermaid-quickjs"))]
  258|     12|    if take_mermaid_flag(&FORCE_MERMAID_RENDER_EVAL_ERROR) {
  259|      1|        return Err(rquickjs::Error::Exception);
  260|     11|    }
  261|     11|    ctx.eval(wrapper)
  262|     12|}
  263|       |
  264|       |#[cfg(feature = "mermaid-quickjs")]
  265|     11|fn call_mermaid_render<'js>(
  266|     11|    func: &rquickjs::Function<'js>,
  267|     11|    args: (
  268|     11|        &str,
  269|     11|        &str,
  270|     11|        &str,
  271|     11|        u32,
  272|     11|        u32,
  273|     11|    ),
  274|     11|) -> rquickjs::Result<rquickjs::promise::MaybePromise<'js>> {
  275|       |    #[cfg(all(test, feature = "mermaid-quickjs"))]
  276|     11|    if take_mermaid_flag(&FORCE_MERMAID_RENDER_CALL_ERROR) {
  277|      1|        return Err(rquickjs::Error::Exception);
  278|     10|    }
  279|     10|    func.call(args)
  280|     11|}
  281|       |
  282|       |#[cfg(feature = "mermaid-quickjs")]
  283|     20|fn pixmap_new_for_test(width: u32, height: u32) -> Option<tiny_skia::Pixmap> {
  284|       |    #[cfg(all(test, feature = "mermaid-quickjs"))]
  285|     20|    if take_mermaid_flag(&FORCE_MERMAID_PIXMAP_ALLOC_FAIL) {
  286|      1|        return None;
  287|     19|    }
  288|     19|    tiny_skia::Pixmap::new(width, height)
  289|     20|}
  290|       |
  291|       |#[cfg(feature = "mermaid-quickjs")]
  292|       |struct MermaidEngine {
  293|       |    #[allow(dead_code)]
  294|       |    rt: rquickjs::Runtime,
  295|       |    ctx: rquickjs::Context,
  296|       |}
  297|       |
  298|       |#[cfg(feature = "mermaid-quickjs")]
  299|       |type MermaidJobSender = Sender<MermaidRequest>;
  300|       |#[cfg(feature = "mermaid-quickjs")]
  301|       |type MermaidJobReceiver = Receiver<MermaidRequest>;
  302|       |#[cfg(feature = "mermaid-quickjs")]
  303|       |type MermaidResultSender = Sender<MermaidResult>;
  304|       |#[cfg(feature = "mermaid-quickjs")]
  305|       |type MermaidResultReceiver = Receiver<MermaidResult>;
  306|       |
  307|       |#[cfg(feature = "mermaid-quickjs")]
  308|       |#[derive(Clone)]
  309|       |struct MermaidTextureEntry {
  310|       |    texture: egui::TextureHandle,
  311|       |    size: [u32; 2],
  312|       |}
  313|       |
  314|       |#[cfg(any(test, feature = "mermaid-quickjs"))]
  315|       |struct LruCache<K, V> {
  316|       |    entries: HashMap<K, V>,
  317|       |    order: VecDeque<K>,
  318|       |    capacity: usize,
  319|       |}
  320|       |
  321|       |#[cfg(any(test, feature = "mermaid-quickjs"))]
  322|       |impl<K, V> LruCache<K, V>
  323|       |where
  324|       |    K: Eq + std::hash::Hash + Clone,
  325|       |    V: Clone,
  326|       |{
  327|  1.57k|    fn new(capacity: usize) -> Self {
  328|  1.57k|        Self {
  329|  1.57k|            entries: HashMap::new(),
  330|  1.57k|            order: VecDeque::new(),
  331|  1.57k|            capacity: capacity.max(1),
  332|  1.57k|        }
  333|  1.57k|    }
  334|       |
  335|       |    #[cfg_attr(test, inline(never))]
  336|     74|    fn get(&mut self, key: &K) -> Option<V> {
  337|     74|        let value = self.entries.get(key).cloned();
  338|     74|        self.touch_if_present(&value, key);
  339|     74|        value
  340|     74|    }
  341|       |
  342|       |    #[cfg_attr(test, inline(never))]
  343|     56|    fn insert(&mut self, key: K, value: V) {
  344|     56|        if self.entries.contains_key(&key) {
  345|      6|            self.entries.insert(key.clone(), value);
  346|      6|            self.touch(&key);
  347|      6|            return;
  348|     50|        }
  349|     58|        while self.entries.len() >= self.capacity {
  350|     15|            if !self.evict_oldest() {
  351|      7|                break;
  352|      8|            }
  353|       |        }
  354|     50|        self.order.push_back(key.clone());
  355|     50|        self.entries.insert(key, value);
  356|     56|    }
  357|       |
  358|       |    #[cfg(feature = "mermaid-quickjs")]
  359|      4|    fn remove(&mut self, key: &K) {
  360|      4|        self.entries.remove(key);
  361|      4|        self.order.retain(|entry| entry != key);
                                                ^3       ^3
  362|      4|    }
  363|       |
  364|       |    #[cfg(test)]
  365|      7|    fn len(&self) -> usize {
  366|      7|        self.entries.len()
  367|      7|    }
  368|       |
  369|       |    #[cfg_attr(test, inline(never))]
  370|     82|    fn touch_if_present(&mut self, value: &Option<V>, key: &K) {
  371|     82|        if value.is_some() {
  372|     24|            self.touch(key);
  373|     58|        }
  374|     82|    }
  375|       |
  376|       |    #[cfg_attr(test, inline(never))]
  377|     23|    fn evict_oldest(&mut self) -> bool {
  378|     23|        if let Some(old) = self.order.pop_front() {
                                  ^12
  379|     12|            self.entries.remove(&old);
  380|     12|            true
  381|       |        } else {
  382|     11|            false
  383|       |        }
  384|     23|    }
  385|       |
  386|     30|    fn touch(&mut self, key: &K) {
  387|     31|        self.order.retain(|entry| entry != key);
                      ^30        ^30
  388|     30|        self.order.push_back(key.clone());
  389|     30|    }
  390|       |}
  391|       |
  392|       |#[cfg(feature = "mermaid-quickjs")]
  393|       |struct MermaidRequest {
  394|       |    svg_key: u64,
  395|       |    texture_key: String,
  396|       |    code: Option<String>,
  397|       |    svg: Option<String>,
  398|       |    width_bucket: u32,
  399|       |    scale_bucket: u32,
  400|       |    viewport_width: u32,
  401|       |    viewport_height: u32,
  402|       |    bg: Option<[u8; 4]>,
  403|       |}
  404|       |
  405|       |#[cfg(feature = "mermaid-quickjs")]
  406|       |struct MermaidResult {
  407|       |    svg_key: u64,
  408|       |    texture_key: String,
  409|       |    svg: Option<String>,
  410|       |    rgba: Option<Vec<u8>>,
  411|       |    size: Option<(u32, u32)>,
  412|       |    error: Option<String>,
  413|       |}
  414|       |
  415|       |#[cfg(feature = "mermaid-quickjs")]
  416|       |#[derive(Debug, PartialEq, Eq)]
  417|       |enum MermaidEnqueueError {
  418|       |    QueueFull,
  419|       |    Disconnected,
  420|       |}
  421|       |
  422|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
  423|       |enum MermaidRenderPreference {
  424|       |    Embedded,
  425|       |    Off,
  426|       |}
  427|       |
  428|       |#[cfg(feature = "mermaid-quickjs")]
  429|       |struct MermaidThemeValues {
  430|       |    theme_name: String,
  431|       |    main_bkg: String,
  432|       |    primary: String,
  433|       |    primary_border: String,
  434|       |    primary_text: String,
  435|       |    secondary: String,
  436|       |    tertiary: String,
  437|       |    line: String,
  438|       |    text: String,
  439|       |    cluster_bkg: String,
  440|       |    cluster_border: String,
  441|       |    default_link: String,
  442|       |    title: String,
  443|       |    label_bg: String,
  444|       |    edge_label_bg: String,
  445|       |    font_family: Option<String>,
  446|       |}
  447|       |
  448|       |pub(crate) struct MermaidRenderer {
  449|       |    #[cfg(feature = "mermaid-quickjs")]
  450|       |    mermaid_textures: RefCell<LruCache<String, MermaidTextureEntry>>,
  451|       |    #[cfg(feature = "mermaid-quickjs")]
  452|       |    mermaid_pending: RefCell<HashSet<String>>,
  453|       |    #[cfg(feature = "mermaid-quickjs")]
  454|       |    mermaid_frame_pending: Cell<bool>,
  455|       |    #[cfg(feature = "mermaid-quickjs")]
  456|       |    mermaid_svg_cache: RefCell<LruCache<u64, String>>,
  457|       |    #[cfg(feature = "mermaid-quickjs")]
  458|       |    mermaid_errors: RefCell<LruCache<u64, String>>,
  459|       |    #[cfg(feature = "mermaid-quickjs")]
  460|       |    mermaid_texture_errors: RefCell<LruCache<String, String>>,
  461|       |    /// Job sender wrapped in Option so Drop can take and drop it first,
  462|       |    /// closing the channel before joining worker threads.
  463|       |    #[cfg(feature = "mermaid-quickjs")]
  464|       |    mermaid_job_tx: Option<MermaidJobSender>,
  465|       |    #[cfg(feature = "mermaid-quickjs")]
  466|       |    mermaid_result_rx: MermaidResultReceiver,
  467|       |    /// Worker thread handles for cleanup on drop.
  468|       |    /// When MermaidRenderer is dropped, we join all worker threads to ensure
  469|       |    /// they exit cleanly and release memory (font database, QuickJS runtime).
  470|       |    #[cfg(feature = "mermaid-quickjs")]
  471|       |    worker_handles: Vec<JoinHandle<()>>,
  472|       |}
  473|       |
  474|       |impl MermaidRenderer {
  475|       |    #[cfg(feature = "mermaid-quickjs")]
  476|       |    const MERMAID_TEXTURE_CACHE_CAPACITY: usize = 128;
  477|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  478|       |    const MERMAID_WIDTH_BUCKET_STEP: u32 = 32;
  479|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  480|       |    const MERMAID_SCALE_BUCKET_FACTOR: f32 = 100.0;
  481|       |    #[cfg(feature = "mermaid-quickjs")]
  482|       |    const MAX_MERMAID_JOBS: usize = 4;
  483|       |    #[cfg(feature = "mermaid-quickjs")]
  484|       |    const MERMAID_SVG_CACHE_CAPACITY: usize = 64;
  485|       |    #[cfg(feature = "mermaid-quickjs")]
  486|       |    const MERMAID_ERROR_CACHE_CAPACITY: usize = 64;
  487|       |    #[cfg(feature = "mermaid-quickjs")]
  488|       |    const MERMAID_TEXTURE_ERROR_CACHE_CAPACITY: usize = 64;
  489|       |    #[cfg(feature = "mermaid-quickjs")]
  490|       |    const MERMAID_MAX_TEXT_SIZE: u32 = 50_000;
  491|       |    #[cfg(feature = "mermaid-quickjs")]
  492|       |    const MERMAID_MAX_RENDER_SIDE: u32 = 4096;
  493|       |    /// Minimum height for Mermaid placeholder to reduce layout shift when diagrams render.
  494|       |    /// Most Mermaid diagrams are 150-400px tall; using 200px as a reasonable middle ground.
  495|       |    #[cfg(feature = "mermaid-quickjs")]
  496|       |    const MERMAID_PLACEHOLDER_MIN_HEIGHT: f32 = 200.0;
  497|       |
  498|    381|    pub(crate) fn new() -> Self {
  499|       |        #[cfg(feature = "mermaid-quickjs")]
  500|    381|        let (mermaid_job_tx, mermaid_job_rx): (MermaidJobSender, MermaidJobReceiver) =
  501|    381|            bounded(Self::MAX_MERMAID_JOBS * 4);
  502|       |        #[cfg(feature = "mermaid-quickjs")]
  503|    381|        let (mermaid_result_tx, mermaid_result_rx): (
  504|    381|            MermaidResultSender,
  505|    381|            MermaidResultReceiver,
  506|    381|        ) = bounded(Self::MAX_MERMAID_JOBS * 4);
  507|       |        #[cfg(feature = "mermaid-quickjs")]
  508|    381|        let worker_handles = Self::spawn_mermaid_workers(mermaid_job_rx, mermaid_result_tx);
  509|    381|        Self {
  510|    381|            #[cfg(feature = "mermaid-quickjs")]
  511|    381|            mermaid_textures: RefCell::new(LruCache::new(Self::MERMAID_TEXTURE_CACHE_CAPACITY)),
  512|    381|            #[cfg(feature = "mermaid-quickjs")]
  513|    381|            mermaid_pending: RefCell::new(HashSet::new()),
  514|    381|            #[cfg(feature = "mermaid-quickjs")]
  515|    381|            mermaid_frame_pending: Cell::new(false),
  516|    381|            #[cfg(feature = "mermaid-quickjs")]
  517|    381|            mermaid_svg_cache: RefCell::new(LruCache::new(Self::MERMAID_SVG_CACHE_CAPACITY)),
  518|    381|            #[cfg(feature = "mermaid-quickjs")]
  519|    381|            mermaid_errors: RefCell::new(LruCache::new(Self::MERMAID_ERROR_CACHE_CAPACITY)),
  520|    381|            #[cfg(feature = "mermaid-quickjs")]
  521|    381|            mermaid_texture_errors: RefCell::new(LruCache::new(
  522|    381|                Self::MERMAID_TEXTURE_ERROR_CACHE_CAPACITY,
  523|    381|            )),
  524|    381|            #[cfg(feature = "mermaid-quickjs")]
  525|    381|            mermaid_job_tx: Some(mermaid_job_tx),
  526|    381|            #[cfg(feature = "mermaid-quickjs")]
  527|    381|            mermaid_result_rx,
  528|    381|            #[cfg(feature = "mermaid-quickjs")]
  529|    381|            worker_handles,
  530|    381|        }
  531|    381|    }
  532|       |
  533|      6|    fn default_mermaid_preference() -> MermaidRenderPreference {
  534|       |        #[cfg(feature = "mermaid-quickjs")]
  535|       |        {
  536|      6|            MermaidRenderPreference::Embedded
  537|       |        }
  538|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  539|       |        {
  540|       |            MermaidRenderPreference::Off
  541|       |        }
  542|      6|    }
  543|       |
  544|     20|    fn mermaid_renderer_preference() -> (MermaidRenderPreference, bool) {
  545|     20|        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_RENDERER") {
                                ^15
  546|     15|            let normalized = raw.trim().to_ascii_lowercase();
  547|     15|            return match normalized.as_str() {
  548|     15|                "off" => (MermaidRenderPreference::Off, true),
                                       ^3
  549|     12|                "embedded" => (MermaidRenderPreference::Embedded, true),
                                            ^11
  550|      1|                _ => (Self::default_mermaid_preference(), false),
  551|       |            };
  552|      5|        }
  553|      5|        (Self::default_mermaid_preference(), false)
  554|     20|    }
  555|       |
  556|     13|    pub(crate) fn has_pending(&self) -> bool {
  557|       |        #[cfg(feature = "mermaid-quickjs")]
  558|       |        {
  559|     13|            return self.mermaid_frame_pending.get() || !self.mermaid_pending.borrow().is_empty();
                                                                     ^11
  560|       |        }
  561|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  562|       |        {
  563|       |            false
  564|       |        }
  565|     13|    }
  566|       |
  567|     24|    pub(crate) fn begin_frame(&self) {
  568|       |        #[cfg(feature = "mermaid-quickjs")]
  569|     24|        self.mermaid_frame_pending.set(false);
  570|     24|    }
  571|       |
  572|     16|    pub(crate) fn render_block(
  573|     16|        &self,
  574|     16|        ui: &mut egui::Ui,
  575|     16|        code: &str,
  576|     16|        ui_scale: f32,
  577|     16|        code_font_size: f32,
  578|     16|    ) -> bool {
  579|     16|        let (preference, _explicit) = Self::mermaid_renderer_preference();
  580|       |
  581|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  582|       |        {
  583|       |            let _ = code;
  584|       |            let _ = ui_scale;
  585|       |        }
  586|       |
  587|     16|        if preference == MermaidRenderPreference::Off {
  588|      2|            egui::Frame::none()
  589|      2|                .fill(Color32::from_rgb(25, 25, 25))
  590|      2|                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  591|      2|                .inner_margin(8.0)
  592|      2|                .show(ui, |ui| {
  593|      2|                    ui.label(
  594|      2|                        RichText::new(
  595|       |                            "Mermaid rendering is disabled. Set MDMDVIEW_MERMAID_RENDERER=embedded to enable.",
  596|       |                        )
  597|      2|                        .color(Color32::from_rgb(200, 160, 80))
  598|      2|                        .family(egui::FontFamily::Monospace)
  599|      2|                        .size(code_font_size),
  600|       |                    );
  601|      2|                    ui.add_space(6.0);
  602|      2|                    ui.label(
  603|      2|                        RichText::new(code)
  604|      2|                            .family(egui::FontFamily::Monospace)
  605|      2|                            .size(code_font_size)
  606|      2|                            .color(Color32::from_rgb(180, 180, 180)),
  607|       |                    );
  608|      2|                });
  609|      2|            return true;
  610|     14|        }
  611|       |
  612|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  613|       |        if _explicit && preference == MermaidRenderPreference::Embedded {
  614|       |            egui::Frame::none()
  615|       |                .fill(Color32::from_rgb(25, 25, 25))
  616|       |                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  617|       |                .inner_margin(8.0)
  618|       |                .show(ui, |ui| {
  619|       |                    ui.label(
  620|       |                        RichText::new(
  621|       |                            "Mermaid rendering via embedded JS is unavailable (feature not enabled).",
  622|       |                        )
  623|       |                        .color(Color32::from_rgb(200, 160, 80))
  624|       |                        .family(egui::FontFamily::Monospace)
  625|       |                        .size(code_font_size),
  626|       |                    );
  627|       |                    ui.add_space(6.0);
  628|       |                    ui.label(
  629|       |                        RichText::new(code)
  630|       |                            .family(egui::FontFamily::Monospace)
  631|       |                            .size(code_font_size)
  632|       |                            .color(Color32::from_rgb(180, 180, 180)),
  633|       |                    );
  634|       |                });
  635|       |            return true;
  636|       |        }
  637|       |
  638|       |        #[cfg(feature = "mermaid-quickjs")]
  639|       |        {
  640|     14|            if mermaid_js_empty() {
  641|      1|                egui::Frame::none()
  642|      1|                    .fill(Color32::from_rgb(25, 25, 25))
  643|      1|                    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  644|      1|                    .inner_margin(8.0)
  645|      1|                    .show(ui, |ui| {
  646|      1|                        ui.label(
  647|      1|                            RichText::new(
  648|       |                                "Mermaid rendering is unavailable (embedded JS missing).",
  649|       |                            )
  650|      1|                            .color(Color32::from_rgb(200, 160, 80))
  651|      1|                            .family(egui::FontFamily::Monospace)
  652|      1|                            .size(code_font_size),
  653|       |                        );
  654|      1|                        ui.add_space(6.0);
  655|      1|                        ui.label(
  656|      1|                            RichText::new(code)
  657|      1|                                .family(egui::FontFamily::Monospace)
  658|      1|                                .size(code_font_size)
  659|      1|                                .color(Color32::from_rgb(180, 180, 180)),
  660|       |                        );
  661|      1|                    });
  662|      1|                return true;
  663|     13|            }
  664|     13|            let svg_key = Self::hash_str(code);
  665|     13|            let mut available_width = ui.available_width();
  666|     13|            let orig_available_width = available_width;
  667|     13|            if available_width <= Self::MERMAID_WIDTH_BUCKET_STEP as f32 {
  668|      4|                let fallback = ui.ctx().available_rect().width();
  669|      4|                if fallback > available_width {
  670|      3|                    available_width = fallback;
  671|      3|                }
                              ^1
  672|      9|            }
  673|     13|            if std::env::var("MDMDVIEW_MERMAID_LOG_WIDTH").is_ok() {
  674|      2|                eprintln!(
  675|      2|                    "Mermaid width: avail={:.2} fallback={:.2}",
  676|      2|                    orig_available_width, available_width
  677|      2|                );
  678|     11|            }
  679|     13|            let width_bucket = Self::width_bucket(available_width);
  680|     13|            let scale_bucket = Self::scale_bucket(ui_scale);
  681|     13|            let mut viewport_width = available_width.round().max(1.0) as u32;
  682|     13|            let mut viewport_height = ui
  683|     13|                .ctx()
  684|     13|                .input(|i| i.screen_rect().height())
  685|     13|                .round()
  686|     13|                .max(1.0) as u32;
  687|     13|            if let Some(kind) = Self::mermaid_diagram_kind(code) {
                                      ^11
  688|     11|                if kind == "timeline" {
  689|      2|                    viewport_width = viewport_width.min(1000);
  690|      2|                    viewport_height = viewport_height.min(700);
  691|      9|                }
  692|      2|            }
  693|     13|            let bg = Self::mermaid_bg_fill();
  694|     13|            let texture_key = Self::texture_key(svg_key, width_bucket, scale_bucket, bg);
  695|       |
  696|     13|            if self.poll_mermaid_results(ui.ctx()) {
  697|      1|                ui.ctx().request_repaint();
  698|     12|            }
  699|       |
  700|     13|            if let Some(entry) = self.mermaid_textures.borrow_mut().get(&texture_key) {
                                      ^2
  701|      2|                let (tw, th) = (entry.size[0] as f32, entry.size[1] as f32);
  702|      2|                let available_w = ui.available_width().max(1.0);
  703|      2|                let scale = if tw > available_w {
  704|      1|                    (available_w / tw).clamp(0.01, 4.0)
  705|       |                } else {
  706|      1|                    1.0
  707|       |                };
  708|      2|                let size = egui::vec2((tw * scale).round(), (th * scale).round());
  709|      2|                ui.add(egui::Image::new(&entry.texture).fit_to_exact_size(size));
  710|      2|                return true;
  711|     11|            }
  712|       |
  713|     11|            let svg_error = self.mermaid_errors.borrow_mut().get(&svg_key);
  714|     11|            let texture_error = self.mermaid_texture_errors.borrow_mut().get(&texture_key);
  715|     11|            if let Some(err) = svg_error.or(texture_error) {
                                      ^1
  716|      1|                egui::Frame::none()
  717|      1|                    .fill(Color32::from_rgb(25, 25, 25))
  718|      1|                    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  719|      1|                    .inner_margin(8.0)
  720|      1|                    .show(ui, |ui| {
  721|      1|                        ui.label(
  722|      1|                            RichText::new("Mermaid render failed; showing source.")
  723|      1|                                .color(Color32::from_rgb(200, 160, 80)),
  724|       |                        );
  725|      1|                        ui.label(
  726|      1|                            RichText::new(format!(
  727|      1|                                "Embedded bytes:{}\nHash:{:016x}\nError:{}",
  728|      1|                                mermaid_embed::MERMAID_JS.len(),
  729|       |                                svg_key,
  730|       |                                err
  731|       |                            ))
  732|      1|                            .family(egui::FontFamily::Monospace)
  733|      1|                            .size(code_font_size)
  734|      1|                            .color(Color32::from_rgb(180, 180, 180)),
  735|       |                        );
  736|      1|                        ui.add_space(6.0);
  737|      1|                        ui.label(
  738|      1|                            RichText::new(code)
  739|      1|                                .family(egui::FontFamily::Monospace)
  740|      1|                                .size(code_font_size)
  741|      1|                                .color(Color32::from_rgb(180, 180, 180)),
  742|       |                        );
  743|      1|                    });
  744|      1|                return true;
  745|     10|            }
  746|     10|            let svg = self.mermaid_svg_cache.borrow_mut().get(&svg_key);
  747|     10|            let pending = self.mermaid_pending.borrow().contains(&texture_key);
  748|     10|            let mut waiting_for_slot = false;
  749|       |
  750|     10|            if !pending {
  751|      9|                let (request_code, request_svg) = match svg {
  752|      1|                    Some(svg) => (None, Some(svg)),
  753|      8|                    None => (Some(code.to_string()), None),
  754|       |                };
  755|      9|                let request = MermaidRequest {
  756|      9|                    svg_key,
  757|      9|                    texture_key: texture_key.clone(),
  758|      9|                    code: request_code,
  759|      9|                    svg: request_svg,
  760|      9|                    width_bucket,
  761|      9|                    scale_bucket,
  762|      9|                    viewport_width,
  763|      9|                    viewport_height,
  764|      9|                    bg,
  765|      9|                };
  766|      9|                match self.enqueue_mermaid_job(request) {
  767|      7|                    Ok(()) => {
  768|      7|                        self.mermaid_pending
  769|      7|                            .borrow_mut()
  770|      7|                            .insert(texture_key.clone());
  771|      7|                        ui.ctx().request_repaint();
  772|      7|                    }
  773|      1|                    Err(MermaidEnqueueError::QueueFull) => {
  774|      1|                        waiting_for_slot = true;
  775|      1|                        ui.ctx().request_repaint();
  776|      1|                    }
  777|       |                    Err(MermaidEnqueueError::Disconnected) => {
  778|      1|                        self.mermaid_errors
  779|      1|                            .borrow_mut()
  780|      1|                            .insert(svg_key, "Mermaid worker pool unavailable".to_string());
  781|      1|                        egui::Frame::none()
  782|      1|                            .fill(Color32::from_rgb(25, 25, 25))
  783|      1|                            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  784|      1|                            .inner_margin(8.0)
  785|      1|                            .show(ui, |ui| {
  786|      1|                                ui.label(
  787|      1|                                    RichText::new("Mermaid worker pool unavailable.")
  788|      1|                                        .color(Color32::from_rgb(200, 160, 80))
  789|      1|                                        .family(egui::FontFamily::Monospace)
  790|      1|                                        .size(code_font_size),
  791|       |                                );
  792|      1|                                ui.add_space(6.0);
  793|      1|                                ui.label(
  794|      1|                                    RichText::new(code)
  795|      1|                                        .family(egui::FontFamily::Monospace)
  796|      1|                                        .size(code_font_size)
  797|      1|                                        .color(Color32::from_rgb(180, 180, 180)),
  798|       |                                );
  799|      1|                            });
  800|      1|                        return true;
  801|       |                    }
  802|       |                }
  803|      1|            }
  804|       |
  805|      9|            let inflight = self.mermaid_pending.borrow().len();
  806|      9|            self.mermaid_frame_pending.set(true);
  807|      9|            egui::Frame::none()
  808|      9|                .fill(Color32::from_rgb(25, 25, 25))
  809|      9|                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  810|      9|                .inner_margin(8.0)
  811|      9|                .show(ui, |ui| {
  812|       |                    // Reserve minimum height for placeholder to reduce layout shift
  813|       |                    // when the actual diagram renders. Most diagrams are 150-400px tall.
  814|      9|                    ui.set_min_height(Self::MERMAID_PLACEHOLDER_MIN_HEIGHT);
  815|      9|                    if waiting_for_slot {
  816|      1|                        ui.label(
  817|      1|                            RichText::new(format!(
  818|      1|                                "Mermaid workers busy ({}/{}) - request queued.",
  819|      1|                                inflight,
  820|      1|                                Self::MAX_MERMAID_JOBS
  821|      1|                            ))
  822|      1|                            .color(Color32::from_rgb(200, 160, 80))
  823|      1|                            .family(egui::FontFamily::Monospace)
  824|      1|                            .size(code_font_size),
  825|      1|                        );
  826|      8|                    } else {
  827|      8|                        ui.label(
  828|      8|                            RichText::new("Rendering diagram locally...")
  829|      8|                                .color(Color32::from_rgb(160, 200, 240)),
  830|      8|                        );
  831|      8|                    }
  832|      9|                });
  833|      9|            true
  834|       |        }
  835|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  836|       |        {
  837|       |            false
  838|       |        }
  839|     16|    }
  840|       |
  841|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  842|     18|    fn width_bucket(available_width: f32) -> u32 {
  843|     18|        let step = Self::MERMAID_WIDTH_BUCKET_STEP;
  844|     18|        let width = available_width.max(1.0).ceil() as u32;
  845|     18|        width.div_ceil(step) * step
  846|     18|    }
  847|       |
  848|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  849|     39|    fn scale_bucket(ui_scale: f32) -> u32 {
  850|     39|        let clamped = ui_scale.clamp(0.5, 4.0);
  851|     39|        (clamped * Self::MERMAID_SCALE_BUCKET_FACTOR).round() as u32
  852|     39|    }
  853|       |
  854|     15|    fn mermaid_diagram_kind(code: &str) -> Option<String> {
  855|     20|        for line in code.lines() {
                                  ^15  ^15
  856|     20|            let trimmed = line.trim();
  857|     20|            if trimmed.is_empty() {
  858|      3|                continue;
  859|     17|            }
  860|     17|            if trimmed.starts_with("%%") {
  861|      5|                continue;
  862|     12|            }
  863|     12|            return trimmed
  864|     12|                .split_whitespace()
  865|     12|                .next()
  866|     12|                .map(|token| token.to_ascii_lowercase());
  867|       |        }
  868|      3|        None
  869|     15|    }
  870|       |
  871|       |    #[cfg(feature = "mermaid-quickjs")]
  872|     20|    fn scale_from_bucket(scale_bucket: u32) -> f32 {
  873|     20|        let scale = scale_bucket as f32 / Self::MERMAID_SCALE_BUCKET_FACTOR;
  874|     20|        scale.clamp(0.5, 4.0)
  875|     20|    }
  876|       |
  877|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  878|     20|    fn mermaid_bg_key(bg: Option<[u8; 4]>) -> String {
  879|     20|        match bg {
  880|     19|            Some([r, g, b, a]) => format!("{:02x}{:02x}{:02x}{:02x}", r, g, b, a),
  881|      1|            None => "none".to_string(),
  882|       |        }
  883|     20|    }
  884|       |
  885|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  886|     18|    fn texture_key(
  887|     18|        svg_key: u64,
  888|     18|        width_bucket: u32,
  889|     18|        scale_bucket: u32,
  890|     18|        bg: Option<[u8; 4]>,
  891|     18|    ) -> String {
  892|     18|        let bg_key = Self::mermaid_bg_key(bg);
  893|     18|        format!(
  894|     18|            "mermaid:{:016x}:w{}:s{}:bg{}",
  895|       |            svg_key, width_bucket, scale_bucket, bg_key
  896|       |        )
  897|     18|    }
  898|       |
  899|       |    #[cfg(feature = "mermaid-quickjs")]
  900|     18|    fn poll_mermaid_results(&self, ctx: &egui::Context) -> bool {
  901|     18|        let mut changed = false;
  902|     24|        while let Ok(result) = self.mermaid_result_rx.try_recv() {
                                   ^6
  903|       |            let MermaidResult {
  904|      6|                svg_key,
  905|      6|                texture_key,
  906|      6|                svg,
  907|      6|                rgba,
  908|      6|                size,
  909|      6|                error,
  910|      6|            } = result;
  911|      6|            let has_svg = svg.is_some();
  912|      6|            self.mermaid_pending.borrow_mut().remove(&texture_key);
  913|       |
  914|      6|            if let Some(svg) = svg {
                                      ^3
  915|      3|                self.mermaid_svg_cache.borrow_mut().insert(svg_key, svg);
  916|      3|                self.mermaid_errors.borrow_mut().remove(&svg_key);
  917|      3|            }
  918|       |
  919|      6|            if let Some(rgba) = rgba {
                                      ^2
  920|      2|                if let Some((w, h)) = size {
                                           ^1 ^1
  921|      1|                    let img =
  922|      1|                        egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &rgba);
  923|      1|                    let tex =
  924|      1|                        ctx.load_texture(texture_key.clone(), img, egui::TextureOptions::LINEAR);
  925|      1|                    self.store_mermaid_texture(&texture_key, tex.clone(), [w, h]);
  926|      1|                    self.mermaid_texture_errors
  927|      1|                        .borrow_mut()
  928|      1|                        .remove(&texture_key);
  929|      1|                } else {
  930|      1|                    self.mermaid_texture_errors.borrow_mut().insert(
  931|      1|                        texture_key.clone(),
  932|      1|                        "Mermaid rasterization failed (missing size)".to_string(),
  933|      1|                    );
  934|      1|                }
  935|      4|            }
  936|       |
  937|      6|            if let Some(err) = error {
                                      ^2
  938|      2|                if !has_svg {
  939|      1|                    self.mermaid_errors.borrow_mut().insert(svg_key, err);
  940|      1|                } else {
  941|      1|                    self.mermaid_texture_errors
  942|      1|                        .borrow_mut()
  943|      1|                        .insert(texture_key, err);
  944|      1|                }
  945|      4|            }
  946|       |
  947|      6|            changed = true;
  948|       |        }
  949|     18|        changed
  950|     18|    }
  951|       |
  952|       |    #[cfg(feature = "mermaid-quickjs")]
  953|     10|    fn enqueue_mermaid_job(&self, request: MermaidRequest) -> Result<(), MermaidEnqueueError> {
  954|     10|        let Some(ref tx) = self.mermaid_job_tx else {
                               ^9
  955|      1|            return Err(MermaidEnqueueError::Disconnected);
  956|       |        };
  957|      9|        match tx.try_send(request) {
  958|      7|            Ok(()) => Ok(()),
  959|      1|            Err(TrySendError::Full(_)) => Err(MermaidEnqueueError::QueueFull),
  960|      1|            Err(TrySendError::Disconnected(_)) => Err(MermaidEnqueueError::Disconnected),
  961|       |        }
  962|     10|    }
  963|       |
  964|       |    #[cfg(feature = "mermaid-quickjs")]
  965|    386|    fn mermaid_worker_count() -> usize {
  966|    386|        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_WORKERS") {
                                ^5
  967|      5|            if let Ok(value) = raw.trim().parse::<usize>() {
                                    ^4
  968|      4|                return value.clamp(1, 16);
  969|      1|            }
  970|    381|        }
  971|    382|        let default = std::thread::available_parallelism()
  972|    382|            .map(|n| n.get())
  973|    382|            .unwrap_or(1);
  974|    382|        default.min(Self::MAX_MERMAID_JOBS.max(1))
  975|    386|    }
  976|       |
  977|       |    #[cfg(feature = "mermaid-quickjs")]
  978|     15|    fn mermaid_timeout_ms() -> u64 {
  979|     15|        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_TIMEOUT_MS") {
                                ^3
  980|      3|            if let Ok(value) = raw.trim().parse::<u64>() {
                                    ^2
  981|      2|                return value.max(100);
  982|      1|            }
  983|     12|        }
  984|     13|        30_000
  985|     15|    }
  986|       |
  987|       |    #[cfg(feature = "mermaid-quickjs")]
  988|  1.52k|    fn spawn_mermaid_worker_thread(
  989|  1.52k|        worker_idx: usize,
  990|  1.52k|        worker_rx: MermaidJobReceiver,
  991|  1.52k|        worker_tx: MermaidResultSender,
  992|  1.52k|        worker_fontdb: Arc<usvg::fontdb::Database>,
  993|  1.52k|    ) -> std::io::Result<JoinHandle<()>> {
  994|       |        #[cfg(test)]
  995|  1.52k|        if FORCE_MERMAID_THREAD_SPAWN_ERROR.swap(false, Ordering::Relaxed) {
  996|      1|            return Err(std::io::Error::new(
  997|      1|                std::io::ErrorKind::Other,
  998|      1|                "forced mermaid spawn error",
  999|      1|            ));
 1000|  1.52k|        }
 1001|  1.52k|        std::thread::Builder::new()
 1002|  1.52k|            .name(format!("mdmdview-mermaid-{worker_idx}"))
 1003|  1.52k|            .spawn(move || {
 1004|  1.52k|                let mut worker = MermaidWorker::new(worker_idx, worker_fontdb).map_err(|e| {
                                                                                                         ^1
 1005|      1|                    eprintln!("Mermaid worker init failed: {}", e);
 1006|      1|                    e
 1007|      1|                });
 1008|  1.52k|                for job in worker_rx.iter() {
                                  ^6
 1009|      6|                    let payload = match &mut worker {
 1010|      5|                        Ok(state) => state.process_job(job),
 1011|      1|                        Err(err) => {
 1012|       |                            let MermaidRequest {
 1013|      1|                                svg_key,
 1014|      1|                                texture_key,
 1015|      1|                                svg,
 1016|       |                                ..
 1017|      1|                            } = job;
 1018|      1|                            MermaidResult {
 1019|      1|                                svg_key,
 1020|      1|                                texture_key,
 1021|      1|                                svg,
 1022|      1|                                rgba: None,
 1023|      1|                                size: None,
 1024|      1|                                error: Some(err.clone()),
 1025|      1|                            }
 1026|       |                        }
 1027|       |                    };
 1028|      6|                    let _ = worker_tx.send(payload);
 1029|       |                }
 1030|  1.52k|            })
 1031|  1.52k|    }
 1032|       |
 1033|       |    #[cfg(feature = "mermaid-quickjs")]
 1034|    383|    fn spawn_mermaid_workers(
 1035|    383|        job_rx: MermaidJobReceiver,
 1036|    383|        result_tx: MermaidResultSender,
 1037|    383|    ) -> Vec<JoinHandle<()>> {
 1038|    383|        let worker_count = Self::mermaid_worker_count();
 1039|    383|        let mut fontdb = usvg::fontdb::Database::new();
 1040|    383|        fontdb.load_system_fonts();
 1041|    383|        let fontdb = Arc::new(fontdb);
 1042|    383|        let mut handles = Vec::with_capacity(worker_count);
 1043|  1.52k|        for worker_idx in 0..worker_count {
                                           ^383
 1044|  1.52k|            let worker_rx = job_rx.clone();
 1045|  1.52k|            let worker_tx = result_tx.clone();
 1046|  1.52k|            let worker_fontdb = Arc::clone(&fontdb);
 1047|  1.52k|            match Self::spawn_mermaid_worker_thread(worker_idx, worker_rx, worker_tx, worker_fontdb)
 1048|       |            {
 1049|  1.52k|                Ok(handle) => handles.push(handle),
 1050|      1|                Err(err) => eprintln!("Failed to start Mermaid worker thread: {}", err),
 1051|       |            }
 1052|       |        }
 1053|    383|        drop(job_rx);
 1054|    383|        handles
 1055|    383|    }
 1056|       |
 1057|       |    #[cfg(feature = "mermaid-quickjs")]
 1058|      1|    fn store_mermaid_texture(&self, key: &str, texture: egui::TextureHandle, size: [u32; 2]) {
 1059|      1|        self.mermaid_textures
 1060|      1|            .borrow_mut()
 1061|      1|            .insert(key.to_string(), MermaidTextureEntry { texture, size });
 1062|      1|    }
 1063|       |
 1064|       |    #[cfg(feature = "mermaid-quickjs")]
 1065|     21|    fn mermaid_theme_values() -> MermaidThemeValues {
 1066|     21|        let def_main_bkg = "#FFF8DB";
 1067|     21|        let def_primary = "#D7EEFF";
 1068|     21|        let def_primary_border = "#9BB2C8";
 1069|     21|        let def_primary_text = "#1C2430";
 1070|     21|        let def_secondary = "#DFF5E1";
 1071|     21|        let def_tertiary = "#E9E2FF";
 1072|     21|        let def_line = "#6B7A90";
 1073|     21|        let def_text = "#1C2430";
 1074|     21|        let def_cluster_bkg = "#FFF1C1";
 1075|     21|        let def_cluster_border = "#E5C07B";
 1076|     21|        let def_default_link = def_line;
 1077|     21|        let def_title = def_text;
 1078|     21|        let def_label_bg = def_main_bkg;
 1079|     21|        let def_edge_label_bg = def_main_bkg;
 1080|       |
 1081|     21|        let theme_name =
 1082|     21|            std::env::var("MDMDVIEW_MERMAID_THEME").unwrap_or_else(|_| "base".to_string());
 1083|     21|        let main_bkg =
 1084|     21|            std::env::var("MDMDVIEW_MERMAID_MAIN_BKG").unwrap_or_else(|_| def_main_bkg.to_string());
 1085|     21|        let primary = std::env::var("MDMDVIEW_MERMAID_PRIMARY_COLOR")
 1086|     21|            .unwrap_or_else(|_| def_primary.to_string());
 1087|     21|        let primary_border = std::env::var("MDMDVIEW_MERMAID_PRIMARY_BORDER")
 1088|     21|            .unwrap_or_else(|_| def_primary_border.to_string());
 1089|     21|        let primary_text = std::env::var("MDMDVIEW_MERMAID_PRIMARY_TEXT")
 1090|     21|            .unwrap_or_else(|_| def_primary_text.to_string());
 1091|     21|        let secondary = std::env::var("MDMDVIEW_MERMAID_SECONDARY_COLOR")
 1092|     21|            .unwrap_or_else(|_| def_secondary.to_string());
 1093|     21|        let tertiary = std::env::var("MDMDVIEW_MERMAID_TERTIARY_COLOR")
 1094|     21|            .unwrap_or_else(|_| def_tertiary.to_string());
 1095|     21|        let line =
 1096|     21|            std::env::var("MDMDVIEW_MERMAID_LINE_COLOR").unwrap_or_else(|_| def_line.to_string());
 1097|     21|        let text =
 1098|     21|            std::env::var("MDMDVIEW_MERMAID_TEXT_COLOR").unwrap_or_else(|_| def_text.to_string());
 1099|     21|        let cluster_bkg = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BKG")
 1100|     21|            .unwrap_or_else(|_| def_cluster_bkg.to_string());
 1101|     21|        let cluster_border = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BORDER")
 1102|     21|            .unwrap_or_else(|_| def_cluster_border.to_string());
 1103|     21|        let default_link = std::env::var("MDMDVIEW_MERMAID_LINK_COLOR")
 1104|     21|            .unwrap_or_else(|_| def_default_link.to_string());
 1105|     21|        let title =
 1106|     21|            std::env::var("MDMDVIEW_MERMAID_TITLE_COLOR").unwrap_or_else(|_| def_title.to_string());
 1107|     21|        let label_bg =
 1108|     21|            std::env::var("MDMDVIEW_MERMAID_LABEL_BG").unwrap_or_else(|_| def_label_bg.to_string());
 1109|     21|        let edge_label_bg = std::env::var("MDMDVIEW_MERMAID_EDGE_LABEL_BG")
 1110|     21|            .unwrap_or_else(|_| def_edge_label_bg.to_string());
 1111|     21|        let font_family = std::env::var("MDMDVIEW_MERMAID_FONT_FAMILY")
 1112|     21|            .ok()
 1113|     21|            .map(|value| value.trim().to_string())
                                       ^3           ^3
 1114|     21|            .filter(|value| !value.is_empty());
                                           ^3    ^3
 1115|       |
 1116|     21|        MermaidThemeValues {
 1117|     21|            theme_name,
 1118|     21|            main_bkg,
 1119|     21|            primary,
 1120|     21|            primary_border,
 1121|     21|            primary_text,
 1122|     21|            secondary,
 1123|     21|            tertiary,
 1124|     21|            line,
 1125|     21|            text,
 1126|     21|            cluster_bkg,
 1127|     21|            cluster_border,
 1128|     21|            default_link,
 1129|     21|            title,
 1130|     21|            label_bg,
 1131|     21|            edge_label_bg,
 1132|     21|            font_family,
 1133|     21|        }
 1134|     21|    }
 1135|       |
 1136|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
 1137|     17|    fn mermaid_security_level() -> String {
 1138|     17|        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_SECURITY") {
                                ^3
 1139|      3|            let normalized = raw.trim().to_ascii_lowercase();
 1140|      3|            if normalized == "loose" {
 1141|      2|                return "loose".to_string();
 1142|      1|            }
 1143|     14|        }
 1144|     15|        "strict".to_string()
 1145|     17|    }
 1146|       |
 1147|       |    #[cfg(feature = "mermaid-quickjs")]
 1148|     14|    fn mermaid_site_config_json(svg_key: u64) -> String {
 1149|     14|        let theme = Self::mermaid_theme_values();
 1150|     14|        let security = Self::mermaid_security_level();
 1151|     14|        let seed = format!("m{:016x}", svg_key);
 1152|     14|        let mut entries = Vec::new();
 1153|       |
 1154|     14|        entries.push("\"startOnLoad\":false".to_string());
 1155|     14|        entries.push(format!(
 1156|     14|            "\"securityLevel\":\"{}\"",
 1157|     14|            Self::json_escape(&security)
 1158|       |        ));
 1159|     14|        entries.push("\"deterministicIds\":true".to_string());
 1160|     14|        entries.push(format!(
 1161|     14|            "\"deterministicIDSeed\":\"{}\"",
 1162|     14|            Self::json_escape(&seed)
 1163|       |        ));
 1164|     14|        entries.push(format!("\"maxTextSize\":{}", Self::MERMAID_MAX_TEXT_SIZE));
 1165|     14|        if security == "strict" {
 1166|     13|            entries.push("\"htmlLabels\":false".to_string());
 1167|     13|            entries.push("\"flowchart\":{\"htmlLabels\":false}".to_string());
 1168|     13|        }
                      ^1
 1169|     14|        entries.push(format!(
 1170|     14|            "\"theme\":\"{}\"",
 1171|     14|            Self::json_escape(&theme.theme_name)
 1172|       |        ));
 1173|       |
 1174|     14|        let mut theme_vars = format!(
 1175|     14|            concat!(
 1176|       |                "\"background\":\"{}\",",
 1177|       |                "\"mainBkg\":\"{}\",",
 1178|       |                "\"textColor\":\"{}\",",
 1179|       |                "\"titleColor\":\"{}\",",
 1180|       |                "\"primaryColor\":\"{}\",",
 1181|       |                "\"primaryBorderColor\":\"{}\",",
 1182|       |                "\"primaryTextColor\":\"{}\",",
 1183|       |                "\"secondaryColor\":\"{}\",",
 1184|       |                "\"tertiaryColor\":\"{}\",",
 1185|       |                "\"lineColor\":\"{}\",",
 1186|       |                "\"defaultLinkColor\":\"{}\",",
 1187|       |                "\"clusterBkg\":\"{}\",",
 1188|       |                "\"clusterBorder\":\"{}\",",
 1189|       |                "\"labelBackground\":\"{}\",",
 1190|       |                "\"edgeLabelBackground\":\"{}\""
 1191|       |            ),
 1192|     14|            Self::json_escape(&theme.main_bkg),
 1193|     14|            Self::json_escape(&theme.main_bkg),
 1194|     14|            Self::json_escape(&theme.text),
 1195|     14|            Self::json_escape(&theme.title),
 1196|     14|            Self::json_escape(&theme.primary),
 1197|     14|            Self::json_escape(&theme.primary_border),
 1198|     14|            Self::json_escape(&theme.primary_text),
 1199|     14|            Self::json_escape(&theme.secondary),
 1200|     14|            Self::json_escape(&theme.tertiary),
 1201|     14|            Self::json_escape(&theme.line),
 1202|     14|            Self::json_escape(&theme.default_link),
 1203|     14|            Self::json_escape(&theme.cluster_bkg),
 1204|     14|            Self::json_escape(&theme.cluster_border),
 1205|     14|            Self::json_escape(&theme.label_bg),
 1206|     14|            Self::json_escape(&theme.edge_label_bg)
 1207|       |        );
 1208|     14|        if let Some(font_family) = theme.font_family.as_ref() {
                                  ^1
 1209|      1|            theme_vars.push_str(&format!(
 1210|      1|                ",\"fontFamily\":\"{}\"",
 1211|      1|                Self::json_escape(font_family)
 1212|      1|            ));
 1213|     13|        }
 1214|     14|        entries.push(format!("\"themeVariables\":{{{}}}", theme_vars));
 1215|       |
 1216|     14|        format!("{{{}}}", entries.join(","))
 1217|     14|    }
 1218|       |
 1219|       |    #[cfg(feature = "mermaid-quickjs")]
 1220|    254|    fn json_escape(input: &str) -> String {
 1221|    254|        let mut out = String::with_capacity(input.len());
 1222|  1.89k|        for ch in input.chars() {
                                ^254  ^254
 1223|  1.89k|            match ch {
 1224|      1|                '\\' => out.push_str("\\\\"),
 1225|      1|                '"' => out.push_str("\\\""),
 1226|      1|                '\n' => out.push_str("\\n"),
 1227|      1|                '\r' => out.push_str("\\r"),
 1228|      1|                '\t' => out.push_str("\\t"),
 1229|  1.89k|                _ => out.push(ch),
 1230|       |            }
 1231|       |        }
 1232|    254|        out
 1233|    254|    }
 1234|       |
 1235|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
 1236|     24|    fn mermaid_bg_fill() -> Option<[u8; 4]> {
 1237|     24|        if let Ok(hex) = std::env::var("MDMDVIEW_MERMAID_BG_COLOR") {
                                ^3
 1238|      3|            if let Some(rgba) = Self::parse_hex_color(&hex) {
                                      ^2
 1239|      2|                return Some(rgba);
 1240|      1|            }
 1241|     21|        }
 1242|     22|        let mode = std::env::var("MDMDVIEW_MERMAID_BG").unwrap_or_else(|_| "theme".to_string());
                                                                                         ^16     ^16
 1243|     22|        match mode.as_str() {
 1244|     22|            "transparent" => None,
                                           ^1
 1245|     21|            "dark" => Some([20, 20, 20, 255]),
                                    ^2
 1246|     19|            "light" => Some([255, 255, 255, 255]),
                                     ^1
 1247|       |            _ => {
 1248|     18|                let hex = std::env::var("MDMDVIEW_MERMAID_MAIN_BKG")
 1249|     18|                    .unwrap_or_else(|_| "#FFF8DB".to_string());
                                                      ^16       ^16
 1250|     18|                Self::parse_hex_color(&hex).or(Some([255, 248, 219, 255]))
 1251|       |            }
 1252|       |        }
 1253|     24|    }
 1254|       |
 1255|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
 1256|     31|    fn parse_hex_color(s: &str) -> Option<[u8; 4]> {
 1257|     31|        let t = s.trim();
 1258|     31|        let hex = t.strip_prefix('#').unwrap_or(t);
 1259|     31|        let (r, g, b, a) = match hex.len() {
                           ^21^21^21^21
 1260|       |            6 => (
 1261|     22|                u8::from_str_radix(&hex[0..2], 16).ok()?,
                                                                     ^1
 1262|     21|                u8::from_str_radix(&hex[2..4], 16).ok()?,
                                                                     ^1
 1263|     20|                u8::from_str_radix(&hex[4..6], 16).ok()?,
                                                                     ^1
 1264|       |                255,
 1265|       |            ),
 1266|       |            8 => (
 1267|      6|                u8::from_str_radix(&hex[0..2], 16).ok()?,
                                                                     ^1
 1268|      5|                u8::from_str_radix(&hex[2..4], 16).ok()?,
                                                                     ^1
 1269|      4|                u8::from_str_radix(&hex[4..6], 16).ok()?,
                                                                     ^1
 1270|      3|                u8::from_str_radix(&hex[6..8], 16).ok()?,
                                                                     ^1
 1271|       |            ),
 1272|      3|            _ => return None,
 1273|       |        };
 1274|     21|        Some([r, g, b, a])
 1275|     31|    }
 1276|       |
 1277|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
 1278|     25|    fn hash_str(s: &str) -> u64 {
 1279|     25|        let mut h = DefaultHasher::new();
 1280|     25|        s.hash(&mut h);
 1281|     25|        h.finish()
 1282|     25|    }
 1283|       |}
 1284|       |
 1285|       |#[cfg(feature = "mermaid-quickjs")]
 1286|       |impl Drop for MermaidRenderer {
 1287|    390|    fn drop(&mut self) {
 1288|       |        // First, drop the job sender to close the channel.
 1289|       |        // This signals workers to exit their `for job in worker_rx.iter()` loop.
 1290|    390|        drop(self.mermaid_job_tx.take());
 1291|       |
 1292|       |        // Now join all worker threads to ensure they've fully exited
 1293|       |        // and released their resources (font database, QuickJS runtime).
 1294|  1.52k|        for handle in self.worker_handles.drain(..) {
                                    ^390                ^390  ^390
 1295|  1.52k|            let _ = handle.join();
 1296|  1.52k|        }
 1297|    390|    }
 1298|       |}
 1299|       |
 1300|       |#[cfg(feature = "mermaid-quickjs")]
 1301|       |struct TextMeasurer {
 1302|       |    fontdb: Arc<usvg::fontdb::Database>,
 1303|       |    face_id: Option<usvg::fontdb::ID>,
 1304|       |    bold_face_id: Option<usvg::fontdb::ID>,
 1305|       |}
 1306|       |
 1307|       |#[cfg(feature = "mermaid-quickjs")]
 1308|       |impl TextMeasurer {
 1309|       |    const BOLD_WIDTH_FALLBACK: f32 = 1.07;
 1310|       |    const BOLD_WIDTH_SCALE: f32 = 1.03;
 1311|       |    const LINE_HEIGHT_SCALE: f32 = 1.0;
 1312|       |
 1313|  1.56k|    fn new(fontdb: Arc<usvg::fontdb::Database>) -> Self {
 1314|  1.56k|        let families = [
 1315|  1.56k|            usvg::fontdb::Family::Name("Trebuchet MS"),
 1316|  1.56k|            usvg::fontdb::Family::Name("Verdana"),
 1317|  1.56k|            usvg::fontdb::Family::Name("Arial"),
 1318|  1.56k|            usvg::fontdb::Family::SansSerif,
 1319|  1.56k|        ];
 1320|  1.56k|        let query = usvg::fontdb::Query {
 1321|  1.56k|            families: &families,
 1322|  1.56k|            ..Default::default()
 1323|  1.56k|        };
 1324|  1.56k|        let face_id = fontdb.query(&query);
 1325|  1.56k|        let bold_query = usvg::fontdb::Query {
 1326|  1.56k|            families: &families,
 1327|  1.56k|            weight: usvg::fontdb::Weight::BOLD,
 1328|  1.56k|            ..Default::default()
 1329|  1.56k|        };
 1330|  1.56k|        let bold_face_id = fontdb.query(&bold_query).or(face_id);
 1331|  1.56k|        Self {
 1332|  1.56k|            fontdb,
 1333|  1.56k|            face_id,
 1334|  1.56k|            bold_face_id,
 1335|  1.56k|        }
 1336|  1.56k|    }
 1337|       |
 1338|     42|    fn measure_text(&self, text: &str, font_size: f32, font_weight: Option<f32>) -> (f32, f32) {
 1339|     42|        if text.is_empty() {
 1340|      1|            return (0.0, 0.0);
 1341|     41|        }
 1342|     41|        let size = if font_size.is_finite() && font_size > 0.0 {
                                                             ^40
 1343|     39|            font_size
 1344|       |        } else {
 1345|      2|            16.0
 1346|       |        };
 1347|     41|        let use_bold = font_weight.unwrap_or(400.0) >= 600.0;
 1348|     41|        let face_id = if use_bold {
 1349|      5|            self.bold_face_id.or(self.face_id)
 1350|       |        } else {
 1351|     36|            self.face_id
 1352|       |        };
 1353|     41|        if let Some((width, height)) = self.measure_with_face(face_id, text, size) {
                                   ^39    ^39
 1354|     39|            if use_bold {
 1355|      4|                let mut adjusted = width * Self::BOLD_WIDTH_SCALE;
 1356|      4|                if self.bold_face_id == self.face_id {
 1357|      1|                    adjusted *= Self::BOLD_WIDTH_FALLBACK;
 1358|      3|                }
 1359|      4|                return (adjusted, height);
 1360|     35|            }
 1361|     35|            return (width, height);
 1362|      2|        }
 1363|      2|        Self::fallback_measure(text, size)
 1364|     42|    }
 1365|       |
 1366|     41|    fn measure_with_face(
 1367|     41|        &self,
 1368|     41|        face_id: Option<usvg::fontdb::ID>,
 1369|     41|        text: &str,
 1370|     41|        font_size: f32,
 1371|     41|    ) -> Option<(f32, f32)> {
 1372|     41|        let face_id = face_id?;
                          ^40              ^1
 1373|     40|        self.fontdb
 1374|     40|            .with_face_data(face_id, |data, index| {
 1375|     40|                let face = face_parse_for_test(data, index)?;
                                  ^39                                    ^1
 1376|     39|                let units_per_em = face.units_per_em().max(1) as f32;
 1377|     39|                let scale = font_size / units_per_em;
 1378|     39|                let fallback_advance = units_per_em * 0.5;
 1379|     39|                let kern_subtables: Vec<_> = face
 1380|     39|                    .tables()
 1381|     39|                    .kern
 1382|     39|                    .map(|kern| {
 1383|     39|                        kern.subtables
 1384|     39|                            .into_iter()
 1385|     39|                            .filter(|table| table.horizontal)
 1386|     39|                            .collect()
 1387|     39|                    })
 1388|     39|                    .unwrap_or_default();
 1389|     39|                let mut max_width_units = 0.0_f32;
 1390|     39|                let mut line_count = 0u32;
 1391|       |
 1392|     39|                for line in text.split('\n') {
 1393|     39|                    line_count += 1;
 1394|     39|                    let mut width_units = 0.0_f32;
 1395|     39|                    let mut prev = None;
 1396|    160|                    for ch in line.chars() {
                                            ^39  ^39
 1397|    160|                        if let Some(glyph) = face.glyph_index(ch) {
                                                  ^159
 1398|    159|                            if let Some(prev_glyph) = prev {
                                                      ^121
 1399|    121|                                let mut kern = 0.0_f32;
 1400|    242|                                for table in &kern_subtables {
                                                  ^121
 1401|    121|                                    if let Some(value) = table.glyphs_kerning(prev_glyph, glyph) {
                                                              ^6
 1402|      6|                                        kern += value as f32;
 1403|    115|                                    }
 1404|       |                                }
 1405|    121|                                width_units += kern;
 1406|     38|                            }
 1407|    159|                            width_units += face
 1408|    159|                                .glyph_hor_advance(glyph)
 1409|    159|                                .map(|adv| adv as f32)
 1410|    159|                                .unwrap_or(fallback_advance);
 1411|    159|                            prev = Some(glyph);
 1412|      1|                        } else {
 1413|      1|                            width_units += fallback_advance;
 1414|      1|                            prev = None;
 1415|      1|                        }
 1416|       |                    }
 1417|     39|                    max_width_units = max_width_units.max(width_units);
 1418|       |                }
 1419|       |
 1420|     39|                let ascender = face.ascender() as f32;
 1421|     39|                let descender = face.descender() as f32;
 1422|     39|                let line_gap = face.line_gap() as f32;
 1423|     39|                let line_height_units = (ascender - descender + line_gap).max(units_per_em);
 1424|     39|                let line_height = line_height_units * scale * Self::LINE_HEIGHT_SCALE;
 1425|     39|                let width = max_width_units * scale;
 1426|     39|                let height = line_height * line_count as f32;
 1427|     39|                Some((width, height))
 1428|     40|            })
 1429|     40|            .flatten()
 1430|     41|    }
 1431|       |
 1432|      3|    fn fallback_measure(text: &str, font_size: f32) -> (f32, f32) {
 1433|      3|        let mut max_len = 0usize;
 1434|      3|        let mut lines = 0usize;
 1435|      4|        for line in text.split('\n') {
                                  ^3   ^3
 1436|      4|            lines += 1;
 1437|      4|            let len = line.chars().count();
 1438|      4|            if len > max_len {
 1439|      3|                max_len = len;
 1440|      3|            }
                          ^1
 1441|       |        }
 1442|      3|        let width = max_len as f32 * font_size * 0.5;
 1443|      3|        let height = lines as f32 * font_size * 1.2;
 1444|      3|        (width, height)
 1445|      3|    }
 1446|       |}
 1447|       |
 1448|       |#[cfg(feature = "mermaid-quickjs")]
 1449|       |struct MermaidWorker {
 1450|       |    engine: MermaidEngine,
 1451|       |    deadline_ms: Arc<AtomicU64>,
 1452|       |    fontdb: Arc<usvg::fontdb::Database>,
 1453|       |    #[allow(dead_code)]
 1454|       |    text_measurer: Arc<TextMeasurer>,
 1455|       |}
 1456|       |
 1457|       |#[cfg(feature = "mermaid-quickjs")]
 1458|       |impl MermaidWorker {
 1459|       |    const MEMORY_LIMIT_BYTES: usize = 2 * 1024 * 1024 * 1024;
 1460|       |    const STACK_LIMIT_BYTES: usize = 4 * 1024 * 1024;
 1461|       |
 1462|       |    // DOMPurify expects a real browser DOM; stub sanitize for the QuickJS shim.
 1463|  1.56k|    fn patch_mermaid_js(js: &str) -> String {
 1464|       |        const TARGET: &str = "var hD=wRe();";
 1465|       |        const PATCH: &str =
 1466|       |            "var hD=wRe();if(!hD||typeof hD.sanitize!==\"function\"){hD={sanitize:function(html){return String(html);},addHook:function(){},removeHook:function(){},removeHooks:function(){},removeAllHooks:function(){},isSupported:true};}";
 1467|       |        const D3_TARGET: &str = "FY.prototype={constructor:FY,appendChild:function(i){return this._parent.insertBefore(i,this._next)},insertBefore:function(i,s){return this._parent.insertBefore(i,s)},querySelector:function(i){return this._parent.querySelector(i)},querySelectorAll:function(i){return this._parent.querySelectorAll(i)}};";
 1468|       |        const D3_PATCH: &str = "FY.prototype={constructor:FY,appendChild:function(i){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p?p.insertBefore(i,this._next):i},insertBefore:function(i,s){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p?p.insertBefore(i,s):i},querySelector:function(i){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p&&p.querySelector?p.querySelector(i):null},querySelectorAll:function(i){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p&&p.querySelectorAll?p.querySelectorAll(i):[]}};";
 1469|       |        const D3_CTOR_TARGET: &str =
 1470|       |            "function FY(i,s){this.ownerDocument=i.ownerDocument,this.namespaceURI=i.namespaceURI,this._next=null,this._parent=i,this.__data__=s}";
 1471|       |        const D3_CTOR_PATCH: &str =
 1472|       |            "function FY(i,s){i=i||((typeof document!==\"undefined\"&&document.body)?document.body:null);this.ownerDocument=i&&i.ownerDocument?i.ownerDocument:(typeof document!==\"undefined\"?document:null);this.namespaceURI=i&&i.namespaceURI?i.namespaceURI:null;this._next=null;this._parent=i;this.__data__=s}";
 1473|       |        const TEXT_WRAP_TARGET: &str = "u.text().split(/(\\s+|<br>)/).reverse()";
 1474|       |        const TEXT_WRAP_PATCH: &str = concat!(
 1475|       |            "String(typeof u.text===\"function\"?u.text():(u.textContent||\"\"))",
 1476|       |            ".split(/(\\s+|<br>)/).reverse()"
 1477|       |        );
 1478|       |        const MINDMAP_LAYOUT_TARGET: &str =
 1479|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 1480|       |        const MINDMAP_LAYOUT_PATCH: &str =
 1481|       |            "p.layout({name:\"breadthfirst\",directed:!0,spacingFactor:1.4,animate:!1}).run()";
 1482|       |        const MINDMAP_READY_TARGET: &str =
 1483|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run(),p.ready(v=>{Xe.info(\"Ready\",v),u(p)})";
 1484|       |        const MINDMAP_READY_PATCH: &str =
 1485|       |            "p.layout({name:\"breadthfirst\",directed:!0,spacingFactor:1.4,animate:!1}).run(),u(p)";
 1486|       |        const MINDMAP_CYTO_TARGET: &str =
 1487|       |            "p=fWe({container:document.getElementById(\"cy\"),style:[{selector:\"edge\",style:{\"curve-style\":\"bezier\"}}]});";
 1488|       |        const MINDMAP_CYTO_PATCH: &str =
 1489|       |            "p=__mdmdview_cytoscape_stub({container:document.getElementById(\"cy\")});";
 1490|       |        const TIMELINE_BOUNDS_TARGET: &str = "const se=_.node().getBBox();";
 1491|       |        const TIMELINE_BOUNDS_PATCH: &str = concat!(
 1492|       |            "const se=_.node().getBBox();",
 1493|       |            "if(se&&typeof se.width===\"number\"&&typeof v===\"number\"){",
 1494|       |            "se.width=Math.max(0,se.width-2*v);",
 1495|       |            "}"
 1496|       |        );
 1497|  1.56k|        let mut out = if js.contains(TARGET) {
 1498|  1.55k|            js.replacen(TARGET, PATCH, 1)
 1499|       |        } else {
 1500|      6|            js.to_string()
 1501|       |        };
 1502|  1.56k|        let debug = std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG").is_ok();
 1503|  1.56k|        if out.contains(D3_CTOR_TARGET) {
 1504|  1.55k|            out = out.replacen(D3_CTOR_TARGET, D3_CTOR_PATCH, 1);
 1505|  1.55k|            if debug {
 1506|      1|                eprintln!("Mermaid patch: D3 ctor applied");
 1507|  1.55k|            }
 1508|      6|        } else if debug {
 1509|      2|            eprintln!("Mermaid patch: D3 ctor not found");
 1510|      4|        }
 1511|  1.56k|        if out.contains(D3_TARGET) {
 1512|  1.55k|            out = out.replacen(D3_TARGET, D3_PATCH, 1);
 1513|  1.55k|            if debug {
 1514|      1|                eprintln!("Mermaid patch: D3 enter applied");
 1515|  1.55k|            }
 1516|      6|        } else if debug {
 1517|      2|            eprintln!("Mermaid patch: D3 enter not found");
 1518|      4|        }
 1519|  1.56k|        if out.contains(TEXT_WRAP_TARGET) {
 1520|  1.55k|            out = out.replacen(TEXT_WRAP_TARGET, TEXT_WRAP_PATCH, 1);
 1521|  1.55k|            if debug {
 1522|      1|                eprintln!("Mermaid patch: D3 text wrap applied");
 1523|  1.55k|            }
 1524|      6|        } else if debug {
 1525|      2|            eprintln!("Mermaid patch: D3 text wrap not found");
 1526|      4|        }
 1527|  1.56k|        let mut mindmap_layout_patched = false;
 1528|  1.56k|        if out.contains(MINDMAP_CYTO_TARGET) {
 1529|  1.55k|            out = out.replacen(MINDMAP_CYTO_TARGET, MINDMAP_CYTO_PATCH, 1);
 1530|  1.55k|            if debug {
 1531|      1|                eprintln!("Mermaid patch: mindmap cytoscape stub applied");
 1532|  1.55k|            }
 1533|      6|        } else if debug {
 1534|      2|            eprintln!("Mermaid patch: mindmap cytoscape stub not found");
 1535|      4|        }
 1536|  1.56k|        if out.contains(MINDMAP_READY_TARGET) {
 1537|  1.55k|            out = out.replacen(MINDMAP_READY_TARGET, MINDMAP_READY_PATCH, 1);
 1538|  1.55k|            mindmap_layout_patched = true;
 1539|  1.55k|            if debug {
 1540|      1|                eprintln!("Mermaid patch: mindmap ready patch applied");
 1541|  1.55k|            }
 1542|      6|        } else if out.contains(MINDMAP_LAYOUT_TARGET) {
 1543|      4|            out = out.replacen(MINDMAP_LAYOUT_TARGET, MINDMAP_LAYOUT_PATCH, 1);
 1544|      4|            mindmap_layout_patched = true;
 1545|      4|            if debug {
 1546|      1|                eprintln!("Mermaid patch: mindmap layout applied");
 1547|      3|            }
 1548|      2|        }
 1549|  1.56k|        if !mindmap_layout_patched && debug {
                                                    ^2
 1550|      1|            eprintln!("Mermaid patch: mindmap layout not found");
 1551|  1.56k|        }
 1552|  1.56k|        if out.contains(TIMELINE_BOUNDS_TARGET) {
 1553|  1.55k|            out = out.replacen(TIMELINE_BOUNDS_TARGET, TIMELINE_BOUNDS_PATCH, 1);
 1554|  1.55k|            if debug {
 1555|      1|                eprintln!("Mermaid patch: timeline bounds applied");
 1556|  1.55k|            }
 1557|      6|        } else if debug {
 1558|      2|            eprintln!("Mermaid patch: timeline bounds not found");
 1559|      4|        }
 1560|  1.56k|        out
 1561|  1.56k|    }
 1562|       |
 1563|     26|    fn format_js_error(ctx: &rquickjs::Ctx<'_>, err: rquickjs::Error) -> String {
 1564|     26|        if let rquickjs::Error::Exception = err {
 1565|     25|            let value = ctx.catch();
 1566|     25|            if let Some(exception) = value.as_exception() {
                                      ^11
 1567|     11|                let message = exception.message().filter(|value| !value.trim().is_empty());
                                                                                ^10          ^10
 1568|     11|                let stack = exception.stack().filter(|value| !value.trim().is_empty());
                                                                            ^10          ^10
 1569|     11|                if let Some(stack) = stack {
                                          ^7
 1570|      7|                    if let Some(message) = &message {
                                              ^6
 1571|      6|                        if stack.contains(message) {
 1572|      1|                            return stack;
 1573|      5|                        }
 1574|      5|                        return format!("{}\n{}", message, stack);
 1575|      1|                    }
 1576|      1|                    return stack;
 1577|      4|                }
 1578|      4|                if let Some(message) = message {
                                          ^3
 1579|      3|                    return message;
 1580|      1|                }
 1581|     14|            }
 1582|     15|            if let Some(js_string) = value.as_string().and_then(|s| s.to_string().ok()) {
                                      ^1                                          ^1^1          ^1
 1583|      1|                return js_string;
 1584|     14|            }
 1585|     14|            if let Some(number) = value.as_int() {
                                      ^1
 1586|      1|                return number.to_string();
 1587|     13|            }
 1588|     13|            if let Some(number) = value.as_float() {
                                      ^1
 1589|      1|                return number.to_string();
 1590|     12|            }
 1591|     12|            if let Some(flag) = value.as_bool() {
                                      ^1
 1592|      1|                return flag.to_string();
 1593|     11|            }
 1594|     11|            return format!("{:?}", value);
 1595|      1|        }
 1596|      1|        err.to_string()
 1597|     26|    }
 1598|       |
 1599|  1.55k|    fn new(worker_idx: usize, fontdb: Arc<usvg::fontdb::Database>) -> Result<Self, String> {
 1600|       |        use rquickjs::Function;
 1601|  1.55k|        if mermaid_js_empty() {
 1602|      1|            return Err("No embedded Mermaid JS".to_string());
 1603|  1.55k|        }
 1604|       |        #[cfg(test)]
 1605|  1.55k|        if FORCE_MERMAID_WORKER_INIT_ERROR.swap(false, Ordering::Relaxed) {
 1606|      1|            return Err("Mermaid worker init forced error".to_string());
 1607|  1.55k|        }
 1608|  1.55k|        let rt = runtime_new_for_test()
                          ^1.55k
 1609|  1.55k|            .map_err(|e| format!("Mermaid runtime init error: {}", e))?;
                                       ^1      ^1                                   ^1
 1610|  1.55k|        rt.set_memory_limit(Self::MEMORY_LIMIT_BYTES);
 1611|  1.55k|        rt.set_max_stack_size(Self::STACK_LIMIT_BYTES);
 1612|  1.55k|        let deadline_ms = Arc::new(AtomicU64::new(0));
 1613|  1.55k|        let deadline_guard = Arc::clone(&deadline_ms);
 1614|  45.2k|        rt.set_interrupt_handler(Some(Box::new(move || {
                      ^1.55k^1.55k                     ^1.55k
 1615|  45.2k|            let deadline = deadline_guard.load(Ordering::Relaxed);
 1616|  45.2k|            if deadline == 0 {
 1617|  44.9k|                return false;
 1618|    343|            }
 1619|    343|            Self::now_ms() >= deadline
 1620|  45.2k|        })));
 1621|  1.55k|        let ctx = context_full_for_test(&rt)
                          ^1.55k
 1622|  1.55k|            .map_err(|e| format!("Mermaid context init error: {}", e))?;
                                       ^1      ^1                                   ^1
 1623|  1.55k|        let engine = MermaidEngine { rt, ctx };
 1624|  1.55k|        let text_measurer = Arc::new(TextMeasurer::new(Arc::clone(&fontdb)));
 1625|  1.55k|        let js = mermaid_js_str_for_test()
                          ^1.55k
 1626|  1.55k|            .map_err(|_| "Mermaid JS is not valid UTF-8".to_string())?;
                                       ^1                              ^1          ^1
 1627|  1.55k|        let js = Self::patch_mermaid_js(js);
 1628|  1.55k|        let init_result: Result<(), String> = engine.ctx.with(|ctx| {
 1629|  1.55k|            let measurer = Arc::clone(&text_measurer);
 1630|  1.55k|            let measure_fn = maybe_force_mermaid_init_error(
                              ^1.55k
 1631|       |                1,
 1632|  1.55k|                Function::new(
 1633|  1.55k|                    ctx.clone(),
 1634|     33|                    move |text: String, font_size: f64, font_weight: Option<f64>| {
 1635|     33|                        let weight = font_weight.map(|value| value as f32);
                                                                           ^32
 1636|     33|                        let (width, height) = measurer.measure_text(&text, font_size as f32, weight);
 1637|     33|                        vec![width as f64, height as f64]
 1638|     33|                    },
 1639|       |                ),
 1640|       |            )
 1641|  1.55k|            .map_err(|err| {
                                         ^1
 1642|      1|                format!(
 1643|      1|                    "Mermaid text measure init error: {}",
 1644|      1|                    MermaidWorker::format_js_error(&ctx, err)
 1645|       |                )
 1646|      1|            })?;
 1647|  1.55k|            maybe_force_mermaid_init_error(2, ctx.globals().set("__mdmdview_measure_text_native", measure_fn))
 1648|  1.55k|                .map_err(|err| {
                                             ^1
 1649|      1|                    format!(
 1650|      1|                        "Mermaid text measure init error: {}",
 1651|      1|                        MermaidWorker::format_js_error(&ctx, err)
 1652|       |                    )
 1653|      1|                })?;
 1654|  4.65k|            let eval = |stage: usize, label: &str, source: &str| -> Result<(), String> {
                              ^1.55k
 1655|  4.65k|                let result = maybe_force_mermaid_init_error(stage, ctx.eval::<(), _>(source));
 1656|  4.65k|                result.map_err(|err| {
                                                   ^3
 1657|      3|                    format!("{}: {}", label, MermaidWorker::format_js_error(&ctx, err))
 1658|      3|                })
 1659|  4.65k|            };
 1660|  1.55k|            eval(3, "Mermaid DOM shim", MERMAID_DOM_SHIM)?;
                                                                       ^1
 1661|  1.55k|            eval(4, "Mermaid JS", &js)?;
                                                    ^1
 1662|  1.54k|            eval(5, "Mermaid init", MERMAID_INIT_SNIPPET)?;
                                                                       ^1
 1663|  1.54k|            if std::env::var("MDMDVIEW_MERMAID_DOM_DEBUG").is_ok() {
 1664|     22|                let dom_ok = ctx
 1665|     22|                    .eval::<bool, _>(
 1666|     22|                        "var root=document.querySelector('body');var d=document.createElement('div');d.setAttribute('id','__mdmdview_dom_test');root.appendChild(d);var f=document.getElementById('__mdmdview_dom_test');!!(f&&f===d);",
 1667|     22|                    )
 1668|     22|                    .unwrap_or(false);
 1669|     22|                eprintln!("Mermaid DOM debug: {}", dom_ok);
 1670|  1.52k|            }
 1671|  1.54k|            Ok(())
 1672|  1.55k|        });
 1673|  1.55k|        Self::map_init_result(init_result)?;
                                                        ^5
 1674|  1.54k|        if worker_idx == 0 {
 1675|    405|            eprintln!(
 1676|    405|                "Mermaid embedded bytes: {}",
 1677|    405|                mermaid_embed::MERMAID_JS.len()
 1678|    405|            );
 1679|  1.14k|        }
 1680|  1.54k|        Ok(Self {
 1681|  1.54k|            engine,
 1682|  1.54k|            deadline_ms,
 1683|  1.54k|            fontdb,
 1684|  1.54k|            text_measurer,
 1685|  1.54k|        })
 1686|  1.55k|    }
 1687|       |
 1688|     12|    fn render_svg(
 1689|     12|        &mut self,
 1690|     12|        key: u64,
 1691|     12|        code: &str,
 1692|     12|        viewport_width: u32,
 1693|     12|        viewport_height: u32,
 1694|     12|    ) -> Result<String, String> {
 1695|       |        use rquickjs::{promise::MaybePromise, Function};
 1696|     12|        let timeout_ms = MermaidRenderer::mermaid_timeout_ms();
 1697|     12|        let deadline = Self::now_ms().saturating_add(timeout_ms);
 1698|     12|        self.deadline_ms.store(deadline, Ordering::Relaxed);
 1699|     12|        let result = self.engine.ctx.with(|ctx| {
 1700|     12|            let wrapper = MERMAID_RENDER_WRAPPER;
 1701|     12|            let func: Function = eval_mermaid_wrapper(&ctx, wrapper)
                              ^11   ^11
 1702|     12|                .map_err(|err| MermaidWorker::format_js_error(&ctx, err))?;
                                             ^1                             ^1    ^1   ^1
 1703|     11|            let id = format!("m{:016x}", key);
 1704|     11|            let site_config = MermaidRenderer::mermaid_site_config_json(key);
 1705|     11|            let maybe: MaybePromise = call_mermaid_render(
                              ^10    ^10
 1706|     11|                &func,
 1707|     11|                (
 1708|     11|                    id.as_str(),
 1709|     11|                    code,
 1710|     11|                    site_config.as_str(),
 1711|     11|                    viewport_width,
 1712|     11|                    viewport_height,
 1713|     11|                ),
 1714|       |            )
 1715|     11|            .map_err(|err| MermaidWorker::format_js_error(&ctx, err))?;
                                         ^1                             ^1    ^1   ^1
 1716|     10|            maybe
 1717|     10|                .finish::<String>()
 1718|     10|                .map_err(|err| MermaidWorker::format_js_error(&ctx, err))
                                             ^2                             ^2    ^2
 1719|     12|        });
 1720|     12|        self.deadline_ms.store(0, Ordering::Relaxed);
 1721|     12|        Self::format_render_result(result, deadline, Self::now_ms())
 1722|     12|    }
 1723|       |
 1724|  1.55k|    fn map_init_result(init_result: Result<(), String>) -> Result<(), String> {
 1725|  1.55k|        match init_result {
 1726|  1.54k|            Ok(()) => Ok(()),
 1727|      6|            Err(err) => Err(format!("Mermaid init error: {}", err)),
 1728|       |        }
 1729|  1.55k|    }
 1730|       |
 1731|     15|    fn format_render_result(
 1732|     15|        result: Result<String, String>,
 1733|     15|        deadline: u64,
 1734|     15|        now_ms: u64,
 1735|     15|    ) -> Result<String, String> {
 1736|     15|        match result {
 1737|      9|            Ok(svg) => Ok(svg),
 1738|      6|            Err(err) => {
 1739|      6|                if now_ms >= deadline {
 1740|      1|                    return Err("Mermaid render timed out".to_string());
 1741|      5|                }
 1742|      5|                Err(format!("Mermaid render error: {}", err))
 1743|       |            }
 1744|       |        }
 1745|     15|    }
 1746|       |
 1747|     13|    fn maybe_dump_svg(svg_key: u64, code: Option<&str>, svg: &str) {
 1748|     13|        let dir = match std::env::var("MDMDVIEW_MERMAID_DUMP_DIR") {
                          ^7
 1749|      8|            Ok(value) if !value.trim().is_empty() => value,
                             ^7                               ^7   ^7
 1750|      6|            _ => return,
 1751|       |        };
 1752|      7|        let dir = PathBuf::from(dir);
 1753|      7|        if std::fs::create_dir_all(&dir).is_err() {
 1754|      1|            return;
 1755|      6|        }
 1756|      6|        let label = code
 1757|      6|            .and_then(|snippet| snippet.lines().next())
                                              ^5              ^5
 1758|      6|            .unwrap_or("mermaid");
 1759|      6|        let mut name = String::new();
 1760|     70|        for ch in label.chars() {
                                ^6    ^6
 1761|     70|            if name.len() >= 32 {
 1762|      1|                break;
 1763|     69|            }
 1764|     69|            if ch.is_ascii_alphanumeric() || ch == '-' || ch == '_' {
                                                           ^3           ^2
 1765|     68|                name.push(ch);
 1766|     68|            } else {
 1767|      1|                name.push('_');
 1768|      1|            }
 1769|       |        }
 1770|      6|        if name.is_empty() {
 1771|      1|            name.push_str("mermaid");
 1772|      5|        }
 1773|      6|        let filename = format!("{:016x}_{}.svg", svg_key, name);
 1774|      6|        let path = dir.join(filename);
 1775|      6|        let _ = std::fs::write(path, svg);
 1776|     13|    }
 1777|       |
 1778|     13|    fn maybe_dump_error(svg_key: u64, code: Option<&str>, err: &str) {
 1779|     13|        let dir = match std::env::var("MDMDVIEW_MERMAID_DUMP_DIR") {
                          ^8
 1780|      9|            Ok(value) if !value.trim().is_empty() => value,
                             ^8                               ^8   ^8
 1781|      5|            _ => return,
 1782|       |        };
 1783|      8|        let dir = PathBuf::from(dir);
 1784|      8|        if std::fs::create_dir_all(&dir).is_err() {
 1785|      1|            return;
 1786|      7|        }
 1787|      7|        let label = code
 1788|      7|            .and_then(|snippet| snippet.lines().next())
                                              ^6              ^6
 1789|      7|            .unwrap_or("mermaid");
 1790|      7|        let mut name = String::new();
 1791|     80|        for ch in label.chars() {
                                ^7    ^7
 1792|     80|            if name.len() >= 32 {
 1793|      1|                break;
 1794|     79|            }
 1795|     79|            if ch.is_ascii_alphanumeric() || ch == '-' || ch == '_' {
                                                           ^7           ^6
 1796|     74|                name.push(ch);
 1797|     74|            } else {
 1798|      5|                name.push('_');
 1799|      5|            }
 1800|       |        }
 1801|      7|        if name.is_empty() {
 1802|      1|            name.push_str("mermaid");
 1803|      6|        }
 1804|      7|        let filename = format!("{:016x}_{}.err.txt", svg_key, name);
 1805|      7|        let path = dir.join(filename);
 1806|      7|        let mut payload = String::new();
 1807|      7|        payload.push_str("error: ");
 1808|      7|        payload.push_str(err);
 1809|      7|        payload.push('\n');
 1810|      7|        if let Some(code) = code {
                                  ^6
 1811|      6|            payload.push_str("\n---\n");
 1812|      6|            payload.push_str(code);
 1813|      6|            payload.push('\n');
 1814|      6|        }
                      ^1
 1815|      7|        let _ = std::fs::write(path, payload);
 1816|     13|    }
 1817|       |
 1818|     11|    fn normalize_svg_size(svg: &str) -> String {
 1819|     11|        let start = match svg.find("<svg") {
                          ^10
 1820|     10|            Some(idx) => idx,
 1821|      1|            None => return svg.to_string(),
 1822|       |        };
 1823|     10|        let end = match svg[start..].find('>') {
                          ^9
 1824|      9|            Some(idx) => start + idx,
 1825|      1|            None => return svg.to_string(),
 1826|       |        };
 1827|      9|        let tag = &svg[start..=end];
 1828|      9|        let viewbox = match Self::find_svg_attr(tag, "viewBox") {
                          ^8
 1829|      8|            Some(v) => v,
 1830|      1|            None => return svg.to_string(),
 1831|       |        };
 1832|      8|        let dims = Self::parse_viewbox_dims(&viewbox);
 1833|      8|        let (width, height) = match dims {
                           ^7     ^7
 1834|      7|            Some(pair) => pair,
 1835|      1|            None => return svg.to_string(),
 1836|       |        };
 1837|      7|        let mut new_tag = tag.to_string();
 1838|      7|        let width_attr = Self::find_svg_attr(&new_tag, "width");
 1839|      7|        if width_attr
 1840|      7|            .as_deref()
 1841|      7|            .map(|val| val.trim().ends_with('%'))
                                     ^6         ^6
 1842|      7|            .unwrap_or(true)
 1843|       |        {
 1844|      5|            let value = Self::format_dim(width);
 1845|      5|            new_tag = if width_attr.is_some() {
 1846|      4|                Self::replace_svg_attr(&new_tag, "width", &value)
 1847|       |            } else {
 1848|      1|                Self::insert_svg_attr(&new_tag, "width", &value)
 1849|       |            };
 1850|      2|        }
 1851|      7|        let height_attr = Self::find_svg_attr(&new_tag, "height");
 1852|      7|        if height_attr
 1853|      7|            .as_deref()
 1854|      7|            .map(|val| val.trim().ends_with('%'))
                                     ^4         ^4
 1855|      7|            .unwrap_or(true)
 1856|       |        {
 1857|      5|            let value = Self::format_dim(height);
 1858|      5|            new_tag = if height_attr.is_some() {
 1859|      2|                Self::replace_svg_attr(&new_tag, "height", &value)
 1860|       |            } else {
 1861|      3|                Self::insert_svg_attr(&new_tag, "height", &value)
 1862|       |            };
 1863|      2|        }
 1864|      7|        if new_tag == tag {
 1865|      2|            return svg.to_string();
 1866|      5|        }
 1867|      5|        let mut out = String::with_capacity(svg.len() + 32);
 1868|      5|        out.push_str(&svg[..start]);
 1869|      5|        out.push_str(&new_tag);
 1870|      5|        out.push_str(&svg[end + 1..]);
 1871|      5|        out
 1872|     11|    }
 1873|       |
 1874|     29|    fn replace_attr(tag: &str, name: &str, value: &str) -> String {
 1875|     29|        let needle = format!("{name}=\"");
 1876|     29|        let start = match tag.find(&needle) {
                          ^28
 1877|     28|            Some(idx) => idx + needle.len(),
 1878|      1|            None => return tag.to_string(),
 1879|       |        };
 1880|     28|        let end = match tag[start..].find('"') {
                          ^27
 1881|     27|            Some(idx) => start + idx,
 1882|      1|            None => return tag.to_string(),
 1883|       |        };
 1884|     27|        let mut out = String::with_capacity(tag.len() + value.len());
 1885|     27|        out.push_str(&tag[..start]);
 1886|     27|        out.push_str(value);
 1887|     27|        out.push_str(&tag[end..]);
 1888|     27|        out
 1889|     29|    }
 1890|       |
 1891|     25|    fn upsert_attr(tag: &str, name: &str, value: &str) -> String {
 1892|     25|        let needle = format!("{name}=\"");
 1893|     25|        if tag.contains(&needle) {
 1894|     18|            return Self::replace_attr(tag, name, value);
 1895|      7|        }
 1896|      7|        let insert_at = match tag.rfind('>') {
                          ^6
 1897|      6|            Some(pos) => pos,
 1898|      1|            None => return tag.to_string(),
 1899|       |        };
 1900|      6|        let mut out = String::with_capacity(tag.len() + name.len() + value.len() + 4);
 1901|      6|        out.push_str(&tag[..insert_at]);
 1902|      6|        out.push(' ');
 1903|      6|        out.push_str(name);
 1904|      6|        out.push_str("=\"");
 1905|      6|        out.push_str(value);
 1906|      6|        out.push('"');
 1907|      6|        out.push_str(&tag[insert_at..]);
 1908|      6|        out
 1909|     25|    }
 1910|       |
 1911|     10|    fn flatten_svg_switches(svg: &str) -> Option<String> {
 1912|     10|        if !svg.contains("<switch") {
 1913|      5|            return None;
 1914|      5|        }
 1915|      5|        let mut out = String::with_capacity(svg.len());
 1916|      5|        let mut remaining = svg;
 1917|      5|        let mut changed = false;
 1918|      8|        while let Some(start) = remaining.find("<switch") {
                                     ^5
 1919|      5|            let (before, after) = remaining.split_at(start);
 1920|      5|            out.push_str(before);
 1921|      5|            let open_end = match after.find('>') {
                              ^4
 1922|      4|                Some(pos) => pos + 1,
 1923|       |                None => {
 1924|      1|                    out.push_str(after);
 1925|      1|                    remaining = "";
 1926|      1|                    break;
 1927|       |                }
 1928|       |            };
 1929|      4|            let after_open = &after[open_end..];
 1930|      4|            let close_rel = match after_open.find("</switch>") {
                              ^3
 1931|      3|                Some(pos) => pos,
 1932|       |                None => {
 1933|      1|                    out.push_str(after);
 1934|      1|                    remaining = "";
 1935|      1|                    break;
 1936|       |                }
 1937|       |            };
 1938|      3|            let inner = &after_open[..close_rel];
 1939|      3|            let mut inner_out = String::with_capacity(inner.len());
 1940|      3|            let mut inner_remaining = inner;
 1941|      5|            while let Some(fo_start) = inner_remaining.find("<foreignObject") {
                                         ^3
 1942|      3|                let (inner_before, inner_after) = inner_remaining.split_at(fo_start);
 1943|      3|                inner_out.push_str(inner_before);
 1944|      3|                if let Some(fo_end_rel) = inner_after.find("</foreignObject>") {
                                          ^2
 1945|      2|                    inner_remaining = &inner_after[fo_end_rel + "</foreignObject>".len()..];
 1946|      2|                } else {
 1947|      1|                    inner_remaining = "";
 1948|      1|                    break;
 1949|       |                }
 1950|       |            }
 1951|      3|            inner_out.push_str(inner_remaining);
 1952|      3|            out.push_str(&inner_out);
 1953|      3|            changed = true;
 1954|      3|            remaining = &after_open[close_rel + "</switch>".len()..];
 1955|       |        }
 1956|      5|        out.push_str(remaining);
 1957|      5|        if changed {
 1958|      3|            Some(out)
 1959|       |        } else {
 1960|      2|            None
 1961|       |        }
 1962|     10|    }
 1963|       |
 1964|     12|    fn fix_journey_section_text(svg: &str, fill: &str) -> Option<String> {
 1965|     12|        if !svg.contains("journey-section") {
 1966|      5|            return None;
 1967|      7|        }
 1968|      7|        let mut out = String::with_capacity(svg.len() + 64);
 1969|      7|        let mut remaining = svg;
 1970|      7|        let mut changed = false;
 1971|     14|        while let Some(idx) = remaining.find("<text") {
                                     ^8
 1972|      8|            let (before, after) = remaining.split_at(idx);
 1973|      8|            out.push_str(before);
 1974|      8|            let end = match after.find('>') {
                              ^7
 1975|      7|                Some(pos) => pos + 1,
 1976|       |                None => {
 1977|      1|                    out.push_str(after);
 1978|      1|                    remaining = "";
 1979|      1|                    break;
 1980|       |                }
 1981|       |            };
 1982|      7|            let (tag, rest) = after.split_at(end);
 1983|      7|            if tag.contains("journey-section") {
 1984|      6|                let mut updated = tag.to_string();
 1985|      6|                if let Some(style_start) = updated.find(" style=\"") {
                                          ^4
 1986|      4|                    let value_start = style_start + " style=\"".len();
 1987|      4|                    if let Some(style_end) = updated[value_start..].find('"') {
                                              ^3
 1988|      3|                        let style_end = value_start + style_end;
 1989|      3|                        let mut style = updated[value_start..style_end].to_string();
 1990|      3|                        let parts: Vec<&str> = style.split(';').collect();
 1991|      3|                        let mut rebuilt: Vec<String> = Vec::new();
 1992|      9|                        for part in parts {
                                          ^6
 1993|      6|                            let trimmed = part.trim();
 1994|      6|                            if trimmed.is_empty() {
 1995|      1|                                continue;
 1996|      5|                            }
 1997|      5|                            if trimmed.starts_with("fill:") {
 1998|      3|                                continue;
 1999|      2|                            }
 2000|      2|                            rebuilt.push(trimmed.to_string());
 2001|       |                        }
 2002|      3|                        rebuilt.push(format!("fill:{}", fill));
 2003|      3|                        style = rebuilt.join(";");
 2004|      3|                        updated.replace_range(value_start..style_end, &style);
 2005|      3|                        out.push_str(&updated);
 2006|      3|                        changed = true;
 2007|      1|                    } else {
 2008|      1|                        out.push_str(tag);
 2009|      1|                    }
 2010|      2|                } else {
 2011|      2|                    let insert_at = updated.len().saturating_sub(1);
 2012|      2|                    updated.insert_str(insert_at, &format!(" style=\"fill:{};\"", fill));
 2013|      2|                    out.push_str(&updated);
 2014|      2|                    changed = true;
 2015|      2|                }
 2016|      1|            } else {
 2017|      1|                out.push_str(tag);
 2018|      1|            }
 2019|      7|            remaining = rest;
 2020|       |        }
 2021|      7|        out.push_str(remaining);
 2022|      7|        if changed {
 2023|      5|            Some(out)
 2024|       |        } else {
 2025|      2|            None
 2026|       |        }
 2027|     12|    }
 2028|       |
 2029|     18|    fn find_circle_tag(body: &str, class_name: &str) -> Option<(usize, usize, String)> {
 2030|     18|        let needle = format!("class=\"{class_name}\"");
 2031|     18|        let class_idx = body.find(&needle)?;
                          ^17                           ^1
 2032|     17|        let start = body[..class_idx].rfind("<circle")?;
                          ^16                                       ^1
 2033|     16|        let end = body[class_idx..].find('>')? + class_idx + 1;
                          ^15                              ^1  ^15
 2034|     15|        Some((start, end, body[start..end].to_string()))
 2035|     18|    }
 2036|       |
 2037|     15|    fn read_r_value(tag: &str) -> Option<String> {
 2038|     15|        let needle = "r=\"";
 2039|     15|        let start = tag.find(needle)? + needle.len();
                          ^14                     ^1  ^14    ^14
 2040|     14|        let end = tag[start..].find('"')? + start;
                          ^13                         ^1  ^13
 2041|     13|        Some(tag[start..end].to_string())
 2042|     15|    }
 2043|       |
 2044|     15|    fn fix_state_end_circles(svg: &str) -> Option<String> {
 2045|     15|        if !svg.contains("state-end") {
 2046|      5|            return None;
 2047|     10|        }
 2048|     10|        let mut out = String::with_capacity(svg.len());
 2049|     10|        let mut cursor = 0;
 2050|     10|        let mut changed = false;
 2051|     19|        while let Some(g_pos_rel) = svg[cursor..].find("<g") {
                                     ^11
 2052|     11|            let g_pos = cursor + g_pos_rel;
 2053|     11|            out.push_str(&svg[cursor..g_pos]);
 2054|     11|            let g_end = match svg[g_pos..].find('>') {
                              ^10
 2055|     10|                Some(pos) => g_pos + pos + 1,
 2056|       |                None => {
 2057|      1|                    out.push_str(&svg[g_pos..]);
 2058|      1|                    cursor = svg.len();
 2059|      1|                    break;
 2060|       |                }
 2061|       |            };
 2062|     10|            let g_tag = &svg[g_pos..g_end];
 2063|     10|            let is_end_group = g_tag.contains("root_end") || g_tag.contains("state-end");
                                                                           ^2    ^2
 2064|     10|            if !is_end_group {
 2065|      1|                out.push_str(g_tag);
 2066|      1|                cursor = g_end;
 2067|      1|                continue;
 2068|      9|            }
 2069|      9|            let close_rel = match svg[g_end..].find("</g>") {
                              ^8
 2070|      8|                Some(pos) => pos,
 2071|       |                None => {
 2072|      1|                    out.push_str(&svg[g_pos..]);
 2073|      1|                    cursor = svg.len();
 2074|      1|                    break;
 2075|       |                }
 2076|       |            };
 2077|      8|            let body_end = g_end + close_rel;
 2078|      8|            let body = &svg[g_end..body_end];
 2079|      8|            let mut body_out = body.to_string();
 2080|       |            if let (
 2081|      7|                Some((s_start, s_end, state_end_tag)),
 2082|      7|                Some((t_start, t_end, state_start_tag)),
 2083|       |            ) = (
 2084|      8|                Self::find_circle_tag(body, "state-end"),
 2085|      8|                Self::find_circle_tag(body, "state-start"),
 2086|       |            ) {
 2087|      6|                if let (Some(end_r), Some(start_r)) = (
 2088|      7|                    Self::read_r_value(&state_end_tag),
 2089|      7|                    Self::read_r_value(&state_start_tag),
 2090|       |                ) {
 2091|      6|                    let end_val = end_r.parse::<f32>().ok();
 2092|      6|                    let start_val = start_r.parse::<f32>().ok();
 2093|      6|                    if let (Some(end_val), Some(start_val)) = (end_val, start_val) {
                                               ^5             ^5
 2094|      5|                        if end_val < start_val {
 2095|      4|                            let end_dim = Self::format_dim(start_val * 2.0);
 2096|      4|                            let start_dim = Self::format_dim(end_val * 2.0);
 2097|      4|                            let mut new_end_tag = Self::replace_attr(&state_end_tag, "r", &start_r);
 2098|      4|                            let mut new_start_tag =
 2099|      4|                                Self::replace_attr(&state_start_tag, "r", &end_r);
 2100|      4|                            new_end_tag = Self::upsert_attr(&new_end_tag, "width", &end_dim);
 2101|      4|                            new_end_tag = Self::upsert_attr(&new_end_tag, "height", &end_dim);
 2102|      4|                            new_start_tag = Self::upsert_attr(&new_start_tag, "width", &start_dim);
 2103|      4|                            new_start_tag = Self::upsert_attr(&new_start_tag, "height", &start_dim);
 2104|      4|                            new_start_tag = new_start_tag.replace("state-start", "end-state-inner");
 2105|      4|                            let mut rebuilt = String::with_capacity(body.len() + 16);
 2106|       |                            let (
 2107|      4|                                first_start,
 2108|      4|                                first_end,
 2109|      4|                                first_tag,
 2110|      4|                                second_start,
 2111|      4|                                second_end,
 2112|      4|                                second_tag,
 2113|      4|                            ) = if s_start <= t_start {
 2114|      3|                                (s_start, s_end, new_end_tag, t_start, t_end, new_start_tag)
 2115|       |                            } else {
 2116|      1|                                (t_start, t_end, new_start_tag, s_start, s_end, new_end_tag)
 2117|       |                            };
 2118|      4|                            rebuilt.push_str(&body[..first_start]);
 2119|      4|                            rebuilt.push_str(&first_tag);
 2120|      4|                            rebuilt.push_str(&body[first_end..second_start]);
 2121|      4|                            rebuilt.push_str(&second_tag);
 2122|      4|                            rebuilt.push_str(&body[second_end..]);
 2123|      4|                            body_out = rebuilt;
 2124|      4|                            changed = true;
 2125|      1|                        }
 2126|      1|                    }
 2127|      1|                }
 2128|      1|            }
 2129|      8|            out.push_str(g_tag);
 2130|      8|            out.push_str(&body_out);
 2131|      8|            out.push_str("</g>");
 2132|      8|            cursor = body_end + 4;
 2133|       |        }
 2134|     10|        out.push_str(&svg[cursor..]);
 2135|     10|        if changed {
 2136|      4|            Some(out)
 2137|       |        } else {
 2138|      6|            None
 2139|       |        }
 2140|     15|    }
 2141|       |
 2142|     11|    fn fix_er_attribute_fills(svg: &str) -> Option<String> {
 2143|     11|        if !svg.contains("attributeBoxOdd") && !svg.contains("attributeBoxEven") {
                                                             ^6
 2144|      5|            return None;
 2145|      6|        }
 2146|      6|        let mut out = String::with_capacity(svg.len() + 32);
 2147|      6|        let mut remaining = svg;
 2148|      6|        let mut changed = false;
 2149|     13|        while let Some(idx) = remaining.find("<rect") {
                                     ^8
 2150|      8|            let (before, after) = remaining.split_at(idx);
 2151|      8|            out.push_str(before);
 2152|      8|            let end = match after.find('>') {
                              ^7
 2153|      7|                Some(pos) => pos + 1,
 2154|       |                None => {
 2155|      1|                    out.push_str(after);
 2156|      1|                    remaining = "";
 2157|      1|                    break;
 2158|       |                }
 2159|       |            };
 2160|      7|            let (tag, rest) = after.split_at(end);
 2161|      7|            let mut updated = tag.to_string();
 2162|      7|            if tag.contains("attributeBoxOdd") {
 2163|      4|                updated = Self::upsert_attr(&updated, "fill", "#ffffff");
 2164|      4|            } else if tag.contains("attributeBoxEven") {
                                    ^3  ^3
 2165|      2|                updated = Self::upsert_attr(&updated, "fill", "#f2f2f2");
 2166|      2|            }
                          ^1
 2167|      7|            if updated != tag {
 2168|      5|                changed = true;
 2169|      5|            }
                          ^2
 2170|      7|            out.push_str(&updated);
 2171|      7|            remaining = rest;
 2172|       |        }
 2173|      6|        out.push_str(remaining);
 2174|      6|        if changed {
 2175|      4|            Some(out)
 2176|       |        } else {
 2177|      2|            None
 2178|       |        }
 2179|     11|    }
 2180|       |
 2181|     44|    fn find_svg_attr(tag: &str, name: &str) -> Option<String> {
 2182|     44|        let needle = format!("{name}=\"");
 2183|     44|        let start = tag.find(&needle)? + needle.len();
                          ^33                      ^11 ^33    ^33
 2184|     33|        let end = tag[start..].find('"')? + start;
                          ^32                         ^1  ^32
 2185|     32|        Some(tag[start..end].to_string())
 2186|     44|    }
 2187|       |
 2188|      8|    fn replace_svg_attr(tag: &str, name: &str, value: &str) -> String {
 2189|      8|        let needle = format!("{name}=\"");
 2190|      8|        let start = match tag.find(&needle) {
                          ^7
 2191|      7|            Some(idx) => idx + needle.len(),
 2192|      1|            None => return tag.to_string(),
 2193|       |        };
 2194|      7|        let end = match tag[start..].find('"') {
                          ^6
 2195|      6|            Some(idx) => start + idx,
 2196|      1|            None => return tag.to_string(),
 2197|       |        };
 2198|      6|        let mut out = String::with_capacity(tag.len() + value.len());
 2199|      6|        out.push_str(&tag[..start]);
 2200|      6|        out.push_str(value);
 2201|      6|        out.push_str(&tag[end..]);
 2202|      6|        out
 2203|      8|    }
 2204|       |
 2205|     27|    fn remove_svg_attr(tag: &str, name: &str) -> String {
 2206|     27|        let needle = format!("{name}=\"");
 2207|     27|        let start = match tag.find(&needle) {
                          ^19
 2208|     19|            Some(idx) => idx,
 2209|      8|            None => return tag.to_string(),
 2210|       |        };
 2211|     19|        let value_start = start + needle.len();
 2212|     19|        let end = match tag[value_start..].find('"') {
                          ^18
 2213|     18|            Some(idx) => value_start + idx + 1,
 2214|      1|            None => return tag.to_string(),
 2215|       |        };
 2216|     18|        let mut out = String::with_capacity(tag.len());
 2217|     18|        out.push_str(&tag[..start]);
 2218|     18|        let rest = &tag[end..];
 2219|     18|        if out.ends_with(' ') && rest.starts_with(' ') {
                                               ^17  ^17
 2220|     16|            out.pop();
 2221|     16|        }
                      ^2
 2222|     18|        out.push_str(rest);
 2223|     18|        out
 2224|     27|    }
 2225|       |
 2226|     24|    fn strip_svg_attr(svg: &str, name: &str) -> Option<String> {
 2227|     24|        let start = svg.find("<svg")?;
                          ^23                     ^1
 2228|     23|        let end = svg[start..].find('>')? + start;
                          ^22                         ^1  ^22
 2229|     22|        let tag = &svg[start..=end];
 2230|     22|        let new_tag = Self::remove_svg_attr(tag, name);
 2231|     22|        if new_tag == tag {
 2232|      7|            return None;
 2233|     15|        }
 2234|     15|        let mut out = String::with_capacity(svg.len());
 2235|     15|        out.push_str(&svg[..start]);
 2236|     15|        out.push_str(&new_tag);
 2237|     15|        out.push_str(&svg[end + 1..]);
 2238|     15|        Some(out)
 2239|     24|    }
 2240|       |
 2241|      6|    fn insert_svg_attr(tag: &str, name: &str, value: &str) -> String {
 2242|      6|        let insert_pos = match tag.find("<svg") {
                          ^5
 2243|      5|            Some(idx) => idx + 4,
 2244|      1|            None => return tag.to_string(),
 2245|       |        };
 2246|      5|        let mut out = String::with_capacity(tag.len() + name.len() + value.len() + 4);
 2247|      5|        out.push_str(&tag[..insert_pos]);
 2248|      5|        out.push_str(&format!(" {name}=\"{value}\""));
 2249|      5|        out.push_str(&tag[insert_pos..]);
 2250|      5|        out
 2251|      6|    }
 2252|       |
 2253|     30|    fn parse_viewbox_dims(viewbox: &str) -> Option<(f32, f32)> {
 2254|     30|        let mut nums = Vec::new();
 2255|    114|        for part in viewbox
                                  ^30
 2256|    395|            .split(|c: char| c.is_whitespace() || c == ',')
                           ^30                                  ^317
 2257|    114|            .filter(|part| !part.is_empty())
                           ^30
 2258|       |        {
 2259|    114|            if let Ok(value) = part.parse::<f32>() {
                                    ^112
 2260|    112|                nums.push(value);
 2261|    112|            }
                          ^2
 2262|       |        }
 2263|     30|        if nums.len() < 4 {
 2264|      2|            return None;
 2265|     28|        }
 2266|     28|        let width = nums[2];
 2267|     28|        let height = nums[3];
 2268|     28|        if width.is_finite() && height.is_finite() && width > 0.0 && height > 0.0 {
                                              ^26    ^26            ^25            ^23
 2269|     22|            Some((width, height))
 2270|       |        } else {
 2271|      6|            None
 2272|       |        }
 2273|     30|    }
 2274|       |
 2275|     23|    fn format_dim(value: f32) -> String {
 2276|     23|        let mut out = format!("{:.3}", value);
 2277|     67|        while out.contains('.') && out.ends_with('0') {
                                                 ^66
 2278|     44|            out.pop();
 2279|     44|        }
 2280|     23|        if out.ends_with('.') {
 2281|     14|            out.pop();
 2282|     14|        }
                      ^9
 2283|     23|        out
 2284|     23|    }
 2285|       |
 2286|      8|    fn process_job(&mut self, job: MermaidRequest) -> MermaidResult {
 2287|       |        let MermaidRequest {
 2288|      8|            svg_key,
 2289|      8|            texture_key,
 2290|      8|            code,
 2291|      8|            svg,
 2292|      8|            width_bucket,
 2293|      8|            scale_bucket,
 2294|      8|            viewport_width,
 2295|      8|            viewport_height,
 2296|      8|            bg,
 2297|      8|        } = job;
 2298|      8|        let code_ref = code.as_deref();
 2299|      8|        let svg_result = match svg {
 2300|      2|            Some(svg) => Ok(svg),
 2301|      6|            None => match code_ref {
 2302|      5|                Some(code) => self.render_svg(svg_key, code, viewport_width, viewport_height),
 2303|      1|                None => Err("Mermaid render request missing code".to_string()),
 2304|       |            },
 2305|       |        };
 2306|       |
 2307|      8|        match svg_result {
 2308|      5|            Ok(svg) => {
 2309|      5|                let mut svg = Self::normalize_svg_size(&svg);
 2310|      5|                if let Some(updated) = Self::flatten_svg_switches(&svg) {
                                          ^1
 2311|      1|                    svg = updated;
 2312|      4|                }
 2313|      5|                let theme = MermaidRenderer::mermaid_theme_values();
 2314|      5|                if let Some(updated) = Self::fix_journey_section_text(&svg, &theme.text) {
                                          ^1
 2315|      1|                    svg = updated;
 2316|      4|                }
 2317|      5|                if let Some(updated) = Self::fix_state_end_circles(&svg) {
                                          ^1
 2318|      1|                    svg = updated;
 2319|      4|                }
 2320|      5|                if let Some(updated) = Self::fix_er_attribute_fills(&svg) {
                                          ^1
 2321|      1|                    svg = updated;
 2322|      4|                }
 2323|      5|                Self::maybe_dump_svg(svg_key, code_ref, &svg);
 2324|      5|                match self.rasterize_svg(&svg, width_bucket, scale_bucket, bg) {
 2325|      4|                    Ok((rgba, w, h)) => MermaidResult {
 2326|      4|                        svg_key,
 2327|      4|                        texture_key,
 2328|      4|                        svg: Some(svg),
 2329|      4|                        rgba: Some(rgba),
 2330|      4|                        size: Some((w, h)),
 2331|      4|                        error: None,
 2332|      4|                    },
 2333|      1|                    Err(err) => {
 2334|      1|                        Self::maybe_dump_error(svg_key, code_ref, &err);
 2335|      1|                        MermaidResult {
 2336|      1|                            svg_key,
 2337|      1|                            texture_key,
 2338|      1|                            svg: Some(svg),
 2339|      1|                            rgba: None,
 2340|      1|                            size: None,
 2341|      1|                            error: Some(err),
 2342|      1|                        }
 2343|       |                    }
 2344|       |                }
 2345|       |            }
 2346|      3|            Err(err) => {
 2347|      3|                Self::maybe_dump_error(svg_key, code_ref, &err);
 2348|      3|                MermaidResult {
 2349|      3|                    svg_key,
 2350|      3|                    texture_key,
 2351|      3|                    svg: None,
 2352|      3|                    rgba: None,
 2353|      3|                    size: None,
 2354|      3|                    error: Some(err),
 2355|      3|                }
 2356|       |            }
 2357|       |        }
 2358|      8|    }
 2359|       |
 2360|     15|    fn parse_raw_svg_tree(svg: &str, opt: &usvg::Options) -> Result<usvg::Tree, String> {
 2361|       |        #[cfg(test)]
 2362|     15|        if FORCE_RAW_TREE_PARSE_FAIL.swap(false, Ordering::Relaxed) {
 2363|      1|            return Err("forced raw svg parse failure".to_string());
 2364|     14|        }
 2365|     14|        usvg::Tree::from_data(svg.as_bytes(), opt).map_err(|e| format!("{}", e))
                                                                             ^1      ^1
 2366|     15|    }
 2367|       |
 2368|     40|    fn bbox_is_valid(width: f32, height: f32, x: f32, y: f32) -> bool {
 2369|     40|        width.is_finite()
 2370|     39|            && height.is_finite()
 2371|     38|            && width > 0.5
 2372|     25|            && height > 0.5
 2373|     24|            && x.is_finite()
 2374|     23|            && y.is_finite()
 2375|     40|    }
 2376|       |
 2377|     16|    fn should_resize_bbox(
 2378|     16|        force_resize: bool,
 2379|     16|        oversize_ok: bool,
 2380|     16|        bbox_w: f32,
 2381|     16|        bbox_h: f32,
 2382|     16|        w_f: f32,
 2383|     16|        h_f: f32,
 2384|     16|    ) -> bool {
 2385|     16|        (force_resize && oversize_ok) || (oversize_ok && (bbox_w > w_f * 1.2 || bbox_h > h_f * 1.2))
                                       ^4               ^13             ^10                   ^7
 2386|     16|    }
 2387|       |
 2388|     22|    fn rasterize_svg(
 2389|     22|        &self,
 2390|     22|        svg: &str,
 2391|     22|        width_bucket: u32,
 2392|     22|        scale_bucket: u32,
 2393|     22|        bg: Option<[u8; 4]>,
 2394|     22|    ) -> Result<(Vec<u8>, u32, u32), String> {
 2395|     22|        let opt = usvg::Options {
 2396|     22|            resources_dir: None,
 2397|     22|            fontdb: Arc::clone(&self.fontdb),
 2398|     22|            image_href_resolver: Self::image_href_resolver(),
 2399|     22|            ..Default::default()
 2400|     22|        };
 2401|       |
 2402|     22|        let tree = usvg::Tree::from_data(svg.as_bytes(), &opt).map_err(|e| format!("{}", e))?;
                          ^20                                                            ^2      ^2       ^2
 2403|     20|        let mut tree = tree;
 2404|     20|        let sz = tree.size().to_int_size();
 2405|     20|        let (mut w, mut h) = (sz.width(), sz.height());
 2406|     20|        let viewbox_dims = Self::find_svg_attr(svg, "viewBox")
 2407|     20|            .and_then(|value| Self::parse_viewbox_dims(&value))
                                            ^14                      ^14
 2408|     20|            .filter(|(vw, vh)| *vw > 0.5 && *vh > 0.5);
                                             ^13          ^12
 2409|     20|        if let Some((vw, vh)) = viewbox_dims {
                                   ^12 ^12
 2410|     12|            w = vw.ceil() as u32;
 2411|     12|            h = vh.ceil() as u32;
 2412|     12|        }
                      ^8
 2413|     20|        let mut translate_x = 0.0_f32;
 2414|     20|        let mut translate_y = 0.0_f32;
 2415|       |
 2416|     20|        let mut bbox = tree.root().abs_stroke_bounding_box();
 2417|     20|        let mut bbox_w = bbox.width();
 2418|     20|        let mut bbox_h = bbox.height();
 2419|     20|        let mut bbox_valid = Self::bbox_is_valid(bbox_w, bbox_h, bbox.x(), bbox.y());
 2420|     20|        let mut force_bbox_resize = false;
 2421|       |
 2422|     20|        let oversize_cap = 6.0_f32;
 2423|     20|        if let Some(raw_svg) = Self::strip_svg_attr(svg, "viewBox") {
                                  ^14
 2424|     14|            if let Ok(raw_tree) = Self::parse_raw_svg_tree(&raw_svg, &opt) {
                                    ^13
 2425|     13|                let raw_bbox = raw_tree.root().abs_stroke_bounding_box();
 2426|     13|                let raw_w = raw_bbox.width();
 2427|     13|                let raw_h = raw_bbox.height();
 2428|     13|                let raw_valid = Self::bbox_is_valid(raw_w, raw_h, raw_bbox.x(), raw_bbox.y());
 2429|     13|                let size_w = w as f32;
 2430|     13|                let size_h = h as f32;
 2431|     13|                let oversize_ok = raw_w <= size_w * oversize_cap && raw_h <= size_h * oversize_cap;
                                                                                  ^12
 2432|     13|                let oversized =
 2433|     13|                    raw_valid && oversize_ok && (raw_w > size_w * 1.2 || raw_h > size_h * 1.2);
                                               ^10             ^9                      ^8
 2434|     13|                if oversized {
 2435|      2|                    tree = raw_tree;
 2436|      2|                    bbox = raw_bbox;
 2437|      2|                    bbox_w = raw_w;
 2438|      2|                    bbox_h = raw_h;
 2439|      2|                    bbox_valid = raw_valid;
 2440|      2|                    force_bbox_resize = true;
 2441|     11|                }
 2442|      1|            }
 2443|      6|        }
 2444|     20|        if bbox_valid {
 2445|     11|            let w_f = w as f32;
 2446|     11|            let h_f = h as f32;
 2447|     11|            let oversize_ok = bbox_w <= w_f * oversize_cap && bbox_h <= h_f * oversize_cap;
                                                                            ^10
 2448|     11|            let oversize =
 2449|     11|                Self::should_resize_bbox(force_bbox_resize, oversize_ok, bbox_w, bbox_h, w_f, h_f);
 2450|     11|            if oversize {
 2451|      4|                let padding = 4.0_f32;
 2452|      4|                let padded_w = (bbox_w + padding * 2.0).max(1.0);
 2453|      4|                let padded_h = (bbox_h + padding * 2.0).max(1.0);
 2454|      4|                w = padded_w.ceil() as u32;
 2455|      4|                h = padded_h.ceil() as u32;
 2456|      4|                translate_x = -bbox.x() + padding;
 2457|      4|                translate_y = -bbox.y() + padding;
 2458|      7|            }
 2459|      9|        }
 2460|       |
 2461|     20|        let base_scale = MermaidRenderer::scale_from_bucket(scale_bucket);
 2462|     20|        let mut scale = base_scale;
 2463|     20|        if width_bucket > 0 {
 2464|      4|            let width_scale = width_bucket as f32 / w.max(1) as f32;
 2465|      4|            scale = scale.min(width_scale);
 2466|     16|        }
 2467|     20|        scale = scale.clamp(0.01, 4.0);
 2468|     20|        let adjustment = Self::scale_adjustment_for_svg(svg);
 2469|     20|        scale = (scale * adjustment).clamp(0.01, 4.0);
 2470|       |
 2471|     20|        let mut target_w = (w as f32 * scale).round() as u32;
 2472|     20|        let mut target_h = (h as f32 * scale).round() as u32;
 2473|     20|        target_w = target_w.max(1);
 2474|     20|        target_h = target_h.max(1);
 2475|       |
 2476|     20|        if std::env::var("MDMDVIEW_MERMAID_LOG_RASTER").is_ok() {
 2477|     14|            eprintln!(
 2478|     14|                "Mermaid raster: svg={}x{} target={}x{} scale={:.3} bbox_valid={} bbox=({:.2},{:.2},{:.2},{:.2})",
 2479|     14|                w,
 2480|     14|                h,
 2481|     14|                target_w,
 2482|     14|                target_h,
 2483|     14|                scale,
 2484|     14|                bbox_valid,
 2485|     14|                bbox.x(),
 2486|     14|                bbox.y(),
 2487|     14|                bbox_w,
 2488|     14|                bbox_h
 2489|     14|            );
 2490|     14|        }
                      ^6
 2491|       |
 2492|     20|        let max_side = MermaidRenderer::MERMAID_MAX_RENDER_SIDE;
 2493|     20|        if target_w > max_side || target_h > max_side {
                                                ^18
 2494|      3|            let clamp_scale =
 2495|      3|                (max_side as f32 / target_w as f32).min(max_side as f32 / target_h as f32);
 2496|      3|            scale = (scale * clamp_scale).clamp(0.01, 4.0);
 2497|      3|            target_w = (w as f32 * scale).round() as u32;
 2498|      3|            target_h = (h as f32 * scale).round() as u32;
 2499|     17|        }
 2500|       |
 2501|     20|        let mut pixmap = pixmap_new_for_test(target_w, target_h)
                          ^19
 2502|     20|            .ok_or_else(|| "Pixmap alloc failed".to_string())?;
                                         ^1                    ^1          ^1
 2503|     19|        if let Some([r, g, b, a]) = bg {
                                   ^4 ^4 ^4 ^4
 2504|      4|            let color = tiny_skia::Color::from_rgba8(r, g, b, a);
 2505|      4|            pixmap.fill(color);
 2506|     15|        }
 2507|       |
 2508|     19|        let mut pmut = pixmap.as_mut();
 2509|     19|        let mut transform = tiny_skia::Transform::from_scale(scale, scale);
 2510|     19|        if translate_x != 0.0 || translate_y != 0.0 {
                                               ^16
 2511|      4|            transform = transform.pre_translate(translate_x, translate_y);
 2512|     15|        }
 2513|     19|        resvg::render(&tree, transform, &mut pmut);
 2514|     19|        let data = pixmap.data().to_vec();
 2515|     19|        Ok((data, target_w, target_h))
 2516|     22|    }
 2517|       |
 2518|     23|    fn image_href_resolver() -> usvg::ImageHrefResolver<'static> {
 2519|     23|        let resolve_data = usvg::ImageHrefResolver::default_data_resolver();
 2520|     23|        let resolve_string = Box::new(|_: &str, _: &usvg::Options| None);
 2521|     23|        usvg::ImageHrefResolver {
 2522|     23|            resolve_data,
 2523|     23|            resolve_string,
 2524|     23|        }
 2525|     23|    }
 2526|       |
 2527|     23|    fn scale_adjustment_for_svg(svg: &str) -> f32 {
 2528|     23|        if svg.contains("aria-roledescription=\"er\"") || svg.contains("aria-roledescription='er'")
                                                                        ^22 ^22
 2529|       |        {
 2530|      2|            0.94
 2531|       |        } else {
 2532|     21|            1.0
 2533|       |        }
 2534|     23|    }
 2535|       |
 2536|    367|    fn now_ms() -> u64 {
 2537|    367|        SystemTime::now()
 2538|    367|            .duration_since(UNIX_EPOCH)
 2539|    367|            .unwrap_or_default()
 2540|    367|            .as_millis() as u64
 2541|    367|    }
 2542|       |}
 2543|       |
 2544|       |#[cfg(feature = "mermaid-quickjs")]
 2545|       |const MERMAID_DOM_SHIM: &str = r#"
 2546|       |var window = globalThis;
 2547|       |var __mdmdview_text_cache = {};
 2548|       |window.__mdmdview_bbox_rev = 0;
 2549|       |function __mdmdview_bump_bbox_rev() {
 2550|       |  window.__mdmdview_bbox_rev = (window.__mdmdview_bbox_rev || 0) + 1;
 2551|       |}
 2552|       |function __mdmdview_measure_text(text, fontSize, fontWeight) {
 2553|       |  var size = fontSize || 16;
 2554|       |  var raw = text ? String(text) : '';
 2555|       |  if (!raw.length) {
 2556|       |    return { width: 0, height: 0 };
 2557|       |  }
 2558|       |  var weight = (typeof fontWeight === 'number' && !isNaN(fontWeight)) ? fontWeight : null;
 2559|       |  var key = size + '|' + (weight || 0) + '|' + raw;
 2560|       |  var hit = __mdmdview_text_cache[key];
 2561|       |  if (hit) { return hit; }
 2562|       |  if (typeof __mdmdview_measure_text_native === 'function') {
 2563|       |    try {
 2564|       |      var native = __mdmdview_measure_text_native(raw, size, weight);
 2565|       |      if (native && typeof native.width === 'number' && typeof native.height === 'number') {
 2566|       |        __mdmdview_text_cache[key] = native;
 2567|       |        return native;
 2568|       |      }
 2569|       |      if (native && typeof native.length === 'number' && native.length >= 2) {
 2570|       |        var w = Number(native[0]);
 2571|       |        var h = Number(native[1]);
 2572|       |        if (isFinite(w) && isFinite(h)) {
 2573|       |          var converted = { width: w, height: h };
 2574|       |          __mdmdview_text_cache[key] = converted;
 2575|       |          return converted;
 2576|       |        }
 2577|       |      }
 2578|       |    } catch (e) {}
 2579|       |  }
 2580|       |  var lines = raw.split(/\n/);
 2581|       |  var maxLen = 0;
 2582|       |  for (var i = 0; i < lines.length; i++) {
 2583|       |    if (lines[i].length > maxLen) { maxLen = lines[i].length; }
 2584|       |  }
 2585|       |  var width = maxLen * size * 0.5;
 2586|       |  var height = lines.length * size * 1.2;
 2587|       |  var res = { width: width, height: height };
 2588|       |  __mdmdview_text_cache[key] = res;
 2589|       |  return res;
 2590|       |}
 2591|       |function __mdmdview_parse_font_size(value, baseSize) {
 2592|       |  if (value === null || value === undefined) { return baseSize; }
 2593|       |  var raw = String(value).trim();
 2594|       |  if (!raw) { return baseSize; }
 2595|       |  var num = parseFloat(raw);
 2596|       |  if (isNaN(num)) { return baseSize; }
 2597|       |  if (raw.indexOf('em') >= 0) {
 2598|       |    var base = baseSize || 16;
 2599|       |    return num * base;
 2600|       |  }
 2601|       |  if (raw.indexOf('ex') >= 0) {
 2602|       |    var baseEx = baseSize || 16;
 2603|       |    return num * baseEx * 0.5;
 2604|       |  }
 2605|       |  return num;
 2606|       |}
 2607|       |function __mdmdview_parse_font_weight_value(value) {
 2608|       |  if (value === null || value === undefined) { return null; }
 2609|       |  var raw = String(value).trim().toLowerCase();
 2610|       |  if (!raw) { return null; }
 2611|       |  if (raw === 'normal') { return 400; }
 2612|       |  if (raw === 'bold' || raw === 'bolder') { return 700; }
 2613|       |  if (raw === 'lighter') { return 300; }
 2614|       |  var num = parseFloat(raw);
 2615|       |  if (isNaN(num)) { return null; }
 2616|       |  return num;
 2617|       |}
 2618|       |function __mdmdview_parse_css_font_sizes(cssText, cache) {
 2619|       |  if (!cssText || !cache) { return; }
 2620|       |  var chunks = String(cssText).split('}');
 2621|       |  for (var i = 0; i < chunks.length; i++) {
 2622|       |    var rule = chunks[i];
 2623|       |    var parts = rule.split('{');
 2624|       |    if (parts.length < 2) { continue; }
 2625|       |    var selector = parts[0];
 2626|       |    var body = parts.slice(1).join('{');
 2627|       |    if (!selector || !body) { continue; }
 2628|       |    var sizeMatch = body.match(/font-size\s*:\s*([^;]+)/i);
 2629|       |    if (!sizeMatch) { continue; }
 2630|       |    var sizeValue = sizeMatch[1];
 2631|       |    var size = __mdmdview_parse_font_size(sizeValue, 16);
 2632|       |    if (!size || isNaN(size)) { continue; }
 2633|       |    var selectors = selector.split(',');
 2634|       |    for (var s = 0; s < selectors.length; s++) {
 2635|       |      var sel = selectors[s].trim();
 2636|       |      if (!sel) { continue; }
 2637|       |      if (sel.indexOf(':') >= 0) { continue; }
 2638|       |      var classMatches = sel.match(/\\.([A-Za-z0-9_-]+)/g);
 2639|       |      if (!classMatches || classMatches.length !== 1) { continue; }
 2640|       |      var cls = classMatches[0].slice(1);
 2641|       |      if (!cls) { continue; }
 2642|       |      if (!cache[cls] || cache[cls] < size) {
 2643|       |        cache[cls] = size;
 2644|       |      }
 2645|       |    }
 2646|       |  }
 2647|       |}
 2648|       |function __mdmdview_parse_css_font_weights(cssText, cache) {
 2649|       |  if (!cssText || !cache) { return; }
 2650|       |  var chunks = String(cssText).split('}');
 2651|       |  for (var i = 0; i < chunks.length; i++) {
 2652|       |    var rule = chunks[i];
 2653|       |    var parts = rule.split('{');
 2654|       |    if (parts.length < 2) { continue; }
 2655|       |    var selector = parts[0];
 2656|       |    var body = parts.slice(1).join('{');
 2657|       |    if (!selector || !body) { continue; }
 2658|       |    var weightMatch = body.match(/font-weight\s*:\s*([^;]+)/i);
 2659|       |    if (!weightMatch) { continue; }
 2660|       |    var weightValue = weightMatch[1];
 2661|       |    var weight = __mdmdview_parse_font_weight_value(weightValue);
 2662|       |    if (!weight || isNaN(weight)) { continue; }
 2663|       |    var selectors = selector.split(',');
 2664|       |    for (var s = 0; s < selectors.length; s++) {
 2665|       |      var sel = selectors[s].trim();
 2666|       |      if (!sel) { continue; }
 2667|       |      if (sel.indexOf(':') >= 0) { continue; }
 2668|       |      var classMatches = sel.match(/\\.([A-Za-z0-9_-]+)/g);
 2669|       |      if (!classMatches || classMatches.length !== 1) { continue; }
 2670|       |      var cls = classMatches[0].slice(1);
 2671|       |      if (!cls) { continue; }
 2672|       |      if (!cache[cls] || cache[cls] < weight) {
 2673|       |        cache[cls] = weight;
 2674|       |      }
 2675|       |    }
 2676|       |  }
 2677|       |}
 2678|       |function __mdmdview_collect_style_texts(node, out) {
 2679|       |  if (!node || !out) { return; }
 2680|       |  var name = (node.tagName || '').toLowerCase();
 2681|       |  if (name === 'style') {
 2682|       |    var text = __mdmdview_collect_text(node);
 2683|       |    if (text) { out.push(text); }
 2684|       |  }
 2685|       |  if (!node.children) { return; }
 2686|       |  for (var i = 0; i < node.children.length; i++) {
 2687|       |    __mdmdview_collect_style_texts(node.children[i], out);
 2688|       |  }
 2689|       |}
 2690|       |function __mdmdview_find_root_node(node) {
 2691|       |  if (!node) { return null; }
 2692|       |  var current = node;
 2693|       |  var last = node;
 2694|       |  var depth = 0;
 2695|       |  while (current && depth < 120) {
 2696|       |    last = current;
 2697|       |    if (!current.__mdmdview_parent_set) { break; }
 2698|       |    current = current.parentNode;
 2699|       |    depth += 1;
 2700|       |  }
 2701|       |  return last;
 2702|       |}
 2703|       |function __mdmdview_style_cache() {
 2704|       |  var rev = window.__mdmdview_bbox_rev || 0;
 2705|       |  if (window.__mdmdview_font_cache && window.__mdmdview_font_cache_rev === rev) {
 2706|       |    return window.__mdmdview_font_cache;
 2707|       |  }
 2708|       |  var cache = {};
 2709|       |  if (typeof document !== 'undefined' && document && document.getElementsByTagName) {
 2710|       |    var styles = document.getElementsByTagName('style') || [];
 2711|       |    for (var i = 0; i < styles.length; i++) {
 2712|       |      var text = styles[i] ? __mdmdview_collect_text(styles[i]) : '';
 2713|       |      __mdmdview_parse_css_font_sizes(text, cache);
 2714|       |    }
 2715|       |  }
 2716|       |  window.__mdmdview_font_cache = cache;
 2717|       |  window.__mdmdview_font_cache_rev = rev;
 2718|       |  window.__mdmdview_font_cache_root = null;
 2719|       |  window.__mdmdview_font_cache_root_rev = rev;
 2720|       |  return cache;
 2721|       |}
 2722|       |function __mdmdview_style_cache_for_node(node) {
 2723|       |  var cache = __mdmdview_style_cache();
 2724|       |  if (!node) { return cache; }
 2725|       |  var rev = window.__mdmdview_bbox_rev || 0;
 2726|       |  var root = __mdmdview_find_root_node(node);
 2727|       |  if (!root) { return cache; }
 2728|       |  if (window.__mdmdview_font_cache_root === root && window.__mdmdview_font_cache_root_rev === rev) {
 2729|       |    return cache;
 2730|       |  }
 2731|       |  var texts = [];
 2732|       |  __mdmdview_collect_style_texts(root, texts);
 2733|       |  for (var i = 0; i < texts.length; i++) {
 2734|       |    __mdmdview_parse_css_font_sizes(texts[i], cache);
 2735|       |  }
 2736|       |  window.__mdmdview_font_cache_root = root;
 2737|       |  window.__mdmdview_font_cache_root_rev = rev;
 2738|       |  return cache;
 2739|       |}
 2740|       |function __mdmdview_style_weight_cache() {
 2741|       |  var rev = window.__mdmdview_bbox_rev || 0;
 2742|       |  if (window.__mdmdview_font_weight_cache && window.__mdmdview_font_weight_cache_rev === rev) {
 2743|       |    return window.__mdmdview_font_weight_cache;
 2744|       |  }
 2745|       |  var cache = {};
 2746|       |  if (typeof document !== 'undefined' && document && document.getElementsByTagName) {
 2747|       |    var styles = document.getElementsByTagName('style') || [];
 2748|       |    for (var i = 0; i < styles.length; i++) {
 2749|       |      var text = styles[i] ? __mdmdview_collect_text(styles[i]) : '';
 2750|       |      __mdmdview_parse_css_font_weights(text, cache);
 2751|       |    }
 2752|       |  }
 2753|       |  window.__mdmdview_font_weight_cache = cache;
 2754|       |  window.__mdmdview_font_weight_cache_rev = rev;
 2755|       |  window.__mdmdview_font_weight_cache_root = null;
 2756|       |  window.__mdmdview_font_weight_cache_root_rev = rev;
 2757|       |  return cache;
 2758|       |}
 2759|       |function __mdmdview_style_weight_cache_for_node(node) {
 2760|       |  var cache = __mdmdview_style_weight_cache();
 2761|       |  if (!node) { return cache; }
 2762|       |  var rev = window.__mdmdview_bbox_rev || 0;
 2763|       |  var root = __mdmdview_find_root_node(node);
 2764|       |  if (!root) { return cache; }
 2765|       |  if (window.__mdmdview_font_weight_cache_root === root && window.__mdmdview_font_weight_cache_root_rev === rev) {
 2766|       |    return cache;
 2767|       |  }
 2768|       |  var texts = [];
 2769|       |  __mdmdview_collect_style_texts(root, texts);
 2770|       |  for (var i = 0; i < texts.length; i++) {
 2771|       |    __mdmdview_parse_css_font_weights(texts[i], cache);
 2772|       |  }
 2773|       |  window.__mdmdview_font_weight_cache_root = root;
 2774|       |  window.__mdmdview_font_weight_cache_root_rev = rev;
 2775|       |  return cache;
 2776|       |}
 2777|       |function __mdmdview_class_font_size(el) {
 2778|       |  if (!el) { return null; }
 2779|       |  var cache = __mdmdview_style_cache_for_node(el);
 2780|       |  if (!cache) { return null; }
 2781|       |  var list = __mdmdview_get_class_list(el);
 2782|       |  for (var i = 0; i < list.length; i++) {
 2783|       |    var size = cache[list[i]];
 2784|       |    if (size && !isNaN(size)) { return size; }
 2785|       |  }
 2786|       |  return null;
 2787|       |}
 2788|       |function __mdmdview_class_font_weight(el) {
 2789|       |  if (!el) { return null; }
 2790|       |  var cache = __mdmdview_style_weight_cache_for_node(el);
 2791|       |  if (!cache) { return null; }
 2792|       |  var list = __mdmdview_get_class_list(el);
 2793|       |  for (var i = 0; i < list.length; i++) {
 2794|       |    var weight = cache[list[i]];
 2795|       |    if (weight && !isNaN(weight)) { return weight; }
 2796|       |  }
 2797|       |  return null;
 2798|       |}
 2799|       |function __mdmdview_get_font_size(el) {
 2800|       |  var size = 16;
 2801|       |  if (el && el.style && el.style.fontSize) {
 2802|       |    size = __mdmdview_parse_font_size(el.style.fontSize, size);
 2803|       |    if (!isNaN(size)) { return size; }
 2804|       |  }
 2805|       |  if (el && el.style && el.style['font-size']) {
 2806|       |    size = __mdmdview_parse_font_size(el.style['font-size'], size);
 2807|       |    if (!isNaN(size)) { return size; }
 2808|       |  }
 2809|       |  if (el && el.getAttribute) {
 2810|       |    var attr = el.getAttribute('font-size');
 2811|       |    if (attr) {
 2812|       |      var a = __mdmdview_parse_font_size(attr, size);
 2813|       |      if (!isNaN(a)) { size = a; }
 2814|       |    }
 2815|       |  }
 2816|       |  var classSize = __mdmdview_class_font_size(el);
 2817|       |  if (classSize && !isNaN(classSize)) { return classSize; }
 2818|       |  var classList = __mdmdview_get_class_list(el);
 2819|       |  for (var c = 0; c < classList.length; c++) {
 2820|       |    var cls = classList[c];
 2821|       |    if (cls === 'commit-label' || cls === 'commit-label-bkg' || cls === 'tag-label' || cls === 'tag-label-bkg') {
 2822|       |      return 10;
 2823|       |    }
 2824|       |    if (cls === 'gitTitleText') {
 2825|       |      return 18;
 2826|       |    }
 2827|       |  }
 2828|       |  var ancestor = el;
 2829|       |  var steps = 0;
 2830|       |  while (ancestor && steps < 6) {
 2831|       |    if (__mdmdview_has_class(ancestor, 'commit-labels') || __mdmdview_has_class(ancestor, 'tag-labels')) {
 2832|       |      return 10;
 2833|       |    }
 2834|       |    ancestor = ancestor.parentNode;
 2835|       |    steps += 1;
 2836|       |  }
 2837|       |  var current = el;
 2838|       |  var depth = 0;
 2839|       |  while (current && depth < 4) {
 2840|       |    current = current.parentNode;
 2841|       |    if (!current) { break; }
 2842|       |    var parentSize = __mdmdview_class_font_size(current);
 2843|       |    if (parentSize && !isNaN(parentSize)) { return parentSize; }
 2844|       |    depth += 1;
 2845|       |  }
 2846|       |  var tag = (el && el.tagName) ? String(el.tagName).toLowerCase() : '';
 2847|       |  if (tag === 'text' || tag === 'tspan') {
 2848|       |    return size;
 2849|       |  }
 2850|       |  return size;
 2851|       |}
 2852|       |function __mdmdview_get_font_weight_raw(el) {
 2853|       |  if (el && el.style) {
 2854|       |    if (el.style.fontWeight) {
 2855|       |      var sw = __mdmdview_parse_font_weight_value(el.style.fontWeight);
 2856|       |      if (sw && !isNaN(sw)) { return sw; }
 2857|       |    }
 2858|       |    if (el.style['font-weight']) {
 2859|       |      var sw2 = __mdmdview_parse_font_weight_value(el.style['font-weight']);
 2860|       |      if (sw2 && !isNaN(sw2)) { return sw2; }
 2861|       |    }
 2862|       |  }
 2863|       |  if (el && el.getAttribute) {
 2864|       |    var attr = el.getAttribute('font-weight');
 2865|       |    if (attr) {
 2866|       |      var aw = __mdmdview_parse_font_weight_value(attr);
 2867|       |      if (aw && !isNaN(aw)) { return aw; }
 2868|       |    }
 2869|       |  }
 2870|       |  var classWeight = __mdmdview_class_font_weight(el);
 2871|       |  if (classWeight && !isNaN(classWeight)) { return classWeight; }
 2872|       |  var classList = __mdmdview_get_class_list(el);
 2873|       |  for (var i = 0; i < classList.length; i++) {
 2874|       |    var cls = classList[i];
 2875|       |    if (cls === 'classTitle' || cls === 'classTitleText' || cls === 'title') {
 2876|       |      return 700;
 2877|       |    }
 2878|       |  }
 2879|       |  return null;
 2880|       |}
 2881|       |function __mdmdview_get_font_weight(el) {
 2882|       |  var direct = __mdmdview_get_font_weight_raw(el);
 2883|       |  if (direct && !isNaN(direct)) { return direct; }
 2884|       |  var current = el;
 2885|       |  var depth = 0;
 2886|       |  while (current && depth < 4) {
 2887|       |    current = current.parentNode;
 2888|       |    if (!current) { break; }
 2889|       |    var parentWeight = __mdmdview_get_font_weight_raw(current);
 2890|       |    if (parentWeight && !isNaN(parentWeight)) { return parentWeight; }
 2891|       |    depth += 1;
 2892|       |  }
 2893|       |  return 400;
 2894|       |}
 2895|       |function __mdmdview_parse_num(value) {
 2896|       |  var num = parseFloat(value);
 2897|       |  return isNaN(num) ? 0 : num;
 2898|       |}
 2899|       |function __mdmdview_parse_length(value, fontSize) {
 2900|       |  if (value === null || value === undefined) { return 0; }
 2901|       |  var raw = String(value).trim();
 2902|       |  if (!raw) { return 0; }
 2903|       |  var num = parseFloat(raw);
 2904|       |  if (isNaN(num)) { return 0; }
 2905|       |  if (raw.indexOf('em') >= 0) {
 2906|       |    return num * (fontSize || 16);
 2907|       |  }
 2908|       |  if (raw.indexOf('ex') >= 0) {
 2909|       |    return num * (fontSize || 16) * 0.5;
 2910|       |  }
 2911|       |  return num;
 2912|       |}
 2913|       |function __mdmdview_transform_point(el, x, y) {
 2914|       |  var box = __mdmdview_apply_transform(el, { x: x, y: y, width: 0, height: 0 });
 2915|       |  return { x: box.x, y: box.y };
 2916|       |}
 2917|       |function __mdmdview_path_points(el) {
 2918|       |  var d = el && el.getAttribute ? el.getAttribute('d') : null;
 2919|       |  if (!d) { return []; }
 2920|       |  var nums = String(d).match(/-?\d*\.?\d+(?:e[-+]?\d+)?/ig);
 2921|       |  if (!nums || nums.length < 2) { return []; }
 2922|       |  var points = [];
 2923|       |  for (var i = 0; i + 1 < nums.length; i += 2) {
 2924|       |    var x = __mdmdview_parse_num(nums[i]);
 2925|       |    var y = __mdmdview_parse_num(nums[i + 1]);
 2926|       |    points.push(__mdmdview_transform_point(el, x, y));
 2927|       |  }
 2928|       |  return points;
 2929|       |}
 2930|       |function __mdmdview_path_total_length(el) {
 2931|       |  var points = __mdmdview_path_points(el);
 2932|       |  if (points.length < 2) { return 0; }
 2933|       |  var total = 0;
 2934|       |  for (var i = 1; i < points.length; i++) {
 2935|       |    var dx = points[i].x - points[i - 1].x;
 2936|       |    var dy = points[i].y - points[i - 1].y;
 2937|       |    total += Math.sqrt(dx * dx + dy * dy);
 2938|       |  }
 2939|       |  return total;
 2940|       |}
 2941|       |function __mdmdview_path_point_at_length(el, length) {
 2942|       |  var points = __mdmdview_path_points(el);
 2943|       |  if (!points.length) { return { x: 0, y: 0 }; }
 2944|       |  if (points.length === 1) { return points[0]; }
 2945|       |  var remaining = Math.max(0, __mdmdview_parse_num(length));
 2946|       |  for (var i = 1; i < points.length; i++) {
 2947|       |    var p0 = points[i - 1];
 2948|       |    var p1 = points[i];
 2949|       |    var dx = p1.x - p0.x;
 2950|       |    var dy = p1.y - p0.y;
 2951|       |    var seg = Math.sqrt(dx * dx + dy * dy);
 2952|       |    if (seg <= 0) { continue; }
 2953|       |    if (remaining <= seg) {
 2954|       |      var t = remaining / seg;
 2955|       |      return { x: p0.x + dx * t, y: p0.y + dy * t };
 2956|       |    }
 2957|       |    remaining -= seg;
 2958|       |  }
 2959|       |  return points[points.length - 1];
 2960|       |}
 2961|       |function __mdmdview_text_metrics(el) {
 2962|       |  var size = __mdmdview_get_font_size(el);
 2963|       |  var weight = __mdmdview_get_font_weight(el);
 2964|       |  if (!el || !el.children || !el.children.length) {
 2965|       |    var raw = el ? __mdmdview_collect_text(el) : '';
 2966|       |    return __mdmdview_measure_text(raw, size, weight);
 2967|       |  }
 2968|       |  var max_w = 0;
 2969|       |  var max_h = 0;
 2970|       |  var lines = 0;
 2971|       |  for (var i = 0; i < el.children.length; i++) {
 2972|       |    var child = el.children[i];
 2973|       |    var tag = (child.tagName || '').toLowerCase();
 2974|       |    if (tag !== 'tspan') { continue; }
 2975|       |    var text = __mdmdview_collect_text(child);
 2976|       |    if (!text || !String(text).trim()) { continue; }
 2977|       |    var child_weight = __mdmdview_get_font_weight(child);
 2978|       |    var m = __mdmdview_measure_text(text, size, child_weight);
 2979|       |    if (m.width > max_w) { max_w = m.width; }
 2980|       |    if (m.height > max_h) { max_h = m.height; }
 2981|       |    lines += 1;
 2982|       |  }
 2983|       |  if (!lines) {
 2984|       |    var fallback = __mdmdview_collect_text(el);
 2985|       |    return __mdmdview_measure_text(fallback, size, weight);
 2986|       |  }
 2987|       |  var line_height = max_h > 0 ? max_h : size * 1.2;
 2988|       |  return { width: max_w, height: lines * line_height };
 2989|       |}
 2990|       |function __mdmdview_apply_matrix(bbox, a, b, c, d, e, f) {
 2991|       |  if (!bbox) { return bbox; }
 2992|       |  var x = bbox.x;
 2993|       |  var y = bbox.y;
 2994|       |  var w = bbox.width;
 2995|       |  var h = bbox.height;
 2996|       |  var pts = [
 2997|       |    [x, y],
 2998|       |    [x + w, y],
 2999|       |    [x, y + h],
 3000|       |    [x + w, y + h]
 3001|       |  ];
 3002|       |  var min_x = Infinity;
 3003|       |  var min_y = Infinity;
 3004|       |  var max_x = -Infinity;
 3005|       |  var max_y = -Infinity;
 3006|       |  for (var i = 0; i < pts.length; i++) {
 3007|       |    var px = pts[i][0];
 3008|       |    var py = pts[i][1];
 3009|       |    var nx = a * px + c * py + e;
 3010|       |    var ny = b * px + d * py + f;
 3011|       |    if (nx < min_x) { min_x = nx; }
 3012|       |    if (ny < min_y) { min_y = ny; }
 3013|       |    if (nx > max_x) { max_x = nx; }
 3014|       |    if (ny > max_y) { max_y = ny; }
 3015|       |  }
 3016|       |  if (!isFinite(min_x) || !isFinite(min_y) || !isFinite(max_x) || !isFinite(max_y)) {
 3017|       |    return bbox;
 3018|       |  }
 3019|       |  return { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y };
 3020|       |}
 3021|       |function __mdmdview_apply_transform(el, bbox) {
 3022|       |  if (!el || !bbox) { return bbox; }
 3023|       |  var transform = el.getAttribute ? el.getAttribute('transform') : null;
 3024|       |  if (!transform) { return bbox; }
 3025|       |  var current = bbox;
 3026|       |  var re = /([a-zA-Z]+)\(([^)]+)\)/g;
 3027|       |  var match = null;
 3028|       |  while ((match = re.exec(String(transform))) !== null) {
 3029|       |    var name = match[1].toLowerCase();
 3030|       |    var params = match[2].split(/[, ]+/).filter(function(p) { return p.length; });
 3031|       |    var nums = [];
 3032|       |    for (var i = 0; i < params.length; i++) {
 3033|       |      nums.push(__mdmdview_parse_num(params[i]));
 3034|       |    }
 3035|       |    if (name === 'translate') {
 3036|       |      var tx = nums.length ? nums[0] : 0;
 3037|       |      var ty = nums.length > 1 ? nums[1] : 0;
 3038|       |      current = __mdmdview_apply_matrix(current, 1, 0, 0, 1, tx, ty);
 3039|       |    } else if (name === 'scale') {
 3040|       |      var sx = nums.length ? nums[0] : 1;
 3041|       |      var sy = nums.length > 1 ? nums[1] : sx;
 3042|       |      current = __mdmdview_apply_matrix(current, sx, 0, 0, sy, 0, 0);
 3043|       |    } else if (name === 'matrix' && nums.length >= 6) {
 3044|       |      current = __mdmdview_apply_matrix(
 3045|       |        current,
 3046|       |        nums[0],
 3047|       |        nums[1],
 3048|       |        nums[2],
 3049|       |        nums[3],
 3050|       |        nums[4],
 3051|       |        nums[5]
 3052|       |      );
 3053|       |    } else if (name === 'rotate' && nums.length) {
 3054|       |      var angle = nums[0] * Math.PI / 180.0;
 3055|       |      var cos = Math.cos(angle);
 3056|       |      var sin = Math.sin(angle);
 3057|       |      if (nums.length >= 3) {
 3058|       |        var cx = nums[1];
 3059|       |        var cy = nums[2];
 3060|       |        current = __mdmdview_apply_matrix(current, 1, 0, 0, 1, -cx, -cy);
 3061|       |        current = __mdmdview_apply_matrix(current, cos, sin, -sin, cos, 0, 0);
 3062|       |        current = __mdmdview_apply_matrix(current, 1, 0, 0, 1, cx, cy);
 3063|       |      } else {
 3064|       |        current = __mdmdview_apply_matrix(current, cos, sin, -sin, cos, 0, 0);
 3065|       |      }
 3066|       |    } else if (name === 'skewx' && nums.length) {
 3067|       |      var ax = nums[0] * Math.PI / 180.0;
 3068|       |      current = __mdmdview_apply_matrix(current, 1, 0, Math.tan(ax), 1, 0, 0);
 3069|       |    } else if (name === 'skewy' && nums.length) {
 3070|       |      var ay = nums[0] * Math.PI / 180.0;
 3071|       |      current = __mdmdview_apply_matrix(current, 1, Math.tan(ay), 0, 1, 0, 0);
 3072|       |    }
 3073|       |  }
 3074|       |  return current;
 3075|       |}
 3076|       |function __mdmdview_children_bounds(el) {
 3077|       |  if (!el || !el.children || !el.children.length) { return null; }
 3078|       |  var min_x = Infinity;
 3079|       |  var min_y = Infinity;
 3080|       |  var max_x = -Infinity;
 3081|       |  var max_y = -Infinity;
 3082|       |  for (var i = 0; i < el.children.length; i++) {
 3083|       |    var child_box = __mdmdview_bbox(el.children[i]);
 3084|       |    if (!child_box) { continue; }
 3085|       |    if (!isFinite(child_box.width) || !isFinite(child_box.height)) { continue; }
 3086|       |    if (child_box.width <= 0 && child_box.height <= 0) { continue; }
 3087|       |    if (child_box.x < min_x) { min_x = child_box.x; }
 3088|       |    if (child_box.y < min_y) { min_y = child_box.y; }
 3089|       |    if (child_box.x + child_box.width > max_x) { max_x = child_box.x + child_box.width; }
 3090|       |    if (child_box.y + child_box.height > max_y) { max_y = child_box.y + child_box.height; }
 3091|       |  }
 3092|       |  if (isFinite(min_x) && isFinite(min_y) && isFinite(max_x) && isFinite(max_y)) {
 3093|       |    return { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y };
 3094|       |  }
 3095|       |  return null;
 3096|       |}
 3097|       |function __mdmdview_cache_bbox(el, box) {
 3098|       |  if (el && box) {
 3099|       |    el.__mdmdview_bbox_cache = box;
 3100|       |    el.__mdmdview_bbox_rev = window.__mdmdview_bbox_rev || 0;
 3101|       |  }
 3102|       |  return box;
 3103|       |}
 3104|       |function __mdmdview_bbox(el) {
 3105|       |  if (!el) { return { x: 0, y: 0, width: 0, height: 0 }; }
 3106|       |  if (el.__mdmdview_bbox_cache && el.__mdmdview_bbox_rev === (window.__mdmdview_bbox_rev || 0)) {
 3107|       |    return el.__mdmdview_bbox_cache;
 3108|       |  }
 3109|       |  var tag = (el.tagName || '').toLowerCase();
 3110|       |  if (
 3111|       |    tag === 'style'
 3112|       |    || tag === 'defs'
 3113|       |    || tag === 'script'
 3114|       |    || tag === 'title'
 3115|       |    || tag === 'desc'
 3116|       |    || tag === 'metadata'
 3117|       |    || tag === 'marker'
 3118|       |    || tag === 'clippath'
 3119|       |    || tag === 'mask'
 3120|       |    || tag === 'pattern'
 3121|       |    || tag === 'lineargradient'
 3122|       |    || tag === 'radialgradient'
 3123|       |    || tag === 'stop'
 3124|       |  ) {
 3125|       |    return { x: 0, y: 0, width: 0, height: 0 };
 3126|       |  }
 3127|       |  if (tag === '#text') {
 3128|       |    var text = el.textContent || '';
 3129|       |    var size = __mdmdview_get_font_size(el);
 3130|       |    var weight = __mdmdview_get_font_weight(el);
 3131|       |    var m = __mdmdview_measure_text(text, size, weight);
 3132|       |    return __mdmdview_cache_bbox(
 3133|       |      el,
 3134|       |      __mdmdview_apply_transform(el, { x: 0, y: 0, width: m.width, height: m.height })
 3135|       |    );
 3136|       |  }
 3137|       |  if (tag === 'svg') {
 3138|       |    if (el.children && el.children.length) {
 3139|       |      var svg_bounds = __mdmdview_children_bounds(el);
 3140|       |      if (svg_bounds) {
 3141|       |        return __mdmdview_cache_bbox(el, __mdmdview_apply_transform(el, svg_bounds));
 3142|       |      }
 3143|       |    }
 3144|       |  }
 3145|       |  if (tag === 'text' || tag === 'tspan') {
 3146|       |    var metrics = __mdmdview_text_metrics(el);
 3147|       |    var fontSize = __mdmdview_get_font_size(el);
 3148|       |    var tx = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('x') : 0);
 3149|       |    var ty = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('y') : 0);
 3150|       |    var dx = __mdmdview_parse_length(el.getAttribute ? el.getAttribute('dx') : 0, fontSize);
 3151|       |    var dy = __mdmdview_parse_length(el.getAttribute ? el.getAttribute('dy') : 0, fontSize);
 3152|       |    if (tag === 'text' && el.children && el.children.length) {
 3153|       |      var first = el.children[0];
 3154|       |      var firstTag = (first.tagName || '').toLowerCase();
 3155|       |      if (firstTag === 'tspan') {
 3156|       |        if (!dx) { dx = __mdmdview_parse_length(first.getAttribute('dx'), fontSize); }
 3157|       |        if (!dy) { dy = __mdmdview_parse_length(first.getAttribute('dy'), fontSize); }
 3158|       |      }
 3159|       |    }
 3160|       |    tx += dx;
 3161|       |    ty += dy;
 3162|       |    var anchor = el.getAttribute ? el.getAttribute('text-anchor') : null;
 3163|       |    if (!anchor && el.style && el.style.textAnchor) { anchor = el.style.textAnchor; }
 3164|       |    if (anchor === 'middle') {
 3165|       |      tx -= metrics.width * 0.5;
 3166|       |    } else if (anchor === 'end' || anchor === 'right') {
 3167|       |      tx -= metrics.width;
 3168|       |    }
 3169|       |    var baseline = el.getAttribute ? el.getAttribute('dominant-baseline') : null;
 3170|       |    if (!baseline && el.style && el.style.dominantBaseline) { baseline = el.style.dominantBaseline; }
 3171|       |    var y = ty - metrics.height * 0.3;
 3172|       |    if (baseline === 'middle' || baseline === 'central') {
 3173|       |      y = ty - metrics.height * 0.5;
 3174|       |    } else if (baseline === 'hanging') {
 3175|       |      y = ty;
 3176|       |    }
 3177|       |    return __mdmdview_cache_bbox(
 3178|       |      el,
 3179|       |      __mdmdview_apply_transform(el, {
 3180|       |        x: tx,
 3181|       |        y: y,
 3182|       |        width: metrics.width,
 3183|       |        height: metrics.height
 3184|       |      })
 3185|       |    );
 3186|       |  }
 3187|       |  if (tag === 'rect') {
 3188|       |    var rx = __mdmdview_parse_num(el.getAttribute('x'));
 3189|       |    var ry = __mdmdview_parse_num(el.getAttribute('y'));
 3190|       |    var rw = __mdmdview_parse_num(el.getAttribute('width'));
 3191|       |    var rh = __mdmdview_parse_num(el.getAttribute('height'));
 3192|       |    return __mdmdview_cache_bbox(
 3193|       |      el,
 3194|       |      __mdmdview_apply_transform(el, { x: rx, y: ry, width: rw, height: rh })
 3195|       |    );
 3196|       |  }
 3197|       |  if (tag === 'circle') {
 3198|       |    var cx = __mdmdview_parse_num(el.getAttribute('cx'));
 3199|       |    var cy = __mdmdview_parse_num(el.getAttribute('cy'));
 3200|       |    var r = __mdmdview_parse_num(el.getAttribute('r'));
 3201|       |    return __mdmdview_cache_bbox(
 3202|       |      el,
 3203|       |      __mdmdview_apply_transform(el, { x: cx - r, y: cy - r, width: r * 2, height: r * 2 })
 3204|       |    );
 3205|       |  }
 3206|       |  if (tag === 'ellipse') {
 3207|       |    var ecx = __mdmdview_parse_num(el.getAttribute('cx'));
 3208|       |    var ecy = __mdmdview_parse_num(el.getAttribute('cy'));
 3209|       |    var erx = __mdmdview_parse_num(el.getAttribute('rx'));
 3210|       |    var ery = __mdmdview_parse_num(el.getAttribute('ry'));
 3211|       |    return __mdmdview_cache_bbox(
 3212|       |      el,
 3213|       |      __mdmdview_apply_transform(el, { x: ecx - erx, y: ecy - ery, width: erx * 2, height: ery * 2 })
 3214|       |    );
 3215|       |  }
 3216|       |  if (tag === 'line') {
 3217|       |    var x1 = __mdmdview_parse_num(el.getAttribute('x1'));
 3218|       |    var y1 = __mdmdview_parse_num(el.getAttribute('y1'));
 3219|       |    var x2 = __mdmdview_parse_num(el.getAttribute('x2'));
 3220|       |    var y2 = __mdmdview_parse_num(el.getAttribute('y2'));
 3221|       |    var min_x = Math.min(x1, x2);
 3222|       |    var min_y = Math.min(y1, y2);
 3223|       |    var max_x = Math.max(x1, x2);
 3224|       |    var max_y = Math.max(y1, y2);
 3225|       |    return __mdmdview_cache_bbox(
 3226|       |      el,
 3227|       |      __mdmdview_apply_transform(el, { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y })
 3228|       |    );
 3229|       |  }
 3230|       |  if (tag === 'polygon' || tag === 'polyline') {
 3231|       |    var points = el.getAttribute('points');
 3232|       |    if (points) {
 3233|       |      var parts = String(points).trim().split(/[\s,]+/).filter(function(p) { return p.length; });
 3234|       |      if (parts.length >= 2) {
 3235|       |        var min_px = Infinity;
 3236|       |        var min_py = Infinity;
 3237|       |        var max_px = -Infinity;
 3238|       |        var max_py = -Infinity;
 3239|       |        for (var i = 0; i + 1 < parts.length; i += 2) {
 3240|       |          var px = __mdmdview_parse_num(parts[i]);
 3241|       |          var py = __mdmdview_parse_num(parts[i + 1]);
 3242|       |          if (px < min_px) { min_px = px; }
 3243|       |          if (py < min_py) { min_py = py; }
 3244|       |          if (px > max_px) { max_px = px; }
 3245|       |          if (py > max_py) { max_py = py; }
 3246|       |        }
 3247|       |        if (isFinite(min_px) && isFinite(min_py) && isFinite(max_px) && isFinite(max_py)) {
 3248|       |          return __mdmdview_cache_bbox(
 3249|       |            el,
 3250|       |            __mdmdview_apply_transform(el, {
 3251|       |              x: min_px,
 3252|       |              y: min_py,
 3253|       |              width: max_px - min_px,
 3254|       |              height: max_py - min_py
 3255|       |            })
 3256|       |          );
 3257|       |        }
 3258|       |      }
 3259|       |    }
 3260|       |  }
 3261|       |  if (tag === 'path') {
 3262|       |    var d = el.getAttribute('d');
 3263|       |    if (d) {
 3264|       |      var nums = String(d).match(/-?\d*\.?\d+(?:e[-+]?\d+)?/ig);
 3265|       |      if (nums && nums.length >= 2) {
 3266|       |        var min_px = Infinity;
 3267|       |        var min_py = Infinity;
 3268|       |        var max_px = -Infinity;
 3269|       |        var max_py = -Infinity;
 3270|       |        for (var i = 0; i + 1 < nums.length; i += 2) {
 3271|       |          var px = __mdmdview_parse_num(nums[i]);
 3272|       |          var py = __mdmdview_parse_num(nums[i + 1]);
 3273|       |          if (px < min_px) { min_px = px; }
 3274|       |          if (py < min_py) { min_py = py; }
 3275|       |          if (px > max_px) { max_px = px; }
 3276|       |          if (py > max_py) { max_py = py; }
 3277|       |        }
 3278|       |        if (isFinite(min_px) && isFinite(min_py) && isFinite(max_px) && isFinite(max_py)) {
 3279|       |          return __mdmdview_cache_bbox(
 3280|       |            el,
 3281|       |            __mdmdview_apply_transform(el, { x: min_px, y: min_py, width: max_px - min_px, height: max_py - min_py })
 3282|       |          );
 3283|       |        }
 3284|       |      }
 3285|       |    }
 3286|       |  }
 3287|       |  var font_size = __mdmdview_get_font_size(el);
 3288|       |  var width_attr = el.getAttribute ? el.getAttribute('width') : null;
 3289|       |  var height_attr = el.getAttribute ? el.getAttribute('height') : null;
 3290|       |  var bw = __mdmdview_parse_length(width_attr, font_size);
 3291|       |  var bh = __mdmdview_parse_length(height_attr, font_size);
 3292|       |  if ((!bw || !bh) && el.style) {
 3293|       |    if (!bw && el.style.width) { bw = __mdmdview_parse_length(el.style.width, font_size); }
 3294|       |    if (!bh && el.style.height) { bh = __mdmdview_parse_length(el.style.height, font_size); }
 3295|       |  }
 3296|       |  if ((!bw || !bh) && el.getAttribute) {
 3297|       |    var view_box = el.getAttribute('viewBox');
 3298|       |    if (view_box) {
 3299|       |      var parts = String(view_box).trim().split(/[\s,]+/).filter(function(p) { return p.length; });
 3300|       |      if (parts.length >= 4) {
 3301|       |        var vbw = __mdmdview_parse_num(parts[2]);
 3302|       |        var vbh = __mdmdview_parse_num(parts[3]);
 3303|       |        if (!bw && vbw) { bw = vbw; }
 3304|       |        if (!bh && vbh) { bh = vbh; }
 3305|       |      }
 3306|       |    }
 3307|       |  }
 3308|       |  if (!bw && !bh) {
 3309|       |    var html_tag = tag === 'div' || tag === 'body' || tag === 'html';
 3310|       |    if (html_tag) {
 3311|       |      bw = window.innerWidth || 0;
 3312|       |      bh = window.innerHeight || 0;
 3313|       |    }
 3314|       |  }
 3315|       |  if (bw || bh) {
 3316|       |    var bx = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('x') : 0);
 3317|       |    var by = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('y') : 0);
 3318|       |    return __mdmdview_cache_bbox(
 3319|       |      el,
 3320|       |      __mdmdview_apply_transform(el, { x: bx, y: by, width: bw, height: bh })
 3321|       |    );
 3322|       |  }
 3323|       |  if (el.children && el.children.length) {
 3324|       |    var child_bounds = __mdmdview_children_bounds(el);
 3325|       |    if (child_bounds) {
 3326|       |      return __mdmdview_cache_bbox(el, __mdmdview_apply_transform(el, child_bounds));
 3327|       |    }
 3328|       |  }
 3329|       |  var fallback_text = el.textContent || '';
 3330|       |  var fallback_size = __mdmdview_get_font_size(el);
 3331|       |  var fallback_weight = __mdmdview_get_font_weight(el);
 3332|       |  var fallback = __mdmdview_measure_text(fallback_text, fallback_size, fallback_weight);
 3333|       |  return __mdmdview_cache_bbox(
 3334|       |    el,
 3335|       |    __mdmdview_apply_transform(el, { x: 0, y: 0, width: fallback.width, height: fallback.height })
 3336|       |  );
 3337|       |}
 3338|       |function __mdmdview_escape_text(text) {
 3339|       |  return String(text)
 3340|       |    .replace(/&/g, '&amp;')
 3341|       |    .replace(/</g, '&lt;')
 3342|       |    .replace(/>/g, '&gt;');
 3343|       |}
 3344|       |function __mdmdview_collect_text(node) {
 3345|       |  if (!node) { return ''; }
 3346|       |  if (node.tagName === '#text') { return node.textContent || ''; }
 3347|       |  var out = '';
 3348|       |  if (node.children && node.children.length) {
 3349|       |    for (var i = 0; i < node.children.length; i++) {
 3350|       |      out += __mdmdview_collect_text(node.children[i]);
 3351|       |    }
 3352|       |  }
 3353|       |  if (out && out.length) { return out; }
 3354|       |  return node.textContent || '';
 3355|       |}
 3356|       |function __mdmdview_escape_attr(text) {
 3357|       |  return String(text)
 3358|       |    .replace(/&/g, '&amp;')
 3359|       |    .replace(/"/g, '&quot;');
 3360|       |}
 3361|       |function __mdmdview_style_text(style) {
 3362|       |  if (!style) { return ''; }
 3363|       |  if (typeof style.cssText === 'string' && style.cssText.trim().length) {
 3364|       |    return style.cssText;
 3365|       |  }
 3366|       |  var parts = [];
 3367|       |  for (var key in style) {
 3368|       |    if (!Object.prototype.hasOwnProperty.call(style, key)) { continue; }
 3369|       |    if (key === 'cssText') { continue; }
 3370|       |    var val = style[key];
 3371|       |    if (typeof val === 'function') { continue; }
 3372|       |    if (val === null || val === undefined || val === '') { continue; }
 3373|       |    parts.push(key + ':' + String(val));
 3374|       |  }
 3375|       |  return parts.join(';');
 3376|       |}
 3377|       |function __mdmdview_is_shape_tag(tag) {
 3378|       |  var t = String(tag || '').toLowerCase();
 3379|       |  return t === 'rect'
 3380|       |    || t === 'path'
 3381|       |    || t === 'polygon'
 3382|       |    || t === 'circle'
 3383|       |    || t === 'ellipse'
 3384|       |    || t === 'line'
 3385|       |    || t === 'image';
 3386|       |}
 3387|       |function __mdmdview_group_has_text(node) {
 3388|       |  if (!node || !node.children || !node.children.length) { return false; }
 3389|       |  for (var i = 0; i < node.children.length; i++) {
 3390|       |    var child = node.children[i];
 3391|       |    if (!child) { continue; }
 3392|       |    var tag = String(child.tagName || '').toLowerCase();
 3393|       |    if (tag === 'text' || tag === 'foreignobject') { return true; }
 3394|       |    if (child.children && child.children.length && __mdmdview_group_has_text(child)) {
 3395|       |      return true;
 3396|       |    }
 3397|       |  }
 3398|       |  return false;
 3399|       |}
 3400|       |function __mdmdview_group_has_shape(node) {
 3401|       |  if (!node || !node.children || !node.children.length) { return false; }
 3402|       |  for (var i = 0; i < node.children.length; i++) {
 3403|       |    var child = node.children[i];
 3404|       |    if (!child) { continue; }
 3405|       |    if (__mdmdview_is_shape_tag(child.tagName)) { return true; }
 3406|       |    if (child.children && child.children.length && __mdmdview_group_has_shape(child)) {
 3407|       |      return true;
 3408|       |    }
 3409|       |  }
 3410|       |  return false;
 3411|       |}
 3412|       |function __mdmdview_is_labelish(node) {
 3413|       |  if (!node || !node.tagName) { return false; }
 3414|       |  var tag = String(node.tagName || '').toLowerCase();
 3415|       |  if (tag === 'text' || tag === 'foreignobject') { return true; }
 3416|       |  if (tag === 'g') {
 3417|       |    if (__mdmdview_has_class(node, 'clusters')) { return false; }
 3418|       |    if (__mdmdview_has_class(node, 'label')) { return true; }
 3419|       |    return __mdmdview_group_has_text(node);
 3420|       |  }
 3421|       |  return false;
 3422|       |}
 3423|       |function __mdmdview_order_children(node) {
 3424|       |  if (!node || !node.children || !node.children.length) {
 3425|       |    return node && node.children ? node.children : [];
 3426|       |  }
 3427|       |  var tag = String(node.tagName || '').toLowerCase();
 3428|       |  if (tag !== 'g') { return node.children; }
 3429|       |  if (!__mdmdview_group_has_shape(node)) { return node.children; }
 3430|       |  var has_label = false;
 3431|       |  for (var i = 0; i < node.children.length; i++) {
 3432|       |    if (__mdmdview_is_labelish(node.children[i])) { has_label = true; break; }
 3433|       |  }
 3434|       |  if (!has_label) { return node.children; }
 3435|       |  var before = [];
 3436|       |  var after = [];
 3437|       |  for (var j = 0; j < node.children.length; j++) {
 3438|       |    var child = node.children[j];
 3439|       |    if (__mdmdview_is_labelish(child)) { after.push(child); }
 3440|       |    else { before.push(child); }
 3441|       |  }
 3442|       |  if (!before.length || !after.length) { return node.children; }
 3443|       |  return before.concat(after);
 3444|       |}
 3445|       |function __mdmdview_serialize_attrs(node) {
 3446|       |  var out = '';
 3447|       |  if (!node || !node.attributes) { return out; }
 3448|       |  var has_style = false;
 3449|       |  for (var key in node.attributes) {
 3450|       |    if (!Object.prototype.hasOwnProperty.call(node.attributes, key)) { continue; }
 3451|       |    var val = node.attributes[key];
 3452|       |    if (val === null || val === undefined) { continue; }
 3453|       |    if (key === 'style') { has_style = true; }
 3454|       |    out += ' ' + key + '="' + __mdmdview_escape_attr(val) + '"';
 3455|       |  }
 3456|       |  if (!has_style && node.style) {
 3457|       |    var style_text = __mdmdview_style_text(node.style);
 3458|       |    if (style_text) {
 3459|       |      out += ' style="' + __mdmdview_escape_attr(style_text) + '"';
 3460|       |    }
 3461|       |  }
 3462|       |  return out;
 3463|       |}
 3464|       |function __mdmdview_serialize(node) {
 3465|       |  if (!node) { return ''; }
 3466|       |  if (node.tagName === '#text') {
 3467|       |    return __mdmdview_escape_text(node.textContent || '');
 3468|       |  }
 3469|       |  var tag = node.tagName || '';
 3470|       |  var attrs = __mdmdview_serialize_attrs(node);
 3471|       |  var content = '';
 3472|       |  var lower = String(tag).toLowerCase();
 3473|       |  if (node.children && node.children.length) {
 3474|       |    if (lower === 'style' || lower === 'script') {
 3475|       |      content = __mdmdview_collect_text(node);
 3476|       |    } else {
 3477|       |      var ordered = __mdmdview_order_children(node);
 3478|       |      for (var i = 0; i < ordered.length; i++) {
 3479|       |        content += __mdmdview_serialize(ordered[i]);
 3480|       |      }
 3481|       |    }
 3482|       |  } else if (node.textContent) {
 3483|       |    if (lower === 'style' || lower === 'script') {
 3484|       |      content = node.textContent;
 3485|       |    } else {
 3486|       |      content = __mdmdview_escape_text(node.textContent);
 3487|       |    }
 3488|       |  }
 3489|       |  return '<' + tag + attrs + '>' + content + '</' + tag + '>';
 3490|       |}
 3491|       |function __mdmdview_serialize_children(node) {
 3492|       |  if (!node || !node.children) { return ''; }
 3493|       |  var content = '';
 3494|       |  var ordered = __mdmdview_order_children(node);
 3495|       |  for (var i = 0; i < ordered.length; i++) {
 3496|       |    content += __mdmdview_serialize(ordered[i]);
 3497|       |  }
 3498|       |  return content;
 3499|       |}
 3500|       |function __mdmdview_make_style() {
 3501|       |  var style = { cssText: '' };
 3502|       |  style.setProperty = function(key, value) { style[key] = String(value); };
 3503|       |  style.removeProperty = function(key) { delete style[key]; };
 3504|       |  style.getPropertyValue = function(key) {
 3505|       |    return Object.prototype.hasOwnProperty.call(style, key) ? style[key] : '';
 3506|       |  };
 3507|       |  return style;
 3508|       |}
 3509|       |function __mdmdview_detach(child) {
 3510|       |  if (!child || typeof child !== 'object') { return; }
 3511|       |  var parent = child.parentNode;
 3512|       |  if (!parent || !parent.children) { return; }
 3513|       |  var idx = parent.children.indexOf(child);
 3514|       |  if (idx >= 0) {
 3515|       |    parent.children.splice(idx, 1);
 3516|       |    parent.childNodes = parent.children;
 3517|       |    parent.firstChild = parent.children[0] || null;
 3518|       |  }
 3519|       |  child.parentNode = null;
 3520|       |}
 3521|       |function __mdmdview_parse_font_px(font) {
 3522|       |  if (!font) { return 16; }
 3523|       |  var match = String(font).match(/(\d+(?:\.\d+)?)px/);
 3524|       |  if (match && match[1]) {
 3525|       |    var value = parseFloat(match[1]);
 3526|       |    if (!isNaN(value)) { return value; }
 3527|       |  }
 3528|       |  return 16;
 3529|       |}
 3530|       |function __mdmdview_parse_font_weight(font) {
 3531|       |  if (!font) { return null; }
 3532|       |  var raw = String(font).toLowerCase();
 3533|       |  if (raw.indexOf('bold') >= 0) { return 700; }
 3534|       |  return null;
 3535|       |}
 3536|       |function __mdmdview_make_canvas_context(canvas) {
 3537|       |  var ctx = {
 3538|       |    canvas: canvas,
 3539|       |    font: '',
 3540|       |    lineWidth: 1,
 3541|       |    fillStyle: '#000',
 3542|       |    strokeStyle: '#000',
 3543|       |    textAlign: 'start',
 3544|       |    textBaseline: 'alphabetic',
 3545|       |    save: function() {},
 3546|       |    restore: function() {},
 3547|       |    beginPath: function() {},
 3548|       |    closePath: function() {},
 3549|       |    moveTo: function() {},
 3550|       |    lineTo: function() {},
 3551|       |    arc: function() {},
 3552|       |    rect: function() {},
 3553|       |    fill: function() {},
 3554|       |    stroke: function() {},
 3555|       |    clip: function() {},
 3556|       |    translate: function() {},
 3557|       |    scale: function() {},
 3558|       |    rotate: function() {},
 3559|       |    clearRect: function() {},
 3560|       |    fillRect: function() {},
 3561|       |    strokeRect: function() {},
 3562|       |    drawImage: function() {},
 3563|       |    setLineDash: function() {},
 3564|       |    measureText: function(text) {
 3565|       |      var size = __mdmdview_parse_font_px(ctx.font);
 3566|       |      var weight = __mdmdview_parse_font_weight(ctx.font);
 3567|       |      var measured = __mdmdview_measure_text(text || '', size, weight);
 3568|       |      return { width: measured.width || 0 };
 3569|       |    },
 3570|       |    fillText: function() {},
 3571|       |    strokeText: function() {},
 3572|       |    createLinearGradient: function() { return { addColorStop: function() {} }; },
 3573|       |    createRadialGradient: function() { return { addColorStop: function() {} }; },
 3574|       |    createPattern: function() { return null; }
 3575|       |  };
 3576|       |  return ctx;
 3577|       |}
 3578|       |function __mdmdview_mindmap_get_size(node) {
 3579|       |  var data = node && typeof node.data === 'function' ? node.data() : null;
 3580|       |  var w = data && data.width !== undefined ? Number(data.width) : 80;
 3581|       |  var h = data && data.height !== undefined ? Number(data.height) : 40;
 3582|       |  if (!isFinite(w) || w <= 0) { w = 80; }
 3583|       |  if (!isFinite(h) || h <= 0) { h = 40; }
 3584|       |  return { w: w, h: h };
 3585|       |}
 3586|       |function __mdmdview_rect_intersection(hw, hh, ux, uy) {
 3587|       |  var ax = Math.abs(ux);
 3588|       |  var ay = Math.abs(uy);
 3589|       |  var dx = ax > 1e-6 ? hw / ax : Infinity;
 3590|       |  var dy = ay > 1e-6 ? hh / ay : Infinity;
 3591|       |  var dist = Math.min(dx, dy);
 3592|       |  if (!isFinite(dist) || dist <= 0) { dist = Math.max(hw, hh); }
 3593|       |  return dist;
 3594|       |}
 3595|       |function __mdmdview_mindmap_collect(nodes, edges) {
 3596|       |  var node_map = {};
 3597|       |  var parents = {};
 3598|       |  var children = {};
 3599|       |  var root = null;
 3600|       |  var root_id = null;
 3601|       |  for (var i = 0; i < nodes.length; i++) {
 3602|       |    var node = nodes[i];
 3603|       |    if (!node || typeof node.data !== 'function') { continue; }
 3604|       |    var data = node.data();
 3605|       |    if (!data) { continue; }
 3606|       |    var id = data.id !== undefined ? String(data.id) : null;
 3607|       |    if (id === null) { continue; }
 3608|       |    node_map[id] = node;
 3609|       |  }
 3610|       |  for (var j = 0; j < edges.length; j++) {
 3611|       |    var edge = edges[j];
 3612|       |    if (!edge || typeof edge.data !== 'function') { continue; }
 3613|       |    var ed = edge.data();
 3614|       |    if (!ed) { continue; }
 3615|       |    var source = ed.source !== undefined ? String(ed.source) : null;
 3616|       |    var target = ed.target !== undefined ? String(ed.target) : null;
 3617|       |    if (!source || !target) { continue; }
 3618|       |    if (!children[source]) { children[source] = []; }
 3619|       |    children[source].push(target);
 3620|       |    parents[target] = source;
 3621|       |  }
 3622|       |  for (var key in node_map) {
 3623|       |    if (!Object.prototype.hasOwnProperty.call(node_map, key)) { continue; }
 3624|       |    if (!Object.prototype.hasOwnProperty.call(parents, key)) {
 3625|       |      root = node_map[key];
 3626|       |      root_id = key;
 3627|       |      break;
 3628|       |    }
 3629|       |  }
 3630|       |  if (!root && nodes.length) {
 3631|       |    root = nodes[0];
 3632|       |    if (root && typeof root.data === 'function') {
 3633|       |      var rd = root.data();
 3634|       |      if (rd && rd.id !== undefined) { root_id = String(rd.id); }
 3635|       |    }
 3636|       |  }
 3637|       |  return { node_map: node_map, children: children, parents: parents, root: root, root_id: root_id };
 3638|       |}
 3639|       |function __mdmdview_mindmap_sorted_children(node_id, tree) {
 3640|       |  var kids = tree.children[node_id] || [];
 3641|       |  return kids.slice();
 3642|       |}
 3643|       |function __mdmdview_mindmap_assign_sides(tree) {
 3644|       |  var sides = {};
 3645|       |  var root_id = tree.root_id;
 3646|       |  if (!root_id) { return sides; }
 3647|       |  sides[root_id] = 0;
 3648|       |  function assign(node_id) {
 3649|       |    var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
 3650|       |    for (var i = 0; i < kids.length; i++) {
 3651|       |      var child_id = kids[i];
 3652|       |      var child_node = tree.node_map[child_id];
 3653|       |      var side = sides[node_id];
 3654|       |      if (node_id === root_id) {
 3655|       |        var data = child_node && typeof child_node.data === 'function' ? child_node.data() : null;
 3656|       |        var section = data && data.section !== undefined ? Number(data.section) : i;
 3657|       |        if (!isFinite(section)) { section = i; }
 3658|       |        side = (section % 2 === 0) ? -1 : 1;
 3659|       |      }
 3660|       |      sides[child_id] = side;
 3661|       |      assign(child_id);
 3662|       |    }
 3663|       |  }
 3664|       |  assign(root_id);
 3665|       |  return sides;
 3666|       |}
 3667|       |function __mdmdview_mindmap_subtree_height(node_id, tree, sizes, gap, heights) {
 3668|       |  var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
 3669|       |  if (!kids.length) {
 3670|       |    heights[node_id] = sizes[node_id].h;
 3671|       |    return heights[node_id];
 3672|       |  }
 3673|       |  var total = 0;
 3674|       |  for (var i = 0; i < kids.length; i++) {
 3675|       |    total += __mdmdview_mindmap_subtree_height(kids[i], tree, sizes, gap, heights);
 3676|       |  }
 3677|       |  total += gap * Math.max(0, kids.length - 1);
 3678|       |  var base = sizes[node_id].h;
 3679|       |  heights[node_id] = total > base ? total : base;
 3680|       |  return heights[node_id];
 3681|       |}
 3682|       |function __mdmdview_mindmap_layout(nodes, edges) {
 3683|       |  var tree = __mdmdview_mindmap_collect(nodes, edges);
 3684|       |  if (!tree.root || !tree.root_id) { return; }
 3685|       |  var sizes = {};
 3686|       |  for (var key in tree.node_map) {
 3687|       |    if (!Object.prototype.hasOwnProperty.call(tree.node_map, key)) { continue; }
 3688|       |    sizes[key] = __mdmdview_mindmap_get_size(tree.node_map[key]);
 3689|       |  }
 3690|       |  var sides = __mdmdview_mindmap_assign_sides(tree);
 3691|       |  var pad = 10;
 3692|       |  var root_data = tree.root && typeof tree.root.data === 'function' ? tree.root.data() : null;
 3693|       |  if (root_data && root_data.padding !== undefined) {
 3694|       |    var p = Number(root_data.padding);
 3695|       |    if (isFinite(p) && p > 0) { pad = p; }
 3696|       |  }
 3697|       |  var gap_x = Math.max(24, pad * 2.2);
 3698|       |  var positions = {};
 3699|       |  positions[tree.root_id] = { x: 0, y: 0 };
 3700|       |  var angles = {};
 3701|       |  angles[tree.root_id] = 0;
 3702|       |  var deg = Math.PI / 180;
 3703|       |  var left_start = 245 * deg;
 3704|       |  var left_end = 122 * deg;
 3705|       |  var right_start = 345 * deg;
 3706|       |  var right_end = 353 * deg;
 3707|       |  function assign_even(children, start, end) {
 3708|       |    if (!children.length) { return; }
 3709|       |    if (children.length === 1) {
 3710|       |      angles[children[0]] = (start + end) / 2;
 3711|       |      return;
 3712|       |    }
 3713|       |    var span = end - start;
 3714|       |    var step = span / (children.length - 1);
 3715|       |    for (var i = 0; i < children.length; i++) {
 3716|       |      angles[children[i]] = start + step * i;
 3717|       |    }
 3718|       |  }
 3719|       |  var root_kids = __mdmdview_mindmap_sorted_children(tree.root_id, tree);
 3720|       |  var left = [];
 3721|       |  var right = [];
 3722|       |  for (var rk = 0; rk < root_kids.length; rk++) {
 3723|       |    var kid = root_kids[rk];
 3724|       |    var side = sides[kid] || 1;
 3725|       |    if (side < 0) { left.push(kid); } else { right.push(kid); }
 3726|       |  }
 3727|       |  assign_even(left, left_start, left_end);
 3728|       |  assign_even(right, right_start, right_end);
 3729|       |  function spread_for_depth(depth, parent_angle) {
 3730|       |    var base = 38 * deg;
 3731|       |    var cos = Math.cos(parent_angle || 0);
 3732|       |    var bias = cos < 0 ? 1.4 : 1.0;
 3733|       |    var depth_factor = 1 + Math.max(0, depth - 1) * 0.2;
 3734|       |    return (base * bias) / depth_factor;
 3735|       |  }
 3736|       |  function assign_child_angles(node_id, depth) {
 3737|       |    var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
 3738|       |    if (!kids.length) { return; }
 3739|       |    var parent_angle = angles[node_id] || 0;
 3740|       |    if (kids.length === 1) {
 3741|       |      var sin = Math.sin(parent_angle);
 3742|       |      var cos = Math.cos(parent_angle);
 3743|       |      var offset = 0;
 3744|       |      if (cos < -0.1 && sin < -0.1) { offset = 20 * deg; }
 3745|       |      angles[kids[0]] = parent_angle + offset;
 3746|       |      assign_child_angles(kids[0], depth + 1);
 3747|       |      return;
 3748|       |    }
 3749|       |    var spread = spread_for_depth(depth, parent_angle);
 3750|       |    var upper = 1.3;
 3751|       |    var lower = 0.9;
 3752|       |    var start = parent_angle - spread * upper;
 3753|       |    var end = parent_angle + spread * lower;
 3754|       |    assign_even(kids, start, end);
 3755|       |    for (var i = 0; i < kids.length; i++) {
 3756|       |      assign_child_angles(kids[i], depth + 1);
 3757|       |    }
 3758|       |  }
 3759|       |  for (var a = 0; a < root_kids.length; a++) {
 3760|       |    assign_child_angles(root_kids[a], 1);
 3761|       |  }
 3762|       |  function place_node(node_id, depth) {
 3763|       |    var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
 3764|       |    if (!kids.length) { return; }
 3765|       |    var parent_pos = positions[node_id];
 3766|       |    var parent_size = sizes[node_id];
 3767|       |    var parent_radius = Math.max(parent_size.w, parent_size.h) / 2;
 3768|       |    var parent_angle = angles[node_id] || 0;
 3769|       |    for (var i = 0; i < kids.length; i++) {
 3770|       |      var child = kids[i];
 3771|       |      var angle = angles[child];
 3772|       |      if (angle === undefined) { angle = angles[node_id] || 0; }
 3773|       |      var child_size = sizes[child];
 3774|       |      var child_radius = Math.max(child_size.w, child_size.h) / 2;
 3775|       |      var dist = parent_radius + child_radius + gap_x;
 3776|       |      if (depth > 0) {
 3777|       |        dist *= 1.15;
 3778|       |      }
 3779|       |      var factor = 1;
 3780|       |      if (depth === 0) {
 3781|       |        var cos = Math.cos(angle);
 3782|       |        var sin = Math.sin(angle);
 3783|       |        factor *= 1.1 * (1 + 0.2 * cos + 0.1 * sin);
 3784|       |      } else {
 3785|       |        var diff = angle - parent_angle;
 3786|       |        while (diff > Math.PI) { diff -= Math.PI * 2; }
 3787|       |        while (diff < -Math.PI) { diff += Math.PI * 2; }
 3788|       |        var norm = diff / (Math.PI / 6);
 3789|       |        if (norm > 1) { norm = 1; }
 3790|       |        if (norm < -1) { norm = -1; }
 3791|       |        factor *= 1 + 0.12 * norm;
 3792|       |        factor *= 0.98 + depth * 0.04;
 3793|       |      }
 3794|       |      if (depth > 0) {
 3795|       |        var sin = Math.sin(angle);
 3796|       |        var cos = Math.cos(angle);
 3797|       |        if (sin >= 0) {
 3798|       |          factor *= 1 + 0.15 * sin;
 3799|       |        } else if (cos > 0) {
 3800|       |          factor *= 1 + 0.05 * sin;
 3801|       |        } else {
 3802|       |          factor *= 1 + 0.25 * sin;
 3803|       |        }
 3804|       |        if (sin < -0.2 && cos < 0) {
 3805|       |          factor *= 0.9;
 3806|       |        }
 3807|       |      }
 3808|       |      if (kids.length === 1) {
 3809|       |        factor *= 0.95;
 3810|       |      }
 3811|       |      dist = dist * factor;
 3812|       |      var cx = parent_pos.x + Math.cos(angle) * dist;
 3813|       |      var cy = parent_pos.y + Math.sin(angle) * dist;
 3814|       |      positions[child] = { x: cx, y: cy };
 3815|       |      place_node(child, depth + 1);
 3816|       |    }
 3817|       |  }
 3818|       |  place_node(tree.root_id, 0);
 3819|       |  var min_x = Infinity;
 3820|       |  var min_y = Infinity;
 3821|       |  for (var id in positions) {
 3822|       |    if (!Object.prototype.hasOwnProperty.call(positions, id)) { continue; }
 3823|       |    var pos = positions[id];
 3824|       |    var size = sizes[id];
 3825|       |    var lx = pos.x - size.w / 2;
 3826|       |    var ly = pos.y - size.h / 2;
 3827|       |    if (lx < min_x) { min_x = lx; }
 3828|       |    if (ly < min_y) { min_y = ly; }
 3829|       |  }
 3830|       |  if (!isFinite(min_x)) { min_x = 0; }
 3831|       |  if (!isFinite(min_y)) { min_y = 0; }
 3832|       |  var dx = pad - min_x;
 3833|       |  var dy = pad - min_y;
 3834|       |  for (var nid in positions) {
 3835|       |    if (!Object.prototype.hasOwnProperty.call(positions, nid)) { continue; }
 3836|       |    positions[nid].x += dx;
 3837|       |    positions[nid].y += dy;
 3838|       |  }
 3839|       |  for (var n = 0; n < nodes.length; n++) {
 3840|       |    var node = nodes[n];
 3841|       |    if (!node || typeof node.data !== 'function') { continue; }
 3842|       |    var data = node.data();
 3843|       |    var id = data && data.id !== undefined ? String(data.id) : null;
 3844|       |    if (!id || !positions[id]) { continue; }
 3845|       |    node._position = { x: positions[id].x, y: positions[id].y };
 3846|       |    node.position = function() { return this._position; };
 3847|       |    data.x = positions[id].x;
 3848|       |    data.y = positions[id].y;
 3849|       |  }
 3850|       |  for (var e = 0; e < edges.length; e++) {
 3851|       |    var edge = edges[e];
 3852|       |    if (!edge || typeof edge.data !== 'function') { continue; }
 3853|       |    var ed = edge.data();
 3854|       |    var source = ed && ed.source !== undefined ? String(ed.source) : null;
 3855|       |    var target = ed && ed.target !== undefined ? String(ed.target) : null;
 3856|       |    if (!source || !target) { continue; }
 3857|       |    var s_pos = positions[source];
 3858|       |    var t_pos = positions[target];
 3859|       |    if (!s_pos || !t_pos) { continue; }
 3860|       |    var s_size = sizes[source];
 3861|       |    var t_size = sizes[target];
 3862|       |    var dx = t_pos.x - s_pos.x;
 3863|       |    var dy = t_pos.y - s_pos.y;
 3864|       |    var len = Math.sqrt(dx * dx + dy * dy);
 3865|       |    if (!isFinite(len) || len <= 0.001) { len = 1; }
 3866|       |    var ux = dx / len;
 3867|       |    var uy = dy / len;
 3868|       |    var s_radius = __mdmdview_rect_intersection(s_size.w / 2, s_size.h / 2, ux, uy);
 3869|       |    var t_radius = __mdmdview_rect_intersection(t_size.w / 2, t_size.h / 2, ux, uy);
 3870|       |    var overlap = -2;
 3871|       |    s_radius += overlap;
 3872|       |    t_radius += overlap;
 3873|       |    if (s_radius < 0) { s_radius = 0; }
 3874|       |    if (t_radius < 0) { t_radius = 0; }
 3875|       |    var max_total = len * 0.95;
 3876|       |    if (s_radius + t_radius > max_total) {
 3877|       |      var scale = max_total / (s_radius + t_radius);
 3878|       |      s_radius *= scale;
 3879|       |      t_radius *= scale;
 3880|       |    }
 3881|       |    var sx = s_pos.x + ux * s_radius;
 3882|       |    var sy = s_pos.y + uy * s_radius;
 3883|       |    var ex = t_pos.x - ux * t_radius;
 3884|       |    var ey = t_pos.y - uy * t_radius;
 3885|       |    var mx = (sx + ex) / 2;
 3886|       |    var my = (sy + ey) / 2;
 3887|       |    edge[0] = edge[0] || {};
 3888|       |    edge[0]._private = {
 3889|       |      bodyBounds: true,
 3890|       |      rscratch: {
 3891|       |        startX: sx,
 3892|       |        startY: sy,
 3893|       |        midX: mx,
 3894|       |        midY: my,
 3895|       |        endX: ex,
 3896|       |        endY: ey
 3897|       |      }
 3898|       |    };
 3899|       |  }
 3900|       |}
 3901|       |function __mdmdview_cytoscape_stub(options) {
 3902|       |  var nodes = [];
 3903|       |  var edges = [];
 3904|       |  function add(entry) {
 3905|       |    if (!entry || !entry.group) { return; }
 3906|       |    if (entry.group === 'nodes') {
 3907|       |      var node = {
 3908|       |        _data: entry.data || {},
 3909|       |        _position: entry.position || { x: 0, y: 0 },
 3910|       |        data: function() { return this._data; },
 3911|       |        position: function() { return this._position; }
 3912|       |      };
 3913|       |      nodes.push(node);
 3914|       |    } else if (entry.group === 'edges') {
 3915|       |      var edge = {
 3916|       |        _data: entry.data || {},
 3917|       |        data: function() { return this._data; }
 3918|       |      };
 3919|       |      edge[0] = { _private: { bodyBounds: false, rscratch: {} } };
 3920|       |      edges.push(edge);
 3921|       |    }
 3922|       |  }
 3923|       |  return {
 3924|       |    add: add,
 3925|       |    nodes: function() { return nodes; },
 3926|       |    edges: function() { return edges; },
 3927|       |    layout: function() {
 3928|       |      return { run: function() { __mdmdview_mindmap_layout(nodes, edges); return this; } };
 3929|       |    }
 3930|       |  };
 3931|       |}
 3932|       |function __mdmdview_make_element(tag, ownerDoc, ns) {
 3933|       |  var doc = ownerDoc;
 3934|       |  if (!doc && typeof document !== 'undefined' && document) { doc = document; }
 3935|       |  var parent = null;
 3936|       |  var parent_set = false;
 3937|       |  var node = {
 3938|       |    tagName: tag,
 3939|       |    namespaceURI: ns || null,
 3940|       |    firstChild: null,
 3941|       |    style: __mdmdview_make_style(),
 3942|       |    children: [],
 3943|       |    childNodes: [],
 3944|       |    attributes: {},
 3945|       |    textContent: '',
 3946|       |    setAttribute: function(key, value) {
 3947|       |      var v = String(value);
 3948|       |      this.attributes[key] = v;
 3949|       |      if (key === 'id') { this.id = v; }
 3950|       |      __mdmdview_bump_bbox_rev();
 3951|       |    },
 3952|       |    setAttributeNS: function(ns, key, value) {
 3953|       |      var v = String(value);
 3954|       |      this.attributes[key] = v;
 3955|       |      if (key === 'id') { this.id = v; }
 3956|       |      __mdmdview_bump_bbox_rev();
 3957|       |    },
 3958|       |    attr: function(key, value) {
 3959|       |      if (value === undefined) { return this.getAttribute(key); }
 3960|       |      if (value === null) { this.removeAttribute(key); return this; }
 3961|       |      this.setAttribute(key, value);
 3962|       |      return this;
 3963|       |    },
 3964|       |    getAttribute: function(key) {
 3965|       |      return Object.prototype.hasOwnProperty.call(this.attributes, key)
 3966|       |        ? this.attributes[key]
 3967|       |        : null;
 3968|       |    },
 3969|       |    getAttributeNS: function(ns, key) { return this.getAttribute(key); },
 3970|       |    text: function(value) {
 3971|       |      if (value === undefined) { return this.textContent || ''; }
 3972|       |      this.textContent = value === null ? '' : String(value);
 3973|       |      __mdmdview_bump_bbox_rev();
 3974|       |      return this;
 3975|       |    },
 3976|       |    append: function(tag) {
 3977|       |      var child = __mdmdview_make_element(tag, this.ownerDocument, this.namespaceURI);
 3978|       |      this.appendChild(child);
 3979|       |      return child;
 3980|       |    },
 3981|       |    removeAttribute: function(key) { delete this.attributes[key]; __mdmdview_bump_bbox_rev(); },
 3982|       |    removeAttributeNS: function(ns, key) { delete this.attributes[key]; __mdmdview_bump_bbox_rev(); },
 3983|       |    appendChild: function(child) {
 3984|       |      __mdmdview_detach(child);
 3985|       |      this.children.push(child);
 3986|       |      this.childNodes = this.children;
 3987|       |      this.firstChild = this.children[0] || null;
 3988|       |      if (child && typeof child === 'object') {
 3989|       |        child.parentNode = this;
 3990|       |        if (!child.ownerDocument && this.ownerDocument) { child.ownerDocument = this.ownerDocument; }
 3991|       |      }
 3992|       |      __mdmdview_bump_bbox_rev();
 3993|       |      return child;
 3994|       |    },
 3995|       |    removeChild: function(child) {
 3996|       |      var idx = this.children.indexOf(child);
 3997|       |      if (idx >= 0) {
 3998|       |        this.children.splice(idx, 1);
 3999|       |        this.childNodes = this.children;
 4000|       |      }
 4001|       |      if (child && typeof child === 'object') { child.parentNode = null; }
 4002|       |      this.firstChild = this.children[0] || null;
 4003|       |      __mdmdview_bump_bbox_rev();
 4004|       |      return child;
 4005|       |    },
 4006|       |    hasChildNodes: function() { return this.children.length > 0; },
 4007|       |    insertBefore: function(child, before) {
 4008|       |      __mdmdview_detach(child);
 4009|       |      var idx = this.children.indexOf(before);
 4010|       |      if (idx < 0) { this.children.push(child); }
 4011|       |      else { this.children.splice(idx, 0, child); }
 4012|       |      this.childNodes = this.children;
 4013|       |      this.firstChild = this.children[0] || null;
 4014|       |      if (child && typeof child === 'object') {
 4015|       |        child.parentNode = this;
 4016|       |        if (!child.ownerDocument && this.ownerDocument) { child.ownerDocument = this.ownerDocument; }
 4017|       |      }
 4018|       |      __mdmdview_bump_bbox_rev();
 4019|       |      return child;
 4020|       |    },
 4021|       |    remove: function() { return null; },
 4022|       |    querySelector: function(sel) { return __mdmdview_query_selector(this, sel); },
 4023|       |    querySelectorAll: function(sel) { return __mdmdview_query_selector_all(this, sel); },
 4024|       |    cloneNode: function(deep) {
 4025|       |      var copy = __mdmdview_make_element(this.tagName, this.ownerDocument, this.namespaceURI);
 4026|       |      copy.textContent = this.textContent;
 4027|       |      copy.innerHTML = this.innerHTML;
 4028|       |      for (var key in this.attributes) {
 4029|       |        if (!Object.prototype.hasOwnProperty.call(this.attributes, key)) { continue; }
 4030|       |        copy.attributes[key] = this.attributes[key];
 4031|       |      }
 4032|       |      if (this.style) {
 4033|       |        for (var prop in this.style) {
 4034|       |          if (!Object.prototype.hasOwnProperty.call(this.style, prop)) { continue; }
 4035|       |          if (typeof this.style[prop] === 'function') { continue; }
 4036|       |          copy.style[prop] = this.style[prop];
 4037|       |        }
 4038|       |      }
 4039|       |      if (deep && this.children && this.children.length) {
 4040|       |        for (var i = 0; i < this.children.length; i++) {
 4041|       |          copy.appendChild(this.children[i].cloneNode(true));
 4042|       |        }
 4043|       |      }
 4044|       |      return copy;
 4045|       |    },
 4046|       |    getBBox: function() {
 4047|       |      var box = __mdmdview_bbox(this);
 4048|       |      if (box) {
 4049|       |        box.w = box.width;
 4050|       |        box.h = box.height;
 4051|       |      }
 4052|       |      return box;
 4053|       |    },
 4054|       |    getBoundingClientRect: function() {
 4055|       |      var box = __mdmdview_bbox(this);
 4056|       |      if (box) {
 4057|       |        box.left = box.x;
 4058|       |        box.top = box.y;
 4059|       |        box.right = box.x + box.width;
 4060|       |        box.bottom = box.y + box.height;
 4061|       |        box.w = box.width;
 4062|       |        box.h = box.height;
 4063|       |      }
 4064|       |      return box;
 4065|       |    },
 4066|       |    getComputedTextLength: function() { return __mdmdview_bbox(this).width; },
 4067|       |    getTotalLength: function() { return __mdmdview_path_total_length(this); },
 4068|       |    getPointAtLength: function(len) { return __mdmdview_path_point_at_length(this, len); },
 4069|       |    addEventListener: function() {},
 4070|       |    removeEventListener: function() {},
 4071|       |    dispatchEvent: function() { return false; }
 4072|       |  };
 4073|       |  var lower = String(tag || '').toLowerCase();
 4074|       |  if (lower === 'canvas') {
 4075|       |    node.width = 300;
 4076|       |    node.height = 150;
 4077|       |    node.getContext = function(kind) {
 4078|       |      if (kind && String(kind).toLowerCase() !== '2d') { return null; }
 4079|       |      if (!node.__mdmdview_ctx) {
 4080|       |        node.__mdmdview_ctx = __mdmdview_make_canvas_context(node);
 4081|       |      }
 4082|       |      return node.__mdmdview_ctx;
 4083|       |    };
 4084|       |  }
 4085|       |  var classList = {
 4086|       |    add: function() {
 4087|       |      var list = __mdmdview_get_class_list(node);
 4088|       |      for (var i = 0; i < arguments.length; i++) {
 4089|       |        var cls = String(arguments[i]);
 4090|       |        if (cls && list.indexOf(cls) < 0) { list.push(cls); }
 4091|       |      }
 4092|       |      __mdmdview_set_class_list(node, list);
 4093|       |    },
 4094|       |    remove: function() {
 4095|       |      var list = __mdmdview_get_class_list(node);
 4096|       |      var next = [];
 4097|       |      for (var i = 0; i < list.length; i++) {
 4098|       |        var keep = true;
 4099|       |        for (var j = 0; j < arguments.length; j++) {
 4100|       |          if (list[i] === String(arguments[j])) { keep = false; break; }
 4101|       |        }
 4102|       |        if (keep) { next.push(list[i]); }
 4103|       |      }
 4104|       |      __mdmdview_set_class_list(node, next);
 4105|       |    },
 4106|       |    contains: function(cls) { return __mdmdview_has_class(node, cls); },
 4107|       |    toggle: function(cls, force) {
 4108|       |      var list = __mdmdview_get_class_list(node);
 4109|       |      var name = String(cls);
 4110|       |      var has = list.indexOf(name) >= 0;
 4111|       |      var should_add = force === undefined ? !has : !!force;
 4112|       |      if (should_add && !has) { list.push(name); }
 4113|       |      if (!should_add && has) { list = list.filter(function(item) { return item !== name; }); }
 4114|       |      __mdmdview_set_class_list(node, list);
 4115|       |      return should_add;
 4116|       |    }
 4117|       |  };
 4118|       |  node.classList = classList;
 4119|       |  Object.defineProperty(node, 'innerHTML', {
 4120|       |    get: function() { return __mdmdview_serialize_children(this); },
 4121|       |    set: function(value) {
 4122|       |      if (this.children && this.children.length) {
 4123|       |        for (var i = 0; i < this.children.length; i++) {
 4124|       |          var child = this.children[i];
 4125|       |          if (child && typeof child === 'object') { child.parentNode = null; }
 4126|       |        }
 4127|       |      }
 4128|       |      this.children = [];
 4129|       |      this.childNodes = this.children;
 4130|       |      this.firstChild = null;
 4131|       |      this.textContent = value ? String(value) : '';
 4132|       |      __mdmdview_bump_bbox_rev();
 4133|       |    },
 4134|       |    configurable: true
 4135|       |  });
 4136|       |  Object.defineProperty(node, 'className', {
 4137|       |    get: function() {
 4138|       |      var cls = this.getAttribute('class');
 4139|       |      return cls ? String(cls) : '';
 4140|       |    },
 4141|       |    set: function(value) { this.setAttribute('class', value); },
 4142|       |    configurable: true
 4143|       |  });
 4144|       |  Object.defineProperty(node, 'outerHTML', {
 4145|       |    get: function() { return __mdmdview_serialize(this); },
 4146|       |    configurable: true
 4147|       |  });
 4148|       |  Object.defineProperty(node, 'ownerDocument', {
 4149|       |    get: function() {
 4150|       |      if (doc) { return doc; }
 4151|       |      if (typeof document !== 'undefined') { return document || null; }
 4152|       |      return null;
 4153|       |    },
 4154|       |    set: function(value) { doc = value; },
 4155|       |    configurable: true
 4156|       |  });
 4157|       |  Object.defineProperty(node, 'parentNode', {
 4158|       |    get: function() {
 4159|       |      if (parent_set) { return parent || null; }
 4160|       |      if (typeof document !== 'undefined' && document && document.body) { return document.body; }
 4161|       |      return null;
 4162|       |    },
 4163|       |    set: function(value) { parent = value; parent_set = true; },
 4164|       |    configurable: true
 4165|       |  });
 4166|       |  Object.defineProperty(node, 'nextSibling', {
 4167|       |    get: function() {
 4168|       |      var p = this.parentNode;
 4169|       |      if (!p || !p.children) { return null; }
 4170|       |      var idx = p.children.indexOf(this);
 4171|       |      return idx >= 0 && idx + 1 < p.children.length ? p.children[idx + 1] : null;
 4172|       |    },
 4173|       |    configurable: true
 4174|       |  });
 4175|       |  Object.defineProperty(node, 'previousSibling', {
 4176|       |    get: function() {
 4177|       |      var p = this.parentNode;
 4178|       |      if (!p || !p.children) { return null; }
 4179|       |      var idx = p.children.indexOf(this);
 4180|       |      return idx > 0 ? p.children[idx - 1] : null;
 4181|       |    },
 4182|       |    configurable: true
 4183|       |  });
 4184|       |  Object.defineProperty(node, 'firstElementChild', {
 4185|       |    get: function() {
 4186|       |      return this.children && this.children.length ? this.children[0] : null;
 4187|       |    },
 4188|       |    configurable: true
 4189|       |  });
 4190|       |  return node;
 4191|       |}
 4192|       |function __mdmdview_find_by_id(node, id) {
 4193|       |  if (!node || !id) { return null; }
 4194|       |  if (node.id === id) { return node; }
 4195|       |  if (node.attributes && node.attributes.id === id) { return node; }
 4196|       |  if (!node.children) { return null; }
 4197|       |  for (var i = 0; i < node.children.length; i++) {
 4198|       |    var hit = __mdmdview_find_by_id(node.children[i], id);
 4199|       |    if (hit) { return hit; }
 4200|       |  }
 4201|       |  return null;
 4202|       |}
 4203|       |function __mdmdview_find_by_tag(node, tag, matches) {
 4204|       |  if (!node || !tag) { return; }
 4205|       |  var name = (node.tagName || '').toLowerCase();
 4206|       |  if (name === tag) { matches.push(node); }
 4207|       |  if (!node.children) { return; }
 4208|       |  for (var i = 0; i < node.children.length; i++) {
 4209|       |    __mdmdview_find_by_tag(node.children[i], tag, matches);
 4210|       |  }
 4211|       |}
 4212|       |function __mdmdview_get_class_list(node) {
 4213|       |  if (!node) { return []; }
 4214|       |  var raw = null;
 4215|       |  if (node.getAttribute) { raw = node.getAttribute('class'); }
 4216|       |  if (raw === null || raw === undefined) { raw = node.attributes && node.attributes['class']; }
 4217|       |  if (!raw) { return []; }
 4218|       |  return String(raw).split(/\s+/).filter(function(item) { return item.length > 0; });
 4219|       |}
 4220|       |function __mdmdview_set_class_list(node, list) {
 4221|       |  if (!node) { return; }
 4222|       |  var value = (list || []).filter(function(item) { return item.length > 0; }).join(' ');
 4223|       |  if (node.setAttribute) { node.setAttribute('class', value); }
 4224|       |  else if (node.attributes) { node.attributes['class'] = value; }
 4225|       |}
 4226|       |function __mdmdview_has_class(node, className) {
 4227|       |  if (!node || !className) { return false; }
 4228|       |  var cls = node.attributes && node.attributes['class'];
 4229|       |  if (!cls) { return false; }
 4230|       |  var parts = String(cls).split(/\s+/);
 4231|       |  for (var i = 0; i < parts.length; i++) {
 4232|       |    if (parts[i] === className) { return true; }
 4233|       |  }
 4234|       |  return false;
 4235|       |}
 4236|       |function __mdmdview_find_by_class(node, className, matches) {
 4237|       |  if (!node || !className) { return; }
 4238|       |  if (__mdmdview_has_class(node, className)) { matches.push(node); }
 4239|       |  if (!node.children) { return; }
 4240|       |  for (var i = 0; i < node.children.length; i++) {
 4241|       |    __mdmdview_find_by_class(node.children[i], className, matches);
 4242|       |  }
 4243|       |}
 4244|       |function __mdmdview_get_attr(node, name) {
 4245|       |  if (!node || !name) { return null; }
 4246|       |  if (node.getAttribute) {
 4247|       |    var val = node.getAttribute(name);
 4248|       |    if (val !== null && val !== undefined) { return String(val); }
 4249|       |  }
 4250|       |  if (node.attributes && Object.prototype.hasOwnProperty.call(node.attributes, name)) {
 4251|       |    return String(node.attributes[name]);
 4252|       |  }
 4253|       |  return null;
 4254|       |}
 4255|       |function __mdmdview_parse_attr_selector(raw) {
 4256|       |  var match = raw.match(/^\[\s*([^\]=\s]+)\s*=\s*["']?([^\"'\]]+)["']?\s*\]$/);
 4257|       |  if (!match) { return null; }
 4258|       |  return { name: match[1], value: match[2] };
 4259|       |}
 4260|       |function __mdmdview_find_by_attr(node, name, value, matches) {
 4261|       |  if (!node || !name) { return null; }
 4262|       |  var attr = __mdmdview_get_attr(node, name);
 4263|       |  if (attr !== null && String(attr) === String(value)) {
 4264|       |    if (matches) { matches.push(node); }
 4265|       |    else { return node; }
 4266|       |  }
 4267|       |  if (!node.children) { return matches ? null : null; }
 4268|       |  for (var i = 0; i < node.children.length; i++) {
 4269|       |    var hit = __mdmdview_find_by_attr(node.children[i], name, value, matches);
 4270|       |    if (!matches && hit) { return hit; }
 4271|       |  }
 4272|       |  return matches ? null : null;
 4273|       |}
 4274|       |function __mdmdview_matches_simple(node, raw) {
 4275|       |  if (!node || !raw) { return false; }
 4276|       |  var attr = __mdmdview_parse_attr_selector(raw);
 4277|       |  if (attr) {
 4278|       |    var attrVal = __mdmdview_get_attr(node, attr.name);
 4279|       |    return attrVal !== null && String(attrVal) === String(attr.value);
 4280|       |  }
 4281|       |  if (raw[0] === '#') {
 4282|       |    var id = raw.slice(1);
 4283|       |    return node.id === id || __mdmdview_get_attr(node, 'id') === id;
 4284|       |  }
 4285|       |  if (raw[0] === '.') {
 4286|       |    return __mdmdview_has_class(node, raw.slice(1));
 4287|       |  }
 4288|       |  var hashIdx = raw.indexOf('#');
 4289|       |  if (hashIdx > 0) {
 4290|       |    var tagName = raw.slice(0, hashIdx).toLowerCase();
 4291|       |    var tagId = raw.slice(hashIdx + 1);
 4292|       |    return (node.tagName || '').toLowerCase() === tagName
 4293|       |      && (node.id === tagId || __mdmdview_get_attr(node, 'id') === tagId);
 4294|       |  }
 4295|       |  var dotIdx = raw.indexOf('.');
 4296|       |  if (dotIdx > 0) {
 4297|       |    var tag = raw.slice(0, dotIdx).toLowerCase();
 4298|       |    var cls = raw.slice(dotIdx + 1);
 4299|       |    return (node.tagName || '').toLowerCase() === tag && __mdmdview_has_class(node, cls);
 4300|       |  }
 4301|       |  return (node.tagName || '').toLowerCase() === raw.toLowerCase();
 4302|       |}
 4303|       |function __mdmdview_matches_selector(node, sel) {
 4304|       |  if (!node || !sel) { return false; }
 4305|       |  var raw = String(sel).trim();
 4306|       |  if (!raw) { return false; }
 4307|       |  var parts = raw.split(/\s+/).filter(function(part) { return part.length > 0; });
 4308|       |  if (parts.length <= 1) { return __mdmdview_matches_simple(node, raw); }
 4309|       |  var idx = parts.length - 1;
 4310|       |  var current = node;
 4311|       |  while (current && idx >= 0) {
 4312|       |    if (__mdmdview_matches_simple(current, parts[idx])) {
 4313|       |      idx -= 1;
 4314|       |    }
 4315|       |    current = current.parentNode;
 4316|       |  }
 4317|       |  return idx < 0;
 4318|       |}
 4319|       |function __mdmdview_query_selector(node, sel) {
 4320|       |  if (!sel) { return null; }
 4321|       |  var raw = String(sel).trim();
 4322|       |  if (!raw) { return null; }
 4323|       |  if (node && !node.tagName && node._parent) { node = node._parent; }
 4324|       |  if ((!node || !node.children) && document && document.body) { node = document.body; }
 4325|       |  var chain = raw.split(/\s+/).filter(function(part) { return part.length > 0; });
 4326|       |  if (chain.length > 1) {
 4327|       |    var current = node;
 4328|       |    for (var c = 0; c < chain.length; c++) {
 4329|       |      current = __mdmdview_query_selector(current, chain[c]);
 4330|       |      if (!current) { return null; }
 4331|       |    }
 4332|       |    return current;
 4333|       |  }
 4334|       |  var result = null;
 4335|       |  var attrSel = __mdmdview_parse_attr_selector(raw);
 4336|       |  if (attrSel) {
 4337|       |    result = __mdmdview_find_by_attr(node, attrSel.name, attrSel.value);
 4338|       |  } else if (raw[0] === '#') {
 4339|       |    result = __mdmdview_find_by_id(node, raw.slice(1));
 4340|       |  } else if (raw[0] === '.') {
 4341|       |    var className = raw.slice(1);
 4342|       |    var classMatches = [];
 4343|       |    __mdmdview_find_by_class(node, className, classMatches);
 4344|       |    result = classMatches.length ? classMatches[0] : null;
 4345|       |  } else if (raw.indexOf('#') > 0) {
 4346|       |    var hashParts = raw.split('#');
 4347|       |    var hashTag = hashParts[0].toLowerCase();
 4348|       |    var hashId = hashParts[1];
 4349|       |    var hashMatches = [];
 4350|       |    __mdmdview_find_by_tag(node, hashTag, hashMatches);
 4351|       |    for (var h = 0; h < hashMatches.length; h++) {
 4352|       |      if (hashMatches[h].id === hashId || __mdmdview_get_attr(hashMatches[h], 'id') === hashId) {
 4353|       |        result = hashMatches[h];
 4354|       |        break;
 4355|       |      }
 4356|       |    }
 4357|       |  } else if (raw.indexOf('.') > 0) {
 4358|       |    var pieces = raw.split('.');
 4359|       |    var tagName = pieces[0].toLowerCase();
 4360|       |    var clsName = pieces[1];
 4361|       |    var tagMatches = [];
 4362|       |    __mdmdview_find_by_tag(node, tagName, tagMatches);
 4363|       |    for (var t = 0; t < tagMatches.length; t++) {
 4364|       |      if (__mdmdview_has_class(tagMatches[t], clsName)) {
 4365|       |        result = tagMatches[t];
 4366|       |        break;
 4367|       |      }
 4368|       |    }
 4369|       |  } else {
 4370|       |    var tag = raw.toLowerCase();
 4371|       |    var matches = [];
 4372|       |    __mdmdview_find_by_tag(node, tag, matches);
 4373|       |    result = matches.length ? matches[0] : null;
 4374|       |  }
 4375|       |  return result;
 4376|       |}
 4377|       |function __mdmdview_query_selector_all(node, sel) {
 4378|       |  if (!sel) { return []; }
 4379|       |  var raw = String(sel).trim();
 4380|       |  if (!raw) { return []; }
 4381|       |  if (node && !node.tagName && node._parent) { node = node._parent; }
 4382|       |  if ((!node || !node.children) && document && document.body) { node = document.body; }
 4383|       |  var chain = raw.split(/\s+/).filter(function(part) { return part.length > 0; });
 4384|       |  if (chain.length > 1) {
 4385|       |    var current = node;
 4386|       |    for (var c = 0; c < chain.length; c++) {
 4387|       |      current = __mdmdview_query_selector(current, chain[c]);
 4388|       |      if (!current) { return []; }
 4389|       |    }
 4390|       |    return [current];
 4391|       |  }
 4392|       |  var attrSel = __mdmdview_parse_attr_selector(raw);
 4393|       |  if (attrSel) {
 4394|       |    var attrMatches = [];
 4395|       |    __mdmdview_find_by_attr(node, attrSel.name, attrSel.value, attrMatches);
 4396|       |    return attrMatches;
 4397|       |  }
 4398|       |  if (raw[0] === '#') {
 4399|       |    var hit = __mdmdview_find_by_id(node, raw.slice(1));
 4400|       |    return hit ? [hit] : [];
 4401|       |  }
 4402|       |  if (raw[0] === '.') {
 4403|       |    var className = raw.slice(1);
 4404|       |    var classMatches = [];
 4405|       |    __mdmdview_find_by_class(node, className, classMatches);
 4406|       |    return classMatches;
 4407|       |  }
 4408|       |  if (raw.indexOf('#') > 0) {
 4409|       |    var hashParts = raw.split('#');
 4410|       |    var hashTag = hashParts[0].toLowerCase();
 4411|       |    var hashId = hashParts[1];
 4412|       |    var hashMatches = [];
 4413|       |    __mdmdview_find_by_tag(node, hashTag, hashMatches);
 4414|       |    var hashHits = [];
 4415|       |    for (var h = 0; h < hashMatches.length; h++) {
 4416|       |      if (hashMatches[h].id === hashId || __mdmdview_get_attr(hashMatches[h], 'id') === hashId) {
 4417|       |        hashHits.push(hashMatches[h]);
 4418|       |      }
 4419|       |    }
 4420|       |    return hashHits;
 4421|       |  }
 4422|       |  if (raw.indexOf('.') > 0) {
 4423|       |    var pieces = raw.split('.');
 4424|       |    var tagName = pieces[0].toLowerCase();
 4425|       |    var clsName = pieces[1];
 4426|       |    var tagMatches = [];
 4427|       |    __mdmdview_find_by_tag(node, tagName, tagMatches);
 4428|       |    var hits = [];
 4429|       |    for (var t = 0; t < tagMatches.length; t++) {
 4430|       |      if (__mdmdview_has_class(tagMatches[t], clsName)) {
 4431|       |        hits.push(tagMatches[t]);
 4432|       |      }
 4433|       |    }
 4434|       |    return hits;
 4435|       |  }
 4436|       |  var tag = raw.toLowerCase();
 4437|       |  var matches = [];
 4438|       |  __mdmdview_find_by_tag(node, tag, matches);
 4439|       |  return matches;
 4440|       |}
 4441|       |var document = {
 4442|       |  body: __mdmdview_make_element('body'),
 4443|       |  head: __mdmdview_make_element('head'),
 4444|       |  children: [],
 4445|       |  childNodes: [],
 4446|       |  createElement: function(tag) { return __mdmdview_make_element(tag, document); },
 4447|       |  createElementNS: function(ns, tag) { return __mdmdview_make_element(tag, document, ns); },
 4448|       |  createTextNode: function(text) {
 4449|       |    var node = __mdmdview_make_element('#text', document);
 4450|       |    node.textContent = text || '';
 4451|       |    return node;
 4452|       |  },
 4453|       |  getElementById: function(id) { return __mdmdview_find_by_id(document, id); },
 4454|       |  getElementsByTagName: function(tag) {
 4455|       |    var raw = String(tag || '').trim().toLowerCase();
 4456|       |    if (!raw) { return []; }
 4457|       |    if (raw === 'head') { return document.head ? [document.head] : []; }
 4458|       |    if (raw === 'body') { return document.body ? [document.body] : []; }
 4459|       |    var matches = [];
 4460|       |    __mdmdview_find_by_tag(document, raw, matches);
 4461|       |    return matches;
 4462|       |  },
 4463|       |  querySelector: function(sel) {
 4464|       |    var raw = String(sel || '').trim().toLowerCase();
 4465|       |    var result = raw === 'head'
 4466|       |      ? document.head
 4467|       |      : (raw === 'body' ? document.body : __mdmdview_query_selector(document, sel));
 4468|       |    return result || (document && document.body ? document.body : null);
 4469|       |  },
 4470|       |  querySelectorAll: function(sel) {
 4471|       |    var raw = String(sel || '').trim().toLowerCase();
 4472|       |    var result = raw === 'head'
 4473|       |      ? [document.head]
 4474|       |      : (raw === 'body' ? [document.body] : __mdmdview_query_selector_all(document, sel));
 4475|       |    if (result && result.length) { return result; }
 4476|       |    return document && document.body ? [document.body] : [];
 4477|       |  },
 4478|       |  appendChild: function(child) {
 4479|       |    return document.documentElement
 4480|       |      ? document.documentElement.appendChild(child)
 4481|       |      : document.body.appendChild(child);
 4482|       |  },
 4483|       |  insertBefore: function(child, before) {
 4484|       |    return document.documentElement
 4485|       |      ? document.documentElement.insertBefore(child, before)
 4486|       |      : document.body.insertBefore(child, before);
 4487|       |  },
 4488|       |  removeChild: function(child) {
 4489|       |    return document.documentElement
 4490|       |      ? document.documentElement.removeChild(child)
 4491|       |      : document.body.removeChild(child);
 4492|       |  },
 4493|       |  hasChildNodes: function() {
 4494|       |    return document.documentElement
 4495|       |      ? document.documentElement.hasChildNodes()
 4496|       |      : document.body.hasChildNodes();
 4497|       |  },
 4498|       |  addEventListener: function() {}
 4499|       |};
 4500|       |window.document = document;
 4501|       |document.body.ownerDocument = document;
 4502|       |document.head.ownerDocument = document;
 4503|       |document.documentElement = __mdmdview_make_element('html');
 4504|       |document.documentElement.ownerDocument = document;
 4505|       |document.documentElement.appendChild(document.head);
 4506|       |document.documentElement.appendChild(document.body);
 4507|       |document.documentElement.parentNode = document;
 4508|       |document.children = [document.documentElement];
 4509|       |document.childNodes = document.children;
 4510|       |document.defaultView = window;
 4511|       |document.ownerDocument = document;
 4512|       |document.body.namespaceURI = 'http://www.w3.org/1999/xhtml';
 4513|       |document.head.namespaceURI = 'http://www.w3.org/1999/xhtml';
 4514|       |document.documentElement.namespaceURI = 'http://www.w3.org/1999/xhtml';
 4515|       |document.namespaceURI = document.body.namespaceURI;
 4516|       |window.ownerDocument = document;
 4517|       |window.namespaceURI = document.body.namespaceURI;
 4518|       |function __mdmdview_clear_node(node) {
 4519|       |  if (!node) { return; }
 4520|       |  if (node.children && node.children.length) {
 4521|       |    for (var i = 0; i < node.children.length; i++) {
 4522|       |      var child = node.children[i];
 4523|       |      if (child && typeof child === 'object') { child.parentNode = null; }
 4524|       |    }
 4525|       |  }
 4526|       |  node.children = [];
 4527|       |  node.childNodes = node.children;
 4528|       |  node.firstChild = null;
 4529|       |  node.textContent = '';
 4530|       |}
 4531|       |function __mdmdview_reset_dom() {
 4532|       |  __mdmdview_clear_node(document.head);
 4533|       |  __mdmdview_clear_node(document.body);
 4534|       |  document.documentElement.children = [document.head, document.body];
 4535|       |  document.documentElement.childNodes = document.documentElement.children;
 4536|       |  document.documentElement.firstChild = document.head || null;
 4537|       |  document.head.parentNode = document.documentElement;
 4538|       |  document.body.parentNode = document.documentElement;
 4539|       |  __mdmdview_text_cache = {};
 4540|       |  window.__mdmdview_timer_queue = [];
 4541|       |  window.__mdmdview_timer_map = {};
 4542|       |  window.__mdmdview_now_base = 0;
 4543|       |  window.__mdmdview_bbox_rev = 0;
 4544|       |}
 4545|       |if (!Object.hasOwn) {
 4546|       |  Object.hasOwn = function(obj, prop) {
 4547|       |    return Object.prototype.hasOwnProperty.call(obj, prop);
 4548|       |  };
 4549|       |}
 4550|       |if (!Object.prototype.hasOwnProperty('ownerDocument')) {
 4551|       |  Object.defineProperty(Object.prototype, 'ownerDocument', {
 4552|       |    get: function() { return document || null; },
 4553|       |    set: function(value) {
 4554|       |      Object.defineProperty(this, 'ownerDocument', { value: value, writable: true, configurable: true });
 4555|       |    },
 4556|       |    configurable: true
 4557|       |  });
 4558|       |}
 4559|       |if (!Object.prototype.hasOwnProperty('parentNode')) {
 4560|       |  Object.defineProperty(Object.prototype, 'parentNode', {
 4561|       |    get: function() {
 4562|       |      if (this && this.__mdmdview_parent_set) {
 4563|       |        return this.__mdmdview_parent || null;
 4564|       |      }
 4565|       |      if (typeof document !== 'undefined' && document && document.body) { return document.body; }
 4566|       |      return null;
 4567|       |    },
 4568|       |    set: function(value) {
 4569|       |      this.__mdmdview_parent = value;
 4570|       |      this.__mdmdview_parent_set = true;
 4571|       |    },
 4572|       |    configurable: true
 4573|       |  });
 4574|       |}
 4575|       |if (!Object.prototype.hasOwnProperty('querySelector')) {
 4576|       |  Object.defineProperty(Object.prototype, 'querySelector', {
 4577|       |    value: function(sel) { return __mdmdview_query_selector(this, sel); },
 4578|       |    writable: true,
 4579|       |    configurable: true
 4580|       |  });
 4581|       |}
 4582|       |if (!Object.prototype.hasOwnProperty('querySelectorAll')) {
 4583|       |  Object.defineProperty(Object.prototype, 'querySelectorAll', {
 4584|       |    value: function(sel) { return __mdmdview_query_selector_all(this, sel); },
 4585|       |    writable: true,
 4586|       |    configurable: true
 4587|       |  });
 4588|       |}
 4589|       |if (!Object.prototype.hasOwnProperty('appendChild')) {
 4590|       |  Object.defineProperty(Object.prototype, 'appendChild', {
 4591|       |    value: function(child) {
 4592|       |      if (this && !this.tagName && document && document.body && this !== document.body) {
 4593|       |        return document.body.appendChild(child);
 4594|       |      }
 4595|       |      __mdmdview_detach(child);
 4596|       |      if (!this.children) { this.children = []; }
 4597|       |      this.children.push(child);
 4598|       |      this.childNodes = this.children;
 4599|       |      this.firstChild = this.children[0] || null;
 4600|       |      if (child && typeof child === 'object') {
 4601|       |        child.parentNode = this;
 4602|       |      }
 4603|       |      return child;
 4604|       |    },
 4605|       |    writable: true,
 4606|       |    configurable: true
 4607|       |  });
 4608|       |}
 4609|       |if (!Object.prototype.hasOwnProperty('insertBefore')) {
 4610|       |  Object.defineProperty(Object.prototype, 'insertBefore', {
 4611|       |    value: function(child, before) {
 4612|       |      if (this && !this.tagName && document && document.body && this !== document.body) {
 4613|       |        return document.body.insertBefore(child, before);
 4614|       |      }
 4615|       |      __mdmdview_detach(child);
 4616|       |      if (!this.children) { this.children = []; }
 4617|       |      var idx = this.children.indexOf(before);
 4618|       |      if (idx < 0) { this.children.push(child); }
 4619|       |      else { this.children.splice(idx, 0, child); }
 4620|       |      this.childNodes = this.children;
 4621|       |      this.firstChild = this.children[0] || null;
 4622|       |      if (child && typeof child === 'object') {
 4623|       |        child.parentNode = this;
 4624|       |      }
 4625|       |      return child;
 4626|       |    },
 4627|       |    writable: true,
 4628|       |    configurable: true
 4629|       |  });
 4630|       |}
 4631|       |if (!Object.prototype.hasOwnProperty('removeChild')) {
 4632|       |  Object.defineProperty(Object.prototype, 'removeChild', {
 4633|       |    value: function(child) {
 4634|       |      if (!this.children) { return child; }
 4635|       |      var idx = this.children.indexOf(child);
 4636|       |      if (idx >= 0) { this.children.splice(idx, 1); }
 4637|       |      this.childNodes = this.children;
 4638|       |      this.firstChild = this.children[0] || null;
 4639|       |      return child;
 4640|       |    },
 4641|       |    writable: true,
 4642|       |    configurable: true
 4643|       |  });
 4644|       |}
 4645|       |if (!Object.prototype.hasOwnProperty('matches')) {
 4646|       |  Object.defineProperty(Object.prototype, 'matches', {
 4647|       |    value: function(sel) { return __mdmdview_matches_selector(this, sel); },
 4648|       |    writable: true,
 4649|       |    configurable: true
 4650|       |  });
 4651|       |}
 4652|       |if (!Object.prototype.hasOwnProperty('nextSibling')) {
 4653|       |  Object.defineProperty(Object.prototype, 'nextSibling', {
 4654|       |    get: function() { return null; },
 4655|       |    configurable: true
 4656|       |  });
 4657|       |}
 4658|       |if (!Object.prototype.hasOwnProperty('previousSibling')) {
 4659|       |  Object.defineProperty(Object.prototype, 'previousSibling', {
 4660|       |    get: function() { return null; },
 4661|       |    configurable: true
 4662|       |  });
 4663|       |}
 4664|       |window.getComputedStyle = function(el) {
 4665|       |  return (el && el.style) ? el.style : __mdmdview_make_style();
 4666|       |};
 4667|       |window.__mdmdview_timer_queue = [];
 4668|       |window.__mdmdview_timer_map = {};
 4669|       |window.__mdmdview_next_timer_id = 1;
 4670|       |window.setTimeout = function(fn, ms) {
 4671|       |  var id = window.__mdmdview_next_timer_id++;
 4672|       |  window.__mdmdview_timer_map[id] = { fn: fn, interval: false };
 4673|       |  window.__mdmdview_timer_queue.push(id);
 4674|       |  return id;
 4675|       |};
 4676|       |window.clearTimeout = function(id) {
 4677|       |  if (window.__mdmdview_timer_map) {
 4678|       |    delete window.__mdmdview_timer_map[id];
 4679|       |  }
 4680|       |};
 4681|       |window.setInterval = function(fn, ms) {
 4682|       |  var id = window.__mdmdview_next_timer_id++;
 4683|       |  window.__mdmdview_timer_map[id] = { fn: fn, interval: true };
 4684|       |  window.__mdmdview_timer_queue.push(id);
 4685|       |  return id;
 4686|       |};
 4687|       |window.clearInterval = function(id) { window.clearTimeout(id); };
 4688|       |window.requestAnimationFrame = function(fn) {
 4689|       |  return window.setTimeout(function() { fn(0); }, 16);
 4690|       |};
 4691|       |window.cancelAnimationFrame = function(id) { window.clearTimeout(id); };
 4692|       |window.__mdmdview_run_timers = function(max_ticks) {
 4693|       |  var ticks = 0;
 4694|       |  var queue = window.__mdmdview_timer_queue || [];
 4695|       |  var map = window.__mdmdview_timer_map || {};
 4696|       |  var limit = typeof max_ticks === 'number' && max_ticks > 0 ? max_ticks : 1000;
 4697|       |  while (queue.length && ticks < limit) {
 4698|       |    var id = queue.shift();
 4699|       |    var entry = map[id];
 4700|       |    if (entry && typeof entry.fn === 'function') { entry.fn(); }
 4701|       |    if (entry && entry.interval) {
 4702|       |      queue.push(id);
 4703|       |    } else {
 4704|       |      delete map[id];
 4705|       |    }
 4706|       |    ticks++;
 4707|       |  }
 4708|       |  return queue.length;
 4709|       |};
 4710|       |if (!window.devicePixelRatio) { window.devicePixelRatio = 1; }
 4711|       |if (!window.Image) {
 4712|       |  window.Image = function() {
 4713|       |    this.complete = true;
 4714|       |    this.addEventListener = function() {};
 4715|       |    this.removeEventListener = function() {};
 4716|       |    return this;
 4717|       |  };
 4718|       |}
 4719|       |window.addEventListener = function() {};
 4720|       |window.removeEventListener = function() {};
 4721|       |window.structuredClone = function(value) {
 4722|       |  if (value === null || value === undefined) { return value; }
 4723|       |  if (typeof value !== 'object') { return value; }
 4724|       |  try { return JSON.parse(JSON.stringify(value)); } catch (e) {}
 4725|       |  if (Array.isArray(value)) { return value.slice(); }
 4726|       |  var out = {};
 4727|       |  for (var key in value) {
 4728|       |    if (!Object.prototype.hasOwnProperty.call(value, key)) { continue; }
 4729|       |    out[key] = value[key];
 4730|       |  }
 4731|       |  return out;
 4732|       |};
 4733|       |window.__mdmdview_now_base = 0;
 4734|       |window.performance = { now: function(){
 4735|       |  if (typeof Date !== 'undefined' && typeof Date.now === 'function') { return Date.now(); }
 4736|       |  window.__mdmdview_now_base += 1;
 4737|       |  return window.__mdmdview_now_base;
 4738|       |} };
 4739|       |window.console = {
 4740|       |  log: function(){},
 4741|       |  warn: function(){},
 4742|       |  error: function(){},
 4743|       |  info: function(){},
 4744|       |  debug: function(){},
 4745|       |  trace: function(){}
 4746|       |};
 4747|       |window.fetch = function(){ throw new Error('fetch disabled'); };
 4748|       |window.XMLHttpRequest = function(){ throw new Error('XMLHttpRequest disabled'); };
 4749|       |window.DOMPurify = { sanitize: function(html){ return html; } };
 4750|       |window.getComputedStyle = function(el) {
 4751|       |  var style = (el && el.style) ? el.style : __mdmdview_make_style();
 4752|       |  if (!style.fontSize) { style.fontSize = '16px'; }
 4753|       |  if (!style['font-size']) { style['font-size'] = style.fontSize; }
 4754|       |  if (!style.fontFamily) { style.fontFamily = 'sans-serif'; }
 4755|       |  if (!style['font-family']) { style['font-family'] = style.fontFamily; }
 4756|       |  if (!style.fontWeight) { style.fontWeight = 'normal'; }
 4757|       |  if (!style['font-weight']) { style['font-weight'] = style.fontWeight; }
 4758|       |  if (!style.fontStyle) { style.fontStyle = 'normal'; }
 4759|       |  if (!style['font-style']) { style['font-style'] = style.fontStyle; }
 4760|       |  if (el && el.getAttribute) {
 4761|       |    var attrSize = el.getAttribute('font-size');
 4762|       |    if (attrSize) {
 4763|       |      style.fontSize = String(attrSize);
 4764|       |      style['font-size'] = style.fontSize;
 4765|       |    }
 4766|       |    var attrFamily = el.getAttribute('font-family');
 4767|       |    if (attrFamily) {
 4768|       |      style.fontFamily = String(attrFamily);
 4769|       |      style['font-family'] = style.fontFamily;
 4770|       |    }
 4771|       |    var attrWeight = el.getAttribute('font-weight');
 4772|       |    if (attrWeight) {
 4773|       |      style.fontWeight = String(attrWeight);
 4774|       |      style['font-weight'] = style.fontWeight;
 4775|       |    }
 4776|       |    var attrStyle = el.getAttribute('font-style');
 4777|       |    if (attrStyle) {
 4778|       |      style.fontStyle = String(attrStyle);
 4779|       |      style['font-style'] = style.fontStyle;
 4780|       |    }
 4781|       |  }
 4782|       |  style.getPropertyValue = function(key) {
 4783|       |    if (Object.prototype.hasOwnProperty.call(style, key)) { return style[key]; }
 4784|       |    if (key === 'font-size') { return style.fontSize; }
 4785|       |    if (key === 'font-family') { return style.fontFamily; }
 4786|       |    if (key === 'font-weight') { return style.fontWeight; }
 4787|       |    if (key === 'font-style') { return style.fontStyle; }
 4788|       |    return '';
 4789|       |  };
 4790|       |  return style;
 4791|       |};
 4792|       |window.__mdmdview_viewport_width = 1200;
 4793|       |window.__mdmdview_viewport_height = 900;
 4794|       |Object.defineProperty(window, 'innerWidth', {
 4795|       |  get: function() { return window.__mdmdview_viewport_width || 0; },
 4796|       |  configurable: true
 4797|       |});
 4798|       |Object.defineProperty(window, 'innerHeight', {
 4799|       |  get: function() { return window.__mdmdview_viewport_height || 0; },
 4800|       |  configurable: true
 4801|       |});
 4802|       |if (!Object.prototype.hasOwnProperty('parentElement')) {
 4803|       |  Object.defineProperty(Object.prototype, 'parentElement', {
 4804|       |    get: function() {
 4805|       |      var p = this && this.parentNode ? this.parentNode : null;
 4806|       |      if (p && p.tagName) { return p; }
 4807|       |      return null;
 4808|       |    },
 4809|       |    configurable: true
 4810|       |  });
 4811|       |}
 4812|       |if (!Object.prototype.hasOwnProperty('offsetWidth')) {
 4813|       |  Object.defineProperty(Object.prototype, 'offsetWidth', {
 4814|       |    get: function() {
 4815|       |      if (this && typeof this.getBBox === 'function') {
 4816|       |        var width = this.getBBox().width || 0;
 4817|       |        if (width) { return width; }
 4818|       |      }
 4819|       |      return window.innerWidth || 0;
 4820|       |    },
 4821|       |    configurable: true
 4822|       |  });
 4823|       |}
 4824|       |if (!Object.prototype.hasOwnProperty('offsetHeight')) {
 4825|       |  Object.defineProperty(Object.prototype, 'offsetHeight', {
 4826|       |    get: function() {
 4827|       |      if (this && typeof this.getBBox === 'function') {
 4828|       |        var height = this.getBBox().height || 0;
 4829|       |        if (height) { return height; }
 4830|       |      }
 4831|       |      return window.innerHeight || 0;
 4832|       |    },
 4833|       |    configurable: true
 4834|       |  });
 4835|       |}
 4836|       |if (!Object.prototype.hasOwnProperty('clientWidth')) {
 4837|       |  Object.defineProperty(Object.prototype, 'clientWidth', {
 4838|       |    get: function() { return this.offsetWidth || 0; },
 4839|       |    configurable: true
 4840|       |  });
 4841|       |}
 4842|       |if (!Object.prototype.hasOwnProperty('clientHeight')) {
 4843|       |  Object.defineProperty(Object.prototype, 'clientHeight', {
 4844|       |    get: function() { return this.offsetHeight || 0; },
 4845|       |    configurable: true
 4846|       |  });
 4847|       |}
 4848|       |"#;
 4849|       |
 4850|       |#[cfg(feature = "mermaid-quickjs")]
 4851|       |const MERMAID_INIT_SNIPPET: &str = r##"
 4852|       |if (window.mermaid && mermaid.mermaidAPI) {
 4853|       |  mermaid.mermaidAPI.initialize({startOnLoad: false});
 4854|       |  window.__mdmdview_is_plain_object = function(value) {
 4855|       |    return value && typeof value === 'object' && !Array.isArray(value);
 4856|       |  };
 4857|       |  window.__mdmdview_merge_config = function(baseConfig, overrideConfig) {
 4858|       |    var out = {};
 4859|       |    function assign(target, source) {
 4860|       |      if (!window.__mdmdview_is_plain_object(source)) { return; }
 4861|       |      for (var key in source) {
 4862|       |        if (!Object.prototype.hasOwnProperty.call(source, key)) { continue; }
 4863|       |        var value = source[key];
 4864|       |        if (window.__mdmdview_is_plain_object(value)) {
 4865|       |          if (!window.__mdmdview_is_plain_object(target[key])) { target[key] = {}; }
 4866|       |          assign(target[key], value);
 4867|       |        } else if (Array.isArray(value)) {
 4868|       |          target[key] = value.slice();
 4869|       |        } else {
 4870|       |          target[key] = value;
 4871|       |        }
 4872|       |      }
 4873|       |    }
 4874|       |    assign(out, baseConfig);
 4875|       |    assign(out, overrideConfig);
 4876|       |    return out;
 4877|       |  };
 4878|       |  window.__mdmdview_sanitize_config = function(cfg) {
 4879|       |    if (!window.__mdmdview_is_plain_object(cfg)) { return null; }
 4880|       |    var disallowed = {
 4881|       |      securityLevel: true,
 4882|       |      startOnLoad: true,
 4883|       |      maxTextSize: true,
 4884|       |      deterministicIds: true,
 4885|       |      deterministicIDSeed: true,
 4886|       |      htmlLabels: true,
 4887|       |      themeCSS: true,
 4888|       |      dompurifyConfig: true,
 4889|       |      secure: true
 4890|       |    };
 4891|       |    var out = {};
 4892|       |    for (var key in cfg) {
 4893|       |      if (!Object.prototype.hasOwnProperty.call(cfg, key)) { continue; }
 4894|       |      if (key.indexOf('__') === 0 || key.indexOf('proto') >= 0 || key.indexOf('constructor') >= 0) {
 4895|       |        continue;
 4896|       |      }
 4897|       |      if (disallowed[key]) { continue; }
 4898|       |      var value = cfg[key];
 4899|       |      if (window.__mdmdview_is_plain_object(value)) {
 4900|       |        var nested = window.__mdmdview_sanitize_config(value);
 4901|       |        if (nested && Object.keys(nested).length) { out[key] = nested; }
 4902|       |      } else if (Array.isArray(value)) {
 4903|       |        out[key] = value.slice();
 4904|       |      } else {
 4905|       |        out[key] = value;
 4906|       |      }
 4907|       |    }
 4908|       |    if (out.themeVariables && window.__mdmdview_is_plain_object(out.themeVariables)) {
 4909|       |      for (var tvKey in out.themeVariables) {
 4910|       |        if (!Object.prototype.hasOwnProperty.call(out.themeVariables, tvKey)) { continue; }
 4911|       |        var tvVal = out.themeVariables[tvKey];
 4912|       |        if (typeof tvVal === 'string') {
 4913|       |          if (!tvVal.match(/^[\d "#%(),.;A-Za-z-]+$/)) {
 4914|       |            delete out.themeVariables[tvKey];
 4915|       |          }
 4916|       |        }
 4917|       |      }
 4918|       |    }
 4919|       |    return out;
 4920|       |  };
 4921|       |  window.__mdmdview_extract_init = function(code) {
 4922|       |    if (typeof code !== 'string') { return { code: code, config: null }; }
 4923|       |    var initRe = /%%\{\s*init\s*:\s*([\s\S]*?)\s*\}%%/g;
 4924|       |    var found = null;
 4925|       |    var cleaned = code.replace(initRe, function(match, json) {
 4926|       |      if (found === null) {
 4927|       |        try { found = JSON.parse(json); } catch (e) { found = null; }
 4928|       |      }
 4929|       |      return '';
 4930|       |    });
 4931|       |    return { code: cleaned, config: found };
 4932|       |  };
 4933|       |} else {
 4934|       |  throw new Error('Mermaid not available');
 4935|       |}
 4936|       |"##;
 4937|       |
 4938|       |#[cfg(feature = "mermaid-quickjs")]
 4939|       |const MERMAID_RENDER_WRAPPER: &str = r#"
 4940|       |(function(id, code, siteConfigJson, viewportWidth, viewportHeight){
 4941|       |  if (typeof __mdmdview_reset_dom === 'function') {
 4942|       |    __mdmdview_reset_dom();
 4943|       |  }
 4944|       |  if (typeof viewportWidth === 'number' && viewportWidth > 0) {
 4945|       |    window.__mdmdview_viewport_width = viewportWidth;
 4946|       |  }
 4947|       |  if (typeof viewportHeight === 'number' && viewportHeight > 0) {
 4948|       |    window.__mdmdview_viewport_height = viewportHeight;
 4949|       |  }
 4950|       |  var siteConfig = {};
 4951|       |  if (typeof siteConfigJson === 'string' && siteConfigJson.length > 0) {
 4952|       |    try { siteConfig = JSON.parse(siteConfigJson); } catch (e) { siteConfig = {}; }
 4953|       |  }
 4954|       |  var extracted = window.__mdmdview_extract_init(code);
 4955|       |  var directiveConfig = window.__mdmdview_sanitize_config(extracted.config) || {};
 4956|       |  var merged = window.__mdmdview_merge_config(directiveConfig, siteConfig);
 4957|       |  if (merged && merged.securityLevel === 'strict') {
 4958|       |    merged.htmlLabels = false;
 4959|       |    if (!merged.flowchart) { merged.flowchart = {}; }
 4960|       |    merged.flowchart.htmlLabels = false;
 4961|       |  }
 4962|       |  function __mdmdview_flush_timers() {
 4963|       |    if (typeof __mdmdview_run_timers !== 'function') { return; }
 4964|       |    var remaining = 0;
 4965|       |    var cycles = 0;
 4966|       |    do {
 4967|       |      remaining = __mdmdview_run_timers(1000);
 4968|       |      cycles++;
 4969|       |    } while (remaining > 0 && cycles < 100);
 4970|       |    if (remaining > 0) { throw new Error('Mermaid timer queue did not drain'); }
 4971|       |  }
 4972|       |  function __mdmdview_pump_timers(max_cycles) {
 4973|       |    var cycles = 0;
 4974|       |    function step() {
 4975|       |      if (typeof __mdmdview_run_timers !== 'function') {
 4976|       |        return Promise.resolve();
 4977|       |      }
 4978|       |      var remaining = __mdmdview_run_timers(1000);
 4979|       |      cycles++;
 4980|       |      if (remaining > 0 && cycles < max_cycles) {
 4981|       |        return Promise.resolve().then(step);
 4982|       |      }
 4983|       |      if (remaining > 0) {
 4984|       |        return Promise.reject(new Error('Mermaid timer queue did not drain'));
 4985|       |      }
 4986|       |      return Promise.resolve();
 4987|       |    }
 4988|       |    return step();
 4989|       |  }
 4990|       |  mermaid.mermaidAPI.initialize(merged);
 4991|       |  var renderCode = extracted && extracted.code !== undefined ? extracted.code : code;
 4992|       |  var svgOut = null;
 4993|       |  var renderResult = null;
 4994|       |  try {
 4995|       |    renderResult = mermaid.mermaidAPI.render(id, renderCode, function(svg){ svgOut = svg; });
 4996|       |    __mdmdview_flush_timers();
 4997|       |  } catch (err) {
 4998|       |    throw err;
 4999|       |  }
 5000|       |  if (renderResult && typeof renderResult.then === 'function') {
 5001|       |    var pump = __mdmdview_pump_timers(400);
 5002|       |    return Promise.all([renderResult, pump]).then(function(values){
 5003|       |      __mdmdview_flush_timers();
 5004|       |      var out = values && values.length ? values[0] : null;
 5005|       |      if (typeof out === 'string') { return out; }
 5006|       |      if (out && out.svg) { return out.svg; }
 5007|       |      if (typeof svgOut === 'string' && svgOut.length > 0) { return svgOut; }
 5008|       |      throw new Error('Mermaid render returned empty');
 5009|       |    });
 5010|       |  }
 5011|       |  if (typeof renderResult === 'string') { return renderResult; }
 5012|       |  if (renderResult && renderResult.svg) { return renderResult.svg; }
 5013|       |  if (typeof svgOut === 'string' && svgOut.length > 0) { return svgOut; }
 5014|       |  throw new Error('Mermaid render returned empty');
 5015|       |})
 5016|       |"#;
 5017|       |
 5018|       |#[cfg(test)]
 5019|       |#[cfg_attr(coverage_nightly, coverage(off))]
 5020|       |mod tests {
 5021|       |    use super::*;
 5022|       |    use std::collections::HashSet;
 5023|       |    use std::sync::{Arc, Mutex, OnceLock};
 5024|       |    use tempfile::tempdir;
 5025|       |
 5026|       |    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
 5027|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
 5028|       |        ENV_LOCK
 5029|       |            .get_or_init(|| Mutex::new(()))
 5030|       |            .lock()
 5031|       |            .expect("env lock")
 5032|       |    }
 5033|       |
 5034|       |    fn restore_env_var(key: &'static str, previous: Option<String>) {
 5035|       |        if let Some(value) = previous {
 5036|       |            std::env::set_var(key, value);
 5037|       |        } else {
 5038|       |            std::env::remove_var(key);
 5039|       |        }
 5040|       |    }
 5041|       |
 5042|       |    #[cfg(feature = "mermaid-quickjs")]
 5043|       |    fn test_renderer_with_channels(
 5044|       |        job_tx: Option<MermaidJobSender>,
 5045|       |        result_rx: MermaidResultReceiver,
 5046|       |    ) -> MermaidRenderer {
 5047|       |        MermaidRenderer {
 5048|       |            mermaid_textures: RefCell::new(LruCache::new(4)),
 5049|       |            mermaid_pending: RefCell::new(HashSet::new()),
 5050|       |            mermaid_frame_pending: Cell::new(false),
 5051|       |            mermaid_svg_cache: RefCell::new(LruCache::new(4)),
 5052|       |            mermaid_errors: RefCell::new(LruCache::new(4)),
 5053|       |            mermaid_texture_errors: RefCell::new(LruCache::new(4)),
 5054|       |            mermaid_job_tx: job_tx,
 5055|       |            mermaid_result_rx: result_rx,
 5056|       |            worker_handles: Vec::new(),
 5057|       |        }
 5058|       |    }
 5059|       |
 5060|       |    #[test]
 5061|       |    fn test_lru_cache_eviction_and_touch() {
 5062|       |        let mut cache = LruCache::new(2);
 5063|       |        let key_a = "a".to_string();
 5064|       |        let key_b = "b".to_string();
 5065|       |        let key_c = "c".to_string();
 5066|       |
 5067|       |        cache.insert(key_a.clone(), 1);
 5068|       |        cache.insert(key_b.clone(), 2);
 5069|       |        assert_eq!(cache.get(&key_a), Some(1));
 5070|       |        cache.insert(key_c.clone(), 3);
 5071|       |        assert!(cache.get(&key_b).is_none());
 5072|       |        assert_eq!(cache.len(), 2);
 5073|       |    }
 5074|       |
 5075|       |    #[test]
 5076|       |    fn test_lru_cache_missing_get_and_empty_order_insert() {
 5077|       |        let mut cache = LruCache::new(1);
 5078|       |        assert!(cache.get(&"missing".to_string()).is_none());
 5079|       |        cache.entries.insert("a".to_string(), 1);
 5080|       |        cache.order.clear();
 5081|       |        cache.insert("b".to_string(), 2);
 5082|       |        assert_eq!(cache.len(), 2);
 5083|       |    }
 5084|       |
 5085|       |    #[test]
 5086|       |    fn test_lru_cache_capacity_zero_insert() {
 5087|       |        let mut cache = LruCache::new(0);
 5088|       |        cache.insert("a".to_string(), 1);
 5089|       |        assert_eq!(cache.len(), 1);
 5090|       |    }
 5091|       |
 5092|       |    #[test]
 5093|       |    fn test_lru_cache_insert_overwrites_existing_key() {
 5094|       |        let mut cache = LruCache::new(2);
 5095|       |        let key = "alpha".to_string();
 5096|       |        cache.insert(key.clone(), 1);
 5097|       |        cache.insert(key.clone(), 2);
 5098|       |        assert_eq!(cache.get(&key), Some(2));
 5099|       |        assert_eq!(cache.len(), 1);
 5100|       |    }
 5101|       |
 5102|       |    #[test]
 5103|       |    fn test_lru_cache_get_missing_does_not_touch_order() {
 5104|       |        let mut cache = LruCache::new(2);
 5105|       |        cache.insert("a".to_string(), 1);
 5106|       |        let before = cache.order.clone();
 5107|       |        assert!(cache.get(&"missing".to_string()).is_none());
 5108|       |        assert_eq!(cache.order, before);
 5109|       |    }
 5110|       |
 5111|       |    #[test]
 5112|       |    fn test_lru_cache_insert_without_eviction() {
 5113|       |        let mut cache = LruCache::new(3);
 5114|       |        cache.insert("a".to_string(), 1);
 5115|       |        cache.insert("b".to_string(), 2);
 5116|       |        assert_eq!(cache.len(), 2);
 5117|       |        assert_eq!(cache.order.len(), 2);
 5118|       |    }
 5119|       |
 5120|       |    #[test]
 5121|       |    fn test_lru_cache_touch_if_present_branches() {
 5122|       |        let mut cache = LruCache::new(2);
 5123|       |        let key = "alpha".to_string();
 5124|       |        cache.entries.insert(key.clone(), 1);
 5125|       |        cache.order.push_back(key.clone());
 5126|       |        let value = cache.entries.get(&key).cloned();
 5127|       |        cache.touch_if_present(&value, &key);
 5128|       |        assert_eq!(cache.order.back(), Some(&key));
 5129|       |
 5130|       |        let before = cache.order.clone();
 5131|       |        let missing: Option<i32> = None;
 5132|       |        cache.touch_if_present(&missing, &"missing".to_string());
 5133|       |        assert_eq!(cache.order, before);
 5134|       |    }
 5135|       |
 5136|       |    #[cfg(feature = "mermaid-quickjs")]
 5137|       |    #[test]
 5138|       |    fn test_lru_cache_touch_if_present_type_variants() {
 5139|       |        let mut id_cache = LruCache::new(1);
 5140|       |        id_cache.entries.insert(1u64, "one".to_string());
 5141|       |        let value = id_cache.entries.get(&1).cloned();
 5142|       |        id_cache.touch_if_present(&value, &1);
 5143|       |        let missing: Option<String> = None;
 5144|       |        id_cache.touch_if_present(&missing, &2);
 5145|       |
 5146|       |        let mut string_cache = LruCache::new(1);
 5147|       |        string_cache
 5148|       |            .entries
 5149|       |            .insert("a".to_string(), "one".to_string());
 5150|       |        let value = string_cache.entries.get(&"a".to_string()).cloned();
 5151|       |        string_cache.touch_if_present(&value, &"a".to_string());
 5152|       |        let missing: Option<String> = None;
 5153|       |        string_cache.touch_if_present(&missing, &"b".to_string());
 5154|       |
 5155|       |        let ctx = egui::Context::default();
 5156|       |        let tex = ctx.load_texture(
 5157|       |            "mermaid_touch_variant",
 5158|       |            egui::ColorImage::new([1, 1], Color32::WHITE),
 5159|       |            egui::TextureOptions::LINEAR,
 5160|       |        );
 5161|       |        let entry = MermaidTextureEntry {
 5162|       |            texture: tex,
 5163|       |            size: [1, 1],
 5164|       |        };
 5165|       |        let mut texture_cache = LruCache::new(1);
 5166|       |        texture_cache.entries.insert("t".to_string(), entry.clone());
 5167|       |        let value = texture_cache.entries.get(&"t".to_string()).cloned();
 5168|       |        texture_cache.touch_if_present(&value, &"t".to_string());
 5169|       |        let missing: Option<MermaidTextureEntry> = None;
 5170|       |        texture_cache.touch_if_present(&missing, &"missing".to_string());
 5171|       |    }
 5172|       |
 5173|       |    #[test]
 5174|       |    fn test_lru_cache_evict_oldest_branches() {
 5175|       |        let mut cache = LruCache::new(1);
 5176|       |        cache.insert("alpha".to_string(), 1);
 5177|       |        assert!(cache.evict_oldest());
 5178|       |        cache.order.clear();
 5179|       |        assert!(!cache.evict_oldest());
 5180|       |    }
 5181|       |
 5182|       |    #[cfg(feature = "mermaid-quickjs")]
 5183|       |    #[test]
 5184|       |    fn test_lru_cache_insert_and_evict_type_variants() {
 5185|       |        let mut id_cache = LruCache::new(1);
 5186|       |        id_cache.insert(1u64, "one".to_string());
 5187|       |        id_cache.insert(2u64, "two".to_string());
 5188|       |        id_cache.entries.insert(3u64, "three".to_string());
 5189|       |        id_cache.order.clear();
 5190|       |        id_cache.insert(4u64, "four".to_string());
 5191|       |        assert!(id_cache.evict_oldest());
 5192|       |        id_cache.order.clear();
 5193|       |        assert!(!id_cache.evict_oldest());
 5194|       |
 5195|       |        let mut string_cache = LruCache::new(1);
 5196|       |        string_cache.insert("a".to_string(), "one".to_string());
 5197|       |        string_cache.insert("b".to_string(), "two".to_string());
 5198|       |        string_cache
 5199|       |            .entries
 5200|       |            .insert("c".to_string(), "three".to_string());
 5201|       |        string_cache.order.clear();
 5202|       |        string_cache.insert("d".to_string(), "four".to_string());
 5203|       |        assert!(string_cache.evict_oldest());
 5204|       |        string_cache.order.clear();
 5205|       |        assert!(!string_cache.evict_oldest());
 5206|       |
 5207|       |        let ctx = egui::Context::default();
 5208|       |        let tex = ctx.load_texture(
 5209|       |            "mermaid_evict_variant",
 5210|       |            egui::ColorImage::new([1, 1], Color32::WHITE),
 5211|       |            egui::TextureOptions::LINEAR,
 5212|       |        );
 5213|       |        let entry = MermaidTextureEntry {
 5214|       |            texture: tex,
 5215|       |            size: [1, 1],
 5216|       |        };
 5217|       |        let mut texture_cache = LruCache::new(1);
 5218|       |        texture_cache.insert("a".to_string(), entry.clone());
 5219|       |        texture_cache.insert("b".to_string(), entry.clone());
 5220|       |        texture_cache.entries.insert("c".to_string(), entry.clone());
 5221|       |        texture_cache.order.clear();
 5222|       |        texture_cache.insert("d".to_string(), entry);
 5223|       |        assert!(texture_cache.evict_oldest());
 5224|       |        texture_cache.order.clear();
 5225|       |        assert!(!texture_cache.evict_oldest());
 5226|       |    }
 5227|       |
 5228|       |    #[test]
 5229|       |    fn test_lru_cache_string_string_branches() {
 5230|       |        let mut cache = LruCache::new(1);
 5231|       |        assert!(cache.get(&"missing".to_string()).is_none());
 5232|       |
 5233|       |        cache.insert("a".to_string(), "one".to_string());
 5234|       |        cache.insert("a".to_string(), "uno".to_string());
 5235|       |        assert_eq!(cache.get(&"a".to_string()), Some("uno".to_string()));
 5236|       |
 5237|       |        cache.insert("b".to_string(), "two".to_string());
 5238|       |        assert!(cache.get(&"a".to_string()).is_none());
 5239|       |
 5240|       |        cache.entries.insert("c".to_string(), "three".to_string());
 5241|       |        cache.order.clear();
 5242|       |        cache.insert("d".to_string(), "four".to_string());
 5243|       |        assert!(cache.len() >= 1);
 5244|       |    }
 5245|       |
 5246|       |    #[cfg(feature = "mermaid-quickjs")]
 5247|       |    #[test]
 5248|       |    fn test_lru_cache_mermaid_type_variants() {
 5249|       |        let mut string_cache = LruCache::new(2);
 5250|       |        string_cache.insert(1u64, "one".to_string());
 5251|       |        string_cache.insert(2u64, "two".to_string());
 5252|       |        assert_eq!(string_cache.get(&1), Some("one".to_string()));
 5253|       |        assert!(string_cache.get(&3).is_none());
 5254|       |        string_cache.insert(1u64, "uno".to_string());
 5255|       |        string_cache.insert(3u64, "three".to_string());
 5256|       |
 5257|       |        let ctx = egui::Context::default();
 5258|       |        let tex = ctx.load_texture(
 5259|       |            "mermaid_cache_test",
 5260|       |            egui::ColorImage::new([1, 1], Color32::WHITE),
 5261|       |            egui::TextureOptions::LINEAR,
 5262|       |        );
 5263|       |        let entry = MermaidTextureEntry {
 5264|       |            texture: tex,
 5265|       |            size: [1, 1],
 5266|       |        };
 5267|       |        let mut texture_cache = LruCache::new(1);
 5268|       |        assert!(texture_cache.get(&"missing".to_string()).is_none());
 5269|       |        texture_cache.insert("a".to_string(), entry.clone());
 5270|       |        assert!(texture_cache.get(&"a".to_string()).is_some());
 5271|       |        texture_cache.insert("a".to_string(), entry.clone());
 5272|       |        texture_cache.insert("b".to_string(), entry.clone());
 5273|       |        texture_cache.entries.insert("c".to_string(), entry.clone());
 5274|       |        texture_cache.order.clear();
 5275|       |        texture_cache.insert("d".to_string(), entry);
 5276|       |    }
 5277|       |
 5278|       |    #[cfg(feature = "mermaid-quickjs")]
 5279|       |    #[test]
 5280|       |    fn test_mermaid_renderer_cache_branches() {
 5281|       |        let renderer = MermaidRenderer::new();
 5282|       |        let ctx = egui::Context::default();
 5283|       |        let tex = ctx.load_texture(
 5284|       |            "mermaid_renderer_cache",
 5285|       |            egui::ColorImage::new([1, 1], Color32::WHITE),
 5286|       |            egui::TextureOptions::LINEAR,
 5287|       |        );
 5288|       |        let entry = MermaidTextureEntry {
 5289|       |            texture: tex,
 5290|       |            size: [1, 1],
 5291|       |        };
 5292|       |
 5293|       |        {
 5294|       |            let mut cache = renderer.mermaid_textures.borrow_mut();
 5295|       |            assert!(cache.get(&"miss".to_string()).is_none());
 5296|       |            cache.insert("hit".to_string(), entry.clone());
 5297|       |            assert!(cache.get(&"hit".to_string()).is_some());
 5298|       |            cache.entries.insert("stale".to_string(), entry.clone());
 5299|       |            cache.order.clear();
 5300|       |            cache.insert("fresh".to_string(), entry.clone());
 5301|       |        }
 5302|       |
 5303|       |        {
 5304|       |            let mut cache = renderer.mermaid_svg_cache.borrow_mut();
 5305|       |            assert!(cache.get(&1).is_none());
 5306|       |            cache.insert(1, "one".to_string());
 5307|       |            assert!(cache.get(&1).is_some());
 5308|       |            cache.entries.insert(2, "two".to_string());
 5309|       |            cache.order.clear();
 5310|       |            cache.insert(3, "three".to_string());
 5311|       |        }
 5312|       |
 5313|       |        {
 5314|       |            let mut cache = renderer.mermaid_errors.borrow_mut();
 5315|       |            assert!(cache.get(&1).is_none());
 5316|       |            cache.insert(1, "err".to_string());
 5317|       |            assert!(cache.get(&1).is_some());
 5318|       |            cache.entries.insert(2, "err2".to_string());
 5319|       |            cache.order.clear();
 5320|       |            cache.insert(3, "err3".to_string());
 5321|       |        }
 5322|       |
 5323|       |        {
 5324|       |            let mut cache = renderer.mermaid_texture_errors.borrow_mut();
 5325|       |            assert!(cache.get(&"miss".to_string()).is_none());
 5326|       |            cache.insert("hit".to_string(), "err".to_string());
 5327|       |            assert!(cache.get(&"hit".to_string()).is_some());
 5328|       |            cache
 5329|       |                .entries
 5330|       |                .insert("stale".to_string(), "err2".to_string());
 5331|       |            cache.order.clear();
 5332|       |            cache.insert("fresh".to_string(), "err3".to_string());
 5333|       |        }
 5334|       |    }
 5335|       |
 5336|       |    #[test]
 5337|       |    fn test_mermaid_texture_key_changes_with_scale_and_bg() {
 5338|       |        let svg_key = 42;
 5339|       |        let width_bucket = 320;
 5340|       |        let scale_a = MermaidRenderer::scale_bucket(1.0);
 5341|       |        let scale_b = MermaidRenderer::scale_bucket(1.2);
 5342|       |        let bg_a = Some([255, 0, 0, 255]);
 5343|       |        let bg_b = Some([0, 0, 0, 255]);
 5344|       |
 5345|       |        let key_a = MermaidRenderer::texture_key(svg_key, width_bucket, scale_a, bg_a);
 5346|       |        let key_b = MermaidRenderer::texture_key(svg_key, width_bucket, scale_b, bg_a);
 5347|       |        let key_c = MermaidRenderer::texture_key(svg_key, width_bucket, scale_a, bg_b);
 5348|       |
 5349|       |        assert_ne!(key_a, key_b);
 5350|       |        assert_ne!(key_a, key_c);
 5351|       |    }
 5352|       |
 5353|       |    #[test]
 5354|       |    fn test_mermaid_width_bucket_rounds_up() {
 5355|       |        let step = MermaidRenderer::MERMAID_WIDTH_BUCKET_STEP;
 5356|       |        assert_eq!(MermaidRenderer::width_bucket(1.0), step);
 5357|       |        assert_eq!(MermaidRenderer::width_bucket(step as f32 + 0.1), step * 2);
 5358|       |    }
 5359|       |
 5360|       |    #[test]
 5361|       |    fn test_mermaid_diagram_kind_skips_comments_and_blank() {
 5362|       |        let code = "\n%% comment\n  \nsequenceDiagram\nAlice->>Bob: Hi";
 5363|       |        assert_eq!(
 5364|       |            MermaidRenderer::mermaid_diagram_kind(code),
 5365|       |            Some("sequencediagram".to_string())
 5366|       |        );
 5367|       |    }
 5368|       |
 5369|       |    #[test]
 5370|       |    fn test_mermaid_diagram_kind_returns_none_for_comments_only() {
 5371|       |        let code = "%% comment\n   \n%% another";
 5372|       |        assert!(MermaidRenderer::mermaid_diagram_kind(code).is_none());
 5373|       |    }
 5374|       |
 5375|       |    #[test]
 5376|       |    fn test_mermaid_renderer_preference_env() {
 5377|       |        let _lock = env_lock();
 5378|       |        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
 5379|       |        let (default_pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
 5380|       |        assert!(!explicit);
 5381|       |        #[cfg(feature = "mermaid-quickjs")]
 5382|       |        assert_eq!(default_pref, MermaidRenderPreference::Embedded);
 5383|       |        #[cfg(not(feature = "mermaid-quickjs"))]
 5384|       |        assert_eq!(default_pref, MermaidRenderPreference::Off);
 5385|       |
 5386|       |        {
 5387|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 5388|       |            let (pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
 5389|       |            assert!(explicit);
 5390|       |            assert_eq!(pref, MermaidRenderPreference::Embedded);
 5391|       |        }
 5392|       |        {
 5393|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "off");
 5394|       |            let (pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
 5395|       |            assert!(explicit);
 5396|       |            assert_eq!(pref, MermaidRenderPreference::Off);
 5397|       |        }
 5398|       |        {
 5399|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "bogus");
 5400|       |            let (pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
 5401|       |            assert!(!explicit);
 5402|       |            #[cfg(feature = "mermaid-quickjs")]
 5403|       |            assert_eq!(pref, MermaidRenderPreference::Embedded);
 5404|       |            #[cfg(not(feature = "mermaid-quickjs"))]
 5405|       |            assert_eq!(pref, MermaidRenderPreference::Off);
 5406|       |        }
 5407|       |    }
 5408|       |
 5409|       |    #[test]
 5410|       |    fn test_mermaid_security_level_default_and_env() {
 5411|       |        let _lock = env_lock();
 5412|       |        std::env::remove_var("MDMDVIEW_MERMAID_SECURITY");
 5413|       |        assert_eq!(MermaidRenderer::mermaid_security_level(), "strict");
 5414|       |        {
 5415|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_SECURITY", "loose");
 5416|       |            assert_eq!(MermaidRenderer::mermaid_security_level(), "loose");
 5417|       |        }
 5418|       |        {
 5419|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_SECURITY", "strict");
 5420|       |            assert_eq!(MermaidRenderer::mermaid_security_level(), "strict");
 5421|       |        }
 5422|       |    }
 5423|       |
 5424|       |    #[cfg(feature = "mermaid-quickjs")]
 5425|       |    #[test]
 5426|       |    fn test_mermaid_worker_count_clamps_env() {
 5427|       |        let _lock = env_lock();
 5428|       |        {
 5429|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "0");
 5430|       |            assert_eq!(MermaidRenderer::mermaid_worker_count(), 1);
 5431|       |        }
 5432|       |        {
 5433|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "999");
 5434|       |            assert_eq!(MermaidRenderer::mermaid_worker_count(), 16);
 5435|       |        }
 5436|       |        {
 5437|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "nope");
 5438|       |            let count = MermaidRenderer::mermaid_worker_count();
 5439|       |            assert!(count >= 1);
 5440|       |            assert!(count <= MermaidRenderer::MAX_MERMAID_JOBS.max(1));
 5441|       |        }
 5442|       |    }
 5443|       |
 5444|       |    #[cfg(feature = "mermaid-quickjs")]
 5445|       |    #[test]
 5446|       |    fn test_mermaid_timeout_ms_env_clamps() {
 5447|       |        let _lock = env_lock();
 5448|       |        {
 5449|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_TIMEOUT_MS", "50");
 5450|       |            assert_eq!(MermaidRenderer::mermaid_timeout_ms(), 100);
 5451|       |        }
 5452|       |        {
 5453|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_TIMEOUT_MS", "250");
 5454|       |            assert_eq!(MermaidRenderer::mermaid_timeout_ms(), 250);
 5455|       |        }
 5456|       |        {
 5457|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_TIMEOUT_MS", "bad");
 5458|       |            assert_eq!(MermaidRenderer::mermaid_timeout_ms(), 30_000);
 5459|       |        }
 5460|       |    }
 5461|       |
 5462|       |    #[cfg(feature = "mermaid-quickjs")]
 5463|       |    #[test]
 5464|       |    fn test_mermaid_theme_values_font_family_trim() {
 5465|       |        let _lock = env_lock();
 5466|       |        {
 5467|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_FONT_FAMILY", "  ");
 5468|       |            let theme = MermaidRenderer::mermaid_theme_values();
 5469|       |            assert!(theme.font_family.is_none());
 5470|       |        }
 5471|       |        {
 5472|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_FONT_FAMILY", "  Test Font  ");
 5473|       |            let theme = MermaidRenderer::mermaid_theme_values();
 5474|       |            assert_eq!(theme.font_family.as_deref(), Some("Test Font"));
 5475|       |        }
 5476|       |    }
 5477|       |
 5478|       |    #[cfg(feature = "mermaid-quickjs")]
 5479|       |    #[test]
 5480|       |    fn test_mermaid_site_config_json_includes_security_flags() {
 5481|       |        let _lock = env_lock();
 5482|       |        {
 5483|       |            std::env::remove_var("MDMDVIEW_MERMAID_SECURITY");
 5484|       |            let json = MermaidRenderer::mermaid_site_config_json(1);
 5485|       |            assert!(json.contains("\"securityLevel\":\"strict\""));
 5486|       |            assert!(json.contains("\"htmlLabels\":false"));
 5487|       |            assert!(json.contains("\"flowchart\":{\"htmlLabels\":false}"));
 5488|       |        }
 5489|       |        {
 5490|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_SECURITY", "loose");
 5491|       |            let json = MermaidRenderer::mermaid_site_config_json(2);
 5492|       |            assert!(json.contains("\"securityLevel\":\"loose\""));
 5493|       |            assert!(!json.contains("\"flowchart\":{\"htmlLabels\":false}"));
 5494|       |        }
 5495|       |    }
 5496|       |
 5497|       |    #[cfg(feature = "mermaid-quickjs")]
 5498|       |    #[test]
 5499|       |    fn test_mermaid_site_config_json_includes_font_family() {
 5500|       |        let _lock = env_lock();
 5501|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_FONT_FAMILY", "Test Sans");
 5502|       |        let json = MermaidRenderer::mermaid_site_config_json(3);
 5503|       |        assert!(json.contains("\"fontFamily\":\"Test Sans\""));
 5504|       |    }
 5505|       |
 5506|       |    #[cfg(feature = "mermaid-quickjs")]
 5507|       |    #[test]
 5508|       |    fn test_json_escape_handles_specials() {
 5509|       |        let input = "quote\" backslash\\ newline\n tab\t carriage\r";
 5510|       |        let escaped = MermaidRenderer::json_escape(input);
 5511|       |        assert!(escaped.contains("\\\""));
 5512|       |        assert!(escaped.contains("\\\\"));
 5513|       |        assert!(escaped.contains("\\n"));
 5514|       |        assert!(escaped.contains("\\t"));
 5515|       |        assert!(escaped.contains("\\r"));
 5516|       |    }
 5517|       |
 5518|       |    #[cfg(feature = "mermaid-quickjs")]
 5519|       |    #[test]
 5520|       |    fn test_mermaid_image_href_resolver_blocks_external() {
 5521|       |        let resolver = MermaidWorker::image_href_resolver();
 5522|       |        let options = usvg::Options::default();
 5523|       |        let resolve_string = &resolver.resolve_string;
 5524|       |
 5525|       |        assert!(resolve_string("http://example.com/img.png", &options).is_none());
 5526|       |        assert!(resolve_string("file:///tmp/foo.png", &options).is_none());
 5527|       |    }
 5528|       |
 5529|       |    #[cfg(feature = "mermaid-quickjs")]
 5530|       |    #[test]
 5531|       |    fn test_mermaid_embed_bytes_present() {
 5532|       |        assert!(!super::mermaid_embed::MERMAID_JS.is_empty());
 5533|       |    }
 5534|       |
 5535|       |    #[cfg(feature = "mermaid-quickjs")]
 5536|       |    #[test]
 5537|       |    fn test_mermaid_quickjs_render_smoke() {
 5538|       |        let mut fontdb = usvg::fontdb::Database::new();
 5539|       |        fontdb.load_system_fonts();
 5540|       |        let fontdb = std::sync::Arc::new(fontdb);
 5541|       |        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5542|       |
 5543|       |        let flow = "graph TD; A-->B;";
 5544|       |        let seq = "sequenceDiagram\nAlice->>Bob: Hello\nBob-->>Alice: Hi";
 5545|       |        let class = "classDiagram\nClass01 <|-- Class02\nClass01 : +int id\nClass02 : +String name";
 5546|       |        let er = "erDiagram\nCUSTOMER ||--o{ ORDER : places\nORDER ||--|{ LINE_ITEM : contains\nCUSTOMER {\n  int id\n  string name\n}\nORDER {\n  int id\n  date created\n}\nLINE_ITEM {\n  int id\n  int qty\n}\n";
 5547|       |        let gantt = "gantt\ntitle Sample Gantt\ndateFormat  YYYY-MM-DD\nsection A\nTask 1 :a1, 2024-01-01, 5d\nTask 2 :after a1, 3d\nsection B\nTask 3 :b1, 2024-01-06, 4d\n";
 5548|       |        let viewport_width = 1200;
 5549|       |        let viewport_height = 900;
 5550|       |
 5551|       |        let flow_svg = worker
 5552|       |            .render_svg(
 5553|       |                MermaidRenderer::hash_str(flow),
 5554|       |                flow,
 5555|       |                viewport_width,
 5556|       |                viewport_height,
 5557|       |            )
 5558|       |            .expect("flowchart render");
 5559|       |        let seq_svg = worker
 5560|       |            .render_svg(
 5561|       |                MermaidRenderer::hash_str(seq),
 5562|       |                seq,
 5563|       |                viewport_width,
 5564|       |                viewport_height,
 5565|       |            )
 5566|       |            .expect("sequence render");
 5567|       |        let class_svg = worker
 5568|       |            .render_svg(
 5569|       |                MermaidRenderer::hash_str(class),
 5570|       |                class,
 5571|       |                viewport_width,
 5572|       |                viewport_height,
 5573|       |            )
 5574|       |            .expect("class render");
 5575|       |        let er_svg = worker
 5576|       |            .render_svg(
 5577|       |                MermaidRenderer::hash_str(er),
 5578|       |                er,
 5579|       |                viewport_width,
 5580|       |                viewport_height,
 5581|       |            )
 5582|       |            .expect("er render");
 5583|       |        let gantt_svg = worker
 5584|       |            .render_svg(
 5585|       |                MermaidRenderer::hash_str(gantt),
 5586|       |                gantt,
 5587|       |                viewport_width,
 5588|       |                viewport_height,
 5589|       |            )
 5590|       |            .expect("gantt render");
 5591|       |
 5592|       |        assert!(flow_svg.contains("<svg"));
 5593|       |        assert!(seq_svg.contains("<svg"));
 5594|       |        assert!(class_svg.contains("<svg"));
 5595|       |        assert!(er_svg.contains("<svg"));
 5596|       |        assert!(gantt_svg.contains("<svg"));
 5597|       |
 5598|       |        let width_bucket = MermaidRenderer::width_bucket(600.0);
 5599|       |        let scale_bucket = MermaidRenderer::scale_bucket(1.0);
 5600|       |        let (rgba, w, h) = worker
 5601|       |            .rasterize_svg(&flow_svg, width_bucket, scale_bucket, None)
 5602|       |            .expect("rasterize svg");
 5603|       |        assert!(!rgba.is_empty());
 5604|       |        assert_eq!(rgba.len(), (w as usize) * (h as usize) * 4);
 5605|       |        assert!(w > 0);
 5606|       |        assert!(h > 0);
 5607|       |        assert!(w <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5608|       |        assert!(h <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5609|       |    }
 5610|       |
 5611|       |    #[cfg(feature = "mermaid-quickjs")]
 5612|       |    #[test]
 5613|       |    fn test_mermaid_worker_dom_debug_env() {
 5614|       |        let _lock = env_lock();
 5615|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_DOM_DEBUG", "1");
 5616|       |        let mut fontdb = usvg::fontdb::Database::new();
 5617|       |        fontdb.load_system_fonts();
 5618|       |        let fontdb = Arc::new(fontdb);
 5619|       |        let worker = MermaidWorker::new(0, fontdb);
 5620|       |        assert!(worker.is_ok());
 5621|       |    }
 5622|       |
 5623|       |    #[cfg(feature = "mermaid-quickjs")]
 5624|       |    #[test]
 5625|       |    fn test_mermaid_js_empty_override_matches_thread() {
 5626|       |        let _lock = env_lock();
 5627|       |        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
 5628|       |        {
 5629|       |            let _guard = MermaidJsEmptyGuard::set(true);
 5630|       |            assert!(mermaid_js_empty());
 5631|       |        }
 5632|       |        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
 5633|       |    }
 5634|       |
 5635|       |    #[cfg(feature = "mermaid-quickjs")]
 5636|       |    #[test]
 5637|       |    fn test_mermaid_js_empty_override_mismatch_thread() {
 5638|       |        let _lock = env_lock();
 5639|       |        let handle = std::thread::spawn(|| set_mermaid_js_empty_for_test(true));
 5640|       |        let _ = handle.join();
 5641|       |        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
 5642|       |        set_mermaid_js_empty_for_test(false);
 5643|       |    }
 5644|       |
 5645|       |    #[cfg(feature = "mermaid-quickjs")]
 5646|       |    #[test]
 5647|       |    fn test_mermaid_js_empty_override_false_clears() {
 5648|       |        let _lock = env_lock();
 5649|       |        set_mermaid_js_empty_for_test(true);
 5650|       |        let previous = set_mermaid_js_empty_for_test(false);
 5651|       |        assert!(previous.is_some());
 5652|       |        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
 5653|       |    }
 5654|       |
 5655|       |    #[cfg(feature = "mermaid-quickjs")]
 5656|       |    #[test]
 5657|       |    fn test_mermaid_js_empty_override_lock_busy() {
 5658|       |        let _lock = env_lock();
 5659|       |        let guard = MERMAID_JS_EMPTY_OVERRIDE.try_lock().expect("override lock");
 5660|       |        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
 5661|       |        drop(guard);
 5662|       |    }
 5663|       |
 5664|       |    #[cfg(feature = "mermaid-quickjs")]
 5665|       |    #[test]
 5666|       |    fn test_mermaid_worker_new_fails_when_js_empty() {
 5667|       |        let _lock = env_lock();
 5668|       |        let _guard = MermaidJsEmptyGuard::set(true);
 5669|       |        let mut fontdb = usvg::fontdb::Database::new();
 5670|       |        fontdb.load_system_fonts();
 5671|       |        let err = MermaidWorker::new(0, Arc::new(fontdb))
 5672|       |            .err()
 5673|       |            .expect("expected error");
 5674|       |        assert!(err.contains("No embedded Mermaid JS"));
 5675|       |    }
 5676|       |
 5677|       |    #[cfg(feature = "mermaid-quickjs")]
 5678|       |    #[test]
 5679|       |    fn test_measure_text_native_handles_optional_weight() {
 5680|       |        let _lock = env_lock();
 5681|       |        let mut fontdb = usvg::fontdb::Database::new();
 5682|       |        fontdb.load_system_fonts();
 5683|       |        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5684|       |        worker.engine.ctx.with(|ctx| {
 5685|       |            let with_weight: Vec<f64> = ctx
 5686|       |                .eval("__mdmdview_measure_text_native('abc', 12, 700)")
 5687|       |                .expect("with weight");
 5688|       |            let without_weight: Vec<f64> = ctx
 5689|       |                .eval("__mdmdview_measure_text_native('abc', 12, undefined)")
 5690|       |                .expect("without weight");
 5691|       |            assert_eq!(with_weight.len(), 2);
 5692|       |            assert_eq!(without_weight.len(), 2);
 5693|       |        });
 5694|       |    }
 5695|       |
 5696|       |    #[cfg(feature = "mermaid-quickjs")]
 5697|       |    #[test]
 5698|       |    fn test_map_init_result_variants() {
 5699|       |        assert!(MermaidWorker::map_init_result(Ok(())).is_ok());
 5700|       |        let err = MermaidWorker::map_init_result(Err("oops".to_string())).unwrap_err();
 5701|       |        assert!(err.contains("Mermaid init error: oops"));
 5702|       |    }
 5703|       |
 5704|       |    #[cfg(feature = "mermaid-quickjs")]
 5705|       |    #[test]
 5706|       |    fn test_format_render_result_variants() {
 5707|       |        let ok = MermaidWorker::format_render_result(Ok("<svg></svg>".to_string()), 10, 5)
 5708|       |            .expect("ok result");
 5709|       |        assert!(ok.contains("<svg"));
 5710|       |
 5711|       |        let err = MermaidWorker::format_render_result(Err("boom".to_string()), 10, 5).unwrap_err();
 5712|       |        assert!(err.contains("Mermaid render error: boom"));
 5713|       |
 5714|       |        let timeout =
 5715|       |            MermaidWorker::format_render_result(Err("late".to_string()), 10, 20).unwrap_err();
 5716|       |        assert_eq!(timeout, "Mermaid render timed out");
 5717|       |    }
 5718|       |
 5719|       |    #[cfg(feature = "mermaid-quickjs")]
 5720|       |    #[test]
 5721|       |    fn test_process_job_missing_code_returns_error() {
 5722|       |        let mut fontdb = usvg::fontdb::Database::new();
 5723|       |        fontdb.load_system_fonts();
 5724|       |        let fontdb = std::sync::Arc::new(fontdb);
 5725|       |        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5726|       |
 5727|       |        let job = MermaidRequest {
 5728|       |            svg_key: 1,
 5729|       |            texture_key: "missing".to_string(),
 5730|       |            code: None,
 5731|       |            svg: None,
 5732|       |            width_bucket: 100,
 5733|       |            scale_bucket: MermaidRenderer::scale_bucket(1.0),
 5734|       |            viewport_width: 100,
 5735|       |            viewport_height: 100,
 5736|       |            bg: None,
 5737|       |        };
 5738|       |
 5739|       |        let result = worker.process_job(job);
 5740|       |        assert!(result.svg.is_none());
 5741|       |        assert!(result.rgba.is_none());
 5742|       |        assert!(result.error.is_some());
 5743|       |    }
 5744|       |
 5745|       |    #[cfg(feature = "mermaid-quickjs")]
 5746|       |    #[test]
 5747|       |    fn test_rasterize_svg_invalid_returns_error() {
 5748|       |        let mut fontdb = usvg::fontdb::Database::new();
 5749|       |        fontdb.load_system_fonts();
 5750|       |        let fontdb = std::sync::Arc::new(fontdb);
 5751|       |        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5752|       |
 5753|       |        let err = worker
 5754|       |            .rasterize_svg("not svg", 100, MermaidRenderer::scale_bucket(1.0), None)
 5755|       |            .unwrap_err();
 5756|       |        assert!(!err.is_empty());
 5757|       |    }
 5758|       |
 5759|       |    #[cfg(feature = "mermaid-quickjs")]
 5760|       |    #[test]
 5761|       |    fn test_rasterize_svg_logs_when_env_set() {
 5762|       |        let _lock = env_lock();
 5763|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_LOG_RASTER", "1");
 5764|       |        let mut fontdb = usvg::fontdb::Database::new();
 5765|       |        fontdb.load_system_fonts();
 5766|       |        let fontdb = std::sync::Arc::new(fontdb);
 5767|       |        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5768|       |        let svg = r#"<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"></svg>"#;
 5769|       |        let (data, w, h) = worker
 5770|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5771|       |            .expect("rasterize svg");
 5772|       |        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 5773|       |    }
 5774|       |
 5775|       |    #[cfg(feature = "mermaid-quickjs")]
 5776|       |    #[test]
 5777|       |    fn test_rasterize_svg_viewbox_filter_rejects_small() {
 5778|       |        let mut fontdb = usvg::fontdb::Database::new();
 5779|       |        fontdb.load_system_fonts();
 5780|       |        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5781|       |        let svg = r#"<svg width="100" height="100" viewBox="0 0 0 0" xmlns="http://www.w3.org/2000/svg"></svg>"#;
 5782|       |        let (data, w, h) = worker
 5783|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5784|       |            .expect("rasterize svg");
 5785|       |        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 5786|       |    }
 5787|       |
 5788|       |    #[cfg(feature = "mermaid-quickjs")]
 5789|       |    #[test]
 5790|       |    fn test_rasterize_svg_skips_resize_when_bbox_exceeds_cap() {
 5791|       |        let mut fontdb = usvg::fontdb::Database::new();
 5792|       |        fontdb.load_system_fonts();
 5793|       |        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5794|       |        let svg = r#"<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect width="1000" height="1000" fill="red"/></svg>"#;
 5795|       |        let (_data, w, h) = worker
 5796|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5797|       |            .expect("rasterize svg");
 5798|       |        assert_eq!((w, h), (10, 10));
 5799|       |    }
 5800|       |
 5801|       |    #[cfg(feature = "mermaid-quickjs")]
 5802|       |    #[test]
 5803|       |    fn test_rasterize_svg_oversize_bbox_translates() {
 5804|       |        let mut fontdb = usvg::fontdb::Database::new();
 5805|       |        fontdb.load_system_fonts();
 5806|       |        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5807|       |        let svg = r#"<svg width="100" height="50" xmlns="http://www.w3.org/2000/svg"><rect x="-60" y="0" width="200" height="50" fill="red"/></svg>"#;
 5808|       |        let (_data, w, h) = worker
 5809|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5810|       |            .expect("rasterize svg");
 5811|       |        assert!(w > 100);
 5812|       |        assert!(h >= 50);
 5813|       |    }
 5814|       |
 5815|       |    #[cfg(feature = "mermaid-quickjs")]
 5816|       |    #[test]
 5817|       |    fn test_rasterize_svg_oversize_bbox_translate_y_only() {
 5818|       |        let mut fontdb = usvg::fontdb::Database::new();
 5819|       |        fontdb.load_system_fonts();
 5820|       |        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5821|       |        let svg = r#"<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="0" width="100" height="200" fill="red"/></svg>"#;
 5822|       |        let (_data, w, h) = worker
 5823|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5824|       |            .expect("rasterize svg");
 5825|       |        assert!(w >= 108);
 5826|       |        assert!(h >= 200);
 5827|       |    }
 5828|       |
 5829|       |    #[cfg(feature = "mermaid-quickjs")]
 5830|       |    #[test]
 5831|       |    fn test_rasterize_svg_clamps_large_width() {
 5832|       |        let mut fontdb = usvg::fontdb::Database::new();
 5833|       |        fontdb.load_system_fonts();
 5834|       |        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5835|       |        let svg = r#"<svg width="4100" height="10" xmlns="http://www.w3.org/2000/svg"><rect width="4100" height="10" fill="red"/></svg>"#;
 5836|       |        let (_data, w, h) = worker
 5837|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5838|       |            .expect("rasterize svg");
 5839|       |        assert!(w <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5840|       |        assert!(h > 0);
 5841|       |    }
 5842|       |
 5843|       |    #[cfg(feature = "mermaid-quickjs")]
 5844|       |    #[test]
 5845|       |    fn test_rasterize_svg_clamps_large_height() {
 5846|       |        let mut fontdb = usvg::fontdb::Database::new();
 5847|       |        fontdb.load_system_fonts();
 5848|       |        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5849|       |        let svg = r#"<svg width="10" height="10000" xmlns="http://www.w3.org/2000/svg"><rect width="10" height="10000" fill="red"/></svg>"#;
 5850|       |        let (_data, w, h) = worker
 5851|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5852|       |            .expect("rasterize svg");
 5853|       |        assert!(w > 0);
 5854|       |        assert!(h <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5855|       |    }
 5856|       |
 5857|       |    #[cfg(feature = "mermaid-quickjs")]
 5858|       |    #[test]
 5859|       |    fn test_rasterize_svg_tiny_bbox_keeps_dimensions() {
 5860|       |        let mut fontdb = usvg::fontdb::Database::new();
 5861|       |        fontdb.load_system_fonts();
 5862|       |        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5863|       |        let svg = r#"<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect width="0.1" height="0.1" fill="red"/></svg>"#;
 5864|       |        let (_data, w, h) = worker
 5865|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5866|       |            .expect("rasterize svg");
 5867|       |        assert_eq!((w, h), (10, 10));
 5868|       |    }
 5869|       |
 5870|       |    #[cfg(feature = "mermaid-quickjs")]
 5871|       |    #[test]
 5872|       |    fn test_rasterize_svg_raw_tree_parse_failure_fallback() {
 5873|       |        let _lock = env_lock();
 5874|       |        let mut fontdb = usvg::fontdb::Database::new();
 5875|       |        fontdb.load_system_fonts();
 5876|       |        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5877|       |        force_raw_tree_parse_fail_for_test();
 5878|       |        let svg = r#"<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect width="20" height="20" fill="red"/></svg>"#;
 5879|       |        let (data, w, h) = worker
 5880|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5881|       |            .expect("rasterize svg");
 5882|       |        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 5883|       |        assert!(w > 0);
 5884|       |        assert!(h > 0);
 5885|       |    }
 5886|       |
 5887|       |    #[cfg(feature = "mermaid-quickjs")]
 5888|       |    #[test]
 5889|       |    fn test_bbox_validation_helpers() {
 5890|       |        assert!(MermaidWorker::bbox_is_valid(10.0, 10.0, 0.0, 0.0));
 5891|       |        assert!(!MermaidWorker::bbox_is_valid(0.0, 10.0, 0.0, 0.0));
 5892|       |        assert!(!MermaidWorker::bbox_is_valid(10.0, 0.0, 0.0, 0.0));
 5893|       |        assert!(!MermaidWorker::bbox_is_valid(f32::NAN, 10.0, 0.0, 0.0));
 5894|       |        assert!(!MermaidWorker::bbox_is_valid(10.0, f32::INFINITY, 0.0, 0.0));
 5895|       |        assert!(!MermaidWorker::bbox_is_valid(10.0, 10.0, f32::NAN, 0.0));
 5896|       |        assert!(!MermaidWorker::bbox_is_valid(
 5897|       |            10.0,
 5898|       |            10.0,
 5899|       |            0.0,
 5900|       |            f32::INFINITY
 5901|       |        ));
 5902|       |    }
 5903|       |
 5904|       |    #[cfg(feature = "mermaid-quickjs")]
 5905|       |    #[test]
 5906|       |    fn test_should_resize_bbox_variants() {
 5907|       |        assert!(MermaidWorker::should_resize_bbox(
 5908|       |            true, true, 1.0, 1.0, 10.0, 10.0
 5909|       |        ));
 5910|       |        assert!(!MermaidWorker::should_resize_bbox(
 5911|       |            true, false, 50.0, 50.0, 10.0, 10.0
 5912|       |        ));
 5913|       |        assert!(MermaidWorker::should_resize_bbox(
 5914|       |            false, true, 20.0, 5.0, 10.0, 10.0
 5915|       |        ));
 5916|       |        assert!(!MermaidWorker::should_resize_bbox(
 5917|       |            false, true, 11.0, 11.0, 10.0, 10.0
 5918|       |        ));
 5919|       |        assert!(!MermaidWorker::should_resize_bbox(
 5920|       |            false, false, 50.0, 50.0, 10.0, 10.0
 5921|       |        ));
 5922|       |    }
 5923|       |
 5924|       |    #[cfg(feature = "mermaid-quickjs")]
 5925|       |    #[test]
 5926|       |    fn test_process_job_svg_input_rasterize_error() {
 5927|       |        let mut fontdb = usvg::fontdb::Database::new();
 5928|       |        fontdb.load_system_fonts();
 5929|       |        let fontdb = std::sync::Arc::new(fontdb);
 5930|       |        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5931|       |
 5932|       |        let job = MermaidRequest {
 5933|       |            svg_key: 2,
 5934|       |            texture_key: "bad-svg".to_string(),
 5935|       |            code: Some("graph TD; A-->B;".to_string()),
 5936|       |            svg: Some("not svg".to_string()),
 5937|       |            width_bucket: 100,
 5938|       |            scale_bucket: MermaidRenderer::scale_bucket(1.0),
 5939|       |            viewport_width: 100,
 5940|       |            viewport_height: 100,
 5941|       |            bg: None,
 5942|       |        };
 5943|       |
 5944|       |        let result = worker.process_job(job);
 5945|       |        assert!(result.svg.is_some());
 5946|       |        assert!(result.rgba.is_none());
 5947|       |        assert!(result.error.is_some());
 5948|       |    }
 5949|       |
 5950|       |    #[cfg(feature = "mermaid-quickjs")]
 5951|       |    #[test]
 5952|       |    fn test_rasterize_svg_adjusts_for_oversized_bbox() {
 5953|       |        let mut fontdb = usvg::fontdb::Database::new();
 5954|       |        fontdb.load_system_fonts();
 5955|       |        let fontdb = std::sync::Arc::new(fontdb);
 5956|       |        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5957|       |
 5958|       |        let svg = r#"<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
 5959|       |<rect x="-50" y="-50" width="200" height="200" fill="red"/>
 5960|       |</svg>"#;
 5961|       |        let (data, w, h) = worker
 5962|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5963|       |            .expect("rasterize svg");
 5964|       |        assert_eq!((w, h), (208, 208));
 5965|       |        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 5966|       |    }
 5967|       |
 5968|       |    #[cfg(feature = "mermaid-quickjs")]
 5969|       |    #[test]
 5970|       |    fn test_rasterize_svg_viewbox_filter_skips_small_dims() {
 5971|       |        let mut fontdb = usvg::fontdb::Database::new();
 5972|       |        fontdb.load_system_fonts();
 5973|       |        let fontdb = std::sync::Arc::new(fontdb);
 5974|       |        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5975|       |
 5976|       |        let svg = r#"<svg width="10" height="12" viewBox="0 0 0.1 0.1" xmlns="http://www.w3.org/2000/svg">
 5977|       | <rect width="0.1" height="0.1" fill="red"/>
 5978|       | </svg>"#;
 5979|       |        let (_data, w, h) = worker
 5980|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5981|       |            .expect("rasterize svg");
 5982|       |        assert_eq!((w, h), (10, 12));
 5983|       |    }
 5984|       |
 5985|       |    #[cfg(feature = "mermaid-quickjs")]
 5986|       |    #[test]
 5987|       |    fn test_rasterize_svg_keeps_dimensions_for_small_bbox() {
 5988|       |        let mut fontdb = usvg::fontdb::Database::new();
 5989|       |        fontdb.load_system_fonts();
 5990|       |        let fontdb = std::sync::Arc::new(fontdb);
 5991|       |        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5992|       |
 5993|       |        let svg = r#"<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
 5994|       | <rect x="10" y="10" width="20" height="20" fill="red"/>
 5995|       | </svg>"#;
 5996|       |        let (_data, w, h) = worker
 5997|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5998|       |            .expect("rasterize svg");
 5999|       |        assert_eq!((w, h), (100, 100));
 6000|       |    }
 6001|       |
 6002|       |    #[cfg(feature = "mermaid-quickjs")]
 6003|       |    #[test]
 6004|       |    fn test_rasterize_svg_clamps_to_max_side() {
 6005|       |        let mut fontdb = usvg::fontdb::Database::new();
 6006|       |        fontdb.load_system_fonts();
 6007|       |        let fontdb = std::sync::Arc::new(fontdb);
 6008|       |        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 6009|       |
 6010|       |        let svg = r#"<svg width="10000" height="10000" viewBox="0 0 10000 10000" xmlns="http://www.w3.org/2000/svg">
 6011|       |<rect width="10000" height="10000" fill="blue"/>
 6012|       |</svg>"#;
 6013|       |        let (_data, w, h) = worker
 6014|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 6015|       |            .expect("rasterize svg");
 6016|       |        assert!(w <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 6017|       |        assert!(h <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 6018|       |    }
 6019|       |
 6020|       |    #[cfg(feature = "mermaid-quickjs")]
 6021|       |    #[test]
 6022|       |    fn test_rasterize_svg_applies_background_fill() {
 6023|       |        let mut fontdb = usvg::fontdb::Database::new();
 6024|       |        fontdb.load_system_fonts();
 6025|       |        let fontdb = std::sync::Arc::new(fontdb);
 6026|       |        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 6027|       |
 6028|       |        let svg = r#"<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"></svg>"#;
 6029|       |        let bg = Some([10, 20, 30, 200]);
 6030|       |        let (data, w, h) = worker
 6031|       |            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), bg)
 6032|       |            .expect("rasterize svg");
 6033|       |        assert_eq!((w, h), (4, 4));
 6034|       |        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 6035|       |        let alpha = 200.0_f32 / 255.0;
 6036|       |        let expected_r = (10.0_f32 * alpha).round() as u8;
 6037|       |        let expected_g = (20.0_f32 * alpha).round() as u8;
 6038|       |        let expected_b = (30.0_f32 * alpha).round() as u8;
 6039|       |        assert_eq!(data[0], expected_r);
 6040|       |        assert_eq!(data[1], expected_g);
 6041|       |        assert_eq!(data[2], expected_b);
 6042|       |        assert_eq!(data[3], 200);
 6043|       |    }
 6044|       |
 6045|       |    #[cfg(feature = "mermaid-quickjs")]
 6046|       |    #[test]
 6047|       |    fn test_process_job_applies_svg_fixups() {
 6048|       |        let mut fontdb = usvg::fontdb::Database::new();
 6049|       |        fontdb.load_system_fonts();
 6050|       |        let fontdb = std::sync::Arc::new(fontdb);
 6051|       |        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");
 6052|       |
 6053|       |        let svg = r#"<svg width="120" height="120" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
 6054|       |<switch>
 6055|       |  <foreignObject><div>Plan</div></foreignObject>
 6056|       |  <text class="journey-section section-type-0" x="10">Plan</text>
 6057|       |</switch>
 6058|       |<g id="state-root_end-0">
 6059|       |  <circle class="state-end" r="5" width="10" height="10"></circle>
 6060|       |  <circle class="state-start" r="7" width="14" height="14"></circle>
 6061|       |</g>
 6062|       |<rect class="er attributeBoxOdd"></rect>
 6063|       |</svg>"#;
 6064|       |
 6065|       |        let job = MermaidRequest {
 6066|       |            svg_key: 4,
 6067|       |            texture_key: "fixups".to_string(),
 6068|       |            code: None,
 6069|       |            svg: Some(svg.to_string()),
 6070|       |            width_bucket: 0,
 6071|       |            scale_bucket: MermaidRenderer::scale_bucket(1.0),
 6072|       |            viewport_width: 120,
 6073|       |            viewport_height: 120,
 6074|       |            bg: None,
 6075|       |        };
 6076|       |
 6077|       |        let result = worker.process_job(job);
 6078|       |        let rendered = result.svg.expect("svg output");
 6079|       |        assert!(!rendered.contains("<switch"));
 6080|       |        assert!(rendered.contains("fill:"));
 6081|       |        assert!(rendered.contains("end-state-inner"));
 6082|       |        assert!(rendered.contains("attributeBoxOdd"));
 6083|       |    }
 6084|       |
 6085|       |    #[cfg(feature = "mermaid-quickjs")]
 6086|       |    #[test]
 6087|       |    fn test_mermaid_dump_helpers_sanitize_labels() {
 6088|       |        let _lock = env_lock();
 6089|       |        let dir = tempdir().expect("temp dir");
 6090|       |        let _guard = EnvGuard::set(
 6091|       |            "MDMDVIEW_MERMAID_DUMP_DIR",
 6092|       |            dir.path().to_string_lossy().as_ref(),
 6093|       |        );
 6094|       |        MermaidWorker::maybe_dump_svg(10, Some("ok-label 123"), "<svg></svg>");
 6095|       |        MermaidWorker::maybe_dump_error(11, Some("::bad label::"), "boom");
 6096|       |        MermaidWorker::maybe_dump_error(12, Some("good_label"), "ok");
 6097|       |        MermaidWorker::maybe_dump_svg(13, Some("\nrest"), "<svg></svg>");
 6098|       |        MermaidWorker::maybe_dump_error(14, Some("dash-label"), "dash");
 6099|       |        MermaidWorker::maybe_dump_error(14, Some("abcdefghijklmnopqrstuvwxyz0123456789"), "long");
 6100|       |        MermaidWorker::maybe_dump_svg(
 6101|       |            16,
 6102|       |            Some("abcdefghijklmnopqrstuvwxyz0123456789"),
 6103|       |            "<svg></svg>",
 6104|       |        );
 6105|       |        MermaidWorker::maybe_dump_svg(16, Some("under_score"), "<svg></svg>");
 6106|       |        MermaidWorker::maybe_dump_error(15, None, "no code");
 6107|       |        MermaidWorker::maybe_dump_svg(17, None, "<svg></svg>");
 6108|       |        MermaidWorker::maybe_dump_error(18, Some(""), "empty");
 6109|       |        MermaidWorker::maybe_dump_svg(19, Some(""), "<svg></svg>");
 6110|       |        MermaidWorker::maybe_dump_error(20, Some("\nrest"), "empty-label");
 6111|       |
 6112|       |        let entries: Vec<_> = std::fs::read_dir(dir.path())
 6113|       |            .expect("read dir")
 6114|       |            .filter_map(|entry| entry.ok())
 6115|       |            .collect();
 6116|       |        assert!(entries
 6117|       |            .iter()
 6118|       |            .any(|entry| entry.path().extension() == Some("svg".as_ref())));
 6119|       |        assert!(entries
 6120|       |            .iter()
 6121|       |            .any(|entry| entry.path().extension() == Some("txt".as_ref())));
 6122|       |    }
 6123|       |
 6124|       |    #[cfg(feature = "mermaid-quickjs")]
 6125|       |    #[test]
 6126|       |    fn test_mermaid_dump_helpers_empty_dir_env_noop() {
 6127|       |        let _lock = env_lock();
 6128|       |        let dir = tempdir().expect("temp dir");
 6129|       |        let seed_path = dir.path().join("seed.txt");
 6130|       |        std::fs::write(&seed_path, "seed").expect("seed write");
 6131|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_DUMP_DIR", "   ");
 6132|       |        MermaidWorker::maybe_dump_svg(20, Some("label"), "<svg></svg>");
 6133|       |        MermaidWorker::maybe_dump_error(21, Some("label"), "err");
 6134|       |        let entries: Vec<_> = std::fs::read_dir(dir.path())
 6135|       |            .expect("read dir")
 6136|       |            .filter_map(|entry| entry.ok())
 6137|       |            .collect();
 6138|       |        assert_eq!(entries.len(), 1);
 6139|       |        assert_eq!(entries[0].path(), seed_path);
 6140|       |    }
 6141|       |
 6142|       |    #[cfg(feature = "mermaid-quickjs")]
 6143|       |    #[test]
 6144|       |    fn test_mermaid_dump_helpers_invalid_dir_noop() {
 6145|       |        let _lock = env_lock();
 6146|       |        let dir = tempdir().expect("temp dir");
 6147|       |        let file_path = dir.path().join("not_a_dir.txt");
 6148|       |        std::fs::write(&file_path, "data").expect("write file");
 6149|       |        let _guard = EnvGuard::set(
 6150|       |            "MDMDVIEW_MERMAID_DUMP_DIR",
 6151|       |            file_path.to_string_lossy().as_ref(),
 6152|       |        );
 6153|       |        MermaidWorker::maybe_dump_svg(22, Some("label"), "<svg></svg>");
 6154|       |        MermaidWorker::maybe_dump_error(23, Some("label"), "err");
 6155|       |        let entries: Vec<_> = std::fs::read_dir(dir.path())
 6156|       |            .expect("read dir")
 6157|       |            .filter_map(|entry| entry.ok())
 6158|       |            .collect();
 6159|       |        assert_eq!(entries.len(), 1);
 6160|       |        assert!(entries[0].path().ends_with("not_a_dir.txt"));
 6161|       |    }
 6162|       |
 6163|       |    #[cfg(feature = "mermaid-quickjs")]
 6164|       |    #[test]
 6165|       |    fn test_poll_mermaid_results_handles_variants() {
 6166|       |        let (result_tx, result_rx) = bounded(10);
 6167|       |        let renderer = MermaidRenderer {
 6168|       |            mermaid_textures: RefCell::new(LruCache::new(4)),
 6169|       |            mermaid_pending: RefCell::new(std::collections::HashSet::new()),
 6170|       |            mermaid_frame_pending: std::cell::Cell::new(false),
 6171|       |            mermaid_svg_cache: RefCell::new(LruCache::new(4)),
 6172|       |            mermaid_errors: RefCell::new(LruCache::new(4)),
 6173|       |            mermaid_texture_errors: RefCell::new(LruCache::new(4)),
 6174|       |            mermaid_job_tx: None,
 6175|       |            mermaid_result_rx: result_rx,
 6176|       |            worker_handles: Vec::new(),
 6177|       |        };
 6178|       |        let ctx = egui::Context::default();
 6179|       |
 6180|       |        renderer
 6181|       |            .mermaid_pending
 6182|       |            .borrow_mut()
 6183|       |            .insert("k1".to_string());
 6184|       |        result_tx
 6185|       |            .send(MermaidResult {
 6186|       |                svg_key: 1,
 6187|       |                texture_key: "k1".to_string(),
 6188|       |                svg: Some("<svg width=\"1\" height=\"1\"></svg>".to_string()),
 6189|       |                rgba: None,
 6190|       |                size: None,
 6191|       |                error: None,
 6192|       |            })
 6193|       |            .expect("send svg");
 6194|       |        assert!(renderer.poll_mermaid_results(&ctx));
 6195|       |        assert!(renderer.mermaid_svg_cache.borrow_mut().get(&1).is_some());
 6196|       |
 6197|       |        renderer
 6198|       |            .mermaid_pending
 6199|       |            .borrow_mut()
 6200|       |            .insert("k2".to_string());
 6201|       |        result_tx
 6202|       |            .send(MermaidResult {
 6203|       |                svg_key: 2,
 6204|       |                texture_key: "k2".to_string(),
 6205|       |                svg: None,
 6206|       |                rgba: Some(vec![0, 0, 0, 0]),
 6207|       |                size: None,
 6208|       |                error: None,
 6209|       |            })
 6210|       |            .expect("send rgba missing size");
 6211|       |        renderer.poll_mermaid_results(&ctx);
 6212|       |        assert!(renderer
 6213|       |            .mermaid_texture_errors
 6214|       |            .borrow_mut()
 6215|       |            .get(&"k2".to_string())
 6216|       |            .is_some());
 6217|       |
 6218|       |        renderer
 6219|       |            .mermaid_pending
 6220|       |            .borrow_mut()
 6221|       |            .insert("k3".to_string());
 6222|       |        result_tx
 6223|       |            .send(MermaidResult {
 6224|       |                svg_key: 3,
 6225|       |                texture_key: "k3".to_string(),
 6226|       |                svg: None,
 6227|       |                rgba: None,
 6228|       |                size: None,
 6229|       |                error: Some("boom".to_string()),
 6230|       |            })
 6231|       |            .expect("send error");
 6232|       |        renderer.poll_mermaid_results(&ctx);
 6233|       |        assert!(renderer.mermaid_errors.borrow_mut().get(&3).is_some());
 6234|       |
 6235|       |        renderer
 6236|       |            .mermaid_pending
 6237|       |            .borrow_mut()
 6238|       |            .insert("k4".to_string());
 6239|       |        result_tx
 6240|       |            .send(MermaidResult {
 6241|       |                svg_key: 4,
 6242|       |                texture_key: "k4".to_string(),
 6243|       |                svg: Some("<svg width=\"1\" height=\"1\"></svg>".to_string()),
 6244|       |                rgba: None,
 6245|       |                size: None,
 6246|       |                error: Some("oops".to_string()),
 6247|       |            })
 6248|       |            .expect("send texture error");
 6249|       |        renderer.poll_mermaid_results(&ctx);
 6250|       |        assert!(renderer
 6251|       |            .mermaid_texture_errors
 6252|       |            .borrow_mut()
 6253|       |            .get(&"k4".to_string())
 6254|       |            .is_some());
 6255|       |
 6256|       |        renderer
 6257|       |            .mermaid_pending
 6258|       |            .borrow_mut()
 6259|       |            .insert("k5".to_string());
 6260|       |        result_tx
 6261|       |            .send(MermaidResult {
 6262|       |                svg_key: 5,
 6263|       |                texture_key: "k5".to_string(),
 6264|       |                svg: None,
 6265|       |                rgba: Some(vec![255, 255, 255, 255]),
 6266|       |                size: Some((1, 1)),
 6267|       |                error: None,
 6268|       |            })
 6269|       |            .expect("send rgba with size");
 6270|       |        renderer.poll_mermaid_results(&ctx);
 6271|       |        assert!(renderer
 6272|       |            .mermaid_textures
 6273|       |            .borrow_mut()
 6274|       |            .get(&"k5".to_string())
 6275|       |            .is_some());
 6276|       |    }
 6277|       |
 6278|       |    #[cfg(feature = "mermaid-quickjs")]
 6279|       |    #[test]
 6280|       |    fn test_format_js_error_variants() {
 6281|       |        let rt = rquickjs::Runtime::new().expect("runtime");
 6282|       |        let ctx = rquickjs::Context::full(&rt).expect("context");
 6283|       |        ctx.with(|ctx| {
 6284|       |            let err = ctx.eval::<(), _>("throw new Error('boom')").unwrap_err();
 6285|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6286|       |            assert!(msg.contains("boom"));
 6287|       |
 6288|       |            let err = ctx
 6289|       |                .eval::<(), _>("var e = new Error('match'); e.stack = 'match\\nstack'; throw e;")
 6290|       |                .unwrap_err();
 6291|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6292|       |            assert!(msg.contains("match"));
 6293|       |
 6294|       |            let err = ctx
 6295|       |                .eval::<(), _>("var e = new Error('note'); e.stack = 'stack only'; throw e;")
 6296|       |                .unwrap_err();
 6297|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6298|       |            assert!(!msg.is_empty());
 6299|       |
 6300|       |            let err = ctx
 6301|       |                .eval::<(), _>("var e = new Error('blank'); e.stack = ' '; throw e;")
 6302|       |                .unwrap_err();
 6303|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6304|       |            assert!(msg.contains("blank"));
 6305|       |
 6306|       |            let err = ctx
 6307|       |                .eval::<(), _>("throw ({ stack: 'stack-only-obj' })")
 6308|       |                .unwrap_err();
 6309|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6310|       |            assert!(!msg.is_empty());
 6311|       |
 6312|       |            let err = ctx
 6313|       |                .eval::<(), _>("throw ({ message: 'message-only-obj' })")
 6314|       |                .unwrap_err();
 6315|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6316|       |            assert!(!msg.is_empty());
 6317|       |
 6318|       |            let err = ctx
 6319|       |                .eval::<(), _>("var e = new Error(''); e.message = undefined; e.stack = 'stack-only'; throw e;")
 6320|       |                .unwrap_err();
 6321|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6322|       |            assert!(msg.contains("stack-only"));
 6323|       |
 6324|       |            let err = ctx
 6325|       |                .eval::<(), _>("var e = new Error('solo'); delete e.stack; throw e;")
 6326|       |                .unwrap_err();
 6327|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6328|       |            assert!(msg.contains("solo"));
 6329|       |
 6330|       |            let err = ctx
 6331|       |                .eval::<(), _>("var e = new Error('solo2'); e.stack = undefined; throw e;")
 6332|       |                .unwrap_err();
 6333|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6334|       |            assert!(msg.contains("solo2"));
 6335|       |
 6336|       |            let err = ctx
 6337|       |                .eval::<(), _>("var e = new Error('zap'); e.stack = ''; throw e;")
 6338|       |                .unwrap_err();
 6339|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6340|       |            assert!(msg.contains("zap"));
 6341|       |
 6342|       |            let err = ctx
 6343|       |                .eval::<(), _>("var e = new Error(''); e.message = ''; e.stack = ''; throw e;")
 6344|       |                .unwrap_err();
 6345|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6346|       |            assert!(!msg.is_empty());
 6347|       |
 6348|       |            let err = ctx.eval::<(), _>("throw 'stringy'").unwrap_err();
 6349|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6350|       |            assert_eq!(msg, "stringy");
 6351|       |
 6352|       |            let err = ctx.eval::<(), _>("throw 42").unwrap_err();
 6353|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6354|       |            assert_eq!(msg, "42");
 6355|       |
 6356|       |            let err = ctx.eval::<(), _>("throw 3.5").unwrap_err();
 6357|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6358|       |            assert!(msg.contains("3.5"));
 6359|       |
 6360|       |            let err = ctx.eval::<(), _>("throw true").unwrap_err();
 6361|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6362|       |            assert_eq!(msg, "true");
 6363|       |
 6364|       |            let msg = MermaidWorker::format_js_error(&ctx, rquickjs::Error::Unknown);
 6365|       |            assert!(!msg.is_empty());
 6366|       |
 6367|       |            let err = ctx.eval::<(), _>("throw ({})").unwrap_err();
 6368|       |            let msg = MermaidWorker::format_js_error(&ctx, err);
 6369|       |            assert!(!msg.is_empty());
 6370|       |        });
 6371|       |    }
 6372|       |
 6373|       |    struct EnvGuard {
 6374|       |        key: &'static str,
 6375|       |        original: Option<String>,
 6376|       |    }
 6377|       |
 6378|       |    impl EnvGuard {
 6379|       |        fn set(key: &'static str, value: &str) -> Self {
 6380|       |            let original = std::env::var(key).ok();
 6381|       |            std::env::set_var(key, value);
 6382|       |            Self { key, original }
 6383|       |        }
 6384|       |    }
 6385|       |
 6386|       |    impl Drop for EnvGuard {
 6387|       |        fn drop(&mut self) {
 6388|       |            if let Some(value) = &self.original {
 6389|       |                std::env::set_var(self.key, value);
 6390|       |            } else {
 6391|       |                std::env::remove_var(self.key);
 6392|       |            }
 6393|       |        }
 6394|       |    }
 6395|       |
 6396|       |    #[cfg(feature = "mermaid-quickjs")]
 6397|       |    struct MermaidJsEmptyGuard {
 6398|       |        previous: Option<std::thread::ThreadId>,
 6399|       |    }
 6400|       |
 6401|       |    #[cfg(feature = "mermaid-quickjs")]
 6402|       |    impl MermaidJsEmptyGuard {
 6403|       |        fn set(value: bool) -> Self {
 6404|       |            let previous = set_mermaid_js_empty_for_test(value);
 6405|       |            Self { previous }
 6406|       |        }
 6407|       |    }
 6408|       |
 6409|       |    #[cfg(feature = "mermaid-quickjs")]
 6410|       |    impl Drop for MermaidJsEmptyGuard {
 6411|       |        fn drop(&mut self) {
 6412|       |            let mut guard = MERMAID_JS_EMPTY_OVERRIDE
 6413|       |                .lock()
 6414|       |                .expect("mermaid js override lock");
 6415|       |            *guard = self.previous.clone();
 6416|       |        }
 6417|       |    }
 6418|       |
 6419|       |    #[test]
 6420|       |    fn test_parse_hex_color_and_mermaid_bg_fill() {
 6421|       |        let _lock = env_lock();
 6422|       |        assert_eq!(
 6423|       |            MermaidRenderer::parse_hex_color("#ff00ff"),
 6424|       |            Some([255, 0, 255, 255])
 6425|       |        );
 6426|       |        assert_eq!(
 6427|       |            MermaidRenderer::parse_hex_color("11223344"),
 6428|       |            Some([17, 34, 51, 68])
 6429|       |        );
 6430|       |        assert!(MermaidRenderer::parse_hex_color("bad").is_none());
 6431|       |        assert!(MermaidRenderer::parse_hex_color("GG0000").is_none());
 6432|       |        assert!(MermaidRenderer::parse_hex_color("00GG00").is_none());
 6433|       |        assert!(MermaidRenderer::parse_hex_color("0000GG").is_none());
 6434|       |        assert!(MermaidRenderer::parse_hex_color("GG000000").is_none());
 6435|       |        assert!(MermaidRenderer::parse_hex_color("00GG0000").is_none());
 6436|       |        assert!(MermaidRenderer::parse_hex_color("0000GG00").is_none());
 6437|       |        assert!(MermaidRenderer::parse_hex_color("000000GG").is_none());
 6438|       |
 6439|       |        {
 6440|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG_COLOR", "#010203");
 6441|       |            assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([1, 2, 3, 255]));
 6442|       |        }
 6443|       |
 6444|       |        {
 6445|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "transparent");
 6446|       |            assert_eq!(MermaidRenderer::mermaid_bg_fill(), None);
 6447|       |        }
 6448|       |
 6449|       |        {
 6450|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "dark");
 6451|       |            assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([20, 20, 20, 255]));
 6452|       |        }
 6453|       |    }
 6454|       |
 6455|       |    #[test]
 6456|       |    fn test_env_guard_restores_original_value() {
 6457|       |        let _lock = env_lock();
 6458|       |        std::env::set_var("MDMDVIEW_MERMAID_PATCH_DEBUG", "before");
 6459|       |        {
 6460|       |            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "after");
 6461|       |            assert_eq!(
 6462|       |                std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG")
 6463|       |                    .ok()
 6464|       |                    .as_deref(),
 6465|       |                Some("after")
 6466|       |            );
 6467|       |        }
 6468|       |        assert_eq!(
 6469|       |            std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG")
 6470|       |                .ok()
 6471|       |                .as_deref(),
 6472|       |            Some("before")
 6473|       |        );
 6474|       |        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
 6475|       |    }
 6476|       |
 6477|       |    #[test]
 6478|       |    fn test_mermaid_bg_fill_invalid_color_falls_back() {
 6479|       |        let _lock = env_lock();
 6480|       |        let _guard_color = EnvGuard::set("MDMDVIEW_MERMAID_BG_COLOR", "bad");
 6481|       |        let _guard_mode = EnvGuard::set("MDMDVIEW_MERMAID_BG", "dark");
 6482|       |        assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([20, 20, 20, 255]));
 6483|       |    }
 6484|       |
 6485|       |    #[test]
 6486|       |    fn test_mermaid_bg_fill_invalid_theme_color_uses_default() {
 6487|       |        let _lock = env_lock();
 6488|       |        let _guard_mode = EnvGuard::set("MDMDVIEW_MERMAID_BG", "theme");
 6489|       |        let _guard_bkg = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "bad");
 6490|       |        assert_eq!(
 6491|       |            MermaidRenderer::mermaid_bg_fill(),
 6492|       |            Some([255, 248, 219, 255])
 6493|       |        );
 6494|       |    }
 6495|       |
 6496|       |    #[test]
 6497|       |    fn test_mermaid_bg_key_and_scale_bucket() {
 6498|       |        assert_eq!(MermaidRenderer::mermaid_bg_key(None), "none");
 6499|       |        assert_eq!(
 6500|       |            MermaidRenderer::mermaid_bg_key(Some([1, 2, 3, 4])),
 6501|       |            "01020304"
 6502|       |        );
 6503|       |
 6504|       |        let factor = MermaidRenderer::MERMAID_SCALE_BUCKET_FACTOR;
 6505|       |        assert_eq!(
 6506|       |            MermaidRenderer::scale_bucket(0.1),
 6507|       |            (0.5 * factor).round() as u32
 6508|       |        );
 6509|       |        assert_eq!(
 6510|       |            MermaidRenderer::scale_bucket(10.0),
 6511|       |            (4.0 * factor).round() as u32
 6512|       |        );
 6513|       |    }
 6514|       |
 6515|       |    #[test]
 6516|       |    fn test_mermaid_hash_str_stable_and_distinct() {
 6517|       |        let a = MermaidRenderer::hash_str("alpha");
 6518|       |        let b = MermaidRenderer::hash_str("alpha");
 6519|       |        let c = MermaidRenderer::hash_str("beta");
 6520|       |        assert_eq!(a, b);
 6521|       |        assert_ne!(a, c);
 6522|       |    }
 6523|       |
 6524|       |    #[test]
 6525|       |    fn test_mermaid_bg_fill_light_mode() {
 6526|       |        let _lock = env_lock();
 6527|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "light");
 6528|       |        assert_eq!(
 6529|       |            MermaidRenderer::mermaid_bg_fill(),
 6530|       |            Some([255, 255, 255, 255])
 6531|       |        );
 6532|       |    }
 6533|       |
 6534|       |    #[test]
 6535|       |    fn test_mermaid_bg_fill_color_override() {
 6536|       |        let _lock = env_lock();
 6537|       |        std::env::remove_var("MDMDVIEW_MERMAID_BG");
 6538|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG_COLOR", "#11223344");
 6539|       |        assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([17, 34, 51, 68]));
 6540|       |    }
 6541|       |
 6542|       |    #[test]
 6543|       |    fn test_mermaid_bg_fill_theme_fallback() {
 6544|       |        let _lock = env_lock();
 6545|       |        let _guard_mode = EnvGuard::set("MDMDVIEW_MERMAID_BG", "theme");
 6546|       |        let _guard_bkg = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "#010203");
 6547|       |        assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([1, 2, 3, 255]));
 6548|       |    }
 6549|       |
 6550|       |    #[test]
 6551|       |    fn test_render_block_off_and_embedded_without_feature() {
 6552|       |        let _lock = env_lock();
 6553|       |        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
 6554|       |        let renderer = MermaidRenderer::new();
 6555|       |        let ctx = egui::Context::default();
 6556|       |        let input = egui::RawInput {
 6557|       |            screen_rect: Some(egui::Rect::from_min_size(
 6558|       |                egui::pos2(0.0, 0.0),
 6559|       |                egui::vec2(800.0, 600.0),
 6560|       |            )),
 6561|       |            ..Default::default()
 6562|       |        };
 6563|       |
 6564|       |        let mut rendered = true;
 6565|       |        let _ = ctx.run(input.clone(), |ctx| {
 6566|       |            egui::CentralPanel::default().show(ctx, |ui| {
 6567|       |                rendered = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 6568|       |            });
 6569|       |        });
 6570|       |        assert!(rendered);
 6571|       |
 6572|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "off");
 6573|       |        let renderer = MermaidRenderer::new();
 6574|       |        let mut rendered_off = true;
 6575|       |        let _ = ctx.run(input.clone(), |ctx| {
 6576|       |            egui::CentralPanel::default().show(ctx, |ui| {
 6577|       |                rendered_off = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 6578|       |            });
 6579|       |        });
 6580|       |        assert!(rendered_off);
 6581|       |
 6582|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6583|       |        let renderer = MermaidRenderer::new();
 6584|       |        let mut rendered_embedded = true;
 6585|       |        let _ = ctx.run(input, |ctx| {
 6586|       |            egui::CentralPanel::default().show(ctx, |ui| {
 6587|       |                rendered_embedded = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 6588|       |            });
 6589|       |        });
 6590|       |        assert!(rendered_embedded);
 6591|       |    }
 6592|       |
 6593|       |    #[cfg(feature = "mermaid-quickjs")]
 6594|       |    #[test]
 6595|       |    fn test_render_block_embedded_missing_js_fallback() {
 6596|       |        let _lock = env_lock();
 6597|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6598|       |        let _empty = MermaidJsEmptyGuard::set(true);
 6599|       |        let (_tx, rx) = bounded(1);
 6600|       |        let renderer = test_renderer_with_channels(None, rx);
 6601|       |        let ctx = egui::Context::default();
 6602|       |        let input = egui::RawInput {
 6603|       |            screen_rect: Some(egui::Rect::from_min_size(
 6604|       |                egui::pos2(0.0, 0.0),
 6605|       |                egui::vec2(800.0, 600.0),
 6606|       |            )),
 6607|       |            ..Default::default()
 6608|       |        };
 6609|       |
 6610|       |        let mut rendered = true;
 6611|       |        let _ = ctx.run(input, |ctx| {
 6612|       |            egui::CentralPanel::default().show(ctx, |ui| {
 6613|       |                rendered = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 6614|       |            });
 6615|       |        });
 6616|       |        assert!(rendered);
 6617|       |    }
 6618|       |
 6619|       |    #[cfg(feature = "mermaid-quickjs")]
 6620|       |    #[test]
 6621|       |    fn test_render_block_width_fallback_for_small_ui() {
 6622|       |        let _lock = env_lock();
 6623|       |        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
 6624|       |        let renderer = MermaidRenderer::new();
 6625|       |        let ctx = egui::Context::default();
 6626|       |        let input = egui::RawInput {
 6627|       |            screen_rect: Some(egui::Rect::from_min_size(
 6628|       |                egui::pos2(0.0, 0.0),
 6629|       |                egui::vec2(800.0, 600.0),
 6630|       |            )),
 6631|       |            ..Default::default()
 6632|       |        };
 6633|       |
 6634|       |        let mut rendered = true;
 6635|       |        let _ = ctx.run(input, |ctx| {
 6636|       |            egui::CentralPanel::default().show(ctx, |ui| {
 6637|       |                ui.allocate_ui_with_layout(
 6638|       |                    egui::vec2(20.0, 200.0),
 6639|       |                    egui::Layout::top_down(egui::Align::Min),
 6640|       |                    |ui| {
 6641|       |                        rendered = renderer.render_block(ui, "%% comment", 1.0, 14.0);
 6642|       |                    },
 6643|       |                );
 6644|       |            });
 6645|       |        });
 6646|       |        assert!(rendered);
 6647|       |    }
 6648|       |
 6649|       |    #[cfg(feature = "mermaid-quickjs")]
 6650|       |    #[test]
 6651|       |    fn test_render_block_width_fallback_equal_screen() {
 6652|       |        let _lock = env_lock();
 6653|       |        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
 6654|       |        let renderer = MermaidRenderer::new();
 6655|       |        let ctx = egui::Context::default();
 6656|       |        let input = egui::RawInput {
 6657|       |            screen_rect: Some(egui::Rect::from_min_size(
 6658|       |                egui::pos2(0.0, 0.0),
 6659|       |                egui::vec2(20.0, 200.0),
 6660|       |            )),
 6661|       |            ..Default::default()
 6662|       |        };
 6663|       |
 6664|       |        let mut rendered = true;
 6665|       |        let _ = ctx.run(input, |ctx| {
 6666|       |            egui::CentralPanel::default().show(ctx, |ui| {
 6667|       |                ui.allocate_ui_with_layout(
 6668|       |                    egui::vec2(20.0, 200.0),
 6669|       |                    egui::Layout::top_down(egui::Align::Min),
 6670|       |                    |ui| {
 6671|       |                        rendered = renderer.render_block(ui, "%% comment", 1.0, 14.0);
 6672|       |                    },
 6673|       |                );
 6674|       |            });
 6675|       |        });
 6676|       |        assert!(rendered);
 6677|       |    }
 6678|       |
 6679|       |    #[cfg(feature = "mermaid-quickjs")]
 6680|       |    #[test]
 6681|       |    fn test_render_block_uses_cached_texture_scales() {
 6682|       |        let _lock = env_lock();
 6683|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6684|       |        let (_result_tx, result_rx) = bounded(1);
 6685|       |        let renderer = test_renderer_with_channels(None, result_rx);
 6686|       |        let ctx = egui::Context::default();
 6687|       |        let input = egui::RawInput {
 6688|       |            screen_rect: Some(egui::Rect::from_min_size(
 6689|       |                egui::pos2(0.0, 0.0),
 6690|       |                egui::vec2(240.0, 160.0),
 6691|       |            )),
 6692|       |            ..Default::default()
 6693|       |        };
 6694|       |        let code = "graph TD; A-->B;";
 6695|       |        let mut rendered_large = false;
 6696|       |        let mut rendered_small = false;
 6697|       |
 6698|       |        let _ = ctx.run(input, |ctx| {
 6699|       |            egui::CentralPanel::default().show(ctx, |ui| {
 6700|       |                let image = egui::ColorImage::new([2, 2], Color32::WHITE);
 6701|       |                let texture =
 6702|       |                    ui.ctx()
 6703|       |                        .load_texture("mermaid-test", image, egui::TextureOptions::default());
 6704|       |                let svg_key = MermaidRenderer::hash_str(code);
 6705|       |                let make_key = |ui: &egui::Ui| {
 6706|       |                    let width_bucket = MermaidRenderer::width_bucket(ui.available_width());
 6707|       |                    let scale_bucket = MermaidRenderer::scale_bucket(1.0);
 6708|       |                    let bg = MermaidRenderer::mermaid_bg_fill();
 6709|       |                    MermaidRenderer::texture_key(svg_key, width_bucket, scale_bucket, bg)
 6710|       |                };
 6711|       |
 6712|       |                let texture_key = make_key(ui);
 6713|       |                renderer.mermaid_textures.borrow_mut().insert(
 6714|       |                    texture_key.clone(),
 6715|       |                    MermaidTextureEntry {
 6716|       |                        texture: texture.clone(),
 6717|       |                        size: [400, 200],
 6718|       |                    },
 6719|       |                );
 6720|       |                rendered_large = renderer.render_block(ui, code, 1.0, 14.0);
 6721|       |
 6722|       |                let texture_key = make_key(ui);
 6723|       |                renderer.mermaid_textures.borrow_mut().insert(
 6724|       |                    texture_key,
 6725|       |                    MermaidTextureEntry {
 6726|       |                        texture,
 6727|       |                        size: [20, 10],
 6728|       |                    },
 6729|       |                );
 6730|       |                rendered_small = renderer.render_block(ui, code, 1.0, 14.0);
 6731|       |            });
 6732|       |        });
 6733|       |
 6734|       |        assert!(rendered_large);
 6735|       |        assert!(rendered_small);
 6736|       |    }
 6737|       |
 6738|       |    #[cfg(feature = "mermaid-quickjs")]
 6739|       |    #[test]
 6740|       |    fn test_render_block_reports_cached_error() {
 6741|       |        let _lock = env_lock();
 6742|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6743|       |        let (_result_tx, result_rx) = bounded(1);
 6744|       |        let renderer = test_renderer_with_channels(None, result_rx);
 6745|       |        let code = "graph TD; A-->B;";
 6746|       |        let svg_key = MermaidRenderer::hash_str(code);
 6747|       |        renderer
 6748|       |            .mermaid_errors
 6749|       |            .borrow_mut()
 6750|       |            .insert(svg_key, "boom".to_string());
 6751|       |        let ctx = egui::Context::default();
 6752|       |        let input = egui::RawInput {
 6753|       |            screen_rect: Some(egui::Rect::from_min_size(
 6754|       |                egui::pos2(0.0, 0.0),
 6755|       |                egui::vec2(240.0, 160.0),
 6756|       |            )),
 6757|       |            ..Default::default()
 6758|       |        };
 6759|       |        let mut rendered = false;
 6760|       |        let _ = ctx.run(input, |ctx| {
 6761|       |            egui::CentralPanel::default().show(ctx, |ui| {
 6762|       |                rendered = renderer.render_block(ui, code, 1.0, 14.0);
 6763|       |            });
 6764|       |        });
 6765|       |        assert!(rendered);
 6766|       |    }
 6767|       |
 6768|       |    #[cfg(feature = "mermaid-quickjs")]
 6769|       |    #[test]
 6770|       |    fn test_render_block_queue_full_sets_waiting() {
 6771|       |        let _lock = env_lock();
 6772|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6773|       |        let (job_tx, job_rx) = bounded(1);
 6774|       |        let (_result_tx, result_rx) = bounded(1);
 6775|       |        let renderer = test_renderer_with_channels(Some(job_tx.clone()), result_rx);
 6776|       |        let request = MermaidRequest {
 6777|       |            svg_key: 1,
 6778|       |            texture_key: "full".to_string(),
 6779|       |            code: Some("graph TD; A-->B;".to_string()),
 6780|       |            svg: None,
 6781|       |            width_bucket: 32,
 6782|       |            scale_bucket: MermaidRenderer::scale_bucket(1.0),
 6783|       |            viewport_width: 120,
 6784|       |            viewport_height: 120,
 6785|       |            bg: MermaidRenderer::mermaid_bg_fill(),
 6786|       |        };
 6787|       |        job_tx.send(request).expect("fill queue");
 6788|       |
 6789|       |        let ctx = egui::Context::default();
 6790|       |        let input = egui::RawInput {
 6791|       |            screen_rect: Some(egui::Rect::from_min_size(
 6792|       |                egui::pos2(0.0, 0.0),
 6793|       |                egui::vec2(240.0, 160.0),
 6794|       |            )),
 6795|       |            ..Default::default()
 6796|       |        };
 6797|       |        let mut rendered = false;
 6798|       |        let _ = ctx.run(input, |ctx| {
 6799|       |            egui::CentralPanel::default().show(ctx, |ui| {
 6800|       |                rendered = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 6801|       |            });
 6802|       |        });
 6803|       |        assert!(rendered);
 6804|       |        assert!(renderer.mermaid_frame_pending.get());
 6805|       |        drop(job_rx);
 6806|       |    }
 6807|       |
 6808|       |    #[cfg(feature = "mermaid-quickjs")]
 6809|       |    #[test]
 6810|       |    fn test_render_block_disconnected_queue_sets_error() {
 6811|       |        let _lock = env_lock();
 6812|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6813|       |        let (_result_tx, result_rx) = bounded(1);
 6814|       |        let renderer = test_renderer_with_channels(None, result_rx);
 6815|       |        let ctx = egui::Context::default();
 6816|       |        let input = egui::RawInput {
 6817|       |            screen_rect: Some(egui::Rect::from_min_size(
 6818|       |                egui::pos2(0.0, 0.0),
 6819|       |                egui::vec2(240.0, 160.0),
 6820|       |            )),
 6821|       |            ..Default::default()
 6822|       |        };
 6823|       |        let code = "graph TD; A-->B;";
 6824|       |        let mut rendered = false;
 6825|       |        let _ = ctx.run(input, |ctx| {
 6826|       |            egui::CentralPanel::default().show(ctx, |ui| {
 6827|       |                rendered = renderer.render_block(ui, code, 1.0, 14.0);
 6828|       |            });
 6829|       |        });
 6830|       |        assert!(rendered);
 6831|       |        let svg_key = MermaidRenderer::hash_str(code);
 6832|       |        assert!(renderer.mermaid_errors.borrow_mut().get(&svg_key).is_some());
 6833|       |    }
 6834|       |
 6835|       |    #[cfg(feature = "mermaid-quickjs")]
 6836|       |    #[test]
 6837|       |    fn test_render_block_pending_and_width_fallback() {
 6838|       |        let _lock = env_lock();
 6839|       |        let _guard_renderer = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6840|       |        let _guard_log = EnvGuard::set("MDMDVIEW_MERMAID_LOG_WIDTH", "1");
 6841|       |        let (job_tx, job_rx) = bounded(2);
 6842|       |        let (result_tx, result_rx) = bounded(2);
 6843|       |        let renderer = test_renderer_with_channels(Some(job_tx), result_rx);
 6844|       |        result_tx
 6845|       |            .send(MermaidResult {
 6846|       |                svg_key: 99,
 6847|       |                texture_key: "other".to_string(),
 6848|       |                svg: Some("<svg width=\"1\" height=\"1\"></svg>".to_string()),
 6849|       |                rgba: None,
 6850|       |                size: None,
 6851|       |                error: None,
 6852|       |            })
 6853|       |            .expect("send svg");
 6854|       |
 6855|       |        let ctx = egui::Context::default();
 6856|       |        let input = egui::RawInput {
 6857|       |            screen_rect: Some(egui::Rect::from_min_size(
 6858|       |                egui::pos2(0.0, 0.0),
 6859|       |                egui::vec2(200.0, 120.0),
 6860|       |            )),
 6861|       |            ..Default::default()
 6862|       |        };
 6863|       |        let code = "timeline\n  title Demo";
 6864|       |        let mut rendered_first = false;
 6865|       |        let mut rendered_second = false;
 6866|       |        let _ = ctx.run(input, |ctx| {
 6867|       |            egui::CentralPanel::default().show(ctx, |ui| {
 6868|       |                let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(10.0, 80.0));
 6869|       |                ui.allocate_ui_at_rect(rect, |ui| {
 6870|       |                    rendered_first = renderer.render_block(ui, code, 1.0, 14.0);
 6871|       |                    rendered_second = renderer.render_block(ui, code, 1.0, 14.0);
 6872|       |                });
 6873|       |            });
 6874|       |        });
 6875|       |        assert!(rendered_first);
 6876|       |        assert!(rendered_second);
 6877|       |        drop(job_rx);
 6878|       |    }
 6879|       |
 6880|       |    #[test]
 6881|       |    fn test_mermaid_cache_insert_existing_key_and_empty_order() {
 6882|       |        let mut cache = LruCache::new(1);
 6883|       |        cache.insert(1u8, "one".to_string());
 6884|       |        cache.insert(1u8, "uno".to_string());
 6885|       |        assert_eq!(cache.get(&1), Some("uno".to_string()));
 6886|       |        assert!(cache.get(&9).is_none());
 6887|       |
 6888|       |        cache.insert(2u8, "two".to_string());
 6889|       |        assert!(cache.get(&1).is_none());
 6890|       |
 6891|       |        cache.entries.clear();
 6892|       |        cache.entries.insert(2u8, "two".to_string());
 6893|       |        cache.order.clear();
 6894|       |        cache.insert(3u8, "three".to_string());
 6895|       |        assert_eq!(cache.len(), 2);
 6896|       |    }
 6897|       |
 6898|       |    #[test]
 6899|       |    fn test_mermaid_has_pending_default_false() {
 6900|       |        let renderer = MermaidRenderer::new();
 6901|       |        assert!(!renderer.has_pending());
 6902|       |    }
 6903|       |
 6904|       |    #[cfg(feature = "mermaid-quickjs")]
 6905|       |    #[test]
 6906|       |    fn test_mermaid_has_pending_true_for_frame_or_queue() {
 6907|       |        let renderer = MermaidRenderer::new();
 6908|       |        renderer.mermaid_frame_pending.set(true);
 6909|       |        assert!(renderer.has_pending());
 6910|       |        renderer.mermaid_frame_pending.set(false);
 6911|       |        renderer
 6912|       |            .mermaid_pending
 6913|       |            .borrow_mut()
 6914|       |            .insert("pending".to_string());
 6915|       |        assert!(renderer.has_pending());
 6916|       |    }
 6917|       |
 6918|       |    #[cfg(feature = "mermaid-quickjs")]
 6919|       |    #[test]
 6920|       |    fn test_fix_journey_section_text_fill_adds_fill() {
 6921|       |        let input = r#"<svg><text class="journey-section section-type-0" x="0">Plan</text></svg>"#;
 6922|       |        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
 6923|       |            .expect("journey text updated");
 6924|       |        assert!(output.contains("class=\"journey-section section-type-0\""));
 6925|       |        assert!(output.contains("fill:#112233"));
 6926|       |    }
 6927|       |
 6928|       |    #[cfg(feature = "mermaid-quickjs")]
 6929|       |    #[test]
 6930|       |    fn test_fix_journey_section_text_overwrites_fill_in_style() {
 6931|       |        let input = r#"<svg><text class="journey-section" style="fill:#000000;stroke:#fff" x="0">Plan</text></svg>"#;
 6932|       |        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
 6933|       |            .expect("journey text updated");
 6934|       |        assert!(output.contains("fill:#112233"));
 6935|       |        assert!(!output.contains("fill:#000000"));
 6936|       |    }
 6937|       |
 6938|       |    #[cfg(feature = "mermaid-quickjs")]
 6939|       |    #[test]
 6940|       |    fn test_fix_journey_section_text_skips_empty_style_parts() {
 6941|       |        let input = r#"<svg><text class="journey-section" style="fill:#000000;;stroke:#fff" x="0">Plan</text></svg>"#;
 6942|       |        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
 6943|       |            .expect("journey text updated");
 6944|       |        assert!(output.contains("fill:#112233"));
 6945|       |        assert!(output.contains("stroke:#fff"));
 6946|       |    }
 6947|       |
 6948|       |    #[cfg(feature = "mermaid-quickjs")]
 6949|       |    #[test]
 6950|       |    fn test_fix_journey_section_text_noop_without_marker() {
 6951|       |        let input = r#"<svg><text class="label" x="0">Plan</text></svg>"#;
 6952|       |        assert!(MermaidWorker::fix_journey_section_text(input, "#112233").is_none());
 6953|       |    }
 6954|       |
 6955|       |    #[cfg(feature = "mermaid-quickjs")]
 6956|       |    #[test]
 6957|       |    fn test_fix_journey_section_text_handles_non_section_tag() {
 6958|       |        let input = r#"<svg><text class="label">A</text><text class="journey-section" style="fill:#000">B</text></svg>"#;
 6959|       |        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
 6960|       |            .expect("journey text updated");
 6961|       |        assert!(output.contains("class=\"label\""));
 6962|       |        assert!(output.contains("fill:#112233"));
 6963|       |    }
 6964|       |
 6965|       |    #[cfg(feature = "mermaid-quickjs")]
 6966|       |    #[test]
 6967|       |    fn test_fix_journey_section_text_style_missing_quote_returns_none() {
 6968|       |        let input = r#"<svg><text class="journey-section" style="fill:#000>Plan</text></svg>"#;
 6969|       |        assert!(MermaidWorker::fix_journey_section_text(input, "#112233").is_none());
 6970|       |    }
 6971|       |
 6972|       |    #[cfg(feature = "mermaid-quickjs")]
 6973|       |    #[test]
 6974|       |    fn test_fix_state_end_circles_swaps_radii() {
 6975|       |        let input = r#"<svg><g id="state-root_end-0"><circle class="state-end" r="5" width="10" height="10"></circle><circle class="state-start" r="7" width="14" height="14"></circle></g></svg>"#;
 6976|       |        let output =
 6977|       |            MermaidWorker::fix_state_end_circles(input).expect("state end circles updated");
 6978|       |        assert!(output.contains("class=\"state-end\" r=\"7\""));
 6979|       |        assert!(output.contains("class=\"end-state-inner\" r=\"5\""));
 6980|       |        assert!(output.contains("class=\"state-end\" r=\"7\" width=\"14\" height=\"14\""));
 6981|       |        assert!(output.contains("class=\"end-state-inner\" r=\"5\" width=\"10\" height=\"10\""));
 6982|       |    }
 6983|       |
 6984|       |    #[cfg(feature = "mermaid-quickjs")]
 6985|       |    #[test]
 6986|       |    fn test_fix_state_end_circles_swaps_radii_when_start_first() {
 6987|       |        let input = r#"<svg><g id="state-root_end-0"><circle class="state-start" r="7" width="14" height="14"></circle><circle class="state-end" r="5" width="10" height="10"></circle></g></svg>"#;
 6988|       |        let output =
 6989|       |            MermaidWorker::fix_state_end_circles(input).expect("state end circles updated");
 6990|       |        assert!(output.contains("end-state-inner"));
 6991|       |        assert!(output.contains("class=\"state-end\" r=\"7\""));
 6992|       |    }
 6993|       |
 6994|       |    #[cfg(feature = "mermaid-quickjs")]
 6995|       |    #[test]
 6996|       |    fn test_fix_state_end_circles_noop_without_marker() {
 6997|       |        let input = r#"<svg><g><circle class="state-start" r="7"></circle></g></svg>"#;
 6998|       |        assert!(MermaidWorker::fix_state_end_circles(input).is_none());
 6999|       |    }
 7000|       |
 7001|       |    #[cfg(feature = "mermaid-quickjs")]
 7002|       |    #[test]
 7003|       |    fn test_fix_state_end_circles_noop_when_radii_ordered() {
 7004|       |        let input = r#"<svg><g id="state-root_end-0"><circle class="state-end" r="7"></circle><circle class="state-start" r="5"></circle></g></svg>"#;
 7005|       |        assert!(MermaidWorker::fix_state_end_circles(input).is_none());
 7006|       |    }
 7007|       |
 7008|       |    #[cfg(feature = "mermaid-quickjs")]
 7009|       |    #[test]
 7010|       |    fn test_fix_state_end_circles_skips_non_end_group() {
 7011|       |        let input = r#"<svg><g id="state-root-0"><circle class="state-end" r="5"></circle></g><g id="state-root_end-0"><circle class="state-end" r="5" width="10" height="10"></circle><circle class="state-start" r="7" width="14" height="14"></circle></g></svg>"#;
 7012|       |        let output =
 7013|       |            MermaidWorker::fix_state_end_circles(input).expect("state end circles updated");
 7014|       |        assert!(output.contains("state-root-0"));
 7015|       |        assert!(output.contains("end-state-inner"));
 7016|       |    }
 7017|       |
 7018|       |    #[cfg(feature = "mermaid-quickjs")]
 7019|       |    #[test]
 7020|       |    fn test_fix_state_end_circles_missing_parts_noop() {
 7021|       |        let missing_start =
 7022|       |            r#"<svg><g id="state-root_end-0"><circle class="state-end" r="5"></circle></g></svg>"#;
 7023|       |        assert!(MermaidWorker::fix_state_end_circles(missing_start).is_none());
 7024|       |
 7025|       |        let missing_r = r#"<svg><g id="state-root_end-0"><circle class="state-end"></circle><circle class="state-start" r="7"></circle></g></svg>"#;
 7026|       |        assert!(MermaidWorker::fix_state_end_circles(missing_r).is_none());
 7027|       |
 7028|       |        let non_numeric = r#"<svg><g id="state-root_end-0"><circle class="state-end" r="x"></circle><circle class="state-start" r="7"></circle></g></svg>"#;
 7029|       |        assert!(MermaidWorker::fix_state_end_circles(non_numeric).is_none());
 7030|       |    }
 7031|       |
 7032|       |    #[cfg(feature = "mermaid-quickjs")]
 7033|       |    #[test]
 7034|       |    fn test_find_circle_tag_missing_parts_returns_none() {
 7035|       |        let missing_circle = r#"<g class="state-end"></g>"#;
 7036|       |        assert!(MermaidWorker::find_circle_tag(missing_circle, "state-end").is_none());
 7037|       |
 7038|       |        let missing_end = r#"<circle class="state-end""#;
 7039|       |        assert!(MermaidWorker::find_circle_tag(missing_end, "state-end").is_none());
 7040|       |    }
 7041|       |
 7042|       |    #[cfg(feature = "mermaid-quickjs")]
 7043|       |    #[test]
 7044|       |    fn test_read_r_value_missing_quote_returns_none() {
 7045|       |        let tag = r#"<circle r="10"#;
 7046|       |        assert!(MermaidWorker::read_r_value(tag).is_none());
 7047|       |    }
 7048|       |
 7049|       |    #[cfg(feature = "mermaid-quickjs")]
 7050|       |    #[test]
 7051|       |    fn test_mindmap_edge_trim_uses_min_radius() {
 7052|       |        let dx_idx = MERMAID_DOM_SHIM
 7053|       |            .find("var dx = t_pos.x - s_pos.x")
 7054|       |            .expect("mindmap dx computed");
 7055|       |        let radius_idx = MERMAID_DOM_SHIM
 7056|       |            .find("var s_radius = __mdmdview_rect_intersection")
 7057|       |            .expect("mindmap radius computed");
 7058|       |        assert!(dx_idx < radius_idx);
 7059|       |    }
 7060|       |
 7061|       |    #[cfg(feature = "mermaid-quickjs")]
 7062|       |    #[test]
 7063|       |    fn test_mindmap_edge_overlap_padding_present() {
 7064|       |        assert!(MERMAID_DOM_SHIM.contains("var overlap = -2"));
 7065|       |        assert!(MERMAID_DOM_SHIM.contains("var max_total = len * 0.95"));
 7066|       |    }
 7067|       |
 7068|       |    #[cfg(feature = "mermaid-quickjs")]
 7069|       |    #[test]
 7070|       |    fn test_flatten_svg_switches_removes_foreignobject() {
 7071|       |        let input = r#"<svg><switch><foreignObject><div>Plan</div></foreignObject><text>Plan</text></switch></svg>"#;
 7072|       |        let output = MermaidWorker::flatten_svg_switches(input).expect("switch flattened");
 7073|       |        assert!(!output.contains("<switch"));
 7074|       |        assert!(!output.contains("foreignObject"));
 7075|       |        assert!(output.contains("<text>Plan</text>"));
 7076|       |    }
 7077|       |
 7078|       |    #[cfg(feature = "mermaid-quickjs")]
 7079|       |    #[test]
 7080|       |    fn test_mermaid_dom_shim_clusters_not_labelish() {
 7081|       |        assert!(MERMAID_DOM_SHIM.contains("has_class(node, 'clusters')"));
 7082|       |    }
 7083|       |
 7084|       |    #[cfg(feature = "mermaid-quickjs")]
 7085|       |    #[test]
 7086|       |    fn test_fix_er_attribute_fills_inlines_colors() {
 7087|       |        let input = r#"<svg><rect class="er attributeBoxOdd"></rect><rect class="er attributeBoxEven"></rect></svg>"#;
 7088|       |        let output = MermaidWorker::fix_er_attribute_fills(input).expect("er fills updated");
 7089|       |        assert!(output.contains("attributeBoxOdd\" fill=\"#ffffff\""));
 7090|       |        assert!(output.contains("attributeBoxEven\" fill=\"#f2f2f2\""));
 7091|       |    }
 7092|       |
 7093|       |    #[cfg(feature = "mermaid-quickjs")]
 7094|       |    #[test]
 7095|       |    fn test_fix_er_attribute_fills_handles_even_only() {
 7096|       |        let input = r#"<svg><rect class="er attributeBoxEven"></rect></svg>"#;
 7097|       |        let output = MermaidWorker::fix_er_attribute_fills(input).expect("er fills updated");
 7098|       |        assert!(output.contains("attributeBoxEven\" fill=\"#f2f2f2\""));
 7099|       |    }
 7100|       |
 7101|       |    #[cfg(feature = "mermaid-quickjs")]
 7102|       |    #[test]
 7103|       |    fn test_fix_er_attribute_fills_skips_unmatched_rects() {
 7104|       |        let input =
 7105|       |            r#"<svg><rect class="er attributeBoxOdd"></rect><rect class="er"></rect></svg>"#;
 7106|       |        let output = MermaidWorker::fix_er_attribute_fills(input).expect("er fills updated");
 7107|       |        assert!(output.contains("attributeBoxOdd\" fill=\"#ffffff\""));
 7108|       |        assert!(output.contains("class=\"er\"></rect>"));
 7109|       |    }
 7110|       |
 7111|       |    #[cfg(feature = "mermaid-quickjs")]
 7112|       |    #[test]
 7113|       |    fn test_fix_er_attribute_fills_noop_without_markers() {
 7114|       |        let input = r#"<svg><rect class="er"></rect></svg>"#;
 7115|       |        assert!(MermaidWorker::fix_er_attribute_fills(input).is_none());
 7116|       |    }
 7117|       |
 7118|       |    #[cfg(feature = "mermaid-quickjs")]
 7119|       |    #[test]
 7120|       |    fn test_fix_er_attribute_fills_noop_when_fill_matches() {
 7121|       |        let input = r##"<svg><rect class="er attributeBoxOdd" fill="#ffffff"></rect></svg>"##;
 7122|       |        assert!(MermaidWorker::fix_er_attribute_fills(input).is_none());
 7123|       |    }
 7124|       |
 7125|       |    #[cfg(feature = "mermaid-quickjs")]
 7126|       |    #[test]
 7127|       |    fn test_flatten_svg_switches_noop_without_switch() {
 7128|       |        let input = r#"<svg><text>Plan</text></svg>"#;
 7129|       |        assert!(MermaidWorker::flatten_svg_switches(input).is_none());
 7130|       |    }
 7131|       |
 7132|       |    #[cfg(feature = "mermaid-quickjs")]
 7133|       |    #[test]
 7134|       |    fn test_flatten_svg_switches_handles_missing_close() {
 7135|       |        let input = r#"<svg><switch><text>Plan</text></svg>"#;
 7136|       |        assert!(MermaidWorker::flatten_svg_switches(input).is_none());
 7137|       |    }
 7138|       |
 7139|       |    #[cfg(feature = "mermaid-quickjs")]
 7140|       |    #[test]
 7141|       |    fn test_flatten_svg_switches_missing_foreign_object_close() {
 7142|       |        let input =
 7143|       |            r#"<svg><switch><foreignObject><div>Plan</div></switch><text>After</text></svg>"#;
 7144|       |        let output = MermaidWorker::flatten_svg_switches(input).expect("switch flattened");
 7145|       |        assert!(output.contains("<text>After</text>"));
 7146|       |    }
 7147|       |
 7148|       |    #[cfg(feature = "mermaid-quickjs")]
 7149|       |    #[test]
 7150|       |    fn test_patch_mermaid_js_applies_expected_replacements() {
 7151|       |        let js = concat!(
 7152|       |            "var hD=wRe();",
 7153|       |            "FY.prototype={constructor:FY,appendChild:function(i){return this._parent.insertBefore(i,this._next)},insertBefore:function(i,s){return this._parent.insertBefore(i,s)},querySelector:function(i){return this._parent.querySelector(i)},querySelectorAll:function(i){return this._parent.querySelectorAll(i)}};",
 7154|       |            "function FY(i,s){this.ownerDocument=i.ownerDocument,this.namespaceURI=i.namespaceURI,this._next=null,this._parent=i,this.__data__=s}",
 7155|       |            "u.text().split(/(\\s+|<br>)/).reverse()",
 7156|       |            "p=fWe({container:document.getElementById(\"cy\"),style:[{selector:\"edge\",style:{\"curve-style\":\"bezier\"}}]});",
 7157|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run(),p.ready(v=>{Xe.info(\"Ready\",v),u(p)})",
 7158|       |            "const se=_.node().getBBox();"
 7159|       |        );
 7160|       |        let output = MermaidWorker::patch_mermaid_js(js);
 7161|       |        assert!(output.contains("sanitize:function"));
 7162|       |        assert!(output.contains("document.body"));
 7163|       |        assert!(output.contains("String(typeof u.text"));
 7164|       |        assert!(output.contains("__mdmdview_cytoscape_stub"));
 7165|       |        assert!(output.contains("breadthfirst"));
 7166|       |        assert!(output.contains("se.width=Math.max"));
 7167|       |    }
 7168|       |
 7169|       |    #[cfg(feature = "mermaid-quickjs")]
 7170|       |    #[test]
 7171|       |    fn test_patch_mermaid_js_applies_mindmap_layout_fallback() {
 7172|       |        let js =
 7173|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 7174|       |        let output = MermaidWorker::patch_mermaid_js(js);
 7175|       |        assert!(output.contains("breadthfirst"));
 7176|       |    }
 7177|       |
 7178|       |    #[cfg(feature = "mermaid-quickjs")]
 7179|       |    #[test]
 7180|       |    fn test_patch_mermaid_js_debug_paths_without_targets() {
 7181|       |        let _lock = env_lock();
 7182|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
 7183|       |        let js = "console.log('no targets here');";
 7184|       |        let output = MermaidWorker::patch_mermaid_js(js);
 7185|       |        assert_eq!(output, js);
 7186|       |    }
 7187|       |
 7188|       |    #[cfg(feature = "mermaid-quickjs")]
 7189|       |    #[test]
 7190|       |    fn test_patch_mermaid_js_debug_false_branch() {
 7191|       |        let _lock = env_lock();
 7192|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
 7193|       |        let previous = std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG").ok();
 7194|       |        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
 7195|       |        let js =
 7196|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 7197|       |        let output = MermaidWorker::patch_mermaid_js(js);
 7198|       |        assert!(output.contains("breadthfirst"));
 7199|       |        restore_env_var("MDMDVIEW_MERMAID_PATCH_DEBUG", previous);
 7200|       |    }
 7201|       |
 7202|       |    #[cfg(feature = "mermaid-quickjs")]
 7203|       |    #[test]
 7204|       |    fn test_patch_mermaid_js_debug_restore_when_missing() {
 7205|       |        let _lock = env_lock();
 7206|       |        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
 7207|       |        let previous = std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG").ok();
 7208|       |        let js =
 7209|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 7210|       |        let output = MermaidWorker::patch_mermaid_js(js);
 7211|       |        assert!(output.contains("breadthfirst"));
 7212|       |        restore_env_var("MDMDVIEW_MERMAID_PATCH_DEBUG", previous);
 7213|       |    }
 7214|       |
 7215|       |    #[cfg(feature = "mermaid-quickjs")]
 7216|       |    #[test]
 7217|       |    fn test_patch_mermaid_js_debug_missing_layout_not_logged_when_debug_off() {
 7218|       |        let _lock = env_lock();
 7219|       |        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
 7220|       |        let js = "console.log('no targets here');";
 7221|       |        let output = MermaidWorker::patch_mermaid_js(js);
 7222|       |        assert_eq!(output, js);
 7223|       |    }
 7224|       |
 7225|       |    #[cfg(feature = "mermaid-quickjs")]
 7226|       |    #[test]
 7227|       |    fn test_patch_mermaid_js_debug_paths_with_targets() {
 7228|       |        let _lock = env_lock();
 7229|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
 7230|       |        let js = concat!(
 7231|       |            "var hD=wRe();",
 7232|       |            "FY.prototype={constructor:FY,appendChild:function(i){return this._parent.insertBefore(i,this._next)},insertBefore:function(i,s){return this._parent.insertBefore(i,s)},querySelector:function(i){return this._parent.querySelector(i)},querySelectorAll:function(i){return this._parent.querySelectorAll(i)}};",
 7233|       |            "function FY(i,s){this.ownerDocument=i.ownerDocument,this.namespaceURI=i.namespaceURI,this._next=null,this._parent=i,this.__data__=s}",
 7234|       |            "u.text().split(/(\\s+|<br>)/).reverse()",
 7235|       |            "p=fWe({container:document.getElementById(\"cy\"),style:[{selector:\"edge\",style:{\"curve-style\":\"bezier\"}}]});",
 7236|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run(),p.ready(v=>{Xe.info(\"Ready\",v),u(p)})",
 7237|       |            "const se=_.node().getBBox();"
 7238|       |        );
 7239|       |        let output = MermaidWorker::patch_mermaid_js(js);
 7240|       |        assert!(output.contains("sanitize:function"));
 7241|       |        assert!(output.contains("__mdmdview_cytoscape_stub"));
 7242|       |    }
 7243|       |
 7244|       |    #[cfg(feature = "mermaid-quickjs")]
 7245|       |    #[test]
 7246|       |    fn test_patch_mermaid_js_debug_paths_with_layout_only() {
 7247|       |        let _lock = env_lock();
 7248|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
 7249|       |        let js =
 7250|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 7251|       |        let output = MermaidWorker::patch_mermaid_js(js);
 7252|       |        assert!(output.contains("breadthfirst"));
 7253|       |    }
 7254|       |
 7255|       |    #[cfg(feature = "mermaid-quickjs")]
 7256|       |    #[test]
 7257|       |    fn test_normalize_svg_size_inserts_dimensions() {
 7258|       |        let svg = r#"<svg viewBox="0 0 200 100" width="100%" height="100%"></svg>"#;
 7259|       |        let output = MermaidWorker::normalize_svg_size(svg);
 7260|       |        assert!(output.contains("width=\"200\""));
 7261|       |        assert!(output.contains("height=\"100\""));
 7262|       |    }
 7263|       |
 7264|       |    #[cfg(feature = "mermaid-quickjs")]
 7265|       |    #[test]
 7266|       |    fn test_normalize_svg_size_inserts_missing_dimension() {
 7267|       |        let svg = r#"<svg viewBox="0 0 320 240" height="100%"></svg>"#;
 7268|       |        let output = MermaidWorker::normalize_svg_size(svg);
 7269|       |        assert!(output.contains("width=\"320\""));
 7270|       |        assert!(output.contains("height=\"240\""));
 7271|       |    }
 7272|       |
 7273|       |    #[cfg(feature = "mermaid-quickjs")]
 7274|       |    #[test]
 7275|       |    fn test_normalize_svg_size_skips_fixed_dimensions() {
 7276|       |        let svg = r#"<svg viewBox="0 0 200 100" width="200" height="100"></svg>"#;
 7277|       |        assert_eq!(MermaidWorker::normalize_svg_size(svg), svg);
 7278|       |    }
 7279|       |
 7280|       |    #[cfg(feature = "mermaid-quickjs")]
 7281|       |    #[test]
 7282|       |    fn test_normalize_svg_size_no_viewbox_no_change() {
 7283|       |        let svg = r#"<svg width="100%" height="100%"></svg>"#;
 7284|       |        assert_eq!(MermaidWorker::normalize_svg_size(svg), svg);
 7285|       |    }
 7286|       |
 7287|       |    #[cfg(feature = "mermaid-quickjs")]
 7288|       |    #[test]
 7289|       |    fn test_replace_and_upsert_attr_paths() {
 7290|       |        let tag = r#"<svg width="10" height="20">"#;
 7291|       |        let replaced = MermaidWorker::replace_attr(tag, "width", "99");
 7292|       |        assert!(replaced.contains("width=\"99\""));
 7293|       |        let unchanged = MermaidWorker::replace_attr(tag, "viewBox", "0 0 1 1");
 7294|       |        assert_eq!(unchanged, tag);
 7295|       |        let upsert_existing = MermaidWorker::upsert_attr(tag, "height", "42");
 7296|       |        assert!(upsert_existing.contains("height=\"42\""));
 7297|       |        let upsert_new = MermaidWorker::upsert_attr(tag, "viewBox", "0 0 1 1");
 7298|       |        assert!(upsert_new.contains("viewBox=\"0 0 1 1\""));
 7299|       |    }
 7300|       |
 7301|       |    #[cfg(feature = "mermaid-quickjs")]
 7302|       |    #[test]
 7303|       |    fn test_strip_svg_attr_and_insert_svg_attr() {
 7304|       |        let svg = r#"<svg width="10" height="20"></svg>"#;
 7305|       |        let stripped = MermaidWorker::strip_svg_attr(svg, "width").expect("width removed");
 7306|       |        assert!(!stripped.contains("width=\"10\""));
 7307|       |        assert!(MermaidWorker::strip_svg_attr(svg, "viewBox").is_none());
 7308|       |        let inserted = MermaidWorker::insert_svg_attr("<svg></svg>", "viewBox", "0 0 1 1");
 7309|       |        assert!(inserted.contains("viewBox=\"0 0 1 1\""));
 7310|       |    }
 7311|       |
 7312|       |    #[cfg(feature = "mermaid-quickjs")]
 7313|       |    #[test]
 7314|       |    fn test_remove_svg_attr_trims_double_space() {
 7315|       |        let tag = r#"<svg width="10"  height="20">"#;
 7316|       |        let stripped = MermaidWorker::remove_svg_attr(tag, "width");
 7317|       |        assert!(!stripped.contains("width=\"10\""));
 7318|       |        assert!(stripped.contains("height=\"20\""));
 7319|       |        assert!(stripped.starts_with("<svg"));
 7320|       |    }
 7321|       |
 7322|       |    #[cfg(feature = "mermaid-quickjs")]
 7323|       |    #[test]
 7324|       |    fn test_remove_svg_attr_handles_no_space_prefix() {
 7325|       |        let tag = r#"<svgwidth="10" height="20">"#;
 7326|       |        let stripped = MermaidWorker::remove_svg_attr(tag, "width");
 7327|       |        assert!(!stripped.contains("width=\"10\""));
 7328|       |        assert!(stripped.contains("height=\"20\""));
 7329|       |        assert!(stripped.starts_with("<svg"));
 7330|       |    }
 7331|       |
 7332|       |    #[cfg(feature = "mermaid-quickjs")]
 7333|       |    #[test]
 7334|       |    fn test_remove_svg_attr_noop_when_missing_or_unclosed() {
 7335|       |        let tag = r#"<svg height="20">"#;
 7336|       |        assert_eq!(MermaidWorker::remove_svg_attr(tag, "width"), tag);
 7337|       |        let unclosed = r#"<svg width="10 height=20>"#;
 7338|       |        assert_eq!(MermaidWorker::remove_svg_attr(unclosed, "width"), unclosed);
 7339|       |    }
 7340|       |
 7341|       |    #[cfg(feature = "mermaid-quickjs")]
 7342|       |    #[test]
 7343|       |    fn test_remove_svg_attr_preserves_spacing_without_double_space() {
 7344|       |        let tag = r#"<svg width="10"height="20">"#;
 7345|       |        assert_eq!(
 7346|       |            MermaidWorker::remove_svg_attr(tag, "width"),
 7347|       |            "<svg height=\"20\">"
 7348|       |        );
 7349|       |    }
 7350|       |
 7351|       |    #[cfg(feature = "mermaid-quickjs")]
 7352|       |    #[test]
 7353|       |    fn test_parse_viewbox_dims_and_format_dim() {
 7354|       |        assert_eq!(
 7355|       |            MermaidWorker::parse_viewbox_dims("0 0 100 200"),
 7356|       |            Some((100.0, 200.0))
 7357|       |        );
 7358|       |        assert_eq!(
 7359|       |            MermaidWorker::parse_viewbox_dims("0,0,100,200"),
 7360|       |            Some((100.0, 200.0))
 7361|       |        );
 7362|       |        assert!(MermaidWorker::parse_viewbox_dims("0,0,100,0").is_none());
 7363|       |        assert!(MermaidWorker::parse_viewbox_dims("0 0 -1 2").is_none());
 7364|       |        assert!(MermaidWorker::parse_viewbox_dims("0 0 NaN 2").is_none());
 7365|       |        assert!(MermaidWorker::parse_viewbox_dims("0 0 inf 2").is_none());
 7366|       |        assert!(MermaidWorker::parse_viewbox_dims("0 0 2 inf").is_none());
 7367|       |        assert!(MermaidWorker::parse_viewbox_dims("bad").is_none());
 7368|       |        assert_eq!(MermaidWorker::format_dim(10.0), "10");
 7369|       |        assert_eq!(MermaidWorker::format_dim(10.5), "10.5");
 7370|       |        assert_eq!(MermaidWorker::format_dim(0.0), "0");
 7371|       |        assert_eq!(MermaidWorker::format_dim(10.123), "10.123");
 7372|       |        let nan = MermaidWorker::format_dim(f32::NAN);
 7373|       |        assert!(!nan.contains('.'));
 7374|       |        assert!(nan.to_lowercase().contains("nan"));
 7375|       |    }
 7376|       |
 7377|       |    #[cfg(feature = "mermaid-quickjs")]
 7378|       |    #[test]
 7379|       |    fn test_find_svg_attr_missing_quote_returns_none() {
 7380|       |        let tag = r#"<svg viewBox="0 0 10 10"#;
 7381|       |        assert!(MermaidWorker::find_svg_attr(tag, "viewBox").is_none());
 7382|       |    }
 7383|       |
 7384|       |    #[cfg(feature = "mermaid-quickjs")]
 7385|       |    #[test]
 7386|       |    fn test_strip_svg_attr_missing_tag_returns_none() {
 7387|       |        assert!(MermaidWorker::strip_svg_attr("no svg here", "width").is_none());
 7388|       |        let missing_end = r#"<svg width="10""#;
 7389|       |        assert!(MermaidWorker::strip_svg_attr(missing_end, "width").is_none());
 7390|       |    }
 7391|       |
 7392|       |    #[cfg(feature = "mermaid-quickjs")]
 7393|       |    #[test]
 7394|       |    fn test_text_measurer_fallback_for_missing_fonts() {
 7395|       |        let fontdb = Arc::new(usvg::fontdb::Database::new());
 7396|       |        let measurer = TextMeasurer::new(Arc::clone(&fontdb));
 7397|       |        let (width, height) = measurer.measure_text("abc", -1.0, Some(700.0));
 7398|       |        assert!(width > 0.0);
 7399|       |        assert!(height > 0.0);
 7400|       |    }
 7401|       |
 7402|       |    #[cfg(feature = "mermaid-quickjs")]
 7403|       |    #[test]
 7404|       |    fn test_text_measurer_non_finite_font_size_uses_default() {
 7405|       |        let mut fontdb = usvg::fontdb::Database::new();
 7406|       |        fontdb.load_system_fonts();
 7407|       |        let measurer = TextMeasurer::new(Arc::new(fontdb));
 7408|       |        let (width, height) = measurer.measure_text("abc", f32::NAN, None);
 7409|       |        assert!(width > 0.0);
 7410|       |        assert!(height > 0.0);
 7411|       |    }
 7412|       |
 7413|       |    #[cfg(feature = "mermaid-quickjs")]
 7414|       |    #[test]
 7415|       |    fn test_text_measurer_missing_glyph_uses_fallback_advance() {
 7416|       |        let mut fontdb = usvg::fontdb::Database::new();
 7417|       |        fontdb.load_system_fonts();
 7418|       |        let measurer = TextMeasurer::new(Arc::new(fontdb));
 7419|       |        let (width, height) = measurer.measure_text("\u{10FFFF}", 16.0, None);
 7420|       |        assert!(width > 0.0);
 7421|       |        assert!(height > 0.0);
 7422|       |    }
 7423|       |
 7424|       |    #[cfg(feature = "mermaid-quickjs")]
 7425|       |    #[test]
 7426|       |    fn test_text_measurer_forced_face_parse_error_falls_back() {
 7427|       |        let mut fontdb = usvg::fontdb::Database::new();
 7428|       |        fontdb.load_system_fonts();
 7429|       |        let measurer = TextMeasurer::new(Arc::new(fontdb));
 7430|       |        force_mermaid_face_parse_error_once();
 7431|       |        let (width, height) = measurer.measure_text("abc", 16.0, None);
 7432|       |        assert!(width > 0.0);
 7433|       |        assert!(height > 0.0);
 7434|       |    }
 7435|       |
 7436|       |    #[cfg(feature = "mermaid-quickjs")]
 7437|       |    #[test]
 7438|       |    fn test_text_measurer_bold_adjusts_when_faces_match() {
 7439|       |        let mut fontdb = usvg::fontdb::Database::new();
 7440|       |        fontdb.load_system_fonts();
 7441|       |        let fontdb = Arc::new(fontdb);
 7442|       |        let face_id = fontdb.query(&usvg::fontdb::Query {
 7443|       |            families: &[usvg::fontdb::Family::SansSerif],
 7444|       |            ..Default::default()
 7445|       |        });
 7446|       |        let measurer = TextMeasurer {
 7447|       |            fontdb: Arc::clone(&fontdb),
 7448|       |            face_id,
 7449|       |            bold_face_id: face_id,
 7450|       |        };
 7451|       |        let (width, height) = measurer.measure_text("Test", 16.0, Some(700.0));
 7452|       |        assert!(width > 0.0);
 7453|       |        assert!(height > 0.0);
 7454|       |    }
 7455|       |
 7456|       |    #[cfg(feature = "mermaid-quickjs")]
 7457|       |    #[test]
 7458|       |    fn test_text_measurer_empty_text_returns_zero() {
 7459|       |        let mut fontdb = usvg::fontdb::Database::new();
 7460|       |        fontdb.load_system_fonts();
 7461|       |        let measurer = TextMeasurer::new(Arc::new(fontdb));
 7462|       |        let (width, height) = measurer.measure_text("", 16.0, None);
 7463|       |        assert_eq!(width, 0.0);
 7464|       |        assert_eq!(height, 0.0);
 7465|       |    }
 7466|       |
 7467|       |    #[cfg(feature = "mermaid-quickjs")]
 7468|       |    #[test]
 7469|       |    fn test_text_measurer_fallback_handles_shorter_lines() {
 7470|       |        let (width, height) = TextMeasurer::fallback_measure("abcd\na", 10.0);
 7471|       |        assert!((width - 20.0).abs() < 0.01);
 7472|       |        assert!((height - 24.0).abs() < 0.01);
 7473|       |    }
 7474|       |
 7475|       |    #[cfg(feature = "mermaid-quickjs")]
 7476|       |    #[test]
 7477|       |    fn test_text_measurer_kerning_adjusts_width_when_available() {
 7478|       |        let mut fontdb = usvg::fontdb::Database::new();
 7479|       |        fontdb.load_system_fonts();
 7480|       |        let fontdb = Arc::new(fontdb);
 7481|       |        let measurer = TextMeasurer::new(Arc::clone(&fontdb));
 7482|       |        let (w_av, _) = measurer.measure_text("AV", 16.0, None);
 7483|       |        let (w_a, _) = measurer.measure_text("A", 16.0, None);
 7484|       |        let (w_v, _) = measurer.measure_text("V", 16.0, None);
 7485|       |        assert!(w_av <= w_a + w_v);
 7486|       |    }
 7487|       |
 7488|       |    #[cfg(feature = "mermaid-quickjs")]
 7489|       |    #[test]
 7490|       |    fn test_scale_adjustment_for_svg_defaults() {
 7491|       |        assert_eq!(MermaidWorker::scale_adjustment_for_svg("<svg></svg>"), 1.0);
 7492|       |        assert_eq!(
 7493|       |            MermaidWorker::scale_adjustment_for_svg("<svg aria-roledescription=\"er\"></svg>"),
 7494|       |            0.94
 7495|       |        );
 7496|       |        assert_eq!(
 7497|       |            MermaidWorker::scale_adjustment_for_svg("<svg aria-roledescription='er'></svg>"),
 7498|       |            0.94
 7499|       |        );
 7500|       |    }
 7501|       |
 7502|       |    #[cfg(feature = "mermaid-quickjs")]
 7503|       |    #[test]
 7504|       |    fn test_enqueue_mermaid_job_disconnected() {
 7505|       |        let (job_tx, job_rx) = bounded(1);
 7506|       |        drop(job_rx);
 7507|       |        let (_result_tx, result_rx) = bounded(1);
 7508|       |        let renderer = test_renderer_with_channels(Some(job_tx), result_rx);
 7509|       |        let request = MermaidRequest {
 7510|       |            svg_key: 1,
 7511|       |            texture_key: "t".to_string(),
 7512|       |            code: Some("graph TD; A-->B;".to_string()),
 7513|       |            svg: None,
 7514|       |            width_bucket: 120,
 7515|       |            scale_bucket: 100,
 7516|       |            viewport_width: 120,
 7517|       |            viewport_height: 120,
 7518|       |            bg: None,
 7519|       |        };
 7520|       |        assert_eq!(
 7521|       |            renderer.enqueue_mermaid_job(request),
 7522|       |            Err(MermaidEnqueueError::Disconnected)
 7523|       |        );
 7524|       |    }
 7525|       |
 7526|       |    #[cfg(feature = "mermaid-quickjs")]
 7527|       |    #[test]
 7528|       |    fn test_render_block_enqueues_cached_svg() {
 7529|       |        let _lock = env_lock();
 7530|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 7531|       |        let (job_tx, job_rx) = bounded(1);
 7532|       |        let (_result_tx, result_rx) = bounded(1);
 7533|       |        let renderer = test_renderer_with_channels(Some(job_tx), result_rx);
 7534|       |        let code = "graph TD; A-->B;";
 7535|       |        let svg_key = MermaidRenderer::hash_str(code);
 7536|       |        renderer
 7537|       |            .mermaid_svg_cache
 7538|       |            .borrow_mut()
 7539|       |            .insert(svg_key, "<svg></svg>".to_string());
 7540|       |        let ctx = egui::Context::default();
 7541|       |        let input = egui::RawInput {
 7542|       |            screen_rect: Some(egui::Rect::from_min_size(
 7543|       |                egui::pos2(0.0, 0.0),
 7544|       |                egui::vec2(240.0, 120.0),
 7545|       |            )),
 7546|       |            ..Default::default()
 7547|       |        };
 7548|       |        let mut rendered = false;
 7549|       |        let _ = ctx.run(input, |ctx| {
 7550|       |            egui::CentralPanel::default().show(ctx, |ui| {
 7551|       |                rendered = renderer.render_block(ui, code, 1.0, 14.0);
 7552|       |            });
 7553|       |        });
 7554|       |        assert!(rendered);
 7555|       |        let request = job_rx
 7556|       |            .recv_timeout(std::time::Duration::from_secs(1))
 7557|       |            .expect("request");
 7558|       |        assert!(request.svg.is_some());
 7559|       |        assert!(request.code.is_none());
 7560|       |    }
 7561|       |
 7562|       |    #[cfg(feature = "mermaid-quickjs")]
 7563|       |    #[test]
 7564|       |    fn test_spawn_mermaid_workers_reports_init_error() {
 7565|       |        let _lock = env_lock();
 7566|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "1");
 7567|       |        force_mermaid_worker_init_error_once();
 7568|       |        let (job_tx, job_rx) = bounded(1);
 7569|       |        let (result_tx, result_rx) = bounded(1);
 7570|       |        let handles = MermaidRenderer::spawn_mermaid_workers(job_rx, result_tx);
 7571|       |        let request = MermaidRequest {
 7572|       |            svg_key: 2,
 7573|       |            texture_key: "t".to_string(),
 7574|       |            code: Some("graph TD; A-->B;".to_string()),
 7575|       |            svg: None,
 7576|       |            width_bucket: 120,
 7577|       |            scale_bucket: 100,
 7578|       |            viewport_width: 120,
 7579|       |            viewport_height: 120,
 7580|       |            bg: None,
 7581|       |        };
 7582|       |        job_tx.send(request).expect("send");
 7583|       |        let result = result_rx
 7584|       |            .recv_timeout(std::time::Duration::from_secs(1))
 7585|       |            .expect("result");
 7586|       |        assert!(result.error.is_some());
 7587|       |        drop(job_tx);
 7588|       |        for handle in handles {
 7589|       |            let _ = handle.join();
 7590|       |        }
 7591|       |    }
 7592|       |
 7593|       |    #[cfg(feature = "mermaid-quickjs")]
 7594|       |    #[test]
 7595|       |    fn test_spawn_mermaid_workers_reports_spawn_error() {
 7596|       |        let _lock = env_lock();
 7597|       |        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "1");
 7598|       |        force_mermaid_thread_spawn_error_once();
 7599|       |        let (_job_tx, job_rx) = bounded(1);
 7600|       |        let (result_tx, _result_rx) = bounded(1);
 7601|       |        let handles = MermaidRenderer::spawn_mermaid_workers(job_rx, result_tx);
 7602|       |        assert!(handles.is_empty());
 7603|       |    }
 7604|       |
 7605|       |    #[cfg(feature = "mermaid-quickjs")]
 7606|       |    #[test]
 7607|       |    fn test_mermaid_worker_init_error_stages() {
 7608|       |        let mut fontdb = usvg::fontdb::Database::new();
 7609|       |        fontdb.load_system_fonts();
 7610|       |        let fontdb = Arc::new(fontdb);
 7611|       |
 7612|       |        force_mermaid_init_error_once(1);
 7613|       |        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
 7614|       |            .err()
 7615|       |            .expect("stage 1 err");
 7616|       |        assert!(err.contains("Mermaid text measure init error"));
 7617|       |
 7618|       |        force_mermaid_init_error_once(2);
 7619|       |        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
 7620|       |            .err()
 7621|       |            .expect("stage 2 err");
 7622|       |        assert!(err.contains("Mermaid text measure init error"));
 7623|       |
 7624|       |        force_mermaid_init_error_once(3);
 7625|       |        let err = MermaidWorker::new(0, fontdb).err().expect("stage 3 err");
 7626|       |        assert!(err.contains("Mermaid DOM shim"));
 7627|       |
 7628|       |        let mut fontdb = usvg::fontdb::Database::new();
 7629|       |        fontdb.load_system_fonts();
 7630|       |        let fontdb = Arc::new(fontdb);
 7631|       |        force_mermaid_init_error_once(4);
 7632|       |        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
 7633|       |            .err()
 7634|       |            .expect("stage 4 err");
 7635|       |        assert!(err.contains("Mermaid JS"));
 7636|       |
 7637|       |        force_mermaid_init_error_once(5);
 7638|       |        let err = MermaidWorker::new(0, fontdb).err().expect("stage 5 err");
 7639|       |        assert!(err.contains("Mermaid init"));
 7640|       |    }
 7641|       |
 7642|       |    #[cfg(feature = "mermaid-quickjs")]
 7643|       |    #[test]
 7644|       |    fn test_mermaid_worker_new_runtime_error_forced() {
 7645|       |        let mut fontdb = usvg::fontdb::Database::new();
 7646|       |        fontdb.load_system_fonts();
 7647|       |        let fontdb = Arc::new(fontdb);
 7648|       |        force_mermaid_runtime_error_once();
 7649|       |        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
 7650|       |            .err()
 7651|       |            .expect("runtime err");
 7652|       |        assert!(err.contains("Mermaid runtime init error"));
 7653|       |    }
 7654|       |
 7655|       |    #[cfg(feature = "mermaid-quickjs")]
 7656|       |    #[test]
 7657|       |    fn test_mermaid_runtime_flag_mismatch_restores() {
 7658|       |        let handle = std::thread::spawn(|| {
 7659|       |            force_mermaid_runtime_error_once();
 7660|       |        });
 7661|       |        handle.join().expect("flag thread");
 7662|       |
 7663|       |        let _ = runtime_new_for_test().expect("runtime ok");
 7664|       |
 7665|       |        let mut guard = FORCE_MERMAID_RUNTIME_ERROR
 7666|       |            .lock()
 7667|       |            .expect("mermaid runtime flag lock");
 7668|       |        *guard = None;
 7669|       |    }
 7670|       |
 7671|       |    #[cfg(feature = "mermaid-quickjs")]
 7672|       |    #[test]
 7673|       |    fn test_mermaid_worker_new_context_error_forced() {
 7674|       |        let mut fontdb = usvg::fontdb::Database::new();
 7675|       |        fontdb.load_system_fonts();
 7676|       |        let fontdb = Arc::new(fontdb);
 7677|       |        force_mermaid_context_error_once();
 7678|       |        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
 7679|       |            .err()
 7680|       |            .expect("context err");
 7681|       |        assert!(err.contains("Mermaid context init error"));
 7682|       |    }
 7683|       |
 7684|       |    #[cfg(feature = "mermaid-quickjs")]
 7685|       |    #[test]
 7686|       |    fn test_mermaid_worker_new_utf8_error_forced() {
 7687|       |        let mut fontdb = usvg::fontdb::Database::new();
 7688|       |        fontdb.load_system_fonts();
 7689|       |        let fontdb = Arc::new(fontdb);
 7690|       |        force_mermaid_utf8_error_once();
 7691|       |        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
 7692|       |            .err()
 7693|       |            .expect("utf8 err");
 7694|       |        assert!(err.contains("Mermaid JS is not valid UTF-8"));
 7695|       |    }
 7696|       |
 7697|       |    #[cfg(feature = "mermaid-quickjs")]
 7698|       |    #[test]
 7699|       |    fn test_mermaid_render_svg_forced_eval_error() {
 7700|       |        let mut fontdb = usvg::fontdb::Database::new();
 7701|       |        fontdb.load_system_fonts();
 7702|       |        let fontdb = Arc::new(fontdb);
 7703|       |        let mut worker = MermaidWorker::new(0, Arc::clone(&fontdb)).expect("worker init");
 7704|       |        force_mermaid_render_eval_error_once();
 7705|       |        let err = worker
 7706|       |            .render_svg(1, "graph TD; A-->B;", 480, 320)
 7707|       |            .unwrap_err();
 7708|       |        assert!(!err.is_empty());
 7709|       |    }
 7710|       |
 7711|       |    #[cfg(feature = "mermaid-quickjs")]
 7712|       |    #[test]
 7713|       |    fn test_mermaid_render_svg_forced_call_error() {
 7714|       |        let mut fontdb = usvg::fontdb::Database::new();
 7715|       |        fontdb.load_system_fonts();
 7716|       |        let fontdb = Arc::new(fontdb);
 7717|       |        let mut worker = MermaidWorker::new(0, Arc::clone(&fontdb)).expect("worker init");
 7718|       |        force_mermaid_render_call_error_once();
 7719|       |        let err = worker
 7720|       |            .render_svg(2, "graph TD; A-->B;", 480, 320)
 7721|       |            .unwrap_err();
 7722|       |        assert!(!err.is_empty());
 7723|       |    }
 7724|       |
 7725|       |    #[cfg(feature = "mermaid-quickjs")]
 7726|       |    #[test]
 7727|       |    fn test_parse_raw_svg_tree_invalid_svg_returns_error() {
 7728|       |        let options = usvg::Options::default();
 7729|       |        let err = MermaidWorker::parse_raw_svg_tree("<svg", &options).unwrap_err();
 7730|       |        assert!(!err.is_empty());
 7731|       |    }
 7732|       |
 7733|       |    #[cfg(feature = "mermaid-quickjs")]
 7734|       |    #[test]
 7735|       |    fn test_rasterize_svg_forced_pixmap_alloc_error() {
 7736|       |        let mut fontdb = usvg::fontdb::Database::new();
 7737|       |        fontdb.load_system_fonts();
 7738|       |        let fontdb = Arc::new(fontdb);
 7739|       |        let worker = MermaidWorker::new(0, Arc::clone(&fontdb)).expect("worker init");
 7740|       |        force_mermaid_pixmap_alloc_fail_once();
 7741|       |        let err = worker
 7742|       |            .rasterize_svg(
 7743|       |                "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"10\" height=\"10\"><rect width=\"10\" height=\"10\"/></svg>",
 7744|       |                0,
 7745|       |                100,
 7746|       |                None,
 7747|       |            )
 7748|       |            .unwrap_err();
 7749|       |        assert!(err.contains("Pixmap alloc failed"));
 7750|       |    }
 7751|       |
 7752|       |    #[cfg(feature = "mermaid-quickjs")]
 7753|       |    #[test]
 7754|       |    fn test_svg_helper_early_returns() {
 7755|       |        assert_eq!(MermaidWorker::normalize_svg_size("<svg"), "<svg");
 7756|       |        assert_eq!(
 7757|       |            MermaidWorker::normalize_svg_size("<svg viewBox=\"bad\">"),
 7758|       |            "<svg viewBox=\"bad\">"
 7759|       |        );
 7760|       |        assert_eq!(
 7761|       |            MermaidWorker::replace_attr("<svg width=\"100", "width", "200"),
 7762|       |            "<svg width=\"100"
 7763|       |        );
 7764|       |        assert_eq!(
 7765|       |            MermaidWorker::upsert_attr("<svg width=\"100\"", "height", "200"),
 7766|       |            "<svg width=\"100\""
 7767|       |        );
 7768|       |        assert!(MermaidWorker::flatten_svg_switches("<switch").is_none());
 7769|       |        assert!(
 7770|       |            MermaidWorker::fix_journey_section_text("<text journey-section", "#fff").is_none()
 7771|       |        );
 7772|       |        assert!(MermaidWorker::fix_state_end_circles("<svg><g class=\"state-end\"").is_none());
 7773|       |        assert!(MermaidWorker::fix_state_end_circles("<svg><g class=\"state-end\"></g").is_none());
 7774|       |        assert!(MermaidWorker::fix_er_attribute_fills("<rect class=\"attributeBoxOdd\"").is_none());
 7775|       |        assert_eq!(
 7776|       |            MermaidWorker::replace_svg_attr("<svg>", "width", "1"),
 7777|       |            "<svg>"
 7778|       |        );
 7779|       |        assert_eq!(
 7780|       |            MermaidWorker::replace_svg_attr("<svg width=\"100>", "width", "1"),
 7781|       |            "<svg width=\"100>"
 7782|       |        );
 7783|       |        assert_eq!(
 7784|       |            MermaidWorker::insert_svg_attr("no svg", "width", "1"),
 7785|       |            "no svg"
 7786|       |        );
 7787|       |    }
 7788|       |}

C:\language\mdmdview\src\table_support\column_spec.rs:
    1|       |use std::cmp::max;
    2|       |use std::hash::{Hash, Hasher};
    3|       |
    4|       |use egui_extras::Column;
    5|       |use unicode_segmentation::UnicodeSegmentation;
    6|       |use unicode_width::UnicodeWidthStr;
    7|       |
    8|       |use crate::markdown_renderer::InlineSpan;
    9|       |
   10|       |const MAX_REMAINDER_COLUMNS: usize = 2;
   11|       |
   12|    135|fn normalize_body_font_px(body: f32) -> f32 {
   13|    135|    if body.is_finite() && body > 4.0 {
                                         ^134
   14|    132|        body
   15|       |    } else {
   16|      3|        14.0
   17|       |    }
   18|    135|}
   19|       |
   20|    131|fn px(body_px: f32, factor: f32) -> f32 {
   21|    131|    normalize_body_font_px(body_px) * factor
   22|    131|}
   23|       |
   24|       |#[derive(Debug, Clone, PartialEq)]
   25|       |pub enum ColumnPolicy {
   26|       |    Auto,
   27|       |    Fixed {
   28|       |        width: f32,
   29|       |        clip: bool,
   30|       |    },
   31|       |    Remainder {
   32|       |        clip: bool,
   33|       |    },
   34|       |    Resizable {
   35|       |        min: f32,
   36|       |        preferred: f32,
   37|       |        clip: bool,
   38|       |    },
   39|       |}
   40|       |
   41|       |impl ColumnPolicy {
   42|     26|    pub fn to_column(&self) -> Column {
   43|     26|        match self {
   44|      2|            ColumnPolicy::Auto => Column::auto(),
   45|      7|            ColumnPolicy::Fixed { width, clip } => {
   46|      7|                let mut col = Column::exact(*width);
   47|      7|                if *clip {
   48|      6|                    col = col.clip(true);
   49|      6|                }
                              ^1
   50|      7|                col
   51|       |            }
   52|      6|            ColumnPolicy::Remainder { clip } => {
   53|      6|                let mut col = Column::remainder();
   54|      6|                if *clip {
   55|      1|                    col = col.clip(true);
   56|      5|                }
   57|      6|                col
   58|       |            }
   59|       |            ColumnPolicy::Resizable {
   60|     11|                min,
   61|     11|                preferred,
   62|     11|                clip,
   63|       |            } => {
   64|     11|                let mut col = Column::initial(*preferred).at_least(*min).resizable(true);
   65|     11|                if *clip {
   66|      2|                    col = col.clip(true);
   67|      9|                }
   68|     11|                col
   69|       |            }
   70|       |        }
   71|     26|    }
   72|       |}
   73|       |
   74|       |impl Hash for ColumnPolicy {
   75|      4|    fn hash<H: Hasher>(&self, state: &mut H) {
   76|      4|        std::mem::discriminant(self).hash(state);
   77|      4|        match self {
   78|      1|            ColumnPolicy::Auto => {}
   79|      1|            ColumnPolicy::Fixed { width, clip } => {
   80|      1|                width.to_bits().hash(state);
   81|      1|                clip.hash(state);
   82|      1|            }
   83|      1|            ColumnPolicy::Remainder { clip } => {
   84|      1|                clip.hash(state);
   85|      1|            }
   86|       |            ColumnPolicy::Resizable {
   87|      1|                min,
   88|      1|                preferred,
   89|      1|                clip,
   90|      1|            } => {
   91|      1|                min.to_bits().hash(state);
   92|      1|                preferred.to_bits().hash(state);
   93|      1|                clip.hash(state);
   94|      1|            }
   95|       |        }
   96|      4|    }
   97|       |}
   98|       |
   99|       |#[derive(Debug, Clone)]
  100|       |pub struct ColumnSpec {
  101|       |    pub index: usize,
  102|       |    pub ident: String,
  103|       |    pub policy: ColumnPolicy,
  104|       |    pub tooltip: Option<String>,
  105|       |    pub policy_hash: u64,
  106|       |}
  107|       |
  108|       |impl ColumnSpec {
  109|    106|    pub fn new(
  110|    106|        index: usize,
  111|    106|        ident: impl Into<String>,
  112|    106|        policy: ColumnPolicy,
  113|    106|        tooltip: Option<String>,
  114|    106|    ) -> Self {
  115|    106|        let ident = ident.into();
  116|    106|        let policy_hash = calculate_policy_hash(index, &ident, &policy);
  117|    106|        Self {
  118|    106|            index,
  119|    106|            ident,
  120|    106|            policy,
  121|    106|            tooltip,
  122|    106|            policy_hash,
  123|    106|        }
  124|    106|    }
  125|       |
  126|     18|    pub fn as_column(&self) -> Column {
  127|     18|        self.policy.to_column()
  128|     18|    }
  129|       |
  130|     34|    pub fn set_policy(&mut self, policy: ColumnPolicy) {
  131|     34|        self.policy = policy;
  132|     34|        self.policy_hash = calculate_policy_hash(self.index, &self.ident, &self.policy);
  133|     34|    }
  134|       |
  135|      5|    pub fn apply_preferred_width(&mut self, width: f32) {
  136|       |        if let ColumnPolicy::Resizable {
  137|      4|            min,
  138|      4|            ref mut preferred,
  139|       |            ..
  140|      5|        } = self.policy
  141|      4|        {
  142|      4|            let clamped = width.max(min);
  143|      4|            *preferred = clamped;
  144|      4|            self.policy_hash = calculate_policy_hash(self.index, &self.ident, &self.policy);
  145|      4|        }
                      ^1
  146|      5|    }
  147|       |}
  148|       |
  149|       |#[derive(Debug, Clone, Copy, Default)]
  150|       |pub struct RichContentFlags {
  151|       |    pub has_link: bool,
  152|       |    pub has_image: bool,
  153|       |    pub has_emoji_like: bool,
  154|       |}
  155|       |
  156|       |#[derive(Debug, Clone, Default)]
  157|       |pub struct ColumnStat {
  158|       |    pub max_graphemes: usize,
  159|       |    pub longest_word: usize,
  160|       |    pub rich_content: RichContentFlags,
  161|       |}
  162|       |
  163|       |pub struct TableColumnContext<'a> {
  164|       |    pub headers: &'a [Vec<InlineSpan>],
  165|       |    pub rows: &'a [Vec<Vec<InlineSpan>>],
  166|       |    pub stats: &'a [ColumnStat],
  167|       |    pub body_font_px: f32,
  168|       |    pub table_id: u64,
  169|       |}
  170|       |
  171|       |impl<'a> TableColumnContext<'a> {
  172|     33|    pub fn new(
  173|     33|        headers: &'a [Vec<InlineSpan>],
  174|     33|        rows: &'a [Vec<Vec<InlineSpan>>],
  175|     33|        stats: &'a [ColumnStat],
  176|     33|        body_font_px: f32,
  177|     33|        table_id: u64,
  178|     33|    ) -> Self {
  179|     33|        Self {
  180|     33|            headers,
  181|     33|            rows,
  182|     33|            stats,
  183|     33|            body_font_px,
  184|     33|            table_id,
  185|     33|        }
  186|     33|    }
  187|       |
  188|    110|    pub fn column_stat(&self, idx: usize) -> Option<&ColumnStat> {
  189|    110|        self.stats.get(idx)
  190|    110|    }
  191|       |}
  192|       |
  193|    144|fn calculate_policy_hash(index: usize, ident: &str, policy: &ColumnPolicy) -> u64 {
  194|    144|    let mut hasher = std::collections::hash_map::DefaultHasher::new();
  195|    144|    index.hash(&mut hasher);
  196|    144|    ident.hash(&mut hasher);
  197|    144|    std::mem::discriminant(policy).hash(&mut hasher);
  198|    144|    match policy {
  199|      5|        ColumnPolicy::Auto => {}
  200|     35|        ColumnPolicy::Fixed { width, clip } => {
  201|     35|            width.to_bits().hash(&mut hasher);
  202|     35|            clip.hash(&mut hasher);
  203|     35|        }
  204|     33|        ColumnPolicy::Remainder { clip } => {
  205|     33|            clip.hash(&mut hasher);
  206|     33|        }
  207|     71|        ColumnPolicy::Resizable { min, clip, .. } => {
  208|     71|            min.to_bits().hash(&mut hasher);
  209|     71|            clip.hash(&mut hasher);
  210|     71|        }
  211|       |    }
  212|    144|    hasher.finish()
  213|    144|}
  214|       |
  215|     33|pub fn derive_column_specs(ctx: &TableColumnContext) -> Vec<ColumnSpec> {
  216|     33|    let mut remainder_assigned = 0usize;
  217|     33|    let mut fallback_idx: Option<usize> = None;
  218|     33|    let mut fallback_score: usize = 0;
  219|     33|    let column_count = ctx
  220|     33|        .stats
  221|     33|        .len()
  222|     33|        .max(ctx.headers.len())
  223|     34|        .max(ctx.rows.iter().map(|r| r.len()).max().unwrap_or(0));
                       ^33 ^33      ^33    ^33              ^33   ^33
  224|       |
  225|     33|    let mut scored_indices: Vec<(usize, usize)> = Vec::with_capacity(column_count);
  226|       |
  227|     33|    let mut specs: Vec<ColumnSpec> = (0..column_count)
  228|     85|        .map(|idx| {
                       ^33
  229|     85|            let spans = ctx.headers.get(idx).map(|v| v.as_slice()).unwrap_or(&[]);
                                                                   ^82^82
  230|     85|            let label = header_text(spans);
  231|     85|            let stat = ctx.column_stat(idx);
  232|       |
  233|     85|            let candidate_score = stat
  234|     85|                .map(|s| {
                                       ^80
  235|     80|                    let mut score = s.max_graphemes + s.longest_word * 2;
  236|     80|                    if s.rich_content.has_image {
  237|      2|                        score += 50;
  238|     78|                    }
  239|     80|                    if s.rich_content.has_link {
  240|      4|                        score += 25;
  241|     76|                    }
  242|     80|                    score
  243|     80|                })
  244|     85|                .unwrap_or_else(|| label.len());
                                                 ^5    ^5
  245|     85|            if candidate_score > fallback_score {
  246|     48|                fallback_score = candidate_score;
  247|     48|                fallback_idx = Some(idx);
  248|     48|            }
                          ^37
  249|     85|            scored_indices.push((idx, candidate_score));
  250|       |
  251|     85|            let policy =
  252|     85|                classify_column(&label, idx, &mut remainder_assigned, stat, ctx.body_font_px);
  253|     85|            let tooltip = column_tooltip(&label, &policy);
  254|     85|            ColumnSpec::new(idx, label, policy, tooltip)
  255|     85|        })
  256|     33|        .collect();
  257|       |
  258|       |    // Ensure at least one remainder if none assigned and available
  259|     33|    if remainder_assigned == 0 {
  260|     24|        let mut candidate = fallback_idx;
  261|     24|        if let Some(idx) = candidate {
                                  ^23
  262|     23|            if matches!(specs[idx].policy, ColumnPolicy::Fixed { .. }) {
                             ^6
  263|     17|                candidate = None;
  264|     17|            }
                          ^6
  265|      1|        }
  266|     24|        let has_non_fixed_other = specs
  267|     24|            .iter()
  268|     24|            .enumerate()
  269|     43|            .any(|(idx, spec)| idx != 0 && !matches!(spec.policy, ColumnPolicy::Fixed { .. }));
                           ^24                            ^17      ^20
  270|     24|        if has_non_fixed_other && (candidate.is_none() || candidate == Some(0)) {
                                                 ^17       ^17          ^6
  271|     14|            candidate = scored_indices
  272|     14|                .iter()
  273|     43|                .filter(|(idx, _)| *idx != 0)
                               ^14
  274|     29|                .filter(|(idx, _)| !matches!(specs[*idx].policy, ColumnPolicy::Fixed { .. }))
                               ^14
  275|     14|                .max_by_key(|(_, score)| *score)
  276|     14|                .map(|(idx, _)| *idx);
  277|     10|        }
  278|     24|        if candidate.is_none() {
  279|      8|            for (idx, spec) in specs.iter().enumerate() {
                                             ^7           ^7
  280|      8|                if !matches!(spec.policy, ColumnPolicy::Fixed { .. }) {
                                  ^1
  281|      1|                    candidate = Some(idx);
  282|      1|                    break;
  283|      7|                }
  284|       |            }
  285|     17|        }
  286|     24|        if let Some(idx) = candidate {
                                  ^18
  287|     18|            let spec = &mut specs[idx];
  288|     18|            spec.set_policy(ColumnPolicy::Remainder { clip: false });
  289|     18|            remainder_assigned += 1;
  290|     18|        }
                      ^6
  291|      9|    }
  292|       |
  293|       |    // Promote additional wide columns to remainder up to the cap
  294|     73|    scored_indices.sort_by(|a, b| b.1.cmp(&a.1));
                  ^33            ^33
  295|    107|    for (idx, _) in scored_indices {
                       ^77
  296|     77|        if remainder_assigned >= MAX_REMAINDER_COLUMNS {
  297|      3|            break;
  298|     74|        }
  299|     74|        let spec = &mut specs[idx];
  300|     74|        if matches!(spec.policy, ColumnPolicy::Resizable { .. })
                         ^49
  301|     25|            && column_needs_remainder(ctx.column_stat(idx))
  302|      1|        {
  303|      1|            spec.set_policy(ColumnPolicy::Remainder { clip: false });
  304|      1|            remainder_assigned += 1;
  305|     73|        }
  306|       |    }
  307|       |
  308|     33|    specs
  309|     33|}
  310|       |
  311|     91|fn header_text(spans: &[InlineSpan]) -> String {
  312|     91|    let mut text = String::new();
  313|    183|    for span in spans {
                      ^92
  314|     92|        match span {
  315|     84|            InlineSpan::Text(t)
  316|      1|            | InlineSpan::Strong(t)
  317|      1|            | InlineSpan::Emphasis(t)
  318|      1|            | InlineSpan::Strikethrough(t)
  319|      1|            | InlineSpan::Code(t) => {
  320|     88|                if !text.is_empty() {
  321|      4|                    text.push(' ');
  322|     84|                }
  323|     88|                text.push_str(t.trim());
  324|       |            }
  325|      2|            InlineSpan::Link { text: t, .. } => {
  326|      2|                if !text.is_empty() {
  327|      1|                    text.push(' ');
  328|      1|                }
  329|      2|                text.push_str(t.trim());
  330|       |            }
  331|      2|            InlineSpan::Image { alt, .. } => {
  332|      2|                if !text.is_empty() {
  333|      1|                    text.push(' ');
  334|      1|                }
  335|      2|                text.push_str(alt.trim());
  336|       |            }
  337|       |        }
  338|       |    }
  339|     91|    if text.trim().is_empty() {
  340|      6|        "Column".to_string()
  341|       |    } else {
  342|     85|        text.trim().to_string()
  343|       |    }
  344|     91|}
  345|       |
  346|     90|fn classify_column(
  347|     90|    label: &str,
  348|     90|    index: usize,
  349|     90|    remainder_assigned: &mut usize,
  350|     90|    stat: Option<&ColumnStat>,
  351|     90|    body_font_px: f32,
  352|     90|) -> ColumnPolicy {
  353|     90|    let lower = label.to_ascii_lowercase();
  354|     90|    if matches_any(&lower, &["version", "rev", "#", "id"]) {
  355|      6|        return ColumnPolicy::Fixed {
  356|      6|            width: px(body_font_px, 5.8).clamp(80.0, 160.0),
  357|      6|            clip: true,
  358|      6|        };
  359|     84|    }
  360|     84|    if matches_any(&lower, &["date", "time", "timestamp"]) {
  361|      1|        return ColumnPolicy::Fixed {
  362|      1|            width: px(body_font_px, 8.5).clamp(110.0, 200.0),
  363|      1|            clip: false,
  364|      1|        };
  365|     83|    }
  366|     83|    if matches_any(&lower, &["author", "owner", "assignee", "user"]) {
  367|      4|        return ColumnPolicy::Resizable {
  368|      4|            min: px(body_font_px, 7.5),
  369|      4|            preferred: px(body_font_px, 10.0),
  370|      4|            clip: false,
  371|      4|        };
  372|     79|    }
  373|     79|    if matches_any(&lower, &["status", "state"]) {
  374|      3|        return ColumnPolicy::Fixed {
  375|      3|            width: px(body_font_px, 7.0).clamp(90.0, 180.0),
  376|      3|            clip: true,
  377|      3|        };
  378|     76|    }
  379|     76|    if matches_any(
  380|     76|        &lower,
  381|     76|        &["notes", "changes", "description", "details", "summary"],
  382|       |    ) {
  383|     15|        return ColumnPolicy::Resizable {
  384|     15|            min: px(body_font_px, 10.5),
  385|     15|            preferred: px(body_font_px, 14.5),
  386|     15|            clip: false,
  387|     15|        };
  388|     61|    }
  389|     61|    if matches_any(
  390|     61|        &lower,
  391|     61|        &["example", "examples", "sample", "use case", "use cases"],
  392|       |    ) {
  393|      6|        *remainder_assigned += 1;
  394|      6|        return ColumnPolicy::Remainder { clip: false };
  395|     55|    }
  396|     55|    if index == 0 {
  397|       |        // First column typically identifiers; keep fixed only for short labels.
  398|     22|        if stat
  399|     22|            .map(|s| s.max_graphemes <= 18 && s.longest_word <= 12)
                                   ^20                      ^17
  400|     22|            .unwrap_or_else(|| label.len() <= 12)
                                             ^2    ^2
  401|       |        {
  402|     18|            return ColumnPolicy::Fixed {
  403|     18|                width: px(body_font_px, 7.0).clamp(80.0, 180.0),
  404|     18|                clip: true,
  405|     18|            };
  406|      4|        }
  407|     33|    }
  408|     37|    if *remainder_assigned < MAX_REMAINDER_COLUMNS && column_needs_remainder(stat) {
                                                                    ^36                    ^36
  409|      5|        *remainder_assigned += 1;
  410|      5|        return ColumnPolicy::Remainder { clip: false };
  411|     32|    }
  412|     32|    ColumnPolicy::Resizable {
  413|     32|        min: px(body_font_px, 7.0),
  414|     32|        preferred: px(body_font_px, 9.5),
  415|     32|        clip: false,
  416|     32|    }
  417|     90|}
  418|       |
  419|     64|fn column_needs_remainder(stat: Option<&ColumnStat>) -> bool {
  420|     64|    if let Some(stat) = stat {
                              ^63
  421|     63|        stat.rich_content.has_image
  422|     62|            || stat.longest_word > 18
  423|     61|            || stat.max_graphemes > 60
  424|     59|            || stat.rich_content.has_link
  425|       |    } else {
  426|      1|        false
  427|       |    }
  428|     64|}
  429|       |
  430|    473|fn matches_any(label: &str, needles: &[&str]) -> bool {
  431|  1.69k|    needles.iter().any(|needle| label.contains(needle))
                  ^473           ^473
  432|    473|}
  433|       |
  434|     91|fn column_tooltip(label: &str, policy: &ColumnPolicy) -> Option<String> {
  435|     91|    let description = match policy {
  436|      1|        ColumnPolicy::Auto => "Auto-sized column".to_string(),
  437|     28|        ColumnPolicy::Fixed { width, clip } => format!(
  438|     28|            "Fixed width {:.0}px{}",
  439|       |            width,
  440|     28|            if *clip { " (clipped)" } else { "" }
                                     ^27                   ^1
  441|       |        ),
  442|     13|        ColumnPolicy::Remainder { clip } => format!(
  443|     13|            "Shared remainder width{}",
  444|     13|            if *clip { " (clipped)" } else { "" }
                                     ^1                    ^12
  445|       |        ),
  446|       |        ColumnPolicy::Resizable {
  447|     49|            min,
  448|     49|            preferred,
  449|     49|            clip,
  450|     49|        } => format!(
  451|     49|            "Resizable (min {:.0}px, start {:.0}px{})",
  452|       |            min,
  453|       |            preferred,
  454|     49|            if *clip { ", clipped" } else { "" }
                                     ^1                   ^48
  455|       |        ),
  456|       |    };
  457|     91|    Some(format!("{label}: {description}"))
  458|     91|}
  459|       |
  460|     30|pub fn compute_column_stats(
  461|     30|    headers: &[Vec<InlineSpan>],
  462|     30|    rows: &[Vec<Vec<InlineSpan>>],
  463|     30|    max_samples: usize,
  464|     30|) -> Vec<ColumnStat> {
  465|     30|    let column_count = max(
  466|     30|        headers.len(),
  467|     34|        rows.iter().map(|row| row.len()).max().unwrap_or(0),
                      ^30  ^30    ^30                  ^30   ^30
  468|       |    );
  469|     30|    if column_count == 0 {
  470|      1|        return Vec::new();
  471|     29|    }
  472|       |
  473|     29|    let mut stats = vec![ColumnStat::default(); column_count];
  474|       |
  475|     70|    for (idx, header) in headers.iter().enumerate() {
                                       ^29     ^29    ^29
  476|     70|        accumulate_stats_for_cell(header, &mut stats[idx]);
  477|     70|    }
  478|       |
  479|     29|    let mut sampled_rows = 0;
  480|     33|    for row in rows.iter() {
                             ^29  ^29
  481|     82|        for (idx, cell) in row.iter().enumerate().take(column_count) {
                                         ^33        ^33         ^33  ^33
  482|     82|            accumulate_stats_for_cell(cell, &mut stats[idx]);
  483|     82|        }
  484|     33|        sampled_rows += 1;
  485|     33|        if sampled_rows >= max_samples {
  486|      1|            break;
  487|     32|        }
  488|       |    }
  489|       |
  490|     29|    stats
  491|     30|}
  492|       |
  493|    157|fn accumulate_stats_for_cell(spans: &[InlineSpan], stat: &mut ColumnStat) {
  494|    157|    if stat.rich_content.has_image {
  495|      1|        // rich-content flags persist; skip repeated scans for pure images.
  496|    156|    }
  497|    157|    let mut has_link = stat.rich_content.has_link;
  498|    157|    let mut has_image = stat.rich_content.has_image;
  499|    157|    let mut has_emoji_like = stat.rich_content.has_emoji_like;
  500|       |
  501|    328|    for span in spans {
                      ^171
  502|    171|        match span {
  503|      3|            InlineSpan::Link { .. } => has_link = true,
  504|      2|            InlineSpan::Image { .. } => has_image = true,
  505|    166|            _ => {}
  506|       |        }
  507|       |    }
  508|       |
  509|    157|    let text = spans_to_text(spans);
  510|    157|    if !text.is_empty() {
  511|    156|        let graphemes = text.graphemes(true).count();
  512|    156|        let display_width = UnicodeWidthStr::width(text.as_str());
  513|    156|        stat.max_graphemes = stat.max_graphemes.max(display_width.max(graphemes));
  514|       |
  515|    234|        for word in text.split_whitespace() {
                                  ^156 ^156
  516|    234|            let word_len = UnicodeWidthStr::width(word).max(word.graphemes(true).count());
  517|    234|            stat.longest_word = stat.longest_word.max(word_len);
  518|    234|        }
  519|       |
  520|    156|        if !has_emoji_like {
  521|  1.15k|            has_emoji_like = text.chars().any(|c| matches!(c as u32, 0x1F300..=0x1FAFF));
                                           ^155         ^155                       ^2
  522|      1|        }
  523|      1|    }
  524|       |
  525|    157|    stat.rich_content = RichContentFlags {
  526|    157|        has_link,
  527|    157|        has_image,
  528|    157|        has_emoji_like,
  529|    157|    };
  530|    157|}
  531|       |
  532|    158|fn spans_to_text(spans: &[InlineSpan]) -> String {
  533|    158|    let mut text = String::new();
  534|    336|    for span in spans {
                      ^178
  535|    178|        match span {
  536|    164|            InlineSpan::Text(t)
  537|      1|            | InlineSpan::Code(t)
  538|      4|            | InlineSpan::Strong(t)
  539|      1|            | InlineSpan::Emphasis(t)
  540|      1|            | InlineSpan::Strikethrough(t) => {
  541|    171|                if !text.is_empty() {
  542|     19|                    text.push(' ');
  543|    152|                }
  544|    171|                text.push_str(t);
  545|       |            }
  546|      4|            InlineSpan::Link { text: t, .. } => {
  547|      4|                if !text.is_empty() {
  548|      1|                    text.push(' ');
  549|      3|                }
  550|      4|                text.push_str(t);
  551|       |            }
  552|      3|            InlineSpan::Image { alt, .. } => {
  553|      3|                if !text.is_empty() {
  554|      1|                    text.push(' ');
  555|      2|                }
  556|      3|                text.push_str(alt);
  557|       |            }
  558|       |        }
  559|       |    }
  560|    158|    text.trim().to_string()
  561|    158|}
  562|       |
  563|       |#[cfg(test)]
  564|       |#[cfg_attr(coverage_nightly, coverage(off))]
  565|       |mod tests {
  566|       |    use super::*;
  567|       |
  568|       |    fn span(text: &str) -> InlineSpan {
  569|       |        InlineSpan::Text(text.to_string())
  570|       |    }
  571|       |
  572|       |    #[test]
  573|       |    fn classify_version_column() {
  574|       |        let headers = vec![vec![span("Version")], vec![span("Changes")]];
  575|       |        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  576|       |        let stats = compute_column_stats(&headers, &rows, 32);
  577|       |        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  578|       |        let specs = derive_column_specs(&ctx);
  579|       |        assert!(matches!(specs[0].policy, ColumnPolicy::Fixed { .. }));
  580|       |        assert!(matches!(specs[1].policy, ColumnPolicy::Remainder { .. }));
  581|       |    }
  582|       |
  583|       |    #[test]
  584|       |    fn classify_author_column() {
  585|       |        let headers = vec![vec![span("Author")], vec![span("Examples")]];
  586|       |        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  587|       |        let stats = compute_column_stats(&headers, &rows, 32);
  588|       |        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  589|       |        let specs = derive_column_specs(&ctx);
  590|       |        assert!(matches!(specs[0].policy, ColumnPolicy::Resizable { .. }));
  591|       |        assert!(matches!(specs[1].policy, ColumnPolicy::Remainder { .. }));
  592|       |    }
  593|       |
  594|       |    #[test]
  595|       |    fn classify_examples_column() {
  596|       |        let headers = vec![
  597|       |            vec![span("Element")],
  598|       |            vec![span("Symbol")],
  599|       |            vec![span("Description")],
  600|       |            vec![span("Examples")],
  601|       |        ];
  602|       |        assert_eq!(header_text(&headers[3]), "Examples");
  603|       |        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  604|       |        let stats = compute_column_stats(&headers, &rows, 32);
  605|       |        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  606|       |        let specs = derive_column_specs(&ctx);
  607|       |        assert!(matches!(specs[3].policy, ColumnPolicy::Remainder { .. }));
  608|       |        assert!(matches!(specs[2].policy, ColumnPolicy::Resizable { .. }));
  609|       |    }
  610|       |
  611|       |    #[test]
  612|       |    fn compute_stats_counts_text() {
  613|       |        let headers = vec![vec![span("Head")]];
  614|       |        let rows = vec![vec![vec![span("Emoji  test")]]];
  615|       |        let stats = compute_column_stats(&headers, &rows, 32);
  616|       |        assert_eq!(stats.len(), 1);
  617|       |        assert!(stats[0].max_graphemes >= 4);
  618|       |        assert!(stats[0].longest_word >= 5);
  619|       |        assert!(stats[0].rich_content.has_emoji_like);
  620|       |    }
  621|       |
  622|       |    #[test]
  623|       |    fn fallback_assigns_remainder_based_on_stats() {
  624|       |        let headers = vec![vec![span("Foo")], vec![span("Bar")]];
  625|       |        let rows = vec![vec![
  626|       |            vec![span("Short")],
  627|       |            vec![span(
  628|       |                "This column contains a very long sentence that should force remainder selection.",
  629|       |            )],
  630|       |        ]];
  631|       |        let stats = compute_column_stats(&headers, &rows, 32);
  632|       |        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  633|       |        let specs = derive_column_specs(&ctx);
  634|       |        assert!(matches!(specs[1].policy, ColumnPolicy::Remainder { .. }));
  635|       |    }
  636|       |
  637|       |    #[test]
  638|       |    fn fallback_avoids_first_column_when_possible() {
  639|       |        let headers = vec![
  640|       |            vec![span("Center")],
  641|       |            vec![span("Left")],
  642|       |            vec![span("Right")],
  643|       |        ];
  644|       |        let rows = vec![vec![
  645|       |            vec![span("Centered label with enough words to raise score")],
  646|       |            vec![span("L1")],
  647|       |            vec![span("R1")],
  648|       |        ]];
  649|       |        let stats = compute_column_stats(&headers, &rows, 32);
  650|       |        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  651|       |        let specs = derive_column_specs(&ctx);
  652|       |        assert!(!matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
  653|       |        assert!(specs[1..]
  654|       |            .iter()
  655|       |            .any(|spec| matches!(spec.policy, ColumnPolicy::Remainder { .. })));
  656|       |    }
  657|       |
  658|       |    #[test]
  659|       |    fn derive_column_specs_handles_missing_stats_with_fixed_columns() {
  660|       |        let headers = vec![vec![span("Alpha")], vec![span("Status")]];
  661|       |        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  662|       |        let stats: Vec<ColumnStat> = Vec::new();
  663|       |        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  664|       |        let specs = derive_column_specs(&ctx);
  665|       |        assert_eq!(specs.len(), 2);
  666|       |        assert!(matches!(specs[0].policy, ColumnPolicy::Fixed { .. }));
  667|       |        assert!(matches!(specs[1].policy, ColumnPolicy::Fixed { .. }));
  668|       |    }
  669|       |
  670|       |    #[test]
  671|       |    fn derive_column_specs_empty_header_label_uses_fixed_policy() {
  672|       |        let headers = vec![Vec::new()];
  673|       |        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  674|       |        let stats: Vec<ColumnStat> = Vec::new();
  675|       |        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  676|       |        let specs = derive_column_specs(&ctx);
  677|       |        assert_eq!(specs.len(), 1);
  678|       |        assert!(matches!(specs[0].policy, ColumnPolicy::Fixed { .. }));
  679|       |    }
  680|       |
  681|       |    #[test]
  682|       |    fn derive_column_specs_picks_first_non_fixed_when_best_is_fixed() {
  683|       |        let headers = vec![vec![span("Notes")], vec![span("Status")]];
  684|       |        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  685|       |        let stats: Vec<ColumnStat> = Vec::new();
  686|       |        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  687|       |        let specs = derive_column_specs(&ctx);
  688|       |        assert!(matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
  689|       |    }
  690|       |
  691|       |    #[test]
  692|       |    fn fallback_skips_fixed_candidate_for_remainder() {
  693|       |        let headers = vec![
  694|       |            vec![span("Version")],
  695|       |            vec![span("Notes")],
  696|       |            vec![span("Owner")],
  697|       |        ];
  698|       |        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  699|       |        let stats = vec![
  700|       |            ColumnStat {
  701|       |                max_graphemes: 50,
  702|       |                longest_word: 10,
  703|       |                rich_content: RichContentFlags {
  704|       |                    has_link: false,
  705|       |                    has_image: false,
  706|       |                    has_emoji_like: false,
  707|       |                },
  708|       |            },
  709|       |            ColumnStat {
  710|       |                max_graphemes: 5,
  711|       |                longest_word: 5,
  712|       |                rich_content: RichContentFlags {
  713|       |                    has_link: false,
  714|       |                    has_image: false,
  715|       |                    has_emoji_like: false,
  716|       |                },
  717|       |            },
  718|       |            ColumnStat {
  719|       |                max_graphemes: 4,
  720|       |                longest_word: 4,
  721|       |                rich_content: RichContentFlags {
  722|       |                    has_link: false,
  723|       |                    has_image: false,
  724|       |                    has_emoji_like: false,
  725|       |                },
  726|       |            },
  727|       |        ];
  728|       |        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  729|       |        let specs = derive_column_specs(&ctx);
  730|       |        assert!(matches!(specs[0].policy, ColumnPolicy::Fixed { .. }));
  731|       |        assert!(specs[1..]
  732|       |            .iter()
  733|       |            .any(|spec| matches!(spec.policy, ColumnPolicy::Remainder { .. })));
  734|       |    }
  735|       |
  736|       |    #[test]
  737|       |    fn examples_header_prefers_remainder() {
  738|       |        let headers = vec![vec![span("Examples")], vec![span("Description")]];
  739|       |        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  740|       |        let stats = compute_column_stats(&headers, &rows, 32);
  741|       |        let ctx = TableColumnContext::new(&headers, &rows, &stats, 16.0, 0);
  742|       |        let specs = derive_column_specs(&ctx);
  743|       |        assert!(matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
  744|       |        assert!(matches!(specs[1].policy, ColumnPolicy::Resizable { .. }));
  745|       |    }
  746|       |
  747|       |    #[test]
  748|       |    fn multiple_remainder_columns_allowed() {
  749|       |        let headers = vec![
  750|       |            vec![span("Summary")],
  751|       |            vec![span("Details")],
  752|       |            vec![span("Examples")],
  753|       |        ];
  754|       |        let rows = vec![vec![
  755|       |            vec![span("short")],
  756|       |            vec![span(
  757|       |                "Long content that should trigger a remainder column due to its width and words.",
  758|       |            )],
  759|       |            vec![span(
  760|       |                "Another large column with links https://example.com and more text.",
  761|       |            )],
  762|       |        ]];
  763|       |        let stats = compute_column_stats(&headers, &rows, 32);
  764|       |        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  765|       |        let specs = derive_column_specs(&ctx);
  766|       |        let remainder_count = specs
  767|       |            .iter()
  768|       |            .filter(|s| matches!(s.policy, ColumnPolicy::Remainder { .. }))
  769|       |            .count();
  770|       |        assert!(remainder_count >= 2);
  771|       |    }
  772|       |
  773|       |    #[test]
  774|       |    fn cjk_widths_increase_stat_estimates() {
  775|       |        let headers = vec![vec![span("")], vec![span("Column")]];
  776|       |        let rows = vec![vec![vec![span("")], vec![span("short")]]];
  777|       |        let stats = compute_column_stats(&headers, &rows, 32);
  778|       |        assert!(stats[0].max_graphemes > stats[1].max_graphemes);
  779|       |    }
  780|       |
  781|       |    #[test]
  782|       |    fn test_header_text_and_spans_to_text_variants() {
  783|       |        let spans = vec![
  784|       |            InlineSpan::Text(" Alpha ".to_string()),
  785|       |            InlineSpan::Strong("Beta".to_string()),
  786|       |            InlineSpan::Emphasis("Gamma".to_string()),
  787|       |            InlineSpan::Strikethrough("Delta".to_string()),
  788|       |            InlineSpan::Code("Epsilon".to_string()),
  789|       |            InlineSpan::Link {
  790|       |                text: "Zeta".to_string(),
  791|       |                url: "https://example.invalid".to_string(),
  792|       |            },
  793|       |            InlineSpan::Image {
  794|       |                src: "img.png".to_string(),
  795|       |                alt: "Eta".to_string(),
  796|       |                title: None,
  797|       |            },
  798|       |        ];
  799|       |
  800|       |        let header = header_text(&spans);
  801|       |        assert!(header.contains("Alpha"));
  802|       |        assert!(header.contains("Beta"));
  803|       |        assert!(header.contains("Zeta"));
  804|       |        assert!(header.contains("Eta"));
  805|       |
  806|       |        let text = spans_to_text(&spans);
  807|       |        assert!(text.contains("Alpha"));
  808|       |        assert!(text.contains("Zeta"));
  809|       |        assert!(text.contains("Eta"));
  810|       |
  811|       |        assert_eq!(header_text(&[]), "Column");
  812|       |        assert_eq!(
  813|       |            header_text(&[InlineSpan::Text("   ".to_string())]),
  814|       |            "Column"
  815|       |        );
  816|       |    }
  817|       |
  818|       |    #[test]
  819|       |    fn test_column_policy_to_column_and_tooltip() {
  820|       |        let policies = vec![
  821|       |            ColumnPolicy::Auto,
  822|       |            ColumnPolicy::Fixed {
  823|       |                width: 120.0,
  824|       |                clip: true,
  825|       |            },
  826|       |            ColumnPolicy::Remainder { clip: false },
  827|       |            ColumnPolicy::Resizable {
  828|       |                min: 50.0,
  829|       |                preferred: 140.0,
  830|       |                clip: true,
  831|       |            },
  832|       |        ];
  833|       |
  834|       |        for policy in policies {
  835|       |            let _col = policy.to_column();
  836|       |            let tooltip = column_tooltip("Header", &policy).expect("tooltip");
  837|       |            assert!(tooltip.contains("Header"));
  838|       |        }
  839|       |    }
  840|       |
  841|       |    #[test]
  842|       |    fn test_apply_preferred_width_clamps_and_hash_stable_for_resizable() {
  843|       |        let mut spec = ColumnSpec::new(
  844|       |            0,
  845|       |            "body",
  846|       |            ColumnPolicy::Resizable {
  847|       |                min: 50.0,
  848|       |                preferred: 120.0,
  849|       |                clip: false,
  850|       |            },
  851|       |            None,
  852|       |        );
  853|       |        let original_hash = spec.policy_hash;
  854|       |        spec.apply_preferred_width(10.0);
  855|       |        assert!(matches!(spec.policy, ColumnPolicy::Resizable { .. }));
  856|       |        assert_eq!(spec.policy_hash, original_hash);
  857|       |
  858|       |        let mut fixed = ColumnSpec::new(
  859|       |            1,
  860|       |            "fixed",
  861|       |            ColumnPolicy::Fixed {
  862|       |                width: 40.0,
  863|       |                clip: false,
  864|       |            },
  865|       |            None,
  866|       |        );
  867|       |        let fixed_hash = fixed.policy_hash;
  868|       |        fixed.apply_preferred_width(100.0);
  869|       |        assert_eq!(fixed.policy_hash, fixed_hash);
  870|       |    }
  871|       |
  872|       |    #[test]
  873|       |    fn test_column_spec_hash_includes_index() {
  874|       |        let policy = ColumnPolicy::Resizable {
  875|       |            min: 40.0,
  876|       |            preferred: 120.0,
  877|       |            clip: false,
  878|       |        };
  879|       |        let first = ColumnSpec::new(0, "Header", policy.clone(), None);
  880|       |        let second = ColumnSpec::new(1, "Header", policy, None);
  881|       |        assert_ne!(first.policy_hash, second.policy_hash);
  882|       |    }
  883|       |
  884|       |    #[test]
  885|       |    fn test_compute_column_stats_empty() {
  886|       |        let stats = compute_column_stats(&[], &[], 10);
  887|       |        assert!(stats.is_empty());
  888|       |    }
  889|       |
  890|       |    #[test]
  891|       |    fn test_classify_date_status_notes_columns() {
  892|       |        let mut remainder = 0usize;
  893|       |        let date_policy = classify_column("Date", 0, &mut remainder, None, 14.0);
  894|       |        let status_policy = classify_column("Status", 1, &mut remainder, None, 14.0);
  895|       |        let notes_policy = classify_column("Notes", 2, &mut remainder, None, 14.0);
  896|       |
  897|       |        assert!(matches!(date_policy, ColumnPolicy::Fixed { .. }));
  898|       |        assert!(matches!(status_policy, ColumnPolicy::Fixed { .. }));
  899|       |        assert!(matches!(notes_policy, ColumnPolicy::Resizable { .. }));
  900|       |    }
  901|       |
  902|       |    #[test]
  903|       |    fn test_derive_column_specs_remainder_for_rich_content() {
  904|       |        let headers = vec![vec![span("Body")]];
  905|       |        let rows = vec![vec![vec![InlineSpan::Link {
  906|       |            text: "verylonglinkword".to_string(),
  907|       |            url: "https://example.invalid".to_string(),
  908|       |        }]]];
  909|       |        let stats = compute_column_stats(&headers, &rows, 32);
  910|       |        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  911|       |        let specs = derive_column_specs(&ctx);
  912|       |
  913|       |        assert!(matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
  914|       |    }
  915|       |
  916|       |    #[test]
  917|       |    fn test_normalize_body_font_px_defaults_for_invalid_values() {
  918|       |        assert_eq!(normalize_body_font_px(f32::NAN), 14.0);
  919|       |        assert_eq!(normalize_body_font_px(-10.0), 14.0);
  920|       |        assert_eq!(normalize_body_font_px(0.0), 14.0);
  921|       |        assert_eq!(normalize_body_font_px(12.0), 12.0);
  922|       |        assert_eq!(px(10.0, 2.0), 20.0);
  923|       |    }
  924|       |
  925|       |    #[test]
  926|       |    fn test_column_policy_tooltip_variants_for_clip_flags() {
  927|       |        let fixed = ColumnPolicy::Fixed {
  928|       |            width: 120.0,
  929|       |            clip: false,
  930|       |        };
  931|       |        let remainder = ColumnPolicy::Remainder { clip: true };
  932|       |
  933|       |        let fixed_tooltip = column_tooltip("Fixed", &fixed).expect("tooltip");
  934|       |        assert!(!fixed_tooltip.contains("clipped"));
  935|       |
  936|       |        let remainder_tooltip = column_tooltip("Remainder", &remainder).expect("tooltip");
  937|       |        assert!(remainder_tooltip.contains("clipped"));
  938|       |    }
  939|       |
  940|       |    #[test]
  941|       |    fn test_set_policy_updates_hash() {
  942|       |        let mut spec = ColumnSpec::new(0, "col", ColumnPolicy::Auto, None);
  943|       |        let original = spec.policy_hash;
  944|       |        spec.set_policy(ColumnPolicy::Fixed {
  945|       |            width: 100.0,
  946|       |            clip: true,
  947|       |        });
  948|       |        assert_ne!(spec.policy_hash, original);
  949|       |    }
  950|       |
  951|       |    #[test]
  952|       |    fn test_apply_preferred_width_updates_preferred_value() {
  953|       |        let mut spec = ColumnSpec::new(
  954|       |            0,
  955|       |            "body",
  956|       |            ColumnPolicy::Resizable {
  957|       |                min: 50.0,
  958|       |                preferred: 120.0,
  959|       |                clip: false,
  960|       |            },
  961|       |            None,
  962|       |        );
  963|       |        spec.apply_preferred_width(180.0);
  964|       |        assert!(matches!(spec.policy, ColumnPolicy::Resizable { .. }));
  965|       |    }
  966|       |
  967|       |    #[test]
  968|       |    fn test_column_policy_hash_variants() {
  969|       |        let policies = [
  970|       |            ColumnPolicy::Auto,
  971|       |            ColumnPolicy::Fixed {
  972|       |                width: 120.0,
  973|       |                clip: true,
  974|       |            },
  975|       |            ColumnPolicy::Remainder { clip: true },
  976|       |            ColumnPolicy::Resizable {
  977|       |                min: 40.0,
  978|       |                preferred: 120.0,
  979|       |                clip: true,
  980|       |            },
  981|       |        ];
  982|       |        for policy in policies {
  983|       |            let mut hasher = std::collections::hash_map::DefaultHasher::new();
  984|       |            policy.hash(&mut hasher);
  985|       |            let _ = hasher.finish();
  986|       |        }
  987|       |    }
  988|       |
  989|       |    #[test]
  990|       |    fn test_column_policy_to_column_clipped_variants() {
  991|       |        let fixed = ColumnPolicy::Fixed {
  992|       |            width: 120.0,
  993|       |            clip: true,
  994|       |        };
  995|       |        let fixed_unclipped = ColumnPolicy::Fixed {
  996|       |            width: 120.0,
  997|       |            clip: false,
  998|       |        };
  999|       |        let remainder = ColumnPolicy::Remainder { clip: true };
 1000|       |        let resizable = ColumnPolicy::Resizable {
 1001|       |            min: 40.0,
 1002|       |            preferred: 120.0,
 1003|       |            clip: true,
 1004|       |        };
 1005|       |        let _ = fixed.to_column();
 1006|       |        let _ = fixed_unclipped.to_column();
 1007|       |        let _ = remainder.to_column();
 1008|       |        let _ = resizable.to_column();
 1009|       |    }
 1010|       |
 1011|       |    #[test]
 1012|       |    fn test_column_needs_remainder_none_is_false() {
 1013|       |        assert!(!column_needs_remainder(None));
 1014|       |    }
 1015|       |
 1016|       |    #[test]
 1017|       |    fn test_accumulate_stats_for_cell_tracks_images() {
 1018|       |        let spans = vec![InlineSpan::Image {
 1019|       |            src: "img.png".to_string(),
 1020|       |            alt: "Alt".to_string(),
 1021|       |            title: None,
 1022|       |        }];
 1023|       |        let mut stat = ColumnStat::default();
 1024|       |        accumulate_stats_for_cell(&spans, &mut stat);
 1025|       |        assert!(stat.rich_content.has_image);
 1026|       |    }
 1027|       |
 1028|       |    #[test]
 1029|       |    fn test_accumulate_stats_detects_emoji_like_text() {
 1030|       |        let emoji = char::from_u32(0x1F600).expect("emoji");
 1031|       |        let spans = vec![InlineSpan::Text(format!("Hello {emoji}"))];
 1032|       |        let mut stat = ColumnStat::default();
 1033|       |        accumulate_stats_for_cell(&spans, &mut stat);
 1034|       |        assert!(stat.rich_content.has_emoji_like);
 1035|       |    }
 1036|       |
 1037|       |    #[test]
 1038|       |    fn test_remainder_cap_forces_resizable() {
 1039|       |        let mut remainder = MAX_REMAINDER_COLUMNS;
 1040|       |        let stat = ColumnStat {
 1041|       |            max_graphemes: 80,
 1042|       |            longest_word: 40,
 1043|       |            rich_content: RichContentFlags {
 1044|       |                has_link: true,
 1045|       |                has_image: false,
 1046|       |                has_emoji_like: false,
 1047|       |            },
 1048|       |        };
 1049|       |        let policy = classify_column("Notes", 2, &mut remainder, Some(&stat), 14.0);
 1050|       |        assert!(matches!(policy, ColumnPolicy::Resizable { .. }));
 1051|       |    }
 1052|       |
 1053|       |    #[test]
 1054|       |    fn test_compute_column_stats_respects_max_samples() {
 1055|       |        let headers = vec![vec![span("Header")]];
 1056|       |        let rows = vec![
 1057|       |            vec![vec![span("short")]],
 1058|       |            vec![vec![span("this_is_a_much_longer_token")]],
 1059|       |        ];
 1060|       |        let stats = compute_column_stats(&headers, &rows, 1);
 1061|       |        assert_eq!(stats.len(), 1);
 1062|       |        assert!(stats[0].longest_word < 20, "should ignore second row");
 1063|       |    }
 1064|       |
 1065|       |    #[test]
 1066|       |    fn test_accumulate_stats_preserves_existing_flags() {
 1067|       |        let mut stat = ColumnStat {
 1068|       |            max_graphemes: 0,
 1069|       |            longest_word: 0,
 1070|       |            rich_content: RichContentFlags {
 1071|       |                has_link: false,
 1072|       |                has_image: true,
 1073|       |                has_emoji_like: false,
 1074|       |            },
 1075|       |        };
 1076|       |        accumulate_stats_for_cell(&[InlineSpan::Text("plain".to_string())], &mut stat);
 1077|       |        assert!(stat.rich_content.has_image);
 1078|       |        assert!(!stat.rich_content.has_link);
 1079|       |    }
 1080|       |
 1081|       |    #[test]
 1082|       |    fn test_derive_column_specs_empty_context_returns_empty() {
 1083|       |        let headers: Vec<Vec<InlineSpan>> = Vec::new();
 1084|       |        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
 1085|       |        let stats: Vec<ColumnStat> = Vec::new();
 1086|       |        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
 1087|       |        let specs = derive_column_specs(&ctx);
 1088|       |        assert!(specs.is_empty());
 1089|       |    }
 1090|       |
 1091|       |    #[test]
 1092|       |    fn test_header_text_link_and_image_first() {
 1093|       |        let spans = vec![InlineSpan::Link {
 1094|       |            text: "Docs".to_string(),
 1095|       |            url: "https://example.com".to_string(),
 1096|       |        }];
 1097|       |        assert_eq!(header_text(&spans), "Docs");
 1098|       |        let spans = vec![InlineSpan::Image {
 1099|       |            src: "img.png".to_string(),
 1100|       |            alt: "Diagram".to_string(),
 1101|       |            title: None,
 1102|       |        }];
 1103|       |        assert_eq!(header_text(&spans), "Diagram");
 1104|       |    }
 1105|       |
 1106|       |    #[test]
 1107|       |    fn test_column_needs_remainder_true_for_long_words() {
 1108|       |        let stat = ColumnStat {
 1109|       |            max_graphemes: 10,
 1110|       |            longest_word: 24,
 1111|       |            rich_content: RichContentFlags {
 1112|       |                has_link: false,
 1113|       |                has_image: false,
 1114|       |                has_emoji_like: false,
 1115|       |            },
 1116|       |        };
 1117|       |        assert!(column_needs_remainder(Some(&stat)));
 1118|       |    }
 1119|       |
 1120|       |    #[test]
 1121|       |    fn test_column_needs_remainder_true_for_images() {
 1122|       |        let stat = ColumnStat {
 1123|       |            max_graphemes: 5,
 1124|       |            longest_word: 5,
 1125|       |            rich_content: RichContentFlags {
 1126|       |                has_link: false,
 1127|       |                has_image: true,
 1128|       |                has_emoji_like: false,
 1129|       |            },
 1130|       |        };
 1131|       |        assert!(column_needs_remainder(Some(&stat)));
 1132|       |    }
 1133|       |
 1134|       |    #[test]
 1135|       |    fn test_classify_column_skips_remainder_when_limit_reached() {
 1136|       |        let mut remainder_assigned = MAX_REMAINDER_COLUMNS;
 1137|       |        let stat = ColumnStat {
 1138|       |            max_graphemes: 2,
 1139|       |            longest_word: 2,
 1140|       |            rich_content: RichContentFlags {
 1141|       |                has_link: false,
 1142|       |                has_image: true,
 1143|       |                has_emoji_like: false,
 1144|       |            },
 1145|       |        };
 1146|       |        let policy = classify_column("misc", 1, &mut remainder_assigned, Some(&stat), 14.0);
 1147|       |        assert!(matches!(policy, ColumnPolicy::Resizable { .. }));
 1148|       |    }
 1149|       |
 1150|       |    #[test]
 1151|       |    fn test_accumulate_stats_empty_text_and_existing_emoji_flag() {
 1152|       |        let mut stat = ColumnStat {
 1153|       |            max_graphemes: 0,
 1154|       |            longest_word: 0,
 1155|       |            rich_content: RichContentFlags {
 1156|       |                has_link: false,
 1157|       |                has_image: false,
 1158|       |                has_emoji_like: true,
 1159|       |            },
 1160|       |        };
 1161|       |        accumulate_stats_for_cell(&[InlineSpan::Text("Hello".to_string())], &mut stat);
 1162|       |        assert!(stat.rich_content.has_emoji_like);
 1163|       |
 1164|       |        let mut empty_stat = ColumnStat::default();
 1165|       |        accumulate_stats_for_cell(&[], &mut empty_stat);
 1166|       |        assert_eq!(empty_stat.max_graphemes, 0);
 1167|       |    }
 1168|       |}

C:\language\mdmdview\src\table_support\metrics.rs:
    1|       |use std::collections::HashMap;
    2|       |
    3|       |#[allow(dead_code)]
    4|       |#[derive(Debug, Default, Clone)]
    5|       |pub struct RowMetrics {
    6|       |    pub max_height: f32,
    7|       |    pub dirty: bool,
    8|       |}
    9|       |
   10|       |#[allow(dead_code)]
   11|       |#[derive(Debug, Default, Clone)]
   12|       |pub struct TableMetricEntry {
   13|       |    pub rows: Vec<RowMetrics>,
   14|       |    pub rendered_rows: usize,
   15|       |    pub total_rows: usize,
   16|       |    pub header_height: f32,
   17|       |    pub resolved_widths: Vec<f32>,
   18|       |    pub last_width_frame: u64,
   19|       |    pub last_discard_frame: Option<u64>,
   20|       |    pub persisted_column_widths: HashMap<u64, f32>,
   21|       |    pub pending_user_resize: Option<PendingResize>,
   22|       |    /// Font size when widths were last persisted. Used to invalidate
   23|       |    /// persisted widths when zoom level changes.
   24|       |    pub persisted_font_size: Option<f32>,
   25|       |}
   26|       |
   27|       |#[derive(Debug, Clone, Copy)]
   28|       |pub struct PendingResize {
   29|       |    pub column_hash: u64,
   30|       |    pub width: f32,
   31|       |}
   32|       |
   33|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   34|       |pub enum WidthChange {
   35|       |    None,
   36|       |    Small,
   37|       |    Large,
   38|       |}
   39|       |
   40|       |const WIDTH_EPSILON: f32 = 0.15;
   41|       |const WIDTH_LARGE_DELTA: f32 = 0.75;
   42|       |
   43|       |impl TableMetricEntry {
   44|     29|    pub fn ensure_row(&mut self, index: usize) -> &mut RowMetrics {
   45|     29|        if index >= self.rows.len() {
   46|     28|            self.rows.resize_with(index + 1, RowMetrics::default);
   47|     28|        }
                      ^1
   48|     29|        &mut self.rows[index]
   49|     29|    }
   50|       |
   51|     31|    pub fn row(&self, index: usize) -> Option<&RowMetrics> {
   52|     31|        self.rows.get(index)
   53|     31|    }
   54|       |
   55|     22|    pub fn begin_pass(&mut self, total_rows: usize) {
   56|     22|        self.total_rows = total_rows;
   57|     22|        self.rendered_rows = 0;
   58|     22|    }
   59|       |
   60|     32|    pub fn note_row_rendered(&mut self) {
   61|     32|        self.rendered_rows += 1;
   62|     32|    }
   63|       |
   64|    100|    pub fn persisted_width(&self, key: u64) -> Option<f32> {
   65|    100|        self.persisted_column_widths.get(&key).copied()
   66|    100|    }
   67|       |
   68|     29|    pub fn set_persisted_width(&mut self, key: u64, width: f32) {
   69|     29|        self.persisted_column_widths.insert(key, width);
   70|     29|    }
   71|       |
   72|      1|    pub fn remove_persisted_width(&mut self, key: u64) {
   73|      1|        self.persisted_column_widths.remove(&key);
   74|      1|    }
   75|       |
   76|     25|    pub fn update_widths(&mut self, widths: &[f32], frame_id: u64) -> WidthChange {
   77|     25|        if widths.is_empty() {
   78|      1|            self.resolved_widths.clear();
   79|      1|            self.last_width_frame = frame_id;
   80|      1|            return WidthChange::None;
   81|     24|        }
   82|       |
   83|     24|        let first_update = self.resolved_widths.is_empty();
   84|     24|        let mut change = WidthChange::None;
   85|     24|        if !first_update && self.resolved_widths.len() != widths.len() {
                                          ^4                   ^4
   86|      1|            change = WidthChange::Large;
   87|      1|        } else {
   88|     23|            for (old, new) in self.resolved_widths.iter().zip(widths.iter()) {
                               ^8   ^8
   89|      8|                let delta = (old - new).abs();
   90|      8|                if delta > WIDTH_LARGE_DELTA {
   91|      1|                    change = WidthChange::Large;
   92|      1|                    break;
   93|      7|                }
   94|      7|                if delta > WIDTH_EPSILON {
   95|      2|                    change = WidthChange::Small;
   96|      5|                }
   97|       |            }
   98|       |        }
   99|       |
  100|     24|        self.resolved_widths.clear();
  101|     24|        self.resolved_widths.extend_from_slice(widths);
  102|     24|        self.last_width_frame = frame_id;
  103|       |
  104|     24|        change
  105|     25|    }
  106|       |
  107|     22|    pub fn header_height(&self) -> Option<f32> {
  108|     22|        if self.header_height > 0.0 {
  109|      3|            Some(self.header_height)
  110|       |        } else {
  111|     19|            None
  112|       |        }
  113|     22|    }
  114|       |
  115|     22|    pub fn update_header_height(&mut self, height: f32) -> bool {
  116|     22|        let clamped = height.max(0.0);
  117|     22|        if (self.header_height - clamped).abs() > 0.5 {
  118|     20|            self.header_height = clamped;
  119|     20|            true
  120|       |        } else {
  121|      2|            false
  122|       |        }
  123|     22|    }
  124|       |
  125|     22|    pub fn current_widths(&self) -> &[f32] {
  126|     22|        &self.resolved_widths
  127|     22|    }
  128|       |
  129|       |    /// Check if font size has changed since widths were last persisted.
  130|       |    /// If so, clear all persisted widths and update the stored font size.
  131|       |    /// Returns true if widths were cleared.
  132|     32|    pub fn check_font_size_change(&mut self, current_font_size: f32) -> bool {
  133|       |        const FONT_SIZE_EPSILON: f32 = 0.5;
  134|     32|        if let Some(stored_font) = self.persisted_font_size {
                                  ^7
  135|      7|            if (stored_font - current_font_size).abs() > FONT_SIZE_EPSILON {
  136|      2|                self.persisted_column_widths.clear();
  137|      2|                self.persisted_font_size = Some(current_font_size);
  138|      2|                return true;
  139|      5|            }
  140|     25|        } else {
  141|     25|            self.persisted_font_size = Some(current_font_size);
  142|     25|        }
  143|     30|        false
  144|     32|    }
  145|       |}
  146|       |
  147|       |#[allow(dead_code)]
  148|       |#[derive(Debug, Default, Clone)]
  149|       |pub struct TableMetrics {
  150|       |    tables: HashMap<u64, TableMetricEntry>,
  151|       |}
  152|       |
  153|       |impl TableMetrics {
  154|    169|    pub fn entry_mut(&mut self, table_id: u64) -> &mut TableMetricEntry {
  155|    169|        self.tables.entry(table_id).or_default()
  156|    169|    }
  157|       |
  158|    100|    pub fn entry(&self, table_id: u64) -> Option<&TableMetricEntry> {
  159|    100|        self.tables.get(&table_id)
  160|    100|    }
  161|       |
  162|      3|    pub fn totals(&self) -> (usize, usize) {
  163|      3|        self.tables
  164|      3|            .values()
  165|      4|            .fold((0, 0), |(rendered, total), entry| {
                           ^3   ^3
  166|      4|                (rendered + entry.rendered_rows, total + entry.total_rows)
  167|      4|            })
  168|      3|    }
  169|       |
  170|    259|    pub fn clear(&mut self) {
  171|    259|        self.tables.clear();
  172|    259|    }
  173|       |}
  174|       |
  175|       |#[allow(dead_code)]
  176|       |#[derive(Debug, Default, Clone)]
  177|       |pub struct CacheStats {
  178|       |    pub hits: u64,
  179|       |    pub misses: u64,
  180|       |}
  181|       |
  182|       |impl CacheStats {
  183|      2|    pub fn record_hit(&mut self) {
  184|      2|        self.hits += 1;
  185|      2|    }
  186|       |
  187|      1|    pub fn record_miss(&mut self) {
  188|      1|        self.misses += 1;
  189|      1|    }
  190|       |}
  191|       |
  192|       |#[cfg(test)]
  193|       |#[cfg_attr(coverage_nightly, coverage(off))]
  194|       |mod tests {
  195|       |    use super::*;
  196|       |
  197|       |    #[test]
  198|       |    fn update_widths_detects_large_change() {
  199|       |        let mut entry = TableMetricEntry::default();
  200|       |        assert_eq!(entry.update_widths(&[100.0, 120.0], 1), WidthChange::None);
  201|       |        assert_eq!(entry.update_widths(&[100.2, 120.6], 2), WidthChange::Small);
  202|       |        assert_eq!(entry.update_widths(&[140.0, 120.6], 3), WidthChange::Large);
  203|       |    }
  204|       |
  205|       |    #[test]
  206|       |    fn font_size_change_clears_persisted_widths() {
  207|       |        let mut entry = TableMetricEntry::default();
  208|       |
  209|       |        // Set some persisted widths at font size 14.0
  210|       |        entry.set_persisted_width(1, 100.0);
  211|       |        entry.set_persisted_width(2, 150.0);
  212|       |        assert!(!entry.check_font_size_change(14.0)); // First call sets baseline
  213|       |        assert_eq!(entry.persisted_width(1), Some(100.0));
  214|       |        assert_eq!(entry.persisted_width(2), Some(150.0));
  215|       |
  216|       |        // Small font size change (within epsilon) should NOT clear
  217|       |        assert!(!entry.check_font_size_change(14.3));
  218|       |        assert_eq!(entry.persisted_width(1), Some(100.0));
  219|       |
  220|       |        // Large font size change should clear all persisted widths
  221|       |        assert!(entry.check_font_size_change(16.0));
  222|       |        assert_eq!(entry.persisted_width(1), None);
  223|       |        assert_eq!(entry.persisted_width(2), None);
  224|       |        assert_eq!(entry.persisted_font_size, Some(16.0));
  225|       |    }
  226|       |
  227|       |    #[test]
  228|       |    fn row_management_tracks_rows_and_rendered_counts() {
  229|       |        let mut entry = TableMetricEntry::default();
  230|       |        entry.begin_pass(3);
  231|       |        assert_eq!(entry.total_rows, 3);
  232|       |        assert_eq!(entry.rendered_rows, 0);
  233|       |
  234|       |        let row = entry.ensure_row(2);
  235|       |        row.max_height = 12.0;
  236|       |        row.dirty = true;
  237|       |
  238|       |        assert_eq!(entry.row(2).map(|r| r.max_height), Some(12.0));
  239|       |        assert_eq!(entry.row(2).map(|r| r.dirty), Some(true));
  240|       |        assert!(entry.row(5).is_none());
  241|       |
  242|       |        entry.note_row_rendered();
  243|       |        entry.note_row_rendered();
  244|       |        assert_eq!(entry.rendered_rows, 2);
  245|       |    }
  246|       |
  247|       |    #[test]
  248|       |    fn persisted_widths_can_be_added_and_removed() {
  249|       |        let mut entry = TableMetricEntry::default();
  250|       |        assert!(entry.persisted_width(10).is_none());
  251|       |        entry.set_persisted_width(10, 123.0);
  252|       |        assert_eq!(entry.persisted_width(10), Some(123.0));
  253|       |        entry.remove_persisted_width(10);
  254|       |        assert!(entry.persisted_width(10).is_none());
  255|       |    }
  256|       |
  257|       |    #[test]
  258|       |    fn update_widths_handles_empty_and_length_change() {
  259|       |        let mut entry = TableMetricEntry::default();
  260|       |        assert_eq!(entry.update_widths(&[], 1), WidthChange::None);
  261|       |        assert!(entry.current_widths().is_empty());
  262|       |
  263|       |        assert_eq!(entry.update_widths(&[50.0, 60.0], 2), WidthChange::None);
  264|       |        assert_eq!(entry.update_widths(&[50.0], 3), WidthChange::Large);
  265|       |    }
  266|       |
  267|       |    #[test]
  268|       |    fn header_height_updates_when_changed() {
  269|       |        let mut entry = TableMetricEntry::default();
  270|       |        assert!(entry.header_height().is_none());
  271|       |        assert!(entry.update_header_height(24.0));
  272|       |        assert_eq!(entry.header_height(), Some(24.0));
  273|       |        assert!(!entry.update_header_height(24.2));
  274|       |        assert!(entry.update_header_height(30.0));
  275|       |        assert_eq!(entry.header_height(), Some(30.0));
  276|       |    }
  277|       |
  278|       |    #[test]
  279|       |    fn table_metrics_totals_and_clear() {
  280|       |        let mut metrics = TableMetrics::default();
  281|       |        metrics.entry_mut(1).begin_pass(2);
  282|       |        metrics.entry_mut(1).note_row_rendered();
  283|       |        metrics.entry_mut(2).begin_pass(3);
  284|       |        metrics.entry_mut(2).note_row_rendered();
  285|       |        metrics.entry_mut(2).note_row_rendered();
  286|       |
  287|       |        assert_eq!(metrics.totals(), (3, 5));
  288|       |        metrics.clear();
  289|       |        assert!(metrics.entry(1).is_none());
  290|       |    }
  291|       |
  292|       |    #[test]
  293|       |    fn cache_stats_counts_hits_and_misses() {
  294|       |        let mut stats = CacheStats::default();
  295|       |        stats.record_hit();
  296|       |        stats.record_hit();
  297|       |        stats.record_miss();
  298|       |        assert_eq!(stats.hits, 2);
  299|       |        assert_eq!(stats.misses, 1);
  300|       |    }
  301|       |}

C:\language\mdmdview\src\window_state.rs:
    1|       |use std::fs;
    2|       |use std::io::{Read, Write};
    3|       |use std::path::PathBuf;
    4|       |
    5|       |#[derive(Debug, Clone, Copy)]
    6|       |pub struct WindowState {
    7|       |    pub pos: [f32; 2],
    8|       |    pub size: [f32; 2],
    9|       |    pub maximized: bool,
   10|       |}
   11|       |
   12|     24|fn config_dir() -> Option<PathBuf> {
   13|       |    // Crossplatform config dir without extra deps
   14|       |    #[cfg(target_os = "windows")]
   15|       |    {
   16|     24|        if let Ok(appdata) = std::env::var("APPDATA") {
                                ^19
   17|     19|            let mut p = PathBuf::from(appdata);
   18|     19|            p.push("MarkdownView");
   19|     19|            return Some(p);
   20|      5|        }
   21|       |    }
   22|       |
   23|       |    #[cfg(target_os = "macos")]
   24|       |    {
   25|       |        if let Ok(home) = std::env::var("HOME") {
   26|       |            let mut p = PathBuf::from(home);
   27|       |            p.push("Library/Application Support/MarkdownView");
   28|       |            return Some(p);
   29|       |        }
   30|       |    }
   31|       |
   32|       |    // Linux / others: XDG or ~/.config
   33|      5|    if let Ok(xdg) = std::env::var("XDG_CONFIG_HOME") {
                            ^1
   34|      1|        let mut p = PathBuf::from(xdg);
   35|      1|        p.push("mdmdview");
   36|      1|        return Some(p);
   37|      4|    }
   38|      4|    if let Ok(home) = std::env::var("HOME") {
                            ^1
   39|      1|        let mut p = PathBuf::from(home);
   40|      1|        p.push(".config/mdmdview");
   41|      1|        return Some(p);
   42|      3|    }
   43|      3|    None
   44|     24|}
   45|       |
   46|     10|fn state_path() -> Option<PathBuf> {
   47|     10|    config_dir().map(|mut dir| {
                                             ^9
   48|      9|        dir.push("window_state.txt");
   49|      9|        dir
   50|      9|    })
   51|     10|}
   52|       |
   53|     11|pub fn load_window_state() -> Option<WindowState> {
   54|       |    #[cfg(windows)]
   55|       |    {
   56|     11|        if let Some(ws) = load_window_state_registry() {
                                  ^1
   57|      1|            return Some(ws);
   58|     10|        }
   59|       |    }
   60|     10|    let path = state_path()?;
                      ^9                 ^1
   61|      9|    let mut f = fs::File::open(path).ok()?;
                      ^8                               ^1
   62|      8|    let mut s = String::new();
   63|      8|    f.read_to_string(&mut s).ok()?;
                                               ^1
   64|       |    // expected format: "x y w h max"
   65|      7|    let parts: Vec<&str> = s.split_whitespace().collect();
   66|      7|    if parts.len() < 5 {
   67|      1|        return None;
   68|      6|    }
   69|      6|    let x = parts[0].parse::<f32>().ok()?;
                      ^5                              ^1
   70|      5|    let y = parts[1].parse::<f32>().ok()?;
                      ^4                              ^1
   71|      4|    let w = parts[2].parse::<f32>().ok()?;
                      ^3                              ^1
   72|      3|    let h = parts[3].parse::<f32>().ok()?;
                      ^2                              ^1
   73|      2|    let max = matches!(parts[4], "1" | "true" | "True");
                            ^1                                ^1
   74|      2|    Some(WindowState {
   75|      2|        pos: [x, y],
   76|      2|        size: [w, h],
   77|      2|        maximized: max,
   78|      2|    })
   79|     11|}
   80|       |
   81|     11|pub fn save_window_state(state: &WindowState) -> std::io::Result<()> {
   82|       |    #[cfg(windows)]
   83|       |    {
   84|     11|        if let Err(e) = save_window_state_registry(state) {
                                 ^1
   85|      1|            eprintln!("Failed to write window state to registry: {e}");
   86|     10|        }
   87|       |    }
   88|     11|    if let Some(mut dir) = config_dir() {
                              ^10
   89|     10|        if !dir.exists() {
   90|      8|            fs::create_dir_all(&dir)?;
                                                  ^1
   91|      2|        }
   92|      9|        dir.push("window_state.txt");
   93|      9|        let mut f = fs::File::create(&dir)?;
                          ^8                            ^1
   94|      8|        write_window_state(&mut f, state)?;
                                                       ^1
   95|      1|    }
   96|      8|    Ok(())
   97|     11|}
   98|       |
   99|      9|fn write_window_state<W: Write>(writer: &mut W, state: &WindowState) -> std::io::Result<()> {
  100|       |    // simple whitespace separated format
  101|       |    #[cfg(test)]
  102|      9|    if take_forced_file_write_error() {
  103|      1|        return Err(std::io::Error::new(
  104|      1|            std::io::ErrorKind::Other,
  105|      1|            "forced write error",
  106|      1|        ));
  107|      8|    }
  108|      8|    writeln!(
  109|      8|        writer,
  110|      8|        "{} {} {} {} {}",
  111|      8|        state.pos[0], state.pos[1], state.size[0], state.size[1], state.maximized as u8
  112|      1|    )?;
  113|      7|    Ok(())
  114|      9|}
  115|       |
  116|      5|pub fn sanitize_window_state(ws: WindowState) -> Option<WindowState> {
  117|       |    // Basic sanity: finite values
  118|      5|    if !ws.pos[0].is_finite()
  119|      4|        || !ws.pos[1].is_finite()
  120|      3|        || !ws.size[0].is_finite()
  121|      2|        || !ws.size[1].is_finite()
  122|       |    {
  123|      4|        return None;
  124|      1|    }
  125|       |
  126|       |    // Clamp to reasonable ranges
  127|      1|    let min_w = 600.0f32;
  128|      1|    let min_h = 400.0f32;
  129|      1|    let max_w = 10000.0f32;
  130|      1|    let max_h = 10000.0f32;
  131|      1|    let max_pos = 20000.0f32; // avoid absurdly large coordinates
  132|       |
  133|      1|    let w = ws.size[0].clamp(min_w, max_w);
  134|      1|    let h = ws.size[1].clamp(min_h, max_h);
  135|      1|    let x = ws.pos[0].max(0.0).min(max_pos);
  136|      1|    let y = ws.pos[1].max(0.0).min(max_pos);
  137|       |
  138|      1|    Some(WindowState {
  139|      1|        pos: [x, y],
  140|      1|        size: [w, h],
  141|      1|        maximized: ws.maximized,
  142|      1|    })
  143|      5|}
  144|       |
  145|       |#[cfg(all(windows, not(test)))]
  146|       |fn load_window_state_registry() -> Option<WindowState> {
  147|       |    use winreg::enums::HKEY_CURRENT_USER;
  148|       |    use winreg::RegKey;
  149|       |    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  150|       |    let key = hkcu.open_subkey("Software\\MarkdownView").ok()?;
  151|       |    let x: u32 = key.get_value("PosX").ok()?;
  152|       |    let y: u32 = key.get_value("PosY").ok()?;
  153|       |    let w: u32 = key.get_value("Width").ok()?;
  154|       |    let h: u32 = key.get_value("Height").ok()?;
  155|       |    let maximized: u32 = key.get_value("Maximized").unwrap_or(0);
  156|       |    Some(WindowState {
  157|       |        pos: [x as f32, y as f32],
  158|       |        size: [w as f32, h as f32],
  159|       |        maximized: maximized != 0,
  160|       |    })
  161|       |}
  162|       |
  163|       |#[cfg(all(windows, not(test)))]
  164|       |fn save_window_state_registry(state: &WindowState) -> std::io::Result<()> {
  165|       |    use winreg::enums::{HKEY_CURRENT_USER, KEY_READ, KEY_WRITE};
  166|       |    use winreg::RegKey;
  167|       |    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  168|       |    let (key, _disp) =
  169|       |        hkcu.create_subkey_with_flags("Software\\MarkdownView", KEY_READ | KEY_WRITE)?;
  170|       |    let to_u32 = |v: f32| -> u32 {
  171|       |        if v.is_finite() {
  172|       |            v.max(0.0).min(u32::MAX as f32).round() as u32
  173|       |        } else {
  174|       |            0
  175|       |        }
  176|       |    };
  177|       |    key.set_value("PosX", &to_u32(state.pos[0]))?;
  178|       |    key.set_value("PosY", &to_u32(state.pos[1]))?;
  179|       |    key.set_value("Width", &to_u32(state.size[0]))?;
  180|       |    key.set_value("Height", &to_u32(state.size[1]))?;
  181|       |    key.set_value("Maximized", &(state.maximized as u32))?;
  182|       |    Ok(())
  183|       |}
  184|       |
  185|       |#[cfg(test)]
  186|       |thread_local! {
  187|       |    static FORCED_FILE_WRITE_ERROR: std::cell::RefCell<bool> =
  188|       |        const { std::cell::RefCell::new(false) };
  189|       |}
  190|       |
  191|       |#[cfg(test)]
  192|      9|fn take_forced_file_write_error() -> bool {
  193|      9|    FORCED_FILE_WRITE_ERROR.with(|flag| flag.replace(false))
  194|      9|}
  195|       |
  196|       |#[cfg(test)]
  197|      1|fn force_file_write_error_once() {
  198|      1|    FORCED_FILE_WRITE_ERROR.with(|flag| {
  199|      1|        *flag.borrow_mut() = true;
  200|      1|    });
  201|      1|}
  202|       |
  203|       |#[cfg(all(windows, test))]
  204|       |thread_local! {
  205|       |    static FORCED_REGISTRY_LOAD: std::cell::RefCell<Option<WindowState>> =
  206|       |        const { std::cell::RefCell::new(None) };
  207|       |    static FORCED_REGISTRY_SAVE_ERROR: std::cell::RefCell<bool> =
  208|       |        const { std::cell::RefCell::new(false) };
  209|       |}
  210|       |
  211|       |#[cfg(all(windows, test))]
  212|     11|fn take_forced_registry_load() -> Option<WindowState> {
  213|     11|    FORCED_REGISTRY_LOAD.with(|slot| slot.borrow_mut().take())
  214|     11|}
  215|       |
  216|       |#[cfg(all(windows, test))]
  217|     11|fn take_forced_registry_save_error() -> bool {
  218|     11|    FORCED_REGISTRY_SAVE_ERROR.with(|flag| flag.replace(false))
  219|     11|}
  220|       |
  221|       |#[cfg(all(windows, test))]
  222|      1|fn force_registry_load_once(state: WindowState) {
  223|      1|    FORCED_REGISTRY_LOAD.with(|slot| {
  224|      1|        *slot.borrow_mut() = Some(state);
  225|      1|    });
  226|      1|}
  227|       |
  228|       |#[cfg(all(windows, test))]
  229|      1|fn force_registry_save_error_once() {
  230|      1|    FORCED_REGISTRY_SAVE_ERROR.with(|flag| {
  231|      1|        *flag.borrow_mut() = true;
  232|      1|    });
  233|      1|}
  234|       |
  235|       |#[cfg(all(windows, test))]
  236|     11|fn load_window_state_registry() -> Option<WindowState> {
  237|     11|    take_forced_registry_load()
  238|     11|}
  239|       |
  240|       |#[cfg(all(windows, test))]
  241|     11|fn save_window_state_registry(_state: &WindowState) -> std::io::Result<()> {
  242|     11|    if take_forced_registry_save_error() {
  243|      1|        return Err(std::io::Error::other("forced registry error"));
  244|     10|    }
  245|     10|    Ok(())
  246|     11|}
  247|       |
  248|       |#[cfg(test)]
  249|       |#[cfg_attr(coverage_nightly, coverage(off))]
  250|       |mod tests {
  251|       |    use super::*;
  252|       |    use std::sync::{Mutex, OnceLock};
  253|       |    use tempfile::TempDir;
  254|       |
  255|       |    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
  256|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
  257|       |        ENV_LOCK
  258|       |            .get_or_init(|| Mutex::new(()))
  259|       |            .lock()
  260|       |            .expect("env lock")
  261|       |    }
  262|       |
  263|       |    struct EnvGuard {
  264|       |        key: &'static str,
  265|       |        original: Option<String>,
  266|       |    }
  267|       |
  268|       |    impl EnvGuard {
  269|       |        fn set(key: &'static str, value: &str) -> Self {
  270|       |            let original = std::env::var(key).ok();
  271|       |            std::env::set_var(key, value);
  272|       |            Self { key, original }
  273|       |        }
  274|       |
  275|       |        fn unset(key: &'static str) -> Self {
  276|       |            let original = std::env::var(key).ok();
  277|       |            std::env::remove_var(key);
  278|       |            Self { key, original }
  279|       |        }
  280|       |    }
  281|       |
  282|       |    impl Drop for EnvGuard {
  283|       |        fn drop(&mut self) {
  284|       |            if let Some(value) = &self.original {
  285|       |                std::env::set_var(self.key, value);
  286|       |            } else {
  287|       |                std::env::remove_var(self.key);
  288|       |            }
  289|       |        }
  290|       |    }
  291|       |
  292|       |    #[test]
  293|       |    fn test_sanitize_window_state_clamps_and_rejects_invalid() {
  294|       |        let invalid = WindowState {
  295|       |            pos: [f32::NAN, 10.0],
  296|       |            size: [800.0, 600.0],
  297|       |            maximized: false,
  298|       |        };
  299|       |        assert!(sanitize_window_state(invalid).is_none());
  300|       |
  301|       |        let input = WindowState {
  302|       |            pos: [-50.0, 25000.0],
  303|       |            size: [100.0, 200.0],
  304|       |            maximized: true,
  305|       |        };
  306|       |        let sanitized = sanitize_window_state(input).expect("expected sanitized state");
  307|       |        assert_eq!(sanitized.pos[0], 0.0);
  308|       |        assert_eq!(sanitized.pos[1], 20000.0);
  309|       |        assert_eq!(sanitized.size[0], 600.0);
  310|       |        assert_eq!(sanitized.size[1], 400.0);
  311|       |        assert!(sanitized.maximized);
  312|       |    }
  313|       |
  314|       |    #[test]
  315|       |    fn test_sanitize_window_state_rejects_non_finite_components() {
  316|       |        let invalid_y = WindowState {
  317|       |            pos: [10.0, f32::NAN],
  318|       |            size: [800.0, 600.0],
  319|       |            maximized: false,
  320|       |        };
  321|       |        assert!(sanitize_window_state(invalid_y).is_none());
  322|       |
  323|       |        let invalid_w = WindowState {
  324|       |            pos: [10.0, 20.0],
  325|       |            size: [f32::NAN, 600.0],
  326|       |            maximized: false,
  327|       |        };
  328|       |        assert!(sanitize_window_state(invalid_w).is_none());
  329|       |
  330|       |        let invalid_h = WindowState {
  331|       |            pos: [10.0, 20.0],
  332|       |            size: [800.0, f32::NAN],
  333|       |            maximized: false,
  334|       |        };
  335|       |        assert!(sanitize_window_state(invalid_h).is_none());
  336|       |    }
  337|       |
  338|       |    #[test]
  339|       |    fn test_save_and_load_window_state_from_file() {
  340|       |        let _lock = env_lock();
  341|       |        let temp = TempDir::new().expect("temp dir");
  342|       |        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  343|       |
  344|       |        let state = WindowState {
  345|       |            pos: [120.0, 80.0],
  346|       |            size: [1024.0, 768.0],
  347|       |            maximized: false,
  348|       |        };
  349|       |        save_window_state(&state).expect("save");
  350|       |
  351|       |        let loaded = load_window_state().expect("load");
  352|       |        assert_eq!(loaded.pos, state.pos);
  353|       |        assert_eq!(loaded.size, state.size);
  354|       |        assert_eq!(loaded.maximized, state.maximized);
  355|       |    }
  356|       |
  357|       |    #[test]
  358|       |    fn test_save_window_state_creates_dir_and_writes_file() {
  359|       |        let _lock = env_lock();
  360|       |        let temp = TempDir::new().expect("temp dir");
  361|       |        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  362|       |
  363|       |        let config_dir = temp.path().join("MarkdownView");
  364|       |        let _ = fs::remove_dir_all(&config_dir);
  365|       |
  366|       |        let state = WindowState {
  367|       |            pos: [10.0, 20.0],
  368|       |            size: [800.0, 600.0],
  369|       |            maximized: true,
  370|       |        };
  371|       |        save_window_state(&state).expect("save");
  372|       |
  373|       |        let path = config_dir.join("window_state.txt");
  374|       |        let contents = fs::read_to_string(&path).expect("read");
  375|       |        let mut parts = contents.split_whitespace();
  376|       |        let pos_x: f32 = parts.next().expect("pos x").parse().expect("parse pos x");
  377|       |        let pos_y: f32 = parts.next().expect("pos y").parse().expect("parse pos y");
  378|       |        let size_x: f32 = parts.next().expect("size x").parse().expect("parse size x");
  379|       |        let size_y: f32 = parts.next().expect("size y").parse().expect("parse size y");
  380|       |        let max_flag = parts.next().expect("max flag");
  381|       |        assert_eq!(pos_x, state.pos[0]);
  382|       |        assert_eq!(pos_y, state.pos[1]);
  383|       |        assert_eq!(size_x, state.size[0]);
  384|       |        assert_eq!(size_y, state.size[1]);
  385|       |        assert_eq!(max_flag, "1");
  386|       |    }
  387|       |
  388|       |    #[test]
  389|       |    fn test_write_window_state_error_propagates() {
  390|       |        struct FailingWriter;
  391|       |
  392|       |        impl Write for FailingWriter {
  393|       |            fn write(&mut self, _buf: &[u8]) -> std::io::Result<usize> {
  394|       |                Err(std::io::Error::new(std::io::ErrorKind::Other, "fail"))
  395|       |            }
  396|       |
  397|       |            fn flush(&mut self) -> std::io::Result<()> {
  398|       |                Ok(())
  399|       |            }
  400|       |        }
  401|       |
  402|       |        let state = WindowState {
  403|       |            pos: [1.0, 2.0],
  404|       |            size: [3.0, 4.0],
  405|       |            maximized: false,
  406|       |        };
  407|       |        let mut writer = FailingWriter;
  408|       |        let err = write_window_state(&mut writer, &state).expect_err("err");
  409|       |        assert_eq!(err.kind(), std::io::ErrorKind::Other);
  410|       |        writer.flush().expect("flush");
  411|       |    }
  412|       |
  413|       |    #[test]
  414|       |    fn test_save_window_state_errors_when_state_path_is_dir() {
  415|       |        let _lock = env_lock();
  416|       |        let temp = TempDir::new().expect("temp dir");
  417|       |        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  418|       |
  419|       |        let config_dir = temp.path().join("MarkdownView");
  420|       |        fs::create_dir_all(&config_dir).expect("create config dir");
  421|       |        let state_dir = config_dir.join("window_state.txt");
  422|       |        fs::create_dir_all(&state_dir).expect("create state dir");
  423|       |
  424|       |        let state = WindowState {
  425|       |            pos: [1.0, 2.0],
  426|       |            size: [3.0, 4.0],
  427|       |            maximized: false,
  428|       |        };
  429|       |        assert!(save_window_state(&state).is_err());
  430|       |    }
  431|       |
  432|       |    #[test]
  433|       |    fn test_save_window_state_forced_write_error_propagates() {
  434|       |        let _lock = env_lock();
  435|       |        let temp = TempDir::new().expect("temp dir");
  436|       |        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  437|       |
  438|       |        force_file_write_error_once();
  439|       |        let state = WindowState {
  440|       |            pos: [1.0, 2.0],
  441|       |            size: [3.0, 4.0],
  442|       |            maximized: false,
  443|       |        };
  444|       |        let err = save_window_state(&state).expect_err("expected error");
  445|       |        assert_eq!(err.kind(), std::io::ErrorKind::Other);
  446|       |    }
  447|       |
  448|       |    #[test]
  449|       |    fn test_save_window_state_when_dir_exists() {
  450|       |        let _lock = env_lock();
  451|       |        let temp = TempDir::new().expect("temp dir");
  452|       |        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  453|       |        let config_dir = temp.path().join("MarkdownView");
  454|       |        fs::create_dir_all(&config_dir).expect("create config dir");
  455|       |
  456|       |        let state = WindowState {
  457|       |            pos: [5.0, 6.0],
  458|       |            size: [700.0, 500.0],
  459|       |            maximized: false,
  460|       |        };
  461|       |        save_window_state(&state).expect("save");
  462|       |        let path = config_dir.join("window_state.txt");
  463|       |        assert!(path.exists());
  464|       |    }
  465|       |
  466|       |    #[test]
  467|       |    fn test_load_window_state_prefers_registry_when_forced() {
  468|       |        let _lock = env_lock();
  469|       |        let temp = TempDir::new().expect("temp dir");
  470|       |        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  471|       |
  472|       |        let state = WindowState {
  473|       |            pos: [42.0, 24.0],
  474|       |            size: [800.0, 600.0],
  475|       |            maximized: true,
  476|       |        };
  477|       |        force_registry_load_once(state);
  478|       |
  479|       |        let loaded = load_window_state().expect("load");
  480|       |        assert_eq!(loaded.pos, state.pos);
  481|       |        assert_eq!(loaded.size, state.size);
  482|       |        assert_eq!(loaded.maximized, state.maximized);
  483|       |    }
  484|       |
  485|       |    #[test]
  486|       |    fn test_save_window_state_registry_error_still_writes_file() {
  487|       |        let _lock = env_lock();
  488|       |        let temp = TempDir::new().expect("temp dir");
  489|       |        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  490|       |        force_registry_save_error_once();
  491|       |
  492|       |        let state = WindowState {
  493|       |            pos: [10.0, 20.0],
  494|       |            size: [1024.0, 768.0],
  495|       |            maximized: false,
  496|       |        };
  497|       |        save_window_state(&state).expect("save");
  498|       |
  499|       |        let path = temp.path().join("MarkdownView").join("window_state.txt");
  500|       |        assert!(path.exists());
  501|       |    }
  502|       |
  503|       |    #[test]
  504|       |    fn test_load_window_state_rejects_bad_file() {
  505|       |        let _lock = env_lock();
  506|       |        let temp = TempDir::new().expect("temp dir");
  507|       |        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  508|       |
  509|       |        let mut config = temp.path().join("MarkdownView");
  510|       |        std::fs::create_dir_all(&config).expect("create config dir");
  511|       |        config.push("window_state.txt");
  512|       |        std::fs::write(&config, "10 20 30").expect("write bad data");
  513|       |
  514|       |        assert!(load_window_state().is_none());
  515|       |    }
  516|       |
  517|       |    #[test]
  518|       |    fn test_load_window_state_rejects_invalid_numbers() {
  519|       |        let _lock = env_lock();
  520|       |        let temp = TempDir::new().expect("temp dir");
  521|       |        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  522|       |
  523|       |        let mut config = temp.path().join("MarkdownView");
  524|       |        std::fs::create_dir_all(&config).expect("create config dir");
  525|       |        config.push("window_state.txt");
  526|       |        std::fs::write(&config, "x y 10 20 true").expect("write bad data");
  527|       |
  528|       |        assert!(load_window_state().is_none());
  529|       |    }
  530|       |
  531|       |    #[test]
  532|       |    fn test_load_window_state_rejects_invalid_components() {
  533|       |        let _lock = env_lock();
  534|       |        let temp = TempDir::new().expect("temp dir");
  535|       |        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  536|       |
  537|       |        let mut config = temp.path().join("MarkdownView");
  538|       |        std::fs::create_dir_all(&config).expect("create config dir");
  539|       |        config.push("window_state.txt");
  540|       |
  541|       |        std::fs::write(&config, "10 y 30 40 1").expect("write bad data");
  542|       |        assert!(load_window_state().is_none());
  543|       |
  544|       |        std::fs::write(&config, "10 20 w 40 1").expect("write bad data");
  545|       |        assert!(load_window_state().is_none());
  546|       |
  547|       |        std::fs::write(&config, "10 20 30 h 1").expect("write bad data");
  548|       |        assert!(load_window_state().is_none());
  549|       |    }
  550|       |
  551|       |    #[test]
  552|       |    fn test_load_window_state_rejects_invalid_utf8() {
  553|       |        let _lock = env_lock();
  554|       |        let temp = TempDir::new().expect("temp dir");
  555|       |        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  556|       |
  557|       |        let mut config = temp.path().join("MarkdownView");
  558|       |        std::fs::create_dir_all(&config).expect("create config dir");
  559|       |        config.push("window_state.txt");
  560|       |        std::fs::write(&config, [0xFF, 0xFE, 0xFD]).expect("write bad data");
  561|       |
  562|       |        assert!(load_window_state().is_none());
  563|       |    }
  564|       |
  565|       |    #[test]
  566|       |    fn test_load_window_state_parses_maximized_true() {
  567|       |        let _lock = env_lock();
  568|       |        let temp = TempDir::new().expect("temp dir");
  569|       |        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  570|       |
  571|       |        let mut config = temp.path().join("MarkdownView");
  572|       |        std::fs::create_dir_all(&config).expect("create config dir");
  573|       |        config.push("window_state.txt");
  574|       |        std::fs::write(&config, "10 20 300 400 true").expect("write data");
  575|       |
  576|       |        let loaded = load_window_state().expect("load");
  577|       |        assert!(loaded.maximized);
  578|       |    }
  579|       |
  580|       |    #[test]
  581|       |    fn test_load_window_state_returns_none_when_missing() {
  582|       |        let _lock = env_lock();
  583|       |        let temp = TempDir::new().expect("temp dir");
  584|       |        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  585|       |
  586|       |        assert!(load_window_state().is_none());
  587|       |    }
  588|       |
  589|       |    #[test]
  590|       |    fn test_config_dir_falls_back_to_xdg() {
  591|       |        let _lock = env_lock();
  592|       |        let temp = TempDir::new().expect("temp dir");
  593|       |        let _guard_appdata = EnvGuard::unset("APPDATA");
  594|       |        let _guard_home = EnvGuard::unset("HOME");
  595|       |        let _guard_xdg = EnvGuard::set("XDG_CONFIG_HOME", temp.path().to_string_lossy().as_ref());
  596|       |
  597|       |        let dir = config_dir().expect("config dir");
  598|       |        assert!(dir.starts_with(temp.path()));
  599|       |        assert!(dir.ends_with("mdmdview"));
  600|       |    }
  601|       |
  602|       |    #[test]
  603|       |    fn test_config_dir_falls_back_to_home() {
  604|       |        let _lock = env_lock();
  605|       |        let temp = TempDir::new().expect("temp dir");
  606|       |        let _guard_appdata = EnvGuard::unset("APPDATA");
  607|       |        let _guard_xdg = EnvGuard::unset("XDG_CONFIG_HOME");
  608|       |        let _guard_home = EnvGuard::set("HOME", temp.path().to_string_lossy().as_ref());
  609|       |
  610|       |        let dir = config_dir().expect("config dir");
  611|       |        assert!(dir.starts_with(temp.path()));
  612|       |        assert!(dir.ends_with(std::path::Path::new(".config").join("mdmdview")));
  613|       |    }
  614|       |
  615|       |    #[test]
  616|       |    fn test_config_dir_none_without_env() {
  617|       |        let _lock = env_lock();
  618|       |        let _guard_appdata = EnvGuard::unset("APPDATA");
  619|       |        let _guard_xdg = EnvGuard::unset("XDG_CONFIG_HOME");
  620|       |        let _guard_home = EnvGuard::unset("HOME");
  621|       |
  622|       |        assert!(config_dir().is_none());
  623|       |        let state = WindowState {
  624|       |            pos: [1.0, 2.0],
  625|       |            size: [800.0, 600.0],
  626|       |            maximized: false,
  627|       |        };
  628|       |        save_window_state(&state).expect("save ok");
  629|       |        assert!(load_window_state().is_none());
  630|       |    }
  631|       |}
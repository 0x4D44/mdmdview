# HLD: Table Border Alignment Fix

**Date**: 2026-02-06
**Status**: DRAFT
**Affects**: `src/markdown_renderer.rs` — `paint_table_dividers`, `resolve_table_rects`

## 1. Problem Statement

Content-fit tables (introduced in v1.3.0) reveal two visual defects in table
border rendering:

1. **Double right border**: Two vertical lines visible on the right edge of
   compact tables.
2. **Left border tight to text**: The left border line touches or overlaps the
   first character of text in the leftmost column.

These defects exist in ALL table rendering modes but are only visible in
content-fit mode because the table edge is in the middle of the viewport.
In viewport-fill mode, the right border is flush against the viewport edge
(hiding the second line), and the left border is at the margin (hiding
the tightness).

### Visual Evidence

Screenshot from Arthur (2026-02-06) shows three 2-column tables
(Name/Status, ID/Date, Key/State) with:
- Clear double vertical lines on the right side
- Left border overlapping the start of text content
- Possible double lines at inter-column dividers

## 2. Root Cause Analysis

### 2.1 How egui Renders Striped Row Backgrounds

egui's `TableBuilder` with `.striped(true)` paints each cell's background
individually. The stripe rect is **expanded** by half the item spacing in
all directions to fill the inter-cell gaps:

```
// egui_extras layout.rs:122-131
let gapless_rect = max_rect.expand2(0.5 * item_spacing);
ui.painter().rect_filled(gapless_rect, Rounding::ZERO, faint_bg_color);
```

For a 2-column table with `item_spacing.x = 6.0`:
- Cell 0 stripe extends from `cell0.left - 3.0` to `cell0.right + 3.0`
- Cell 1 stripe extends from `cell1.left - 3.0` to `cell1.right + 3.0`
- Adjacent stripes overlap in the 6px gap, creating seamless row shading

**The critical consequence**: the visual extent of the table (the striped
area) is `spacing/2` wider on each side than the sum of column widths.

### 2.2 How Our Border Is Positioned

`resolve_table_rects` computes the table rect used for border painting:

```
calculated_width = sum(body.widths()) + (N-1) * column_spacing
left  = layout_rect.left()        // = body.max_rect().left() = first cell's left edge
right = left + calculated_width    // = last cell's right edge + (N-1) * spacing
```

`paint_table_dividers` draws the outer border at this rect:

```
painter.rect_stroke(rect, 0.0, border_stroke);  // 1.0px stroke centered on rect
```

### 2.3 The Mismatch

For a 2-column table (widths = [150, 200], spacing = 6):

```
                 Our border rect
                 |←————————————————→|
    stripe       ↓                  ↓  stripe
    ←—3px—→|  cell0  |  6px  |  cell1  |←—3px—→
            |←—150px—→|      |←—200px—→|
            ↑                           ↑
            left                        right = left + 150 + 200 + 6 = left + 356

    Stripe extends from (left - 3) to (right + 3) = 362px total
    Border rect is from  left        to right       = 356px total
```

**Issue 1 — Double right border**: The border line is drawn at `right`.
The stripe background extends 3px beyond to `right + 3`. The visual
result is: border line → 3px of stripe color → stripe ends. This creates
two visible edges (the border + the stripe termination).

**Issue 2 — Left border tight to text**: The border is drawn at `left`,
which is exactly where cell content begins. egui cells have **no internal
padding** — text renders at the cell's left edge. The stripe extends 3px
to the LEFT of the border, but the border + text start at the same x
position.

### 2.4 Inter-Column Divider Double Lines

In content-fit mode, ALL columns use `Column::initial(width).resizable(true)`.
egui draws resize handle lines at column boundaries (between adjacent
resizable columns). Our `paint_table_dividers` also draws custom divider
lines at column midpoints:

```rust
divider_x = x + column_spacing * (idx as f32 + 0.5);
x_pos = (divider_x.round() + 0.5).clamp(rect.left(), rect.right());
```

The `.round() + 0.5` pixel-snapping may place our divider 1px away from
egui's resize handle, creating a visible double line between columns.

In viewport-fill mode, `Column::exact()` (Fixed policy) is not resizable,
so egui does NOT draw resize handles for those boundaries — only our
custom dividers are visible. No double line.

### 2.5 Why Viewport-Fill Mode Hides These Issues

In viewport-fill mode:
- The table fills the entire viewport width
- `rect.right() ≈ viewport_right` — the right border is at the screen edge
- The stripe's 3px extension is clipped by the viewport margin
- The left border is at the left margin of the content area
- Fixed columns use `Column::exact()` (not resizable) → no egui resize handles

## 3. Design

### 3.1 Fix 1: Expand Border Rect to Match Stripe Extent

In `paint_table_dividers`, compute an expanded rect that matches the
visual extent of the striped backgrounds:

```rust
let half_spacing = column_spacing * 0.5;
let border_rect = egui::Rect::from_min_max(
    egui::pos2(rect.left() - half_spacing, rect.top()),
    egui::pos2(rect.right() + half_spacing, rect.bottom()),
);
```

Use `border_rect` for:
- **Outer border**: `painter.rect_stroke(border_rect, 0.0, border_stroke)`
- **Header separator**: `painter.hline(border_rect.x_range(), ...)`
- **Expanded clip**: `clip_rect.union(border_rect)`

Keep the original `rect` for:
- **Divider loop**: `let mut x = rect.left()` — dividers must start at
  the first column's left edge, not the expanded border

This gives the border `spacing/2` padding on each side, matching the
stripe visual extent exactly.

### 3.2 Fix 2: Suppress Custom Dividers When Resize Handles Exist

Add a `draw_dividers: bool` parameter to `paint_table_dividers`. When
columns are all resizable (content-fit mode), pass `false` to suppress
custom inter-column dividers — egui's resize handles provide the visual
separation.

Call site in `render_table_tablebuilder`:

```rust
let draw_dividers = !content_fits;  // viewport-fill and hscroll need custom dividers
self.paint_table_dividers(
    &outer_painter, &outer_visuals,
    rect, clip_rect, &widths,
    header_height, column_spacing,
    draw_dividers,
);
```

In `paint_table_dividers`, gate the divider loop:

```rust
if draw_dividers && widths.len() > 1 {
    let mut x = rect.left();
    for (idx, width) in widths.iter().take(widths.len().saturating_sub(1)).enumerate() {
        // ... existing divider drawing ...
    }
}
```

### 3.3 Summary of Changes

| # | Change | Location | Lines |
|---|--------|----------|-------|
| 1 | Compute `border_rect` expanded by `column_spacing/2` horizontally | `paint_table_dividers` | ~5 |
| 2 | Use `border_rect` for outer border, header separator, clip expansion | `paint_table_dividers` | ~3 |
| 3 | Add `draw_dividers: bool` parameter | `paint_table_dividers` signature | 1 |
| 4 | Gate divider loop on `draw_dividers` | `paint_table_dividers` | 1 |
| 5 | Pass `!content_fits` as `draw_dividers` at call site | `render_table_tablebuilder` | 1 |

Total: ~11 lines changed.

## 4. Worked Examples

### 4.1 Content-Fit: 2-Column Table (Name | Status)

Before fix:
```
border   text starts
  ↓        ↓
  |Name    |  Status  |    |  ← stripe extends 3px right
  ↑        ↑          ↑    ↑
  left     divider    right stripe end
  (border touches text)    (double line: border + stripe end)
```

After fix:
```
border     text starts
  ↓          ↓
  | Name    |  Status  |  ← single clean border
  ↑          ↑          ↑
  left-3     divider    right+3
  (3px padding)         (border = stripe end → single line)
```

### 4.2 Viewport-Fill: Multi-Column Table

Before fix:
```
|Col0|Col1|Col2|Col3|Col4|Col5|Col6|  ← border at viewport edge
                                    ↑
                                    border + stripe end both at viewport edge
                                    (no visual issue — both clipped by margin)
```

After fix:
```
|Col0|Col1|Col2|Col3|Col4|Col5|Col6|  ← border shifted 3px right
                                    ↑
                                    border extends 3px into viewport margin
                                    (clipped, not visible — no behavioral change)
```

### 4.3 Hscroll: Wide Table

No change — hscroll tables scroll horizontally, and the border is inside
the scroll area. The 3px expansion is negligible relative to scroll extent.

## 5. Impact Analysis

### 5.1 Visual Impact

| Mode | Before | After |
|------|--------|-------|
| Content-fit | Double right border, tight left | Clean single border, padded text |
| Viewport-fill | No visible change | Border extends 3px into margin (imperceptible) |
| Hscroll | No visible change | Negligible 3px expansion inside scroll area |

### 5.2 Test Impact

Existing tests that check table rendering should be unaffected — the
border rect expansion is purely cosmetic and doesn't affect column widths,
row heights, or layout.

Tests that assert exact rect positions in `paint_table_dividers` (if any)
would need updating, but no such tests exist currently.

### 5.3 Risk Assessment

| Risk | Severity | Mitigation |
|------|----------|------------|
| Border too wide on tables with large spacing | Low | Spacing is typically 6-8px; expansion is 3-4px |
| Viewport-fill border extends beyond visible area | None | Clipped by parent UI clip rect |
| Custom dividers missing in content-fit mode | Low | egui resize handles provide equivalent visual |
| Resize handles style differs from custom dividers | Low | Both are subtle gray lines; visual consistency maintained |

## 6. Files to Modify

| File | Change |
|------|--------|
| `src/markdown_renderer.rs` | `paint_table_dividers`: expand border rect, add `draw_dividers` param |
| `src/markdown_renderer.rs` | `render_table_tablebuilder`: pass `draw_dividers` at call site |

## 7. Testing Strategy

1. **Automated**: Run `cargo test` — existing tests should pass unchanged
2. **Visual**: Build debug binary, open `test_stress.md`, verify:
   - 2-column tables have clean single borders on all sides
   - Left border has visible padding from text
   - Inter-column boundaries show single clean lines
   - Wide tables (viewport-fill) look unchanged
   - Column resize still works
3. **Edge cases**: Single-column table, table with 1 row, empty table

## 8. Alternatives Considered

### 8.1 Modify `resolve_table_rects` Instead

Expanding the rect in `resolve_table_rects` would affect all consumers
of the rect (e.g., `record_resolved_widths`, `persist_resizable_widths`).
This could introduce bugs in width tracking. Rejected — the expansion
is purely visual and belongs in the painting function.

### 8.2 Disable Striped Rows Expansion

Would require modifying egui source or forking egui_extras. Not practical.
The expansion is a deliberate design choice to create seamless stripes.

### 8.3 Add Cell Padding to Content

Adding padding inside cells would affect content layout, text wrapping,
and row height estimation. Too invasive for a border alignment fix.

### 8.4 Draw Custom Stripes Instead of Using egui's `.striped(true)`

Would require removing `.striped(true)` and painting backgrounds manually
in each cell. Significant complexity increase for a cosmetic fix. Could
be considered for future refactoring but not justified here.

### 8.5 Always Draw Custom Dividers (Remove Suppression)

Keep drawing custom dividers in content-fit mode. The double line would
persist between columns but would be less noticeable after the border
rect expansion. Simpler change but doesn't fully fix the visual. Could
be used as fallback if resize handles prove insufficient.

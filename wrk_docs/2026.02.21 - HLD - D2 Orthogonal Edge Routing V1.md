# HLD — D2 Orthogonal Edge Routing (V1)

**Date:** 2026-02-21
**Author:** Claude Opus 4.6 + Arthur
**Status:** Draft
**Crate:** `mdmdview-d2` (`crates/d2/`)
**Revision:** V1 — fixes critical issues found in V0 review

---

## Changelog from V0

| # | Issue in V0 | Fix in V1 |
|---|-------------|-----------|
| 1 | **RankInfo assumed a single global rank structure** — Sugiyama runs per-container (root, Services, Data Layer each have independent rank structures). Cross-container edges span multiple rank structures, making a single global `RankInfo` incorrect. | Replaced RankInfo with hierarchy-based channel computation: find LCA of src/dst, use child-ancestor bounding boxes to compute gap positions. No stored rank metadata needed. |
| 2 | **Channel position "midpoint between rank extents" could land inside a rank** — If adjacent ranks have very different sizes, the midpoint of their extents may be inside the larger rank's bounding box. | Channel X (or Y) is now computed as midpoint of the GAP between adjacent child-ancestor bounding boxes: `(src_anc.right() + dst_anc.x) / 2.0` for direction=right. |
| 3 | **Port selection ignored non-rectangular shapes** — `exit_port()` placed ports on the rectangular bounding box edge, which for clouds, diamonds, hexagons, etc. may be outside the actual shape boundary. | Added shape-aware port fallback: rectangular shapes use the direct edge placement; non-rectangular shapes use `clip_to_shape` from center toward the exit direction. |
| 4 | **Port ordering unspecified** — Without ordering ports to match destination positions, edges cross unnecessarily at source/destination shapes. | Ports are now sorted by destination cross-position before index assignment, so the topmost outgoing edge exits at the topmost port. |
| 5 | **Label on "longest segment" causes overlap** — For three-segment routes, the longest segment is often the channel (vertical for direction=right). Multiple edges sharing a gap all place labels on channel segments at similar positions → overlap. | Labels now prefer exit or enter segments (the horizontal segments for direction=right). Fall back to longest segment only if exit/enter are too short for the label text. |
| 6 | **Same-rank edge routing underspecified** — V0 showed a vague U-turn diagram but didn't specify port sides or route geometry clearly. | Added concrete five-segment route geometry for same-rank edges with direction-aware side selection. |
| 7 | **Channel sort by destination Y only** — Doesn't prevent crossings when source ordering differs from destination ordering. | Sort edges by source cross-position (Y for direction=right). This ensures vertical channel segments are ordered consistently from the source side. |
| 8 | **Axis enum referenced but never defined** — `axes()` function returns `(Axis, Axis, f64)` but `Axis` was never declared. | Removed Axis enum. Direction handling uses explicit match arms (already the pattern in `assign_coordinates`). |
| 9 | **Backward edges (against layout direction) not addressed** — V0 assumed all edges go "forward" in the layout direction. Reversed edges (cycle removal artifacts or explicitly backward edges) need different exit/enter side selection. | Added §3.8 covering backward edge routing with reversed port sides. |
| 10 | **Direction is per-container, not global** — V0's design ignored that nested containers can override direction. | LCA-based routing reads effective direction from the LCA container's direction field (or inherits from parent). |

---

## 1. Problem Statement

*(Unchanged from V0 — see original for the full architecture example and defect table.)*

The current edge routing produces diagonal Bézier curves between node centers. For diagrams with multiple cross-container edges this creates tangled bundles, overlapping labels, unnecessary crossings, and arbitrary entry/exit angles. We want orthogonal (axis-aligned) edge paths with clean right-angle turns.

---

## 2. Key Architectural Insight: Hierarchical Routing

The Sugiyama layout runs **per-container**: root lays out {lb, services, data}, Services lays out {gw, auth, orders, notify}, Data Layer lays out {pg, redis, s3}. Each container has its own direction and rank structure.

Cross-container edges (e.g., `services.auth -> data.redis`) have their actual endpoints at leaf nodes deep in the hierarchy, but at the root level they're abstracted as edges between container children (`services -> data`).

**The router must work with the hierarchy:**

1. For edge (src, dst), find their **Lowest Common Ancestor (LCA)** container
2. Find the **child-of-LCA ancestor** of src (`src_anc`) and dst (`dst_anc`)
3. Read the **effective direction** of the LCA container
4. Compute the **channel position** in the gap between `src_anc` and `dst_anc`
5. Route from the actual leaf node position through the channel to the destination

**Example trace for `auth -> redis`:**

```
auth's parent chain: auth → Services → root
redis's parent chain: redis → Data Layer → root
LCA = root
src_anc = Services (direct child of root containing auth)
dst_anc = Data Layer (direct child of root containing redis)
direction = right (root's direction)
gap_start = Services.right()    ≈ 600
gap_end   = Data Layer.x        ≈ 700
channel_x = (600 + 700) / 2     = 650
Route: auth.right_edge →(horizontal)→ 650 →(vertical)→ redis.y →(horizontal)→ redis.left_edge
```

For **intra-container edges** (e.g., `gw -> auth` within Services):

```
LCA = Services
src_anc = gw (direct child of Services)
dst_anc = auth (direct child of Services)
direction = right (Services' effective direction)
channel_x = (gw.right() + auth.x) / 2.0
Route: gw.right_edge →(horizontal)→ channel_x →(vertical)→ auth.y →(horizontal)→ auth.left_edge
```

---

## 3. Design

### 3.1 Route Shape: Three-Segment Orthogonal Path

For a hierarchical layout, the primary routing pattern is a **three-segment path**:

```
direction: right                    direction: down

  ┌─────┐                            ┌─────┐
  │ src ├──── exit ─┐                │ src │
  └─────┘           │ channel        └──┬──┘
                    │ (vertical)        │ exit
  ┌─────┐           │                   │ (vertical)
  │ dst ◄──── enter─┘            ┌──────┤ channel (horizontal)
  └─────┘                        │      │
                              ┌──▼──┐
                              │ dst │
                              └─────┘
```

**Segment definitions for `direction: right`:**

| Segment | Axis | From | To |
|---------|------|------|----|
| Exit | Horizontal (+X) | Source port (shape right edge) | Channel X |
| Channel | Vertical (±Y) | Source port Y → Destination port Y | At channel X |
| Enter | Horizontal (+X) | Channel X | Destination port (shape left edge) |

**Degenerate cases:**

- **Same cross-position** (same Y for direction=right): Channel segment has zero length → two-point straight line.
- **Same-rank edges** (src and dst at same primary position): Requires U-turn routing (see §3.7).
- **Backward edges** (dst is behind src in layout direction): Reversed port sides (see §3.8).

### 3.2 LCA Resolution and Channel Position

**No stored rank metadata needed.** The router computes channel positions on-the-fly from the graph hierarchy and final node positions.

```rust
/// Find the Lowest Common Ancestor container of two nodes.
fn find_lca(graph: &D2Graph, a: NodeIndex, b: NodeIndex) -> NodeIndex {
    // Collect ancestor chains for both nodes
    let ancestors_a: HashSet<NodeIndex> = ancestor_chain(graph, a);
    // Walk up from b until we find a node in a's ancestor set
    let mut current = b;
    loop {
        if ancestors_a.contains(&current) {
            return current;
        }
        match graph.graph[current].parent {
            Some(p) => current = p,
            None => return graph.root, // shouldn't happen in well-formed graph
        }
    }
}

/// Find the direct child of `ancestor` that contains `node`.
fn child_ancestor_of(
    graph: &D2Graph,
    node: NodeIndex,
    ancestor: NodeIndex,
) -> NodeIndex {
    let mut current = node;
    loop {
        match graph.graph[current].parent {
            Some(p) if p == ancestor => return current,
            Some(p) => current = p,
            None => return node, // node is the ancestor itself (shouldn't happen)
        }
    }
}
```

**Channel position for direction=right:**

```rust
let lca = find_lca(graph, src, dst);
let src_anc = child_ancestor_of(graph, src, lca);
let dst_anc = child_ancestor_of(graph, dst, lca);

let src_anc_rect = graph.graph[src_anc].box_.unwrap();
let dst_anc_rect = graph.graph[dst_anc].box_.unwrap();

// Gap between ancestors in the primary axis
let gap_start = src_anc_rect.right();  // right edge of src's ancestor
let gap_end = dst_anc_rect.x;          // left edge of dst's ancestor
let channel_x = (gap_start + gap_end) / 2.0;
```

**Effective direction:** Read from the LCA container:

```rust
fn effective_direction(graph: &D2Graph, container: NodeIndex) -> Direction {
    graph.graph[container].direction
        .unwrap_or_else(|| {
            // Walk up to find inherited direction
            let mut node = container;
            loop {
                if let Some(dir) = graph.graph[node].direction {
                    return dir;
                }
                match graph.graph[node].parent {
                    Some(p) => node = p,
                    None => return graph.direction, // root default
                }
            }
        })
}
```

### 3.3 Channel Allocation: Preventing Edge Overlap

When multiple edges cross the same inter-ancestor gap, their channel segments must be spaced apart.

**Algorithm:**

1. **Group edges by gap.** Two edges share a gap when they have the same LCA AND the same `(src_anc, dst_anc)` pair (or reversed pair).

2. **Sort edges within each gap by source cross-position.** For direction=right, sort by source node's center Y. This ensures vertical channel segments are ordered consistently from the source side, minimizing crossings.

3. **Assign channel primary-axis offsets.** Spread edges around the gap midpoint:

```rust
let n = edges_in_gap.len();
let total_spread = (n - 1) as f64 * CHANNEL_SPACING;
for (i, edge) in edges_in_gap.iter().enumerate() {
    edge.channel_primary = gap_midpoint - total_spread / 2.0 + i as f64 * CHANNEL_SPACING;
}
```

**Clamping:** If the spread exceeds the gap width minus `2 * MIN_STUB_LENGTH`, reduce `CHANNEL_SPACING` proportionally so edges stay within the gap.

### 3.4 Port Selection: Where Edges Attach to Shapes

**Rectangular shapes** (rectangle, square, cylinder, code): Place ports directly on the bounding box edge.

**Non-rectangular shapes** (cloud, diamond, hexagon, oval, etc.): Use `clip_to_shape()` from the node center toward a target point on the desired exit side. This produces a port on the actual shape boundary.

```rust
fn compute_port(
    graph: &D2Graph,
    node: NodeIndex,
    direction: Direction,
    port_y: f64, // cross-axis position for the port
) -> Point {
    let rect = graph.graph[node].box_.unwrap();
    let shape = graph.graph[node].shape;

    // Target point on the bounding box exit edge
    let target = match direction {
        Direction::Right => Point::new(rect.right() + 100.0, port_y),
        Direction::Left => Point::new(rect.x - 100.0, port_y),
        Direction::Down => Point::new(port_y, rect.bottom() + 100.0),
        Direction::Up => Point::new(port_y, rect.y - 100.0),
    };

    match shape {
        ShapeType::Rectangle | ShapeType::Square | ShapeType::Cylinder
        | ShapeType::Code | ShapeType::Package | ShapeType::Queue
        | ShapeType::Page | ShapeType::Step | ShapeType::StoredData => {
            // Rectangular: place directly on edge
            match direction {
                Direction::Right => Point::new(rect.right(), port_y),
                Direction::Left => Point::new(rect.x, port_y),
                Direction::Down => Point::new(port_y, rect.bottom()),
                Direction::Up => Point::new(port_y, rect.y),
            }
        }
        _ => {
            // Non-rectangular: clip from center toward exit direction
            clip_to_shape(shape, &rect, rect.center(), target)
        }
    }
}
```

**Port ordering:** When a node has N outgoing edges, sort them by destination cross-position before assigning port indices. This ensures the topmost edge exits at the topmost port, minimizing crossings at the source node.

```rust
// For direction=right: sort outgoing edges by destination center Y
outgoing_edges.sort_by(|a, b| {
    let a_dst_y = graph.graph[a.dst].box_.unwrap().center().y;
    let b_dst_y = graph.graph[b.dst].box_.unwrap().center().y;
    a_dst_y.partial_cmp(&b_dst_y).unwrap()
});

// Assign port positions evenly along the exit edge
let edge_length = src_rect.height; // for direction=right
let step = edge_length / (outgoing_edges.len() as f64 + 1.0);
for (i, edge) in outgoing_edges.iter().enumerate() {
    let port_y = src_rect.y + step * (i as f64 + 1.0);
    // ... use port_y for this edge's exit port
}
```

Same logic applies to destination entry ports: sort incoming edges by source cross-position, distribute entry ports evenly.

### 3.5 Rounded Corners

Replace sharp right-angle bends with small-radius quadratic Bézier arcs.

**At each bend point** (where two consecutive segments meet at a right angle):

```
Given segments: A→B→C (where B is the bend point)

r = min(BEND_RADIUS, |AB|/2, |BC|/2)   // clamp to half-segment

start_arc = B + r * unit(A - B)    // point on segment AB, r before B
end_arc   = B + r * unit(C - B)    // point on segment BC, r after B

SVG: ... L start_arc.x start_arc.y Q B.x B.y end_arc.x end_arc.y L ...
```

**Corner radius:** `BEND_RADIUS = 5.0` pixels.

**SVG path construction for a polyline with rounded corners:**

```rust
fn polyline_with_rounded_corners(points: &[Point], radius: f64) -> String {
    let mut path = format!("M {} {}", points[0].x, points[0].y);

    for i in 1..points.len() - 1 {
        let prev = points[i - 1];
        let curr = points[i];
        let next = points[i + 1];

        // Vector from curr to prev and curr to next
        let dx1 = prev.x - curr.x;
        let dy1 = prev.y - curr.y;
        let dx2 = next.x - curr.x;
        let dy2 = next.y - curr.y;

        let len1 = (dx1 * dx1 + dy1 * dy1).sqrt();
        let len2 = (dx2 * dx2 + dy2 * dy2).sqrt();

        let r = radius.min(len1 / 2.0).min(len2 / 2.0);

        // Arc start: r pixels before the bend, along the incoming segment
        let arc_start_x = curr.x + dx1 / len1 * r;
        let arc_start_y = curr.y + dy1 / len1 * r;

        // Arc end: r pixels after the bend, along the outgoing segment
        let arc_end_x = curr.x + dx2 / len2 * r;
        let arc_end_y = curr.y + dy2 / len2 * r;

        path.push_str(&format!(
            " L {} {} Q {} {} {} {}",
            arc_start_x, arc_start_y,
            curr.x, curr.y,
            arc_end_x, arc_end_y,
        ));
    }

    // Final point
    let last = points.last().unwrap();
    path.push_str(&format!(" L {} {}", last.x, last.y));

    path
}
```

### 3.6 Route Data Format

Add `RouteType` to distinguish Bézier and orthogonal path interpretation:

```rust
// In graph.rs

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RouteType {
    /// Cubic Bézier: [start, ctrl1, ctrl2, end, ctrl1, ctrl2, end, ...]
    Bezier,
    /// Orthogonal polyline: [p0, p1, p2, ...] with line segments
    /// and automatic rounded corners at bend points.
    Orthogonal,
}

impl Default for RouteType {
    fn default() -> Self { RouteType::Bezier }
}

// In D2EdgeData — add field:
pub route_type: RouteType,
```

The SVG renderer checks `route_type`:
- `Bezier` → existing `M ... C ...` logic (unchanged)
- `Orthogonal` → `polyline_with_rounded_corners()` from §3.5

### 3.7 Same-Rank Edges (U-Turn Routing)

When src and dst are at the same primary-axis position (same rank), a three-segment route doesn't work — there's no gap in the primary axis to place a channel.

**Solution: Five-segment U-turn route.**

For direction=right, src and dst are at similar X positions. If src is above dst (src.y < dst.y):

```
  ┌─────┐
  │ src ├───┐           exit right
  └─────┘   │
             │ jog_x    vertical down
  ┌─────┐   │
  │ dst ◄───┘           enter right (← from right)
  └─────┘
```

Wait — this is just a normal three-segment route where the "channel" X is to the RIGHT of both nodes (since they're at the same rank, we jog out to the right).

```
jog_x = max(src.right(), dst.right()) + SAME_RANK_JOG_DISTANCE
```

Route: `[src_port, (jog_x, src_port.y), (jog_x, dst_port.y), dst_port]`

This is a standard three-segment route but with the channel beyond both nodes rather than between them.

For the case where we want to route left (away from the layout direction) to avoid colliding with nodes to the right:

```
jog_x = min(src.x, dst.x) - SAME_RANK_JOG_DISTANCE
```

**Choice heuristic:** Route in whichever direction has more open space. For now, default to the cross-axis jog (route rightward/downward from the exit side).

**Constant:** `SAME_RANK_JOG: f64 = 30.0` — distance beyond the node for the jog segment.

### 3.8 Backward Edges

When src is further along the primary axis than dst (e.g., src.x > dst.x for direction=right), the edge goes "backward" against the layout direction.

**Port sides are reversed:**
- Exit from the LEFT side of src (against direction)
- Enter from the RIGHT side of dst (against direction)

**Channel position:** Midpoint of gap from dst_anc's right edge to src_anc's left edge.

**Detection:**

```rust
let forward = match direction {
    Direction::Right => src_anc_rect.center().x < dst_anc_rect.center().x,
    Direction::Left  => src_anc_rect.center().x > dst_anc_rect.center().x,
    Direction::Down  => src_anc_rect.center().y < dst_anc_rect.center().y,
    Direction::Up    => src_anc_rect.center().y > dst_anc_rect.center().y,
};
```

If not forward, swap the exit/enter sides and compute the channel in the reversed gap.

### 3.9 Label Placement

Labels are placed on an **exit or enter segment** (not the channel segment), to avoid overlap when multiple edges share a gap.

**Algorithm:**

1. Identify the exit segment (first segment of route) and enter segment (last segment)
2. Compute label text width: `label.len() * char_width` (approximate)
3. If exit segment is long enough for the label (length > label_width + padding): place label at exit segment midpoint
4. Else if enter segment is long enough: place label at enter segment midpoint
5. Else: fall back to longest segment midpoint

**Offset:** Shift label perpendicular to the segment by `LABEL_OFFSET` (10px). For horizontal segments, shift Y upward. For vertical segments, shift X to the left (to avoid the label sitting on the line).

### 3.10 SVG Renderer Changes

`svg_render.rs::render_edges()` adds a branch for orthogonal routes:

```rust
// Build SVG path
let path_str = match edge.route_type {
    RouteType::Bezier => {
        // existing cubic Bézier path construction (unchanged)
        build_bezier_path(&edge.route)
    }
    RouteType::Orthogonal => {
        polyline_with_rounded_corners(&edge.route, BEND_RADIUS)
    }
};
```

Arrowhead rendering uses the last two points of the route for direction — works correctly for both Bézier and orthogonal since the last segment is always axis-aligned.

### 3.11 Interaction with Existing Features

| Feature | Impact |
|---------|--------|
| **Self-loops** | Unchanged. Keep `RouteType::Bezier` and existing `self_loop_route()`. |
| **Parallel edges** | Sorted and allocated separate channel positions via §3.3. |
| **Animated/dashed edges** | `stroke-dasharray` works identically on polyline paths. |
| **Back-edges** | §3.8 handles reversed port sides. |
| **Shape clipping** | Replaced by `compute_port()` (§3.4) for orthogonal routes. `clip_to_shape` retained for non-rectangular port computation and Bézier fallback. |
| **Direction overrides** | `effective_direction()` (§3.2) reads per-container direction from the LCA. |
| **ViewBox** | `compute_viewbox` already includes all route points. Orthogonal routes produce axis-aligned bounding boxes (no Bézier overshoot). |

---

## 4. Implementation Plan

### Phase 1: Data Model Changes (Small)

**Files:** `graph.rs`

1. Add `RouteType` enum (default: `Bezier`)
2. Add `route_type: RouteType` field to `D2EdgeData`

**Tests:** Existing tests compile and pass unchanged (default is `Bezier`).

### Phase 2: Hierarchy Utilities (Small)

**Files:** `edge_routing.rs`

1. Implement `find_lca(graph, src, dst) -> NodeIndex`
2. Implement `child_ancestor_of(graph, node, ancestor) -> NodeIndex`
3. Implement `effective_direction(graph, container) -> Direction`

**Tests:**
- `find_lca` returns root for nodes in different top-level containers
- `find_lca` returns the container for sibling nodes
- `child_ancestor_of` returns the correct intermediate ancestor
- `effective_direction` inherits from parent when container has no override

### Phase 3: Orthogonal Router (Core)

**Files:** `edge_routing.rs`

1. Add `route_orthogonal_edges(graph)` — the main orthogonal routing function
2. Implement:
   - LCA + child-ancestor lookup per edge
   - Channel position computation from ancestor bounding boxes
   - Forward/backward detection
   - Port selection with multi-port spacing and sort-by-destination
   - Three-segment path generation for all four directions
   - Same-rank U-turn routing
3. Channel allocation: group edges by gap, sort by source cross-position, assign offsets
4. Update `route_all_edges()` to call `route_orthogonal_edges()` for all non-self-loop edges

**Tests:**
- `a -> b` (direction=right): straight horizontal line
- `a -> b` (direction=down): straight vertical line
- Cross-rank with offset: 4-point Z-shaped route
- Same-rank: 4-point jog route
- Multiple edges same gap: channel positions spread apart
- Cross-container: channel is between container boundaries
- Self-loop: still Bézier

### Phase 4: SVG Rendering (Small)

**Files:** `svg_render.rs`

1. Add `polyline_with_rounded_corners()` function
2. Add `RouteType::Orthogonal` branch in `render_edges()`

**Tests:**
- SVG output for orthogonal edges contains `L` and `Q` commands
- Arrowheads point in correct cardinal direction

### Phase 5: Label Placement (Small)

**Files:** `edge_routing.rs`

1. Implement exit/enter-preferring label placement (§3.9)
2. Apply perpendicular offset

**Tests:**
- Label on horizontal segment, offset above the line
- Label not overlapping source or destination nodes
- Multiple edges in same gap have labels at different Y positions

---

## 5. Constants

```rust
/// Spacing between parallel channel segments in the same inter-ancestor gap.
const CHANNEL_SPACING: f64 = 12.0;

/// Minimum length for exit/enter stub segments.
const MIN_STUB_LENGTH: f64 = 15.0;

/// Radius for rounded corners at orthogonal bends.
const BEND_RADIUS: f64 = 5.0;

/// Perpendicular offset for edge labels from the path segment.
const LABEL_OFFSET: f64 = 10.0;

/// Distance beyond nodes for same-rank U-turn jog.
const SAME_RANK_JOG: f64 = 30.0;
```

---

## 6. Edge Cases

### 6.1 Long-Span Edges (Skipping Ranks)

An edge from rank 0 to rank 3 has its channel in the gap between the src and dst child-ancestors. Intermediate nodes may be in the way — the vertical channel segment could visually pass through them. This is a known limitation (§8: edge-node avoidance deferred).

### 6.2 Container Boundary Crossing

Cross-container edges route from leaf node positions through container borders to the inter-container gap. The container boundary is not explicitly modeled in the route — the edge passes through it visually. This matches the official D2 renderer.

### 6.3 All Four Directions

Direction handling uses explicit match arms (the existing pattern in `assign_coordinates`):

```rust
match direction {
    Direction::Right => {
        exit_side = right, enter_side = left,
        primary = x, cross = y
    }
    Direction::Left => {
        exit_side = left, enter_side = right,
        primary = x (negated), cross = y
    }
    Direction::Down => {
        exit_side = bottom, enter_side = top,
        primary = y, cross = x
    }
    Direction::Up => {
        exit_side = top, enter_side = bottom,
        primary = y (negated), cross = x
    }
}
```

### 6.4 Nodes with Many Edges

A node with many outgoing edges distributes ports evenly along the exit edge. Minimum port spacing clamped to `4.0px`. If the node is too small for all ports, fall back to center-port for all edges (degraded but safe).

### 6.5 Degenerate Same-Cross-Position

When source and destination have the same cross-position (same Y for direction=right), the channel segment has zero length. The route degenerates to a straight horizontal line: `[src_port, dst_port]`. No bends, no rounding needed.

---

## 7. Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| LCA computation is O(depth²) per edge | Tree depth is typically ≤ 5. Cache ancestor chains if profiling shows issues. |
| Orthogonal looks worse for simple 2-node diagrams | Degenerate case → straight line (§6.5). No visual regression. |
| Channel spread exceeds gap width | Clamp CHANNEL_SPACING so total spread ≤ gap_width - 2 * MIN_STUB_LENGTH. |
| Rounded corners overshoot on short segments | r clamped to min(segment_length / 2) at each corner. |
| Non-rectangular shape ports may produce slightly off-axis exit points | `clip_to_shape` returns the true boundary point; the first route segment adjusts accordingly. Small diagonal at shape boundary is acceptable. |
| Existing edge label tests break | Expected: label positions change from Bézier midpoint to exit/enter segment. Update test assertions. |

---

## 8. What This HLD Does NOT Address

- **Edge-node avoidance**: Long-span edges may visually pass through intermediate nodes. Requires obstacle-aware routing (visibility graph or A*). Deferred.
- **Edge crossing minimization in routing phase**: Sugiyama's crossing reduction handles node ordering; edge routing may still produce crossings. Full crossing minimization is a separate problem.
- **Container descendant stranding** (V3 HLD bug A): Layout bug, not routing. Fix independently.
- **Curved orthogonal edges**: This HLD uses polyline + rounded corners (matching official D2 aesthetic).
- **Mixed-direction containers**: When a child container has a different direction than its parent, cross-container edges may need to transition between axis orientations. For V1, use the LCA's direction for the entire route.

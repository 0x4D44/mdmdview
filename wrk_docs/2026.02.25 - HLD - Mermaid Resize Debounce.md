# HLD: Mermaid Resize Debounce

**Date**: 2026-02-25
**Status**: Draft
**Scope**: `mermaid_renderer.rs` (primary), `markdown_renderer.rs` (minor)

---

## Problem

Resizing the application window while Mermaid diagrams are visible causes severe UI sluggishness. The main thread feels blocked and the resize is hard to perform.

### Root Cause

There are two compounding problems:

**1. No debounce — every width bucket change fires a new render job**

`render_block()` runs every frame. It computes a `width_bucket` (rounded to 32px steps) and a `texture_key` that embeds the bucket. When the window is resized, the bucket changes approximately every 32 pixels of drag. Each new bucket means a new `texture_key`, which misses the texture cache, which triggers a new QuickJS render + rasterize job.

A 400px resize drag across 4 visible diagrams produces ~48 render jobs (12 buckets x 4 diagrams). The 32px bucketing provides some quantization but no temporal debounce at all.

**2. Stale results are never discarded — all complete and upload to GPU**

Old render jobs for stale width buckets continue to completion. Each result causes a `ctx.load_texture()` call on the main thread in `poll_mermaid_results()`, uploading the RGBA buffer to the GPU. A 4096x4096 diagram is ~64MB of pixel data per upload. Multiple diagrams x multiple stale widths = many synchronous GPU uploads, each stalling the frame by 10-50ms.

The bounded queue (capacity 16) limits in-flight jobs, but during resize the queue stays perpetually full because new jobs are enqueued as fast as old ones complete.

### What the User Sees

1. Window resize becomes laggy/jerky (frame stalls from GPU uploads)
2. Diagrams flash "Rendering diagram locally..." even though textures at a slightly different width already exist in cache
3. After resize settles, diagrams re-render at the final width — unnecessary delay

---

## Current Architecture

### Key Constants

| Constant | Value | Purpose |
|----------|-------|---------|
| `MERMAID_WIDTH_BUCKET_STEP` | 32 | Width quantization (pixels) |
| `MAX_MERMAID_JOBS` | 4 | Worker thread count |
| Queue capacity | 16 | `MAX_MERMAID_JOBS * 4` |
| `MERMAID_TEXTURE_CACHE_CAPACITY` | 128 | LRU texture cache entries |
| `MERMAID_SVG_CACHE_CAPACITY` | 64 | LRU SVG cache entries |

### Key Data Types

```
texture_key = "mermaid:{svg_key:016x}:w{width_bucket}:s{scale_bucket}:bg{bg_hex}"
svg_key     = hash(theme_name + ":" + code)
```

`texture_key` uniquely identifies a rendered bitmap. It changes when *any* of: diagram code, theme, width bucket, scale, or background changes. `svg_key` identifies the semantic SVG content (code + theme) and is width-independent.

### Current Frame Flow (per diagram)

```
render_block(ui, code, scale, font_size, theme)
  │
  ├─ poll_mermaid_results(ctx)          ← drains ALL completed results
  │    └─ for each result:
  │         ctx.load_texture(rgba)      ← GPU upload, BLOCKS main thread
  │         store in texture cache
  │
  ├─ compute svg_key, width_bucket, texture_key
  │
  ├─ if texture_key in texture_cache:
  │    └─ display cached texture, RETURN
  │
  ├─ if svg_key in error_cache:
  │    └─ display error, RETURN
  │
  ├─ if texture_key NOT in pending_set:
  │    ├─ build MermaidRequest (with code or cached SVG)
  │    └─ enqueue_mermaid_job(request)  ← try_send, non-blocking
  │         ├─ Ok: add to pending_set, request_repaint
  │         ├─ QueueFull: set waiting_for_slot flag
  │         └─ Disconnected: show error
  │
  └─ show placeholder ("Rendering diagram locally...")
```

### Worker Thread Flow

```
loop {
    job = job_rx.recv()           ← blocks until job available
    result = process_job(job)
    result_tx.send(result)        ← blocks until space in result channel
}

process_job(request):
    svg = request.svg OR render_svg(code)   ← QuickJS execution (slow)
    svg = apply_fixups(svg)                 ← string transforms
    (rgba, w, h) = rasterize_svg(svg, width_bucket, scale_bucket, bg)
    return MermaidResult { svg, rgba, size }
```

---

## Design

### Strategy

Two complementary changes:

**A. Debounce: suppress enqueue during resize; show stale texture as placeholder**
**B. Discard: skip GPU upload for results whose width bucket is stale**

### A. Debounce — Suppress Enqueue During Resize

#### Concept

Track when the width bucket changes. When it does, start a cooldown timer. During the cooldown, don't enqueue new render jobs — instead, display the *best available* cached texture (from a nearby width bucket) scaled to fit. Only enqueue the render once the cooldown expires (meaning the resize has settled).

#### New State

Add to `MermaidRenderer`:

```rust
/// Per-diagram debounce state for resize-aware rendering.
/// Key: svg_key (u64). Tracks the last-enqueued width bucket
/// and the time when the width bucket last changed.
#[cfg(feature = "mermaid-quickjs")]
mermaid_width_debounce: RefCell<HashMap<u64, WidthDebounce>>,
```

```rust
#[cfg(feature = "mermaid-quickjs")]
struct WidthDebounce {
    /// The width bucket for which a render was last enqueued or completed.
    last_enqueued_bucket: u32,
    /// When the requested width bucket last changed from last_enqueued_bucket.
    /// None if the current bucket matches last_enqueued_bucket.
    bucket_changed_at: Option<Instant>,
}
```

#### New Constant

```rust
/// How long to wait after the last width bucket change before
/// enqueueing a re-render. Prevents flooding workers during resize.
const MERMAID_RESIZE_DEBOUNCE_MS: u64 = 150;
```

150ms is chosen because:
- Fast enough that diagrams update promptly after resize stops
- Slow enough to collapse a typical resize drag into 1-2 render requests
- Matches common UI debounce intervals (100-200ms range)

#### Modified Flow in `render_block`

After computing `svg_key`, `width_bucket`, `texture_key`:

```
1. Check texture_key in cache → hit? display, RETURN (unchanged)

2. Check error cache → hit? display, RETURN (unchanged)

3. NEW: Debounce gate
   a. Look up WidthDebounce for this svg_key
   b. If no entry exists, create one with last_enqueued_bucket = width_bucket
      (first render — no debounce needed, proceed to enqueue)
   c. If entry exists and width_bucket == last_enqueued_bucket:
      → bucket hasn't changed, proceed to enqueue normally
   d. If entry exists and width_bucket != last_enqueued_bucket:
      → bucket changed (resize in progress)
      → update bucket_changed_at to now (if not already set, or if bucket
        changed again)
      → check if elapsed >= MERMAID_RESIZE_DEBOUNCE_MS
        YES → debounce expired, update last_enqueued_bucket, proceed to enqueue
        NO  → still in cooldown:
              • find best stale texture (see below)
              • display it scaled to current width
              • request_repaint_after(remaining debounce time)
              • RETURN (do NOT enqueue)

4. Enqueue if not pending (unchanged from current logic)
```

#### Finding the Best Stale Texture

When debounce suppresses the enqueue, we need a texture to show. The texture cache is keyed by full `texture_key` (which includes `width_bucket`), so we can't do a direct lookup. Instead:

Add a helper method that scans the texture cache for any entry whose key starts with the same `svg_key` prefix and has the same scale/bg:

```rust
/// Find the best cached texture for this diagram, regardless of width bucket.
/// Returns the entry with the closest width bucket to the requested one.
fn find_nearest_texture(
    &self,
    svg_key: u64,
    scale_bucket: u32,
    bg: [u8; 4],
    target_width_bucket: u32,
) -> Option<(MermaidTextureEntry, u32)>  // (entry, its width_bucket)
```

Implementation: iterate `mermaid_textures` entries, parse the texture_key to extract the width_bucket component, pick the one closest to `target_width_bucket`. This is O(n) over cached entries but n ≤ 128 and it only runs during active resize.

**Alternative (simpler, preferred)**: Maintain a secondary index — a `HashMap<u64, String>` mapping `svg_key → most recent texture_key` — updated whenever a texture is stored. During debounce, look up this key and display that texture scaled. This is O(1) and avoids parsing keys.

```rust
/// Maps svg_key → the texture_key of the most recently stored texture.
/// Used during resize debounce to find a stale-but-displayable texture.
#[cfg(feature = "mermaid-quickjs")]
mermaid_latest_texture: RefCell<HashMap<u64, String>>,
```

Updated in `store_mermaid_texture`:
```rust
fn store_mermaid_texture(&self, key: &str, texture: TextureHandle, size: [u32; 2], svg_key: u64) {
    self.mermaid_textures.borrow_mut().insert(key.to_string(), MermaidTextureEntry { texture, size });
    self.mermaid_latest_texture.borrow_mut().insert(svg_key, key.to_string());
}
```

During debounce, look up `mermaid_latest_texture[svg_key]`, then look up that key in `mermaid_textures`. The existing display logic (lines 759-769) already scales the texture to fit `available_width`, so the stale texture will appear at the correct width — just potentially slightly blurry or slightly cropped at the edges. This is imperceptible during a fast drag.

#### Debounce Reset

When `clear_mermaid_cache()` is called (e.g., theme change), also clear `mermaid_width_debounce` and `mermaid_latest_texture`.

### B. Discard Stale Results in `poll_mermaid_results`

Even with debounce, some stale jobs may already be in the queue when debounce kicks in. We want to skip the expensive GPU upload for results whose width bucket no longer matches what's needed.

#### Concept

When processing a `MermaidResult`, check if the `width_bucket` encoded in the `texture_key` still matches what the UI currently needs. If it doesn't, cache the SVG (cheap) but skip the RGBA upload (expensive).

#### Problem: We Don't Know the "Current" Width

`poll_mermaid_results` runs at the start of `render_block`, before the per-diagram render loop. It doesn't know what width each diagram will need this frame. We need a lightweight way to check staleness.

#### Solution: Track the "wanted" Width Bucket

Add a per-diagram tracking map:

```rust
/// The width bucket that was most recently *requested* for each svg_key.
/// Updated every frame in render_block before the debounce gate.
/// Used by poll_mermaid_results to detect stale results.
#[cfg(feature = "mermaid-quickjs")]
mermaid_wanted_bucket: RefCell<HashMap<u64, u32>>,
```

In `render_block`, after computing `width_bucket`:
```rust
self.mermaid_wanted_bucket.borrow_mut().insert(svg_key, width_bucket);
```

This is updated *every frame*, even during debounce (since we still compute the bucket, we just don't enqueue).

#### Modified `poll_mermaid_results`

```rust
fn poll_mermaid_results(&self, ctx: &egui::Context) -> bool {
    let mut changed = false;
    while let Ok(result) = self.mermaid_result_rx.try_recv() {
        let MermaidResult { svg_key, texture_key, svg, rgba, size, error } = result;
        self.mermaid_pending.borrow_mut().remove(&texture_key);

        // Always cache the SVG — it's content-addressed and width-independent
        if let Some(svg) = svg {
            self.mermaid_svg_cache.borrow_mut().insert(svg_key, svg);
            self.mermaid_errors.borrow_mut().remove(&svg_key);
        }

        // NEW: Check if this result's width bucket is still wanted
        let stale = self.is_stale_result(&texture_key, svg_key);

        if stale {
            // Skip GPU upload — this width is no longer needed
            // The SVG is already cached above, so re-render at the
            // correct width will be fast (skip QuickJS, just rasterize)
            changed = true;
            continue;
        }

        // Upload texture to GPU (existing logic, unchanged)
        if let Some(rgba) = rgba {
            if let Some((w, h)) = size {
                let img = egui::ColorImage::from_rgba_unmultiplied(
                    [w as usize, h as usize], &rgba
                );
                let tex = ctx.load_texture(
                    texture_key.clone(), img, egui::TextureOptions::LINEAR
                );
                self.store_mermaid_texture(&texture_key, tex, [w, h], svg_key);
                self.mermaid_texture_errors.borrow_mut().remove(&texture_key);
            }
        }

        if let Some(err) = error { /* unchanged */ }
        changed = true;
    }
    changed
}
```

#### Staleness Check

```rust
/// Returns true if the result's width bucket no longer matches
/// what the UI currently wants for this diagram.
fn is_stale_result(&self, texture_key: &str, svg_key: u64) -> bool {
    // Extract width_bucket from texture_key
    // Format: "mermaid:{hex}:w{bucket}:s{scale}:bg{hex}"
    let result_bucket = Self::parse_width_from_texture_key(texture_key);
    let wanted_bucket = self.mermaid_wanted_bucket.borrow().get(&svg_key).copied();
    match (result_bucket, wanted_bucket) {
        (Some(rb), Some(wb)) => rb != wb,
        _ => false, // Can't determine staleness, process normally
    }
}

/// Parse the width bucket from a texture key string.
fn parse_width_from_texture_key(key: &str) -> Option<u32> {
    // "mermaid:0123456789abcdef:w320:s100:bgFFFFFFFF"
    //                           ^^^^
    let w_start = key.find(":w")? + 2;
    let w_end = key[w_start..].find(':')? + w_start;
    key[w_start..w_end].parse().ok()
}
```

---

## Interaction Between A and B

The two mechanisms work together but handle different phases:

| Phase | Debounce (A) | Discard (B) |
|-------|--------------|-------------|
| Resize starts, bucket changes | Suppresses new enqueues | N/A — no new results yet |
| Jobs already in queue when resize started | N/A — already enqueued | Skips GPU upload for stale widths |
| Resize settles, debounce expires | Enqueues at final width | Results at final width pass through |
| Initial render (no resize) | No-op (bucket matches) | No-op (nothing stale) |

Without A, the queue keeps filling with new jobs during resize. Without B, pre-existing jobs waste GPU bandwidth. Both are needed.

---

## Edge Cases

### First render of a diagram
No `WidthDebounce` entry exists → create one → proceed directly to enqueue. No debounce delay on first render.

### Scale change (zoom) without width change
`scale_bucket` changes but `width_bucket` doesn't → `texture_key` changes, cache miss → normal enqueue path. Debounce only gates on width changes, so zoom is not affected.

### Theme change
`clear_mermaid_cache()` clears textures, SVG cache, and errors. Also clears `mermaid_width_debounce`, `mermaid_latest_texture`, and `mermaid_wanted_bucket` so diagrams re-render fresh.

### Multiple diagrams visible
Each diagram has its own `svg_key` and therefore its own independent debounce state. They don't interfere with each other.

### Window maximize / snap (instant large resize)
Single bucket change → debounce timer starts → 150ms later, enqueue fires. The stale texture displays during the 150ms gap, which is fine because maximize is a single step, not a drag.

### Debounce timer and `request_repaint_after`
During debounce, we call `ui.ctx().request_repaint_after(remaining)` so the frame loop wakes up when the timer expires. This avoids polling.

### `poll_mermaid_results` runs before per-diagram renders
`mermaid_wanted_bucket` is populated by `render_block` calls. On the very first frame after a resize, the wanted buckets may be from the *previous* frame. This is fine — the wanted bucket from the previous frame is still the "most recent" information, and it changes monotonically during resize. A one-frame lag in staleness detection doesn't cause correctness issues; at worst, one stale result gets uploaded before subsequent ones are skipped.

### Screenshot mode
Screenshot mode renders a single frame with fixed dimensions. No resize happens, so debounce never activates. No behavioral change.

---

## Files Changed

| File | Changes |
|------|---------|
| `src/mermaid_renderer.rs` | Add `WidthDebounce` struct, 3 new `RefCell<HashMap>` fields, debounce gate in `render_block`, staleness check in `poll_mermaid_results`, `parse_width_from_texture_key`, `find_nearest_texture` or `mermaid_latest_texture` index, update `store_mermaid_texture` signature, update `clear_mermaid_cache` |
| `src/markdown_renderer.rs` | Update `clear_mermaid_cache` call if signature changes |

No changes to `app.rs`, `window_state.rs`, or any Python tools.

---

## Constants to Tune

| Constant | Proposed Value | Rationale |
|----------|---------------|-----------|
| `MERMAID_RESIZE_DEBOUNCE_MS` | 150 | Balances responsiveness vs. flood suppression |
| `MERMAID_WIDTH_BUCKET_STEP` | 32 (unchanged) | Still useful for cache reuse across small wiggles |

The debounce interval is the primary tuning knob. Lower values = more responsive but less flood suppression. 150ms should feel instant to users (resize lag is perceptible above ~300ms).

---

## Tests

### New Tests

1. **`test_debounce_suppresses_enqueue_during_resize`** — Render at width A, then width B within debounce window. Verify no new job enqueued for width B. Verify stale texture from width A is displayed.

2. **`test_debounce_fires_after_cooldown`** — Render at width A, change to width B, wait > debounce interval, render again. Verify job enqueued for width B.

3. **`test_debounce_resets_on_continued_resize`** — Change width A→B→C within debounce window. Verify debounce timer resets on B→C transition. Only one job fires (for width C) after final cooldown.

4. **`test_stale_result_skips_gpu_upload`** — Enqueue job at width A, change wanted bucket to B, deliver result for A. Verify no `load_texture` call, but SVG is cached.

5. **`test_stale_result_caches_svg`** — Same as above, verify SVG cache populated even though texture upload skipped.

6. **`test_first_render_no_debounce_delay`** — First render of a new diagram proceeds immediately without debounce.

7. **`test_theme_change_clears_debounce_state`** — Call `clear_mermaid_cache()`, verify debounce maps are empty.

8. **`test_parse_width_from_texture_key`** — Unit test for key parsing with various formats.

9. **`test_latest_texture_index_updated_on_store`** — Verify `mermaid_latest_texture` maps svg_key to most recent texture_key.

### Modified Tests

Any test that calls `store_mermaid_texture` will need to pass the additional `svg_key` parameter.

---

## Alternatives Considered

### Increase width bucket step to 128px or 256px
Would reduce the number of re-renders during resize, but also means diagrams look noticeably wrong (up to 256px too wide/narrow) even after resize settles. Doesn't address the stale-result GPU upload problem. Rejected.

### Cancel in-flight jobs via a shared AtomicBool
Workers would check a "cancel" flag periodically during QuickJS execution. However, QuickJS doesn't support cooperative cancellation — `render_svg` is a single blocking call into the JS runtime. We'd need to interrupt from outside, which risks leaving the runtime in an invalid state. Rejected as too complex for the benefit.

### Drain and discard the entire job queue on resize
Replace the bounded channel with one that supports `drain()`. When width changes, drain all pending jobs. Simple but loses jobs for *other* diagrams that haven't changed width. Also doesn't help with jobs already being processed by workers. Rejected.

### Rate-limit `poll_mermaid_results` to 1 result per frame
Would spread GPU uploads across frames, reducing per-frame stalls. But still uploads stale textures. Could be combined with the discard mechanism as an additional refinement, but the discard alone is simpler and more effective. Deferred — can add later if needed.

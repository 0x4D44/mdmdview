# Implementation Plan: Content-Driven Table Width

**Date**: 2026-02-05
**Design**: `wrk_docs/2026.02.05 - HLD - Content-Driven Table Width.md` (V3)
**Approach**: TDD — write tests first, then implement to pass them

## Overview

Four stages, each independently compilable and committable:

| Stage | What | Tests | Lines | Risk |
|-------|------|-------|-------|------|
| 1 | New estimation functions + unit tests | 6 new | ~60 | None — no behavior change |
| 2 | Wire up content-fit mode in renderer | Existing pass | ~50 | Medium — visual change |
| 3 | Visual verification + constant tuning | Manual | ~5 | Low — cosmetic adjustments |
| 4 | Release build + version bump | Full suite | ~2 | Low |

---

## Stage 1: Estimation Functions (TDD)

**Goal**: Add `estimate_natural_column_widths` and `natural_table_width`
with comprehensive unit tests. No behavior change yet — functions exist
but aren't called from the rendering path.

### 1a. Write failing tests (RED)

File: `src/markdown_renderer.rs` (in `#[cfg(test)]` block, near
existing `test_estimate_table_*` tests around line ~8720)

```rust
// Test 1: Two short columns — content drives widths
#[test]
fn test_natural_widths_two_short_columns() {
    let renderer = MarkdownRenderer::new();
    let headers = vec![
        vec![InlineSpan::Text("Name".into())],
        vec![InlineSpan::Text("Status".into())],
    ];
    let stats = vec![
        ColumnStat { max_graphemes: 21, longest_word: 14, ..Default::default() },
        ColumnStat { max_graphemes: 11, longest_word: 8, ..Default::default() },
    ];
    let resolved = vec![98.0, 98.0]; // Fixed policy widths
    let widths = renderer.estimate_natural_column_widths(&stats, &headers, &resolved, 2);
    assert_eq!(widths.len(), 2);
    // Content estimate for col 0: 21 * 8.68 + 25.2 ≈ 207
    // max(207, 98) = 207
    assert!(widths[0] > 150.0, "col 0 should be content-driven, got {}", widths[0]);
    assert!(widths[0] < 250.0);
    // Content estimate for col 1: 11 * 8.68 + 25.2 ≈ 121
    // max(121, 98) = 121
    assert!(widths[1] > 100.0, "col 1 should be content-driven, got {}", widths[1]);
    assert!(widths[1] < 160.0);
}

// Test 2: Policy width wins when content is short
#[test]
fn test_natural_widths_uses_max_of_content_and_policy() {
    let renderer = MarkdownRenderer::new();
    let headers = vec![vec![InlineSpan::Text("ID".into())]];
    let stats = vec![
        ColumnStat { max_graphemes: 3, longest_word: 3, ..Default::default() },
    ];
    let resolved = vec![98.0]; // Fixed "ID" width
    let widths = renderer.estimate_natural_column_widths(&stats, &headers, &resolved, 1);
    // Content: 3 * 8.68 + 25.2 ≈ 51 → clamped to MIN ~56
    // max(56, 98) = 98 → policy wins
    assert!((widths[0] - 98.0).abs() < 1.0, "policy should win, got {}", widths[0]);
}

// Test 3: Clamp to MIN and MAX bounds
#[test]
fn test_natural_widths_clamped_to_bounds() {
    let renderer = MarkdownRenderer::new();
    let body_px = renderer.font_sizes.body; // 14.0
    let min_col = body_px * 4.0;  // 56
    let max_col = body_px * 35.0; // 490

    // Tiny content, tiny policy → clamped to MIN
    let headers = vec![vec![InlineSpan::Text("X".into())]];
    let stats = vec![
        ColumnStat { max_graphemes: 1, longest_word: 1, ..Default::default() },
    ];
    let widths = renderer.estimate_natural_column_widths(&stats, &headers, &[20.0], 1);
    assert!(widths[0] >= min_col - 0.5, "should be at least MIN, got {}", widths[0]);

    // Huge content → clamped to MAX
    let stats_huge = vec![
        ColumnStat { max_graphemes: 200, longest_word: 30, ..Default::default() },
    ];
    let widths_huge = renderer.estimate_natural_column_widths(&stats_huge, &headers, &[84.0], 1);
    assert!(widths_huge[0] <= max_col + 0.5, "should be at most MAX, got {}", widths_huge[0]);
}

// Test 4: natural_table_width sums correctly
#[test]
fn test_natural_table_width_sums_correctly() {
    assert_eq!(MarkdownRenderer::natural_table_width(&[100.0, 200.0], 6.0), 306.0);
    assert_eq!(MarkdownRenderer::natural_table_width(&[100.0], 6.0), 100.0);
    assert_eq!(MarkdownRenderer::natural_table_width(&[], 6.0), 0.0);
    assert_eq!(MarkdownRenderer::natural_table_width(&[50.0, 60.0, 70.0], 10.0), 200.0);
}

// Test 5: content_fits logic — small table
#[test]
fn test_content_fit_mode_activated_for_small_table() {
    let renderer = MarkdownRenderer::new();
    let headers = vec![
        vec![InlineSpan::Text("Name".into())],
        vec![InlineSpan::Text("Status".into())],
    ];
    let stats = vec![
        ColumnStat { max_graphemes: 6, longest_word: 6, ..Default::default() },
        ColumnStat { max_graphemes: 6, longest_word: 6, ..Default::default() },
    ];
    let resolved = vec![98.0, 98.0];
    let widths = renderer.estimate_natural_column_widths(&stats, &headers, &resolved, 2);
    let total = MarkdownRenderer::natural_table_width(&widths, 6.0);
    // Both columns ~98px (policy wins), total ≈ 202
    assert!(total < 1100.0, "small table should be content-fit");
    let content_fits = total < 1100.0 - 0.5;
    assert!(content_fits);
}

// Test 6: content_fits = false for wide table
#[test]
fn test_viewport_fill_mode_for_wide_table() {
    let renderer = MarkdownRenderer::new();
    let mut headers = Vec::new();
    let mut stats = Vec::new();
    let mut resolved = Vec::new();
    for i in 0..9 {
        headers.push(vec![InlineSpan::Text(format!("Col{}", i))]);
        stats.push(ColumnStat { max_graphemes: 20, longest_word: 10, ..Default::default() });
        resolved.push(133.0);
    }
    let widths = renderer.estimate_natural_column_widths(&stats, &headers, &resolved, 9);
    let total = MarkdownRenderer::natural_table_width(&widths, 6.0);
    // 9 columns × ~199px + 8*6 spacing ≈ 1839px
    assert!(total > 1100.0, "wide table should exceed viewport, got {}", total);
    let content_fits = total < 1100.0 - 0.5;
    assert!(!content_fits);
}
```

### 1b. Implement functions (GREEN)

File: `src/markdown_renderer.rs` (near existing `estimate_table_*`
functions around line ~4700)

**`estimate_natural_column_widths`** (~30 lines):
- Method on `MarkdownRenderer` (needs `self.font_sizes.body`)
- Per HLD §5.1 algorithm: for each column, compute content estimate
  from `unicode_width(header_text)` and `stats.max_graphemes`, take
  `max(content, resolved)`, clamp to `[MIN, MAX]`
- Uses `header_text()` helper from `column_spec.rs` — already `pub`?
  Check; if not, extract text inline using the same span-walking logic

**`natural_table_width`** (~5 lines):
- Associated function (no `self`), or free function
- Sum of widths + inter-column spacing

**Implementation notes**:
- Import `unicode_width::UnicodeWidthStr` (already in column_spec.rs;
  check if imported in markdown_renderer.rs — likely yes via
  `use unicode_width::*`)
- `header_text` is defined in `column_spec.rs` as `fn header_text(spans: &[InlineSpan]) -> String`.
  It's `pub(super)` or private. If private, either make it `pub(crate)`,
  or inline the text extraction (simple: iterate spans, concatenate text).
  Prefer making it `pub(crate)` since we're in the same crate.

**Commit**: "feat: add estimate_natural_column_widths and natural_table_width"

---

## Stage 2: Wire Up Content-Fit Mode

**Goal**: Modify `render_table_tablebuilder` to use the new functions
and implement two-mode rendering. This is the behavioral change.

### 2a. Preparation — verify existing tests pass

Run `cargo test` to establish baseline. All ~887 tests should pass.

### 2b. Modify `render_table_tablebuilder` (4 changes from HLD §5.3)

File: `src/markdown_renderer.rs`, function starting at line ~4106.

**Change 1** — Compute natural widths (after `resolve_table_column_widths`,
before `min_widths` computation, around line 4133):

```rust
// Rename existing `available_width` to `viewport_width`
let viewport_width = ui.available_width().max(1.0);

// NEW: compute content-driven widths
let natural_widths = self.estimate_natural_column_widths(
    &column_stats, headers, &resolved_widths, column_specs.len(),
);
let natural_total = Self::natural_table_width(&natural_widths, column_spacing);
let effective_width = natural_total.min(viewport_width);
let content_fits = effective_width < viewport_width - 0.5;
```

Also update all subsequent references from `available_width` →
`viewport_width` within the function body (~8 occurrences):
- `available_for_columns` computation (line ~4142)
- `content_width` computation (line ~4158-4159)
- hscroll render path (if any direct reference)

**Change 2** — Add content-fit branch in column layout (line ~4190):

Insert `else if content_fits { ... }` branch between `use_hscroll` and
the existing viewport-fill branch. Per HLD §5.3 Change 2.

Key: all columns use `Column::initial(natural_width).resizable(true)`.
Extract `clip` flag from policy. No `Column::remainder()`.

**Change 3** — Add content-fit branch in render dispatch (line ~4499):

```rust
if use_hscroll {
    // ... existing ...
} else if content_fits {
    render_table(ui, effective_width);
} else {
    render_table(ui, viewport_width);
}
```

**Change 4** — Fix row height estimation inside `render_table` closure
(line ~4299):

```rust
let approx_widths = if content_fits {
    natural_widths.clone()
} else {
    self.estimate_table_row_widths(
        &column_specs, &resolved_widths, &adjusted_widths,
        available_for_columns, min_floor, use_hscroll, scaled_down,
    )
};
```

The closure must capture `content_fits` (Copy) and `natural_widths`
(Vec<f32>, moved or cloned). Since the closure already captures many
outer variables, this is straightforward.

### 2c. Verify — run full test suite

```bash
cargo test
```

All existing tests must pass. The viewport-fill path is unchanged, so
tests using `force_table_policies` or wide tables should be unaffected.

Tests using `with_test_ui` have a 1024px viewport. Tables with few
columns will now enter content-fit mode. This may cause
`test_render_table_tablebuilder_variants` or similar tests to produce
different column widths. If so, update assertions to match new behavior
(narrower tables are correct, not a regression).

**Specifically watch for**:
- `test_render_table_tablebuilder_variants` (line ~10168)
- `test_render_table_tablebuilder_policy_mix` (line ~10658)
- `test_render_table_tablebuilder_scaled_down*` tests
- `test_render_table_tablebuilder_hscroll` (should be unaffected)

### 2d. Fix any failing tests

Likely adjustments:
- Tests that assert exact column widths may need tolerance for
  content-fit mode widths
- Tests that check `ui.min_rect().width()` may see narrower tables
- Tests that force policies and expect Remainder expansion need the
  table content to exceed viewport width to trigger viewport-fill mode

Strategy: if a test fails because content-fit mode activates on a
previously viewport-fill table, either:
1. Add enough columns/content to exceed 1024px (the test viewport), or
2. Update the test to verify content-fit behavior instead

**Commit**: "feat: implement content-driven table width (two-mode rendering)"

---

## Stage 3: Visual Verification + Tuning

**Goal**: Build debug, run the app, verify tables look right, tune
constants if needed.

### 3a. Build debug

```bash
cargo build
```

### 3b. Visual verification

Open the app with `test_stress.md` and verify:
- 2-column tables (`| Name | Status |`) are compact, not full-width
- 2-column tables are not squished-left (container matches content)
- Wide tables (many columns) still fill viewport normally
- Tables with long descriptions wrap appropriately
- Zoom in/out — tables scale proportionally
- Column resize still works (drag column borders)
- Horizontal scroll still works for very wide tables

Use `mdscreensnap` to capture before/after screenshots.

### 3c. Tune constants (if needed)

If columns appear too narrow or too wide, adjust in
`estimate_natural_column_widths`:

| Constant | Tune if... | Direction |
|----------|-----------|-----------|
| `CHAR_WIDTH_FACTOR` (0.62) | Columns too narrow for text | Increase to 0.65-0.70 |
| `CELL_PADDING` (1.8) | Not enough breathing room | Increase to 2.0-2.2 |
| `MIN_COL_WIDTH` (4.0) | Tiny columns look bad | Increase to 5.0 |
| `MAX_COL_WIDTH` (35.0) | Long text columns too wide/narrow | Adjust range |

**Commit** (only if constants changed): "fix: tune content-driven table width constants"

---

## Stage 4: Release Build + Version Bump

### 4a. Version bump

File: `Cargo.toml`
- `1.2.0` → `1.3.0` (minor: new feature — content-driven table sizing)

### 4b. Release build

```bash
cargo build --release
```

### 4c. Final test run

```bash
cargo test
cargo clippy
```

Zero warnings required.

### 4d. Visual smoke test with release binary

Open release binary, load `test_stress.md`, verify tables render
correctly.

**Commit**: "chore: version bump 1.2.0 → 1.3.0"

---

## Dependency Graph

```
Stage 1 ──► Stage 2 ──► Stage 3 ──► Stage 4
  (funcs)    (wire up)   (verify)    (release)
```

Each stage produces a working, compilable, testable build. If issues
are found in Stage 3, iterate on Stage 2 without affecting Stage 1.

## Key Files

| File | Stages | Changes |
|------|--------|---------|
| `src/markdown_renderer.rs` | 1, 2 | New functions, modified render_table_tablebuilder |
| `src/table_support/column_spec.rs` | 1 | Make `header_text` pub(crate) if needed |
| `Cargo.toml` | 4 | Version bump |
| `test_stress.md` | 3 | Visual test cases (already has 2-col tables) |

## Rollback Plan

If content-fit mode causes unexpected regressions:
1. The mode is gated by `content_fits` flag
2. Disable by changing `let content_fits = false;` — instant rollback
   to viewport-fill-only behavior
3. The estimation functions remain available for future use

# HLD — D2 Edge Label Placement Fix

Date: 2026.02.21

## Problem Statement

Edge labels in our D2 renderer frequently overlap node boxes. Two root causes:

1. **Label position is computed from the enter segment only.** The current `compute_label_position()` uses the midpoint of the *last segment before the destination*, with a fixed 10px perpendicular offset. For multi-segment routes, the enter segment is typically short (it's the stub from the channel into the destination port), so the label lands right on top of or inside the destination node.

2. **Label dimensions are not considered during placement.** The routing code emits a bare `Point` for the label center, but never checks whether the label's bounding box (text width × height) will intersect any node. The SVG renderer estimates label size at render time (`char_width = font_size * 0.55`) but by then it's too late to move anything.

### Visual evidence

**Screenshot 1** (horizontal architecture): Labels "HTTPS", "verify", "sessions", "route", "CRUD" all overlap their destination boxes. The labels are placed on the short enter stub that goes directly into the box.

**Screenshot 2** (vertical platform): The "route" label between API Gateway and Service overlaps the API Gateway box.

### How D2 official handles this

D2's Dagre layout places labels at a **percentage along the total route** (default 50% = midpoint). The `lib/label` package computes position by walking the polyline from start to the target percentage of total arc length, then offsets perpendicular. Labels end up in the inter-rank gap where there is space, not near either endpoint.

## Current Code (what we're changing)

File: `crates/d2/src/edge_routing.rs`, lines 711–744.

```rust
fn compute_label_position(route: &[Point]) -> Option<Point> {
    if route.len() < 2 { return None; }

    // BUG: selects the enter segment (last segment)
    let (a, b) = if route.len() == 2 {
        (route[0], route[1])
    } else {
        let n = route.len();
        (route[n - 2], route[n - 1])   // ← this is the problem
    };

    let mid = Point::new((a.x + b.x) / 2.0, (a.y + b.y) / 2.0);
    // ... fixed 10px offset ...
}
```

And the SVG renderer at `crates/d2/src/svg_render.rs`, lines 602–650, which estimates label size at render time:

```rust
let char_width = font_size * 0.55;
let label_width = label.chars().count() as f64 * char_width;
let label_height = font_size * 1.2;
```

## Design

### Change 1: Percentage-along-route placement

Replace the enter-segment heuristic with a **percentage-of-total-arc-length** approach, matching D2's strategy.

**Algorithm:**

```
fn compute_label_position(route: &[Point], percentage: f64) -> Option<Point>
    1. Compute total route length: sum of Euclidean distances between consecutive points.
    2. Target distance = total_length * percentage.
    3. Walk segments from start, accumulating distance:
       - When accumulated + segment_length >= target_distance:
         - t = (target_distance - accumulated) / segment_length
         - label_center = lerp(segment_start, segment_end, t)
         - Offset perpendicular to this segment (same axis-aware logic)
         - Return label_center
    4. Fallback: return midpoint of last segment (degenerate case).
```

The default percentage is **0.5** (route midpoint). This naturally places labels in the inter-rank channel, which is the longest segment for typical orthogonal routes.

**Why 50%:** For a 4-point orthogonal route (port → bend → bend → port), the midpoint falls on the channel segment, which is the horizontal or vertical run between the two bends — exactly the open gap between ranks where no nodes live. For a 2-point straight route, the midpoint is between the two nodes, also correct.

### Change 2: Label bounding box stored on edge data

Add label dimensions to `D2EdgeData` so the routing code can reason about overlap.

```rust
// In graph.rs — D2EdgeData
pub label_position: Option<Point>,
pub label_width: f64,    // NEW — estimated label width in pixels
pub label_height: f64,   // NEW — estimated label height in pixels
```

Compute these during routing (not at SVG render time) using the existing `text::measure_and_wrap_label()`:

```rust
// In edge_routing.rs, where we set label_position
let (label_w, label_h) = if let Some(ref label_text) = graph.graph[eidx].label {
    let m = text::measure_and_wrap_label(label_text, font_size, &options.font_family);
    (m.width, m.height)
} else {
    (0.0, 0.0)
};
graph.graph[eidx].label_width = label_w;
graph.graph[eidx].label_height = label_h;
```

The SVG renderer then uses `edge.label_width` / `edge.label_height` instead of re-estimating. This also means the halo rect is correctly sized.

### Change 3: Post-placement overlap nudge

After all labels are positioned by percentage, run a single pass to detect and fix overlaps:

```
fn nudge_overlapping_labels(graph: &mut D2Graph)
    For each edge with a label:
        Compute label_rect from (label_position, label_width, label_height)
        For each node (that is not the edge's source or destination):
            If label_rect intersects node.box_:
                Nudge label along its route segment away from the node
                (slide toward whichever direction increases clearance)
        For each other edge label already placed:
            If label_rects overlap:
                Spread apart perpendicular to the shared route direction
```

This is a safety net. The percentage placement should handle the common case; the nudge handles edge cases where the inter-rank gap is unusually small or nodes are positioned close together.

### Change 4: Perpendicular offset scales with label size

Replace the fixed `LABEL_OFFSET = 10.0` with a dynamic offset based on label height:

```rust
let offset = (label_height / 2.0) + LABEL_PADDING;
```

Where `LABEL_PADDING = 4.0` is a small gap between the label halo edge and the route line. This ensures the label's bottom edge clears the route regardless of font size.

## Detailed Changes

### `crates/d2/src/graph.rs`

Add two fields to `D2EdgeData`:

```rust
pub struct D2EdgeData {
    // ... existing fields ...
    pub label_position: Option<Point>,
    pub label_width: f64,     // NEW
    pub label_height: f64,    // NEW
}
```

Default both to `0.0` in `Default` impl.

### `crates/d2/src/edge_routing.rs`

1. **Replace `compute_label_position`** with:

```rust
/// Padding between label halo edge and route line (pixels).
const LABEL_PADDING: f64 = 4.0;

/// Compute label position at a percentage along the total route arc length.
/// Returns the label center point, offset perpendicular to the segment.
fn compute_label_position(
    route: &[Point],
    percentage: f64,
    label_height: f64,
) -> Option<Point> {
    if route.len() < 2 {
        return None;
    }

    // 1. Compute segment lengths and total.
    let mut seg_lengths: Vec<f64> = Vec::with_capacity(route.len() - 1);
    let mut total = 0.0;
    for i in 0..route.len() - 1 {
        let dx = route[i + 1].x - route[i].x;
        let dy = route[i + 1].y - route[i].y;
        let len = (dx * dx + dy * dy).sqrt();
        seg_lengths.push(len);
        total += len;
    }

    if total < 1e-6 {
        return Some(route[0]);
    }

    // 2. Walk to target distance.
    let target = total * percentage.clamp(0.0, 1.0);
    let mut accumulated = 0.0;

    for (i, &seg_len) in seg_lengths.iter().enumerate() {
        if accumulated + seg_len >= target || i == seg_lengths.len() - 1 {
            let t = if seg_len > 1e-6 {
                (target - accumulated) / seg_len
            } else {
                0.5
            };
            let a = route[i];
            let b = route[i + 1];
            let px = a.x + (b.x - a.x) * t;
            let py = a.y + (b.y - a.y) * t;

            // 3. Perpendicular offset scaled to label size.
            let dx = b.x - a.x;
            let dy = b.y - a.y;
            let offset = (label_height / 2.0) + LABEL_PADDING;

            return if dx.abs() > dy.abs() {
                // Horizontal segment: offset upward
                Some(Point::new(px, py - offset))
            } else {
                // Vertical segment: offset leftward
                Some(Point::new(px - offset, py))
            };
        }
        accumulated += seg_len;
    }

    None
}
```

2. **Update the call site** in `route_orthogonal_edges` (around line 324):

```rust
// Before:
let label_pos = if graph.graph[ec.edge_idx].label.is_some() {
    compute_label_position(&route)
} else {
    None
};

// After:
let (label_pos, label_w, label_h) = if let Some(ref label_text) = graph.graph[ec.edge_idx].label {
    let m = crate::text::measure_and_wrap_label(label_text, font_size, font_family);
    let pos = compute_label_position(&route, 0.5, m.height);
    (pos, m.width, m.height)
} else {
    (None, 0.0, 0.0)
};

graph.graph[ec.edge_idx].route = route;
graph.graph[ec.edge_idx].route_type = RouteType::Orthogonal;
graph.graph[ec.edge_idx].label_position = label_pos;
graph.graph[ec.edge_idx].label_width = label_w;
graph.graph[ec.edge_idx].label_height = label_h;
```

This requires `font_size` and `font_family` to be available in `route_orthogonal_edges`. Thread them from `route_all_edges`, which receives `RenderOptions`.

3. **Add `nudge_overlapping_labels`** after all routes are computed:

```rust
/// Post-pass: nudge labels that overlap node bounding boxes.
fn nudge_overlapping_labels(graph: &mut D2Graph) {
    // Collect all node rects (excluding root).
    let node_rects: Vec<(NodeIndex, Rect)> = graph.objects.iter()
        .filter(|&&idx| idx != graph.root)
        .filter_map(|&idx| graph.graph[idx].box_.map(|r| (idx, r)))
        .collect();

    for &eidx in &graph.edges {
        let edge = &graph.graph[eidx];
        let pos = match edge.label_position {
            Some(p) => p,
            None => continue,
        };

        let lw = edge.label_width;
        let lh = edge.label_height;
        if lw < 1.0 || lh < 1.0 {
            continue;
        }

        let pad = 3.0; // halo padding (matches SVG renderer)
        let label_rect = Rect {
            x: pos.x - lw / 2.0 - pad,
            y: pos.y - lh / 2.0 - pad,
            width: lw + pad * 2.0,
            height: lh + pad * 2.0,
        };

        // Get source/destination for this edge.
        let (src, dst) = match graph.graph.edge_endpoints(eidx) {
            Some(ep) => ep,
            None => continue,
        };

        // Check each node for overlap.
        for &(nidx, node_rect) in &node_rects {
            if nidx == src || nidx == dst {
                continue; // skip endpoints — some overlap may be acceptable
            }
            if !rects_intersect(&label_rect, &node_rect) {
                continue;
            }
            // Nudge: move label along its route segment until clear.
            // Try sliding ±5px increments along the route direction.
            // (detailed nudge logic omitted here — see implementation)
        }
    }
}
```

The nudge implementation slides the label center along the route direction (using the same segment it was placed on) in small increments until the label rect no longer intersects any non-endpoint node. If no clear position is found within the route bounds, fall back to the original position (i.e., don't make it worse).

4. **Update `route_all_edges` signature** to accept `RenderOptions`:

```rust
pub fn route_all_edges(graph: &mut D2Graph, options: &RenderOptions) {
    // ... existing self-loop logic ...
    route_orthogonal_edges(graph, &non_self_loops, options);
    nudge_overlapping_labels(graph);
}
```

### `crates/d2/src/svg_render.rs`

Update the edge label rendering to use stored dimensions instead of re-estimating:

```rust
// Before:
let char_width = font_size * 0.55;
let label_width = label.chars().count() as f64 * char_width;
let label_height = font_size * 1.2;

// After:
let label_width = if edge.label_width > 0.0 {
    edge.label_width
} else {
    label.chars().count() as f64 * font_size * 0.55  // fallback
};
let label_height = if edge.label_height > 0.0 {
    edge.label_height
} else {
    font_size * 1.2  // fallback
};
```

### `crates/d2/src/layout.rs`

The `layout()` function calls `route_all_edges`. Update to pass options through:

```rust
// Before:
edge_routing::route_all_edges(&mut graph);

// After:
edge_routing::route_all_edges(&mut graph, options);
```

## Test Plan

### Existing tests to update

These tests assert specific label positions that will change with the new algorithm. Update expected values:

- `test_label_between_nodes` — label y should still be between a.bottom and b.top (this invariant holds; the position within the gap may shift)
- `test_label_between_nodes_horizontal` — label x should still be between a.right and b.left
- `test_ortho_label_horizontal` — may need updated offset assertion
- `test_ortho_label_vertical` — may need updated offset assertion

### New tests

1. **`test_label_at_route_midpoint`** — For a 4-point route, verify the label's x (or y) coordinate is at 50% of total arc length, not at the enter segment midpoint.

2. **`test_label_clears_destination_box`** — The bug test. Set up the architecture diagram from screenshot 1. Assert that every label's bounding box does not intersect any non-endpoint node's bounding box.

3. **`test_label_clears_all_nodes`** — For each edge label, verify `label_rect ∩ node_rect == ∅` for all non-endpoint nodes. Use the architecture D2 source:
   ```
   direction: right
   lb: Load Balancer
   gw: API Gateway
   auth: Auth
   redis: Redis
   orders: Orders
   pg: PostgreSQL
   lb -> gw: HTTPS
   gw -> auth: verify
   auth -> redis: sessions
   gw -> orders: route
   orders -> pg: CRUD
   ```

4. **`test_label_dimensions_stored`** — After routing, verify `label_width > 0` and `label_height > 0` for every labeled edge.

5. **`test_label_nudge_avoids_node`** — Construct a scenario where percentage placement puts a label on top of an intermediate node, verify the nudge moves it clear.

6. **`test_parallel_labels_dont_overlap`** — Two labeled edges in the same gap should have non-overlapping label rects.

## Risk Assessment

**Low risk:** The change is confined to edge routing output. Node positions, edge routes (waypoints), and the SVG rendering pipeline are unaffected. The only output that changes is `label_position`, `label_width`, and `label_height` on `D2EdgeData`.

**Regression risk:** Existing tests that assert specific label coordinates will need updating. The invariants (label between nodes, label offset from line) should still hold — only the specific position within the gap changes.

**Performance:** Computing arc length is O(N) per edge where N is route points (typically 2–4). The nudge pass is O(E × N) where E is labeled edges and N is nodes. Both are negligible for diagrams with < 1000 edges.

## Implementation Order

1. Add `label_width` / `label_height` fields to `D2EdgeData` (graph.rs) — mechanical, no behavior change.
2. Thread `RenderOptions` through to `route_all_edges` (layout.rs, edge_routing.rs) — plumbing, no behavior change.
3. Replace `compute_label_position` with percentage-along-route — **this fixes the primary bug**.
4. Update SVG renderer to use stored dimensions — consistency fix.
5. Add `nudge_overlapping_labels` — safety net for remaining edge cases.
6. Update tests, add new tests.
7. Visual verification against the two screenshot scenarios.

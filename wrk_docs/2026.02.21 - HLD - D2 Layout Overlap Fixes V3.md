# HLD — D2 Layout Overlap Fixes (V3)

**Date:** 2026-02-21
**Author:** Claude Opus 4.6 + Arthur
**Status:** Draft
**Crate:** `mdmdview-d2` (`crates/d2/`)
**Revision:** V3 — corrects V2 offset count, completes direction-arm pseudocode, tightens implementation spec

---

## Changelog from V2

| # | Issue in V2 | Fix in V3 |
|---|-------------|-----------|
| 1 | Claims `fit_containers` causes 2x label offset (48px) — actual is 3x (72px) | Corrected analysis: each non-root container gets `fit_container` called 3 times (1 from `layout_recursive` + 2 from `fit_containers`), producing 3×24=72px |
| 2 | `assign_coordinates` "AFTER" pseudocode references `rect.width` from removed `if let` pattern | Replaced with explicit `graph.graph[node].box_.map(...)` reads |
| 3 | `arrange_in_line` fix only shows Down/Up direction | Added Right/Left branch pseudocode |
| 4 | `assign_coordinates` says "all four arms" but only shows Down | Explicit pseudocode for all four direction arms (Up/Left need height/width for negated positions) |

---

## 1. Problem Statement

Three classes of visual overlap are observed in rendered D2 diagrams:

| # | Symptom | Severity | Example |
|---|---------|----------|---------|
| A | Nodes inside sibling containers overlap in absolute coordinates | **Critical** | Backend/Frontend children pile on top of each other |
| B | Edge labels render on top of nodes instead of in the gap between ranks | Moderate | "fetch", "CRUD" labels obscure node text |
| C | Adjacent containers crowd each other; padding insufficient for dense graphs | Low | Sibling containers overlap at boundaries |

All three are **layout-phase** bugs, not rendering bugs. The SVG renderer faithfully draws what the layout produces.

---

## 2. Root Cause Analysis

### 2A. Container Descendant Stranding (Critical)

**Location:** Three call sites in `layout_sugiyama.rs` + one pre-existing bug in `layout.rs`

**Mechanism:**

The recursive layout processes containers bottom-up. After child containers are recursively laid out and fitted (`fit_container` sets their `box_` to wrap their children), the parent's Sugiyama algorithm repositions them — overwriting `box_.x` and `box_.y` while preserving width/height. But descendants inside the repositioned containers **are not shifted by the same delta**. They remain stranded at their old absolute positions.

**The bug exists in three places:**

1. **`assign_coordinates` (line 760-785)** — The primary coordinate assignment: `rect.x = cross_offset; rect.y = rank_offsets[rank_idx]`. Overwrites container positions without shifting descendants.

2. **`arrange_in_line` (line 218-237)** — Fallback for disconnected nodes: `rect.x = 0.0; rect.y = offset`. Same problem if a disconnected child is a container.

3. **Component stacking (line 117-127)** — After laying out disconnected components, each component is shifted to avoid overlap: `rect.x += shift`. Container descendants are not shifted along.

**Concrete example (from stress-test "Container Nesting"):**

```
layout_recursive(Platform):
  1. layout_recursive(Frontend) → positions {app, cdn}, fit_container → Frontend.box_ = (-30, -12, 120, 180)
  2. layout_recursive(Backend)  → positions {api, svc}, fit_container → Backend.box_ = (-30, -12, 160, 192)
  3. layout_sugiyama::layout_children(Platform):
     assign_coordinates OVERWRITES Frontend.box_ to (-60, 0, 120, 180)
     assign_coordinates OVERWRITES Backend.box_ to (-80, 240, 160, 192)
     ► Descendants {app, cdn, api, svc} still at positions from steps 1-2!
  4. fit_container(Platform) → computes bbox from Frontend+Backend (correct positions)
     but grandchildren are STRANDED near origin
```

**Why it's intermittent:** Single-level containers at root level aren't repositioned (Sugiyama runs for root's children directly). The bug manifests for nested containers (2+ levels of nesting) and for multi-component layouts where component stacking shifts containers.

### 2A2. Pre-existing `fit_containers` Triple-Call Bug

**Location:** `layout.rs:47` and `layout.rs:191-228`

After `layout_recursive` completes (which calls `fit_container` once per container), `layout()` calls `fit_containers(graph, root)` which **re-calls `fit_container` for every container in the tree, twice per container**. This causes:

1. **Triple label offset:** `fit_container` calls `offset_subtree(children, 0, CONTAINER_LABEL_HEIGHT)` to push children down and make room for the container label. The total calls per non-root container:
   - 1 from `layout_recursive`
   - 1 from `fit_containers` (the `if container != graph.root` branch at the bottom of the recursive call)
   - 1 from `fit_containers` (the `fit_container(graph, child)` in the parent's loop body, after the recursive call)
   - **Total: 3 calls → 3 × 24 = 72px instead of 24px**

2. **Position overwrite:** `fit_container` recomputes the container's `box_` from children's current positions. After Fix A propagates deltas correctly, this triple call would overwrite container positions and triple-apply the label offset.

**Impact without Fix A:** Containers are ~48px taller than necessary, with children shifted too far down. Visually manifests as excessive label-to-children gap, but doesn't cause overlap.

**Impact with Fix A if not addressed:** The extra `fit_containers` pass partially undoes Fix A's delta propagation by triple-applying the label offset, producing incorrect container sizes and child positions.

### 2B. Edge Label Placement at Bézier Midpoint

**Location:** `edge_routing.rs:119-121`

```rust
let mid = bezier_midpoint(&route);
let label_pos = Some(Point::new(mid.x, mid.y - 10.0));
```

**Gap analysis:** The rank-to-rank gap computation in `assign_coordinates` is:
```rust
rank_offset += max_size + NODE_SPACING_V;  // max_size ≈ 36-50px, NODE_SPACING_V = 60
```

For rank 0 nodes with `max_height = 36px`:
- Rank 0 bottom edge: y = 0 + 36 = 36
- Rank 1 top edge: y = 36 + 60 = 96
- **Gap = 60px**

A label is ~20px tall. With 60px of gap, the label fits with ~20px clearance on each side. **The gap is usually sufficient.**

The actual problems are:

1. **The -10px constant offset** is not centered. The Bézier parametric midpoint at t=0.5 is at y≈66 for a gap of 36→96. With -10px offset, label center is at y=56, spanning y=46→66. Top clearance: 46-36=10px. Bottom clearance: 96-66=30px. Asymmetric but not overlapping for straight edges.

2. **Diagonal edges** between nodes at different horizontal positions have Bézier midpoints that can land on nearby nodes, especially in dense graphs.

3. **After Fix A,** the label overlap seen in screenshots 1 and 3 will largely disappear because those overlaps are primarily caused by the container stranding bug. The labels appear to overlap nodes because the nodes themselves are overlapping.

### 2C. Insufficient Container Spacing

**Location:** `layout_sugiyama.rs:20-23`

```rust
const NODE_SPACING_H: f64 = 40.0;   // Between nodes in same rank
const NODE_SPACING_V: f64 = 60.0;   // Between ranks
```

Containers use the same spacing as leaf nodes. A 40px gap between two 300px-wide containers looks cramped. This is a cosmetic issue, not a correctness bug. It becomes noticeable only after Fix A resolves the stranding — until then, the overlap masks the spacing.

---

## 3. Proposed Solutions

### Fix A1: `reposition_node` — Centralized Container-Aware Repositioning

**Strategy:** Add a `reposition_node` method to `D2Graph` that computes the positional delta and shifts all descendants when a container is moved. Use it at all three call sites.

**File:** `graph.rs` (new methods on `D2Graph`)

```rust
impl D2Graph {
    /// Move a node to (new_x, new_y). If the node is a container,
    /// shift all descendants by the same delta to preserve relative positions.
    pub fn reposition_node(&mut self, node: NodeIndex, new_x: f64, new_y: f64) {
        let (dx, dy) = if let Some(ref mut rect) = self.graph[node].box_ {
            let dx = new_x - rect.x;
            let dy = new_y - rect.y;
            rect.x = new_x;
            rect.y = new_y;
            (dx, dy)
        } else {
            return;
        };

        if self.graph[node].is_container && (dx.abs() > 0.01 || dy.abs() > 0.01) {
            let children = self.graph[node].children.clone();
            Self::offset_subtree_inner(&mut self.graph, &children, dx, dy);
        }
    }

    /// Shift a node and all its descendants by (dx, dy).
    /// Use when adjusting positions relatively (e.g., component stacking).
    pub fn offset_node(&mut self, node: NodeIndex, dx: f64, dy: f64) {
        if let Some(ref mut rect) = self.graph[node].box_ {
            rect.x += dx;
            rect.y += dy;
        }
        if self.graph[node].is_container {
            let children = self.graph[node].children.clone();
            Self::offset_subtree_inner(&mut self.graph, &children, dx, dy);
        }
    }

    /// Internal recursive offset (operates on the petgraph store directly
    /// to avoid borrow conflicts with &mut self).
    fn offset_subtree_inner(
        graph: &mut petgraph::stable_graph::StableDiGraph<D2Object, D2EdgeData>,
        nodes: &[NodeIndex],
        dx: f64,
        dy: f64,
    ) {
        for &node in nodes {
            if let Some(ref mut rect) = graph[node].box_ {
                rect.x += dx;
                rect.y += dy;
            }
            let children = graph[node].children.clone();
            if !children.is_empty() {
                Self::offset_subtree_inner(graph, &children, dx, dy);
            }
        }
    }
}
```

**Borrow checker note:** The `if let Some(ref mut rect)` borrow is scoped to the `if let` block. After it drops, `self.graph[node].is_container` and `.children.clone()` are safe reads. `Self::offset_subtree_inner` takes `&mut self.graph` (the petgraph store) directly, avoiding a double-borrow of `&mut self`.

**File:** `layout_sugiyama.rs` — Apply `reposition_node` in three places:

**1. `assign_coordinates` — all four direction arms:**

```rust
// Replace the entire `for &node in rank_nodes { if let Some(ref mut rect) ... }` block:

for &node in rank_nodes {
    if graph.graph[node].box_.is_some() {
        match direction {
            Direction::Down => {
                let width = graph.graph[node].box_.unwrap().width;
                graph.reposition_node(node, cross_offset, rank_offsets[rank_idx]);
                cross_offset += width + NODE_SPACING_H;
            }
            Direction::Up => {
                let r = graph.graph[node].box_.unwrap();
                graph.reposition_node(
                    node,
                    cross_offset,
                    -(rank_offsets[rank_idx] + r.height),
                );
                cross_offset += r.width + NODE_SPACING_H;
            }
            Direction::Right => {
                let height = graph.graph[node].box_.unwrap().height;
                graph.reposition_node(node, rank_offsets[rank_idx], cross_offset);
                cross_offset += height + NODE_SPACING_H;
            }
            Direction::Left => {
                let r = graph.graph[node].box_.unwrap();
                graph.reposition_node(
                    node,
                    -(rank_offsets[rank_idx] + r.width),
                    cross_offset,
                );
                cross_offset += r.height + NODE_SPACING_H;
            }
        }
    }
}
```

**Why `unwrap()` is safe:** The `is_some()` guard immediately before guarantees `box_` is `Some`. The `unwrap()` reads a `Copy` type (`Rect`), producing an owned copy, so there's no active borrow when `reposition_node` is called.

**2. `arrange_in_line` — all four direction arms:**

```rust
fn arrange_in_line(graph: &mut D2Graph, children: &[NodeIndex], direction: Direction) {
    let mut offset = 0.0;

    for &child in children {
        if graph.graph[child].box_.is_some() {
            match direction {
                Direction::Down | Direction::Up => {
                    let height = graph.graph[child].box_.unwrap().height;
                    graph.reposition_node(child, 0.0, offset);
                    offset += height + NODE_SPACING_V;
                }
                Direction::Right | Direction::Left => {
                    let width = graph.graph[child].box_.unwrap().width;
                    graph.reposition_node(child, offset, 0.0);
                    offset += width + NODE_SPACING_H;
                }
            }
        }
    }
}
```

**3. Component stacking:**

```rust
// Replace the inner loop:
for &node in component {
    if is_horizontal {
        graph.offset_node(node, 0.0, shift);
    } else {
        graph.offset_node(node, shift, 0.0);
    }
}
```

**Why `offset_node` not `reposition_node`:** Component stacking applies a relative shift, not an absolute position. `offset_node` shifts the node and its descendants by (dx, dy). Each node in the `component` list is a direct child of the container — if it's a container itself, `offset_node` propagates the shift to its descendants.

### Fix A2: Remove Redundant `fit_containers` Call

**File:** `layout.rs`

Replace the `fit_containers(graph, graph.root)` call with a minimal root-bbox computation:

```rust
// BEFORE (layout.rs:47):
fit_containers(graph, graph.root);

// AFTER:
compute_root_bbox(graph);
```

Where `compute_root_bbox` is extracted from the existing root branch of `fit_containers`:

```rust
fn compute_root_bbox(graph: &mut D2Graph) {
    let all_objects: Vec<NodeIndex> = graph.objects.clone();
    let mut min_x = f64::INFINITY;
    let mut min_y = f64::INFINITY;
    let mut max_x = f64::NEG_INFINITY;
    let mut max_y = f64::NEG_INFINITY;

    for &idx in &all_objects {
        if let Some(rect) = graph.graph[idx].box_ {
            min_x = min_x.min(rect.x);
            min_y = min_y.min(rect.y);
            max_x = max_x.max(rect.x + rect.width);
            max_y = max_y.max(rect.y + rect.height);
        }
    }

    if min_x != f64::INFINITY {
        graph.graph[graph.root].box_ = Some(Rect::new(
            min_x, min_y, max_x - min_x, max_y - min_y,
        ));
    }
}
```

The `fit_containers` function and its recursive traversal can be deleted entirely. `layout_recursive` already calls `fit_container` once per container (bottom-up), which is sufficient.

**Why this is safe:** `fit_container` is called exactly once per container inside `layout_recursive`, after its children are positioned. No subsequent phase (before `compute_root_bbox`) modifies child positions. The triple-call was redundant at best, harmful at worst.

**What to keep:** The `fit_container` function (singular) is still needed — it's called from `layout_recursive`. Only `fit_containers` (plural, the recursive re-traversal) is deleted.

### Fix B: Improved Edge Label Positioning

**B2. Geometric Midpoint Placement (Primary fix)**

**File:** `edge_routing.rs`, function `route_all_edges`

Replace the Bézier parametric midpoint + hardcoded offset with the geometric midpoint of the clipped edge endpoints:

```rust
// BEFORE (lines 119-121):
let mid = bezier_midpoint(&route);
let label_pos = Some(Point::new(mid.x, mid.y - 10.0));

// AFTER:
let label_pos = if graph.graph[eidx].label.is_some() {
    // Geometric center of the gap between shape boundaries.
    // `start` is clipped to source shape edge, `end` to destination shape edge.
    Some(Point::new(
        (start.x + end.x) / 2.0,
        (start.y + end.y) / 2.0,
    ))
} else {
    None
};
```

**Why geometric > Bézier parametric:** The clipped `start` sits on the source shape's boundary and `end` on the destination's boundary. Their midpoint is always in the visual gap between nodes. The Bézier parametric midpoint can deviate significantly for diagonal edges because control points at 40% pull it toward one node.

**Why `None` for unlabeled edges:** The SVG renderer (`svg_render.rs:516-519`) already guards on `edge.label.is_some()` before rendering labels. Setting `label_position = None` for unlabeled edges avoids computing unnecessary positions and makes intent explicit.

**B1. Extra Rank-Gap Spacing for Labeled Edges (Optional/Future)**

Downgraded from V1's "High priority" because:
- The actual inter-rank gap is 60px (not "~10-24px" as V1 incorrectly claimed)
- A 20px label fits in a 60px gap with ~20px clearance on each side
- Most label overlap in the screenshots is caused by the container stranding bug (Fix A), not insufficient gap

If needed later, the approach is: pass `edges` slice into `assign_coordinates`, check `graph.graph[eidx].label.is_some()` for edges spanning each rank pair, and add `EDGE_LABEL_SPACING` to the rank offset.

**Known limitation:** This only handles edges spanning a single rank gap. Multi-rank-span edges (rare in practice) would need virtual label nodes.

### Fix C: Adaptive Container Spacing

**File:** `layout_sugiyama.rs`, function `assign_coordinates`

When computing cross-rank (within-rank) spacing, use a larger minimum for ranks containing container nodes:

```rust
/// Minimum horizontal spacing between container nodes in the same rank.
const CONTAINER_CROSS_SPACING: f64 = 60.0;

/// Minimum vertical spacing between ranks when either rank has a container.
const CONTAINER_RANK_SPACING: f64 = 80.0;
```

In the rank offset loop:
```rust
// Check if current rank has any containers
let has_container = rank_nodes.iter().any(|&n| graph.graph[n].is_container);
let rank_spacing = if has_container {
    CONTAINER_RANK_SPACING
} else {
    NODE_SPACING_V
};
rank_offset += max_size + rank_spacing;
```

In the cross-offset loop:
```rust
let is_container_node = graph.graph[node].is_container;
let cross_spacing = if is_container_node {
    CONTAINER_CROSS_SPACING
} else {
    NODE_SPACING_H
};
cross_offset += rect_size + cross_spacing;
```

This is a cosmetic improvement. It only matters after Fix A resolves the stranding bug. Lower priority.

---

## 4. Implementation Plan

### Phase 1: Container Descendant Fix (Fix A1 + A2) — Critical

**Files modified:** `graph.rs`, `layout_sugiyama.rs`, `layout.rs`

1. Add `reposition_node`, `offset_node`, and `offset_subtree_inner` to `D2Graph` in `graph.rs`.
2. In `layout_sugiyama.rs`, replace direct position assignments with `reposition_node`/`offset_node` calls in all three sites (see Section 3 for complete pseudocode for all direction arms).
3. In `layout.rs`, replace `fit_containers(graph, graph.root)` with `compute_root_bbox(graph)`. Delete the `fit_containers` function. Keep `fit_container` (singular) — it's still used by `layout_recursive`.
4. The existing `offset_subtree` in `layout.rs` (used by `fit_container` for label offsets) remains as-is — it operates on direct children within a container, not on repositioned containers.

**Tests:**
- `test_container_children_inside_parent`: Parse `"a: { x\n y\n }\nb: { p\n q\n }\na.x -> b.p"`. Verify each leaf's bounding box is fully enclosed by its parent container's bounding box.
- `test_nested_container_no_overlap`: Parse the stress-test "Container Nesting" source. Apply `assert_no_leaf_overlap`.
- `test_container_delta_propagation`: Parse a 3-level nesting (`outer: { mid: { inner } }`). Verify `inner`'s position is within both `mid` and `outer`.
- `test_arrange_in_line_containers`: Two containers with no edges between them. Verify children of each are inside their respective containers.

**Risk:** Low. The `reposition_node` / `offset_node` methods are pure arithmetic applied at the three existing call sites. Regression risk is limited to layout changes (positions will change — existing e2e tests may need updated assertions since the old positions were wrong).

### Phase 2: Edge Label Positioning (Fix B2) — Moderate

**Files modified:** `edge_routing.rs`

1. Replace Bézier midpoint + hardcoded offset with geometric midpoint of clipped endpoints.
2. Set `label_position = None` for unlabeled edges.

**Tests:**
- `test_label_between_nodes`: Parse `"a -> b: hello"`, run full pipeline. Verify `label_position.y` is between `a.box_.y + a.box_.height` and `b.box_.y`.
- `test_label_between_nodes_horizontal`: Same for `direction: right`. Verify `label_position.x` is between `a.box_.x + a.box_.width` and `b.box_.x`.
- `test_unlabeled_edge_no_label_position`: Parse `"a -> b"`. Verify `label_position` is `None`.

### Phase 3: Adaptive Container Spacing (Fix C) — Low

**Files modified:** `layout_sugiyama.rs`

1. Add `CONTAINER_CROSS_SPACING` and `CONTAINER_RANK_SPACING` constants.
2. Use container-aware spacing in `assign_coordinates` when containers are in a rank.

**Tests:**
- `test_container_spacing_wider`: Parse two containers in the same rank connected to a third. Verify horizontal gap >= `CONTAINER_CROSS_SPACING`.
- `test_leaf_spacing_unchanged`: Parse leaf-only diagram. Verify spacing is exactly `NODE_SPACING_H`.

---

## 5. Files Changed Summary

| File | Change | Phase |
|------|--------|-------|
| `crates/d2/src/graph.rs` | Add `reposition_node`, `offset_node`, `offset_subtree_inner` methods | 1 |
| `crates/d2/src/layout_sugiyama.rs` | Use `reposition_node`/`offset_node` at 3 call sites; add container spacing constants | 1, 3 |
| `crates/d2/src/layout.rs` | Replace `fit_containers` with `compute_root_bbox`; delete `fit_containers` | 1 |
| `crates/d2/src/edge_routing.rs` | Geometric midpoint label placement | 2 |

No changes to: `parser.rs`, `compiler.rs`, `shapes.rs`, `svg_render.rs`, `text.rs`.

---

## 6. Design Decisions and Trade-offs

### Why `reposition_node` on D2Graph instead of patching `layout_recursive`?

V1 proposed snapshotting positions before Sugiyama and computing deltas after. This only fixes `assign_coordinates` and requires explicit delta tracking. The `reposition_node` approach:
- Fixes all three call sites (assign_coordinates, arrange_in_line, component stacking)
- Requires no snapshot/delta bookkeeping
- Is self-contained — any future code that repositions a container automatically handles descendants
- Can be unit-tested independently of the layout algorithm

### Why delete `fit_containers` instead of making `fit_container` idempotent?

Making `fit_container` idempotent would require tracking whether the label offset was already applied (e.g., a flag or checking child positions relative to container bounds). This adds state and complexity. Since `layout_recursive` already calls `fit_container` exactly once per container in the correct bottom-up order, the triple-call was entirely redundant. Deleting it is simpler and eliminates the triple-offset bug.

### Why downgrade B1 (edge label spacing) from High to Optional?

V1's gap analysis was wrong. The actual gap between adjacent ranks is `NODE_SPACING_V = 60px`, which accommodates a ~20px label with ~20px clearance on each side. The label overlap visible in the screenshots is primarily caused by the container stranding bug (Fix A), not by insufficient gap. Fix B2 (geometric midpoint) is sufficient for label positioning.

### Why geometric midpoint instead of Bézier midpoint?

For a vertical edge from y=36 to y=96:
- Bézier midpoint at t=0.5: y ≈ 66 (verified via de Casteljau)
- Geometric midpoint of endpoints: y = (36+96)/2 = 66 (same for straight vertical)

For a diagonal edge from (0, 36) to (100, 96):
- Bézier midpoint: biased toward source due to control point at 40% along y-axis
- Geometric midpoint: (50, 66) — centered in the gap

The geometric midpoint is strictly better for diagonal edges and equivalent for vertical edges. Removing the hardcoded -10px offset gives a truly centered placement.

### Why two `offset_subtree` functions?

`offset_subtree` in `layout.rs` takes `&mut D2Graph` and is used by `fit_container` to push children down for the label. `offset_subtree_inner` in `graph.rs` takes `&mut StableDiGraph` directly, needed by `reposition_node`/`offset_node` to avoid a double-borrow of `&mut self`. Both do the same arithmetic. Consolidating them is possible (e.g., `fit_container` could call `D2Graph::offset_subtree_inner(&mut graph.graph, ...)`) but adds coupling between modules for no functional benefit. Left as a future cleanup.

### Cross-container edge routing after Fix A

After Fix A correctly positions descendants, edges between nodes in different containers will route correctly automatically. `route_all_edges` reads absolute node positions to compute edge paths. When nodes are at correct positions, edge routing produces correct paths. No special container-aware routing is needed.

---

## 7. Verification Strategy

### Manual Verification

Re-render the three diagrams from the bug screenshots:
1. **Container nesting**: Verify Frontend and Backend children don't overlap.
2. **Styled elements**: Verify "retry" label sits between the green and red boxes.
3. **Architecture**: Verify labels sit in gaps between nodes, not on top of them.

### `assert_no_leaf_overlap` Helper

```rust
fn assert_no_leaf_overlap(graph: &D2Graph) {
    let leaves: Vec<(NodeIndex, Rect)> = graph.objects.iter()
        .filter(|&&idx| idx != graph.root && !graph.graph[idx].is_container)
        .filter_map(|&idx| graph.graph[idx].box_.map(|r| (idx, r)))
        .collect();

    for i in 0..leaves.len() {
        for j in (i + 1)..leaves.len() {
            let (a_idx, a) = leaves[i];
            let (b_idx, b) = leaves[j];
            let overlap_x = a.x < b.x + b.width && b.x < a.x + a.width;
            let overlap_y = a.y < b.y + b.height && b.y < a.y + a.height;
            assert!(
                !(overlap_x && overlap_y),
                "leaf nodes '{}' and '{}' overlap:\n  {} = ({}, {}, {}x{})\n  {} = ({}, {}, {}x{})",
                graph.graph[a_idx].id, graph.graph[b_idx].id,
                graph.graph[a_idx].id, a.x, a.y, a.width, a.height,
                graph.graph[b_idx].id, b.x, b.y, b.width, b.height,
            );
        }
    }
}
```

O(n^2) but acceptable for test inputs (<100 nodes).

### Automated Test Matrix

| Test | Phase | What it validates |
|------|-------|-------------------|
| `test_container_children_inside_parent` | 1 | Children enclosed by parent container |
| `test_nested_container_no_overlap` | 1 | No leaf overlap in nested containers |
| `test_container_delta_propagation` | 1 | 3-level nesting correctness |
| `test_arrange_in_line_containers` | 1 | Disconnected containers position correctly |
| `test_label_between_nodes` | 2 | Label in vertical gap between nodes |
| `test_label_between_nodes_horizontal` | 2 | Label in horizontal gap (direction: right) |
| `test_unlabeled_edge_no_label_position` | 2 | No label_position for unlabeled edges |
| `test_container_spacing_wider` | 3 | Containers get more breathing room |

---

## 8. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Fix A1 changes all container layouts; existing e2e tests break | **High** | Low | Expected — old positions were wrong. Update assertions. |
| Removing `fit_containers` breaks edge case not covered by `layout_recursive` | Low | Medium | `layout_recursive` is a complete bottom-up traversal. All containers are fitted exactly once. Verify with full test suite. |
| `reposition_node` has borrow issues with `&mut self` and child iteration | Low | Low | `offset_subtree_inner` takes `&mut StableDiGraph` directly. Pattern verified in Section 3 pseudocode. |
| Fix B2 geometric midpoint still overlaps for very short edges | Low | Low | Short edges (< 20px) are rare. Future collision nudging can handle. |
| Deleting `fit_containers` changes container sizes (removing triple label offset) | High | Low | Containers become ~48px shorter (correct size). Visual improvement. |

---

## 9. Future Work

Out of scope for this HLD:

1. **Brandes-Kopf coordinate assignment** — Align nodes with connected parents.
2. **Virtual label nodes** — First-class label participation in ranking.
3. **Edge label collision nudging** — Post-layout pass to avoid node overlap.
4. **B1 rank-gap spacing for labeled edges** — Extra space when labeled edges exist.
5. **Orthogonal edge routing** — Horizontal/vertical segments around containers.
6. **Container-aware edge clipping** — Clip edges at container boundaries.
7. **Consolidate `offset_subtree` functions** — Unify `layout.rs::offset_subtree` and `graph.rs::offset_subtree_inner`.

---

## 10. Implementation Order

```
Phase 1 (Fix A1+A2) ──→ Phase 2 (Fix B2) ──→ Phase 3 (Fix C)
   Critical                 Moderate              Low
   ~70 lines                ~10 lines             ~20 lines
   graph.rs + layout*.rs    edge_routing.rs       layout_sugiyama.rs
```

Phase 1 must land first — it changes all container positions, which affects edge routing and label placement. Phases 2 and 3 are independent of each other and can be done in either order or combined.

---

## Appendix: Detailed Trace of Fix A1

To verify correctness, here is a step-by-step trace for the "Container Nesting" stress-test diagram:

```d2
platform: Platform {
  frontend: Frontend {
    app: React App
    cdn: CDN
  }
  backend: Backend {
    api: API Gateway
    svc: Service
    api -> svc: route
  }
  frontend.app -> backend.api: fetch
}
```

**After `layout_recursive(frontend)`:**
- app: box_ = (0, 0, 99, 44)   [measured: "React App" + padding]
- cdn: box_ = (0, 104, 60, 36)  [measured: "CDN" + padding, offset by height+V_SPACING]
- fit_container(frontend): pushes children down by 24 (label "Frontend"), then wraps
- frontend.box_ = (-30, -12, 159, 224)

**After `layout_recursive(backend)`:**
- api: box_ = (-30, 0, 125, 44)  [centered in rank 0]
- svc: box_ = (-30, 104, 80, 44) [centered in rank 1]
- fit_container(backend): pushes children down by 24, then wraps
- backend.box_ = (-60, -12, 215, 232)

**`layout_sugiyama::layout_children(platform)` with `reposition_node`:**

Cross-container edge: frontend.app → backend.api maps to frontend → backend.
- Ranks: frontend=0, backend=1

`assign_coordinates` for direction Down:
- Rank 0: [frontend]
  - cross_offset = -frontend.width/2 = -79.5
  - `graph.reposition_node(frontend, -79.5, 0.0)`
    - Old position: (-30, -12) → delta = (-49.5, +12)
    - Shifts descendants {app, cdn} by (-49.5, +12)
    - app: (0, 24) → (-49.5, 36)
    - cdn: (0, 128) → (-49.5, 140)
  - frontend.box_ = (-79.5, 0, 159, 224)

- Rank 1: [backend]
  - cross_offset = -backend.width/2 = -107.5
  - rank_offset = 224 + 60 = 284
  - `graph.reposition_node(backend, -107.5, 284.0)`
    - Old position: (-60, -12) → delta = (-47.5, +296)
    - Shifts descendants {api, svc} by (-47.5, +296)
    - api: (-30, 24) → (-77.5, 320)
    - svc: (-30, 128) → (-77.5, 424)
  - backend.box_ = (-107.5, 284, 215, 232)

**Verification:** All children are inside their parent containers:
- app (-49.5, 36) inside frontend (-79.5, 0, 159, 224)? x: -79.5 <= -49.5 <= -79.5+159=79.5. y: 0 <= 36 <= 224. Yes.
- api (-77.5, 320) inside backend (-107.5, 284, 215, 232)? x: -107.5 <= -77.5 <= 107.5. y: 284 <= 320 <= 516. Yes.
- No overlap between frontend's and backend's children. Yes.

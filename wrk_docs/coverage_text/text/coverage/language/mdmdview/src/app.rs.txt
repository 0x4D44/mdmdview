Coverage Report
Created: 2026-01-13 12:48
C:\language\mdmdview\src\app.rs:
    1|       |/// Main application logic for the markdown viewer
    2|       |///
    3|       |/// This module contains the primary app state, UI logic, and event handling
    4|       |/// for the markdown viewer application built with egui.
    5|       |use crate::{MarkdownElement, MarkdownRenderer, SampleFile, WindowState, SAMPLE_FILES};
    6|       |use anyhow::{bail, Result};
    7|       |use crossbeam_channel::{unbounded, Receiver, Sender};
    8|       |use egui::text::LayoutJob;
    9|       |use egui::text::TextFormat;
   10|       |use egui::{menu, CentralPanel, Color32, Context, RichText, TopBottomPanel};
   11|       |use egui::{TextEdit, TextStyle};
   12|       |use image::{imageops, RgbaImage};
   13|       |#[cfg(not(test))]
   14|       |use rfd::FileDialog;
   15|       |#[cfg(test)]
   16|       |use std::cell::RefCell;
   17|       |#[cfg(test)]
   18|       |use std::collections::HashSet;
   19|       |use std::collections::VecDeque;
   20|       |use std::io::ErrorKind;
   21|       |use std::path::{Path, PathBuf};
   22|       |#[cfg(test)]
   23|       |use std::sync::atomic::{AtomicBool, Ordering};
   24|       |use std::time::{Duration, Instant};
   25|       |use unicode_casefold::UnicodeCaseFold;
   26|       |use unicode_normalization::UnicodeNormalization;
   27|       |
   28|       |/// Prefix used for application/window titles.
   29|       |pub const APP_TITLE_PREFIX: &str = "mdmdview";
   30|       |const BUILD_VERSION: &str = env!("CARGO_PKG_VERSION");
   31|       |const BUILD_TIMESTAMP: &str = env!("MDMDVIEW_BUILD_TIMESTAMP");
   32|       |const ASYNC_LOAD_THRESHOLD_BYTES: u64 = 2 * 1024 * 1024;
   33|       |
   34|       |#[cfg(test)]
   35|       |thread_local! {
   36|       |    static FORCED_APP_ACTIONS: RefCell<HashSet<&'static str>> = RefCell::new(HashSet::new());
   37|       |    static FORCED_OPEN_PATH: RefCell<Option<PathBuf>> = const { RefCell::new(None) };
   38|       |    static FORCED_SAVE_PATH: RefCell<Option<PathBuf>> = const { RefCell::new(None) };
   39|       |    static FORCED_LOAD_ERROR: RefCell<bool> = const { RefCell::new(false) };
   40|       |    static FORCED_SCAN_ERROR: RefCell<bool> = const { RefCell::new(false) };
   41|       |}
   42|       |
   43|       |#[cfg(test)]
   44|       |static FORCE_THREAD_SPAWN_ERROR: AtomicBool = AtomicBool::new(false);
   45|       |
   46|       |#[cfg(test)]
   47|    975|fn app_action_triggered(triggered: bool, action: &'static str) -> bool {
   48|    975|    triggered || FORCED_APP_ACTIONS.with(|actions| actions.borrow().contains(action))
                               ^974               ^974           ^974             ^974     ^974
   49|    975|}
   50|       |
   51|       |#[cfg(not(test))]
   52|       |fn app_action_triggered(triggered: bool, _action: &'static str) -> bool {
   53|       |    triggered
   54|       |}
   55|       |
   56|       |#[cfg(test)]
   57|      8|fn take_forced_open_path() -> Option<PathBuf> {
   58|      8|    FORCED_OPEN_PATH.with(|slot| slot.borrow_mut().take())
   59|      8|}
   60|       |
   61|       |#[cfg(test)]
   62|      5|fn take_forced_save_path() -> Option<PathBuf> {
   63|      5|    FORCED_SAVE_PATH.with(|slot| slot.borrow_mut().take())
   64|      5|}
   65|       |
   66|       |#[cfg(test)]
   67|     27|fn take_forced_load_error() -> bool {
   68|     27|    FORCED_LOAD_ERROR.with(|flag| flag.replace(false))
   69|     27|}
   70|       |
   71|       |#[cfg(test)]
   72|      6|fn take_forced_scan_error() -> bool {
   73|      6|    FORCED_SCAN_ERROR.with(|flag| flag.replace(false))
   74|      6|}
   75|       |
   76|       |/// Entry in navigation history for back/forward navigation
   77|       |#[derive(Clone, Debug)]
   78|       |struct HistoryEntry {
   79|       |    file_path: Option<PathBuf>,
   80|       |    title: String,
   81|       |    content: String,
   82|       |}
   83|       |
   84|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
   85|       |pub enum ScreenshotTheme {
   86|       |    Light,
   87|       |    Dark,
   88|       |}
   89|       |
   90|       |impl ScreenshotTheme {
   91|     13|    fn as_str(self) -> &'static str {
   92|     13|        match self {
   93|     10|            ScreenshotTheme::Light => "light",
   94|      3|            ScreenshotTheme::Dark => "dark",
   95|       |        }
   96|     13|    }
   97|       |}
   98|       |
   99|       |#[derive(Clone, Debug)]
  100|       |pub struct ScreenshotConfig {
  101|       |    pub output_path: PathBuf,
  102|       |    pub viewport_width: f32,
  103|       |    pub viewport_height: f32,
  104|       |    pub content_only: bool,
  105|       |    pub scroll_ratio: Option<f32>,
  106|       |    pub wait_ms: u64,
  107|       |    pub settle_frames: u32,
  108|       |    pub zoom: f32,
  109|       |    pub theme: ScreenshotTheme,
  110|       |    pub font_source: Option<String>,
  111|       |}
  112|       |
  113|       |impl ScreenshotConfig {
  114|     12|    fn metadata_path(&self) -> PathBuf {
  115|     12|        self.output_path.with_extension("json")
  116|     12|    }
  117|       |}
  118|       |
  119|       |#[derive(Clone, Copy, Debug)]
  120|       |struct ScrollSnapshot {
  121|       |    content_size: egui::Vec2,
  122|       |    inner_rect: egui::Rect,
  123|       |    offset_y: f32,
  124|       |}
  125|       |
  126|       |#[derive(Debug, Clone, Copy)]
  127|       |struct WindowAdjustment {
  128|       |    pos: Option<egui::Pos2>,
  129|       |    size: Option<egui::Vec2>,
  130|       |}
  131|       |
  132|       |struct FileLoadRequest {
  133|       |    id: u64,
  134|       |    path: PathBuf,
  135|       |}
  136|       |
  137|       |struct FileLoadResult {
  138|       |    id: u64,
  139|       |    content: Result<(String, bool), String>,
  140|       |}
  141|       |
  142|       |#[derive(Clone)]
  143|       |struct PendingFileLoad {
  144|       |    id: u64,
  145|       |    path: PathBuf,
  146|       |}
  147|       |
  148|       |#[derive(Debug)]
  149|       |struct ScreenshotState {
  150|       |    config: ScreenshotConfig,
  151|       |    started: Instant,
  152|       |    stable_frames: u32,
  153|       |    last_layout_hash: Option<u64>,
  154|       |    last_scroll_offset: Option<f32>,
  155|       |    scroll_offset: Option<f32>,
  156|       |    content_rect: Option<egui::Rect>,
  157|       |    last_content_size: Option<egui::Vec2>,
  158|       |    last_inner_rect: Option<egui::Rect>,
  159|       |    pixels_per_point: f32,
  160|       |    viewport_adjusted: bool,
  161|       |    requested: bool,
  162|       |    done: bool,
  163|       |    timed_out: bool,
  164|       |    pending_renders: bool,
  165|       |}
  166|       |
  167|       |#[derive(Clone, Debug)]
  168|       |struct ScreenshotSnapshot {
  169|       |    config: ScreenshotConfig,
  170|       |    content_rect: Option<egui::Rect>,
  171|       |    pixels_per_point: f32,
  172|       |    stable_frames: u32,
  173|       |    timed_out: bool,
  174|       |    pending_renders: bool,
  175|       |    last_scroll_offset: Option<f32>,
  176|       |    started: Instant,
  177|       |}
  178|       |
  179|       |impl ScreenshotState {
  180|     14|    fn new(config: ScreenshotConfig) -> Self {
  181|     14|        Self {
  182|     14|            config,
  183|     14|            started: Instant::now(),
  184|     14|            stable_frames: 0,
  185|     14|            last_layout_hash: None,
  186|     14|            last_scroll_offset: None,
  187|     14|            scroll_offset: None,
  188|     14|            content_rect: None,
  189|     14|            last_content_size: None,
  190|     14|            last_inner_rect: None,
  191|     14|            pixels_per_point: 1.0,
  192|     14|            viewport_adjusted: false,
  193|     14|            requested: false,
  194|     14|            done: false,
  195|     14|            timed_out: false,
  196|     14|            pending_renders: false,
  197|     14|        }
  198|     14|    }
  199|       |
  200|      6|    fn record_scroll(&mut self, snapshot: ScrollSnapshot) -> bool {
  201|      6|        self.last_content_size = Some(snapshot.content_size);
  202|      6|        self.last_inner_rect = Some(snapshot.inner_rect);
  203|      6|        self.last_scroll_offset = Some(snapshot.offset_y);
  204|       |
  205|      6|        if self.scroll_offset.is_none() {
  206|      3|            if let Some(ratio) = self.config.scroll_ratio {
                                      ^2
  207|      2|                let max_scroll = (snapshot.content_size.y - snapshot.inner_rect.height()).max(0.0);
  208|      2|                self.scroll_offset = Some((max_scroll * ratio).round());
  209|      2|                return true;
  210|      1|            }
  211|      3|        }
  212|      4|        false
  213|      6|    }
  214|       |
  215|      9|    fn scroll_ready(&self) -> bool {
  216|       |        match (
  217|      9|            self.config.scroll_ratio,
  218|      9|            self.scroll_offset,
  219|      9|            self.last_scroll_offset,
  220|       |        ) {
  221|      3|            (None, _, _) => true,
  222|      3|            (Some(_), Some(target), Some(actual)) => (actual - target).abs() <= 0.5,
  223|      3|            _ => false,
  224|       |        }
  225|      9|    }
  226|       |
  227|      9|    fn update_stability(&mut self, layout_hash: Option<u64>, scroll_offset: Option<f32>) {
  228|      9|        let mut changed = false;
  229|      9|        if let Some(hash) = layout_hash {
                                  ^5
  230|      5|            if self.last_layout_hash != Some(hash) {
  231|      4|                changed = true;
  232|      4|            }
                          ^1
  233|      5|            self.last_layout_hash = Some(hash);
  234|      4|        } else {
  235|      4|            changed = true;
  236|      4|        }
  237|       |
  238|      9|        if let (Some(prev), Some(current)) = (self.last_scroll_offset, scroll_offset) {
                                   ^4          ^4
  239|      4|            if (prev - current).abs() > 0.5 {
  240|      1|                changed = true;
  241|      3|            }
  242|      5|        }
  243|       |
  244|      9|        if changed {
  245|      8|            self.stable_frames = 0;
  246|      8|        } else {
  247|      1|            self.stable_frames = self.stable_frames.saturating_add(1);
  248|      1|        }
  249|      9|    }
  250|       |}
  251|       |
  252|       |impl From<&ScreenshotState> for ScreenshotSnapshot {
  253|      2|    fn from(state: &ScreenshotState) -> Self {
  254|      2|        Self {
  255|      2|            config: state.config.clone(),
  256|      2|            content_rect: state.content_rect,
  257|      2|            pixels_per_point: state.pixels_per_point,
  258|      2|            stable_frames: state.stable_frames,
  259|      2|            timed_out: state.timed_out,
  260|      2|            pending_renders: state.pending_renders,
  261|      2|            last_scroll_offset: state.last_scroll_offset,
  262|      2|            started: state.started,
  263|      2|        }
  264|      2|    }
  265|       |}
  266|       |
  267|       |/// Main application state and logic
  268|       |pub struct MarkdownViewerApp {
  269|       |    /// Markdown renderer instance
  270|       |    renderer: MarkdownRenderer,
  271|       |    /// Currently loaded file path
  272|       |    current_file: Option<PathBuf>,
  273|       |    /// Current markdown content as string
  274|       |    current_content: String,
  275|       |    /// Buffer for raw view (read-only for now)
  276|       |    raw_buffer: String,
  277|       |    /// Parsed markdown elements ready for rendering
  278|       |    parsed_elements: Vec<MarkdownElement>,
  279|       |    /// Application title for window
  280|       |    title: String,
  281|       |    /// Error message to display if any
  282|       |    error_message: Option<String>,
  283|       |    /// Navigation request for keyboard shortcuts
  284|       |    nav_request: Option<NavigationRequest>,
  285|       |    /// Scroll area ID for state management
  286|       |    scroll_area_id: egui::Id,
  287|       |    /// Flag to request fullscreen toggle
  288|       |    toggle_fullscreen: bool,
  289|       |    /// Current view mode
  290|       |    view_mode: ViewMode,
  291|       |    /// Wrap long lines in raw view
  292|       |    wrap_raw: bool,
  293|       |    /// Write mode: allow editing in Raw view
  294|       |    write_enabled: bool,
  295|       |    /// Remember caret position in raw editor (byte index)
  296|       |    raw_cursor: Option<usize>,
  297|       |    /// Request focus for raw editor on next render
  298|       |    raw_focus_requested: bool,
  299|       |    /// Flag to request reload of current file (handled outside input context)
  300|       |    reload_requested: bool,
  301|       |    /// Defer toggling view mode to outside input context
  302|       |    view_toggle_requested: bool,
  303|       |    /// Defer toggling write mode to outside input context
  304|       |    write_toggle_requested: bool,
  305|       |    /// Last known window position (for persistence)
  306|       |    last_window_pos: Option<[f32; 2]>,
  307|       |    /// Last known window size (for persistence)
  308|       |    last_window_size: Option<[f32; 2]>,
  309|       |    /// Last known maximized state
  310|       |    last_window_maximized: bool,
  311|       |    /// Last persisted window snapshot to avoid redundant disk writes
  312|       |    last_persisted_state: Option<WindowState>,
  313|       |    /// Throttle saving window state
  314|       |    last_persist_instant: std::time::Instant,
  315|       |    file_load_tx: Sender<FileLoadRequest>,
  316|       |    file_load_rx: Receiver<FileLoadResult>,
  317|       |    pending_file_load: Option<PendingFileLoad>,
  318|       |    next_file_load_id: u64,
  319|       |    // Search state
  320|       |    show_search: bool,
  321|       |    search_query: String,
  322|       |    last_query: String,
  323|       |    last_match_index: Option<usize>,
  324|       |    pending_scroll_to_element: Option<usize>,
  325|       |    search_focus_requested: bool,
  326|       |    /// Deferred caret movement (in lines) for raw editor
  327|       |    pending_raw_cursor_line_move: Option<i32>,
  328|       |    // Navigation history
  329|       |    /// History of visited files and samples for back/forward navigation
  330|       |    history: Vec<HistoryEntry>,
  331|       |    /// Current position in history
  332|       |    history_index: usize,
  333|       |    /// Maximum history entries to keep
  334|       |    max_history: usize,
  335|       |    // Drag and drop state
  336|       |    /// Visual state: file is being dragged over window
  337|       |    drag_hover: bool,
  338|       |    /// Queue of files waiting to be opened (from multi-file drop)
  339|       |    pending_files: VecDeque<PathBuf>,
  340|       |    screenshot: Option<ScreenshotState>,
  341|       |}
  342|       |
  343|       |/// Navigation request for keyboard-triggered scrolling
  344|       |#[derive(Debug, Clone)]
  345|       |enum NavigationRequest {
  346|       |    Top,
  347|       |    Bottom,
  348|       |    PageUp,
  349|       |    PageDown,
  350|       |    ScrollUp,   // Arrow up - fine scrolling
  351|       |    ScrollDown, // Arrow down - fine scrolling
  352|       |}
  353|       |
  354|       |/// Which view the user is in
  355|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
  356|       |enum ViewMode {
  357|       |    Rendered,
  358|       |    Raw,
  359|       |}
  360|       |
  361|       |impl MarkdownViewerApp {
  362|      9|    fn toggle_write_mode(&mut self, ctx: &Context) {
  363|      9|        if self.write_enabled {
  364|       |            // About to disable; capture current cursor if in Raw view
  365|      5|            if matches!(self.view_mode, ViewMode::Raw) {
                             ^1
  366|      4|                let editor_id = egui::Id::new("raw_editor");
  367|      4|                if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
                                          ^3
  368|      3|                    if let Some(range) = state.cursor.char_range() {
                                              ^2
  369|      2|                        self.raw_cursor = Some(range.primary.index);
  370|      2|                    }
                                  ^1
  371|      1|                }
  372|      1|            }
  373|      5|            self.write_enabled = false;
  374|       |        } else {
  375|       |            // Enabling write mode: ensure the raw editor will gain focus
  376|      4|            self.write_enabled = true;
  377|      4|            if matches!(self.view_mode, ViewMode::Raw) {
                             ^0
  378|      4|                self.raw_focus_requested = true;
  379|      4|            }
                          ^0
  380|       |        }
  381|      9|    }
  382|       |
  383|     15|    fn move_raw_cursor_lines(&mut self, ctx: &Context, delta_lines: i32) {
  384|     15|        if !matches!(self.view_mode, ViewMode::Raw) || !self.write_enabled {
                          ^2                                         ^13
  385|      3|            return;
  386|     12|        }
  387|     12|        let editor_id = egui::Id::new("raw_editor");
  388|     12|        if let Some(mut state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
                                  ^11
  389|     11|            let mut idx = state
  390|     11|                .cursor
  391|     11|                .char_range()
  392|     11|                .map(|r| r.primary.index)
  393|     11|                .unwrap_or_else(|| self.raw_cursor.unwrap_or(0))
                                                 ^1              ^1
  394|     11|                .min(self.raw_buffer.len());
  395|       |
  396|     11|            let s = self.raw_buffer.as_str();
  397|     11|            match delta_lines.cmp(&0) {
  398|       |                std::cmp::Ordering::Less => {
  399|      3|                    let mut lines = -delta_lines;
  400|       |                    // Move to start of current line
  401|      3|                    idx = s[..idx].rfind('\n').map(|p| p + 1).unwrap_or(0);
                                                                     ^2
  402|      6|                    while lines > 0 && idx > 0 {
                                                     ^4
  403|      3|                        if let Some(prev_nl) = s[..idx.saturating_sub(1)].rfind('\n') {
                                                  ^1
  404|      1|                            idx = prev_nl + 1;
  405|      2|                        } else {
  406|      2|                            idx = 0;
  407|      2|                        }
  408|      3|                        lines -= 1;
  409|       |                    }
  410|       |                }
  411|       |                std::cmp::Ordering::Greater => {
  412|      7|                    let mut lines = delta_lines;
  413|       |                    // Move to start of next line
  414|      7|                    if let Some(nl) = s[idx..].find('\n') {
                                              ^5
  415|      5|                        idx = (idx + nl + 1).min(s.len());
  416|      5|                        lines -= 1;
  417|      5|                    }
                                  ^2
  418|     10|                    while lines > 0 && idx < s.len() {
                                                     ^4
  419|      3|                        if let Some(nl) = s[idx..].find('\n') {
                                                  ^1
  420|      1|                            idx = (idx + nl + 1).min(s.len());
  421|      2|                        } else {
  422|      2|                            idx = s.len();
  423|      2|                        }
  424|      3|                        lines -= 1;
  425|       |                    }
  426|       |                }
  427|      1|                std::cmp::Ordering::Equal => {}
  428|       |            }
  429|     11|            let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(idx));
  430|     11|            state.cursor.set_char_range(Some(cr));
  431|     11|            state.store(ctx, editor_id);
  432|     11|            self.raw_cursor = Some(idx);
  433|     11|            self.raw_focus_requested = true; // keep focus and make caret visible
  434|      1|        }
  435|     15|    }
  436|      3|    fn clear_search_state(&mut self) {
  437|      3|        self.search_query.clear();
  438|      3|        self.last_query.clear();
  439|      3|        self.last_match_index = None;
  440|      3|        self.pending_scroll_to_element = None;
  441|      3|        self.renderer.set_highlight_phrase(None);
  442|      3|    }
  443|      6|    fn find_next(&mut self) {
  444|      6|        if self.search_query.is_empty() && self.last_query.is_empty() {
                                                         ^2              ^2
  445|      1|            return;
  446|      5|        }
  447|      5|        let needle = if !self.search_query.is_empty() {
  448|      4|            self.last_query = self.search_query.clone();
  449|      4|            Self::fold_for_search(&self.search_query)
  450|       |        } else {
  451|      1|            Self::fold_for_search(&self.last_query)
  452|       |        };
  453|      5|        let mut start = self.last_match_index.unwrap_or(usize::MAX);
  454|      5|        if start == usize::MAX {
  455|      4|            start = 0;
  456|      4|        } else {
  457|      1|            start = start.saturating_add(1);
  458|      1|        }
  459|       |        // Wrap-around search forward
  460|      5|        let total = self.parsed_elements.len();
  461|      6|        for pass in 0..2 {
  462|      6|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
  463|      5|                Box::new(start..total)
  464|       |            } else {
  465|      1|                Box::new(0..start.min(total))
  466|       |            };
  467|      9|            for idx in range {
                              ^8
  468|      8|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
  469|      8|                    &self.parsed_elements[idx],
  470|       |                );
  471|      8|                if Self::fold_for_search(&text).contains(&needle) {
  472|      5|                    self.last_match_index = Some(idx);
  473|      5|                    self.pending_scroll_to_element = Some(idx);
  474|      5|                    return;
  475|      3|                }
  476|       |            }
  477|       |        }
  478|      6|    }
  479|       |
  480|      6|    fn find_previous(&mut self) {
  481|      6|        if self.search_query.is_empty() && self.last_query.is_empty() {
                                                         ^2              ^2
  482|      1|            return;
  483|      5|        }
  484|      5|        let needle = if !self.search_query.is_empty() {
  485|      4|            self.last_query = self.search_query.clone();
  486|      4|            Self::fold_for_search(&self.search_query)
  487|       |        } else {
  488|      1|            Self::fold_for_search(&self.last_query)
  489|       |        };
  490|      5|        let total = self.parsed_elements.len();
  491|      5|        let mut start = self.last_match_index.unwrap_or(0);
  492|      5|        if start == 0 {
  493|      3|            start = total.saturating_sub(1);
  494|      3|        } else {
  495|      2|            start = start.saturating_sub(1);
  496|      2|        }
  497|       |        // Wrap-around search backward
  498|      6|        for pass in 0..2 {
  499|      6|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
  500|      5|                Box::new((0..=start).rev())
  501|       |            } else {
  502|      1|                Box::new(((start + 1)..total).rev())
  503|       |            };
  504|     10|            for idx in range {
                              ^9
  505|      9|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
  506|      9|                    &self.parsed_elements[idx],
  507|       |                );
  508|      9|                if Self::fold_for_search(&text).contains(&needle) {
  509|      5|                    self.last_match_index = Some(idx);
  510|      5|                    self.pending_scroll_to_element = Some(idx);
  511|      5|                    return;
  512|      4|                }
  513|       |            }
  514|       |        }
  515|      6|    }
  516|       |    /// Create a new application instance
  517|    159|    pub fn new() -> Self {
  518|    159|        let (file_load_tx, file_load_rx) = Self::spawn_file_loader();
  519|    159|        let mut app = Self {
  520|    159|            renderer: MarkdownRenderer::new(),
  521|    159|            current_file: None,
  522|    159|            current_content: String::new(),
  523|    159|            raw_buffer: String::new(),
  524|    159|            parsed_elements: Vec::new(),
  525|    159|            title: APP_TITLE_PREFIX.to_string(),
  526|    159|            error_message: None,
  527|    159|            nav_request: None,
  528|    159|            scroll_area_id: egui::Id::new("main_scroll_area"),
  529|    159|            toggle_fullscreen: false,
  530|    159|            view_mode: ViewMode::Rendered,
  531|    159|            wrap_raw: false,
  532|    159|            write_enabled: false,
  533|    159|            raw_cursor: None,
  534|    159|            raw_focus_requested: false,
  535|    159|            reload_requested: false,
  536|    159|            view_toggle_requested: false,
  537|    159|            write_toggle_requested: false,
  538|    159|            last_window_pos: None,
  539|    159|            last_window_size: None,
  540|    159|            last_window_maximized: false,
  541|    159|            last_persisted_state: None,
  542|    159|            last_persist_instant: std::time::Instant::now(),
  543|    159|            file_load_tx,
  544|    159|            file_load_rx,
  545|    159|            pending_file_load: None,
  546|    159|            next_file_load_id: 0,
  547|    159|            show_search: false,
  548|    159|            search_query: String::new(),
  549|    159|            last_query: String::new(),
  550|    159|            last_match_index: None,
  551|    159|            pending_scroll_to_element: None,
  552|    159|            search_focus_requested: false,
  553|    159|            pending_raw_cursor_line_move: None,
  554|    159|            history: Vec::new(),
  555|    159|            history_index: 0,
  556|    159|            max_history: 50,
  557|    159|            drag_hover: false,
  558|    159|            pending_files: VecDeque::new(),
  559|    159|            screenshot: None,
  560|    159|        };
  561|       |        // Load welcome content by default
  562|    159|        app.load_welcome_from_samples(SAMPLE_FILES, false);
  563|       |
  564|    159|        app
  565|    159|    }
  566|       |
  567|      1|    pub fn set_zoom_scale(&mut self, scale: f32) {
  568|      1|        self.renderer.set_zoom_scale(scale);
  569|      1|    }
  570|       |
  571|      3|    pub fn set_screenshot_mode(&mut self, config: ScreenshotConfig) {
  572|      3|        self.screenshot = Some(ScreenshotState::new(config));
  573|      3|        self.view_mode = ViewMode::Rendered;
  574|      3|        self.write_enabled = false;
  575|      3|        self.show_search = false;
  576|      3|        self.search_focus_requested = false;
  577|      3|        self.nav_request = None;
  578|      3|    }
  579|       |
  580|       |    /// Check if file has valid markdown extension
  581|    143|    fn is_valid_markdown_file(&self, path: &Path) -> bool {
  582|    143|        if let Some(ext) = path.extension() {
                                  ^142
  583|    142|            let ext = ext.to_string_lossy().to_lowercase();
  584|    142|            matches!(ext.as_str(), "md" | "markdown" | "mdown" | "mkd" | "txt")
                          ^135                          ^13          ^10       ^9      ^8
  585|       |        } else {
  586|      1|            false
  587|       |        }
  588|    143|    }
  589|       |
  590|       |    /// Handle dropped files from drag-and-drop operation
  591|     16|    fn handle_file_drop(&mut self, paths: Vec<PathBuf>) {
  592|     16|        if paths.is_empty() {
  593|      1|            return;
  594|     15|        }
  595|       |
  596|     15|        let mut valid_files = Vec::new();
  597|     15|        let mut errors = Vec::new();
  598|       |
  599|       |        // Validate all dropped files
  600|    147|        for path in paths {
                          ^132
  601|    132|            if !path.exists() {
  602|      3|                errors.push(format!("File not found: {}", path.display()));
  603|      3|                continue;
  604|    129|            }
  605|       |
  606|    129|            if path.is_dir() {
  607|       |                // Handle directory by scanning for markdown files
  608|      4|                match self.scan_directory(&path) {
  609|      3|                    Ok(dir_files) => {
  610|      3|                        if dir_files.is_empty() {
  611|      2|                            errors.push(format!(
  612|      2|                                "No markdown files in directory: {}",
  613|      2|                                path.display()
  614|      2|                            ));
  615|      2|                        } else {
  616|      1|                            valid_files.extend(dir_files);
  617|      1|                        }
  618|       |                    }
  619|      1|                    Err(e) => {
  620|      1|                        errors.push(format!("Cannot read directory {}: {}", path.display(), e));
  621|      1|                    }
  622|       |                }
  623|      4|                continue;
  624|    125|            }
  625|       |
  626|    125|            if !self.is_valid_markdown_file(&path) {
  627|      3|                errors.push(format!(
  628|      3|                    "Not a markdown file: {}",
  629|      3|                    path.file_name().unwrap_or_default().to_string_lossy()
  630|       |                ));
  631|      3|                continue;
  632|    122|            }
  633|       |
  634|    122|            valid_files.push(path);
  635|       |        }
  636|       |
  637|       |        // Limit to prevent memory issues
  638|       |        const MAX_FILES: usize = 50;
  639|     15|        if valid_files.len() > MAX_FILES {
  640|      2|            self.error_message = Some(format!(
  641|      2|                "Too many files ({}). Maximum is {}.\n\
  642|      2|                 Please drop files in smaller batches.",
  643|      2|                valid_files.len(),
  644|      2|                MAX_FILES
  645|      2|            ));
  646|      2|            return;
  647|     13|        }
  648|       |
  649|       |        // Handle valid files
  650|     13|        if !valid_files.is_empty() {
  651|       |            // Open first file immediately
  652|      7|            let first_file = valid_files.remove(0);
  653|      7|            if let Err(e) = self.load_file(first_file, true) {
                                     ^1
  654|      1|                self.error_message = Some(format!("Failed to load file: {}", e));
  655|      1|                return;
  656|      6|            }
  657|       |
  658|       |            // Queue remaining files
  659|      6|            self.pending_files.extend(valid_files.iter().cloned());
  660|       |
  661|       |            // Show info message if multiple files
  662|      6|            if !self.pending_files.is_empty() {
  663|      3|                eprintln!(
  664|      3|                    "Queued {} files. Use Alt+Right to navigate to the next file.",
  665|      3|                    self.pending_files.len()
  666|      3|                );
  667|      3|            }
  668|      6|        }
  669|       |
  670|       |        // Show errors if any
  671|     12|        if !errors.is_empty() {
  672|      8|            let valid_count = if valid_files.is_empty() {
  673|      7|                0
  674|       |            } else {
  675|      1|                valid_files.len() + 1
  676|       |            };
  677|      8|            let error_msg = if errors.len() == 1 && valid_count == 0 {
                                                                  ^7
  678|      6|                errors[0].clone()
  679|      2|            } else if valid_count == 0 {
  680|       |                // All files failed
  681|      1|                format!("No valid files:\n{}", errors.join("\n"))
  682|       |            } else {
  683|       |                // Some succeeded, some failed
  684|      1|                format!(
  685|      1|                    "Opened {} files. Skipped {}:\n{}",
  686|       |                    valid_count,
  687|      1|                    errors.len(),
  688|      1|                    errors.join("\n")
  689|       |                )
  690|       |            };
  691|      8|            self.error_message = Some(error_msg);
  692|      4|        }
  693|     16|    }
  694|       |
  695|       |    /// Scan directory for markdown files (non-recursive)
  696|      6|    fn scan_directory(&self, dir: &Path) -> Result<Vec<PathBuf>> {
  697|       |        #[cfg(test)]
  698|      6|        if take_forced_scan_error() {
  699|      1|            bail!("Forced scan error");
  700|      5|        }
  701|       |
  702|      5|        let mut files = Vec::new();
  703|       |
  704|      5|        let entries = std::fs::read_dir(dir)?;
                                                          ^0
  705|       |
  706|     13|        for entry in entries {
                          ^8
  707|      8|            let entry = entry?;
                                           ^0
  708|      8|            let path = entry.path();
  709|       |
  710|       |            // Only include files (not subdirectories)
  711|      8|            if path.is_file() && self.is_valid_markdown_file(&path) {
                                               ^7   ^7                     ^7
  712|      6|                files.push(path);
  713|      6|            }
                          ^2
  714|       |        }
  715|       |
  716|       |        // Sort alphabetically for predictable order
  717|      5|        files.sort();
  718|       |
  719|      5|        Ok(files)
  720|      6|    }
  721|       |
  722|       |    /// Load markdown content from a string
  723|    229|    pub fn load_content(&mut self, content: &str, title: Option<String>) {
  724|    229|        self.pending_file_load = None;
  725|    229|        self.current_content = content.to_string();
  726|    229|        self.raw_buffer = self.current_content.clone();
  727|    229|        self.error_message = None;
  728|    229|        self.nav_request = None; // Reset any pending navigation
  729|       |                                 // Ensure scroll resets to top on new content
  730|    229|        self.pending_scroll_to_element = Some(0);
  731|    229|        self.renderer.clear_table_layout_cache();
  732|       |
  733|    229|        match self.renderer.parse(content) {
  734|    228|            Ok(elements) => {
  735|    228|                self.parsed_elements = elements;
  736|    228|                if let Some(title) = title {
                                          ^227
  737|    227|                    self.title = format!("{APP_TITLE_PREFIX} - {}", title);
  738|    227|                }
                              ^1
  739|       |            }
  740|      1|            Err(e) => {
  741|      1|                self.error_message = Some(format!("Failed to parse markdown: {}", e));
  742|      1|                self.parsed_elements.clear();
  743|      1|            }
  744|       |        }
  745|    229|    }
  746|       |
  747|       |    /// Load markdown content from a file path
  748|     27|    pub fn load_file(&mut self, path: PathBuf, record_history: bool) -> Result<()> {
  749|       |        #[cfg(test)]
  750|     27|        if take_forced_load_error() {
  751|      3|            bail!("Forced load error");
  752|     24|        }
  753|       |
  754|       |        // Push current state to history before loading new file
  755|     24|        if record_history && !self.current_content.is_empty() {
                                           ^19
  756|     18|            self.push_history();
  757|     18|        }
                      ^6
  758|       |
  759|     24|        let file_size = std::fs::metadata(&path).ok().map(|m| m.len());
                                                                            ^23^23
  760|     24|        let use_async = self.screenshot.is_none()
  761|     23|            && file_size.is_some_and(|size| size >= ASYNC_LOAD_THRESHOLD_BYTES);
                                                          ^22
  762|     24|        if use_async {
  763|      2|            let load_id = self.next_file_load_id;
  764|      2|            self.next_file_load_id = self.next_file_load_id.wrapping_add(1);
  765|      2|            let request = FileLoadRequest {
  766|      2|                id: load_id,
  767|      2|                path: path.clone(),
  768|      2|            };
  769|      2|            if self.file_load_tx.send(request).is_ok() {
  770|      1|                self.pending_file_load = Some(PendingFileLoad { id: load_id, path });
  771|      1|                return Ok(());
  772|      1|            }
  773|     22|        }
  774|       |
  775|     23|        let (content, lossy) = Self::read_file_lossy(&path)?;
                           ^22      ^22                                  ^1
  776|     22|        let filename = path
  777|     22|            .file_name()
  778|     22|            .and_then(|n| n.to_str())
  779|     22|            .unwrap_or("Unknown")
  780|     22|            .to_string();
  781|       |
  782|     22|        let base = path.parent().map(|p| p.to_path_buf());
  783|     22|        self.renderer.set_base_dir(base.as_deref());
  784|     22|        self.current_file = Some(path);
  785|     22|        self.load_content(&content, Some(filename));
  786|     22|        if lossy {
  787|      1|            eprintln!("Loaded file with invalid UTF-8; replaced invalid sequences.");
  788|     21|        }
  789|     22|        Ok(())
  790|     27|    }
  791|       |
  792|       |    /// Normalize all line endings to Unix style (\n)
  793|       |    /// Handles Windows (\r\n), Unix (\n), and old Mac (\r) formats
  794|     31|    fn normalize_line_endings(s: &str) -> String {
  795|       |        // Order matters: replace \r\n first (Windows), then remaining \r (old Mac)
  796|     31|        let normalized = s.replace("\r\n", "\n").replace('\r', "\n");
  797|     31|        if let Some(stripped) = normalized.strip_prefix('\u{FEFF}') {
                                  ^1
  798|      1|            stripped.to_string()
  799|       |        } else {
  800|     30|            normalized
  801|       |        }
  802|     31|    }
  803|       |
  804|     26|    fn read_file_lossy(path: &Path) -> Result<(String, bool)> {
  805|     26|        match std::fs::read_to_string(path) {
  806|     23|            Ok(s) => Ok((Self::normalize_line_endings(&s), false)),
  807|      3|            Err(e) if e.kind() == ErrorKind::InvalidData => {
                              ^1                                     ^1
  808|      1|                let bytes = std::fs::read(path)?;
                                                             ^0
  809|      1|                let s = String::from_utf8_lossy(&bytes).into_owned();
  810|      1|                Ok((Self::normalize_line_endings(&s), true))
  811|       |            }
  812|      2|            Err(e) => Err(e.into()),
  813|       |        }
  814|     26|    }
  815|       |
  816|    162|    fn spawn_named_thread(
  817|    162|        name: &str,
  818|    162|        f: impl FnOnce() + Send + 'static,
  819|    162|    ) -> std::io::Result<std::thread::JoinHandle<()>> {
  820|       |        #[cfg(test)]
  821|    162|        if FORCE_THREAD_SPAWN_ERROR.swap(false, Ordering::Relaxed) {
  822|      1|            return Err(std::io::Error::new(
  823|      1|                ErrorKind::Other,
  824|      1|                "forced thread spawn failure",
  825|      1|            ));
  826|    161|        }
  827|    161|        std::thread::Builder::new().name(name.to_string()).spawn(f)
  828|    162|    }
  829|       |
  830|       |    #[cfg(test)]
  831|      1|    fn force_thread_spawn_error_for_test() {
  832|      1|        FORCE_THREAD_SPAWN_ERROR.store(true, Ordering::Relaxed);
  833|      1|    }
  834|       |
  835|    162|    fn spawn_file_loader() -> (Sender<FileLoadRequest>, Receiver<FileLoadResult>) {
  836|    162|        let (request_tx, request_rx) = unbounded::<FileLoadRequest>();
  837|    162|        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
  838|    162|        if let Err(err) = Self::spawn_named_thread("mdmdview-file-loader", move || {
                                 ^1                                                              ^161
  839|    161|            for request in request_rx.iter() {
                              ^3
  840|      3|                let content = MarkdownViewerApp::read_file_lossy(&request.path)
  841|      3|                    .map_err(|err| err.to_string());
                                                 ^1  ^1
  842|      3|                let _ = result_tx.send(FileLoadResult {
  843|      3|                    id: request.id,
  844|      3|                    content,
  845|      3|                });
  846|       |            }
  847|    161|        }) {
  848|      1|            eprintln!("Failed to start file loader thread: {err}");
  849|    161|        }
  850|    162|        (request_tx, result_rx)
  851|    162|    }
  852|       |
  853|     35|    fn poll_file_loads(&mut self) {
  854|     39|        while let Ok(result) = self.file_load_rx.try_recv() {
                                   ^4
  855|      4|            let pending = match &self.pending_file_load {
                              ^3
  856|      4|                Some(pending) if pending.id == result.id => pending.clone(),
                                                                     ^3   ^3      ^3
  857|      1|                _ => continue,
  858|       |            };
  859|      3|            self.pending_file_load = None;
  860|      3|            match result.content {
  861|      2|                Ok((content, lossy)) => {
  862|      2|                    let filename = pending
  863|      2|                        .path
  864|      2|                        .file_name()
  865|      2|                        .and_then(|n| n.to_str())
  866|      2|                        .unwrap_or("Unknown")
  867|      2|                        .to_string();
  868|      2|                    let base = pending.path.parent().map(|p| p.to_path_buf());
  869|      2|                    self.renderer.set_base_dir(base.as_deref());
  870|      2|                    self.current_file = Some(pending.path);
  871|      2|                    self.load_content(&content, Some(filename));
  872|      2|                    if lossy {
  873|      1|                        eprintln!("Loaded file with invalid UTF-8; replaced invalid sequences.");
  874|      1|                    }
  875|       |                }
  876|      1|                Err(err) => {
  877|      1|                    self.error_message = Some(format!("Failed to load file: {err}"));
  878|      1|                }
  879|       |            }
  880|       |        }
  881|     35|    }
  882|       |
  883|     10|    fn current_window_state(&self) -> Option<WindowState> {
  884|     10|        let pos = self.last_window_pos?;
                          ^8                        ^2
  885|      8|        let size = self.last_window_size?;
                                                      ^0
  886|      8|        Some(WindowState {
  887|      8|            pos,
  888|      8|            size,
  889|      8|            maximized: self.last_window_maximized,
  890|      8|        })
  891|     10|    }
  892|       |
  893|     40|    fn compute_window_adjustment(
  894|     40|        outer_rect: Option<egui::Rect>,
  895|     40|        inner_rect: Option<egui::Rect>,
  896|     40|        monitor_size: Option<egui::Vec2>,
  897|     40|    ) -> Option<WindowAdjustment> {
  898|     40|        let outer = outer_rect?;
                          ^14               ^26
  899|     14|        let inner = inner_rect.unwrap_or(outer);
  900|     14|        let monitor = monitor_size?;
                                                ^0
  901|       |
  902|     14|        if monitor.x <= 0.0 || monitor.y <= 0.0 {
                                             ^13
  903|      2|            return None;
  904|     12|        }
  905|       |
  906|       |        const MIN_WIDTH: f32 = 600.0;
  907|       |        const MIN_HEIGHT: f32 = 400.0;
  908|       |        const OFFSCREEN_TOLERANCE: f32 = 32.0;
  909|       |
  910|     12|        let mut pos = outer.min;
  911|     12|        let mut size = inner.size();
  912|     12|        let mut pos_adjusted = false;
  913|     12|        let mut size_adjusted = false;
  914|       |
  915|     12|        if !pos.x.is_finite() || !pos.y.is_finite() {
                                               ^10
  916|      3|            pos = egui::pos2(0.0, 0.0);
  917|      3|            pos_adjusted = true;
  918|      9|        }
  919|     12|        if !size.x.is_finite() || !size.y.is_finite() {
                                                ^11
  920|      2|            size = egui::vec2(MIN_WIDTH, MIN_HEIGHT);
  921|      2|            size_adjusted = true;
  922|     10|        }
  923|       |
  924|     12|        let outer_size = outer.size();
  925|     12|        let inner_size = inner.size();
  926|     12|        let frame = egui::vec2(
  927|     12|            (outer_size.x - inner_size.x).max(0.0),
  928|     12|            (outer_size.y - inner_size.y).max(0.0),
  929|       |        );
  930|       |
  931|     12|        let available_width = (monitor.x - frame.x).max(MIN_WIDTH);
  932|     12|        let available_height = (monitor.y - frame.y).max(MIN_HEIGHT);
  933|       |
  934|     12|        if size.x < MIN_WIDTH {
  935|      3|            size.x = MIN_WIDTH.min(available_width);
  936|      3|            size_adjusted = true;
  937|      9|        }
  938|     12|        if size.y < MIN_HEIGHT {
  939|      3|            size.y = MIN_HEIGHT.min(available_height);
  940|      3|            size_adjusted = true;
  941|      9|        }
  942|     12|        if size.x > available_width {
  943|      1|            size.x = available_width;
  944|      1|            size_adjusted = true;
  945|     11|        }
  946|     12|        if size.y > available_height {
  947|      1|            size.y = available_height;
  948|      1|            size_adjusted = true;
  949|     11|        }
  950|       |
  951|     12|        let outer_size_for_bounds = size + frame;
  952|     12|        let max_pos = egui::pos2(
  953|     12|            (monitor.x - outer_size_for_bounds.x).max(0.0),
  954|     12|            (monitor.y - outer_size_for_bounds.y).max(0.0),
  955|       |        );
  956|       |
  957|     12|        if pos.x <= -0.25 * outer_size_for_bounds.x {
  958|      1|            pos.x = 0.0;
  959|      1|            pos_adjusted = true;
  960|     11|        }
  961|     12|        if pos.y <= -0.25 * outer_size_for_bounds.y {
  962|      2|            pos.y = 0.0;
  963|      2|            pos_adjusted = true;
  964|     10|        }
  965|     12|        if pos.x > max_pos.x + OFFSCREEN_TOLERANCE {
  966|      2|            pos.x = max_pos.x;
  967|      2|            pos_adjusted = true;
  968|     10|        }
  969|     12|        if pos.y > max_pos.y + OFFSCREEN_TOLERANCE {
  970|      2|            pos.y = max_pos.y;
  971|      2|            pos_adjusted = true;
  972|     10|        }
  973|       |
  974|     12|        if pos_adjusted || size_adjusted {
                                         ^5
  975|     10|            size.x = size.x.max(MIN_WIDTH.min(available_width));
  976|     10|            size.y = size.y.max(MIN_HEIGHT.min(available_height));
  977|     10|            Some(WindowAdjustment {
  978|     10|                pos: pos_adjusted.then_some(pos),
  979|     10|                size: size_adjusted.then_some(size),
  980|     10|            })
  981|       |        } else {
  982|      2|            None
  983|       |        }
  984|     40|    }
  985|       |
  986|     12|    fn window_state_changed(&self, new_state: &WindowState) -> bool {
  987|     12|        match &self.last_persisted_state {
  988|      5|            Some(prev) => {
  989|      5|                let pos_changed = (prev.pos[0] - new_state.pos[0]).abs() > 0.5
  990|      4|                    || (prev.pos[1] - new_state.pos[1]).abs() > 0.5;
  991|      5|                let size_changed = (prev.size[0] - new_state.size[0]).abs() > 0.5
  992|      4|                    || (prev.size[1] - new_state.size[1]).abs() > 0.5;
  993|      5|                let maximized_changed = prev.maximized != new_state.maximized;
  994|      5|                pos_changed || size_changed || maximized_changed
                                             ^4              ^3
  995|       |            }
  996|      7|            None => true,
  997|       |        }
  998|     12|    }
  999|       |
 1000|     39|    fn fold_for_search(input: &str) -> String {
 1001|     39|        input.case_fold().nfkc().collect()
 1002|     39|    }
 1003|       |
 1004|       |    /// Push current state to navigation history
 1005|     48|    fn push_history(&mut self) {
 1006|       |        // Truncate forward history if we're not at the end
 1007|     48|        if self.history_index < self.history.len() {
 1008|      2|            self.history.truncate(self.history_index);
 1009|     46|        }
 1010|       |
 1011|       |        // Create entry for current state
 1012|     48|        let entry = HistoryEntry {
 1013|     48|            file_path: self.current_file.clone(),
 1014|     48|            title: self.title.clone(),
 1015|     48|            content: self.current_content.clone(),
 1016|     48|        };
 1017|       |
 1018|     48|        self.history.push(entry);
 1019|       |
 1020|       |        // Limit history size
 1021|     48|        if self.history.len() > self.max_history {
 1022|      1|            self.history.remove(0);
 1023|     47|        } else {
 1024|     47|            self.history_index = self.history.len();
 1025|     47|        }
 1026|     48|    }
 1027|       |
 1028|       |    /// Navigate back in history
 1029|      4|    fn navigate_back(&mut self) -> bool {
 1030|      4|        if self.history_index > 0 {
 1031|      3|            self.history_index -= 1;
 1032|      3|            self.restore_from_history();
 1033|      3|            true
 1034|       |        } else {
 1035|      1|            false
 1036|       |        }
 1037|      4|    }
 1038|       |
 1039|       |    /// Navigate forward in history
 1040|      7|    fn navigate_forward(&mut self) -> bool {
 1041|       |        // First try pending files queue
 1042|      7|        if let Some(next_file) = self.pending_files.pop_front() {
                                  ^2
 1043|       |            // Load next file from queue
 1044|      2|            if let Err(e) = self.load_file(next_file, true) {
                                     ^1
 1045|      1|                self.error_message = Some(format!("Failed to load file: {}", e));
 1046|      1|            }
 1047|      2|            return true;
 1048|      5|        }
 1049|       |
 1050|       |        // Otherwise use history navigation (existing code)
 1051|      5|        if self.history_index < self.history.len().saturating_sub(1) {
 1052|      2|            self.history_index += 1;
 1053|      2|            self.restore_from_history();
 1054|      2|            true
 1055|       |        } else {
 1056|      3|            false
 1057|       |        }
 1058|      7|    }
 1059|       |
 1060|       |    /// Restore state from history at current index
 1061|      8|    fn restore_from_history(&mut self) {
 1062|      8|        if let Some(entry) = self.history.get(self.history_index) {
                                  ^7
 1063|      7|            self.current_file = entry.file_path.clone();
 1064|      7|            self.title = entry.title.clone();
 1065|      7|            self.current_content = entry.content.clone();
 1066|      7|            self.raw_buffer = self.current_content.clone();
 1067|       |
 1068|       |            // Re-parse content
 1069|      7|            match self.renderer.parse(&self.current_content) {
 1070|      6|                Ok(elements) => {
 1071|      6|                    self.parsed_elements = elements;
 1072|      6|                    self.error_message = None;
 1073|      6|                }
 1074|      1|                Err(e) => {
 1075|      1|                    self.error_message = Some(format!("Failed to parse: {}", e));
 1076|      1|                }
 1077|       |            }
 1078|       |
 1079|       |            // Set base dir for images
 1080|      7|            if let Some(ref path) = self.current_file {
                                      ^1
 1081|      1|                self.renderer.set_base_dir(path.parent());
 1082|      6|            } else {
 1083|      6|                self.renderer.set_base_dir(None);
 1084|      6|            }
 1085|       |
 1086|       |            // Scroll to top
 1087|      7|            self.pending_scroll_to_element = Some(0);
 1088|      1|        }
 1089|      8|    }
 1090|       |
 1091|       |    /// Check if we can navigate back
 1092|     34|    fn can_navigate_back(&self) -> bool {
 1093|     34|        self.history_index > 0
 1094|     34|    }
 1095|       |
 1096|       |    /// Check if we can navigate forward
 1097|     35|    fn can_navigate_forward(&self) -> bool {
 1098|     35|        !self.pending_files.is_empty() || self.history_index < self.history.len().saturating_sub(1)
                                                        ^33                  ^33
 1099|     35|    }
 1100|       |
 1101|       |    /// Request a reload of the current file (processed outside of input context)
 1102|      4|    fn request_reload(&mut self) {
 1103|      4|        if self.current_file.is_some() {
 1104|      1|            self.reload_requested = true;
 1105|      3|        } else {
 1106|      3|            self.error_message = Some("No file loaded to reload".to_string());
 1107|      3|        }
 1108|      4|    }
 1109|       |
 1110|       |    /// Reload the currently opened file from disk
 1111|      4|    pub fn reload_current_file(&mut self) -> Result<()> {
 1112|      4|        let path = if let Some(p) = self.current_file.clone() {
                          ^2                 ^2
 1113|      2|            p
 1114|       |        } else {
 1115|      2|            bail!("No file loaded to reload");
 1116|       |        };
 1117|      2|        self.load_file(path, false)
 1118|      4|    }
 1119|       |
 1120|       |    /// Load a sample file by name
 1121|     27|    pub fn load_sample(&mut self, sample: &SampleFile) {
 1122|       |        // Push current state to history before loading sample
 1123|     27|        if !self.current_content.is_empty() {
 1124|     26|            self.push_history();
 1125|     26|        }
                      ^1
 1126|       |
 1127|     27|        self.current_file = None;
 1128|       |        // Samples have no file base-dir
 1129|     27|        self.renderer.set_base_dir(None);
 1130|     27|        self.load_content(sample.content, Some(sample.title.to_string()));
 1131|       |        // Scroll to top for new sample
 1132|     27|        self.pending_scroll_to_element = Some(0);
 1133|     27|    }
 1134|       |
 1135|      8|    fn load_sample_by_name(&mut self, samples: &[SampleFile], name: &str) -> bool {
 1136|     16|        if let Some(sample) = samples.iter().find(|sample| sample.name == name) {
                                  ^7        ^8             ^8
 1137|      7|            self.load_sample(sample);
 1138|      7|            return true;
 1139|      1|        }
 1140|      1|        false
 1141|      8|    }
 1142|       |
 1143|    167|    fn load_welcome_from_samples(&mut self, samples: &[SampleFile], scroll_to_top: bool) {
 1144|    167|        if let Some(welcome) = samples.iter().find(|sample| sample.name == "welcome.md") {
                                  ^166                                    ^166           ^166
 1145|    166|            self.load_content(welcome.content, Some("Welcome".to_string()));
 1146|    166|            if scroll_to_top {
 1147|      7|                self.pending_scroll_to_element = Some(0);
 1148|    159|            }
 1149|      1|        } else {
 1150|      1|            // Fallback if welcome file is missing
 1151|      1|            self.current_content.clear();
 1152|      1|            self.parsed_elements.clear();
 1153|      1|            self.title = APP_TITLE_PREFIX.to_string();
 1154|      1|            self.error_message = None;
 1155|      1|        }
 1156|    167|    }
 1157|       |
 1158|       |    /// Close the current file and return to welcome screen
 1159|      6|    pub fn close_current_file(&mut self) {
 1160|      6|        self.current_file = None;
 1161|      6|        self.renderer.set_base_dir(None);
 1162|      6|        self.load_welcome_from_samples(SAMPLE_FILES, true);
 1163|      6|    }
 1164|       |
 1165|       |    #[cfg(not(test))]
 1166|       |    fn request_close(&self, ctx: &Context) {
 1167|       |        ctx.send_viewport_cmd(egui::ViewportCommand::Close);
 1168|       |    }
 1169|       |
 1170|       |    #[cfg(test)]
 1171|      2|    fn request_close(&self, _ctx: &Context) {}
 1172|       |
 1173|       |    #[cfg(not(test))]
 1174|       |    fn pick_open_path(&self) -> Option<PathBuf> {
 1175|       |        FileDialog::new()
 1176|       |            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
 1177|       |            .add_filter("All files", &["*"])
 1178|       |            .set_title("Open Markdown File")
 1179|       |            .pick_file()
 1180|       |    }
 1181|       |
 1182|       |    #[cfg(test)]
 1183|      8|    fn pick_open_path(&self) -> Option<PathBuf> {
 1184|      8|        take_forced_open_path()
 1185|      8|    }
 1186|       |
 1187|       |    #[cfg(not(test))]
 1188|       |    fn pick_save_path(&self) -> Option<PathBuf> {
 1189|       |        FileDialog::new()
 1190|       |            .set_title("Save Markdown File")
 1191|       |            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
 1192|       |            .save_file()
 1193|       |    }
 1194|       |
 1195|       |    #[cfg(test)]
 1196|      5|    fn pick_save_path(&self) -> Option<PathBuf> {
 1197|      5|        take_forced_save_path()
 1198|      5|    }
 1199|       |
 1200|       |    /// Open file dialog to select a markdown file
 1201|      8|    fn open_file_dialog(&mut self) {
 1202|      8|        if let Some(path) = self.pick_open_path() {
                                  ^5
 1203|      5|            if let Err(e) = self.load_file(path, true) {
                                     ^1
 1204|      1|                self.error_message = Some(format!("Failed to open file: {}", e));
 1205|      4|            }
 1206|      3|        }
 1207|      8|    }
 1208|       |
 1209|       |    /// Toggle between Rendered and Raw view
 1210|      9|    fn toggle_view_mode(&mut self, ctx: &Context) {
 1211|       |        // If leaving Raw view while editing, capture cursor before switching
 1212|      9|        if matches!(self.view_mode, ViewMode::Raw) && self.write_enabled {
                         ^4                                         ^5
 1213|      4|            let editor_id = egui::Id::new("raw_editor");
 1214|      4|            if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
                                      ^2
 1215|      2|                if let Some(range) = state.cursor.char_range() {
                                          ^1
 1216|      1|                    self.raw_cursor = Some(range.primary.index);
 1217|      1|                }
 1218|      2|            }
 1219|      5|        }
 1220|      9|        self.view_mode = match self.view_mode {
 1221|       |            ViewMode::Rendered => {
 1222|      4|                self.raw_focus_requested = true;
 1223|      4|                ViewMode::Raw
 1224|       |            }
 1225|      5|            ViewMode::Raw => ViewMode::Rendered,
 1226|       |        };
 1227|      9|    }
 1228|       |
 1229|       |    /// Handle keyboard shortcuts
 1230|     53|    fn handle_shortcuts(&mut self, ctx: &Context) {
 1231|     53|        ctx.input_mut(|i| {
 1232|     53|            let in_raw_edit = matches!(self.view_mode, ViewMode::Raw) && self.write_enabled;
                                            ^44                                        ^9
 1233|       |            // Ctrl+O - Open file
 1234|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1235|     53|                egui::Modifiers::CTRL,
 1236|     53|                egui::Key::O,
 1237|     53|            )) {
 1238|      1|                self.open_file_dialog();
 1239|     52|            }
 1240|       |
 1241|       |            // Alt-based accelerators for common actions (mnemonics)
 1242|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1243|     53|                egui::Modifiers::ALT,
 1244|     53|                egui::Key::O,
 1245|     53|            )) {
 1246|      1|                self.open_file_dialog();
 1247|     52|            }
 1248|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1249|     53|                egui::Modifiers::ALT,
 1250|     53|                egui::Key::W,
 1251|     53|            )) {
 1252|      1|                self.close_current_file();
 1253|     52|            }
 1254|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1255|     53|                egui::Modifiers::ALT,
 1256|     53|                egui::Key::Q,
 1257|     53|            )) {
 1258|      1|                self.request_close(ctx);
 1259|     52|            }
 1260|       |
 1261|       |            // Ctrl+Q - Quit application
 1262|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1263|     53|                egui::Modifiers::CTRL,
 1264|     53|                egui::Key::Q,
 1265|     53|            )) {
 1266|      1|                self.request_close(ctx);
 1267|     52|            }
 1268|       |
 1269|       |            // Ctrl+W - Close current file
 1270|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1271|     53|                egui::Modifiers::CTRL,
 1272|     53|                egui::Key::W,
 1273|     53|            )) {
 1274|      1|                self.close_current_file();
 1275|     52|            }
 1276|       |
 1277|       |            // Ctrl+F - Open search dialog
 1278|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1279|     53|                egui::Modifiers::CTRL,
 1280|     53|                egui::Key::F,
 1281|     53|            )) {
 1282|      3|                self.show_search = true;
 1283|      3|                if self.last_match_index.is_none() {
 1284|      2|                    self.last_match_index = Some(0);
 1285|      2|                }
                              ^1
 1286|      3|                self.search_focus_requested = true;
 1287|     50|            }
 1288|       |
 1289|       |            // F3 navigation: next / previous
 1290|     53|            let prev_shift = i.consume_shortcut(&egui::KeyboardShortcut::new(
 1291|     53|                egui::Modifiers::SHIFT,
 1292|     53|                egui::Key::F3,
 1293|     53|            ));
 1294|     53|            let prev_alt = i.consume_shortcut(&egui::KeyboardShortcut::new(
 1295|     53|                egui::Modifiers::ALT,
 1296|     53|                egui::Key::F3,
 1297|     53|            ));
 1298|     53|            if prev_shift || prev_alt {
                                           ^51
 1299|      3|                self.find_previous();
 1300|     50|            } else if i.consume_key(egui::Modifiers::NONE, egui::Key::F3) {
 1301|      1|                self.find_next();
 1302|     49|            }
 1303|       |
 1304|       |            // Ctrl+Plus - Zoom in
 1305|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1306|     53|                egui::Modifiers::CTRL,
 1307|     53|                egui::Key::Plus,
 1308|     53|            )) {
 1309|      1|                self.renderer.zoom_in();
 1310|     52|            }
 1311|       |
 1312|       |            // Ctrl+Minus - Zoom out
 1313|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1314|     53|                egui::Modifiers::CTRL,
 1315|     53|                egui::Key::Minus,
 1316|     53|            )) {
 1317|      1|                self.renderer.zoom_out();
 1318|     52|            }
 1319|       |
 1320|       |            // Ctrl+0 - Reset zoom
 1321|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1322|     53|                egui::Modifiers::CTRL,
 1323|     53|                egui::Key::Num0,
 1324|     53|            )) {
 1325|      1|                self.renderer.reset_zoom();
 1326|     52|            }
 1327|       |
 1328|       |            // Alt+Left - Navigate back
 1329|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1330|     53|                egui::Modifiers::ALT,
 1331|     53|                egui::Key::ArrowLeft,
 1332|     53|            )) {
 1333|      1|                self.navigate_back();
 1334|     52|            }
 1335|       |
 1336|       |            // Alt+Right - Navigate forward
 1337|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1338|     53|                egui::Modifiers::ALT,
 1339|     53|                egui::Key::ArrowRight,
 1340|     53|            )) {
 1341|      1|                self.navigate_forward();
 1342|     52|            }
 1343|       |
 1344|       |            // Ctrl + Mouse Wheel - Zoom
 1345|     53|            if i.modifiers.ctrl {
 1346|      6|                let mut total = 0.0f32;
 1347|     11|                for ev in &i.events {
                                  ^5
 1348|      5|                    if let egui::Event::MouseWheel { delta, .. } = ev {
                                                                   ^4
 1349|      4|                        total += delta.y;
 1350|      4|                    }
                                  ^1
 1351|       |                }
 1352|      6|                if total.abs() > 0.0 {
 1353|      4|                    if total > 0.0 {
 1354|      2|                        self.renderer.zoom_in();
 1355|      2|                    } else {
 1356|      2|                        self.renderer.zoom_out();
 1357|      2|                    }
 1358|      2|                }
 1359|     47|            }
 1360|       |
 1361|       |            // Ctrl+R - Toggle raw view
 1362|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1363|     53|                egui::Modifiers::CTRL,
 1364|     53|                egui::Key::R,
 1365|     53|            )) {
 1366|      1|                // Defer to avoid acting inside input context
 1367|      1|                self.view_toggle_requested = true;
 1368|     52|            }
 1369|       |            // Ctrl+E - Toggle write mode (deferred)
 1370|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1371|     53|                egui::Modifiers::CTRL,
 1372|     53|                egui::Key::E,
 1373|     53|            )) {
 1374|      1|                self.write_toggle_requested = true;
 1375|     52|            }
 1376|       |            // Ctrl+S - Save document
 1377|     53|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
 1378|     53|                egui::Modifiers::CTRL,
 1379|     53|                egui::Key::S,
 1380|     53|            )) {
 1381|      2|                if let Err(e) = self.save_current_document() {
                                         ^1
 1382|      1|                    self.error_message = Some(format!("Failed to save: {}", e));
 1383|      1|                }
 1384|     51|            }
 1385|       |            // Note: No global Alt+R to avoid conflict (File > Reload vs View > Raw)
 1386|       |
 1387|       |            // F11 - Toggle fullscreen (set flag to handle outside input context)
 1388|     53|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F11) {
 1389|      1|                self.toggle_fullscreen = true;
 1390|     52|            }
 1391|       |
 1392|       |            // F5 - Reload current file (set flag; actual IO handled outside input context)
 1393|     53|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F5) {
 1394|      1|                self.request_reload();
 1395|     52|            }
 1396|       |
 1397|       |            // Esc - dismiss search dialog if visible
 1398|     53|            if self.show_search && i.consume_key(egui::Modifiers::NONE, egui::Key::Escape) {
                                                 ^6^6                                 ^6
 1399|      1|                self.clear_search_state();
 1400|      1|                self.show_search = false;
 1401|     52|            }
 1402|       |
 1403|       |            // Only consume navigation keys when not editing in raw view
 1404|     53|            if !in_raw_edit {
 1405|     45|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
 1406|      1|                    self.nav_request = Some(NavigationRequest::PageUp);
 1407|     44|                }
 1408|     45|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
 1409|      1|                    self.nav_request = Some(NavigationRequest::PageDown);
 1410|     44|                }
 1411|       |                // Home - Go to top of document
 1412|     45|                if i.consume_key(egui::Modifiers::NONE, egui::Key::Home) {
 1413|      1|                    self.nav_request = Some(NavigationRequest::Top);
 1414|     44|                }
 1415|       |
 1416|       |                // End - Go to bottom of document
 1417|     45|                if i.consume_key(egui::Modifiers::NONE, egui::Key::End) {
 1418|      1|                    self.nav_request = Some(NavigationRequest::Bottom);
 1419|     44|                }
 1420|       |
 1421|       |                // Arrow Up - Fine scroll up
 1422|     45|                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowUp) {
 1423|      1|                    self.nav_request = Some(NavigationRequest::ScrollUp);
 1424|     44|                }
 1425|       |
 1426|       |                // Arrow Down - Fine scroll down
 1427|     45|                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowDown) {
 1428|      1|                    self.nav_request = Some(NavigationRequest::ScrollDown);
 1429|     44|                }
 1430|       |            } else {
 1431|       |                // In raw edit mode: implement PageUp/PageDown by moving caret by ~a page of lines
 1432|       |                const PAGE_LINES: i32 = 24; // match desired_rows for the editor
 1433|      8|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
 1434|      1|                    self.pending_raw_cursor_line_move = Some(-PAGE_LINES);
 1435|      1|                    self.raw_focus_requested = true;
 1436|      7|                }
 1437|      8|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
 1438|      1|                    self.pending_raw_cursor_line_move = Some(PAGE_LINES);
 1439|      1|                    self.raw_focus_requested = true;
 1440|      7|                }
 1441|       |            }
 1442|     53|        });
 1443|     53|    }
 1444|       |
 1445|     35|    fn render_file_menu_contents(
 1446|     35|        &mut self,
 1447|     35|        ui: &mut egui::Ui,
 1448|     35|        alt_pressed: bool,
 1449|     35|        menu_text_color: Color32,
 1450|     35|    ) {
 1451|     35|        ui.horizontal(|ui| {
 1452|     35|            let clicked = ui
 1453|     35|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1454|     35|                    None,
 1455|     35|                    "Open...",
 1456|     35|                    'O',
 1457|     35|                    alt_pressed,
 1458|     35|                    menu_text_color,
 1459|     35|                )))
 1460|     35|                .clicked();
 1461|     35|            if app_action_triggered(clicked, "menu_open") {
 1462|      3|                self.open_file_dialog();
 1463|      3|                ui.close_menu();
 1464|     32|            }
 1465|     35|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1466|     35|                ui.label(RichText::new("Ctrl+O").color(menu_text_color));
 1467|     35|            });
 1468|     35|        });
 1469|       |
 1470|     35|        ui.horizontal(|ui| {
 1471|     35|            let enabled = !self.current_content.is_empty();
 1472|     35|            let button = ui.add_enabled(
 1473|     35|                enabled,
 1474|     35|                egui::Button::new(Self::menu_text_with_mnemonic(
 1475|     35|                    None,
 1476|     35|                    "Save",
 1477|       |                    'S',
 1478|     35|                    alt_pressed,
 1479|     35|                    menu_text_color,
 1480|       |                )),
 1481|       |            );
 1482|     35|            if app_action_triggered(button.clicked(), "menu_save") {
 1483|      4|                if let Err(e) = self.save_current_document() {
                                         ^1
 1484|      1|                    self.error_message = Some(format!("Failed to save: {}", e));
 1485|      3|                }
 1486|      4|                ui.close_menu();
 1487|     31|            }
 1488|     35|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1489|     35|                ui.label(RichText::new("Ctrl+S").color(menu_text_color));
 1490|     35|            });
 1491|     35|        });
 1492|       |
 1493|     35|        ui.horizontal(|ui| {
 1494|     35|            let clicked = ui
 1495|     35|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1496|     35|                    None,
 1497|     35|                    "Close",
 1498|     35|                    'C',
 1499|     35|                    alt_pressed,
 1500|     35|                    menu_text_color,
 1501|     35|                )))
 1502|     35|                .clicked();
 1503|     35|            if app_action_triggered(clicked, "menu_close") {
 1504|      3|                self.close_current_file();
 1505|      3|                ui.close_menu();
 1506|     32|            }
 1507|     35|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1508|     35|                ui.label(RichText::new("Ctrl+W").color(menu_text_color));
 1509|     35|            });
 1510|     35|        });
 1511|       |
 1512|     35|        ui.horizontal(|ui| {
 1513|     35|            let enabled = self.current_file.is_some();
 1514|     35|            let button = ui.add_enabled(
 1515|     35|                enabled,
 1516|     35|                egui::Button::new(Self::menu_text_with_mnemonic(
 1517|     35|                    None,
 1518|     35|                    "Reload",
 1519|       |                    'R',
 1520|     35|                    alt_pressed,
 1521|     35|                    menu_text_color,
 1522|       |                )),
 1523|       |            );
 1524|     35|            if app_action_triggered(button.clicked(), "menu_reload") {
 1525|      3|                self.request_reload();
 1526|      3|                ui.close_menu();
 1527|     32|            }
 1528|     35|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1529|     35|                ui.label(RichText::new("F5").color(menu_text_color));
 1530|     35|            });
 1531|     35|        });
 1532|       |
 1533|     35|        ui.horizontal(|ui| {
 1534|     35|            let clicked = ui
 1535|     35|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1536|     35|                    None,
 1537|     35|                    "Find...",
 1538|     35|                    'F',
 1539|     35|                    alt_pressed,
 1540|     35|                    menu_text_color,
 1541|     35|                )))
 1542|     35|                .clicked();
 1543|     35|            if app_action_triggered(clicked, "menu_find") {
 1544|      3|                self.show_search = true;
 1545|      3|                self.search_focus_requested = true;
 1546|      3|                ui.close_menu();
 1547|     32|            }
 1548|     35|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1549|     35|                ui.label(RichText::new("Ctrl+F").color(menu_text_color));
 1550|     35|            });
 1551|     35|        });
 1552|       |
 1553|     35|        ui.separator();
 1554|       |
 1555|       |        #[cfg(not(test))]
 1556|       |        ui.menu_button(
 1557|       |            Self::menu_text_with_mnemonic(None, "Samples", 'S', alt_pressed, menu_text_color),
 1558|       |            |ui| {
 1559|       |                self.render_samples_menu_contents(ui);
 1560|       |            },
 1561|       |        );
 1562|       |        #[cfg(test)]
 1563|     35|        self.render_samples_menu_contents(ui);
 1564|     35|        if app_action_triggered(false, "menu_samples") {
 1565|      3|            self.render_samples_menu_contents(ui);
 1566|     32|        }
 1567|     35|    }
 1568|       |
 1569|     38|    fn render_samples_menu_contents(&mut self, ui: &mut egui::Ui) {
 1570|    266|        for sample in SAMPLE_FILES {
                          ^228
 1571|    228|            if app_action_triggered(ui.button(sample.title).clicked(), sample.name) {
 1572|     12|                self.load_sample(sample);
 1573|     12|                ui.close_menu();
 1574|    216|            }
 1575|       |        }
 1576|     38|    }
 1577|       |
 1578|     34|    fn render_view_menu_contents(
 1579|     34|        &mut self,
 1580|     34|        ui: &mut egui::Ui,
 1581|     34|        ctx: &Context,
 1582|     34|        alt_pressed: bool,
 1583|     34|        menu_text_color: Color32,
 1584|     34|    ) {
 1585|     34|        ui.horizontal(|ui| {
 1586|     34|            let enabled = self.can_navigate_back();
 1587|     34|            let clicked = ui
 1588|     34|                .add_enabled(enabled, egui::Button::new("<- Back"))
 1589|     34|                .clicked();
 1590|     34|            if app_action_triggered(clicked, "menu_back") {
 1591|      3|                self.navigate_back();
 1592|      3|                ui.close_menu();
 1593|     31|            }
 1594|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1595|     34|                ui.label(RichText::new("Alt+Left").color(menu_text_color));
 1596|     34|            });
 1597|     34|        });
 1598|       |
 1599|     34|        ui.horizontal(|ui| {
 1600|     34|            let enabled = self.can_navigate_forward();
 1601|     34|            let clicked = ui
 1602|     34|                .add_enabled(enabled, egui::Button::new("Forward ->"))
 1603|     34|                .clicked();
 1604|     34|            if app_action_triggered(clicked, "menu_forward") {
 1605|      3|                self.navigate_forward();
 1606|      3|                ui.close_menu();
 1607|     31|            }
 1608|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1609|     34|                ui.label(RichText::new("Alt+Right").color(menu_text_color));
 1610|     34|            });
 1611|     34|        });
 1612|       |
 1613|     34|        ui.separator();
 1614|       |
 1615|     34|        ui.horizontal(|ui| {
 1616|     34|            let selected = matches!(self.view_mode, ViewMode::Raw);
                                         ^24
 1617|     34|            let clicked = ui
 1618|     34|                .add(egui::SelectableLabel::new(
 1619|     34|                    selected,
 1620|     34|                    Self::menu_text_with_mnemonic(
 1621|     34|                        None,
 1622|     34|                        "Raw Markdown",
 1623|     34|                        'R',
 1624|     34|                        alt_pressed,
 1625|     34|                        menu_text_color,
 1626|     34|                    ),
 1627|     34|                ))
 1628|     34|                .clicked();
 1629|     34|            if app_action_triggered(clicked, "menu_raw") {
 1630|      3|                self.toggle_view_mode(ctx);
 1631|      3|                ui.close_menu();
 1632|     31|            }
 1633|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1634|     34|                ui.label(RichText::new("Ctrl+R").color(menu_text_color));
 1635|     34|            });
 1636|     34|        });
 1637|       |
 1638|     34|        ui.horizontal(|ui| {
 1639|     34|            let selected = self.write_enabled;
 1640|     34|            let clicked = ui
 1641|     34|                .add(egui::SelectableLabel::new(
 1642|     34|                    selected,
 1643|     34|                    Self::menu_text_with_mnemonic(
 1644|     34|                        None,
 1645|     34|                        "Write Mode",
 1646|     34|                        'W',
 1647|     34|                        alt_pressed,
 1648|     34|                        menu_text_color,
 1649|     34|                    ),
 1650|     34|                ))
 1651|     34|                .clicked();
 1652|     34|            if app_action_triggered(clicked, "menu_write") {
 1653|      3|                self.toggle_write_mode(ctx);
 1654|      3|                ui.close_menu();
 1655|     31|            }
 1656|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1657|     34|                ui.label(RichText::new("Ctrl+E").color(menu_text_color));
 1658|     34|            });
 1659|     34|        });
 1660|       |
 1661|     34|        ui.horizontal(|ui| {
 1662|     34|            let clicked = ui
 1663|     34|                .add(egui::SelectableLabel::new(
 1664|     34|                    self.wrap_raw,
 1665|     34|                    Self::menu_text_with_mnemonic(
 1666|     34|                        None,
 1667|     34|                        "Wrap Raw Lines",
 1668|     34|                        'L',
 1669|     34|                        alt_pressed,
 1670|     34|                        menu_text_color,
 1671|     34|                    ),
 1672|     34|                ))
 1673|     34|                .clicked();
 1674|     34|            if app_action_triggered(clicked, "menu_wrap_raw") {
 1675|      3|                self.wrap_raw = !self.wrap_raw;
 1676|     31|            }
 1677|     34|        });
 1678|       |
 1679|     34|        ui.horizontal(|ui| {
 1680|     34|            let clicked = ui
 1681|     34|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1682|     34|                    None,
 1683|     34|                    "Zoom In",
 1684|     34|                    'I',
 1685|     34|                    alt_pressed,
 1686|     34|                    menu_text_color,
 1687|     34|                )))
 1688|     34|                .clicked();
 1689|     34|            if app_action_triggered(clicked, "menu_zoom_in") {
 1690|      3|                self.renderer.zoom_in();
 1691|      3|                ui.close_menu();
 1692|     31|            }
 1693|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1694|     34|                ui.label(RichText::new("Ctrl++").color(menu_text_color));
 1695|     34|            });
 1696|     34|        });
 1697|       |
 1698|     34|        ui.horizontal(|ui| {
 1699|     34|            let clicked = ui
 1700|     34|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1701|     34|                    None,
 1702|     34|                    "Zoom Out",
 1703|     34|                    'O',
 1704|     34|                    alt_pressed,
 1705|     34|                    menu_text_color,
 1706|     34|                )))
 1707|     34|                .clicked();
 1708|     34|            if app_action_triggered(clicked, "menu_zoom_out") {
 1709|      3|                self.renderer.zoom_out();
 1710|      3|                ui.close_menu();
 1711|     31|            }
 1712|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1713|     34|                ui.label(RichText::new("Ctrl+-").color(menu_text_color));
 1714|     34|            });
 1715|     34|        });
 1716|       |
 1717|     34|        ui.horizontal(|ui| {
 1718|     34|            let clicked = ui
 1719|     34|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1720|     34|                    None,
 1721|     34|                    "Reset Zoom",
 1722|     34|                    'Z',
 1723|     34|                    alt_pressed,
 1724|     34|                    menu_text_color,
 1725|     34|                )))
 1726|     34|                .clicked();
 1727|     34|            if app_action_triggered(clicked, "menu_zoom_reset") {
 1728|      3|                self.renderer.reset_zoom();
 1729|      3|                ui.close_menu();
 1730|     31|            }
 1731|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1732|     34|                ui.label(RichText::new("Ctrl+0").color(menu_text_color));
 1733|     34|            });
 1734|     34|        });
 1735|       |
 1736|     34|        ui.separator();
 1737|       |
 1738|     34|        ui.horizontal(|ui| {
 1739|     34|            let clicked = ui
 1740|     34|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1741|     34|                    None,
 1742|     34|                    "Toggle Fullscreen",
 1743|     34|                    'T',
 1744|     34|                    alt_pressed,
 1745|     34|                    menu_text_color,
 1746|     34|                )))
 1747|     34|                .clicked();
 1748|     34|            if app_action_triggered(clicked, "menu_fullscreen") {
 1749|      3|                let is_fullscreen = ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
 1750|      3|                ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(!is_fullscreen));
 1751|      3|                ui.close_menu();
 1752|     31|            }
 1753|     34|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1754|     34|                ui.label(RichText::new("F11").color(menu_text_color));
 1755|     34|            });
 1756|     34|        });
 1757|     34|    }
 1758|       |
 1759|     34|    fn render_help_menu_contents(
 1760|     34|        &mut self,
 1761|     34|        ui: &mut egui::Ui,
 1762|     34|        alt_pressed: bool,
 1763|     34|        menu_text_color: Color32,
 1764|     34|    ) {
 1765|     34|        ui.horizontal(|ui| {
 1766|     34|            let clicked = ui
 1767|     34|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1768|     34|                    None,
 1769|     34|                    "Usage Instructions",
 1770|     34|                    'U',
 1771|     34|                    alt_pressed,
 1772|     34|                    menu_text_color,
 1773|     34|                )))
 1774|     34|                .clicked();
 1775|     34|            if app_action_triggered(clicked, "menu_help_usage") {
 1776|      3|                let _ = self.load_sample_by_name(SAMPLE_FILES, "usage.md");
 1777|      3|                ui.close_menu();
 1778|     31|            }
 1779|     34|        });
 1780|       |
 1781|     34|        ui.horizontal(|ui| {
 1782|     34|            let clicked = ui
 1783|     34|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1784|     34|                    None,
 1785|     34|                    "About",
 1786|     34|                    'A',
 1787|     34|                    alt_pressed,
 1788|     34|                    menu_text_color,
 1789|     34|                )))
 1790|     34|                .clicked();
 1791|     34|            if app_action_triggered(clicked, "menu_help_about") {
 1792|      3|                let _ = self.load_sample_by_name(SAMPLE_FILES, "welcome.md");
 1793|      3|                ui.close_menu();
 1794|     31|            }
 1795|     34|        });
 1796|     34|    }
 1797|       |
 1798|       |    /// Render the menu bar
 1799|     31|    fn render_menu_bar(&mut self, ctx: &Context) {
 1800|     31|        TopBottomPanel::top("menu_bar").show(ctx, |ui| {
 1801|     31|            let alt_pressed = ui.input(|i| i.modifiers.alt);
 1802|     31|            let menu_text_color = if ui.visuals().dark_mode {
 1803|     30|                Color32::WHITE
 1804|       |            } else {
 1805|      1|                Color32::BLACK
 1806|       |            };
 1807|     31|            menu::bar(ui, |ui| {
 1808|       |                // File menu (Alt+F mnemonic visual)
 1809|       |                #[cfg(not(test))]
 1810|       |                ui.menu_button(
 1811|       |                    Self::menu_text_with_mnemonic(None, "File", 'F', alt_pressed, menu_text_color),
 1812|       |                    |ui| {
 1813|       |                        self.render_file_menu_contents(ui, alt_pressed, menu_text_color);
 1814|       |                    },
 1815|       |                );
 1816|       |                #[cfg(test)]
 1817|     31|                self.render_file_menu_contents(ui, alt_pressed, menu_text_color);
 1818|     31|                if app_action_triggered(false, "menu_bar_file") {
 1819|      1|                    self.render_file_menu_contents(ui, alt_pressed, menu_text_color);
 1820|     30|                }
 1821|       |
 1822|       |                // View menu
 1823|       |                #[cfg(not(test))]
 1824|       |                ui.menu_button(
 1825|       |                    Self::menu_text_with_mnemonic(None, "View", 'V', alt_pressed, menu_text_color),
 1826|       |                    |ui| {
 1827|       |                        self.render_view_menu_contents(ui, ctx, alt_pressed, menu_text_color);
 1828|       |                    },
 1829|       |                );
 1830|       |                #[cfg(test)]
 1831|     31|                self.render_view_menu_contents(ui, ctx, alt_pressed, menu_text_color);
 1832|     31|                if app_action_triggered(false, "menu_bar_view") {
 1833|      1|                    self.render_view_menu_contents(ui, ctx, alt_pressed, menu_text_color);
 1834|     30|                }
 1835|       |
 1836|       |                #[cfg(not(test))]
 1837|       |                ui.menu_button(
 1838|       |                    Self::menu_text_with_mnemonic(None, "Help", 'H', alt_pressed, menu_text_color),
 1839|       |                    |ui| {
 1840|       |                        self.render_help_menu_contents(ui, alt_pressed, menu_text_color);
 1841|       |                    },
 1842|       |                );
 1843|       |                #[cfg(test)]
 1844|     31|                self.render_help_menu_contents(ui, alt_pressed, menu_text_color);
 1845|     31|                if app_action_triggered(false, "menu_bar_help") {
 1846|      1|                    self.render_help_menu_contents(ui, alt_pressed, menu_text_color);
 1847|     30|                }
 1848|     31|            });
 1849|     31|        });
 1850|       |
 1851|       |        // No programmatic overlay menus; rely on pointer to open egui menus.
 1852|     31|    }
 1853|       |
 1854|      2|    fn render_main_context_menu(&mut self, ui: &mut egui::Ui) {
 1855|      2|        ui.label("Select text, then use Ctrl+C to copy");
 1856|      2|        ui.separator();
 1857|       |
 1858|       |        // Copy All Text option
 1859|      2|        if app_action_triggered(ui.button("Copy All Text").clicked(), "ctx_copy_all") {
 1860|      1|            let all_text = MarkdownRenderer::elements_to_plain_text(&self.parsed_elements);
 1861|      1|            ui.ctx().copy_text(all_text);
 1862|      1|            ui.close_menu();
 1863|      1|        }
 1864|       |
 1865|       |        // Copy as Markdown (Raw) option
 1866|      2|        if app_action_triggered(ui.button("Copy as Markdown").clicked(), "ctx_copy_markdown") {
 1867|      1|            ui.ctx().copy_text(self.current_content.clone());
 1868|      1|            ui.close_menu();
 1869|      1|        }
 1870|       |
 1871|      2|        ui.separator();
 1872|       |
 1873|       |        // Navigation shortcuts
 1874|      2|        if app_action_triggered(ui.button("Go to Top").clicked(), "ctx_nav_top") {
 1875|      1|            self.nav_request = Some(NavigationRequest::Top);
 1876|      1|            ui.close_menu();
 1877|      1|        }
 1878|       |
 1879|      2|        if app_action_triggered(ui.button("Go to Bottom").clicked(), "ctx_nav_bottom") {
 1880|      1|            self.nav_request = Some(NavigationRequest::Bottom);
 1881|      1|            ui.close_menu();
 1882|      1|        }
 1883|      2|    }
 1884|       |    /// Render the status bar
 1885|     34|    fn render_status_bar(&self, ctx: &Context) {
 1886|     34|        TopBottomPanel::bottom("status_bar").show(ctx, |ui| {
 1887|     34|            ui.horizontal(|ui| {
 1888|       |                // Current file info
 1889|     34|                if let Some(path) = &self.current_file {
                                          ^2
 1890|      2|                    ui.label(format!("File: {}", path.display()));
 1891|     32|                } else if !self.parsed_elements.is_empty() {
 1892|     28|                    ui.label("Sample file");
 1893|     28|                } else {
 1894|      4|                    ui.label("No file loaded");
 1895|      4|                }
 1896|       |
 1897|     34|                if let Some(pending) = &self.pending_file_load {
                                          ^1
 1898|      1|                    ui.separator();
 1899|      1|                    ui.label(
 1900|      1|                        RichText::new(format!("Loading {}", pending.path.display()))
 1901|      1|                            .color(Color32::from_rgb(120, 200, 255)),
 1902|      1|                    );
 1903|     33|                }
 1904|       |
 1905|       |                // Show pending file count if files are queued
 1906|     34|                if !self.pending_files.is_empty() {
 1907|      2|                    ui.separator();
 1908|      2|                    ui.label(
 1909|      2|                        RichText::new(format!("{} files in queue", self.pending_files.len()))
 1910|      2|                            .color(egui::Color32::from_rgb(100, 150, 255)),
 1911|      2|                    );
 1912|      2|
 1913|      2|                    ui.label(
 1914|      2|                        RichText::new("(Alt+Right for next)")
 1915|      2|                            .color(egui::Color32::GRAY)
 1916|      2|                            .italics(),
 1917|      2|                    );
 1918|     32|                }
 1919|       |
 1920|     34|                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1921|       |                    // Document stats
 1922|     34|                    let element_count = self.parsed_elements.len();
 1923|     34|                    let char_count = self.current_content.len();
 1924|     34|                    let mode = match self.view_mode {
 1925|     24|                        ViewMode::Rendered => "Rendered",
 1926|     10|                        ViewMode::Raw => "Raw",
 1927|       |                    };
 1928|     34|                    let status = format!(
 1929|     34|                        "Mode: {} | Elements: {} | Characters: {}",
 1930|       |                        mode, element_count, char_count
 1931|       |                    );
 1932|       |                    #[cfg(test)]
 1933|     34|                    {
 1934|     34|                        ui.label(status);
 1935|     34|                        self.render_status_tooltip(ui);
 1936|     34|                    }
 1937|       |                    #[cfg(not(test))]
 1938|       |                    {
 1939|       |                        ui.label(status)
 1940|       |                            .on_hover_ui(|ui| self.render_status_tooltip(ui));
 1941|       |                    }
 1942|     34|                    if app_action_triggered(false, "status_hover") {
 1943|      2|                        self.render_status_tooltip(ui);
 1944|     32|                    }
 1945|     34|                });
 1946|     34|            });
 1947|     34|        });
 1948|     34|    }
 1949|       |
 1950|     36|    fn render_status_tooltip(&self, ui: &mut egui::Ui) {
 1951|     36|        ui.label(format!("Version: {}", BUILD_VERSION));
 1952|     36|        ui.label(format!("Built: {}", BUILD_TIMESTAMP));
 1953|     36|    }
 1954|       |    /// Handle drag-drop events from egui
 1955|     29|    fn handle_drag_drop_events(&mut self, ctx: &Context) {
 1956|     29|        ctx.input(|i| {
 1957|       |            // Check if files are being hovered
 1958|     29|            self.drag_hover = !i.raw.hovered_files.is_empty();
 1959|       |
 1960|       |            // Check if files were dropped
 1961|     29|            if !i.raw.dropped_files.is_empty() {
 1962|      1|                let paths: Vec<PathBuf> = i
 1963|      1|                    .raw
 1964|      1|                    .dropped_files
 1965|      1|                    .iter()
 1966|      1|                    .filter_map(|f| f.path.clone())
 1967|      1|                    .collect();
 1968|       |
 1969|      1|                self.handle_file_drop(paths);
 1970|     28|            }
 1971|     29|        });
 1972|     29|    }
 1973|       |
 1974|       |    /// Render drag-and-drop overlay when files are hovered
 1975|     30|    fn render_drag_overlay(&self, ctx: &Context) {
 1976|     30|        if !self.drag_hover {
 1977|     28|            return;
 1978|      2|        }
 1979|       |
 1980|       |        // Full-screen overlay
 1981|      2|        egui::Area::new(egui::Id::new("drag_overlay"))
 1982|      2|            .fixed_pos(egui::pos2(0.0, 0.0))
 1983|      2|            .order(egui::Order::Foreground)
 1984|      2|            .show(ctx, |ui| {
 1985|      2|                let screen_rect = ctx.screen_rect();
 1986|       |
 1987|       |                // Semi-transparent dark background
 1988|      2|                ui.painter()
 1989|      2|                    .rect_filled(screen_rect, 0.0, egui::Color32::from_black_alpha(180));
 1990|       |
 1991|       |                // Dashed border effect using rounded rect with stroke
 1992|      2|                let border_rect = screen_rect.shrink(20.0);
 1993|      2|                let border_color = egui::Color32::from_rgb(100, 150, 255);
 1994|       |
 1995|       |                // Draw border
 1996|      2|                ui.painter()
 1997|      2|                    .rect_stroke(border_rect, 8.0, egui::Stroke::new(4.0, border_color));
 1998|       |
 1999|       |                // Center text
 2000|      2|                ui.allocate_ui_at_rect(screen_rect, |ui| {
 2001|      2|                    ui.vertical_centered(|ui| {
 2002|      2|                        ui.add_space(screen_rect.height() / 2.0 - 80.0);
 2003|       |
 2004|       |                        // Main message
 2005|      2|                        ui.label(
 2006|      2|                            RichText::new("Drop files to open")
 2007|      2|                                .size(36.0)
 2008|      2|                                .color(egui::Color32::WHITE)
 2009|      2|                                .strong(),
 2010|       |                        );
 2011|       |
 2012|      2|                        ui.add_space(20.0);
 2013|       |
 2014|       |                        // Supported formats
 2015|      2|                        ui.label(
 2016|      2|                            RichText::new("Supported: .md, .markdown, .mdown, .mkd, .txt")
 2017|      2|                                .size(18.0)
 2018|      2|                                .color(egui::Color32::LIGHT_GRAY),
 2019|       |                        );
 2020|       |
 2021|      2|                        ui.add_space(10.0);
 2022|       |
 2023|       |                        // Additional hint
 2024|      2|                        ui.label(
 2025|      2|                            RichText::new("Drop multiple files to open them in sequence")
 2026|      2|                                .size(14.0)
 2027|      2|                                .color(egui::Color32::from_rgb(150, 150, 150))
 2028|      2|                                .italics(),
 2029|       |                        );
 2030|      2|                    });
 2031|      2|                });
 2032|      2|            });
 2033|     30|    }
 2034|       |
 2035|     31|    fn update_impl(&mut self, ctx: &Context) {
 2036|     31|        self.handle_screenshot_events(ctx);
 2037|     31|        self.poll_file_loads();
 2038|     31|        if self.screenshot.as_ref().is_some_and(|state| state.done) {
 2039|      1|            return;
 2040|     30|        }
 2041|       |
 2042|     30|        let screenshot_active = self.screenshot.is_some();
 2043|     30|        let hide_chrome = screenshot_active;
 2044|       |
 2045|       |        // Handle drag-drop events
 2046|     30|        if !screenshot_active {
 2047|     29|            self.handle_drag_drop_events(ctx);
 2048|     29|        }
                      ^1
 2049|       |
 2050|       |        // Handle keyboard shortcuts
 2051|     30|        if !screenshot_active {
 2052|     29|            self.handle_shortcuts(ctx);
 2053|     29|        }
                      ^1
 2054|       |
 2055|       |        // Keep native window title in sync with the current document
 2056|     30|        ctx.send_viewport_cmd(egui::ViewportCommand::Title(self.title.clone()));
 2057|       |
 2058|     30|        let (monitor_size, outer_rect, inner_rect, is_fullscreen, is_maximized) = ctx.input(|i| {
 2059|     30|            let vp = i.viewport();
 2060|     30|            (
 2061|     30|                vp.monitor_size,
 2062|     30|                vp.outer_rect,
 2063|     30|                vp.inner_rect,
 2064|     30|                vp.fullscreen.unwrap_or(false),
 2065|     30|                vp.maximized.unwrap_or(false),
 2066|     30|            )
 2067|     30|        });
 2068|       |
 2069|     30|        let mut pos_adjusted = false;
 2070|     30|        let mut size_adjusted = false;
 2071|     30|        if !is_fullscreen {
 2072|      2|            if let Some(adjustment) =
 2073|     29|                Self::compute_window_adjustment(outer_rect, inner_rect, monitor_size)
 2074|       |            {
 2075|      2|                if let Some(pos) = adjustment.pos {
                                          ^1
 2076|      1|                    pos_adjusted = true;
 2077|      1|                    ctx.send_viewport_cmd(egui::ViewportCommand::OuterPosition(pos));
 2078|      1|                    self.last_window_pos = Some([pos.x, pos.y]);
 2079|      1|                }
 2080|      2|                if let Some(size) = adjustment.size {
                                          ^1
 2081|      1|                    size_adjusted = true;
 2082|      1|                    ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(size));
 2083|      1|                    self.last_window_size = Some([size.x, size.y]);
 2084|      1|                }
 2085|     27|            }
 2086|      1|        }
 2087|       |
 2088|     30|        if !pos_adjusted {
 2089|     29|            if let Some(outer) = outer_rect {
                                      ^3
 2090|      3|                self.last_window_pos = Some([outer.left(), outer.top()]);
 2091|     26|            }
 2092|      1|        }
 2093|     30|        if !size_adjusted && !is_fullscreen {
                                           ^29
 2094|     28|            if let Some(inner) = inner_rect {
                                      ^2
 2095|      2|                self.last_window_size = Some([inner.width(), inner.height()]);
 2096|     26|            }
 2097|      2|        }
 2098|     30|        self.last_window_maximized = is_maximized;
 2099|       |
 2100|       |        // Opportunistically persist window state if it changed, throttled to once per second
 2101|     30|        if self.should_persist_window_state() {
 2102|      1|            self.persist_window_state();
 2103|      1|            self.last_persist_instant = std::time::Instant::now();
 2104|     29|        }
 2105|       |
 2106|       |        // Handle fullscreen toggle outside input context to avoid deadlocks
 2107|     30|        if self.toggle_fullscreen {
 2108|      1|            self.toggle_fullscreen = false;
 2109|      1|            let current_fullscreen = ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
 2110|      1|            ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(!current_fullscreen));
 2111|     29|        }
 2112|       |
 2113|       |        // Handle deferred view toggle outside of input context
 2114|     30|        if self.view_toggle_requested {
 2115|      1|            self.view_toggle_requested = false;
 2116|      1|            self.toggle_view_mode(ctx);
 2117|     29|        }
 2118|       |
 2119|       |        // Handle deferred write toggle outside of input context
 2120|     30|        if self.write_toggle_requested {
 2121|      1|            self.write_toggle_requested = false;
 2122|      1|            self.toggle_write_mode(ctx);
 2123|     29|        }
 2124|       |
 2125|       |        // Handle deferred caret movement for raw editor
 2126|     30|        if let Some(delta) = self.pending_raw_cursor_line_move.take() {
                                  ^1
 2127|      1|            self.move_raw_cursor_lines(ctx, delta);
 2128|     29|        }
 2129|       |
 2130|       |        // Handle reload request outside input context to avoid blocking within input handling
 2131|     30|        if self.reload_requested {
 2132|      2|            self.reload_requested = false;
 2133|      2|            if let Err(e) = self.reload_current_file() {
                                     ^1
 2134|      1|                self.error_message = Some(format!("Failed to reload file: {}", e));
 2135|      1|            }
 2136|     28|        }
 2137|       |
 2138|       |        // Render chrome panels before the central area so they reserve space.
 2139|     30|        if !hide_chrome {
 2140|     29|            self.render_menu_bar(ctx);
 2141|     29|            self.render_status_bar(ctx);
 2142|     29|        }
                      ^1
 2143|       |
 2144|     30|        let mut layout_signature: Option<u64> = None;
 2145|     30|        let mut scroll_snapshot: Option<ScrollSnapshot> = None;
 2146|     30|        let screenshot_scroll_offset = self
 2147|     30|            .screenshot
 2148|     30|            .as_ref()
 2149|     30|            .and_then(|state| state.scroll_offset);
 2150|       |
 2151|       |        // Main content area
 2152|     30|        let central_response = CentralPanel::default().show(ctx, |ui| {
 2153|       |            // Show error message if any
 2154|     30|            if let Some(ref error) = self.error_message {
                                      ^2
 2155|      2|                ui.colored_label(Color32::RED, format!("Error: {}", error));
 2156|      2|                ui.separator();
 2157|     28|            }
 2158|       |
 2159|       |            // Render markdown content in a scrollable area
 2160|     30|            let scroll_delta = if let Some(nav) = self.nav_request.take() {
                                                         ^6
 2161|      6|                match nav {
 2162|       |                    NavigationRequest::Top => {
 2163|       |                        // Scroll to top: use a large POSITIVE delta to reach the beginning
 2164|      1|                        egui::Vec2::new(0.0, 100000.0)
 2165|       |                    }
 2166|       |                    NavigationRequest::Bottom => {
 2167|       |                        // Scroll to bottom: use a large NEGATIVE delta to reach the end
 2168|      1|                        egui::Vec2::new(0.0, -100000.0)
 2169|       |                    }
 2170|       |                    NavigationRequest::PageUp => {
 2171|      1|                        let viewport_height = ui.available_height();
 2172|      1|                        let page_size = viewport_height * 0.8;
 2173|      1|                        egui::Vec2::new(0.0, page_size) // Positive = scroll up (show earlier content)
 2174|       |                    }
 2175|       |                    NavigationRequest::PageDown => {
 2176|      1|                        let viewport_height = ui.available_height();
 2177|      1|                        let page_size = viewport_height * 0.8;
 2178|      1|                        egui::Vec2::new(0.0, -page_size) // Negative = scroll down (show later content)
 2179|       |                    }
 2180|       |                    NavigationRequest::ScrollUp => {
 2181|      1|                        egui::Vec2::new(0.0, 40.0) // Positive = fine scroll up
 2182|       |                    }
 2183|       |                    NavigationRequest::ScrollDown => {
 2184|      1|                        egui::Vec2::new(0.0, -40.0) // Negative = fine scroll down
 2185|       |                    }
 2186|       |                }
 2187|       |            } else {
 2188|     24|                egui::Vec2::ZERO
 2189|       |            };
 2190|       |
 2191|       |            // Use AlwaysVisible to prevent scrollbar appearance/disappearance from
 2192|       |            // changing the available width, which would cause Mermaid diagrams to
 2193|       |            // re-render at different widths and create layout oscillation/flickering.
 2194|     30|            let mut scroll_area = egui::ScrollArea::vertical()
 2195|     30|                .id_source(self.scroll_area_id)
 2196|     30|                .auto_shrink([false, false])
 2197|     30|                .scroll_bar_visibility(egui::scroll_area::ScrollBarVisibility::AlwaysVisible);
 2198|     30|            if let Some(offset) = screenshot_scroll_offset {
                                      ^1
 2199|      1|                scroll_area = scroll_area.vertical_scroll_offset(offset);
 2200|     29|            }
 2201|     30|            if screenshot_active {
 2202|      1|                scroll_area = scroll_area.enable_scrolling(false);
 2203|     29|            }
 2204|     30|            let scroll_output = scroll_area.show(ui, |ui| {
 2205|       |                // Apply scroll delta if we have navigation
 2206|     30|                if scroll_delta != egui::Vec2::ZERO {
 2207|      6|                    ui.scroll_with_delta(scroll_delta);
 2208|     24|                }
 2209|       |
 2210|     30|                ui.spacing_mut().item_spacing.y = 8.0;
 2211|       |
 2212|     30|                if self.parsed_elements.is_empty() && self.error_message.is_none() {
                                                                    ^3                 ^3
 2213|      2|                    ui.vertical_centered(|ui| {
 2214|      2|                        ui.add_space(50.0);
 2215|      2|                        ui.label(RichText::new("Welcome to MarkdownView").size(24.0).strong());
 2216|      2|                        ui.add_space(20.0);
 2217|      2|                        ui.label("Open a markdown file or select a sample to get started.");
 2218|      2|                        ui.add_space(20.0);
 2219|       |
 2220|      2|                        if app_action_triggered(ui.button("Open File").clicked(), "welcome_open") {
 2221|      1|                            self.open_file_dialog();
 2222|      1|                        }
 2223|      2|                    });
 2224|       |                } else {
 2225|     28|                    match self.view_mode {
 2226|       |                        ViewMode::Rendered => {
 2227|       |                            // Update highlight phrase: prefer live input, else last executed
 2228|     19|                            if self.show_search && !self.search_query.is_empty() {
                                                                 ^2
 2229|      1|                                self.renderer.set_highlight_phrase(Some(&self.search_query));
 2230|     18|                            } else if !self.last_query.is_empty() {
 2231|      2|                                self.renderer.set_highlight_phrase(Some(&self.last_query));
 2232|     16|                            } else {
 2233|     16|                                self.renderer.set_highlight_phrase(None);
 2234|     16|                            }
 2235|       |
 2236|     19|                            self.renderer.render_to_ui(ui, &self.parsed_elements);
 2237|       |                            // If a header anchor was clicked, scroll to it
 2238|     19|                            if let Some(anchor) = self.renderer.take_pending_anchor() {
                                                      ^2
 2239|      2|                                if let Some(rect) = self.renderer.header_rect_for(&anchor) {
                                                          ^1
 2240|      1|                                    // Align target header to the top of the visible area
 2241|      1|                                    ui.scroll_to_rect(rect, Some(egui::Align::Min));
 2242|      1|                                }
 2243|     17|                            }
 2244|       |                            // If a search requested a scroll, align to top of visible area
 2245|     19|                            if let Some(idx) = self.pending_scroll_to_element.take() {
                                                      ^13
 2246|     13|                                if let Some(rect) = self.renderer.element_rect_at(idx) {
                                                          ^11
 2247|     11|                                    ui.scroll_to_rect(rect, Some(egui::Align::Min));
 2248|     11|                                }
                                              ^2
 2249|      6|                            }
 2250|     19|                            layout_signature = Some(self.renderer.layout_signature());
 2251|       |                        }
 2252|       |                        ViewMode::Raw => {
 2253|       |                            // Raw markdown view; editable when write mode is enabled
 2254|      9|                            if self.write_enabled {
 2255|      8|                                let editor_id = egui::Id::new("raw_editor");
 2256|       |                                // If we have a remembered cursor, restore it (clamped)
 2257|      8|                                if let Some(mut idx) = self.raw_cursor.take() {
                                                          ^2
 2258|      2|                                    idx = idx.min(self.raw_buffer.len());
 2259|      1|                                    if let Some(mut state) =
 2260|      2|                                        egui::text_edit::TextEditState::load(ui.ctx(), editor_id)
 2261|      1|                                    {
 2262|      1|                                        let cr = egui::text::CCursorRange::one(
 2263|      1|                                            egui::text::CCursor::new(idx),
 2264|      1|                                        );
 2265|      1|                                        state.cursor.set_char_range(Some(cr));
 2266|      1|                                        state.store(ui.ctx(), editor_id);
 2267|      1|                                    } else {
 2268|      1|                                        let mut state = egui::text_edit::TextEditState::default();
 2269|      1|                                        let cr = egui::text::CCursorRange::one(
 2270|      1|                                            egui::text::CCursor::new(idx),
 2271|      1|                                        );
 2272|      1|                                        state.cursor.set_char_range(Some(cr));
 2273|      1|                                        state.store(ui.ctx(), editor_id);
 2274|      1|                                    }
 2275|      6|                                }
 2276|      8|                                let before = self.raw_buffer.clone();
 2277|      8|                                let resp = ui.add(
 2278|      8|                                    TextEdit::multiline(&mut self.raw_buffer)
 2279|      8|                                        .font(TextStyle::Monospace)
 2280|      8|                                        .code_editor()
 2281|      8|                                        .lock_focus(false)
 2282|      8|                                        .interactive(true)
 2283|      8|                                        .desired_width(f32::INFINITY)
 2284|      8|                                        .desired_rows(24)
 2285|      8|                                        .id_source(editor_id),
 2286|       |                                );
 2287|      8|                                if self.raw_focus_requested {
 2288|      4|                                    resp.request_focus();
 2289|      4|                                    self.raw_focus_requested = false;
 2290|      4|                                }
 2291|       |                                // Remember cursor position for next time
 2292|      3|                                if let Some(state) =
 2293|      8|                                    egui::text_edit::TextEditState::load(ui.ctx(), editor_id)
 2294|       |                                {
 2295|      3|                                    if let Some(range) = state.cursor.char_range() {
                                                              ^2
 2296|      2|                                        let idx = range.primary.index;
 2297|      2|                                        self.raw_cursor = Some(idx);
 2298|      2|                                    }
                                                  ^1
 2299|      5|                                }
 2300|      8|                                if self.raw_buffer != before {
 2301|      2|                                    self.current_content = self.raw_buffer.clone();
 2302|      2|                                    match self.renderer.parse(&self.current_content) {
 2303|      1|                                        Ok(elements) => {
 2304|      1|                                            self.parsed_elements = elements;
 2305|      1|                                            self.error_message = None;
 2306|      1|                                        }
 2307|      1|                                        Err(e) => {
 2308|      1|                                            self.error_message =
 2309|      1|                                                Some(format!("Failed to parse markdown: {}", e));
 2310|      1|                                        }
 2311|       |                                    }
 2312|      6|                                }
 2313|      1|                            } else {
 2314|      1|                                // Read-only
 2315|      1|                                let mut tmp = self.raw_buffer.clone();
 2316|      1|                                ui.add(
 2317|      1|                                    TextEdit::multiline(&mut tmp)
 2318|      1|                                        .font(TextStyle::Monospace)
 2319|      1|                                        .code_editor()
 2320|      1|                                        .lock_focus(false)
 2321|      1|                                        .interactive(false)
 2322|      1|                                        .desired_width(f32::INFINITY)
 2323|      1|                                        .desired_rows(24),
 2324|      1|                                );
 2325|      1|                            }
 2326|       |                        }
 2327|       |                    }
 2328|       |                }
 2329|     30|            });
 2330|     30|            scroll_snapshot = Some(ScrollSnapshot {
 2331|     30|                content_size: scroll_output.content_size,
 2332|     30|                inner_rect: scroll_output.inner_rect,
 2333|     30|                offset_y: scroll_output.state.offset.y,
 2334|     30|            });
 2335|     30|        });
 2336|       |
 2337|       |        // Add context menu for the main panel
 2338|       |        #[cfg(not(test))]
 2339|       |        central_response
 2340|       |            .response
 2341|       |            .context_menu(|ui| self.render_main_context_menu(ui));
 2342|       |
 2343|     30|        if let Some(state) = self.screenshot.as_mut() {
                                  ^1
 2344|      1|            state.content_rect = Some(central_response.response.rect);
 2345|     29|        }
 2346|     30|        self.update_screenshot_state(ctx, layout_signature, scroll_snapshot);
 2347|       |
 2348|     30|        if !hide_chrome {
 2349|     29|            // Render floating search dialog (non-modal, always on top)
 2350|     29|            self.render_search_dialog(ctx);
 2351|     29|
 2352|     29|            // Render drag-and-drop overlay (must be last to appear on top)
 2353|     29|            self.render_drag_overlay(ctx);
 2354|     29|        }
                      ^1
 2355|     31|    }
 2356|       |}
 2357|       |
 2358|       |impl eframe::App for MarkdownViewerApp {
 2359|       |    /// Update function called every frame
 2360|      1|    fn update(&mut self, ctx: &Context, _frame: &mut eframe::Frame) {
 2361|      1|        self.update_impl(ctx);
 2362|      1|    }
 2363|       |
 2364|      1|    fn auto_save_interval(&self) -> std::time::Duration {
 2365|      1|        std::time::Duration::from_secs(30)
 2366|      1|    }
 2367|       |
 2368|      2|    fn save(&mut self, _storage: &mut dyn eframe::Storage) {
 2369|       |        // Persist window position and size on app save/exit
 2370|      2|        if self.screenshot.is_none() {
 2371|      1|            self.persist_window_state();
 2372|      1|        }
 2373|      2|    }
 2374|       |}
 2375|       |
 2376|       |impl MarkdownViewerApp {
 2377|       |    // Build a rich-text label with only the mnemonic character underlined (visual cue only).
 2378|    484|    fn menu_text_with_mnemonic(
 2379|    484|        prefix: Option<&str>,
 2380|    484|        label: &str,
 2381|    484|        mnemonic: char,
 2382|    484|        underline: bool,
 2383|    484|        text_color: Color32,
 2384|    484|    ) -> LayoutJob {
 2385|    484|        let mut job = LayoutJob::default();
 2386|    484|        let default_fmt = TextFormat {
 2387|    484|            color: text_color,
 2388|    484|            ..TextFormat::default()
 2389|    484|        };
 2390|    484|        if let Some(p) = prefix {
                                  ^1
 2391|      1|            job.append(p, 0.0, default_fmt.clone());
 2392|    483|        }
 2393|    484|        let m = mnemonic.to_ascii_lowercase();
 2394|    484|        let mut applied = false;
 2395|  4.46k|        for c in label.chars() {
                               ^484  ^484
 2396|  4.46k|            let mut fmt = default_fmt.clone();
 2397|  4.46k|            if underline && !applied && c.to_ascii_lowercase() == m {
                                          ^8          ^5
 2398|      1|                // Use a subtle underline color; white works well on dark theme
 2399|      1|                fmt.underline = egui::Stroke::new(1.0, text_color);
 2400|      1|                applied = true;
 2401|  4.46k|            }
 2402|  4.46k|            let s = c.to_string();
 2403|  4.46k|            job.append(&s, 0.0, fmt);
 2404|       |        }
 2405|    484|        job
 2406|    484|    }
 2407|      6|    fn persist_window_state(&mut self) {
 2408|      6|        if let Some(state) = self.current_window_state() {
                                  ^5
 2409|      5|            if !self.window_state_changed(&state) {
 2410|      1|                return;
 2411|      4|            }
 2412|      4|            if crate::save_window_state(&state).is_ok() {
 2413|      3|                self.last_persist_instant = std::time::Instant::now();
 2414|      3|                self.last_persisted_state = Some(state);
 2415|      3|            }
                          ^1
 2416|      1|        }
 2417|      6|    }
 2418|       |
 2419|     34|    fn should_persist_window_state(&self) -> bool {
 2420|     34|        if self.screenshot.is_some() {
 2421|      2|            return false;
 2422|     32|        }
 2423|     32|        if self.last_persist_instant.elapsed() < std::time::Duration::from_secs(1) {
 2424|     29|            return false;
 2425|      3|        }
 2426|      3|        if let Some(state) = self.current_window_state() {
                                  ^2
 2427|      2|            self.window_state_changed(&state)
 2428|       |        } else {
 2429|      1|            false
 2430|       |        }
 2431|     34|    }
 2432|       |
 2433|       |    /// Save current document. If no file is associated, prompts for a path.
 2434|     10|    fn save_current_document(&mut self) -> Result<()> {
 2435|     10|        if let Some(path) = self.current_file.clone() {
                                  ^5
 2436|      5|            std::fs::write(&path, &self.current_content)?;
                                                                      ^2
 2437|      3|            let parent = path.parent();
 2438|      3|            self.renderer.set_base_dir(parent);
 2439|      3|            Ok(())
 2440|      5|        } else if let Some(path) = self.pick_save_path() {
                                         ^3
 2441|      3|            std::fs::write(&path, &self.current_content)?;
                                                                      ^0
 2442|      3|            let filename = path
 2443|      3|                .file_name()
 2444|      3|                .and_then(|n| n.to_str())
 2445|      3|                .unwrap_or("Unknown")
 2446|      3|                .to_string();
 2447|      3|            self.current_file = Some(path);
 2448|      3|            let parent = self.current_file.as_ref().and_then(|p| p.parent());
 2449|      3|            self.renderer.set_base_dir(parent);
 2450|      3|            self.title = format!("{APP_TITLE_PREFIX} - {}", filename);
 2451|      3|            Ok(())
 2452|       |        } else {
 2453|      2|            Ok(())
 2454|       |        }
 2455|     10|    }
 2456|       |
 2457|       |    /// Render the floating non-modal search dialog
 2458|     35|    fn render_search_dialog(&mut self, ctx: &Context) {
 2459|     35|        if !self.show_search {
 2460|     27|            return;
 2461|      8|        }
 2462|      8|        let mut open = self.show_search;
 2463|      8|        let prev_query = self.search_query.clone();
 2464|      8|        egui::Window::new("Find")
 2465|      8|            .collapsible(false)
 2466|      8|            .resizable(false)
 2467|      8|            .default_pos(egui::pos2(80.0, 80.0))
 2468|      8|            .open(&mut open)
 2469|      8|            .show(ctx, |ui| {
 2470|      8|                let mut submitted_next = false;
 2471|      8|                ui.horizontal(|ui| {
 2472|      8|                    let text_edit = egui::TextEdit::singleline(&mut self.search_query)
 2473|      8|                        .hint_text("Search text...")
 2474|      8|                        .desired_width(240.0);
 2475|      8|                    let resp = ui.add(text_edit);
 2476|      8|                    if self.search_focus_requested {
 2477|      2|                        resp.request_focus();
 2478|      2|                        self.search_focus_requested = false;
 2479|      6|                    }
 2480|      8|                    if Self::should_submit_search(
 2481|      8|                        resp.lost_focus(),
 2482|      8|                        ui.input(|i| i.key_pressed(egui::Key::Enter)),
 2483|      1|                    ) {
 2484|      1|                        submitted_next = true;
 2485|      7|                    }
 2486|      8|                    let next_clicked = ui.button("Next (F3)").clicked();
 2487|      8|                    if app_action_triggered(next_clicked, "search_next") || submitted_next {
                                                                                          ^7
 2488|      2|                        self.find_next();
 2489|      6|                    }
 2490|      8|                    let prev_clicked = ui.button("Prev (Shift+F3)").clicked();
 2491|      8|                    if app_action_triggered(prev_clicked, "search_prev") {
 2492|      1|                        self.find_previous();
 2493|      7|                    }
 2494|      8|                });
 2495|      8|            });
 2496|      8|        if app_action_triggered(false, "search_close") {
 2497|      2|            open = false;
 2498|      6|        }
 2499|      8|        self.update_search_results(&prev_query);
 2500|       |        // If dialog closed via close button, clear before hiding
 2501|      8|        if !open {
 2502|      2|            self.clear_search_state();
 2503|      6|        }
 2504|      8|        self.show_search = open;
 2505|     35|    }
 2506|       |
 2507|     11|    fn should_submit_search(lost_focus: bool, enter_pressed: bool) -> bool {
 2508|     11|        lost_focus && enter_pressed
                                    ^3
 2509|     11|    }
 2510|       |
 2511|     12|    fn update_search_results(&mut self, prev_query: &str) {
 2512|     12|        if self.search_query == prev_query {
 2513|      8|            return;
 2514|      4|        }
 2515|      4|        if self.search_query.is_empty() {
 2516|      1|            self.last_query.clear();
 2517|      1|            self.renderer.set_highlight_phrase(None);
 2518|      1|            return;
 2519|      3|        }
 2520|      3|        self.last_query = self.search_query.clone();
 2521|       |        // Use current last match as baseline if set, else start of doc
 2522|      3|        let baseline = self.last_match_index.unwrap_or(0);
 2523|      3|        let needle = Self::fold_for_search(&self.search_query);
 2524|      3|        let total = self.parsed_elements.len();
 2525|      3|        let mut found: Option<usize> = None;
 2526|      6|        for pass in 0..2 {
                          ^5
 2527|      5|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
 2528|      3|                Box::new(baseline..total)
 2529|       |            } else {
 2530|      2|                Box::new(0..baseline.min(total))
 2531|       |            };
 2532|      8|            for idx in range {
                              ^5
 2533|      5|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
 2534|      5|                    &self.parsed_elements[idx],
 2535|       |                );
 2536|      5|                if Self::fold_for_search(&text).contains(&needle) {
 2537|      2|                    found = Some(idx);
 2538|      2|                    break;
 2539|      3|                }
 2540|       |            }
 2541|      5|            if found.is_some() {
 2542|      2|                break;
 2543|      3|            }
 2544|       |        }
 2545|      3|        if let Some(idx) = found {
                                  ^2
 2546|      2|            self.last_match_index = Some(idx);
 2547|      2|            self.pending_scroll_to_element = Some(idx);
 2548|      2|        }
                      ^1
 2549|     12|    }
 2550|       |
 2551|     35|    fn handle_screenshot_events(&mut self, ctx: &Context) {
 2552|     35|        let screenshot = ctx.input(|i| {
 2553|     35|            i.events.iter().find_map(|event| {
                                                           ^7
 2554|      7|                if let egui::Event::Screenshot { image, .. } = event {
                                                               ^4
 2555|      4|                    Some(std::sync::Arc::clone(image))
 2556|       |                } else {
 2557|      3|                    None
 2558|       |                }
 2559|      7|            })
 2560|     35|        });
 2561|     35|        let Some(image) = screenshot else {
                               ^4
 2562|     31|            return;
 2563|       |        };
 2564|      2|        let snapshot = {
 2565|      4|            let Some(state) = self.screenshot.as_ref() else {
                                   ^3
 2566|      1|                return;
 2567|       |            };
 2568|      3|            if state.done {
 2569|      1|                return;
 2570|      2|            }
 2571|      2|            ScreenshotSnapshot::from(state)
 2572|       |        };
 2573|      2|        if let Err(err) = Self::save_screenshot_image(&image, &snapshot) {
                                 ^1
 2574|      1|            eprintln!("Failed to save screenshot: {err}");
 2575|      1|        }
 2576|      2|        let state = self.screenshot.as_mut().expect("screenshot state");
 2577|      2|        state.done = true;
 2578|      2|        ctx.send_viewport_cmd(egui::ViewportCommand::Close);
 2579|     35|    }
 2580|       |
 2581|     36|    fn update_screenshot_state(
 2582|     36|        &mut self,
 2583|     36|        ctx: &Context,
 2584|     36|        layout_signature: Option<u64>,
 2585|     36|        scroll_snapshot: Option<ScrollSnapshot>,
 2586|     36|    ) {
 2587|     36|        let Some(state) = self.screenshot.as_mut() else {
                               ^7
 2588|     29|            return;
 2589|       |        };
 2590|      7|        let native_ppp = ctx
 2591|      7|            .input(|i| i.viewport().native_pixels_per_point)
 2592|      7|            .unwrap_or(1.0);
 2593|      7|        ctx.set_pixels_per_point(1.0);
 2594|      7|        state.pixels_per_point = ctx.input(|i| i.pixels_per_point);
 2595|       |
 2596|      7|        if !state.viewport_adjusted {
 2597|      6|            let width_points = (state.config.viewport_width / native_ppp).max(1.0);
 2598|      6|            let height_points = (state.config.viewport_height / native_ppp).max(1.0);
 2599|      6|            ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(egui::vec2(
 2600|      6|                width_points,
 2601|      6|                height_points,
 2602|      6|            )));
 2603|      6|            state.viewport_adjusted = true;
 2604|      6|            ctx.request_repaint();
 2605|      6|        }
                      ^1
 2606|       |
 2607|      7|        let mut scroll_offset = None;
 2608|      7|        let mut scroll_changed = false;
 2609|      7|        if let Some(snapshot) = scroll_snapshot {
                                  ^3
 2610|      3|            scroll_offset = Some(snapshot.offset_y);
 2611|      3|            scroll_changed = state.record_scroll(snapshot);
 2612|      4|        }
 2613|       |
 2614|      7|        state.update_stability(layout_signature, scroll_offset);
 2615|       |
 2616|      7|        let pending = self.renderer.has_pending_renders();
 2617|      7|        state.pending_renders = pending;
 2618|      7|        let elapsed = state.started.elapsed();
 2619|      7|        let timed_out = elapsed >= Duration::from_millis(state.config.wait_ms);
 2620|      7|        let stable = Self::screenshot_is_stable(
 2621|      7|            state.scroll_ready(),
 2622|      7|            state.stable_frames,
 2623|      7|            state.config.settle_frames,
 2624|      7|            pending,
 2625|       |        );
 2626|       |
 2627|      7|        if stable || timed_out {
                                   ^3
 2628|      6|            if timed_out && !stable {
                                          ^4
 2629|      2|                state.timed_out = true;
 2630|      4|            }
 2631|      6|            if !state.requested {
 2632|      4|                ctx.send_viewport_cmd(egui::ViewportCommand::Screenshot);
 2633|      4|                state.requested = true;
 2634|      4|            }
                          ^2
 2635|      1|        } else {
 2636|      1|            ctx.request_repaint_after(Duration::from_millis(16));
 2637|      1|        }
 2638|       |
 2639|      7|        if scroll_changed {
 2640|      1|            ctx.request_repaint();
 2641|      6|        }
 2642|      7|        if state.requested && !state.done {
                                            ^6
 2643|      5|            ctx.request_repaint();
 2644|      5|        }
                      ^2
 2645|     36|    }
 2646|       |
 2647|     11|    fn screenshot_is_stable(
 2648|     11|        scroll_ready: bool,
 2649|     11|        stable_frames: u32,
 2650|     11|        settle_frames: u32,
 2651|     11|        pending: bool,
 2652|     11|    ) -> bool {
 2653|     11|        scroll_ready && stable_frames >= settle_frames && !pending
                                      ^7                                ^6
 2654|     11|    }
 2655|       |
 2656|     13|    fn save_screenshot_image(image: &egui::ColorImage, state: &ScreenshotSnapshot) -> Result<()> {
 2657|     13|        let full_width = image.size[0] as u32;
 2658|     13|        let full_height = image.size[1] as u32;
 2659|     13|        let mut rgba = Self::color_image_to_rgba(image);
 2660|       |
 2661|     13|        let mut crop_x = 0u32;
 2662|     13|        let mut crop_y = 0u32;
 2663|     13|        let mut crop_w = full_width;
 2664|     13|        let mut crop_h = full_height;
 2665|       |
 2666|     13|        if state.config.content_only {
 2667|      8|            if let Some(rect) = state.content_rect {
                                      ^7
 2668|      7|                let pixels_per_point = state.pixels_per_point.max(0.1);
 2669|      7|                let min_x = (rect.min.x * pixels_per_point).round() as i32;
 2670|      7|                let min_y = (rect.min.y * pixels_per_point).round() as i32;
 2671|      7|                let max_x = (rect.max.x * pixels_per_point).round() as i32;
 2672|      7|                let max_y = (rect.max.y * pixels_per_point).round() as i32;
 2673|       |
 2674|      7|                let min_x = min_x.clamp(0, full_width as i32);
 2675|      7|                let min_y = min_y.clamp(0, full_height as i32);
 2676|      7|                let max_x = max_x.clamp(min_x, full_width as i32);
 2677|      7|                let max_y = max_y.clamp(min_y, full_height as i32);
 2678|       |
 2679|      7|                let width = (max_x - min_x) as u32;
 2680|      7|                let height = (max_y - min_y) as u32;
 2681|      7|                if width > 0 && height > 0 {
                                              ^6
 2682|      5|                    crop_x = min_x as u32;
 2683|      5|                    crop_y = min_y as u32;
 2684|      5|                    crop_w = width;
 2685|      5|                    crop_h = height;
 2686|      5|                }
                              ^2
 2687|      1|            }
 2688|      5|        }
 2689|       |
 2690|     13|        if crop_x != 0 || crop_y != 0 || crop_w != full_width || crop_h != full_height {
                                        ^11            ^10                     ^9
 2691|      5|            rgba = imageops::crop_imm(&rgba, crop_x, crop_y, crop_w, crop_h).to_image();
 2692|      8|        }
 2693|       |
 2694|     13|        if let Some(parent) = state.config.output_path.parent() {
                                  ^12
 2695|     12|            std::fs::create_dir_all(parent)?;
                                                         ^0
 2696|      1|        }
 2697|     13|        rgba.save(&state.config.output_path)?;
                                                          ^2
 2698|       |
 2699|     11|        let metadata = Self::screenshot_metadata(state, full_width, full_height, crop_w, crop_h);
 2700|     11|        std::fs::write(state.config.metadata_path(), metadata)?;
                                                                            ^0
 2701|     11|        Ok(())
 2702|     13|    }
 2703|       |
 2704|     11|    fn screenshot_metadata(
 2705|     11|        state: &ScreenshotSnapshot,
 2706|     11|        full_width: u32,
 2707|     11|        full_height: u32,
 2708|     11|        crop_width: u32,
 2709|     11|        crop_height: u32,
 2710|     11|    ) -> String {
 2711|     11|        let output_path = Self::json_escape(&state.config.output_path.to_string_lossy());
 2712|     11|        let font_source = state
 2713|     11|            .config
 2714|     11|            .font_source
 2715|     11|            .as_ref()
 2716|     11|            .map(|value| format!("\"{}\"", Self::json_escape(value)))
                                       ^1      ^1        ^1                ^1
 2717|     11|            .unwrap_or_else(|| "null".to_string());
                                             ^10    ^10
 2718|     11|        let scroll_ratio = Self::json_opt_f32(state.config.scroll_ratio);
 2719|     11|        let scroll_offset = Self::json_opt_f32(state.last_scroll_offset);
 2720|     11|        let elapsed_ms = state.started.elapsed().as_millis();
 2721|       |
 2722|     11|        format!(
 2723|     11|            "{{\n  \"version\": \"{}\",\n  \"build_timestamp\": \"{}\",\n  \"output\": \"{}\",\n  \"theme\": \"{}\",\n  \"zoom\": {:.3},\n  \"content_only\": {},\n  \"scroll_ratio\": {},\n  \"scroll_offset\": {},\n  \"viewport_px\": {{\"width\": {}, \"height\": {}}},\n  \"content_px\": {{\"width\": {}, \"height\": {}}},\n  \"pixels_per_point\": {:.3},\n  \"wait_ms\": {},\n  \"settle_frames\": {},\n  \"stable_frames\": {},\n  \"timed_out\": {},\n  \"pending_renders\": {},\n  \"font_source\": {},\n  \"elapsed_ms\": {}\n}}\n",
 2724|       |            BUILD_VERSION,
 2725|       |            BUILD_TIMESTAMP,
 2726|       |            output_path,
 2727|     11|            state.config.theme.as_str(),
 2728|       |            state.config.zoom,
 2729|       |            state.config.content_only,
 2730|       |            scroll_ratio,
 2731|       |            scroll_offset,
 2732|       |            full_width,
 2733|       |            full_height,
 2734|       |            crop_width,
 2735|       |            crop_height,
 2736|       |            state.pixels_per_point,
 2737|       |            state.config.wait_ms,
 2738|       |            state.config.settle_frames,
 2739|       |            state.stable_frames,
 2740|       |            state.timed_out,
 2741|       |            state.pending_renders,
 2742|       |            font_source,
 2743|       |            elapsed_ms
 2744|       |        )
 2745|     11|    }
 2746|       |
 2747|     14|    fn color_image_to_rgba(image: &egui::ColorImage) -> RgbaImage {
 2748|     14|        let width = image.size[0] as u32;
 2749|     14|        let height = image.size[1] as u32;
 2750|     14|        let mut data = Vec::with_capacity(image.pixels.len() * 4);
 2751|  8.21k|        for pixel in &image.pixels {
                          ^8.20k
 2752|  8.20k|            data.extend_from_slice(&[pixel.r(), pixel.g(), pixel.b(), pixel.a()]);
 2753|  8.20k|        }
 2754|     14|        RgbaImage::from_raw(width, height, data).unwrap_or_else(|| RgbaImage::new(width, height))
                                                                                 ^1             ^1     ^1
 2755|     14|    }
 2756|       |
 2757|     13|    fn json_escape(value: &str) -> String {
 2758|     13|        let mut out = String::with_capacity(value.len() + 8);
 2759|    645|        for ch in value.chars() {
                                ^13   ^13
 2760|    645|            match ch {
 2761|     79|                '\\' => out.push_str("\\\\"),
 2762|      1|                '"' => out.push_str("\\\""),
 2763|      1|                '\n' => out.push_str("\\n"),
 2764|      1|                '\r' => out.push_str("\\r"),
 2765|      1|                '\t' => out.push_str("\\t"),
 2766|    562|                _ => out.push(ch),
 2767|       |            }
 2768|       |        }
 2769|     13|        out
 2770|     13|    }
 2771|       |
 2772|     24|    fn json_opt_f32(value: Option<f32>) -> String {
 2773|     24|        value
 2774|     24|            .map(|v| format!("{v:.3}"))
                                   ^3      ^3
 2775|     24|            .unwrap_or_else(|| "null".to_string())
                                             ^21    ^21
 2776|     24|    }
 2777|       |
 2778|       |    // No overlay menu helpers; we only render egui's built-in menus.
 2779|       |}
 2780|       |
 2781|       |impl Default for MarkdownViewerApp {
 2782|      1|    fn default() -> Self {
 2783|      1|        Self::new()
 2784|      1|    }
 2785|       |}
 2786|       |
 2787|       |#[cfg(test)]
 2788|       |mod tests {
 2789|       |    use super::*;
 2790|       |    use crate::markdown_renderer::InlineSpan;
 2791|       |    use eframe::{App, Storage};
 2792|       |    use std::io::Write;
 2793|       |    use std::sync::{Arc, Mutex, OnceLock};
 2794|       |    use tempfile::{NamedTempFile, TempDir};
 2795|       |
 2796|     30|    fn run_app_frame(app: &mut MarkdownViewerApp, ctx: &egui::Context, input: egui::RawInput) {
 2797|     30|        let _ = ctx.run(input, |ctx| {
 2798|     30|            app.update_impl(ctx);
 2799|     30|        });
 2800|     30|    }
 2801|       |
 2802|     66|    fn default_input() -> egui::RawInput {
 2803|     66|        egui::RawInput {
 2804|     66|            screen_rect: Some(egui::Rect::from_min_size(
 2805|     66|                egui::pos2(0.0, 0.0),
 2806|     66|                egui::vec2(960.0, 640.0),
 2807|     66|            )),
 2808|     66|            ..Default::default()
 2809|     66|        }
 2810|     66|    }
 2811|       |
 2812|      6|    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
 2813|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
 2814|      6|        ENV_LOCK
 2815|      6|            .get_or_init(|| Mutex::new(()))
                                          ^1         ^1
 2816|      6|            .lock()
 2817|      6|            .expect("env lock")
 2818|      6|    }
 2819|       |
 2820|       |    struct EnvGuard {
 2821|       |        key: &'static str,
 2822|       |        original: Option<String>,
 2823|       |    }
 2824|       |
 2825|       |    impl EnvGuard {
 2826|      6|        fn set(key: &'static str, value: &str) -> Self {
 2827|      6|            let original = std::env::var(key).ok();
 2828|      6|            std::env::set_var(key, value);
 2829|      6|            Self { key, original }
 2830|      6|        }
 2831|       |    }
 2832|       |
 2833|       |    impl Drop for EnvGuard {
 2834|      6|        fn drop(&mut self) {
 2835|      6|            if let Some(value) = &self.original {
                                      ^5
 2836|      5|                std::env::set_var(self.key, value);
 2837|      5|            } else {
 2838|      1|                std::env::remove_var(self.key);
 2839|      1|            }
 2840|      6|        }
 2841|       |    }
 2842|       |
 2843|       |    #[derive(Default)]
 2844|       |    struct DummyStorage;
 2845|       |
 2846|       |    impl eframe::Storage for DummyStorage {
 2847|      1|        fn get_string(&self, _key: &str) -> Option<String> {
 2848|      1|            None
 2849|      1|        }
 2850|       |
 2851|      1|        fn set_string(&mut self, _key: &str, _value: String) {}
 2852|       |
 2853|      1|        fn flush(&mut self) {}
 2854|       |    }
 2855|       |
 2856|       |    #[test]
 2857|      1|    fn test_dummy_storage_methods_cover_noops() {
 2858|      1|        let mut storage = DummyStorage;
 2859|      1|        assert!(storage.get_string("missing").is_none());
 2860|      1|        storage.set_string("key", "value".to_string());
 2861|      1|        storage.flush();
 2862|      1|    }
 2863|       |
 2864|       |    #[test]
 2865|      1|    fn test_app_auto_save_interval_is_30_seconds() {
 2866|      1|        let app = MarkdownViewerApp::new();
 2867|      1|        assert_eq!(app.auto_save_interval(), std::time::Duration::from_secs(30));
 2868|      1|    }
 2869|       |
 2870|       |    #[test]
 2871|      1|    fn test_app_update_calls_update_impl() {
 2872|      1|        let mut app = MarkdownViewerApp::new();
 2873|      1|        let ctx = egui::Context::default();
 2874|      1|        let _ = ctx.run(default_input(), |_| {});
 2875|       |        // SAFETY: eframe::Frame is unused by update(), so a dummy value is sufficient here.
 2876|      1|        let mut frame = std::mem::MaybeUninit::<eframe::Frame>::zeroed();
 2877|      1|        let frame = unsafe { frame.assume_init_mut() };
 2878|      1|        app.update(&ctx, frame);
 2879|      1|    }
 2880|       |
 2881|       |    struct ForcedAppActions {
 2882|       |        actions: Vec<&'static str>,
 2883|       |    }
 2884|       |
 2885|       |    impl ForcedAppActions {
 2886|      6|        fn new(actions: &[&'static str]) -> Self {
 2887|      6|            FORCED_APP_ACTIONS.with(|set| {
 2888|      6|                let mut set = set.borrow_mut();
 2889|     42|                for action in actions {
                                  ^36
 2890|     36|                    set.insert(*action);
 2891|     36|                }
 2892|      6|            });
 2893|      6|            Self {
 2894|      6|                actions: actions.to_vec(),
 2895|      6|            }
 2896|      6|        }
 2897|       |    }
 2898|       |
 2899|       |    impl Drop for ForcedAppActions {
 2900|      6|        fn drop(&mut self) {
 2901|      6|            FORCED_APP_ACTIONS.with(|set| {
 2902|      6|                let mut set = set.borrow_mut();
 2903|     42|                for action in &self.actions {
                                  ^36
 2904|     36|                    set.remove(action);
 2905|     36|                }
 2906|      6|            });
 2907|      6|        }
 2908|       |    }
 2909|       |
 2910|       |    struct ForcedDialogPaths;
 2911|       |
 2912|       |    impl ForcedDialogPaths {
 2913|      8|        fn new(open: Option<PathBuf>, save: Option<PathBuf>) -> Self {
 2914|      8|            FORCED_OPEN_PATH.with(|slot| {
 2915|      8|                *slot.borrow_mut() = open;
 2916|      8|            });
 2917|      8|            FORCED_SAVE_PATH.with(|slot| {
 2918|      8|                *slot.borrow_mut() = save;
 2919|      8|            });
 2920|      8|            Self
 2921|      8|        }
 2922|       |    }
 2923|       |
 2924|       |    impl Drop for ForcedDialogPaths {
 2925|      8|        fn drop(&mut self) {
 2926|      8|            FORCED_OPEN_PATH.with(|slot| {
 2927|      8|                slot.borrow_mut().take();
 2928|      8|            });
 2929|      8|            FORCED_SAVE_PATH.with(|slot| {
 2930|      8|                slot.borrow_mut().take();
 2931|      8|            });
 2932|      8|        }
 2933|       |    }
 2934|       |
 2935|       |    struct ForcedLoadError;
 2936|       |
 2937|       |    impl ForcedLoadError {
 2938|      3|        fn new() -> Self {
 2939|      3|            FORCED_LOAD_ERROR.with(|flag| {
 2940|      3|                *flag.borrow_mut() = true;
 2941|      3|            });
 2942|      3|            Self
 2943|      3|        }
 2944|       |    }
 2945|       |
 2946|       |    impl Drop for ForcedLoadError {
 2947|      3|        fn drop(&mut self) {
 2948|      3|            FORCED_LOAD_ERROR.with(|flag| {
 2949|      3|                *flag.borrow_mut() = false;
 2950|      3|            });
 2951|      3|        }
 2952|       |    }
 2953|       |
 2954|       |    struct ForcedScanError;
 2955|       |
 2956|       |    impl ForcedScanError {
 2957|      1|        fn new() -> Self {
 2958|      1|            FORCED_SCAN_ERROR.with(|flag| {
 2959|      1|                *flag.borrow_mut() = true;
 2960|      1|            });
 2961|      1|            Self
 2962|      1|        }
 2963|       |    }
 2964|       |
 2965|       |    impl Drop for ForcedScanError {
 2966|      1|        fn drop(&mut self) {
 2967|      1|            FORCED_SCAN_ERROR.with(|flag| {
 2968|      1|                *flag.borrow_mut() = false;
 2969|      1|            });
 2970|      1|        }
 2971|       |    }
 2972|       |
 2973|       |    #[test]
 2974|      1|    fn test_app_action_triggered_with_forced_action() {
 2975|      1|        let _guard = ForcedAppActions::new(&["menu_open"]);
 2976|      1|        assert!(app_action_triggered(false, "menu_open"));
 2977|      1|        assert!(app_action_triggered(true, "menu_open"));
 2978|      1|    }
 2979|       |
 2980|       |    #[test]
 2981|      1|    fn test_normalize_line_endings() {
 2982|       |        // Windows style (\r\n)
 2983|      1|        assert_eq!(
 2984|      1|            MarkdownViewerApp::normalize_line_endings("Hello\r\nWorld"),
 2985|       |            "Hello\nWorld"
 2986|       |        );
 2987|       |
 2988|       |        // Unix style (\n) - no change
 2989|      1|        assert_eq!(
 2990|      1|            MarkdownViewerApp::normalize_line_endings("Hello\nWorld"),
 2991|       |            "Hello\nWorld"
 2992|       |        );
 2993|       |
 2994|       |        // Old Mac style (\r)
 2995|      1|        assert_eq!(
 2996|      1|            MarkdownViewerApp::normalize_line_endings("Hello\rWorld"),
 2997|       |            "Hello\nWorld"
 2998|       |        );
 2999|       |
 3000|       |        // Mixed line endings
 3001|      1|        assert_eq!(
 3002|      1|            MarkdownViewerApp::normalize_line_endings("A\r\nB\nC\rD"),
 3003|       |            "A\nB\nC\nD"
 3004|       |        );
 3005|       |
 3006|       |        // Multiple blank lines with Windows endings
 3007|      1|        assert_eq!(
 3008|      1|            MarkdownViewerApp::normalize_line_endings("A\r\n\r\nB"),
 3009|       |            "A\n\nB"
 3010|       |        );
 3011|       |
 3012|       |        // Empty string
 3013|      1|        assert_eq!(MarkdownViewerApp::normalize_line_endings(""), "");
 3014|       |
 3015|       |        // No line endings
 3016|      1|        assert_eq!(
 3017|      1|            MarkdownViewerApp::normalize_line_endings("Single line"),
 3018|       |            "Single line"
 3019|       |        );
 3020|      1|    }
 3021|       |
 3022|       |    #[test]
 3023|      1|    fn test_load_file_with_windows_line_endings() -> Result<()> {
 3024|      1|        let mut app = MarkdownViewerApp::new();
 3025|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3026|       |
 3027|       |        // Write content with explicit Windows line endings
 3028|      1|        temp_file.write_all(b"Line 1\r\nLine 2\r\n\r\nParagraph text")?;
                                                                                    ^0
 3029|      1|        temp_file.flush()?;
                                       ^0
 3030|       |
 3031|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 3032|       |
 3033|       |        // Should not contain any \r characters after normalization
 3034|      1|        assert!(!app.current_content.contains('\r'));
 3035|      1|        assert!(app.current_content.contains("Line 1\nLine 2"));
 3036|      1|        assert!(app.current_content.contains("\n\nParagraph"));
 3037|      1|        Ok(())
 3038|      1|    }
 3039|       |
 3040|       |    #[test]
 3041|      1|    fn test_load_file_with_mixed_line_endings() -> Result<()> {
 3042|      1|        let mut app = MarkdownViewerApp::new();
 3043|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3044|       |
 3045|       |        // Mix of \r\n (Windows), \n (Unix), and \r (old Mac)
 3046|      1|        temp_file.write_all(b"Line 1\r\nLine 2\nLine 3\rLine 4")?;
                                                                              ^0
 3047|      1|        temp_file.flush()?;
                                       ^0
 3048|       |
 3049|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 3050|       |
 3051|       |        // All should be normalized to \n
 3052|      1|        assert!(!app.current_content.contains('\r'));
 3053|      1|        assert_eq!(app.current_content.lines().count(), 4);
 3054|      1|        let lines: Vec<&str> = app.current_content.lines().collect();
 3055|      1|        assert_eq!(lines[0], "Line 1");
 3056|      1|        assert_eq!(lines[1], "Line 2");
 3057|      1|        assert_eq!(lines[2], "Line 3");
 3058|      1|        assert_eq!(lines[3], "Line 4");
 3059|      1|        Ok(())
 3060|      1|    }
 3061|       |
 3062|       |    #[test]
 3063|      1|    fn test_load_file_strips_bom() -> Result<()> {
 3064|      1|        let mut app = MarkdownViewerApp::new();
 3065|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3066|       |
 3067|      1|        temp_file.write_all(b"\xEF\xBB\xBF# Heading\nContent")?;
                                                                            ^0
 3068|      1|        temp_file.flush()?;
                                       ^0
 3069|       |
 3070|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 3071|       |
 3072|      1|        assert!(!app.current_content.starts_with('\u{FEFF}'));
 3073|      1|        assert!(app.current_content.starts_with("# Heading"));
 3074|      1|        Ok(())
 3075|      1|    }
 3076|       |
 3077|       |    #[test]
 3078|      1|    fn test_app_creation() {
 3079|      1|        let app = MarkdownViewerApp::new();
 3080|      1|        assert!(!app.parsed_elements.is_empty()); // Should load welcome content
 3081|      1|        assert!(app.title.contains(APP_TITLE_PREFIX));
 3082|      1|        assert!(app.error_message.is_none());
 3083|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 3084|      1|    }
 3085|       |
 3086|       |    #[test]
 3087|      1|    fn test_load_content() {
 3088|      1|        let mut app = MarkdownViewerApp::new();
 3089|      1|        let content = "# Test Header\n\nThis is test content.";
 3090|       |
 3091|      1|        app.load_content(content, Some("Test".to_string()));
 3092|       |
 3093|      1|        assert_eq!(app.current_content, content);
 3094|      1|        assert_eq!(app.raw_buffer, content);
 3095|      1|        assert!(app.title.contains("Test"));
 3096|      1|        assert!(!app.parsed_elements.is_empty());
 3097|      1|        assert!(app.error_message.is_none());
 3098|      1|    }
 3099|       |
 3100|       |    #[test]
 3101|      1|    fn test_toggle_view_mode() {
 3102|      1|        let mut app = MarkdownViewerApp::new();
 3103|      1|        let ctx = egui::Context::default();
 3104|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 3105|      1|        app.toggle_view_mode(&ctx);
 3106|      1|        assert!(matches!(app.view_mode, ViewMode::Raw));
                              ^0
 3107|      1|        app.toggle_view_mode(&ctx);
 3108|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 3109|      1|    }
 3110|       |
 3111|       |    #[test]
 3112|      1|    fn test_toggle_view_mode_without_text_state() {
 3113|      1|        let mut app = MarkdownViewerApp::new();
 3114|      1|        app.view_mode = ViewMode::Raw;
 3115|      1|        app.write_enabled = true;
 3116|      1|        let ctx = egui::Context::default();
 3117|      1|        app.toggle_view_mode(&ctx);
 3118|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 3119|      1|        assert!(app.raw_cursor.is_none());
 3120|      1|    }
 3121|       |
 3122|       |    #[test]
 3123|      1|    fn test_toggle_view_mode_with_state_without_cursor_range() {
 3124|      1|        let mut app = MarkdownViewerApp::new();
 3125|      1|        app.view_mode = ViewMode::Raw;
 3126|      1|        app.write_enabled = true;
 3127|      1|        let ctx = egui::Context::default();
 3128|      1|        let editor_id = egui::Id::new("raw_editor");
 3129|      1|        let mut state = egui::text_edit::TextEditState::default();
 3130|      1|        state.cursor.set_char_range(None);
 3131|      1|        state.store(&ctx, editor_id);
 3132|       |
 3133|      1|        app.toggle_view_mode(&ctx);
 3134|       |
 3135|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 3136|      1|        assert!(app.raw_cursor.is_none());
 3137|      1|    }
 3138|       |
 3139|       |    #[test]
 3140|      1|    fn test_load_sample() {
 3141|      1|        let mut app = MarkdownViewerApp::new();
 3142|      1|        let sample = &SAMPLE_FILES[0]; // First sample file
 3143|       |
 3144|      1|        app.load_sample(sample);
 3145|       |
 3146|      1|        assert_eq!(app.current_content, sample.content);
 3147|      1|        assert!(app.title.contains(sample.title));
 3148|      1|        assert!(!app.parsed_elements.is_empty());
 3149|      1|        assert!(app.current_file.is_none()); // Sample files don't set file path
 3150|      1|    }
 3151|       |
 3152|       |    #[test]
 3153|      1|    fn test_load_sample_by_name_reports_missing() {
 3154|      1|        let mut app = MarkdownViewerApp::new();
 3155|      1|        app.current_content = "keep".to_string();
 3156|       |
 3157|      1|        let loaded = app.load_sample_by_name(&[], "missing.md");
 3158|       |
 3159|      1|        assert!(!loaded);
 3160|      1|        assert_eq!(app.current_content, "keep");
 3161|      1|    }
 3162|       |
 3163|       |    #[test]
 3164|      1|    fn test_load_sample_by_name_loads_content() {
 3165|      1|        let mut app = MarkdownViewerApp::new();
 3166|      1|        let sample = SAMPLE_FILES
 3167|      1|            .iter()
 3168|      1|            .find(|sample| sample.name == "welcome.md")
 3169|      1|            .expect("welcome sample");
 3170|       |
 3171|      1|        let loaded = app.load_sample_by_name(SAMPLE_FILES, "welcome.md");
 3172|       |
 3173|      1|        assert!(loaded);
 3174|      1|        assert_eq!(app.current_content, sample.content);
 3175|      1|        assert_eq!(app.pending_scroll_to_element, Some(0));
 3176|      1|    }
 3177|       |
 3178|       |    #[test]
 3179|      1|    fn test_load_welcome_from_samples_missing_clears_state() {
 3180|      1|        let mut app = MarkdownViewerApp::new();
 3181|      1|        app.current_content = "content".to_string();
 3182|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 3183|      1|            "content".to_string(),
 3184|      1|        )])];
 3185|      1|        app.title = "Custom".to_string();
 3186|      1|        app.error_message = Some("error".to_string());
 3187|       |
 3188|      1|        app.load_welcome_from_samples(&[], false);
 3189|       |
 3190|      1|        assert!(app.current_content.is_empty());
 3191|      1|        assert!(app.parsed_elements.is_empty());
 3192|      1|        assert_eq!(app.title, APP_TITLE_PREFIX);
 3193|      1|        assert!(app.error_message.is_none());
 3194|      1|    }
 3195|       |
 3196|       |    #[test]
 3197|      1|    fn test_load_welcome_from_samples_sets_scroll_when_requested() {
 3198|      1|        let mut app = MarkdownViewerApp::new();
 3199|      1|        app.pending_scroll_to_element = None;
 3200|       |
 3201|      1|        app.load_welcome_from_samples(SAMPLE_FILES, true);
 3202|       |
 3203|      1|        assert_eq!(app.pending_scroll_to_element, Some(0));
 3204|      1|    }
 3205|       |
 3206|       |    #[test]
 3207|      1|    fn test_spawn_file_loader_handles_error_path() {
 3208|      1|        MarkdownViewerApp::force_thread_spawn_error_for_test();
 3209|      1|        let _ = MarkdownViewerApp::spawn_file_loader();
 3210|      1|    }
 3211|       |
 3212|       |    #[test]
 3213|      1|    fn test_spawn_file_loader_processes_request() -> Result<()> {
 3214|      1|        let temp = NamedTempFile::new()?;
                                                     ^0
 3215|      1|        writeln!(&temp, "hello")?;
                                              ^0
 3216|       |
 3217|      1|        let (request_tx, result_rx) = MarkdownViewerApp::spawn_file_loader();
 3218|      1|        request_tx
 3219|      1|            .send(FileLoadRequest {
 3220|      1|                id: 99,
 3221|      1|                path: temp.path().to_path_buf(),
 3222|      1|            })
 3223|      1|            .expect("send");
 3224|      1|        let result = result_rx
 3225|      1|            .recv_timeout(std::time::Duration::from_secs(1))
 3226|      1|            .expect("result");
 3227|      1|        let (content, lossy) = result.content.expect("content");
 3228|      1|        assert!(content.contains("hello"));
 3229|      1|        assert!(!lossy);
 3230|      1|        drop(request_tx);
 3231|      1|        Ok(())
 3232|      1|    }
 3233|       |
 3234|       |    #[test]
 3235|      1|    fn test_spawn_file_loader_reports_missing_file() {
 3236|      1|        let temp_dir = TempDir::new().expect("temp dir");
 3237|      1|        let missing_path = temp_dir.path().join("missing.md");
 3238|       |
 3239|      1|        let (request_tx, result_rx) = MarkdownViewerApp::spawn_file_loader();
 3240|      1|        request_tx
 3241|      1|            .send(FileLoadRequest {
 3242|      1|                id: 101,
 3243|      1|                path: missing_path,
 3244|      1|            })
 3245|      1|            .expect("send");
 3246|      1|        let result = result_rx
 3247|      1|            .recv_timeout(std::time::Duration::from_secs(1))
 3248|      1|            .expect("result");
 3249|      1|        assert!(result.content.is_err());
 3250|      1|        drop(request_tx);
 3251|      1|    }
 3252|       |
 3253|       |    #[test]
 3254|      1|    fn test_load_sample_without_existing_content_skips_history() {
 3255|      1|        let mut app = MarkdownViewerApp::new();
 3256|      1|        app.current_content.clear();
 3257|      1|        app.raw_buffer.clear();
 3258|      1|        app.history.clear();
 3259|      1|        app.history_index = 0;
 3260|      1|        let sample = &SAMPLE_FILES[0];
 3261|       |
 3262|      1|        app.load_sample(sample);
 3263|       |
 3264|      1|        assert!(app.history.is_empty());
 3265|      1|    }
 3266|       |
 3267|       |    #[test]
 3268|      1|    fn test_load_file() -> Result<()> {
 3269|      1|        let mut app = MarkdownViewerApp::new();
 3270|       |
 3271|       |        // Create a temporary markdown file
 3272|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3273|      1|        let content = "# Temporary File\n\nThis is a test markdown file.";
 3274|      1|        temp_file.write_all(content.as_bytes())?;
                                                             ^0
 3275|      1|        temp_file.flush()?;
                                       ^0
 3276|       |
 3277|      1|        let path = temp_file.path().to_path_buf();
 3278|      1|        app.load_file(path.clone(), true)?;
                                                       ^0
 3279|       |
 3280|      1|        assert_eq!(app.current_content, content);
 3281|      1|        assert_eq!(app.current_file, Some(path));
 3282|      1|        assert!(!app.parsed_elements.is_empty());
 3283|      1|        assert!(app.error_message.is_none());
 3284|       |
 3285|      1|        Ok(())
 3286|      1|    }
 3287|       |
 3288|       |    #[test]
 3289|      1|    fn test_load_file_async_sends_request() -> Result<()> {
 3290|      1|        let mut app = MarkdownViewerApp::new();
 3291|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3292|      1|        let payload = vec![b'a'; ASYNC_LOAD_THRESHOLD_BYTES as usize];
 3293|      1|        temp_file.write_all(&payload)?;
                                                   ^0
 3294|      1|        temp_file.flush()?;
                                       ^0
 3295|       |
 3296|      1|        let path = temp_file.path().to_path_buf();
 3297|      1|        app.load_file(path.clone(), false)?;
                                                        ^0
 3298|      1|        assert!(app.pending_file_load.is_some());
 3299|      1|        assert_eq!(app.pending_file_load.as_ref().expect("pending").path, path);
 3300|      1|        Ok(())
 3301|      1|    }
 3302|       |
 3303|       |    #[test]
 3304|      1|    fn test_load_file_skips_async_when_screenshot_active() -> Result<()> {
 3305|      1|        let mut app = MarkdownViewerApp::new();
 3306|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3307|      1|        let payload = vec![b'a'; ASYNC_LOAD_THRESHOLD_BYTES as usize];
 3308|      1|        temp_file.write_all(&payload)?;
                                                   ^0
 3309|      1|        temp_file.flush()?;
                                       ^0
 3310|       |
 3311|      1|        let config = ScreenshotConfig {
 3312|      1|            output_path: temp_file.path().with_extension("png"),
 3313|      1|            viewport_width: 120.0,
 3314|      1|            viewport_height: 80.0,
 3315|      1|            content_only: false,
 3316|      1|            scroll_ratio: None,
 3317|      1|            wait_ms: 0,
 3318|      1|            settle_frames: 0,
 3319|      1|            zoom: 1.0,
 3320|      1|            theme: ScreenshotTheme::Light,
 3321|      1|            font_source: None,
 3322|      1|        };
 3323|      1|        app.screenshot = Some(ScreenshotState::new(config));
 3324|       |
 3325|      1|        let path = temp_file.path().to_path_buf();
 3326|      1|        app.load_file(path.clone(), false)?;
                                                        ^0
 3327|       |
 3328|      1|        assert!(app.pending_file_load.is_none());
 3329|      1|        assert_eq!(app.current_file, Some(path));
 3330|      1|        Ok(())
 3331|      1|    }
 3332|       |
 3333|       |    #[test]
 3334|      1|    fn test_load_file_async_falls_back_when_channel_closed() -> Result<()> {
 3335|      1|        let mut app = MarkdownViewerApp::new();
 3336|      1|        let (tx, rx) = unbounded::<FileLoadRequest>();
 3337|      1|        drop(rx);
 3338|      1|        app.file_load_tx = tx;
 3339|       |
 3340|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3341|      1|        let payload = vec![b'a'; ASYNC_LOAD_THRESHOLD_BYTES as usize];
 3342|      1|        temp_file.write_all(&payload)?;
                                                   ^0
 3343|      1|        temp_file.flush()?;
                                       ^0
 3344|       |
 3345|      1|        let path = temp_file.path().to_path_buf();
 3346|      1|        app.load_file(path.clone(), false)?;
                                                        ^0
 3347|      1|        assert_eq!(app.current_file, Some(path));
 3348|      1|        assert!(app.pending_file_load.is_none());
 3349|      1|        Ok(())
 3350|      1|    }
 3351|       |
 3352|       |    #[test]
 3353|      1|    fn test_poll_file_loads_handles_mismatch_and_lossy() {
 3354|      1|        let mut app = MarkdownViewerApp::new();
 3355|      1|        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
 3356|      1|        app.file_load_rx = result_rx;
 3357|       |
 3358|      1|        let temp = NamedTempFile::new().expect("temp");
 3359|      1|        let path = temp.path().to_path_buf();
 3360|      1|        app.pending_file_load = Some(PendingFileLoad {
 3361|      1|            id: 1,
 3362|      1|            path: path.clone(),
 3363|      1|        });
 3364|       |
 3365|      1|        result_tx
 3366|      1|            .send(FileLoadResult {
 3367|      1|                id: 2,
 3368|      1|                content: Ok(("ignored".to_string(), false)),
 3369|      1|            })
 3370|      1|            .expect("send mismatch");
 3371|      1|        app.poll_file_loads();
 3372|      1|        assert!(app.pending_file_load.is_some());
 3373|       |
 3374|      1|        result_tx
 3375|      1|            .send(FileLoadResult {
 3376|      1|                id: 1,
 3377|      1|                content: Ok(("loaded".to_string(), true)),
 3378|      1|            })
 3379|      1|            .expect("send match");
 3380|      1|        app.poll_file_loads();
 3381|      1|        assert!(app.pending_file_load.is_none());
 3382|      1|        assert_eq!(app.current_file, Some(path));
 3383|      1|    }
 3384|       |
 3385|       |    #[test]
 3386|      1|    fn test_poll_file_loads_handles_match_non_lossy() {
 3387|      1|        let mut app = MarkdownViewerApp::new();
 3388|      1|        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
 3389|      1|        app.file_load_rx = result_rx;
 3390|       |
 3391|      1|        let temp = NamedTempFile::new().expect("temp");
 3392|      1|        let path = temp.path().to_path_buf();
 3393|      1|        app.pending_file_load = Some(PendingFileLoad {
 3394|      1|            id: 1,
 3395|      1|            path: path.clone(),
 3396|      1|        });
 3397|       |
 3398|      1|        result_tx
 3399|      1|            .send(FileLoadResult {
 3400|      1|                id: 1,
 3401|      1|                content: Ok(("loaded".to_string(), false)),
 3402|      1|            })
 3403|      1|            .expect("send match");
 3404|      1|        app.poll_file_loads();
 3405|      1|        assert!(app.pending_file_load.is_none());
 3406|      1|        assert_eq!(app.current_file, Some(path));
 3407|      1|    }
 3408|       |
 3409|       |    #[test]
 3410|      1|    fn test_poll_file_loads_sets_error_on_failure() {
 3411|      1|        let mut app = MarkdownViewerApp::new();
 3412|      1|        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
 3413|      1|        app.file_load_rx = result_rx;
 3414|       |
 3415|      1|        let temp = NamedTempFile::new().expect("temp");
 3416|      1|        let path = temp.path().to_path_buf();
 3417|      1|        app.pending_file_load = Some(PendingFileLoad { id: 1, path });
 3418|       |
 3419|      1|        result_tx
 3420|      1|            .send(FileLoadResult {
 3421|      1|                id: 1,
 3422|      1|                content: Err("boom".to_string()),
 3423|      1|            })
 3424|      1|            .expect("send match");
 3425|      1|        app.poll_file_loads();
 3426|      1|        assert!(app.pending_file_load.is_none());
 3427|      1|        assert!(app.error_message.as_deref().unwrap_or("").contains("boom"));
 3428|      1|    }
 3429|       |
 3430|       |    #[test]
 3431|      1|    fn test_load_invalid_markdown() {
 3432|      1|        let mut app = MarkdownViewerApp::new();
 3433|       |        // Even "invalid" markdown should parse successfully with pulldown-cmark
 3434|       |        // as it's very permissive
 3435|      1|        let content = "This is just plain text with some <invalid> HTML tags";
 3436|       |
 3437|      1|        app.load_content(content, Some("Invalid".to_string()));
 3438|       |
 3439|       |        // Should still work - pulldown-cmark is very permissive
 3440|      1|        assert_eq!(app.current_content, content);
 3441|      1|        assert!(app.error_message.is_none());
 3442|      1|    }
 3443|       |
 3444|       |    #[test]
 3445|      1|    fn test_load_content_parse_error_sets_message() {
 3446|      1|        let mut app = MarkdownViewerApp::new();
 3447|      1|        crate::markdown_renderer::force_parse_error_once();
 3448|       |
 3449|      1|        app.load_content("# Bad Parse", Some("Bad".to_string()));
 3450|       |
 3451|      1|        assert!(app
 3452|      1|            .error_message
 3453|      1|            .as_ref()
 3454|      1|            .is_some_and(|msg| msg.contains("Failed to parse markdown")));
 3455|      1|        assert!(app.parsed_elements.is_empty());
 3456|      1|    }
 3457|       |
 3458|       |    #[test]
 3459|      1|    fn test_load_empty_content() {
 3460|      1|        let mut app = MarkdownViewerApp::new();
 3461|      1|        app.load_content("", Some("Empty".to_string()));
 3462|       |
 3463|      1|        assert_eq!(app.current_content, "");
 3464|      1|        assert!(app.title.contains("Empty"));
 3465|      1|        assert!(app.error_message.is_none());
 3466|      1|    }
 3467|       |
 3468|       |    #[test]
 3469|      1|    fn test_load_nonexistent_file() {
 3470|      1|        let mut app = MarkdownViewerApp::new();
 3471|      1|        let fake_path = PathBuf::from("/nonexistent/file.md");
 3472|       |
 3473|      1|        let result = app.load_file(fake_path, true);
 3474|      1|        assert!(result.is_err());
 3475|      1|    }
 3476|       |
 3477|       |    #[test]
 3478|      1|    fn test_reload_current_file() -> Result<()> {
 3479|      1|        let mut app = MarkdownViewerApp::new();
 3480|       |
 3481|       |        // Create a temporary markdown file
 3482|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3483|      1|        let content1 = "# Title\n\nVersion 1";
 3484|      1|        temp_file.write_all(content1.as_bytes())?;
                                                              ^0
 3485|      1|        temp_file.flush()?;
                                       ^0
 3486|       |
 3487|      1|        let path = temp_file.path().to_path_buf();
 3488|      1|        app.load_file(path.clone(), true)?;
                                                       ^0
 3489|      1|        assert!(app.current_content.contains("Version 1"));
 3490|       |
 3491|       |        // Update file content
 3492|      1|        let content2 = "# Title\n\nVersion 2";
 3493|      1|        temp_file.as_file_mut().set_len(0)?; // clear
                                                        ^0
 3494|      1|        temp_file.write_all(content2.as_bytes())?;
                                                              ^0
 3495|      1|        temp_file.flush()?;
                                       ^0
 3496|       |
 3497|       |        // Reload and verify
 3498|      1|        app.reload_current_file()?;
                                               ^0
 3499|      1|        assert!(app.current_content.contains("Version 2"));
 3500|      1|        Ok(())
 3501|      1|    }
 3502|       |
 3503|       |    #[test]
 3504|      1|    fn test_load_file_with_invalid_utf8() -> Result<()> {
 3505|      1|        let mut app = MarkdownViewerApp::new();
 3506|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3507|      1|        let bytes = b"Hello\xFFWorld";
 3508|      1|        temp_file.write_all(bytes)?;
                                                ^0
 3509|      1|        temp_file.flush()?;
                                       ^0
 3510|       |
 3511|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 3512|       |
 3513|      1|        assert!(app.current_content.contains('\u{FFFD}'));
 3514|      1|        assert!(!app.parsed_elements.is_empty());
 3515|      1|        assert!(app.error_message.is_none());
 3516|      1|        Ok(())
 3517|      1|    }
 3518|       |
 3519|       |    #[test]
 3520|      1|    fn test_reload_without_file() {
 3521|      1|        let mut app = MarkdownViewerApp::new();
 3522|      1|        assert!(app.current_file.is_none());
 3523|      1|        let result = app.reload_current_file();
 3524|      1|        assert!(result.is_err());
 3525|      1|    }
 3526|       |
 3527|       |    #[test]
 3528|      1|    fn test_window_state_change_detection() {
 3529|      1|        let mut app = MarkdownViewerApp::new();
 3530|      1|        app.last_window_pos = Some([10.0, 10.0]);
 3531|      1|        app.last_window_size = Some([800.0, 600.0]);
 3532|      1|        app.last_window_maximized = false;
 3533|       |
 3534|      1|        let state = app.current_window_state().expect("state");
 3535|      1|        assert!(app.window_state_changed(&state));
 3536|      1|        app.last_persisted_state = Some(state);
 3537|      1|        assert!(!app.window_state_changed(&state));
 3538|       |
 3539|      1|        let mut moved = state;
 3540|      1|        moved.pos = [12.0, 10.0];
 3541|      1|        assert!(app.window_state_changed(&moved));
 3542|       |
 3543|      1|        let mut resized = state;
 3544|      1|        resized.size = [820.0, 610.0];
 3545|      1|        assert!(app.window_state_changed(&resized));
 3546|       |
 3547|      1|        let mut maximized = state;
 3548|      1|        maximized.maximized = true;
 3549|      1|        assert!(app.window_state_changed(&maximized));
 3550|      1|    }
 3551|       |
 3552|       |    #[test]
 3553|      1|    fn test_fold_for_search_handles_case_and_accents() {
 3554|      1|        assert_eq!(
 3555|      1|            MarkdownViewerApp::fold_for_search("\u{00C4}\u{00DF}"),
 3556|      1|            MarkdownViewerApp::fold_for_search("\u{00E4}SS")
 3557|       |        );
 3558|      1|        assert_eq!(
 3559|      1|            MarkdownViewerApp::fold_for_search("To\u{0301}m"),
 3560|      1|            MarkdownViewerApp::fold_for_search("T\u{00D3}m")
 3561|       |        );
 3562|      1|    }
 3563|       |
 3564|       |    #[test]
 3565|      1|    fn test_title_updates() {
 3566|      1|        let mut app = MarkdownViewerApp::new();
 3567|       |
 3568|       |        // Test with custom title
 3569|      1|        app.load_content("# Test", Some("Custom Title".to_string()));
 3570|      1|        assert!(app.title.contains("Custom Title"));
 3571|       |
 3572|       |        // Test with no title (should keep existing)
 3573|      1|        let old_title = app.title.clone();
 3574|      1|        app.load_content("# Another Test", None);
 3575|      1|        assert_eq!(app.title, old_title); // Should remain unchanged
 3576|      1|    }
 3577|       |
 3578|       |    #[test]
 3579|      1|    fn test_complex_markdown_loading() {
 3580|      1|        let mut app = MarkdownViewerApp::new();
 3581|      1|        let complex_content = r#"# Complex Document
 3582|      1|
 3583|      1|## With Multiple Sections
 3584|      1|
 3585|      1|This has **bold** and *italic* text.
 3586|      1|
 3587|      1|```rust
 3588|      1|fn main() {
 3589|      1|    println!("Hello, world!");
 3590|      1|}
 3591|      1|```
 3592|      1|
 3593|      1|- List item 1
 3594|      1|- List item 2
 3595|      1|
 3596|      1|> A blockquote
 3597|      1|
 3598|      1|[A link](https://example.com)
 3599|      1|
 3600|      1|---
 3601|      1|
 3602|      1|The end.
 3603|      1|"#;
 3604|       |
 3605|      1|        app.load_content(complex_content, Some("Complex".to_string()));
 3606|       |
 3607|      1|        assert_eq!(app.current_content, complex_content);
 3608|      1|        assert!(app.title.contains("Complex"));
 3609|      1|        assert!(!app.parsed_elements.is_empty());
 3610|      1|        assert!(app.error_message.is_none());
 3611|       |
 3612|       |        // Should have parsed various element types
 3613|      1|        assert!(app.parsed_elements.len() > 5); // Complex document should have many elements
 3614|      1|    }
 3615|       |
 3616|       |    #[test]
 3617|      1|    fn test_error_handling() {
 3618|      1|        let app = MarkdownViewerApp::new();
 3619|       |
 3620|       |        // Test that app starts without errors
 3621|      1|        assert!(app.error_message.is_none());
 3622|       |
 3623|       |        // Even with the welcome content loaded, should be error-free
 3624|      1|        assert!(!app.parsed_elements.is_empty());
 3625|      1|    }
 3626|       |
 3627|       |    #[test]
 3628|      1|    fn test_default_state() {
 3629|      1|        let app = MarkdownViewerApp::default();
 3630|       |
 3631|       |        // Default should be same as new()
 3632|      1|        assert!(!app.parsed_elements.is_empty());
 3633|      1|        assert!(app.title.contains(APP_TITLE_PREFIX));
 3634|      1|        assert!(app.error_message.is_none());
 3635|      1|        assert!(app.current_file.is_none());
 3636|      1|    }
 3637|       |
 3638|       |    #[test]
 3639|      1|    fn test_sample_files_integration() {
 3640|      1|        let mut app = MarkdownViewerApp::new();
 3641|       |
 3642|       |        // Test loading each sample file
 3643|      7|        for sample in SAMPLE_FILES {
                          ^6
 3644|      6|            app.load_sample(sample);
 3645|       |
 3646|      6|            assert_eq!(app.current_content, sample.content);
 3647|      6|            assert!(app.title.contains(sample.title));
 3648|      6|            assert!(app.current_file.is_none());
 3649|      6|            assert!(app.error_message.is_none());
 3650|       |        }
 3651|      1|    }
 3652|       |
 3653|       |    #[test]
 3654|      1|    fn test_close_current_file() {
 3655|      1|        let mut app = MarkdownViewerApp::new();
 3656|       |
 3657|       |        // Load some content first
 3658|      1|        app.load_content("# Test Content", Some("Test File".to_string()));
 3659|      1|        assert!(app.title.contains("Test File"));
 3660|       |
 3661|       |        // Close the file
 3662|      1|        app.close_current_file();
 3663|       |
 3664|       |        // Should return to welcome screen
 3665|      1|        assert!(app.title.contains("Welcome"));
 3666|      1|        assert!(app.current_file.is_none());
 3667|      1|        assert!(!app.parsed_elements.is_empty()); // Should have welcome content
 3668|      1|        assert!(app.error_message.is_none());
 3669|      1|    }
 3670|       |
 3671|       |    #[test]
 3672|      1|    fn test_navigation_request_enum() {
 3673|       |        // Test that the enum values exist and are correct
 3674|      1|        let _top = NavigationRequest::Top;
 3675|      1|        let _bottom = NavigationRequest::Bottom;
 3676|      1|        let _page_up = NavigationRequest::PageUp;
 3677|      1|        let _page_down = NavigationRequest::PageDown;
 3678|      1|        let _scroll_up = NavigationRequest::ScrollUp;
 3679|      1|        let _scroll_down = NavigationRequest::ScrollDown;
 3680|       |
 3681|       |        // Ensure it's cloneable and debuggable
 3682|      1|        let nav = NavigationRequest::Top;
 3683|      1|        let _cloned = nav.clone();
 3684|      1|        let _debug = format!("{:?}", nav);
 3685|       |
 3686|       |        // Basic compilation test performed by using the enum and Debug/Clone
 3687|      1|    }
 3688|       |
 3689|       |    #[test]
 3690|      1|    fn test_navigation_state_initialization() {
 3691|      1|        let app = MarkdownViewerApp::new();
 3692|       |        // Test that nav_request is initialized to None
 3693|      1|        assert!(app.nav_request.is_none());
 3694|       |        // Test that fullscreen toggle flag is initialized to false
 3695|      1|        assert!(!app.toggle_fullscreen);
 3696|      1|    }
 3697|       |
 3698|       |    #[test]
 3699|      1|    fn test_fullscreen_toggle_flag() {
 3700|      1|        let mut app = MarkdownViewerApp::new();
 3701|       |
 3702|       |        // Initially should be false
 3703|      1|        assert!(!app.toggle_fullscreen);
 3704|       |
 3705|       |        // Simulate F11 key press (this would be set in handle_shortcuts)
 3706|      1|        app.toggle_fullscreen = true;
 3707|      1|        assert!(app.toggle_fullscreen);
 3708|       |
 3709|       |        // After handling, it should be reset to false
 3710|      1|        app.toggle_fullscreen = false;
 3711|      1|        assert!(!app.toggle_fullscreen);
 3712|      1|    }
 3713|       |
 3714|       |    #[test]
 3715|      1|    fn test_navigation_state_reset_on_load() {
 3716|      1|        let mut app = MarkdownViewerApp::new();
 3717|       |
 3718|       |        // Set a navigation request
 3719|      1|        app.nav_request = Some(NavigationRequest::Top);
 3720|      1|        assert!(app.nav_request.is_some());
 3721|       |
 3722|       |        // Load content should reset navigation state
 3723|      1|        app.load_content("# Test Content", Some("Test".to_string()));
 3724|      1|        assert!(app.nav_request.is_none());
 3725|      1|    }
 3726|       |
 3727|       |    #[test]
 3728|      1|    fn test_page_navigation_calculations() {
 3729|       |        // Test the page size calculation logic used in navigation
 3730|      1|        let viewport_height = 800.0f32;
 3731|      1|        let page_size = viewport_height * 0.8;
 3732|      1|        assert_eq!(page_size, 640.0);
 3733|       |
 3734|       |        // Test boundary conditions for Page Up
 3735|      1|        let current_offset = 100.0f32;
 3736|      1|        let new_offset_up = (current_offset - page_size).max(0.0);
 3737|      1|        assert_eq!(new_offset_up, 0.0); // Should clamp to 0
 3738|       |
 3739|       |        // Test Page Down calculation
 3740|      1|        let new_offset_down = current_offset + page_size;
 3741|      1|        assert_eq!(new_offset_down, 740.0);
 3742|       |
 3743|       |        // Test that Page Up from near top goes to 0
 3744|      1|        let near_top = 300.0f32;
 3745|      1|        let from_near_top = (near_top - page_size).max(0.0);
 3746|      1|        assert_eq!(from_near_top, 0.0);
 3747|      1|    }
 3748|       |
 3749|       |    #[test]
 3750|      1|    fn test_compute_window_adjustment_clamps_offscreen_window() {
 3751|      1|        let outer = egui::Rect::from_min_size(egui::pos2(1200.0, 900.0), egui::vec2(800.0, 600.0));
 3752|      1|        let monitor = egui::vec2(1024.0, 768.0);
 3753|      1|        let adjustment =
 3754|      1|            MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), Some(monitor))
 3755|      1|                .expect("should adjust window geometry");
 3756|      1|        let pos = adjustment.pos.expect("expected position adjustment");
 3757|      1|        let size = adjustment.size.unwrap_or_else(|| outer.size());
 3758|      1|        assert!(pos.x <= monitor.x - size.x + 1.0);
 3759|      1|        assert!(pos.y <= monitor.y - size.y + 1.0);
 3760|      1|        assert!(adjustment.size.is_none());
 3761|      1|    }
 3762|       |
 3763|       |    #[test]
 3764|      1|    fn test_compute_window_adjustment_respects_min_size() {
 3765|      1|        let outer = egui::Rect::from_min_size(egui::pos2(-200.0, -100.0), egui::vec2(200.0, 100.0));
 3766|      1|        let monitor = egui::vec2(1920.0, 1080.0);
 3767|      1|        let adjustment =
 3768|      1|            MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), Some(monitor))
 3769|      1|                .expect("should enforce minimum window size");
 3770|      1|        let pos = adjustment.pos.unwrap_or(outer.min);
 3771|      1|        let size = adjustment.size.expect("expected size adjustment");
 3772|      1|        assert!(size.x >= 600.0);
 3773|      1|        assert!(size.y >= 400.0);
 3774|      1|        assert!(pos.x >= 0.0);
 3775|      1|        assert!(pos.y >= 0.0);
 3776|      1|    }
 3777|       |
 3778|       |    #[test]
 3779|      1|    fn test_is_valid_markdown_file() {
 3780|      1|        let app = MarkdownViewerApp::new();
 3781|       |
 3782|       |        // Valid markdown extensions
 3783|      1|        assert!(app.is_valid_markdown_file(Path::new("test.md")));
 3784|      1|        assert!(app.is_valid_markdown_file(Path::new("test.markdown")));
 3785|      1|        assert!(app.is_valid_markdown_file(Path::new("test.mdown")));
 3786|      1|        assert!(app.is_valid_markdown_file(Path::new("test.mkd")));
 3787|      1|        assert!(app.is_valid_markdown_file(Path::new("test.txt")));
 3788|       |
 3789|       |        // Case insensitive
 3790|      1|        assert!(app.is_valid_markdown_file(Path::new("test.MD")));
 3791|      1|        assert!(app.is_valid_markdown_file(Path::new("test.Markdown")));
 3792|       |
 3793|       |        // Invalid extensions
 3794|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.pdf")));
 3795|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.docx")));
 3796|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.html")));
 3797|       |
 3798|       |        // No extension
 3799|      1|        assert!(!app.is_valid_markdown_file(Path::new("test")));
 3800|      1|    }
 3801|       |
 3802|       |    #[test]
 3803|      1|    fn test_scan_directory() -> Result<()> {
 3804|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3805|      1|        let dir_path = temp_dir.path();
 3806|       |
 3807|       |        // Create test files
 3808|      1|        std::fs::write(dir_path.join("zebra.md"), "# Z")?;
                                                                      ^0
 3809|      1|        std::fs::write(dir_path.join("alpha.md"), "# A")?;
                                                                      ^0
 3810|      1|        std::fs::write(dir_path.join("image.png"), "fake")?;
                                                                        ^0
 3811|      1|        std::fs::write(dir_path.join("beta.markdown"), "# B")?;
                                                                           ^0
 3812|       |
 3813|       |        // Create subdirectory (should be ignored)
 3814|      1|        std::fs::create_dir(dir_path.join("subdir"))?;
                                                                  ^0
 3815|      1|        std::fs::write(dir_path.join("subdir/nested.md"), "# N")?;
                                                                              ^0
 3816|       |
 3817|      1|        let app = MarkdownViewerApp::new();
 3818|      1|        let files = app.scan_directory(dir_path)?;
                                                              ^0
 3819|       |
 3820|       |        // Should find 3 markdown files (alpha, beta, zebra)
 3821|       |        // Should NOT find image.png or nested.md
 3822|      1|        assert_eq!(files.len(), 3);
 3823|       |
 3824|       |        // Should be sorted alphabetically
 3825|      1|        assert!(files[0].ends_with("alpha.md"));
 3826|      1|        assert!(files[1].ends_with("beta.markdown"));
 3827|      1|        assert!(files[2].ends_with("zebra.md"));
 3828|       |
 3829|      1|        Ok(())
 3830|      1|    }
 3831|       |
 3832|       |    #[test]
 3833|      1|    fn test_scan_empty_directory() -> Result<()> {
 3834|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3835|      1|        let app = MarkdownViewerApp::new();
 3836|      1|        let files = app.scan_directory(temp_dir.path())?;
                                                                     ^0
 3837|       |
 3838|      1|        assert_eq!(files.len(), 0);
 3839|      1|        Ok(())
 3840|      1|    }
 3841|       |
 3842|       |    #[test]
 3843|      1|    fn test_single_file_drop() -> Result<()> {
 3844|      1|        let mut app = MarkdownViewerApp::new();
 3845|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3846|      1|        let file = temp_dir.path().join("test.md");
 3847|      1|        std::fs::write(&file, "# Test")?;
                                                     ^0
 3848|       |
 3849|      1|        app.handle_file_drop(vec![file.clone()]);
 3850|       |
 3851|      1|        assert_eq!(app.current_file, Some(file));
 3852|      1|        assert!(app.pending_files.is_empty());
 3853|      1|        assert!(app.error_message.is_none());
 3854|      1|        Ok(())
 3855|      1|    }
 3856|       |
 3857|       |    #[test]
 3858|      1|    fn test_multiple_files_drop() -> Result<()> {
 3859|      1|        let mut app = MarkdownViewerApp::new();
 3860|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3861|       |
 3862|      1|        let files: Vec<PathBuf> = (0..5)
 3863|      5|            .map(|i| {
                           ^1
 3864|      5|                let path = temp_dir.path().join(format!("file{}.md", i));
 3865|      5|                std::fs::write(&path, format!("# File {}", i)).unwrap();
 3866|      5|                path
 3867|      5|            })
 3868|      1|            .collect();
 3869|       |
 3870|      1|        app.handle_file_drop(files.clone());
 3871|       |
 3872|      1|        assert_eq!(app.current_file, Some(files[0].clone()));
 3873|      1|        assert_eq!(app.pending_files.len(), 4);
 3874|      1|        Ok(())
 3875|      1|    }
 3876|       |
 3877|       |    #[test]
 3878|      1|    fn test_directory_drop() -> Result<()> {
 3879|      1|        let mut app = MarkdownViewerApp::new();
 3880|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3881|       |
 3882|       |        // Create files in directory
 3883|      1|        std::fs::write(temp_dir.path().join("a.md"), "# A")?;
                                                                         ^0
 3884|      1|        std::fs::write(temp_dir.path().join("b.md"), "# B")?;
                                                                         ^0
 3885|      1|        std::fs::write(temp_dir.path().join("c.md"), "# C")?;
                                                                         ^0
 3886|       |
 3887|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 3888|       |
 3889|      1|        assert!(app.current_file.is_some());
 3890|      1|        assert_eq!(app.pending_files.len(), 2);
 3891|      1|        Ok(())
 3892|      1|    }
 3893|       |
 3894|       |    #[test]
 3895|      1|    fn test_invalid_file_drop() {
 3896|      1|        let mut app = MarkdownViewerApp::new();
 3897|      1|        let temp_dir = tempfile::TempDir::new().unwrap();
 3898|      1|        let file = temp_dir.path().join("test.pdf");
 3899|      1|        std::fs::write(&file, "fake pdf").unwrap();
 3900|       |
 3901|      1|        app.handle_file_drop(vec![file]);
 3902|       |
 3903|       |        // Current file should remain None (or welcome sample)
 3904|      1|        assert!(app.error_message.is_some());
 3905|      1|        assert!(app
 3906|      1|            .error_message
 3907|      1|            .as_ref()
 3908|      1|            .unwrap()
 3909|      1|            .contains("Not a markdown file"));
 3910|      1|    }
 3911|       |
 3912|       |    #[test]
 3913|      1|    fn test_too_many_files() {
 3914|      1|        let mut app = MarkdownViewerApp::new();
 3915|      1|        let temp_dir = tempfile::TempDir::new().unwrap();
 3916|       |
 3917|      1|        let files: Vec<PathBuf> = (0..60)
 3918|     60|            .map(|i| {
                           ^1
 3919|     60|                let path = temp_dir.path().join(format!("file{}.md", i));
 3920|     60|                std::fs::write(&path, format!("# File {}", i)).unwrap();
 3921|     60|                path
 3922|     60|            })
 3923|      1|            .collect();
 3924|       |
 3925|      1|        app.handle_file_drop(files);
 3926|       |
 3927|      1|        assert!(app.error_message.is_some());
 3928|      1|        assert!(app
 3929|      1|            .error_message
 3930|      1|            .as_ref()
 3931|      1|            .unwrap()
 3932|      1|            .contains("Too many files"));
 3933|      1|    }
 3934|       |
 3935|       |    #[test]
 3936|      1|    fn test_queue_navigation() -> Result<()> {
 3937|      1|        let mut app = MarkdownViewerApp::new();
 3938|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3939|       |
 3940|      1|        let file1 = temp_dir.path().join("file1.md");
 3941|      1|        let file2 = temp_dir.path().join("file2.md");
 3942|       |
 3943|      1|        std::fs::write(&file1, "# File 1")?;
                                                        ^0
 3944|      1|        std::fs::write(&file2, "# File 2")?;
                                                        ^0
 3945|       |
 3946|       |        // Load first file and queue second
 3947|      1|        app.load_file(file1.clone(), true)?;
                                                        ^0
 3948|      1|        app.pending_files.push_back(file2.clone());
 3949|       |
 3950|      1|        assert!(app.can_navigate_forward());
 3951|      1|        app.navigate_forward();
 3952|      1|        assert_eq!(app.current_file, Some(file2));
 3953|      1|        assert!(app.pending_files.is_empty());
 3954|       |
 3955|      1|        Ok(())
 3956|      1|    }
 3957|       |
 3958|       |    #[test]
 3959|      1|    fn test_mixed_valid_invalid_files() -> Result<()> {
 3960|      1|        let mut app = MarkdownViewerApp::new();
 3961|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3962|       |
 3963|      1|        let md_file = temp_dir.path().join("test.md");
 3964|      1|        let pdf_file = temp_dir.path().join("test.pdf");
 3965|       |
 3966|      1|        std::fs::write(&md_file, "# Test")?;
                                                        ^0
 3967|      1|        std::fs::write(&pdf_file, "fake pdf")?;
                                                           ^0
 3968|       |
 3969|      1|        app.handle_file_drop(vec![md_file.clone(), pdf_file]);
 3970|       |
 3971|       |        // Should open the valid markdown file
 3972|      1|        assert_eq!(app.current_file, Some(md_file));
 3973|       |        // Should show error about the invalid file
 3974|      1|        assert!(app.error_message.is_some());
 3975|      1|        Ok(())
 3976|      1|    }
 3977|       |
 3978|       |    #[test]
 3979|      1|    fn test_empty_directory_drop() -> Result<()> {
 3980|      1|        let mut app = MarkdownViewerApp::new();
 3981|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3982|       |
 3983|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 3984|       |
 3985|      1|        assert!(app.error_message.is_some());
 3986|      1|        assert!(app
 3987|      1|            .error_message
 3988|      1|            .as_ref()
 3989|      1|            .unwrap()
 3990|      1|            .contains("No markdown files"));
 3991|      1|        Ok(())
 3992|      1|    }
 3993|       |
 3994|       |    #[test]
 3995|      1|    fn test_toggle_write_mode_tracks_cursor_and_focus() {
 3996|      1|        let mut app = MarkdownViewerApp::new();
 3997|      1|        app.view_mode = ViewMode::Raw;
 3998|      1|        app.write_enabled = false;
 3999|      1|        app.raw_focus_requested = false;
 4000|       |
 4001|      1|        let ctx = egui::Context::default();
 4002|      1|        let editor_id = egui::Id::new("raw_editor");
 4003|      1|        let mut state = egui::text_edit::TextEditState::default();
 4004|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(3));
 4005|      1|        state.cursor.set_char_range(Some(cr));
 4006|      1|        state.store(&ctx, editor_id);
 4007|       |
 4008|      1|        app.toggle_write_mode(&ctx);
 4009|      1|        assert!(app.write_enabled);
 4010|      1|        assert!(app.raw_focus_requested);
 4011|       |
 4012|      1|        app.toggle_write_mode(&ctx);
 4013|      1|        assert!(!app.write_enabled);
 4014|      1|        assert_eq!(app.raw_cursor, Some(3));
 4015|      1|    }
 4016|       |
 4017|       |    #[test]
 4018|      1|    fn test_find_next_and_previous_wraps() {
 4019|      1|        let mut app = MarkdownViewerApp::new();
 4020|      1|        app.load_content("Alpha\n\nBeta\n\nGamma", Some("Search".to_string()));
 4021|      1|        app.search_query = "beta".to_string();
 4022|       |
 4023|      1|        app.find_next();
 4024|      1|        assert_eq!(app.last_match_index, Some(1));
 4025|      1|        assert_eq!(app.pending_scroll_to_element, Some(1));
 4026|       |
 4027|      1|        app.find_next();
 4028|      1|        assert_eq!(app.last_match_index, Some(1));
 4029|       |
 4030|      1|        app.find_previous();
 4031|      1|        assert_eq!(app.last_match_index, Some(1));
 4032|      1|    }
 4033|       |
 4034|       |    #[test]
 4035|      1|    fn test_update_impl_rendered_view_runs() -> Result<()> {
 4036|      1|        let mut app = MarkdownViewerApp::new();
 4037|      1|        app.nav_request = Some(NavigationRequest::PageDown);
 4038|      1|        app.toggle_fullscreen = true;
 4039|       |
 4040|      1|        let mut temp_file = tempfile::Builder::new().suffix(".md").tempfile()?;
                                                                                           ^0
 4041|      1|        temp_file.write_all(b"# Dropped\nContent")?;
                                                                ^0
 4042|      1|        temp_file.flush()?;
                                       ^0
 4043|       |
 4044|      1|        let ctx = egui::Context::default();
 4045|      1|        let mut input = default_input();
 4046|      1|        let vp = input
 4047|      1|            .viewports
 4048|      1|            .get_mut(&egui::ViewportId::ROOT)
 4049|      1|            .expect("root viewport");
 4050|      1|        vp.monitor_size = Some(egui::vec2(1024.0, 768.0));
 4051|      1|        vp.outer_rect = Some(egui::Rect::from_min_size(
 4052|      1|            egui::pos2(1200.0, 900.0),
 4053|      1|            egui::vec2(800.0, 600.0),
 4054|      1|        ));
 4055|      1|        vp.inner_rect = Some(egui::Rect::from_min_size(
 4056|      1|            egui::pos2(0.0, 0.0),
 4057|      1|            egui::vec2(800.0, 600.0),
 4058|      1|        ));
 4059|      1|        vp.fullscreen = Some(false);
 4060|      1|        vp.maximized = Some(false);
 4061|      1|        input.hovered_files.push(egui::HoveredFile {
 4062|      1|            path: Some(temp_file.path().to_path_buf()),
 4063|      1|            ..Default::default()
 4064|      1|        });
 4065|      1|        input.dropped_files.push(egui::DroppedFile {
 4066|      1|            path: Some(temp_file.path().to_path_buf()),
 4067|      1|            ..Default::default()
 4068|      1|        });
 4069|       |
 4070|      1|        run_app_frame(&mut app, &ctx, input);
 4071|       |
 4072|      1|        assert!(app.drag_hover);
 4073|      1|        assert!(app.current_file.is_some());
 4074|      1|        assert!(app.last_window_pos.is_some());
 4075|      1|        assert!(app.last_window_size.is_some());
 4076|      1|        Ok(())
 4077|      1|    }
 4078|       |
 4079|       |    #[test]
 4080|      1|    fn test_update_impl_applies_size_adjustment() {
 4081|      1|        let mut app = MarkdownViewerApp::new();
 4082|      1|        let ctx = egui::Context::default();
 4083|      1|        let mut input = default_input();
 4084|      1|        let vp = input
 4085|      1|            .viewports
 4086|      1|            .get_mut(&egui::ViewportId::ROOT)
 4087|      1|            .expect("root viewport");
 4088|      1|        vp.monitor_size = Some(egui::vec2(800.0, 600.0));
 4089|      1|        vp.outer_rect = Some(egui::Rect::from_min_size(
 4090|      1|            egui::pos2(10.0, 10.0),
 4091|      1|            egui::vec2(800.0, 600.0),
 4092|      1|        ));
 4093|      1|        vp.inner_rect = Some(egui::Rect::from_min_size(
 4094|      1|            egui::pos2(0.0, 0.0),
 4095|      1|            egui::vec2(200.0, 100.0),
 4096|      1|        ));
 4097|      1|        vp.fullscreen = Some(false);
 4098|      1|        vp.maximized = Some(false);
 4099|       |
 4100|      1|        run_app_frame(&mut app, &ctx, input);
 4101|       |
 4102|      1|        assert!(app.last_window_size.is_some());
 4103|      1|        assert!(app.last_window_pos.is_some());
 4104|      1|    }
 4105|       |
 4106|       |    #[test]
 4107|      1|    fn test_update_impl_applies_deferred_toggles() {
 4108|      1|        let mut app = MarkdownViewerApp::new();
 4109|      1|        app.view_toggle_requested = true;
 4110|      1|        app.write_toggle_requested = true;
 4111|       |
 4112|      1|        let ctx = egui::Context::default();
 4113|      1|        run_app_frame(&mut app, &ctx, default_input());
 4114|       |
 4115|      1|        assert_eq!(app.view_mode, ViewMode::Raw);
 4116|      1|        assert!(app.write_enabled);
 4117|      1|    }
 4118|       |
 4119|       |    #[test]
 4120|      1|    fn test_update_impl_reload_without_file_sets_error() {
 4121|      1|        let mut app = MarkdownViewerApp::new();
 4122|      1|        app.reload_requested = true;
 4123|       |
 4124|      1|        let ctx = egui::Context::default();
 4125|      1|        let input = default_input();
 4126|      1|        run_app_frame(&mut app, &ctx, input);
 4127|       |
 4128|      1|        assert!(app.error_message.is_some());
 4129|      1|    }
 4130|       |
 4131|       |    #[test]
 4132|      1|    fn test_update_impl_raw_read_only_renders() {
 4133|      1|        let mut app = MarkdownViewerApp::new();
 4134|      1|        app.view_mode = ViewMode::Raw;
 4135|      1|        app.write_enabled = false;
 4136|      1|        app.raw_buffer = "Line 1\nLine 2".to_string();
 4137|      1|        app.current_content = app.raw_buffer.clone();
 4138|       |
 4139|      1|        let ctx = egui::Context::default();
 4140|      1|        let input = default_input();
 4141|      1|        run_app_frame(&mut app, &ctx, input);
 4142|       |
 4143|      1|        assert_eq!(app.raw_buffer, "Line 1\nLine 2");
 4144|      1|    }
 4145|       |
 4146|       |    #[test]
 4147|      1|    fn test_update_impl_moves_raw_cursor() {
 4148|      1|        let mut app = MarkdownViewerApp::new();
 4149|      1|        app.view_mode = ViewMode::Raw;
 4150|      1|        app.write_enabled = true;
 4151|      1|        app.raw_buffer = "Line 1\nLine 2\nLine 3".to_string();
 4152|      1|        app.current_content = app.raw_buffer.clone();
 4153|      1|        app.pending_raw_cursor_line_move = Some(1);
 4154|       |
 4155|      1|        let ctx = egui::Context::default();
 4156|      1|        let editor_id = egui::Id::new("raw_editor");
 4157|      1|        let mut state = egui::text_edit::TextEditState::default();
 4158|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 4159|      1|        state.cursor.set_char_range(Some(cr));
 4160|      1|        state.store(&ctx, editor_id);
 4161|       |
 4162|      1|        let input = default_input();
 4163|      1|        run_app_frame(&mut app, &ctx, input);
 4164|       |
 4165|      1|        assert!(app.raw_cursor.unwrap_or(0) > 0);
 4166|      1|    }
 4167|       |
 4168|       |    #[test]
 4169|      1|    fn test_json_helpers_escape_and_opt() {
 4170|      1|        assert_eq!(
 4171|      1|            MarkdownViewerApp::json_escape("a\"b\\c\n\t\r"),
 4172|       |            "a\\\"b\\\\c\\n\\t\\r"
 4173|       |        );
 4174|      1|        assert_eq!(MarkdownViewerApp::json_opt_f32(Some(1.23456)), "1.235");
 4175|      1|        assert_eq!(MarkdownViewerApp::json_opt_f32(None), "null");
 4176|      1|    }
 4177|       |
 4178|       |    #[test]
 4179|      1|    fn test_color_image_to_rgba_falls_back_on_invalid_buffer() {
 4180|      1|        let image = egui::ColorImage {
 4181|      1|            size: [1, 1],
 4182|      1|            pixels: Vec::new(),
 4183|      1|        };
 4184|      1|        let rgba = MarkdownViewerApp::color_image_to_rgba(&image);
 4185|      1|        assert_eq!(rgba.width(), 1);
 4186|      1|        assert_eq!(rgba.height(), 1);
 4187|      1|    }
 4188|       |
 4189|       |    #[test]
 4190|      1|    fn test_save_screenshot_image_crops_and_writes_metadata() -> Result<()> {
 4191|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 4192|      1|        let output_path = temp_dir.path().join("shot.png");
 4193|      1|        let config = ScreenshotConfig {
 4194|      1|            output_path: output_path.clone(),
 4195|      1|            viewport_width: 80.0,
 4196|      1|            viewport_height: 60.0,
 4197|      1|            content_only: true,
 4198|      1|            scroll_ratio: Some(0.5),
 4199|      1|            wait_ms: 0,
 4200|      1|            settle_frames: 0,
 4201|      1|            zoom: 1.0,
 4202|      1|            theme: ScreenshotTheme::Light,
 4203|      1|            font_source: Some("TestFont".to_string()),
 4204|      1|        };
 4205|      1|        let snapshot = ScreenshotSnapshot {
 4206|      1|            config,
 4207|      1|            content_rect: Some(egui::Rect::from_min_size(
 4208|      1|                egui::pos2(10.0, 5.0),
 4209|      1|                egui::vec2(20.0, 10.0),
 4210|      1|            )),
 4211|      1|            pixels_per_point: 1.0,
 4212|      1|            stable_frames: 3,
 4213|      1|            timed_out: false,
 4214|      1|            pending_renders: false,
 4215|      1|            last_scroll_offset: Some(12.0),
 4216|      1|            started: Instant::now(),
 4217|      1|        };
 4218|       |
 4219|      1|        let mut image = egui::ColorImage::new([80, 60], Color32::BLACK);
 4220|      1|        image.pixels[0] = Color32::from_rgb(10, 20, 30);
 4221|       |
 4222|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
                                                                                 ^0
 4223|       |
 4224|      1|        let saved = image::open(&output_path)?;
                                                           ^0
 4225|      1|        assert_eq!(saved.width(), 20);
 4226|      1|        assert_eq!(saved.height(), 10);
 4227|       |
 4228|      1|        let metadata = std::fs::read_to_string(output_path.with_extension("json"))?;
                                                                                                ^0
 4229|      1|        assert!(metadata.contains("\"content_only\": true"));
 4230|      1|        assert!(metadata.contains("\"font_source\": \"TestFont\""));
 4231|      1|        Ok(())
 4232|      1|    }
 4233|       |
 4234|       |    #[test]
 4235|      1|    fn test_update_screenshot_state_requests_and_scrolls() {
 4236|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 4237|      1|        let config = ScreenshotConfig {
 4238|      1|            output_path: temp_dir.path().join("shot.png"),
 4239|      1|            viewport_width: 100.0,
 4240|      1|            viewport_height: 80.0,
 4241|      1|            content_only: false,
 4242|      1|            scroll_ratio: Some(0.5),
 4243|      1|            wait_ms: 0,
 4244|      1|            settle_frames: 0,
 4245|      1|            zoom: 1.0,
 4246|      1|            theme: ScreenshotTheme::Dark,
 4247|      1|            font_source: None,
 4248|      1|        };
 4249|       |
 4250|      1|        let mut app = MarkdownViewerApp::new();
 4251|      1|        app.set_screenshot_mode(config);
 4252|       |
 4253|      1|        let ctx = egui::Context::default();
 4254|      1|        let snapshot = ScrollSnapshot {
 4255|      1|            content_size: egui::vec2(100.0, 200.0),
 4256|      1|            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(100.0, 100.0)),
 4257|      1|            offset_y: 0.0,
 4258|      1|        };
 4259|      1|        app.update_screenshot_state(&ctx, Some(1), Some(snapshot));
 4260|       |
 4261|      1|        let target_offset = app
 4262|      1|            .screenshot
 4263|      1|            .as_ref()
 4264|      1|            .and_then(|state| state.scroll_offset)
 4265|      1|            .unwrap_or(0.0);
 4266|      1|        let snapshot_ready = ScrollSnapshot {
 4267|      1|            content_size: egui::vec2(100.0, 200.0),
 4268|      1|            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(100.0, 100.0)),
 4269|      1|            offset_y: target_offset,
 4270|      1|        };
 4271|      1|        app.update_screenshot_state(&ctx, Some(1), Some(snapshot_ready));
 4272|       |
 4273|      1|        let state = app.screenshot.as_ref().expect("screenshot state");
 4274|      1|        assert!(state.viewport_adjusted);
 4275|      1|        assert!(state.requested);
 4276|      1|        assert!(state.scroll_ready());
 4277|      1|    }
 4278|       |
 4279|       |    #[test]
 4280|      1|    fn test_update_screenshot_state_stable_without_timeout() {
 4281|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 4282|      1|        let config = ScreenshotConfig {
 4283|      1|            output_path: temp_dir.path().join("shot.png"),
 4284|      1|            viewport_width: 120.0,
 4285|      1|            viewport_height: 80.0,
 4286|      1|            content_only: false,
 4287|      1|            scroll_ratio: None,
 4288|      1|            wait_ms: 10_000,
 4289|      1|            settle_frames: 0,
 4290|      1|            zoom: 1.0,
 4291|      1|            theme: ScreenshotTheme::Light,
 4292|      1|            font_source: None,
 4293|      1|        };
 4294|      1|        let mut app = MarkdownViewerApp::new();
 4295|      1|        app.screenshot = Some(ScreenshotState::new(config));
 4296|       |
 4297|      1|        let ctx = egui::Context::default();
 4298|      1|        app.update_screenshot_state(&ctx, Some(1), None);
 4299|       |
 4300|      1|        let state = app.screenshot.as_ref().expect("screenshot state");
 4301|      1|        assert!(state.requested);
 4302|      1|        assert!(!state.timed_out);
 4303|      1|    }
 4304|       |
 4305|       |    #[test]
 4306|      1|    fn test_update_screenshot_state_times_out_before_stable() {
 4307|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 4308|      1|        let config = ScreenshotConfig {
 4309|      1|            output_path: temp_dir.path().join("shot.png"),
 4310|      1|            viewport_width: 120.0,
 4311|      1|            viewport_height: 80.0,
 4312|      1|            content_only: false,
 4313|      1|            scroll_ratio: Some(0.5),
 4314|      1|            wait_ms: 0,
 4315|      1|            settle_frames: 5,
 4316|      1|            zoom: 1.0,
 4317|      1|            theme: ScreenshotTheme::Light,
 4318|      1|            font_source: None,
 4319|      1|        };
 4320|      1|        let mut app = MarkdownViewerApp::new();
 4321|      1|        app.screenshot = Some(ScreenshotState::new(config));
 4322|       |
 4323|      1|        let ctx = egui::Context::default();
 4324|      1|        app.update_screenshot_state(&ctx, None, None);
 4325|       |
 4326|      1|        let state = app.screenshot.as_ref().expect("screenshot state");
 4327|      1|        assert!(state.timed_out);
 4328|      1|    }
 4329|       |
 4330|       |    #[test]
 4331|      1|    fn test_save_persists_window_state_when_no_screenshot() {
 4332|      1|        let _lock = env_lock();
 4333|      1|        let temp_dir = TempDir::new().expect("temp dir");
 4334|      1|        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());
 4335|       |
 4336|      1|        let mut app = MarkdownViewerApp::new();
 4337|      1|        app.last_window_pos = Some([10.0, 20.0]);
 4338|      1|        app.last_window_size = Some([800.0, 600.0]);
 4339|      1|        let mut storage = DummyStorage::default();
 4340|      1|        app.save(&mut storage);
 4341|       |
 4342|      1|        let path = temp_dir
 4343|      1|            .path()
 4344|      1|            .join("MarkdownView")
 4345|      1|            .join("window_state.txt");
 4346|      1|        assert!(path.exists());
 4347|      1|    }
 4348|       |
 4349|       |    #[test]
 4350|      1|    fn test_save_skips_persist_when_screenshot_active() {
 4351|      1|        let _lock = env_lock();
 4352|      1|        let temp_dir = TempDir::new().expect("temp dir");
 4353|      1|        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());
 4354|       |
 4355|      1|        let mut app = MarkdownViewerApp::new();
 4356|      1|        let config = ScreenshotConfig {
 4357|      1|            output_path: temp_dir.path().join("shot.png"),
 4358|      1|            viewport_width: 10.0,
 4359|      1|            viewport_height: 10.0,
 4360|      1|            content_only: false,
 4361|      1|            scroll_ratio: None,
 4362|      1|            wait_ms: 0,
 4363|      1|            settle_frames: 0,
 4364|      1|            zoom: 1.0,
 4365|      1|            theme: ScreenshotTheme::Light,
 4366|      1|            font_source: None,
 4367|      1|        };
 4368|      1|        app.set_screenshot_mode(config);
 4369|      1|        let mut storage = DummyStorage::default();
 4370|      1|        app.save(&mut storage);
 4371|       |
 4372|      1|        let path = temp_dir
 4373|      1|            .path()
 4374|      1|            .join("MarkdownView")
 4375|      1|            .join("window_state.txt");
 4376|      1|        assert!(!path.exists());
 4377|      1|    }
 4378|       |
 4379|       |    #[test]
 4380|      1|    fn test_save_screenshot_image_crops_content_rect() -> Result<()> {
 4381|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 4382|      1|        let output_path = temp_dir.path().join("shot.png");
 4383|      1|        let config = ScreenshotConfig {
 4384|      1|            output_path: output_path.clone(),
 4385|      1|            viewport_width: 100.0,
 4386|      1|            viewport_height: 80.0,
 4387|      1|            content_only: true,
 4388|      1|            scroll_ratio: None,
 4389|      1|            wait_ms: 0,
 4390|      1|            settle_frames: 0,
 4391|      1|            zoom: 1.0,
 4392|      1|            theme: ScreenshotTheme::Dark,
 4393|      1|            font_source: None,
 4394|      1|        };
 4395|      1|        let snapshot = ScreenshotSnapshot {
 4396|      1|            config,
 4397|      1|            content_rect: Some(egui::Rect::from_min_max(
 4398|      1|                egui::pos2(2.0, 2.0),
 4399|      1|                egui::pos2(8.0, 8.0),
 4400|      1|            )),
 4401|      1|            pixels_per_point: 1.0,
 4402|      1|            stable_frames: 0,
 4403|      1|            timed_out: false,
 4404|      1|            pending_renders: false,
 4405|      1|            last_scroll_offset: None,
 4406|      1|            started: std::time::Instant::now(),
 4407|      1|        };
 4408|      1|        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4409|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
                                                                                 ^0
 4410|      1|        assert!(output_path.exists());
 4411|      1|        assert!(output_path.with_extension("json").exists());
 4412|      1|        Ok(())
 4413|      1|    }
 4414|       |
 4415|       |    #[test]
 4416|      1|    fn test_save_screenshot_image_no_crop() -> Result<()> {
 4417|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 4418|      1|        let output_path = temp_dir.path().join("shot.png");
 4419|      1|        let config = ScreenshotConfig {
 4420|      1|            output_path: output_path.clone(),
 4421|      1|            viewport_width: 100.0,
 4422|      1|            viewport_height: 80.0,
 4423|      1|            content_only: false,
 4424|      1|            scroll_ratio: None,
 4425|      1|            wait_ms: 0,
 4426|      1|            settle_frames: 0,
 4427|      1|            zoom: 1.0,
 4428|      1|            theme: ScreenshotTheme::Light,
 4429|      1|            font_source: None,
 4430|      1|        };
 4431|      1|        let snapshot = ScreenshotSnapshot {
 4432|      1|            config,
 4433|      1|            content_rect: None,
 4434|      1|            pixels_per_point: 1.0,
 4435|      1|            stable_frames: 0,
 4436|      1|            timed_out: false,
 4437|      1|            pending_renders: false,
 4438|      1|            last_scroll_offset: None,
 4439|      1|            started: std::time::Instant::now(),
 4440|      1|        };
 4441|      1|        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4442|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
                                                                                 ^0
 4443|      1|        assert!(output_path.exists());
 4444|      1|        Ok(())
 4445|      1|    }
 4446|       |
 4447|       |    #[test]
 4448|      1|    fn test_save_screenshot_image_zero_content_rect_ignored() -> Result<()> {
 4449|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 4450|      1|        let output_path = temp_dir.path().join("shot.png");
 4451|      1|        let config = ScreenshotConfig {
 4452|      1|            output_path: output_path.clone(),
 4453|      1|            viewport_width: 100.0,
 4454|      1|            viewport_height: 80.0,
 4455|      1|            content_only: true,
 4456|      1|            scroll_ratio: None,
 4457|      1|            wait_ms: 0,
 4458|      1|            settle_frames: 0,
 4459|      1|            zoom: 1.0,
 4460|      1|            theme: ScreenshotTheme::Dark,
 4461|      1|            font_source: None,
 4462|      1|        };
 4463|      1|        let snapshot = ScreenshotSnapshot {
 4464|      1|            config,
 4465|      1|            content_rect: Some(egui::Rect::from_min_max(
 4466|      1|                egui::pos2(5.0, 5.0),
 4467|      1|                egui::pos2(5.0, 5.0),
 4468|      1|            )),
 4469|      1|            pixels_per_point: 1.0,
 4470|      1|            stable_frames: 0,
 4471|      1|            timed_out: false,
 4472|      1|            pending_renders: false,
 4473|      1|            last_scroll_offset: None,
 4474|      1|            started: std::time::Instant::now(),
 4475|      1|        };
 4476|      1|        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4477|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
                                                                                 ^0
 4478|      1|        let saved = image::open(&output_path)?;
                                                           ^0
 4479|      1|        assert_eq!(saved.width(), 10);
 4480|      1|        assert_eq!(saved.height(), 10);
 4481|      1|        Ok(())
 4482|      1|    }
 4483|       |
 4484|       |    #[test]
 4485|      1|    fn test_save_screenshot_image_content_only_without_rect() -> Result<()> {
 4486|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 4487|      1|        let output_path = temp_dir.path().join("shot.png");
 4488|      1|        let config = ScreenshotConfig {
 4489|      1|            output_path: output_path.clone(),
 4490|      1|            viewport_width: 100.0,
 4491|      1|            viewport_height: 80.0,
 4492|      1|            content_only: true,
 4493|      1|            scroll_ratio: None,
 4494|      1|            wait_ms: 0,
 4495|      1|            settle_frames: 0,
 4496|      1|            zoom: 1.0,
 4497|      1|            theme: ScreenshotTheme::Light,
 4498|      1|            font_source: None,
 4499|      1|        };
 4500|      1|        let snapshot = ScreenshotSnapshot {
 4501|      1|            config,
 4502|      1|            content_rect: None,
 4503|      1|            pixels_per_point: 1.0,
 4504|      1|            stable_frames: 0,
 4505|      1|            timed_out: false,
 4506|      1|            pending_renders: false,
 4507|      1|            last_scroll_offset: None,
 4508|      1|            started: std::time::Instant::now(),
 4509|      1|        };
 4510|      1|        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4511|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
                                                                                 ^0
 4512|      1|        assert!(output_path.exists());
 4513|      1|        Ok(())
 4514|      1|    }
 4515|       |
 4516|       |    #[test]
 4517|      1|    fn test_save_screenshot_image_height_zero_skips_crop() -> Result<()> {
 4518|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 4519|      1|        let output_path = temp_dir.path().join("shot.png");
 4520|      1|        let config = ScreenshotConfig {
 4521|      1|            output_path: output_path.clone(),
 4522|      1|            viewport_width: 100.0,
 4523|      1|            viewport_height: 80.0,
 4524|      1|            content_only: true,
 4525|      1|            scroll_ratio: None,
 4526|      1|            wait_ms: 0,
 4527|      1|            settle_frames: 0,
 4528|      1|            zoom: 1.0,
 4529|      1|            theme: ScreenshotTheme::Light,
 4530|      1|            font_source: None,
 4531|      1|        };
 4532|      1|        let snapshot = ScreenshotSnapshot {
 4533|      1|            config,
 4534|      1|            content_rect: Some(egui::Rect::from_min_max(
 4535|      1|                egui::pos2(2.0, 2.0),
 4536|      1|                egui::pos2(8.0, 2.0),
 4537|      1|            )),
 4538|      1|            pixels_per_point: 1.0,
 4539|      1|            stable_frames: 0,
 4540|      1|            timed_out: false,
 4541|      1|            pending_renders: false,
 4542|      1|            last_scroll_offset: None,
 4543|      1|            started: std::time::Instant::now(),
 4544|      1|        };
 4545|      1|        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4546|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
                                                                                 ^0
 4547|      1|        let saved = image::open(&output_path)?;
                                                           ^0
 4548|      1|        assert_eq!(saved.width(), 10);
 4549|      1|        assert_eq!(saved.height(), 10);
 4550|      1|        Ok(())
 4551|      1|    }
 4552|       |
 4553|       |    #[test]
 4554|      1|    fn test_save_screenshot_image_empty_output_path_errors() {
 4555|      1|        let config = ScreenshotConfig {
 4556|      1|            output_path: PathBuf::new(),
 4557|      1|            viewport_width: 100.0,
 4558|      1|            viewport_height: 80.0,
 4559|      1|            content_only: false,
 4560|      1|            scroll_ratio: None,
 4561|      1|            wait_ms: 0,
 4562|      1|            settle_frames: 0,
 4563|      1|            zoom: 1.0,
 4564|      1|            theme: ScreenshotTheme::Light,
 4565|      1|            font_source: None,
 4566|      1|        };
 4567|      1|        let snapshot = ScreenshotSnapshot {
 4568|      1|            config,
 4569|      1|            content_rect: None,
 4570|      1|            pixels_per_point: 1.0,
 4571|      1|            stable_frames: 0,
 4572|      1|            timed_out: false,
 4573|      1|            pending_renders: false,
 4574|      1|            last_scroll_offset: None,
 4575|      1|            started: std::time::Instant::now(),
 4576|      1|        };
 4577|      1|        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4578|      1|        assert!(MarkdownViewerApp::save_screenshot_image(&image, &snapshot).is_err());
 4579|      1|    }
 4580|       |
 4581|       |    #[test]
 4582|      1|    fn test_save_screenshot_image_crop_condition_variants() -> Result<()> {
 4583|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 4584|      1|        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4585|       |
 4586|      1|        let make_config = |name: &str| ScreenshotConfig {
 4587|      3|            output_path: temp_dir.path().join(name),
 4588|       |            viewport_width: 100.0,
 4589|       |            viewport_height: 80.0,
 4590|       |            content_only: true,
 4591|      3|            scroll_ratio: None,
 4592|       |            wait_ms: 0,
 4593|       |            settle_frames: 0,
 4594|       |            zoom: 1.0,
 4595|      3|            theme: ScreenshotTheme::Light,
 4596|      3|            font_source: None,
 4597|      3|        };
 4598|       |
 4599|      1|        let snapshot_y = ScreenshotSnapshot {
 4600|      1|            config: make_config("shot_y.png"),
 4601|      1|            content_rect: Some(egui::Rect::from_min_max(
 4602|      1|                egui::pos2(0.0, 2.0),
 4603|      1|                egui::pos2(10.0, 9.0),
 4604|      1|            )),
 4605|      1|            pixels_per_point: 1.0,
 4606|      1|            stable_frames: 0,
 4607|      1|            timed_out: false,
 4608|      1|            pending_renders: false,
 4609|      1|            last_scroll_offset: None,
 4610|      1|            started: std::time::Instant::now(),
 4611|      1|        };
 4612|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot_y)?;
                                                                                   ^0
 4613|       |
 4614|      1|        let snapshot_w = ScreenshotSnapshot {
 4615|      1|            config: make_config("shot_w.png"),
 4616|      1|            content_rect: Some(egui::Rect::from_min_max(
 4617|      1|                egui::pos2(0.0, 0.0),
 4618|      1|                egui::pos2(6.0, 10.0),
 4619|      1|            )),
 4620|      1|            pixels_per_point: 1.0,
 4621|      1|            stable_frames: 0,
 4622|      1|            timed_out: false,
 4623|      1|            pending_renders: false,
 4624|      1|            last_scroll_offset: None,
 4625|      1|            started: std::time::Instant::now(),
 4626|      1|        };
 4627|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot_w)?;
                                                                                   ^0
 4628|       |
 4629|      1|        let snapshot_h = ScreenshotSnapshot {
 4630|      1|            config: make_config("shot_h.png"),
 4631|      1|            content_rect: Some(egui::Rect::from_min_max(
 4632|      1|                egui::pos2(0.0, 0.0),
 4633|      1|                egui::pos2(10.0, 6.0),
 4634|      1|            )),
 4635|      1|            pixels_per_point: 1.0,
 4636|      1|            stable_frames: 0,
 4637|      1|            timed_out: false,
 4638|      1|            pending_renders: false,
 4639|      1|            last_scroll_offset: None,
 4640|      1|            started: std::time::Instant::now(),
 4641|      1|        };
 4642|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot_h)?;
                                                                                   ^0
 4643|       |
 4644|      1|        assert!(temp_dir.path().join("shot_y.png").exists());
 4645|      1|        assert!(temp_dir.path().join("shot_w.png").exists());
 4646|      1|        assert!(temp_dir.path().join("shot_h.png").exists());
 4647|      1|        Ok(())
 4648|      1|    }
 4649|       |
 4650|       |    #[test]
 4651|      1|    fn test_handle_screenshot_event_saves_file() -> Result<()> {
 4652|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 4653|      1|        let output_path = temp_dir.path().join("shot.png");
 4654|      1|        let config = ScreenshotConfig {
 4655|      1|            output_path: output_path.clone(),
 4656|      1|            viewport_width: 40.0,
 4657|      1|            viewport_height: 30.0,
 4658|      1|            content_only: false,
 4659|      1|            scroll_ratio: None,
 4660|      1|            wait_ms: 0,
 4661|      1|            settle_frames: 0,
 4662|      1|            zoom: 1.0,
 4663|      1|            theme: ScreenshotTheme::Light,
 4664|      1|            font_source: None,
 4665|      1|        };
 4666|       |
 4667|      1|        let mut app = MarkdownViewerApp::new();
 4668|      1|        app.set_screenshot_mode(config);
 4669|       |
 4670|      1|        let mut input = default_input();
 4671|      1|        let image = egui::ColorImage::new([40, 30], Color32::WHITE);
 4672|      1|        input.events.push(egui::Event::Screenshot {
 4673|      1|            viewport_id: egui::ViewportId::ROOT,
 4674|      1|            image: Arc::new(image),
 4675|      1|        });
 4676|       |
 4677|      1|        let ctx = egui::Context::default();
 4678|      1|        run_app_frame(&mut app, &ctx, input);
 4679|       |
 4680|      1|        assert!(output_path.exists());
 4681|      1|        assert!(output_path.with_extension("json").exists());
 4682|      1|        assert!(app.screenshot.as_ref().is_some_and(|state| state.done));
 4683|      1|        Ok(())
 4684|      1|    }
 4685|       |
 4686|       |    #[test]
 4687|      1|    fn test_handle_shortcuts_sets_flags() {
 4688|      1|        let mut app = MarkdownViewerApp::new();
 4689|      1|        app.load_content("Alpha\n\nBeta\n\nGamma", Some("Search".to_string()));
 4690|      1|        app.search_query = "beta".to_string();
 4691|      1|        app.current_file = Some(PathBuf::from("dummy.md"));
 4692|       |
 4693|      1|        let mut input = default_input();
 4694|      1|        input.events.extend([
 4695|      1|            egui::Event::Key {
 4696|      1|                key: egui::Key::F,
 4697|      1|                physical_key: None,
 4698|      1|                pressed: true,
 4699|      1|                repeat: false,
 4700|      1|                modifiers: egui::Modifiers::CTRL,
 4701|      1|            },
 4702|      1|            egui::Event::Key {
 4703|      1|                key: egui::Key::R,
 4704|      1|                physical_key: None,
 4705|      1|                pressed: true,
 4706|      1|                repeat: false,
 4707|      1|                modifiers: egui::Modifiers::CTRL,
 4708|      1|            },
 4709|      1|            egui::Event::Key {
 4710|      1|                key: egui::Key::E,
 4711|      1|                physical_key: None,
 4712|      1|                pressed: true,
 4713|      1|                repeat: false,
 4714|      1|                modifiers: egui::Modifiers::CTRL,
 4715|      1|            },
 4716|      1|            egui::Event::Key {
 4717|      1|                key: egui::Key::Plus,
 4718|      1|                physical_key: None,
 4719|      1|                pressed: true,
 4720|      1|                repeat: false,
 4721|      1|                modifiers: egui::Modifiers::CTRL,
 4722|      1|            },
 4723|      1|            egui::Event::Key {
 4724|      1|                key: egui::Key::Minus,
 4725|      1|                physical_key: None,
 4726|      1|                pressed: true,
 4727|      1|                repeat: false,
 4728|      1|                modifiers: egui::Modifiers::CTRL,
 4729|      1|            },
 4730|      1|            egui::Event::Key {
 4731|      1|                key: egui::Key::Num0,
 4732|      1|                physical_key: None,
 4733|      1|                pressed: true,
 4734|      1|                repeat: false,
 4735|      1|                modifiers: egui::Modifiers::CTRL,
 4736|      1|            },
 4737|      1|            egui::Event::Key {
 4738|      1|                key: egui::Key::ArrowLeft,
 4739|      1|                physical_key: None,
 4740|      1|                pressed: true,
 4741|      1|                repeat: false,
 4742|      1|                modifiers: egui::Modifiers::ALT,
 4743|      1|            },
 4744|      1|            egui::Event::Key {
 4745|      1|                key: egui::Key::ArrowRight,
 4746|      1|                physical_key: None,
 4747|      1|                pressed: true,
 4748|      1|                repeat: false,
 4749|      1|                modifiers: egui::Modifiers::ALT,
 4750|      1|            },
 4751|      1|            egui::Event::Key {
 4752|      1|                key: egui::Key::F3,
 4753|      1|                physical_key: None,
 4754|      1|                pressed: true,
 4755|      1|                repeat: false,
 4756|      1|                modifiers: egui::Modifiers::NONE,
 4757|      1|            },
 4758|      1|            egui::Event::Key {
 4759|      1|                key: egui::Key::F3,
 4760|      1|                physical_key: None,
 4761|      1|                pressed: true,
 4762|      1|                repeat: false,
 4763|      1|                modifiers: egui::Modifiers::SHIFT,
 4764|      1|            },
 4765|      1|            egui::Event::Key {
 4766|      1|                key: egui::Key::F11,
 4767|      1|                physical_key: None,
 4768|      1|                pressed: true,
 4769|      1|                repeat: false,
 4770|      1|                modifiers: egui::Modifiers::NONE,
 4771|      1|            },
 4772|      1|            egui::Event::Key {
 4773|      1|                key: egui::Key::F5,
 4774|      1|                physical_key: None,
 4775|      1|                pressed: true,
 4776|      1|                repeat: false,
 4777|      1|                modifiers: egui::Modifiers::NONE,
 4778|      1|            },
 4779|      1|        ]);
 4780|       |
 4781|      1|        let ctx = egui::Context::default();
 4782|      1|        let _ = ctx.run(input, |ctx| {
 4783|      1|            app.handle_shortcuts(ctx);
 4784|      1|        });
 4785|       |
 4786|      1|        assert!(app.show_search);
 4787|      1|        assert!(app.search_focus_requested);
 4788|      1|        assert!(app.view_toggle_requested);
 4789|      1|        assert!(app.write_toggle_requested);
 4790|      1|        assert!(app.toggle_fullscreen);
 4791|      1|        assert!(app.reload_requested);
 4792|      1|        assert!(app.last_match_index.is_some());
 4793|      1|    }
 4794|       |
 4795|       |    #[test]
 4796|      1|    fn test_handle_shortcuts_navigation_keys() {
 4797|      1|        let mut app = MarkdownViewerApp::new();
 4798|      1|        let ctx = egui::Context::default();
 4799|       |
 4800|      1|        let mut input = default_input();
 4801|      1|        input.events.push(egui::Event::Key {
 4802|      1|            key: egui::Key::PageUp,
 4803|      1|            physical_key: None,
 4804|      1|            pressed: true,
 4805|      1|            repeat: false,
 4806|      1|            modifiers: egui::Modifiers::NONE,
 4807|      1|        });
 4808|      1|        let _ = ctx.run(input, |ctx| {
 4809|      1|            app.handle_shortcuts(ctx);
 4810|      1|        });
 4811|      1|        assert!(matches!(app.nav_request, Some(NavigationRequest::PageUp)));
                              ^0
 4812|       |
 4813|      1|        app.nav_request = None;
 4814|      1|        let mut input = default_input();
 4815|      1|        input.events.push(egui::Event::Key {
 4816|      1|            key: egui::Key::PageDown,
 4817|      1|            physical_key: None,
 4818|      1|            pressed: true,
 4819|      1|            repeat: false,
 4820|      1|            modifiers: egui::Modifiers::NONE,
 4821|      1|        });
 4822|      1|        let _ = ctx.run(input, |ctx| {
 4823|      1|            app.handle_shortcuts(ctx);
 4824|      1|        });
 4825|      1|        assert!(matches!(app.nav_request, Some(NavigationRequest::PageDown)));
                              ^0
 4826|       |
 4827|      1|        app.nav_request = None;
 4828|      1|        let mut input = default_input();
 4829|      1|        input.events.push(egui::Event::Key {
 4830|      1|            key: egui::Key::Home,
 4831|      1|            physical_key: None,
 4832|      1|            pressed: true,
 4833|      1|            repeat: false,
 4834|      1|            modifiers: egui::Modifiers::NONE,
 4835|      1|        });
 4836|      1|        let _ = ctx.run(input, |ctx| {
 4837|      1|            app.handle_shortcuts(ctx);
 4838|      1|        });
 4839|      1|        assert!(matches!(app.nav_request, Some(NavigationRequest::Top)));
                              ^0
 4840|       |
 4841|      1|        app.nav_request = None;
 4842|      1|        let mut input = default_input();
 4843|      1|        input.events.push(egui::Event::Key {
 4844|      1|            key: egui::Key::End,
 4845|      1|            physical_key: None,
 4846|      1|            pressed: true,
 4847|      1|            repeat: false,
 4848|      1|            modifiers: egui::Modifiers::NONE,
 4849|      1|        });
 4850|      1|        let _ = ctx.run(input, |ctx| {
 4851|      1|            app.handle_shortcuts(ctx);
 4852|      1|        });
 4853|      1|        assert!(matches!(app.nav_request, Some(NavigationRequest::Bottom)));
                              ^0
 4854|       |
 4855|      1|        app.nav_request = None;
 4856|      1|        let mut input = default_input();
 4857|      1|        input.events.push(egui::Event::Key {
 4858|      1|            key: egui::Key::ArrowUp,
 4859|      1|            physical_key: None,
 4860|      1|            pressed: true,
 4861|      1|            repeat: false,
 4862|      1|            modifiers: egui::Modifiers::NONE,
 4863|      1|        });
 4864|      1|        let _ = ctx.run(input, |ctx| {
 4865|      1|            app.handle_shortcuts(ctx);
 4866|      1|        });
 4867|      1|        assert!(matches!(app.nav_request, Some(NavigationRequest::ScrollUp)));
                              ^0
 4868|       |
 4869|      1|        app.nav_request = None;
 4870|      1|        let mut input = default_input();
 4871|      1|        input.events.push(egui::Event::Key {
 4872|      1|            key: egui::Key::ArrowDown,
 4873|      1|            physical_key: None,
 4874|      1|            pressed: true,
 4875|      1|            repeat: false,
 4876|      1|            modifiers: egui::Modifiers::NONE,
 4877|      1|        });
 4878|      1|        let _ = ctx.run(input, |ctx| {
 4879|      1|            app.handle_shortcuts(ctx);
 4880|      1|        });
 4881|      1|        assert!(matches!(
                              ^0
 4882|      1|            app.nav_request,
 4883|       |            Some(NavigationRequest::ScrollDown)
 4884|       |        ));
 4885|      1|    }
 4886|       |
 4887|       |    #[test]
 4888|      1|    fn test_handle_shortcuts_escape_clears_search() {
 4889|      1|        let mut app = MarkdownViewerApp::new();
 4890|      1|        app.show_search = true;
 4891|      1|        app.search_query = "alpha".to_string();
 4892|      1|        app.last_query = "alpha".to_string();
 4893|      1|        app.last_match_index = Some(0);
 4894|      1|        app.pending_scroll_to_element = Some(1);
 4895|       |
 4896|      1|        let mut input = default_input();
 4897|      1|        input.events.push(egui::Event::Key {
 4898|      1|            key: egui::Key::Escape,
 4899|      1|            physical_key: None,
 4900|      1|            pressed: true,
 4901|      1|            repeat: false,
 4902|      1|            modifiers: egui::Modifiers::NONE,
 4903|      1|        });
 4904|       |
 4905|      1|        let ctx = egui::Context::default();
 4906|      1|        let _ = ctx.run(input, |ctx| {
 4907|      1|            app.handle_shortcuts(ctx);
 4908|      1|        });
 4909|       |
 4910|      1|        assert!(!app.show_search);
 4911|      1|        assert!(app.search_query.is_empty());
 4912|      1|        assert!(app.last_query.is_empty());
 4913|      1|        assert!(app.last_match_index.is_none());
 4914|      1|        assert!(app.pending_scroll_to_element.is_none());
 4915|      1|    }
 4916|       |
 4917|       |    #[test]
 4918|      1|    fn test_update_search_results_updates_matches() {
 4919|      1|        let mut app = MarkdownViewerApp::new();
 4920|      1|        app.load_content("Alpha\n\nBeta\n\nGamma", Some("Search".to_string()));
 4921|       |
 4922|      1|        app.search_query = "beta".to_string();
 4923|      1|        app.update_search_results("");
 4924|      1|        assert_eq!(app.last_query, "beta");
 4925|      1|        assert_eq!(app.last_match_index, Some(1));
 4926|      1|        assert_eq!(app.pending_scroll_to_element, Some(1));
 4927|       |
 4928|      1|        app.search_query.clear();
 4929|      1|        app.update_search_results("beta");
 4930|      1|        assert!(app.last_query.is_empty());
 4931|      1|    }
 4932|       |
 4933|       |    #[test]
 4934|      1|    fn test_update_search_results_no_match_leaves_index_clear() {
 4935|      1|        let mut app = MarkdownViewerApp::new();
 4936|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 4937|      1|            "Alpha".to_string(),
 4938|      1|        )])];
 4939|      1|        app.search_query = "Beta".to_string();
 4940|      1|        app.pending_scroll_to_element = None;
 4941|       |
 4942|      1|        app.update_search_results("");
 4943|       |
 4944|      1|        assert!(app.last_match_index.is_none());
 4945|      1|        assert!(app.pending_scroll_to_element.is_none());
 4946|      1|    }
 4947|       |
 4948|       |    #[test]
 4949|      1|    fn test_handle_shortcuts_ctrl_mouse_wheel_zoom() {
 4950|      1|        let mut app = MarkdownViewerApp::new();
 4951|      1|        let ctx = egui::Context::default();
 4952|      3|        for delta in [20.0, -20.0] {
                          ^2
 4953|      2|            let mut input = default_input();
 4954|      2|            input.modifiers = egui::Modifiers::CTRL;
 4955|      2|            input.events.push(egui::Event::MouseWheel {
 4956|      2|                unit: egui::MouseWheelUnit::Point,
 4957|      2|                delta: egui::vec2(0.0, delta),
 4958|      2|                modifiers: egui::Modifiers::CTRL,
 4959|      2|            });
 4960|      2|            let _ = ctx.run(input, |ctx| {
 4961|      2|                app.handle_shortcuts(ctx);
 4962|      2|            });
 4963|       |        }
 4964|      1|    }
 4965|       |
 4966|       |    #[test]
 4967|      1|    fn test_handle_shortcuts_ctrl_mouse_wheel_no_wheel_events() {
 4968|      1|        let mut app = MarkdownViewerApp::new();
 4969|      1|        let mut input = default_input();
 4970|      1|        input.modifiers = egui::Modifiers::CTRL;
 4971|      1|        input.events.push(egui::Event::Key {
 4972|      1|            key: egui::Key::A,
 4973|      1|            physical_key: None,
 4974|      1|            pressed: true,
 4975|      1|            repeat: false,
 4976|      1|            modifiers: egui::Modifiers::CTRL,
 4977|      1|        });
 4978|       |
 4979|      1|        let ctx = egui::Context::default();
 4980|      1|        let _ = ctx.run(input, |ctx| {
 4981|      1|            app.handle_shortcuts(ctx);
 4982|      1|        });
 4983|      1|    }
 4984|       |
 4985|       |    #[test]
 4986|      1|    fn test_handle_shortcuts_raw_page_moves() {
 4987|      1|        let mut app = MarkdownViewerApp::new();
 4988|      1|        app.view_mode = ViewMode::Raw;
 4989|      1|        app.write_enabled = true;
 4990|       |
 4991|      1|        let mut input = default_input();
 4992|      1|        input.events.extend([
 4993|      1|            egui::Event::Key {
 4994|      1|                key: egui::Key::PageUp,
 4995|      1|                physical_key: None,
 4996|      1|                pressed: true,
 4997|      1|                repeat: false,
 4998|      1|                modifiers: egui::Modifiers::NONE,
 4999|      1|            },
 5000|      1|            egui::Event::Key {
 5001|      1|                key: egui::Key::PageDown,
 5002|      1|                physical_key: None,
 5003|      1|                pressed: true,
 5004|      1|                repeat: false,
 5005|      1|                modifiers: egui::Modifiers::NONE,
 5006|      1|            },
 5007|      1|        ]);
 5008|       |
 5009|      1|        let ctx = egui::Context::default();
 5010|      1|        let _ = ctx.run(input, |ctx| {
 5011|      1|            app.handle_shortcuts(ctx);
 5012|      1|        });
 5013|       |
 5014|      1|        assert!(app.pending_raw_cursor_line_move.is_some());
 5015|      1|        assert!(app.raw_focus_requested);
 5016|      1|    }
 5017|       |
 5018|       |    #[test]
 5019|      1|    fn test_render_helpers_cover_ui_paths() {
 5020|      1|        let mut app = MarkdownViewerApp::new();
 5021|      1|        app.current_content = "Hello".to_string();
 5022|      1|        app.pending_files.push_back(PathBuf::from("queued.md"));
 5023|      1|        app.drag_hover = true;
 5024|      1|        app.show_search = true;
 5025|      1|        app.search_query = "welcome".to_string();
 5026|       |
 5027|      1|        let ctx = egui::Context::default();
 5028|      1|        let _ = ctx.run(default_input(), |ctx| {
 5029|      1|            CentralPanel::default().show(ctx, |ui| {
 5030|      1|                app.render_file_menu_contents(ui, false, Color32::WHITE);
 5031|      1|                app.render_view_menu_contents(ui, ctx, false, Color32::WHITE);
 5032|      1|                app.render_help_menu_contents(ui, false, Color32::WHITE);
 5033|      1|            });
 5034|      1|            app.render_status_bar(ctx);
 5035|      1|            app.render_search_dialog(ctx);
 5036|      1|            app.render_drag_overlay(ctx);
 5037|      1|        });
 5038|       |
 5039|      1|        assert!(app.show_search);
 5040|      1|    }
 5041|       |
 5042|       |    #[test]
 5043|      1|    fn test_screenshot_config_helpers() {
 5044|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 5045|      1|        let output_path = temp_dir.path().join("shot.png");
 5046|      1|        let config = ScreenshotConfig {
 5047|      1|            output_path: output_path.clone(),
 5048|      1|            viewport_width: 100.0,
 5049|      1|            viewport_height: 80.0,
 5050|      1|            content_only: true,
 5051|      1|            scroll_ratio: None,
 5052|      1|            wait_ms: 0,
 5053|      1|            settle_frames: 0,
 5054|      1|            zoom: 1.0,
 5055|      1|            theme: ScreenshotTheme::Light,
 5056|      1|            font_source: None,
 5057|      1|        };
 5058|       |
 5059|      1|        assert_eq!(config.metadata_path(), output_path.with_extension("json"));
 5060|      1|        assert_eq!(config.theme.as_str(), "light");
 5061|      1|        assert_eq!(ScreenshotTheme::Dark.as_str(), "dark");
 5062|      1|    }
 5063|       |
 5064|       |    #[test]
 5065|      1|    fn test_open_file_dialog_forced_path() -> Result<()> {
 5066|      1|        let mut app = MarkdownViewerApp::new();
 5067|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5068|      1|        let file_path = temp_dir.path().join("open.md");
 5069|      1|        std::fs::write(&file_path, "# Open")?;
                                                          ^0
 5070|      1|        let _forced = ForcedDialogPaths::new(Some(file_path.clone()), None);
 5071|       |
 5072|      1|        app.open_file_dialog();
 5073|       |
 5074|      1|        assert_eq!(app.current_file, Some(file_path));
 5075|      1|        assert!(app.error_message.is_none());
 5076|      1|        Ok(())
 5077|      1|    }
 5078|       |
 5079|       |    #[test]
 5080|      1|    fn test_save_current_document_existing_path() -> Result<()> {
 5081|      1|        let mut app = MarkdownViewerApp::new();
 5082|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5083|      1|        let file_path = temp_dir.path().join("save.md");
 5084|      1|        app.current_file = Some(file_path.clone());
 5085|      1|        app.current_content = "Saved content".to_string();
 5086|       |
 5087|      1|        app.save_current_document()?;
                                                 ^0
 5088|       |
 5089|      1|        let saved = std::fs::read_to_string(&file_path)?;
                                                                     ^0
 5090|      1|        assert_eq!(saved, "Saved content");
 5091|      1|        Ok(())
 5092|      1|    }
 5093|       |
 5094|       |    #[test]
 5095|      1|    fn test_save_current_document_forced_path() -> Result<()> {
 5096|      1|        let mut app = MarkdownViewerApp::new();
 5097|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5098|      1|        let file_path = temp_dir.path().join("save_forced.md");
 5099|      1|        let _forced = ForcedDialogPaths::new(None, Some(file_path.clone()));
 5100|      1|        app.current_content = "Forced save".to_string();
 5101|       |
 5102|      1|        app.save_current_document()?;
                                                 ^0
 5103|       |
 5104|      1|        assert_eq!(app.current_file, Some(file_path.clone()));
 5105|      1|        assert!(app.title.contains("save_forced.md"));
 5106|      1|        let saved = std::fs::read_to_string(&file_path)?;
                                                                     ^0
 5107|      1|        assert_eq!(saved, "Forced save");
 5108|      1|        Ok(())
 5109|      1|    }
 5110|       |
 5111|       |    #[test]
 5112|      1|    fn test_save_current_document_no_path_no_dialog() -> Result<()> {
 5113|      1|        let mut app = MarkdownViewerApp::new();
 5114|      1|        let _forced = ForcedDialogPaths::new(None, None);
 5115|      1|        app.current_content = "No save".to_string();
 5116|       |
 5117|      1|        app.save_current_document()?;
                                                 ^0
 5118|       |
 5119|      1|        assert!(app.current_file.is_none());
 5120|      1|        Ok(())
 5121|      1|    }
 5122|       |
 5123|       |    #[test]
 5124|      1|    fn test_restore_from_history_sets_state() {
 5125|      1|        let mut app = MarkdownViewerApp::new();
 5126|      1|        app.current_content = "first".to_string();
 5127|      1|        app.current_file = Some(PathBuf::from("first.md"));
 5128|      1|        app.title = "mdmdview - first".to_string();
 5129|      1|        app.push_history();
 5130|       |
 5131|      1|        app.current_content = "second".to_string();
 5132|      1|        app.current_file = None;
 5133|      1|        app.title = "mdmdview - second".to_string();
 5134|      1|        app.push_history();
 5135|       |
 5136|      1|        app.history_index = 0;
 5137|      1|        app.restore_from_history();
 5138|       |
 5139|      1|        assert_eq!(app.current_file, Some(PathBuf::from("first.md")));
 5140|      1|        assert_eq!(app.current_content, "first");
 5141|      1|        assert_eq!(app.pending_scroll_to_element, Some(0));
 5142|      1|    }
 5143|       |
 5144|       |    #[test]
 5145|      1|    fn test_restore_from_history_out_of_range_no_change() {
 5146|      1|        let mut app = MarkdownViewerApp::new();
 5147|      1|        app.current_content = "current".to_string();
 5148|      1|        app.history_index = 3;
 5149|       |
 5150|      1|        app.restore_from_history();
 5151|       |
 5152|      1|        assert_eq!(app.current_content, "current");
 5153|      1|        assert!(app.current_file.is_none());
 5154|      1|    }
 5155|       |
 5156|       |    #[test]
 5157|      1|    fn test_handle_file_drop_mixed_files() -> Result<()> {
 5158|      1|        let mut app = MarkdownViewerApp::new();
 5159|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5160|      1|        let good1 = temp_dir.path().join("good1.md");
 5161|      1|        let good2 = temp_dir.path().join("good2.md");
 5162|      1|        let bad = temp_dir.path().join("bad.pdf");
 5163|      1|        std::fs::write(&good1, "# Good1")?;
                                                       ^0
 5164|      1|        std::fs::write(&good2, "# Good2")?;
                                                       ^0
 5165|      1|        std::fs::write(&bad, "nope")?;
                                                  ^0
 5166|       |
 5167|      1|        app.handle_file_drop(vec![bad, good1.clone(), good2.clone()]);
 5168|       |
 5169|      1|        assert_eq!(app.current_file, Some(good1));
 5170|      1|        assert!(app.pending_files.contains(&good2));
 5171|      1|        assert!(app.error_message.is_some());
 5172|      1|        Ok(())
 5173|      1|    }
 5174|       |
 5175|       |    #[test]
 5176|      1|    fn test_handle_file_drop_directory_no_markdown() -> Result<()> {
 5177|      1|        let mut app = MarkdownViewerApp::new();
 5178|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5179|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 5180|      1|        assert!(app.error_message.is_some());
 5181|      1|        Ok(())
 5182|      1|    }
 5183|       |
 5184|       |    #[test]
 5185|      1|    fn test_handle_file_drop_too_many_files() -> Result<()> {
 5186|      1|        let mut app = MarkdownViewerApp::new();
 5187|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5188|      1|        let mut files = Vec::new();
 5189|     52|        for idx in 0..51 {
                          ^51
 5190|     51|            let path = temp_dir.path().join(format!("file{}.md", idx));
 5191|     51|            std::fs::write(&path, "# Test")?;
                                                         ^0
 5192|     51|            files.push(path);
 5193|       |        }
 5194|       |
 5195|      1|        app.handle_file_drop(files);
 5196|       |
 5197|      1|        assert!(app.error_message.is_some());
 5198|      1|        Ok(())
 5199|      1|    }
 5200|       |
 5201|       |    #[test]
 5202|      1|    fn test_move_raw_cursor_lines_up_and_down() {
 5203|      1|        let mut app = MarkdownViewerApp::new();
 5204|      1|        app.view_mode = ViewMode::Raw;
 5205|      1|        app.write_enabled = true;
 5206|      1|        app.raw_buffer = "Line 1\nLine 2\nLine 3".to_string();
 5207|      1|        app.current_content = app.raw_buffer.clone();
 5208|       |
 5209|      1|        let ctx = egui::Context::default();
 5210|      1|        let editor_id = egui::Id::new("raw_editor");
 5211|      1|        let mut state = egui::text_edit::TextEditState::default();
 5212|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 5213|      1|        state.cursor.set_char_range(Some(cr));
 5214|      1|        state.store(&ctx, editor_id);
 5215|       |
 5216|      1|        app.move_raw_cursor_lines(&ctx, 1);
 5217|      1|        let down_idx = app.raw_cursor.unwrap_or(0);
 5218|      1|        assert!(down_idx > 0);
 5219|       |
 5220|      1|        app.move_raw_cursor_lines(&ctx, -1);
 5221|      1|        let up_idx = app.raw_cursor.unwrap_or(0);
 5222|      1|        assert!(up_idx <= down_idx);
 5223|      1|    }
 5224|       |
 5225|       |    #[test]
 5226|      1|    fn test_move_raw_cursor_lines_early_return_when_not_raw() {
 5227|      1|        let mut app = MarkdownViewerApp::new();
 5228|      1|        app.view_mode = ViewMode::Rendered;
 5229|      1|        app.write_enabled = true;
 5230|      1|        app.raw_cursor = Some(2);
 5231|       |
 5232|      1|        let ctx = egui::Context::default();
 5233|      1|        app.move_raw_cursor_lines(&ctx, 1);
 5234|       |
 5235|      1|        assert_eq!(app.raw_cursor, Some(2));
 5236|      1|    }
 5237|       |
 5238|       |    #[test]
 5239|      1|    fn test_move_raw_cursor_lines_write_disabled_returns() {
 5240|      1|        let mut app = MarkdownViewerApp::new();
 5241|      1|        app.view_mode = ViewMode::Raw;
 5242|      1|        app.write_enabled = false;
 5243|      1|        app.raw_cursor = Some(1);
 5244|       |
 5245|      1|        let ctx = egui::Context::default();
 5246|      1|        app.move_raw_cursor_lines(&ctx, 1);
 5247|       |
 5248|      1|        assert_eq!(app.raw_cursor, Some(1));
 5249|      1|    }
 5250|       |
 5251|       |    #[test]
 5252|      1|    fn test_move_raw_cursor_lines_without_text_state() {
 5253|      1|        let mut app = MarkdownViewerApp::new();
 5254|      1|        app.view_mode = ViewMode::Raw;
 5255|      1|        app.write_enabled = true;
 5256|      1|        app.raw_buffer = "Line".to_string();
 5257|      1|        app.current_content = app.raw_buffer.clone();
 5258|       |
 5259|      1|        let ctx = egui::Context::default();
 5260|      1|        app.move_raw_cursor_lines(&ctx, 1);
 5261|       |
 5262|      1|        assert!(app.raw_cursor.is_none());
 5263|      1|    }
 5264|       |
 5265|       |    #[test]
 5266|      1|    fn test_move_raw_cursor_lines_uses_raw_cursor_when_char_range_missing() {
 5267|      1|        let mut app = MarkdownViewerApp::new();
 5268|      1|        app.view_mode = ViewMode::Raw;
 5269|      1|        app.write_enabled = true;
 5270|      1|        app.raw_buffer = "Line 1\nLine 2\nLine 3".to_string();
 5271|      1|        app.current_content = app.raw_buffer.clone();
 5272|      1|        app.raw_cursor = Some(7);
 5273|       |
 5274|      1|        let ctx = egui::Context::default();
 5275|      1|        let editor_id = egui::Id::new("raw_editor");
 5276|      1|        let mut state = egui::text_edit::TextEditState::default();
 5277|      1|        state.cursor.set_char_range(None);
 5278|      1|        state.store(&ctx, editor_id);
 5279|       |
 5280|      1|        app.move_raw_cursor_lines(&ctx, 1);
 5281|       |
 5282|      1|        assert_eq!(app.raw_cursor, Some(14));
 5283|      1|    }
 5284|       |
 5285|       |    #[test]
 5286|      1|    fn test_move_raw_cursor_lines_negative_at_start_no_loop() {
 5287|      1|        let mut app = MarkdownViewerApp::new();
 5288|      1|        app.view_mode = ViewMode::Raw;
 5289|      1|        app.write_enabled = true;
 5290|      1|        app.raw_buffer = "Line 1\nLine 2".to_string();
 5291|      1|        app.current_content = app.raw_buffer.clone();
 5292|       |
 5293|      1|        let ctx = egui::Context::default();
 5294|      1|        let editor_id = egui::Id::new("raw_editor");
 5295|      1|        let mut state = egui::text_edit::TextEditState::default();
 5296|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 5297|      1|        state.cursor.set_char_range(Some(cr));
 5298|      1|        state.store(&ctx, editor_id);
 5299|       |
 5300|      1|        app.move_raw_cursor_lines(&ctx, -1);
 5301|      1|        assert_eq!(app.raw_cursor, Some(0));
 5302|      1|    }
 5303|       |
 5304|       |    #[test]
 5305|      1|    fn test_move_raw_cursor_lines_down_without_newline() {
 5306|      1|        let mut app = MarkdownViewerApp::new();
 5307|      1|        app.view_mode = ViewMode::Raw;
 5308|      1|        app.write_enabled = true;
 5309|      1|        app.raw_buffer = "Line".to_string();
 5310|      1|        app.current_content = app.raw_buffer.clone();
 5311|       |
 5312|      1|        let ctx = egui::Context::default();
 5313|      1|        let editor_id = egui::Id::new("raw_editor");
 5314|      1|        let mut state = egui::text_edit::TextEditState::default();
 5315|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 5316|      1|        state.cursor.set_char_range(Some(cr));
 5317|      1|        state.store(&ctx, editor_id);
 5318|       |
 5319|      1|        app.move_raw_cursor_lines(&ctx, 1);
 5320|      1|        assert_eq!(app.raw_cursor, Some(app.raw_buffer.len()));
 5321|      1|    }
 5322|       |
 5323|       |    #[test]
 5324|      1|    fn test_move_raw_cursor_lines_down_at_end_no_loop() {
 5325|      1|        let mut app = MarkdownViewerApp::new();
 5326|      1|        app.view_mode = ViewMode::Raw;
 5327|      1|        app.write_enabled = true;
 5328|      1|        app.raw_buffer = "Line 1\nLine 2".to_string();
 5329|      1|        app.current_content = app.raw_buffer.clone();
 5330|       |
 5331|      1|        let ctx = egui::Context::default();
 5332|      1|        let editor_id = egui::Id::new("raw_editor");
 5333|      1|        let mut state = egui::text_edit::TextEditState::default();
 5334|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(app.raw_buffer.len()));
 5335|      1|        state.cursor.set_char_range(Some(cr));
 5336|      1|        state.store(&ctx, editor_id);
 5337|       |
 5338|      1|        app.move_raw_cursor_lines(&ctx, 1);
 5339|      1|        assert_eq!(app.raw_cursor, Some(app.raw_buffer.len()));
 5340|      1|    }
 5341|       |
 5342|       |    #[test]
 5343|      1|    fn test_handle_shortcuts_open_accelerators() -> Result<()> {
 5344|      1|        let mut app = MarkdownViewerApp::new();
 5345|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5346|      1|        let open_path = temp_dir.path().join("open.md");
 5347|      1|        std::fs::write(&open_path, "# Open")?;
                                                          ^0
 5348|      1|        let _forced = ForcedDialogPaths::new(Some(open_path.clone()), None);
 5349|       |
 5350|      1|        let mut input = default_input();
 5351|      1|        input.events.extend([
 5352|      1|            egui::Event::Key {
 5353|      1|                key: egui::Key::O,
 5354|      1|                physical_key: None,
 5355|      1|                pressed: true,
 5356|      1|                repeat: false,
 5357|      1|                modifiers: egui::Modifiers::CTRL,
 5358|      1|            },
 5359|      1|            egui::Event::Key {
 5360|      1|                key: egui::Key::O,
 5361|      1|                physical_key: None,
 5362|      1|                pressed: true,
 5363|      1|                repeat: false,
 5364|      1|                modifiers: egui::Modifiers::ALT,
 5365|      1|            },
 5366|      1|        ]);
 5367|       |
 5368|      1|        let ctx = egui::Context::default();
 5369|      1|        let _ = ctx.run(input, |ctx| {
 5370|      1|            app.handle_shortcuts(ctx);
 5371|      1|        });
 5372|       |
 5373|      1|        assert_eq!(app.current_file, Some(open_path));
 5374|      1|        Ok(())
 5375|      1|    }
 5376|       |
 5377|       |    #[test]
 5378|      1|    fn test_handle_shortcuts_close_accelerators() {
 5379|      1|        let mut app = MarkdownViewerApp::new();
 5380|      1|        app.current_file = Some(PathBuf::from("dummy.md"));
 5381|      1|        app.current_content = "# Dummy".to_string();
 5382|       |
 5383|      1|        let mut input = default_input();
 5384|      1|        input.events.extend([
 5385|      1|            egui::Event::Key {
 5386|      1|                key: egui::Key::W,
 5387|      1|                physical_key: None,
 5388|      1|                pressed: true,
 5389|      1|                repeat: false,
 5390|      1|                modifiers: egui::Modifiers::ALT,
 5391|      1|            },
 5392|      1|            egui::Event::Key {
 5393|      1|                key: egui::Key::W,
 5394|      1|                physical_key: None,
 5395|      1|                pressed: true,
 5396|      1|                repeat: false,
 5397|      1|                modifiers: egui::Modifiers::CTRL,
 5398|      1|            },
 5399|      1|            egui::Event::Key {
 5400|      1|                key: egui::Key::Q,
 5401|      1|                physical_key: None,
 5402|      1|                pressed: true,
 5403|      1|                repeat: false,
 5404|      1|                modifiers: egui::Modifiers::ALT,
 5405|      1|            },
 5406|      1|            egui::Event::Key {
 5407|      1|                key: egui::Key::Q,
 5408|      1|                physical_key: None,
 5409|      1|                pressed: true,
 5410|      1|                repeat: false,
 5411|      1|                modifiers: egui::Modifiers::CTRL,
 5412|      1|            },
 5413|      1|        ]);
 5414|       |
 5415|      1|        let ctx = egui::Context::default();
 5416|      1|        let _ = ctx.run(input, |ctx| {
 5417|      1|            app.handle_shortcuts(ctx);
 5418|      1|        });
 5419|       |
 5420|      1|        assert!(app.current_file.is_none());
 5421|      1|    }
 5422|       |
 5423|       |    #[test]
 5424|      1|    fn test_handle_shortcuts_ctrl_save() -> Result<()> {
 5425|      1|        let mut app = MarkdownViewerApp::new();
 5426|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5427|      1|        let file_path = temp_dir.path().join("save.md");
 5428|      1|        app.current_file = Some(file_path.clone());
 5429|      1|        app.current_content = "Saved".to_string();
 5430|       |
 5431|      1|        let mut input = default_input();
 5432|      1|        input.events.push(egui::Event::Key {
 5433|      1|            key: egui::Key::S,
 5434|      1|            physical_key: None,
 5435|      1|            pressed: true,
 5436|      1|            repeat: false,
 5437|      1|            modifiers: egui::Modifiers::CTRL,
 5438|      1|        });
 5439|       |
 5440|      1|        let ctx = egui::Context::default();
 5441|      1|        let _ = ctx.run(input, |ctx| {
 5442|      1|            app.handle_shortcuts(ctx);
 5443|      1|        });
 5444|       |
 5445|      1|        let saved = std::fs::read_to_string(&file_path)?;
                                                                     ^0
 5446|      1|        assert_eq!(saved, "Saved");
 5447|      1|        Ok(())
 5448|      1|    }
 5449|       |
 5450|       |    #[test]
 5451|      1|    fn test_compute_window_adjustment_clamps() {
 5452|      1|        let outer = egui::Rect::from_min_size(egui::pos2(-100.0, -100.0), egui::vec2(200.0, 100.0));
 5453|      1|        let monitor = egui::vec2(800.0, 600.0);
 5454|      1|        let adjusted =
 5455|      1|            MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), Some(monitor));
 5456|      1|        assert!(adjusted.is_some());
 5457|       |
 5458|      1|        let outer_ok = egui::Rect::from_min_size(egui::pos2(10.0, 10.0), egui::vec2(800.0, 600.0));
 5459|      1|        let unchanged = MarkdownViewerApp::compute_window_adjustment(
 5460|      1|            Some(outer_ok),
 5461|      1|            Some(outer_ok),
 5462|      1|            Some(monitor),
 5463|       |        );
 5464|      1|        assert!(unchanged.is_none());
 5465|      1|    }
 5466|       |
 5467|       |    #[test]
 5468|      1|    fn test_persist_window_state_updates_cache() {
 5469|      1|        let _lock = env_lock();
 5470|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 5471|      1|        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());
 5472|      1|        let mut app = MarkdownViewerApp::new();
 5473|      1|        app.last_window_pos = Some([10.0, 20.0]);
 5474|      1|        app.last_window_size = Some([800.0, 600.0]);
 5475|      1|        app.last_window_maximized = true;
 5476|       |
 5477|      1|        app.persist_window_state();
 5478|       |
 5479|      1|        assert!(app.last_persisted_state.is_some());
 5480|      1|    }
 5481|       |
 5482|       |    #[test]
 5483|      1|    fn test_render_actions_trigger_menu_and_context() {
 5484|      1|        let mut app = MarkdownViewerApp::new();
 5485|      1|        app.current_content = "Hello".to_string();
 5486|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5487|      1|            "Hello".to_string(),
 5488|      1|        )])];
 5489|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 5490|      1|        let open_path = temp_dir.path().join("open.md");
 5491|      1|        std::fs::write(&open_path, "# Open").expect("write");
 5492|      1|        let save_path = temp_dir.path().join("save.md");
 5493|      1|        let _forced = ForcedDialogPaths::new(Some(open_path), Some(save_path));
 5494|      1|        let _actions = ForcedAppActions::new(&[
 5495|      1|            "menu_open",
 5496|      1|            "menu_save",
 5497|      1|            "menu_close",
 5498|      1|            "menu_reload",
 5499|      1|            "menu_find",
 5500|      1|            "menu_samples",
 5501|      1|            "menu_bar_file",
 5502|      1|            "menu_bar_view",
 5503|      1|            "menu_bar_help",
 5504|      1|            "menu_help_usage",
 5505|      1|            "menu_help_about",
 5506|      1|            "menu_back",
 5507|      1|            "menu_forward",
 5508|      1|            "menu_raw",
 5509|      1|            "menu_write",
 5510|      1|            "menu_wrap_raw",
 5511|      1|            "menu_zoom_in",
 5512|      1|            "menu_zoom_out",
 5513|      1|            "menu_zoom_reset",
 5514|      1|            "menu_fullscreen",
 5515|      1|            "ctx_copy_all",
 5516|      1|            "ctx_copy_markdown",
 5517|      1|            "ctx_nav_top",
 5518|      1|            "ctx_nav_bottom",
 5519|      1|            "search_next",
 5520|      1|            "search_prev",
 5521|      1|            "search_close",
 5522|      1|            "status_hover",
 5523|      1|            "welcome_open",
 5524|      1|            "welcome.md",
 5525|      1|            "usage.md",
 5526|      1|        ]);
 5527|       |
 5528|      1|        let ctx = egui::Context::default();
 5529|      1|        let _ = ctx.run(default_input(), |ctx| {
 5530|      1|            CentralPanel::default().show(ctx, |ui| {
 5531|      1|                app.render_file_menu_contents(ui, false, Color32::WHITE);
 5532|      1|                app.render_view_menu_contents(ui, ctx, false, Color32::WHITE);
 5533|      1|                app.render_help_menu_contents(ui, false, Color32::WHITE);
 5534|      1|                app.render_main_context_menu(ui);
 5535|      1|            });
 5536|      1|            app.show_search = true;
 5537|      1|            app.render_search_dialog(ctx);
 5538|      1|            app.render_menu_bar(ctx);
 5539|      1|            app.render_status_bar(ctx);
 5540|      1|        });
 5541|      1|    }
 5542|       |
 5543|       |    #[test]
 5544|      1|    fn test_render_search_dialog_stays_open() {
 5545|      1|        let mut app = MarkdownViewerApp::new();
 5546|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5547|      1|            "Alpha".to_string(),
 5548|      1|        )])];
 5549|      1|        app.show_search = true;
 5550|      1|        app.search_query = "Alpha".to_string();
 5551|       |
 5552|      1|        let ctx = egui::Context::default();
 5553|      1|        let _ = ctx.run(default_input(), |ctx| {
 5554|      1|            app.render_search_dialog(ctx);
 5555|      1|        });
 5556|       |
 5557|      1|        assert!(app.show_search);
 5558|      1|        assert_eq!(app.search_query, "Alpha");
 5559|      1|    }
 5560|       |
 5561|       |    #[test]
 5562|      1|    fn test_render_search_dialog_close_clears_state() {
 5563|      1|        let mut app = MarkdownViewerApp::new();
 5564|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5565|      1|            "Alpha".to_string(),
 5566|      1|        )])];
 5567|      1|        app.show_search = true;
 5568|      1|        app.search_query = "Alpha".to_string();
 5569|      1|        app.last_query = "Alpha".to_string();
 5570|      1|        app.last_match_index = Some(0);
 5571|      1|        app.pending_scroll_to_element = Some(1);
 5572|      1|        let _actions = ForcedAppActions::new(&["search_close"]);
 5573|       |
 5574|      1|        let ctx = egui::Context::default();
 5575|      1|        let _ = ctx.run(default_input(), |ctx| {
 5576|      1|            app.render_search_dialog(ctx);
 5577|      1|        });
 5578|       |
 5579|      1|        assert!(!app.show_search);
 5580|      1|        assert!(app.search_query.is_empty());
 5581|      1|        assert!(app.last_query.is_empty());
 5582|      1|        assert!(app.last_match_index.is_none());
 5583|      1|        assert!(app.pending_scroll_to_element.is_none());
 5584|      1|    }
 5585|       |
 5586|       |    #[test]
 5587|      1|    fn test_render_search_dialog_submitted_next_on_enter() {
 5588|      1|        let mut app = MarkdownViewerApp::new();
 5589|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5590|      1|            "Alpha".to_string(),
 5591|      1|        )])];
 5592|      1|        app.show_search = true;
 5593|      1|        app.search_query = "Alpha".to_string();
 5594|      1|        app.search_focus_requested = true;
 5595|       |
 5596|      1|        let ctx = egui::Context::default();
 5597|      1|        let _ = ctx.run(default_input(), |ctx| {
 5598|      1|            app.render_search_dialog(ctx);
 5599|      1|        });
 5600|       |
 5601|      1|        let mut input = default_input();
 5602|      1|        input.events.push(egui::Event::Key {
 5603|      1|            key: egui::Key::Enter,
 5604|      1|            physical_key: None,
 5605|      1|            pressed: true,
 5606|      1|            repeat: false,
 5607|      1|            modifiers: egui::Modifiers::NONE,
 5608|      1|        });
 5609|      1|        let _ = ctx.run(input, |ctx| {
 5610|      1|            app.render_search_dialog(ctx);
 5611|      1|        });
 5612|       |
 5613|      1|        assert!(app.last_match_index.is_some());
 5614|      1|    }
 5615|       |
 5616|       |    #[test]
 5617|      1|    fn test_should_submit_search_requires_focus_and_enter() {
 5618|      1|        assert!(MarkdownViewerApp::should_submit_search(true, true));
 5619|      1|        assert!(!MarkdownViewerApp::should_submit_search(false, true));
 5620|      1|        assert!(!MarkdownViewerApp::should_submit_search(true, false));
 5621|      1|    }
 5622|       |
 5623|       |    #[test]
 5624|      1|    fn test_render_main_context_menu_no_actions() {
 5625|      1|        let mut app = MarkdownViewerApp::new();
 5626|      1|        app.current_content = "Hello".to_string();
 5627|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5628|      1|            "Hello".to_string(),
 5629|      1|        )])];
 5630|       |
 5631|      1|        let ctx = egui::Context::default();
 5632|      1|        let _ = ctx.run(default_input(), |ctx| {
 5633|      1|            CentralPanel::default().show(ctx, |ui| {
 5634|      1|                app.render_main_context_menu(ui);
 5635|      1|            });
 5636|      1|        });
 5637|       |
 5638|      1|        assert!(app.nav_request.is_none());
 5639|      1|    }
 5640|       |
 5641|       |    #[test]
 5642|      1|    fn test_render_menu_bar_light_mode() {
 5643|      1|        let mut app = MarkdownViewerApp::new();
 5644|      1|        let ctx = egui::Context::default();
 5645|      1|        ctx.set_visuals(egui::Visuals::light());
 5646|       |
 5647|      1|        let _ = ctx.run(default_input(), |ctx| {
 5648|      1|            app.render_menu_bar(ctx);
 5649|      1|        });
 5650|      1|    }
 5651|       |
 5652|       |    #[test]
 5653|      1|    fn test_handle_file_drop_empty_and_missing() {
 5654|      1|        let mut app = MarkdownViewerApp::new();
 5655|      1|        app.handle_file_drop(Vec::new());
 5656|       |
 5657|      1|        app.handle_file_drop(vec![PathBuf::from("missing.md")]);
 5658|      1|        assert!(app
 5659|      1|            .error_message
 5660|      1|            .as_ref()
 5661|      1|            .is_some_and(|msg| msg.contains("File not found")));
 5662|      1|    }
 5663|       |
 5664|       |    #[test]
 5665|      1|    fn test_handle_file_drop_scan_error() -> Result<()> {
 5666|      1|        let mut app = MarkdownViewerApp::new();
 5667|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5668|      1|        let _forced = ForcedScanError::new();
 5669|       |
 5670|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 5671|       |
 5672|      1|        assert!(app.error_message.is_some());
 5673|      1|        Ok(())
 5674|      1|    }
 5675|       |
 5676|       |    #[test]
 5677|      1|    fn test_handle_file_drop_load_failure() -> Result<()> {
 5678|      1|        let mut app = MarkdownViewerApp::new();
 5679|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5680|      1|        let file_path = temp_dir.path().join("fail.md");
 5681|      1|        std::fs::write(&file_path, "# Fail")?;
                                                          ^0
 5682|      1|        let _forced = ForcedLoadError::new();
 5683|       |
 5684|      1|        app.handle_file_drop(vec![file_path]);
 5685|       |
 5686|      1|        assert!(app
 5687|      1|            .error_message
 5688|      1|            .as_ref()
 5689|      1|            .is_some_and(|msg| msg.contains("Failed to load file")));
 5690|      1|        Ok(())
 5691|      1|    }
 5692|       |
 5693|       |    #[test]
 5694|      1|    fn test_handle_shortcuts_ctrl_f_sets_match_index() {
 5695|      1|        let mut app = MarkdownViewerApp::new();
 5696|      1|        app.last_match_index = None;
 5697|       |
 5698|      1|        let mut input = default_input();
 5699|      1|        input.events.push(egui::Event::Key {
 5700|      1|            key: egui::Key::F,
 5701|      1|            physical_key: None,
 5702|      1|            pressed: true,
 5703|      1|            repeat: false,
 5704|      1|            modifiers: egui::Modifiers::CTRL,
 5705|      1|        });
 5706|       |
 5707|      1|        let ctx = egui::Context::default();
 5708|      1|        let _ = ctx.run(input, |ctx| {
 5709|      1|            app.handle_shortcuts(ctx);
 5710|      1|        });
 5711|       |
 5712|      1|        assert_eq!(app.last_match_index, Some(0));
 5713|      1|    }
 5714|       |
 5715|       |    #[test]
 5716|      1|    fn test_handle_shortcuts_ctrl_f_preserves_match_index() {
 5717|      1|        let mut app = MarkdownViewerApp::new();
 5718|      1|        app.last_match_index = Some(2);
 5719|       |
 5720|      1|        let mut input = default_input();
 5721|      1|        input.events.push(egui::Event::Key {
 5722|      1|            key: egui::Key::F,
 5723|      1|            physical_key: None,
 5724|      1|            pressed: true,
 5725|      1|            repeat: false,
 5726|      1|            modifiers: egui::Modifiers::CTRL,
 5727|      1|        });
 5728|       |
 5729|      1|        let ctx = egui::Context::default();
 5730|      1|        let _ = ctx.run(input, |ctx| {
 5731|      1|            app.handle_shortcuts(ctx);
 5732|      1|        });
 5733|       |
 5734|      1|        assert_eq!(app.last_match_index, Some(2));
 5735|      1|    }
 5736|       |
 5737|       |    #[test]
 5738|      1|    fn test_handle_shortcuts_ctrl_mouse_wheel_zoom_directions() {
 5739|      1|        let mut app = MarkdownViewerApp::new();
 5740|      1|        let ctx = egui::Context::default();
 5741|       |
 5742|      1|        let mut input = default_input();
 5743|      1|        input.modifiers = egui::Modifiers::CTRL;
 5744|      1|        input.events.push(egui::Event::MouseWheel {
 5745|      1|            unit: egui::MouseWheelUnit::Point,
 5746|      1|            delta: egui::vec2(0.0, 20.0),
 5747|      1|            modifiers: egui::Modifiers::CTRL,
 5748|      1|        });
 5749|      1|        let _ = ctx.run(input, |ctx| {
 5750|      1|            app.handle_shortcuts(ctx);
 5751|      1|        });
 5752|       |
 5753|      1|        let mut input = default_input();
 5754|      1|        input.modifiers = egui::Modifiers::CTRL;
 5755|      1|        input.events.push(egui::Event::MouseWheel {
 5756|      1|            unit: egui::MouseWheelUnit::Point,
 5757|      1|            delta: egui::vec2(0.0, -20.0),
 5758|      1|            modifiers: egui::Modifiers::CTRL,
 5759|      1|        });
 5760|      1|        let _ = ctx.run(input, |ctx| {
 5761|      1|            app.handle_shortcuts(ctx);
 5762|      1|        });
 5763|      1|    }
 5764|       |
 5765|       |    #[test]
 5766|      1|    fn test_handle_shortcuts_ctrl_mouse_wheel_without_events() {
 5767|      1|        let mut app = MarkdownViewerApp::new();
 5768|      1|        let ctx = egui::Context::default();
 5769|      1|        let mut input = default_input();
 5770|      1|        input.modifiers = egui::Modifiers::CTRL;
 5771|      1|        let _ = ctx.run(input, |ctx| {
 5772|      1|            app.handle_shortcuts(ctx);
 5773|      1|        });
 5774|      1|    }
 5775|       |
 5776|       |    #[test]
 5777|      1|    fn test_handle_shortcuts_ctrl_save_error() {
 5778|      1|        let mut app = MarkdownViewerApp::new();
 5779|      1|        app.current_file = Some(PathBuf::from("missing_dir\\save.md"));
 5780|      1|        app.current_content = "Data".to_string();
 5781|       |
 5782|      1|        let mut input = default_input();
 5783|      1|        input.events.push(egui::Event::Key {
 5784|      1|            key: egui::Key::S,
 5785|      1|            physical_key: None,
 5786|      1|            pressed: true,
 5787|      1|            repeat: false,
 5788|      1|            modifiers: egui::Modifiers::CTRL,
 5789|      1|        });
 5790|       |
 5791|      1|        let ctx = egui::Context::default();
 5792|      1|        let _ = ctx.run(input, |ctx| {
 5793|      1|            app.handle_shortcuts(ctx);
 5794|      1|        });
 5795|       |
 5796|      1|        assert!(app.error_message.is_some());
 5797|      1|    }
 5798|       |
 5799|       |    #[test]
 5800|      1|    fn test_move_raw_cursor_lines_edge_cases() {
 5801|      1|        let mut app = MarkdownViewerApp::new();
 5802|      1|        app.raw_buffer = "Line 1\nLine 2\nLine 3\nLine 4".to_string();
 5803|      1|        app.current_content = app.raw_buffer.clone();
 5804|       |
 5805|      1|        let ctx = egui::Context::default();
 5806|      1|        app.move_raw_cursor_lines(&ctx, 1);
 5807|       |
 5808|      1|        app.view_mode = ViewMode::Raw;
 5809|      1|        app.write_enabled = true;
 5810|      1|        let editor_id = egui::Id::new("raw_editor");
 5811|      1|        let mut state = egui::text_edit::TextEditState::default();
 5812|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(3));
 5813|      1|        state.cursor.set_char_range(Some(cr));
 5814|      1|        state.store(&ctx, editor_id);
 5815|       |
 5816|      1|        app.move_raw_cursor_lines(&ctx, 0);
 5817|      1|        app.move_raw_cursor_lines(&ctx, 2);
 5818|      1|        app.move_raw_cursor_lines(&ctx, -2);
 5819|      1|    }
 5820|       |
 5821|       |    #[test]
 5822|      1|    fn test_render_status_bar_no_file_and_tooltip() {
 5823|      1|        let mut app = MarkdownViewerApp::new();
 5824|      1|        app.current_file = None;
 5825|      1|        app.parsed_elements.clear();
 5826|       |
 5827|      1|        let _actions = ForcedAppActions::new(&["status_hover"]);
 5828|      1|        let ctx = egui::Context::default();
 5829|      1|        let _ = ctx.run(default_input(), |ctx| {
 5830|      1|            app.render_status_bar(ctx);
 5831|      1|        });
 5832|      1|    }
 5833|       |
 5834|       |    #[test]
 5835|      1|    fn test_render_status_bar_table_stats() {
 5836|      1|        let mut app = MarkdownViewerApp::new();
 5837|      1|        app.current_file = None;
 5838|      1|        app.parsed_elements = vec![MarkdownElement::Table {
 5839|      1|            headers: vec![vec![InlineSpan::Text("H".to_string())]],
 5840|      1|            rows: vec![vec![vec![InlineSpan::Text("C".to_string())]]],
 5841|      1|            alignments: vec![pulldown_cmark::Alignment::Left],
 5842|      1|        }];
 5843|       |
 5844|      1|        let ctx = egui::Context::default();
 5845|      1|        let _ = ctx.run(default_input(), |ctx| {
 5846|      1|            CentralPanel::default().show(ctx, |ui| {
 5847|      1|                app.renderer.render_to_ui(ui, &app.parsed_elements);
 5848|      1|            });
 5849|      1|            app.render_status_bar(ctx);
 5850|      1|        });
 5851|      1|    }
 5852|       |
 5853|       |    #[test]
 5854|      1|    fn test_render_status_bar_pending_load_and_queue() {
 5855|      1|        let mut app = MarkdownViewerApp::new();
 5856|      1|        app.pending_file_load = Some(PendingFileLoad {
 5857|      1|            id: 1,
 5858|      1|            path: PathBuf::from("pending.md"),
 5859|      1|        });
 5860|      1|        app.pending_files.push_back(PathBuf::from("queued.md"));
 5861|       |
 5862|      1|        let ctx = egui::Context::default();
 5863|      1|        let _ = ctx.run(default_input(), |ctx| {
 5864|      1|            app.render_status_bar(ctx);
 5865|      1|        });
 5866|      1|    }
 5867|       |
 5868|       |    #[test]
 5869|      1|    fn test_update_impl_welcome_open_button() -> Result<()> {
 5870|      1|        let mut app = MarkdownViewerApp::new();
 5871|      1|        app.parsed_elements.clear();
 5872|      1|        app.current_content.clear();
 5873|      1|        app.error_message = None;
 5874|       |
 5875|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5876|      1|        let file_path = temp_dir.path().join("welcome.md");
 5877|      1|        std::fs::write(&file_path, "# Welcome")?;
                                                             ^0
 5878|      1|        let _forced = ForcedDialogPaths::new(Some(file_path.clone()), None);
 5879|      1|        let _actions = ForcedAppActions::new(&["welcome_open"]);
 5880|       |
 5881|      1|        let ctx = egui::Context::default();
 5882|      1|        run_app_frame(&mut app, &ctx, default_input());
 5883|       |
 5884|      1|        assert_eq!(app.current_file, Some(file_path));
 5885|      1|        Ok(())
 5886|      1|    }
 5887|       |
 5888|       |    #[test]
 5889|      1|    fn test_update_impl_welcome_screen_no_open() {
 5890|      1|        let mut app = MarkdownViewerApp::new();
 5891|      1|        app.parsed_elements.clear();
 5892|      1|        app.current_content.clear();
 5893|      1|        app.error_message = None;
 5894|       |
 5895|      1|        let ctx = egui::Context::default();
 5896|      1|        run_app_frame(&mut app, &ctx, default_input());
 5897|       |
 5898|      1|        assert!(app.current_file.is_none());
 5899|      1|    }
 5900|       |
 5901|       |    #[test]
 5902|      1|    fn test_update_impl_welcome_screen_with_error_message() {
 5903|      1|        let mut app = MarkdownViewerApp::new();
 5904|      1|        app.parsed_elements.clear();
 5905|      1|        app.current_content.clear();
 5906|      1|        app.error_message = Some("Load failed".to_string());
 5907|       |
 5908|      1|        let ctx = egui::Context::default();
 5909|      1|        run_app_frame(&mut app, &ctx, default_input());
 5910|       |
 5911|      1|        assert!(app.error_message.is_some());
 5912|      1|    }
 5913|       |
 5914|       |    #[test]
 5915|      1|    fn test_update_impl_navigation_requests() {
 5916|      1|        let mut app = MarkdownViewerApp::new();
 5917|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5918|      1|            "Nav".to_string(),
 5919|      1|        )])];
 5920|      1|        let ctx = egui::Context::default();
 5921|      1|        let input = default_input();
 5922|      1|        let navs = [
 5923|      1|            NavigationRequest::Top,
 5924|      1|            NavigationRequest::Bottom,
 5925|      1|            NavigationRequest::PageUp,
 5926|      1|            NavigationRequest::PageDown,
 5927|      1|            NavigationRequest::ScrollUp,
 5928|      1|            NavigationRequest::ScrollDown,
 5929|      1|        ];
 5930|      7|        for nav in navs {
                          ^6
 5931|      6|            app.nav_request = Some(nav);
 5932|      6|            run_app_frame(&mut app, &ctx, input.clone());
 5933|      6|        }
 5934|      1|    }
 5935|       |
 5936|       |    #[test]
 5937|      1|    fn test_update_impl_anchor_and_search_highlight() {
 5938|      1|        let mut app = MarkdownViewerApp::new();
 5939|      1|        app.parsed_elements = vec![MarkdownElement::Header {
 5940|      1|            level: 1,
 5941|      1|            spans: vec![InlineSpan::Text("Section".to_string())],
 5942|      1|            id: "section".to_string(),
 5943|      1|        }];
 5944|      1|        app.current_content = "# Section".to_string();
 5945|      1|        app.show_search = true;
 5946|      1|        app.search_query = "Section".to_string();
 5947|      1|        app.pending_scroll_to_element = Some(0);
 5948|      1|        app.renderer.trigger_link("#section");
 5949|       |
 5950|      1|        let ctx = egui::Context::default();
 5951|      1|        run_app_frame(&mut app, &ctx, default_input());
 5952|       |
 5953|      1|        app.show_search = false;
 5954|      1|        app.search_query.clear();
 5955|      1|        app.last_query = "Section".to_string();
 5956|      1|        run_app_frame(&mut app, &ctx, default_input());
 5957|      1|    }
 5958|       |
 5959|       |    #[test]
 5960|      1|    fn test_update_impl_search_highlight_empty_query_prefers_last() {
 5961|      1|        let mut app = MarkdownViewerApp::new();
 5962|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5963|      1|            "Find me".to_string(),
 5964|      1|        )])];
 5965|      1|        app.current_content = "Find me".to_string();
 5966|      1|        app.show_search = true;
 5967|      1|        app.search_query.clear();
 5968|      1|        app.last_query = "Find".to_string();
 5969|       |
 5970|      1|        let ctx = egui::Context::default();
 5971|      1|        run_app_frame(&mut app, &ctx, default_input());
 5972|      1|    }
 5973|       |
 5974|       |    #[test]
 5975|      1|    fn test_update_impl_missing_anchor_and_scroll_target() {
 5976|      1|        let mut app = MarkdownViewerApp::new();
 5977|      1|        app.parsed_elements = vec![MarkdownElement::Header {
 5978|      1|            level: 1,
 5979|      1|            spans: vec![InlineSpan::Text("Known".to_string())],
 5980|      1|            id: "known".to_string(),
 5981|      1|        }];
 5982|      1|        app.current_content = "# Known".to_string();
 5983|      1|        app.renderer.trigger_link("#missing");
 5984|      1|        app.pending_scroll_to_element = Some(99);
 5985|       |
 5986|      1|        let ctx = egui::Context::default();
 5987|      1|        run_app_frame(&mut app, &ctx, default_input());
 5988|       |
 5989|      1|        assert!(app.pending_scroll_to_element.is_none());
 5990|      1|    }
 5991|       |
 5992|       |    #[test]
 5993|      1|    fn test_update_impl_raw_cursor_restore_without_state() {
 5994|      1|        let mut app = MarkdownViewerApp::new();
 5995|      1|        app.view_mode = ViewMode::Raw;
 5996|      1|        app.write_enabled = true;
 5997|      1|        app.raw_buffer = "Line 1\nLine 2".to_string();
 5998|      1|        app.current_content = app.raw_buffer.clone();
 5999|      1|        app.raw_cursor = Some(3);
 6000|       |
 6001|      1|        let ctx = egui::Context::default();
 6002|      1|        run_app_frame(&mut app, &ctx, default_input());
 6003|      1|    }
 6004|       |
 6005|       |    #[test]
 6006|      1|    fn test_update_impl_raw_cursor_without_char_range() {
 6007|      1|        let mut app = MarkdownViewerApp::new();
 6008|      1|        app.view_mode = ViewMode::Raw;
 6009|      1|        app.write_enabled = true;
 6010|      1|        app.raw_buffer = "Line".to_string();
 6011|      1|        app.current_content = app.raw_buffer.clone();
 6012|       |
 6013|      1|        let ctx = egui::Context::default();
 6014|      1|        let editor_id = egui::Id::new("raw_editor");
 6015|      1|        let mut state = egui::text_edit::TextEditState::default();
 6016|      1|        state.cursor.set_char_range(None);
 6017|      1|        state.store(&ctx, editor_id);
 6018|       |
 6019|      1|        run_app_frame(&mut app, &ctx, default_input());
 6020|       |
 6021|      1|        assert!(app.raw_cursor.is_none());
 6022|      1|    }
 6023|       |
 6024|       |    #[test]
 6025|      1|    fn test_update_impl_raw_edit_updates_content() {
 6026|      1|        let mut app = MarkdownViewerApp::new();
 6027|      1|        app.view_mode = ViewMode::Raw;
 6028|      1|        app.write_enabled = true;
 6029|      1|        app.raw_focus_requested = true;
 6030|      1|        app.raw_buffer = "Line".to_string();
 6031|      1|        app.current_content = app.raw_buffer.clone();
 6032|       |
 6033|      1|        let ctx = egui::Context::default();
 6034|      1|        let mut input = default_input();
 6035|      1|        input.focused = true;
 6036|      1|        run_app_frame(&mut app, &ctx, input);
 6037|       |
 6038|      1|        let mut input = default_input();
 6039|      1|        input.focused = true;
 6040|      1|        input.events.push(egui::Event::Text("X".to_string()));
 6041|      1|        run_app_frame(&mut app, &ctx, input);
 6042|       |
 6043|      1|        assert!(app.current_content.contains('X'));
 6044|      1|    }
 6045|       |
 6046|       |    #[test]
 6047|      1|    fn test_update_impl_raw_edit_parse_error_sets_message() {
 6048|      1|        let mut app = MarkdownViewerApp::new();
 6049|      1|        app.view_mode = ViewMode::Raw;
 6050|      1|        app.write_enabled = true;
 6051|      1|        app.raw_focus_requested = true;
 6052|      1|        app.raw_buffer = "Line".to_string();
 6053|      1|        app.current_content = app.raw_buffer.clone();
 6054|      1|        crate::markdown_renderer::force_parse_error_once();
 6055|       |
 6056|      1|        let ctx = egui::Context::default();
 6057|      1|        let mut input = default_input();
 6058|      1|        input.focused = true;
 6059|      1|        run_app_frame(&mut app, &ctx, input);
 6060|       |
 6061|      1|        let mut input = default_input();
 6062|      1|        input.focused = true;
 6063|      1|        input.events.push(egui::Event::Text("X".to_string()));
 6064|      1|        run_app_frame(&mut app, &ctx, input);
 6065|       |
 6066|      1|        assert!(app.error_message.is_some());
 6067|      1|    }
 6068|       |
 6069|       |    #[test]
 6070|      1|    fn test_update_impl_screenshot_scroll_offset() {
 6071|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 6072|      1|        let config = ScreenshotConfig {
 6073|      1|            output_path: temp_dir.path().join("shot.png"),
 6074|      1|            viewport_width: 80.0,
 6075|      1|            viewport_height: 60.0,
 6076|      1|            content_only: false,
 6077|      1|            scroll_ratio: None,
 6078|      1|            wait_ms: 0,
 6079|      1|            settle_frames: 0,
 6080|      1|            zoom: 1.0,
 6081|      1|            theme: ScreenshotTheme::Light,
 6082|      1|            font_source: None,
 6083|      1|        };
 6084|      1|        let mut app = MarkdownViewerApp::new();
 6085|      1|        app.screenshot = Some(ScreenshotState::new(config));
 6086|      1|        let state = app.screenshot.as_mut().expect("screenshot state");
 6087|      1|        state.scroll_offset = Some(10.0);
 6088|       |
 6089|      1|        let ctx = egui::Context::default();
 6090|      1|        run_app_frame(&mut app, &ctx, default_input());
 6091|      1|    }
 6092|       |
 6093|       |    #[test]
 6094|      1|    fn test_save_screenshot_image_creates_parent_dir() -> Result<()> {
 6095|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 6096|      1|        let nested = temp_dir.path().join("nested").join("shot.png");
 6097|      1|        let config = ScreenshotConfig {
 6098|      1|            output_path: nested.clone(),
 6099|      1|            viewport_width: 40.0,
 6100|      1|            viewport_height: 30.0,
 6101|      1|            content_only: false,
 6102|      1|            scroll_ratio: None,
 6103|      1|            wait_ms: 0,
 6104|      1|            settle_frames: 0,
 6105|      1|            zoom: 1.0,
 6106|      1|            theme: ScreenshotTheme::Light,
 6107|      1|            font_source: None,
 6108|      1|        };
 6109|      1|        let snapshot = ScreenshotSnapshot {
 6110|      1|            config,
 6111|      1|            content_rect: None,
 6112|      1|            pixels_per_point: 1.0,
 6113|      1|            stable_frames: 0,
 6114|      1|            timed_out: false,
 6115|      1|            pending_renders: false,
 6116|      1|            last_scroll_offset: None,
 6117|      1|            started: Instant::now(),
 6118|      1|        };
 6119|      1|        let image = egui::ColorImage::new([40, 30], Color32::WHITE);
 6120|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
                                                                                 ^0
 6121|      1|        assert!(nested.exists());
 6122|      1|        assert!(nested.with_extension("json").exists());
 6123|      1|        Ok(())
 6124|      1|    }
 6125|       |
 6126|       |    #[test]
 6127|      1|    fn test_handle_screenshot_events_branches() {
 6128|      1|        let mut app = MarkdownViewerApp::new();
 6129|      1|        let ctx = egui::Context::default();
 6130|       |
 6131|      1|        let mut input = default_input();
 6132|      1|        input.events.push(egui::Event::Key {
 6133|      1|            key: egui::Key::A,
 6134|      1|            physical_key: None,
 6135|      1|            pressed: true,
 6136|      1|            repeat: false,
 6137|      1|            modifiers: egui::Modifiers::NONE,
 6138|      1|        });
 6139|      1|        let _ = ctx.run(input, |ctx| {
 6140|      1|            app.handle_screenshot_events(ctx);
 6141|      1|        });
 6142|       |
 6143|      1|        let image = egui::ColorImage::new([10, 10], Color32::WHITE);
 6144|      1|        let mut input = default_input();
 6145|      1|        input.events.push(egui::Event::Screenshot {
 6146|      1|            viewport_id: egui::ViewportId::ROOT,
 6147|      1|            image: std::sync::Arc::new(image),
 6148|      1|        });
 6149|      1|        let _ = ctx.run(input, |ctx| {
 6150|      1|            app.handle_screenshot_events(ctx);
 6151|      1|        });
 6152|       |
 6153|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 6154|      1|        let config = ScreenshotConfig {
 6155|      1|            output_path: temp_dir.path().to_path_buf(),
 6156|      1|            viewport_width: 40.0,
 6157|      1|            viewport_height: 30.0,
 6158|      1|            content_only: false,
 6159|      1|            scroll_ratio: None,
 6160|      1|            wait_ms: 0,
 6161|      1|            settle_frames: 0,
 6162|      1|            zoom: 1.0,
 6163|      1|            theme: ScreenshotTheme::Light,
 6164|      1|            font_source: None,
 6165|      1|        };
 6166|      1|        app.screenshot = Some(ScreenshotState::new(config));
 6167|      1|        let state = app.screenshot.as_mut().expect("screenshot state");
 6168|      1|        state.done = true;
 6169|      1|        let image = egui::ColorImage::new([10, 10], Color32::WHITE);
 6170|      1|        let mut input = default_input();
 6171|      1|        input.events.push(egui::Event::Screenshot {
 6172|      1|            viewport_id: egui::ViewportId::ROOT,
 6173|      1|            image: std::sync::Arc::new(image),
 6174|      1|        });
 6175|      1|        let _ = ctx.run(input, |ctx| {
 6176|      1|            app.handle_screenshot_events(ctx);
 6177|      1|        });
 6178|      1|    }
 6179|       |
 6180|       |    #[test]
 6181|      1|    fn test_screenshot_state_helpers() {
 6182|      1|        let config = ScreenshotConfig {
 6183|      1|            output_path: PathBuf::from("dummy.png"),
 6184|      1|            viewport_width: 120.0,
 6185|      1|            viewport_height: 80.0,
 6186|      1|            content_only: false,
 6187|      1|            scroll_ratio: Some(0.5),
 6188|      1|            wait_ms: 500,
 6189|      1|            settle_frames: 2,
 6190|      1|            zoom: 1.0,
 6191|      1|            theme: ScreenshotTheme::Light,
 6192|      1|            font_source: None,
 6193|      1|        };
 6194|      1|        let mut state = ScreenshotState::new(config);
 6195|      1|        assert!(!state.scroll_ready());
 6196|       |
 6197|      1|        let snapshot = ScrollSnapshot {
 6198|      1|            content_size: egui::vec2(200.0, 400.0),
 6199|      1|            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 200.0)),
 6200|      1|            offset_y: 0.0,
 6201|      1|        };
 6202|      1|        assert!(state.record_scroll(snapshot));
 6203|      1|        assert!(!state.record_scroll(snapshot));
 6204|       |
 6205|      1|        state.update_stability(None, None);
 6206|      1|        state.last_scroll_offset = Some(0.0);
 6207|      1|        state.update_stability(Some(1), Some(10.0));
 6208|      1|    }
 6209|       |
 6210|       |    #[test]
 6211|      1|    fn test_screenshot_is_stable_requires_no_pending() {
 6212|      1|        assert!(MarkdownViewerApp::screenshot_is_stable(true, 2, 2, false));
 6213|      1|        assert!(!MarkdownViewerApp::screenshot_is_stable(true, 2, 2, true));
 6214|      1|        assert!(!MarkdownViewerApp::screenshot_is_stable(false, 2, 2, false));
 6215|      1|        assert!(!MarkdownViewerApp::screenshot_is_stable(true, 1, 2, false));
 6216|      1|    }
 6217|       |
 6218|       |    #[test]
 6219|      1|    fn test_record_scroll_without_ratio_returns_false() {
 6220|      1|        let config = ScreenshotConfig {
 6221|      1|            output_path: PathBuf::from("dummy.png"),
 6222|      1|            viewport_width: 120.0,
 6223|      1|            viewport_height: 80.0,
 6224|      1|            content_only: false,
 6225|      1|            scroll_ratio: None,
 6226|      1|            wait_ms: 500,
 6227|      1|            settle_frames: 2,
 6228|      1|            zoom: 1.0,
 6229|      1|            theme: ScreenshotTheme::Light,
 6230|      1|            font_source: None,
 6231|      1|        };
 6232|      1|        let mut state = ScreenshotState::new(config);
 6233|      1|        let snapshot = ScrollSnapshot {
 6234|      1|            content_size: egui::vec2(200.0, 400.0),
 6235|      1|            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 200.0)),
 6236|      1|            offset_y: 0.0,
 6237|      1|        };
 6238|      1|        assert!(!state.record_scroll(snapshot));
 6239|      1|        assert!(state.scroll_offset.is_none());
 6240|      1|    }
 6241|       |
 6242|       |    #[test]
 6243|      1|    fn test_toggle_write_mode_captures_cursor() {
 6244|      1|        let mut app = MarkdownViewerApp::new();
 6245|      1|        app.view_mode = ViewMode::Raw;
 6246|      1|        app.write_enabled = true;
 6247|       |
 6248|      1|        let ctx = egui::Context::default();
 6249|      1|        let editor_id = egui::Id::new("raw_editor");
 6250|      1|        let mut state = egui::text_edit::TextEditState::default();
 6251|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(2));
 6252|      1|        state.cursor.set_char_range(Some(cr));
 6253|      1|        state.store(&ctx, editor_id);
 6254|       |
 6255|      1|        app.toggle_write_mode(&ctx);
 6256|      1|        assert!(!app.write_enabled);
 6257|      1|        assert_eq!(app.raw_cursor, Some(2));
 6258|      1|    }
 6259|       |
 6260|       |    #[test]
 6261|      1|    fn test_toggle_write_mode_without_text_state() {
 6262|      1|        let mut app = MarkdownViewerApp::new();
 6263|      1|        app.view_mode = ViewMode::Raw;
 6264|      1|        app.write_enabled = true;
 6265|       |
 6266|      1|        let ctx = egui::Context::default();
 6267|      1|        app.toggle_write_mode(&ctx);
 6268|      1|        assert!(!app.write_enabled);
 6269|      1|        assert!(app.raw_cursor.is_none());
 6270|      1|    }
 6271|       |
 6272|       |    #[test]
 6273|      1|    fn test_toggle_write_mode_without_cursor_range() {
 6274|      1|        let mut app = MarkdownViewerApp::new();
 6275|      1|        app.view_mode = ViewMode::Raw;
 6276|      1|        app.write_enabled = true;
 6277|       |
 6278|      1|        let ctx = egui::Context::default();
 6279|      1|        let editor_id = egui::Id::new("raw_editor");
 6280|      1|        let mut state = egui::text_edit::TextEditState::default();
 6281|      1|        state.cursor.set_char_range(None);
 6282|      1|        state.store(&ctx, editor_id);
 6283|       |
 6284|      1|        app.toggle_write_mode(&ctx);
 6285|      1|        assert!(!app.write_enabled);
 6286|      1|        assert!(app.raw_cursor.is_none());
 6287|      1|    }
 6288|       |
 6289|       |    #[test]
 6290|      1|    fn test_move_raw_cursor_lines_moves_to_end() {
 6291|      1|        let mut app = MarkdownViewerApp::new();
 6292|      1|        app.view_mode = ViewMode::Raw;
 6293|      1|        app.write_enabled = true;
 6294|      1|        app.raw_buffer = "Line 1\nLine 2".to_string();
 6295|      1|        app.current_content = app.raw_buffer.clone();
 6296|       |
 6297|      1|        let ctx = egui::Context::default();
 6298|      1|        let editor_id = egui::Id::new("raw_editor");
 6299|      1|        let mut state = egui::text_edit::TextEditState::default();
 6300|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 6301|      1|        state.cursor.set_char_range(Some(cr));
 6302|      1|        state.store(&ctx, editor_id);
 6303|       |
 6304|      1|        app.move_raw_cursor_lines(&ctx, 2);
 6305|      1|        assert_eq!(app.raw_cursor, Some(app.raw_buffer.len()));
 6306|      1|    }
 6307|       |
 6308|       |    #[test]
 6309|      1|    fn test_find_next_uses_last_query() {
 6310|      1|        let mut app = MarkdownViewerApp::new();
 6311|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6312|      1|            "Hello".to_string(),
 6313|      1|        )])];
 6314|      1|        app.search_query.clear();
 6315|      1|        app.last_query = "Hello".to_string();
 6316|       |
 6317|      1|        app.find_next();
 6318|      1|        assert_eq!(app.last_match_index, Some(0));
 6319|      1|    }
 6320|       |
 6321|       |    #[test]
 6322|      1|    fn test_find_previous_wraps_from_start() {
 6323|      1|        let mut app = MarkdownViewerApp::new();
 6324|      1|        app.parsed_elements = vec![
 6325|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
 6326|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("Other".to_string())]),
 6327|       |        ];
 6328|      1|        app.search_query.clear();
 6329|      1|        app.last_query = "Match".to_string();
 6330|      1|        app.last_match_index = Some(0);
 6331|       |
 6332|      1|        app.find_previous();
 6333|      1|        assert_eq!(app.last_match_index, Some(0));
 6334|      1|    }
 6335|       |
 6336|       |    #[test]
 6337|      1|    fn test_set_zoom_scale_on_app() {
 6338|      1|        let mut app = MarkdownViewerApp::new();
 6339|      1|        let before = app.renderer.font_sizes().body;
 6340|      1|        app.set_zoom_scale(1.5);
 6341|      1|        assert_ne!(app.renderer.font_sizes().body, before);
 6342|      1|    }
 6343|       |
 6344|       |    #[test]
 6345|      1|    fn test_handle_file_drop_no_valid_files() {
 6346|      1|        let mut app = MarkdownViewerApp::new();
 6347|      1|        app.handle_file_drop(vec![
 6348|      1|            PathBuf::from("missing1.md"),
 6349|      1|            PathBuf::from("missing2.md"),
 6350|       |        ]);
 6351|      1|        assert!(app
 6352|      1|            .error_message
 6353|      1|            .as_ref()
 6354|      1|            .is_some_and(|msg| msg.contains("No valid files")));
 6355|      1|    }
 6356|       |
 6357|       |    #[test]
 6358|      1|    fn test_compute_window_adjustment_invalid_monitor_returns_none() {
 6359|      1|        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 100.0));
 6360|      1|        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6361|      1|            Some(outer),
 6362|      1|            Some(outer),
 6363|      1|            Some(egui::vec2(0.0, 0.0)),
 6364|       |        );
 6365|      1|        assert!(adjusted.is_none());
 6366|      1|    }
 6367|       |
 6368|       |    #[test]
 6369|      1|    fn test_compute_window_adjustment_invalid_monitor_height_returns_none() {
 6370|      1|        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 100.0));
 6371|      1|        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6372|      1|            Some(outer),
 6373|      1|            Some(outer),
 6374|      1|            Some(egui::vec2(800.0, 0.0)),
 6375|       |        );
 6376|      1|        assert!(adjusted.is_none());
 6377|      1|    }
 6378|       |
 6379|       |    #[test]
 6380|      1|    fn test_compute_window_adjustment_handles_nan_and_clamps() {
 6381|      1|        let outer = egui::Rect::from_min_size(
 6382|      1|            egui::pos2(f32::NAN, f32::NAN),
 6383|      1|            egui::vec2(f32::NAN, f32::NAN),
 6384|       |        );
 6385|      1|        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6386|      1|            Some(outer),
 6387|      1|            Some(outer),
 6388|      1|            Some(egui::vec2(800.0, 600.0)),
 6389|       |        );
 6390|      1|        assert!(adjusted.is_some());
 6391|       |
 6392|      1|        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(5000.0, 4000.0));
 6393|      1|        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6394|      1|            Some(outer),
 6395|      1|            Some(outer),
 6396|      1|            Some(egui::vec2(800.0, 600.0)),
 6397|       |        );
 6398|      1|        assert!(adjusted.is_some());
 6399|      1|    }
 6400|       |
 6401|       |    #[test]
 6402|      1|    fn test_compute_window_adjustment_invalid_pos_only() {
 6403|      1|        let outer = egui::Rect::from_min_size(egui::pos2(f32::NAN, 0.0), egui::vec2(800.0, 600.0));
 6404|      1|        let inner = egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(800.0, 600.0));
 6405|      1|        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6406|      1|            Some(outer),
 6407|      1|            Some(inner),
 6408|      1|            Some(egui::vec2(1200.0, 900.0)),
 6409|       |        )
 6410|      1|        .expect("adjustment");
 6411|      1|        assert!(adjusted.pos.is_some());
 6412|      1|        assert!(adjusted.size.is_none());
 6413|      1|    }
 6414|       |
 6415|       |    #[test]
 6416|      1|    fn test_compute_window_adjustment_invalid_pos_y_only() {
 6417|      1|        let outer = egui::Rect::from_min_size(egui::pos2(0.0, f32::NAN), egui::vec2(800.0, 600.0));
 6418|      1|        let inner = egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(800.0, 600.0));
 6419|      1|        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6420|      1|            Some(outer),
 6421|      1|            Some(inner),
 6422|      1|            Some(egui::vec2(1200.0, 900.0)),
 6423|       |        )
 6424|      1|        .expect("adjustment");
 6425|      1|        assert!(adjusted.pos.is_some());
 6426|      1|        assert!(adjusted.size.is_none());
 6427|      1|    }
 6428|       |
 6429|       |    #[test]
 6430|      1|    fn test_compute_window_adjustment_invalid_size_only() {
 6431|      1|        let outer = egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(800.0, f32::NAN));
 6432|      1|        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 6433|      1|            Some(outer),
 6434|      1|            Some(outer),
 6435|      1|            Some(egui::vec2(1200.0, 900.0)),
 6436|       |        )
 6437|      1|        .expect("adjustment");
 6438|      1|        assert!(adjusted.pos.is_none());
 6439|      1|        assert!(adjusted.size.is_some());
 6440|      1|    }
 6441|       |
 6442|       |    #[test]
 6443|      1|    fn test_push_history_caps_max() {
 6444|      1|        let mut app = MarkdownViewerApp::new();
 6445|      1|        app.max_history = 1;
 6446|      1|        app.current_content = "First".to_string();
 6447|      1|        app.title = "First".to_string();
 6448|      1|        app.push_history();
 6449|       |
 6450|      1|        app.current_content = "Second".to_string();
 6451|      1|        app.title = "Second".to_string();
 6452|      1|        app.push_history();
 6453|       |
 6454|      1|        assert_eq!(app.history.len(), 1);
 6455|      1|        assert_eq!(app.history[0].content, "Second");
 6456|      1|    }
 6457|       |
 6458|       |    #[test]
 6459|      1|    fn test_navigate_forward_pending_error() {
 6460|      1|        let mut app = MarkdownViewerApp::new();
 6461|      1|        let _forced = ForcedLoadError::new();
 6462|      1|        app.pending_files.push_back(PathBuf::from("missing.md"));
 6463|       |
 6464|      1|        assert!(app.navigate_forward());
 6465|      1|        assert!(app.error_message.is_some());
 6466|      1|    }
 6467|       |
 6468|       |    #[test]
 6469|      1|    fn test_navigate_forward_history() {
 6470|      1|        let mut app = MarkdownViewerApp::new();
 6471|      1|        app.history = vec![
 6472|      1|            HistoryEntry {
 6473|      1|                file_path: None,
 6474|      1|                title: "One".to_string(),
 6475|      1|                content: "One".to_string(),
 6476|      1|            },
 6477|      1|            HistoryEntry {
 6478|      1|                file_path: None,
 6479|      1|                title: "Two".to_string(),
 6480|      1|                content: "Two".to_string(),
 6481|      1|            },
 6482|       |        ];
 6483|      1|        app.history_index = 0;
 6484|       |
 6485|      1|        assert!(app.navigate_forward());
 6486|      1|        assert_eq!(app.history_index, 1);
 6487|      1|        assert_eq!(app.current_content, "Two");
 6488|      1|    }
 6489|       |
 6490|       |    #[test]
 6491|      1|    fn test_restore_from_history_parse_error() {
 6492|      1|        let mut app = MarkdownViewerApp::new();
 6493|      1|        app.history = vec![HistoryEntry {
 6494|      1|            file_path: None,
 6495|      1|            title: "Bad".to_string(),
 6496|      1|            content: "Bad".to_string(),
 6497|      1|        }];
 6498|      1|        app.history_index = 0;
 6499|      1|        crate::markdown_renderer::force_parse_error_once();
 6500|       |
 6501|      1|        app.restore_from_history();
 6502|      1|        assert!(app.error_message.is_some());
 6503|      1|    }
 6504|       |
 6505|       |    #[test]
 6506|      1|    fn test_open_file_dialog_load_error() -> Result<()> {
 6507|      1|        let mut app = MarkdownViewerApp::new();
 6508|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 6509|      1|        let open_path = temp_dir.path().join("open.md");
 6510|      1|        std::fs::write(&open_path, "# Open")?;
                                                          ^0
 6511|      1|        let _forced_path = ForcedDialogPaths::new(Some(open_path), None);
 6512|      1|        let _forced_load = ForcedLoadError::new();
 6513|       |
 6514|      1|        app.open_file_dialog();
 6515|      1|        assert!(app
 6516|      1|            .error_message
 6517|      1|            .as_ref()
 6518|      1|            .is_some_and(|msg| msg.contains("Failed to open file")));
 6519|      1|        Ok(())
 6520|      1|    }
 6521|       |
 6522|       |    #[test]
 6523|      1|    fn test_toggle_view_mode_captures_cursor() {
 6524|      1|        let mut app = MarkdownViewerApp::new();
 6525|      1|        app.view_mode = ViewMode::Raw;
 6526|      1|        app.write_enabled = true;
 6527|       |
 6528|      1|        let ctx = egui::Context::default();
 6529|      1|        let editor_id = egui::Id::new("raw_editor");
 6530|      1|        let mut state = egui::text_edit::TextEditState::default();
 6531|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(4));
 6532|      1|        state.cursor.set_char_range(Some(cr));
 6533|      1|        state.store(&ctx, editor_id);
 6534|       |
 6535|      1|        app.toggle_view_mode(&ctx);
 6536|      1|        assert_eq!(app.raw_cursor, Some(4));
 6537|      1|        assert_eq!(app.view_mode, ViewMode::Rendered);
 6538|      1|    }
 6539|       |
 6540|       |    #[test]
 6541|      1|    fn test_handle_shortcuts_shift_f3_triggers_previous() {
 6542|      1|        let mut app = MarkdownViewerApp::new();
 6543|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6544|      1|            "Nav".to_string(),
 6545|      1|        )])];
 6546|      1|        app.search_query = "Nav".to_string();
 6547|       |
 6548|      1|        let mut input = default_input();
 6549|      1|        input.modifiers = egui::Modifiers::SHIFT;
 6550|      1|        input.events.push(egui::Event::Key {
 6551|      1|            key: egui::Key::F3,
 6552|      1|            physical_key: None,
 6553|      1|            pressed: true,
 6554|      1|            repeat: false,
 6555|      1|            modifiers: egui::Modifiers::SHIFT,
 6556|      1|        });
 6557|       |
 6558|      1|        let ctx = egui::Context::default();
 6559|      1|        let _ = ctx.run(input, |ctx| {
 6560|      1|            app.handle_shortcuts(ctx);
 6561|      1|        });
 6562|       |
 6563|      1|        assert_eq!(app.last_match_index, Some(0));
 6564|      1|    }
 6565|       |
 6566|       |    #[test]
 6567|      1|    fn test_handle_shortcuts_f3_triggers_next() {
 6568|      1|        let mut app = MarkdownViewerApp::new();
 6569|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6570|      1|            "Nav".to_string(),
 6571|      1|        )])];
 6572|      1|        app.search_query = "Nav".to_string();
 6573|       |
 6574|      1|        let mut input = default_input();
 6575|      1|        input.events.push(egui::Event::Key {
 6576|      1|            key: egui::Key::F3,
 6577|      1|            physical_key: None,
 6578|      1|            pressed: true,
 6579|      1|            repeat: false,
 6580|      1|            modifiers: egui::Modifiers::NONE,
 6581|      1|        });
 6582|       |
 6583|      1|        let ctx = egui::Context::default();
 6584|      1|        let _ = ctx.run(input, |ctx| {
 6585|      1|            app.handle_shortcuts(ctx);
 6586|      1|        });
 6587|       |
 6588|      1|        assert_eq!(app.last_match_index, Some(0));
 6589|      1|    }
 6590|       |
 6591|       |    #[test]
 6592|      1|    fn test_handle_shortcuts_alt_f3_triggers_previous() {
 6593|      1|        let mut app = MarkdownViewerApp::new();
 6594|      1|        app.parsed_elements = vec![
 6595|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
 6596|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
 6597|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
 6598|       |        ];
 6599|      1|        app.search_query = "Match".to_string();
 6600|      1|        app.last_match_index = Some(1);
 6601|      1|        app.pending_scroll_to_element = None;
 6602|       |
 6603|      1|        let mut input = default_input();
 6604|      1|        input.modifiers = egui::Modifiers::ALT;
 6605|      1|        input.events.push(egui::Event::Key {
 6606|      1|            key: egui::Key::F3,
 6607|      1|            physical_key: None,
 6608|      1|            pressed: true,
 6609|      1|            repeat: false,
 6610|      1|            modifiers: egui::Modifiers::ALT,
 6611|      1|        });
 6612|       |
 6613|      1|        let ctx = egui::Context::default();
 6614|      1|        let _ = ctx.run(input, |ctx| {
 6615|      1|            app.handle_shortcuts(ctx);
 6616|      1|        });
 6617|       |
 6618|      1|        assert_eq!(app.last_match_index, Some(0));
 6619|      1|        assert_eq!(app.pending_scroll_to_element, Some(0));
 6620|      1|    }
 6621|       |
 6622|       |    #[test]
 6623|      1|    fn test_render_file_menu_save_error_sets_message() {
 6624|      1|        let mut app = MarkdownViewerApp::new();
 6625|      1|        app.current_file = Some(PathBuf::from("missing_dir\\save.md"));
 6626|      1|        app.current_content = "Data".to_string();
 6627|      1|        let _actions = ForcedAppActions::new(&["menu_save"]);
 6628|       |
 6629|      1|        let ctx = egui::Context::default();
 6630|      1|        let _ = ctx.run(default_input(), |ctx| {
 6631|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 6632|      1|                app.render_file_menu_contents(ui, false, Color32::WHITE);
 6633|      1|            });
 6634|      1|        });
 6635|       |
 6636|      1|        assert!(app.error_message.is_some());
 6637|      1|    }
 6638|       |
 6639|       |    #[test]
 6640|      1|    fn test_menu_text_with_mnemonic_prefix_and_underline() {
 6641|      1|        let job = MarkdownViewerApp::menu_text_with_mnemonic(
 6642|      1|            Some("Alt+"),
 6643|      1|            "Open",
 6644|       |            'O',
 6645|       |            true,
 6646|       |            Color32::WHITE,
 6647|       |        );
 6648|      1|        assert!(!job.sections.is_empty());
 6649|      1|    }
 6650|       |
 6651|       |    #[test]
 6652|      1|    fn test_menu_text_with_mnemonic_no_underline() {
 6653|      1|        let job =
 6654|      1|            MarkdownViewerApp::menu_text_with_mnemonic(None, "Save", 'S', false, Color32::WHITE);
 6655|      1|        assert!(!job.sections.is_empty());
 6656|      1|    }
 6657|       |
 6658|       |    #[test]
 6659|      1|    fn test_menu_text_with_mnemonic_missing_character() {
 6660|      1|        let job =
 6661|      1|            MarkdownViewerApp::menu_text_with_mnemonic(None, "Save", 'Z', true, Color32::WHITE);
 6662|      1|        assert!(!job.sections.is_empty());
 6663|      1|    }
 6664|       |
 6665|       |    #[test]
 6666|      1|    fn test_persist_window_state_no_change_returns_early() {
 6667|      1|        let mut app = MarkdownViewerApp::new();
 6668|      1|        app.last_window_pos = Some([10.0, 10.0]);
 6669|      1|        app.last_window_size = Some([800.0, 600.0]);
 6670|      1|        app.last_window_maximized = false;
 6671|      1|        app.last_persisted_state = Some(WindowState {
 6672|      1|            pos: [10.0, 10.0],
 6673|      1|            size: [800.0, 600.0],
 6674|      1|            maximized: false,
 6675|      1|        });
 6676|       |
 6677|      1|        app.persist_window_state();
 6678|      1|        assert!(app.last_persisted_state.is_some());
 6679|      1|    }
 6680|       |
 6681|       |    #[test]
 6682|      1|    fn test_persist_window_state_without_window_state() {
 6683|      1|        let mut app = MarkdownViewerApp::new();
 6684|      1|        app.last_window_pos = None;
 6685|      1|        app.last_window_size = None;
 6686|       |
 6687|      1|        app.persist_window_state();
 6688|      1|        assert!(app.last_persisted_state.is_none());
 6689|      1|    }
 6690|       |
 6691|       |    #[test]
 6692|      1|    fn test_persist_window_state_save_failure() {
 6693|      1|        let _lock = env_lock();
 6694|      1|        let temp_file = NamedTempFile::new().expect("temp file");
 6695|      1|        let _guard = EnvGuard::set("APPDATA", temp_file.path().to_string_lossy().as_ref());
 6696|       |
 6697|      1|        let mut app = MarkdownViewerApp::new();
 6698|      1|        app.last_window_pos = Some([10.0, 10.0]);
 6699|      1|        app.last_window_size = Some([800.0, 600.0]);
 6700|      1|        app.last_window_maximized = false;
 6701|       |
 6702|      1|        app.persist_window_state();
 6703|      1|        assert!(app.last_persisted_state.is_none());
 6704|      1|    }
 6705|       |
 6706|       |    #[test]
 6707|      1|    fn test_should_persist_window_state_screenshot_blocks() {
 6708|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 6709|      1|        let config = ScreenshotConfig {
 6710|      1|            output_path: temp_dir.path().join("shot.png"),
 6711|      1|            viewport_width: 80.0,
 6712|      1|            viewport_height: 60.0,
 6713|      1|            content_only: false,
 6714|      1|            scroll_ratio: None,
 6715|      1|            wait_ms: 0,
 6716|      1|            settle_frames: 0,
 6717|      1|            zoom: 1.0,
 6718|      1|            theme: ScreenshotTheme::Light,
 6719|      1|            font_source: None,
 6720|      1|        };
 6721|      1|        let mut app = MarkdownViewerApp::new();
 6722|      1|        app.screenshot = Some(ScreenshotState::new(config));
 6723|      1|        assert!(!app.should_persist_window_state());
 6724|      1|    }
 6725|       |
 6726|       |    #[test]
 6727|      1|    fn test_should_persist_window_state_recently_persisted() {
 6728|      1|        let mut app = MarkdownViewerApp::new();
 6729|      1|        app.last_window_pos = Some([10.0, 10.0]);
 6730|      1|        app.last_window_size = Some([800.0, 600.0]);
 6731|      1|        app.last_persist_instant = std::time::Instant::now();
 6732|      1|        assert!(!app.should_persist_window_state());
 6733|      1|    }
 6734|       |
 6735|       |    #[test]
 6736|      1|    fn test_should_persist_window_state_without_window_state() {
 6737|      1|        let mut app = MarkdownViewerApp::new();
 6738|      1|        app.last_persist_instant = std::time::Instant::now() - std::time::Duration::from_secs(2);
 6739|      1|        assert!(!app.should_persist_window_state());
 6740|      1|    }
 6741|       |
 6742|       |    #[test]
 6743|      1|    fn test_should_persist_window_state_when_changed() {
 6744|      1|        let mut app = MarkdownViewerApp::new();
 6745|      1|        app.last_window_pos = Some([10.0, 10.0]);
 6746|      1|        app.last_window_size = Some([800.0, 600.0]);
 6747|      1|        app.last_persist_instant = std::time::Instant::now() - std::time::Duration::from_secs(2);
 6748|       |
 6749|      1|        assert!(app.should_persist_window_state());
 6750|      1|    }
 6751|       |
 6752|       |    #[test]
 6753|      1|    fn test_update_impl_persists_window_state_when_due() {
 6754|      1|        let _lock = env_lock();
 6755|      1|        let temp_dir = TempDir::new().expect("temp dir");
 6756|      1|        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());
 6757|       |
 6758|      1|        let mut app = MarkdownViewerApp::new();
 6759|      1|        app.last_persist_instant = std::time::Instant::now() - std::time::Duration::from_secs(2);
 6760|       |
 6761|      1|        let ctx = egui::Context::default();
 6762|      1|        let mut input = default_input();
 6763|      1|        let vp = input
 6764|      1|            .viewports
 6765|      1|            .get_mut(&egui::ViewportId::ROOT)
 6766|      1|            .expect("root viewport");
 6767|      1|        vp.monitor_size = Some(egui::vec2(1024.0, 768.0));
 6768|      1|        vp.outer_rect = Some(egui::Rect::from_min_size(
 6769|      1|            egui::pos2(10.0, 10.0),
 6770|      1|            egui::vec2(800.0, 600.0),
 6771|      1|        ));
 6772|      1|        vp.inner_rect = Some(egui::Rect::from_min_size(
 6773|      1|            egui::pos2(20.0, 20.0),
 6774|      1|            egui::vec2(780.0, 580.0),
 6775|      1|        ));
 6776|      1|        vp.fullscreen = Some(false);
 6777|      1|        vp.maximized = Some(false);
 6778|       |
 6779|      1|        run_app_frame(&mut app, &ctx, input);
 6780|       |
 6781|      1|        let path = temp_dir
 6782|      1|            .path()
 6783|      1|            .join("MarkdownView")
 6784|      1|            .join("window_state.txt");
 6785|      1|        assert!(path.exists());
 6786|      1|        assert!(app.last_persisted_state.is_some());
 6787|      1|    }
 6788|       |
 6789|       |    #[test]
 6790|      1|    fn test_update_impl_fullscreen_skips_size_persist() {
 6791|      1|        let mut app = MarkdownViewerApp::new();
 6792|      1|        app.last_window_size = None;
 6793|       |
 6794|      1|        let ctx = egui::Context::default();
 6795|      1|        let mut input = default_input();
 6796|      1|        let vp = input
 6797|      1|            .viewports
 6798|      1|            .get_mut(&egui::ViewportId::ROOT)
 6799|      1|            .expect("root viewport");
 6800|      1|        vp.monitor_size = Some(egui::vec2(1024.0, 768.0));
 6801|      1|        vp.outer_rect = Some(egui::Rect::from_min_size(
 6802|      1|            egui::pos2(10.0, 10.0),
 6803|      1|            egui::vec2(800.0, 600.0),
 6804|      1|        ));
 6805|      1|        vp.inner_rect = Some(egui::Rect::from_min_size(
 6806|      1|            egui::pos2(20.0, 20.0),
 6807|      1|            egui::vec2(780.0, 580.0),
 6808|      1|        ));
 6809|      1|        vp.fullscreen = Some(true);
 6810|      1|        vp.maximized = Some(false);
 6811|       |
 6812|      1|        run_app_frame(&mut app, &ctx, input);
 6813|       |
 6814|      1|        assert!(app.last_window_size.is_none());
 6815|      1|    }
 6816|       |
 6817|       |    #[test]
 6818|      1|    fn test_update_impl_reload_with_file_succeeds() -> Result<()> {
 6819|      1|        let mut app = MarkdownViewerApp::new();
 6820|      1|        let mut temp_file = tempfile::Builder::new().suffix(".md").tempfile()?;
                                                                                           ^0
 6821|      1|        temp_file.write_all(b"# Reloaded")?;
                                                        ^0
 6822|      1|        temp_file.flush()?;
                                       ^0
 6823|      1|        app.current_file = Some(temp_file.path().to_path_buf());
 6824|      1|        app.reload_requested = true;
 6825|       |
 6826|      1|        let ctx = egui::Context::default();
 6827|      1|        let input = default_input();
 6828|      1|        run_app_frame(&mut app, &ctx, input);
 6829|       |
 6830|      1|        assert!(app.error_message.is_none());
 6831|      1|        Ok(())
 6832|      1|    }
 6833|       |
 6834|       |    #[test]
 6835|      1|    fn test_save_current_document_parentless_path() -> Result<()> {
 6836|      1|        let mut app = MarkdownViewerApp::new();
 6837|      1|        app.current_content = "Saved".to_string();
 6838|      1|        let filename = format!("save_parentless_{}.md", std::process::id());
 6839|      1|        let _forced = ForcedDialogPaths::new(None, Some(PathBuf::from(&filename)));
 6840|       |
 6841|      1|        app.save_current_document()?;
                                                 ^0
 6842|      1|        assert_eq!(app.current_file, Some(PathBuf::from(&filename)));
 6843|      1|        std::fs::remove_file(&filename)?;
                                                     ^0
 6844|      1|        Ok(())
 6845|      1|    }
 6846|       |
 6847|       |    #[test]
 6848|      1|    fn test_update_search_results_wraps() {
 6849|      1|        let mut app = MarkdownViewerApp::new();
 6850|      1|        app.parsed_elements = vec![
 6851|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
 6852|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("Other".to_string())]),
 6853|       |        ];
 6854|      1|        app.search_query = "Match".to_string();
 6855|      1|        app.last_match_index = Some(1);
 6856|       |
 6857|      1|        app.update_search_results("");
 6858|      1|        assert_eq!(app.last_match_index, Some(0));
 6859|      1|    }
 6860|       |
 6861|       |    #[test]
 6862|      1|    fn test_handle_screenshot_events_save_error() {
 6863|      1|        let mut app = MarkdownViewerApp::new();
 6864|      1|        let ctx = egui::Context::default();
 6865|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 6866|      1|        let config = ScreenshotConfig {
 6867|      1|            output_path: temp_dir.path().to_path_buf(),
 6868|      1|            viewport_width: 40.0,
 6869|      1|            viewport_height: 30.0,
 6870|      1|            content_only: false,
 6871|      1|            scroll_ratio: None,
 6872|      1|            wait_ms: 0,
 6873|      1|            settle_frames: 0,
 6874|      1|            zoom: 1.0,
 6875|      1|            theme: ScreenshotTheme::Light,
 6876|      1|            font_source: None,
 6877|      1|        };
 6878|      1|        app.screenshot = Some(ScreenshotState::new(config));
 6879|       |
 6880|      1|        let image = egui::ColorImage::new([10, 10], Color32::WHITE);
 6881|      1|        let mut input = default_input();
 6882|      1|        input.events.push(egui::Event::Screenshot {
 6883|      1|            viewport_id: egui::ViewportId::ROOT,
 6884|      1|            image: std::sync::Arc::new(image),
 6885|      1|        });
 6886|      1|        let _ = ctx.run(input, |ctx| {
 6887|      1|            app.handle_screenshot_events(ctx);
 6888|      1|        });
 6889|       |
 6890|      1|        assert!(app.screenshot.as_ref().is_some_and(|state| state.done));
 6891|      1|    }
 6892|       |
 6893|       |    #[test]
 6894|      1|    fn test_update_screenshot_state_requests_repaint() {
 6895|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 6896|      1|        let config = ScreenshotConfig {
 6897|      1|            output_path: temp_dir.path().join("shot.png"),
 6898|      1|            viewport_width: 200.0,
 6899|      1|            viewport_height: 100.0,
 6900|      1|            content_only: false,
 6901|      1|            scroll_ratio: Some(0.5),
 6902|      1|            wait_ms: 1000,
 6903|      1|            settle_frames: 5,
 6904|      1|            zoom: 1.0,
 6905|      1|            theme: ScreenshotTheme::Light,
 6906|      1|            font_source: None,
 6907|      1|        };
 6908|      1|        let mut app = MarkdownViewerApp::new();
 6909|      1|        app.screenshot = Some(ScreenshotState::new(config));
 6910|       |
 6911|      1|        let ctx = egui::Context::default();
 6912|      1|        app.update_screenshot_state(&ctx, None, None);
 6913|      1|    }
 6914|       |
 6915|       |    #[test]
 6916|      1|    fn test_update_screenshot_state_requested_done_skips_repaint() {
 6917|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 6918|      1|        let config = ScreenshotConfig {
 6919|      1|            output_path: temp_dir.path().join("shot.png"),
 6920|      1|            viewport_width: 200.0,
 6921|      1|            viewport_height: 100.0,
 6922|      1|            content_only: false,
 6923|      1|            scroll_ratio: None,
 6924|      1|            wait_ms: 1000,
 6925|      1|            settle_frames: 0,
 6926|      1|            zoom: 1.0,
 6927|      1|            theme: ScreenshotTheme::Light,
 6928|      1|            font_source: None,
 6929|      1|        };
 6930|      1|        let mut state = ScreenshotState::new(config);
 6931|      1|        state.requested = true;
 6932|      1|        state.done = true;
 6933|       |
 6934|      1|        let mut app = MarkdownViewerApp::new();
 6935|      1|        app.screenshot = Some(state);
 6936|       |
 6937|      1|        let ctx = egui::Context::default();
 6938|      1|        app.update_screenshot_state(&ctx, None, None);
 6939|       |
 6940|      1|        let state = app.screenshot.as_ref().expect("screenshot state");
 6941|      1|        assert!(state.requested);
 6942|      1|        assert!(state.done);
 6943|      1|    }
 6944|       |
 6945|       |    #[test]
 6946|      1|    fn test_env_guard_removes_unset_key() {
 6947|      1|        let _lock = env_lock();
 6948|      1|        std::env::remove_var("MDMDVIEW_TMP_ENV");
 6949|      1|        {
 6950|      1|            let _guard = EnvGuard::set("MDMDVIEW_TMP_ENV", "value");
 6951|      1|        }
 6952|      1|        assert!(std::env::var("MDMDVIEW_TMP_ENV").is_err());
 6953|      1|    }
 6954|       |}


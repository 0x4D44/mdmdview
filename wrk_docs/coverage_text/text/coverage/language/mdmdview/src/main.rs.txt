Coverage Report
Created: 2026-01-13 12:48
C:\language\mdmdview\src\main.rs:
    1|       |#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")] // Hide console in release mode
    2|       |
    3|       |#[cfg(not(test))]
    4|       |use mdmdview::app::{ScreenshotConfig, ScreenshotTheme};
    5|       |/// Main entry point for the MarkdownView application
    6|       |///
    7|       |/// A simple, standalone markdown viewer for Windows built with Rust and egui.
    8|       |/// This application provides a clean interface for viewing markdown files with
    9|       |/// syntax highlighting, embedded samples, and essential viewing features.
   10|       |#[cfg(not(test))]
   11|       |use mdmdview::{load_window_state, sanitize_window_state, MarkdownViewerApp, APP_TITLE_PREFIX};
   12|       |#[cfg(not(test))]
   13|       |use std::path::Path;
   14|       |use std::path::PathBuf;
   15|       |
   16|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
   17|       |enum ThemeChoice {
   18|       |    Light,
   19|       |    Dark,
   20|       |}
   21|       |
   22|       |#[derive(Default)]
   23|       |struct CliOptions {
   24|       |    initial_file: Option<PathBuf>,
   25|       |    screenshot: bool,
   26|       |    screenshot_output: Option<PathBuf>,
   27|       |    width: Option<f32>,
   28|       |    height: Option<f32>,
   29|       |    theme: Option<ThemeChoice>,
   30|       |    zoom: Option<f32>,
   31|       |    content_only: bool,
   32|       |    scroll: Option<f32>,
   33|       |    wait_ms: Option<u64>,
   34|       |    settle_frames: Option<u32>,
   35|       |    test_fonts: Option<PathBuf>,
   36|       |}
   37|       |
   38|       |#[cfg(not(test))]
   39|       |fn parse_cli_args() -> Result<CliOptions, String> {
   40|       |    parse_cli_from(std::env::args().skip(1))
   41|       |}
   42|       |
   43|     10|fn parse_cli_from<I>(args: I) -> Result<CliOptions, String>
   44|     10|where
   45|     10|    I: IntoIterator<Item = String>,
   46|       |{
   47|     10|    let mut opts = CliOptions::default();
   48|     10|    let mut iter = args.into_iter();
   49|       |
   50|     30|    while let Some(arg) = iter.next() {
                                 ^24
   51|     24|        match arg.as_str() {
   52|     24|            "--screenshot" => {
   53|      4|                opts.screenshot = true;
   54|      4|                let value = next_value(&mut iter, "--screenshot")?;
                                  ^3                                           ^1
   55|      3|                opts.initial_file = Some(PathBuf::from(value));
   56|       |            }
   57|     20|            "--output" => {
   58|      2|                let value = next_value(&mut iter, "--output")?;
                                                                           ^0
   59|      2|                opts.screenshot_output = Some(PathBuf::from(value));
   60|       |            }
   61|     18|            "--width" => {
   62|      2|                let value = next_value(&mut iter, "--width")?;
                                                                          ^0
   63|      2|                opts.width = Some(parse_f32("--width", &value)?);
                                                                            ^1
   64|       |            }
   65|     16|            "--height" => {
   66|      2|                let value = next_value(&mut iter, "--height")?;
                                  ^1                                       ^1
   67|      1|                opts.height = Some(parse_f32("--height", &value)?);
                                                                              ^0
   68|       |            }
   69|     14|            "--theme" => {
   70|      3|                let value = next_value(&mut iter, "--theme")?;
                                                                          ^0
   71|      3|                opts.theme = Some(parse_theme(&value)?);
                                                                   ^1
   72|       |            }
   73|     11|            "--zoom" => {
   74|      1|                let value = next_value(&mut iter, "--zoom")?;
                                                                         ^0
   75|      1|                opts.zoom = Some(parse_f32("--zoom", &value)?);
                                                                          ^0
   76|       |            }
   77|     10|            "--content-only" => opts.content_only = true,
                                              ^1
   78|      9|            "--scroll" => {
   79|      2|                let value = next_value(&mut iter, "--scroll")?;
                                                                           ^0
   80|      2|                let ratio = parse_f32("--scroll", &value)?.clamp(0.0, 1.0);
                                                                       ^0
   81|      2|                opts.scroll = Some(ratio);
   82|       |            }
   83|      7|            "--wait-ms" => {
   84|      1|                let value = next_value(&mut iter, "--wait-ms")?;
                                                                            ^0
   85|      1|                opts.wait_ms = Some(parse_u64("--wait-ms", &value)?);
                                                                                ^0
   86|       |            }
   87|      6|            "--settle-frames" => {
   88|      1|                let value = next_value(&mut iter, "--settle-frames")?;
                                                                                  ^0
   89|      1|                opts.settle_frames = Some(parse_u32("--settle-frames", &value)?);
                                                                                            ^0
   90|       |            }
   91|      5|            "--test-fonts" => {
   92|      1|                let value = next_value(&mut iter, "--test-fonts")?;
                                                                               ^0
   93|      1|                opts.test_fonts = Some(PathBuf::from(value));
   94|       |            }
   95|      4|            _ if opts.initial_file.is_none() => opts.initial_file = Some(PathBuf::from(arg)),
                                                         ^3   ^3
   96|      1|            _ => {}
   97|       |        }
   98|       |    }
   99|       |
  100|      6|    if opts.screenshot && opts.screenshot_output.is_none() {
                                        ^3                     ^3
  101|      1|        return Err("Missing --output for screenshot mode".to_string());
  102|      5|    }
  103|       |
  104|      5|    Ok(opts)
  105|     10|}
  106|       |
  107|     19|fn next_value<I>(iter: &mut I, flag: &str) -> Result<String, String>
  108|     19|where
  109|     19|    I: Iterator<Item = String>,
  110|       |{
  111|     19|    iter.next()
  112|     19|        .ok_or_else(|| format!("{flag} requires a value"))
                                     ^2      ^2
  113|     19|}
  114|       |
  115|      3|fn parse_theme(value: &str) -> Result<ThemeChoice, String> {
  116|      3|    match value.trim().to_ascii_lowercase().as_str() {
  117|      3|        "light" => Ok(ThemeChoice::Light),
                                 ^1
  118|      2|        "dark" => Ok(ThemeChoice::Dark),
                                ^1
  119|      1|        _ => Err(format!("Unsupported theme: {value}")),
  120|       |    }
  121|      3|}
  122|       |
  123|      4|fn parse_hex_color32(value: &str) -> Option<egui::Color32> {
  124|      4|    let hex = value.trim().trim_start_matches('#');
  125|      4|    if hex.len() != 6 {
  126|      2|        return None;
  127|      2|    }
  128|      2|    let r = u8::from_str_radix(&hex[0..2], 16).ok()?;
                                                                 ^0
  129|      2|    let g = u8::from_str_radix(&hex[2..4], 16).ok()?;
                                                                 ^0
  130|      2|    let b = u8::from_str_radix(&hex[4..6], 16).ok()?;
                                                                 ^0
  131|      2|    Some(egui::Color32::from_rgb(r, g, b))
  132|      4|}
  133|       |
  134|      3|fn screenshot_background_color() -> egui::Color32 {
  135|      3|    if let Ok(hex) = std::env::var("MDMDVIEW_MERMAID_MAIN_BKG") {
                            ^2
  136|      2|        if let Some(color) = parse_hex_color32(&hex) {
                                  ^1
  137|      1|            return color;
  138|      1|        }
  139|      1|    }
  140|      2|    egui::Color32::from_rgb(255, 248, 219)
  141|      3|}
  142|       |
  143|      6|fn parse_f32(flag: &str, value: &str) -> Result<f32, String> {
  144|      6|    value
  145|      6|        .parse::<f32>()
  146|      6|        .map_err(|_| format!("Invalid {flag} value: {value}"))
                                   ^1      ^1
  147|      6|}
  148|       |
  149|      3|fn parse_u32(flag: &str, value: &str) -> Result<u32, String> {
  150|      3|    value
  151|      3|        .parse::<u32>()
  152|      3|        .map_err(|_| format!("Invalid {flag} value: {value}"))
                                   ^1      ^1
  153|      3|}
  154|       |
  155|      3|fn parse_u64(flag: &str, value: &str) -> Result<u64, String> {
  156|      3|    value
  157|      3|        .parse::<u64>()
  158|      3|        .map_err(|_| format!("Invalid {flag} value: {value}"))
                                   ^1      ^1
  159|      3|}
  160|       |
  161|       |#[cfg(not(test))]
  162|       |fn load_fonts_from_dir(ctx: &egui::Context, dir: &Path) -> Result<(), String> {
  163|       |    let mut font_paths: Vec<PathBuf> = std::fs::read_dir(dir)
  164|       |        .map_err(|e| format!("Failed to read font dir {dir:?}: {e}"))?
  165|       |        .filter_map(|entry| entry.ok().map(|e| e.path()))
  166|       |        .filter(|path| {
  167|       |            path.extension()
  168|       |                .and_then(|ext| ext.to_str())
  169|       |                .map(|ext| matches!(ext.to_ascii_lowercase().as_str(), "ttf" | "otf"))
  170|       |                .unwrap_or(false)
  171|       |        })
  172|       |        .collect();
  173|       |
  174|       |    if font_paths.is_empty() {
  175|       |        return Err(format!("No font files found in {dir:?}"));
  176|       |    }
  177|       |
  178|       |    font_paths.sort_by(|a, b| a.to_string_lossy().cmp(&b.to_string_lossy()));
  179|       |
  180|       |    let mut fonts = egui::FontDefinitions::default();
  181|       |    let mut prop_names = Vec::new();
  182|       |    let mut mono_names = Vec::new();
  183|       |    let mut used_names = std::collections::HashSet::new();
  184|       |
  185|       |    for path in font_paths {
  186|       |        let bytes =
  187|       |            std::fs::read(&path).map_err(|e| format!("Failed to read font {path:?}: {e}"))?;
  188|       |        let name = path
  189|       |            .file_stem()
  190|       |            .and_then(|stem| stem.to_str())
  191|       |            .map(|stem| stem.to_string())
  192|       |            .unwrap_or_else(|| format!("font-{}", prop_names.len() + mono_names.len()));
  193|       |        let base = format!("test-{name}");
  194|       |        let mut name = base.clone();
  195|       |        let mut counter = 1usize;
  196|       |        while used_names.contains(&name) {
  197|       |            name = format!("{base}-{counter}");
  198|       |            counter += 1;
  199|       |        }
  200|       |        used_names.insert(name.clone());
  201|       |
  202|       |        fonts
  203|       |            .font_data
  204|       |            .insert(name.clone(), egui::FontData::from_owned(bytes));
  205|       |
  206|       |        let lower = name.to_ascii_lowercase();
  207|       |        if lower.contains("mono") || lower.contains("code") {
  208|       |            mono_names.push(name);
  209|       |        } else {
  210|       |            prop_names.push(name);
  211|       |        }
  212|       |    }
  213|       |
  214|       |    if prop_names.is_empty() {
  215|       |        prop_names = mono_names.clone();
  216|       |    }
  217|       |    if mono_names.is_empty() {
  218|       |        mono_names = prop_names.clone();
  219|       |    }
  220|       |
  221|       |    if let Some(family) = fonts.families.get_mut(&egui::FontFamily::Proportional) {
  222|       |        for name in prop_names.iter().rev() {
  223|       |            family.insert(0, name.clone());
  224|       |        }
  225|       |    }
  226|       |    if let Some(family) = fonts.families.get_mut(&egui::FontFamily::Monospace) {
  227|       |        for name in mono_names.iter().rev() {
  228|       |            family.insert(0, name.clone());
  229|       |        }
  230|       |    }
  231|       |
  232|       |    ctx.set_fonts(fonts);
  233|       |    Ok(())
  234|       |}
  235|       |
  236|       |/// Application entry point
  237|       |#[cfg(not(test))]
  238|       |fn main() -> Result<(), eframe::Error> {
  239|       |    // Configure logging for debugging (only in debug builds)
  240|       |    #[cfg(debug_assertions)]
  241|       |    env_logger::init();
  242|       |
  243|       |    let cli = match parse_cli_args() {
  244|       |        Ok(opts) => opts,
  245|       |        Err(err) => {
  246|       |            eprintln!("{err}");
  247|       |            return Ok(());
  248|       |        }
  249|       |    };
  250|       |
  251|       |    let screenshot_enabled = cli.screenshot;
  252|       |    let resolved_theme = if screenshot_enabled {
  253|       |        Some(cli.theme.unwrap_or(ThemeChoice::Light))
  254|       |    } else {
  255|       |        cli.theme
  256|       |    };
  257|       |    let screenshot_zoom = cli.zoom.unwrap_or(1.0);
  258|       |
  259|       |    let default_width = if screenshot_enabled { 1280.0 } else { 1000.0 };
  260|       |    let default_height = if screenshot_enabled { 720.0 } else { 700.0 };
  261|       |    let window_width = cli.width.unwrap_or(default_width);
  262|       |    let window_height = cli.height.unwrap_or(default_height);
  263|       |
  264|       |    // Set up eframe options for the native window
  265|       |    let mut viewport = egui::ViewportBuilder::default()
  266|       |        .with_title(format!("{APP_TITLE_PREFIX} - A Simple Markdown Viewer"))
  267|       |        .with_inner_size(egui::Vec2::new(window_width, window_height))
  268|       |        .with_min_inner_size(egui::Vec2::new(
  269|       |            if screenshot_enabled { 100.0 } else { 600.0 },
  270|       |            if screenshot_enabled { 100.0 } else { 400.0 },
  271|       |        ))
  272|       |        .with_icon(create_app_icon())
  273|       |        .with_resizable(!screenshot_enabled)
  274|       |        .with_maximize_button(!screenshot_enabled)
  275|       |        .with_minimize_button(!screenshot_enabled)
  276|       |        .with_drag_and_drop(!screenshot_enabled);
  277|       |
  278|       |    // Restore previous window position/size if available
  279|       |    if !screenshot_enabled {
  280|       |        if let Some(ws) = load_window_state() {
  281|       |            if let Some(ws) = sanitize_window_state(ws) {
  282|       |                viewport = viewport
  283|       |                    .with_inner_size(egui::Vec2::new(ws.size[0], ws.size[1]))
  284|       |                    .with_position(egui::pos2(ws.pos[0], ws.pos[1]))
  285|       |                    .with_maximized(ws.maximized);
  286|       |            }
  287|       |        }
  288|       |    }
  289|       |
  290|       |    let native_options = eframe::NativeOptions {
  291|       |        viewport,
  292|       |        // Disable eframe's built-in window persistence - we handle it ourselves via
  293|       |        // load_window_state/save_window_state to avoid conflicts
  294|       |        persist_window: false,
  295|       |        ..Default::default()
  296|       |    };
  297|       |
  298|       |    let initial_file = cli.initial_file.clone();
  299|       |    let test_fonts = cli.test_fonts.clone();
  300|       |    let screenshot_config = if screenshot_enabled {
  301|       |        let theme = match resolved_theme.unwrap_or(ThemeChoice::Light) {
  302|       |            ThemeChoice::Light => ScreenshotTheme::Light,
  303|       |            ThemeChoice::Dark => ScreenshotTheme::Dark,
  304|       |        };
  305|       |        Some(ScreenshotConfig {
  306|       |            output_path: cli
  307|       |                .screenshot_output
  308|       |                .clone()
  309|       |                .expect("screenshot output required"),
  310|       |            viewport_width: window_width,
  311|       |            viewport_height: window_height,
  312|       |            content_only: cli.content_only,
  313|       |            scroll_ratio: cli.scroll,
  314|       |            wait_ms: cli.wait_ms.unwrap_or(2000),
  315|       |            settle_frames: cli.settle_frames.unwrap_or(3),
  316|       |            zoom: screenshot_zoom,
  317|       |            theme,
  318|       |            font_source: test_fonts
  319|       |                .as_ref()
  320|       |                .map(|path| path.to_string_lossy().to_string()),
  321|       |        })
  322|       |    } else {
  323|       |        None
  324|       |    };
  325|       |
  326|       |    // Launch the application
  327|       |    eframe::run_native(
  328|       |        APP_TITLE_PREFIX,
  329|       |        native_options,
  330|       |        Box::new(move |cc| {
  331|       |            if let Some(theme) = resolved_theme {
  332|       |                let mut visuals = match theme {
  333|       |                    ThemeChoice::Light => egui::Visuals::light(),
  334|       |                    ThemeChoice::Dark => egui::Visuals::dark(),
  335|       |                };
  336|       |                if screenshot_enabled {
  337|       |                    let bg = screenshot_background_color();
  338|       |                    visuals.panel_fill = bg;
  339|       |                    visuals.window_fill = bg;
  340|       |                    visuals.extreme_bg_color = bg;
  341|       |                    visuals.faint_bg_color = bg;
  342|       |                }
  343|       |                cc.egui_ctx.set_visuals(visuals);
  344|       |            }
  345|       |
  346|       |            // Configure egui styling for better markdown display
  347|       |            configure_egui_style(&cc.egui_ctx);
  348|       |            if let Some(font_dir) = test_fonts.as_ref() {
  349|       |                if let Err(err) = load_fonts_from_dir(&cc.egui_ctx, font_dir) {
  350|       |                    eprintln!("{err}");
  351|       |                }
  352|       |            }
  353|       |
  354|       |            let mut app = MarkdownViewerApp::new();
  355|       |            if screenshot_zoom != 1.0 {
  356|       |                app.set_zoom_scale(screenshot_zoom);
  357|       |            }
  358|       |            if let Some(config) = screenshot_config {
  359|       |                app.set_screenshot_mode(config);
  360|       |            }
  361|       |
  362|       |            // Load initial file if provided via command line
  363|       |            if let Some(file_path) = initial_file {
  364|       |                if file_path.exists() && file_path.is_file() {
  365|       |                    if let Err(e) = app.load_file(file_path, true) {
  366|       |                        eprintln!("Failed to load file: {}", e);
  367|       |                        // Continue with default welcome screen
  368|       |                    }
  369|       |                } else {
  370|       |                    eprintln!("File not found: {}", file_path.display());
  371|       |                    // Continue with default welcome screen
  372|       |                }
  373|       |            }
  374|       |
  375|       |            Box::new(app)
  376|       |        }),
  377|       |    )
  378|       |}
  379|       |
  380|       |#[cfg(test)]
  381|      1|fn main() {}
  382|       |
  383|       |/// Create an application icon from embedded data
  384|      2|fn create_app_icon() -> egui::IconData {
  385|       |    // Create a 32x32 markdown-style document icon
  386|      2|    let size = 32;
  387|      2|    let mut rgba_data = Vec::with_capacity(size * size * 4);
  388|       |
  389|     64|    for y in 0..size {
                              ^2
  390|  2.04k|        for x in 0..size {
                                  ^64
  391|  2.04k|            let (r, g, b, a) = if x == 0 || x == size - 1 || y == 0 || y == size - 1 {
                                                          ^1.98k           ^1.92k    ^1.86k
  392|       |                // Border
  393|    248|                (60, 60, 60, 255)
  394|  1.80k|            } else if x == 1 || x == size - 2 || y == 1 || y == size - 2 {
                                              ^1.74k           ^1.68k    ^1.62k
  395|       |                // Inner border for depth
  396|    232|                (80, 80, 80, 255)
  397|  1.56k|            } else if (4..=8).contains(&y) && (4..=28).contains(&x) {
                                                             ^280    ^280     ^280
  398|       |                // Header area (title bar)
  399|    250|                if (6..=12).contains(&x) {
  400|     70|                    (100, 150, 255, 255) // Blue for # header
  401|    180|                } else if (14..=26).contains(&x) {
  402|    130|                    (200, 200, 200, 255) // Light text
  403|       |                } else {
  404|     50|                    (250, 250, 250, 255) // Background
  405|       |                }
  406|  1.31k|            } else if (11..=13).contains(&y) && (4..=28).contains(&x) {
                                                               ^168    ^168     ^168
  407|       |                // Text line 1
  408|    150|                if (6..=8).contains(&x) {
  409|     18|                    (150, 150, 150, 255) // Bullet point
  410|    132|                } else if (10..=24).contains(&x) {
  411|     90|                    (180, 180, 180, 255) // Text
  412|       |                } else {
  413|     42|                    (250, 250, 250, 255) // Background
  414|       |                }
  415|  1.16k|            } else if (15..=17).contains(&y) && (4..=28).contains(&x) {
                                                               ^168    ^168     ^168
  416|       |                // Text line 2
  417|    150|                if (6..=8).contains(&x) {
  418|     18|                    (150, 150, 150, 255) // Bullet point
  419|    132|                } else if (10..=22).contains(&x) {
  420|     78|                    (180, 180, 180, 255) // Text
  421|       |                } else {
  422|     54|                    (250, 250, 250, 255) // Background
  423|       |                }
  424|  1.01k|            } else if (20..=22).contains(&y) && (6..=26).contains(&x) {
                                                               ^168    ^168     ^168
  425|       |                // Code block area
  426|    126|                if (8..=24).contains(&x) {
  427|    102|                    (100, 255, 100, 255) // Green code text
  428|       |                } else {
  429|     24|                    (40, 40, 40, 255) // Dark background
  430|       |                }
  431|    892|            } else if (25..=27).contains(&y) && (4..=28).contains(&x) {
                                                               ^168    ^168     ^168
  432|       |                // Text line 3
  433|    150|                if (6..=20).contains(&x) {
  434|     90|                    (180, 180, 180, 255) // Text
  435|       |                } else {
  436|     60|                    (250, 250, 250, 255) // Background
  437|       |                }
  438|       |            } else {
  439|       |                // Document background
  440|    742|                (250, 250, 250, 255)
  441|       |            };
  442|       |
  443|  2.04k|            rgba_data.extend_from_slice(&[r, g, b, a]);
  444|       |        }
  445|       |    }
  446|       |
  447|      2|    egui::IconData {
  448|      2|        rgba: rgba_data,
  449|      2|        width: size as u32,
  450|      2|        height: size as u32,
  451|      2|    }
  452|      2|}
  453|       |
  454|       |/// Configure egui styling for optimal markdown display
  455|      2|fn configure_egui_style(ctx: &egui::Context) {
  456|      2|    let mut style = (*ctx.style()).clone();
  457|       |
  458|       |    // Configure spacing for better readability
  459|      2|    style.spacing.item_spacing = egui::Vec2::new(8.0, 8.0);
  460|      2|    style.spacing.window_margin = egui::Margin::same(8.0);
  461|      2|    style.spacing.menu_margin = egui::Margin::same(6.0);
  462|       |
  463|       |    // Configure interaction settings
  464|      2|    style.interaction.resize_grab_radius_side = 8.0;
  465|      2|    style.interaction.resize_grab_radius_corner = 12.0;
  466|       |
  467|       |    // Configure visuals for better contrast with black background
  468|      2|    style.visuals.window_rounding = egui::Rounding::same(4.0);
  469|      2|    style.visuals.menu_rounding = egui::Rounding::same(4.0);
  470|       |
  471|       |    // Set to true black background for maximum contrast
  472|      2|    if style.visuals.dark_mode {
  473|      1|        style.visuals.window_fill = egui::Color32::BLACK;
  474|      1|        style.visuals.panel_fill = egui::Color32::BLACK;
  475|      1|        style.visuals.faint_bg_color = egui::Color32::from_gray(20);
  476|      1|        style.visuals.extreme_bg_color = egui::Color32::BLACK;
  477|      1|        // The text color will be handled by egui's theme system
  478|      1|    }
  479|       |
  480|      2|    ctx.set_style(style);
  481|       |
  482|       |    // Use default fonts - egui has good built-in font support
  483|       |    // Custom fonts could be added here if needed
  484|      2|}
  485|       |
  486|       |#[cfg(test)]
  487|       |mod tests {
  488|       |    use super::*;
  489|       |    use std::sync::{Mutex, OnceLock};
  490|       |
  491|      6|    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
  492|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
  493|      6|        ENV_LOCK
  494|      6|            .get_or_init(|| Mutex::new(()))
                                          ^1         ^1
  495|      6|            .lock()
  496|      6|            .expect("env lock")
  497|      6|    }
  498|       |
  499|       |    struct EnvGuard {
  500|       |        key: &'static str,
  501|       |        original: Option<String>,
  502|       |        _lock: std::sync::MutexGuard<'static, ()>,
  503|       |    }
  504|       |
  505|       |    impl EnvGuard {
  506|      2|        fn set(key: &'static str, value: &str) -> Self {
  507|      2|            let lock = env_lock();
  508|      2|            let original = std::env::var(key).ok();
  509|      2|            std::env::set_var(key, value);
  510|      2|            Self {
  511|      2|                key,
  512|      2|                original,
  513|      2|                _lock: lock,
  514|      2|            }
  515|      2|        }
  516|       |
  517|      2|        fn unset(key: &'static str) -> Self {
  518|      2|            let lock = env_lock();
  519|      2|            let original = std::env::var(key).ok();
  520|      2|            std::env::remove_var(key);
  521|      2|            Self {
  522|      2|                key,
  523|      2|                original,
  524|      2|                _lock: lock,
  525|      2|            }
  526|      2|        }
  527|       |    }
  528|       |
  529|       |    impl Drop for EnvGuard {
  530|      5|        fn drop(&mut self) {
  531|      5|            if let Some(prev) = &self.original {
                                      ^1
  532|      1|                std::env::set_var(self.key, prev);
  533|      4|            } else {
  534|      4|                std::env::remove_var(self.key);
  535|      4|            }
  536|      5|        }
  537|       |    }
  538|       |
  539|       |    #[test]
  540|      1|    fn test_app_icon_creation() {
  541|      1|        let icon = create_app_icon();
  542|      1|        assert_eq!(icon.width, 32);
  543|      1|        assert_eq!(icon.height, 32);
  544|      1|        assert_eq!(icon.rgba.len(), 32 * 32 * 4); // RGBA format
  545|      1|    }
  546|       |
  547|       |    #[test]
  548|      1|    fn test_main_function_setup() {
  549|       |        // Test that the main function components work
  550|       |        // This is a basic smoke test
  551|      1|        let icon = create_app_icon();
  552|      1|        assert!(!icon.rgba.is_empty());
  553|      1|    }
  554|       |
  555|       |    #[test]
  556|      1|    fn test_configure_egui_style_dark_mode() {
  557|      1|        let ctx = egui::Context::default();
  558|      1|        let mut style = (*ctx.style()).clone();
  559|      1|        style.visuals.dark_mode = true;
  560|      1|        ctx.set_style(style);
  561|       |
  562|      1|        configure_egui_style(&ctx);
  563|       |
  564|      1|        let style = ctx.style();
  565|      1|        assert_eq!(style.spacing.item_spacing, egui::Vec2::new(8.0, 8.0));
  566|      1|        assert_eq!(style.spacing.window_margin, egui::Margin::same(8.0));
  567|      1|        assert_eq!(style.spacing.menu_margin, egui::Margin::same(6.0));
  568|      1|        assert_eq!(style.visuals.window_rounding, egui::Rounding::same(4.0));
  569|      1|        assert_eq!(style.visuals.menu_rounding, egui::Rounding::same(4.0));
  570|      1|        assert_eq!(style.visuals.window_fill, egui::Color32::BLACK);
  571|      1|        assert_eq!(style.visuals.panel_fill, egui::Color32::BLACK);
  572|      1|        assert_eq!(style.visuals.faint_bg_color, egui::Color32::from_gray(20));
  573|      1|        assert_eq!(style.visuals.extreme_bg_color, egui::Color32::BLACK);
  574|      1|    }
  575|       |
  576|       |    #[test]
  577|      1|    fn test_configure_egui_style_light_mode() {
  578|      1|        let ctx = egui::Context::default();
  579|      1|        let mut style = (*ctx.style()).clone();
  580|      1|        style.visuals.dark_mode = false;
  581|      1|        style.visuals.window_fill = egui::Color32::from_rgb(1, 2, 3);
  582|      1|        style.visuals.panel_fill = egui::Color32::from_rgb(4, 5, 6);
  583|      1|        style.visuals.faint_bg_color = egui::Color32::from_rgb(7, 8, 9);
  584|      1|        style.visuals.extreme_bg_color = egui::Color32::from_rgb(10, 11, 12);
  585|      1|        ctx.set_style(style);
  586|       |
  587|      1|        configure_egui_style(&ctx);
  588|       |
  589|      1|        let style = ctx.style();
  590|      1|        assert_eq!(style.spacing.item_spacing, egui::Vec2::new(8.0, 8.0));
  591|      1|        assert_eq!(style.spacing.window_margin, egui::Margin::same(8.0));
  592|      1|        assert_eq!(style.spacing.menu_margin, egui::Margin::same(6.0));
  593|      1|        assert_eq!(style.visuals.window_rounding, egui::Rounding::same(4.0));
  594|      1|        assert_eq!(style.visuals.menu_rounding, egui::Rounding::same(4.0));
  595|      1|        assert_eq!(style.visuals.window_fill, egui::Color32::from_rgb(1, 2, 3));
  596|      1|        assert_eq!(style.visuals.panel_fill, egui::Color32::from_rgb(4, 5, 6));
  597|      1|        assert_eq!(
  598|      1|            style.visuals.faint_bg_color,
  599|      1|            egui::Color32::from_rgb(7, 8, 9)
  600|       |        );
  601|      1|        assert_eq!(
  602|      1|            style.visuals.extreme_bg_color,
  603|      1|            egui::Color32::from_rgb(10, 11, 12)
  604|       |        );
  605|      1|    }
  606|       |
  607|       |    #[test]
  608|      1|    fn test_parse_cli_sets_initial_file_from_arg() {
  609|      1|        let opts = parse_cli_from(vec!["readme.md".to_string()]).expect("parse");
  610|      1|        assert_eq!(opts.initial_file, Some(PathBuf::from("readme.md")));
  611|      1|    }
  612|       |
  613|       |    #[test]
  614|      1|    fn test_parse_cli_screenshot_args() {
  615|      1|        let args = vec![
  616|      1|            "--screenshot".to_string(),
  617|      1|            "doc.md".to_string(),
  618|      1|            "--output".to_string(),
  619|      1|            "out.png".to_string(),
  620|      1|            "--width".to_string(),
  621|      1|            "800".to_string(),
  622|      1|            "--height".to_string(),
  623|      1|            "600".to_string(),
  624|      1|            "--theme".to_string(),
  625|      1|            "dark".to_string(),
  626|      1|            "--scroll".to_string(),
  627|      1|            "0.5".to_string(),
  628|       |        ];
  629|      1|        let opts = parse_cli_from(args).expect("parse");
  630|      1|        assert!(opts.screenshot);
  631|      1|        assert_eq!(opts.initial_file, Some(PathBuf::from("doc.md")));
  632|      1|        assert_eq!(opts.screenshot_output, Some(PathBuf::from("out.png")));
  633|      1|        assert_eq!(opts.width, Some(800.0));
  634|      1|        assert_eq!(opts.height, Some(600.0));
  635|      1|        assert_eq!(opts.theme, Some(ThemeChoice::Dark));
  636|      1|        assert_eq!(opts.scroll, Some(0.5));
  637|      1|    }
  638|       |
  639|       |    #[test]
  640|      1|    fn test_parse_cli_missing_screenshot_input() {
  641|      1|        let args = vec!["--screenshot".to_string()];
  642|      1|        let err = parse_cli_from(args)
  643|      1|            .err()
  644|      1|            .expect("expected missing screenshot input error");
  645|      1|        assert!(err.contains("--screenshot requires a value"));
  646|      1|    }
  647|       |
  648|       |    #[test]
  649|      1|    fn test_parse_cli_missing_screenshot_output() {
  650|      1|        let args = vec!["--screenshot".to_string(), "doc.md".to_string()];
  651|      1|        let err = parse_cli_from(args)
  652|      1|            .err()
  653|      1|            .expect("expected missing output error");
  654|      1|        assert!(err.contains("Missing --output"));
  655|      1|    }
  656|       |
  657|       |    #[test]
  658|      1|    fn test_parse_cli_invalid_values() {
  659|      1|        let args = vec!["--width".to_string(), "nope".to_string()];
  660|      1|        let err = parse_cli_from(args)
  661|      1|            .err()
  662|      1|            .expect("expected invalid width error");
  663|      1|        assert!(err.contains("Invalid --width"));
  664|       |
  665|      1|        let args = vec!["--theme".to_string(), "blue".to_string()];
  666|      1|        let err = parse_cli_from(args)
  667|      1|            .err()
  668|      1|            .expect("expected invalid theme error");
  669|      1|        assert!(err.contains("Unsupported theme"));
  670|      1|    }
  671|       |
  672|       |    #[test]
  673|      1|    fn test_parse_cli_missing_flag_value() {
  674|      1|        let args = vec!["--height".to_string()];
  675|      1|        let err = parse_cli_from(args)
  676|      1|            .err()
  677|      1|            .expect("expected missing height value error");
  678|      1|        assert!(err.contains("--height requires a value"));
  679|      1|    }
  680|       |
  681|       |    #[test]
  682|      1|    fn test_parse_cli_scroll_clamps() {
  683|      1|        let args = vec![
  684|      1|            "--scroll".to_string(),
  685|      1|            "2.5".to_string(),
  686|      1|            "doc.md".to_string(),
  687|       |        ];
  688|      1|        let opts = parse_cli_from(args).expect("parse");
  689|      1|        assert_eq!(opts.scroll, Some(1.0));
  690|      1|        assert_eq!(opts.initial_file, Some(PathBuf::from("doc.md")));
  691|      1|    }
  692|       |
  693|       |    #[test]
  694|      1|    fn test_parse_cli_additional_flags() {
  695|      1|        let args = vec![
  696|      1|            "--screenshot".to_string(),
  697|      1|            "doc.md".to_string(),
  698|      1|            "--output".to_string(),
  699|      1|            "out.png".to_string(),
  700|      1|            "--content-only".to_string(),
  701|      1|            "--wait-ms".to_string(),
  702|      1|            "1200".to_string(),
  703|      1|            "--settle-frames".to_string(),
  704|      1|            "3".to_string(),
  705|      1|            "--zoom".to_string(),
  706|      1|            "1.5".to_string(),
  707|      1|            "--theme".to_string(),
  708|      1|            "light".to_string(),
  709|      1|            "--test-fonts".to_string(),
  710|      1|            "fonts".to_string(),
  711|       |        ];
  712|      1|        let opts = parse_cli_from(args).expect("parse");
  713|      1|        assert!(opts.screenshot);
  714|      1|        assert!(opts.content_only);
  715|      1|        assert_eq!(opts.wait_ms, Some(1200));
  716|      1|        assert_eq!(opts.settle_frames, Some(3));
  717|      1|        assert_eq!(opts.zoom, Some(1.5));
  718|      1|        assert_eq!(opts.theme, Some(ThemeChoice::Light));
  719|      1|        assert_eq!(opts.test_fonts, Some(PathBuf::from("fonts")));
  720|      1|    }
  721|       |
  722|       |    #[test]
  723|      1|    fn test_parse_cli_ignores_extra_args() {
  724|      1|        let args = vec!["doc.md".to_string(), "extra.md".to_string()];
  725|      1|        let opts = parse_cli_from(args).expect("parse");
  726|      1|        assert_eq!(opts.initial_file, Some(PathBuf::from("doc.md")));
  727|      1|    }
  728|       |
  729|       |    #[test]
  730|      1|    fn test_parse_hex_color32() {
  731|      1|        let color = parse_hex_color32("#FFF8DB").expect("color");
  732|      1|        assert_eq!(color, egui::Color32::from_rgb(255, 248, 219));
  733|      1|        assert!(parse_hex_color32("#XYZ").is_none());
  734|      1|    }
  735|       |
  736|       |    #[test]
  737|      1|    fn test_parse_unsigned_helpers() {
  738|      1|        assert_eq!(parse_u32("--width", "12").expect("u32"), 12);
  739|      1|        assert!(parse_u32("--width", "nope").is_err());
  740|      1|        assert_eq!(parse_u64("--timeout", "42").expect("u64"), 42);
  741|      1|        assert!(parse_u64("--timeout", "-1").is_err());
  742|      1|    }
  743|       |
  744|       |    #[test]
  745|      1|    fn test_screenshot_background_color_env() {
  746|       |        {
  747|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "#112233");
  748|      1|            let color = screenshot_background_color();
  749|      1|            assert_eq!(color, egui::Color32::from_rgb(17, 34, 51));
  750|       |        }
  751|       |        {
  752|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "bad");
  753|      1|            let color = screenshot_background_color();
  754|      1|            assert_eq!(color, egui::Color32::from_rgb(255, 248, 219));
  755|       |        }
  756|      1|    }
  757|       |
  758|       |    #[test]
  759|      1|    fn test_screenshot_background_color_default_when_unset() {
  760|      1|        let _guard = EnvGuard::unset("MDMDVIEW_MERMAID_MAIN_BKG");
  761|      1|        let color = screenshot_background_color();
  762|      1|        assert_eq!(color, egui::Color32::from_rgb(255, 248, 219));
  763|      1|    }
  764|       |
  765|       |    #[test]
  766|      1|    fn test_env_guard_restores_previous_value() {
  767|      1|        let key = "MDMDVIEW_MERMAID_MAIN_BKG";
  768|      1|        let _lock = env_lock();
  769|      1|        std::env::set_var(key, "preexisting");
  770|      1|        let previous = std::env::var(key).ok();
  771|      1|        {
  772|      1|            std::env::set_var(key, "orig");
  773|      1|            let guard = EnvGuard {
  774|      1|                key,
  775|      1|                original: Some("orig".to_string()),
  776|      1|                _lock,
  777|      1|            };
  778|      1|            std::env::set_var(key, "new");
  779|      1|            drop(guard);
  780|      1|        }
  781|      1|        assert_eq!(std::env::var(key).ok().as_deref(), Some("orig"));
  782|      1|        let _lock = env_lock();
  783|      2|        for previous in [previous, None] {
                                       ^1        ^1
  784|      2|            match previous {
  785|      1|                Some(value) => std::env::set_var(key, value),
  786|      1|                None => std::env::remove_var(key),
  787|       |            }
  788|       |        }
  789|      1|        let missing_key = "MDMDVIEW_MERMAID_MAIN_BKG_MISSING";
  790|      1|        std::env::remove_var(missing_key);
  791|      1|        let previous = std::env::var(missing_key).ok();
  792|      2|        for previous in [previous, Some("temp".to_string())] {
                                       ^1        ^1
  793|      2|            match previous {
  794|      1|                Some(value) => std::env::set_var(missing_key, value),
  795|      1|                None => std::env::remove_var(missing_key),
  796|       |            }
  797|       |        }
  798|      1|    }
  799|       |
  800|       |    #[test]
  801|      1|    fn test_env_guard_drop_removes_unset_key() {
  802|      1|        let key = "MDMDVIEW_MERMAID_MAIN_BKG";
  803|      1|        std::env::remove_var(key);
  804|      1|        {
  805|      1|            let _guard = EnvGuard::unset(key);
  806|      1|            std::env::set_var(key, "temp");
  807|      1|        }
  808|      1|        assert!(std::env::var(key).is_err());
  809|      1|    }
  810|       |
  811|       |    #[test]
  812|      1|    fn test_main_stub_executes() {
  813|      1|        super::main();
  814|      1|    }
  815|       |}


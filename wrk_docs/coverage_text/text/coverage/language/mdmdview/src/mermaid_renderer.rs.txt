Coverage Report
Created: 2026-01-13 12:48
C:\language\mdmdview\src\mermaid_renderer.rs:
    1|       |#[cfg(feature = "mermaid-quickjs")]
    2|       |use crossbeam_channel::{bounded, Receiver, Sender, TrySendError};
    3|       |use egui::{Color32, RichText, Stroke};
    4|       |#[cfg(feature = "mermaid-quickjs")]
    5|       |use std::cell::{Cell, RefCell};
    6|       |#[cfg(feature = "mermaid-quickjs")]
    7|       |use std::collections::HashSet;
    8|       |#[cfg(any(test, feature = "mermaid-quickjs"))]
    9|       |use std::collections::{hash_map::DefaultHasher, HashMap, VecDeque};
   10|       |#[cfg(any(test, feature = "mermaid-quickjs"))]
   11|       |use std::hash::{Hash, Hasher};
   12|       |
   13|       |#[cfg(feature = "mermaid-quickjs")]
   14|       |use std::path::PathBuf;
   15|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   16|       |use std::sync::atomic::AtomicBool;
   17|       |#[cfg(feature = "mermaid-quickjs")]
   18|       |use std::sync::{
   19|       |    atomic::{AtomicU64, Ordering},
   20|       |    Arc,
   21|       |};
   22|       |#[cfg(feature = "mermaid-quickjs")]
   23|       |use std::thread::JoinHandle;
   24|       |#[cfg(feature = "mermaid-quickjs")]
   25|       |use std::time::{SystemTime, UNIX_EPOCH};
   26|       |
   27|       |#[cfg(feature = "mermaid-quickjs")]
   28|       |mod mermaid_embed {
   29|       |    include!(concat!(env!("OUT_DIR"), "/mermaid_js.rs"));
   30|       |}
   31|       |
   32|       |#[cfg(feature = "mermaid-quickjs")]
   33|       |const MERMAID_JS_EMPTY: bool = mermaid_embed::MERMAID_JS.is_empty();
   34|       |
   35|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   36|       |static MERMAID_JS_EMPTY_OVERRIDE: std::sync::Mutex<Option<std::thread::ThreadId>> =
   37|       |    std::sync::Mutex::new(None);
   38|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   39|       |static FORCE_RAW_TREE_PARSE_FAIL: std::sync::atomic::AtomicBool =
   40|       |    std::sync::atomic::AtomicBool::new(false);
   41|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   42|       |static FORCE_MERMAID_WORKER_INIT_ERROR: AtomicBool = AtomicBool::new(false);
   43|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   44|       |static FORCE_MERMAID_THREAD_SPAWN_ERROR: AtomicBool = AtomicBool::new(false);
   45|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   46|       |static FORCE_MERMAID_INIT_ERROR_STAGE: std::sync::Mutex<Option<(std::thread::ThreadId, usize)>> =
   47|       |    std::sync::Mutex::new(None);
   48|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   49|       |static FORCE_MERMAID_RUNTIME_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
   50|       |    std::sync::Mutex::new(None);
   51|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   52|       |static FORCE_MERMAID_CONTEXT_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
   53|       |    std::sync::Mutex::new(None);
   54|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   55|       |static FORCE_MERMAID_UTF8_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
   56|       |    std::sync::Mutex::new(None);
   57|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   58|       |static FORCE_MERMAID_RENDER_EVAL_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
   59|       |    std::sync::Mutex::new(None);
   60|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   61|       |static FORCE_MERMAID_RENDER_CALL_ERROR: std::sync::Mutex<Option<std::thread::ThreadId>> =
   62|       |    std::sync::Mutex::new(None);
   63|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   64|       |static FORCE_MERMAID_PIXMAP_ALLOC_FAIL: std::sync::Mutex<Option<std::thread::ThreadId>> =
   65|       |    std::sync::Mutex::new(None);
   66|       |
   67|       |#[cfg(feature = "mermaid-quickjs")]
   68|  1.54k|fn mermaid_js_empty() -> bool {
   69|       |    #[cfg(test)]
   70|  1.54k|    if let Ok(guard) = MERMAID_JS_EMPTY_OVERRIDE.try_lock() {
                            ^1.54k
   71|  1.54k|        if let Some(id) = guard.as_ref() {
                                  ^4
   72|      4|            if *id == std::thread::current().id() {
   73|      3|                return true;
   74|      1|            }
   75|  1.53k|        }
   76|      1|    }
   77|  1.54k|    MERMAID_JS_EMPTY
   78|  1.54k|}
   79|       |
   80|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   81|      7|fn set_mermaid_js_empty_for_test(value: bool) -> Option<std::thread::ThreadId> {
   82|      7|    let mut guard = MERMAID_JS_EMPTY_OVERRIDE
   83|      7|        .lock()
   84|      7|        .expect("mermaid js override lock");
   85|      7|    let previous = guard.clone();
   86|      7|    *guard = if value {
   87|      5|        Some(std::thread::current().id())
   88|       |    } else {
   89|      2|        None
   90|       |    };
   91|      7|    previous
   92|      7|}
   93|       |
   94|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
   95|      1|fn force_raw_tree_parse_fail_for_test() {
   96|      1|    FORCE_RAW_TREE_PARSE_FAIL.store(true, Ordering::Relaxed);
   97|      1|}
   98|       |
   99|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  100|      1|fn force_mermaid_worker_init_error_once() {
  101|      1|    FORCE_MERMAID_WORKER_INIT_ERROR.store(true, Ordering::Relaxed);
  102|      1|}
  103|       |
  104|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  105|      1|fn force_mermaid_thread_spawn_error_once() {
  106|      1|    FORCE_MERMAID_THREAD_SPAWN_ERROR.store(true, Ordering::Relaxed);
  107|      1|}
  108|       |
  109|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  110|      3|fn force_mermaid_init_error_once(stage: usize) {
  111|      3|    let mut guard = FORCE_MERMAID_INIT_ERROR_STAGE
  112|      3|        .lock()
  113|      3|        .expect("mermaid init error lock");
  114|      3|    *guard = Some((std::thread::current().id(), stage));
  115|      3|}
  116|       |
  117|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  118|  4.60k|fn take_mermaid_flag(flag: &std::sync::Mutex<Option<std::thread::ThreadId>>) -> bool {
  119|  4.60k|    let mut guard = flag.lock().expect("mermaid flag lock");
  120|  4.60k|    if let Some(thread_id) = guard.take() {
                              ^7
  121|      7|        if thread_id == std::thread::current().id() {
  122|      6|            return true;
  123|      1|        }
  124|      1|        *guard = Some(thread_id);
  125|  4.60k|    }
  126|  4.60k|    false
  127|  4.60k|}
  128|       |
  129|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  130|      2|fn force_mermaid_runtime_error_once() {
  131|      2|    let mut guard = FORCE_MERMAID_RUNTIME_ERROR
  132|      2|        .lock()
  133|      2|        .expect("mermaid runtime error lock");
  134|      2|    *guard = Some(std::thread::current().id());
  135|      2|}
  136|       |
  137|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  138|      1|fn force_mermaid_context_error_once() {
  139|      1|    let mut guard = FORCE_MERMAID_CONTEXT_ERROR
  140|      1|        .lock()
  141|      1|        .expect("mermaid context error lock");
  142|      1|    *guard = Some(std::thread::current().id());
  143|      1|}
  144|       |
  145|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  146|      1|fn force_mermaid_utf8_error_once() {
  147|      1|    let mut guard = FORCE_MERMAID_UTF8_ERROR
  148|      1|        .lock()
  149|      1|        .expect("mermaid utf8 error lock");
  150|      1|    *guard = Some(std::thread::current().id());
  151|      1|}
  152|       |
  153|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  154|      1|fn force_mermaid_render_eval_error_once() {
  155|      1|    let mut guard = FORCE_MERMAID_RENDER_EVAL_ERROR
  156|      1|        .lock()
  157|      1|        .expect("mermaid render eval error lock");
  158|      1|    *guard = Some(std::thread::current().id());
  159|      1|}
  160|       |
  161|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  162|      1|fn force_mermaid_render_call_error_once() {
  163|      1|    let mut guard = FORCE_MERMAID_RENDER_CALL_ERROR
  164|      1|        .lock()
  165|      1|        .expect("mermaid render call error lock");
  166|      1|    *guard = Some(std::thread::current().id());
  167|      1|}
  168|       |
  169|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  170|      1|fn force_mermaid_pixmap_alloc_fail_once() {
  171|      1|    let mut guard = FORCE_MERMAID_PIXMAP_ALLOC_FAIL
  172|      1|        .lock()
  173|      1|        .expect("mermaid pixmap fail lock");
  174|      1|    *guard = Some(std::thread::current().id());
  175|      1|}
  176|       |
  177|       |#[cfg(all(test, feature = "mermaid-quickjs"))]
  178|  7.58k|fn maybe_force_mermaid_init_error<T>(
  179|  7.58k|    stage: usize,
  180|  7.58k|    result: rquickjs::Result<T>,
  181|  7.58k|) -> rquickjs::Result<T> {
  182|  7.58k|    if let Ok(mut guard) = FORCE_MERMAID_INIT_ERROR_STAGE.try_lock() {
                            ^7.58k
  183|  7.58k|        if let Some((thread_id, target_stage)) = guard.take() {
                                   ^6         ^6
  184|      6|            if thread_id == std::thread::current().id() && target_stage == stage {
  185|      3|                return Err(rquickjs::Error::Exception);
  186|      3|            }
  187|      3|            *guard = Some((thread_id, target_stage));
  188|  7.57k|        }
  189|      5|    }
  190|  7.58k|    result
  191|  7.58k|}
  192|       |
  193|       |#[cfg(not(all(test, feature = "mermaid-quickjs")))]
  194|       |fn maybe_force_mermaid_init_error<T>(
  195|       |    _stage: usize,
  196|       |    result: rquickjs::Result<T>,
  197|       |) -> rquickjs::Result<T> {
  198|       |    result
  199|       |}
  200|       |
  201|       |#[cfg(feature = "mermaid-quickjs")]
  202|  1.52k|fn runtime_new_for_test() -> rquickjs::Result<rquickjs::Runtime> {
  203|       |    #[cfg(all(test, feature = "mermaid-quickjs"))]
  204|  1.52k|    if take_mermaid_flag(&FORCE_MERMAID_RUNTIME_ERROR) {
  205|      1|        return Err(rquickjs::Error::Exception);
  206|  1.52k|    }
  207|  1.52k|    rquickjs::Runtime::new()
  208|  1.52k|}
  209|       |
  210|       |#[cfg(feature = "mermaid-quickjs")]
  211|  1.52k|fn context_full_for_test(rt: &rquickjs::Runtime) -> rquickjs::Result<rquickjs::Context> {
  212|       |    #[cfg(all(test, feature = "mermaid-quickjs"))]
  213|  1.52k|    if take_mermaid_flag(&FORCE_MERMAID_CONTEXT_ERROR) {
  214|      1|        return Err(rquickjs::Error::Exception);
  215|  1.52k|    }
  216|  1.52k|    rquickjs::Context::full(rt)
  217|  1.52k|}
  218|       |
  219|       |#[cfg(feature = "mermaid-quickjs")]
  220|  1.52k|fn mermaid_js_str_for_test() -> Result<&'static str, std::str::Utf8Error> {
  221|       |    #[cfg(all(test, feature = "mermaid-quickjs"))]
  222|  1.52k|    if take_mermaid_flag(&FORCE_MERMAID_UTF8_ERROR) {
  223|       |        #[allow(invalid_from_utf8)]
  224|       |        {
  225|       |            static INVALID_UTF8: [u8; 1] = [0xFF];
  226|      1|            return std::str::from_utf8(&INVALID_UTF8);
  227|       |        }
  228|  1.51k|    }
  229|  1.51k|    std::str::from_utf8(mermaid_embed::MERMAID_JS)
  230|  1.52k|}
  231|       |
  232|       |#[cfg(feature = "mermaid-quickjs")]
  233|     12|fn eval_mermaid_wrapper<'js>(
  234|     12|    ctx: &rquickjs::Ctx<'js>,
  235|     12|    wrapper: &str,
  236|     12|) -> rquickjs::Result<rquickjs::Function<'js>> {
  237|       |    #[cfg(all(test, feature = "mermaid-quickjs"))]
  238|     12|    if take_mermaid_flag(&FORCE_MERMAID_RENDER_EVAL_ERROR) {
  239|      1|        return Err(rquickjs::Error::Exception);
  240|     11|    }
  241|     11|    ctx.eval(wrapper)
  242|     12|}
  243|       |
  244|       |#[cfg(feature = "mermaid-quickjs")]
  245|     11|fn call_mermaid_render<'js>(
  246|     11|    func: &rquickjs::Function<'js>,
  247|     11|    args: (
  248|     11|        &str,
  249|     11|        &str,
  250|     11|        &str,
  251|     11|        u32,
  252|     11|        u32,
  253|     11|    ),
  254|     11|) -> rquickjs::Result<rquickjs::promise::MaybePromise<'js>> {
  255|       |    #[cfg(all(test, feature = "mermaid-quickjs"))]
  256|     11|    if take_mermaid_flag(&FORCE_MERMAID_RENDER_CALL_ERROR) {
  257|      1|        return Err(rquickjs::Error::Exception);
  258|     10|    }
  259|     10|    func.call(args)
  260|     11|}
  261|       |
  262|       |#[cfg(feature = "mermaid-quickjs")]
  263|     20|fn pixmap_new_for_test(width: u32, height: u32) -> Option<tiny_skia::Pixmap> {
  264|       |    #[cfg(all(test, feature = "mermaid-quickjs"))]
  265|     20|    if take_mermaid_flag(&FORCE_MERMAID_PIXMAP_ALLOC_FAIL) {
  266|      1|        return None;
  267|     19|    }
  268|     19|    tiny_skia::Pixmap::new(width, height)
  269|     20|}
  270|       |
  271|       |#[cfg(feature = "mermaid-quickjs")]
  272|       |struct MermaidEngine {
  273|       |    #[allow(dead_code)]
  274|       |    rt: rquickjs::Runtime,
  275|       |    ctx: rquickjs::Context,
  276|       |}
  277|       |
  278|       |#[cfg(feature = "mermaid-quickjs")]
  279|       |type MermaidJobSender = Sender<MermaidRequest>;
  280|       |#[cfg(feature = "mermaid-quickjs")]
  281|       |type MermaidJobReceiver = Receiver<MermaidRequest>;
  282|       |#[cfg(feature = "mermaid-quickjs")]
  283|       |type MermaidResultSender = Sender<MermaidResult>;
  284|       |#[cfg(feature = "mermaid-quickjs")]
  285|       |type MermaidResultReceiver = Receiver<MermaidResult>;
  286|       |
  287|       |#[cfg(feature = "mermaid-quickjs")]
  288|       |#[derive(Clone)]
  289|       |struct MermaidTextureEntry {
  290|       |    texture: egui::TextureHandle,
  291|       |    size: [u32; 2],
  292|       |}
  293|       |
  294|       |#[cfg(any(test, feature = "mermaid-quickjs"))]
  295|       |struct LruCache<K, V> {
  296|       |    entries: HashMap<K, V>,
  297|       |    order: VecDeque<K>,
  298|       |    capacity: usize,
  299|       |}
  300|       |
  301|       |#[cfg(any(test, feature = "mermaid-quickjs"))]
  302|       |impl<K, V> LruCache<K, V>
  303|       |where
  304|       |    K: Eq + std::hash::Hash + Clone,
  305|       |    V: Clone,
  306|       |{
  307|  1.54k|    fn new(capacity: usize) -> Self {
  308|  1.54k|        Self {
  309|  1.54k|            entries: HashMap::new(),
  310|  1.54k|            order: VecDeque::new(),
  311|  1.54k|            capacity: capacity.max(1),
  312|  1.54k|        }
  313|  1.54k|    }
  314|       |
  315|       |    #[cfg_attr(test, inline(never))]
  316|     74|    fn get(&mut self, key: &K) -> Option<V> {
  317|     74|        let value = self.entries.get(key).cloned();
  318|     74|        self.touch_if_present(&value, key);
  319|     74|        value
  320|     74|    }
  321|       |
  322|       |    #[cfg_attr(test, inline(never))]
  323|     56|    fn insert(&mut self, key: K, value: V) {
  324|     56|        if self.entries.contains_key(&key) {
  325|      6|            self.entries.insert(key.clone(), value);
  326|      6|            self.touch(&key);
  327|      6|            return;
  328|     50|        }
  329|     58|        while self.entries.len() >= self.capacity {
  330|     15|            if !self.evict_oldest() {
  331|      7|                break;
  332|      8|            }
  333|       |        }
  334|     50|        self.order.push_back(key.clone());
  335|     50|        self.entries.insert(key, value);
  336|     56|    }
  337|       |
  338|       |    #[cfg(feature = "mermaid-quickjs")]
  339|      4|    fn remove(&mut self, key: &K) {
  340|      4|        self.entries.remove(key);
  341|      4|        self.order.retain(|entry| entry != key);
                                                ^3       ^3
  342|      4|    }
  343|       |
  344|       |    #[cfg(test)]
  345|      7|    fn len(&self) -> usize {
  346|      7|        self.entries.len()
  347|      7|    }
  348|       |
  349|       |    #[cfg_attr(test, inline(never))]
  350|     82|    fn touch_if_present(&mut self, value: &Option<V>, key: &K) {
  351|     82|        if value.is_some() {
  352|     24|            self.touch(key);
  353|     58|        }
  354|     82|    }
  355|       |
  356|       |    #[cfg_attr(test, inline(never))]
  357|     23|    fn evict_oldest(&mut self) -> bool {
  358|     23|        if let Some(old) = self.order.pop_front() {
                                  ^12
  359|     12|            self.entries.remove(&old);
  360|     12|            true
  361|       |        } else {
  362|     11|            false
  363|       |        }
  364|     23|    }
  365|       |
  366|     30|    fn touch(&mut self, key: &K) {
  367|     31|        self.order.retain(|entry| entry != key);
                      ^30        ^30
  368|     30|        self.order.push_back(key.clone());
  369|     30|    }
  370|       |}
  371|       |
  372|       |#[cfg(feature = "mermaid-quickjs")]
  373|       |struct MermaidRequest {
  374|       |    svg_key: u64,
  375|       |    texture_key: String,
  376|       |    code: Option<String>,
  377|       |    svg: Option<String>,
  378|       |    width_bucket: u32,
  379|       |    scale_bucket: u32,
  380|       |    viewport_width: u32,
  381|       |    viewport_height: u32,
  382|       |    bg: Option<[u8; 4]>,
  383|       |}
  384|       |
  385|       |#[cfg(feature = "mermaid-quickjs")]
  386|       |struct MermaidResult {
  387|       |    svg_key: u64,
  388|       |    texture_key: String,
  389|       |    svg: Option<String>,
  390|       |    rgba: Option<Vec<u8>>,
  391|       |    size: Option<(u32, u32)>,
  392|       |    error: Option<String>,
  393|       |}
  394|       |
  395|       |#[cfg(feature = "mermaid-quickjs")]
  396|       |#[derive(Debug, PartialEq, Eq)]
  397|       |enum MermaidEnqueueError {
  398|       |    QueueFull,
  399|       |    Disconnected,
  400|       |}
  401|       |
  402|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
  403|       |enum MermaidRenderPreference {
  404|       |    Embedded,
  405|       |    Off,
  406|       |}
  407|       |
  408|       |#[cfg(feature = "mermaid-quickjs")]
  409|       |struct MermaidThemeValues {
  410|       |    theme_name: String,
  411|       |    main_bkg: String,
  412|       |    primary: String,
  413|       |    primary_border: String,
  414|       |    primary_text: String,
  415|       |    secondary: String,
  416|       |    tertiary: String,
  417|       |    line: String,
  418|       |    text: String,
  419|       |    cluster_bkg: String,
  420|       |    cluster_border: String,
  421|       |    default_link: String,
  422|       |    title: String,
  423|       |    label_bg: String,
  424|       |    edge_label_bg: String,
  425|       |    font_family: Option<String>,
  426|       |}
  427|       |
  428|       |pub(crate) struct MermaidRenderer {
  429|       |    #[cfg(feature = "mermaid-quickjs")]
  430|       |    mermaid_textures: RefCell<LruCache<String, MermaidTextureEntry>>,
  431|       |    #[cfg(feature = "mermaid-quickjs")]
  432|       |    mermaid_pending: RefCell<HashSet<String>>,
  433|       |    #[cfg(feature = "mermaid-quickjs")]
  434|       |    mermaid_frame_pending: Cell<bool>,
  435|       |    #[cfg(feature = "mermaid-quickjs")]
  436|       |    mermaid_svg_cache: RefCell<LruCache<u64, String>>,
  437|       |    #[cfg(feature = "mermaid-quickjs")]
  438|       |    mermaid_errors: RefCell<LruCache<u64, String>>,
  439|       |    #[cfg(feature = "mermaid-quickjs")]
  440|       |    mermaid_texture_errors: RefCell<LruCache<String, String>>,
  441|       |    /// Job sender wrapped in Option so Drop can take and drop it first,
  442|       |    /// closing the channel before joining worker threads.
  443|       |    #[cfg(feature = "mermaid-quickjs")]
  444|       |    mermaid_job_tx: Option<MermaidJobSender>,
  445|       |    #[cfg(feature = "mermaid-quickjs")]
  446|       |    mermaid_result_rx: MermaidResultReceiver,
  447|       |    /// Worker thread handles for cleanup on drop.
  448|       |    /// When MermaidRenderer is dropped, we join all worker threads to ensure
  449|       |    /// they exit cleanly and release memory (font database, QuickJS runtime).
  450|       |    #[cfg(feature = "mermaid-quickjs")]
  451|       |    worker_handles: Vec<JoinHandle<()>>,
  452|       |}
  453|       |
  454|       |impl MermaidRenderer {
  455|       |    #[cfg(feature = "mermaid-quickjs")]
  456|       |    const MERMAID_TEXTURE_CACHE_CAPACITY: usize = 128;
  457|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  458|       |    const MERMAID_WIDTH_BUCKET_STEP: u32 = 32;
  459|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  460|       |    const MERMAID_SCALE_BUCKET_FACTOR: f32 = 100.0;
  461|       |    #[cfg(feature = "mermaid-quickjs")]
  462|       |    const MAX_MERMAID_JOBS: usize = 4;
  463|       |    #[cfg(feature = "mermaid-quickjs")]
  464|       |    const MERMAID_SVG_CACHE_CAPACITY: usize = 64;
  465|       |    #[cfg(feature = "mermaid-quickjs")]
  466|       |    const MERMAID_ERROR_CACHE_CAPACITY: usize = 64;
  467|       |    #[cfg(feature = "mermaid-quickjs")]
  468|       |    const MERMAID_TEXTURE_ERROR_CACHE_CAPACITY: usize = 64;
  469|       |    #[cfg(feature = "mermaid-quickjs")]
  470|       |    const MERMAID_MAX_TEXT_SIZE: u32 = 50_000;
  471|       |    #[cfg(feature = "mermaid-quickjs")]
  472|       |    const MERMAID_MAX_RENDER_SIDE: u32 = 4096;
  473|       |    /// Minimum height for Mermaid placeholder to reduce layout shift when diagrams render.
  474|       |    /// Most Mermaid diagrams are 150-400px tall; using 200px as a reasonable middle ground.
  475|       |    #[cfg(feature = "mermaid-quickjs")]
  476|       |    const MERMAID_PLACEHOLDER_MIN_HEIGHT: f32 = 200.0;
  477|       |
  478|    373|    pub(crate) fn new() -> Self {
  479|       |        #[cfg(feature = "mermaid-quickjs")]
  480|    373|        let (mermaid_job_tx, mermaid_job_rx): (MermaidJobSender, MermaidJobReceiver) =
  481|    373|            bounded(Self::MAX_MERMAID_JOBS * 4);
  482|       |        #[cfg(feature = "mermaid-quickjs")]
  483|    373|        let (mermaid_result_tx, mermaid_result_rx): (
  484|    373|            MermaidResultSender,
  485|    373|            MermaidResultReceiver,
  486|    373|        ) = bounded(Self::MAX_MERMAID_JOBS * 4);
  487|       |        #[cfg(feature = "mermaid-quickjs")]
  488|    373|        let worker_handles = Self::spawn_mermaid_workers(mermaid_job_rx, mermaid_result_tx);
  489|    373|        Self {
  490|    373|            #[cfg(feature = "mermaid-quickjs")]
  491|    373|            mermaid_textures: RefCell::new(LruCache::new(Self::MERMAID_TEXTURE_CACHE_CAPACITY)),
  492|    373|            #[cfg(feature = "mermaid-quickjs")]
  493|    373|            mermaid_pending: RefCell::new(HashSet::new()),
  494|    373|            #[cfg(feature = "mermaid-quickjs")]
  495|    373|            mermaid_frame_pending: Cell::new(false),
  496|    373|            #[cfg(feature = "mermaid-quickjs")]
  497|    373|            mermaid_svg_cache: RefCell::new(LruCache::new(Self::MERMAID_SVG_CACHE_CAPACITY)),
  498|    373|            #[cfg(feature = "mermaid-quickjs")]
  499|    373|            mermaid_errors: RefCell::new(LruCache::new(Self::MERMAID_ERROR_CACHE_CAPACITY)),
  500|    373|            #[cfg(feature = "mermaid-quickjs")]
  501|    373|            mermaid_texture_errors: RefCell::new(LruCache::new(
  502|    373|                Self::MERMAID_TEXTURE_ERROR_CACHE_CAPACITY,
  503|    373|            )),
  504|    373|            #[cfg(feature = "mermaid-quickjs")]
  505|    373|            mermaid_job_tx: Some(mermaid_job_tx),
  506|    373|            #[cfg(feature = "mermaid-quickjs")]
  507|    373|            mermaid_result_rx,
  508|    373|            #[cfg(feature = "mermaid-quickjs")]
  509|    373|            worker_handles,
  510|    373|        }
  511|    373|    }
  512|       |
  513|      6|    fn default_mermaid_preference() -> MermaidRenderPreference {
  514|       |        #[cfg(feature = "mermaid-quickjs")]
  515|       |        {
  516|      6|            MermaidRenderPreference::Embedded
  517|       |        }
  518|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  519|       |        {
  520|       |            MermaidRenderPreference::Off
  521|       |        }
  522|      6|    }
  523|       |
  524|     20|    fn mermaid_renderer_preference() -> (MermaidRenderPreference, bool) {
  525|     20|        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_RENDERER") {
                                ^15
  526|     15|            let normalized = raw.trim().to_ascii_lowercase();
  527|     15|            return match normalized.as_str() {
  528|     15|                "off" => (MermaidRenderPreference::Off, true),
                                       ^3
  529|     12|                "embedded" => (MermaidRenderPreference::Embedded, true),
                                            ^11
  530|      1|                _ => (Self::default_mermaid_preference(), false),
  531|       |            };
  532|      5|        }
  533|      5|        (Self::default_mermaid_preference(), false)
  534|     20|    }
  535|       |
  536|     13|    pub(crate) fn has_pending(&self) -> bool {
  537|       |        #[cfg(feature = "mermaid-quickjs")]
  538|       |        {
  539|     13|            return self.mermaid_frame_pending.get() || !self.mermaid_pending.borrow().is_empty();
                                                                     ^11
  540|       |        }
  541|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  542|       |        {
  543|       |            false
  544|       |        }
  545|     13|    }
  546|       |
  547|     24|    pub(crate) fn begin_frame(&self) {
  548|       |        #[cfg(feature = "mermaid-quickjs")]
  549|     24|        self.mermaid_frame_pending.set(false);
  550|     24|    }
  551|       |
  552|     16|    pub(crate) fn render_block(
  553|     16|        &self,
  554|     16|        ui: &mut egui::Ui,
  555|     16|        code: &str,
  556|     16|        ui_scale: f32,
  557|     16|        code_font_size: f32,
  558|     16|    ) -> bool {
  559|     16|        let (preference, _explicit) = Self::mermaid_renderer_preference();
  560|       |
  561|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  562|       |        {
  563|       |            let _ = code;
  564|       |            let _ = ui_scale;
  565|       |        }
  566|       |
  567|     16|        if preference == MermaidRenderPreference::Off {
  568|      2|            egui::Frame::none()
  569|      2|                .fill(Color32::from_rgb(25, 25, 25))
  570|      2|                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  571|      2|                .inner_margin(8.0)
  572|      2|                .show(ui, |ui| {
  573|      2|                    ui.label(
  574|      2|                        RichText::new(
  575|       |                            "Mermaid rendering is disabled. Set MDMDVIEW_MERMAID_RENDERER=embedded to enable.",
  576|       |                        )
  577|      2|                        .color(Color32::from_rgb(200, 160, 80))
  578|      2|                        .family(egui::FontFamily::Monospace)
  579|      2|                        .size(code_font_size),
  580|       |                    );
  581|      2|                    ui.add_space(6.0);
  582|      2|                    ui.label(
  583|      2|                        RichText::new(code)
  584|      2|                            .family(egui::FontFamily::Monospace)
  585|      2|                            .size(code_font_size)
  586|      2|                            .color(Color32::from_rgb(180, 180, 180)),
  587|       |                    );
  588|      2|                });
  589|      2|            return true;
  590|     14|        }
  591|       |
  592|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  593|       |        if _explicit && preference == MermaidRenderPreference::Embedded {
  594|       |            egui::Frame::none()
  595|       |                .fill(Color32::from_rgb(25, 25, 25))
  596|       |                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  597|       |                .inner_margin(8.0)
  598|       |                .show(ui, |ui| {
  599|       |                    ui.label(
  600|       |                        RichText::new(
  601|       |                            "Mermaid rendering via embedded JS is unavailable (feature not enabled).",
  602|       |                        )
  603|       |                        .color(Color32::from_rgb(200, 160, 80))
  604|       |                        .family(egui::FontFamily::Monospace)
  605|       |                        .size(code_font_size),
  606|       |                    );
  607|       |                    ui.add_space(6.0);
  608|       |                    ui.label(
  609|       |                        RichText::new(code)
  610|       |                            .family(egui::FontFamily::Monospace)
  611|       |                            .size(code_font_size)
  612|       |                            .color(Color32::from_rgb(180, 180, 180)),
  613|       |                    );
  614|       |                });
  615|       |            return true;
  616|       |        }
  617|       |
  618|       |        #[cfg(feature = "mermaid-quickjs")]
  619|       |        {
  620|     14|            if mermaid_js_empty() {
  621|      1|                egui::Frame::none()
  622|      1|                    .fill(Color32::from_rgb(25, 25, 25))
  623|      1|                    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  624|      1|                    .inner_margin(8.0)
  625|      1|                    .show(ui, |ui| {
  626|      1|                        ui.label(
  627|      1|                            RichText::new(
  628|       |                                "Mermaid rendering is unavailable (embedded JS missing).",
  629|       |                            )
  630|      1|                            .color(Color32::from_rgb(200, 160, 80))
  631|      1|                            .family(egui::FontFamily::Monospace)
  632|      1|                            .size(code_font_size),
  633|       |                        );
  634|      1|                        ui.add_space(6.0);
  635|      1|                        ui.label(
  636|      1|                            RichText::new(code)
  637|      1|                                .family(egui::FontFamily::Monospace)
  638|      1|                                .size(code_font_size)
  639|      1|                                .color(Color32::from_rgb(180, 180, 180)),
  640|       |                        );
  641|      1|                    });
  642|      1|                return true;
  643|     13|            }
  644|     13|            let svg_key = Self::hash_str(code);
  645|     13|            let mut available_width = ui.available_width();
  646|     13|            let orig_available_width = available_width;
  647|     13|            if available_width <= Self::MERMAID_WIDTH_BUCKET_STEP as f32 {
  648|      4|                let fallback = ui.ctx().available_rect().width();
  649|      4|                if fallback > available_width {
  650|      3|                    available_width = fallback;
  651|      3|                }
                              ^1
  652|      9|            }
  653|     13|            if std::env::var("MDMDVIEW_MERMAID_LOG_WIDTH").is_ok() {
  654|      2|                eprintln!(
  655|      2|                    "Mermaid width: avail={:.2} fallback={:.2}",
  656|      2|                    orig_available_width, available_width
  657|      2|                );
  658|     11|            }
  659|     13|            let width_bucket = Self::width_bucket(available_width);
  660|     13|            let scale_bucket = Self::scale_bucket(ui_scale);
  661|     13|            let mut viewport_width = available_width.round().max(1.0) as u32;
  662|     13|            let mut viewport_height = ui
  663|     13|                .ctx()
  664|     13|                .input(|i| i.screen_rect().height())
  665|     13|                .round()
  666|     13|                .max(1.0) as u32;
  667|     13|            if let Some(kind) = Self::mermaid_diagram_kind(code) {
                                      ^11
  668|     11|                if kind == "timeline" {
  669|      2|                    viewport_width = viewport_width.min(1000);
  670|      2|                    viewport_height = viewport_height.min(700);
  671|      9|                }
  672|      2|            }
  673|     13|            let bg = Self::mermaid_bg_fill();
  674|     13|            let texture_key = Self::texture_key(svg_key, width_bucket, scale_bucket, bg);
  675|       |
  676|     13|            if self.poll_mermaid_results(ui.ctx()) {
  677|      1|                ui.ctx().request_repaint();
  678|     12|            }
  679|       |
  680|     13|            if let Some(entry) = self.mermaid_textures.borrow_mut().get(&texture_key) {
                                      ^2
  681|      2|                let (tw, th) = (entry.size[0] as f32, entry.size[1] as f32);
  682|      2|                let available_w = ui.available_width().max(1.0);
  683|      2|                let scale = if tw > available_w {
  684|      1|                    (available_w / tw).clamp(0.01, 4.0)
  685|       |                } else {
  686|      1|                    1.0
  687|       |                };
  688|      2|                let size = egui::vec2((tw * scale).round(), (th * scale).round());
  689|      2|                ui.add(egui::Image::new(&entry.texture).fit_to_exact_size(size));
  690|      2|                return true;
  691|     11|            }
  692|       |
  693|     11|            let svg_error = self.mermaid_errors.borrow_mut().get(&svg_key);
  694|     11|            let texture_error = self.mermaid_texture_errors.borrow_mut().get(&texture_key);
  695|     11|            if let Some(err) = svg_error.or(texture_error) {
                                      ^1
  696|      1|                egui::Frame::none()
  697|      1|                    .fill(Color32::from_rgb(25, 25, 25))
  698|      1|                    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  699|      1|                    .inner_margin(8.0)
  700|      1|                    .show(ui, |ui| {
  701|      1|                        ui.label(
  702|      1|                            RichText::new("Mermaid render failed; showing source.")
  703|      1|                                .color(Color32::from_rgb(200, 160, 80)),
  704|       |                        );
  705|      1|                        ui.label(
  706|      1|                            RichText::new(format!(
  707|      1|                                "Embedded bytes:{}\nHash:{:016x}\nError:{}",
  708|      1|                                mermaid_embed::MERMAID_JS.len(),
  709|       |                                svg_key,
  710|       |                                err
  711|       |                            ))
  712|      1|                            .family(egui::FontFamily::Monospace)
  713|      1|                            .size(code_font_size)
  714|      1|                            .color(Color32::from_rgb(180, 180, 180)),
  715|       |                        );
  716|      1|                        ui.add_space(6.0);
  717|      1|                        ui.label(
  718|      1|                            RichText::new(code)
  719|      1|                                .family(egui::FontFamily::Monospace)
  720|      1|                                .size(code_font_size)
  721|      1|                                .color(Color32::from_rgb(180, 180, 180)),
  722|       |                        );
  723|      1|                    });
  724|      1|                return true;
  725|     10|            }
  726|     10|            let svg = self.mermaid_svg_cache.borrow_mut().get(&svg_key);
  727|     10|            let pending = self.mermaid_pending.borrow().contains(&texture_key);
  728|     10|            let mut waiting_for_slot = false;
  729|       |
  730|     10|            if !pending {
  731|      9|                let (request_code, request_svg) = match svg {
  732|      1|                    Some(svg) => (None, Some(svg)),
  733|      8|                    None => (Some(code.to_string()), None),
  734|       |                };
  735|      9|                let request = MermaidRequest {
  736|      9|                    svg_key,
  737|      9|                    texture_key: texture_key.clone(),
  738|      9|                    code: request_code,
  739|      9|                    svg: request_svg,
  740|      9|                    width_bucket,
  741|      9|                    scale_bucket,
  742|      9|                    viewport_width,
  743|      9|                    viewport_height,
  744|      9|                    bg,
  745|      9|                };
  746|      9|                match self.enqueue_mermaid_job(request) {
  747|      7|                    Ok(()) => {
  748|      7|                        self.mermaid_pending
  749|      7|                            .borrow_mut()
  750|      7|                            .insert(texture_key.clone());
  751|      7|                        ui.ctx().request_repaint();
  752|      7|                    }
  753|      1|                    Err(MermaidEnqueueError::QueueFull) => {
  754|      1|                        waiting_for_slot = true;
  755|      1|                        ui.ctx().request_repaint();
  756|      1|                    }
  757|       |                    Err(MermaidEnqueueError::Disconnected) => {
  758|      1|                        self.mermaid_errors
  759|      1|                            .borrow_mut()
  760|      1|                            .insert(svg_key, "Mermaid worker pool unavailable".to_string());
  761|      1|                        egui::Frame::none()
  762|      1|                            .fill(Color32::from_rgb(25, 25, 25))
  763|      1|                            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  764|      1|                            .inner_margin(8.0)
  765|      1|                            .show(ui, |ui| {
  766|      1|                                ui.label(
  767|      1|                                    RichText::new("Mermaid worker pool unavailable.")
  768|      1|                                        .color(Color32::from_rgb(200, 160, 80))
  769|      1|                                        .family(egui::FontFamily::Monospace)
  770|      1|                                        .size(code_font_size),
  771|       |                                );
  772|      1|                                ui.add_space(6.0);
  773|      1|                                ui.label(
  774|      1|                                    RichText::new(code)
  775|      1|                                        .family(egui::FontFamily::Monospace)
  776|      1|                                        .size(code_font_size)
  777|      1|                                        .color(Color32::from_rgb(180, 180, 180)),
  778|       |                                );
  779|      1|                            });
  780|      1|                        return true;
  781|       |                    }
  782|       |                }
  783|      1|            }
  784|       |
  785|      9|            let inflight = self.mermaid_pending.borrow().len();
  786|      9|            self.mermaid_frame_pending.set(true);
  787|      9|            egui::Frame::none()
  788|      9|                .fill(Color32::from_rgb(25, 25, 25))
  789|      9|                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  790|      9|                .inner_margin(8.0)
  791|      9|                .show(ui, |ui| {
  792|       |                    // Reserve minimum height for placeholder to reduce layout shift
  793|       |                    // when the actual diagram renders. Most diagrams are 150-400px tall.
  794|      9|                    ui.set_min_height(Self::MERMAID_PLACEHOLDER_MIN_HEIGHT);
  795|      9|                    if waiting_for_slot {
  796|      1|                        ui.label(
  797|      1|                            RichText::new(format!(
  798|      1|                                "Mermaid workers busy ({}/{}) - request queued.",
  799|      1|                                inflight,
  800|      1|                                Self::MAX_MERMAID_JOBS
  801|      1|                            ))
  802|      1|                            .color(Color32::from_rgb(200, 160, 80))
  803|      1|                            .family(egui::FontFamily::Monospace)
  804|      1|                            .size(code_font_size),
  805|      1|                        );
  806|      8|                    } else {
  807|      8|                        ui.label(
  808|      8|                            RichText::new("Rendering diagram locally...")
  809|      8|                                .color(Color32::from_rgb(160, 200, 240)),
  810|      8|                        );
  811|      8|                    }
  812|      9|                });
  813|      9|            true
  814|       |        }
  815|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  816|       |        {
  817|       |            false
  818|       |        }
  819|     16|    }
  820|       |
  821|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  822|     18|    fn width_bucket(available_width: f32) -> u32 {
  823|     18|        let step = Self::MERMAID_WIDTH_BUCKET_STEP;
  824|     18|        let width = available_width.max(1.0).ceil() as u32;
  825|     18|        width.div_ceil(step) * step
  826|     18|    }
  827|       |
  828|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  829|     39|    fn scale_bucket(ui_scale: f32) -> u32 {
  830|     39|        let clamped = ui_scale.clamp(0.5, 4.0);
  831|     39|        (clamped * Self::MERMAID_SCALE_BUCKET_FACTOR).round() as u32
  832|     39|    }
  833|       |
  834|     15|    fn mermaid_diagram_kind(code: &str) -> Option<String> {
  835|     20|        for line in code.lines() {
                                  ^15  ^15
  836|     20|            let trimmed = line.trim();
  837|     20|            if trimmed.is_empty() {
  838|      3|                continue;
  839|     17|            }
  840|     17|            if trimmed.starts_with("%%") {
  841|      5|                continue;
  842|     12|            }
  843|     12|            return trimmed
  844|     12|                .split_whitespace()
  845|     12|                .next()
  846|     12|                .map(|token| token.to_ascii_lowercase());
  847|       |        }
  848|      3|        None
  849|     15|    }
  850|       |
  851|       |    #[cfg(feature = "mermaid-quickjs")]
  852|     20|    fn scale_from_bucket(scale_bucket: u32) -> f32 {
  853|     20|        let scale = scale_bucket as f32 / Self::MERMAID_SCALE_BUCKET_FACTOR;
  854|     20|        scale.clamp(0.5, 4.0)
  855|     20|    }
  856|       |
  857|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  858|     20|    fn mermaid_bg_key(bg: Option<[u8; 4]>) -> String {
  859|     20|        match bg {
  860|     19|            Some([r, g, b, a]) => format!("{:02x}{:02x}{:02x}{:02x}", r, g, b, a),
  861|      1|            None => "none".to_string(),
  862|       |        }
  863|     20|    }
  864|       |
  865|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  866|     18|    fn texture_key(
  867|     18|        svg_key: u64,
  868|     18|        width_bucket: u32,
  869|     18|        scale_bucket: u32,
  870|     18|        bg: Option<[u8; 4]>,
  871|     18|    ) -> String {
  872|     18|        let bg_key = Self::mermaid_bg_key(bg);
  873|     18|        format!(
  874|     18|            "mermaid:{:016x}:w{}:s{}:bg{}",
  875|       |            svg_key, width_bucket, scale_bucket, bg_key
  876|       |        )
  877|     18|    }
  878|       |
  879|       |    #[cfg(feature = "mermaid-quickjs")]
  880|     18|    fn poll_mermaid_results(&self, ctx: &egui::Context) -> bool {
  881|     18|        let mut changed = false;
  882|     24|        while let Ok(result) = self.mermaid_result_rx.try_recv() {
                                   ^6
  883|       |            let MermaidResult {
  884|      6|                svg_key,
  885|      6|                texture_key,
  886|      6|                svg,
  887|      6|                rgba,
  888|      6|                size,
  889|      6|                error,
  890|      6|            } = result;
  891|      6|            let has_svg = svg.is_some();
  892|      6|            self.mermaid_pending.borrow_mut().remove(&texture_key);
  893|       |
  894|      6|            if let Some(svg) = svg {
                                      ^3
  895|      3|                self.mermaid_svg_cache.borrow_mut().insert(svg_key, svg);
  896|      3|                self.mermaid_errors.borrow_mut().remove(&svg_key);
  897|      3|            }
  898|       |
  899|      6|            if let Some(rgba) = rgba {
                                      ^2
  900|      2|                if let Some((w, h)) = size {
                                           ^1 ^1
  901|      1|                    let img =
  902|      1|                        egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &rgba);
  903|      1|                    let tex =
  904|      1|                        ctx.load_texture(texture_key.clone(), img, egui::TextureOptions::LINEAR);
  905|      1|                    self.store_mermaid_texture(&texture_key, tex.clone(), [w, h]);
  906|      1|                    self.mermaid_texture_errors
  907|      1|                        .borrow_mut()
  908|      1|                        .remove(&texture_key);
  909|      1|                } else {
  910|      1|                    self.mermaid_texture_errors.borrow_mut().insert(
  911|      1|                        texture_key.clone(),
  912|      1|                        "Mermaid rasterization failed (missing size)".to_string(),
  913|      1|                    );
  914|      1|                }
  915|      4|            }
  916|       |
  917|      6|            if let Some(err) = error {
                                      ^2
  918|      2|                if !has_svg {
  919|      1|                    self.mermaid_errors.borrow_mut().insert(svg_key, err);
  920|      1|                } else {
  921|      1|                    self.mermaid_texture_errors
  922|      1|                        .borrow_mut()
  923|      1|                        .insert(texture_key, err);
  924|      1|                }
  925|      4|            }
  926|       |
  927|      6|            changed = true;
  928|       |        }
  929|     18|        changed
  930|     18|    }
  931|       |
  932|       |    #[cfg(feature = "mermaid-quickjs")]
  933|     10|    fn enqueue_mermaid_job(&self, request: MermaidRequest) -> Result<(), MermaidEnqueueError> {
  934|     10|        let Some(ref tx) = self.mermaid_job_tx else {
                               ^9
  935|      1|            return Err(MermaidEnqueueError::Disconnected);
  936|       |        };
  937|      9|        match tx.try_send(request) {
  938|      7|            Ok(()) => Ok(()),
  939|      1|            Err(TrySendError::Full(_)) => Err(MermaidEnqueueError::QueueFull),
  940|      1|            Err(TrySendError::Disconnected(_)) => Err(MermaidEnqueueError::Disconnected),
  941|       |        }
  942|     10|    }
  943|       |
  944|       |    #[cfg(feature = "mermaid-quickjs")]
  945|    378|    fn mermaid_worker_count() -> usize {
  946|    378|        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_WORKERS") {
                                ^5
  947|      5|            if let Ok(value) = raw.trim().parse::<usize>() {
                                    ^4
  948|      4|                return value.clamp(1, 16);
  949|      1|            }
  950|    373|        }
  951|    374|        let default = std::thread::available_parallelism()
  952|    374|            .map(|n| n.get())
  953|    374|            .unwrap_or(1);
  954|    374|        default.min(Self::MAX_MERMAID_JOBS.max(1))
  955|    378|    }
  956|       |
  957|       |    #[cfg(feature = "mermaid-quickjs")]
  958|     15|    fn mermaid_timeout_ms() -> u64 {
  959|     15|        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_TIMEOUT_MS") {
                                ^3
  960|      3|            if let Ok(value) = raw.trim().parse::<u64>() {
                                    ^2
  961|      2|                return value.max(100);
  962|      1|            }
  963|     12|        }
  964|     13|        30_000
  965|     15|    }
  966|       |
  967|       |    #[cfg(feature = "mermaid-quickjs")]
  968|  1.49k|    fn spawn_mermaid_worker_thread(
  969|  1.49k|        worker_idx: usize,
  970|  1.49k|        worker_rx: MermaidJobReceiver,
  971|  1.49k|        worker_tx: MermaidResultSender,
  972|  1.49k|        worker_fontdb: Arc<usvg::fontdb::Database>,
  973|  1.49k|    ) -> std::io::Result<JoinHandle<()>> {
  974|       |        #[cfg(test)]
  975|  1.49k|        if FORCE_MERMAID_THREAD_SPAWN_ERROR.swap(false, Ordering::Relaxed) {
  976|      1|            return Err(std::io::Error::new(
  977|      1|                std::io::ErrorKind::Other,
  978|      1|                "forced mermaid spawn error",
  979|      1|            ));
  980|  1.49k|        }
  981|  1.49k|        std::thread::Builder::new()
  982|  1.49k|            .name(format!("mdmdview-mermaid-{worker_idx}"))
  983|  1.49k|            .spawn(move || {
  984|  1.49k|                let mut worker = MermaidWorker::new(worker_idx, worker_fontdb).map_err(|e| {
                                                                                                         ^1
  985|      1|                    eprintln!("Mermaid worker init failed: {}", e);
  986|      1|                    e
  987|      1|                });
  988|  1.49k|                for job in worker_rx.iter() {
                                  ^6
  989|      6|                    let payload = match &mut worker {
  990|      5|                        Ok(state) => state.process_job(job),
  991|      1|                        Err(err) => {
  992|       |                            let MermaidRequest {
  993|      1|                                svg_key,
  994|      1|                                texture_key,
  995|      1|                                svg,
  996|       |                                ..
  997|      1|                            } = job;
  998|      1|                            MermaidResult {
  999|      1|                                svg_key,
 1000|      1|                                texture_key,
 1001|      1|                                svg,
 1002|      1|                                rgba: None,
 1003|      1|                                size: None,
 1004|      1|                                error: Some(err.clone()),
 1005|      1|                            }
 1006|       |                        }
 1007|       |                    };
 1008|      6|                    let _ = worker_tx.send(payload);
 1009|       |                }
 1010|  1.49k|            })
 1011|  1.49k|    }
 1012|       |
 1013|       |    #[cfg(feature = "mermaid-quickjs")]
 1014|    375|    fn spawn_mermaid_workers(
 1015|    375|        job_rx: MermaidJobReceiver,
 1016|    375|        result_tx: MermaidResultSender,
 1017|    375|    ) -> Vec<JoinHandle<()>> {
 1018|    375|        let worker_count = Self::mermaid_worker_count();
 1019|    375|        let mut fontdb = usvg::fontdb::Database::new();
 1020|    375|        fontdb.load_system_fonts();
 1021|    375|        let fontdb = Arc::new(fontdb);
 1022|    375|        let mut handles = Vec::with_capacity(worker_count);
 1023|  1.49k|        for worker_idx in 0..worker_count {
                                           ^375
 1024|  1.49k|            let worker_rx = job_rx.clone();
 1025|  1.49k|            let worker_tx = result_tx.clone();
 1026|  1.49k|            let worker_fontdb = Arc::clone(&fontdb);
 1027|  1.49k|            match Self::spawn_mermaid_worker_thread(worker_idx, worker_rx, worker_tx, worker_fontdb)
 1028|       |            {
 1029|  1.49k|                Ok(handle) => handles.push(handle),
 1030|      1|                Err(err) => eprintln!("Failed to start Mermaid worker thread: {}", err),
 1031|       |            }
 1032|       |        }
 1033|    375|        drop(job_rx);
 1034|    375|        handles
 1035|    375|    }
 1036|       |
 1037|       |    #[cfg(feature = "mermaid-quickjs")]
 1038|      1|    fn store_mermaid_texture(&self, key: &str, texture: egui::TextureHandle, size: [u32; 2]) {
 1039|      1|        self.mermaid_textures
 1040|      1|            .borrow_mut()
 1041|      1|            .insert(key.to_string(), MermaidTextureEntry { texture, size });
 1042|      1|    }
 1043|       |
 1044|       |    #[cfg(feature = "mermaid-quickjs")]
 1045|     21|    fn mermaid_theme_values() -> MermaidThemeValues {
 1046|     21|        let def_main_bkg = "#FFF8DB";
 1047|     21|        let def_primary = "#D7EEFF";
 1048|     21|        let def_primary_border = "#9BB2C8";
 1049|     21|        let def_primary_text = "#1C2430";
 1050|     21|        let def_secondary = "#DFF5E1";
 1051|     21|        let def_tertiary = "#E9E2FF";
 1052|     21|        let def_line = "#6B7A90";
 1053|     21|        let def_text = "#1C2430";
 1054|     21|        let def_cluster_bkg = "#FFF1C1";
 1055|     21|        let def_cluster_border = "#E5C07B";
 1056|     21|        let def_default_link = def_line;
 1057|     21|        let def_title = def_text;
 1058|     21|        let def_label_bg = def_main_bkg;
 1059|     21|        let def_edge_label_bg = def_main_bkg;
 1060|       |
 1061|     21|        let theme_name =
 1062|     21|            std::env::var("MDMDVIEW_MERMAID_THEME").unwrap_or_else(|_| "base".to_string());
 1063|     21|        let main_bkg =
 1064|     21|            std::env::var("MDMDVIEW_MERMAID_MAIN_BKG").unwrap_or_else(|_| def_main_bkg.to_string());
 1065|     21|        let primary = std::env::var("MDMDVIEW_MERMAID_PRIMARY_COLOR")
 1066|     21|            .unwrap_or_else(|_| def_primary.to_string());
 1067|     21|        let primary_border = std::env::var("MDMDVIEW_MERMAID_PRIMARY_BORDER")
 1068|     21|            .unwrap_or_else(|_| def_primary_border.to_string());
 1069|     21|        let primary_text = std::env::var("MDMDVIEW_MERMAID_PRIMARY_TEXT")
 1070|     21|            .unwrap_or_else(|_| def_primary_text.to_string());
 1071|     21|        let secondary = std::env::var("MDMDVIEW_MERMAID_SECONDARY_COLOR")
 1072|     21|            .unwrap_or_else(|_| def_secondary.to_string());
 1073|     21|        let tertiary = std::env::var("MDMDVIEW_MERMAID_TERTIARY_COLOR")
 1074|     21|            .unwrap_or_else(|_| def_tertiary.to_string());
 1075|     21|        let line =
 1076|     21|            std::env::var("MDMDVIEW_MERMAID_LINE_COLOR").unwrap_or_else(|_| def_line.to_string());
 1077|     21|        let text =
 1078|     21|            std::env::var("MDMDVIEW_MERMAID_TEXT_COLOR").unwrap_or_else(|_| def_text.to_string());
 1079|     21|        let cluster_bkg = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BKG")
 1080|     21|            .unwrap_or_else(|_| def_cluster_bkg.to_string());
 1081|     21|        let cluster_border = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BORDER")
 1082|     21|            .unwrap_or_else(|_| def_cluster_border.to_string());
 1083|     21|        let default_link = std::env::var("MDMDVIEW_MERMAID_LINK_COLOR")
 1084|     21|            .unwrap_or_else(|_| def_default_link.to_string());
 1085|     21|        let title =
 1086|     21|            std::env::var("MDMDVIEW_MERMAID_TITLE_COLOR").unwrap_or_else(|_| def_title.to_string());
 1087|     21|        let label_bg =
 1088|     21|            std::env::var("MDMDVIEW_MERMAID_LABEL_BG").unwrap_or_else(|_| def_label_bg.to_string());
 1089|     21|        let edge_label_bg = std::env::var("MDMDVIEW_MERMAID_EDGE_LABEL_BG")
 1090|     21|            .unwrap_or_else(|_| def_edge_label_bg.to_string());
 1091|     21|        let font_family = std::env::var("MDMDVIEW_MERMAID_FONT_FAMILY")
 1092|     21|            .ok()
 1093|     21|            .map(|value| value.trim().to_string())
                                       ^3           ^3
 1094|     21|            .filter(|value| !value.is_empty());
                                           ^3    ^3
 1095|       |
 1096|     21|        MermaidThemeValues {
 1097|     21|            theme_name,
 1098|     21|            main_bkg,
 1099|     21|            primary,
 1100|     21|            primary_border,
 1101|     21|            primary_text,
 1102|     21|            secondary,
 1103|     21|            tertiary,
 1104|     21|            line,
 1105|     21|            text,
 1106|     21|            cluster_bkg,
 1107|     21|            cluster_border,
 1108|     21|            default_link,
 1109|     21|            title,
 1110|     21|            label_bg,
 1111|     21|            edge_label_bg,
 1112|     21|            font_family,
 1113|     21|        }
 1114|     21|    }
 1115|       |
 1116|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
 1117|     17|    fn mermaid_security_level() -> String {
 1118|     17|        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_SECURITY") {
                                ^3
 1119|      3|            let normalized = raw.trim().to_ascii_lowercase();
 1120|      3|            if normalized == "loose" {
 1121|      2|                return "loose".to_string();
 1122|      1|            }
 1123|     14|        }
 1124|     15|        "strict".to_string()
 1125|     17|    }
 1126|       |
 1127|       |    #[cfg(feature = "mermaid-quickjs")]
 1128|     14|    fn mermaid_site_config_json(svg_key: u64) -> String {
 1129|     14|        let theme = Self::mermaid_theme_values();
 1130|     14|        let security = Self::mermaid_security_level();
 1131|     14|        let seed = format!("m{:016x}", svg_key);
 1132|     14|        let mut entries = Vec::new();
 1133|       |
 1134|     14|        entries.push("\"startOnLoad\":false".to_string());
 1135|     14|        entries.push(format!(
 1136|     14|            "\"securityLevel\":\"{}\"",
 1137|     14|            Self::json_escape(&security)
 1138|       |        ));
 1139|     14|        entries.push("\"deterministicIds\":true".to_string());
 1140|     14|        entries.push(format!(
 1141|     14|            "\"deterministicIDSeed\":\"{}\"",
 1142|     14|            Self::json_escape(&seed)
 1143|       |        ));
 1144|     14|        entries.push(format!("\"maxTextSize\":{}", Self::MERMAID_MAX_TEXT_SIZE));
 1145|     14|        if security == "strict" {
 1146|     13|            entries.push("\"htmlLabels\":false".to_string());
 1147|     13|            entries.push("\"flowchart\":{\"htmlLabels\":false}".to_string());
 1148|     13|        }
                      ^1
 1149|     14|        entries.push(format!(
 1150|     14|            "\"theme\":\"{}\"",
 1151|     14|            Self::json_escape(&theme.theme_name)
 1152|       |        ));
 1153|       |
 1154|     14|        let mut theme_vars = format!(
 1155|     14|            concat!(
 1156|       |                "\"background\":\"{}\",",
 1157|       |                "\"mainBkg\":\"{}\",",
 1158|       |                "\"textColor\":\"{}\",",
 1159|       |                "\"titleColor\":\"{}\",",
 1160|       |                "\"primaryColor\":\"{}\",",
 1161|       |                "\"primaryBorderColor\":\"{}\",",
 1162|       |                "\"primaryTextColor\":\"{}\",",
 1163|       |                "\"secondaryColor\":\"{}\",",
 1164|       |                "\"tertiaryColor\":\"{}\",",
 1165|       |                "\"lineColor\":\"{}\",",
 1166|       |                "\"defaultLinkColor\":\"{}\",",
 1167|       |                "\"clusterBkg\":\"{}\",",
 1168|       |                "\"clusterBorder\":\"{}\",",
 1169|       |                "\"labelBackground\":\"{}\",",
 1170|       |                "\"edgeLabelBackground\":\"{}\""
 1171|       |            ),
 1172|     14|            Self::json_escape(&theme.main_bkg),
 1173|     14|            Self::json_escape(&theme.main_bkg),
 1174|     14|            Self::json_escape(&theme.text),
 1175|     14|            Self::json_escape(&theme.title),
 1176|     14|            Self::json_escape(&theme.primary),
 1177|     14|            Self::json_escape(&theme.primary_border),
 1178|     14|            Self::json_escape(&theme.primary_text),
 1179|     14|            Self::json_escape(&theme.secondary),
 1180|     14|            Self::json_escape(&theme.tertiary),
 1181|     14|            Self::json_escape(&theme.line),
 1182|     14|            Self::json_escape(&theme.default_link),
 1183|     14|            Self::json_escape(&theme.cluster_bkg),
 1184|     14|            Self::json_escape(&theme.cluster_border),
 1185|     14|            Self::json_escape(&theme.label_bg),
 1186|     14|            Self::json_escape(&theme.edge_label_bg)
 1187|       |        );
 1188|     14|        if let Some(font_family) = theme.font_family.as_ref() {
                                  ^1
 1189|      1|            theme_vars.push_str(&format!(
 1190|      1|                ",\"fontFamily\":\"{}\"",
 1191|      1|                Self::json_escape(font_family)
 1192|      1|            ));
 1193|     13|        }
 1194|     14|        entries.push(format!("\"themeVariables\":{{{}}}", theme_vars));
 1195|       |
 1196|     14|        format!("{{{}}}", entries.join(","))
 1197|     14|    }
 1198|       |
 1199|       |    #[cfg(feature = "mermaid-quickjs")]
 1200|    254|    fn json_escape(input: &str) -> String {
 1201|    254|        let mut out = String::with_capacity(input.len());
 1202|  1.89k|        for ch in input.chars() {
                                ^254  ^254
 1203|  1.89k|            match ch {
 1204|      1|                '\\' => out.push_str("\\\\"),
 1205|      1|                '"' => out.push_str("\\\""),
 1206|      1|                '\n' => out.push_str("\\n"),
 1207|      1|                '\r' => out.push_str("\\r"),
 1208|      1|                '\t' => out.push_str("\\t"),
 1209|  1.89k|                _ => out.push(ch),
 1210|       |            }
 1211|       |        }
 1212|    254|        out
 1213|    254|    }
 1214|       |
 1215|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
 1216|     24|    fn mermaid_bg_fill() -> Option<[u8; 4]> {
 1217|     24|        if let Ok(hex) = std::env::var("MDMDVIEW_MERMAID_BG_COLOR") {
                                ^3
 1218|      3|            if let Some(rgba) = Self::parse_hex_color(&hex) {
                                      ^2
 1219|      2|                return Some(rgba);
 1220|      1|            }
 1221|     21|        }
 1222|     22|        let mode = std::env::var("MDMDVIEW_MERMAID_BG").unwrap_or_else(|_| "theme".to_string());
                                                                                         ^16     ^16
 1223|     22|        match mode.as_str() {
 1224|     22|            "transparent" => None,
                                           ^1
 1225|     21|            "dark" => Some([20, 20, 20, 255]),
                                    ^2
 1226|     19|            "light" => Some([255, 255, 255, 255]),
                                     ^1
 1227|       |            _ => {
 1228|     18|                let hex = std::env::var("MDMDVIEW_MERMAID_MAIN_BKG")
 1229|     18|                    .unwrap_or_else(|_| "#FFF8DB".to_string());
                                                      ^16       ^16
 1230|     18|                Self::parse_hex_color(&hex).or(Some([255, 248, 219, 255]))
 1231|       |            }
 1232|       |        }
 1233|     24|    }
 1234|       |
 1235|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
 1236|     24|    fn parse_hex_color(s: &str) -> Option<[u8; 4]> {
 1237|     24|        let t = s.trim();
 1238|     24|        let hex = t.strip_prefix('#').unwrap_or(t);
 1239|     24|        let (r, g, b, a) = match hex.len() {
                           ^21^21^21^21
 1240|       |            6 => (
 1241|     19|                u8::from_str_radix(&hex[0..2], 16).ok()?,
                                                                     ^0
 1242|     19|                u8::from_str_radix(&hex[2..4], 16).ok()?,
                                                                     ^0
 1243|     19|                u8::from_str_radix(&hex[4..6], 16).ok()?,
                                                                     ^0
 1244|       |                255,
 1245|       |            ),
 1246|       |            8 => (
 1247|      2|                u8::from_str_radix(&hex[0..2], 16).ok()?,
                                                                     ^0
 1248|      2|                u8::from_str_radix(&hex[2..4], 16).ok()?,
                                                                     ^0
 1249|      2|                u8::from_str_radix(&hex[4..6], 16).ok()?,
                                                                     ^0
 1250|      2|                u8::from_str_radix(&hex[6..8], 16).ok()?,
                                                                     ^0
 1251|       |            ),
 1252|      3|            _ => return None,
 1253|       |        };
 1254|     21|        Some([r, g, b, a])
 1255|     24|    }
 1256|       |
 1257|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
 1258|     25|    fn hash_str(s: &str) -> u64 {
 1259|     25|        let mut h = DefaultHasher::new();
 1260|     25|        s.hash(&mut h);
 1261|     25|        h.finish()
 1262|     25|    }
 1263|       |}
 1264|       |
 1265|       |#[cfg(feature = "mermaid-quickjs")]
 1266|       |impl Drop for MermaidRenderer {
 1267|    382|    fn drop(&mut self) {
 1268|       |        // First, drop the job sender to close the channel.
 1269|       |        // This signals workers to exit their `for job in worker_rx.iter()` loop.
 1270|    382|        drop(self.mermaid_job_tx.take());
 1271|       |
 1272|       |        // Now join all worker threads to ensure they've fully exited
 1273|       |        // and released their resources (font database, QuickJS runtime).
 1274|  1.49k|        for handle in self.worker_handles.drain(..) {
                                    ^382                ^382  ^382
 1275|  1.49k|            let _ = handle.join();
 1276|  1.49k|        }
 1277|    382|    }
 1278|       |}
 1279|       |
 1280|       |#[cfg(feature = "mermaid-quickjs")]
 1281|       |struct TextMeasurer {
 1282|       |    fontdb: Arc<usvg::fontdb::Database>,
 1283|       |    face_id: Option<usvg::fontdb::ID>,
 1284|       |    bold_face_id: Option<usvg::fontdb::ID>,
 1285|       |}
 1286|       |
 1287|       |#[cfg(feature = "mermaid-quickjs")]
 1288|       |impl TextMeasurer {
 1289|       |    const BOLD_WIDTH_FALLBACK: f32 = 1.07;
 1290|       |    const BOLD_WIDTH_SCALE: f32 = 1.03;
 1291|       |    const LINE_HEIGHT_SCALE: f32 = 1.0;
 1292|       |
 1293|  1.52k|    fn new(fontdb: Arc<usvg::fontdb::Database>) -> Self {
 1294|  1.52k|        let families = [
 1295|  1.52k|            usvg::fontdb::Family::Name("Trebuchet MS"),
 1296|  1.52k|            usvg::fontdb::Family::Name("Verdana"),
 1297|  1.52k|            usvg::fontdb::Family::Name("Arial"),
 1298|  1.52k|            usvg::fontdb::Family::SansSerif,
 1299|  1.52k|        ];
 1300|  1.52k|        let query = usvg::fontdb::Query {
 1301|  1.52k|            families: &families,
 1302|  1.52k|            ..Default::default()
 1303|  1.52k|        };
 1304|  1.52k|        let face_id = fontdb.query(&query);
 1305|  1.52k|        let bold_query = usvg::fontdb::Query {
 1306|  1.52k|            families: &families,
 1307|  1.52k|            weight: usvg::fontdb::Weight::BOLD,
 1308|  1.52k|            ..Default::default()
 1309|  1.52k|        };
 1310|  1.52k|        let bold_face_id = fontdb.query(&bold_query).or(face_id);
 1311|  1.52k|        Self {
 1312|  1.52k|            fontdb,
 1313|  1.52k|            face_id,
 1314|  1.52k|            bold_face_id,
 1315|  1.52k|        }
 1316|  1.52k|    }
 1317|       |
 1318|     41|    fn measure_text(&self, text: &str, font_size: f32, font_weight: Option<f32>) -> (f32, f32) {
 1319|     41|        if text.is_empty() {
 1320|      1|            return (0.0, 0.0);
 1321|     40|        }
 1322|     40|        let size = if font_size.is_finite() && font_size > 0.0 {
                                                             ^39
 1323|     38|            font_size
 1324|       |        } else {
 1325|      2|            16.0
 1326|       |        };
 1327|     40|        let use_bold = font_weight.unwrap_or(400.0) >= 600.0;
 1328|     40|        let face_id = if use_bold {
 1329|      5|            self.bold_face_id.or(self.face_id)
 1330|       |        } else {
 1331|     35|            self.face_id
 1332|       |        };
 1333|     40|        if let Some((width, height)) = self.measure_with_face(face_id, text, size) {
                                   ^39    ^39
 1334|     39|            if use_bold {
 1335|      4|                let mut adjusted = width * Self::BOLD_WIDTH_SCALE;
 1336|      4|                if self.bold_face_id == self.face_id {
 1337|      1|                    adjusted *= Self::BOLD_WIDTH_FALLBACK;
 1338|      3|                }
 1339|      4|                return (adjusted, height);
 1340|     35|            }
 1341|     35|            return (width, height);
 1342|      1|        }
 1343|      1|        Self::fallback_measure(text, size)
 1344|     41|    }
 1345|       |
 1346|     40|    fn measure_with_face(
 1347|     40|        &self,
 1348|     40|        face_id: Option<usvg::fontdb::ID>,
 1349|     40|        text: &str,
 1350|     40|        font_size: f32,
 1351|     40|    ) -> Option<(f32, f32)> {
 1352|     40|        let face_id = face_id?;
                          ^39              ^1
 1353|     39|        self.fontdb
 1354|     39|            .with_face_data(face_id, |data, index| {
 1355|     39|                let face = ttf_parser::Face::parse(data, index).ok()?;
                                                                                  ^0
 1356|     39|                let units_per_em = face.units_per_em().max(1) as f32;
 1357|     39|                let scale = font_size / units_per_em;
 1358|     39|                let fallback_advance = units_per_em * 0.5;
 1359|     39|                let kern_subtables: Vec<_> = face
 1360|     39|                    .tables()
 1361|     39|                    .kern
 1362|     39|                    .map(|kern| {
 1363|     39|                        kern.subtables
 1364|     39|                            .into_iter()
 1365|     39|                            .filter(|table| table.horizontal)
 1366|     39|                            .collect()
 1367|     39|                    })
 1368|     39|                    .unwrap_or_default();
 1369|     39|                let mut max_width_units = 0.0_f32;
 1370|     39|                let mut line_count = 0u32;
 1371|       |
 1372|     39|                for line in text.split('\n') {
 1373|     39|                    line_count += 1;
 1374|     39|                    let mut width_units = 0.0_f32;
 1375|     39|                    let mut prev = None;
 1376|    160|                    for ch in line.chars() {
                                            ^39  ^39
 1377|    160|                        if let Some(glyph) = face.glyph_index(ch) {
                                                  ^159
 1378|    159|                            if let Some(prev_glyph) = prev {
                                                      ^121
 1379|    121|                                let mut kern = 0.0_f32;
 1380|    242|                                for table in &kern_subtables {
                                                  ^121
 1381|    121|                                    if let Some(value) = table.glyphs_kerning(prev_glyph, glyph) {
                                                              ^6
 1382|      6|                                        kern += value as f32;
 1383|    115|                                    }
 1384|       |                                }
 1385|    121|                                width_units += kern;
 1386|     38|                            }
 1387|    159|                            width_units += face
 1388|    159|                                .glyph_hor_advance(glyph)
 1389|    159|                                .map(|adv| adv as f32)
 1390|    159|                                .unwrap_or(fallback_advance);
 1391|    159|                            prev = Some(glyph);
 1392|      1|                        } else {
 1393|      1|                            width_units += fallback_advance;
 1394|      1|                            prev = None;
 1395|      1|                        }
 1396|       |                    }
 1397|     39|                    max_width_units = max_width_units.max(width_units);
 1398|       |                }
 1399|       |
 1400|     39|                let ascender = face.ascender() as f32;
 1401|     39|                let descender = face.descender() as f32;
 1402|     39|                let line_gap = face.line_gap() as f32;
 1403|     39|                let line_height_units = (ascender - descender + line_gap).max(units_per_em);
 1404|     39|                let line_height = line_height_units * scale * Self::LINE_HEIGHT_SCALE;
 1405|     39|                let width = max_width_units * scale;
 1406|     39|                let height = line_height * line_count as f32;
 1407|     39|                Some((width, height))
 1408|     39|            })
 1409|     39|            .flatten()
 1410|     40|    }
 1411|       |
 1412|      2|    fn fallback_measure(text: &str, font_size: f32) -> (f32, f32) {
 1413|      2|        let mut max_len = 0usize;
 1414|      2|        let mut lines = 0usize;
 1415|      3|        for line in text.split('\n') {
                                  ^2   ^2
 1416|      3|            lines += 1;
 1417|      3|            let len = line.chars().count();
 1418|      3|            if len > max_len {
 1419|      2|                max_len = len;
 1420|      2|            }
                          ^1
 1421|       |        }
 1422|      2|        let width = max_len as f32 * font_size * 0.5;
 1423|      2|        let height = lines as f32 * font_size * 1.2;
 1424|      2|        (width, height)
 1425|      2|    }
 1426|       |}
 1427|       |
 1428|       |#[cfg(feature = "mermaid-quickjs")]
 1429|       |struct MermaidWorker {
 1430|       |    engine: MermaidEngine,
 1431|       |    deadline_ms: Arc<AtomicU64>,
 1432|       |    fontdb: Arc<usvg::fontdb::Database>,
 1433|       |    #[allow(dead_code)]
 1434|       |    text_measurer: Arc<TextMeasurer>,
 1435|       |}
 1436|       |
 1437|       |#[cfg(feature = "mermaid-quickjs")]
 1438|       |impl MermaidWorker {
 1439|       |    const MEMORY_LIMIT_BYTES: usize = 2 * 1024 * 1024 * 1024;
 1440|       |    const STACK_LIMIT_BYTES: usize = 4 * 1024 * 1024;
 1441|       |
 1442|       |    // DOMPurify expects a real browser DOM; stub sanitize for the QuickJS shim.
 1443|  1.52k|    fn patch_mermaid_js(js: &str) -> String {
 1444|       |        const TARGET: &str = "var hD=wRe();";
 1445|       |        const PATCH: &str =
 1446|       |            "var hD=wRe();if(!hD||typeof hD.sanitize!==\"function\"){hD={sanitize:function(html){return String(html);},addHook:function(){},removeHook:function(){},removeHooks:function(){},removeAllHooks:function(){},isSupported:true};}";
 1447|       |        const D3_TARGET: &str = "FY.prototype={constructor:FY,appendChild:function(i){return this._parent.insertBefore(i,this._next)},insertBefore:function(i,s){return this._parent.insertBefore(i,s)},querySelector:function(i){return this._parent.querySelector(i)},querySelectorAll:function(i){return this._parent.querySelectorAll(i)}};";
 1448|       |        const D3_PATCH: &str = "FY.prototype={constructor:FY,appendChild:function(i){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p?p.insertBefore(i,this._next):i},insertBefore:function(i,s){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p?p.insertBefore(i,s):i},querySelector:function(i){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p&&p.querySelector?p.querySelector(i):null},querySelectorAll:function(i){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p&&p.querySelectorAll?p.querySelectorAll(i):[]}};";
 1449|       |        const D3_CTOR_TARGET: &str =
 1450|       |            "function FY(i,s){this.ownerDocument=i.ownerDocument,this.namespaceURI=i.namespaceURI,this._next=null,this._parent=i,this.__data__=s}";
 1451|       |        const D3_CTOR_PATCH: &str =
 1452|       |            "function FY(i,s){i=i||((typeof document!==\"undefined\"&&document.body)?document.body:null);this.ownerDocument=i&&i.ownerDocument?i.ownerDocument:(typeof document!==\"undefined\"?document:null);this.namespaceURI=i&&i.namespaceURI?i.namespaceURI:null;this._next=null;this._parent=i;this.__data__=s}";
 1453|       |        const TEXT_WRAP_TARGET: &str = "u.text().split(/(\\s+|<br>)/).reverse()";
 1454|       |        const TEXT_WRAP_PATCH: &str = concat!(
 1455|       |            "String(typeof u.text===\"function\"?u.text():(u.textContent||\"\"))",
 1456|       |            ".split(/(\\s+|<br>)/).reverse()"
 1457|       |        );
 1458|       |        const MINDMAP_LAYOUT_TARGET: &str =
 1459|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 1460|       |        const MINDMAP_LAYOUT_PATCH: &str =
 1461|       |            "p.layout({name:\"breadthfirst\",directed:!0,spacingFactor:1.4,animate:!1}).run()";
 1462|       |        const MINDMAP_READY_TARGET: &str =
 1463|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run(),p.ready(v=>{Xe.info(\"Ready\",v),u(p)})";
 1464|       |        const MINDMAP_READY_PATCH: &str =
 1465|       |            "p.layout({name:\"breadthfirst\",directed:!0,spacingFactor:1.4,animate:!1}).run(),u(p)";
 1466|       |        const MINDMAP_CYTO_TARGET: &str =
 1467|       |            "p=fWe({container:document.getElementById(\"cy\"),style:[{selector:\"edge\",style:{\"curve-style\":\"bezier\"}}]});";
 1468|       |        const MINDMAP_CYTO_PATCH: &str =
 1469|       |            "p=__mdmdview_cytoscape_stub({container:document.getElementById(\"cy\")});";
 1470|       |        const TIMELINE_BOUNDS_TARGET: &str = "const se=_.node().getBBox();";
 1471|       |        const TIMELINE_BOUNDS_PATCH: &str = concat!(
 1472|       |            "const se=_.node().getBBox();",
 1473|       |            "if(se&&typeof se.width===\"number\"&&typeof v===\"number\"){",
 1474|       |            "se.width=Math.max(0,se.width-2*v);",
 1475|       |            "}"
 1476|       |        );
 1477|  1.52k|        let mut out = if js.contains(TARGET) {
 1478|  1.52k|            js.replacen(TARGET, PATCH, 1)
 1479|       |        } else {
 1480|      6|            js.to_string()
 1481|       |        };
 1482|  1.52k|        let debug = std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG").is_ok();
 1483|  1.52k|        if out.contains(D3_CTOR_TARGET) {
 1484|  1.52k|            out = out.replacen(D3_CTOR_TARGET, D3_CTOR_PATCH, 1);
 1485|  1.52k|            if debug {
 1486|      1|                eprintln!("Mermaid patch: D3 ctor applied");
 1487|  1.52k|            }
 1488|      6|        } else if debug {
 1489|      2|            eprintln!("Mermaid patch: D3 ctor not found");
 1490|      4|        }
 1491|  1.52k|        if out.contains(D3_TARGET) {
 1492|  1.52k|            out = out.replacen(D3_TARGET, D3_PATCH, 1);
 1493|  1.52k|            if debug {
 1494|      1|                eprintln!("Mermaid patch: D3 enter applied");
 1495|  1.52k|            }
 1496|      6|        } else if debug {
 1497|      2|            eprintln!("Mermaid patch: D3 enter not found");
 1498|      4|        }
 1499|  1.52k|        if out.contains(TEXT_WRAP_TARGET) {
 1500|  1.52k|            out = out.replacen(TEXT_WRAP_TARGET, TEXT_WRAP_PATCH, 1);
 1501|  1.52k|            if debug {
 1502|      1|                eprintln!("Mermaid patch: D3 text wrap applied");
 1503|  1.52k|            }
 1504|      6|        } else if debug {
 1505|      2|            eprintln!("Mermaid patch: D3 text wrap not found");
 1506|      4|        }
 1507|  1.52k|        let mut mindmap_layout_patched = false;
 1508|  1.52k|        if out.contains(MINDMAP_CYTO_TARGET) {
 1509|  1.52k|            out = out.replacen(MINDMAP_CYTO_TARGET, MINDMAP_CYTO_PATCH, 1);
 1510|  1.52k|            if debug {
 1511|      1|                eprintln!("Mermaid patch: mindmap cytoscape stub applied");
 1512|  1.52k|            }
 1513|      6|        } else if debug {
 1514|      2|            eprintln!("Mermaid patch: mindmap cytoscape stub not found");
 1515|      4|        }
 1516|  1.52k|        if out.contains(MINDMAP_READY_TARGET) {
 1517|  1.52k|            out = out.replacen(MINDMAP_READY_TARGET, MINDMAP_READY_PATCH, 1);
 1518|  1.52k|            mindmap_layout_patched = true;
 1519|  1.52k|            if debug {
 1520|      1|                eprintln!("Mermaid patch: mindmap ready patch applied");
 1521|  1.52k|            }
 1522|      6|        } else if out.contains(MINDMAP_LAYOUT_TARGET) {
 1523|      4|            out = out.replacen(MINDMAP_LAYOUT_TARGET, MINDMAP_LAYOUT_PATCH, 1);
 1524|      4|            mindmap_layout_patched = true;
 1525|      4|            if debug {
 1526|      1|                eprintln!("Mermaid patch: mindmap layout applied");
 1527|      3|            }
 1528|      2|        }
 1529|  1.52k|        if !mindmap_layout_patched && debug {
                                                    ^2
 1530|      1|            eprintln!("Mermaid patch: mindmap layout not found");
 1531|  1.52k|        }
 1532|  1.52k|        if out.contains(TIMELINE_BOUNDS_TARGET) {
 1533|  1.52k|            out = out.replacen(TIMELINE_BOUNDS_TARGET, TIMELINE_BOUNDS_PATCH, 1);
 1534|  1.52k|            if debug {
 1535|      1|                eprintln!("Mermaid patch: timeline bounds applied");
 1536|  1.52k|            }
 1537|      6|        } else if debug {
 1538|      2|            eprintln!("Mermaid patch: timeline bounds not found");
 1539|      4|        }
 1540|  1.52k|        out
 1541|  1.52k|    }
 1542|       |
 1543|     24|    fn format_js_error(ctx: &rquickjs::Ctx<'_>, err: rquickjs::Error) -> String {
 1544|     24|        if let rquickjs::Error::Exception = err {
 1545|     23|            let value = ctx.catch();
 1546|     23|            if let Some(exception) = value.as_exception() {
                                      ^11
 1547|     11|                let message = exception.message().filter(|value| !value.trim().is_empty());
                                                                                ^10          ^10
 1548|     11|                let stack = exception.stack().filter(|value| !value.trim().is_empty());
                                                                            ^10          ^10
 1549|     11|                if let Some(stack) = stack {
                                          ^7
 1550|      7|                    if let Some(message) = &message {
                                              ^6
 1551|      6|                        if stack.contains(message) {
 1552|      1|                            return stack;
 1553|      5|                        }
 1554|      5|                        return format!("{}\n{}", message, stack);
 1555|      1|                    }
 1556|      1|                    return stack;
 1557|      4|                }
 1558|      4|                if let Some(message) = message {
                                          ^3
 1559|      3|                    return message;
 1560|      1|                }
 1561|     12|            }
 1562|     13|            if let Some(js_string) = value.as_string().and_then(|s| s.to_string().ok()) {
                                      ^1                                          ^1^1          ^1
 1563|      1|                return js_string;
 1564|     12|            }
 1565|     12|            if let Some(number) = value.as_int() {
                                      ^1
 1566|      1|                return number.to_string();
 1567|     11|            }
 1568|     11|            if let Some(number) = value.as_float() {
                                      ^1
 1569|      1|                return number.to_string();
 1570|     10|            }
 1571|     10|            if let Some(flag) = value.as_bool() {
                                      ^1
 1572|      1|                return flag.to_string();
 1573|      9|            }
 1574|      9|            return format!("{:?}", value);
 1575|      1|        }
 1576|      1|        err.to_string()
 1577|     24|    }
 1578|       |
 1579|  1.52k|    fn new(worker_idx: usize, fontdb: Arc<usvg::fontdb::Database>) -> Result<Self, String> {
 1580|       |        use rquickjs::Function;
 1581|  1.52k|        if mermaid_js_empty() {
 1582|      1|            return Err("No embedded Mermaid JS".to_string());
 1583|  1.52k|        }
 1584|       |        #[cfg(test)]
 1585|  1.52k|        if FORCE_MERMAID_WORKER_INIT_ERROR.swap(false, Ordering::Relaxed) {
 1586|      1|            return Err("Mermaid worker init forced error".to_string());
 1587|  1.52k|        }
 1588|  1.52k|        let rt = runtime_new_for_test()
                          ^1.52k
 1589|  1.52k|            .map_err(|e| format!("Mermaid runtime init error: {}", e))?;
                                       ^1      ^1                                   ^1
 1590|  1.52k|        rt.set_memory_limit(Self::MEMORY_LIMIT_BYTES);
 1591|  1.52k|        rt.set_max_stack_size(Self::STACK_LIMIT_BYTES);
 1592|  1.52k|        let deadline_ms = Arc::new(AtomicU64::new(0));
 1593|  1.52k|        let deadline_guard = Arc::clone(&deadline_ms);
 1594|  44.3k|        rt.set_interrupt_handler(Some(Box::new(move || {
                      ^1.52k^1.52k                     ^1.52k
 1595|  44.3k|            let deadline = deadline_guard.load(Ordering::Relaxed);
 1596|  44.3k|            if deadline == 0 {
 1597|  43.9k|                return false;
 1598|    343|            }
 1599|    343|            Self::now_ms() >= deadline
 1600|  44.3k|        })));
 1601|  1.52k|        let ctx = context_full_for_test(&rt)
                          ^1.52k
 1602|  1.52k|            .map_err(|e| format!("Mermaid context init error: {}", e))?;
                                       ^1      ^1                                   ^1
 1603|  1.52k|        let engine = MermaidEngine { rt, ctx };
 1604|  1.52k|        let text_measurer = Arc::new(TextMeasurer::new(Arc::clone(&fontdb)));
 1605|  1.52k|        let js = mermaid_js_str_for_test()
                          ^1.51k
 1606|  1.52k|            .map_err(|_| "Mermaid JS is not valid UTF-8".to_string())?;
                                       ^1                              ^1          ^1
 1607|  1.51k|        let js = Self::patch_mermaid_js(js);
 1608|  1.51k|        let init_result: Result<(), String> = engine.ctx.with(|ctx| {
 1609|  1.51k|            let measurer = Arc::clone(&text_measurer);
 1610|  1.51k|            let measure_fn = maybe_force_mermaid_init_error(
                              ^1.51k
 1611|       |                1,
 1612|  1.51k|                Function::new(
 1613|  1.51k|                    ctx.clone(),
 1614|     33|                    move |text: String, font_size: f64, font_weight: Option<f64>| {
 1615|     33|                        let weight = font_weight.map(|value| value as f32);
                                                                           ^32
 1616|     33|                        let (width, height) = measurer.measure_text(&text, font_size as f32, weight);
 1617|     33|                        vec![width as f64, height as f64]
 1618|     33|                    },
 1619|       |                ),
 1620|       |            )
 1621|  1.51k|            .map_err(|err| {
                                         ^1
 1622|      1|                format!(
 1623|      1|                    "Mermaid text measure init error: {}",
 1624|      1|                    MermaidWorker::format_js_error(&ctx, err)
 1625|       |                )
 1626|      1|            })?;
 1627|  1.51k|            maybe_force_mermaid_init_error(2, ctx.globals().set("__mdmdview_measure_text_native", measure_fn))
 1628|  1.51k|                .map_err(|err| {
                                             ^1
 1629|      1|                    format!(
 1630|      1|                        "Mermaid text measure init error: {}",
 1631|      1|                        MermaidWorker::format_js_error(&ctx, err)
 1632|       |                    )
 1633|      1|                })?;
 1634|  4.54k|            let eval = |label: &str, source: &str| -> Result<(), String> {
                              ^1.51k
 1635|  4.54k|                let result = maybe_force_mermaid_init_error(3, ctx.eval::<(), _>(source));
 1636|  4.54k|                result.map_err(|err| {
                                                   ^1
 1637|      1|                    format!("{}: {}", label, MermaidWorker::format_js_error(&ctx, err))
 1638|      1|                })
 1639|  4.54k|            };
 1640|  1.51k|            eval("Mermaid DOM shim", MERMAID_DOM_SHIM)?;
                                                                    ^1
 1641|  1.51k|            eval("Mermaid JS", &js)?;
                                                 ^0
 1642|  1.51k|            eval("Mermaid init", MERMAID_INIT_SNIPPET)?;
                                                                    ^0
 1643|  1.51k|            if std::env::var("MDMDVIEW_MERMAID_DOM_DEBUG").is_ok() {
 1644|      5|                let dom_ok = ctx
 1645|      5|                    .eval::<bool, _>(
 1646|      5|                        "var root=document.querySelector('body');var d=document.createElement('div');d.setAttribute('id','__mdmdview_dom_test');root.appendChild(d);var f=document.getElementById('__mdmdview_dom_test');!!(f&&f===d);",
 1647|      5|                    )
 1648|      5|                    .unwrap_or(false);
 1649|      5|                eprintln!("Mermaid DOM debug: {}", dom_ok);
 1650|  1.51k|            }
 1651|  1.51k|            Ok(())
 1652|  1.51k|        });
 1653|  1.51k|        Self::map_init_result(init_result)?;
                                                        ^3
 1654|  1.51k|        if worker_idx == 0 {
 1655|    397|            eprintln!(
 1656|    397|                "Mermaid embedded bytes: {}",
 1657|    397|                mermaid_embed::MERMAID_JS.len()
 1658|    397|            );
 1659|  1.11k|        }
 1660|  1.51k|        Ok(Self {
 1661|  1.51k|            engine,
 1662|  1.51k|            deadline_ms,
 1663|  1.51k|            fontdb,
 1664|  1.51k|            text_measurer,
 1665|  1.51k|        })
 1666|  1.52k|    }
 1667|       |
 1668|     12|    fn render_svg(
 1669|     12|        &mut self,
 1670|     12|        key: u64,
 1671|     12|        code: &str,
 1672|     12|        viewport_width: u32,
 1673|     12|        viewport_height: u32,
 1674|     12|    ) -> Result<String, String> {
 1675|       |        use rquickjs::{promise::MaybePromise, Function};
 1676|     12|        let timeout_ms = MermaidRenderer::mermaid_timeout_ms();
 1677|     12|        let deadline = Self::now_ms().saturating_add(timeout_ms);
 1678|     12|        self.deadline_ms.store(deadline, Ordering::Relaxed);
 1679|     12|        let result = self.engine.ctx.with(|ctx| {
 1680|     12|            let wrapper = MERMAID_RENDER_WRAPPER;
 1681|     12|            let func: Function = eval_mermaid_wrapper(&ctx, wrapper)
                              ^11   ^11
 1682|     12|                .map_err(|err| MermaidWorker::format_js_error(&ctx, err))?;
                                             ^1                             ^1    ^1   ^1
 1683|     11|            let id = format!("m{:016x}", key);
 1684|     11|            let site_config = MermaidRenderer::mermaid_site_config_json(key);
 1685|     11|            let maybe: MaybePromise = call_mermaid_render(
                              ^10    ^10
 1686|     11|                &func,
 1687|     11|                (
 1688|     11|                    id.as_str(),
 1689|     11|                    code,
 1690|     11|                    site_config.as_str(),
 1691|     11|                    viewport_width,
 1692|     11|                    viewport_height,
 1693|     11|                ),
 1694|       |            )
 1695|     11|            .map_err(|err| MermaidWorker::format_js_error(&ctx, err))?;
                                         ^1                             ^1    ^1   ^1
 1696|     10|            maybe
 1697|     10|                .finish::<String>()
 1698|     10|                .map_err(|err| MermaidWorker::format_js_error(&ctx, err))
                                             ^2                             ^2    ^2
 1699|     12|        });
 1700|     12|        self.deadline_ms.store(0, Ordering::Relaxed);
 1701|     12|        Self::format_render_result(result, deadline, Self::now_ms())
 1702|     12|    }
 1703|       |
 1704|  1.52k|    fn map_init_result(init_result: Result<(), String>) -> Result<(), String> {
 1705|  1.52k|        match init_result {
 1706|  1.51k|            Ok(()) => Ok(()),
 1707|      4|            Err(err) => Err(format!("Mermaid init error: {}", err)),
 1708|       |        }
 1709|  1.52k|    }
 1710|       |
 1711|     15|    fn format_render_result(
 1712|     15|        result: Result<String, String>,
 1713|     15|        deadline: u64,
 1714|     15|        now_ms: u64,
 1715|     15|    ) -> Result<String, String> {
 1716|     15|        match result {
 1717|      9|            Ok(svg) => Ok(svg),
 1718|      6|            Err(err) => {
 1719|      6|                if now_ms >= deadline {
 1720|      1|                    return Err("Mermaid render timed out".to_string());
 1721|      5|                }
 1722|      5|                Err(format!("Mermaid render error: {}", err))
 1723|       |            }
 1724|       |        }
 1725|     15|    }
 1726|       |
 1727|     13|    fn maybe_dump_svg(svg_key: u64, code: Option<&str>, svg: &str) {
 1728|     13|        let dir = match std::env::var("MDMDVIEW_MERMAID_DUMP_DIR") {
                          ^7
 1729|      8|            Ok(value) if !value.trim().is_empty() => value,
                             ^7                               ^7   ^7
 1730|      6|            _ => return,
 1731|       |        };
 1732|      7|        let dir = PathBuf::from(dir);
 1733|      7|        if std::fs::create_dir_all(&dir).is_err() {
 1734|      1|            return;
 1735|      6|        }
 1736|      6|        let label = code
 1737|      6|            .and_then(|snippet| snippet.lines().next())
                                              ^5              ^5
 1738|      6|            .unwrap_or("mermaid");
 1739|      6|        let mut name = String::new();
 1740|     70|        for ch in label.chars() {
                                ^6    ^6
 1741|     70|            if name.len() >= 32 {
 1742|      1|                break;
 1743|     69|            }
 1744|     69|            if ch.is_ascii_alphanumeric() || ch == '-' || ch == '_' {
                                                           ^3           ^2
 1745|     68|                name.push(ch);
 1746|     68|            } else {
 1747|      1|                name.push('_');
 1748|      1|            }
 1749|       |        }
 1750|      6|        if name.is_empty() {
 1751|      1|            name.push_str("mermaid");
 1752|      5|        }
 1753|      6|        let filename = format!("{:016x}_{}.svg", svg_key, name);
 1754|      6|        let path = dir.join(filename);
 1755|      6|        let _ = std::fs::write(path, svg);
 1756|     13|    }
 1757|       |
 1758|     13|    fn maybe_dump_error(svg_key: u64, code: Option<&str>, err: &str) {
 1759|     13|        let dir = match std::env::var("MDMDVIEW_MERMAID_DUMP_DIR") {
                          ^8
 1760|      9|            Ok(value) if !value.trim().is_empty() => value,
                             ^8                               ^8   ^8
 1761|      5|            _ => return,
 1762|       |        };
 1763|      8|        let dir = PathBuf::from(dir);
 1764|      8|        if std::fs::create_dir_all(&dir).is_err() {
 1765|      1|            return;
 1766|      7|        }
 1767|      7|        let label = code
 1768|      7|            .and_then(|snippet| snippet.lines().next())
                                              ^6              ^6
 1769|      7|            .unwrap_or("mermaid");
 1770|      7|        let mut name = String::new();
 1771|     80|        for ch in label.chars() {
                                ^7    ^7
 1772|     80|            if name.len() >= 32 {
 1773|      1|                break;
 1774|     79|            }
 1775|     79|            if ch.is_ascii_alphanumeric() || ch == '-' || ch == '_' {
                                                           ^7           ^6
 1776|     74|                name.push(ch);
 1777|     74|            } else {
 1778|      5|                name.push('_');
 1779|      5|            }
 1780|       |        }
 1781|      7|        if name.is_empty() {
 1782|      1|            name.push_str("mermaid");
 1783|      6|        }
 1784|      7|        let filename = format!("{:016x}_{}.err.txt", svg_key, name);
 1785|      7|        let path = dir.join(filename);
 1786|      7|        let mut payload = String::new();
 1787|      7|        payload.push_str("error: ");
 1788|      7|        payload.push_str(err);
 1789|      7|        payload.push('\n');
 1790|      7|        if let Some(code) = code {
                                  ^6
 1791|      6|            payload.push_str("\n---\n");
 1792|      6|            payload.push_str(code);
 1793|      6|            payload.push('\n');
 1794|      6|        }
                      ^1
 1795|      7|        let _ = std::fs::write(path, payload);
 1796|     13|    }
 1797|       |
 1798|     11|    fn normalize_svg_size(svg: &str) -> String {
 1799|     11|        let start = match svg.find("<svg") {
                          ^10
 1800|     10|            Some(idx) => idx,
 1801|      1|            None => return svg.to_string(),
 1802|       |        };
 1803|     10|        let end = match svg[start..].find('>') {
                          ^9
 1804|      9|            Some(idx) => start + idx,
 1805|      1|            None => return svg.to_string(),
 1806|       |        };
 1807|      9|        let tag = &svg[start..=end];
 1808|      9|        let viewbox = match Self::find_svg_attr(tag, "viewBox") {
                          ^8
 1809|      8|            Some(v) => v,
 1810|      1|            None => return svg.to_string(),
 1811|       |        };
 1812|      8|        let dims = Self::parse_viewbox_dims(&viewbox);
 1813|      8|        let (width, height) = match dims {
                           ^7     ^7
 1814|      7|            Some(pair) => pair,
 1815|      1|            None => return svg.to_string(),
 1816|       |        };
 1817|      7|        let mut new_tag = tag.to_string();
 1818|      7|        let width_attr = Self::find_svg_attr(&new_tag, "width");
 1819|      7|        if width_attr
 1820|      7|            .as_deref()
 1821|      7|            .map(|val| val.trim().ends_with('%'))
                                     ^6         ^6
 1822|      7|            .unwrap_or(true)
 1823|       |        {
 1824|      5|            let value = Self::format_dim(width);
 1825|      5|            new_tag = if width_attr.is_some() {
 1826|      4|                Self::replace_svg_attr(&new_tag, "width", &value)
 1827|       |            } else {
 1828|      1|                Self::insert_svg_attr(&new_tag, "width", &value)
 1829|       |            };
 1830|      2|        }
 1831|      7|        let height_attr = Self::find_svg_attr(&new_tag, "height");
 1832|      7|        if height_attr
 1833|      7|            .as_deref()
 1834|      7|            .map(|val| val.trim().ends_with('%'))
                                     ^4         ^4
 1835|      7|            .unwrap_or(true)
 1836|       |        {
 1837|      5|            let value = Self::format_dim(height);
 1838|      5|            new_tag = if height_attr.is_some() {
 1839|      2|                Self::replace_svg_attr(&new_tag, "height", &value)
 1840|       |            } else {
 1841|      3|                Self::insert_svg_attr(&new_tag, "height", &value)
 1842|       |            };
 1843|      2|        }
 1844|      7|        if new_tag == tag {
 1845|      2|            return svg.to_string();
 1846|      5|        }
 1847|      5|        let mut out = String::with_capacity(svg.len() + 32);
 1848|      5|        out.push_str(&svg[..start]);
 1849|      5|        out.push_str(&new_tag);
 1850|      5|        out.push_str(&svg[end + 1..]);
 1851|      5|        out
 1852|     11|    }
 1853|       |
 1854|     29|    fn replace_attr(tag: &str, name: &str, value: &str) -> String {
 1855|     29|        let needle = format!("{name}=\"");
 1856|     29|        let start = match tag.find(&needle) {
                          ^28
 1857|     28|            Some(idx) => idx + needle.len(),
 1858|      1|            None => return tag.to_string(),
 1859|       |        };
 1860|     28|        let end = match tag[start..].find('"') {
                          ^27
 1861|     27|            Some(idx) => start + idx,
 1862|      1|            None => return tag.to_string(),
 1863|       |        };
 1864|     27|        let mut out = String::with_capacity(tag.len() + value.len());
 1865|     27|        out.push_str(&tag[..start]);
 1866|     27|        out.push_str(value);
 1867|     27|        out.push_str(&tag[end..]);
 1868|     27|        out
 1869|     29|    }
 1870|       |
 1871|     25|    fn upsert_attr(tag: &str, name: &str, value: &str) -> String {
 1872|     25|        let needle = format!("{name}=\"");
 1873|     25|        if tag.contains(&needle) {
 1874|     18|            return Self::replace_attr(tag, name, value);
 1875|      7|        }
 1876|      7|        let insert_at = match tag.rfind('>') {
                          ^6
 1877|      6|            Some(pos) => pos,
 1878|      1|            None => return tag.to_string(),
 1879|       |        };
 1880|      6|        let mut out = String::with_capacity(tag.len() + name.len() + value.len() + 4);
 1881|      6|        out.push_str(&tag[..insert_at]);
 1882|      6|        out.push(' ');
 1883|      6|        out.push_str(name);
 1884|      6|        out.push_str("=\"");
 1885|      6|        out.push_str(value);
 1886|      6|        out.push('"');
 1887|      6|        out.push_str(&tag[insert_at..]);
 1888|      6|        out
 1889|     25|    }
 1890|       |
 1891|     10|    fn flatten_svg_switches(svg: &str) -> Option<String> {
 1892|     10|        if !svg.contains("<switch") {
 1893|      5|            return None;
 1894|      5|        }
 1895|      5|        let mut out = String::with_capacity(svg.len());
 1896|      5|        let mut remaining = svg;
 1897|      5|        let mut changed = false;
 1898|      8|        while let Some(start) = remaining.find("<switch") {
                                     ^5
 1899|      5|            let (before, after) = remaining.split_at(start);
 1900|      5|            out.push_str(before);
 1901|      5|            let open_end = match after.find('>') {
                              ^4
 1902|      4|                Some(pos) => pos + 1,
 1903|       |                None => {
 1904|      1|                    out.push_str(after);
 1905|      1|                    remaining = "";
 1906|      1|                    break;
 1907|       |                }
 1908|       |            };
 1909|      4|            let after_open = &after[open_end..];
 1910|      4|            let close_rel = match after_open.find("</switch>") {
                              ^3
 1911|      3|                Some(pos) => pos,
 1912|       |                None => {
 1913|      1|                    out.push_str(after);
 1914|      1|                    remaining = "";
 1915|      1|                    break;
 1916|       |                }
 1917|       |            };
 1918|      3|            let inner = &after_open[..close_rel];
 1919|      3|            let mut inner_out = String::with_capacity(inner.len());
 1920|      3|            let mut inner_remaining = inner;
 1921|      5|            while let Some(fo_start) = inner_remaining.find("<foreignObject") {
                                         ^3
 1922|      3|                let (inner_before, inner_after) = inner_remaining.split_at(fo_start);
 1923|      3|                inner_out.push_str(inner_before);
 1924|      3|                if let Some(fo_end_rel) = inner_after.find("</foreignObject>") {
                                          ^2
 1925|      2|                    inner_remaining = &inner_after[fo_end_rel + "</foreignObject>".len()..];
 1926|      2|                } else {
 1927|      1|                    inner_remaining = "";
 1928|      1|                    break;
 1929|       |                }
 1930|       |            }
 1931|      3|            inner_out.push_str(inner_remaining);
 1932|      3|            out.push_str(&inner_out);
 1933|      3|            changed = true;
 1934|      3|            remaining = &after_open[close_rel + "</switch>".len()..];
 1935|       |        }
 1936|      5|        out.push_str(remaining);
 1937|      5|        if changed {
 1938|      3|            Some(out)
 1939|       |        } else {
 1940|      2|            None
 1941|       |        }
 1942|     10|    }
 1943|       |
 1944|     12|    fn fix_journey_section_text(svg: &str, fill: &str) -> Option<String> {
 1945|     12|        if !svg.contains("journey-section") {
 1946|      5|            return None;
 1947|      7|        }
 1948|      7|        let mut out = String::with_capacity(svg.len() + 64);
 1949|      7|        let mut remaining = svg;
 1950|      7|        let mut changed = false;
 1951|     14|        while let Some(idx) = remaining.find("<text") {
                                     ^8
 1952|      8|            let (before, after) = remaining.split_at(idx);
 1953|      8|            out.push_str(before);
 1954|      8|            let end = match after.find('>') {
                              ^7
 1955|      7|                Some(pos) => pos + 1,
 1956|       |                None => {
 1957|      1|                    out.push_str(after);
 1958|      1|                    remaining = "";
 1959|      1|                    break;
 1960|       |                }
 1961|       |            };
 1962|      7|            let (tag, rest) = after.split_at(end);
 1963|      7|            if tag.contains("journey-section") {
 1964|      6|                let mut updated = tag.to_string();
 1965|      6|                if let Some(style_start) = updated.find(" style=\"") {
                                          ^4
 1966|      4|                    let value_start = style_start + " style=\"".len();
 1967|      4|                    if let Some(style_end) = updated[value_start..].find('"') {
                                              ^3
 1968|      3|                        let style_end = value_start + style_end;
 1969|      3|                        let mut style = updated[value_start..style_end].to_string();
 1970|      3|                        let parts: Vec<&str> = style.split(';').collect();
 1971|      3|                        let mut rebuilt: Vec<String> = Vec::new();
 1972|      9|                        for part in parts {
                                          ^6
 1973|      6|                            let trimmed = part.trim();
 1974|      6|                            if trimmed.is_empty() {
 1975|      1|                                continue;
 1976|      5|                            }
 1977|      5|                            if trimmed.starts_with("fill:") {
 1978|      3|                                continue;
 1979|      2|                            }
 1980|      2|                            rebuilt.push(trimmed.to_string());
 1981|       |                        }
 1982|      3|                        rebuilt.push(format!("fill:{}", fill));
 1983|      3|                        style = rebuilt.join(";");
 1984|      3|                        updated.replace_range(value_start..style_end, &style);
 1985|      3|                        out.push_str(&updated);
 1986|      3|                        changed = true;
 1987|      1|                    } else {
 1988|      1|                        out.push_str(tag);
 1989|      1|                    }
 1990|      2|                } else {
 1991|      2|                    let insert_at = updated.len().saturating_sub(1);
 1992|      2|                    updated.insert_str(insert_at, &format!(" style=\"fill:{};\"", fill));
 1993|      2|                    out.push_str(&updated);
 1994|      2|                    changed = true;
 1995|      2|                }
 1996|      1|            } else {
 1997|      1|                out.push_str(tag);
 1998|      1|            }
 1999|      7|            remaining = rest;
 2000|       |        }
 2001|      7|        out.push_str(remaining);
 2002|      7|        if changed {
 2003|      5|            Some(out)
 2004|       |        } else {
 2005|      2|            None
 2006|       |        }
 2007|     12|    }
 2008|       |
 2009|     16|    fn find_circle_tag(body: &str, class_name: &str) -> Option<(usize, usize, String)> {
 2010|     16|        let needle = format!("class=\"{class_name}\"");
 2011|     16|        let class_idx = body.find(&needle)?;
                          ^15                           ^1
 2012|     15|        let start = body[..class_idx].rfind("<circle")?;
                                                                    ^0
 2013|     15|        let end = body[class_idx..].find('>')? + class_idx + 1;
                                                           ^0
 2014|     15|        Some((start, end, body[start..end].to_string()))
 2015|     16|    }
 2016|       |
 2017|     14|    fn read_r_value(tag: &str) -> Option<String> {
 2018|     14|        let needle = "r=\"";
 2019|     14|        let start = tag.find(needle)? + needle.len();
                          ^13                     ^1  ^13    ^13
 2020|     13|        let end = tag[start..].find('"')? + start;
                                                      ^0
 2021|     13|        Some(tag[start..end].to_string())
 2022|     14|    }
 2023|       |
 2024|     15|    fn fix_state_end_circles(svg: &str) -> Option<String> {
 2025|     15|        if !svg.contains("state-end") {
 2026|      5|            return None;
 2027|     10|        }
 2028|     10|        let mut out = String::with_capacity(svg.len());
 2029|     10|        let mut cursor = 0;
 2030|     10|        let mut changed = false;
 2031|     19|        while let Some(g_pos_rel) = svg[cursor..].find("<g") {
                                     ^11
 2032|     11|            let g_pos = cursor + g_pos_rel;
 2033|     11|            out.push_str(&svg[cursor..g_pos]);
 2034|     11|            let g_end = match svg[g_pos..].find('>') {
                              ^10
 2035|     10|                Some(pos) => g_pos + pos + 1,
 2036|       |                None => {
 2037|      1|                    out.push_str(&svg[g_pos..]);
 2038|      1|                    cursor = svg.len();
 2039|      1|                    break;
 2040|       |                }
 2041|       |            };
 2042|     10|            let g_tag = &svg[g_pos..g_end];
 2043|     10|            let is_end_group = g_tag.contains("root_end") || g_tag.contains("state-end");
                                                                           ^2    ^2
 2044|     10|            if !is_end_group {
 2045|      1|                out.push_str(g_tag);
 2046|      1|                cursor = g_end;
 2047|      1|                continue;
 2048|      9|            }
 2049|      9|            let close_rel = match svg[g_end..].find("</g>") {
                              ^8
 2050|      8|                Some(pos) => pos,
 2051|       |                None => {
 2052|      1|                    out.push_str(&svg[g_pos..]);
 2053|      1|                    cursor = svg.len();
 2054|      1|                    break;
 2055|       |                }
 2056|       |            };
 2057|      8|            let body_end = g_end + close_rel;
 2058|      8|            let body = &svg[g_end..body_end];
 2059|      8|            let mut body_out = body.to_string();
 2060|       |            if let (
 2061|      7|                Some((s_start, s_end, state_end_tag)),
 2062|      7|                Some((t_start, t_end, state_start_tag)),
 2063|       |            ) = (
 2064|      8|                Self::find_circle_tag(body, "state-end"),
 2065|      8|                Self::find_circle_tag(body, "state-start"),
 2066|       |            ) {
 2067|      6|                if let (Some(end_r), Some(start_r)) = (
 2068|      7|                    Self::read_r_value(&state_end_tag),
 2069|      7|                    Self::read_r_value(&state_start_tag),
 2070|       |                ) {
 2071|      6|                    let end_val = end_r.parse::<f32>().ok();
 2072|      6|                    let start_val = start_r.parse::<f32>().ok();
 2073|      6|                    if let (Some(end_val), Some(start_val)) = (end_val, start_val) {
                                               ^5             ^5
 2074|      5|                        if end_val < start_val {
 2075|      4|                            let end_dim = Self::format_dim(start_val * 2.0);
 2076|      4|                            let start_dim = Self::format_dim(end_val * 2.0);
 2077|      4|                            let mut new_end_tag = Self::replace_attr(&state_end_tag, "r", &start_r);
 2078|      4|                            let mut new_start_tag =
 2079|      4|                                Self::replace_attr(&state_start_tag, "r", &end_r);
 2080|      4|                            new_end_tag = Self::upsert_attr(&new_end_tag, "width", &end_dim);
 2081|      4|                            new_end_tag = Self::upsert_attr(&new_end_tag, "height", &end_dim);
 2082|      4|                            new_start_tag = Self::upsert_attr(&new_start_tag, "width", &start_dim);
 2083|      4|                            new_start_tag = Self::upsert_attr(&new_start_tag, "height", &start_dim);
 2084|      4|                            new_start_tag = new_start_tag.replace("state-start", "end-state-inner");
 2085|      4|                            let mut rebuilt = String::with_capacity(body.len() + 16);
 2086|       |                            let (
 2087|      4|                                first_start,
 2088|      4|                                first_end,
 2089|      4|                                first_tag,
 2090|      4|                                second_start,
 2091|      4|                                second_end,
 2092|      4|                                second_tag,
 2093|      4|                            ) = if s_start <= t_start {
 2094|      3|                                (s_start, s_end, new_end_tag, t_start, t_end, new_start_tag)
 2095|       |                            } else {
 2096|      1|                                (t_start, t_end, new_start_tag, s_start, s_end, new_end_tag)
 2097|       |                            };
 2098|      4|                            rebuilt.push_str(&body[..first_start]);
 2099|      4|                            rebuilt.push_str(&first_tag);
 2100|      4|                            rebuilt.push_str(&body[first_end..second_start]);
 2101|      4|                            rebuilt.push_str(&second_tag);
 2102|      4|                            rebuilt.push_str(&body[second_end..]);
 2103|      4|                            body_out = rebuilt;
 2104|      4|                            changed = true;
 2105|      1|                        }
 2106|      1|                    }
 2107|      1|                }
 2108|      1|            }
 2109|      8|            out.push_str(g_tag);
 2110|      8|            out.push_str(&body_out);
 2111|      8|            out.push_str("</g>");
 2112|      8|            cursor = body_end + 4;
 2113|       |        }
 2114|     10|        out.push_str(&svg[cursor..]);
 2115|     10|        if changed {
 2116|      4|            Some(out)
 2117|       |        } else {
 2118|      6|            None
 2119|       |        }
 2120|     15|    }
 2121|       |
 2122|     11|    fn fix_er_attribute_fills(svg: &str) -> Option<String> {
 2123|     11|        if !svg.contains("attributeBoxOdd") && !svg.contains("attributeBoxEven") {
                                                             ^6
 2124|      5|            return None;
 2125|      6|        }
 2126|      6|        let mut out = String::with_capacity(svg.len() + 32);
 2127|      6|        let mut remaining = svg;
 2128|      6|        let mut changed = false;
 2129|     13|        while let Some(idx) = remaining.find("<rect") {
                                     ^8
 2130|      8|            let (before, after) = remaining.split_at(idx);
 2131|      8|            out.push_str(before);
 2132|      8|            let end = match after.find('>') {
                              ^7
 2133|      7|                Some(pos) => pos + 1,
 2134|       |                None => {
 2135|      1|                    out.push_str(after);
 2136|      1|                    remaining = "";
 2137|      1|                    break;
 2138|       |                }
 2139|       |            };
 2140|      7|            let (tag, rest) = after.split_at(end);
 2141|      7|            let mut updated = tag.to_string();
 2142|      7|            if tag.contains("attributeBoxOdd") {
 2143|      4|                updated = Self::upsert_attr(&updated, "fill", "#ffffff");
 2144|      4|            } else if tag.contains("attributeBoxEven") {
                                    ^3  ^3
 2145|      2|                updated = Self::upsert_attr(&updated, "fill", "#f2f2f2");
 2146|      2|            }
                          ^1
 2147|      7|            if updated != tag {
 2148|      5|                changed = true;
 2149|      5|            }
                          ^2
 2150|      7|            out.push_str(&updated);
 2151|      7|            remaining = rest;
 2152|       |        }
 2153|      6|        out.push_str(remaining);
 2154|      6|        if changed {
 2155|      4|            Some(out)
 2156|       |        } else {
 2157|      2|            None
 2158|       |        }
 2159|     11|    }
 2160|       |
 2161|     43|    fn find_svg_attr(tag: &str, name: &str) -> Option<String> {
 2162|     43|        let needle = format!("{name}=\"");
 2163|     43|        let start = tag.find(&needle)? + needle.len();
                          ^32                      ^11 ^32    ^32
 2164|     32|        let end = tag[start..].find('"')? + start;
                                                      ^0
 2165|     32|        Some(tag[start..end].to_string())
 2166|     43|    }
 2167|       |
 2168|      8|    fn replace_svg_attr(tag: &str, name: &str, value: &str) -> String {
 2169|      8|        let needle = format!("{name}=\"");
 2170|      8|        let start = match tag.find(&needle) {
                          ^7
 2171|      7|            Some(idx) => idx + needle.len(),
 2172|      1|            None => return tag.to_string(),
 2173|       |        };
 2174|      7|        let end = match tag[start..].find('"') {
                          ^6
 2175|      6|            Some(idx) => start + idx,
 2176|      1|            None => return tag.to_string(),
 2177|       |        };
 2178|      6|        let mut out = String::with_capacity(tag.len() + value.len());
 2179|      6|        out.push_str(&tag[..start]);
 2180|      6|        out.push_str(value);
 2181|      6|        out.push_str(&tag[end..]);
 2182|      6|        out
 2183|      8|    }
 2184|       |
 2185|     27|    fn remove_svg_attr(tag: &str, name: &str) -> String {
 2186|     27|        let needle = format!("{name}=\"");
 2187|     27|        let start = match tag.find(&needle) {
                          ^19
 2188|     19|            Some(idx) => idx,
 2189|      8|            None => return tag.to_string(),
 2190|       |        };
 2191|     19|        let value_start = start + needle.len();
 2192|     19|        let end = match tag[value_start..].find('"') {
                          ^18
 2193|     18|            Some(idx) => value_start + idx + 1,
 2194|      1|            None => return tag.to_string(),
 2195|       |        };
 2196|     18|        let mut out = String::with_capacity(tag.len());
 2197|     18|        out.push_str(&tag[..start]);
 2198|     18|        let rest = &tag[end..];
 2199|     18|        if out.ends_with(' ') && rest.starts_with(' ') {
                                               ^17  ^17
 2200|     16|            out.pop();
 2201|     16|        }
                      ^2
 2202|     18|        out.push_str(rest);
 2203|     18|        out
 2204|     27|    }
 2205|       |
 2206|     22|    fn strip_svg_attr(svg: &str, name: &str) -> Option<String> {
 2207|     22|        let start = svg.find("<svg")?;
                                                  ^0
 2208|     22|        let end = svg[start..].find('>')? + start;
                                                      ^0
 2209|     22|        let tag = &svg[start..=end];
 2210|     22|        let new_tag = Self::remove_svg_attr(tag, name);
 2211|     22|        if new_tag == tag {
 2212|      7|            return None;
 2213|     15|        }
 2214|     15|        let mut out = String::with_capacity(svg.len());
 2215|     15|        out.push_str(&svg[..start]);
 2216|     15|        out.push_str(&new_tag);
 2217|     15|        out.push_str(&svg[end + 1..]);
 2218|     15|        Some(out)
 2219|     22|    }
 2220|       |
 2221|      6|    fn insert_svg_attr(tag: &str, name: &str, value: &str) -> String {
 2222|      6|        let insert_pos = match tag.find("<svg") {
                          ^5
 2223|      5|            Some(idx) => idx + 4,
 2224|      1|            None => return tag.to_string(),
 2225|       |        };
 2226|      5|        let mut out = String::with_capacity(tag.len() + name.len() + value.len() + 4);
 2227|      5|        out.push_str(&tag[..insert_pos]);
 2228|      5|        out.push_str(&format!(" {name}=\"{value}\""));
 2229|      5|        out.push_str(&tag[insert_pos..]);
 2230|      5|        out
 2231|      6|    }
 2232|       |
 2233|     30|    fn parse_viewbox_dims(viewbox: &str) -> Option<(f32, f32)> {
 2234|     30|        let mut nums = Vec::new();
 2235|    114|        for part in viewbox
                                  ^30
 2236|    395|            .split(|c: char| c.is_whitespace() || c == ',')
                           ^30                                  ^317
 2237|    114|            .filter(|part| !part.is_empty())
                           ^30
 2238|       |        {
 2239|    114|            if let Ok(value) = part.parse::<f32>() {
                                    ^112
 2240|    112|                nums.push(value);
 2241|    112|            }
                          ^2
 2242|       |        }
 2243|     30|        if nums.len() < 4 {
 2244|      2|            return None;
 2245|     28|        }
 2246|     28|        let width = nums[2];
 2247|     28|        let height = nums[3];
 2248|     28|        if width.is_finite() && height.is_finite() && width > 0.0 && height > 0.0 {
                                              ^26    ^26            ^25            ^23
 2249|     22|            Some((width, height))
 2250|       |        } else {
 2251|      6|            None
 2252|       |        }
 2253|     30|    }
 2254|       |
 2255|     23|    fn format_dim(value: f32) -> String {
 2256|     23|        let mut out = format!("{:.3}", value);
 2257|     67|        while out.contains('.') && out.ends_with('0') {
                                                 ^66
 2258|     44|            out.pop();
 2259|     44|        }
 2260|     23|        if out.ends_with('.') {
 2261|     14|            out.pop();
 2262|     14|        }
                      ^9
 2263|     23|        out
 2264|     23|    }
 2265|       |
 2266|      8|    fn process_job(&mut self, job: MermaidRequest) -> MermaidResult {
 2267|       |        let MermaidRequest {
 2268|      8|            svg_key,
 2269|      8|            texture_key,
 2270|      8|            code,
 2271|      8|            svg,
 2272|      8|            width_bucket,
 2273|      8|            scale_bucket,
 2274|      8|            viewport_width,
 2275|      8|            viewport_height,
 2276|      8|            bg,
 2277|      8|        } = job;
 2278|      8|        let code_ref = code.as_deref();
 2279|      8|        let svg_result = match svg {
 2280|      2|            Some(svg) => Ok(svg),
 2281|      6|            None => match code_ref {
 2282|      5|                Some(code) => self.render_svg(svg_key, code, viewport_width, viewport_height),
 2283|      1|                None => Err("Mermaid render request missing code".to_string()),
 2284|       |            },
 2285|       |        };
 2286|       |
 2287|      8|        match svg_result {
 2288|      5|            Ok(svg) => {
 2289|      5|                let mut svg = Self::normalize_svg_size(&svg);
 2290|      5|                if let Some(updated) = Self::flatten_svg_switches(&svg) {
                                          ^1
 2291|      1|                    svg = updated;
 2292|      4|                }
 2293|      5|                let theme = MermaidRenderer::mermaid_theme_values();
 2294|      5|                if let Some(updated) = Self::fix_journey_section_text(&svg, &theme.text) {
                                          ^1
 2295|      1|                    svg = updated;
 2296|      4|                }
 2297|      5|                if let Some(updated) = Self::fix_state_end_circles(&svg) {
                                          ^1
 2298|      1|                    svg = updated;
 2299|      4|                }
 2300|      5|                if let Some(updated) = Self::fix_er_attribute_fills(&svg) {
                                          ^1
 2301|      1|                    svg = updated;
 2302|      4|                }
 2303|      5|                Self::maybe_dump_svg(svg_key, code_ref, &svg);
 2304|      5|                match self.rasterize_svg(&svg, width_bucket, scale_bucket, bg) {
 2305|      4|                    Ok((rgba, w, h)) => MermaidResult {
 2306|      4|                        svg_key,
 2307|      4|                        texture_key,
 2308|      4|                        svg: Some(svg),
 2309|      4|                        rgba: Some(rgba),
 2310|      4|                        size: Some((w, h)),
 2311|      4|                        error: None,
 2312|      4|                    },
 2313|      1|                    Err(err) => {
 2314|      1|                        Self::maybe_dump_error(svg_key, code_ref, &err);
 2315|      1|                        MermaidResult {
 2316|      1|                            svg_key,
 2317|      1|                            texture_key,
 2318|      1|                            svg: Some(svg),
 2319|      1|                            rgba: None,
 2320|      1|                            size: None,
 2321|      1|                            error: Some(err),
 2322|      1|                        }
 2323|       |                    }
 2324|       |                }
 2325|       |            }
 2326|      3|            Err(err) => {
 2327|      3|                Self::maybe_dump_error(svg_key, code_ref, &err);
 2328|      3|                MermaidResult {
 2329|      3|                    svg_key,
 2330|      3|                    texture_key,
 2331|      3|                    svg: None,
 2332|      3|                    rgba: None,
 2333|      3|                    size: None,
 2334|      3|                    error: Some(err),
 2335|      3|                }
 2336|       |            }
 2337|       |        }
 2338|      8|    }
 2339|       |
 2340|     15|    fn parse_raw_svg_tree(svg: &str, opt: &usvg::Options) -> Result<usvg::Tree, String> {
 2341|       |        #[cfg(test)]
 2342|     15|        if FORCE_RAW_TREE_PARSE_FAIL.swap(false, Ordering::Relaxed) {
 2343|      1|            return Err("forced raw svg parse failure".to_string());
 2344|     14|        }
 2345|     14|        usvg::Tree::from_data(svg.as_bytes(), opt).map_err(|e| format!("{}", e))
                                                                             ^1      ^1
 2346|     15|    }
 2347|       |
 2348|     40|    fn bbox_is_valid(width: f32, height: f32, x: f32, y: f32) -> bool {
 2349|     40|        width.is_finite()
 2350|     39|            && height.is_finite()
 2351|     38|            && width > 0.5
 2352|     25|            && height > 0.5
 2353|     24|            && x.is_finite()
 2354|     23|            && y.is_finite()
 2355|     40|    }
 2356|       |
 2357|     16|    fn should_resize_bbox(
 2358|     16|        force_resize: bool,
 2359|     16|        oversize_ok: bool,
 2360|     16|        bbox_w: f32,
 2361|     16|        bbox_h: f32,
 2362|     16|        w_f: f32,
 2363|     16|        h_f: f32,
 2364|     16|    ) -> bool {
 2365|     16|        (force_resize && oversize_ok) || (oversize_ok && (bbox_w > w_f * 1.2 || bbox_h > h_f * 1.2))
                                       ^4               ^13             ^10                   ^7
 2366|     16|    }
 2367|       |
 2368|     22|    fn rasterize_svg(
 2369|     22|        &self,
 2370|     22|        svg: &str,
 2371|     22|        width_bucket: u32,
 2372|     22|        scale_bucket: u32,
 2373|     22|        bg: Option<[u8; 4]>,
 2374|     22|    ) -> Result<(Vec<u8>, u32, u32), String> {
 2375|     22|        let opt = usvg::Options {
 2376|     22|            resources_dir: None,
 2377|     22|            fontdb: Arc::clone(&self.fontdb),
 2378|     22|            image_href_resolver: Self::image_href_resolver(),
 2379|     22|            ..Default::default()
 2380|     22|        };
 2381|       |
 2382|     22|        let tree = usvg::Tree::from_data(svg.as_bytes(), &opt).map_err(|e| format!("{}", e))?;
                          ^20                                                            ^2      ^2       ^2
 2383|     20|        let mut tree = tree;
 2384|     20|        let sz = tree.size().to_int_size();
 2385|     20|        let (mut w, mut h) = (sz.width(), sz.height());
 2386|     20|        let viewbox_dims = Self::find_svg_attr(svg, "viewBox")
 2387|     20|            .and_then(|value| Self::parse_viewbox_dims(&value))
                                            ^14                      ^14
 2388|     20|            .filter(|(vw, vh)| *vw > 0.5 && *vh > 0.5);
                                             ^13          ^12
 2389|     20|        if let Some((vw, vh)) = viewbox_dims {
                                   ^12 ^12
 2390|     12|            w = vw.ceil() as u32;
 2391|     12|            h = vh.ceil() as u32;
 2392|     12|        }
                      ^8
 2393|     20|        let mut translate_x = 0.0_f32;
 2394|     20|        let mut translate_y = 0.0_f32;
 2395|       |
 2396|     20|        let mut bbox = tree.root().abs_stroke_bounding_box();
 2397|     20|        let mut bbox_w = bbox.width();
 2398|     20|        let mut bbox_h = bbox.height();
 2399|     20|        let mut bbox_valid = Self::bbox_is_valid(bbox_w, bbox_h, bbox.x(), bbox.y());
 2400|     20|        let mut force_bbox_resize = false;
 2401|       |
 2402|     20|        let oversize_cap = 6.0_f32;
 2403|     20|        if let Some(raw_svg) = Self::strip_svg_attr(svg, "viewBox") {
                                  ^14
 2404|     14|            if let Ok(raw_tree) = Self::parse_raw_svg_tree(&raw_svg, &opt) {
                                    ^13
 2405|     13|                let raw_bbox = raw_tree.root().abs_stroke_bounding_box();
 2406|     13|                let raw_w = raw_bbox.width();
 2407|     13|                let raw_h = raw_bbox.height();
 2408|     13|                let raw_valid = Self::bbox_is_valid(raw_w, raw_h, raw_bbox.x(), raw_bbox.y());
 2409|     13|                let size_w = w as f32;
 2410|     13|                let size_h = h as f32;
 2411|     13|                let oversize_ok = raw_w <= size_w * oversize_cap && raw_h <= size_h * oversize_cap;
                                                                                  ^12
 2412|     13|                let oversized =
 2413|     13|                    raw_valid && oversize_ok && (raw_w > size_w * 1.2 || raw_h > size_h * 1.2);
                                               ^10             ^9                      ^8
 2414|     13|                if oversized {
 2415|      2|                    tree = raw_tree;
 2416|      2|                    bbox = raw_bbox;
 2417|      2|                    bbox_w = raw_w;
 2418|      2|                    bbox_h = raw_h;
 2419|      2|                    bbox_valid = raw_valid;
 2420|      2|                    force_bbox_resize = true;
 2421|     11|                }
 2422|      1|            }
 2423|      6|        }
 2424|     20|        if bbox_valid {
 2425|     11|            let w_f = w as f32;
 2426|     11|            let h_f = h as f32;
 2427|     11|            let oversize_ok = bbox_w <= w_f * oversize_cap && bbox_h <= h_f * oversize_cap;
                                                                            ^10
 2428|     11|            let oversize =
 2429|     11|                Self::should_resize_bbox(force_bbox_resize, oversize_ok, bbox_w, bbox_h, w_f, h_f);
 2430|     11|            if oversize {
 2431|      4|                let padding = 4.0_f32;
 2432|      4|                let padded_w = (bbox_w + padding * 2.0).max(1.0);
 2433|      4|                let padded_h = (bbox_h + padding * 2.0).max(1.0);
 2434|      4|                w = padded_w.ceil() as u32;
 2435|      4|                h = padded_h.ceil() as u32;
 2436|      4|                translate_x = -bbox.x() + padding;
 2437|      4|                translate_y = -bbox.y() + padding;
 2438|      7|            }
 2439|      9|        }
 2440|       |
 2441|     20|        let base_scale = MermaidRenderer::scale_from_bucket(scale_bucket);
 2442|     20|        let mut scale = base_scale;
 2443|     20|        if width_bucket > 0 {
 2444|      4|            let width_scale = width_bucket as f32 / w.max(1) as f32;
 2445|      4|            scale = scale.min(width_scale);
 2446|     16|        }
 2447|     20|        scale = scale.clamp(0.01, 4.0);
 2448|     20|        let adjustment = Self::scale_adjustment_for_svg(svg);
 2449|     20|        scale = (scale * adjustment).clamp(0.01, 4.0);
 2450|       |
 2451|     20|        let mut target_w = (w as f32 * scale).round() as u32;
 2452|     20|        let mut target_h = (h as f32 * scale).round() as u32;
 2453|     20|        target_w = target_w.max(1);
 2454|     20|        target_h = target_h.max(1);
 2455|       |
 2456|     20|        if std::env::var("MDMDVIEW_MERMAID_LOG_RASTER").is_ok() {
 2457|      2|            eprintln!(
 2458|      2|                "Mermaid raster: svg={}x{} target={}x{} scale={:.3} bbox_valid={} bbox=({:.2},{:.2},{:.2},{:.2})",
 2459|      2|                w,
 2460|      2|                h,
 2461|      2|                target_w,
 2462|      2|                target_h,
 2463|      2|                scale,
 2464|      2|                bbox_valid,
 2465|      2|                bbox.x(),
 2466|      2|                bbox.y(),
 2467|      2|                bbox_w,
 2468|      2|                bbox_h
 2469|      2|            );
 2470|     18|        }
 2471|       |
 2472|     20|        let max_side = MermaidRenderer::MERMAID_MAX_RENDER_SIDE;
 2473|     20|        if target_w > max_side || target_h > max_side {
                                                ^18
 2474|      3|            let clamp_scale =
 2475|      3|                (max_side as f32 / target_w as f32).min(max_side as f32 / target_h as f32);
 2476|      3|            scale = (scale * clamp_scale).clamp(0.01, 4.0);
 2477|      3|            target_w = (w as f32 * scale).round() as u32;
 2478|      3|            target_h = (h as f32 * scale).round() as u32;
 2479|     17|        }
 2480|       |
 2481|     20|        let mut pixmap = pixmap_new_for_test(target_w, target_h)
                          ^19
 2482|     20|            .ok_or_else(|| "Pixmap alloc failed".to_string())?;
                                         ^1                    ^1          ^1
 2483|     19|        if let Some([r, g, b, a]) = bg {
                                   ^4 ^4 ^4 ^4
 2484|      4|            let color = tiny_skia::Color::from_rgba8(r, g, b, a);
 2485|      4|            pixmap.fill(color);
 2486|     15|        }
 2487|       |
 2488|     19|        let mut pmut = pixmap.as_mut();
 2489|     19|        let mut transform = tiny_skia::Transform::from_scale(scale, scale);
 2490|     19|        if translate_x != 0.0 || translate_y != 0.0 {
                                               ^16
 2491|      4|            transform = transform.pre_translate(translate_x, translate_y);
 2492|     15|        }
 2493|     19|        resvg::render(&tree, transform, &mut pmut);
 2494|     19|        let data = pixmap.data().to_vec();
 2495|     19|        Ok((data, target_w, target_h))
 2496|     22|    }
 2497|       |
 2498|     23|    fn image_href_resolver() -> usvg::ImageHrefResolver<'static> {
 2499|     23|        let resolve_data = usvg::ImageHrefResolver::default_data_resolver();
 2500|     23|        let resolve_string = Box::new(|_: &str, _: &usvg::Options| None);
 2501|     23|        usvg::ImageHrefResolver {
 2502|     23|            resolve_data,
 2503|     23|            resolve_string,
 2504|     23|        }
 2505|     23|    }
 2506|       |
 2507|     23|    fn scale_adjustment_for_svg(svg: &str) -> f32 {
 2508|     23|        if svg.contains("aria-roledescription=\"er\"") || svg.contains("aria-roledescription='er'")
                                                                        ^22 ^22
 2509|       |        {
 2510|      2|            0.94
 2511|       |        } else {
 2512|     21|            1.0
 2513|       |        }
 2514|     23|    }
 2515|       |
 2516|    367|    fn now_ms() -> u64 {
 2517|    367|        SystemTime::now()
 2518|    367|            .duration_since(UNIX_EPOCH)
 2519|    367|            .unwrap_or_default()
 2520|    367|            .as_millis() as u64
 2521|    367|    }
 2522|       |}
 2523|       |
 2524|       |#[cfg(feature = "mermaid-quickjs")]
 2525|       |const MERMAID_DOM_SHIM: &str = r#"
 2526|       |var window = globalThis;
 2527|       |var __mdmdview_text_cache = {};
 2528|       |window.__mdmdview_bbox_rev = 0;
 2529|       |function __mdmdview_bump_bbox_rev() {
 2530|       |  window.__mdmdview_bbox_rev = (window.__mdmdview_bbox_rev || 0) + 1;
 2531|       |}
 2532|       |function __mdmdview_measure_text(text, fontSize, fontWeight) {
 2533|       |  var size = fontSize || 16;
 2534|       |  var raw = text ? String(text) : '';
 2535|       |  if (!raw.length) {
 2536|       |    return { width: 0, height: 0 };
 2537|       |  }
 2538|       |  var weight = (typeof fontWeight === 'number' && !isNaN(fontWeight)) ? fontWeight : null;
 2539|       |  var key = size + '|' + (weight || 0) + '|' + raw;
 2540|       |  var hit = __mdmdview_text_cache[key];
 2541|       |  if (hit) { return hit; }
 2542|       |  if (typeof __mdmdview_measure_text_native === 'function') {
 2543|       |    try {
 2544|       |      var native = __mdmdview_measure_text_native(raw, size, weight);
 2545|       |      if (native && typeof native.width === 'number' && typeof native.height === 'number') {
 2546|       |        __mdmdview_text_cache[key] = native;
 2547|       |        return native;
 2548|       |      }
 2549|       |      if (native && typeof native.length === 'number' && native.length >= 2) {
 2550|       |        var w = Number(native[0]);
 2551|       |        var h = Number(native[1]);
 2552|       |        if (isFinite(w) && isFinite(h)) {
 2553|       |          var converted = { width: w, height: h };
 2554|       |          __mdmdview_text_cache[key] = converted;
 2555|       |          return converted;
 2556|       |        }
 2557|       |      }
 2558|       |    } catch (e) {}
 2559|       |  }
 2560|       |  var lines = raw.split(/\n/);
 2561|       |  var maxLen = 0;
 2562|       |  for (var i = 0; i < lines.length; i++) {
 2563|       |    if (lines[i].length > maxLen) { maxLen = lines[i].length; }
 2564|       |  }
 2565|       |  var width = maxLen * size * 0.5;
 2566|       |  var height = lines.length * size * 1.2;
 2567|       |  var res = { width: width, height: height };
 2568|       |  __mdmdview_text_cache[key] = res;
 2569|       |  return res;
 2570|       |}
 2571|       |function __mdmdview_parse_font_size(value, baseSize) {
 2572|       |  if (value === null || value === undefined) { return baseSize; }
 2573|       |  var raw = String(value).trim();
 2574|       |  if (!raw) { return baseSize; }
 2575|       |  var num = parseFloat(raw);
 2576|       |  if (isNaN(num)) { return baseSize; }
 2577|       |  if (raw.indexOf('em') >= 0) {
 2578|       |    var base = baseSize || 16;
 2579|       |    return num * base;
 2580|       |  }
 2581|       |  if (raw.indexOf('ex') >= 0) {
 2582|       |    var baseEx = baseSize || 16;
 2583|       |    return num * baseEx * 0.5;
 2584|       |  }
 2585|       |  return num;
 2586|       |}
 2587|       |function __mdmdview_parse_font_weight_value(value) {
 2588|       |  if (value === null || value === undefined) { return null; }
 2589|       |  var raw = String(value).trim().toLowerCase();
 2590|       |  if (!raw) { return null; }
 2591|       |  if (raw === 'normal') { return 400; }
 2592|       |  if (raw === 'bold' || raw === 'bolder') { return 700; }
 2593|       |  if (raw === 'lighter') { return 300; }
 2594|       |  var num = parseFloat(raw);
 2595|       |  if (isNaN(num)) { return null; }
 2596|       |  return num;
 2597|       |}
 2598|       |function __mdmdview_parse_css_font_sizes(cssText, cache) {
 2599|       |  if (!cssText || !cache) { return; }
 2600|       |  var chunks = String(cssText).split('}');
 2601|       |  for (var i = 0; i < chunks.length; i++) {
 2602|       |    var rule = chunks[i];
 2603|       |    var parts = rule.split('{');
 2604|       |    if (parts.length < 2) { continue; }
 2605|       |    var selector = parts[0];
 2606|       |    var body = parts.slice(1).join('{');
 2607|       |    if (!selector || !body) { continue; }
 2608|       |    var sizeMatch = body.match(/font-size\s*:\s*([^;]+)/i);
 2609|       |    if (!sizeMatch) { continue; }
 2610|       |    var sizeValue = sizeMatch[1];
 2611|       |    var size = __mdmdview_parse_font_size(sizeValue, 16);
 2612|       |    if (!size || isNaN(size)) { continue; }
 2613|       |    var selectors = selector.split(',');
 2614|       |    for (var s = 0; s < selectors.length; s++) {
 2615|       |      var sel = selectors[s].trim();
 2616|       |      if (!sel) { continue; }
 2617|       |      if (sel.indexOf(':') >= 0) { continue; }
 2618|       |      var classMatches = sel.match(/\\.([A-Za-z0-9_-]+)/g);
 2619|       |      if (!classMatches || classMatches.length !== 1) { continue; }
 2620|       |      var cls = classMatches[0].slice(1);
 2621|       |      if (!cls) { continue; }
 2622|       |      if (!cache[cls] || cache[cls] < size) {
 2623|       |        cache[cls] = size;
 2624|       |      }
 2625|       |    }
 2626|       |  }
 2627|       |}
 2628|       |function __mdmdview_parse_css_font_weights(cssText, cache) {
 2629|       |  if (!cssText || !cache) { return; }
 2630|       |  var chunks = String(cssText).split('}');
 2631|       |  for (var i = 0; i < chunks.length; i++) {
 2632|       |    var rule = chunks[i];
 2633|       |    var parts = rule.split('{');
 2634|       |    if (parts.length < 2) { continue; }
 2635|       |    var selector = parts[0];
 2636|       |    var body = parts.slice(1).join('{');
 2637|       |    if (!selector || !body) { continue; }
 2638|       |    var weightMatch = body.match(/font-weight\s*:\s*([^;]+)/i);
 2639|       |    if (!weightMatch) { continue; }
 2640|       |    var weightValue = weightMatch[1];
 2641|       |    var weight = __mdmdview_parse_font_weight_value(weightValue);
 2642|       |    if (!weight || isNaN(weight)) { continue; }
 2643|       |    var selectors = selector.split(',');
 2644|       |    for (var s = 0; s < selectors.length; s++) {
 2645|       |      var sel = selectors[s].trim();
 2646|       |      if (!sel) { continue; }
 2647|       |      if (sel.indexOf(':') >= 0) { continue; }
 2648|       |      var classMatches = sel.match(/\\.([A-Za-z0-9_-]+)/g);
 2649|       |      if (!classMatches || classMatches.length !== 1) { continue; }
 2650|       |      var cls = classMatches[0].slice(1);
 2651|       |      if (!cls) { continue; }
 2652|       |      if (!cache[cls] || cache[cls] < weight) {
 2653|       |        cache[cls] = weight;
 2654|       |      }
 2655|       |    }
 2656|       |  }
 2657|       |}
 2658|       |function __mdmdview_collect_style_texts(node, out) {
 2659|       |  if (!node || !out) { return; }
 2660|       |  var name = (node.tagName || '').toLowerCase();
 2661|       |  if (name === 'style') {
 2662|       |    var text = __mdmdview_collect_text(node);
 2663|       |    if (text) { out.push(text); }
 2664|       |  }
 2665|       |  if (!node.children) { return; }
 2666|       |  for (var i = 0; i < node.children.length; i++) {
 2667|       |    __mdmdview_collect_style_texts(node.children[i], out);
 2668|       |  }
 2669|       |}
 2670|       |function __mdmdview_find_root_node(node) {
 2671|       |  if (!node) { return null; }
 2672|       |  var current = node;
 2673|       |  var last = node;
 2674|       |  var depth = 0;
 2675|       |  while (current && depth < 120) {
 2676|       |    last = current;
 2677|       |    if (!current.__mdmdview_parent_set) { break; }
 2678|       |    current = current.parentNode;
 2679|       |    depth += 1;
 2680|       |  }
 2681|       |  return last;
 2682|       |}
 2683|       |function __mdmdview_style_cache() {
 2684|       |  var rev = window.__mdmdview_bbox_rev || 0;
 2685|       |  if (window.__mdmdview_font_cache && window.__mdmdview_font_cache_rev === rev) {
 2686|       |    return window.__mdmdview_font_cache;
 2687|       |  }
 2688|       |  var cache = {};
 2689|       |  if (typeof document !== 'undefined' && document && document.getElementsByTagName) {
 2690|       |    var styles = document.getElementsByTagName('style') || [];
 2691|       |    for (var i = 0; i < styles.length; i++) {
 2692|       |      var text = styles[i] ? __mdmdview_collect_text(styles[i]) : '';
 2693|       |      __mdmdview_parse_css_font_sizes(text, cache);
 2694|       |    }
 2695|       |  }
 2696|       |  window.__mdmdview_font_cache = cache;
 2697|       |  window.__mdmdview_font_cache_rev = rev;
 2698|       |  window.__mdmdview_font_cache_root = null;
 2699|       |  window.__mdmdview_font_cache_root_rev = rev;
 2700|       |  return cache;
 2701|       |}
 2702|       |function __mdmdview_style_cache_for_node(node) {
 2703|       |  var cache = __mdmdview_style_cache();
 2704|       |  if (!node) { return cache; }
 2705|       |  var rev = window.__mdmdview_bbox_rev || 0;
 2706|       |  var root = __mdmdview_find_root_node(node);
 2707|       |  if (!root) { return cache; }
 2708|       |  if (window.__mdmdview_font_cache_root === root && window.__mdmdview_font_cache_root_rev === rev) {
 2709|       |    return cache;
 2710|       |  }
 2711|       |  var texts = [];
 2712|       |  __mdmdview_collect_style_texts(root, texts);
 2713|       |  for (var i = 0; i < texts.length; i++) {
 2714|       |    __mdmdview_parse_css_font_sizes(texts[i], cache);
 2715|       |  }
 2716|       |  window.__mdmdview_font_cache_root = root;
 2717|       |  window.__mdmdview_font_cache_root_rev = rev;
 2718|       |  return cache;
 2719|       |}
 2720|       |function __mdmdview_style_weight_cache() {
 2721|       |  var rev = window.__mdmdview_bbox_rev || 0;
 2722|       |  if (window.__mdmdview_font_weight_cache && window.__mdmdview_font_weight_cache_rev === rev) {
 2723|       |    return window.__mdmdview_font_weight_cache;
 2724|       |  }
 2725|       |  var cache = {};
 2726|       |  if (typeof document !== 'undefined' && document && document.getElementsByTagName) {
 2727|       |    var styles = document.getElementsByTagName('style') || [];
 2728|       |    for (var i = 0; i < styles.length; i++) {
 2729|       |      var text = styles[i] ? __mdmdview_collect_text(styles[i]) : '';
 2730|       |      __mdmdview_parse_css_font_weights(text, cache);
 2731|       |    }
 2732|       |  }
 2733|       |  window.__mdmdview_font_weight_cache = cache;
 2734|       |  window.__mdmdview_font_weight_cache_rev = rev;
 2735|       |  window.__mdmdview_font_weight_cache_root = null;
 2736|       |  window.__mdmdview_font_weight_cache_root_rev = rev;
 2737|       |  return cache;
 2738|       |}
 2739|       |function __mdmdview_style_weight_cache_for_node(node) {
 2740|       |  var cache = __mdmdview_style_weight_cache();
 2741|       |  if (!node) { return cache; }
 2742|       |  var rev = window.__mdmdview_bbox_rev || 0;
 2743|       |  var root = __mdmdview_find_root_node(node);
 2744|       |  if (!root) { return cache; }
 2745|       |  if (window.__mdmdview_font_weight_cache_root === root && window.__mdmdview_font_weight_cache_root_rev === rev) {
 2746|       |    return cache;
 2747|       |  }
 2748|       |  var texts = [];
 2749|       |  __mdmdview_collect_style_texts(root, texts);
 2750|       |  for (var i = 0; i < texts.length; i++) {
 2751|       |    __mdmdview_parse_css_font_weights(texts[i], cache);
 2752|       |  }
 2753|       |  window.__mdmdview_font_weight_cache_root = root;
 2754|       |  window.__mdmdview_font_weight_cache_root_rev = rev;
 2755|       |  return cache;
 2756|       |}
 2757|       |function __mdmdview_class_font_size(el) {
 2758|       |  if (!el) { return null; }
 2759|       |  var cache = __mdmdview_style_cache_for_node(el);
 2760|       |  if (!cache) { return null; }
 2761|       |  var list = __mdmdview_get_class_list(el);
 2762|       |  for (var i = 0; i < list.length; i++) {
 2763|       |    var size = cache[list[i]];
 2764|       |    if (size && !isNaN(size)) { return size; }
 2765|       |  }
 2766|       |  return null;
 2767|       |}
 2768|       |function __mdmdview_class_font_weight(el) {
 2769|       |  if (!el) { return null; }
 2770|       |  var cache = __mdmdview_style_weight_cache_for_node(el);
 2771|       |  if (!cache) { return null; }
 2772|       |  var list = __mdmdview_get_class_list(el);
 2773|       |  for (var i = 0; i < list.length; i++) {
 2774|       |    var weight = cache[list[i]];
 2775|       |    if (weight && !isNaN(weight)) { return weight; }
 2776|       |  }
 2777|       |  return null;
 2778|       |}
 2779|       |function __mdmdview_get_font_size(el) {
 2780|       |  var size = 16;
 2781|       |  if (el && el.style && el.style.fontSize) {
 2782|       |    size = __mdmdview_parse_font_size(el.style.fontSize, size);
 2783|       |    if (!isNaN(size)) { return size; }
 2784|       |  }
 2785|       |  if (el && el.style && el.style['font-size']) {
 2786|       |    size = __mdmdview_parse_font_size(el.style['font-size'], size);
 2787|       |    if (!isNaN(size)) { return size; }
 2788|       |  }
 2789|       |  if (el && el.getAttribute) {
 2790|       |    var attr = el.getAttribute('font-size');
 2791|       |    if (attr) {
 2792|       |      var a = __mdmdview_parse_font_size(attr, size);
 2793|       |      if (!isNaN(a)) { size = a; }
 2794|       |    }
 2795|       |  }
 2796|       |  var classSize = __mdmdview_class_font_size(el);
 2797|       |  if (classSize && !isNaN(classSize)) { return classSize; }
 2798|       |  var classList = __mdmdview_get_class_list(el);
 2799|       |  for (var c = 0; c < classList.length; c++) {
 2800|       |    var cls = classList[c];
 2801|       |    if (cls === 'commit-label' || cls === 'commit-label-bkg' || cls === 'tag-label' || cls === 'tag-label-bkg') {
 2802|       |      return 10;
 2803|       |    }
 2804|       |    if (cls === 'gitTitleText') {
 2805|       |      return 18;
 2806|       |    }
 2807|       |  }
 2808|       |  var ancestor = el;
 2809|       |  var steps = 0;
 2810|       |  while (ancestor && steps < 6) {
 2811|       |    if (__mdmdview_has_class(ancestor, 'commit-labels') || __mdmdview_has_class(ancestor, 'tag-labels')) {
 2812|       |      return 10;
 2813|       |    }
 2814|       |    ancestor = ancestor.parentNode;
 2815|       |    steps += 1;
 2816|       |  }
 2817|       |  var current = el;
 2818|       |  var depth = 0;
 2819|       |  while (current && depth < 4) {
 2820|       |    current = current.parentNode;
 2821|       |    if (!current) { break; }
 2822|       |    var parentSize = __mdmdview_class_font_size(current);
 2823|       |    if (parentSize && !isNaN(parentSize)) { return parentSize; }
 2824|       |    depth += 1;
 2825|       |  }
 2826|       |  var tag = (el && el.tagName) ? String(el.tagName).toLowerCase() : '';
 2827|       |  if (tag === 'text' || tag === 'tspan') {
 2828|       |    return size;
 2829|       |  }
 2830|       |  return size;
 2831|       |}
 2832|       |function __mdmdview_get_font_weight_raw(el) {
 2833|       |  if (el && el.style) {
 2834|       |    if (el.style.fontWeight) {
 2835|       |      var sw = __mdmdview_parse_font_weight_value(el.style.fontWeight);
 2836|       |      if (sw && !isNaN(sw)) { return sw; }
 2837|       |    }
 2838|       |    if (el.style['font-weight']) {
 2839|       |      var sw2 = __mdmdview_parse_font_weight_value(el.style['font-weight']);
 2840|       |      if (sw2 && !isNaN(sw2)) { return sw2; }
 2841|       |    }
 2842|       |  }
 2843|       |  if (el && el.getAttribute) {
 2844|       |    var attr = el.getAttribute('font-weight');
 2845|       |    if (attr) {
 2846|       |      var aw = __mdmdview_parse_font_weight_value(attr);
 2847|       |      if (aw && !isNaN(aw)) { return aw; }
 2848|       |    }
 2849|       |  }
 2850|       |  var classWeight = __mdmdview_class_font_weight(el);
 2851|       |  if (classWeight && !isNaN(classWeight)) { return classWeight; }
 2852|       |  var classList = __mdmdview_get_class_list(el);
 2853|       |  for (var i = 0; i < classList.length; i++) {
 2854|       |    var cls = classList[i];
 2855|       |    if (cls === 'classTitle' || cls === 'classTitleText' || cls === 'title') {
 2856|       |      return 700;
 2857|       |    }
 2858|       |  }
 2859|       |  return null;
 2860|       |}
 2861|       |function __mdmdview_get_font_weight(el) {
 2862|       |  var direct = __mdmdview_get_font_weight_raw(el);
 2863|       |  if (direct && !isNaN(direct)) { return direct; }
 2864|       |  var current = el;
 2865|       |  var depth = 0;
 2866|       |  while (current && depth < 4) {
 2867|       |    current = current.parentNode;
 2868|       |    if (!current) { break; }
 2869|       |    var parentWeight = __mdmdview_get_font_weight_raw(current);
 2870|       |    if (parentWeight && !isNaN(parentWeight)) { return parentWeight; }
 2871|       |    depth += 1;
 2872|       |  }
 2873|       |  return 400;
 2874|       |}
 2875|       |function __mdmdview_parse_num(value) {
 2876|       |  var num = parseFloat(value);
 2877|       |  return isNaN(num) ? 0 : num;
 2878|       |}
 2879|       |function __mdmdview_parse_length(value, fontSize) {
 2880|       |  if (value === null || value === undefined) { return 0; }
 2881|       |  var raw = String(value).trim();
 2882|       |  if (!raw) { return 0; }
 2883|       |  var num = parseFloat(raw);
 2884|       |  if (isNaN(num)) { return 0; }
 2885|       |  if (raw.indexOf('em') >= 0) {
 2886|       |    return num * (fontSize || 16);
 2887|       |  }
 2888|       |  if (raw.indexOf('ex') >= 0) {
 2889|       |    return num * (fontSize || 16) * 0.5;
 2890|       |  }
 2891|       |  return num;
 2892|       |}
 2893|       |function __mdmdview_transform_point(el, x, y) {
 2894|       |  var box = __mdmdview_apply_transform(el, { x: x, y: y, width: 0, height: 0 });
 2895|       |  return { x: box.x, y: box.y };
 2896|       |}
 2897|       |function __mdmdview_path_points(el) {
 2898|       |  var d = el && el.getAttribute ? el.getAttribute('d') : null;
 2899|       |  if (!d) { return []; }
 2900|       |  var nums = String(d).match(/-?\d*\.?\d+(?:e[-+]?\d+)?/ig);
 2901|       |  if (!nums || nums.length < 2) { return []; }
 2902|       |  var points = [];
 2903|       |  for (var i = 0; i + 1 < nums.length; i += 2) {
 2904|       |    var x = __mdmdview_parse_num(nums[i]);
 2905|       |    var y = __mdmdview_parse_num(nums[i + 1]);
 2906|       |    points.push(__mdmdview_transform_point(el, x, y));
 2907|       |  }
 2908|       |  return points;
 2909|       |}
 2910|       |function __mdmdview_path_total_length(el) {
 2911|       |  var points = __mdmdview_path_points(el);
 2912|       |  if (points.length < 2) { return 0; }
 2913|       |  var total = 0;
 2914|       |  for (var i = 1; i < points.length; i++) {
 2915|       |    var dx = points[i].x - points[i - 1].x;
 2916|       |    var dy = points[i].y - points[i - 1].y;
 2917|       |    total += Math.sqrt(dx * dx + dy * dy);
 2918|       |  }
 2919|       |  return total;
 2920|       |}
 2921|       |function __mdmdview_path_point_at_length(el, length) {
 2922|       |  var points = __mdmdview_path_points(el);
 2923|       |  if (!points.length) { return { x: 0, y: 0 }; }
 2924|       |  if (points.length === 1) { return points[0]; }
 2925|       |  var remaining = Math.max(0, __mdmdview_parse_num(length));
 2926|       |  for (var i = 1; i < points.length; i++) {
 2927|       |    var p0 = points[i - 1];
 2928|       |    var p1 = points[i];
 2929|       |    var dx = p1.x - p0.x;
 2930|       |    var dy = p1.y - p0.y;
 2931|       |    var seg = Math.sqrt(dx * dx + dy * dy);
 2932|       |    if (seg <= 0) { continue; }
 2933|       |    if (remaining <= seg) {
 2934|       |      var t = remaining / seg;
 2935|       |      return { x: p0.x + dx * t, y: p0.y + dy * t };
 2936|       |    }
 2937|       |    remaining -= seg;
 2938|       |  }
 2939|       |  return points[points.length - 1];
 2940|       |}
 2941|       |function __mdmdview_text_metrics(el) {
 2942|       |  var size = __mdmdview_get_font_size(el);
 2943|       |  var weight = __mdmdview_get_font_weight(el);
 2944|       |  if (!el || !el.children || !el.children.length) {
 2945|       |    var raw = el ? __mdmdview_collect_text(el) : '';
 2946|       |    return __mdmdview_measure_text(raw, size, weight);
 2947|       |  }
 2948|       |  var max_w = 0;
 2949|       |  var max_h = 0;
 2950|       |  var lines = 0;
 2951|       |  for (var i = 0; i < el.children.length; i++) {
 2952|       |    var child = el.children[i];
 2953|       |    var tag = (child.tagName || '').toLowerCase();
 2954|       |    if (tag !== 'tspan') { continue; }
 2955|       |    var text = __mdmdview_collect_text(child);
 2956|       |    if (!text || !String(text).trim()) { continue; }
 2957|       |    var child_weight = __mdmdview_get_font_weight(child);
 2958|       |    var m = __mdmdview_measure_text(text, size, child_weight);
 2959|       |    if (m.width > max_w) { max_w = m.width; }
 2960|       |    if (m.height > max_h) { max_h = m.height; }
 2961|       |    lines += 1;
 2962|       |  }
 2963|       |  if (!lines) {
 2964|       |    var fallback = __mdmdview_collect_text(el);
 2965|       |    return __mdmdview_measure_text(fallback, size, weight);
 2966|       |  }
 2967|       |  var line_height = max_h > 0 ? max_h : size * 1.2;
 2968|       |  return { width: max_w, height: lines * line_height };
 2969|       |}
 2970|       |function __mdmdview_apply_matrix(bbox, a, b, c, d, e, f) {
 2971|       |  if (!bbox) { return bbox; }
 2972|       |  var x = bbox.x;
 2973|       |  var y = bbox.y;
 2974|       |  var w = bbox.width;
 2975|       |  var h = bbox.height;
 2976|       |  var pts = [
 2977|       |    [x, y],
 2978|       |    [x + w, y],
 2979|       |    [x, y + h],
 2980|       |    [x + w, y + h]
 2981|       |  ];
 2982|       |  var min_x = Infinity;
 2983|       |  var min_y = Infinity;
 2984|       |  var max_x = -Infinity;
 2985|       |  var max_y = -Infinity;
 2986|       |  for (var i = 0; i < pts.length; i++) {
 2987|       |    var px = pts[i][0];
 2988|       |    var py = pts[i][1];
 2989|       |    var nx = a * px + c * py + e;
 2990|       |    var ny = b * px + d * py + f;
 2991|       |    if (nx < min_x) { min_x = nx; }
 2992|       |    if (ny < min_y) { min_y = ny; }
 2993|       |    if (nx > max_x) { max_x = nx; }
 2994|       |    if (ny > max_y) { max_y = ny; }
 2995|       |  }
 2996|       |  if (!isFinite(min_x) || !isFinite(min_y) || !isFinite(max_x) || !isFinite(max_y)) {
 2997|       |    return bbox;
 2998|       |  }
 2999|       |  return { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y };
 3000|       |}
 3001|       |function __mdmdview_apply_transform(el, bbox) {
 3002|       |  if (!el || !bbox) { return bbox; }
 3003|       |  var transform = el.getAttribute ? el.getAttribute('transform') : null;
 3004|       |  if (!transform) { return bbox; }
 3005|       |  var current = bbox;
 3006|       |  var re = /([a-zA-Z]+)\(([^)]+)\)/g;
 3007|       |  var match = null;
 3008|       |  while ((match = re.exec(String(transform))) !== null) {
 3009|       |    var name = match[1].toLowerCase();
 3010|       |    var params = match[2].split(/[, ]+/).filter(function(p) { return p.length; });
 3011|       |    var nums = [];
 3012|       |    for (var i = 0; i < params.length; i++) {
 3013|       |      nums.push(__mdmdview_parse_num(params[i]));
 3014|       |    }
 3015|       |    if (name === 'translate') {
 3016|       |      var tx = nums.length ? nums[0] : 0;
 3017|       |      var ty = nums.length > 1 ? nums[1] : 0;
 3018|       |      current = __mdmdview_apply_matrix(current, 1, 0, 0, 1, tx, ty);
 3019|       |    } else if (name === 'scale') {
 3020|       |      var sx = nums.length ? nums[0] : 1;
 3021|       |      var sy = nums.length > 1 ? nums[1] : sx;
 3022|       |      current = __mdmdview_apply_matrix(current, sx, 0, 0, sy, 0, 0);
 3023|       |    } else if (name === 'matrix' && nums.length >= 6) {
 3024|       |      current = __mdmdview_apply_matrix(
 3025|       |        current,
 3026|       |        nums[0],
 3027|       |        nums[1],
 3028|       |        nums[2],
 3029|       |        nums[3],
 3030|       |        nums[4],
 3031|       |        nums[5]
 3032|       |      );
 3033|       |    } else if (name === 'rotate' && nums.length) {
 3034|       |      var angle = nums[0] * Math.PI / 180.0;
 3035|       |      var cos = Math.cos(angle);
 3036|       |      var sin = Math.sin(angle);
 3037|       |      if (nums.length >= 3) {
 3038|       |        var cx = nums[1];
 3039|       |        var cy = nums[2];
 3040|       |        current = __mdmdview_apply_matrix(current, 1, 0, 0, 1, -cx, -cy);
 3041|       |        current = __mdmdview_apply_matrix(current, cos, sin, -sin, cos, 0, 0);
 3042|       |        current = __mdmdview_apply_matrix(current, 1, 0, 0, 1, cx, cy);
 3043|       |      } else {
 3044|       |        current = __mdmdview_apply_matrix(current, cos, sin, -sin, cos, 0, 0);
 3045|       |      }
 3046|       |    } else if (name === 'skewx' && nums.length) {
 3047|       |      var ax = nums[0] * Math.PI / 180.0;
 3048|       |      current = __mdmdview_apply_matrix(current, 1, 0, Math.tan(ax), 1, 0, 0);
 3049|       |    } else if (name === 'skewy' && nums.length) {
 3050|       |      var ay = nums[0] * Math.PI / 180.0;
 3051|       |      current = __mdmdview_apply_matrix(current, 1, Math.tan(ay), 0, 1, 0, 0);
 3052|       |    }
 3053|       |  }
 3054|       |  return current;
 3055|       |}
 3056|       |function __mdmdview_children_bounds(el) {
 3057|       |  if (!el || !el.children || !el.children.length) { return null; }
 3058|       |  var min_x = Infinity;
 3059|       |  var min_y = Infinity;
 3060|       |  var max_x = -Infinity;
 3061|       |  var max_y = -Infinity;
 3062|       |  for (var i = 0; i < el.children.length; i++) {
 3063|       |    var child_box = __mdmdview_bbox(el.children[i]);
 3064|       |    if (!child_box) { continue; }
 3065|       |    if (!isFinite(child_box.width) || !isFinite(child_box.height)) { continue; }
 3066|       |    if (child_box.width <= 0 && child_box.height <= 0) { continue; }
 3067|       |    if (child_box.x < min_x) { min_x = child_box.x; }
 3068|       |    if (child_box.y < min_y) { min_y = child_box.y; }
 3069|       |    if (child_box.x + child_box.width > max_x) { max_x = child_box.x + child_box.width; }
 3070|       |    if (child_box.y + child_box.height > max_y) { max_y = child_box.y + child_box.height; }
 3071|       |  }
 3072|       |  if (isFinite(min_x) && isFinite(min_y) && isFinite(max_x) && isFinite(max_y)) {
 3073|       |    return { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y };
 3074|       |  }
 3075|       |  return null;
 3076|       |}
 3077|       |function __mdmdview_cache_bbox(el, box) {
 3078|       |  if (el && box) {
 3079|       |    el.__mdmdview_bbox_cache = box;
 3080|       |    el.__mdmdview_bbox_rev = window.__mdmdview_bbox_rev || 0;
 3081|       |  }
 3082|       |  return box;
 3083|       |}
 3084|       |function __mdmdview_bbox(el) {
 3085|       |  if (!el) { return { x: 0, y: 0, width: 0, height: 0 }; }
 3086|       |  if (el.__mdmdview_bbox_cache && el.__mdmdview_bbox_rev === (window.__mdmdview_bbox_rev || 0)) {
 3087|       |    return el.__mdmdview_bbox_cache;
 3088|       |  }
 3089|       |  var tag = (el.tagName || '').toLowerCase();
 3090|       |  if (
 3091|       |    tag === 'style'
 3092|       |    || tag === 'defs'
 3093|       |    || tag === 'script'
 3094|       |    || tag === 'title'
 3095|       |    || tag === 'desc'
 3096|       |    || tag === 'metadata'
 3097|       |    || tag === 'marker'
 3098|       |    || tag === 'clippath'
 3099|       |    || tag === 'mask'
 3100|       |    || tag === 'pattern'
 3101|       |    || tag === 'lineargradient'
 3102|       |    || tag === 'radialgradient'
 3103|       |    || tag === 'stop'
 3104|       |  ) {
 3105|       |    return { x: 0, y: 0, width: 0, height: 0 };
 3106|       |  }
 3107|       |  if (tag === '#text') {
 3108|       |    var text = el.textContent || '';
 3109|       |    var size = __mdmdview_get_font_size(el);
 3110|       |    var weight = __mdmdview_get_font_weight(el);
 3111|       |    var m = __mdmdview_measure_text(text, size, weight);
 3112|       |    return __mdmdview_cache_bbox(
 3113|       |      el,
 3114|       |      __mdmdview_apply_transform(el, { x: 0, y: 0, width: m.width, height: m.height })
 3115|       |    );
 3116|       |  }
 3117|       |  if (tag === 'svg') {
 3118|       |    if (el.children && el.children.length) {
 3119|       |      var svg_bounds = __mdmdview_children_bounds(el);
 3120|       |      if (svg_bounds) {
 3121|       |        return __mdmdview_cache_bbox(el, __mdmdview_apply_transform(el, svg_bounds));
 3122|       |      }
 3123|       |    }
 3124|       |  }
 3125|       |  if (tag === 'text' || tag === 'tspan') {
 3126|       |    var metrics = __mdmdview_text_metrics(el);
 3127|       |    var fontSize = __mdmdview_get_font_size(el);
 3128|       |    var tx = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('x') : 0);
 3129|       |    var ty = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('y') : 0);
 3130|       |    var dx = __mdmdview_parse_length(el.getAttribute ? el.getAttribute('dx') : 0, fontSize);
 3131|       |    var dy = __mdmdview_parse_length(el.getAttribute ? el.getAttribute('dy') : 0, fontSize);
 3132|       |    if (tag === 'text' && el.children && el.children.length) {
 3133|       |      var first = el.children[0];
 3134|       |      var firstTag = (first.tagName || '').toLowerCase();
 3135|       |      if (firstTag === 'tspan') {
 3136|       |        if (!dx) { dx = __mdmdview_parse_length(first.getAttribute('dx'), fontSize); }
 3137|       |        if (!dy) { dy = __mdmdview_parse_length(first.getAttribute('dy'), fontSize); }
 3138|       |      }
 3139|       |    }
 3140|       |    tx += dx;
 3141|       |    ty += dy;
 3142|       |    var anchor = el.getAttribute ? el.getAttribute('text-anchor') : null;
 3143|       |    if (!anchor && el.style && el.style.textAnchor) { anchor = el.style.textAnchor; }
 3144|       |    if (anchor === 'middle') {
 3145|       |      tx -= metrics.width * 0.5;
 3146|       |    } else if (anchor === 'end' || anchor === 'right') {
 3147|       |      tx -= metrics.width;
 3148|       |    }
 3149|       |    var baseline = el.getAttribute ? el.getAttribute('dominant-baseline') : null;
 3150|       |    if (!baseline && el.style && el.style.dominantBaseline) { baseline = el.style.dominantBaseline; }
 3151|       |    var y = ty - metrics.height * 0.3;
 3152|       |    if (baseline === 'middle' || baseline === 'central') {
 3153|       |      y = ty - metrics.height * 0.5;
 3154|       |    } else if (baseline === 'hanging') {
 3155|       |      y = ty;
 3156|       |    }
 3157|       |    return __mdmdview_cache_bbox(
 3158|       |      el,
 3159|       |      __mdmdview_apply_transform(el, {
 3160|       |        x: tx,
 3161|       |        y: y,
 3162|       |        width: metrics.width,
 3163|       |        height: metrics.height
 3164|       |      })
 3165|       |    );
 3166|       |  }
 3167|       |  if (tag === 'rect') {
 3168|       |    var rx = __mdmdview_parse_num(el.getAttribute('x'));
 3169|       |    var ry = __mdmdview_parse_num(el.getAttribute('y'));
 3170|       |    var rw = __mdmdview_parse_num(el.getAttribute('width'));
 3171|       |    var rh = __mdmdview_parse_num(el.getAttribute('height'));
 3172|       |    return __mdmdview_cache_bbox(
 3173|       |      el,
 3174|       |      __mdmdview_apply_transform(el, { x: rx, y: ry, width: rw, height: rh })
 3175|       |    );
 3176|       |  }
 3177|       |  if (tag === 'circle') {
 3178|       |    var cx = __mdmdview_parse_num(el.getAttribute('cx'));
 3179|       |    var cy = __mdmdview_parse_num(el.getAttribute('cy'));
 3180|       |    var r = __mdmdview_parse_num(el.getAttribute('r'));
 3181|       |    return __mdmdview_cache_bbox(
 3182|       |      el,
 3183|       |      __mdmdview_apply_transform(el, { x: cx - r, y: cy - r, width: r * 2, height: r * 2 })
 3184|       |    );
 3185|       |  }
 3186|       |  if (tag === 'ellipse') {
 3187|       |    var ecx = __mdmdview_parse_num(el.getAttribute('cx'));
 3188|       |    var ecy = __mdmdview_parse_num(el.getAttribute('cy'));
 3189|       |    var erx = __mdmdview_parse_num(el.getAttribute('rx'));
 3190|       |    var ery = __mdmdview_parse_num(el.getAttribute('ry'));
 3191|       |    return __mdmdview_cache_bbox(
 3192|       |      el,
 3193|       |      __mdmdview_apply_transform(el, { x: ecx - erx, y: ecy - ery, width: erx * 2, height: ery * 2 })
 3194|       |    );
 3195|       |  }
 3196|       |  if (tag === 'line') {
 3197|       |    var x1 = __mdmdview_parse_num(el.getAttribute('x1'));
 3198|       |    var y1 = __mdmdview_parse_num(el.getAttribute('y1'));
 3199|       |    var x2 = __mdmdview_parse_num(el.getAttribute('x2'));
 3200|       |    var y2 = __mdmdview_parse_num(el.getAttribute('y2'));
 3201|       |    var min_x = Math.min(x1, x2);
 3202|       |    var min_y = Math.min(y1, y2);
 3203|       |    var max_x = Math.max(x1, x2);
 3204|       |    var max_y = Math.max(y1, y2);
 3205|       |    return __mdmdview_cache_bbox(
 3206|       |      el,
 3207|       |      __mdmdview_apply_transform(el, { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y })
 3208|       |    );
 3209|       |  }
 3210|       |  if (tag === 'polygon' || tag === 'polyline') {
 3211|       |    var points = el.getAttribute('points');
 3212|       |    if (points) {
 3213|       |      var parts = String(points).trim().split(/[\s,]+/).filter(function(p) { return p.length; });
 3214|       |      if (parts.length >= 2) {
 3215|       |        var min_px = Infinity;
 3216|       |        var min_py = Infinity;
 3217|       |        var max_px = -Infinity;
 3218|       |        var max_py = -Infinity;
 3219|       |        for (var i = 0; i + 1 < parts.length; i += 2) {
 3220|       |          var px = __mdmdview_parse_num(parts[i]);
 3221|       |          var py = __mdmdview_parse_num(parts[i + 1]);
 3222|       |          if (px < min_px) { min_px = px; }
 3223|       |          if (py < min_py) { min_py = py; }
 3224|       |          if (px > max_px) { max_px = px; }
 3225|       |          if (py > max_py) { max_py = py; }
 3226|       |        }
 3227|       |        if (isFinite(min_px) && isFinite(min_py) && isFinite(max_px) && isFinite(max_py)) {
 3228|       |          return __mdmdview_cache_bbox(
 3229|       |            el,
 3230|       |            __mdmdview_apply_transform(el, {
 3231|       |              x: min_px,
 3232|       |              y: min_py,
 3233|       |              width: max_px - min_px,
 3234|       |              height: max_py - min_py
 3235|       |            })
 3236|       |          );
 3237|       |        }
 3238|       |      }
 3239|       |    }
 3240|       |  }
 3241|       |  if (tag === 'path') {
 3242|       |    var d = el.getAttribute('d');
 3243|       |    if (d) {
 3244|       |      var nums = String(d).match(/-?\d*\.?\d+(?:e[-+]?\d+)?/ig);
 3245|       |      if (nums && nums.length >= 2) {
 3246|       |        var min_px = Infinity;
 3247|       |        var min_py = Infinity;
 3248|       |        var max_px = -Infinity;
 3249|       |        var max_py = -Infinity;
 3250|       |        for (var i = 0; i + 1 < nums.length; i += 2) {
 3251|       |          var px = __mdmdview_parse_num(nums[i]);
 3252|       |          var py = __mdmdview_parse_num(nums[i + 1]);
 3253|       |          if (px < min_px) { min_px = px; }
 3254|       |          if (py < min_py) { min_py = py; }
 3255|       |          if (px > max_px) { max_px = px; }
 3256|       |          if (py > max_py) { max_py = py; }
 3257|       |        }
 3258|       |        if (isFinite(min_px) && isFinite(min_py) && isFinite(max_px) && isFinite(max_py)) {
 3259|       |          return __mdmdview_cache_bbox(
 3260|       |            el,
 3261|       |            __mdmdview_apply_transform(el, { x: min_px, y: min_py, width: max_px - min_px, height: max_py - min_py })
 3262|       |          );
 3263|       |        }
 3264|       |      }
 3265|       |    }
 3266|       |  }
 3267|       |  var font_size = __mdmdview_get_font_size(el);
 3268|       |  var width_attr = el.getAttribute ? el.getAttribute('width') : null;
 3269|       |  var height_attr = el.getAttribute ? el.getAttribute('height') : null;
 3270|       |  var bw = __mdmdview_parse_length(width_attr, font_size);
 3271|       |  var bh = __mdmdview_parse_length(height_attr, font_size);
 3272|       |  if ((!bw || !bh) && el.style) {
 3273|       |    if (!bw && el.style.width) { bw = __mdmdview_parse_length(el.style.width, font_size); }
 3274|       |    if (!bh && el.style.height) { bh = __mdmdview_parse_length(el.style.height, font_size); }
 3275|       |  }
 3276|       |  if ((!bw || !bh) && el.getAttribute) {
 3277|       |    var view_box = el.getAttribute('viewBox');
 3278|       |    if (view_box) {
 3279|       |      var parts = String(view_box).trim().split(/[\s,]+/).filter(function(p) { return p.length; });
 3280|       |      if (parts.length >= 4) {
 3281|       |        var vbw = __mdmdview_parse_num(parts[2]);
 3282|       |        var vbh = __mdmdview_parse_num(parts[3]);
 3283|       |        if (!bw && vbw) { bw = vbw; }
 3284|       |        if (!bh && vbh) { bh = vbh; }
 3285|       |      }
 3286|       |    }
 3287|       |  }
 3288|       |  if (!bw && !bh) {
 3289|       |    var html_tag = tag === 'div' || tag === 'body' || tag === 'html';
 3290|       |    if (html_tag) {
 3291|       |      bw = window.innerWidth || 0;
 3292|       |      bh = window.innerHeight || 0;
 3293|       |    }
 3294|       |  }
 3295|       |  if (bw || bh) {
 3296|       |    var bx = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('x') : 0);
 3297|       |    var by = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('y') : 0);
 3298|       |    return __mdmdview_cache_bbox(
 3299|       |      el,
 3300|       |      __mdmdview_apply_transform(el, { x: bx, y: by, width: bw, height: bh })
 3301|       |    );
 3302|       |  }
 3303|       |  if (el.children && el.children.length) {
 3304|       |    var child_bounds = __mdmdview_children_bounds(el);
 3305|       |    if (child_bounds) {
 3306|       |      return __mdmdview_cache_bbox(el, __mdmdview_apply_transform(el, child_bounds));
 3307|       |    }
 3308|       |  }
 3309|       |  var fallback_text = el.textContent || '';
 3310|       |  var fallback_size = __mdmdview_get_font_size(el);
 3311|       |  var fallback_weight = __mdmdview_get_font_weight(el);
 3312|       |  var fallback = __mdmdview_measure_text(fallback_text, fallback_size, fallback_weight);
 3313|       |  return __mdmdview_cache_bbox(
 3314|       |    el,
 3315|       |    __mdmdview_apply_transform(el, { x: 0, y: 0, width: fallback.width, height: fallback.height })
 3316|       |  );
 3317|       |}
 3318|       |function __mdmdview_escape_text(text) {
 3319|       |  return String(text)
 3320|       |    .replace(/&/g, '&amp;')
 3321|       |    .replace(/</g, '&lt;')
 3322|       |    .replace(/>/g, '&gt;');
 3323|       |}
 3324|       |function __mdmdview_collect_text(node) {
 3325|       |  if (!node) { return ''; }
 3326|       |  if (node.tagName === '#text') { return node.textContent || ''; }
 3327|       |  var out = '';
 3328|       |  if (node.children && node.children.length) {
 3329|       |    for (var i = 0; i < node.children.length; i++) {
 3330|       |      out += __mdmdview_collect_text(node.children[i]);
 3331|       |    }
 3332|       |  }
 3333|       |  if (out && out.length) { return out; }
 3334|       |  return node.textContent || '';
 3335|       |}
 3336|       |function __mdmdview_escape_attr(text) {
 3337|       |  return String(text)
 3338|       |    .replace(/&/g, '&amp;')
 3339|       |    .replace(/"/g, '&quot;');
 3340|       |}
 3341|       |function __mdmdview_style_text(style) {
 3342|       |  if (!style) { return ''; }
 3343|       |  if (typeof style.cssText === 'string' && style.cssText.trim().length) {
 3344|       |    return style.cssText;
 3345|       |  }
 3346|       |  var parts = [];
 3347|       |  for (var key in style) {
 3348|       |    if (!Object.prototype.hasOwnProperty.call(style, key)) { continue; }
 3349|       |    if (key === 'cssText') { continue; }
 3350|       |    var val = style[key];
 3351|       |    if (typeof val === 'function') { continue; }
 3352|       |    if (val === null || val === undefined || val === '') { continue; }
 3353|       |    parts.push(key + ':' + String(val));
 3354|       |  }
 3355|       |  return parts.join(';');
 3356|       |}
 3357|       |function __mdmdview_is_shape_tag(tag) {
 3358|       |  var t = String(tag || '').toLowerCase();
 3359|       |  return t === 'rect'
 3360|       |    || t === 'path'
 3361|       |    || t === 'polygon'
 3362|       |    || t === 'circle'
 3363|       |    || t === 'ellipse'
 3364|       |    || t === 'line'
 3365|       |    || t === 'image';
 3366|       |}
 3367|       |function __mdmdview_group_has_text(node) {
 3368|       |  if (!node || !node.children || !node.children.length) { return false; }
 3369|       |  for (var i = 0; i < node.children.length; i++) {
 3370|       |    var child = node.children[i];
 3371|       |    if (!child) { continue; }
 3372|       |    var tag = String(child.tagName || '').toLowerCase();
 3373|       |    if (tag === 'text' || tag === 'foreignobject') { return true; }
 3374|       |    if (child.children && child.children.length && __mdmdview_group_has_text(child)) {
 3375|       |      return true;
 3376|       |    }
 3377|       |  }
 3378|       |  return false;
 3379|       |}
 3380|       |function __mdmdview_group_has_shape(node) {
 3381|       |  if (!node || !node.children || !node.children.length) { return false; }
 3382|       |  for (var i = 0; i < node.children.length; i++) {
 3383|       |    var child = node.children[i];
 3384|       |    if (!child) { continue; }
 3385|       |    if (__mdmdview_is_shape_tag(child.tagName)) { return true; }
 3386|       |    if (child.children && child.children.length && __mdmdview_group_has_shape(child)) {
 3387|       |      return true;
 3388|       |    }
 3389|       |  }
 3390|       |  return false;
 3391|       |}
 3392|       |function __mdmdview_is_labelish(node) {
 3393|       |  if (!node || !node.tagName) { return false; }
 3394|       |  var tag = String(node.tagName || '').toLowerCase();
 3395|       |  if (tag === 'text' || tag === 'foreignobject') { return true; }
 3396|       |  if (tag === 'g') {
 3397|       |    if (__mdmdview_has_class(node, 'clusters')) { return false; }
 3398|       |    if (__mdmdview_has_class(node, 'label')) { return true; }
 3399|       |    return __mdmdview_group_has_text(node);
 3400|       |  }
 3401|       |  return false;
 3402|       |}
 3403|       |function __mdmdview_order_children(node) {
 3404|       |  if (!node || !node.children || !node.children.length) {
 3405|       |    return node && node.children ? node.children : [];
 3406|       |  }
 3407|       |  var tag = String(node.tagName || '').toLowerCase();
 3408|       |  if (tag !== 'g') { return node.children; }
 3409|       |  if (!__mdmdview_group_has_shape(node)) { return node.children; }
 3410|       |  var has_label = false;
 3411|       |  for (var i = 0; i < node.children.length; i++) {
 3412|       |    if (__mdmdview_is_labelish(node.children[i])) { has_label = true; break; }
 3413|       |  }
 3414|       |  if (!has_label) { return node.children; }
 3415|       |  var before = [];
 3416|       |  var after = [];
 3417|       |  for (var j = 0; j < node.children.length; j++) {
 3418|       |    var child = node.children[j];
 3419|       |    if (__mdmdview_is_labelish(child)) { after.push(child); }
 3420|       |    else { before.push(child); }
 3421|       |  }
 3422|       |  if (!before.length || !after.length) { return node.children; }
 3423|       |  return before.concat(after);
 3424|       |}
 3425|       |function __mdmdview_serialize_attrs(node) {
 3426|       |  var out = '';
 3427|       |  if (!node || !node.attributes) { return out; }
 3428|       |  var has_style = false;
 3429|       |  for (var key in node.attributes) {
 3430|       |    if (!Object.prototype.hasOwnProperty.call(node.attributes, key)) { continue; }
 3431|       |    var val = node.attributes[key];
 3432|       |    if (val === null || val === undefined) { continue; }
 3433|       |    if (key === 'style') { has_style = true; }
 3434|       |    out += ' ' + key + '="' + __mdmdview_escape_attr(val) + '"';
 3435|       |  }
 3436|       |  if (!has_style && node.style) {
 3437|       |    var style_text = __mdmdview_style_text(node.style);
 3438|       |    if (style_text) {
 3439|       |      out += ' style="' + __mdmdview_escape_attr(style_text) + '"';
 3440|       |    }
 3441|       |  }
 3442|       |  return out;
 3443|       |}
 3444|       |function __mdmdview_serialize(node) {
 3445|       |  if (!node) { return ''; }
 3446|       |  if (node.tagName === '#text') {
 3447|       |    return __mdmdview_escape_text(node.textContent || '');
 3448|       |  }
 3449|       |  var tag = node.tagName || '';
 3450|       |  var attrs = __mdmdview_serialize_attrs(node);
 3451|       |  var content = '';
 3452|       |  var lower = String(tag).toLowerCase();
 3453|       |  if (node.children && node.children.length) {
 3454|       |    if (lower === 'style' || lower === 'script') {
 3455|       |      content = __mdmdview_collect_text(node);
 3456|       |    } else {
 3457|       |      var ordered = __mdmdview_order_children(node);
 3458|       |      for (var i = 0; i < ordered.length; i++) {
 3459|       |        content += __mdmdview_serialize(ordered[i]);
 3460|       |      }
 3461|       |    }
 3462|       |  } else if (node.textContent) {
 3463|       |    if (lower === 'style' || lower === 'script') {
 3464|       |      content = node.textContent;
 3465|       |    } else {
 3466|       |      content = __mdmdview_escape_text(node.textContent);
 3467|       |    }
 3468|       |  }
 3469|       |  return '<' + tag + attrs + '>' + content + '</' + tag + '>';
 3470|       |}
 3471|       |function __mdmdview_serialize_children(node) {
 3472|       |  if (!node || !node.children) { return ''; }
 3473|       |  var content = '';
 3474|       |  var ordered = __mdmdview_order_children(node);
 3475|       |  for (var i = 0; i < ordered.length; i++) {
 3476|       |    content += __mdmdview_serialize(ordered[i]);
 3477|       |  }
 3478|       |  return content;
 3479|       |}
 3480|       |function __mdmdview_make_style() {
 3481|       |  var style = { cssText: '' };
 3482|       |  style.setProperty = function(key, value) { style[key] = String(value); };
 3483|       |  style.removeProperty = function(key) { delete style[key]; };
 3484|       |  style.getPropertyValue = function(key) {
 3485|       |    return Object.prototype.hasOwnProperty.call(style, key) ? style[key] : '';
 3486|       |  };
 3487|       |  return style;
 3488|       |}
 3489|       |function __mdmdview_detach(child) {
 3490|       |  if (!child || typeof child !== 'object') { return; }
 3491|       |  var parent = child.parentNode;
 3492|       |  if (!parent || !parent.children) { return; }
 3493|       |  var idx = parent.children.indexOf(child);
 3494|       |  if (idx >= 0) {
 3495|       |    parent.children.splice(idx, 1);
 3496|       |    parent.childNodes = parent.children;
 3497|       |    parent.firstChild = parent.children[0] || null;
 3498|       |  }
 3499|       |  child.parentNode = null;
 3500|       |}
 3501|       |function __mdmdview_parse_font_px(font) {
 3502|       |  if (!font) { return 16; }
 3503|       |  var match = String(font).match(/(\d+(?:\.\d+)?)px/);
 3504|       |  if (match && match[1]) {
 3505|       |    var value = parseFloat(match[1]);
 3506|       |    if (!isNaN(value)) { return value; }
 3507|       |  }
 3508|       |  return 16;
 3509|       |}
 3510|       |function __mdmdview_parse_font_weight(font) {
 3511|       |  if (!font) { return null; }
 3512|       |  var raw = String(font).toLowerCase();
 3513|       |  if (raw.indexOf('bold') >= 0) { return 700; }
 3514|       |  return null;
 3515|       |}
 3516|       |function __mdmdview_make_canvas_context(canvas) {
 3517|       |  var ctx = {
 3518|       |    canvas: canvas,
 3519|       |    font: '',
 3520|       |    lineWidth: 1,
 3521|       |    fillStyle: '#000',
 3522|       |    strokeStyle: '#000',
 3523|       |    textAlign: 'start',
 3524|       |    textBaseline: 'alphabetic',
 3525|       |    save: function() {},
 3526|       |    restore: function() {},
 3527|       |    beginPath: function() {},
 3528|       |    closePath: function() {},
 3529|       |    moveTo: function() {},
 3530|       |    lineTo: function() {},
 3531|       |    arc: function() {},
 3532|       |    rect: function() {},
 3533|       |    fill: function() {},
 3534|       |    stroke: function() {},
 3535|       |    clip: function() {},
 3536|       |    translate: function() {},
 3537|       |    scale: function() {},
 3538|       |    rotate: function() {},
 3539|       |    clearRect: function() {},
 3540|       |    fillRect: function() {},
 3541|       |    strokeRect: function() {},
 3542|       |    drawImage: function() {},
 3543|       |    setLineDash: function() {},
 3544|       |    measureText: function(text) {
 3545|       |      var size = __mdmdview_parse_font_px(ctx.font);
 3546|       |      var weight = __mdmdview_parse_font_weight(ctx.font);
 3547|       |      var measured = __mdmdview_measure_text(text || '', size, weight);
 3548|       |      return { width: measured.width || 0 };
 3549|       |    },
 3550|       |    fillText: function() {},
 3551|       |    strokeText: function() {},
 3552|       |    createLinearGradient: function() { return { addColorStop: function() {} }; },
 3553|       |    createRadialGradient: function() { return { addColorStop: function() {} }; },
 3554|       |    createPattern: function() { return null; }
 3555|       |  };
 3556|       |  return ctx;
 3557|       |}
 3558|       |function __mdmdview_mindmap_get_size(node) {
 3559|       |  var data = node && typeof node.data === 'function' ? node.data() : null;
 3560|       |  var w = data && data.width !== undefined ? Number(data.width) : 80;
 3561|       |  var h = data && data.height !== undefined ? Number(data.height) : 40;
 3562|       |  if (!isFinite(w) || w <= 0) { w = 80; }
 3563|       |  if (!isFinite(h) || h <= 0) { h = 40; }
 3564|       |  return { w: w, h: h };
 3565|       |}
 3566|       |function __mdmdview_rect_intersection(hw, hh, ux, uy) {
 3567|       |  var ax = Math.abs(ux);
 3568|       |  var ay = Math.abs(uy);
 3569|       |  var dx = ax > 1e-6 ? hw / ax : Infinity;
 3570|       |  var dy = ay > 1e-6 ? hh / ay : Infinity;
 3571|       |  var dist = Math.min(dx, dy);
 3572|       |  if (!isFinite(dist) || dist <= 0) { dist = Math.max(hw, hh); }
 3573|       |  return dist;
 3574|       |}
 3575|       |function __mdmdview_mindmap_collect(nodes, edges) {
 3576|       |  var node_map = {};
 3577|       |  var parents = {};
 3578|       |  var children = {};
 3579|       |  var root = null;
 3580|       |  var root_id = null;
 3581|       |  for (var i = 0; i < nodes.length; i++) {
 3582|       |    var node = nodes[i];
 3583|       |    if (!node || typeof node.data !== 'function') { continue; }
 3584|       |    var data = node.data();
 3585|       |    if (!data) { continue; }
 3586|       |    var id = data.id !== undefined ? String(data.id) : null;
 3587|       |    if (id === null) { continue; }
 3588|       |    node_map[id] = node;
 3589|       |  }
 3590|       |  for (var j = 0; j < edges.length; j++) {
 3591|       |    var edge = edges[j];
 3592|       |    if (!edge || typeof edge.data !== 'function') { continue; }
 3593|       |    var ed = edge.data();
 3594|       |    if (!ed) { continue; }
 3595|       |    var source = ed.source !== undefined ? String(ed.source) : null;
 3596|       |    var target = ed.target !== undefined ? String(ed.target) : null;
 3597|       |    if (!source || !target) { continue; }
 3598|       |    if (!children[source]) { children[source] = []; }
 3599|       |    children[source].push(target);
 3600|       |    parents[target] = source;
 3601|       |  }
 3602|       |  for (var key in node_map) {
 3603|       |    if (!Object.prototype.hasOwnProperty.call(node_map, key)) { continue; }
 3604|       |    if (!Object.prototype.hasOwnProperty.call(parents, key)) {
 3605|       |      root = node_map[key];
 3606|       |      root_id = key;
 3607|       |      break;
 3608|       |    }
 3609|       |  }
 3610|       |  if (!root && nodes.length) {
 3611|       |    root = nodes[0];
 3612|       |    if (root && typeof root.data === 'function') {
 3613|       |      var rd = root.data();
 3614|       |      if (rd && rd.id !== undefined) { root_id = String(rd.id); }
 3615|       |    }
 3616|       |  }
 3617|       |  return { node_map: node_map, children: children, parents: parents, root: root, root_id: root_id };
 3618|       |}
 3619|       |function __mdmdview_mindmap_sorted_children(node_id, tree) {
 3620|       |  var kids = tree.children[node_id] || [];
 3621|       |  return kids.slice();
 3622|       |}
 3623|       |function __mdmdview_mindmap_assign_sides(tree) {
 3624|       |  var sides = {};
 3625|       |  var root_id = tree.root_id;
 3626|       |  if (!root_id) { return sides; }
 3627|       |  sides[root_id] = 0;
 3628|       |  function assign(node_id) {
 3629|       |    var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
 3630|       |    for (var i = 0; i < kids.length; i++) {
 3631|       |      var child_id = kids[i];
 3632|       |      var child_node = tree.node_map[child_id];
 3633|       |      var side = sides[node_id];
 3634|       |      if (node_id === root_id) {
 3635|       |        var data = child_node && typeof child_node.data === 'function' ? child_node.data() : null;
 3636|       |        var section = data && data.section !== undefined ? Number(data.section) : i;
 3637|       |        if (!isFinite(section)) { section = i; }
 3638|       |        side = (section % 2 === 0) ? -1 : 1;
 3639|       |      }
 3640|       |      sides[child_id] = side;
 3641|       |      assign(child_id);
 3642|       |    }
 3643|       |  }
 3644|       |  assign(root_id);
 3645|       |  return sides;
 3646|       |}
 3647|       |function __mdmdview_mindmap_subtree_height(node_id, tree, sizes, gap, heights) {
 3648|       |  var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
 3649|       |  if (!kids.length) {
 3650|       |    heights[node_id] = sizes[node_id].h;
 3651|       |    return heights[node_id];
 3652|       |  }
 3653|       |  var total = 0;
 3654|       |  for (var i = 0; i < kids.length; i++) {
 3655|       |    total += __mdmdview_mindmap_subtree_height(kids[i], tree, sizes, gap, heights);
 3656|       |  }
 3657|       |  total += gap * Math.max(0, kids.length - 1);
 3658|       |  var base = sizes[node_id].h;
 3659|       |  heights[node_id] = total > base ? total : base;
 3660|       |  return heights[node_id];
 3661|       |}
 3662|       |function __mdmdview_mindmap_layout(nodes, edges) {
 3663|       |  var tree = __mdmdview_mindmap_collect(nodes, edges);
 3664|       |  if (!tree.root || !tree.root_id) { return; }
 3665|       |  var sizes = {};
 3666|       |  for (var key in tree.node_map) {
 3667|       |    if (!Object.prototype.hasOwnProperty.call(tree.node_map, key)) { continue; }
 3668|       |    sizes[key] = __mdmdview_mindmap_get_size(tree.node_map[key]);
 3669|       |  }
 3670|       |  var sides = __mdmdview_mindmap_assign_sides(tree);
 3671|       |  var pad = 10;
 3672|       |  var root_data = tree.root && typeof tree.root.data === 'function' ? tree.root.data() : null;
 3673|       |  if (root_data && root_data.padding !== undefined) {
 3674|       |    var p = Number(root_data.padding);
 3675|       |    if (isFinite(p) && p > 0) { pad = p; }
 3676|       |  }
 3677|       |  var gap_x = Math.max(24, pad * 2.2);
 3678|       |  var positions = {};
 3679|       |  positions[tree.root_id] = { x: 0, y: 0 };
 3680|       |  var angles = {};
 3681|       |  angles[tree.root_id] = 0;
 3682|       |  var deg = Math.PI / 180;
 3683|       |  var left_start = 245 * deg;
 3684|       |  var left_end = 122 * deg;
 3685|       |  var right_start = 345 * deg;
 3686|       |  var right_end = 353 * deg;
 3687|       |  function assign_even(children, start, end) {
 3688|       |    if (!children.length) { return; }
 3689|       |    if (children.length === 1) {
 3690|       |      angles[children[0]] = (start + end) / 2;
 3691|       |      return;
 3692|       |    }
 3693|       |    var span = end - start;
 3694|       |    var step = span / (children.length - 1);
 3695|       |    for (var i = 0; i < children.length; i++) {
 3696|       |      angles[children[i]] = start + step * i;
 3697|       |    }
 3698|       |  }
 3699|       |  var root_kids = __mdmdview_mindmap_sorted_children(tree.root_id, tree);
 3700|       |  var left = [];
 3701|       |  var right = [];
 3702|       |  for (var rk = 0; rk < root_kids.length; rk++) {
 3703|       |    var kid = root_kids[rk];
 3704|       |    var side = sides[kid] || 1;
 3705|       |    if (side < 0) { left.push(kid); } else { right.push(kid); }
 3706|       |  }
 3707|       |  assign_even(left, left_start, left_end);
 3708|       |  assign_even(right, right_start, right_end);
 3709|       |  function spread_for_depth(depth, parent_angle) {
 3710|       |    var base = 38 * deg;
 3711|       |    var cos = Math.cos(parent_angle || 0);
 3712|       |    var bias = cos < 0 ? 1.4 : 1.0;
 3713|       |    var depth_factor = 1 + Math.max(0, depth - 1) * 0.2;
 3714|       |    return (base * bias) / depth_factor;
 3715|       |  }
 3716|       |  function assign_child_angles(node_id, depth) {
 3717|       |    var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
 3718|       |    if (!kids.length) { return; }
 3719|       |    var parent_angle = angles[node_id] || 0;
 3720|       |    if (kids.length === 1) {
 3721|       |      var sin = Math.sin(parent_angle);
 3722|       |      var cos = Math.cos(parent_angle);
 3723|       |      var offset = 0;
 3724|       |      if (cos < -0.1 && sin < -0.1) { offset = 20 * deg; }
 3725|       |      angles[kids[0]] = parent_angle + offset;
 3726|       |      assign_child_angles(kids[0], depth + 1);
 3727|       |      return;
 3728|       |    }
 3729|       |    var spread = spread_for_depth(depth, parent_angle);
 3730|       |    var upper = 1.3;
 3731|       |    var lower = 0.9;
 3732|       |    var start = parent_angle - spread * upper;
 3733|       |    var end = parent_angle + spread * lower;
 3734|       |    assign_even(kids, start, end);
 3735|       |    for (var i = 0; i < kids.length; i++) {
 3736|       |      assign_child_angles(kids[i], depth + 1);
 3737|       |    }
 3738|       |  }
 3739|       |  for (var a = 0; a < root_kids.length; a++) {
 3740|       |    assign_child_angles(root_kids[a], 1);
 3741|       |  }
 3742|       |  function place_node(node_id, depth) {
 3743|       |    var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
 3744|       |    if (!kids.length) { return; }
 3745|       |    var parent_pos = positions[node_id];
 3746|       |    var parent_size = sizes[node_id];
 3747|       |    var parent_radius = Math.max(parent_size.w, parent_size.h) / 2;
 3748|       |    var parent_angle = angles[node_id] || 0;
 3749|       |    for (var i = 0; i < kids.length; i++) {
 3750|       |      var child = kids[i];
 3751|       |      var angle = angles[child];
 3752|       |      if (angle === undefined) { angle = angles[node_id] || 0; }
 3753|       |      var child_size = sizes[child];
 3754|       |      var child_radius = Math.max(child_size.w, child_size.h) / 2;
 3755|       |      var dist = parent_radius + child_radius + gap_x;
 3756|       |      if (depth > 0) {
 3757|       |        dist *= 1.15;
 3758|       |      }
 3759|       |      var factor = 1;
 3760|       |      if (depth === 0) {
 3761|       |        var cos = Math.cos(angle);
 3762|       |        var sin = Math.sin(angle);
 3763|       |        factor *= 1.1 * (1 + 0.2 * cos + 0.1 * sin);
 3764|       |      } else {
 3765|       |        var diff = angle - parent_angle;
 3766|       |        while (diff > Math.PI) { diff -= Math.PI * 2; }
 3767|       |        while (diff < -Math.PI) { diff += Math.PI * 2; }
 3768|       |        var norm = diff / (Math.PI / 6);
 3769|       |        if (norm > 1) { norm = 1; }
 3770|       |        if (norm < -1) { norm = -1; }
 3771|       |        factor *= 1 + 0.12 * norm;
 3772|       |        factor *= 0.98 + depth * 0.04;
 3773|       |      }
 3774|       |      if (depth > 0) {
 3775|       |        var sin = Math.sin(angle);
 3776|       |        var cos = Math.cos(angle);
 3777|       |        if (sin >= 0) {
 3778|       |          factor *= 1 + 0.15 * sin;
 3779|       |        } else if (cos > 0) {
 3780|       |          factor *= 1 + 0.05 * sin;
 3781|       |        } else {
 3782|       |          factor *= 1 + 0.25 * sin;
 3783|       |        }
 3784|       |        if (sin < -0.2 && cos < 0) {
 3785|       |          factor *= 0.9;
 3786|       |        }
 3787|       |      }
 3788|       |      if (kids.length === 1) {
 3789|       |        factor *= 0.95;
 3790|       |      }
 3791|       |      dist = dist * factor;
 3792|       |      var cx = parent_pos.x + Math.cos(angle) * dist;
 3793|       |      var cy = parent_pos.y + Math.sin(angle) * dist;
 3794|       |      positions[child] = { x: cx, y: cy };
 3795|       |      place_node(child, depth + 1);
 3796|       |    }
 3797|       |  }
 3798|       |  place_node(tree.root_id, 0);
 3799|       |  var min_x = Infinity;
 3800|       |  var min_y = Infinity;
 3801|       |  for (var id in positions) {
 3802|       |    if (!Object.prototype.hasOwnProperty.call(positions, id)) { continue; }
 3803|       |    var pos = positions[id];
 3804|       |    var size = sizes[id];
 3805|       |    var lx = pos.x - size.w / 2;
 3806|       |    var ly = pos.y - size.h / 2;
 3807|       |    if (lx < min_x) { min_x = lx; }
 3808|       |    if (ly < min_y) { min_y = ly; }
 3809|       |  }
 3810|       |  if (!isFinite(min_x)) { min_x = 0; }
 3811|       |  if (!isFinite(min_y)) { min_y = 0; }
 3812|       |  var dx = pad - min_x;
 3813|       |  var dy = pad - min_y;
 3814|       |  for (var nid in positions) {
 3815|       |    if (!Object.prototype.hasOwnProperty.call(positions, nid)) { continue; }
 3816|       |    positions[nid].x += dx;
 3817|       |    positions[nid].y += dy;
 3818|       |  }
 3819|       |  for (var n = 0; n < nodes.length; n++) {
 3820|       |    var node = nodes[n];
 3821|       |    if (!node || typeof node.data !== 'function') { continue; }
 3822|       |    var data = node.data();
 3823|       |    var id = data && data.id !== undefined ? String(data.id) : null;
 3824|       |    if (!id || !positions[id]) { continue; }
 3825|       |    node._position = { x: positions[id].x, y: positions[id].y };
 3826|       |    node.position = function() { return this._position; };
 3827|       |    data.x = positions[id].x;
 3828|       |    data.y = positions[id].y;
 3829|       |  }
 3830|       |  for (var e = 0; e < edges.length; e++) {
 3831|       |    var edge = edges[e];
 3832|       |    if (!edge || typeof edge.data !== 'function') { continue; }
 3833|       |    var ed = edge.data();
 3834|       |    var source = ed && ed.source !== undefined ? String(ed.source) : null;
 3835|       |    var target = ed && ed.target !== undefined ? String(ed.target) : null;
 3836|       |    if (!source || !target) { continue; }
 3837|       |    var s_pos = positions[source];
 3838|       |    var t_pos = positions[target];
 3839|       |    if (!s_pos || !t_pos) { continue; }
 3840|       |    var s_size = sizes[source];
 3841|       |    var t_size = sizes[target];
 3842|       |    var dx = t_pos.x - s_pos.x;
 3843|       |    var dy = t_pos.y - s_pos.y;
 3844|       |    var len = Math.sqrt(dx * dx + dy * dy);
 3845|       |    if (!isFinite(len) || len <= 0.001) { len = 1; }
 3846|       |    var ux = dx / len;
 3847|       |    var uy = dy / len;
 3848|       |    var s_radius = __mdmdview_rect_intersection(s_size.w / 2, s_size.h / 2, ux, uy);
 3849|       |    var t_radius = __mdmdview_rect_intersection(t_size.w / 2, t_size.h / 2, ux, uy);
 3850|       |    var overlap = -2;
 3851|       |    s_radius += overlap;
 3852|       |    t_radius += overlap;
 3853|       |    if (s_radius < 0) { s_radius = 0; }
 3854|       |    if (t_radius < 0) { t_radius = 0; }
 3855|       |    var max_total = len * 0.95;
 3856|       |    if (s_radius + t_radius > max_total) {
 3857|       |      var scale = max_total / (s_radius + t_radius);
 3858|       |      s_radius *= scale;
 3859|       |      t_radius *= scale;
 3860|       |    }
 3861|       |    var sx = s_pos.x + ux * s_radius;
 3862|       |    var sy = s_pos.y + uy * s_radius;
 3863|       |    var ex = t_pos.x - ux * t_radius;
 3864|       |    var ey = t_pos.y - uy * t_radius;
 3865|       |    var mx = (sx + ex) / 2;
 3866|       |    var my = (sy + ey) / 2;
 3867|       |    edge[0] = edge[0] || {};
 3868|       |    edge[0]._private = {
 3869|       |      bodyBounds: true,
 3870|       |      rscratch: {
 3871|       |        startX: sx,
 3872|       |        startY: sy,
 3873|       |        midX: mx,
 3874|       |        midY: my,
 3875|       |        endX: ex,
 3876|       |        endY: ey
 3877|       |      }
 3878|       |    };
 3879|       |  }
 3880|       |}
 3881|       |function __mdmdview_cytoscape_stub(options) {
 3882|       |  var nodes = [];
 3883|       |  var edges = [];
 3884|       |  function add(entry) {
 3885|       |    if (!entry || !entry.group) { return; }
 3886|       |    if (entry.group === 'nodes') {
 3887|       |      var node = {
 3888|       |        _data: entry.data || {},
 3889|       |        _position: entry.position || { x: 0, y: 0 },
 3890|       |        data: function() { return this._data; },
 3891|       |        position: function() { return this._position; }
 3892|       |      };
 3893|       |      nodes.push(node);
 3894|       |    } else if (entry.group === 'edges') {
 3895|       |      var edge = {
 3896|       |        _data: entry.data || {},
 3897|       |        data: function() { return this._data; }
 3898|       |      };
 3899|       |      edge[0] = { _private: { bodyBounds: false, rscratch: {} } };
 3900|       |      edges.push(edge);
 3901|       |    }
 3902|       |  }
 3903|       |  return {
 3904|       |    add: add,
 3905|       |    nodes: function() { return nodes; },
 3906|       |    edges: function() { return edges; },
 3907|       |    layout: function() {
 3908|       |      return { run: function() { __mdmdview_mindmap_layout(nodes, edges); return this; } };
 3909|       |    }
 3910|       |  };
 3911|       |}
 3912|       |function __mdmdview_make_element(tag, ownerDoc, ns) {
 3913|       |  var doc = ownerDoc;
 3914|       |  if (!doc && typeof document !== 'undefined' && document) { doc = document; }
 3915|       |  var parent = null;
 3916|       |  var parent_set = false;
 3917|       |  var node = {
 3918|       |    tagName: tag,
 3919|       |    namespaceURI: ns || null,
 3920|       |    firstChild: null,
 3921|       |    style: __mdmdview_make_style(),
 3922|       |    children: [],
 3923|       |    childNodes: [],
 3924|       |    attributes: {},
 3925|       |    textContent: '',
 3926|       |    setAttribute: function(key, value) {
 3927|       |      var v = String(value);
 3928|       |      this.attributes[key] = v;
 3929|       |      if (key === 'id') { this.id = v; }
 3930|       |      __mdmdview_bump_bbox_rev();
 3931|       |    },
 3932|       |    setAttributeNS: function(ns, key, value) {
 3933|       |      var v = String(value);
 3934|       |      this.attributes[key] = v;
 3935|       |      if (key === 'id') { this.id = v; }
 3936|       |      __mdmdview_bump_bbox_rev();
 3937|       |    },
 3938|       |    attr: function(key, value) {
 3939|       |      if (value === undefined) { return this.getAttribute(key); }
 3940|       |      if (value === null) { this.removeAttribute(key); return this; }
 3941|       |      this.setAttribute(key, value);
 3942|       |      return this;
 3943|       |    },
 3944|       |    getAttribute: function(key) {
 3945|       |      return Object.prototype.hasOwnProperty.call(this.attributes, key)
 3946|       |        ? this.attributes[key]
 3947|       |        : null;
 3948|       |    },
 3949|       |    getAttributeNS: function(ns, key) { return this.getAttribute(key); },
 3950|       |    text: function(value) {
 3951|       |      if (value === undefined) { return this.textContent || ''; }
 3952|       |      this.textContent = value === null ? '' : String(value);
 3953|       |      __mdmdview_bump_bbox_rev();
 3954|       |      return this;
 3955|       |    },
 3956|       |    append: function(tag) {
 3957|       |      var child = __mdmdview_make_element(tag, this.ownerDocument, this.namespaceURI);
 3958|       |      this.appendChild(child);
 3959|       |      return child;
 3960|       |    },
 3961|       |    removeAttribute: function(key) { delete this.attributes[key]; __mdmdview_bump_bbox_rev(); },
 3962|       |    removeAttributeNS: function(ns, key) { delete this.attributes[key]; __mdmdview_bump_bbox_rev(); },
 3963|       |    appendChild: function(child) {
 3964|       |      __mdmdview_detach(child);
 3965|       |      this.children.push(child);
 3966|       |      this.childNodes = this.children;
 3967|       |      this.firstChild = this.children[0] || null;
 3968|       |      if (child && typeof child === 'object') {
 3969|       |        child.parentNode = this;
 3970|       |        if (!child.ownerDocument && this.ownerDocument) { child.ownerDocument = this.ownerDocument; }
 3971|       |      }
 3972|       |      __mdmdview_bump_bbox_rev();
 3973|       |      return child;
 3974|       |    },
 3975|       |    removeChild: function(child) {
 3976|       |      var idx = this.children.indexOf(child);
 3977|       |      if (idx >= 0) {
 3978|       |        this.children.splice(idx, 1);
 3979|       |        this.childNodes = this.children;
 3980|       |      }
 3981|       |      if (child && typeof child === 'object') { child.parentNode = null; }
 3982|       |      this.firstChild = this.children[0] || null;
 3983|       |      __mdmdview_bump_bbox_rev();
 3984|       |      return child;
 3985|       |    },
 3986|       |    hasChildNodes: function() { return this.children.length > 0; },
 3987|       |    insertBefore: function(child, before) {
 3988|       |      __mdmdview_detach(child);
 3989|       |      var idx = this.children.indexOf(before);
 3990|       |      if (idx < 0) { this.children.push(child); }
 3991|       |      else { this.children.splice(idx, 0, child); }
 3992|       |      this.childNodes = this.children;
 3993|       |      this.firstChild = this.children[0] || null;
 3994|       |      if (child && typeof child === 'object') {
 3995|       |        child.parentNode = this;
 3996|       |        if (!child.ownerDocument && this.ownerDocument) { child.ownerDocument = this.ownerDocument; }
 3997|       |      }
 3998|       |      __mdmdview_bump_bbox_rev();
 3999|       |      return child;
 4000|       |    },
 4001|       |    remove: function() { return null; },
 4002|       |    querySelector: function(sel) { return __mdmdview_query_selector(this, sel); },
 4003|       |    querySelectorAll: function(sel) { return __mdmdview_query_selector_all(this, sel); },
 4004|       |    cloneNode: function(deep) {
 4005|       |      var copy = __mdmdview_make_element(this.tagName, this.ownerDocument, this.namespaceURI);
 4006|       |      copy.textContent = this.textContent;
 4007|       |      copy.innerHTML = this.innerHTML;
 4008|       |      for (var key in this.attributes) {
 4009|       |        if (!Object.prototype.hasOwnProperty.call(this.attributes, key)) { continue; }
 4010|       |        copy.attributes[key] = this.attributes[key];
 4011|       |      }
 4012|       |      if (this.style) {
 4013|       |        for (var prop in this.style) {
 4014|       |          if (!Object.prototype.hasOwnProperty.call(this.style, prop)) { continue; }
 4015|       |          if (typeof this.style[prop] === 'function') { continue; }
 4016|       |          copy.style[prop] = this.style[prop];
 4017|       |        }
 4018|       |      }
 4019|       |      if (deep && this.children && this.children.length) {
 4020|       |        for (var i = 0; i < this.children.length; i++) {
 4021|       |          copy.appendChild(this.children[i].cloneNode(true));
 4022|       |        }
 4023|       |      }
 4024|       |      return copy;
 4025|       |    },
 4026|       |    getBBox: function() {
 4027|       |      var box = __mdmdview_bbox(this);
 4028|       |      if (box) {
 4029|       |        box.w = box.width;
 4030|       |        box.h = box.height;
 4031|       |      }
 4032|       |      return box;
 4033|       |    },
 4034|       |    getBoundingClientRect: function() {
 4035|       |      var box = __mdmdview_bbox(this);
 4036|       |      if (box) {
 4037|       |        box.left = box.x;
 4038|       |        box.top = box.y;
 4039|       |        box.right = box.x + box.width;
 4040|       |        box.bottom = box.y + box.height;
 4041|       |        box.w = box.width;
 4042|       |        box.h = box.height;
 4043|       |      }
 4044|       |      return box;
 4045|       |    },
 4046|       |    getComputedTextLength: function() { return __mdmdview_bbox(this).width; },
 4047|       |    getTotalLength: function() { return __mdmdview_path_total_length(this); },
 4048|       |    getPointAtLength: function(len) { return __mdmdview_path_point_at_length(this, len); },
 4049|       |    addEventListener: function() {},
 4050|       |    removeEventListener: function() {},
 4051|       |    dispatchEvent: function() { return false; }
 4052|       |  };
 4053|       |  var lower = String(tag || '').toLowerCase();
 4054|       |  if (lower === 'canvas') {
 4055|       |    node.width = 300;
 4056|       |    node.height = 150;
 4057|       |    node.getContext = function(kind) {
 4058|       |      if (kind && String(kind).toLowerCase() !== '2d') { return null; }
 4059|       |      if (!node.__mdmdview_ctx) {
 4060|       |        node.__mdmdview_ctx = __mdmdview_make_canvas_context(node);
 4061|       |      }
 4062|       |      return node.__mdmdview_ctx;
 4063|       |    };
 4064|       |  }
 4065|       |  var classList = {
 4066|       |    add: function() {
 4067|       |      var list = __mdmdview_get_class_list(node);
 4068|       |      for (var i = 0; i < arguments.length; i++) {
 4069|       |        var cls = String(arguments[i]);
 4070|       |        if (cls && list.indexOf(cls) < 0) { list.push(cls); }
 4071|       |      }
 4072|       |      __mdmdview_set_class_list(node, list);
 4073|       |    },
 4074|       |    remove: function() {
 4075|       |      var list = __mdmdview_get_class_list(node);
 4076|       |      var next = [];
 4077|       |      for (var i = 0; i < list.length; i++) {
 4078|       |        var keep = true;
 4079|       |        for (var j = 0; j < arguments.length; j++) {
 4080|       |          if (list[i] === String(arguments[j])) { keep = false; break; }
 4081|       |        }
 4082|       |        if (keep) { next.push(list[i]); }
 4083|       |      }
 4084|       |      __mdmdview_set_class_list(node, next);
 4085|       |    },
 4086|       |    contains: function(cls) { return __mdmdview_has_class(node, cls); },
 4087|       |    toggle: function(cls, force) {
 4088|       |      var list = __mdmdview_get_class_list(node);
 4089|       |      var name = String(cls);
 4090|       |      var has = list.indexOf(name) >= 0;
 4091|       |      var should_add = force === undefined ? !has : !!force;
 4092|       |      if (should_add && !has) { list.push(name); }
 4093|       |      if (!should_add && has) { list = list.filter(function(item) { return item !== name; }); }
 4094|       |      __mdmdview_set_class_list(node, list);
 4095|       |      return should_add;
 4096|       |    }
 4097|       |  };
 4098|       |  node.classList = classList;
 4099|       |  Object.defineProperty(node, 'innerHTML', {
 4100|       |    get: function() { return __mdmdview_serialize_children(this); },
 4101|       |    set: function(value) {
 4102|       |      if (this.children && this.children.length) {
 4103|       |        for (var i = 0; i < this.children.length; i++) {
 4104|       |          var child = this.children[i];
 4105|       |          if (child && typeof child === 'object') { child.parentNode = null; }
 4106|       |        }
 4107|       |      }
 4108|       |      this.children = [];
 4109|       |      this.childNodes = this.children;
 4110|       |      this.firstChild = null;
 4111|       |      this.textContent = value ? String(value) : '';
 4112|       |      __mdmdview_bump_bbox_rev();
 4113|       |    },
 4114|       |    configurable: true
 4115|       |  });
 4116|       |  Object.defineProperty(node, 'className', {
 4117|       |    get: function() {
 4118|       |      var cls = this.getAttribute('class');
 4119|       |      return cls ? String(cls) : '';
 4120|       |    },
 4121|       |    set: function(value) { this.setAttribute('class', value); },
 4122|       |    configurable: true
 4123|       |  });
 4124|       |  Object.defineProperty(node, 'outerHTML', {
 4125|       |    get: function() { return __mdmdview_serialize(this); },
 4126|       |    configurable: true
 4127|       |  });
 4128|       |  Object.defineProperty(node, 'ownerDocument', {
 4129|       |    get: function() {
 4130|       |      if (doc) { return doc; }
 4131|       |      if (typeof document !== 'undefined') { return document || null; }
 4132|       |      return null;
 4133|       |    },
 4134|       |    set: function(value) { doc = value; },
 4135|       |    configurable: true
 4136|       |  });
 4137|       |  Object.defineProperty(node, 'parentNode', {
 4138|       |    get: function() {
 4139|       |      if (parent_set) { return parent || null; }
 4140|       |      if (typeof document !== 'undefined' && document && document.body) { return document.body; }
 4141|       |      return null;
 4142|       |    },
 4143|       |    set: function(value) { parent = value; parent_set = true; },
 4144|       |    configurable: true
 4145|       |  });
 4146|       |  Object.defineProperty(node, 'nextSibling', {
 4147|       |    get: function() {
 4148|       |      var p = this.parentNode;
 4149|       |      if (!p || !p.children) { return null; }
 4150|       |      var idx = p.children.indexOf(this);
 4151|       |      return idx >= 0 && idx + 1 < p.children.length ? p.children[idx + 1] : null;
 4152|       |    },
 4153|       |    configurable: true
 4154|       |  });
 4155|       |  Object.defineProperty(node, 'previousSibling', {
 4156|       |    get: function() {
 4157|       |      var p = this.parentNode;
 4158|       |      if (!p || !p.children) { return null; }
 4159|       |      var idx = p.children.indexOf(this);
 4160|       |      return idx > 0 ? p.children[idx - 1] : null;
 4161|       |    },
 4162|       |    configurable: true
 4163|       |  });
 4164|       |  Object.defineProperty(node, 'firstElementChild', {
 4165|       |    get: function() {
 4166|       |      return this.children && this.children.length ? this.children[0] : null;
 4167|       |    },
 4168|       |    configurable: true
 4169|       |  });
 4170|       |  return node;
 4171|       |}
 4172|       |function __mdmdview_find_by_id(node, id) {
 4173|       |  if (!node || !id) { return null; }
 4174|       |  if (node.id === id) { return node; }
 4175|       |  if (node.attributes && node.attributes.id === id) { return node; }
 4176|       |  if (!node.children) { return null; }
 4177|       |  for (var i = 0; i < node.children.length; i++) {
 4178|       |    var hit = __mdmdview_find_by_id(node.children[i], id);
 4179|       |    if (hit) { return hit; }
 4180|       |  }
 4181|       |  return null;
 4182|       |}
 4183|       |function __mdmdview_find_by_tag(node, tag, matches) {
 4184|       |  if (!node || !tag) { return; }
 4185|       |  var name = (node.tagName || '').toLowerCase();
 4186|       |  if (name === tag) { matches.push(node); }
 4187|       |  if (!node.children) { return; }
 4188|       |  for (var i = 0; i < node.children.length; i++) {
 4189|       |    __mdmdview_find_by_tag(node.children[i], tag, matches);
 4190|       |  }
 4191|       |}
 4192|       |function __mdmdview_get_class_list(node) {
 4193|       |  if (!node) { return []; }
 4194|       |  var raw = null;
 4195|       |  if (node.getAttribute) { raw = node.getAttribute('class'); }
 4196|       |  if (raw === null || raw === undefined) { raw = node.attributes && node.attributes['class']; }
 4197|       |  if (!raw) { return []; }
 4198|       |  return String(raw).split(/\s+/).filter(function(item) { return item.length > 0; });
 4199|       |}
 4200|       |function __mdmdview_set_class_list(node, list) {
 4201|       |  if (!node) { return; }
 4202|       |  var value = (list || []).filter(function(item) { return item.length > 0; }).join(' ');
 4203|       |  if (node.setAttribute) { node.setAttribute('class', value); }
 4204|       |  else if (node.attributes) { node.attributes['class'] = value; }
 4205|       |}
 4206|       |function __mdmdview_has_class(node, className) {
 4207|       |  if (!node || !className) { return false; }
 4208|       |  var cls = node.attributes && node.attributes['class'];
 4209|       |  if (!cls) { return false; }
 4210|       |  var parts = String(cls).split(/\s+/);
 4211|       |  for (var i = 0; i < parts.length; i++) {
 4212|       |    if (parts[i] === className) { return true; }
 4213|       |  }
 4214|       |  return false;
 4215|       |}
 4216|       |function __mdmdview_find_by_class(node, className, matches) {
 4217|       |  if (!node || !className) { return; }
 4218|       |  if (__mdmdview_has_class(node, className)) { matches.push(node); }
 4219|       |  if (!node.children) { return; }
 4220|       |  for (var i = 0; i < node.children.length; i++) {
 4221|       |    __mdmdview_find_by_class(node.children[i], className, matches);
 4222|       |  }
 4223|       |}
 4224|       |function __mdmdview_get_attr(node, name) {
 4225|       |  if (!node || !name) { return null; }
 4226|       |  if (node.getAttribute) {
 4227|       |    var val = node.getAttribute(name);
 4228|       |    if (val !== null && val !== undefined) { return String(val); }
 4229|       |  }
 4230|       |  if (node.attributes && Object.prototype.hasOwnProperty.call(node.attributes, name)) {
 4231|       |    return String(node.attributes[name]);
 4232|       |  }
 4233|       |  return null;
 4234|       |}
 4235|       |function __mdmdview_parse_attr_selector(raw) {
 4236|       |  var match = raw.match(/^\[\s*([^\]=\s]+)\s*=\s*["']?([^\"'\]]+)["']?\s*\]$/);
 4237|       |  if (!match) { return null; }
 4238|       |  return { name: match[1], value: match[2] };
 4239|       |}
 4240|       |function __mdmdview_find_by_attr(node, name, value, matches) {
 4241|       |  if (!node || !name) { return null; }
 4242|       |  var attr = __mdmdview_get_attr(node, name);
 4243|       |  if (attr !== null && String(attr) === String(value)) {
 4244|       |    if (matches) { matches.push(node); }
 4245|       |    else { return node; }
 4246|       |  }
 4247|       |  if (!node.children) { return matches ? null : null; }
 4248|       |  for (var i = 0; i < node.children.length; i++) {
 4249|       |    var hit = __mdmdview_find_by_attr(node.children[i], name, value, matches);
 4250|       |    if (!matches && hit) { return hit; }
 4251|       |  }
 4252|       |  return matches ? null : null;
 4253|       |}
 4254|       |function __mdmdview_matches_simple(node, raw) {
 4255|       |  if (!node || !raw) { return false; }
 4256|       |  var attr = __mdmdview_parse_attr_selector(raw);
 4257|       |  if (attr) {
 4258|       |    var attrVal = __mdmdview_get_attr(node, attr.name);
 4259|       |    return attrVal !== null && String(attrVal) === String(attr.value);
 4260|       |  }
 4261|       |  if (raw[0] === '#') {
 4262|       |    var id = raw.slice(1);
 4263|       |    return node.id === id || __mdmdview_get_attr(node, 'id') === id;
 4264|       |  }
 4265|       |  if (raw[0] === '.') {
 4266|       |    return __mdmdview_has_class(node, raw.slice(1));
 4267|       |  }
 4268|       |  var hashIdx = raw.indexOf('#');
 4269|       |  if (hashIdx > 0) {
 4270|       |    var tagName = raw.slice(0, hashIdx).toLowerCase();
 4271|       |    var tagId = raw.slice(hashIdx + 1);
 4272|       |    return (node.tagName || '').toLowerCase() === tagName
 4273|       |      && (node.id === tagId || __mdmdview_get_attr(node, 'id') === tagId);
 4274|       |  }
 4275|       |  var dotIdx = raw.indexOf('.');
 4276|       |  if (dotIdx > 0) {
 4277|       |    var tag = raw.slice(0, dotIdx).toLowerCase();
 4278|       |    var cls = raw.slice(dotIdx + 1);
 4279|       |    return (node.tagName || '').toLowerCase() === tag && __mdmdview_has_class(node, cls);
 4280|       |  }
 4281|       |  return (node.tagName || '').toLowerCase() === raw.toLowerCase();
 4282|       |}
 4283|       |function __mdmdview_matches_selector(node, sel) {
 4284|       |  if (!node || !sel) { return false; }
 4285|       |  var raw = String(sel).trim();
 4286|       |  if (!raw) { return false; }
 4287|       |  var parts = raw.split(/\s+/).filter(function(part) { return part.length > 0; });
 4288|       |  if (parts.length <= 1) { return __mdmdview_matches_simple(node, raw); }
 4289|       |  var idx = parts.length - 1;
 4290|       |  var current = node;
 4291|       |  while (current && idx >= 0) {
 4292|       |    if (__mdmdview_matches_simple(current, parts[idx])) {
 4293|       |      idx -= 1;
 4294|       |    }
 4295|       |    current = current.parentNode;
 4296|       |  }
 4297|       |  return idx < 0;
 4298|       |}
 4299|       |function __mdmdview_query_selector(node, sel) {
 4300|       |  if (!sel) { return null; }
 4301|       |  var raw = String(sel).trim();
 4302|       |  if (!raw) { return null; }
 4303|       |  if (node && !node.tagName && node._parent) { node = node._parent; }
 4304|       |  if ((!node || !node.children) && document && document.body) { node = document.body; }
 4305|       |  var chain = raw.split(/\s+/).filter(function(part) { return part.length > 0; });
 4306|       |  if (chain.length > 1) {
 4307|       |    var current = node;
 4308|       |    for (var c = 0; c < chain.length; c++) {
 4309|       |      current = __mdmdview_query_selector(current, chain[c]);
 4310|       |      if (!current) { return null; }
 4311|       |    }
 4312|       |    return current;
 4313|       |  }
 4314|       |  var result = null;
 4315|       |  var attrSel = __mdmdview_parse_attr_selector(raw);
 4316|       |  if (attrSel) {
 4317|       |    result = __mdmdview_find_by_attr(node, attrSel.name, attrSel.value);
 4318|       |  } else if (raw[0] === '#') {
 4319|       |    result = __mdmdview_find_by_id(node, raw.slice(1));
 4320|       |  } else if (raw[0] === '.') {
 4321|       |    var className = raw.slice(1);
 4322|       |    var classMatches = [];
 4323|       |    __mdmdview_find_by_class(node, className, classMatches);
 4324|       |    result = classMatches.length ? classMatches[0] : null;
 4325|       |  } else if (raw.indexOf('#') > 0) {
 4326|       |    var hashParts = raw.split('#');
 4327|       |    var hashTag = hashParts[0].toLowerCase();
 4328|       |    var hashId = hashParts[1];
 4329|       |    var hashMatches = [];
 4330|       |    __mdmdview_find_by_tag(node, hashTag, hashMatches);
 4331|       |    for (var h = 0; h < hashMatches.length; h++) {
 4332|       |      if (hashMatches[h].id === hashId || __mdmdview_get_attr(hashMatches[h], 'id') === hashId) {
 4333|       |        result = hashMatches[h];
 4334|       |        break;
 4335|       |      }
 4336|       |    }
 4337|       |  } else if (raw.indexOf('.') > 0) {
 4338|       |    var pieces = raw.split('.');
 4339|       |    var tagName = pieces[0].toLowerCase();
 4340|       |    var clsName = pieces[1];
 4341|       |    var tagMatches = [];
 4342|       |    __mdmdview_find_by_tag(node, tagName, tagMatches);
 4343|       |    for (var t = 0; t < tagMatches.length; t++) {
 4344|       |      if (__mdmdview_has_class(tagMatches[t], clsName)) {
 4345|       |        result = tagMatches[t];
 4346|       |        break;
 4347|       |      }
 4348|       |    }
 4349|       |  } else {
 4350|       |    var tag = raw.toLowerCase();
 4351|       |    var matches = [];
 4352|       |    __mdmdview_find_by_tag(node, tag, matches);
 4353|       |    result = matches.length ? matches[0] : null;
 4354|       |  }
 4355|       |  return result;
 4356|       |}
 4357|       |function __mdmdview_query_selector_all(node, sel) {
 4358|       |  if (!sel) { return []; }
 4359|       |  var raw = String(sel).trim();
 4360|       |  if (!raw) { return []; }
 4361|       |  if (node && !node.tagName && node._parent) { node = node._parent; }
 4362|       |  if ((!node || !node.children) && document && document.body) { node = document.body; }
 4363|       |  var chain = raw.split(/\s+/).filter(function(part) { return part.length > 0; });
 4364|       |  if (chain.length > 1) {
 4365|       |    var current = node;
 4366|       |    for (var c = 0; c < chain.length; c++) {
 4367|       |      current = __mdmdview_query_selector(current, chain[c]);
 4368|       |      if (!current) { return []; }
 4369|       |    }
 4370|       |    return [current];
 4371|       |  }
 4372|       |  var attrSel = __mdmdview_parse_attr_selector(raw);
 4373|       |  if (attrSel) {
 4374|       |    var attrMatches = [];
 4375|       |    __mdmdview_find_by_attr(node, attrSel.name, attrSel.value, attrMatches);
 4376|       |    return attrMatches;
 4377|       |  }
 4378|       |  if (raw[0] === '#') {
 4379|       |    var hit = __mdmdview_find_by_id(node, raw.slice(1));
 4380|       |    return hit ? [hit] : [];
 4381|       |  }
 4382|       |  if (raw[0] === '.') {
 4383|       |    var className = raw.slice(1);
 4384|       |    var classMatches = [];
 4385|       |    __mdmdview_find_by_class(node, className, classMatches);
 4386|       |    return classMatches;
 4387|       |  }
 4388|       |  if (raw.indexOf('#') > 0) {
 4389|       |    var hashParts = raw.split('#');
 4390|       |    var hashTag = hashParts[0].toLowerCase();
 4391|       |    var hashId = hashParts[1];
 4392|       |    var hashMatches = [];
 4393|       |    __mdmdview_find_by_tag(node, hashTag, hashMatches);
 4394|       |    var hashHits = [];
 4395|       |    for (var h = 0; h < hashMatches.length; h++) {
 4396|       |      if (hashMatches[h].id === hashId || __mdmdview_get_attr(hashMatches[h], 'id') === hashId) {
 4397|       |        hashHits.push(hashMatches[h]);
 4398|       |      }
 4399|       |    }
 4400|       |    return hashHits;
 4401|       |  }
 4402|       |  if (raw.indexOf('.') > 0) {
 4403|       |    var pieces = raw.split('.');
 4404|       |    var tagName = pieces[0].toLowerCase();
 4405|       |    var clsName = pieces[1];
 4406|       |    var tagMatches = [];
 4407|       |    __mdmdview_find_by_tag(node, tagName, tagMatches);
 4408|       |    var hits = [];
 4409|       |    for (var t = 0; t < tagMatches.length; t++) {
 4410|       |      if (__mdmdview_has_class(tagMatches[t], clsName)) {
 4411|       |        hits.push(tagMatches[t]);
 4412|       |      }
 4413|       |    }
 4414|       |    return hits;
 4415|       |  }
 4416|       |  var tag = raw.toLowerCase();
 4417|       |  var matches = [];
 4418|       |  __mdmdview_find_by_tag(node, tag, matches);
 4419|       |  return matches;
 4420|       |}
 4421|       |var document = {
 4422|       |  body: __mdmdview_make_element('body'),
 4423|       |  head: __mdmdview_make_element('head'),
 4424|       |  children: [],
 4425|       |  childNodes: [],
 4426|       |  createElement: function(tag) { return __mdmdview_make_element(tag, document); },
 4427|       |  createElementNS: function(ns, tag) { return __mdmdview_make_element(tag, document, ns); },
 4428|       |  createTextNode: function(text) {
 4429|       |    var node = __mdmdview_make_element('#text', document);
 4430|       |    node.textContent = text || '';
 4431|       |    return node;
 4432|       |  },
 4433|       |  getElementById: function(id) { return __mdmdview_find_by_id(document, id); },
 4434|       |  getElementsByTagName: function(tag) {
 4435|       |    var raw = String(tag || '').trim().toLowerCase();
 4436|       |    if (!raw) { return []; }
 4437|       |    if (raw === 'head') { return document.head ? [document.head] : []; }
 4438|       |    if (raw === 'body') { return document.body ? [document.body] : []; }
 4439|       |    var matches = [];
 4440|       |    __mdmdview_find_by_tag(document, raw, matches);
 4441|       |    return matches;
 4442|       |  },
 4443|       |  querySelector: function(sel) {
 4444|       |    var raw = String(sel || '').trim().toLowerCase();
 4445|       |    var result = raw === 'head'
 4446|       |      ? document.head
 4447|       |      : (raw === 'body' ? document.body : __mdmdview_query_selector(document, sel));
 4448|       |    return result || (document && document.body ? document.body : null);
 4449|       |  },
 4450|       |  querySelectorAll: function(sel) {
 4451|       |    var raw = String(sel || '').trim().toLowerCase();
 4452|       |    var result = raw === 'head'
 4453|       |      ? [document.head]
 4454|       |      : (raw === 'body' ? [document.body] : __mdmdview_query_selector_all(document, sel));
 4455|       |    if (result && result.length) { return result; }
 4456|       |    return document && document.body ? [document.body] : [];
 4457|       |  },
 4458|       |  appendChild: function(child) {
 4459|       |    return document.documentElement
 4460|       |      ? document.documentElement.appendChild(child)
 4461|       |      : document.body.appendChild(child);
 4462|       |  },
 4463|       |  insertBefore: function(child, before) {
 4464|       |    return document.documentElement
 4465|       |      ? document.documentElement.insertBefore(child, before)
 4466|       |      : document.body.insertBefore(child, before);
 4467|       |  },
 4468|       |  removeChild: function(child) {
 4469|       |    return document.documentElement
 4470|       |      ? document.documentElement.removeChild(child)
 4471|       |      : document.body.removeChild(child);
 4472|       |  },
 4473|       |  hasChildNodes: function() {
 4474|       |    return document.documentElement
 4475|       |      ? document.documentElement.hasChildNodes()
 4476|       |      : document.body.hasChildNodes();
 4477|       |  },
 4478|       |  addEventListener: function() {}
 4479|       |};
 4480|       |window.document = document;
 4481|       |document.body.ownerDocument = document;
 4482|       |document.head.ownerDocument = document;
 4483|       |document.documentElement = __mdmdview_make_element('html');
 4484|       |document.documentElement.ownerDocument = document;
 4485|       |document.documentElement.appendChild(document.head);
 4486|       |document.documentElement.appendChild(document.body);
 4487|       |document.documentElement.parentNode = document;
 4488|       |document.children = [document.documentElement];
 4489|       |document.childNodes = document.children;
 4490|       |document.defaultView = window;
 4491|       |document.ownerDocument = document;
 4492|       |document.body.namespaceURI = 'http://www.w3.org/1999/xhtml';
 4493|       |document.head.namespaceURI = 'http://www.w3.org/1999/xhtml';
 4494|       |document.documentElement.namespaceURI = 'http://www.w3.org/1999/xhtml';
 4495|       |document.namespaceURI = document.body.namespaceURI;
 4496|       |window.ownerDocument = document;
 4497|       |window.namespaceURI = document.body.namespaceURI;
 4498|       |function __mdmdview_clear_node(node) {
 4499|       |  if (!node) { return; }
 4500|       |  if (node.children && node.children.length) {
 4501|       |    for (var i = 0; i < node.children.length; i++) {
 4502|       |      var child = node.children[i];
 4503|       |      if (child && typeof child === 'object') { child.parentNode = null; }
 4504|       |    }
 4505|       |  }
 4506|       |  node.children = [];
 4507|       |  node.childNodes = node.children;
 4508|       |  node.firstChild = null;
 4509|       |  node.textContent = '';
 4510|       |}
 4511|       |function __mdmdview_reset_dom() {
 4512|       |  __mdmdview_clear_node(document.head);
 4513|       |  __mdmdview_clear_node(document.body);
 4514|       |  document.documentElement.children = [document.head, document.body];
 4515|       |  document.documentElement.childNodes = document.documentElement.children;
 4516|       |  document.documentElement.firstChild = document.head || null;
 4517|       |  document.head.parentNode = document.documentElement;
 4518|       |  document.body.parentNode = document.documentElement;
 4519|       |  __mdmdview_text_cache = {};
 4520|       |  window.__mdmdview_timer_queue = [];
 4521|       |  window.__mdmdview_timer_map = {};
 4522|       |  window.__mdmdview_now_base = 0;
 4523|       |  window.__mdmdview_bbox_rev = 0;
 4524|       |}
 4525|       |if (!Object.hasOwn) {
 4526|       |  Object.hasOwn = function(obj, prop) {
 4527|       |    return Object.prototype.hasOwnProperty.call(obj, prop);
 4528|       |  };
 4529|       |}
 4530|       |if (!Object.prototype.hasOwnProperty('ownerDocument')) {
 4531|       |  Object.defineProperty(Object.prototype, 'ownerDocument', {
 4532|       |    get: function() { return document || null; },
 4533|       |    set: function(value) {
 4534|       |      Object.defineProperty(this, 'ownerDocument', { value: value, writable: true, configurable: true });
 4535|       |    },
 4536|       |    configurable: true
 4537|       |  });
 4538|       |}
 4539|       |if (!Object.prototype.hasOwnProperty('parentNode')) {
 4540|       |  Object.defineProperty(Object.prototype, 'parentNode', {
 4541|       |    get: function() {
 4542|       |      if (this && this.__mdmdview_parent_set) {
 4543|       |        return this.__mdmdview_parent || null;
 4544|       |      }
 4545|       |      if (typeof document !== 'undefined' && document && document.body) { return document.body; }
 4546|       |      return null;
 4547|       |    },
 4548|       |    set: function(value) {
 4549|       |      this.__mdmdview_parent = value;
 4550|       |      this.__mdmdview_parent_set = true;
 4551|       |    },
 4552|       |    configurable: true
 4553|       |  });
 4554|       |}
 4555|       |if (!Object.prototype.hasOwnProperty('querySelector')) {
 4556|       |  Object.defineProperty(Object.prototype, 'querySelector', {
 4557|       |    value: function(sel) { return __mdmdview_query_selector(this, sel); },
 4558|       |    writable: true,
 4559|       |    configurable: true
 4560|       |  });
 4561|       |}
 4562|       |if (!Object.prototype.hasOwnProperty('querySelectorAll')) {
 4563|       |  Object.defineProperty(Object.prototype, 'querySelectorAll', {
 4564|       |    value: function(sel) { return __mdmdview_query_selector_all(this, sel); },
 4565|       |    writable: true,
 4566|       |    configurable: true
 4567|       |  });
 4568|       |}
 4569|       |if (!Object.prototype.hasOwnProperty('appendChild')) {
 4570|       |  Object.defineProperty(Object.prototype, 'appendChild', {
 4571|       |    value: function(child) {
 4572|       |      if (this && !this.tagName && document && document.body && this !== document.body) {
 4573|       |        return document.body.appendChild(child);
 4574|       |      }
 4575|       |      __mdmdview_detach(child);
 4576|       |      if (!this.children) { this.children = []; }
 4577|       |      this.children.push(child);
 4578|       |      this.childNodes = this.children;
 4579|       |      this.firstChild = this.children[0] || null;
 4580|       |      if (child && typeof child === 'object') {
 4581|       |        child.parentNode = this;
 4582|       |      }
 4583|       |      return child;
 4584|       |    },
 4585|       |    writable: true,
 4586|       |    configurable: true
 4587|       |  });
 4588|       |}
 4589|       |if (!Object.prototype.hasOwnProperty('insertBefore')) {
 4590|       |  Object.defineProperty(Object.prototype, 'insertBefore', {
 4591|       |    value: function(child, before) {
 4592|       |      if (this && !this.tagName && document && document.body && this !== document.body) {
 4593|       |        return document.body.insertBefore(child, before);
 4594|       |      }
 4595|       |      __mdmdview_detach(child);
 4596|       |      if (!this.children) { this.children = []; }
 4597|       |      var idx = this.children.indexOf(before);
 4598|       |      if (idx < 0) { this.children.push(child); }
 4599|       |      else { this.children.splice(idx, 0, child); }
 4600|       |      this.childNodes = this.children;
 4601|       |      this.firstChild = this.children[0] || null;
 4602|       |      if (child && typeof child === 'object') {
 4603|       |        child.parentNode = this;
 4604|       |      }
 4605|       |      return child;
 4606|       |    },
 4607|       |    writable: true,
 4608|       |    configurable: true
 4609|       |  });
 4610|       |}
 4611|       |if (!Object.prototype.hasOwnProperty('removeChild')) {
 4612|       |  Object.defineProperty(Object.prototype, 'removeChild', {
 4613|       |    value: function(child) {
 4614|       |      if (!this.children) { return child; }
 4615|       |      var idx = this.children.indexOf(child);
 4616|       |      if (idx >= 0) { this.children.splice(idx, 1); }
 4617|       |      this.childNodes = this.children;
 4618|       |      this.firstChild = this.children[0] || null;
 4619|       |      return child;
 4620|       |    },
 4621|       |    writable: true,
 4622|       |    configurable: true
 4623|       |  });
 4624|       |}
 4625|       |if (!Object.prototype.hasOwnProperty('matches')) {
 4626|       |  Object.defineProperty(Object.prototype, 'matches', {
 4627|       |    value: function(sel) { return __mdmdview_matches_selector(this, sel); },
 4628|       |    writable: true,
 4629|       |    configurable: true
 4630|       |  });
 4631|       |}
 4632|       |if (!Object.prototype.hasOwnProperty('nextSibling')) {
 4633|       |  Object.defineProperty(Object.prototype, 'nextSibling', {
 4634|       |    get: function() { return null; },
 4635|       |    configurable: true
 4636|       |  });
 4637|       |}
 4638|       |if (!Object.prototype.hasOwnProperty('previousSibling')) {
 4639|       |  Object.defineProperty(Object.prototype, 'previousSibling', {
 4640|       |    get: function() { return null; },
 4641|       |    configurable: true
 4642|       |  });
 4643|       |}
 4644|       |window.getComputedStyle = function(el) {
 4645|       |  return (el && el.style) ? el.style : __mdmdview_make_style();
 4646|       |};
 4647|       |window.__mdmdview_timer_queue = [];
 4648|       |window.__mdmdview_timer_map = {};
 4649|       |window.__mdmdview_next_timer_id = 1;
 4650|       |window.setTimeout = function(fn, ms) {
 4651|       |  var id = window.__mdmdview_next_timer_id++;
 4652|       |  window.__mdmdview_timer_map[id] = { fn: fn, interval: false };
 4653|       |  window.__mdmdview_timer_queue.push(id);
 4654|       |  return id;
 4655|       |};
 4656|       |window.clearTimeout = function(id) {
 4657|       |  if (window.__mdmdview_timer_map) {
 4658|       |    delete window.__mdmdview_timer_map[id];
 4659|       |  }
 4660|       |};
 4661|       |window.setInterval = function(fn, ms) {
 4662|       |  var id = window.__mdmdview_next_timer_id++;
 4663|       |  window.__mdmdview_timer_map[id] = { fn: fn, interval: true };
 4664|       |  window.__mdmdview_timer_queue.push(id);
 4665|       |  return id;
 4666|       |};
 4667|       |window.clearInterval = function(id) { window.clearTimeout(id); };
 4668|       |window.requestAnimationFrame = function(fn) {
 4669|       |  return window.setTimeout(function() { fn(0); }, 16);
 4670|       |};
 4671|       |window.cancelAnimationFrame = function(id) { window.clearTimeout(id); };
 4672|       |window.__mdmdview_run_timers = function(max_ticks) {
 4673|       |  var ticks = 0;
 4674|       |  var queue = window.__mdmdview_timer_queue || [];
 4675|       |  var map = window.__mdmdview_timer_map || {};
 4676|       |  var limit = typeof max_ticks === 'number' && max_ticks > 0 ? max_ticks : 1000;
 4677|       |  while (queue.length && ticks < limit) {
 4678|       |    var id = queue.shift();
 4679|       |    var entry = map[id];
 4680|       |    if (entry && typeof entry.fn === 'function') { entry.fn(); }
 4681|       |    if (entry && entry.interval) {
 4682|       |      queue.push(id);
 4683|       |    } else {
 4684|       |      delete map[id];
 4685|       |    }
 4686|       |    ticks++;
 4687|       |  }
 4688|       |  return queue.length;
 4689|       |};
 4690|       |if (!window.devicePixelRatio) { window.devicePixelRatio = 1; }
 4691|       |if (!window.Image) {
 4692|       |  window.Image = function() {
 4693|       |    this.complete = true;
 4694|       |    this.addEventListener = function() {};
 4695|       |    this.removeEventListener = function() {};
 4696|       |    return this;
 4697|       |  };
 4698|       |}
 4699|       |window.addEventListener = function() {};
 4700|       |window.removeEventListener = function() {};
 4701|       |window.structuredClone = function(value) {
 4702|       |  if (value === null || value === undefined) { return value; }
 4703|       |  if (typeof value !== 'object') { return value; }
 4704|       |  try { return JSON.parse(JSON.stringify(value)); } catch (e) {}
 4705|       |  if (Array.isArray(value)) { return value.slice(); }
 4706|       |  var out = {};
 4707|       |  for (var key in value) {
 4708|       |    if (!Object.prototype.hasOwnProperty.call(value, key)) { continue; }
 4709|       |    out[key] = value[key];
 4710|       |  }
 4711|       |  return out;
 4712|       |};
 4713|       |window.__mdmdview_now_base = 0;
 4714|       |window.performance = { now: function(){
 4715|       |  if (typeof Date !== 'undefined' && typeof Date.now === 'function') { return Date.now(); }
 4716|       |  window.__mdmdview_now_base += 1;
 4717|       |  return window.__mdmdview_now_base;
 4718|       |} };
 4719|       |window.console = {
 4720|       |  log: function(){},
 4721|       |  warn: function(){},
 4722|       |  error: function(){},
 4723|       |  info: function(){},
 4724|       |  debug: function(){},
 4725|       |  trace: function(){}
 4726|       |};
 4727|       |window.fetch = function(){ throw new Error('fetch disabled'); };
 4728|       |window.XMLHttpRequest = function(){ throw new Error('XMLHttpRequest disabled'); };
 4729|       |window.DOMPurify = { sanitize: function(html){ return html; } };
 4730|       |window.getComputedStyle = function(el) {
 4731|       |  var style = (el && el.style) ? el.style : __mdmdview_make_style();
 4732|       |  if (!style.fontSize) { style.fontSize = '16px'; }
 4733|       |  if (!style['font-size']) { style['font-size'] = style.fontSize; }
 4734|       |  if (!style.fontFamily) { style.fontFamily = 'sans-serif'; }
 4735|       |  if (!style['font-family']) { style['font-family'] = style.fontFamily; }
 4736|       |  if (!style.fontWeight) { style.fontWeight = 'normal'; }
 4737|       |  if (!style['font-weight']) { style['font-weight'] = style.fontWeight; }
 4738|       |  if (!style.fontStyle) { style.fontStyle = 'normal'; }
 4739|       |  if (!style['font-style']) { style['font-style'] = style.fontStyle; }
 4740|       |  if (el && el.getAttribute) {
 4741|       |    var attrSize = el.getAttribute('font-size');
 4742|       |    if (attrSize) {
 4743|       |      style.fontSize = String(attrSize);
 4744|       |      style['font-size'] = style.fontSize;
 4745|       |    }
 4746|       |    var attrFamily = el.getAttribute('font-family');
 4747|       |    if (attrFamily) {
 4748|       |      style.fontFamily = String(attrFamily);
 4749|       |      style['font-family'] = style.fontFamily;
 4750|       |    }
 4751|       |    var attrWeight = el.getAttribute('font-weight');
 4752|       |    if (attrWeight) {
 4753|       |      style.fontWeight = String(attrWeight);
 4754|       |      style['font-weight'] = style.fontWeight;
 4755|       |    }
 4756|       |    var attrStyle = el.getAttribute('font-style');
 4757|       |    if (attrStyle) {
 4758|       |      style.fontStyle = String(attrStyle);
 4759|       |      style['font-style'] = style.fontStyle;
 4760|       |    }
 4761|       |  }
 4762|       |  style.getPropertyValue = function(key) {
 4763|       |    if (Object.prototype.hasOwnProperty.call(style, key)) { return style[key]; }
 4764|       |    if (key === 'font-size') { return style.fontSize; }
 4765|       |    if (key === 'font-family') { return style.fontFamily; }
 4766|       |    if (key === 'font-weight') { return style.fontWeight; }
 4767|       |    if (key === 'font-style') { return style.fontStyle; }
 4768|       |    return '';
 4769|       |  };
 4770|       |  return style;
 4771|       |};
 4772|       |window.__mdmdview_viewport_width = 1200;
 4773|       |window.__mdmdview_viewport_height = 900;
 4774|       |Object.defineProperty(window, 'innerWidth', {
 4775|       |  get: function() { return window.__mdmdview_viewport_width || 0; },
 4776|       |  configurable: true
 4777|       |});
 4778|       |Object.defineProperty(window, 'innerHeight', {
 4779|       |  get: function() { return window.__mdmdview_viewport_height || 0; },
 4780|       |  configurable: true
 4781|       |});
 4782|       |if (!Object.prototype.hasOwnProperty('parentElement')) {
 4783|       |  Object.defineProperty(Object.prototype, 'parentElement', {
 4784|       |    get: function() {
 4785|       |      var p = this && this.parentNode ? this.parentNode : null;
 4786|       |      if (p && p.tagName) { return p; }
 4787|       |      return null;
 4788|       |    },
 4789|       |    configurable: true
 4790|       |  });
 4791|       |}
 4792|       |if (!Object.prototype.hasOwnProperty('offsetWidth')) {
 4793|       |  Object.defineProperty(Object.prototype, 'offsetWidth', {
 4794|       |    get: function() {
 4795|       |      if (this && typeof this.getBBox === 'function') {
 4796|       |        var width = this.getBBox().width || 0;
 4797|       |        if (width) { return width; }
 4798|       |      }
 4799|       |      return window.innerWidth || 0;
 4800|       |    },
 4801|       |    configurable: true
 4802|       |  });
 4803|       |}
 4804|       |if (!Object.prototype.hasOwnProperty('offsetHeight')) {
 4805|       |  Object.defineProperty(Object.prototype, 'offsetHeight', {
 4806|       |    get: function() {
 4807|       |      if (this && typeof this.getBBox === 'function') {
 4808|       |        var height = this.getBBox().height || 0;
 4809|       |        if (height) { return height; }
 4810|       |      }
 4811|       |      return window.innerHeight || 0;
 4812|       |    },
 4813|       |    configurable: true
 4814|       |  });
 4815|       |}
 4816|       |if (!Object.prototype.hasOwnProperty('clientWidth')) {
 4817|       |  Object.defineProperty(Object.prototype, 'clientWidth', {
 4818|       |    get: function() { return this.offsetWidth || 0; },
 4819|       |    configurable: true
 4820|       |  });
 4821|       |}
 4822|       |if (!Object.prototype.hasOwnProperty('clientHeight')) {
 4823|       |  Object.defineProperty(Object.prototype, 'clientHeight', {
 4824|       |    get: function() { return this.offsetHeight || 0; },
 4825|       |    configurable: true
 4826|       |  });
 4827|       |}
 4828|       |"#;
 4829|       |
 4830|       |#[cfg(feature = "mermaid-quickjs")]
 4831|       |const MERMAID_INIT_SNIPPET: &str = r##"
 4832|       |if (window.mermaid && mermaid.mermaidAPI) {
 4833|       |  mermaid.mermaidAPI.initialize({startOnLoad: false});
 4834|       |  window.__mdmdview_is_plain_object = function(value) {
 4835|       |    return value && typeof value === 'object' && !Array.isArray(value);
 4836|       |  };
 4837|       |  window.__mdmdview_merge_config = function(baseConfig, overrideConfig) {
 4838|       |    var out = {};
 4839|       |    function assign(target, source) {
 4840|       |      if (!window.__mdmdview_is_plain_object(source)) { return; }
 4841|       |      for (var key in source) {
 4842|       |        if (!Object.prototype.hasOwnProperty.call(source, key)) { continue; }
 4843|       |        var value = source[key];
 4844|       |        if (window.__mdmdview_is_plain_object(value)) {
 4845|       |          if (!window.__mdmdview_is_plain_object(target[key])) { target[key] = {}; }
 4846|       |          assign(target[key], value);
 4847|       |        } else if (Array.isArray(value)) {
 4848|       |          target[key] = value.slice();
 4849|       |        } else {
 4850|       |          target[key] = value;
 4851|       |        }
 4852|       |      }
 4853|       |    }
 4854|       |    assign(out, baseConfig);
 4855|       |    assign(out, overrideConfig);
 4856|       |    return out;
 4857|       |  };
 4858|       |  window.__mdmdview_sanitize_config = function(cfg) {
 4859|       |    if (!window.__mdmdview_is_plain_object(cfg)) { return null; }
 4860|       |    var disallowed = {
 4861|       |      securityLevel: true,
 4862|       |      startOnLoad: true,
 4863|       |      maxTextSize: true,
 4864|       |      deterministicIds: true,
 4865|       |      deterministicIDSeed: true,
 4866|       |      htmlLabels: true,
 4867|       |      themeCSS: true,
 4868|       |      dompurifyConfig: true,
 4869|       |      secure: true
 4870|       |    };
 4871|       |    var out = {};
 4872|       |    for (var key in cfg) {
 4873|       |      if (!Object.prototype.hasOwnProperty.call(cfg, key)) { continue; }
 4874|       |      if (key.indexOf('__') === 0 || key.indexOf('proto') >= 0 || key.indexOf('constructor') >= 0) {
 4875|       |        continue;
 4876|       |      }
 4877|       |      if (disallowed[key]) { continue; }
 4878|       |      var value = cfg[key];
 4879|       |      if (window.__mdmdview_is_plain_object(value)) {
 4880|       |        var nested = window.__mdmdview_sanitize_config(value);
 4881|       |        if (nested && Object.keys(nested).length) { out[key] = nested; }
 4882|       |      } else if (Array.isArray(value)) {
 4883|       |        out[key] = value.slice();
 4884|       |      } else {
 4885|       |        out[key] = value;
 4886|       |      }
 4887|       |    }
 4888|       |    if (out.themeVariables && window.__mdmdview_is_plain_object(out.themeVariables)) {
 4889|       |      for (var tvKey in out.themeVariables) {
 4890|       |        if (!Object.prototype.hasOwnProperty.call(out.themeVariables, tvKey)) { continue; }
 4891|       |        var tvVal = out.themeVariables[tvKey];
 4892|       |        if (typeof tvVal === 'string') {
 4893|       |          if (!tvVal.match(/^[\d "#%(),.;A-Za-z-]+$/)) {
 4894|       |            delete out.themeVariables[tvKey];
 4895|       |          }
 4896|       |        }
 4897|       |      }
 4898|       |    }
 4899|       |    return out;
 4900|       |  };
 4901|       |  window.__mdmdview_extract_init = function(code) {
 4902|       |    if (typeof code !== 'string') { return { code: code, config: null }; }
 4903|       |    var initRe = /%%\{\s*init\s*:\s*([\s\S]*?)\s*\}%%/g;
 4904|       |    var found = null;
 4905|       |    var cleaned = code.replace(initRe, function(match, json) {
 4906|       |      if (found === null) {
 4907|       |        try { found = JSON.parse(json); } catch (e) { found = null; }
 4908|       |      }
 4909|       |      return '';
 4910|       |    });
 4911|       |    return { code: cleaned, config: found };
 4912|       |  };
 4913|       |} else {
 4914|       |  throw new Error('Mermaid not available');
 4915|       |}
 4916|       |"##;
 4917|       |
 4918|       |#[cfg(feature = "mermaid-quickjs")]
 4919|       |const MERMAID_RENDER_WRAPPER: &str = r#"
 4920|       |(function(id, code, siteConfigJson, viewportWidth, viewportHeight){
 4921|       |  if (typeof __mdmdview_reset_dom === 'function') {
 4922|       |    __mdmdview_reset_dom();
 4923|       |  }
 4924|       |  if (typeof viewportWidth === 'number' && viewportWidth > 0) {
 4925|       |    window.__mdmdview_viewport_width = viewportWidth;
 4926|       |  }
 4927|       |  if (typeof viewportHeight === 'number' && viewportHeight > 0) {
 4928|       |    window.__mdmdview_viewport_height = viewportHeight;
 4929|       |  }
 4930|       |  var siteConfig = {};
 4931|       |  if (typeof siteConfigJson === 'string' && siteConfigJson.length > 0) {
 4932|       |    try { siteConfig = JSON.parse(siteConfigJson); } catch (e) { siteConfig = {}; }
 4933|       |  }
 4934|       |  var extracted = window.__mdmdview_extract_init(code);
 4935|       |  var directiveConfig = window.__mdmdview_sanitize_config(extracted.config) || {};
 4936|       |  var merged = window.__mdmdview_merge_config(directiveConfig, siteConfig);
 4937|       |  if (merged && merged.securityLevel === 'strict') {
 4938|       |    merged.htmlLabels = false;
 4939|       |    if (!merged.flowchart) { merged.flowchart = {}; }
 4940|       |    merged.flowchart.htmlLabels = false;
 4941|       |  }
 4942|       |  function __mdmdview_flush_timers() {
 4943|       |    if (typeof __mdmdview_run_timers !== 'function') { return; }
 4944|       |    var remaining = 0;
 4945|       |    var cycles = 0;
 4946|       |    do {
 4947|       |      remaining = __mdmdview_run_timers(1000);
 4948|       |      cycles++;
 4949|       |    } while (remaining > 0 && cycles < 100);
 4950|       |    if (remaining > 0) { throw new Error('Mermaid timer queue did not drain'); }
 4951|       |  }
 4952|       |  function __mdmdview_pump_timers(max_cycles) {
 4953|       |    var cycles = 0;
 4954|       |    function step() {
 4955|       |      if (typeof __mdmdview_run_timers !== 'function') {
 4956|       |        return Promise.resolve();
 4957|       |      }
 4958|       |      var remaining = __mdmdview_run_timers(1000);
 4959|       |      cycles++;
 4960|       |      if (remaining > 0 && cycles < max_cycles) {
 4961|       |        return Promise.resolve().then(step);
 4962|       |      }
 4963|       |      if (remaining > 0) {
 4964|       |        return Promise.reject(new Error('Mermaid timer queue did not drain'));
 4965|       |      }
 4966|       |      return Promise.resolve();
 4967|       |    }
 4968|       |    return step();
 4969|       |  }
 4970|       |  mermaid.mermaidAPI.initialize(merged);
 4971|       |  var renderCode = extracted && extracted.code !== undefined ? extracted.code : code;
 4972|       |  var svgOut = null;
 4973|       |  var renderResult = null;
 4974|       |  try {
 4975|       |    renderResult = mermaid.mermaidAPI.render(id, renderCode, function(svg){ svgOut = svg; });
 4976|       |    __mdmdview_flush_timers();
 4977|       |  } catch (err) {
 4978|       |    throw err;
 4979|       |  }
 4980|       |  if (renderResult && typeof renderResult.then === 'function') {
 4981|       |    var pump = __mdmdview_pump_timers(400);
 4982|       |    return Promise.all([renderResult, pump]).then(function(values){
 4983|       |      __mdmdview_flush_timers();
 4984|       |      var out = values && values.length ? values[0] : null;
 4985|       |      if (typeof out === 'string') { return out; }
 4986|       |      if (out && out.svg) { return out.svg; }
 4987|       |      if (typeof svgOut === 'string' && svgOut.length > 0) { return svgOut; }
 4988|       |      throw new Error('Mermaid render returned empty');
 4989|       |    });
 4990|       |  }
 4991|       |  if (typeof renderResult === 'string') { return renderResult; }
 4992|       |  if (renderResult && renderResult.svg) { return renderResult.svg; }
 4993|       |  if (typeof svgOut === 'string' && svgOut.length > 0) { return svgOut; }
 4994|       |  throw new Error('Mermaid render returned empty');
 4995|       |})
 4996|       |"#;
 4997|       |
 4998|       |#[cfg(test)]
 4999|       |mod tests {
 5000|       |    use super::*;
 5001|       |    use std::collections::HashSet;
 5002|       |    use std::sync::{Arc, Mutex, OnceLock};
 5003|       |    use tempfile::tempdir;
 5004|       |
 5005|     44|    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
 5006|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
 5007|     44|        ENV_LOCK
 5008|     44|            .get_or_init(|| Mutex::new(()))
                                          ^1         ^1
 5009|     44|            .lock()
 5010|     44|            .expect("env lock")
 5011|     44|    }
 5012|       |
 5013|      2|    fn restore_env_var(key: &'static str, previous: Option<String>) {
 5014|      2|        if let Some(value) = previous {
                                  ^1
 5015|      1|            std::env::set_var(key, value);
 5016|      1|        } else {
 5017|      1|            std::env::remove_var(key);
 5018|      1|        }
 5019|      2|    }
 5020|       |
 5021|       |    #[cfg(feature = "mermaid-quickjs")]
 5022|      8|    fn test_renderer_with_channels(
 5023|      8|        job_tx: Option<MermaidJobSender>,
 5024|      8|        result_rx: MermaidResultReceiver,
 5025|      8|    ) -> MermaidRenderer {
 5026|      8|        MermaidRenderer {
 5027|      8|            mermaid_textures: RefCell::new(LruCache::new(4)),
 5028|      8|            mermaid_pending: RefCell::new(HashSet::new()),
 5029|      8|            mermaid_frame_pending: Cell::new(false),
 5030|      8|            mermaid_svg_cache: RefCell::new(LruCache::new(4)),
 5031|      8|            mermaid_errors: RefCell::new(LruCache::new(4)),
 5032|      8|            mermaid_texture_errors: RefCell::new(LruCache::new(4)),
 5033|      8|            mermaid_job_tx: job_tx,
 5034|      8|            mermaid_result_rx: result_rx,
 5035|      8|            worker_handles: Vec::new(),
 5036|      8|        }
 5037|      8|    }
 5038|       |
 5039|       |    #[test]
 5040|      1|    fn test_lru_cache_eviction_and_touch() {
 5041|      1|        let mut cache = LruCache::new(2);
 5042|      1|        let key_a = "a".to_string();
 5043|      1|        let key_b = "b".to_string();
 5044|      1|        let key_c = "c".to_string();
 5045|       |
 5046|      1|        cache.insert(key_a.clone(), 1);
 5047|      1|        cache.insert(key_b.clone(), 2);
 5048|      1|        assert_eq!(cache.get(&key_a), Some(1));
 5049|      1|        cache.insert(key_c.clone(), 3);
 5050|      1|        assert!(cache.get(&key_b).is_none());
 5051|      1|        assert_eq!(cache.len(), 2);
 5052|      1|    }
 5053|       |
 5054|       |    #[test]
 5055|      1|    fn test_lru_cache_missing_get_and_empty_order_insert() {
 5056|      1|        let mut cache = LruCache::new(1);
 5057|      1|        assert!(cache.get(&"missing".to_string()).is_none());
 5058|      1|        cache.entries.insert("a".to_string(), 1);
 5059|      1|        cache.order.clear();
 5060|      1|        cache.insert("b".to_string(), 2);
 5061|      1|        assert_eq!(cache.len(), 2);
 5062|      1|    }
 5063|       |
 5064|       |    #[test]
 5065|      1|    fn test_lru_cache_capacity_zero_insert() {
 5066|      1|        let mut cache = LruCache::new(0);
 5067|      1|        cache.insert("a".to_string(), 1);
 5068|      1|        assert_eq!(cache.len(), 1);
 5069|      1|    }
 5070|       |
 5071|       |    #[test]
 5072|      1|    fn test_lru_cache_insert_overwrites_existing_key() {
 5073|      1|        let mut cache = LruCache::new(2);
 5074|      1|        let key = "alpha".to_string();
 5075|      1|        cache.insert(key.clone(), 1);
 5076|      1|        cache.insert(key.clone(), 2);
 5077|      1|        assert_eq!(cache.get(&key), Some(2));
 5078|      1|        assert_eq!(cache.len(), 1);
 5079|      1|    }
 5080|       |
 5081|       |    #[test]
 5082|      1|    fn test_lru_cache_get_missing_does_not_touch_order() {
 5083|      1|        let mut cache = LruCache::new(2);
 5084|      1|        cache.insert("a".to_string(), 1);
 5085|      1|        let before = cache.order.clone();
 5086|      1|        assert!(cache.get(&"missing".to_string()).is_none());
 5087|      1|        assert_eq!(cache.order, before);
 5088|      1|    }
 5089|       |
 5090|       |    #[test]
 5091|      1|    fn test_lru_cache_insert_without_eviction() {
 5092|      1|        let mut cache = LruCache::new(3);
 5093|      1|        cache.insert("a".to_string(), 1);
 5094|      1|        cache.insert("b".to_string(), 2);
 5095|      1|        assert_eq!(cache.len(), 2);
 5096|      1|        assert_eq!(cache.order.len(), 2);
 5097|      1|    }
 5098|       |
 5099|       |    #[test]
 5100|      1|    fn test_lru_cache_touch_if_present_branches() {
 5101|      1|        let mut cache = LruCache::new(2);
 5102|      1|        let key = "alpha".to_string();
 5103|      1|        cache.entries.insert(key.clone(), 1);
 5104|      1|        cache.order.push_back(key.clone());
 5105|      1|        let value = cache.entries.get(&key).cloned();
 5106|      1|        cache.touch_if_present(&value, &key);
 5107|      1|        assert_eq!(cache.order.back(), Some(&key));
 5108|       |
 5109|      1|        let before = cache.order.clone();
 5110|      1|        let missing: Option<i32> = None;
 5111|      1|        cache.touch_if_present(&missing, &"missing".to_string());
 5112|      1|        assert_eq!(cache.order, before);
 5113|      1|    }
 5114|       |
 5115|       |    #[cfg(feature = "mermaid-quickjs")]
 5116|       |    #[test]
 5117|      1|    fn test_lru_cache_touch_if_present_type_variants() {
 5118|      1|        let mut id_cache = LruCache::new(1);
 5119|      1|        id_cache.entries.insert(1u64, "one".to_string());
 5120|      1|        let value = id_cache.entries.get(&1).cloned();
 5121|      1|        id_cache.touch_if_present(&value, &1);
 5122|      1|        let missing: Option<String> = None;
 5123|      1|        id_cache.touch_if_present(&missing, &2);
 5124|       |
 5125|      1|        let mut string_cache = LruCache::new(1);
 5126|      1|        string_cache
 5127|      1|            .entries
 5128|      1|            .insert("a".to_string(), "one".to_string());
 5129|      1|        let value = string_cache.entries.get(&"a".to_string()).cloned();
 5130|      1|        string_cache.touch_if_present(&value, &"a".to_string());
 5131|      1|        let missing: Option<String> = None;
 5132|      1|        string_cache.touch_if_present(&missing, &"b".to_string());
 5133|       |
 5134|      1|        let ctx = egui::Context::default();
 5135|      1|        let tex = ctx.load_texture(
 5136|       |            "mermaid_touch_variant",
 5137|      1|            egui::ColorImage::new([1, 1], Color32::WHITE),
 5138|       |            egui::TextureOptions::LINEAR,
 5139|       |        );
 5140|      1|        let entry = MermaidTextureEntry {
 5141|      1|            texture: tex,
 5142|      1|            size: [1, 1],
 5143|      1|        };
 5144|      1|        let mut texture_cache = LruCache::new(1);
 5145|      1|        texture_cache.entries.insert("t".to_string(), entry.clone());
 5146|      1|        let value = texture_cache.entries.get(&"t".to_string()).cloned();
 5147|      1|        texture_cache.touch_if_present(&value, &"t".to_string());
 5148|      1|        let missing: Option<MermaidTextureEntry> = None;
 5149|      1|        texture_cache.touch_if_present(&missing, &"missing".to_string());
 5150|      1|    }
 5151|       |
 5152|       |    #[test]
 5153|      1|    fn test_lru_cache_evict_oldest_branches() {
 5154|      1|        let mut cache = LruCache::new(1);
 5155|      1|        cache.insert("alpha".to_string(), 1);
 5156|      1|        assert!(cache.evict_oldest());
 5157|      1|        cache.order.clear();
 5158|      1|        assert!(!cache.evict_oldest());
 5159|      1|    }
 5160|       |
 5161|       |    #[cfg(feature = "mermaid-quickjs")]
 5162|       |    #[test]
 5163|      1|    fn test_lru_cache_insert_and_evict_type_variants() {
 5164|      1|        let mut id_cache = LruCache::new(1);
 5165|      1|        id_cache.insert(1u64, "one".to_string());
 5166|      1|        id_cache.insert(2u64, "two".to_string());
 5167|      1|        id_cache.entries.insert(3u64, "three".to_string());
 5168|      1|        id_cache.order.clear();
 5169|      1|        id_cache.insert(4u64, "four".to_string());
 5170|      1|        assert!(id_cache.evict_oldest());
 5171|      1|        id_cache.order.clear();
 5172|      1|        assert!(!id_cache.evict_oldest());
 5173|       |
 5174|      1|        let mut string_cache = LruCache::new(1);
 5175|      1|        string_cache.insert("a".to_string(), "one".to_string());
 5176|      1|        string_cache.insert("b".to_string(), "two".to_string());
 5177|      1|        string_cache
 5178|      1|            .entries
 5179|      1|            .insert("c".to_string(), "three".to_string());
 5180|      1|        string_cache.order.clear();
 5181|      1|        string_cache.insert("d".to_string(), "four".to_string());
 5182|      1|        assert!(string_cache.evict_oldest());
 5183|      1|        string_cache.order.clear();
 5184|      1|        assert!(!string_cache.evict_oldest());
 5185|       |
 5186|      1|        let ctx = egui::Context::default();
 5187|      1|        let tex = ctx.load_texture(
 5188|       |            "mermaid_evict_variant",
 5189|      1|            egui::ColorImage::new([1, 1], Color32::WHITE),
 5190|       |            egui::TextureOptions::LINEAR,
 5191|       |        );
 5192|      1|        let entry = MermaidTextureEntry {
 5193|      1|            texture: tex,
 5194|      1|            size: [1, 1],
 5195|      1|        };
 5196|      1|        let mut texture_cache = LruCache::new(1);
 5197|      1|        texture_cache.insert("a".to_string(), entry.clone());
 5198|      1|        texture_cache.insert("b".to_string(), entry.clone());
 5199|      1|        texture_cache.entries.insert("c".to_string(), entry.clone());
 5200|      1|        texture_cache.order.clear();
 5201|      1|        texture_cache.insert("d".to_string(), entry);
 5202|      1|        assert!(texture_cache.evict_oldest());
 5203|      1|        texture_cache.order.clear();
 5204|      1|        assert!(!texture_cache.evict_oldest());
 5205|      1|    }
 5206|       |
 5207|       |    #[test]
 5208|      1|    fn test_lru_cache_string_string_branches() {
 5209|      1|        let mut cache = LruCache::new(1);
 5210|      1|        assert!(cache.get(&"missing".to_string()).is_none());
 5211|       |
 5212|      1|        cache.insert("a".to_string(), "one".to_string());
 5213|      1|        cache.insert("a".to_string(), "uno".to_string());
 5214|      1|        assert_eq!(cache.get(&"a".to_string()), Some("uno".to_string()));
 5215|       |
 5216|      1|        cache.insert("b".to_string(), "two".to_string());
 5217|      1|        assert!(cache.get(&"a".to_string()).is_none());
 5218|       |
 5219|      1|        cache.entries.insert("c".to_string(), "three".to_string());
 5220|      1|        cache.order.clear();
 5221|      1|        cache.insert("d".to_string(), "four".to_string());
 5222|      1|        assert!(cache.len() >= 1);
 5223|      1|    }
 5224|       |
 5225|       |    #[cfg(feature = "mermaid-quickjs")]
 5226|       |    #[test]
 5227|      1|    fn test_lru_cache_mermaid_type_variants() {
 5228|      1|        let mut string_cache = LruCache::new(2);
 5229|      1|        string_cache.insert(1u64, "one".to_string());
 5230|      1|        string_cache.insert(2u64, "two".to_string());
 5231|      1|        assert_eq!(string_cache.get(&1), Some("one".to_string()));
 5232|      1|        assert!(string_cache.get(&3).is_none());
 5233|      1|        string_cache.insert(1u64, "uno".to_string());
 5234|      1|        string_cache.insert(3u64, "three".to_string());
 5235|       |
 5236|      1|        let ctx = egui::Context::default();
 5237|      1|        let tex = ctx.load_texture(
 5238|       |            "mermaid_cache_test",
 5239|      1|            egui::ColorImage::new([1, 1], Color32::WHITE),
 5240|       |            egui::TextureOptions::LINEAR,
 5241|       |        );
 5242|      1|        let entry = MermaidTextureEntry {
 5243|      1|            texture: tex,
 5244|      1|            size: [1, 1],
 5245|      1|        };
 5246|      1|        let mut texture_cache = LruCache::new(1);
 5247|      1|        assert!(texture_cache.get(&"missing".to_string()).is_none());
 5248|      1|        texture_cache.insert("a".to_string(), entry.clone());
 5249|      1|        assert!(texture_cache.get(&"a".to_string()).is_some());
 5250|      1|        texture_cache.insert("a".to_string(), entry.clone());
 5251|      1|        texture_cache.insert("b".to_string(), entry.clone());
 5252|      1|        texture_cache.entries.insert("c".to_string(), entry.clone());
 5253|      1|        texture_cache.order.clear();
 5254|      1|        texture_cache.insert("d".to_string(), entry);
 5255|      1|    }
 5256|       |
 5257|       |    #[cfg(feature = "mermaid-quickjs")]
 5258|       |    #[test]
 5259|      1|    fn test_mermaid_renderer_cache_branches() {
 5260|      1|        let renderer = MermaidRenderer::new();
 5261|      1|        let ctx = egui::Context::default();
 5262|      1|        let tex = ctx.load_texture(
 5263|       |            "mermaid_renderer_cache",
 5264|      1|            egui::ColorImage::new([1, 1], Color32::WHITE),
 5265|       |            egui::TextureOptions::LINEAR,
 5266|       |        );
 5267|      1|        let entry = MermaidTextureEntry {
 5268|      1|            texture: tex,
 5269|      1|            size: [1, 1],
 5270|      1|        };
 5271|       |
 5272|       |        {
 5273|      1|            let mut cache = renderer.mermaid_textures.borrow_mut();
 5274|      1|            assert!(cache.get(&"miss".to_string()).is_none());
 5275|      1|            cache.insert("hit".to_string(), entry.clone());
 5276|      1|            assert!(cache.get(&"hit".to_string()).is_some());
 5277|      1|            cache.entries.insert("stale".to_string(), entry.clone());
 5278|      1|            cache.order.clear();
 5279|      1|            cache.insert("fresh".to_string(), entry.clone());
 5280|       |        }
 5281|       |
 5282|       |        {
 5283|      1|            let mut cache = renderer.mermaid_svg_cache.borrow_mut();
 5284|      1|            assert!(cache.get(&1).is_none());
 5285|      1|            cache.insert(1, "one".to_string());
 5286|      1|            assert!(cache.get(&1).is_some());
 5287|      1|            cache.entries.insert(2, "two".to_string());
 5288|      1|            cache.order.clear();
 5289|      1|            cache.insert(3, "three".to_string());
 5290|       |        }
 5291|       |
 5292|       |        {
 5293|      1|            let mut cache = renderer.mermaid_errors.borrow_mut();
 5294|      1|            assert!(cache.get(&1).is_none());
 5295|      1|            cache.insert(1, "err".to_string());
 5296|      1|            assert!(cache.get(&1).is_some());
 5297|      1|            cache.entries.insert(2, "err2".to_string());
 5298|      1|            cache.order.clear();
 5299|      1|            cache.insert(3, "err3".to_string());
 5300|       |        }
 5301|       |
 5302|       |        {
 5303|      1|            let mut cache = renderer.mermaid_texture_errors.borrow_mut();
 5304|      1|            assert!(cache.get(&"miss".to_string()).is_none());
 5305|      1|            cache.insert("hit".to_string(), "err".to_string());
 5306|      1|            assert!(cache.get(&"hit".to_string()).is_some());
 5307|      1|            cache
 5308|      1|                .entries
 5309|      1|                .insert("stale".to_string(), "err2".to_string());
 5310|      1|            cache.order.clear();
 5311|      1|            cache.insert("fresh".to_string(), "err3".to_string());
 5312|       |        }
 5313|      1|    }
 5314|       |
 5315|       |    #[test]
 5316|      1|    fn test_mermaid_texture_key_changes_with_scale_and_bg() {
 5317|      1|        let svg_key = 42;
 5318|      1|        let width_bucket = 320;
 5319|      1|        let scale_a = MermaidRenderer::scale_bucket(1.0);
 5320|      1|        let scale_b = MermaidRenderer::scale_bucket(1.2);
 5321|      1|        let bg_a = Some([255, 0, 0, 255]);
 5322|      1|        let bg_b = Some([0, 0, 0, 255]);
 5323|       |
 5324|      1|        let key_a = MermaidRenderer::texture_key(svg_key, width_bucket, scale_a, bg_a);
 5325|      1|        let key_b = MermaidRenderer::texture_key(svg_key, width_bucket, scale_b, bg_a);
 5326|      1|        let key_c = MermaidRenderer::texture_key(svg_key, width_bucket, scale_a, bg_b);
 5327|       |
 5328|      1|        assert_ne!(key_a, key_b);
 5329|      1|        assert_ne!(key_a, key_c);
 5330|      1|    }
 5331|       |
 5332|       |    #[test]
 5333|      1|    fn test_mermaid_width_bucket_rounds_up() {
 5334|      1|        let step = MermaidRenderer::MERMAID_WIDTH_BUCKET_STEP;
 5335|      1|        assert_eq!(MermaidRenderer::width_bucket(1.0), step);
 5336|      1|        assert_eq!(MermaidRenderer::width_bucket(step as f32 + 0.1), step * 2);
 5337|      1|    }
 5338|       |
 5339|       |    #[test]
 5340|      1|    fn test_mermaid_diagram_kind_skips_comments_and_blank() {
 5341|      1|        let code = "\n%% comment\n  \nsequenceDiagram\nAlice->>Bob: Hi";
 5342|      1|        assert_eq!(
 5343|      1|            MermaidRenderer::mermaid_diagram_kind(code),
 5344|      1|            Some("sequencediagram".to_string())
 5345|       |        );
 5346|      1|    }
 5347|       |
 5348|       |    #[test]
 5349|      1|    fn test_mermaid_diagram_kind_returns_none_for_comments_only() {
 5350|      1|        let code = "%% comment\n   \n%% another";
 5351|      1|        assert!(MermaidRenderer::mermaid_diagram_kind(code).is_none());
 5352|      1|    }
 5353|       |
 5354|       |    #[test]
 5355|      1|    fn test_mermaid_renderer_preference_env() {
 5356|      1|        let _lock = env_lock();
 5357|      1|        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
 5358|      1|        let (default_pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
 5359|      1|        assert!(!explicit);
 5360|       |        #[cfg(feature = "mermaid-quickjs")]
 5361|      1|        assert_eq!(default_pref, MermaidRenderPreference::Embedded);
 5362|       |        #[cfg(not(feature = "mermaid-quickjs"))]
 5363|       |        assert_eq!(default_pref, MermaidRenderPreference::Off);
 5364|       |
 5365|       |        {
 5366|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 5367|      1|            let (pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
 5368|      1|            assert!(explicit);
 5369|      1|            assert_eq!(pref, MermaidRenderPreference::Embedded);
 5370|       |        }
 5371|       |        {
 5372|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "off");
 5373|      1|            let (pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
 5374|      1|            assert!(explicit);
 5375|      1|            assert_eq!(pref, MermaidRenderPreference::Off);
 5376|       |        }
 5377|       |        {
 5378|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "bogus");
 5379|      1|            let (pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
 5380|      1|            assert!(!explicit);
 5381|       |            #[cfg(feature = "mermaid-quickjs")]
 5382|      1|            assert_eq!(pref, MermaidRenderPreference::Embedded);
 5383|       |            #[cfg(not(feature = "mermaid-quickjs"))]
 5384|       |            assert_eq!(pref, MermaidRenderPreference::Off);
 5385|       |        }
 5386|      1|    }
 5387|       |
 5388|       |    #[test]
 5389|      1|    fn test_mermaid_security_level_default_and_env() {
 5390|      1|        let _lock = env_lock();
 5391|      1|        std::env::remove_var("MDMDVIEW_MERMAID_SECURITY");
 5392|      1|        assert_eq!(MermaidRenderer::mermaid_security_level(), "strict");
 5393|       |        {
 5394|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_SECURITY", "loose");
 5395|      1|            assert_eq!(MermaidRenderer::mermaid_security_level(), "loose");
 5396|       |        }
 5397|       |        {
 5398|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_SECURITY", "strict");
 5399|      1|            assert_eq!(MermaidRenderer::mermaid_security_level(), "strict");
 5400|       |        }
 5401|      1|    }
 5402|       |
 5403|       |    #[cfg(feature = "mermaid-quickjs")]
 5404|       |    #[test]
 5405|      1|    fn test_mermaid_worker_count_clamps_env() {
 5406|      1|        let _lock = env_lock();
 5407|       |        {
 5408|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "0");
 5409|      1|            assert_eq!(MermaidRenderer::mermaid_worker_count(), 1);
 5410|       |        }
 5411|       |        {
 5412|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "999");
 5413|      1|            assert_eq!(MermaidRenderer::mermaid_worker_count(), 16);
 5414|       |        }
 5415|       |        {
 5416|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "nope");
 5417|      1|            let count = MermaidRenderer::mermaid_worker_count();
 5418|      1|            assert!(count >= 1);
 5419|      1|            assert!(count <= MermaidRenderer::MAX_MERMAID_JOBS.max(1));
 5420|       |        }
 5421|      1|    }
 5422|       |
 5423|       |    #[cfg(feature = "mermaid-quickjs")]
 5424|       |    #[test]
 5425|      1|    fn test_mermaid_timeout_ms_env_clamps() {
 5426|      1|        let _lock = env_lock();
 5427|       |        {
 5428|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_TIMEOUT_MS", "50");
 5429|      1|            assert_eq!(MermaidRenderer::mermaid_timeout_ms(), 100);
 5430|       |        }
 5431|       |        {
 5432|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_TIMEOUT_MS", "250");
 5433|      1|            assert_eq!(MermaidRenderer::mermaid_timeout_ms(), 250);
 5434|       |        }
 5435|       |        {
 5436|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_TIMEOUT_MS", "bad");
 5437|      1|            assert_eq!(MermaidRenderer::mermaid_timeout_ms(), 30_000);
 5438|       |        }
 5439|      1|    }
 5440|       |
 5441|       |    #[cfg(feature = "mermaid-quickjs")]
 5442|       |    #[test]
 5443|      1|    fn test_mermaid_theme_values_font_family_trim() {
 5444|      1|        let _lock = env_lock();
 5445|       |        {
 5446|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_FONT_FAMILY", "  ");
 5447|      1|            let theme = MermaidRenderer::mermaid_theme_values();
 5448|      1|            assert!(theme.font_family.is_none());
 5449|       |        }
 5450|       |        {
 5451|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_FONT_FAMILY", "  Test Font  ");
 5452|      1|            let theme = MermaidRenderer::mermaid_theme_values();
 5453|      1|            assert_eq!(theme.font_family.as_deref(), Some("Test Font"));
 5454|       |        }
 5455|      1|    }
 5456|       |
 5457|       |    #[cfg(feature = "mermaid-quickjs")]
 5458|       |    #[test]
 5459|      1|    fn test_mermaid_site_config_json_includes_security_flags() {
 5460|      1|        let _lock = env_lock();
 5461|       |        {
 5462|      1|            std::env::remove_var("MDMDVIEW_MERMAID_SECURITY");
 5463|      1|            let json = MermaidRenderer::mermaid_site_config_json(1);
 5464|      1|            assert!(json.contains("\"securityLevel\":\"strict\""));
 5465|      1|            assert!(json.contains("\"htmlLabels\":false"));
 5466|      1|            assert!(json.contains("\"flowchart\":{\"htmlLabels\":false}"));
 5467|       |        }
 5468|       |        {
 5469|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_SECURITY", "loose");
 5470|      1|            let json = MermaidRenderer::mermaid_site_config_json(2);
 5471|      1|            assert!(json.contains("\"securityLevel\":\"loose\""));
 5472|      1|            assert!(!json.contains("\"flowchart\":{\"htmlLabels\":false}"));
 5473|       |        }
 5474|      1|    }
 5475|       |
 5476|       |    #[cfg(feature = "mermaid-quickjs")]
 5477|       |    #[test]
 5478|      1|    fn test_mermaid_site_config_json_includes_font_family() {
 5479|      1|        let _lock = env_lock();
 5480|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_FONT_FAMILY", "Test Sans");
 5481|      1|        let json = MermaidRenderer::mermaid_site_config_json(3);
 5482|      1|        assert!(json.contains("\"fontFamily\":\"Test Sans\""));
 5483|      1|    }
 5484|       |
 5485|       |    #[cfg(feature = "mermaid-quickjs")]
 5486|       |    #[test]
 5487|      1|    fn test_json_escape_handles_specials() {
 5488|      1|        let input = "quote\" backslash\\ newline\n tab\t carriage\r";
 5489|      1|        let escaped = MermaidRenderer::json_escape(input);
 5490|      1|        assert!(escaped.contains("\\\""));
 5491|      1|        assert!(escaped.contains("\\\\"));
 5492|      1|        assert!(escaped.contains("\\n"));
 5493|      1|        assert!(escaped.contains("\\t"));
 5494|      1|        assert!(escaped.contains("\\r"));
 5495|      1|    }
 5496|       |
 5497|       |    #[cfg(feature = "mermaid-quickjs")]
 5498|       |    #[test]
 5499|      1|    fn test_mermaid_image_href_resolver_blocks_external() {
 5500|      1|        let resolver = MermaidWorker::image_href_resolver();
 5501|      1|        let options = usvg::Options::default();
 5502|      1|        let resolve_string = &resolver.resolve_string;
 5503|       |
 5504|      1|        assert!(resolve_string("http://example.com/img.png", &options).is_none());
 5505|      1|        assert!(resolve_string("file:///tmp/foo.png", &options).is_none());
 5506|      1|    }
 5507|       |
 5508|       |    #[cfg(feature = "mermaid-quickjs")]
 5509|       |    #[test]
 5510|      1|    fn test_mermaid_embed_bytes_present() {
 5511|      1|        assert!(!super::mermaid_embed::MERMAID_JS.is_empty());
 5512|      1|    }
 5513|       |
 5514|       |    #[cfg(feature = "mermaid-quickjs")]
 5515|       |    #[test]
 5516|      1|    fn test_mermaid_quickjs_render_smoke() {
 5517|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5518|      1|        fontdb.load_system_fonts();
 5519|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5520|      1|        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5521|       |
 5522|      1|        let flow = "graph TD; A-->B;";
 5523|      1|        let seq = "sequenceDiagram\nAlice->>Bob: Hello\nBob-->>Alice: Hi";
 5524|      1|        let class = "classDiagram\nClass01 <|-- Class02\nClass01 : +int id\nClass02 : +String name";
 5525|      1|        let er = "erDiagram\nCUSTOMER ||--o{ ORDER : places\nORDER ||--|{ LINE_ITEM : contains\nCUSTOMER {\n  int id\n  string name\n}\nORDER {\n  int id\n  date created\n}\nLINE_ITEM {\n  int id\n  int qty\n}\n";
 5526|      1|        let gantt = "gantt\ntitle Sample Gantt\ndateFormat  YYYY-MM-DD\nsection A\nTask 1 :a1, 2024-01-01, 5d\nTask 2 :after a1, 3d\nsection B\nTask 3 :b1, 2024-01-06, 4d\n";
 5527|      1|        let viewport_width = 1200;
 5528|      1|        let viewport_height = 900;
 5529|       |
 5530|      1|        let flow_svg = worker
 5531|      1|            .render_svg(
 5532|      1|                MermaidRenderer::hash_str(flow),
 5533|      1|                flow,
 5534|      1|                viewport_width,
 5535|      1|                viewport_height,
 5536|       |            )
 5537|      1|            .expect("flowchart render");
 5538|      1|        let seq_svg = worker
 5539|      1|            .render_svg(
 5540|      1|                MermaidRenderer::hash_str(seq),
 5541|      1|                seq,
 5542|      1|                viewport_width,
 5543|      1|                viewport_height,
 5544|       |            )
 5545|      1|            .expect("sequence render");
 5546|      1|        let class_svg = worker
 5547|      1|            .render_svg(
 5548|      1|                MermaidRenderer::hash_str(class),
 5549|      1|                class,
 5550|      1|                viewport_width,
 5551|      1|                viewport_height,
 5552|       |            )
 5553|      1|            .expect("class render");
 5554|      1|        let er_svg = worker
 5555|      1|            .render_svg(
 5556|      1|                MermaidRenderer::hash_str(er),
 5557|      1|                er,
 5558|      1|                viewport_width,
 5559|      1|                viewport_height,
 5560|       |            )
 5561|      1|            .expect("er render");
 5562|      1|        let gantt_svg = worker
 5563|      1|            .render_svg(
 5564|      1|                MermaidRenderer::hash_str(gantt),
 5565|      1|                gantt,
 5566|      1|                viewport_width,
 5567|      1|                viewport_height,
 5568|       |            )
 5569|      1|            .expect("gantt render");
 5570|       |
 5571|      1|        assert!(flow_svg.contains("<svg"));
 5572|      1|        assert!(seq_svg.contains("<svg"));
 5573|      1|        assert!(class_svg.contains("<svg"));
 5574|      1|        assert!(er_svg.contains("<svg"));
 5575|      1|        assert!(gantt_svg.contains("<svg"));
 5576|       |
 5577|      1|        let width_bucket = MermaidRenderer::width_bucket(600.0);
 5578|      1|        let scale_bucket = MermaidRenderer::scale_bucket(1.0);
 5579|      1|        let (rgba, w, h) = worker
 5580|      1|            .rasterize_svg(&flow_svg, width_bucket, scale_bucket, None)
 5581|      1|            .expect("rasterize svg");
 5582|      1|        assert!(!rgba.is_empty());
 5583|      1|        assert_eq!(rgba.len(), (w as usize) * (h as usize) * 4);
 5584|      1|        assert!(w > 0);
 5585|      1|        assert!(h > 0);
 5586|      1|        assert!(w <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5587|      1|        assert!(h <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5588|      1|    }
 5589|       |
 5590|       |    #[cfg(feature = "mermaid-quickjs")]
 5591|       |    #[test]
 5592|      1|    fn test_mermaid_worker_dom_debug_env() {
 5593|      1|        let _lock = env_lock();
 5594|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_DOM_DEBUG", "1");
 5595|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5596|      1|        fontdb.load_system_fonts();
 5597|      1|        let fontdb = Arc::new(fontdb);
 5598|      1|        let worker = MermaidWorker::new(0, fontdb);
 5599|      1|        assert!(worker.is_ok());
 5600|      1|    }
 5601|       |
 5602|       |    #[cfg(feature = "mermaid-quickjs")]
 5603|       |    #[test]
 5604|      1|    fn test_mermaid_js_empty_override_matches_thread() {
 5605|      1|        let _lock = env_lock();
 5606|      1|        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
 5607|       |        {
 5608|      1|            let _guard = MermaidJsEmptyGuard::set(true);
 5609|      1|            assert!(mermaid_js_empty());
 5610|       |        }
 5611|      1|        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
 5612|      1|    }
 5613|       |
 5614|       |    #[cfg(feature = "mermaid-quickjs")]
 5615|       |    #[test]
 5616|      1|    fn test_mermaid_js_empty_override_mismatch_thread() {
 5617|      1|        let _lock = env_lock();
 5618|      1|        let handle = std::thread::spawn(|| set_mermaid_js_empty_for_test(true));
 5619|      1|        let _ = handle.join();
 5620|      1|        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
 5621|      1|        set_mermaid_js_empty_for_test(false);
 5622|      1|    }
 5623|       |
 5624|       |    #[cfg(feature = "mermaid-quickjs")]
 5625|       |    #[test]
 5626|      1|    fn test_mermaid_js_empty_override_false_clears() {
 5627|      1|        let _lock = env_lock();
 5628|      1|        set_mermaid_js_empty_for_test(true);
 5629|      1|        let previous = set_mermaid_js_empty_for_test(false);
 5630|      1|        assert!(previous.is_some());
 5631|      1|        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
 5632|      1|    }
 5633|       |
 5634|       |    #[cfg(feature = "mermaid-quickjs")]
 5635|       |    #[test]
 5636|      1|    fn test_mermaid_js_empty_override_lock_busy() {
 5637|      1|        let _lock = env_lock();
 5638|      1|        let guard = MERMAID_JS_EMPTY_OVERRIDE.try_lock().expect("override lock");
 5639|      1|        assert_eq!(mermaid_js_empty(), MERMAID_JS_EMPTY);
 5640|      1|        drop(guard);
 5641|      1|    }
 5642|       |
 5643|       |    #[cfg(feature = "mermaid-quickjs")]
 5644|       |    #[test]
 5645|      1|    fn test_mermaid_worker_new_fails_when_js_empty() {
 5646|      1|        let _lock = env_lock();
 5647|      1|        let _guard = MermaidJsEmptyGuard::set(true);
 5648|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5649|      1|        fontdb.load_system_fonts();
 5650|      1|        let err = MermaidWorker::new(0, Arc::new(fontdb))
 5651|      1|            .err()
 5652|      1|            .expect("expected error");
 5653|      1|        assert!(err.contains("No embedded Mermaid JS"));
 5654|      1|    }
 5655|       |
 5656|       |    #[cfg(feature = "mermaid-quickjs")]
 5657|       |    #[test]
 5658|      1|    fn test_measure_text_native_handles_optional_weight() {
 5659|      1|        let _lock = env_lock();
 5660|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5661|      1|        fontdb.load_system_fonts();
 5662|      1|        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5663|      1|        worker.engine.ctx.with(|ctx| {
 5664|      1|            let with_weight: Vec<f64> = ctx
 5665|      1|                .eval("__mdmdview_measure_text_native('abc', 12, 700)")
 5666|      1|                .expect("with weight");
 5667|      1|            let without_weight: Vec<f64> = ctx
 5668|      1|                .eval("__mdmdview_measure_text_native('abc', 12, undefined)")
 5669|      1|                .expect("without weight");
 5670|      1|            assert_eq!(with_weight.len(), 2);
 5671|      1|            assert_eq!(without_weight.len(), 2);
 5672|      1|        });
 5673|      1|    }
 5674|       |
 5675|       |    #[cfg(feature = "mermaid-quickjs")]
 5676|       |    #[test]
 5677|      1|    fn test_map_init_result_variants() {
 5678|      1|        assert!(MermaidWorker::map_init_result(Ok(())).is_ok());
 5679|      1|        let err = MermaidWorker::map_init_result(Err("oops".to_string())).unwrap_err();
 5680|      1|        assert!(err.contains("Mermaid init error: oops"));
 5681|      1|    }
 5682|       |
 5683|       |    #[cfg(feature = "mermaid-quickjs")]
 5684|       |    #[test]
 5685|      1|    fn test_format_render_result_variants() {
 5686|      1|        let ok = MermaidWorker::format_render_result(Ok("<svg></svg>".to_string()), 10, 5)
 5687|      1|            .expect("ok result");
 5688|      1|        assert!(ok.contains("<svg"));
 5689|       |
 5690|      1|        let err = MermaidWorker::format_render_result(Err("boom".to_string()), 10, 5).unwrap_err();
 5691|      1|        assert!(err.contains("Mermaid render error: boom"));
 5692|       |
 5693|      1|        let timeout =
 5694|      1|            MermaidWorker::format_render_result(Err("late".to_string()), 10, 20).unwrap_err();
 5695|      1|        assert_eq!(timeout, "Mermaid render timed out");
 5696|      1|    }
 5697|       |
 5698|       |    #[cfg(feature = "mermaid-quickjs")]
 5699|       |    #[test]
 5700|      1|    fn test_process_job_missing_code_returns_error() {
 5701|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5702|      1|        fontdb.load_system_fonts();
 5703|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5704|      1|        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5705|       |
 5706|      1|        let job = MermaidRequest {
 5707|      1|            svg_key: 1,
 5708|      1|            texture_key: "missing".to_string(),
 5709|      1|            code: None,
 5710|      1|            svg: None,
 5711|      1|            width_bucket: 100,
 5712|      1|            scale_bucket: MermaidRenderer::scale_bucket(1.0),
 5713|      1|            viewport_width: 100,
 5714|      1|            viewport_height: 100,
 5715|      1|            bg: None,
 5716|      1|        };
 5717|       |
 5718|      1|        let result = worker.process_job(job);
 5719|      1|        assert!(result.svg.is_none());
 5720|      1|        assert!(result.rgba.is_none());
 5721|      1|        assert!(result.error.is_some());
 5722|      1|    }
 5723|       |
 5724|       |    #[cfg(feature = "mermaid-quickjs")]
 5725|       |    #[test]
 5726|      1|    fn test_rasterize_svg_invalid_returns_error() {
 5727|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5728|      1|        fontdb.load_system_fonts();
 5729|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5730|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5731|       |
 5732|      1|        let err = worker
 5733|      1|            .rasterize_svg("not svg", 100, MermaidRenderer::scale_bucket(1.0), None)
 5734|      1|            .unwrap_err();
 5735|      1|        assert!(!err.is_empty());
 5736|      1|    }
 5737|       |
 5738|       |    #[cfg(feature = "mermaid-quickjs")]
 5739|       |    #[test]
 5740|      1|    fn test_rasterize_svg_logs_when_env_set() {
 5741|      1|        let _lock = env_lock();
 5742|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_LOG_RASTER", "1");
 5743|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5744|      1|        fontdb.load_system_fonts();
 5745|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5746|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5747|      1|        let svg = r#"<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"></svg>"#;
 5748|      1|        let (data, w, h) = worker
 5749|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5750|      1|            .expect("rasterize svg");
 5751|      1|        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 5752|      1|    }
 5753|       |
 5754|       |    #[cfg(feature = "mermaid-quickjs")]
 5755|       |    #[test]
 5756|      1|    fn test_rasterize_svg_viewbox_filter_rejects_small() {
 5757|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5758|      1|        fontdb.load_system_fonts();
 5759|      1|        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5760|      1|        let svg = r#"<svg width="100" height="100" viewBox="0 0 0 0" xmlns="http://www.w3.org/2000/svg"></svg>"#;
 5761|      1|        let (data, w, h) = worker
 5762|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5763|      1|            .expect("rasterize svg");
 5764|      1|        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 5765|      1|    }
 5766|       |
 5767|       |    #[cfg(feature = "mermaid-quickjs")]
 5768|       |    #[test]
 5769|      1|    fn test_rasterize_svg_skips_resize_when_bbox_exceeds_cap() {
 5770|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5771|      1|        fontdb.load_system_fonts();
 5772|      1|        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5773|      1|        let svg = r#"<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect width="1000" height="1000" fill="red"/></svg>"#;
 5774|      1|        let (_data, w, h) = worker
 5775|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5776|      1|            .expect("rasterize svg");
 5777|      1|        assert_eq!((w, h), (10, 10));
 5778|      1|    }
 5779|       |
 5780|       |    #[cfg(feature = "mermaid-quickjs")]
 5781|       |    #[test]
 5782|      1|    fn test_rasterize_svg_oversize_bbox_translates() {
 5783|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5784|      1|        fontdb.load_system_fonts();
 5785|      1|        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5786|      1|        let svg = r#"<svg width="100" height="50" xmlns="http://www.w3.org/2000/svg"><rect x="-60" y="0" width="200" height="50" fill="red"/></svg>"#;
 5787|      1|        let (_data, w, h) = worker
 5788|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5789|      1|            .expect("rasterize svg");
 5790|      1|        assert!(w > 100);
 5791|      1|        assert!(h >= 50);
 5792|      1|    }
 5793|       |
 5794|       |    #[cfg(feature = "mermaid-quickjs")]
 5795|       |    #[test]
 5796|      1|    fn test_rasterize_svg_oversize_bbox_translate_y_only() {
 5797|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5798|      1|        fontdb.load_system_fonts();
 5799|      1|        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5800|      1|        let svg = r#"<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="0" width="100" height="200" fill="red"/></svg>"#;
 5801|      1|        let (_data, w, h) = worker
 5802|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5803|      1|            .expect("rasterize svg");
 5804|      1|        assert!(w >= 108);
 5805|      1|        assert!(h >= 200);
 5806|      1|    }
 5807|       |
 5808|       |    #[cfg(feature = "mermaid-quickjs")]
 5809|       |    #[test]
 5810|      1|    fn test_rasterize_svg_clamps_large_width() {
 5811|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5812|      1|        fontdb.load_system_fonts();
 5813|      1|        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5814|      1|        let svg = r#"<svg width="4100" height="10" xmlns="http://www.w3.org/2000/svg"><rect width="4100" height="10" fill="red"/></svg>"#;
 5815|      1|        let (_data, w, h) = worker
 5816|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5817|      1|            .expect("rasterize svg");
 5818|      1|        assert!(w <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5819|      1|        assert!(h > 0);
 5820|      1|    }
 5821|       |
 5822|       |    #[cfg(feature = "mermaid-quickjs")]
 5823|       |    #[test]
 5824|      1|    fn test_rasterize_svg_clamps_large_height() {
 5825|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5826|      1|        fontdb.load_system_fonts();
 5827|      1|        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5828|      1|        let svg = r#"<svg width="10" height="10000" xmlns="http://www.w3.org/2000/svg"><rect width="10" height="10000" fill="red"/></svg>"#;
 5829|      1|        let (_data, w, h) = worker
 5830|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5831|      1|            .expect("rasterize svg");
 5832|      1|        assert!(w > 0);
 5833|      1|        assert!(h <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5834|      1|    }
 5835|       |
 5836|       |    #[cfg(feature = "mermaid-quickjs")]
 5837|       |    #[test]
 5838|      1|    fn test_rasterize_svg_tiny_bbox_keeps_dimensions() {
 5839|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5840|      1|        fontdb.load_system_fonts();
 5841|      1|        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5842|      1|        let svg = r#"<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect width="0.1" height="0.1" fill="red"/></svg>"#;
 5843|      1|        let (_data, w, h) = worker
 5844|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5845|      1|            .expect("rasterize svg");
 5846|      1|        assert_eq!((w, h), (10, 10));
 5847|      1|    }
 5848|       |
 5849|       |    #[cfg(feature = "mermaid-quickjs")]
 5850|       |    #[test]
 5851|      1|    fn test_rasterize_svg_raw_tree_parse_failure_fallback() {
 5852|      1|        let _lock = env_lock();
 5853|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5854|      1|        fontdb.load_system_fonts();
 5855|      1|        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5856|      1|        force_raw_tree_parse_fail_for_test();
 5857|      1|        let svg = r#"<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><rect width="20" height="20" fill="red"/></svg>"#;
 5858|      1|        let (data, w, h) = worker
 5859|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5860|      1|            .expect("rasterize svg");
 5861|      1|        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 5862|      1|        assert!(w > 0);
 5863|      1|        assert!(h > 0);
 5864|      1|    }
 5865|       |
 5866|       |    #[cfg(feature = "mermaid-quickjs")]
 5867|       |    #[test]
 5868|      1|    fn test_bbox_validation_helpers() {
 5869|      1|        assert!(MermaidWorker::bbox_is_valid(10.0, 10.0, 0.0, 0.0));
 5870|      1|        assert!(!MermaidWorker::bbox_is_valid(0.0, 10.0, 0.0, 0.0));
 5871|      1|        assert!(!MermaidWorker::bbox_is_valid(10.0, 0.0, 0.0, 0.0));
 5872|      1|        assert!(!MermaidWorker::bbox_is_valid(f32::NAN, 10.0, 0.0, 0.0));
 5873|      1|        assert!(!MermaidWorker::bbox_is_valid(10.0, f32::INFINITY, 0.0, 0.0));
 5874|      1|        assert!(!MermaidWorker::bbox_is_valid(10.0, 10.0, f32::NAN, 0.0));
 5875|      1|        assert!(!MermaidWorker::bbox_is_valid(
 5876|      1|            10.0,
 5877|      1|            10.0,
 5878|      1|            0.0,
 5879|      1|            f32::INFINITY
 5880|      1|        ));
 5881|      1|    }
 5882|       |
 5883|       |    #[cfg(feature = "mermaid-quickjs")]
 5884|       |    #[test]
 5885|      1|    fn test_should_resize_bbox_variants() {
 5886|      1|        assert!(MermaidWorker::should_resize_bbox(
 5887|       |            true, true, 1.0, 1.0, 10.0, 10.0
 5888|       |        ));
 5889|      1|        assert!(!MermaidWorker::should_resize_bbox(
 5890|      1|            true, false, 50.0, 50.0, 10.0, 10.0
 5891|      1|        ));
 5892|      1|        assert!(MermaidWorker::should_resize_bbox(
 5893|       |            false, true, 20.0, 5.0, 10.0, 10.0
 5894|       |        ));
 5895|      1|        assert!(!MermaidWorker::should_resize_bbox(
 5896|      1|            false, true, 11.0, 11.0, 10.0, 10.0
 5897|      1|        ));
 5898|      1|        assert!(!MermaidWorker::should_resize_bbox(
 5899|      1|            false, false, 50.0, 50.0, 10.0, 10.0
 5900|      1|        ));
 5901|      1|    }
 5902|       |
 5903|       |    #[cfg(feature = "mermaid-quickjs")]
 5904|       |    #[test]
 5905|      1|    fn test_process_job_svg_input_rasterize_error() {
 5906|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5907|      1|        fontdb.load_system_fonts();
 5908|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5909|      1|        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5910|       |
 5911|      1|        let job = MermaidRequest {
 5912|      1|            svg_key: 2,
 5913|      1|            texture_key: "bad-svg".to_string(),
 5914|      1|            code: Some("graph TD; A-->B;".to_string()),
 5915|      1|            svg: Some("not svg".to_string()),
 5916|      1|            width_bucket: 100,
 5917|      1|            scale_bucket: MermaidRenderer::scale_bucket(1.0),
 5918|      1|            viewport_width: 100,
 5919|      1|            viewport_height: 100,
 5920|      1|            bg: None,
 5921|      1|        };
 5922|       |
 5923|      1|        let result = worker.process_job(job);
 5924|      1|        assert!(result.svg.is_some());
 5925|      1|        assert!(result.rgba.is_none());
 5926|      1|        assert!(result.error.is_some());
 5927|      1|    }
 5928|       |
 5929|       |    #[cfg(feature = "mermaid-quickjs")]
 5930|       |    #[test]
 5931|      1|    fn test_rasterize_svg_adjusts_for_oversized_bbox() {
 5932|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5933|      1|        fontdb.load_system_fonts();
 5934|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5935|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5936|       |
 5937|      1|        let svg = r#"<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
 5938|      1|<rect x="-50" y="-50" width="200" height="200" fill="red"/>
 5939|      1|</svg>"#;
 5940|      1|        let (data, w, h) = worker
 5941|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5942|      1|            .expect("rasterize svg");
 5943|      1|        assert_eq!((w, h), (208, 208));
 5944|      1|        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 5945|      1|    }
 5946|       |
 5947|       |    #[cfg(feature = "mermaid-quickjs")]
 5948|       |    #[test]
 5949|      1|    fn test_rasterize_svg_viewbox_filter_skips_small_dims() {
 5950|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5951|      1|        fontdb.load_system_fonts();
 5952|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5953|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5954|       |
 5955|      1|        let svg = r#"<svg width="10" height="12" viewBox="0 0 0.1 0.1" xmlns="http://www.w3.org/2000/svg">
 5956|      1| <rect width="0.1" height="0.1" fill="red"/>
 5957|      1| </svg>"#;
 5958|      1|        let (_data, w, h) = worker
 5959|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5960|      1|            .expect("rasterize svg");
 5961|      1|        assert_eq!((w, h), (10, 12));
 5962|      1|    }
 5963|       |
 5964|       |    #[cfg(feature = "mermaid-quickjs")]
 5965|       |    #[test]
 5966|      1|    fn test_rasterize_svg_keeps_dimensions_for_small_bbox() {
 5967|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5968|      1|        fontdb.load_system_fonts();
 5969|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5970|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5971|       |
 5972|      1|        let svg = r#"<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
 5973|      1| <rect x="10" y="10" width="20" height="20" fill="red"/>
 5974|      1| </svg>"#;
 5975|      1|        let (_data, w, h) = worker
 5976|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5977|      1|            .expect("rasterize svg");
 5978|      1|        assert_eq!((w, h), (100, 100));
 5979|      1|    }
 5980|       |
 5981|       |    #[cfg(feature = "mermaid-quickjs")]
 5982|       |    #[test]
 5983|      1|    fn test_rasterize_svg_clamps_to_max_side() {
 5984|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5985|      1|        fontdb.load_system_fonts();
 5986|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5987|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5988|       |
 5989|      1|        let svg = r#"<svg width="10000" height="10000" viewBox="0 0 10000 10000" xmlns="http://www.w3.org/2000/svg">
 5990|      1|<rect width="10000" height="10000" fill="blue"/>
 5991|      1|</svg>"#;
 5992|      1|        let (_data, w, h) = worker
 5993|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5994|      1|            .expect("rasterize svg");
 5995|      1|        assert!(w <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5996|      1|        assert!(h <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5997|      1|    }
 5998|       |
 5999|       |    #[cfg(feature = "mermaid-quickjs")]
 6000|       |    #[test]
 6001|      1|    fn test_rasterize_svg_applies_background_fill() {
 6002|      1|        let mut fontdb = usvg::fontdb::Database::new();
 6003|      1|        fontdb.load_system_fonts();
 6004|      1|        let fontdb = std::sync::Arc::new(fontdb);
 6005|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 6006|       |
 6007|      1|        let svg = r#"<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"></svg>"#;
 6008|      1|        let bg = Some([10, 20, 30, 200]);
 6009|      1|        let (data, w, h) = worker
 6010|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), bg)
 6011|      1|            .expect("rasterize svg");
 6012|      1|        assert_eq!((w, h), (4, 4));
 6013|      1|        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 6014|      1|        let alpha = 200.0_f32 / 255.0;
 6015|      1|        let expected_r = (10.0_f32 * alpha).round() as u8;
 6016|      1|        let expected_g = (20.0_f32 * alpha).round() as u8;
 6017|      1|        let expected_b = (30.0_f32 * alpha).round() as u8;
 6018|      1|        assert_eq!(data[0], expected_r);
 6019|      1|        assert_eq!(data[1], expected_g);
 6020|      1|        assert_eq!(data[2], expected_b);
 6021|      1|        assert_eq!(data[3], 200);
 6022|      1|    }
 6023|       |
 6024|       |    #[cfg(feature = "mermaid-quickjs")]
 6025|       |    #[test]
 6026|      1|    fn test_process_job_applies_svg_fixups() {
 6027|      1|        let mut fontdb = usvg::fontdb::Database::new();
 6028|      1|        fontdb.load_system_fonts();
 6029|      1|        let fontdb = std::sync::Arc::new(fontdb);
 6030|      1|        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");
 6031|       |
 6032|      1|        let svg = r#"<svg width="120" height="120" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
 6033|      1|<switch>
 6034|      1|  <foreignObject><div>Plan</div></foreignObject>
 6035|      1|  <text class="journey-section section-type-0" x="10">Plan</text>
 6036|      1|</switch>
 6037|      1|<g id="state-root_end-0">
 6038|      1|  <circle class="state-end" r="5" width="10" height="10"></circle>
 6039|      1|  <circle class="state-start" r="7" width="14" height="14"></circle>
 6040|      1|</g>
 6041|      1|<rect class="er attributeBoxOdd"></rect>
 6042|      1|</svg>"#;
 6043|       |
 6044|      1|        let job = MermaidRequest {
 6045|      1|            svg_key: 4,
 6046|      1|            texture_key: "fixups".to_string(),
 6047|      1|            code: None,
 6048|      1|            svg: Some(svg.to_string()),
 6049|      1|            width_bucket: 0,
 6050|      1|            scale_bucket: MermaidRenderer::scale_bucket(1.0),
 6051|      1|            viewport_width: 120,
 6052|      1|            viewport_height: 120,
 6053|      1|            bg: None,
 6054|      1|        };
 6055|       |
 6056|      1|        let result = worker.process_job(job);
 6057|      1|        let rendered = result.svg.expect("svg output");
 6058|      1|        assert!(!rendered.contains("<switch"));
 6059|      1|        assert!(rendered.contains("fill:"));
 6060|      1|        assert!(rendered.contains("end-state-inner"));
 6061|      1|        assert!(rendered.contains("attributeBoxOdd"));
 6062|      1|    }
 6063|       |
 6064|       |    #[cfg(feature = "mermaid-quickjs")]
 6065|       |    #[test]
 6066|      1|    fn test_mermaid_dump_helpers_sanitize_labels() {
 6067|      1|        let _lock = env_lock();
 6068|      1|        let dir = tempdir().expect("temp dir");
 6069|      1|        let _guard = EnvGuard::set(
 6070|       |            "MDMDVIEW_MERMAID_DUMP_DIR",
 6071|      1|            dir.path().to_string_lossy().as_ref(),
 6072|       |        );
 6073|      1|        MermaidWorker::maybe_dump_svg(10, Some("ok-label 123"), "<svg></svg>");
 6074|      1|        MermaidWorker::maybe_dump_error(11, Some("::bad label::"), "boom");
 6075|      1|        MermaidWorker::maybe_dump_error(12, Some("good_label"), "ok");
 6076|      1|        MermaidWorker::maybe_dump_svg(13, Some("\nrest"), "<svg></svg>");
 6077|      1|        MermaidWorker::maybe_dump_error(14, Some("dash-label"), "dash");
 6078|      1|        MermaidWorker::maybe_dump_error(14, Some("abcdefghijklmnopqrstuvwxyz0123456789"), "long");
 6079|      1|        MermaidWorker::maybe_dump_svg(
 6080|       |            16,
 6081|      1|            Some("abcdefghijklmnopqrstuvwxyz0123456789"),
 6082|      1|            "<svg></svg>",
 6083|       |        );
 6084|      1|        MermaidWorker::maybe_dump_svg(16, Some("under_score"), "<svg></svg>");
 6085|      1|        MermaidWorker::maybe_dump_error(15, None, "no code");
 6086|      1|        MermaidWorker::maybe_dump_svg(17, None, "<svg></svg>");
 6087|      1|        MermaidWorker::maybe_dump_error(18, Some(""), "empty");
 6088|      1|        MermaidWorker::maybe_dump_svg(19, Some(""), "<svg></svg>");
 6089|      1|        MermaidWorker::maybe_dump_error(20, Some("\nrest"), "empty-label");
 6090|       |
 6091|      1|        let entries: Vec<_> = std::fs::read_dir(dir.path())
 6092|      1|            .expect("read dir")
 6093|     13|            .filter_map(|entry| entry.ok())
                           ^1
 6094|      1|            .collect();
 6095|      1|        assert!(entries
 6096|      1|            .iter()
 6097|      1|            .any(|entry| entry.path().extension() == Some("svg".as_ref())));
 6098|      1|        assert!(entries
 6099|      1|            .iter()
 6100|      2|            .any(|entry| entry.path().extension() == Some("txt".as_ref())));
                           ^1
 6101|      1|    }
 6102|       |
 6103|       |    #[cfg(feature = "mermaid-quickjs")]
 6104|       |    #[test]
 6105|      1|    fn test_mermaid_dump_helpers_empty_dir_env_noop() {
 6106|      1|        let _lock = env_lock();
 6107|      1|        let dir = tempdir().expect("temp dir");
 6108|      1|        let seed_path = dir.path().join("seed.txt");
 6109|      1|        std::fs::write(&seed_path, "seed").expect("seed write");
 6110|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_DUMP_DIR", "   ");
 6111|      1|        MermaidWorker::maybe_dump_svg(20, Some("label"), "<svg></svg>");
 6112|      1|        MermaidWorker::maybe_dump_error(21, Some("label"), "err");
 6113|      1|        let entries: Vec<_> = std::fs::read_dir(dir.path())
 6114|      1|            .expect("read dir")
 6115|      1|            .filter_map(|entry| entry.ok())
 6116|      1|            .collect();
 6117|      1|        assert_eq!(entries.len(), 1);
 6118|      1|        assert_eq!(entries[0].path(), seed_path);
 6119|      1|    }
 6120|       |
 6121|       |    #[cfg(feature = "mermaid-quickjs")]
 6122|       |    #[test]
 6123|      1|    fn test_mermaid_dump_helpers_invalid_dir_noop() {
 6124|      1|        let _lock = env_lock();
 6125|      1|        let dir = tempdir().expect("temp dir");
 6126|      1|        let file_path = dir.path().join("not_a_dir.txt");
 6127|      1|        std::fs::write(&file_path, "data").expect("write file");
 6128|      1|        let _guard = EnvGuard::set(
 6129|       |            "MDMDVIEW_MERMAID_DUMP_DIR",
 6130|      1|            file_path.to_string_lossy().as_ref(),
 6131|       |        );
 6132|      1|        MermaidWorker::maybe_dump_svg(22, Some("label"), "<svg></svg>");
 6133|      1|        MermaidWorker::maybe_dump_error(23, Some("label"), "err");
 6134|      1|        let entries: Vec<_> = std::fs::read_dir(dir.path())
 6135|      1|            .expect("read dir")
 6136|      1|            .filter_map(|entry| entry.ok())
 6137|      1|            .collect();
 6138|      1|        assert_eq!(entries.len(), 1);
 6139|      1|        assert!(entries[0].path().ends_with("not_a_dir.txt"));
 6140|      1|    }
 6141|       |
 6142|       |    #[cfg(feature = "mermaid-quickjs")]
 6143|       |    #[test]
 6144|      1|    fn test_poll_mermaid_results_handles_variants() {
 6145|      1|        let (result_tx, result_rx) = bounded(10);
 6146|      1|        let renderer = MermaidRenderer {
 6147|      1|            mermaid_textures: RefCell::new(LruCache::new(4)),
 6148|      1|            mermaid_pending: RefCell::new(std::collections::HashSet::new()),
 6149|      1|            mermaid_frame_pending: std::cell::Cell::new(false),
 6150|      1|            mermaid_svg_cache: RefCell::new(LruCache::new(4)),
 6151|      1|            mermaid_errors: RefCell::new(LruCache::new(4)),
 6152|      1|            mermaid_texture_errors: RefCell::new(LruCache::new(4)),
 6153|      1|            mermaid_job_tx: None,
 6154|      1|            mermaid_result_rx: result_rx,
 6155|      1|            worker_handles: Vec::new(),
 6156|      1|        };
 6157|      1|        let ctx = egui::Context::default();
 6158|       |
 6159|      1|        renderer
 6160|      1|            .mermaid_pending
 6161|      1|            .borrow_mut()
 6162|      1|            .insert("k1".to_string());
 6163|      1|        result_tx
 6164|      1|            .send(MermaidResult {
 6165|      1|                svg_key: 1,
 6166|      1|                texture_key: "k1".to_string(),
 6167|      1|                svg: Some("<svg width=\"1\" height=\"1\"></svg>".to_string()),
 6168|      1|                rgba: None,
 6169|      1|                size: None,
 6170|      1|                error: None,
 6171|      1|            })
 6172|      1|            .expect("send svg");
 6173|      1|        assert!(renderer.poll_mermaid_results(&ctx));
 6174|      1|        assert!(renderer.mermaid_svg_cache.borrow_mut().get(&1).is_some());
 6175|       |
 6176|      1|        renderer
 6177|      1|            .mermaid_pending
 6178|      1|            .borrow_mut()
 6179|      1|            .insert("k2".to_string());
 6180|      1|        result_tx
 6181|      1|            .send(MermaidResult {
 6182|      1|                svg_key: 2,
 6183|      1|                texture_key: "k2".to_string(),
 6184|      1|                svg: None,
 6185|      1|                rgba: Some(vec![0, 0, 0, 0]),
 6186|      1|                size: None,
 6187|      1|                error: None,
 6188|      1|            })
 6189|      1|            .expect("send rgba missing size");
 6190|      1|        renderer.poll_mermaid_results(&ctx);
 6191|      1|        assert!(renderer
 6192|      1|            .mermaid_texture_errors
 6193|      1|            .borrow_mut()
 6194|      1|            .get(&"k2".to_string())
 6195|      1|            .is_some());
 6196|       |
 6197|      1|        renderer
 6198|      1|            .mermaid_pending
 6199|      1|            .borrow_mut()
 6200|      1|            .insert("k3".to_string());
 6201|      1|        result_tx
 6202|      1|            .send(MermaidResult {
 6203|      1|                svg_key: 3,
 6204|      1|                texture_key: "k3".to_string(),
 6205|      1|                svg: None,
 6206|      1|                rgba: None,
 6207|      1|                size: None,
 6208|      1|                error: Some("boom".to_string()),
 6209|      1|            })
 6210|      1|            .expect("send error");
 6211|      1|        renderer.poll_mermaid_results(&ctx);
 6212|      1|        assert!(renderer.mermaid_errors.borrow_mut().get(&3).is_some());
 6213|       |
 6214|      1|        renderer
 6215|      1|            .mermaid_pending
 6216|      1|            .borrow_mut()
 6217|      1|            .insert("k4".to_string());
 6218|      1|        result_tx
 6219|      1|            .send(MermaidResult {
 6220|      1|                svg_key: 4,
 6221|      1|                texture_key: "k4".to_string(),
 6222|      1|                svg: Some("<svg width=\"1\" height=\"1\"></svg>".to_string()),
 6223|      1|                rgba: None,
 6224|      1|                size: None,
 6225|      1|                error: Some("oops".to_string()),
 6226|      1|            })
 6227|      1|            .expect("send texture error");
 6228|      1|        renderer.poll_mermaid_results(&ctx);
 6229|      1|        assert!(renderer
 6230|      1|            .mermaid_texture_errors
 6231|      1|            .borrow_mut()
 6232|      1|            .get(&"k4".to_string())
 6233|      1|            .is_some());
 6234|       |
 6235|      1|        renderer
 6236|      1|            .mermaid_pending
 6237|      1|            .borrow_mut()
 6238|      1|            .insert("k5".to_string());
 6239|      1|        result_tx
 6240|      1|            .send(MermaidResult {
 6241|      1|                svg_key: 5,
 6242|      1|                texture_key: "k5".to_string(),
 6243|      1|                svg: None,
 6244|      1|                rgba: Some(vec![255, 255, 255, 255]),
 6245|      1|                size: Some((1, 1)),
 6246|      1|                error: None,
 6247|      1|            })
 6248|      1|            .expect("send rgba with size");
 6249|      1|        renderer.poll_mermaid_results(&ctx);
 6250|      1|        assert!(renderer
 6251|      1|            .mermaid_textures
 6252|      1|            .borrow_mut()
 6253|      1|            .get(&"k5".to_string())
 6254|      1|            .is_some());
 6255|      1|    }
 6256|       |
 6257|       |    #[cfg(feature = "mermaid-quickjs")]
 6258|       |    #[test]
 6259|      1|    fn test_format_js_error_variants() {
 6260|      1|        let rt = rquickjs::Runtime::new().expect("runtime");
 6261|      1|        let ctx = rquickjs::Context::full(&rt).expect("context");
 6262|      1|        ctx.with(|ctx| {
 6263|      1|            let err = ctx.eval::<(), _>("throw new Error('boom')").unwrap_err();
 6264|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6265|      1|            assert!(msg.contains("boom"));
 6266|       |
 6267|      1|            let err = ctx
 6268|      1|                .eval::<(), _>("var e = new Error('match'); e.stack = 'match\\nstack'; throw e;")
 6269|      1|                .unwrap_err();
 6270|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6271|      1|            assert!(msg.contains("match"));
 6272|       |
 6273|      1|            let err = ctx
 6274|      1|                .eval::<(), _>("var e = new Error('note'); e.stack = 'stack only'; throw e;")
 6275|      1|                .unwrap_err();
 6276|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6277|      1|            assert!(!msg.is_empty());
 6278|       |
 6279|      1|            let err = ctx
 6280|      1|                .eval::<(), _>("var e = new Error('blank'); e.stack = ' '; throw e;")
 6281|      1|                .unwrap_err();
 6282|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6283|      1|            assert!(msg.contains("blank"));
 6284|       |
 6285|      1|            let err = ctx
 6286|      1|                .eval::<(), _>("throw ({ stack: 'stack-only-obj' })")
 6287|      1|                .unwrap_err();
 6288|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6289|      1|            assert!(!msg.is_empty());
 6290|       |
 6291|      1|            let err = ctx
 6292|      1|                .eval::<(), _>("throw ({ message: 'message-only-obj' })")
 6293|      1|                .unwrap_err();
 6294|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6295|      1|            assert!(!msg.is_empty());
 6296|       |
 6297|      1|            let err = ctx
 6298|      1|                .eval::<(), _>("var e = new Error(''); e.message = undefined; e.stack = 'stack-only'; throw e;")
 6299|      1|                .unwrap_err();
 6300|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6301|      1|            assert!(msg.contains("stack-only"));
 6302|       |
 6303|      1|            let err = ctx
 6304|      1|                .eval::<(), _>("var e = new Error('solo'); delete e.stack; throw e;")
 6305|      1|                .unwrap_err();
 6306|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6307|      1|            assert!(msg.contains("solo"));
 6308|       |
 6309|      1|            let err = ctx
 6310|      1|                .eval::<(), _>("var e = new Error('solo2'); e.stack = undefined; throw e;")
 6311|      1|                .unwrap_err();
 6312|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6313|      1|            assert!(msg.contains("solo2"));
 6314|       |
 6315|      1|            let err = ctx
 6316|      1|                .eval::<(), _>("var e = new Error('zap'); e.stack = ''; throw e;")
 6317|      1|                .unwrap_err();
 6318|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6319|      1|            assert!(msg.contains("zap"));
 6320|       |
 6321|      1|            let err = ctx
 6322|      1|                .eval::<(), _>("var e = new Error(''); e.message = ''; e.stack = ''; throw e;")
 6323|      1|                .unwrap_err();
 6324|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6325|      1|            assert!(!msg.is_empty());
 6326|       |
 6327|      1|            let err = ctx.eval::<(), _>("throw 'stringy'").unwrap_err();
 6328|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6329|      1|            assert_eq!(msg, "stringy");
 6330|       |
 6331|      1|            let err = ctx.eval::<(), _>("throw 42").unwrap_err();
 6332|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6333|      1|            assert_eq!(msg, "42");
 6334|       |
 6335|      1|            let err = ctx.eval::<(), _>("throw 3.5").unwrap_err();
 6336|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6337|      1|            assert!(msg.contains("3.5"));
 6338|       |
 6339|      1|            let err = ctx.eval::<(), _>("throw true").unwrap_err();
 6340|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6341|      1|            assert_eq!(msg, "true");
 6342|       |
 6343|      1|            let msg = MermaidWorker::format_js_error(&ctx, rquickjs::Error::Unknown);
 6344|      1|            assert!(!msg.is_empty());
 6345|       |
 6346|      1|            let err = ctx.eval::<(), _>("throw ({})").unwrap_err();
 6347|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 6348|      1|            assert!(!msg.is_empty());
 6349|      1|        });
 6350|      1|    }
 6351|       |
 6352|       |    struct EnvGuard {
 6353|       |        key: &'static str,
 6354|       |        original: Option<String>,
 6355|       |    }
 6356|       |
 6357|       |    impl EnvGuard {
 6358|     48|        fn set(key: &'static str, value: &str) -> Self {
 6359|     48|            let original = std::env::var(key).ok();
 6360|     48|            std::env::set_var(key, value);
 6361|     48|            Self { key, original }
 6362|     48|        }
 6363|       |    }
 6364|       |
 6365|       |    impl Drop for EnvGuard {
 6366|     48|        fn drop(&mut self) {
 6367|     48|            if let Some(value) = &self.original {
                                      ^2
 6368|      2|                std::env::set_var(self.key, value);
 6369|     46|            } else {
 6370|     46|                std::env::remove_var(self.key);
 6371|     46|            }
 6372|     48|        }
 6373|       |    }
 6374|       |
 6375|       |    #[cfg(feature = "mermaid-quickjs")]
 6376|       |    struct MermaidJsEmptyGuard {
 6377|       |        previous: Option<std::thread::ThreadId>,
 6378|       |    }
 6379|       |
 6380|       |    #[cfg(feature = "mermaid-quickjs")]
 6381|       |    impl MermaidJsEmptyGuard {
 6382|      3|        fn set(value: bool) -> Self {
 6383|      3|            let previous = set_mermaid_js_empty_for_test(value);
 6384|      3|            Self { previous }
 6385|      3|        }
 6386|       |    }
 6387|       |
 6388|       |    #[cfg(feature = "mermaid-quickjs")]
 6389|       |    impl Drop for MermaidJsEmptyGuard {
 6390|      3|        fn drop(&mut self) {
 6391|      3|            let mut guard = MERMAID_JS_EMPTY_OVERRIDE
 6392|      3|                .lock()
 6393|      3|                .expect("mermaid js override lock");
 6394|      3|            *guard = self.previous.clone();
 6395|      3|        }
 6396|       |    }
 6397|       |
 6398|       |    #[test]
 6399|      1|    fn test_parse_hex_color_and_mermaid_bg_fill() {
 6400|      1|        let _lock = env_lock();
 6401|      1|        assert_eq!(
 6402|      1|            MermaidRenderer::parse_hex_color("#ff00ff"),
 6403|       |            Some([255, 0, 255, 255])
 6404|       |        );
 6405|      1|        assert_eq!(
 6406|      1|            MermaidRenderer::parse_hex_color("11223344"),
 6407|       |            Some([17, 34, 51, 68])
 6408|       |        );
 6409|      1|        assert!(MermaidRenderer::parse_hex_color("bad").is_none());
 6410|       |
 6411|       |        {
 6412|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG_COLOR", "#010203");
 6413|      1|            assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([1, 2, 3, 255]));
 6414|       |        }
 6415|       |
 6416|       |        {
 6417|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "transparent");
 6418|      1|            assert_eq!(MermaidRenderer::mermaid_bg_fill(), None);
 6419|       |        }
 6420|       |
 6421|       |        {
 6422|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "dark");
 6423|      1|            assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([20, 20, 20, 255]));
 6424|       |        }
 6425|      1|    }
 6426|       |
 6427|       |    #[test]
 6428|      1|    fn test_env_guard_restores_original_value() {
 6429|      1|        let _lock = env_lock();
 6430|      1|        std::env::set_var("MDMDVIEW_MERMAID_PATCH_DEBUG", "before");
 6431|       |        {
 6432|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "after");
 6433|      1|            assert_eq!(
 6434|      1|                std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG")
 6435|      1|                    .ok()
 6436|      1|                    .as_deref(),
 6437|       |                Some("after")
 6438|       |            );
 6439|       |        }
 6440|      1|        assert_eq!(
 6441|      1|            std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG")
 6442|      1|                .ok()
 6443|      1|                .as_deref(),
 6444|       |            Some("before")
 6445|       |        );
 6446|      1|        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
 6447|      1|    }
 6448|       |
 6449|       |    #[test]
 6450|      1|    fn test_mermaid_bg_fill_invalid_color_falls_back() {
 6451|      1|        let _lock = env_lock();
 6452|      1|        let _guard_color = EnvGuard::set("MDMDVIEW_MERMAID_BG_COLOR", "bad");
 6453|      1|        let _guard_mode = EnvGuard::set("MDMDVIEW_MERMAID_BG", "dark");
 6454|      1|        assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([20, 20, 20, 255]));
 6455|      1|    }
 6456|       |
 6457|       |    #[test]
 6458|      1|    fn test_mermaid_bg_fill_invalid_theme_color_uses_default() {
 6459|      1|        let _lock = env_lock();
 6460|      1|        let _guard_mode = EnvGuard::set("MDMDVIEW_MERMAID_BG", "theme");
 6461|      1|        let _guard_bkg = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "bad");
 6462|      1|        assert_eq!(
 6463|      1|            MermaidRenderer::mermaid_bg_fill(),
 6464|       |            Some([255, 248, 219, 255])
 6465|       |        );
 6466|      1|    }
 6467|       |
 6468|       |    #[test]
 6469|      1|    fn test_mermaid_bg_key_and_scale_bucket() {
 6470|      1|        assert_eq!(MermaidRenderer::mermaid_bg_key(None), "none");
 6471|      1|        assert_eq!(
 6472|      1|            MermaidRenderer::mermaid_bg_key(Some([1, 2, 3, 4])),
 6473|       |            "01020304"
 6474|       |        );
 6475|       |
 6476|      1|        let factor = MermaidRenderer::MERMAID_SCALE_BUCKET_FACTOR;
 6477|      1|        assert_eq!(
 6478|      1|            MermaidRenderer::scale_bucket(0.1),
 6479|      1|            (0.5 * factor).round() as u32
 6480|       |        );
 6481|      1|        assert_eq!(
 6482|      1|            MermaidRenderer::scale_bucket(10.0),
 6483|      1|            (4.0 * factor).round() as u32
 6484|       |        );
 6485|      1|    }
 6486|       |
 6487|       |    #[test]
 6488|      1|    fn test_mermaid_hash_str_stable_and_distinct() {
 6489|      1|        let a = MermaidRenderer::hash_str("alpha");
 6490|      1|        let b = MermaidRenderer::hash_str("alpha");
 6491|      1|        let c = MermaidRenderer::hash_str("beta");
 6492|      1|        assert_eq!(a, b);
 6493|      1|        assert_ne!(a, c);
 6494|      1|    }
 6495|       |
 6496|       |    #[test]
 6497|      1|    fn test_mermaid_bg_fill_light_mode() {
 6498|      1|        let _lock = env_lock();
 6499|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "light");
 6500|      1|        assert_eq!(
 6501|      1|            MermaidRenderer::mermaid_bg_fill(),
 6502|       |            Some([255, 255, 255, 255])
 6503|       |        );
 6504|      1|    }
 6505|       |
 6506|       |    #[test]
 6507|      1|    fn test_mermaid_bg_fill_color_override() {
 6508|      1|        let _lock = env_lock();
 6509|      1|        std::env::remove_var("MDMDVIEW_MERMAID_BG");
 6510|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG_COLOR", "#11223344");
 6511|      1|        assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([17, 34, 51, 68]));
 6512|      1|    }
 6513|       |
 6514|       |    #[test]
 6515|      1|    fn test_mermaid_bg_fill_theme_fallback() {
 6516|      1|        let _lock = env_lock();
 6517|      1|        let _guard_mode = EnvGuard::set("MDMDVIEW_MERMAID_BG", "theme");
 6518|      1|        let _guard_bkg = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "#010203");
 6519|      1|        assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([1, 2, 3, 255]));
 6520|      1|    }
 6521|       |
 6522|       |    #[test]
 6523|      1|    fn test_render_block_off_and_embedded_without_feature() {
 6524|      1|        let _lock = env_lock();
 6525|      1|        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
 6526|      1|        let renderer = MermaidRenderer::new();
 6527|      1|        let ctx = egui::Context::default();
 6528|      1|        let input = egui::RawInput {
 6529|      1|            screen_rect: Some(egui::Rect::from_min_size(
 6530|      1|                egui::pos2(0.0, 0.0),
 6531|      1|                egui::vec2(800.0, 600.0),
 6532|      1|            )),
 6533|      1|            ..Default::default()
 6534|      1|        };
 6535|       |
 6536|      1|        let mut rendered = true;
 6537|      1|        let _ = ctx.run(input.clone(), |ctx| {
 6538|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 6539|      1|                rendered = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 6540|      1|            });
 6541|      1|        });
 6542|      1|        assert!(rendered);
 6543|       |
 6544|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "off");
 6545|      1|        let renderer = MermaidRenderer::new();
 6546|      1|        let mut rendered_off = true;
 6547|      1|        let _ = ctx.run(input.clone(), |ctx| {
 6548|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 6549|      1|                rendered_off = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 6550|      1|            });
 6551|      1|        });
 6552|      1|        assert!(rendered_off);
 6553|       |
 6554|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6555|      1|        let renderer = MermaidRenderer::new();
 6556|      1|        let mut rendered_embedded = true;
 6557|      1|        let _ = ctx.run(input, |ctx| {
 6558|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 6559|      1|                rendered_embedded = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 6560|      1|            });
 6561|      1|        });
 6562|      1|        assert!(rendered_embedded);
 6563|      1|    }
 6564|       |
 6565|       |    #[cfg(feature = "mermaid-quickjs")]
 6566|       |    #[test]
 6567|      1|    fn test_render_block_embedded_missing_js_fallback() {
 6568|      1|        let _lock = env_lock();
 6569|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6570|      1|        let _empty = MermaidJsEmptyGuard::set(true);
 6571|      1|        let (_tx, rx) = bounded(1);
 6572|      1|        let renderer = test_renderer_with_channels(None, rx);
 6573|      1|        let ctx = egui::Context::default();
 6574|      1|        let input = egui::RawInput {
 6575|      1|            screen_rect: Some(egui::Rect::from_min_size(
 6576|      1|                egui::pos2(0.0, 0.0),
 6577|      1|                egui::vec2(800.0, 600.0),
 6578|      1|            )),
 6579|      1|            ..Default::default()
 6580|      1|        };
 6581|       |
 6582|      1|        let mut rendered = true;
 6583|      1|        let _ = ctx.run(input, |ctx| {
 6584|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 6585|      1|                rendered = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 6586|      1|            });
 6587|      1|        });
 6588|      1|        assert!(rendered);
 6589|      1|    }
 6590|       |
 6591|       |    #[cfg(feature = "mermaid-quickjs")]
 6592|       |    #[test]
 6593|      1|    fn test_render_block_width_fallback_for_small_ui() {
 6594|      1|        let _lock = env_lock();
 6595|      1|        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
 6596|      1|        let renderer = MermaidRenderer::new();
 6597|      1|        let ctx = egui::Context::default();
 6598|      1|        let input = egui::RawInput {
 6599|      1|            screen_rect: Some(egui::Rect::from_min_size(
 6600|      1|                egui::pos2(0.0, 0.0),
 6601|      1|                egui::vec2(800.0, 600.0),
 6602|      1|            )),
 6603|      1|            ..Default::default()
 6604|      1|        };
 6605|       |
 6606|      1|        let mut rendered = true;
 6607|      1|        let _ = ctx.run(input, |ctx| {
 6608|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 6609|      1|                ui.allocate_ui_with_layout(
 6610|      1|                    egui::vec2(20.0, 200.0),
 6611|      1|                    egui::Layout::top_down(egui::Align::Min),
 6612|      1|                    |ui| {
 6613|      1|                        rendered = renderer.render_block(ui, "%% comment", 1.0, 14.0);
 6614|      1|                    },
 6615|       |                );
 6616|      1|            });
 6617|      1|        });
 6618|      1|        assert!(rendered);
 6619|      1|    }
 6620|       |
 6621|       |    #[cfg(feature = "mermaid-quickjs")]
 6622|       |    #[test]
 6623|      1|    fn test_render_block_width_fallback_equal_screen() {
 6624|      1|        let _lock = env_lock();
 6625|      1|        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
 6626|      1|        let renderer = MermaidRenderer::new();
 6627|      1|        let ctx = egui::Context::default();
 6628|      1|        let input = egui::RawInput {
 6629|      1|            screen_rect: Some(egui::Rect::from_min_size(
 6630|      1|                egui::pos2(0.0, 0.0),
 6631|      1|                egui::vec2(20.0, 200.0),
 6632|      1|            )),
 6633|      1|            ..Default::default()
 6634|      1|        };
 6635|       |
 6636|      1|        let mut rendered = true;
 6637|      1|        let _ = ctx.run(input, |ctx| {
 6638|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 6639|      1|                ui.allocate_ui_with_layout(
 6640|      1|                    egui::vec2(20.0, 200.0),
 6641|      1|                    egui::Layout::top_down(egui::Align::Min),
 6642|      1|                    |ui| {
 6643|      1|                        rendered = renderer.render_block(ui, "%% comment", 1.0, 14.0);
 6644|      1|                    },
 6645|       |                );
 6646|      1|            });
 6647|      1|        });
 6648|      1|        assert!(rendered);
 6649|      1|    }
 6650|       |
 6651|       |    #[cfg(feature = "mermaid-quickjs")]
 6652|       |    #[test]
 6653|      1|    fn test_render_block_uses_cached_texture_scales() {
 6654|      1|        let _lock = env_lock();
 6655|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6656|      1|        let (_result_tx, result_rx) = bounded(1);
 6657|      1|        let renderer = test_renderer_with_channels(None, result_rx);
 6658|      1|        let ctx = egui::Context::default();
 6659|      1|        let input = egui::RawInput {
 6660|      1|            screen_rect: Some(egui::Rect::from_min_size(
 6661|      1|                egui::pos2(0.0, 0.0),
 6662|      1|                egui::vec2(240.0, 160.0),
 6663|      1|            )),
 6664|      1|            ..Default::default()
 6665|      1|        };
 6666|      1|        let code = "graph TD; A-->B;";
 6667|      1|        let mut rendered_large = false;
 6668|      1|        let mut rendered_small = false;
 6669|       |
 6670|      1|        let _ = ctx.run(input, |ctx| {
 6671|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 6672|      1|                let image = egui::ColorImage::new([2, 2], Color32::WHITE);
 6673|      1|                let texture =
 6674|      1|                    ui.ctx()
 6675|      1|                        .load_texture("mermaid-test", image, egui::TextureOptions::default());
 6676|      1|                let svg_key = MermaidRenderer::hash_str(code);
 6677|      2|                let make_key = |ui: &egui::Ui| {
                                  ^1
 6678|      2|                    let width_bucket = MermaidRenderer::width_bucket(ui.available_width());
 6679|      2|                    let scale_bucket = MermaidRenderer::scale_bucket(1.0);
 6680|      2|                    let bg = MermaidRenderer::mermaid_bg_fill();
 6681|      2|                    MermaidRenderer::texture_key(svg_key, width_bucket, scale_bucket, bg)
 6682|      2|                };
 6683|       |
 6684|      1|                let texture_key = make_key(ui);
 6685|      1|                renderer.mermaid_textures.borrow_mut().insert(
 6686|      1|                    texture_key.clone(),
 6687|      1|                    MermaidTextureEntry {
 6688|      1|                        texture: texture.clone(),
 6689|      1|                        size: [400, 200],
 6690|      1|                    },
 6691|      1|                );
 6692|      1|                rendered_large = renderer.render_block(ui, code, 1.0, 14.0);
 6693|       |
 6694|      1|                let texture_key = make_key(ui);
 6695|      1|                renderer.mermaid_textures.borrow_mut().insert(
 6696|      1|                    texture_key,
 6697|      1|                    MermaidTextureEntry {
 6698|      1|                        texture,
 6699|      1|                        size: [20, 10],
 6700|      1|                    },
 6701|      1|                );
 6702|      1|                rendered_small = renderer.render_block(ui, code, 1.0, 14.0);
 6703|      1|            });
 6704|      1|        });
 6705|       |
 6706|      1|        assert!(rendered_large);
 6707|      1|        assert!(rendered_small);
 6708|      1|    }
 6709|       |
 6710|       |    #[cfg(feature = "mermaid-quickjs")]
 6711|       |    #[test]
 6712|      1|    fn test_render_block_reports_cached_error() {
 6713|      1|        let _lock = env_lock();
 6714|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6715|      1|        let (_result_tx, result_rx) = bounded(1);
 6716|      1|        let renderer = test_renderer_with_channels(None, result_rx);
 6717|      1|        let code = "graph TD; A-->B;";
 6718|      1|        let svg_key = MermaidRenderer::hash_str(code);
 6719|      1|        renderer
 6720|      1|            .mermaid_errors
 6721|      1|            .borrow_mut()
 6722|      1|            .insert(svg_key, "boom".to_string());
 6723|      1|        let ctx = egui::Context::default();
 6724|      1|        let input = egui::RawInput {
 6725|      1|            screen_rect: Some(egui::Rect::from_min_size(
 6726|      1|                egui::pos2(0.0, 0.0),
 6727|      1|                egui::vec2(240.0, 160.0),
 6728|      1|            )),
 6729|      1|            ..Default::default()
 6730|      1|        };
 6731|      1|        let mut rendered = false;
 6732|      1|        let _ = ctx.run(input, |ctx| {
 6733|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 6734|      1|                rendered = renderer.render_block(ui, code, 1.0, 14.0);
 6735|      1|            });
 6736|      1|        });
 6737|      1|        assert!(rendered);
 6738|      1|    }
 6739|       |
 6740|       |    #[cfg(feature = "mermaid-quickjs")]
 6741|       |    #[test]
 6742|      1|    fn test_render_block_queue_full_sets_waiting() {
 6743|      1|        let _lock = env_lock();
 6744|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6745|      1|        let (job_tx, job_rx) = bounded(1);
 6746|      1|        let (_result_tx, result_rx) = bounded(1);
 6747|      1|        let renderer = test_renderer_with_channels(Some(job_tx.clone()), result_rx);
 6748|      1|        let request = MermaidRequest {
 6749|      1|            svg_key: 1,
 6750|      1|            texture_key: "full".to_string(),
 6751|      1|            code: Some("graph TD; A-->B;".to_string()),
 6752|      1|            svg: None,
 6753|      1|            width_bucket: 32,
 6754|      1|            scale_bucket: MermaidRenderer::scale_bucket(1.0),
 6755|      1|            viewport_width: 120,
 6756|      1|            viewport_height: 120,
 6757|      1|            bg: MermaidRenderer::mermaid_bg_fill(),
 6758|      1|        };
 6759|      1|        job_tx.send(request).expect("fill queue");
 6760|       |
 6761|      1|        let ctx = egui::Context::default();
 6762|      1|        let input = egui::RawInput {
 6763|      1|            screen_rect: Some(egui::Rect::from_min_size(
 6764|      1|                egui::pos2(0.0, 0.0),
 6765|      1|                egui::vec2(240.0, 160.0),
 6766|      1|            )),
 6767|      1|            ..Default::default()
 6768|      1|        };
 6769|      1|        let mut rendered = false;
 6770|      1|        let _ = ctx.run(input, |ctx| {
 6771|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 6772|      1|                rendered = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 6773|      1|            });
 6774|      1|        });
 6775|      1|        assert!(rendered);
 6776|      1|        assert!(renderer.mermaid_frame_pending.get());
 6777|      1|        drop(job_rx);
 6778|      1|    }
 6779|       |
 6780|       |    #[cfg(feature = "mermaid-quickjs")]
 6781|       |    #[test]
 6782|      1|    fn test_render_block_disconnected_queue_sets_error() {
 6783|      1|        let _lock = env_lock();
 6784|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6785|      1|        let (_result_tx, result_rx) = bounded(1);
 6786|      1|        let renderer = test_renderer_with_channels(None, result_rx);
 6787|      1|        let ctx = egui::Context::default();
 6788|      1|        let input = egui::RawInput {
 6789|      1|            screen_rect: Some(egui::Rect::from_min_size(
 6790|      1|                egui::pos2(0.0, 0.0),
 6791|      1|                egui::vec2(240.0, 160.0),
 6792|      1|            )),
 6793|      1|            ..Default::default()
 6794|      1|        };
 6795|      1|        let code = "graph TD; A-->B;";
 6796|      1|        let mut rendered = false;
 6797|      1|        let _ = ctx.run(input, |ctx| {
 6798|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 6799|      1|                rendered = renderer.render_block(ui, code, 1.0, 14.0);
 6800|      1|            });
 6801|      1|        });
 6802|      1|        assert!(rendered);
 6803|      1|        let svg_key = MermaidRenderer::hash_str(code);
 6804|      1|        assert!(renderer.mermaid_errors.borrow_mut().get(&svg_key).is_some());
 6805|      1|    }
 6806|       |
 6807|       |    #[cfg(feature = "mermaid-quickjs")]
 6808|       |    #[test]
 6809|      1|    fn test_render_block_pending_and_width_fallback() {
 6810|      1|        let _lock = env_lock();
 6811|      1|        let _guard_renderer = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6812|      1|        let _guard_log = EnvGuard::set("MDMDVIEW_MERMAID_LOG_WIDTH", "1");
 6813|      1|        let (job_tx, job_rx) = bounded(2);
 6814|      1|        let (result_tx, result_rx) = bounded(2);
 6815|      1|        let renderer = test_renderer_with_channels(Some(job_tx), result_rx);
 6816|      1|        result_tx
 6817|      1|            .send(MermaidResult {
 6818|      1|                svg_key: 99,
 6819|      1|                texture_key: "other".to_string(),
 6820|      1|                svg: Some("<svg width=\"1\" height=\"1\"></svg>".to_string()),
 6821|      1|                rgba: None,
 6822|      1|                size: None,
 6823|      1|                error: None,
 6824|      1|            })
 6825|      1|            .expect("send svg");
 6826|       |
 6827|      1|        let ctx = egui::Context::default();
 6828|      1|        let input = egui::RawInput {
 6829|      1|            screen_rect: Some(egui::Rect::from_min_size(
 6830|      1|                egui::pos2(0.0, 0.0),
 6831|      1|                egui::vec2(200.0, 120.0),
 6832|      1|            )),
 6833|      1|            ..Default::default()
 6834|      1|        };
 6835|      1|        let code = "timeline\n  title Demo";
 6836|      1|        let mut rendered_first = false;
 6837|      1|        let mut rendered_second = false;
 6838|      1|        let _ = ctx.run(input, |ctx| {
 6839|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 6840|      1|                let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(10.0, 80.0));
 6841|      1|                ui.allocate_ui_at_rect(rect, |ui| {
 6842|      1|                    rendered_first = renderer.render_block(ui, code, 1.0, 14.0);
 6843|      1|                    rendered_second = renderer.render_block(ui, code, 1.0, 14.0);
 6844|      1|                });
 6845|      1|            });
 6846|      1|        });
 6847|      1|        assert!(rendered_first);
 6848|      1|        assert!(rendered_second);
 6849|      1|        drop(job_rx);
 6850|      1|    }
 6851|       |
 6852|       |    #[test]
 6853|      1|    fn test_mermaid_cache_insert_existing_key_and_empty_order() {
 6854|      1|        let mut cache = LruCache::new(1);
 6855|      1|        cache.insert(1u8, "one".to_string());
 6856|      1|        cache.insert(1u8, "uno".to_string());
 6857|      1|        assert_eq!(cache.get(&1), Some("uno".to_string()));
 6858|      1|        assert!(cache.get(&9).is_none());
 6859|       |
 6860|      1|        cache.insert(2u8, "two".to_string());
 6861|      1|        assert!(cache.get(&1).is_none());
 6862|       |
 6863|      1|        cache.entries.clear();
 6864|      1|        cache.entries.insert(2u8, "two".to_string());
 6865|      1|        cache.order.clear();
 6866|      1|        cache.insert(3u8, "three".to_string());
 6867|      1|        assert_eq!(cache.len(), 2);
 6868|      1|    }
 6869|       |
 6870|       |    #[test]
 6871|      1|    fn test_mermaid_has_pending_default_false() {
 6872|      1|        let renderer = MermaidRenderer::new();
 6873|      1|        assert!(!renderer.has_pending());
 6874|      1|    }
 6875|       |
 6876|       |    #[cfg(feature = "mermaid-quickjs")]
 6877|       |    #[test]
 6878|      1|    fn test_mermaid_has_pending_true_for_frame_or_queue() {
 6879|      1|        let renderer = MermaidRenderer::new();
 6880|      1|        renderer.mermaid_frame_pending.set(true);
 6881|      1|        assert!(renderer.has_pending());
 6882|      1|        renderer.mermaid_frame_pending.set(false);
 6883|      1|        renderer
 6884|      1|            .mermaid_pending
 6885|      1|            .borrow_mut()
 6886|      1|            .insert("pending".to_string());
 6887|      1|        assert!(renderer.has_pending());
 6888|      1|    }
 6889|       |
 6890|       |    #[cfg(feature = "mermaid-quickjs")]
 6891|       |    #[test]
 6892|      1|    fn test_fix_journey_section_text_fill_adds_fill() {
 6893|      1|        let input = r#"<svg><text class="journey-section section-type-0" x="0">Plan</text></svg>"#;
 6894|      1|        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
 6895|      1|            .expect("journey text updated");
 6896|      1|        assert!(output.contains("class=\"journey-section section-type-0\""));
 6897|      1|        assert!(output.contains("fill:#112233"));
 6898|      1|    }
 6899|       |
 6900|       |    #[cfg(feature = "mermaid-quickjs")]
 6901|       |    #[test]
 6902|      1|    fn test_fix_journey_section_text_overwrites_fill_in_style() {
 6903|      1|        let input = r#"<svg><text class="journey-section" style="fill:#000000;stroke:#fff" x="0">Plan</text></svg>"#;
 6904|      1|        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
 6905|      1|            .expect("journey text updated");
 6906|      1|        assert!(output.contains("fill:#112233"));
 6907|      1|        assert!(!output.contains("fill:#000000"));
 6908|      1|    }
 6909|       |
 6910|       |    #[cfg(feature = "mermaid-quickjs")]
 6911|       |    #[test]
 6912|      1|    fn test_fix_journey_section_text_skips_empty_style_parts() {
 6913|      1|        let input = r#"<svg><text class="journey-section" style="fill:#000000;;stroke:#fff" x="0">Plan</text></svg>"#;
 6914|      1|        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
 6915|      1|            .expect("journey text updated");
 6916|      1|        assert!(output.contains("fill:#112233"));
 6917|      1|        assert!(output.contains("stroke:#fff"));
 6918|      1|    }
 6919|       |
 6920|       |    #[cfg(feature = "mermaid-quickjs")]
 6921|       |    #[test]
 6922|      1|    fn test_fix_journey_section_text_noop_without_marker() {
 6923|      1|        let input = r#"<svg><text class="label" x="0">Plan</text></svg>"#;
 6924|      1|        assert!(MermaidWorker::fix_journey_section_text(input, "#112233").is_none());
 6925|      1|    }
 6926|       |
 6927|       |    #[cfg(feature = "mermaid-quickjs")]
 6928|       |    #[test]
 6929|      1|    fn test_fix_journey_section_text_handles_non_section_tag() {
 6930|      1|        let input = r#"<svg><text class="label">A</text><text class="journey-section" style="fill:#000">B</text></svg>"#;
 6931|      1|        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
 6932|      1|            .expect("journey text updated");
 6933|      1|        assert!(output.contains("class=\"label\""));
 6934|      1|        assert!(output.contains("fill:#112233"));
 6935|      1|    }
 6936|       |
 6937|       |    #[cfg(feature = "mermaid-quickjs")]
 6938|       |    #[test]
 6939|      1|    fn test_fix_journey_section_text_style_missing_quote_returns_none() {
 6940|      1|        let input = r#"<svg><text class="journey-section" style="fill:#000>Plan</text></svg>"#;
 6941|      1|        assert!(MermaidWorker::fix_journey_section_text(input, "#112233").is_none());
 6942|      1|    }
 6943|       |
 6944|       |    #[cfg(feature = "mermaid-quickjs")]
 6945|       |    #[test]
 6946|      1|    fn test_fix_state_end_circles_swaps_radii() {
 6947|      1|        let input = r#"<svg><g id="state-root_end-0"><circle class="state-end" r="5" width="10" height="10"></circle><circle class="state-start" r="7" width="14" height="14"></circle></g></svg>"#;
 6948|      1|        let output =
 6949|      1|            MermaidWorker::fix_state_end_circles(input).expect("state end circles updated");
 6950|      1|        assert!(output.contains("class=\"state-end\" r=\"7\""));
 6951|      1|        assert!(output.contains("class=\"end-state-inner\" r=\"5\""));
 6952|      1|        assert!(output.contains("class=\"state-end\" r=\"7\" width=\"14\" height=\"14\""));
 6953|      1|        assert!(output.contains("class=\"end-state-inner\" r=\"5\" width=\"10\" height=\"10\""));
 6954|      1|    }
 6955|       |
 6956|       |    #[cfg(feature = "mermaid-quickjs")]
 6957|       |    #[test]
 6958|      1|    fn test_fix_state_end_circles_swaps_radii_when_start_first() {
 6959|      1|        let input = r#"<svg><g id="state-root_end-0"><circle class="state-start" r="7" width="14" height="14"></circle><circle class="state-end" r="5" width="10" height="10"></circle></g></svg>"#;
 6960|      1|        let output =
 6961|      1|            MermaidWorker::fix_state_end_circles(input).expect("state end circles updated");
 6962|      1|        assert!(output.contains("end-state-inner"));
 6963|      1|        assert!(output.contains("class=\"state-end\" r=\"7\""));
 6964|      1|    }
 6965|       |
 6966|       |    #[cfg(feature = "mermaid-quickjs")]
 6967|       |    #[test]
 6968|      1|    fn test_fix_state_end_circles_noop_without_marker() {
 6969|      1|        let input = r#"<svg><g><circle class="state-start" r="7"></circle></g></svg>"#;
 6970|      1|        assert!(MermaidWorker::fix_state_end_circles(input).is_none());
 6971|      1|    }
 6972|       |
 6973|       |    #[cfg(feature = "mermaid-quickjs")]
 6974|       |    #[test]
 6975|      1|    fn test_fix_state_end_circles_noop_when_radii_ordered() {
 6976|      1|        let input = r#"<svg><g id="state-root_end-0"><circle class="state-end" r="7"></circle><circle class="state-start" r="5"></circle></g></svg>"#;
 6977|      1|        assert!(MermaidWorker::fix_state_end_circles(input).is_none());
 6978|      1|    }
 6979|       |
 6980|       |    #[cfg(feature = "mermaid-quickjs")]
 6981|       |    #[test]
 6982|      1|    fn test_fix_state_end_circles_skips_non_end_group() {
 6983|      1|        let input = r#"<svg><g id="state-root-0"><circle class="state-end" r="5"></circle></g><g id="state-root_end-0"><circle class="state-end" r="5" width="10" height="10"></circle><circle class="state-start" r="7" width="14" height="14"></circle></g></svg>"#;
 6984|      1|        let output =
 6985|      1|            MermaidWorker::fix_state_end_circles(input).expect("state end circles updated");
 6986|      1|        assert!(output.contains("state-root-0"));
 6987|      1|        assert!(output.contains("end-state-inner"));
 6988|      1|    }
 6989|       |
 6990|       |    #[cfg(feature = "mermaid-quickjs")]
 6991|       |    #[test]
 6992|      1|    fn test_fix_state_end_circles_missing_parts_noop() {
 6993|      1|        let missing_start =
 6994|      1|            r#"<svg><g id="state-root_end-0"><circle class="state-end" r="5"></circle></g></svg>"#;
 6995|      1|        assert!(MermaidWorker::fix_state_end_circles(missing_start).is_none());
 6996|       |
 6997|      1|        let missing_r = r#"<svg><g id="state-root_end-0"><circle class="state-end"></circle><circle class="state-start" r="7"></circle></g></svg>"#;
 6998|      1|        assert!(MermaidWorker::fix_state_end_circles(missing_r).is_none());
 6999|       |
 7000|      1|        let non_numeric = r#"<svg><g id="state-root_end-0"><circle class="state-end" r="x"></circle><circle class="state-start" r="7"></circle></g></svg>"#;
 7001|      1|        assert!(MermaidWorker::fix_state_end_circles(non_numeric).is_none());
 7002|      1|    }
 7003|       |
 7004|       |    #[cfg(feature = "mermaid-quickjs")]
 7005|       |    #[test]
 7006|      1|    fn test_mindmap_edge_trim_uses_min_radius() {
 7007|      1|        let dx_idx = MERMAID_DOM_SHIM
 7008|      1|            .find("var dx = t_pos.x - s_pos.x")
 7009|      1|            .expect("mindmap dx computed");
 7010|      1|        let radius_idx = MERMAID_DOM_SHIM
 7011|      1|            .find("var s_radius = __mdmdview_rect_intersection")
 7012|      1|            .expect("mindmap radius computed");
 7013|      1|        assert!(dx_idx < radius_idx);
 7014|      1|    }
 7015|       |
 7016|       |    #[cfg(feature = "mermaid-quickjs")]
 7017|       |    #[test]
 7018|      1|    fn test_mindmap_edge_overlap_padding_present() {
 7019|      1|        assert!(MERMAID_DOM_SHIM.contains("var overlap = -2"));
 7020|      1|        assert!(MERMAID_DOM_SHIM.contains("var max_total = len * 0.95"));
 7021|      1|    }
 7022|       |
 7023|       |    #[cfg(feature = "mermaid-quickjs")]
 7024|       |    #[test]
 7025|      1|    fn test_flatten_svg_switches_removes_foreignobject() {
 7026|      1|        let input = r#"<svg><switch><foreignObject><div>Plan</div></foreignObject><text>Plan</text></switch></svg>"#;
 7027|      1|        let output = MermaidWorker::flatten_svg_switches(input).expect("switch flattened");
 7028|      1|        assert!(!output.contains("<switch"));
 7029|      1|        assert!(!output.contains("foreignObject"));
 7030|      1|        assert!(output.contains("<text>Plan</text>"));
 7031|      1|    }
 7032|       |
 7033|       |    #[cfg(feature = "mermaid-quickjs")]
 7034|       |    #[test]
 7035|      1|    fn test_mermaid_dom_shim_clusters_not_labelish() {
 7036|      1|        assert!(MERMAID_DOM_SHIM.contains("has_class(node, 'clusters')"));
 7037|      1|    }
 7038|       |
 7039|       |    #[cfg(feature = "mermaid-quickjs")]
 7040|       |    #[test]
 7041|      1|    fn test_fix_er_attribute_fills_inlines_colors() {
 7042|      1|        let input = r#"<svg><rect class="er attributeBoxOdd"></rect><rect class="er attributeBoxEven"></rect></svg>"#;
 7043|      1|        let output = MermaidWorker::fix_er_attribute_fills(input).expect("er fills updated");
 7044|      1|        assert!(output.contains("attributeBoxOdd\" fill=\"#ffffff\""));
 7045|      1|        assert!(output.contains("attributeBoxEven\" fill=\"#f2f2f2\""));
 7046|      1|    }
 7047|       |
 7048|       |    #[cfg(feature = "mermaid-quickjs")]
 7049|       |    #[test]
 7050|      1|    fn test_fix_er_attribute_fills_handles_even_only() {
 7051|      1|        let input = r#"<svg><rect class="er attributeBoxEven"></rect></svg>"#;
 7052|      1|        let output = MermaidWorker::fix_er_attribute_fills(input).expect("er fills updated");
 7053|      1|        assert!(output.contains("attributeBoxEven\" fill=\"#f2f2f2\""));
 7054|      1|    }
 7055|       |
 7056|       |    #[cfg(feature = "mermaid-quickjs")]
 7057|       |    #[test]
 7058|      1|    fn test_fix_er_attribute_fills_skips_unmatched_rects() {
 7059|      1|        let input =
 7060|      1|            r#"<svg><rect class="er attributeBoxOdd"></rect><rect class="er"></rect></svg>"#;
 7061|      1|        let output = MermaidWorker::fix_er_attribute_fills(input).expect("er fills updated");
 7062|      1|        assert!(output.contains("attributeBoxOdd\" fill=\"#ffffff\""));
 7063|      1|        assert!(output.contains("class=\"er\"></rect>"));
 7064|      1|    }
 7065|       |
 7066|       |    #[cfg(feature = "mermaid-quickjs")]
 7067|       |    #[test]
 7068|      1|    fn test_fix_er_attribute_fills_noop_without_markers() {
 7069|      1|        let input = r#"<svg><rect class="er"></rect></svg>"#;
 7070|      1|        assert!(MermaidWorker::fix_er_attribute_fills(input).is_none());
 7071|      1|    }
 7072|       |
 7073|       |    #[cfg(feature = "mermaid-quickjs")]
 7074|       |    #[test]
 7075|      1|    fn test_fix_er_attribute_fills_noop_when_fill_matches() {
 7076|      1|        let input = r##"<svg><rect class="er attributeBoxOdd" fill="#ffffff"></rect></svg>"##;
 7077|      1|        assert!(MermaidWorker::fix_er_attribute_fills(input).is_none());
 7078|      1|    }
 7079|       |
 7080|       |    #[cfg(feature = "mermaid-quickjs")]
 7081|       |    #[test]
 7082|      1|    fn test_flatten_svg_switches_noop_without_switch() {
 7083|      1|        let input = r#"<svg><text>Plan</text></svg>"#;
 7084|      1|        assert!(MermaidWorker::flatten_svg_switches(input).is_none());
 7085|      1|    }
 7086|       |
 7087|       |    #[cfg(feature = "mermaid-quickjs")]
 7088|       |    #[test]
 7089|      1|    fn test_flatten_svg_switches_handles_missing_close() {
 7090|      1|        let input = r#"<svg><switch><text>Plan</text></svg>"#;
 7091|      1|        assert!(MermaidWorker::flatten_svg_switches(input).is_none());
 7092|      1|    }
 7093|       |
 7094|       |    #[cfg(feature = "mermaid-quickjs")]
 7095|       |    #[test]
 7096|      1|    fn test_flatten_svg_switches_missing_foreign_object_close() {
 7097|      1|        let input =
 7098|      1|            r#"<svg><switch><foreignObject><div>Plan</div></switch><text>After</text></svg>"#;
 7099|      1|        let output = MermaidWorker::flatten_svg_switches(input).expect("switch flattened");
 7100|      1|        assert!(output.contains("<text>After</text>"));
 7101|      1|    }
 7102|       |
 7103|       |    #[cfg(feature = "mermaid-quickjs")]
 7104|       |    #[test]
 7105|      1|    fn test_patch_mermaid_js_applies_expected_replacements() {
 7106|      1|        let js = concat!(
 7107|       |            "var hD=wRe();",
 7108|       |            "FY.prototype={constructor:FY,appendChild:function(i){return this._parent.insertBefore(i,this._next)},insertBefore:function(i,s){return this._parent.insertBefore(i,s)},querySelector:function(i){return this._parent.querySelector(i)},querySelectorAll:function(i){return this._parent.querySelectorAll(i)}};",
 7109|       |            "function FY(i,s){this.ownerDocument=i.ownerDocument,this.namespaceURI=i.namespaceURI,this._next=null,this._parent=i,this.__data__=s}",
 7110|       |            "u.text().split(/(\\s+|<br>)/).reverse()",
 7111|       |            "p=fWe({container:document.getElementById(\"cy\"),style:[{selector:\"edge\",style:{\"curve-style\":\"bezier\"}}]});",
 7112|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run(),p.ready(v=>{Xe.info(\"Ready\",v),u(p)})",
 7113|       |            "const se=_.node().getBBox();"
 7114|       |        );
 7115|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 7116|      1|        assert!(output.contains("sanitize:function"));
 7117|      1|        assert!(output.contains("document.body"));
 7118|      1|        assert!(output.contains("String(typeof u.text"));
 7119|      1|        assert!(output.contains("__mdmdview_cytoscape_stub"));
 7120|      1|        assert!(output.contains("breadthfirst"));
 7121|      1|        assert!(output.contains("se.width=Math.max"));
 7122|      1|    }
 7123|       |
 7124|       |    #[cfg(feature = "mermaid-quickjs")]
 7125|       |    #[test]
 7126|      1|    fn test_patch_mermaid_js_applies_mindmap_layout_fallback() {
 7127|      1|        let js =
 7128|      1|            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 7129|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 7130|      1|        assert!(output.contains("breadthfirst"));
 7131|      1|    }
 7132|       |
 7133|       |    #[cfg(feature = "mermaid-quickjs")]
 7134|       |    #[test]
 7135|      1|    fn test_patch_mermaid_js_debug_paths_without_targets() {
 7136|      1|        let _lock = env_lock();
 7137|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
 7138|      1|        let js = "console.log('no targets here');";
 7139|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 7140|      1|        assert_eq!(output, js);
 7141|      1|    }
 7142|       |
 7143|       |    #[cfg(feature = "mermaid-quickjs")]
 7144|       |    #[test]
 7145|      1|    fn test_patch_mermaid_js_debug_false_branch() {
 7146|      1|        let _lock = env_lock();
 7147|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
 7148|      1|        let previous = std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG").ok();
 7149|      1|        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
 7150|      1|        let js =
 7151|      1|            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 7152|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 7153|      1|        assert!(output.contains("breadthfirst"));
 7154|      1|        restore_env_var("MDMDVIEW_MERMAID_PATCH_DEBUG", previous);
 7155|      1|    }
 7156|       |
 7157|       |    #[cfg(feature = "mermaid-quickjs")]
 7158|       |    #[test]
 7159|      1|    fn test_patch_mermaid_js_debug_restore_when_missing() {
 7160|      1|        let _lock = env_lock();
 7161|      1|        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
 7162|      1|        let previous = std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG").ok();
 7163|      1|        let js =
 7164|      1|            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 7165|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 7166|      1|        assert!(output.contains("breadthfirst"));
 7167|      1|        restore_env_var("MDMDVIEW_MERMAID_PATCH_DEBUG", previous);
 7168|      1|    }
 7169|       |
 7170|       |    #[cfg(feature = "mermaid-quickjs")]
 7171|       |    #[test]
 7172|      1|    fn test_patch_mermaid_js_debug_missing_layout_not_logged_when_debug_off() {
 7173|      1|        let _lock = env_lock();
 7174|      1|        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
 7175|      1|        let js = "console.log('no targets here');";
 7176|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 7177|      1|        assert_eq!(output, js);
 7178|      1|    }
 7179|       |
 7180|       |    #[cfg(feature = "mermaid-quickjs")]
 7181|       |    #[test]
 7182|      1|    fn test_patch_mermaid_js_debug_paths_with_targets() {
 7183|      1|        let _lock = env_lock();
 7184|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
 7185|      1|        let js = concat!(
 7186|       |            "var hD=wRe();",
 7187|       |            "FY.prototype={constructor:FY,appendChild:function(i){return this._parent.insertBefore(i,this._next)},insertBefore:function(i,s){return this._parent.insertBefore(i,s)},querySelector:function(i){return this._parent.querySelector(i)},querySelectorAll:function(i){return this._parent.querySelectorAll(i)}};",
 7188|       |            "function FY(i,s){this.ownerDocument=i.ownerDocument,this.namespaceURI=i.namespaceURI,this._next=null,this._parent=i,this.__data__=s}",
 7189|       |            "u.text().split(/(\\s+|<br>)/).reverse()",
 7190|       |            "p=fWe({container:document.getElementById(\"cy\"),style:[{selector:\"edge\",style:{\"curve-style\":\"bezier\"}}]});",
 7191|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run(),p.ready(v=>{Xe.info(\"Ready\",v),u(p)})",
 7192|       |            "const se=_.node().getBBox();"
 7193|       |        );
 7194|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 7195|      1|        assert!(output.contains("sanitize:function"));
 7196|      1|        assert!(output.contains("__mdmdview_cytoscape_stub"));
 7197|      1|    }
 7198|       |
 7199|       |    #[cfg(feature = "mermaid-quickjs")]
 7200|       |    #[test]
 7201|      1|    fn test_patch_mermaid_js_debug_paths_with_layout_only() {
 7202|      1|        let _lock = env_lock();
 7203|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
 7204|      1|        let js =
 7205|      1|            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 7206|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 7207|      1|        assert!(output.contains("breadthfirst"));
 7208|      1|    }
 7209|       |
 7210|       |    #[cfg(feature = "mermaid-quickjs")]
 7211|       |    #[test]
 7212|      1|    fn test_normalize_svg_size_inserts_dimensions() {
 7213|      1|        let svg = r#"<svg viewBox="0 0 200 100" width="100%" height="100%"></svg>"#;
 7214|      1|        let output = MermaidWorker::normalize_svg_size(svg);
 7215|      1|        assert!(output.contains("width=\"200\""));
 7216|      1|        assert!(output.contains("height=\"100\""));
 7217|      1|    }
 7218|       |
 7219|       |    #[cfg(feature = "mermaid-quickjs")]
 7220|       |    #[test]
 7221|      1|    fn test_normalize_svg_size_inserts_missing_dimension() {
 7222|      1|        let svg = r#"<svg viewBox="0 0 320 240" height="100%"></svg>"#;
 7223|      1|        let output = MermaidWorker::normalize_svg_size(svg);
 7224|      1|        assert!(output.contains("width=\"320\""));
 7225|      1|        assert!(output.contains("height=\"240\""));
 7226|      1|    }
 7227|       |
 7228|       |    #[cfg(feature = "mermaid-quickjs")]
 7229|       |    #[test]
 7230|      1|    fn test_normalize_svg_size_skips_fixed_dimensions() {
 7231|      1|        let svg = r#"<svg viewBox="0 0 200 100" width="200" height="100"></svg>"#;
 7232|      1|        assert_eq!(MermaidWorker::normalize_svg_size(svg), svg);
 7233|      1|    }
 7234|       |
 7235|       |    #[cfg(feature = "mermaid-quickjs")]
 7236|       |    #[test]
 7237|      1|    fn test_normalize_svg_size_no_viewbox_no_change() {
 7238|      1|        let svg = r#"<svg width="100%" height="100%"></svg>"#;
 7239|      1|        assert_eq!(MermaidWorker::normalize_svg_size(svg), svg);
 7240|      1|    }
 7241|       |
 7242|       |    #[cfg(feature = "mermaid-quickjs")]
 7243|       |    #[test]
 7244|      1|    fn test_replace_and_upsert_attr_paths() {
 7245|      1|        let tag = r#"<svg width="10" height="20">"#;
 7246|      1|        let replaced = MermaidWorker::replace_attr(tag, "width", "99");
 7247|      1|        assert!(replaced.contains("width=\"99\""));
 7248|      1|        let unchanged = MermaidWorker::replace_attr(tag, "viewBox", "0 0 1 1");
 7249|      1|        assert_eq!(unchanged, tag);
 7250|      1|        let upsert_existing = MermaidWorker::upsert_attr(tag, "height", "42");
 7251|      1|        assert!(upsert_existing.contains("height=\"42\""));
 7252|      1|        let upsert_new = MermaidWorker::upsert_attr(tag, "viewBox", "0 0 1 1");
 7253|      1|        assert!(upsert_new.contains("viewBox=\"0 0 1 1\""));
 7254|      1|    }
 7255|       |
 7256|       |    #[cfg(feature = "mermaid-quickjs")]
 7257|       |    #[test]
 7258|      1|    fn test_strip_svg_attr_and_insert_svg_attr() {
 7259|      1|        let svg = r#"<svg width="10" height="20"></svg>"#;
 7260|      1|        let stripped = MermaidWorker::strip_svg_attr(svg, "width").expect("width removed");
 7261|      1|        assert!(!stripped.contains("width=\"10\""));
 7262|      1|        assert!(MermaidWorker::strip_svg_attr(svg, "viewBox").is_none());
 7263|      1|        let inserted = MermaidWorker::insert_svg_attr("<svg></svg>", "viewBox", "0 0 1 1");
 7264|      1|        assert!(inserted.contains("viewBox=\"0 0 1 1\""));
 7265|      1|    }
 7266|       |
 7267|       |    #[cfg(feature = "mermaid-quickjs")]
 7268|       |    #[test]
 7269|      1|    fn test_remove_svg_attr_trims_double_space() {
 7270|      1|        let tag = r#"<svg width="10"  height="20">"#;
 7271|      1|        let stripped = MermaidWorker::remove_svg_attr(tag, "width");
 7272|      1|        assert!(!stripped.contains("width=\"10\""));
 7273|      1|        assert!(stripped.contains("height=\"20\""));
 7274|      1|        assert!(stripped.starts_with("<svg"));
 7275|      1|    }
 7276|       |
 7277|       |    #[cfg(feature = "mermaid-quickjs")]
 7278|       |    #[test]
 7279|      1|    fn test_remove_svg_attr_handles_no_space_prefix() {
 7280|      1|        let tag = r#"<svgwidth="10" height="20">"#;
 7281|      1|        let stripped = MermaidWorker::remove_svg_attr(tag, "width");
 7282|      1|        assert!(!stripped.contains("width=\"10\""));
 7283|      1|        assert!(stripped.contains("height=\"20\""));
 7284|      1|        assert!(stripped.starts_with("<svg"));
 7285|      1|    }
 7286|       |
 7287|       |    #[cfg(feature = "mermaid-quickjs")]
 7288|       |    #[test]
 7289|      1|    fn test_remove_svg_attr_noop_when_missing_or_unclosed() {
 7290|      1|        let tag = r#"<svg height="20">"#;
 7291|      1|        assert_eq!(MermaidWorker::remove_svg_attr(tag, "width"), tag);
 7292|      1|        let unclosed = r#"<svg width="10 height=20>"#;
 7293|      1|        assert_eq!(MermaidWorker::remove_svg_attr(unclosed, "width"), unclosed);
 7294|      1|    }
 7295|       |
 7296|       |    #[cfg(feature = "mermaid-quickjs")]
 7297|       |    #[test]
 7298|      1|    fn test_remove_svg_attr_preserves_spacing_without_double_space() {
 7299|      1|        let tag = r#"<svg width="10"height="20">"#;
 7300|      1|        assert_eq!(
 7301|      1|            MermaidWorker::remove_svg_attr(tag, "width"),
 7302|       |            "<svg height=\"20\">"
 7303|       |        );
 7304|      1|    }
 7305|       |
 7306|       |    #[cfg(feature = "mermaid-quickjs")]
 7307|       |    #[test]
 7308|      1|    fn test_parse_viewbox_dims_and_format_dim() {
 7309|      1|        assert_eq!(
 7310|      1|            MermaidWorker::parse_viewbox_dims("0 0 100 200"),
 7311|       |            Some((100.0, 200.0))
 7312|       |        );
 7313|      1|        assert_eq!(
 7314|      1|            MermaidWorker::parse_viewbox_dims("0,0,100,200"),
 7315|       |            Some((100.0, 200.0))
 7316|       |        );
 7317|      1|        assert!(MermaidWorker::parse_viewbox_dims("0,0,100,0").is_none());
 7318|      1|        assert!(MermaidWorker::parse_viewbox_dims("0 0 -1 2").is_none());
 7319|      1|        assert!(MermaidWorker::parse_viewbox_dims("0 0 NaN 2").is_none());
 7320|      1|        assert!(MermaidWorker::parse_viewbox_dims("0 0 inf 2").is_none());
 7321|      1|        assert!(MermaidWorker::parse_viewbox_dims("0 0 2 inf").is_none());
 7322|      1|        assert!(MermaidWorker::parse_viewbox_dims("bad").is_none());
 7323|      1|        assert_eq!(MermaidWorker::format_dim(10.0), "10");
 7324|      1|        assert_eq!(MermaidWorker::format_dim(10.5), "10.5");
 7325|      1|        assert_eq!(MermaidWorker::format_dim(0.0), "0");
 7326|      1|        assert_eq!(MermaidWorker::format_dim(10.123), "10.123");
 7327|      1|        let nan = MermaidWorker::format_dim(f32::NAN);
 7328|      1|        assert!(!nan.contains('.'));
 7329|      1|        assert!(nan.to_lowercase().contains("nan"));
 7330|      1|    }
 7331|       |
 7332|       |    #[cfg(feature = "mermaid-quickjs")]
 7333|       |    #[test]
 7334|      1|    fn test_text_measurer_fallback_for_missing_fonts() {
 7335|      1|        let fontdb = Arc::new(usvg::fontdb::Database::new());
 7336|      1|        let measurer = TextMeasurer::new(Arc::clone(&fontdb));
 7337|      1|        let (width, height) = measurer.measure_text("abc", -1.0, Some(700.0));
 7338|      1|        assert!(width > 0.0);
 7339|      1|        assert!(height > 0.0);
 7340|      1|    }
 7341|       |
 7342|       |    #[cfg(feature = "mermaid-quickjs")]
 7343|       |    #[test]
 7344|      1|    fn test_text_measurer_non_finite_font_size_uses_default() {
 7345|      1|        let mut fontdb = usvg::fontdb::Database::new();
 7346|      1|        fontdb.load_system_fonts();
 7347|      1|        let measurer = TextMeasurer::new(Arc::new(fontdb));
 7348|      1|        let (width, height) = measurer.measure_text("abc", f32::NAN, None);
 7349|      1|        assert!(width > 0.0);
 7350|      1|        assert!(height > 0.0);
 7351|      1|    }
 7352|       |
 7353|       |    #[cfg(feature = "mermaid-quickjs")]
 7354|       |    #[test]
 7355|      1|    fn test_text_measurer_missing_glyph_uses_fallback_advance() {
 7356|      1|        let mut fontdb = usvg::fontdb::Database::new();
 7357|      1|        fontdb.load_system_fonts();
 7358|      1|        let measurer = TextMeasurer::new(Arc::new(fontdb));
 7359|      1|        let (width, height) = measurer.measure_text("\u{10FFFF}", 16.0, None);
 7360|      1|        assert!(width > 0.0);
 7361|      1|        assert!(height > 0.0);
 7362|      1|    }
 7363|       |
 7364|       |    #[cfg(feature = "mermaid-quickjs")]
 7365|       |    #[test]
 7366|      1|    fn test_text_measurer_bold_adjusts_when_faces_match() {
 7367|      1|        let mut fontdb = usvg::fontdb::Database::new();
 7368|      1|        fontdb.load_system_fonts();
 7369|      1|        let fontdb = Arc::new(fontdb);
 7370|      1|        let face_id = fontdb.query(&usvg::fontdb::Query {
 7371|      1|            families: &[usvg::fontdb::Family::SansSerif],
 7372|      1|            ..Default::default()
 7373|      1|        });
 7374|      1|        let measurer = TextMeasurer {
 7375|      1|            fontdb: Arc::clone(&fontdb),
 7376|      1|            face_id,
 7377|      1|            bold_face_id: face_id,
 7378|      1|        };
 7379|      1|        let (width, height) = measurer.measure_text("Test", 16.0, Some(700.0));
 7380|      1|        assert!(width > 0.0);
 7381|      1|        assert!(height > 0.0);
 7382|      1|    }
 7383|       |
 7384|       |    #[cfg(feature = "mermaid-quickjs")]
 7385|       |    #[test]
 7386|      1|    fn test_text_measurer_empty_text_returns_zero() {
 7387|      1|        let mut fontdb = usvg::fontdb::Database::new();
 7388|      1|        fontdb.load_system_fonts();
 7389|      1|        let measurer = TextMeasurer::new(Arc::new(fontdb));
 7390|      1|        let (width, height) = measurer.measure_text("", 16.0, None);
 7391|      1|        assert_eq!(width, 0.0);
 7392|      1|        assert_eq!(height, 0.0);
 7393|      1|    }
 7394|       |
 7395|       |    #[cfg(feature = "mermaid-quickjs")]
 7396|       |    #[test]
 7397|      1|    fn test_text_measurer_fallback_handles_shorter_lines() {
 7398|      1|        let (width, height) = TextMeasurer::fallback_measure("abcd\na", 10.0);
 7399|      1|        assert!((width - 20.0).abs() < 0.01);
 7400|      1|        assert!((height - 24.0).abs() < 0.01);
 7401|      1|    }
 7402|       |
 7403|       |    #[cfg(feature = "mermaid-quickjs")]
 7404|       |    #[test]
 7405|      1|    fn test_text_measurer_kerning_adjusts_width_when_available() {
 7406|      1|        let mut fontdb = usvg::fontdb::Database::new();
 7407|      1|        fontdb.load_system_fonts();
 7408|      1|        let fontdb = Arc::new(fontdb);
 7409|      1|        let measurer = TextMeasurer::new(Arc::clone(&fontdb));
 7410|      1|        let (w_av, _) = measurer.measure_text("AV", 16.0, None);
 7411|      1|        let (w_a, _) = measurer.measure_text("A", 16.0, None);
 7412|      1|        let (w_v, _) = measurer.measure_text("V", 16.0, None);
 7413|      1|        assert!(w_av <= w_a + w_v);
 7414|      1|    }
 7415|       |
 7416|       |    #[cfg(feature = "mermaid-quickjs")]
 7417|       |    #[test]
 7418|      1|    fn test_scale_adjustment_for_svg_defaults() {
 7419|      1|        assert_eq!(MermaidWorker::scale_adjustment_for_svg("<svg></svg>"), 1.0);
 7420|      1|        assert_eq!(
 7421|      1|            MermaidWorker::scale_adjustment_for_svg("<svg aria-roledescription=\"er\"></svg>"),
 7422|       |            0.94
 7423|       |        );
 7424|      1|        assert_eq!(
 7425|      1|            MermaidWorker::scale_adjustment_for_svg("<svg aria-roledescription='er'></svg>"),
 7426|       |            0.94
 7427|       |        );
 7428|      1|    }
 7429|       |
 7430|       |    #[cfg(feature = "mermaid-quickjs")]
 7431|       |    #[test]
 7432|      1|    fn test_enqueue_mermaid_job_disconnected() {
 7433|      1|        let (job_tx, job_rx) = bounded(1);
 7434|      1|        drop(job_rx);
 7435|      1|        let (_result_tx, result_rx) = bounded(1);
 7436|      1|        let renderer = test_renderer_with_channels(Some(job_tx), result_rx);
 7437|      1|        let request = MermaidRequest {
 7438|      1|            svg_key: 1,
 7439|      1|            texture_key: "t".to_string(),
 7440|      1|            code: Some("graph TD; A-->B;".to_string()),
 7441|      1|            svg: None,
 7442|      1|            width_bucket: 120,
 7443|      1|            scale_bucket: 100,
 7444|      1|            viewport_width: 120,
 7445|      1|            viewport_height: 120,
 7446|      1|            bg: None,
 7447|      1|        };
 7448|      1|        assert_eq!(
 7449|      1|            renderer.enqueue_mermaid_job(request),
 7450|       |            Err(MermaidEnqueueError::Disconnected)
 7451|       |        );
 7452|      1|    }
 7453|       |
 7454|       |    #[cfg(feature = "mermaid-quickjs")]
 7455|       |    #[test]
 7456|      1|    fn test_render_block_enqueues_cached_svg() {
 7457|      1|        let _lock = env_lock();
 7458|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 7459|      1|        let (job_tx, job_rx) = bounded(1);
 7460|      1|        let (_result_tx, result_rx) = bounded(1);
 7461|      1|        let renderer = test_renderer_with_channels(Some(job_tx), result_rx);
 7462|      1|        let code = "graph TD; A-->B;";
 7463|      1|        let svg_key = MermaidRenderer::hash_str(code);
 7464|      1|        renderer
 7465|      1|            .mermaid_svg_cache
 7466|      1|            .borrow_mut()
 7467|      1|            .insert(svg_key, "<svg></svg>".to_string());
 7468|      1|        let ctx = egui::Context::default();
 7469|      1|        let input = egui::RawInput {
 7470|      1|            screen_rect: Some(egui::Rect::from_min_size(
 7471|      1|                egui::pos2(0.0, 0.0),
 7472|      1|                egui::vec2(240.0, 120.0),
 7473|      1|            )),
 7474|      1|            ..Default::default()
 7475|      1|        };
 7476|      1|        let mut rendered = false;
 7477|      1|        let _ = ctx.run(input, |ctx| {
 7478|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 7479|      1|                rendered = renderer.render_block(ui, code, 1.0, 14.0);
 7480|      1|            });
 7481|      1|        });
 7482|      1|        assert!(rendered);
 7483|      1|        let request = job_rx
 7484|      1|            .recv_timeout(std::time::Duration::from_secs(1))
 7485|      1|            .expect("request");
 7486|      1|        assert!(request.svg.is_some());
 7487|      1|        assert!(request.code.is_none());
 7488|      1|    }
 7489|       |
 7490|       |    #[cfg(feature = "mermaid-quickjs")]
 7491|       |    #[test]
 7492|      1|    fn test_spawn_mermaid_workers_reports_init_error() {
 7493|      1|        let _lock = env_lock();
 7494|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "1");
 7495|      1|        force_mermaid_worker_init_error_once();
 7496|      1|        let (job_tx, job_rx) = bounded(1);
 7497|      1|        let (result_tx, result_rx) = bounded(1);
 7498|      1|        let handles = MermaidRenderer::spawn_mermaid_workers(job_rx, result_tx);
 7499|      1|        let request = MermaidRequest {
 7500|      1|            svg_key: 2,
 7501|      1|            texture_key: "t".to_string(),
 7502|      1|            code: Some("graph TD; A-->B;".to_string()),
 7503|      1|            svg: None,
 7504|      1|            width_bucket: 120,
 7505|      1|            scale_bucket: 100,
 7506|      1|            viewport_width: 120,
 7507|      1|            viewport_height: 120,
 7508|      1|            bg: None,
 7509|      1|        };
 7510|      1|        job_tx.send(request).expect("send");
 7511|      1|        let result = result_rx
 7512|      1|            .recv_timeout(std::time::Duration::from_secs(1))
 7513|      1|            .expect("result");
 7514|      1|        assert!(result.error.is_some());
 7515|      1|        drop(job_tx);
 7516|      2|        for handle in handles {
                          ^1
 7517|      1|            let _ = handle.join();
 7518|      1|        }
 7519|      1|    }
 7520|       |
 7521|       |    #[cfg(feature = "mermaid-quickjs")]
 7522|       |    #[test]
 7523|      1|    fn test_spawn_mermaid_workers_reports_spawn_error() {
 7524|      1|        let _lock = env_lock();
 7525|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "1");
 7526|      1|        force_mermaid_thread_spawn_error_once();
 7527|      1|        let (_job_tx, job_rx) = bounded(1);
 7528|      1|        let (result_tx, _result_rx) = bounded(1);
 7529|      1|        let handles = MermaidRenderer::spawn_mermaid_workers(job_rx, result_tx);
 7530|      1|        assert!(handles.is_empty());
 7531|      1|    }
 7532|       |
 7533|       |    #[cfg(feature = "mermaid-quickjs")]
 7534|       |    #[test]
 7535|      1|    fn test_mermaid_worker_init_error_stages() {
 7536|      1|        let mut fontdb = usvg::fontdb::Database::new();
 7537|      1|        fontdb.load_system_fonts();
 7538|      1|        let fontdb = Arc::new(fontdb);
 7539|       |
 7540|      1|        force_mermaid_init_error_once(1);
 7541|      1|        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
 7542|      1|            .err()
 7543|      1|            .expect("stage 1 err");
 7544|      1|        assert!(err.contains("Mermaid text measure init error"));
 7545|       |
 7546|      1|        force_mermaid_init_error_once(2);
 7547|      1|        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
 7548|      1|            .err()
 7549|      1|            .expect("stage 2 err");
 7550|      1|        assert!(err.contains("Mermaid text measure init error"));
 7551|       |
 7552|      1|        force_mermaid_init_error_once(3);
 7553|      1|        let err = MermaidWorker::new(0, fontdb).err().expect("stage 3 err");
 7554|      1|        assert!(err.contains("Mermaid DOM shim"));
 7555|      1|    }
 7556|       |
 7557|       |    #[cfg(feature = "mermaid-quickjs")]
 7558|       |    #[test]
 7559|      1|    fn test_mermaid_worker_new_runtime_error_forced() {
 7560|      1|        let mut fontdb = usvg::fontdb::Database::new();
 7561|      1|        fontdb.load_system_fonts();
 7562|      1|        let fontdb = Arc::new(fontdb);
 7563|      1|        force_mermaid_runtime_error_once();
 7564|      1|        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
 7565|      1|            .err()
 7566|      1|            .expect("runtime err");
 7567|      1|        assert!(err.contains("Mermaid runtime init error"));
 7568|      1|    }
 7569|       |
 7570|       |    #[cfg(feature = "mermaid-quickjs")]
 7571|       |    #[test]
 7572|      1|    fn test_mermaid_runtime_flag_mismatch_restores() {
 7573|      1|        let handle = std::thread::spawn(|| {
 7574|      1|            force_mermaid_runtime_error_once();
 7575|      1|        });
 7576|      1|        handle.join().expect("flag thread");
 7577|       |
 7578|      1|        let _ = runtime_new_for_test().expect("runtime ok");
 7579|       |
 7580|      1|        let mut guard = FORCE_MERMAID_RUNTIME_ERROR
 7581|      1|            .lock()
 7582|      1|            .expect("mermaid runtime flag lock");
 7583|      1|        *guard = None;
 7584|      1|    }
 7585|       |
 7586|       |    #[cfg(feature = "mermaid-quickjs")]
 7587|       |    #[test]
 7588|      1|    fn test_mermaid_worker_new_context_error_forced() {
 7589|      1|        let mut fontdb = usvg::fontdb::Database::new();
 7590|      1|        fontdb.load_system_fonts();
 7591|      1|        let fontdb = Arc::new(fontdb);
 7592|      1|        force_mermaid_context_error_once();
 7593|      1|        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
 7594|      1|            .err()
 7595|      1|            .expect("context err");
 7596|      1|        assert!(err.contains("Mermaid context init error"));
 7597|      1|    }
 7598|       |
 7599|       |    #[cfg(feature = "mermaid-quickjs")]
 7600|       |    #[test]
 7601|      1|    fn test_mermaid_worker_new_utf8_error_forced() {
 7602|      1|        let mut fontdb = usvg::fontdb::Database::new();
 7603|      1|        fontdb.load_system_fonts();
 7604|      1|        let fontdb = Arc::new(fontdb);
 7605|      1|        force_mermaid_utf8_error_once();
 7606|      1|        let err = MermaidWorker::new(0, Arc::clone(&fontdb))
 7607|      1|            .err()
 7608|      1|            .expect("utf8 err");
 7609|      1|        assert!(err.contains("Mermaid JS is not valid UTF-8"));
 7610|      1|    }
 7611|       |
 7612|       |    #[cfg(feature = "mermaid-quickjs")]
 7613|       |    #[test]
 7614|      1|    fn test_mermaid_render_svg_forced_eval_error() {
 7615|      1|        let mut fontdb = usvg::fontdb::Database::new();
 7616|      1|        fontdb.load_system_fonts();
 7617|      1|        let fontdb = Arc::new(fontdb);
 7618|      1|        let mut worker = MermaidWorker::new(0, Arc::clone(&fontdb)).expect("worker init");
 7619|      1|        force_mermaid_render_eval_error_once();
 7620|      1|        let err = worker
 7621|      1|            .render_svg(1, "graph TD; A-->B;", 480, 320)
 7622|      1|            .unwrap_err();
 7623|      1|        assert!(!err.is_empty());
 7624|      1|    }
 7625|       |
 7626|       |    #[cfg(feature = "mermaid-quickjs")]
 7627|       |    #[test]
 7628|      1|    fn test_mermaid_render_svg_forced_call_error() {
 7629|      1|        let mut fontdb = usvg::fontdb::Database::new();
 7630|      1|        fontdb.load_system_fonts();
 7631|      1|        let fontdb = Arc::new(fontdb);
 7632|      1|        let mut worker = MermaidWorker::new(0, Arc::clone(&fontdb)).expect("worker init");
 7633|      1|        force_mermaid_render_call_error_once();
 7634|      1|        let err = worker
 7635|      1|            .render_svg(2, "graph TD; A-->B;", 480, 320)
 7636|      1|            .unwrap_err();
 7637|      1|        assert!(!err.is_empty());
 7638|      1|    }
 7639|       |
 7640|       |    #[cfg(feature = "mermaid-quickjs")]
 7641|       |    #[test]
 7642|      1|    fn test_parse_raw_svg_tree_invalid_svg_returns_error() {
 7643|      1|        let options = usvg::Options::default();
 7644|      1|        let err = MermaidWorker::parse_raw_svg_tree("<svg", &options).unwrap_err();
 7645|      1|        assert!(!err.is_empty());
 7646|      1|    }
 7647|       |
 7648|       |    #[cfg(feature = "mermaid-quickjs")]
 7649|       |    #[test]
 7650|      1|    fn test_rasterize_svg_forced_pixmap_alloc_error() {
 7651|      1|        let mut fontdb = usvg::fontdb::Database::new();
 7652|      1|        fontdb.load_system_fonts();
 7653|      1|        let fontdb = Arc::new(fontdb);
 7654|      1|        let worker = MermaidWorker::new(0, Arc::clone(&fontdb)).expect("worker init");
 7655|      1|        force_mermaid_pixmap_alloc_fail_once();
 7656|      1|        let err = worker
 7657|      1|            .rasterize_svg(
 7658|      1|                "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"10\" height=\"10\"><rect width=\"10\" height=\"10\"/></svg>",
 7659|       |                0,
 7660|       |                100,
 7661|      1|                None,
 7662|       |            )
 7663|      1|            .unwrap_err();
 7664|      1|        assert!(err.contains("Pixmap alloc failed"));
 7665|      1|    }
 7666|       |
 7667|       |    #[cfg(feature = "mermaid-quickjs")]
 7668|       |    #[test]
 7669|      1|    fn test_svg_helper_early_returns() {
 7670|      1|        assert_eq!(MermaidWorker::normalize_svg_size("<svg"), "<svg");
 7671|      1|        assert_eq!(
 7672|      1|            MermaidWorker::normalize_svg_size("<svg viewBox=\"bad\">"),
 7673|       |            "<svg viewBox=\"bad\">"
 7674|       |        );
 7675|      1|        assert_eq!(
 7676|      1|            MermaidWorker::replace_attr("<svg width=\"100", "width", "200"),
 7677|       |            "<svg width=\"100"
 7678|       |        );
 7679|      1|        assert_eq!(
 7680|      1|            MermaidWorker::upsert_attr("<svg width=\"100\"", "height", "200"),
 7681|       |            "<svg width=\"100\""
 7682|       |        );
 7683|      1|        assert!(MermaidWorker::flatten_svg_switches("<switch").is_none());
 7684|      1|        assert!(
 7685|      1|            MermaidWorker::fix_journey_section_text("<text journey-section", "#fff").is_none()
 7686|       |        );
 7687|      1|        assert!(MermaidWorker::fix_state_end_circles("<svg><g class=\"state-end\"").is_none());
 7688|      1|        assert!(MermaidWorker::fix_state_end_circles("<svg><g class=\"state-end\"></g").is_none());
 7689|      1|        assert!(MermaidWorker::fix_er_attribute_fills("<rect class=\"attributeBoxOdd\"").is_none());
 7690|      1|        assert_eq!(
 7691|      1|            MermaidWorker::replace_svg_attr("<svg>", "width", "1"),
 7692|       |            "<svg>"
 7693|       |        );
 7694|      1|        assert_eq!(
 7695|      1|            MermaidWorker::replace_svg_attr("<svg width=\"100>", "width", "1"),
 7696|       |            "<svg width=\"100>"
 7697|       |        );
 7698|      1|        assert_eq!(
 7699|      1|            MermaidWorker::insert_svg_attr("no svg", "width", "1"),
 7700|       |            "no svg"
 7701|       |        );
 7702|      1|    }
 7703|       |}


Coverage Report
Created: 2026-01-13 12:48
C:\language\mdmdview\src\markdown_renderer.rs:
    1|       |use crate::image_decode;
    2|       |use crate::mermaid_renderer::MermaidRenderer;
    3|       |use crate::table_support::{
    4|       |    compute_column_stats, derive_column_specs, ColumnPolicy, ColumnSpec, ColumnStat,
    5|       |    TableColumnContext, TableMetrics, WidthChange,
    6|       |};
    7|       |use crate::{emoji_assets, emoji_catalog};
    8|       |use anyhow::Result;
    9|       |use crossbeam_channel::{bounded, Receiver, Sender, TrySendError};
   10|       |use egui::{
   11|       |    text::{Galley, LayoutJob, TextWrapping},
   12|       |    Align, Color32, Context, FontSelection, Painter, RichText, Stroke, Vec2, Visuals,
   13|       |};
   14|       |use egui_extras::{Column, TableBuilder};
   15|       |use pulldown_cmark::{Alignment, Event, LinkType, Options, Parser, Tag};
   16|       |use std::cell::{Cell, RefCell};
   17|       |use std::collections::{hash_map::DefaultHasher, HashMap, HashSet, VecDeque};
   18|       |use std::hash::{Hash, Hasher};
   19|       |use std::ops::Range;
   20|       |use std::path::{Path, PathBuf};
   21|       |#[cfg(test)]
   22|       |use std::sync::atomic::{AtomicBool, Ordering};
   23|       |use std::sync::Arc;
   24|       |use std::time::{Duration, Instant, SystemTime};
   25|       |use syntect::easy::HighlightLines;
   26|       |use syntect::highlighting::ThemeSet;
   27|       |use syntect::parsing::SyntaxSet;
   28|       |use syntect::util::LinesWithEndings;
   29|       |use unicode_casefold::UnicodeCaseFold;
   30|       |use unicode_normalization::UnicodeNormalization;
   31|       |use unicode_segmentation::UnicodeSegmentation;
   32|       |
   33|       |#[derive(Clone, Copy, Default)]
   34|       |struct InlineStyle {
   35|       |    strong: bool,
   36|       |    italics: bool,
   37|       |    strike: bool,
   38|       |    color: Option<Color32>,
   39|       |}
   40|       |
   41|       |#[cfg(test)]
   42|       |thread_local! {
   43|       |    static FORCED_RENDER_ACTIONS: RefCell<HashSet<&'static str>> = RefCell::new(HashSet::new());
   44|       |    static FORCED_TABLE_POLICIES: RefCell<Option<Vec<ColumnPolicy>>> = const { RefCell::new(None) };
   45|       |    static FORCED_PARSE_ERROR: RefCell<bool> = const { RefCell::new(false) };
   46|       |}
   47|       |
   48|       |#[cfg(test)]
   49|       |static FORCE_THREAD_SPAWN_ERROR: AtomicBool = AtomicBool::new(false);
   50|       |
   51|       |#[cfg(test)]
   52|       |static FORCE_EMOJI_DECODE_ERROR: AtomicBool = AtomicBool::new(false);
   53|       |
   54|       |#[cfg(test)]
   55|    451|fn render_action_triggered(triggered: bool, action: &'static str) -> bool {
   56|    451|    triggered || FORCED_RENDER_ACTIONS.with(|actions| actions.borrow().contains(action))
                               ^449                  ^449           ^449             ^449     ^449
   57|    451|}
   58|       |
   59|       |#[cfg(not(test))]
   60|       |fn render_action_triggered(triggered: bool, _action: &'static str) -> bool {
   61|       |    triggered
   62|       |}
   63|       |
   64|       |#[cfg(test)]
   65|     19|fn take_forced_table_policies() -> Option<Vec<ColumnPolicy>> {
   66|     19|    FORCED_TABLE_POLICIES.with(|policies| policies.borrow_mut().take())
   67|     19|}
   68|       |
   69|       |#[cfg(test)]
   70|      4|pub(crate) fn force_parse_error_once() {
   71|      4|    FORCED_PARSE_ERROR.with(|flag| flag.replace(true));
   72|      4|}
   73|       |
   74|       |#[cfg(test)]
   75|      2|fn force_emoji_decode_error_once() {
   76|      2|    FORCE_EMOJI_DECODE_ERROR.store(true, Ordering::Relaxed);
   77|      2|}
   78|       |
   79|       |#[cfg(test)]
   80|    267|fn take_forced_parse_error() -> bool {
   81|    267|    FORCED_PARSE_ERROR.with(|flag| flag.replace(false))
   82|    267|}
   83|       |
   84|       |/// Font size configuration
   85|       |#[derive(Debug, Clone)]
   86|       |pub struct FontSizes {
   87|       |    pub body: f32,
   88|       |    pub h1: f32,
   89|       |    pub h2: f32,
   90|       |    pub h3: f32,
   91|       |    pub h4: f32,
   92|       |    pub h5: f32,
   93|       |    pub h6: f32,
   94|       |    pub code: f32,
   95|       |}
   96|       |
   97|       |impl Default for FontSizes {
   98|    389|    fn default() -> Self {
   99|    389|        Self {
  100|    389|            body: 14.0,
  101|    389|            h1: 28.0,
  102|    389|            h2: 24.0,
  103|    389|            h3: 20.0,
  104|    389|            h4: 18.0,
  105|    389|            h5: 16.0,
  106|    389|            h6: 14.0,
  107|    389|            code: 12.0,
  108|    389|        }
  109|    389|    }
  110|       |}
  111|       |
  112|       |/// Represents an inline text span with formatting
  113|       |#[derive(Debug, Clone)]
  114|       |pub enum InlineSpan {
  115|       |    Text(String),
  116|       |    Code(String),
  117|       |    Strong(String),
  118|       |    Emphasis(String),
  119|       |    Strikethrough(String),
  120|       |    Link {
  121|       |        text: String,
  122|       |        url: String,
  123|       |    },
  124|       |    Image {
  125|       |        src: String,
  126|       |        alt: String,
  127|       |        title: Option<String>,
  128|       |    },
  129|       |}
  130|       |
  131|       |#[cfg_attr(not(test), allow(dead_code))]
  132|       |#[derive(Debug, Clone)]
  133|       |enum CellFragment<'a> {
  134|       |    Text(&'a [InlineSpan]),
  135|       |    Emoji(String),
  136|       |    Image(&'a InlineSpan),
  137|       |}
  138|       |
  139|       |#[cfg_attr(not(test), allow(dead_code))]
  140|       |#[derive(Debug, Clone)]
  141|       |struct LayoutJobBuild {
  142|       |    job: LayoutJob,
  143|       |    #[allow(dead_code)]
  144|       |    plain_text: String,
  145|       |    #[cfg_attr(not(test), allow(dead_code))]
  146|       |    link_ranges: Vec<LinkRange>,
  147|       |}
  148|       |
  149|       |#[cfg_attr(not(test), allow(dead_code))]
  150|       |#[derive(Debug, Clone)]
  151|       |struct LinkRange {
  152|       |    char_range: Range<usize>,
  153|       |    url: String,
  154|       |}
  155|       |
  156|       |const TABLE_LAYOUT_CACHE_CAPACITY: usize = 512;
  157|       |const COLUMN_STATS_SAMPLE_ROWS: usize = 128;
  158|       |const PIPE_SENTINEL: char = '\u{1F}';
  159|       |const IMAGE_TEXTURE_CACHE_CAPACITY: usize = 256;
  160|       |const IMAGE_MAX_PENDING: usize = 64;
  161|       |const IMAGE_FAILURE_BACKOFF: Duration = Duration::from_secs(5);
  162|       |
  163|       |#[derive(Debug, Clone, Hash, PartialEq, Eq)]
  164|       |struct CellLayoutKey {
  165|       |    row: Option<usize>,
  166|       |    col: usize,
  167|       |    width: u32,
  168|       |    align: u8,
  169|       |    strong: bool,
  170|       |    text_color: [u8; 4],
  171|       |    highlight_hash: u64,
  172|       |    content_hash: u64,
  173|       |}
  174|       |
  175|       |struct CellLayoutCache {
  176|       |    entries: HashMap<CellLayoutKey, LayoutJobBuild>,
  177|       |    order: VecDeque<CellLayoutKey>,
  178|       |    hits: u64,
  179|       |    misses: u64,
  180|       |    capacity: usize,
  181|       |}
  182|       |
  183|       |#[derive(Clone)]
  184|       |struct ColumnStatsCacheEntry {
  185|       |    content_hash: u64,
  186|       |    stats: Vec<ColumnStat>,
  187|       |}
  188|       |
  189|       |impl CellLayoutCache {
  190|    368|    fn new(capacity: usize) -> Self {
  191|    368|        Self {
  192|    368|            entries: HashMap::new(),
  193|    368|            order: VecDeque::new(),
  194|    368|            hits: 0,
  195|    368|            misses: 0,
  196|    368|            capacity,
  197|    368|        }
  198|    368|    }
  199|       |
  200|    180|    fn get(&mut self, key: &CellLayoutKey) -> Option<LayoutJobBuild> {
  201|    180|        if let Some(build) = self.entries.get(key) {
                                  ^16
  202|     16|            self.hits += 1;
  203|     16|            Some(build.clone())
  204|       |        } else {
  205|    164|            self.misses += 1;
  206|    164|            None
  207|       |        }
  208|    180|    }
  209|       |
  210|    170|    fn insert(&mut self, key: CellLayoutKey, build: LayoutJobBuild) {
  211|    170|        if self.entries.len() >= self.capacity && !self.entries.contains_key(&key) {
                                                                ^3^3
  212|      3|            while self.entries.len() >= self.capacity {
  213|      2|                if let Some(old) = self.order.pop_front() {
                                          ^1
  214|      1|                    self.entries.remove(&old);
  215|      1|                } else {
  216|      1|                    break;
  217|       |                }
  218|       |            }
  219|    168|        }
  220|    977|        self.order.retain(|existing| existing != &key);
                      ^170       ^170
  221|    170|        self.order.push_back(key.clone());
  222|    170|        self.entries.insert(key, build);
  223|    170|    }
  224|       |
  225|    261|    fn clear(&mut self) {
  226|    261|        self.entries.clear();
  227|    261|        self.order.clear();
  228|    261|        self.hits = 0;
  229|    261|        self.misses = 0;
  230|    261|    }
  231|       |
  232|      4|    fn stats(&self) -> (u64, u64) {
  233|      4|        (self.hits, self.misses)
  234|      4|    }
  235|       |}
  236|       |
  237|       |#[derive(Debug, Clone)]
  238|       |pub struct ListItem {
  239|       |    pub blocks: Vec<MarkdownElement>,
  240|       |}
  241|       |
  242|       |/// Represents a rendered markdown element
  243|       |#[derive(Debug, Clone)]
  244|       |pub enum MarkdownElement {
  245|       |    Paragraph(Vec<InlineSpan>),
  246|       |    Header {
  247|       |        level: u8,
  248|       |        spans: Vec<InlineSpan>,
  249|       |        id: String,
  250|       |    },
  251|       |    CodeBlock {
  252|       |        language: Option<String>,
  253|       |        text: String,
  254|       |    },
  255|       |    List {
  256|       |        ordered: bool,
  257|       |        items: Vec<ListItem>,
  258|       |    }, // List items can contain block elements
  259|       |    Quote {
  260|       |        depth: u8,
  261|       |        blocks: Vec<MarkdownElement>,
  262|       |    },
  263|       |    HorizontalRule,
  264|       |    Table {
  265|       |        headers: Vec<Vec<InlineSpan>>,   // header cells as inline spans
  266|       |        rows: Vec<Vec<Vec<InlineSpan>>>, // rows -> cells -> spans
  267|       |        alignments: Vec<Alignment>,
  268|       |    },
  269|       |}
  270|       |
  271|       |/// Type alias for table parsing result
  272|       |type TableParseResult = (Vec<Vec<InlineSpan>>, Vec<Vec<Vec<InlineSpan>>>, usize);
  273|       |
  274|       |/// Type alias for quote blocks (nested markdown elements)
  275|       |type QuoteBlocks = Vec<MarkdownElement>;
  276|       |
  277|       |#[derive(Clone)]
  278|       |struct ImageCacheEntry {
  279|       |    texture: egui::TextureHandle,
  280|       |    size: [u32; 2],
  281|       |    modified: Option<SystemTime>,
  282|       |}
  283|       |
  284|       |struct ImageCache {
  285|       |    entries: HashMap<String, ImageCacheEntry>,
  286|       |    order: VecDeque<String>,
  287|       |    capacity: usize,
  288|       |}
  289|       |
  290|       |impl ImageCache {
  291|    368|    fn new(capacity: usize) -> Self {
  292|    368|        Self {
  293|    368|            entries: HashMap::new(),
  294|    368|            order: VecDeque::new(),
  295|    368|            capacity: capacity.max(1),
  296|    368|        }
  297|    368|    }
  298|       |
  299|     45|    fn get(&mut self, key: &str) -> Option<ImageCacheEntry> {
  300|     45|        let entry = self.entries.get(key).cloned();
  301|     45|        if entry.is_some() {
  302|     18|            self.touch(key);
  303|     27|        }
  304|     45|        entry
  305|     45|    }
  306|       |
  307|     17|    fn insert(&mut self, key: String, entry: ImageCacheEntry) {
  308|     17|        if self.entries.contains_key(&key) {
  309|      1|            self.entries.insert(key.clone(), entry);
  310|      1|            self.touch(&key);
  311|      1|            return;
  312|     16|        }
  313|     17|        while self.entries.len() >= self.capacity {
  314|      2|            if let Some(old) = self.order.pop_front() {
                                      ^1
  315|      1|                self.entries.remove(&old);
  316|      1|            } else {
  317|      1|                break;
  318|       |            }
  319|       |        }
  320|     16|        self.order.push_back(key.clone());
  321|     16|        self.entries.insert(key, entry);
  322|     17|    }
  323|       |
  324|      1|    fn remove(&mut self, key: &str) {
  325|      1|        self.entries.remove(key);
  326|      1|        self.order.retain(|entry| entry != key);
  327|      1|    }
  328|       |
  329|       |    #[cfg(test)]
  330|      5|    fn contains_key(&self, key: &str) -> bool {
  331|      5|        self.entries.contains_key(key)
  332|      5|    }
  333|       |
  334|     19|    fn touch(&mut self, key: &str) {
  335|     19|        self.order.retain(|entry| entry != key);
  336|     19|        self.order.push_back(key.to_string());
  337|     19|    }
  338|       |}
  339|       |
  340|       |struct ImageFailure {
  341|       |    last_attempt: Instant,
  342|       |}
  343|       |
  344|       |enum ImageLoadSource {
  345|       |    Embedded(&'static [u8]),
  346|       |    File(PathBuf),
  347|       |}
  348|       |
  349|       |struct ImageLoadRequest {
  350|       |    key: String,
  351|       |    source: ImageLoadSource,
  352|       |}
  353|       |
  354|       |enum ImageLoadResult {
  355|       |    Loaded {
  356|       |        key: String,
  357|       |        image: egui::ColorImage,
  358|       |        size: [u32; 2],
  359|       |        modified: Option<SystemTime>,
  360|       |    },
  361|       |    Failed {
  362|       |        key: String,
  363|       |    },
  364|       |}
  365|       |
  366|       |/// Markdown renderer with proper inline element handling
  367|       |pub struct MarkdownRenderer {
  368|       |    font_sizes: FontSizes,
  369|       |    syntax_set: SyntaxSet,
  370|       |    theme_set: ThemeSet,
  371|       |    emoji_textures: RefCell<HashMap<String, egui::TextureHandle>>,
  372|       |    image_textures: RefCell<ImageCache>,
  373|       |    image_pending: RefCell<HashSet<String>>,
  374|       |    image_failures: RefCell<HashMap<String, ImageFailure>>,
  375|       |    image_job_tx: Sender<ImageLoadRequest>,
  376|       |    image_result_rx: Receiver<ImageLoadResult>,
  377|       |    // Mapping of header id -> last rendered rect (for in-document navigation)
  378|       |    header_rects: RefCell<HashMap<String, egui::Rect>>,
  379|       |    // Last clicked internal anchor (e.g., "getting-started") for the app to consume
  380|       |    pending_anchor: RefCell<Option<String>>,
  381|       |    // Unique counter to avoid egui Id collisions for repeated links
  382|       |    link_counter: RefCell<u64>,
  383|       |    // Per-frame table counter to build stable table ids in render order
  384|       |    table_counter: RefCell<u64>,
  385|       |    // Per-frame rect for each top-level element in render order
  386|       |    element_rects: RefCell<Vec<egui::Rect>>,
  387|       |    // Optional highlight phrase (lowercased) for in-text highlighting
  388|       |    highlight_phrase: RefCell<Option<String>>,
  389|       |    // Cache for image/diagram textures
  390|       |    // Base directory used to resolve relative image paths
  391|       |    base_dir: RefCell<Option<PathBuf>>,
  392|       |    mermaid: MermaidRenderer,
  393|       |    table_layout_cache: RefCell<CellLayoutCache>,
  394|       |    table_metrics: RefCell<TableMetrics>,
  395|       |    column_stats_cache: RefCell<HashMap<u64, ColumnStatsCacheEntry>>,
  396|       |}
  397|       |
  398|       |impl Default for MarkdownRenderer {
  399|      1|    fn default() -> Self {
  400|      1|        Self::new()
  401|      1|    }
  402|       |}
  403|       |
  404|       |impl MarkdownRenderer {
  405|       |    #[cfg_attr(not(test), allow(dead_code))]
  406|    160|    fn cell_fragments<'a>(&'a self, spans: &'a [InlineSpan]) -> Vec<CellFragment<'a>> {
  407|    160|        if let Some(emoji) = self.cell_single_emoji(spans) {
                                  ^3
  408|      3|            return vec![CellFragment::Emoji(emoji)];
  409|    157|        }
  410|    157|        let mut fragments = Vec::new();
  411|    157|        let mut run_start: Option<usize> = None;
  412|    157|        let flush_run =
  413|      7|            |start: &mut Option<usize>, end: usize, fragments: &mut Vec<CellFragment<'a>>| {
  414|      7|                if let Some(run_begin) = start.take() {
                                          ^3
  415|      3|                    fragments.push(CellFragment::Text(&spans[run_begin..end]));
  416|      4|                }
  417|      7|            };
  418|       |
  419|    190|        for (idx, span) in spans.iter().enumerate() {
                                         ^157  ^157   ^157
  420|    190|            if matches!(span, InlineSpan::Image { .. }) {
                             ^183
  421|      7|                flush_run(&mut run_start, idx, &mut fragments);
  422|      7|                fragments.push(CellFragment::Image(span));
  423|      7|                continue;
  424|    183|            }
  425|       |
  426|    183|            if run_start.is_none() {
  427|    151|                run_start = Some(idx);
  428|    151|            }
                          ^32
  429|       |        }
  430|       |
  431|    157|        if let Some(start) = run_start {
                                  ^148
  432|    148|            fragments.push(CellFragment::Text(&spans[start..]));
  433|    148|        }
                      ^9
  434|       |
  435|    157|        fragments
  436|    160|    }
  437|       |
  438|    164|    fn cell_single_emoji(&self, spans: &[InlineSpan]) -> Option<String> {
  439|    164|        let mut text = String::new();
  440|    345|        for span in spans {
                          ^195
  441|    195|            match span {
  442|    172|                InlineSpan::Text(t)
  443|      8|                | InlineSpan::Strong(t)
  444|      1|                | InlineSpan::Emphasis(t)
  445|    181|                | InlineSpan::Strikethrough(t) => text.push_str(t),
                                                          ^0
  446|       |                InlineSpan::Code(_) | InlineSpan::Link { .. } | InlineSpan::Image { .. } => {
  447|     14|                    return None;
  448|       |                }
  449|       |            }
  450|       |        }
  451|       |
  452|    150|        let trimmed = text.trim();
  453|    150|        if trimmed.is_empty() {
  454|      5|            return None;
  455|    145|        }
  456|    145|        let mut graphemes = trimmed.graphemes(true);
  457|    145|        let first = graphemes.next()?;
                                                  ^0
  458|    145|        if graphemes.next().is_some() {
  459|    110|            return None;
  460|     35|        }
  461|     35|        self.emoji_key_for_grapheme(first)
  462|    164|    }
  463|       |
  464|    267|    fn highlight_segments(&self, text: &str, highlight: Option<&str>) -> Vec<(Range<usize>, bool)> {
  465|    267|        if text.is_empty() {
  466|      1|            return Vec::new();
  467|    266|        }
  468|    266|        let Some(needle) = highlight.filter(|h| !h.is_empty()) else {
                               ^39                             ^40^40
  469|    227|            return vec![(0..text.len(), false)];
  470|       |        };
  471|       |
  472|     39|        let mut folded = String::new();
  473|     39|        let mut folded_to_char: Vec<usize> = Vec::new();
  474|     39|        let mut char_ranges: Vec<(usize, usize)> = Vec::new();
  475|    234|        for (char_idx, (byte_idx, ch)) in text.char_indices().enumerate() {
                                                        ^39  ^39            ^39
  476|    234|            let folded_piece: String = ch.to_string().case_fold().nfkc().collect();
  477|    234|            let before = folded.len();
  478|    234|            folded.push_str(&folded_piece);
  479|    234|            let after = folded.len();
  480|    237|            for _ in before..after {
                                   ^234    ^234
  481|    237|                folded_to_char.push(char_idx);
  482|    237|            }
  483|    234|            char_ranges.push((byte_idx, byte_idx + ch.len_utf8()));
  484|       |        }
  485|       |
  486|     39|        let mut segments = Vec::new();
  487|     39|        let mut rendered_until = 0usize;
  488|     39|        let mut search_at = 0usize;
  489|     53|        while let Some(pos) = folded[search_at..].find(needle) {
                                     ^14
  490|     14|            let abs = search_at + pos;
  491|     14|            let start_char_idx = folded_to_char[abs];
  492|     14|            let (start_byte, _) = char_ranges[start_char_idx];
  493|     14|            if start_byte > rendered_until {
  494|      2|                segments.push((rendered_until..start_byte, false));
  495|     12|            }
  496|     14|            let match_end = abs + needle.len();
  497|     14|            let end_char_idx = folded_to_char[match_end.saturating_sub(1)];
  498|     14|            let (_, end_byte) = char_ranges[end_char_idx];
  499|     14|            segments.push((start_byte..end_byte, true));
  500|     14|            rendered_until = end_byte;
  501|     14|            search_at = match_end;
  502|       |        }
  503|       |
  504|     39|        if rendered_until < text.len() {
  505|     33|            segments.push((rendered_until..text.len(), false));
  506|     33|        }
                      ^6
  507|       |
  508|     39|        segments
  509|    267|    }
  510|       |
  511|       |    #[cfg_attr(not(test), allow(dead_code))]
  512|    207|    fn build_layout_job(
  513|    207|        &self,
  514|    207|        style: &egui::Style,
  515|    207|        spans: &[InlineSpan],
  516|    207|        wrap_width: f32,
  517|    207|        strong_override: bool,
  518|    207|        halign: Align,
  519|    207|    ) -> LayoutJobBuild {
  520|    207|        let mut job = LayoutJob {
  521|    207|            wrap: TextWrapping {
  522|    207|                max_width: wrap_width.max(1.0),
  523|    207|                ..Default::default()
  524|    207|            },
  525|    207|            break_on_newline: true,
  526|    207|            halign,
  527|    207|            ..Default::default()
  528|    207|        };
  529|       |
  530|    207|        let highlight = self
  531|    207|            .highlight_phrase
  532|    207|            .borrow()
  533|    207|            .clone()
  534|    207|            .filter(|s| !s.is_empty());
                                       ^10^10
  535|       |
  536|    207|        let mut plain_text = String::new();
  537|    207|        let mut link_ranges = Vec::new();
  538|    207|        let mut job_char_offset = 0usize;
  539|       |
  540|    450|        for span in spans {
                          ^243
  541|    243|            match span {
  542|      1|                InlineSpan::Image { .. } => {}
  543|      1|                InlineSpan::Code(code) => {
  544|      1|                    job_char_offset +=
  545|      1|                        self.append_code_span(style, &mut job, &mut plain_text, code);
  546|      1|                }
  547|     18|                InlineSpan::Link { text, url } => {
  548|     18|                    let inline_style = InlineStyle {
  549|     18|                        strong: strong_override,
  550|     18|                        color: Some(if Self::is_external_url(url) {
  551|     11|                            Color32::from_rgb(120, 190, 255)
  552|       |                        } else {
  553|      7|                            Color32::LIGHT_BLUE
  554|       |                        }),
  555|     18|                        ..Default::default()
  556|       |                    };
  557|     18|                    let mut normalized = self.fix_unicode_chars(text);
  558|     18|                    normalized = Self::expand_shortcodes(&normalized);
  559|     18|                    normalized = Self::expand_superscripts(&normalized);
  560|     18|                    let appended = self.append_text_sections(
  561|     18|                        style,
  562|     18|                        &mut job,
  563|     18|                        &mut plain_text,
  564|     18|                        &normalized,
  565|     18|                        self.font_sizes.body,
  566|     18|                        inline_style,
  567|     18|                        highlight.as_deref(),
  568|       |                    );
  569|     18|                    if appended > 0 {
  570|     17|                        let start_char = job_char_offset;
  571|     17|                        job_char_offset += appended;
  572|     17|                        link_ranges.push(LinkRange {
  573|     17|                            char_range: start_char..job_char_offset,
  574|     17|                            url: url.clone(),
  575|     17|                        });
  576|     17|                    }
                                  ^1
  577|       |                }
  578|      7|                InlineSpan::Strong(text) => {
  579|      7|                    job_char_offset += self.append_plain_span(
  580|      7|                        style,
  581|      7|                        &mut job,
  582|      7|                        &mut plain_text,
  583|      7|                        text,
  584|      7|                        InlineStyle {
  585|      7|                            strong: true,
  586|      7|                            ..Default::default()
  587|      7|                        },
  588|      7|                        highlight.as_deref(),
  589|      7|                    );
  590|      7|                }
  591|      1|                InlineSpan::Emphasis(text) => {
  592|      1|                    job_char_offset += self.append_plain_span(
  593|      1|                        style,
  594|      1|                        &mut job,
  595|      1|                        &mut plain_text,
  596|      1|                        text,
  597|      1|                        InlineStyle {
  598|      1|                            italics: true,
  599|      1|                            strong: strong_override,
  600|      1|                            ..Default::default()
  601|      1|                        },
  602|      1|                        highlight.as_deref(),
  603|      1|                    );
  604|      1|                }
  605|      1|                InlineSpan::Strikethrough(text) => {
  606|      1|                    job_char_offset += self.append_plain_span(
  607|      1|                        style,
  608|      1|                        &mut job,
  609|      1|                        &mut plain_text,
  610|      1|                        text,
  611|      1|                        InlineStyle {
  612|      1|                            strike: true,
  613|      1|                            strong: strong_override,
  614|      1|                            ..Default::default()
  615|      1|                        },
  616|      1|                        highlight.as_deref(),
  617|      1|                    );
  618|      1|                }
  619|    214|                InlineSpan::Text(text) => {
  620|    214|                    job_char_offset += self.append_plain_span(
  621|    214|                        style,
  622|    214|                        &mut job,
  623|    214|                        &mut plain_text,
  624|    214|                        text,
  625|    214|                        InlineStyle {
  626|    214|                            strong: strong_override,
  627|    214|                            ..Default::default()
  628|    214|                        },
  629|    214|                        highlight.as_deref(),
  630|    214|                    );
  631|    214|                }
  632|       |            }
  633|       |        }
  634|       |
  635|    207|        LayoutJobBuild {
  636|    207|            job,
  637|    207|            plain_text,
  638|    207|            link_ranges,
  639|    207|        }
  640|    207|    }
  641|       |
  642|    224|    fn append_plain_span(
  643|    224|        &self,
  644|    224|        style: &egui::Style,
  645|    224|        job: &mut LayoutJob,
  646|    224|        plain_text: &mut String,
  647|    224|        text: &str,
  648|    224|        inline_style: InlineStyle,
  649|    224|        highlight: Option<&str>,
  650|    224|    ) -> usize {
  651|    224|        if text.is_empty() {
  652|      1|            return 0;
  653|    223|        }
  654|    223|        let mut normalized = self.fix_unicode_chars(text);
  655|    223|        normalized = Self::expand_shortcodes(&normalized);
  656|    223|        normalized = Self::expand_superscripts(&normalized);
  657|    223|        self.append_text_sections(
  658|    223|            style,
  659|    223|            job,
  660|    223|            plain_text,
  661|    223|            &normalized,
  662|    223|            self.font_sizes.body,
  663|    223|            inline_style,
  664|    223|            highlight,
  665|       |        )
  666|    224|    }
  667|       |
  668|      3|    fn append_code_span(
  669|      3|        &self,
  670|      3|        style: &egui::Style,
  671|      3|        job: &mut LayoutJob,
  672|      3|        plain_text: &mut String,
  673|      3|        code: &str,
  674|      3|    ) -> usize {
  675|      3|        if code.is_empty() {
  676|      1|            return 0;
  677|      2|        }
  678|      2|        plain_text.push_str(code);
  679|      2|        let visuals = &style.visuals;
  680|      2|        let (bg, fg) = if visuals.dark_mode {
  681|      1|            (
  682|      1|                Color32::from_rgb(30, 30, 30),
  683|      1|                Color32::from_rgb(180, 255, 180),
  684|      1|            )
  685|       |        } else {
  686|      1|            (Color32::WHITE, Color32::from_rgb(60, 80, 150))
  687|       |        };
  688|      2|        let rich = RichText::new(code.to_string())
  689|      2|            .size(self.font_sizes.code)
  690|      2|            .monospace()
  691|      2|            .background_color(bg)
  692|      2|            .color(fg);
  693|      2|        rich.append_to(job, style, FontSelection::Default, Align::LEFT);
  694|      2|        code.chars().count()
  695|      3|    }
  696|       |
  697|       |    #[allow(clippy::too_many_arguments)]
  698|    243|    fn append_text_sections(
  699|    243|        &self,
  700|    243|        style: &egui::Style,
  701|    243|        job: &mut LayoutJob,
  702|    243|        plain_text: &mut String,
  703|    243|        text: &str,
  704|    243|        font_size: f32,
  705|    243|        inline_style: InlineStyle,
  706|    243|        highlight: Option<&str>,
  707|    243|    ) -> usize {
  708|    243|        if text.is_empty() {
  709|      2|            return 0;
  710|    241|        }
  711|    241|        plain_text.push_str(text);
  712|    241|        let char_count = text.chars().count();
  713|    241|        let visuals = &style.visuals;
  714|    241|        let segments = self.highlight_segments(text, highlight);
  715|    485|        for (range, highlighted) in segments {
                           ^244   ^244
  716|    244|            let slice = &text[range];
  717|    244|            let mut rich = RichText::new(slice.to_string()).size(font_size);
  718|    244|            if inline_style.strong {
  719|    100|                rich = rich.strong();
  720|    144|            }
  721|    244|            if inline_style.italics {
  722|      1|                rich = rich.italics();
  723|    243|            }
  724|    244|            if inline_style.strike {
  725|      1|                rich = rich.strikethrough();
  726|    243|            }
  727|    244|            let mut text_color = inline_style.color;
  728|    244|            if highlighted {
  729|      3|                rich = rich.background_color(visuals.selection.bg_fill);
  730|      3|                if text_color.is_none() {
  731|      2|                    text_color = Some(visuals.selection.stroke.color);
  732|      2|                }
                              ^1
  733|    241|            } else if text_color.is_none() && inline_style.strong {
                                                            ^224
  734|    100|                if let Some(override_color) = visuals.override_text_color {
                                          ^1
  735|      1|                    text_color = Some(override_color);
  736|     99|                }
  737|    141|            }
  738|    244|            if let Some(color) = text_color {
                                      ^21
  739|     21|                rich = rich.color(color);
  740|    223|            }
  741|    244|            rich.append_to(job, style, FontSelection::Default, Align::LEFT);
  742|       |        }
  743|    241|        char_count
  744|    243|    }
  745|       |
  746|       |    /// Create a new markdown renderer
  747|    365|    pub fn new() -> Self {
  748|    365|        let mermaid = MermaidRenderer::new();
  749|    365|        let (image_job_tx, image_job_rx) = bounded(IMAGE_MAX_PENDING.max(1));
  750|    365|        let (image_result_tx, image_result_rx) = bounded(IMAGE_MAX_PENDING.max(1) * 2);
  751|    365|        Self::spawn_image_loader(image_job_rx, image_result_tx);
  752|    365|        Self {
  753|    365|            font_sizes: FontSizes::default(),
  754|    365|            syntax_set: SyntaxSet::load_defaults_newlines(),
  755|    365|            theme_set: ThemeSet::load_defaults(),
  756|    365|            emoji_textures: RefCell::new(HashMap::new()),
  757|    365|            image_textures: RefCell::new(ImageCache::new(IMAGE_TEXTURE_CACHE_CAPACITY)),
  758|    365|            image_pending: RefCell::new(HashSet::new()),
  759|    365|            image_failures: RefCell::new(HashMap::new()),
  760|    365|            image_job_tx,
  761|    365|            image_result_rx,
  762|    365|            header_rects: RefCell::new(HashMap::new()),
  763|    365|            pending_anchor: RefCell::new(None),
  764|    365|            link_counter: RefCell::new(0),
  765|    365|            table_counter: RefCell::new(0),
  766|    365|            element_rects: RefCell::new(Vec::new()),
  767|    365|            highlight_phrase: RefCell::new(None),
  768|    365|            base_dir: RefCell::new(None),
  769|    365|            mermaid,
  770|    365|            table_layout_cache: RefCell::new(CellLayoutCache::new(TABLE_LAYOUT_CACHE_CAPACITY)),
  771|    365|            table_metrics: RefCell::new(TableMetrics::default()),
  772|    365|            column_stats_cache: RefCell::new(HashMap::new()),
  773|    365|        }
  774|    365|    }
  775|       |
  776|    370|    fn spawn_image_loader(job_rx: Receiver<ImageLoadRequest>, result_tx: Sender<ImageLoadResult>) {
  777|    370|        if let Err(err) = Self::spawn_named_thread("mdmdview-image-loader", move || {
                                 ^1                                                               ^369
  778|    369|            for request in job_rx.iter() {
                              ^16
  779|     16|                let ImageLoadRequest { key, source } = request;
  780|     16|                let result = match source {
  781|      9|                    ImageLoadSource::Embedded(bytes) => {
  782|      9|                        match image_decode::bytes_to_color_image_guess(bytes, None) {
  783|      8|                            Some((image, w, h)) => ImageLoadResult::Loaded {
  784|      8|                                key,
  785|      8|                                image,
  786|      8|                                size: [w, h],
  787|      8|                                modified: None,
  788|      8|                            },
  789|      1|                            None => ImageLoadResult::Failed { key },
  790|       |                        }
  791|       |                    }
  792|      7|                    ImageLoadSource::File(path) => {
  793|      7|                        if !path.exists() {
  794|      1|                            ImageLoadResult::Failed { key }
  795|       |                        } else {
  796|      6|                            match std::fs::read(&path) {
  797|      5|                                Ok(bytes) => {
  798|      5|                                    let modified = Self::disk_image_timestamp(&path);
  799|      5|                                    match image_decode::bytes_to_color_image_guess(&bytes, None) {
  800|      4|                                        Some((image, w, h)) => ImageLoadResult::Loaded {
  801|      4|                                            key,
  802|      4|                                            image,
  803|      4|                                            size: [w, h],
  804|      4|                                            modified,
  805|      4|                                        },
  806|      1|                                        None => ImageLoadResult::Failed { key },
  807|       |                                    }
  808|       |                                }
  809|      1|                                Err(_) => ImageLoadResult::Failed { key },
  810|       |                            }
  811|       |                        }
  812|       |                    }
  813|       |                };
  814|     16|                let _ = result_tx.send(result);
  815|       |            }
  816|    369|        }) {
  817|      1|            eprintln!("Failed to start image loader thread: {err}");
  818|    369|        }
  819|    370|    }
  820|       |
  821|    370|    fn spawn_named_thread(
  822|    370|        name: &str,
  823|    370|        f: impl FnOnce() + Send + 'static,
  824|    370|    ) -> std::io::Result<std::thread::JoinHandle<()>> {
  825|       |        #[cfg(test)]
  826|    370|        if FORCE_THREAD_SPAWN_ERROR.swap(false, Ordering::Relaxed) {
  827|      1|            return Err(std::io::Error::new(
  828|      1|                std::io::ErrorKind::Other,
  829|      1|                "forced thread spawn failure",
  830|      1|            ));
  831|    369|        }
  832|    369|        std::thread::Builder::new().name(name.to_string()).spawn(f)
  833|    370|    }
  834|       |
  835|       |    #[cfg(test)]
  836|      1|    fn force_thread_spawn_error_for_test() {
  837|      1|        FORCE_THREAD_SPAWN_ERROR.store(true, Ordering::Relaxed);
  838|      1|    }
  839|       |
  840|       |    /// UI scale factor derived from body font size relative to default.
  841|       |    /// Used to scale non-text elements (e.g., images) consistently with zoom.
  842|     13|    fn ui_scale(&self) -> f32 {
  843|     13|        let default_body = FontSizes::default().body;
  844|     13|        (self.font_sizes.body / default_body).clamp(0.5, 4.0)
  845|     13|    }
  846|       |
  847|       |    /// Get current font sizes
  848|      2|    pub fn font_sizes(&self) -> &FontSizes {
  849|      2|        &self.font_sizes
  850|      2|    }
  851|       |
  852|    312|    fn escape_table_pipes_in_inline_code(markdown: &str) -> String {
  853|    312|        let mut out = String::with_capacity(markdown.len());
  854|    312|        let mut in_table = false;
  855|    312|        let mut table_blockquote_level: Option<usize> = None;
  856|    312|        let mut table_list_indent: Option<usize> = None;
  857|    312|        let mut in_fenced_block = false;
  858|    312|        let mut fence_char = '\0';
  859|    312|        let mut fence_len = 0usize;
  860|    312|        let mut fence_blockquote_level: Option<usize> = None;
  861|       |
  862|    312|        let lines: Vec<&str> = markdown.split_inclusive('\n').collect();
  863|    312|        let mut i = 0;
  864|  6.54k|        while i < lines.len() {
  865|  6.22k|            let line = lines[i];
  866|  6.22k|            let (blockquote_level, rest) = Self::table_line_info(line);
  867|  6.22k|            let list_info = Self::list_marker_info(rest);
  868|  6.22k|            let mut list_indent = list_info.map(|(_, _, content_indent)| content_indent);
  869|  6.22k|            let mut list_stripped = list_info.map(|(content, _, _)| content).unwrap_or(rest);
  870|  6.22k|            let mut list_marker_present = list_info.is_some();
  871|  6.22k|            if !list_marker_present && i > 0 {
                                                     ^4.17k
  872|  3.90k|                let parent_list_indent =
  873|  3.90k|                    Self::parent_list_indent_for_line(&lines, i, blockquote_level, rest);
  874|  3.90k|                if let Some(parent_indent) = parent_list_indent {
                                          ^89
  875|     18|                    if let Some((content, _indent_after, content_indent, leading_spaces)) =
  876|     89|                        Self::list_marker_info_any_indent(rest)
  877|       |                    {
  878|     18|                        if leading_spaces < parent_indent + 4 {
  879|     13|                            list_marker_present = true;
  880|     13|                            list_indent = Some(content_indent);
  881|     13|                            list_stripped = content;
  882|     13|                        }
                                      ^5
  883|     71|                    }
  884|     89|                    if list_indent.is_none() {
  885|     76|                        let code_strip = Self::strip_indent_columns(rest, parent_indent + 4);
  886|     76|                        if code_strip.is_none() {
  887|     57|                            list_indent = Some(parent_indent);
  888|     57|                        }
                                      ^19
  889|     13|                    }
  890|  3.81k|                }
  891|  2.32k|            }
  892|  6.22k|            let (fence_line_level, fence_line_rest) = if list_marker_present {
  893|  2.06k|                let (nested_level, nested_rest) = Self::table_line_info(list_stripped);
  894|  2.06k|                (blockquote_level + nested_level, nested_rest)
  895|       |            } else {
  896|  4.16k|                Self::table_line_info_with_list(line, list_indent)
  897|       |            };
  898|  6.22k|            let trimmed_fence = fence_line_rest.trim_start();
  899|       |
  900|  6.22k|            if in_fenced_block {
  901|    120|                let fence_end = fence_blockquote_level == Some(fence_line_level)
  902|    119|                    && Self::is_fence_end(trimmed_fence, fence_char, fence_len);
  903|    120|                if fence_end {
  904|     16|                    in_fenced_block = false;
  905|     16|                    fence_char = '\0';
  906|     16|                    fence_len = 0;
  907|     16|                    fence_blockquote_level = None;
  908|    104|                }
  909|    120|                out.push_str(line);
  910|    120|                i += 1;
  911|    120|                continue;
  912|  6.10k|            }
  913|       |
  914|  6.10k|            if let Some((ch, len)) = Self::fence_start(trimmed_fence) {
                                       ^16 ^16
  915|     16|                in_fenced_block = true;
  916|     16|                fence_char = ch;
  917|     16|                fence_len = len;
  918|     16|                fence_blockquote_level = Some(fence_line_level);
  919|     16|                out.push_str(line);
  920|     16|                i += 1;
  921|     16|                continue;
  922|  6.09k|            }
  923|       |
  924|  6.09k|            if in_table {
  925|    264|                if let Some((level, rest)) = Self::table_line_info_in_list(line, table_list_indent)
                                           ^260   ^260
  926|       |                {
  927|    260|                    if table_blockquote_level == Some(level) {
  928|    259|                        let candidate = Some(rest);
  929|    259|                        if candidate.is_some_and(Self::is_table_row_candidate) {
  930|    236|                            out.push_str(&Self::escape_pipes_in_inline_code_line(line));
  931|    236|                            i += 1;
  932|    236|                            continue;
  933|     23|                        }
  934|      1|                    }
  935|      4|                }
  936|     28|                in_table = false;
  937|     28|                table_blockquote_level = None;
  938|     28|                table_list_indent = None;
  939|     28|                out.push_str(line);
  940|     28|                i += 1;
  941|     28|                continue;
  942|  5.82k|            }
  943|       |
  944|  5.82k|            if i + 1 < lines.len() {
  945|  5.56k|                let header_from_list_marker = list_marker_present;
  946|  5.56k|                let (level, rest) = if list_marker_present {
  947|  2.06k|                    let (nested_level, nested_rest) = Self::table_line_info(list_stripped);
  948|  2.06k|                    (blockquote_level + nested_level, nested_rest)
  949|       |                } else {
  950|  3.50k|                    Self::table_line_info_with_list(line, list_indent)
  951|       |                };
  952|  5.56k|                let next_info = if list_indent.is_some() {
  953|  2.07k|                    Self::table_line_info_in_list(lines[i + 1], list_indent)
  954|       |                } else {
  955|  3.49k|                    Some(Self::table_line_info(lines[i + 1]))
  956|       |                };
  957|  5.56k|                let header_line = if header_from_list_marker {
  958|  2.06k|                    let (_, stripped) = Self::table_line_info(list_stripped);
  959|  2.06k|                    stripped
  960|       |                } else {
  961|  3.50k|                    rest
  962|       |                };
  963|       |
  964|  5.56k|                if let Some((next_level, next_rest)) = next_info {
                                           ^3.56k      ^3.56k
  965|  3.56k|                    if level == next_level && Self::is_table_row_candidate(header_line) {
                                                            ^3.54k                       ^3.54k
  966|     74|                        let delimiter_line = Some(next_rest);
  967|     74|                        if delimiter_line.is_some_and(Self::is_table_delimiter_line) {
  968|     68|                            if !header_from_list_marker && i > 0 {
                                                                         ^51
  969|     43|                                let (prev_level, prev_rest) =
  970|     43|                                    Self::table_line_info_with_list(lines[i - 1], list_indent);
  971|     43|                                if prev_level == level && !prev_rest.trim().is_empty() {
                                                                        ^42
  972|     10|                                    let prefix_len = line.len().saturating_sub(rest.len());
  973|     10|                                    out.push_str(&line[..prefix_len]);
  974|     10|                                    let newline =
  975|     10|                                        if line.ends_with("\r\n") { "\r\n" } else { "\n" };
                                                                                  ^1              ^9
  976|     10|                                    out.push_str(newline);
  977|     33|                                }
  978|     25|                            }
  979|     68|                            out.push_str(&Self::escape_pipes_in_inline_code_line(line));
  980|     68|                            out.push_str(lines[i + 1]);
  981|     68|                            in_table = true;
  982|     68|                            table_blockquote_level = Some(level);
  983|     68|                            table_list_indent = list_indent;
  984|     68|                            i += 2;
  985|     68|                            continue;
  986|      6|                        }
  987|  3.49k|                    }
  988|  2.00k|                }
  989|    259|            }
  990|       |
  991|  5.76k|            out.push_str(line);
  992|  5.76k|            i += 1;
  993|       |        }
  994|       |
  995|    312|        out
  996|    312|    }
  997|       |
  998|    308|    fn escape_pipes_in_inline_code_line(line: &str) -> String {
  999|    308|        if !line.contains('|') || !line.contains('`') {
                                                ^307
 1000|    127|            return line.to_string();
 1001|    181|        }
 1002|    181|        let mut out: Vec<char> = Vec::with_capacity(line.len());
 1003|    181|        let mut in_code = false;
 1004|    181|        let mut delimiter_len = 0usize;
 1005|    181|        let mut pending_pipes: Vec<usize> = Vec::new();
 1006|    181|        let mut backslash_run = 0usize;
 1007|    181|        let mut chars = line.chars().peekable();
 1008|       |
 1009|  6.14k|        while let Some(ch) = chars.next() {
                                     ^5.96k
 1010|  5.96k|            if ch == '\\' {
 1011|      2|                backslash_run += 1;
 1012|      2|                out.push(ch);
 1013|      2|                continue;
 1014|  5.95k|            }
 1015|       |
 1016|  5.95k|            let escaped = !in_code && backslash_run % 2 == 1;
                                                    ^4.85k
 1017|  5.95k|            backslash_run = 0;
 1018|       |
 1019|  5.95k|            if ch == '`' {
 1020|    361|                if escaped {
 1021|      2|                    out.push('`');
 1022|      2|                    continue;
 1023|    359|                }
 1024|    359|                let mut run_len = 1usize;
 1025|    363|                while matches!(chars.peek(), Some('`')) {
                                    ^359
 1026|      4|                    chars.next();
 1027|      4|                    run_len += 1;
 1028|      4|                }
 1029|    359|                if in_code {
 1030|    179|                    if run_len == delimiter_len {
 1031|    178|                        in_code = false;
 1032|    178|                        delimiter_len = 0;
 1033|    178|                        pending_pipes.clear();
 1034|    178|                    }
                                  ^1
 1035|    180|                } else {
 1036|    180|                    in_code = true;
 1037|    180|                    delimiter_len = run_len;
 1038|    180|                    pending_pipes.clear();
 1039|    180|                }
 1040|    359|                out.extend(std::iter::repeat_n('`', run_len));
 1041|    359|                continue;
 1042|  5.59k|            }
 1043|       |
 1044|  5.59k|            if in_code && ch == '|' {
                                        ^927
 1045|     54|                pending_pipes.push(out.len());
 1046|     54|                out.push(PIPE_SENTINEL);
 1047|  5.54k|            } else {
 1048|  5.54k|                out.push(ch);
 1049|  5.54k|            }
 1050|       |        }
 1051|       |
 1052|    181|        if in_code {
 1053|      5|            for idx in pending_pipes {
                              ^3
 1054|      3|                out[idx] = '|';
 1055|      3|            }
 1056|    179|        }
 1057|       |
 1058|    181|        out.into_iter().collect()
 1059|    308|    }
 1060|       |
 1061|     39|    fn is_html_line_break(html: &str) -> bool {
 1062|     39|        let trimmed = html.trim();
 1063|     39|        if trimmed.len() < 4 {
 1064|      3|            return false;
 1065|     36|        }
 1066|     36|        let normalized = trimmed.to_ascii_lowercase();
 1067|     36|        if !normalized.starts_with("<br") || !normalized.ends_with('>') {
                                                           ^31
 1068|      6|            return false;
 1069|     30|        }
 1070|     30|        let rest = &normalized[3..];
 1071|     30|        let first = rest.chars().next();
 1072|      7|        match first {
 1073|     19|            Some('>') => true,
 1074|      4|            Some('/') => rest[1..].trim_start().starts_with('>'),
 1075|      7|            Some(ch) if ch.is_whitespace() => true,
                               ^6                      ^6   ^6
 1076|      1|            _ => false,
 1077|       |        }
 1078|     39|    }
 1079|       |
 1080|     35|    fn tab_advance(col: usize) -> usize {
 1081|     35|        let rem = col % 4;
 1082|     35|        if rem == 0 {
 1083|     32|            4
 1084|       |        } else {
 1085|      3|            4 - rem
 1086|       |        }
 1087|     35|    }
 1088|       |
 1089|  3.88k|    fn is_indented_code_line(line: &str) -> bool {
 1090|  3.88k|        let mut col = 0usize;
 1091|  3.93k|        for ch in line.chars() {
                                ^3.88k^3.88k
 1092|  3.93k|            match ch {
 1093|       |                ' ' => {
 1094|     76|                    col += 1;
 1095|     76|                    if col >= 4 {
 1096|     17|                        return true;
 1097|     59|                    }
 1098|       |                }
 1099|       |                '\t' => {
 1100|      1|                    col += Self::tab_advance(col);
 1101|      1|                    return col >= 4;
 1102|       |                }
 1103|  3.86k|                _ => break,
 1104|       |            }
 1105|       |        }
 1106|  3.86k|        col >= 4
 1107|  3.88k|    }
 1108|       |
 1109|  36.7k|    fn table_line_info(line: &str) -> (usize, &str) {
 1110|  36.7k|        let mut rest = line;
 1111|  36.7k|        let mut level = 0usize;
 1112|       |        loop {
 1113|  37.1k|            let bytes = rest.as_bytes();
 1114|  37.1k|            let mut idx = 0usize;
 1115|  39.3k|            while idx < bytes.len() && idx < 3 && bytes[idx] == b' ' {
                                                     ^39.3k     ^38.7k
 1116|  2.25k|                idx += 1;
 1117|  2.25k|            }
 1118|  37.1k|            if idx < bytes.len() && bytes[idx] == b'>' {
                                                  ^37.1k
 1119|    392|                idx += 1;
 1120|    392|                if idx < bytes.len() && (bytes[idx] == b' ' || bytes[idx] == b'\t') {
                                                       ^391                  ^40
 1121|    361|                    idx += 1;
 1122|    361|                }
                              ^31
 1123|    392|                level += 1;
 1124|    392|                rest = &rest[idx..];
 1125|    392|                continue;
 1126|  36.7k|            }
 1127|  36.7k|            break;
 1128|       |        }
 1129|  36.7k|        (level, rest)
 1130|  36.7k|    }
 1131|       |
 1132|  7.71k|    fn table_line_info_with_list(line: &str, list_indent: Option<usize>) -> (usize, &str) {
 1133|  7.71k|        let (level, rest) = Self::table_line_info(line);
 1134|  7.71k|        if let Some(indent) = list_indent {
                                  ^81
 1135|     81|            if let Some(stripped) = Self::strip_indent_columns(rest, indent) {
                                      ^72
 1136|     72|                let (nested_level, nested_rest) = Self::table_line_info(stripped);
 1137|     72|                return (level + nested_level, nested_rest);
 1138|      9|            }
 1139|      9|            if let Some(stripped) = Self::strip_indent_columns(line, indent) {
                                      ^1
 1140|      1|                return Self::table_line_info(stripped);
 1141|      8|            }
 1142|  7.63k|        }
 1143|  7.64k|        (level, rest)
 1144|  7.71k|    }
 1145|       |
 1146|  2.33k|    fn table_line_info_in_list(line: &str, list_indent: Option<usize>) -> Option<(usize, &str)> {
 1147|  2.33k|        let (level, rest) = Self::table_line_info(line);
 1148|  2.33k|        if let Some(indent) = list_indent {
                                  ^2.10k
 1149|  2.10k|            if let Some(stripped) = Self::strip_indent_columns(rest, indent) {
                                      ^94
 1150|     94|                let (nested_level, nested_rest) = Self::table_line_info(stripped);
 1151|     94|                return Some((level + nested_level, nested_rest));
 1152|  2.01k|            }
 1153|  2.01k|            let stripped = Self::strip_indent_columns(line, indent)?;
                              ^2                                                 ^2.00k
 1154|      2|            return Some(Self::table_line_info(stripped));
 1155|    233|        }
 1156|    233|        Some((level, rest))
 1157|  2.33k|    }
 1158|       |
 1159|  14.4k|    fn list_marker_info(line: &str) -> Option<(&str, usize, usize)> {
 1160|  14.4k|        let bytes = line.as_bytes();
 1161|  14.4k|        let mut idx = 0usize;
 1162|  14.4k|        let mut spaces = 0usize;
 1163|  15.7k|        while idx < bytes.len() && spaces < 3 && bytes[idx] == b' ' {
                                                 ^15.7k        ^15.3k
 1164|  1.34k|            idx += 1;
 1165|  1.34k|            spaces += 1;
 1166|  1.34k|        }
 1167|  14.4k|        if idx < bytes.len() && bytes[idx] == b'\t' {
                                              ^14.4k
 1168|     15|            return None;
 1169|  14.4k|        }
 1170|  14.4k|        if idx >= bytes.len() {
 1171|      2|            return None;
 1172|  14.4k|        }
 1173|  14.4k|        let marker_start = idx;
 1174|  14.4k|        match bytes[idx] {
 1175|  5.16k|            b'-' | b'+' | b'*' => {
 1176|  5.16k|                idx += 1;
 1177|  5.16k|            }
 1178|  4.06k|            b'0'..=b'9' => {
 1179|  3.86k|                while idx < bytes.len() && bytes[idx].is_ascii_digit() {
                                                         ^3.86k     ^3.86k
 1180|  1.94k|                    idx += 1;
 1181|  1.94k|                }
 1182|  1.92k|                if idx < bytes.len() && (bytes[idx] == b'.' || bytes[idx] == b')') {
                                                       ^1.92k                ^10
 1183|  1.91k|                    idx += 1;
 1184|  1.91k|                } else {
 1185|      9|                    return None;
 1186|       |                }
 1187|       |            }
 1188|  7.33k|            _ => return None,
 1189|       |        }
 1190|  7.07k|        let marker_width = idx.saturating_sub(marker_start);
 1191|  7.07k|        let mut indent = 0usize;
 1192|  7.07k|        let mut has_ws = false;
 1193|  7.07k|        let mut col = spaces + marker_width;
 1194|  13.2k|        while idx < bytes.len() {
 1195|  13.2k|            match bytes[idx] {
 1196|  6.16k|                b' ' => {
 1197|  6.16k|                    indent += 1;
 1198|  6.16k|                    col += 1;
 1199|  6.16k|                    idx += 1;
 1200|  6.16k|                    has_ws = true;
 1201|  6.16k|                }
 1202|      1|                b'\t' => {
 1203|      1|                    let advance = Self::tab_advance(col);
 1204|      1|                    indent += advance;
 1205|      1|                    col += advance;
 1206|      1|                    idx += 1;
 1207|      1|                    has_ws = true;
 1208|      1|                }
 1209|  7.07k|                _ => break,
 1210|       |            }
 1211|       |        }
 1212|  7.07k|        if !has_ws {
 1213|    917|            return None;
 1214|  6.15k|        }
 1215|  6.15k|        let content_indent = col;
 1216|  6.15k|        Some((&line[idx..], indent, content_indent))
 1217|  14.4k|    }
 1218|       |
 1219|  4.19k|    fn list_marker_info_any_indent(line: &str) -> Option<(&str, usize, usize, usize)> {
 1220|  4.19k|        let bytes = line.as_bytes();
 1221|  4.19k|        let mut idx = 0usize;
 1222|  4.19k|        let mut leading_cols = 0usize;
 1223|  6.22k|        while idx < bytes.len() {
 1224|  6.22k|            match bytes[idx] {
 1225|  2.00k|                b' ' => {
 1226|  2.00k|                    idx += 1;
 1227|  2.00k|                    leading_cols += 1;
 1228|  2.00k|                }
 1229|     15|                b'\t' => {
 1230|     15|                    let advance = Self::tab_advance(leading_cols);
 1231|     15|                    idx += 1;
 1232|     15|                    leading_cols += advance;
 1233|     15|                }
 1234|  4.19k|                _ => break,
 1235|       |            }
 1236|       |        }
 1237|  4.19k|        if idx >= bytes.len() {
 1238|      2|            return None;
 1239|  4.19k|        }
 1240|  4.19k|        let marker_start = idx;
 1241|  4.19k|        match bytes[idx] {
 1242|    526|            b'-' | b'+' | b'*' => {
 1243|    526|                idx += 1;
 1244|    526|            }
 1245|  1.61k|            b'0'..=b'9' => {
 1246|     27|                while idx < bytes.len() && bytes[idx].is_ascii_digit() {
                                                         ^26        ^26
 1247|     16|                    idx += 1;
 1248|     16|                }
 1249|     11|                if idx < bytes.len() && (bytes[idx] == b'.' || bytes[idx] == b')') {
                                                       ^10                   ^7
 1250|      5|                    idx += 1;
 1251|      5|                } else {
 1252|      6|                    return None;
 1253|       |                }
 1254|       |            }
 1255|  3.66k|            _ => return None,
 1256|       |        }
 1257|    531|        let marker_width = idx.saturating_sub(marker_start);
 1258|    531|        let mut indent = 0usize;
 1259|    531|        let mut has_ws = false;
 1260|    531|        let mut col = leading_cols + marker_width;
 1261|    581|        while idx < bytes.len() {
 1262|    579|            match bytes[idx] {
 1263|     49|                b' ' => {
 1264|     49|                    indent += 1;
 1265|     49|                    col += 1;
 1266|     49|                    idx += 1;
 1267|     49|                    has_ws = true;
 1268|     49|                }
 1269|      1|                b'\t' => {
 1270|      1|                    let advance = Self::tab_advance(col);
 1271|      1|                    indent += advance;
 1272|      1|                    col += advance;
 1273|      1|                    idx += 1;
 1274|      1|                    has_ws = true;
 1275|      1|                }
 1276|    529|                _ => break,
 1277|       |            }
 1278|       |        }
 1279|    531|        if !has_ws {
 1280|    481|            return None;
 1281|     50|        }
 1282|     50|        let content_indent = col;
 1283|     50|        Some((&line[idx..], indent, content_indent, leading_cols))
 1284|  4.19k|    }
 1285|       |
 1286|  3.90k|    fn parent_list_indent_for_line(
 1287|  3.90k|        lines: &[&str],
 1288|  3.90k|        idx: usize,
 1289|  3.90k|        level: usize,
 1290|  3.90k|        line_rest: &str,
 1291|  3.90k|    ) -> Option<usize> {
 1292|  3.90k|        if idx == 0 {
 1293|      1|            return None;
 1294|  3.90k|        }
 1295|  10.5k|        for back_idx in (0..idx).rev() {
                                       ^3.90k  ^3.90k
 1296|  10.5k|            let (prev_level, prev_rest) = Self::table_line_info(lines[back_idx]);
 1297|  10.5k|            if prev_level < level {
 1298|     15|                break;
 1299|  10.5k|            }
 1300|  10.5k|            if prev_level > level {
 1301|     33|                continue;
 1302|  10.5k|            }
 1303|  10.5k|            if prev_rest.trim().is_empty() {
 1304|  2.33k|                continue;
 1305|  8.19k|            }
 1306|  8.19k|            if let Some((_, _, content_indent)) = Self::list_marker_info(prev_rest) {
                                             ^4.10k
 1307|  4.10k|                if Self::strip_indent_columns(line_rest, content_indent).is_some() {
 1308|     77|                    return Some(content_indent);
 1309|  4.02k|                }
 1310|     27|            } else if let Some((_, _, content_indent, _)) =
 1311|  4.09k|                Self::list_marker_info_any_indent(prev_rest)
 1312|       |            {
 1313|     27|                if Self::strip_indent_columns(line_rest, content_indent).is_some() {
 1314|     17|                    return Some(content_indent);
 1315|     10|                }
 1316|  4.06k|            } else if !prev_rest.starts_with(' ') && !prev_rest.starts_with('\t') {
                                                                   ^3.79k
 1317|  3.78k|                break;
 1318|    279|            }
 1319|       |        }
 1320|  3.81k|        None
 1321|  3.90k|    }
 1322|       |
 1323|  8.42k|    fn strip_indent_columns(line: &str, indent: usize) -> Option<&str> {
 1324|  8.42k|        if indent == 0 {
 1325|      1|            return Some(line);
 1326|  8.41k|        }
 1327|  8.41k|        let mut col = 0usize;
 1328|  8.41k|        let mut cut = 0usize;
 1329|  9.64k|        for (idx, ch) in line.char_indices() {
                                       ^8.41k^8.41k
 1330|  9.64k|            if col >= indent {
 1331|    286|                break;
 1332|  9.35k|            }
 1333|  9.35k|            match ch {
 1334|  1.20k|                ' ' => {
 1335|  1.20k|                    col += 1;
 1336|  1.20k|                    cut = idx + ch.len_utf8();
 1337|  1.20k|                }
 1338|     17|                '\t' => {
 1339|     17|                    col += Self::tab_advance(col);
 1340|     17|                    cut = idx + ch.len_utf8();
 1341|     17|                }
 1342|  8.13k|                _ => return None,
 1343|       |            }
 1344|       |        }
 1345|    287|        if col >= indent {
 1346|    286|            Some(&line[cut..])
 1347|       |        } else {
 1348|      1|            None
 1349|       |        }
 1350|  8.42k|    }
 1351|       |
 1352|  1.88k|    fn has_pipe_outside_inline_code(line: &str) -> bool {
 1353|  1.88k|        if !line.contains('|') {
 1354|  1.57k|            return false;
 1355|    315|        }
 1356|    315|        let mut in_code = false;
 1357|    315|        let mut delimiter_len = 0usize;
 1358|    315|        let mut backslash_run = 0usize;
 1359|    315|        let mut chars = line.chars().peekable();
 1360|       |
 1361|    510|        while let Some(ch) = chars.next() {
                                     ^506
 1362|    506|            if ch == '\\' {
 1363|      2|                backslash_run += 1;
 1364|      2|                continue;
 1365|    504|            }
 1366|       |
 1367|    504|            let escaped = !in_code && backslash_run % 2 == 1;
                                                    ^471
 1368|    504|            backslash_run = 0;
 1369|       |
 1370|    504|            if ch == '`' {
 1371|      9|                if escaped {
 1372|      1|                    continue;
 1373|      8|                }
 1374|      8|                let mut run_len = 1usize;
 1375|     11|                while matches!(chars.peek(), Some('`')) {
                                    ^8
 1376|      3|                    chars.next();
 1377|      3|                    run_len += 1;
 1378|      3|                }
 1379|      8|                if in_code {
 1380|      4|                    if run_len == delimiter_len {
 1381|      3|                        in_code = false;
 1382|      3|                        delimiter_len = 0;
 1383|      3|                    }
                                  ^1
 1384|      4|                } else {
 1385|      4|                    in_code = true;
 1386|      4|                    delimiter_len = run_len;
 1387|      4|                }
 1388|      8|                continue;
 1389|    495|            }
 1390|       |
 1391|    495|            if ch == '|' && !in_code && !escaped {
                                          ^316        ^312
 1392|    311|                return true;
 1393|    184|            }
 1394|       |        }
 1395|       |
 1396|      4|        false
 1397|  1.88k|    }
 1398|       |
 1399|  3.80k|    fn is_table_row_candidate(line: &str) -> bool {
 1400|  3.80k|        if Self::is_indented_code_line(line) {
 1401|     16|            return false;
 1402|  3.78k|        }
 1403|  3.78k|        let trimmed_line = line.trim_end_matches(['\r', '\n']);
 1404|  3.78k|        if trimmed_line.trim().is_empty() {
 1405|  1.90k|            return false;
 1406|  1.88k|        }
 1407|  1.88k|        Self::has_pipe_outside_inline_code(trimmed_line)
 1408|  3.80k|    }
 1409|       |
 1410|     76|    fn is_table_delimiter_line(line: &str) -> bool {
 1411|     76|        if Self::is_indented_code_line(line) {
 1412|      1|            return false;
 1413|     75|        }
 1414|     75|        let trimmed = line.trim_end_matches(['\r', '\n']).trim();
 1415|     75|        if trimmed.is_empty() {
 1416|      2|            return false;
 1417|     73|        }
 1418|     73|        let mut has_dash = false;
 1419|     73|        let mut has_pipe = false;
 1420|  1.07k|        for ch in trimmed.chars() {
                                ^73     ^73
 1421|  1.07k|            match ch {
 1422|    613|                '-' => has_dash = true,
 1423|    208|                '|' => has_pipe = true,
 1424|    251|                ':' | ' ' | '\t' => {}
 1425|      2|                _ => return false,
 1426|       |            }
 1427|       |        }
 1428|     71|        has_dash && has_pipe
                                  ^70
 1429|     76|    }
 1430|       |
 1431|  6.11k|    fn fence_start(line: &str) -> Option<(char, usize)> {
 1432|  6.11k|        let trimmed = line.trim_start();
 1433|  6.11k|        let mut chars = trimmed.chars();
 1434|  6.11k|        let first = chars.next()?;
                          ^4.19k              ^1.91k
 1435|  4.19k|        if first != '`' && first != '~' {
                                         ^4.12k
 1436|  4.12k|            return None;
 1437|     67|        }
 1438|     67|        let mut count = 1usize;
 1439|    104|        for ch in chars {
                          ^101
 1440|    101|            if ch == first {
 1441|     37|                count += 1;
 1442|     37|            } else {
 1443|     64|                break;
 1444|       |            }
 1445|       |        }
 1446|     67|        if count >= 3 {
 1447|     18|            Some((first, count))
 1448|       |        } else {
 1449|     49|            None
 1450|       |        }
 1451|  6.11k|    }
 1452|       |
 1453|    122|    fn is_fence_end(line: &str, fence_char: char, fence_len: usize) -> bool {
 1454|    122|        let trimmed = line.trim_start();
 1455|    122|        let mut count = 0usize;
 1456|    161|        for ch in trimmed.chars() {
                                ^122    ^122
 1457|    161|            if ch == fence_char {
 1458|     56|                count += 1;
 1459|     56|            } else {
 1460|    105|                break;
 1461|       |            }
 1462|       |        }
 1463|    122|        count >= fence_len
 1464|    122|    }
 1465|       |
 1466|  4.00k|    fn restore_pipe_sentinel(text: &str) -> String {
 1467|  4.00k|        if text.contains(PIPE_SENTINEL) {
 1468|      2|            text.chars()
 1469|      8|                .map(|ch| if ch == PIPE_SENTINEL { '|' } else { ch })
                               ^2                                ^3           ^5
 1470|      2|                .collect()
 1471|       |        } else {
 1472|  3.99k|            text.to_string()
 1473|       |        }
 1474|  4.00k|    }
 1475|       |
 1476|       |    /// Parse markdown content into elements with proper inline handling
 1477|    267|    pub fn parse(&self, markdown: &str) -> Result<Vec<MarkdownElement>, anyhow::Error> {
 1478|       |        #[cfg(test)]
 1479|    267|        if take_forced_parse_error() {
 1480|      4|            return Err(anyhow::anyhow!("forced parse error"));
 1481|    263|        }
 1482|       |
 1483|    263|        let mut options = Options::empty();
 1484|    263|        options.insert(Options::ENABLE_STRIKETHROUGH);
 1485|    263|        options.insert(Options::ENABLE_TABLES);
 1486|    263|        options.insert(Options::ENABLE_TASKLISTS);
 1487|       |
 1488|    263|        let prepared = Self::escape_table_pipes_in_inline_code(markdown);
 1489|    263|        let parser = Parser::new_ext(&prepared, options);
 1490|    263|        let mut elements = Vec::new();
 1491|    263|        let events = parser.collect::<Vec<_>>();
 1492|       |
 1493|    263|        let mut i = 0;
 1494|       |        // Track header slug occurrences for stable de-duplication
 1495|    263|        let mut slug_counts: HashMap<String, usize> = HashMap::new();
 1496|  2.59k|        while i < events.len() {
 1497|  2.33k|            i = self.parse_element(&events, i, &mut elements, &mut slug_counts)?;
                                                                                             ^0
 1498|       |        }
 1499|       |
 1500|    263|        Ok(elements)
 1501|    267|    }
 1502|       |
 1503|       |    /// Parse a single element from the event stream
 1504|  2.34k|    fn parse_element(
 1505|  2.34k|        &self,
 1506|  2.34k|        events: &[Event],
 1507|  2.34k|        start: usize,
 1508|  2.34k|        elements: &mut Vec<MarkdownElement>,
 1509|  2.34k|        slug_counts: &mut HashMap<String, usize>,
 1510|  2.34k|    ) -> Result<usize, anyhow::Error> {
 1511|  2.34k|        match &events[start] {
 1512|       |            Event::Start(Tag::Paragraph) => {
 1513|       |                // Always preserve line breaks in paragraphs (consistent with blockquotes)
 1514|       |                // This allows poetry, lyrics, and structured content to render correctly
 1515|    703|                let (spans, next_idx) =
 1516|    703|                    self.parse_inline_spans_with_breaks(events, start + 1, Tag::Paragraph, true);
 1517|    703|                if !spans.is_empty() {
 1518|    702|                    elements.push(MarkdownElement::Paragraph(spans));
 1519|    702|                }
                              ^1
 1520|    703|                Ok(next_idx)
 1521|       |            }
 1522|       |            // Images encountered outside paragraphs: treat as a single paragraph with an inline image
 1523|      2|            Event::Start(Tag::Image(_, url, title)) => {
 1524|      2|                let (alt, next_idx) = self.collect_until_tag_end(
 1525|      2|                    events,
 1526|      2|                    start + 1,
 1527|      2|                    Tag::Image(LinkType::Inline, "".into(), "".into()),
 1528|      2|                    false,
 1529|      2|                );
 1530|      2|                let mut spans: Vec<InlineSpan> = Vec::new();
 1531|      2|                spans.push(InlineSpan::Image {
 1532|      2|                    src: url.to_string(),
 1533|      2|                    alt,
 1534|      2|                    title: if title.is_empty() {
 1535|      1|                        None
 1536|       |                    } else {
 1537|      1|                        Some(title.to_string())
 1538|       |                    },
 1539|       |                });
 1540|      2|                elements.push(MarkdownElement::Paragraph(spans));
 1541|      2|                Ok(next_idx)
 1542|       |            }
 1543|    849|            Event::Start(Tag::Heading(level, _, _)) => {
 1544|    849|                let (spans, next_idx) =
 1545|    849|                    self.parse_inline_spans(events, start + 1, Tag::Heading(*level, None, vec![]));
 1546|    849|                let title_text = Self::spans_plain_text(&spans);
 1547|    849|                let base = Self::slugify(&title_text);
 1548|    849|                let count = slug_counts.entry(base.clone()).or_insert(0);
 1549|    849|                let id = if *count == 0 {
 1550|    847|                    base.clone()
 1551|       |                } else {
 1552|      2|                    format!("{}-{}", base, *count)
 1553|       |                };
 1554|    849|                *count += 1;
 1555|    849|                elements.push(MarkdownElement::Header {
 1556|    849|                    level: *level as u8,
 1557|    849|                    spans,
 1558|    849|                    id,
 1559|    849|                });
 1560|    849|                Ok(next_idx)
 1561|       |            }
 1562|       |            Event::Start(Tag::CodeBlock(_)) => {
 1563|      9|                let (code_text, language, next_idx) = self.parse_code_block(events, start)?;
                                                                                                        ^0
 1564|      9|                elements.push(MarkdownElement::CodeBlock {
 1565|      9|                    language,
 1566|      9|                    text: code_text,
 1567|      9|                });
 1568|      9|                Ok(next_idx)
 1569|       |            }
 1570|    536|            Event::Start(Tag::List(first_item)) => {
 1571|    536|                let (items, next_idx) = self.parse_list(events, start + 1, slug_counts)?;
                                                                                                     ^0
 1572|    536|                elements.push(MarkdownElement::List {
 1573|    536|                    ordered: first_item.is_some(),
 1574|    536|                    items,
 1575|    536|                });
 1576|    536|                Ok(next_idx)
 1577|       |            }
 1578|       |            Event::Rule => {
 1579|    203|                elements.push(MarkdownElement::HorizontalRule);
 1580|    203|                Ok(start + 1)
 1581|       |            }
 1582|       |            Event::Start(Tag::BlockQuote) => {
 1583|     12|                let (quotes, next_idx) =
 1584|     12|                    self.collect_blockquotes(events, start + 1, 1, slug_counts)?;
                                                                                             ^0
 1585|     28|                for (depth, blocks) in quotes {
                                   ^16    ^16
 1586|     16|                    elements.push(MarkdownElement::Quote { depth, blocks });
 1587|     16|                }
 1588|     12|                Ok(next_idx)
 1589|       |            }
 1590|     31|            Event::Start(Tag::Table(alignments)) => {
 1591|     31|                let (headers, rows, next_idx) = self.parse_table(events, start + 1)?;
                                                                                                 ^0
 1592|     31|                elements.push(MarkdownElement::Table {
 1593|     31|                    headers,
 1594|     31|                    rows,
 1595|     31|                    alignments: alignments.to_vec(),
 1596|     31|                });
 1597|     31|                Ok(next_idx)
 1598|       |            }
 1599|       |            _ => {
 1600|       |                // Skip other events
 1601|      1|                Ok(start + 1)
 1602|       |            }
 1603|       |        }
 1604|  2.34k|    }
 1605|       |
 1606|       |    // Build a slug from text similar to GitHub: lowercase, spaces->dashes, strip punctuation
 1607|    861|    fn slugify(text: &str) -> String {
 1608|    861|        let mut out = String::with_capacity(text.len());
 1609|    861|        let mut last_dash = false;
 1610|  11.8k|        for ch in text.chars() {
                                ^861 ^861
 1611|  11.8k|            let c = ch.to_ascii_lowercase();
 1612|  11.8k|            if c.is_ascii_alphanumeric() {
 1613|  10.9k|                out.push(c);
 1614|  10.9k|                last_dash = false;
 1615|  10.9k|            } else if c.is_whitespace() || c == '-' {
                                    ^862^862               ^18
 1616|    856|                if !last_dash && !out.is_empty() {
                                               ^848
 1617|    846|                    out.push('-');
 1618|    846|                    last_dash = true;
 1619|    846|                }
                              ^10
 1620|      6|            } else {
 1621|      6|                // drop punctuation/symbols
 1622|      6|            }
 1623|       |        }
 1624|       |        // Trim trailing dash if any
 1625|    861|        if out.ends_with('-') {
 1626|      2|            out.pop();
 1627|    859|        }
 1628|    861|        out
 1629|    861|    }
 1630|       |
 1631|    956|    fn spans_plain_text(spans: &[InlineSpan]) -> String {
 1632|    956|        let mut s = String::new();
 1633|  1.94k|        for span in spans {
                          ^992
 1634|    992|            match span {
 1635|    968|                InlineSpan::Text(t)
 1636|     12|                | InlineSpan::Strong(t)
 1637|      1|                | InlineSpan::Emphasis(t)
 1638|    981|                | InlineSpan::Strikethrough(t) => s.push_str(t),
                                                          ^0
 1639|      4|                InlineSpan::Code(t) => s.push_str(t),
 1640|      1|                InlineSpan::Link { text, .. } => s.push_str(text),
 1641|      6|                InlineSpan::Image { alt, title, .. } => {
 1642|      6|                    if !alt.is_empty() {
 1643|      3|                        s.push_str(alt);
 1644|      3|                    }
 1645|      6|                    if let Some(t) = title {
                                              ^5
 1646|      5|                        if !t.is_empty() {
 1647|      4|                            if !s.is_empty() {
 1648|      2|                                s.push(' ');
 1649|      2|                            }
 1650|      4|                            s.push_str(t);
 1651|      1|                        }
 1652|      1|                    }
 1653|       |                }
 1654|       |            }
 1655|       |        }
 1656|    956|        s
 1657|    956|    }
 1658|       |
 1659|       |    /// Extract plain text from all markdown elements
 1660|     14|    pub fn elements_to_plain_text(elements: &[MarkdownElement]) -> String {
 1661|     14|        let mut result = String::new();
 1662|     35|        for element in elements.iter() {
                                     ^14      ^14
 1663|     35|            match element {
 1664|      9|                MarkdownElement::Paragraph(spans) | MarkdownElement::Header { spans, .. } => {
                                                                                            ^6
 1665|     15|                    if !result.is_empty() {
 1666|      7|                        result.push('\n');
 1667|      8|                    }
 1668|     15|                    result.push_str(&Self::spans_plain_text(spans));
 1669|       |                }
 1670|      2|                MarkdownElement::CodeBlock { text, .. } => {
 1671|      2|                    if !result.is_empty() {
 1672|      1|                        result.push('\n');
 1673|      1|                    }
 1674|      2|                    result.push_str(text);
 1675|       |                }
 1676|      5|                MarkdownElement::List { items, .. } => {
 1677|     16|                    for item in items {
                                      ^11
 1678|     22|                        for block in &item.blocks {
                                          ^11
 1679|     11|                            if !result.is_empty() {
 1680|     10|                                result.push('\n');
 1681|     10|                            }
                                          ^1
 1682|     11|                            result.push_str(&Self::element_plain_text(block));
 1683|       |                        }
 1684|       |                    }
 1685|       |                }
 1686|      3|                MarkdownElement::Quote { blocks, .. } => {
 1687|      6|                    for block in blocks {
                                      ^3
 1688|      3|                        if !result.is_empty() {
 1689|      2|                            result.push('\n');
 1690|      2|                        }
                                      ^1
 1691|      3|                        result.push_str(&Self::element_plain_text(block));
 1692|       |                    }
 1693|       |                }
 1694|       |                MarkdownElement::Table {
 1695|      5|                    headers,
 1696|      5|                    rows,
 1697|       |                    alignments: _,
 1698|       |                } => {
 1699|       |                    // Headers
 1700|     11|                    for header in headers {
                                      ^6
 1701|      6|                        if !result.is_empty() {
 1702|      5|                            result.push('\n');
 1703|      5|                        }
                                      ^1
 1704|      6|                        result.push_str(&Self::spans_plain_text(header));
 1705|       |                    }
 1706|       |                    // Rows
 1707|     15|                    for row in rows {
                                      ^10
 1708|     27|                        for cell in row {
                                          ^17
 1709|     17|                            if !result.is_empty() {
 1710|     16|                                result.push('\n');
 1711|     16|                            }
                                          ^1
 1712|     17|                            result.push_str(&Self::spans_plain_text(cell));
 1713|       |                        }
 1714|       |                    }
 1715|       |                }
 1716|       |                MarkdownElement::HorizontalRule => {
 1717|      5|                    if !result.is_empty() {
 1718|      4|                        result.push_str("\n---\n");
 1719|      4|                    }
                                  ^1
 1720|       |                }
 1721|       |            }
 1722|       |        }
 1723|     14|        result
 1724|     14|    }
 1725|       |
 1726|       |    /// Collect blockquotes into (depth, blocks) entries; supports nesting and block elements.
 1727|     26|    fn collect_blockquotes(
 1728|     26|        &self,
 1729|     26|        events: &[Event],
 1730|     26|        start: usize,
 1731|     26|        depth: u8,
 1732|     26|        slug_counts: &mut HashMap<String, usize>,
 1733|     26|    ) -> Result<(Vec<(u8, QuoteBlocks)>, usize), anyhow::Error> {
 1734|     26|        let mut i = start;
 1735|     26|        let mut result: Vec<(u8, QuoteBlocks)> = Vec::new();
 1736|     26|        let mut blocks: QuoteBlocks = Vec::new();
 1737|     26|        let mut spans: Vec<InlineSpan> = Vec::new();
 1738|       |
 1739|     73|        let flush_inline = |blocks: &mut QuoteBlocks, spans: &mut Vec<InlineSpan>| {
                          ^26
 1740|     73|            if !spans.is_empty() {
 1741|      4|                blocks.push(MarkdownElement::Paragraph(std::mem::take(spans)));
 1742|     69|            }
 1743|     73|        };
 1744|       |
 1745|     89|        while i < events.len() {
 1746|     87|            match &events[i] {
 1747|       |                Event::Start(Tag::Paragraph) => {
 1748|     22|                    flush_inline(&mut blocks, &mut spans);
 1749|     22|                    let (ps, next) =
 1750|     22|                        self.parse_inline_spans_with_breaks(events, i + 1, Tag::Paragraph, true);
 1751|     22|                    if !ps.is_empty() {
 1752|     21|                        blocks.push(MarkdownElement::Paragraph(ps));
 1753|     21|                    }
                                  ^1
 1754|     22|                    i = next;
 1755|       |                }
 1756|      5|                Event::Start(Tag::Heading(level, _, _)) => {
 1757|      5|                    flush_inline(&mut blocks, &mut spans);
 1758|      5|                    let (ps, next) =
 1759|      5|                        self.parse_inline_spans(events, i + 1, Tag::Heading(*level, None, vec![]));
 1760|      5|                    let title_text = Self::spans_plain_text(&ps);
 1761|      5|                    let base = Self::slugify(&title_text);
 1762|      5|                    let count = slug_counts.entry(base.clone()).or_insert(0);
 1763|      5|                    let id = if *count == 0 {
 1764|      4|                        base.clone()
 1765|       |                    } else {
 1766|      1|                        format!("{}-{}", base, *count)
 1767|       |                    };
 1768|      5|                    *count += 1;
 1769|      5|                    blocks.push(MarkdownElement::Header {
 1770|      5|                        level: *level as u8,
 1771|      5|                        spans: ps,
 1772|      5|                        id,
 1773|      5|                    });
 1774|      5|                    i = next;
 1775|       |                }
 1776|      4|                Event::Start(Tag::Table(alignments)) => {
 1777|      4|                    flush_inline(&mut blocks, &mut spans);
 1778|      4|                    let (headers, rows, next_idx) = self.parse_table(events, i + 1)?;
                                                                                                 ^0
 1779|      4|                    blocks.push(MarkdownElement::Table {
 1780|      4|                        headers,
 1781|      4|                        rows,
 1782|      4|                        alignments: alignments.to_vec(),
 1783|      4|                    });
 1784|      4|                    i = next_idx;
 1785|       |                }
 1786|      4|                Event::Start(Tag::List(first_item)) => {
 1787|      4|                    flush_inline(&mut blocks, &mut spans);
 1788|      4|                    let (items, next_idx) = self.parse_list(events, i + 1, slug_counts)?;
                                                                                                     ^0
 1789|      4|                    blocks.push(MarkdownElement::List {
 1790|      4|                        ordered: first_item.is_some(),
 1791|      4|                        items,
 1792|      4|                    });
 1793|      4|                    i = next_idx;
 1794|       |                }
 1795|       |                Event::Start(Tag::CodeBlock(_)) => {
 1796|      3|                    flush_inline(&mut blocks, &mut spans);
 1797|      3|                    let (code_text, language, next_idx) = self.parse_code_block(events, i)?;
                                                                                                        ^0
 1798|      3|                    blocks.push(MarkdownElement::CodeBlock {
 1799|      3|                        language,
 1800|      3|                        text: code_text,
 1801|      3|                    });
 1802|      3|                    i = next_idx;
 1803|       |                }
 1804|      2|                Event::Rule => {
 1805|      2|                    flush_inline(&mut blocks, &mut spans);
 1806|      2|                    blocks.push(MarkdownElement::HorizontalRule);
 1807|      2|                    i += 1;
 1808|      2|                }
 1809|       |                Event::Start(Tag::BlockQuote) => {
 1810|      7|                    flush_inline(&mut blocks, &mut spans);
 1811|      7|                    if !blocks.is_empty() {
 1812|      6|                        result.push((depth, std::mem::take(&mut blocks)));
 1813|      6|                    }
                                  ^1
 1814|      7|                    let (nested, next) =
 1815|      7|                        self.collect_blockquotes(events, i + 1, depth + 1, slug_counts)?;
                                                                                                     ^0
 1816|      7|                    result.extend(nested);
 1817|      7|                    i = next;
 1818|       |                }
 1819|       |                Event::End(Tag::BlockQuote) => {
 1820|     24|                    flush_inline(&mut blocks, &mut spans);
 1821|     24|                    if !blocks.is_empty() {
 1822|     16|                        result.push((depth, blocks));
 1823|     16|                    }
                                  ^8
 1824|     24|                    return Ok((result, i + 1));
 1825|       |                }
 1826|      1|                Event::Text(t) => {
 1827|      1|                    spans.push(InlineSpan::Text(Self::restore_pipe_sentinel(t)));
 1828|      1|                    i += 1;
 1829|      1|                }
 1830|      2|                Event::Code(code) => {
 1831|      2|                    spans.push(InlineSpan::Code(Self::restore_pipe_sentinel(code)));
 1832|      2|                    i += 1;
 1833|      2|                }
 1834|      1|                Event::Start(Tag::Emphasis) => {
 1835|      1|                    let (inner_text, next) =
 1836|      1|                        self.collect_until_tag_end(events, i + 1, Tag::Emphasis, true);
 1837|      1|                    spans.push(InlineSpan::Emphasis(inner_text));
 1838|      1|                    i = next;
 1839|      1|                }
 1840|      1|                Event::Start(Tag::Strong) => {
 1841|      1|                    let (inner_text, next) =
 1842|      1|                        self.collect_until_tag_end(events, i + 1, Tag::Strong, true);
 1843|      1|                    spans.push(InlineSpan::Strong(inner_text));
 1844|      1|                    i = next;
 1845|      1|                }
 1846|      1|                Event::Start(Tag::Strikethrough) => {
 1847|      1|                    let (inner_text, next) =
 1848|      1|                        self.collect_until_tag_end(events, i + 1, Tag::Strikethrough, true);
 1849|      1|                    spans.push(InlineSpan::Strikethrough(inner_text));
 1850|      1|                    i = next;
 1851|      1|                }
 1852|      2|                Event::Start(Tag::Link(_, url, _)) => {
 1853|      2|                    let url_str = url.to_string();
 1854|      2|                    let (link_text, next) = self.collect_until_tag_end(
 1855|      2|                        events,
 1856|      2|                        i + 1,
 1857|      2|                        Tag::Link(LinkType::Inline, "".into(), "".into()),
 1858|      2|                        true,
 1859|      2|                    );
 1860|      2|                    spans.push(InlineSpan::Link {
 1861|      2|                        text: link_text,
 1862|      2|                        url: url_str,
 1863|      2|                    });
 1864|      2|                    i = next;
 1865|      2|                }
 1866|      2|                Event::Start(Tag::Image(_, url, title)) => {
 1867|      2|                    let url_str = url.to_string();
 1868|      2|                    let (alt_text, next) = self.collect_until_tag_end(
 1869|      2|                        events,
 1870|      2|                        i + 1,
 1871|      2|                        Tag::Image(LinkType::Inline, "".into(), "".into()),
 1872|      2|                        true,
 1873|      2|                    );
 1874|      2|                    spans.push(InlineSpan::Image {
 1875|      2|                        src: url_str,
 1876|      2|                        alt: alt_text,
 1877|      2|                        title: if title.is_empty() {
 1878|      1|                            None
 1879|       |                        } else {
 1880|      1|                            Some(title.to_string())
 1881|       |                        },
 1882|       |                    });
 1883|      2|                    i = next;
 1884|       |                }
 1885|      3|                Event::SoftBreak | Event::HardBreak => {
 1886|      3|                    spans.push(InlineSpan::Text("\n".to_string()));
 1887|      3|                    i += 1;
 1888|      3|                }
 1889|      2|                Event::Html(html) => {
 1890|      2|                    if Self::is_html_line_break(html) {
 1891|      1|                        spans.push(InlineSpan::Text("\n".to_string()));
 1892|      1|                    }
 1893|      2|                    i += 1;
 1894|       |                }
 1895|      1|                _ => {
 1896|      1|                    i += 1;
 1897|      1|                }
 1898|       |            }
 1899|       |        }
 1900|       |
 1901|      2|        flush_inline(&mut blocks, &mut spans);
 1902|      2|        if !blocks.is_empty() {
 1903|      1|            result.push((depth, blocks));
 1904|      1|        }
 1905|      2|        Ok((result, i))
 1906|     26|    }
 1907|       |
 1908|       |    /// Parse inline spans until reaching the end tag
 1909|  2.11k|    fn parse_inline_spans_with_breaks(
 1910|  2.11k|        &self,
 1911|  2.11k|        events: &[Event],
 1912|  2.11k|        start: usize,
 1913|  2.11k|        end_tag: Tag,
 1914|  2.11k|        keep_breaks: bool,
 1915|  2.11k|    ) -> (Vec<InlineSpan>, usize) {
 1916|  2.11k|        let mut spans = Vec::new();
 1917|  2.11k|        let mut i = start;
 1918|  2.11k|        let mut text_buffer = String::new();
 1919|       |
 1920|  4.58k|        while i < events.len() {
 1921|  4.58k|            match &events[i] {
 1922|  2.11k|                Event::End(tag)
 1923|  2.11k|                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
                                                                                                   ^2.11k
 1924|       |                {
 1925|  2.11k|                    if !text_buffer.is_empty() {
 1926|  1.71k|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1927|  1.71k|                        text_buffer.clear();
 1928|  1.71k|                    }
                                  ^395
 1929|  2.11k|                    return (spans, i + 1);
 1930|       |                }
 1931|  1.95k|                Event::Text(text) => {
 1932|  1.95k|                    let restored = Self::restore_pipe_sentinel(text);
 1933|  1.95k|                    text_buffer.push_str(&restored);
 1934|  1.95k|                    i += 1;
 1935|  1.95k|                }
 1936|       |                Event::SoftBreak | Event::HardBreak => {
 1937|     19|                    if keep_breaks {
 1938|     18|                        if !text_buffer.is_empty() {
 1939|     11|                            spans.push(InlineSpan::Text(text_buffer.clone()));
 1940|     11|                            text_buffer.clear();
 1941|     11|                        }
                                      ^7
 1942|     18|                        spans.push(InlineSpan::Text("\n".to_string()));
 1943|      1|                    } else {
 1944|      1|                        text_buffer.push(' ');
 1945|      1|                    }
 1946|     19|                    i += 1;
 1947|       |                }
 1948|    177|                Event::Code(code) => {
 1949|    177|                    if !text_buffer.is_empty() {
 1950|     29|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1951|     29|                        text_buffer.clear();
 1952|    148|                    }
 1953|    177|                    spans.push(InlineSpan::Code(Self::restore_pipe_sentinel(code)));
 1954|    177|                    i += 1;
 1955|       |                }
 1956|     20|                Event::Html(html) => {
 1957|     20|                    if Self::is_html_line_break(html) {
 1958|     19|                        if keep_breaks {
 1959|     18|                            if !text_buffer.is_empty() {
 1960|     16|                                spans.push(InlineSpan::Text(text_buffer.clone()));
 1961|     16|                                text_buffer.clear();
 1962|     16|                            }
                                          ^2
 1963|     18|                            spans.push(InlineSpan::Text("\n".to_string()));
 1964|      1|                        } else {
 1965|      1|                            text_buffer.push(' ');
 1966|      1|                        }
 1967|      1|                    }
 1968|     20|                    i += 1;
 1969|       |                }
 1970|       |                Event::Start(Tag::Strong) => {
 1971|     51|                    if !text_buffer.is_empty() {
 1972|      7|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1973|      7|                        text_buffer.clear();
 1974|     44|                    }
 1975|     51|                    let (inner_text, next_i) =
 1976|     51|                        self.collect_until_tag_end(events, i + 1, Tag::Strong, keep_breaks);
 1977|     51|                    spans.push(InlineSpan::Strong(inner_text));
 1978|     51|                    i = next_i;
 1979|       |                }
 1980|       |                Event::Start(Tag::Emphasis) => {
 1981|    204|                    if !text_buffer.is_empty() {
 1982|      7|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1983|      7|                        text_buffer.clear();
 1984|    197|                    }
 1985|    204|                    let (inner_text, next_i) =
 1986|    204|                        self.collect_until_tag_end(events, i + 1, Tag::Emphasis, keep_breaks);
 1987|    204|                    spans.push(InlineSpan::Emphasis(inner_text));
 1988|    204|                    i = next_i;
 1989|       |                }
 1990|       |                Event::Start(Tag::Strikethrough) => {
 1991|      5|                    if !text_buffer.is_empty() {
 1992|      4|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1993|      4|                        text_buffer.clear();
 1994|      4|                    }
                                  ^1
 1995|      5|                    let (inner_text, next_i) =
 1996|      5|                        self.collect_until_tag_end(events, i + 1, Tag::Strikethrough, keep_breaks);
 1997|      5|                    spans.push(InlineSpan::Strikethrough(inner_text));
 1998|      5|                    i = next_i;
 1999|       |                }
 2000|     17|                Event::Start(Tag::Link(_, url, _)) => {
 2001|     17|                    if !text_buffer.is_empty() {
 2002|      8|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 2003|      8|                        text_buffer.clear();
 2004|      9|                    }
 2005|     17|                    let url_str = url.to_string();
 2006|     17|                    let (link_text, next_i) = self.collect_until_tag_end(
 2007|     17|                        events,
 2008|     17|                        i + 1,
 2009|     17|                        Tag::Link(LinkType::Inline, "".into(), "".into()),
 2010|     17|                        keep_breaks,
 2011|     17|                    );
 2012|     17|                    spans.push(InlineSpan::Link {
 2013|     17|                        text: link_text,
 2014|     17|                        url: url_str,
 2015|     17|                    });
 2016|     17|                    i = next_i;
 2017|       |                }
 2018|     20|                Event::Start(Tag::Image(_, url, title)) => {
 2019|     20|                    if !text_buffer.is_empty() {
 2020|      3|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 2021|      3|                        text_buffer.clear();
 2022|     17|                    }
 2023|     20|                    let url_str = url.to_string();
 2024|     20|                    let (alt_text, next_i) = self.collect_until_tag_end(
 2025|     20|                        events,
 2026|     20|                        i + 1,
 2027|     20|                        Tag::Image(LinkType::Inline, "".into(), "".into()),
 2028|     20|                        keep_breaks,
 2029|     20|                    );
 2030|     20|                    spans.push(InlineSpan::Image {
 2031|     20|                        src: url_str,
 2032|     20|                        alt: alt_text,
 2033|     20|                        title: if title.is_empty() {
 2034|      3|                            None
 2035|       |                        } else {
 2036|     17|                            Some(title.to_string())
 2037|       |                        },
 2038|       |                    });
 2039|     20|                    i = next_i;
 2040|       |                }
 2041|      2|                _ => {
 2042|      2|                    i += 1;
 2043|      2|                }
 2044|       |            }
 2045|       |        }
 2046|       |
 2047|      3|        if !text_buffer.is_empty() {
 2048|      2|            spans.push(InlineSpan::Text(text_buffer));
 2049|      2|        }
                      ^1
 2050|       |
 2051|      3|        (spans, i)
 2052|  2.11k|    }
 2053|       |
 2054|       |    /// Default inline parsing without preserving explicit line breaks
 2055|    865|    fn parse_inline_spans(
 2056|    865|        &self,
 2057|    865|        events: &[Event],
 2058|    865|        start: usize,
 2059|    865|        end_tag: Tag,
 2060|    865|    ) -> (Vec<InlineSpan>, usize) {
 2061|    865|        self.parse_inline_spans_with_breaks(events, start, end_tag, false)
 2062|    865|    }
 2063|       |
 2064|       |    /// Collect text until a specific end tag
 2065|  1.86k|    fn collect_until_tag_end(
 2066|  1.86k|        &self,
 2067|  1.86k|        events: &[Event],
 2068|  1.86k|        start: usize,
 2069|  1.86k|        end_tag: Tag,
 2070|  1.86k|        keep_breaks: bool,
 2071|  1.86k|    ) -> (String, usize) {
 2072|  1.86k|        let mut text = String::new();
 2073|  1.86k|        let mut i = start;
 2074|       |
 2075|  3.74k|        while i < events.len() {
 2076|  3.74k|            match &events[i] {
 2077|  1.86k|                Event::End(tag)
 2078|  1.86k|                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
                                                                                                   ^1.85k
 2079|       |                {
 2080|  1.85k|                    return (text, i + 1);
 2081|       |                }
 2082|  1.86k|                Event::Text(t) => {
 2083|  1.86k|                    let restored = Self::restore_pipe_sentinel(t);
 2084|  1.86k|                    text.push_str(&restored);
 2085|  1.86k|                }
 2086|      2|                Event::Code(code) => {
 2087|      2|                    let restored = Self::restore_pipe_sentinel(code);
 2088|      2|                    text.push_str(&restored);
 2089|      2|                }
 2090|       |                Event::SoftBreak | Event::HardBreak => {
 2091|      5|                    if keep_breaks {
 2092|      3|                        text.push('\n');
 2093|      3|                    } else {
 2094|      2|                        text.push(' ');
 2095|      2|                    }
 2096|       |                }
 2097|      8|                Event::Html(html) => {
 2098|      8|                    if Self::is_html_line_break(html) {
 2099|      6|                        if keep_breaks {
 2100|      4|                            text.push('\n');
 2101|      4|                        } else {
 2102|      2|                            text.push(' ');
 2103|      2|                        }
 2104|      2|                    }
 2105|       |                }
 2106|      4|                _ => {}
 2107|       |            }
 2108|  1.88k|            i += 1;
 2109|       |        }
 2110|       |
 2111|      1|        (text, i)
 2112|  1.86k|    }
 2113|       |
 2114|       |    /// Parse a code block
 2115|     18|    fn parse_code_block(
 2116|     18|        &self,
 2117|     18|        events: &[Event],
 2118|     18|        start: usize,
 2119|     18|    ) -> Result<(String, Option<String>, usize), anyhow::Error> {
 2120|     18|        let mut language = None;
 2121|     18|        let mut code_text = String::new();
 2122|     18|        let mut i = start;
 2123|       |
 2124|       |        // Extract language from the start tag
 2125|     18|        if let Event::Start(Tag::CodeBlock(kind)) = &events[start] {
                                                         ^17
 2126|     17|            if let pulldown_cmark::CodeBlockKind::Fenced(lang) = kind {
                                                                       ^16
 2127|     16|                if !lang.is_empty() {
 2128|     15|                    language = Some(lang.to_string());
 2129|     15|                }
                              ^1
 2130|      1|            }
 2131|     17|            i += 1;
 2132|      1|        }
 2133|       |
 2134|     39|        while i < events.len() {
 2135|     38|            match &events[i] {
 2136|       |                Event::End(Tag::CodeBlock(_)) => {
 2137|     17|                    return Ok((code_text, language, i + 1));
 2138|       |                }
 2139|     20|                Event::Text(text) => {
 2140|     20|                    code_text.push_str(text);
 2141|     20|                }
 2142|      1|                _ => {}
 2143|       |            }
 2144|     21|            i += 1;
 2145|       |        }
 2146|       |
 2147|      1|        Ok((code_text, language, i))
 2148|     18|    }
 2149|       |
 2150|       |    /// Parse a list item into block-level markdown elements.
 2151|    554|    fn parse_list(
 2152|    554|        &self,
 2153|    554|        events: &[Event],
 2154|    554|        start: usize,
 2155|    554|        slug_counts: &mut HashMap<String, usize>,
 2156|    554|    ) -> Result<(Vec<ListItem>, usize), anyhow::Error> {
 2157|    554|        let mut items: Vec<ListItem> = Vec::new();
 2158|    554|        let mut i = start;
 2159|       |
 2160|  2.57k|        while i < events.len() {
 2161|  2.57k|            match &events[i] {
 2162|    553|                Event::End(Tag::List(_)) => return Ok((items, i + 1)),
 2163|       |                Event::Start(Tag::Item) => {
 2164|  2.02k|                    i += 1;
 2165|  2.02k|                    let mut blocks: Vec<MarkdownElement> = Vec::new();
 2166|  2.02k|                    let mut spans: Vec<InlineSpan> = Vec::new();
 2167|  2.02k|                    let flush_inline =
 2168|  2.04k|                        |blocks: &mut Vec<MarkdownElement>, spans: &mut Vec<InlineSpan>| {
 2169|  2.04k|                            if !spans.is_empty() {
 2170|  2.01k|                                blocks.push(MarkdownElement::Paragraph(std::mem::take(spans)));
 2171|  2.01k|                            }
                                          ^29
 2172|  2.04k|                        };
 2173|       |
 2174|       |                    loop {
 2175|  6.94k|                        if i >= events.len() {
 2176|      1|                            break;
 2177|  6.94k|                        }
 2178|  6.94k|                        match &events[i] {
 2179|       |                            Event::End(Tag::Item) => {
 2180|  2.02k|                                i += 1;
 2181|  2.02k|                                break;
 2182|       |                            }
 2183|       |                            Event::Start(Tag::Paragraph) => {
 2184|      2|                                flush_inline(&mut blocks, &mut spans);
 2185|      2|                                let (ps, next) =
 2186|      2|                                    self.parse_inline_spans(events, i + 1, Tag::Paragraph);
 2187|      2|                                if !ps.is_empty() {
 2188|      1|                                    blocks.push(MarkdownElement::Paragraph(ps));
 2189|      1|                                }
 2190|      2|                                i = next;
 2191|       |                            }
 2192|      5|                            Event::Start(Tag::Heading(level, _, _)) => {
 2193|      5|                                flush_inline(&mut blocks, &mut spans);
 2194|      5|                                let (ps, next) = self.parse_inline_spans(
 2195|      5|                                    events,
 2196|      5|                                    i + 1,
 2197|      5|                                    Tag::Heading(*level, None, vec![]),
 2198|      5|                                );
 2199|      5|                                let title_text = Self::spans_plain_text(&ps);
 2200|      5|                                let base = Self::slugify(&title_text);
 2201|      5|                                let count = slug_counts.entry(base.clone()).or_insert(0);
 2202|      5|                                let id = if *count == 0 {
 2203|      4|                                    base.clone()
 2204|       |                                } else {
 2205|      1|                                    format!("{}-{}", base, *count)
 2206|       |                                };
 2207|      5|                                *count += 1;
 2208|      5|                                blocks.push(MarkdownElement::Header {
 2209|      5|                                    level: *level as u8,
 2210|      5|                                    spans: ps,
 2211|      5|                                    id,
 2212|      5|                                });
 2213|      5|                                i = next;
 2214|       |                            }
 2215|      3|                            Event::Start(Tag::Table(alignments)) => {
 2216|      3|                                flush_inline(&mut blocks, &mut spans);
 2217|      3|                                let (headers, rows, next_idx) = self.parse_table(events, i + 1)?;
                                                                                                             ^0
 2218|      3|                                blocks.push(MarkdownElement::Table {
 2219|      3|                                    headers,
 2220|      3|                                    rows,
 2221|      3|                                    alignments: alignments.to_vec(),
 2222|      3|                                });
 2223|      3|                                i = next_idx;
 2224|       |                            }
 2225|       |                            Event::Start(Tag::CodeBlock(_)) => {
 2226|      2|                                flush_inline(&mut blocks, &mut spans);
 2227|      2|                                let (code_text, language, next_idx) =
 2228|      2|                                    self.parse_code_block(events, i)?;
                                                                                  ^0
 2229|      2|                                blocks.push(MarkdownElement::CodeBlock {
 2230|      2|                                    language,
 2231|      2|                                    text: code_text,
 2232|      2|                                });
 2233|      2|                                i = next_idx;
 2234|       |                            }
 2235|       |                            Event::Start(Tag::BlockQuote) => {
 2236|      2|                                flush_inline(&mut blocks, &mut spans);
 2237|      2|                                let (quotes, next_idx) =
 2238|      2|                                    self.collect_blockquotes(events, i + 1, 1, slug_counts)?;
                                                                                                         ^0
 2239|      4|                                for (depth, quote_blocks) in quotes {
                                                   ^2     ^2
 2240|      2|                                    blocks.push(MarkdownElement::Quote {
 2241|      2|                                        depth,
 2242|      2|                                        blocks: quote_blocks,
 2243|      2|                                    });
 2244|      2|                                }
 2245|      2|                                i = next_idx;
 2246|       |                            }
 2247|      8|                            Event::Start(Tag::List(child_first)) => {
 2248|      8|                                flush_inline(&mut blocks, &mut spans);
 2249|      8|                                let (child_items, next) =
 2250|      8|                                    self.parse_list(events, i + 1, slug_counts)?;
                                                                                             ^0
 2251|      8|                                blocks.push(MarkdownElement::List {
 2252|      8|                                    ordered: child_first.is_some(),
 2253|      8|                                    items: child_items,
 2254|      8|                                });
 2255|      8|                                i = next;
 2256|       |                            }
 2257|      1|                            Event::Rule => {
 2258|      1|                                flush_inline(&mut blocks, &mut spans);
 2259|      1|                                blocks.push(MarkdownElement::HorizontalRule);
 2260|      1|                                i += 1;
 2261|      1|                            }
 2262|    705|                            Event::Code(code) => {
 2263|    705|                                spans.push(InlineSpan::Code(code.to_string()));
 2264|    705|                                i += 1;
 2265|    705|                            }
 2266|      7|                            Event::Start(Tag::Emphasis) => {
 2267|      7|                                let (inner_text, next) = self.collect_until_tag_end(
 2268|      7|                                    events,
 2269|      7|                                    i + 1,
 2270|      7|                                    Tag::Emphasis,
 2271|      7|                                    false,
 2272|      7|                                );
 2273|      7|                                spans.push(InlineSpan::Emphasis(inner_text));
 2274|      7|                                i = next;
 2275|      7|                            }
 2276|  1.50k|                            Event::Start(Tag::Strong) => {
 2277|  1.50k|                                let (inner_text, next) =
 2278|  1.50k|                                    self.collect_until_tag_end(events, i + 1, Tag::Strong, false);
 2279|  1.50k|                                spans.push(InlineSpan::Strong(inner_text));
 2280|  1.50k|                                i = next;
 2281|  1.50k|                            }
 2282|      7|                            Event::Start(Tag::Strikethrough) => {
 2283|      7|                                let (inner_text, next) = self.collect_until_tag_end(
 2284|      7|                                    events,
 2285|      7|                                    i + 1,
 2286|      7|                                    Tag::Strikethrough,
 2287|      7|                                    false,
 2288|      7|                                );
 2289|      7|                                spans.push(InlineSpan::Strikethrough(inner_text));
 2290|      7|                                i = next;
 2291|      7|                            }
 2292|     26|                            Event::Start(Tag::Link(_, url, _)) => {
 2293|     26|                                let url_str = url.to_string();
 2294|     26|                                let (link_text, next) = self.collect_until_tag_end(
 2295|     26|                                    events,
 2296|     26|                                    i + 1,
 2297|     26|                                    Tag::Link(LinkType::Inline, "".into(), "".into()),
 2298|     26|                                    false,
 2299|     26|                                );
 2300|     26|                                spans.push(InlineSpan::Link {
 2301|     26|                                    text: link_text,
 2302|     26|                                    url: url_str,
 2303|     26|                                });
 2304|     26|                                i = next;
 2305|     26|                            }
 2306|      4|                            Event::Start(Tag::Image(_, url, title)) => {
 2307|      4|                                let url_str = url.to_string();
 2308|      4|                                let (alt_text, next) = self.collect_until_tag_end(
 2309|      4|                                    events,
 2310|      4|                                    i + 1,
 2311|      4|                                    Tag::Image(LinkType::Inline, "".into(), "".into()),
 2312|      4|                                    false,
 2313|      4|                                );
 2314|      4|                                spans.push(InlineSpan::Image {
 2315|      4|                                    src: url_str,
 2316|      4|                                    alt: alt_text,
 2317|      4|                                    title: if title.is_empty() {
 2318|      1|                                        None
 2319|       |                                    } else {
 2320|      3|                                        Some(title.to_string())
 2321|       |                                    },
 2322|       |                                });
 2323|      4|                                i = next;
 2324|       |                            }
 2325|  2.63k|                            Event::Text(t) => {
 2326|  2.63k|                                spans.push(InlineSpan::Text(t.to_string()));
 2327|  2.63k|                                i += 1;
 2328|  2.63k|                            }
 2329|      4|                            Event::SoftBreak | Event::HardBreak => {
 2330|      4|                                spans.push(InlineSpan::Text(" ".into()));
 2331|      4|                                i += 1;
 2332|      4|                            }
 2333|      1|                            _ => {
 2334|      1|                                i += 1;
 2335|      1|                            }
 2336|       |                        }
 2337|       |                    }
 2338|       |
 2339|  2.02k|                    flush_inline(&mut blocks, &mut spans);
 2340|  2.02k|                    items.push(ListItem { blocks });
 2341|       |                }
 2342|      1|                _ => i += 1,
 2343|       |            }
 2344|       |        }
 2345|       |
 2346|      1|        Ok((items, i))
 2347|    554|    }
 2348|       |
 2349|       |    /// Parse a table with headers and rows
 2350|     44|    fn parse_table(
 2351|     44|        &self,
 2352|     44|        events: &[Event],
 2353|     44|        start: usize,
 2354|     44|    ) -> Result<TableParseResult, anyhow::Error> {
 2355|     44|        let mut headers: Vec<Vec<InlineSpan>> = Vec::new();
 2356|     44|        let mut rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
 2357|     44|        let mut i = start;
 2358|       |
 2359|    298|        while i < events.len() {
 2360|    295|            match &events[i] {
 2361|       |                Event::Start(Tag::TableHead) => {
 2362|     42|                    i += 1;
 2363|    134|                    while i < events.len() {
 2364|    133|                        match &events[i] {
 2365|     81|                            Event::Start(Tag::TableCell) => {
 2366|     81|                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
 2367|     81|                                    events,
 2368|     81|                                    i + 1,
 2369|     81|                                    Tag::TableCell,
 2370|     81|                                    true,
 2371|     81|                                );
 2372|     81|                                headers.push(spans);
 2373|     81|                                i = next_idx;
 2374|     81|                            }
 2375|       |                            Event::End(Tag::TableHead) => {
 2376|     41|                                i += 1;
 2377|     41|                                break;
 2378|       |                            }
 2379|     11|                            _ => i += 1,
 2380|       |                        }
 2381|       |                    }
 2382|       |                }
 2383|       |                Event::Start(Tag::TableRow) => {
 2384|    211|                    i += 1;
 2385|    211|                    let mut row: Vec<Vec<InlineSpan>> = Vec::new();
 2386|    646|                    while i < events.len() {
 2387|    645|                        match &events[i] {
 2388|    434|                            Event::Start(Tag::TableCell) => {
 2389|    434|                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
 2390|    434|                                    events,
 2391|    434|                                    i + 1,
 2392|    434|                                    Tag::TableCell,
 2393|    434|                                    true,
 2394|    434|                                );
 2395|    434|                                row.push(spans);
 2396|    434|                                i = next_idx;
 2397|    434|                            }
 2398|       |                            Event::End(Tag::TableRow) => {
 2399|    210|                                i += 1;
 2400|    210|                                if !row.is_empty() {
 2401|    209|                                    rows.push(row);
 2402|    209|                                }
                                              ^1
 2403|    210|                                break;
 2404|       |                            }
 2405|      1|                            _ => i += 1,
 2406|       |                        }
 2407|       |                    }
 2408|       |                }
 2409|     41|                Event::End(Tag::Table(_)) => return Ok((headers, rows, i + 1)),
 2410|      1|                _ => i += 1,
 2411|       |            }
 2412|       |        }
 2413|      3|        Ok((headers, rows, i))
 2414|     44|    }
 2415|       |
 2416|     90|    fn render_element_body(&self, ui: &mut egui::Ui, element: &MarkdownElement) {
 2417|     90|        match element {
 2418|     29|            MarkdownElement::Paragraph(spans) => {
 2419|     29|                self.render_inline_spans(ui, spans);
 2420|     29|                ui.add_space(4.0);
 2421|     29|            }
 2422|      1|            MarkdownElement::Quote { depth, blocks } => {
 2423|      1|                ui.add_space(4.0);
 2424|      1|                let bar_width = 3.0;
 2425|      1|                let bar_gap = 6.0;
 2426|      1|                let left_pad = 10.0 + (*depth as f32) * (bar_width + bar_gap);
 2427|       |                // Substack-like styling: dark grey block with orange accent bars and white text
 2428|      1|                let bg = Color32::from_rgb(24, 24, 24);
 2429|       |
 2430|      1|                let resp = egui::Frame::none()
 2431|      1|                    .fill(bg)
 2432|      1|                    .stroke(Stroke::new(1.0, Color32::from_rgb(40, 40, 40)))
 2433|      1|                    .rounding(egui::Rounding::same(6.0))
 2434|      1|                    .inner_margin(egui::Margin {
 2435|      1|                        left: left_pad,
 2436|      1|                        right: 10.0,
 2437|      1|                        top: 8.0,
 2438|      1|                        bottom: 8.0,
 2439|      1|                    })
 2440|      1|                    .show(ui, |ui| {
 2441|      1|                        let prev_override = ui.style().visuals.override_text_color;
 2442|       |                        // White text for quote content
 2443|      1|                        ui.style_mut().visuals.override_text_color = Some(Color32::WHITE);
 2444|      2|                        for block in blocks {
                                          ^1
 2445|      1|                            self.render_element_body(ui, block);
 2446|      1|                        }
 2447|      1|                        ui.style_mut().visuals.override_text_color = prev_override;
 2448|      1|                    });
 2449|       |
 2450|       |                // Draw vertical orange quote bars on the left of the frame
 2451|      1|                let rect = resp.response.rect;
 2452|      1|                let top = rect.top() + 6.0;
 2453|      1|                let bottom = rect.bottom() - 6.0;
 2454|      1|                let bar_color = Color32::from_rgb(255, 103, 25); // Substack-like orange
 2455|      1|                for d in 0..*depth {
 2456|      1|                    let x = rect.left() + 6.0 + (d as f32) * (bar_width + bar_gap);
 2457|      1|                    let bar_rect = egui::Rect::from_min_max(
 2458|      1|                        egui::pos2(x, top),
 2459|      1|                        egui::pos2(x + bar_width, bottom),
 2460|      1|                    );
 2461|      1|                    ui.painter().rect_filled(bar_rect, 2.0, bar_color);
 2462|      1|                }
 2463|       |
 2464|      1|                ui.add_space(6.0);
 2465|       |            }
 2466|     32|            MarkdownElement::Header { level, spans, id } => {
 2467|     32|                let font_size = match level {
 2468|     13|                    1 => self.font_sizes.h1,
 2469|     14|                    2 => self.font_sizes.h2,
 2470|      1|                    3 => self.font_sizes.h3,
 2471|      1|                    4 => self.font_sizes.h4,
 2472|      1|                    5 => self.font_sizes.h5,
 2473|      1|                    6 => self.font_sizes.h6,
 2474|      1|                    _ => self.font_sizes.body,
 2475|       |                };
 2476|       |
 2477|     32|                ui.add_space(8.0);
 2478|     32|                let resp = ui.horizontal_wrapped(|ui| {
 2479|       |                    // Avoid artificial gaps between header fragments
 2480|     32|                    ui.spacing_mut().item_spacing.x = 0.0;
 2481|     64|                    for span in spans {
                                      ^32
 2482|     32|                        self.render_inline_span(ui, span, Some(font_size), Some(true));
 2483|     32|                    }
 2484|     32|                });
 2485|       |                // Record the header rect for in-document navigation
 2486|     32|                self.header_rects
 2487|     32|                    .borrow_mut()
 2488|     32|                    .insert(id.clone(), resp.response.rect);
 2489|     32|                ui.add_space(6.0);
 2490|       |            }
 2491|      4|            MarkdownElement::CodeBlock { language, text } => {
 2492|      4|                self.render_code_block(ui, language.as_deref(), text);
 2493|      4|            }
 2494|     13|            MarkdownElement::List { ordered, items } => {
 2495|     13|                self.render_list(ui, *ordered, items);
 2496|     13|            }
 2497|      7|            MarkdownElement::HorizontalRule => {
 2498|      7|                ui.add_space(8.0);
 2499|      7|                ui.separator();
 2500|      7|                ui.add_space(8.0);
 2501|      7|            }
 2502|       |            MarkdownElement::Table {
 2503|      4|                headers,
 2504|      4|                rows,
 2505|      4|                alignments,
 2506|      4|            } => {
 2507|      4|                self.render_table(ui, headers, rows, alignments);
 2508|      4|            }
 2509|       |        }
 2510|     90|    }
 2511|       |
 2512|       |    /// Render parsed markdown elements to egui UI
 2513|     23|    pub fn render_to_ui(&self, ui: &mut egui::Ui, elements: &[MarkdownElement]) {
 2514|     23|        self.poll_image_results(ui.ctx());
 2515|     23|        self.mermaid.begin_frame();
 2516|       |        // Clear header rects before rendering a new frame
 2517|     23|        self.header_rects.borrow_mut().clear();
 2518|       |        // Reset per-frame link counter to ensure link IDs are stable across frames
 2519|     23|        *self.link_counter.borrow_mut() = 0;
 2520|       |        // Reset per-frame table counter
 2521|     23|        *self.table_counter.borrow_mut() = 0;
 2522|       |        // Reset per-frame element rects
 2523|     23|        self.element_rects.borrow_mut().clear();
 2524|     79|        for element in elements.iter() {
                                     ^23      ^23
 2525|       |            // Wrap each element in a no-op frame to capture its rect
 2526|     79|            let ir = egui::Frame::none().show(ui, |ui| {
 2527|     79|                self.render_element_body(ui, element);
 2528|     79|            });
 2529|     79|            self.element_rects.borrow_mut().push(ir.response.rect);
 2530|       |        }
 2531|       |        // Add a little extra breathing room at the end so
 2532|       |        // the final line doesn't sit flush under the status bar.
 2533|     23|        ui.add_space(16.0);
 2534|     23|    }
 2535|       |
 2536|       |    /// Render inline spans in a wrapped horizontal layout
 2537|     29|    fn render_inline_spans(&self, ui: &mut egui::Ui, spans: &[InlineSpan]) {
 2538|     29|        ui.horizontal_wrapped(|ui| {
 2539|       |            // Avoid adding UI spacing between inline fragments
 2540|     29|            ui.spacing_mut().item_spacing.x = 0.0;
 2541|     70|            for span in spans {
                              ^41
 2542|     41|                self.render_inline_span(ui, span, None, None);
 2543|     41|            }
 2544|     29|        });
 2545|     29|    }
 2546|       |
 2547|       |    /// Fix Unicode characters that may not render properly in the default font
 2548|    463|    fn fix_unicode_chars(&self, text: &str) -> String {
 2549|    463|        let normalized: String = text.nfc().collect();
 2550|  5.73k|        if !normalized.chars().any(|c| {
                          ^463               ^463
 2551|  5.73k|            matches!(
 2552|  5.73k|                c,
 2553|       |                '\u{2011}'
 2554|       |                    | '\u{00AD}'
 2555|       |                    | '\u{2010}'
 2556|       |                    | '\u{2212}'
 2557|       |                    | '\u{2013}'
 2558|       |                    | '\u{2014}'
 2559|       |                    | '\u{00A0}'
 2560|       |                    | '\u{202F}'
 2561|       |                    | '\u{2190}'
 2562|       |                    | '\u{2192}'
 2563|       |                    | '\u{2191}'
 2564|       |                    | '\u{2193}'
 2565|       |            )
 2566|  5.73k|        }) {
 2567|    460|            return normalized;
 2568|      3|        }
 2569|       |
 2570|      3|        let mut out = String::with_capacity(normalized.len());
 2571|     15|        for ch in normalized.chars() {
                                ^3         ^3
 2572|     15|            match ch {
 2573|       |                '\u{2011}' | '\u{00AD}' | '\u{2010}' | '\u{2212}' | '\u{2013}' | '\u{2014}' => {
 2574|      1|                    out.push('-')
 2575|       |                }
 2576|      1|                '\u{00A0}' | '\u{202F}' => out.push(' '),
 2577|      1|                '\u{2190}' => {
 2578|      1|                    out.push('<');
 2579|      1|                    out.push('-');
 2580|      1|                }
 2581|      2|                '\u{2192}' => {
 2582|      2|                    out.push('-');
 2583|      2|                    out.push('>');
 2584|      2|                }
 2585|      1|                '\u{2191}' => {
 2586|      1|                    out.push('^');
 2587|      1|                }
 2588|      1|                '\u{2193}' => {
 2589|      1|                    out.push('v');
 2590|      1|                }
 2591|      8|                _ => out.push(ch),
 2592|       |            }
 2593|       |        }
 2594|      3|        out
 2595|    463|    }
 2596|       |
 2597|       |    #[cfg(test)]
 2598|      3|    pub(crate) fn normalize_text_for_test(&self, text: &str) -> String {
 2599|      3|        self.fix_unicode_chars(text)
 2600|      3|    }
 2601|       |
 2602|       |    /// Render a single inline span    /// Render a single inline span
 2603|    248|    fn render_inline_span(
 2604|    248|        &self,
 2605|    248|        ui: &mut egui::Ui,
 2606|    248|        span: &InlineSpan,
 2607|    248|        font_size: Option<f32>,
 2608|    248|        strong: Option<bool>,
 2609|    248|    ) {
 2610|    248|        let size = font_size.unwrap_or(self.font_sizes.body);
 2611|    248|        let is_strong = strong.unwrap_or(false);
 2612|       |
 2613|    248|        match span {
 2614|    141|            InlineSpan::Text(text) => {
 2615|    141|                let fixed_text = self.fix_unicode_chars(text);
 2616|    141|                let style = InlineStyle {
 2617|    141|                    strong: is_strong,
 2618|    141|                    ..Default::default()
 2619|    141|                };
 2620|    141|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 2621|    141|            }
 2622|     22|            InlineSpan::Code(code) => {
 2623|       |                // Inline code: adapt style to theme (light vs dark)
 2624|     22|                ui.spacing_mut().item_spacing.x = 0.0;
 2625|     22|                let is_dark = ui.visuals().dark_mode;
 2626|     22|                let (bg, fg) = if is_dark {
 2627|     21|                    (
 2628|     21|                        Color32::from_rgb(30, 30, 30),
 2629|     21|                        Color32::from_rgb(180, 255, 180),
 2630|     21|                    )
 2631|       |                } else {
 2632|       |                    // Light theme: white background with readable code color
 2633|      1|                    (Color32::WHITE, Color32::from_rgb(60, 80, 150))
 2634|       |                };
 2635|     22|                let response = ui.add(
 2636|     22|                    egui::Label::new(
 2637|     22|                        RichText::new(code.clone())
 2638|     22|                            .size(self.font_sizes.code)
 2639|     22|                            .family(egui::FontFamily::Monospace)
 2640|     22|                            .background_color(bg)
 2641|     22|                            .color(fg),
 2642|       |                    )
 2643|     22|                    .wrap(true),
 2644|       |                );
 2645|       |
 2646|       |                // Add context menu for code
 2647|       |                #[cfg(test)]
 2648|     22|                {
 2649|     22|                    let _ = &response;
 2650|     22|                    self.render_inline_code_context_menu(ui, code);
 2651|     22|                }
 2652|       |                #[cfg(not(test))]
 2653|       |                response.context_menu(|ui| {
 2654|       |                    self.render_inline_code_context_menu(ui, code);
 2655|       |                });
 2656|       |            }
 2657|     51|            InlineSpan::Strong(text) => {
 2658|     51|                let fixed_text = self.fix_unicode_chars(text);
 2659|     51|                let style = InlineStyle {
 2660|     51|                    strong: true,
 2661|     51|                    ..Default::default()
 2662|     51|                };
 2663|     51|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 2664|     51|            }
 2665|      8|            InlineSpan::Emphasis(text) => {
 2666|      8|                let fixed_text = self.fix_unicode_chars(text);
 2667|      8|                let style = InlineStyle {
 2668|      8|                    italics: true,
 2669|      8|                    strong: is_strong,
 2670|      8|                    ..Default::default()
 2671|      8|                };
 2672|      8|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 2673|      8|            }
 2674|      2|            InlineSpan::Strikethrough(text) => {
 2675|      2|                let fixed_text = self.fix_unicode_chars(text);
 2676|      2|                let style = InlineStyle {
 2677|      2|                    strike: true,
 2678|      2|                    strong: is_strong,
 2679|      2|                    ..Default::default()
 2680|      2|                };
 2681|      2|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 2682|      2|            }
 2683|      6|            InlineSpan::Link { text, url } => {
 2684|      6|                let fixed_text = self.fix_unicode_chars(text);
 2685|      6|                let group = ui.horizontal_wrapped(|ui| {
 2686|       |                    // Render link-like styled text with emoji expansion
 2687|      6|                    let color = if Self::is_external_url(url) {
 2688|       |                        // Slightly different color to indicate external website links
 2689|      4|                        Color32::from_rgb(120, 190, 255)
 2690|       |                    } else {
 2691|      2|                        Color32::LIGHT_BLUE
 2692|       |                    };
 2693|      6|                    let style = InlineStyle {
 2694|      6|                        strong: is_strong,
 2695|      6|                        color: Some(color),
 2696|      6|                        ..Default::default()
 2697|      6|                    };
 2698|      6|                    self.render_text_with_emojis(ui, &fixed_text, size, style);
 2699|      6|                });
 2700|       |                // Use a unique id per link occurrence to avoid collisions when the same URL appears multiple times
 2701|      6|                let mut counter = self.link_counter.borrow_mut();
 2702|      6|                let id = egui::Id::new(format!("link:{}:{}", *counter, url));
 2703|      6|                *counter += 1;
 2704|      6|                let r = ui.interact(group.response.rect, id, egui::Sense::click());
 2705|      6|                if render_action_triggered(r.hovered(), "link_hover") {
 2706|      3|                    ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
 2707|      3|                }
 2708|      6|                if render_action_triggered(r.clicked(), "link_click") {
 2709|      3|                    self.trigger_link(url);
 2710|      3|                }
 2711|       |
 2712|       |                // Add context menu for links
 2713|       |                #[cfg(test)]
 2714|      6|                self.render_link_context_menu(ui, text, url);
 2715|       |                #[cfg(not(test))]
 2716|       |                r.context_menu(|ui| {
 2717|       |                    self.render_link_context_menu(ui, text, url);
 2718|       |                });
 2719|       |            }
 2720|     18|            InlineSpan::Image { src, alt, title } => {
 2721|       |                // Resolve path
 2722|     18|                let resolved = self.resolve_image_path(src);
 2723|     18|                let available_w = ui.available_width().max(1.0);
 2724|       |                // Try to get or load texture
 2725|     18|                if let Some((tex, w, h)) = self.get_or_load_image_texture(ui, &resolved) {
                                           ^7   ^7 ^7
 2726|      7|                    let (tw, th) = (w as f32, h as f32);
 2727|       |                    // Scale logic:
 2728|       |                    // - Start at UI scale (e.g., 1.0 for 100%, 1.1 for 110%).
 2729|       |                    // - Only downscale further if it would exceed available width.
 2730|      7|                    let base_scale = self.ui_scale();
 2731|      7|                    let scaled_w = tw * base_scale;
 2732|      7|                    let scale = if scaled_w > available_w {
 2733|      1|                        (available_w / tw).clamp(0.01, 4.0)
 2734|       |                    } else {
 2735|      6|                        base_scale
 2736|       |                    };
 2737|      7|                    let size = egui::vec2((tw * scale).round(), (th * scale).round());
 2738|      7|                    let image = egui::Image::new(&tex).fit_to_exact_size(size);
 2739|      7|                    let resp = ui.add(image);
 2740|      7|                    if let Some(t) = title {
                                              ^6
 2741|      6|                        if !t.is_empty() {
 2742|      5|                            if render_action_triggered(resp.hovered(), "image_hover") {
 2743|      2|                                resp.on_hover_text(t.clone());
 2744|      3|                            }
 2745|       |                            // Subtle caption below image
 2746|      5|                            ui.add_space(2.0);
 2747|      5|                            ui.label(
 2748|      5|                                RichText::new(t.clone())
 2749|      5|                                    .size(self.font_sizes.body - 2.0)
 2750|      5|                                    .color(Color32::from_rgb(140, 140, 140)),
 2751|       |                            );
 2752|      1|                        }
 2753|      1|                    }
 2754|      7|                    ui.add_space(6.0);
 2755|       |                } else {
 2756|       |                    // Placeholder with alt and error info
 2757|     11|                    egui::Frame::none()
 2758|     11|                        .fill(Color32::from_rgb(30, 30, 30))
 2759|     11|                        .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2760|     11|                        .inner_margin(8.0)
 2761|     11|                        .show(ui, |ui| {
 2762|     11|                            let pending = self.image_pending.borrow().contains(&resolved);
 2763|     11|                            let msg = if pending {
 2764|      5|                                "Loading image..."
 2765|      6|                            } else if src.starts_with("http://") || src.starts_with("https://") {
                                                                                  ^5
 2766|      3|                                "Remote images are disabled"
 2767|       |                            } else {
 2768|      3|                                "Image not found or unsupported"
 2769|       |                            };
 2770|     11|                            let label = if alt.is_empty() {
 2771|      1|                                src.as_str()
 2772|       |                            } else {
 2773|     10|                                alt.as_str()
 2774|       |                            };
 2775|     11|                            ui.label(
 2776|     11|                                RichText::new(format!("{}\n{}", label, msg))
 2777|     11|                                    .size(self.font_sizes.body),
 2778|       |                            );
 2779|     11|                        });
 2780|     11|                    ui.add_space(6.0);
 2781|       |                }
 2782|       |            }
 2783|       |        }
 2784|    248|    }
 2785|       |
 2786|     12|    fn extract_fragment(url: &str) -> Option<String> {
 2787|     12|        if let Some(stripped) = url.strip_prefix('#') {
                                  ^6
 2788|       |            // Already a fragment within current document
 2789|      6|            return Some(stripped.to_ascii_lowercase());
 2790|      6|        }
 2791|      6|        None
 2792|     12|    }
 2793|       |
 2794|     29|    fn is_external_url(url: &str) -> bool {
 2795|     29|        let lower = url.to_ascii_lowercase();
 2796|     29|        lower.starts_with("http://")
 2797|     28|            || lower.starts_with("https://")
 2798|     12|            || lower.starts_with("mailto:")
 2799|     11|            || lower.starts_with("www.")
 2800|     29|    }
 2801|       |
 2802|    209|    fn render_text_with_emojis(
 2803|    209|        &self,
 2804|    209|        ui: &mut egui::Ui,
 2805|    209|        text: &str,
 2806|    209|        size: f32,
 2807|    209|        style: InlineStyle,
 2808|    209|    ) {
 2809|    209|        let mut buffer = String::new();
 2810|  4.27k|        for g in text.graphemes(true) {
                               ^209 ^209
 2811|  4.27k|            if let Some(key) = self.emoji_key_for_grapheme(g) {
                                      ^8
 2812|       |                // Flush buffered text first (with highlighting if active)
 2813|      8|                if !buffer.is_empty() {
 2814|      7|                    self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
 2815|      7|                    buffer.clear();
 2816|      7|                }
                              ^1
 2817|      8|                let handle = self.get_or_make_emoji_texture(ui, &key);
 2818|      8|                let sz = size * 1.2;
 2819|      8|                ui.add(egui::Image::new(&handle).max_width(sz).max_height(sz));
 2820|  4.27k|            } else {
 2821|  4.27k|                buffer.push_str(g);
 2822|  4.27k|            }
 2823|       |        }
 2824|    209|        if !buffer.is_empty() {
 2825|    208|            self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
 2826|    208|        }
                      ^1
 2827|    209|    }
 2828|       |
 2829|    215|    fn render_text_segment_with_optional_highlight(
 2830|    215|        &self,
 2831|    215|        ui: &mut egui::Ui,
 2832|    215|        segment: &str,
 2833|    215|        size: f32,
 2834|    215|        style: InlineStyle,
 2835|    215|    ) {
 2836|       |        // First expand emoji shortcodes, then superscript ^...^ notation
 2837|    215|        let expanded = Self::expand_shortcodes(segment);
 2838|    215|        let expanded = Self::expand_superscripts(&expanded);
 2839|    215|        if let Some(h) = self
                                  ^22
 2840|    215|            .highlight_phrase
 2841|    215|            .borrow()
 2842|    215|            .as_ref()
 2843|    215|            .filter(|s| !s.is_empty())
                                       ^22^22
 2844|       |        {
 2845|     27|            for (range, highlighted) in self.highlight_segments(&expanded, Some(h)) {
                                                      ^22  ^22                ^22        ^22
 2846|     27|                let slice = &expanded[range];
 2847|     27|                if highlighted {
 2848|     10|                    self.render_highlighted_segment(ui, slice, size, style);
 2849|     17|                } else {
 2850|     17|                    self.render_plain_segment(ui, slice, size, style);
 2851|     17|                }
 2852|       |            }
 2853|     22|            return;
 2854|    193|        }
 2855|    193|        self.render_plain_segment(ui, &expanded, size, style);
 2856|    215|    }
 2857|       |
 2858|    213|    fn render_plain_segment(&self, ui: &mut egui::Ui, text: &str, size: f32, style: InlineStyle) {
 2859|    213|        if text.is_empty() {
 2860|      1|            return;
 2861|    212|        }
 2862|    212|        let mut rich = RichText::new(text).size(size);
 2863|    212|        if style.strong {
 2864|     81|            rich = rich.strong();
 2865|    131|        }
 2866|    212|        if style.italics {
 2867|     13|            rich = rich.italics();
 2868|    199|        }
 2869|    212|        if style.strike {
 2870|      1|            rich = rich.strikethrough();
 2871|    211|        }
 2872|    212|        let mut text_color = style.color;
 2873|    212|        if text_color.is_none() && style.strong {
                                                 ^206
 2874|     81|            if let Some(override_color) = ui.visuals().override_text_color {
                                      ^1
 2875|      1|                text_color = Some(override_color);
 2876|     80|            }
 2877|    131|        }
 2878|    212|        if let Some(color) = text_color {
                                  ^7
 2879|      7|            rich = rich.color(color);
 2880|    205|        }
 2881|    212|        let response = ui.add(egui::Label::new(rich).wrap(true));
 2882|       |
 2883|       |        // Add context menu for text
 2884|       |        // Note: Due to egui limitations, selection is cleared on right-click
 2885|       |        // As a workaround, we provide "Copy Text" for the segment
 2886|       |        #[cfg(test)]
 2887|    212|        {
 2888|    212|            let _ = &response;
 2889|    212|            self.render_text_context_menu(ui, text);
 2890|    212|        }
 2891|       |        #[cfg(not(test))]
 2892|       |        response.context_menu(|ui| {
 2893|       |            self.render_text_context_menu(ui, text);
 2894|       |        });
 2895|    213|    }
 2896|       |
 2897|     11|    fn render_highlighted_segment(
 2898|     11|        &self,
 2899|     11|        ui: &mut egui::Ui,
 2900|     11|        text: &str,
 2901|     11|        size: f32,
 2902|     11|        style: InlineStyle,
 2903|     11|    ) {
 2904|     11|        if text.is_empty() {
 2905|      1|            return;
 2906|     10|        }
 2907|     10|        let visuals = ui.visuals();
 2908|     10|        let bg = visuals.selection.bg_fill;
 2909|     10|        let fallback_color = visuals.selection.stroke.color;
 2910|     10|        let text_color = style.color.unwrap_or(fallback_color);
 2911|       |
 2912|     10|        let mut rich = RichText::new(text)
 2913|     10|            .size(size)
 2914|     10|            .background_color(bg)
 2915|     10|            .color(text_color);
 2916|     10|        if style.strong {
 2917|      3|            rich = rich.strong();
 2918|      7|        }
 2919|     10|        if style.italics {
 2920|      1|            rich = rich.italics();
 2921|      9|        }
 2922|     10|        if style.strike {
 2923|      1|            rich = rich.strikethrough();
 2924|      9|        }
 2925|     10|        let response = ui.add(egui::Label::new(rich).wrap(true));
 2926|       |
 2927|       |        // Add context menu for highlighted text
 2928|       |        #[cfg(test)]
 2929|     10|        {
 2930|     10|            let _ = &response;
 2931|     10|            self.render_text_context_menu(ui, text);
 2932|     10|        }
 2933|       |        #[cfg(not(test))]
 2934|       |        response.context_menu(|ui| {
 2935|       |            self.render_text_context_menu(ui, text);
 2936|       |        });
 2937|     11|    }
 2938|       |
 2939|    224|    fn render_text_context_menu(&self, ui: &mut egui::Ui, text: &str) {
 2940|    224|        if render_action_triggered(ui.button("Copy Text").clicked(), "copy_text") {
 2941|      1|            self.copy_text_and_close(ui, text);
 2942|    223|        }
 2943|    224|        ui.label("Tip: Use Ctrl+C to copy selected text");
 2944|    224|    }
 2945|       |
 2946|     24|    fn render_inline_code_context_menu(&self, ui: &mut egui::Ui, code: &str) {
 2947|     24|        if render_action_triggered(ui.button("Copy Code").clicked(), "copy_inline_code") {
 2948|      1|            self.copy_text_and_close(ui, code);
 2949|     23|        }
 2950|     24|    }
 2951|       |
 2952|     14|    fn render_code_block_context_menu(
 2953|     14|        &self,
 2954|     14|        ui: &mut egui::Ui,
 2955|     14|        code: &str,
 2956|     14|        language: Option<&str>,
 2957|     14|    ) {
 2958|     14|        if render_action_triggered(ui.button("Copy Code").clicked(), "copy_code_block") {
 2959|      1|            self.copy_text_and_close(ui, code);
 2960|     13|        }
 2961|     14|        if let Some(lang) = language {
                                  ^10
 2962|     10|            if render_action_triggered(
 2963|     10|                ui.button(format!("Copy as {}", lang)).clicked(),
 2964|       |                "copy_code_block_lang",
 2965|      2|            ) {
 2966|      2|                self.copy_text_and_close(ui, &format!("```{}\n{}\n```", lang, code));
 2967|      8|            }
 2968|      4|        }
 2969|     14|    }
 2970|       |
 2971|      8|    fn render_link_context_menu(&self, ui: &mut egui::Ui, text: &str, url: &str) {
 2972|      8|        if render_action_triggered(ui.button("Open Link").clicked(), "open_link") {
 2973|      1|            self.trigger_link(url);
 2974|      1|            ui.close_menu();
 2975|      7|        }
 2976|      8|        ui.separator();
 2977|      8|        if render_action_triggered(ui.button("Copy Link Text").clicked(), "copy_link_text") {
 2978|      1|            self.copy_text_and_close(ui, text);
 2979|      7|        }
 2980|      8|        if render_action_triggered(ui.button("Copy Link URL").clicked(), "copy_link_url") {
 2981|      1|            self.copy_text_and_close(ui, url);
 2982|      7|        }
 2983|      8|    }
 2984|       |
 2985|    135|    fn render_cell_context_menu(&self, ui: &mut egui::Ui, text: &str) {
 2986|    135|        if render_action_triggered(ui.button("Copy Cell Text").clicked(), "copy_cell_text") {
 2987|      1|            self.copy_text_and_close(ui, text);
 2988|    134|        }
 2989|    135|    }
 2990|       |
 2991|      9|    fn copy_text_and_close(&self, ui: &mut egui::Ui, text: &str) {
 2992|      9|        ui.ctx().copy_text(text.to_string());
 2993|      9|        ui.close_menu();
 2994|      9|    }
 2995|       |
 2996|       |    /// Map a grapheme cluster to an emoji image key if available.
 2997|  4.31k|    fn emoji_key_for_grapheme(&self, g: &str) -> Option<String> {
 2998|  4.31k|        if crate::emoji_catalog::image_bytes_for(g).is_some() {
 2999|      6|            return Some(g.to_string());
 3000|  4.30k|        }
 3001|  4.31k|        let stripped: String = g.chars().filter(|&c| c != '\u{FE0F}').collect();
                          ^4.30k    ^4.30k   ^4.30k^4.30k  ^4.30k                       ^4.30k
 3002|  4.30k|        if stripped != g && crate::emoji_catalog::image_bytes_for(&stripped).is_some() {
                                          ^7                                               ^7
 3003|      1|            return Some(stripped);
 3004|  4.30k|        }
 3005|       |        // If the grapheme explicitly requests emoji presentation (contains VS16),
 3006|       |        // treat it as an emoji even if we don't have a sprite; fall back to a
 3007|       |        // generated placeholder via emoji_assets to avoid stray tofu.
 3008|  4.31k|        if g.chars().any(|c| c == '\u{FE0F}') {
                         ^4.30k    ^4.30k
 3009|      6|            return Some(stripped); // prefer stripped as the texture key
 3010|  4.30k|        }
 3011|  4.30k|        None
 3012|  4.31k|    }
 3013|       |
 3014|     16|    fn get_or_make_emoji_texture(&self, ui: &mut egui::Ui, emoji: &str) -> egui::TextureHandle {
 3015|     16|        if let Some(tex) = self.emoji_textures.borrow().get(emoji) {
                                  ^1
 3016|      1|            return tex.clone();
 3017|     15|        }
 3018|       |
 3019|     15|        let img = if let Some(bytes) = emoji_catalog::image_bytes_for(emoji) {
                                            ^7
 3020|      7|            let bytes = {
 3021|       |                #[cfg(test)]
 3022|       |                {
 3023|      7|                    if FORCE_EMOJI_DECODE_ERROR.swap(false, Ordering::Relaxed) {
 3024|      2|                        b"mdmdview"
 3025|       |                    } else {
 3026|      5|                        bytes
 3027|       |                    }
 3028|       |                }
 3029|       |                #[cfg(not(test))]
 3030|       |                {
 3031|       |                    bytes
 3032|       |                }
 3033|       |            };
 3034|      7|            match image::load_from_memory(bytes) {
 3035|      5|                Ok(dyn_img) => {
 3036|      5|                    let rgba = dyn_img.to_rgba8();
 3037|      5|                    let (w, h) = rgba.dimensions();
 3038|      5|                    let pixels = rgba.into_vec();
 3039|      5|                    egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &pixels)
 3040|       |                }
 3041|      2|                Err(_) => match emoji_assets::make_image(emoji, 64) {
 3042|      1|                    Some(img) => img,
 3043|      1|                    None => self.generate_emoji_image(emoji, 64),
 3044|       |                },
 3045|       |            }
 3046|       |        } else {
 3047|      8|            match emoji_assets::make_image(emoji, 64) {
 3048|      6|                Some(img) => img,
 3049|      2|                None => self.generate_emoji_image(emoji, 64),
 3050|       |            }
 3051|       |        };
 3052|     15|        let handle = ui.ctx().load_texture(
 3053|     15|            format!("emoji:{}", emoji),
 3054|     15|            img,
 3055|       |            egui::TextureOptions::LINEAR,
 3056|       |        );
 3057|     15|        self.emoji_textures
 3058|     15|            .borrow_mut()
 3059|     15|            .insert(emoji.to_string(), handle.clone());
 3060|     15|        handle
 3061|     16|    }
 3062|       |
 3063|       |    #[cfg(test)]
 3064|       |    // Rough width measurement for inline spans without wrapping
 3065|      8|    fn measure_inline_spans(&self, ui: &egui::Ui, spans: &[InlineSpan]) -> f32 {
 3066|      8|        let mut max_line_width = 0.0f32;
 3067|      8|        let mut current_line_width = 0.0f32;
 3068|      8|        ui.fonts(|fonts| {
 3069|      8|            let body = egui::FontId::proportional(self.font_sizes.body);
 3070|      8|            let mono = egui::FontId::monospace(self.font_sizes.code);
 3071|     23|            for span in spans {
                              ^15
 3072|     15|                match span {
 3073|      7|                    InlineSpan::Text(t)
 3074|      1|                    | InlineSpan::Strong(t)
 3075|      1|                    | InlineSpan::Emphasis(t)
 3076|      1|                    | InlineSpan::Strikethrough(t)
 3077|      1|                    | InlineSpan::Link { text: t, .. } => {
 3078|       |                        // Normalize to match render path before measuring.
 3079|     11|                        let mut normalized = self.fix_unicode_chars(t);
 3080|     11|                        normalized = Self::expand_shortcodes(&normalized);
 3081|     11|                        normalized = Self::expand_superscripts(&normalized);
 3082|     16|                        for (line_idx, line) in normalized.split('\n').enumerate() {
                                                              ^11                    ^11
 3083|     16|                            if line_idx > 0 {
 3084|      5|                                max_line_width = max_line_width.max(current_line_width);
 3085|      5|                                current_line_width = 0.0;
 3086|     11|                            }
 3087|     16|                            if line.is_empty() {
 3088|      3|                                continue;
 3089|     13|                            }
 3090|     13|                            let galley = fonts.layout_no_wrap(
 3091|     13|                                line.to_string(),
 3092|     13|                                body.clone(),
 3093|       |                                Color32::WHITE,
 3094|       |                            );
 3095|     13|                            let mut line_width = galley.size().x;
 3096|       |                            // Add a small extra width for emoji images (drawn larger than text).
 3097|     13|                            let emoji_extra =
 3098|    102|                                line.chars().filter(|c| Self::is_known_emoji(*c)).count() as f32
                                              ^13  ^13     ^13                                  ^13
 3099|     13|                                    * (self.font_sizes.body * 0.2);
 3100|     13|                            line_width += emoji_extra;
 3101|     13|                            if current_line_width > 0.0 {
 3102|      3|                                current_line_width += 4.0;
 3103|     10|                            }
 3104|     13|                            current_line_width += line_width;
 3105|       |                        }
 3106|       |                    }
 3107|      2|                    InlineSpan::Code(code) => {
 3108|      5|                        for (line_idx, line) in code.split('\n').enumerate() {
                                                              ^2               ^2
 3109|      5|                            if line_idx > 0 {
 3110|      3|                                max_line_width = max_line_width.max(current_line_width);
 3111|      3|                                current_line_width = 0.0;
 3112|      3|                            }
                                          ^2
 3113|      5|                            if line.is_empty() {
 3114|      1|                                continue;
 3115|      4|                            }
 3116|      4|                            let galley = fonts.layout_no_wrap(
 3117|      4|                                line.to_string(),
 3118|      4|                                mono.clone(),
 3119|       |                                Color32::WHITE,
 3120|       |                            );
 3121|      4|                            let line_width = galley.size().x + 6.0; // padding for code background
 3122|      4|                            if current_line_width > 0.0 {
 3123|      1|                                current_line_width += 4.0;
 3124|      3|                            }
 3125|      4|                            current_line_width += line_width;
 3126|       |                        }
 3127|       |                    }
 3128|      2|                    InlineSpan::Image { src, .. } => {
 3129|       |                        // Use cached texture size if available; otherwise a conservative thumbnail.
 3130|      2|                        let cap = (ui.available_width() * 0.6).max(48.0);
 3131|      2|                        let cached = self
 3132|      2|                            .image_textures
 3133|      2|                            .borrow_mut()
 3134|      2|                            .get(src)
 3135|      2|                            .map(|entry| entry.size[0] as f32 * self.ui_scale());
                                                       ^1                     ^1   ^1
 3136|      2|                        let approx = cached.unwrap_or(self.font_sizes.body * 12.0);
 3137|      2|                        let line_width = approx.min(cap);
 3138|      2|                        if current_line_width > 0.0 {
 3139|      1|                            current_line_width += 4.0;
 3140|      1|                        }
 3141|      2|                        current_line_width += line_width;
 3142|       |                    }
 3143|       |                }
 3144|       |            }
 3145|      8|        });
 3146|      8|        max_line_width.max(current_line_width)
 3147|      8|    }
 3148|       |
 3149|       |    #[cfg(test)]
 3150|    102|    fn is_known_emoji(c: char) -> bool {
 3151|    101|        matches!(
 3152|    102|            c,
 3153|       |            '\u{1f389}' // 
 3154|       |                | '\u{2705}' // 
 3155|       |                | '\u{1f680}' // 
 3156|       |                | '\u{1f642}' // 
 3157|       |                | '\u{1f600}' // 
 3158|       |                | '\u{1f609}' // 
 3159|       |                | '\u{2b50}'  // 
 3160|       |                | '\u{1f525}' // 
 3161|       |                | '\u{1f44d}' // 
 3162|       |                | '\u{1f44e}' // 
 3163|       |                | '\u{1f4a1}' // 
 3164|       |                | '\u{2753}'  // 
 3165|       |                | '\u{2757}'  // 
 3166|       |                | '\u{1f4dd}' // 
 3167|       |                | '\u{1f9e0}' // 
 3168|       |                | '\u{1f9ea}' // 
 3169|       |                | '\u{1f4e6}' // 
 3170|       |                | '\u{1f527}' // 
 3171|       |        )
 3172|    102|    }
 3173|       |
 3174|    471|    fn expand_shortcodes(s: &str) -> String {
 3175|       |        use crate::emoji_catalog::shortcode_map;
 3176|    471|        if !s.contains(':') {
 3177|    448|            return s.to_string();
 3178|     23|        }
 3179|     23|        let mut out = String::new();
 3180|     23|        let map = shortcode_map();
 3181|     23|        let mut i = 0;
 3182|     23|        let bytes = s.as_bytes();
 3183|    370|        while i < s.len() {
 3184|    347|            if bytes[i] == b':' {
 3185|    305|                if let Some(end_rel) = bytes[i + 1..].iter().position(|&b| b == b':') {
                                          ^5         ^24                   ^24
 3186|      5|                    let end = i + 1 + end_rel;
 3187|      5|                    let code = &s[i..=end];
 3188|      5|                    if let Some(&emoji) = map.get(code) {
                                               ^4
 3189|      4|                        out.push_str(emoji);
 3190|      4|                        i = end + 1;
 3191|      4|                        continue;
 3192|      1|                    }
 3193|     19|                }
 3194|    323|            }
 3195|       |            // advance by one UTF-8 character
 3196|    343|            let ch = s[i..].chars().next().unwrap();
 3197|    343|            out.push(ch);
 3198|    343|            i += ch.len_utf8();
 3199|       |        }
 3200|     23|        out
 3201|    471|    }
 3202|       |
 3203|       |    // Expand ^...^ segments into Unicode superscript characters when available.
 3204|       |    // Example: "5^th^" -> "5??"
 3205|    475|    fn expand_superscripts(s: &str) -> String {
 3206|    475|        if !s.contains('^') {
 3207|    467|            return s.to_string();
 3208|      8|        }
 3209|      8|        let mut out = String::new();
 3210|      8|        let mut chars = s.chars().peekable();
 3211|    203|        while let Some(c) = chars.next() {
                                     ^195
 3212|    195|            if c == '^' {
 3213|       |                // Look ahead to see if there's a matching closing caret within reasonable bounds
 3214|     14|                let mut buf = String::new();
 3215|     14|                let mut found_closing = false;
 3216|     14|                let mut temp_chars = chars.clone();
 3217|     14|                let mut char_count = 0;
 3218|       |
 3219|     41|                while let Some(&nc) = temp_chars.peek() {
                                              ^38
 3220|     38|                    if nc == '^' {
 3221|      5|                        found_closing = true;
 3222|      5|                        break;
 3223|     33|                    }
 3224|     33|                    if !nc.is_alphanumeric() && !matches!(nc, '+' | '-' | '=' | '(' | ')') {
                                                               ^5       ^6
 3225|      5|                        break;
 3226|     28|                    }
 3227|     28|                    if char_count >= 10 {
 3228|      1|                        break;
 3229|     27|                    }
 3230|     27|                    temp_chars.next();
 3231|     27|                    char_count += 1;
 3232|       |                }
 3233|       |
 3234|     14|                if found_closing && char_count > 0 {
                                                  ^5
 3235|      6|                    for nc in chars.by_ref().take(char_count) {
                                            ^4             ^4   ^4
 3236|      6|                        buf.push(nc);
 3237|      6|                    }
 3238|       |                    // Skip the closing caret
 3239|      4|                    chars.next();
 3240|      4|                    out.push_str(&Self::to_superscript(&buf));
 3241|     10|                } else {
 3242|     10|                    out.push('^');
 3243|     10|                }
 3244|    181|            } else {
 3245|    181|                out.push(c);
 3246|    181|            }
 3247|       |        }
 3248|      8|        out
 3249|    475|    }
 3250|       |
 3251|      6|    fn to_superscript(s: &str) -> String {
 3252|      6|        s.chars()
 3253|     81|            .map(|c| match c {
                           ^6
 3254|      1|                '0' => '\u{2070}',
 3255|      2|                '1' => '\u{00b9}',
 3256|      3|                '2' => '\u{00b2}',
 3257|      2|                '3' => '\u{00b3}',
 3258|      1|                '4' => '\u{2074}',
 3259|      1|                '5' => '\u{2075}',
 3260|      1|                '6' => '\u{2076}',
 3261|      1|                '7' => '\u{2077}',
 3262|      1|                '8' => '\u{2078}',
 3263|      1|                '9' => '\u{2079}',
 3264|      2|                '+' => '\u{207a}',
 3265|      1|                '-' => '\u{207b}',
 3266|      1|                '=' => '\u{207c}',
 3267|      1|                '(' => '\u{207d}',
 3268|      1|                ')' => '\u{207e}',
 3269|      3|                'a' | 'A' => '\u{1d43}',
 3270|      3|                'b' | 'B' => '\u{1d47}',
 3271|      3|                'c' | 'C' => '\u{1d9c}',
 3272|      2|                'd' | 'D' => '\u{1d48}',
 3273|      2|                'e' | 'E' => '\u{1d49}',
 3274|      2|                'f' | 'F' => '\u{1da0}',
 3275|      2|                'g' | 'G' => '\u{1d4d}',
 3276|      4|                'h' | 'H' => '\u{02b0}',
 3277|      2|                'i' | 'I' => '\u{2071}',
 3278|      2|                'j' | 'J' => '\u{02b2}',
 3279|      2|                'k' | 'K' => '\u{1d4f}',
 3280|      2|                'l' | 'L' => '\u{02e1}',
 3281|      2|                'm' | 'M' => '\u{1d50}',
 3282|      2|                'n' | 'N' => '\u{207f}',
 3283|      2|                'o' | 'O' => '\u{1d52}',
 3284|      2|                'p' | 'P' => '\u{1d56}',
 3285|      2|                'q' | 'Q' => '\u{1d56}',
 3286|      2|                'r' | 'R' => '\u{02b3}',
 3287|      2|                's' | 'S' => '\u{02e2}',
 3288|      4|                't' | 'T' => '\u{1d57}',
 3289|      2|                'u' | 'U' => '\u{1d58}',
 3290|      2|                'v' | 'V' => '\u{1d5b}',
 3291|      2|                'w' | 'W' => '\u{02b7}',
 3292|      2|                'x' | 'X' => '\u{02e3}',
 3293|      2|                'y' | 'Y' => '\u{02b8}',
 3294|      2|                'z' | 'Z' => '\u{1dbb}',
 3295|      2|                other => other,
 3296|     81|            })
 3297|      6|            .collect()
 3298|      6|    }
 3299|       |
 3300|     23|    fn generate_emoji_image(&self, emoji: &str, size: usize) -> egui::ColorImage {
 3301|       |        // Simple procedural placeholder icons to keep binary small and avoid external assets
 3302|       |        use egui::Color32 as C;
 3303|     23|        let mut img = egui::ColorImage::new([size, size], C::TRANSPARENT);
 3304|     23|        let cx = (size as i32) / 2;
 3305|     23|        let cy = cx;
 3306|     23|        let r = (size as i32) / 2 - 2;
 3307|       |
 3308|     23|        let (base, accent) = match emoji {
 3309|     23|            "\u{1f389}" => (C::from_rgb(255, 215, 0), C::from_rgb(255, 80, 80)),
                                         ^1
 3310|     22|            "\u{2705}" => (C::from_rgb(30, 150, 30), C::WHITE),
                                        ^1
 3311|     21|            "\u{1f680}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 100, 100)),
                                         ^1
 3312|     20|            "\u{1f642}" | "\u{1f600}" | "\u{1f609}" => {
                                        ^19           ^18
 3313|      3|                (C::from_rgb(255, 205, 64), C::from_rgb(90, 60, 10))
 3314|       |            }
 3315|     17|            "\u{2b50}" => (C::from_rgb(255, 215, 0), C::WHITE),
                                        ^1
 3316|     16|            "\u{1f525}" => (C::from_rgb(255, 120, 50), C::from_rgb(255, 200, 120)),
                                         ^1
 3317|     15|            "\u{1f44d}" | "\u{1f44e}" => (C::from_rgb(200, 200, 200), C::from_rgb(80, 80, 80)),
                                        ^14            ^2
 3318|     13|            "\u{1f4a1}" => (C::from_rgb(255, 240, 120), C::from_rgb(255, 255, 255)),
                                         ^1
 3319|     12|            "\u{2753}" | "\u{2757}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 255, 255)),
                                       ^11           ^2
 3320|     10|            "\u{1f4dd}" => (C::from_rgb(240, 240, 200), C::from_rgb(140, 140, 140)),
                                         ^1
 3321|      9|            "\u{1f9e0}" => (C::from_rgb(220, 160, 200), C::from_rgb(255, 255, 255)),
                                         ^1
 3322|      8|            "\u{1f9ea}" => (C::from_rgb(180, 220, 255), C::from_rgb(120, 160, 240)),
                                         ^1
 3323|      7|            "\u{1f4e6}" => (C::from_rgb(205, 170, 125), C::from_rgb(150, 110, 70)),
                                         ^1
 3324|      6|            "\u{1f527}" => (C::from_rgb(160, 170, 180), C::from_rgb(220, 220, 220)),
                                         ^2
 3325|      4|            _ => (C::from_rgb(180, 180, 180), C::WHITE),
 3326|       |        };
 3327|       |
 3328|       |        // draw filled circle
 3329|    360|        for y in 0..size as i32 {
                                  ^23
 3330|  13.7k|            for x in 0..size as i32 {
                                      ^360
 3331|  13.7k|                let dx = x - cx;
 3332|  13.7k|                let dy = y - cy;
 3333|  13.7k|                if dx * dx + dy * dy <= r * r {
 3334|  8.82k|                    img[(x as usize, y as usize)] = base;
 3335|  8.82k|                }
                              ^4.93k
 3336|       |            }
 3337|       |        }
 3338|       |
 3339|       |        // add a simple accent (diagonal highlight)
 3340|    360|        for t in 0..size {
                                  ^23
 3341|    360|            let x = t as i32;
 3342|    360|            let y = (t as i32) / 2;
 3343|    360|            let xx = (x / 2 + 6).clamp(0, size as i32 - 1) as usize;
 3344|    360|            let yy = (y + 6).clamp(0, size as i32 - 1) as usize;
 3345|    360|            img[(xx, yy)] = accent;
 3346|    360|        }
 3347|       |
 3348|     23|        img
 3349|     23|    }
 3350|       |
 3351|     57|    fn render_list_paragraph(
 3352|     57|        &self,
 3353|     57|        ui: &mut egui::Ui,
 3354|     57|        marker: Option<&str>,
 3355|     57|        marker_color: Color32,
 3356|     57|        indent_px: f32,
 3357|     57|        spans: &[InlineSpan],
 3358|     57|    ) {
 3359|       |        // Split into lines on embedded '\n'
 3360|     57|        let mut lines: Vec<Vec<InlineSpan>> = vec![Vec::new()];
 3361|    142|        for s in spans.iter().cloned() {
                               ^57   ^57    ^57
 3362|     75|            match s {
 3363|     75|                InlineSpan::Text(t) if t.contains('\n') => {
                                               ^3                   ^3
 3364|      3|                    let parts: Vec<&str> = t.split('\n').collect();
 3365|      7|                    for (pi, part) in parts.iter().enumerate() {
                                                    ^3           ^3
 3366|      7|                        if !part.is_empty() {
 3367|      6|                            lines
 3368|      6|                                .last_mut()
 3369|      6|                                .unwrap()
 3370|      6|                                .push(InlineSpan::Text(part.to_string()));
 3371|      6|                        }
                                      ^1
 3372|      7|                        if pi < parts.len() - 1 {
 3373|      4|                            lines.push(Vec::new());
 3374|      4|                        }
                                      ^3
 3375|       |                    }
 3376|       |                }
 3377|    139|                other => lines.last_mut().unwrap().push(other),
 3378|       |            }
 3379|       |        }
 3380|       |
 3381|     61|        for (li, mut line) in lines.into_iter().enumerate() {
                                            ^57   ^57         ^57
 3382|     61|            ui.horizontal_wrapped(|ui| {
 3383|     61|                if li == 0 {
 3384|     57|                    if let Some(marker) = marker {
                                              ^53
 3385|     53|                        ui.label(
 3386|     53|                            RichText::new(format!("{} ", marker))
 3387|     53|                                .size(self.font_sizes.body)
 3388|     53|                                .color(marker_color),
 3389|     53|                        );
 3390|     53|                    } else {
 3391|      4|                        ui.add_space(indent_px);
 3392|      4|                    }
 3393|       |                } else {
 3394|       |                    // Determine additional indentation from leading spaces in this line
 3395|      4|                    let mut leading_spaces = 0usize;
 3396|      4|                    if let Some(InlineSpan::Text(t0)) = line.first_mut() {
                                                               ^3
 3397|      7|                        leading_spaces = t0.chars().take_while(|c| *c == ' ').count();
                                                       ^3         ^3                        ^3
 3398|      3|                        if leading_spaces > 0 {
 3399|      2|                            let trimmed = t0.trim_start_matches(' ').to_string();
 3400|      2|                            *t0 = trimmed;
 3401|      2|                        }
                                      ^1
 3402|      1|                    }
 3403|      4|                    let indent = indent_px + (leading_spaces as f32) * 6.0;
 3404|      4|                    ui.add_space(indent);
 3405|       |                }
 3406|     61|                ui.spacing_mut().item_spacing.x = 0.0;
 3407|    206|                for span in &line {
                                  ^145
 3408|    145|                    self.render_inline_span(ui, span, None, None);
 3409|    145|                }
 3410|     61|            });
 3411|       |        }
 3412|     57|    }
 3413|       |
 3414|       |    /// Render a list with proper inline formatting, including nested block content
 3415|     18|    fn render_list(&self, ui: &mut egui::Ui, ordered: bool, items: &[ListItem]) {
 3416|     18|        if items.is_empty() {
 3417|      2|            return;
 3418|     16|        }
 3419|       |
 3420|     16|        ui.add_space(4.0);
 3421|     16|        let marker_color = ui.visuals().text_color();
 3422|     16|        let indent_px = 18.0;
 3423|       |
 3424|     57|        for (index, item) in items.iter().enumerate() {
                                           ^16   ^16    ^16
 3425|     57|            let marker = if ordered {
 3426|     22|                format!("{}.", index + 1)
 3427|       |            } else {
 3428|     35|                "-".to_string()
 3429|       |            };
 3430|       |
 3431|     57|            let mut blocks = item.blocks.iter();
 3432|     57|            if let Some(first_block) = blocks.next() {
                                      ^55
 3433|     55|                match first_block {
 3434|     53|                    MarkdownElement::Paragraph(spans) => {
 3435|     53|                        self.render_list_paragraph(
 3436|     53|                            ui,
 3437|     53|                            Some(&marker),
 3438|     53|                            marker_color,
 3439|     53|                            indent_px,
 3440|     53|                            spans,
 3441|     53|                        );
 3442|     53|                    }
 3443|       |                    _ => {
 3444|      2|                        ui.horizontal_wrapped(|ui| {
 3445|      2|                            ui.label(
 3446|      2|                                RichText::new(format!("{} ", marker))
 3447|      2|                                    .size(self.font_sizes.body)
 3448|      2|                                    .color(marker_color),
 3449|       |                            );
 3450|      2|                        });
 3451|      2|                        self.render_list_block(ui, first_block, indent_px, marker_color);
 3452|       |                    }
 3453|       |                }
 3454|       |            } else {
 3455|      2|                ui.horizontal_wrapped(|ui| {
 3456|      2|                    ui.label(
 3457|      2|                        RichText::new(format!("{} ", marker))
 3458|      2|                            .size(self.font_sizes.body)
 3459|      2|                            .color(marker_color),
 3460|       |                    );
 3461|      2|                });
 3462|       |            }
 3463|       |
 3464|     61|            for block in blocks {
                              ^4
 3465|      4|                self.render_list_block(ui, block, indent_px, marker_color);
 3466|      4|            }
 3467|       |        }
 3468|       |
 3469|     16|        ui.add_space(4.0);
 3470|     18|    }
 3471|       |
 3472|      7|    fn render_list_block(
 3473|      7|        &self,
 3474|      7|        ui: &mut egui::Ui,
 3475|      7|        block: &MarkdownElement,
 3476|      7|        indent_px: f32,
 3477|      7|        marker_color: Color32,
 3478|      7|    ) {
 3479|      7|        match block {
 3480|      2|            MarkdownElement::Paragraph(spans) => {
 3481|      2|                self.render_list_paragraph(ui, None, marker_color, indent_px, spans);
 3482|      2|            }
 3483|       |            _ => {
 3484|      5|                ui.horizontal(|ui| {
 3485|      5|                    ui.add_space(indent_px);
 3486|      5|                    ui.vertical(|ui| {
 3487|      5|                        self.render_element_body(ui, block);
 3488|      5|                    });
 3489|      5|                });
 3490|       |            }
 3491|       |        }
 3492|      7|    }
 3493|       |
 3494|       |    /// Render a code block with syntax highlighting
 3495|     11|    fn render_code_block(&self, ui: &mut egui::Ui, language: Option<&str>, code: &str) {
 3496|     11|        ui.add_space(8.0);
 3497|       |
 3498|       |        // Special handling for Mermaid diagrams
 3499|     11|        if let Some(lang) = language {
                                  ^8
 3500|      8|            if lang.eq_ignore_ascii_case("mermaid") {
 3501|      1|                let _ = self.render_mermaid_block(ui, code);
 3502|      1|                ui.add_space(8.0);
 3503|      1|                return;
 3504|      7|            }
 3505|      3|        }
 3506|       |
 3507|     10|        let frame_response = egui::Frame::none()
 3508|     10|            .fill(Color32::from_rgb(25, 25, 25))
 3509|     10|            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 3510|     10|            .inner_margin(8.0)
 3511|     10|            .show(ui, |ui| {
 3512|     10|                ui.with_layout(egui::Layout::top_down(egui::Align::LEFT), |ui| {
 3513|     10|                    if let Some(lang) = language {
                                              ^7
 3514|      7|                        ui.label(
 3515|      7|                            RichText::new(lang)
 3516|      7|                                .size(self.font_sizes.code - 1.0)
 3517|      7|                                .color(Color32::from_rgb(150, 150, 150))
 3518|      7|                                .family(egui::FontFamily::Monospace),
 3519|      7|                        );
 3520|      7|                        ui.add_space(2.0);
 3521|      7|                    }
                                  ^3
 3522|       |
 3523|       |                    // Try syntax highlighting
 3524|     10|                    if let Some(lang) = language {
                                              ^7
 3525|      7|                        if let Some(syntax) = self
                                                  ^6
 3526|      7|                            .find_syntax_for_language(lang)
 3527|      7|                            .or_else(|| self.syntax_set.find_syntax_by_first_line(code))
                                                      ^1              ^1                        ^1
 3528|       |                        {
 3529|      6|                            let theme = &self.theme_set.themes["base16-ocean.dark"];
 3530|      6|                            let mut h = HighlightLines::new(syntax, theme);
 3531|       |
 3532|     10|                            for line in LinesWithEndings::from(code) {
                                                      ^6                     ^6
 3533|     10|                                let ranges =
 3534|     10|                                    h.highlight_line(line, &self.syntax_set).unwrap_or_default();
 3535|       |
 3536|     10|                                ui.horizontal_wrapped(|ui| {
 3537|       |                                    // Remove spacing between tokens to avoid visual gaps
 3538|     10|                                    ui.spacing_mut().item_spacing.x = 0.0;
 3539|     73|                                    for (style, text) in ranges {
                                                       ^63    ^63
 3540|       |                                        // Drop newline characters completely; they're handled by the outer line loop
 3541|     63|                                        let cleaned = text.replace(['\n', '\r'], "");
 3542|       |
 3543|     63|                                        if cleaned.is_empty() {
 3544|      4|                                            continue;
 3545|     59|                                        }
 3546|       |
 3547|       |                                        // Check if this token is pure whitespace (spaces or tabs only)
 3548|     70|                                        if cleaned.chars().all(|c| c == ' ' || c == '\t') {
                                                         ^59             ^59                 ^43
 3549|     16|                                            // Render whitespace as transparent to preserve layout without visual gaps
 3550|     16|                                            ui.label(
 3551|     16|                                                RichText::new(cleaned)
 3552|     16|                                                    .size(self.font_sizes.code)
 3553|     16|                                                    .color(Color32::TRANSPARENT)
 3554|     16|                                                    .family(egui::FontFamily::Monospace),
 3555|     16|                                            );
 3556|     16|                                        } else {
 3557|       |                                            // For non-whitespace, use normal highlighting but replace spaces with transparent ones
 3558|     43|                                            let color = Color32::from_rgb(
 3559|     43|                                                style.foreground.r,
 3560|     43|                                                style.foreground.g,
 3561|     43|                                                style.foreground.b,
 3562|       |                                            );
 3563|       |
 3564|       |                                            // Split by spaces and handle separately
 3565|     43|                                            let parts: Vec<&str> = cleaned.split(' ').collect();
 3566|     49|                                            for (i, part) in parts.iter().enumerate() {
                                                                           ^43          ^43
 3567|     49|                                                if !part.is_empty() {
 3568|     45|                                                    let mut rich_text = RichText::new(*part)
 3569|     45|                                                        .size(self.font_sizes.code)
 3570|     45|                                                        .color(color)
 3571|     45|                                                        .family(egui::FontFamily::Monospace);
 3572|       |
 3573|     45|                                                    if style.font_style.contains(
 3574|       |                                                        syntect::highlighting::FontStyle::BOLD,
 3575|      6|                                                    ) {
 3576|      6|                                                        rich_text = rich_text.strong();
 3577|     39|                                                    }
 3578|     45|                                                    if style.font_style.contains(
 3579|       |                                                        syntect::highlighting::FontStyle::ITALIC,
 3580|      6|                                                    ) {
 3581|      6|                                                        rich_text = rich_text.italics();
 3582|     39|                                                    }
 3583|       |
 3584|     45|                                                    ui.label(rich_text);
 3585|      4|                                                }
 3586|       |
 3587|       |                                                // Add transparent space between parts (except after last part)
 3588|     49|                                                if i < parts.len() - 1 {
 3589|      6|                                                    ui.label(
 3590|      6|                                                        RichText::new(" ")
 3591|      6|                                                            .size(self.font_sizes.code)
 3592|      6|                                                            .color(Color32::TRANSPARENT)
 3593|      6|                                                            .family(egui::FontFamily::Monospace),
 3594|      6|                                                    );
 3595|     43|                                                }
 3596|       |                                            }
 3597|       |                                        }
 3598|       |                                    }
 3599|     10|                                });
 3600|       |                            }
 3601|      6|                            return; // Early return if highlighting succeeded
 3602|      1|                        }
 3603|      3|                    }
 3604|       |
 3605|       |                    // Fallback: render as plain text
 3606|      4|                    ui.label(
 3607|      4|                        RichText::new(code)
 3608|      4|                            .size(self.font_sizes.code)
 3609|      4|                            .color(Color32::from_rgb(220, 220, 220))
 3610|      4|                            .family(egui::FontFamily::Monospace),
 3611|       |                    );
 3612|     10|                });
 3613|     10|            });
 3614|       |
 3615|       |        // Add context menu for code blocks
 3616|       |        #[cfg(test)]
 3617|     10|        {
 3618|     10|            let _ = &frame_response;
 3619|     10|            self.render_code_block_context_menu(ui, code, language);
 3620|     10|        }
 3621|       |        #[cfg(not(test))]
 3622|       |        frame_response.response.context_menu(|ui| {
 3623|       |            self.render_code_block_context_menu(ui, code, language);
 3624|       |        });
 3625|       |
 3626|     10|        ui.add_space(8.0);
 3627|     11|    }
 3628|       |
 3629|       |    /// Try to render a Mermaid diagram. Returns true if handled (rendered or placeholder drawn).
 3630|      1|    fn render_mermaid_block(&self, ui: &mut egui::Ui, code: &str) -> bool {
 3631|      1|        self.mermaid
 3632|      1|            .render_block(ui, code, self.ui_scale(), self.font_sizes.code)
 3633|      1|    }
 3634|       |
 3635|      8|    fn hash_str(s: &str) -> u64 {
 3636|      8|        let mut h = DefaultHasher::new();
 3637|      8|        s.hash(&mut h);
 3638|      8|        h.finish()
 3639|      8|    }
 3640|       |
 3641|    577|    fn hash_inline_spans(spans: &[InlineSpan]) -> u64 {
 3642|    577|        let mut h = DefaultHasher::new();
 3643|  1.20k|        for span in spans {
                          ^628
 3644|    628|            match span {
 3645|    600|                InlineSpan::Text(t) => {
 3646|    600|                    0u8.hash(&mut h);
 3647|    600|                    t.hash(&mut h);
 3648|    600|                }
 3649|      1|                InlineSpan::Code(t) => {
 3650|      1|                    1u8.hash(&mut h);
 3651|      1|                    t.hash(&mut h);
 3652|      1|                }
 3653|     10|                InlineSpan::Strong(t) => {
 3654|     10|                    2u8.hash(&mut h);
 3655|     10|                    t.hash(&mut h);
 3656|     10|                }
 3657|      1|                InlineSpan::Emphasis(t) => {
 3658|      1|                    3u8.hash(&mut h);
 3659|      1|                    t.hash(&mut h);
 3660|      1|                }
 3661|      1|                InlineSpan::Strikethrough(t) => {
 3662|      1|                    4u8.hash(&mut h);
 3663|      1|                    t.hash(&mut h);
 3664|      1|                }
 3665|     10|                InlineSpan::Link { text, url } => {
 3666|     10|                    5u8.hash(&mut h);
 3667|     10|                    text.hash(&mut h);
 3668|     10|                    url.hash(&mut h);
 3669|     10|                }
 3670|      5|                InlineSpan::Image { src, alt, title } => {
 3671|      5|                    6u8.hash(&mut h);
 3672|      5|                    src.hash(&mut h);
 3673|      5|                    alt.hash(&mut h);
 3674|      5|                    title.hash(&mut h);
 3675|      5|                }
 3676|       |            }
 3677|       |        }
 3678|    577|        h.finish()
 3679|    577|    }
 3680|       |
 3681|     23|    fn alignment_hash(align: Alignment) -> u8 {
 3682|     23|        match align {
 3683|     10|            Alignment::None => 0,
 3684|      7|            Alignment::Left => 1,
 3685|      3|            Alignment::Center => 2,
 3686|      3|            Alignment::Right => 3,
 3687|       |        }
 3688|     23|    }
 3689|       |
 3690|      8|    fn alignment_to_egui(align: Alignment) -> Align {
 3691|      8|        match align {
 3692|      1|            Alignment::Center => Align::Center,
 3693|      1|            Alignment::Right => Align::RIGHT,
 3694|      6|            Alignment::Left | Alignment::None => Align::LEFT,
 3695|       |        }
 3696|      8|    }
 3697|       |
 3698|     55|    fn alignment_for_column(alignments: &[Alignment], col_idx: usize) -> Align {
 3699|     55|        alignments
 3700|     55|            .get(col_idx)
 3701|     55|            .copied()
 3702|     55|            .map(Self::alignment_to_egui)
 3703|     55|            .unwrap_or(Align::LEFT)
 3704|     55|    }
 3705|       |
 3706|    176|    fn align_to_u8(align: Align) -> u8 {
 3707|    176|        if align == Align::LEFT {
 3708|    166|            0
 3709|     10|        } else if align == Align::Center {
 3710|      5|            1
 3711|       |        } else {
 3712|      5|            2
 3713|       |        }
 3714|    176|    }
 3715|       |
 3716|      4|    fn next_table_index(&self) -> u64 {
 3717|      4|        let mut counter = self.table_counter.borrow_mut();
 3718|      4|        let idx = *counter;
 3719|      4|        *counter += 1;
 3720|      4|        idx
 3721|      4|    }
 3722|       |
 3723|     23|    fn compute_table_id(
 3724|     23|        &self,
 3725|     23|        headers: &[Vec<InlineSpan>],
 3726|     23|        rows: &[Vec<Vec<InlineSpan>>],
 3727|     23|        alignments: &[Alignment],
 3728|     23|        table_index: u64,
 3729|     23|    ) -> u64 {
 3730|     23|        let mut hasher = DefaultHasher::new();
 3731|     23|        if let Some(base) = self.base_dir.borrow().as_ref() {
                                  ^1
 3732|      1|            base.hash(&mut hasher);
 3733|     22|        }
 3734|     23|        hasher.write_u64(table_index);
 3735|     23|        hasher.write_u64(self.compute_table_content_hash(headers, rows, alignments));
 3736|     23|        hasher.finish()
 3737|     23|    }
 3738|       |
 3739|     44|    fn compute_table_content_hash(
 3740|     44|        &self,
 3741|     44|        headers: &[Vec<InlineSpan>],
 3742|     44|        rows: &[Vec<Vec<InlineSpan>>],
 3743|     44|        alignments: &[Alignment],
 3744|     44|    ) -> u64 {
 3745|     44|        let mut hasher = DefaultHasher::new();
 3746|     44|        hasher.write_usize(headers.len());
 3747|    156|        for header in headers {
                          ^112
 3748|    112|            hasher.write_u64(Self::hash_inline_spans(header));
 3749|    112|        }
 3750|     44|        hasher.write_usize(alignments.len());
 3751|     67|        for align in alignments {
                          ^23
 3752|     23|            hasher.write_u8(Self::alignment_hash(*align));
 3753|     23|        }
 3754|     44|        let mut counted = 0usize;
 3755|    230|        for row in rows {
                          ^187
 3756|    474|            for cell in row {
                              ^287
 3757|    287|                hasher.write_u64(Self::hash_inline_spans(cell));
 3758|    287|            }
 3759|    187|            counted += 1;
 3760|    187|            if counted >= COLUMN_STATS_SAMPLE_ROWS {
 3761|      1|                break;
 3762|    186|            }
 3763|       |        }
 3764|     44|        hasher.finish()
 3765|     44|    }
 3766|       |
 3767|     20|    fn column_stats_for_table(
 3768|     20|        &self,
 3769|     20|        table_id: u64,
 3770|     20|        headers: &[Vec<InlineSpan>],
 3771|     20|        rows: &[Vec<Vec<InlineSpan>>],
 3772|     20|        alignments: &[Alignment],
 3773|     20|    ) -> Vec<ColumnStat> {
 3774|     20|        let content_hash = self.compute_table_content_hash(headers, rows, alignments);
 3775|     20|        if let Some(entry) = self
                                  ^2
 3776|     20|            .column_stats_cache
 3777|     20|            .borrow()
 3778|     20|            .get(&table_id)
 3779|     20|            .filter(|entry| entry.content_hash == content_hash)
                                          ^2                    ^2
 3780|       |        {
 3781|      2|            return entry.stats.clone();
 3782|     18|        }
 3783|     18|        let stats = compute_column_stats(headers, rows, COLUMN_STATS_SAMPLE_ROWS);
 3784|     18|        self.column_stats_cache.borrow_mut().insert(
 3785|     18|            table_id,
 3786|     18|            ColumnStatsCacheEntry {
 3787|     18|                content_hash,
 3788|     18|                stats: stats.clone(),
 3789|     18|            },
 3790|     18|        );
 3791|     18|        stats
 3792|     20|    }
 3793|       |
 3794|       |    /// Render a table using an egui Grid
 3795|      5|    fn render_table(
 3796|      5|        &self,
 3797|      5|        ui: &mut egui::Ui,
 3798|      5|        headers: &[Vec<InlineSpan>],
 3799|      5|        rows: &[Vec<Vec<InlineSpan>>],
 3800|      5|        alignments: &[Alignment],
 3801|      5|    ) {
 3802|      5|        if headers.is_empty() {
 3803|      1|            return;
 3804|      4|        }
 3805|       |
 3806|      4|        let table_index = self.next_table_index();
 3807|      4|        let table_id = self.compute_table_id(headers, rows, alignments, table_index);
 3808|      4|        self.render_table_tablebuilder(ui, headers, rows, alignments, table_id);
 3809|      4|        ui.add_space(8.0);
 3810|      5|    }
 3811|       |
 3812|    136|    fn extend_table_rect(target: &mut Option<egui::Rect>, rect: egui::Rect) {
 3813|    136|        if rect.min.x.is_nan() || rect.min.y.is_nan() || rect.max.x.is_nan() || rect.max.y.is_nan()
                                                ^135       ^135        ^134       ^134        ^133       ^133
 3814|       |        {
 3815|      4|            return;
 3816|    132|        }
 3817|    132|        if let Some(existing) = target {
                                  ^93
 3818|     93|            existing.min.x = existing.min.x.min(rect.min.x);
 3819|     93|            existing.min.y = existing.min.y.min(rect.min.y);
 3820|     93|            existing.max.x = existing.max.x.max(rect.max.x);
 3821|     93|            existing.max.y = existing.max.y.max(rect.max.y);
 3822|     93|        } else {
 3823|     39|            *target = Some(rect);
 3824|     39|        }
 3825|    136|    }
 3826|       |
 3827|     19|    fn render_table_tablebuilder(
 3828|     19|        &self,
 3829|     19|        ui: &mut egui::Ui,
 3830|     19|        headers: &[Vec<InlineSpan>],
 3831|     19|        rows: &[Vec<Vec<InlineSpan>>],
 3832|     19|        alignments: &[Alignment],
 3833|     19|        table_id: u64,
 3834|     19|    ) {
 3835|     19|        let column_stats = self.column_stats_for_table(table_id, headers, rows, alignments);
 3836|     19|        let ctx =
 3837|     19|            TableColumnContext::new(headers, rows, &column_stats, self.font_sizes.body, table_id);
 3838|     19|        let mut column_specs = derive_column_specs(&ctx);
 3839|       |        #[cfg(test)]
 3840|     19|        if let Some(policies) = take_forced_table_policies() {
                                  ^5
 3841|     14|            for (spec, policy) in column_specs.iter_mut().zip(policies.into_iter()) {
                                                ^5                      ^5  ^5       ^5
 3842|     14|                spec.set_policy(policy);
 3843|     14|            }
 3844|     14|        }
 3845|     19|        self.apply_persisted_widths(table_id, &mut column_specs);
 3846|     19|        let column_aligns: Vec<Align> = (0..column_specs.len())
 3847|     55|            .map(|ci| Self::alignment_for_column(alignments, ci))
                           ^19
 3848|     19|            .collect();
 3849|       |
 3850|     19|        let column_spacing = ui.spacing().item_spacing.x.max(6.0);
 3851|     19|        let available_width = ui.available_width().max(1.0);
 3852|     19|        let min_floor = self.table_min_column_width();
 3853|     19|        let resolved_widths = self.resolve_table_column_widths(table_id, &column_specs, min_floor);
 3854|     19|        let min_widths: Vec<f32> = column_specs
 3855|     19|            .iter()
 3856|     55|            .map(|spec| match spec.policy {
                           ^19
 3857|     16|                ColumnPolicy::Fixed { width, .. } => width,
 3858|     20|                ColumnPolicy::Resizable { min, .. } => min,
 3859|     19|                ColumnPolicy::Remainder { .. } | ColumnPolicy::Auto => min_floor,
 3860|     55|            })
 3861|     19|            .collect();
 3862|     19|        let spacing_total = column_spacing * column_specs.len().saturating_sub(1) as f32;
 3863|     19|        let available_for_columns = available_width - spacing_total;
 3864|     19|        let mut fixed_total = 0.0;
 3865|     19|        let mut flexible_indices: Vec<usize> = Vec::new();
 3866|     19|        let mut remainder_indices: Vec<usize> = Vec::new();
 3867|     55|        for (idx, spec) in column_specs.iter().enumerate() {
                                         ^19                 ^19
 3868|     55|            match spec.policy {
 3869|     16|                ColumnPolicy::Fixed { width, .. } => fixed_total += width,
 3870|     20|                ColumnPolicy::Resizable { .. } => flexible_indices.push(idx),
 3871|     16|                ColumnPolicy::Remainder { .. } => {
 3872|     16|                    flexible_indices.push(idx);
 3873|     16|                    remainder_indices.push(idx);
 3874|     16|                }
 3875|      3|                ColumnPolicy::Auto => flexible_indices.push(idx),
 3876|       |            }
 3877|       |        }
 3878|     39|        let min_flex_total: f32 = flexible_indices.iter().map(|idx| min_widths[*idx]).sum();
                          ^19             ^19   ^19                     ^19                         ^19
 3879|     19|        let desired_total_width = resolved_widths.iter().sum::<f32>() + spacing_total;
 3880|     19|        let content_width = desired_total_width.max(available_width);
 3881|     19|        let remaining_for_flex = available_for_columns - fixed_total;
 3882|     19|        let use_hscroll = available_for_columns <= 0.0
 3883|     18|            || fixed_total > available_for_columns + 0.5
 3884|     17|            || remaining_for_flex < min_flex_total - 0.5;
 3885|     19|        let mut adjusted_widths = resolved_widths.clone();
 3886|     19|        let mut scaled_down = false;
 3887|     19|        if !use_hscroll {
 3888|     14|            let remaining = remaining_for_flex.max(0.0);
 3889|     14|            let flex_total: f32 = flexible_indices
 3890|     14|                .iter()
 3891|     25|                .map(|idx| resolved_widths[*idx])
                               ^14
 3892|     14|                .sum();
 3893|     14|            if flex_total > remaining + 0.5 {
 3894|      2|                if remaining <= min_flex_total + 0.5 {
 3895|      3|                    for idx in &flexible_indices {
                                      ^2
 3896|      2|                        adjusted_widths[*idx] = min_widths[*idx].max(1.0);
 3897|      2|                    }
 3898|       |                } else {
 3899|      1|                    let extra_total = flex_total - min_flex_total;
 3900|      1|                    let extra_scale = ((remaining - min_flex_total) / extra_total).clamp(0.0, 1.0);
 3901|      4|                    for idx in &flexible_indices {
                                      ^3
 3902|      3|                        let min_width = min_widths[*idx];
 3903|      3|                        let desired = resolved_widths[*idx];
 3904|      3|                        let extra = (desired - min_width).max(0.0);
 3905|      3|                        adjusted_widths[*idx] = (min_width + extra * extra_scale).max(1.0);
 3906|      3|                    }
 3907|       |                }
 3908|      2|                scaled_down = true;
 3909|     12|            }
 3910|      5|        }
 3911|     19|        let column_layout: Vec<Column> = if use_hscroll {
 3912|     18|            column_specs.iter().map(|spec| spec.as_column()).collect()
                          ^5                  ^5                           ^5
 3913|       |        } else {
 3914|     14|            column_specs
 3915|     14|                .iter()
 3916|     14|                .enumerate()
 3917|     37|                .map(|(idx, spec)| {
                               ^14
 3918|     37|                    let width = adjusted_widths
 3919|     37|                        .get(idx)
 3920|     37|                        .copied()
 3921|     37|                        .unwrap_or(min_floor)
 3922|     37|                        .max(1.0);
 3923|     37|                    match spec.policy {
 3924|     12|                        ColumnPolicy::Fixed { width, clip } => {
 3925|     12|                            let mut col = Column::exact(width);
 3926|     12|                            if clip {
 3927|     10|                                col = col.clip(true);
 3928|     10|                            }
                                          ^2
 3929|     12|                            col
 3930|       |                        }
 3931|     11|                        ColumnPolicy::Resizable { min, clip, .. } => {
 3932|     11|                            let mut col = Column::initial(width)
 3933|     11|                                .at_least(min.min(width))
 3934|     11|                                .resizable(true);
 3935|     11|                            if clip {
 3936|      1|                                col = col.clip(true);
 3937|     10|                            }
 3938|     11|                            col
 3939|       |                        }
 3940|     12|                        ColumnPolicy::Remainder { clip } => {
 3941|     12|                            let mut col = if scaled_down {
 3942|      1|                                Column::initial(width).at_least(min_floor.min(width))
 3943|       |                            } else {
 3944|     11|                                Column::remainder().at_least(min_floor)
 3945|       |                            };
 3946|     12|                            if clip {
 3947|      1|                                col = col.clip(true);
 3948|     11|                            }
 3949|     12|                            col
 3950|       |                        }
 3951|       |                        ColumnPolicy::Auto => {
 3952|      2|                            if scaled_down {
 3953|      1|                                Column::initial(width).at_least(min_floor.min(width))
 3954|       |                            } else {
 3955|      1|                                Column::auto_with_initial_suggestion(width).at_least(min_floor)
 3956|       |                            }
 3957|       |                        }
 3958|       |                    }
 3959|     37|                })
 3960|     14|                .collect()
 3961|       |        };
 3962|       |
 3963|     19|        let render_table = |ui: &mut egui::Ui, max_width: f32| {
 3964|     19|            let width_bucket = max_width.round() as i32;
 3965|     19|            ui.push_id((table_id, width_bucket), |ui| {
 3966|     19|                let layout = *ui.layout();
 3967|     19|                ui.allocate_ui_with_layout(Vec2::new(max_width, 0.0), layout, |ui| {
 3968|     19|                    ui.set_width(max_width);
 3969|     19|                    let needs_estimate = {
 3970|     19|                        let metrics = self.table_metrics.borrow();
 3971|     19|                        metrics
 3972|     19|                            .entry(table_id)
 3973|     19|                            .is_none_or(|entry| entry.rows.is_empty())
 3974|       |                    };
 3975|     19|                    self.begin_table_pass(table_id, rows.len());
 3976|       |
 3977|     19|                    let prev_spacing = ui.spacing().item_spacing;
 3978|     19|                    if (prev_spacing.x - column_spacing).abs() > f32::EPSILON {
 3979|      2|                        ui.spacing_mut().item_spacing.x = column_spacing;
 3980|     17|                    }
 3981|       |
 3982|     19|                    let cached_header_height = self
 3983|     19|                        .table_metrics
 3984|     19|                        .borrow()
 3985|     19|                        .entry(table_id)
 3986|     19|                        .and_then(|entry| entry.header_height());
 3987|       |                    // Rough header height estimation using equally divided width; refines on next frame via cache.
 3988|     19|                    let header_height = cached_header_height.unwrap_or_else(|| {
                                                                                             ^18
 3989|     18|                        let mut estimate = self.row_height_fallback();
 3990|     18|                        let column_count = column_specs.len().max(1);
 3991|     18|                        let approx_width = (ui.available_width() / column_count as f32)
 3992|     18|                            .max(self.font_sizes.body * 6.0)
 3993|     18|                            .max(48.0);
 3994|     18|                        let style = ui.style().clone();
 3995|     18|                        estimate = headers
 3996|     18|                            .iter()
 3997|     18|                            .enumerate()
 3998|     47|                            .map(|(ci, spans)| {
                                           ^18
 3999|     47|                                let halign = column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
 4000|     47|                                let build = self.cached_layout_job(
 4001|     47|                                    &style,
 4002|     47|                                    None,
 4003|     47|                                    ci,
 4004|     47|                                    spans,
 4005|     47|                                    approx_width,
 4006|       |                                    true,
 4007|     47|                                    halign,
 4008|       |                                );
 4009|     47|                                ui.fonts(|f| f.layout_job(build.job.clone()).size().y + 6.0)
 4010|     47|                            })
 4011|     47|                            .fold(estimate, |acc, h| acc.max(h));
                                           ^18  ^18
 4012|     18|                        estimate.min(self.row_height_fallback() * 3.0)
 4013|     18|                    });
 4014|       |
 4015|     19|                    let fallback_row_height = self.row_height_fallback();
 4016|     19|                    let mut row_heights: Vec<f32> = (0..rows.len())
 4017|     27|                        .map(|idx| self.row_height_hint(table_id, idx))
                                       ^19
 4018|     19|                        .collect();
 4019|     19|                    if needs_estimate {
 4020|     18|                        let approx_widths = self.estimate_table_column_widths(
 4021|     18|                            &column_specs,
 4022|     18|                            max_width,
 4023|     18|                            column_spacing,
 4024|       |                        );
 4025|     18|                        let style = ui.style().clone();
 4026|     26|                        for (idx, row) in rows.iter().enumerate() {
                                                        ^18  ^18    ^18
 4027|     26|                            if self.row_needs_height_estimate(row) {
 4028|      8|                                let estimate = self.estimate_table_row_height(
 4029|      8|                                    ui,
 4030|      8|                                    &style,
 4031|      8|                                    row,
 4032|      8|                                    &column_aligns,
 4033|      8|                                    &approx_widths,
 4034|      8|                                    fallback_row_height,
 4035|      8|                                );
 4036|      8|                                row_heights[idx] = row_heights[idx].max(estimate);
 4037|     18|                            }
 4038|       |                        }
 4039|      1|                    }
 4040|       |
 4041|       |                    // Capture painter from outer UI BEFORE TableBuilder to ensure dividers
 4042|       |                    // paint on top of both header and body (fixes header divider visibility).
 4043|     19|                    let outer_painter = ui.painter().clone();
 4044|     19|                    let outer_visuals = ui.visuals().clone();
 4045|     19|                    let outer_ctx = ui.ctx().clone();
 4046|       |
 4047|     19|                    let mut table = TableBuilder::new(ui).striped(true).vscroll(false);
 4048|     74|                    for column in &column_layout {
                                      ^55
 4049|     55|                        table = table.column(*column);
 4050|     55|                    }
 4051|       |
 4052|       |                    // Use RefCell to allow capturing widths from body closure.
 4053|       |                    // BUG FIX: Previously captured ui.min_rect().width() which is the cell *content* width.
 4054|       |                    // Now we capture body.widths() which gives the actual *allocated* column widths.
 4055|       |                    // See: https://docs.rs/egui_extras/latest/egui_extras/struct.TableBody.html#method.widths
 4056|     19|                    let column_widths: RefCell<Vec<f32>> =
 4057|     19|                        RefCell::new(vec![0.0f32; column_specs.len()]);
 4058|       |                    // Track header and body rects separately for accurate table bounds calculation.
 4059|       |                    // The header rect captures the header row bounds, body_rect captures body row bounds.
 4060|       |                    // These are combined after rendering to get the full table rect.
 4061|     19|                    let mut header_rect: Option<egui::Rect> = None;
 4062|     19|                    let mut body_rect: Option<egui::Rect> = None;
 4063|       |                    // body_layout_rect captures the allocated layout region from body.max_rect(),
 4064|       |                    // which is more accurate than union of cell min_rects for table width.
 4065|     19|                    let body_layout_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);
 4066|       |                    // Track clip rects separately for header and body, then union them.
 4067|       |                    // This ensures dividers respect scroll boundaries for both regions.
 4068|     19|                    let mut header_clip_rect: Option<egui::Rect> = None;
 4069|     19|                    let body_clip_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);
 4070|       |
 4071|     19|                    let mut height_change = false;
 4072|     19|                    let header_height_actual = Cell::new(0.0f32);
 4073|     19|                    table
 4074|     19|                        .header(header_height, |mut header| {
 4075|     55|                            for (ci, _) in column_specs.iter().enumerate() {
                                                         ^19                 ^19
 4076|     55|                                header.col(|ui| {
 4077|     55|                                    let width = ui.available_width().max(1.0);
 4078|     55|                                    let spans =
 4079|     55|                                        headers.get(ci).map(|v| v.as_slice()).unwrap_or(&[]);
                                                                              ^52^52
 4080|     55|                                    let halign =
 4081|     55|                                        column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
 4082|     55|                                    let cell_height = self.render_overhauled_cell(
 4083|     55|                                        ui, spans, width, true, None, ci, halign,
 4084|       |                                    );
 4085|     55|                                    header_height_actual
 4086|     55|                                        .set(header_height_actual.get().max(cell_height));
 4087|       |                                    // NOTE: Do NOT capture ui.min_rect().width() here - that's the content width,
 4088|       |                                    // not the column width. Column widths are captured from body.widths() below.
 4089|       |                                    // Extend header_rect (not body_rect) for accurate header bounds.
 4090|     55|                                    Self::extend_table_rect(&mut header_rect, ui.min_rect());
 4091|     55|                                    if header_clip_rect.is_none() {
 4092|     19|                                        header_clip_rect = Some(ui.clip_rect());
 4093|     36|                                    }
 4094|     55|                                });
 4095|       |                            }
 4096|     19|                        })
 4097|     19|                        .body(|body| {
 4098|       |                            // Capture the actual allocated column widths from the table layout system.
 4099|       |                            // This MUST be done before heterogeneous_rows() consumes the body.
 4100|     19|                            *column_widths.borrow_mut() = body.widths().to_vec();
 4101|       |
 4102|       |                            // Capture body's layout rect for accurate table width calculation.
 4103|       |                            // This is the allocated region, not the content bounds.
 4104|     19|                            *body_layout_rect.borrow_mut() = Some(body.max_rect());
 4105|       |
 4106|     19|                            let row_height_hints = row_heights.clone();
 4107|     27|                            body.heterogeneous_rows(row_height_hints.into_iter(), |mut row| {
                                          ^19  ^19                ^19              ^19
 4108|     27|                                let idx = row.index();
 4109|     27|                                let row_cells = rows.get(idx);
 4110|     27|                                let mut row_height = fallback_row_height;
 4111|     74|                                for (ci, _) in column_specs.iter().enumerate() {
                                                             ^27                 ^27
 4112|     74|                                    let mut cell_height = fallback_row_height;
 4113|     74|                                    row.col(|ui| {
 4114|     74|                                        let width = ui.available_width().max(1.0);
 4115|     74|                                        let spans = row_cells
 4116|     74|                                            .and_then(|cells| cells.get(ci))
 4117|     74|                                            .map(|cell| cell.as_slice())
 4118|     74|                                            .unwrap_or(&[]);
 4119|     74|                                        let halign =
 4120|     74|                                            column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
 4121|     74|                                        cell_height = self.render_overhauled_cell(
 4122|     74|                                            ui,
 4123|     74|                                            spans,
 4124|     74|                                            width,
 4125|     74|                                            false,
 4126|     74|                                            Some(idx),
 4127|     74|                                            ci,
 4128|     74|                                            halign,
 4129|     74|                                        );
 4130|       |                                        // Extend body_rect (not header_rect) for accurate body bounds.
 4131|     74|                                        Self::extend_table_rect(&mut body_rect, ui.min_rect());
 4132|     74|                                        if body_clip_rect.borrow().is_none() {
 4133|     18|                                            *body_clip_rect.borrow_mut() = Some(ui.clip_rect());
 4134|     56|                                        }
 4135|     74|                                    });
 4136|     74|                                    row_height = row_height.max(cell_height);
 4137|       |                                }
 4138|     27|                                if (row_height - row_heights[idx]).abs() > 0.5 {
 4139|     26|                                    height_change = true;
 4140|     26|                                }
                                              ^1
 4141|     27|                                self.update_row_height(table_id, idx, row_height);
 4142|     27|                                self.note_row_rendered(table_id);
 4143|     27|                            });
 4144|     19|                        });
 4145|       |
 4146|     19|                    ui.spacing_mut().item_spacing = prev_spacing;
 4147|       |
 4148|       |                    // Extract column widths from RefCell for use in divider painting
 4149|     19|                    let widths = column_widths.into_inner();
 4150|     19|                    let layout_rect = body_layout_rect.into_inner();
 4151|     19|                    let body_clip = body_clip_rect.into_inner();
 4152|     19|                    let measured_header_height = header_height_actual.get();
 4153|     19|                    if self.update_header_height(table_id, measured_header_height) {
 4154|     18|                        ui.ctx().request_repaint();
 4155|     18|                    }
                                  ^1
 4156|       |
 4157|     19|                    let (rect, clip_rect) = self.resolve_table_rects(
 4158|     19|                        header_rect,
 4159|     19|                        body_rect,
 4160|     19|                        layout_rect,
 4161|     19|                        header_clip_rect,
 4162|     19|                        body_clip,
 4163|     19|                        &widths,
 4164|     19|                        column_spacing,
 4165|     19|                    );
 4166|     19|                    let frame_id = outer_ctx.frame_nr();
 4167|     19|                    let change = self.record_resolved_widths(table_id, frame_id, &widths);
 4168|     19|                    self.persist_resizable_widths(table_id, &column_specs, &widths);
 4169|     19|                    self.handle_width_change(&outer_ctx, table_id, change);
 4170|       |                    // Use outer_painter (captured before TableBuilder) to ensure
 4171|       |                    // dividers paint on top of both header and body.
 4172|     19|                    self.paint_table_dividers(
 4173|     19|                        &outer_painter,
 4174|     19|                        &outer_visuals,
 4175|     19|                        rect,
 4176|     19|                        clip_rect,
 4177|     19|                        &widths,
 4178|     19|                        header_height,
 4179|     19|                        column_spacing,
 4180|       |                    );
 4181|     19|                    if height_change {
 4182|     17|                        ui.ctx().request_repaint();
 4183|     17|                    }
                                  ^2
 4184|     19|                });
 4185|     19|            });
 4186|     19|        };
 4187|       |
 4188|     19|        if use_hscroll {
 4189|      5|            egui::ScrollArea::horizontal()
 4190|      5|                .id_source(("md_table_hscroll_overhaul", table_id))
 4191|      5|                .auto_shrink([false, true])
 4192|      5|                .scroll_bar_visibility(egui::scroll_area::ScrollBarVisibility::VisibleWhenNeeded)
 4193|      5|                .show(ui, |ui| {
 4194|      5|                    ui.set_min_width(content_width);
 4195|      5|                    render_table(ui, content_width);
 4196|      5|                });
 4197|     14|        } else {
 4198|     14|            render_table(ui, available_width);
 4199|     14|        }
 4200|     19|    }
 4201|       |
 4202|     25|    fn resolve_table_rects(
 4203|     25|        &self,
 4204|     25|        header_rect: Option<egui::Rect>,
 4205|     25|        body_rect: Option<egui::Rect>,
 4206|     25|        layout_rect: Option<egui::Rect>,
 4207|     25|        header_clip_rect: Option<egui::Rect>,
 4208|     25|        body_clip: Option<egui::Rect>,
 4209|     25|        widths: &[f32],
 4210|     25|        column_spacing: f32,
 4211|     25|    ) -> (egui::Rect, egui::Rect) {
 4212|       |        // Combine header and body clip rects to ensure dividers respect scroll bounds.
 4213|     25|        let clip_rect = match (header_clip_rect, body_clip) {
 4214|     18|            (Some(h), Some(b)) => Some(h.union(b)),
 4215|      1|            (Some(h), None) => Some(h),
 4216|      1|            (None, Some(b)) => Some(b),
 4217|      5|            (None, None) => None,
 4218|       |        };
 4219|       |
 4220|       |        // Calculate accurate table width from column widths.
 4221|       |        // This is more accurate than union of cell min_rects which may be smaller
 4222|       |        // than the allocated column space.
 4223|     25|        let calculated_width: f32 =
 4224|     25|            widths.iter().sum::<f32>() + column_spacing * widths.len().saturating_sub(1) as f32;
 4225|       |
 4226|       |        // Combine header/body bounds with layout bounds for accurate borders,
 4227|       |        // especially when the first column is centered or right-aligned.
 4228|     25|        let left = layout_rect
 4229|     25|            .map(|rect| rect.left())
                                      ^21  ^21
 4230|     25|            .or_else(|| header_rect.map(|rect| rect.left()))
                                      ^4          ^4         ^1   ^1
 4231|     25|            .or_else(|| body_rect.map(|rect| rect.left()));
                                      ^3        ^3         ^1   ^1
 4232|     25|        let right = left.map(|value| value + calculated_width);
                                                   ^23     ^23
 4233|     25|        let top = header_rect
 4234|     25|            .map(|rect| rect.top())
                                      ^21  ^21
 4235|     25|            .or_else(|| body_rect.map(|rect| rect.top()))
                                      ^4        ^4         ^1   ^1
 4236|     25|            .or_else(|| layout_rect.map(|rect| rect.top()));
                                      ^3          ^3         ^1   ^1
 4237|     25|        let bottom = body_rect
 4238|     25|            .map(|rect| rect.bottom())
                                      ^20  ^20
 4239|     25|            .or_else(|| header_rect.map(|rect| rect.bottom()))
                                      ^5          ^5         ^2   ^2
 4240|     25|            .or_else(|| layout_rect.map(|rect| rect.bottom()));
                                      ^3          ^3         ^1   ^1
 4241|     25|        let table_rect = match (left, right, top, bottom) {
 4242|     23|            (Some(left), Some(right), Some(top), Some(bottom)) => Some(egui::Rect::from_min_max(
 4243|     23|                egui::pos2(left, top),
 4244|     23|                egui::pos2(right, bottom),
 4245|     23|            )),
 4246|      2|            _ => None,
 4247|       |        };
 4248|       |
 4249|     25|        let rect = table_rect.unwrap_or_else(|| {
                                                              ^2
 4250|      2|            layout_rect.unwrap_or_else(|| {
 4251|      2|                egui::Rect::from_min_max(egui::pos2(0.0, 0.0), egui::pos2(0.0, 0.0))
 4252|      2|            })
 4253|      2|        });
 4254|     25|        let clip_rect = clip_rect.unwrap_or(rect);
 4255|     25|        (rect, clip_rect)
 4256|     25|    }
 4257|       |
 4258|     31|    fn row_needs_height_estimate(&self, row: &[Vec<InlineSpan>]) -> bool {
 4259|     72|        row.iter().any(|cell| {
                      ^31        ^31
 4260|     80|            cell.iter().any(|span| match span {
                          ^72         ^72
 4261|      1|                InlineSpan::Image { .. } => true,
 4262|     73|                InlineSpan::Text(text)
 4263|      1|                | InlineSpan::Code(text)
 4264|      1|                | InlineSpan::Strong(text)
 4265|      1|                | InlineSpan::Emphasis(text)
 4266|      1|                | InlineSpan::Strikethrough(text)
 4267|     79|                | InlineSpan::Link { text, .. } => text.contains('\n'),
                                                   ^2
 4268|     80|            })
 4269|     72|        })
 4270|     31|    }
 4271|       |
 4272|     42|    fn table_min_column_width(&self) -> f32 {
 4273|     42|        (self.font_sizes.body * 6.0).max(48.0)
 4274|     42|    }
 4275|       |
 4276|     22|    fn resolve_table_column_widths(
 4277|     22|        &self,
 4278|     22|        table_id: u64,
 4279|     22|        column_specs: &[ColumnSpec],
 4280|     22|        min_floor: f32,
 4281|     22|    ) -> Vec<f32> {
 4282|     22|        if column_specs.is_empty() {
 4283|      1|            return Vec::new();
 4284|     21|        }
 4285|       |
 4286|     21|        let stored_widths = {
 4287|     21|            let metrics = self.table_metrics.borrow();
 4288|     21|            metrics
 4289|     21|                .entry(table_id)
 4290|     21|                .map(|entry| entry.current_widths().to_vec())
                                           ^20                    ^20
 4291|     21|                .unwrap_or_default()
 4292|       |        };
 4293|       |
 4294|     21|        column_specs
 4295|     21|            .iter()
 4296|     21|            .enumerate()
 4297|     60|            .map(|(idx, spec)| {
                           ^21
 4298|     60|                let stored = stored_widths
 4299|     60|                    .get(idx)
 4300|     60|                    .copied()
 4301|     60|                    .filter(|width| width.is_finite() && *width > 0.0);
                                                  ^7    ^7             ^6
 4302|     60|                let width = match spec.policy {
 4303|     16|                    ColumnPolicy::Fixed { width, .. } => width,
 4304|     23|                    ColumnPolicy::Resizable { min, preferred, .. } => {
 4305|     23|                        stored.unwrap_or(preferred.max(min)).max(min)
 4306|       |                    }
 4307|     17|                    ColumnPolicy::Remainder { .. } => min_floor,
 4308|      4|                    ColumnPolicy::Auto => stored.unwrap_or(min_floor).max(min_floor),
 4309|       |                };
 4310|     60|                width.max(1.0)
 4311|     60|            })
 4312|     21|            .collect()
 4313|     22|    }
 4314|       |
 4315|     22|    fn estimate_table_column_widths(
 4316|     22|        &self,
 4317|     22|        column_specs: &[ColumnSpec],
 4318|     22|        max_width: f32,
 4319|     22|        column_spacing: f32,
 4320|     22|    ) -> Vec<f32> {
 4321|     22|        let column_count = column_specs.len().max(1);
 4322|     22|        let spacing_total = column_spacing * column_count.saturating_sub(1) as f32;
 4323|     22|        let available = (max_width - spacing_total).max(1.0);
 4324|     22|        let min_floor = self.table_min_column_width();
 4325|     22|        let mut widths: Vec<f32> = column_specs
 4326|     22|            .iter()
 4327|     56|            .map(|spec| match spec.policy {
                           ^22
 4328|     19|                ColumnPolicy::Fixed { width, .. } => width,
 4329|     20|                ColumnPolicy::Resizable { min, .. } => min,
 4330|     14|                ColumnPolicy::Remainder { .. } => min_floor,
 4331|      3|                ColumnPolicy::Auto => min_floor,
 4332|     56|            })
 4333|     56|            .map(|width| width.max(1.0))
                           ^22
 4334|     22|            .collect();
 4335|       |
 4336|     22|        if widths.is_empty() {
 4337|      1|            return vec![available];
 4338|     21|        }
 4339|     21|        let sum: f32 = widths.iter().sum();
 4340|     21|        if sum > available {
 4341|      2|            let scale = available / sum;
 4342|      6|            for width in &mut widths {
                              ^4
 4343|      4|                *width = (*width * scale).max(1.0);
 4344|      4|            }
 4345|     19|        }
 4346|     21|        widths
 4347|     22|    }
 4348|       |
 4349|       |    #[cfg(test)]
 4350|      2|    fn estimate_table_total_width(
 4351|      2|        &self,
 4352|      2|        table_id: u64,
 4353|      2|        column_specs: &[ColumnSpec],
 4354|      2|        column_spacing: f32,
 4355|      2|    ) -> f32 {
 4356|      2|        if column_specs.is_empty() {
 4357|      1|            return 0.0;
 4358|      1|        }
 4359|      1|        let min_floor = self.table_min_column_width();
 4360|      1|        let widths = self.resolve_table_column_widths(table_id, column_specs, min_floor);
 4361|      1|        let spacing_total = column_spacing * widths.len().saturating_sub(1) as f32;
 4362|      1|        widths.iter().sum::<f32>() + spacing_total
 4363|      2|    }
 4364|       |
 4365|     10|    fn estimate_table_row_height(
 4366|     10|        &self,
 4367|     10|        ui: &egui::Ui,
 4368|     10|        style: &egui::Style,
 4369|     10|        row: &[Vec<InlineSpan>],
 4370|     10|        column_aligns: &[Align],
 4371|     10|        widths: &[f32],
 4372|     10|        fallback: f32,
 4373|     10|    ) -> f32 {
 4374|     10|        let mut max_height = fallback;
 4375|     10|        let column_count = widths.len().max(row.len()).max(1);
 4376|     22|        for ci in 0..column_count {
                                   ^10
 4377|     22|            let spans = row.get(ci).map(|cell| cell.as_slice()).unwrap_or(&[]);
 4378|     22|            if spans.is_empty() {
 4379|      1|                continue;
 4380|     21|            }
 4381|     21|            let width = widths
 4382|     21|                .get(ci)
 4383|     21|                .copied()
 4384|     21|                .or_else(|| widths.last().copied())
                                          ^1     ^1     ^1
 4385|     21|                .unwrap_or(1.0);
 4386|     21|            let halign = column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
 4387|     21|            let height = self.estimate_table_cell_height(style, ui, spans, width, halign, fallback);
 4388|     21|            max_height = max_height.max(height);
 4389|       |        }
 4390|     10|        max_height
 4391|     10|    }
 4392|       |
 4393|     24|    fn estimate_table_cell_height(
 4394|     24|        &self,
 4395|     24|        style: &egui::Style,
 4396|     24|        ui: &egui::Ui,
 4397|     24|        spans: &[InlineSpan],
 4398|     24|        width: f32,
 4399|     24|        halign: Align,
 4400|     24|        fallback: f32,
 4401|     24|    ) -> f32 {
 4402|     24|        if spans.is_empty() {
 4403|      1|            return fallback;
 4404|     23|        }
 4405|     23|        let fragments = self.cell_fragments(spans);
 4406|     23|        let mut total = 0.0;
 4407|     24|        for (idx, fragment) in fragments.into_iter().enumerate() {
                                             ^23       ^23         ^23
 4408|     24|            if idx > 0 {
 4409|      1|                total += 2.0;
 4410|     23|            }
 4411|     24|            match fragment {
 4412|     21|                CellFragment::Text(slice) => {
 4413|     21|                    let build = self.build_layout_job(style, slice, width, false, halign);
 4414|     21|                    let height = ui.fonts(|f| f.layout_job(build.job.clone()).size().y);
 4415|     21|                    total += height;
 4416|       |                }
 4417|      1|                CellFragment::Emoji(_) => {
 4418|      1|                    total += self.font_sizes.body * 1.2;
 4419|      1|                }
 4420|      2|                CellFragment::Image(span) => {
 4421|      2|                    total += self.estimate_table_image_height(ui, span, width);
 4422|      2|                }
 4423|       |            }
 4424|       |        }
 4425|     23|        total.max(fallback)
 4426|     24|    }
 4427|       |
 4428|      5|    fn estimate_table_image_height(
 4429|      5|        &self,
 4430|      5|        ui: &egui::Ui,
 4431|      5|        span: &InlineSpan,
 4432|      5|        available_w: f32,
 4433|      5|    ) -> f32 {
 4434|      5|        let InlineSpan::Image { src, title, .. } = span else {
                                              ^4   ^4
 4435|      1|            return self.font_sizes.body * 1.2;
 4436|       |        };
 4437|      4|        let resolved = self.resolve_image_path(src);
 4438|      4|        let (tw, th) = self
 4439|      4|            .get_or_load_image_texture(ui, &resolved)
 4440|      4|            .map(|(_, w, h)| (w as f32, h as f32))
                                            ^1        ^1
 4441|      4|            .unwrap_or((self.font_sizes.body * 12.0, self.font_sizes.body * 8.0));
 4442|      4|        let base_scale = self.ui_scale();
 4443|      4|        let scaled_w = tw * base_scale;
 4444|      4|        let scale = if scaled_w > available_w {
 4445|      3|            (available_w / tw).clamp(0.01, 4.0)
 4446|       |        } else {
 4447|      1|            base_scale
 4448|       |        };
 4449|      4|        let mut height = (th * scale).round();
 4450|      4|        if let Some(text) = title {
                                  ^3
 4451|      3|            if !text.is_empty() {
 4452|      2|                height += 2.0 + (self.font_sizes.body - 2.0).max(1.0);
 4453|      2|            }
                          ^1
 4454|      1|        }
 4455|      4|        height + 6.0
 4456|      5|    }
 4457|       |
 4458|    243|    fn row_height_fallback(&self) -> f32 {
 4459|    243|        self.font_sizes.body * 1.6
 4460|    243|    }
 4461|       |
 4462|     28|    fn row_height_hint(&self, table_id: u64, idx: usize) -> f32 {
 4463|     28|        let fallback = self.row_height_fallback();
 4464|     28|        self.table_metrics
 4465|     28|            .borrow()
 4466|     28|            .entry(table_id)
 4467|     28|            .and_then(|entry| entry.row(idx))
 4468|     28|            .map(|m| {
                                   ^2
 4469|      2|                if m.max_height > 0.0 {
 4470|      1|                    m.max_height
 4471|       |                } else {
 4472|      1|                    fallback
 4473|       |                }
 4474|      2|            })
 4475|     28|            .unwrap_or(fallback)
 4476|     28|    }
 4477|       |
 4478|     27|    fn update_row_height(&self, table_id: u64, idx: usize, height: f32) {
 4479|     27|        let clamped = height.max(self.row_height_fallback());
 4480|     27|        let mut metrics = self.table_metrics.borrow_mut();
 4481|     27|        let entry = metrics.entry_mut(table_id);
 4482|     27|        let row = entry.ensure_row(idx);
 4483|     27|        row.max_height = clamped;
 4484|     27|        row.dirty = false;
 4485|     27|    }
 4486|       |
 4487|     19|    fn update_header_height(&self, table_id: u64, height: f32) -> bool {
 4488|     19|        let mut metrics = self.table_metrics.borrow_mut();
 4489|     19|        let entry = metrics.entry_mut(table_id);
 4490|     19|        entry.update_header_height(height)
 4491|     19|    }
 4492|       |
 4493|     19|    fn begin_table_pass(&self, table_id: u64, total_rows: usize) {
 4494|     19|        let mut metrics = self.table_metrics.borrow_mut();
 4495|     19|        metrics.entry_mut(table_id).begin_pass(total_rows);
 4496|     19|    }
 4497|       |
 4498|     27|    fn note_row_rendered(&self, table_id: u64) {
 4499|     27|        let mut metrics = self.table_metrics.borrow_mut();
 4500|     27|        metrics.entry_mut(table_id).note_row_rendered();
 4501|     27|    }
 4502|       |
 4503|     20|    fn apply_persisted_widths(&self, table_id: u64, specs: &mut [ColumnSpec]) {
 4504|     20|        if specs.is_empty() {
 4505|      1|            return;
 4506|     19|        }
 4507|     19|        let mut metrics = self.table_metrics.borrow_mut();
 4508|     19|        let entry = metrics.entry_mut(table_id);
 4509|     55|        for spec in specs.iter_mut() {
                                  ^19   ^19
 4510|     55|            if let Some(width) = entry.persisted_width(spec.policy_hash) {
                                      ^2
 4511|      2|                spec.apply_preferred_width(width);
 4512|     53|            }
 4513|       |        }
 4514|     20|    }
 4515|       |
 4516|     32|    fn persist_resizable_widths(&self, table_id: u64, specs: &[ColumnSpec], widths: &[f32]) {
 4517|     32|        if specs.is_empty() || widths.is_empty() {
                                             ^30    ^30
 4518|      3|            return;
 4519|     29|        }
 4520|     29|        let mut metrics = self.table_metrics.borrow_mut();
 4521|     29|        let entry = metrics.entry_mut(table_id);
 4522|       |
 4523|       |        // Check if font size changed since last persist - if so, clear old widths
 4524|       |        // to prevent size mismatch after zoom changes. Skip persisting in this
 4525|       |        // frame so the next layout can compute fresh widths before we store them.
 4526|     29|        if entry.check_font_size_change(self.font_sizes.body) {
 4527|      1|            return;
 4528|     28|        }
 4529|       |
 4530|     64|        for (spec, width) in specs.iter().zip(widths.iter()) {
                                           ^28   ^28    ^28 ^28    ^28
 4531|     64|            if let ColumnPolicy::Resizable { .. } = spec.policy {
 4532|     29|                let stored = entry.persisted_width(spec.policy_hash).unwrap_or(-1.0);
 4533|     29|                if stored < 0.0 || (stored - width).abs() > 0.5 {
                                                 ^4
 4534|     26|                    entry.set_persisted_width(spec.policy_hash, *width);
 4535|     26|                }
                              ^3
 4536|     35|            }
 4537|       |        }
 4538|     32|    }
 4539|       |
 4540|     20|    fn record_resolved_widths(&self, table_id: u64, frame_id: u64, widths: &[f32]) -> WidthChange {
 4541|     20|        if widths.is_empty() {
 4542|      1|            return WidthChange::None;
 4543|     19|        }
 4544|     19|        let mut metrics = self.table_metrics.borrow_mut();
 4545|     19|        metrics.entry_mut(table_id).update_widths(widths, frame_id)
 4546|     20|    }
 4547|       |
 4548|     22|    fn handle_width_change(&self, ctx: &Context, table_id: u64, change: WidthChange) {
 4549|     22|        if matches!(change, WidthChange::Large) {
                         ^19
 4550|      3|            let frame_id = ctx.frame_nr();
 4551|      3|            let mut metrics = self.table_metrics.borrow_mut();
 4552|      3|            let entry = metrics.entry_mut(table_id);
 4553|      3|            if entry.last_discard_frame != Some(frame_id) {
 4554|      2|                ctx.request_repaint();
 4555|      2|                entry.last_discard_frame = Some(frame_id);
 4556|      2|            }
                          ^1
 4557|     19|        }
 4558|     22|    }
 4559|       |
 4560|       |    /// Paint vertical dividers between table columns, a horizontal header separator,
 4561|       |    /// and an outer border.
 4562|       |    ///
 4563|       |    /// # Arguments
 4564|       |    /// * `widths` - The actual allocated column widths from `TableBody::widths()`.
 4565|       |    ///   IMPORTANT: These must NOT be cell content widths from `ui.min_rect()`,
 4566|       |    ///   which would cause dividers to be misaligned.
 4567|       |    /// * `header_height` - The height of the header row. A horizontal separator is
 4568|       |    ///   drawn at this y-offset to visually separate header from body rows.
 4569|       |    #[allow(clippy::too_many_arguments)]
 4570|     23|    fn paint_table_dividers(
 4571|     23|        &self,
 4572|     23|        painter: &Painter,
 4573|     23|        visuals: &Visuals,
 4574|     23|        rect: egui::Rect,
 4575|     23|        clip_rect: egui::Rect,
 4576|     23|        widths: &[f32],
 4577|     23|        header_height: f32,
 4578|     23|        column_spacing: f32,
 4579|     23|    ) {
 4580|     23|        if widths.is_empty() {
 4581|      1|            return;
 4582|     22|        }
 4583|     22|        let separator_color = visuals
 4584|     22|            .widgets
 4585|     22|            .noninteractive
 4586|     22|            .bg_stroke
 4587|     22|            .color
 4588|     22|            .gamma_multiply(0.9);
 4589|     22|        let separator_stroke = Stroke::new(1.0, separator_color);
 4590|     22|        let border_stroke = visuals.window_stroke();
 4591|       |        // Expand clip_rect to include the full table rect so borders aren't clipped.
 4592|       |        // The cell clip_rect may not include the outer border area.
 4593|     22|        let expanded_clip = clip_rect.union(rect);
 4594|     22|        let painter = painter.with_clip_rect(expanded_clip);
 4595|       |
 4596|       |        // Draw vertical dividers between columns
 4597|     22|        if widths.len() > 1 {
 4598|     20|            let mut x = rect.left();
 4599|     39|            for (idx, width) in widths
                                              ^20
 4600|     20|                .iter()
 4601|     20|                .take(widths.len().saturating_sub(1))
 4602|     20|                .enumerate()
 4603|     39|            {
 4604|     39|                x += *width;
 4605|     39|                let divider_x = x + column_spacing * (idx as f32 + 0.5);
 4606|     39|                let x_pos = (divider_x.round() + 0.5).clamp(rect.left(), rect.right());
 4607|     39|                painter.vline(x_pos, rect.y_range(), separator_stroke);
 4608|     39|            }
 4609|      2|        }
 4610|       |
 4611|       |        // Draw horizontal separator below header row
 4612|     22|        if header_height > 0.0 {
 4613|     21|            let header_y = rect.top() + header_height;
 4614|     21|            if header_y < rect.bottom() {
 4615|     21|                painter.hline(rect.x_range(), header_y.round() + 0.5, separator_stroke);
 4616|     21|            }
                          ^0
 4617|      1|        }
 4618|       |
 4619|       |        // Draw outer border
 4620|     22|        painter.rect_stroke(rect, 0.0, border_stroke);
 4621|     23|    }
 4622|       |
 4623|       |    #[allow(clippy::too_many_arguments)]
 4624|    132|    fn render_overhauled_cell(
 4625|    132|        &self,
 4626|    132|        ui: &mut egui::Ui,
 4627|    132|        spans: &[InlineSpan],
 4628|    132|        width: f32,
 4629|    132|        is_header: bool,
 4630|    132|        row_idx: Option<usize>,
 4631|    132|        col_idx: usize,
 4632|    132|        halign: Align,
 4633|    132|    ) -> f32 {
 4634|    132|        let fallback_height = self.row_height_fallback();
 4635|    132|        let fragments = self.cell_fragments(spans);
 4636|    132|        let inner = ui.allocate_ui_with_layout(
 4637|    132|            Vec2::new(width, 0.0),
 4638|    132|            egui::Layout::top_down(halign),
 4639|    132|            |ui| {
 4640|    132|                ui.set_width(width);
 4641|    132|                ui.set_max_width(width);
 4642|    132|                ui.spacing_mut().item_spacing = egui::vec2(4.0, 2.0);
 4643|    132|                if fragments.is_empty() {
 4644|      4|                    ui.allocate_exact_size(
 4645|      4|                        Vec2::new(width, self.font_sizes.body * 1.2),
 4646|      4|                        egui::Sense::hover(),
 4647|       |                    );
 4648|      4|                    return;
 4649|    128|                }
 4650|    257|                for fragment in fragments {
                                  ^129
 4651|    129|                    match fragment {
 4652|    125|                        CellFragment::Text(slice) => {
 4653|    125|                            let build = self.cached_layout_job(
 4654|    125|                                ui.style(),
 4655|    125|                                row_idx,
 4656|    125|                                col_idx,
 4657|    125|                                slice,
 4658|    125|                                width,
 4659|    125|                                is_header,
 4660|    125|                                halign,
 4661|    125|                            );
 4662|    125|                            self.paint_table_text_job(ui, width, build);
 4663|    125|                        }
 4664|      1|                        CellFragment::Emoji(key) => {
 4665|      1|                            self.render_table_emoji(ui, &key);
 4666|      1|                        }
 4667|      3|                        CellFragment::Image(span) => {
 4668|      3|                            self.render_inline_span(ui, span, None, Some(is_header));
 4669|      3|                        }
 4670|       |                    }
 4671|       |                }
 4672|    132|            },
 4673|       |        );
 4674|    132|        inner.response.rect.height().max(fallback_height)
 4675|    132|    }
 4676|       |
 4677|    133|    fn paint_table_text_job(
 4678|    133|        &self,
 4679|    133|        ui: &mut egui::Ui,
 4680|    133|        width: f32,
 4681|    133|        build: LayoutJobBuild,
 4682|    133|    ) -> egui::Response {
 4683|    133|        let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
 4684|    133|        let height = galley.size().y;
 4685|    133|        let (rect, mut response) =
 4686|    133|            ui.allocate_exact_size(Vec2::new(width, height), egui::Sense::click());
 4687|    133|        let text_color = ui.visuals().text_color();
 4688|    133|        let text_origin = Self::aligned_text_origin(rect, &galley, build.job.halign);
 4689|    133|        ui.painter_at(rect)
 4690|    133|            .galley(text_origin, galley.clone(), text_color);
 4691|    133|        if galley.rows.len() > 1 || galley.size().x > width + 0.5 {
                                                  ^115
 4692|     19|            response = response.on_hover_text(build.plain_text.clone());
 4693|    114|        }
 4694|       |        #[cfg(test)]
 4695|    133|        self.render_cell_context_menu(ui, &build.plain_text);
 4696|       |        #[cfg(not(test))]
 4697|       |        response.context_menu(|ui| {
 4698|       |            self.render_cell_context_menu(ui, &build.plain_text);
 4699|       |        });
 4700|       |
 4701|    133|        if let Some(link) = self.link_at_pointer(&response, &galley, &build, text_origin) {
                                  ^3
 4702|      3|            ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
 4703|      3|            response = response.on_hover_text(link.url.clone());
 4704|      3|            if response.clicked() {
 4705|      2|                self.trigger_link(&link.url);
 4706|      2|            }
                          ^1
 4707|    130|        }
 4708|       |
 4709|    133|        response
 4710|    133|    }
 4711|       |
 4712|       |    #[allow(clippy::too_many_arguments)]
 4713|    176|    fn cached_layout_job(
 4714|    176|        &self,
 4715|    176|        style: &egui::Style,
 4716|    176|        row_idx: Option<usize>,
 4717|    176|        col_idx: usize,
 4718|    176|        spans: &[InlineSpan],
 4719|    176|        width: f32,
 4720|    176|        is_header: bool,
 4721|    176|        halign: Align,
 4722|    176|    ) -> LayoutJobBuild {
 4723|    176|        let highlight_hash = self
 4724|    176|            .highlight_phrase
 4725|    176|            .borrow()
 4726|    176|            .as_ref()
 4727|    176|            .map(|s| Self::hash_str(s))
                                   ^8             ^8
 4728|    176|            .unwrap_or(0);
 4729|    176|        let content_hash = Self::hash_inline_spans(spans);
 4730|    176|        let text_color = style.visuals.text_color().to_array();
 4731|    176|        let key = CellLayoutKey {
 4732|    176|            row: row_idx,
 4733|    176|            col: col_idx,
 4734|    176|            width: width.round() as u32,
 4735|    176|            align: Self::align_to_u8(halign),
 4736|    176|            strong: is_header,
 4737|    176|            text_color,
 4738|    176|            highlight_hash,
 4739|    176|            content_hash,
 4740|    176|        };
 4741|    176|        if let Some(build) = self.table_layout_cache.borrow_mut().get(&key) {
                                  ^13
 4742|     13|            return build;
 4743|    163|        }
 4744|    163|        let build = self.build_layout_job(style, spans, width, is_header, halign);
 4745|    163|        self.table_layout_cache
 4746|    163|            .borrow_mut()
 4747|    163|            .insert(key, build.clone());
 4748|    163|        build
 4749|    176|    }
 4750|       |
 4751|    136|    fn link_at_pointer<'a>(
 4752|    136|        &self,
 4753|    136|        response: &egui::Response,
 4754|    136|        galley: &Arc<Galley>,
 4755|    136|        build: &'a LayoutJobBuild,
 4756|    136|        text_origin: egui::Pos2,
 4757|    136|    ) -> Option<&'a LinkRange> {
 4758|    136|        let pointer = response.hover_pos()?;
                          ^5                            ^131
 4759|      5|        let text_rect = galley.rect.translate(text_origin.to_vec2());
 4760|      5|        if !text_rect.contains(pointer) {
 4761|      1|            return None;
 4762|      4|        }
 4763|      4|        let local = pointer - text_origin;
 4764|      4|        let cursor = galley.cursor_from_pos(local);
 4765|      4|        let idx = cursor.ccursor.index;
 4766|      4|        build
 4767|      4|            .link_ranges
 4768|      4|            .iter()
 4769|      4|            .find(|range| range.char_range.contains(&idx))
 4770|    136|    }
 4771|       |
 4772|    142|    fn aligned_text_origin(rect: egui::Rect, galley: &Galley, halign: Align) -> egui::Pos2 {
 4773|    142|        let galley_rect = galley.rect;
 4774|    142|        let x = if halign == Align::RIGHT {
 4775|      5|            rect.right() - galley_rect.right()
 4776|    137|        } else if halign == Align::Center {
 4777|      5|            rect.center().x - galley_rect.center().x
 4778|       |        } else {
 4779|    132|            rect.left() - galley_rect.left()
 4780|       |        };
 4781|    142|        egui::pos2(x, rect.top() - galley_rect.top())
 4782|    142|    }
 4783|       |
 4784|      2|    fn render_table_emoji(&self, ui: &mut egui::Ui, emoji: &str) {
 4785|      2|        let handle = self.get_or_make_emoji_texture(ui, emoji);
 4786|      2|        let size = self.font_sizes.body * 1.2;
 4787|      2|        ui.add(
 4788|      2|            egui::Image::new(&handle)
 4789|      2|                .max_size(Vec2::splat(size))
 4790|      2|                .sense(egui::Sense::hover()),
 4791|       |        );
 4792|      2|    }
 4793|       |
 4794|       |    #[cfg(test)]
 4795|      8|    fn resolve_table_widths(available: f32, mins: &[f32], desired: &[f32]) -> Vec<f32> {
 4796|      8|        debug_assert_eq!(mins.len(), desired.len());
 4797|      8|        if mins.is_empty() {
 4798|      1|            return Vec::new();
 4799|      7|        }
 4800|      7|        let clamped_available = available.max(1.0);
 4801|      7|        let desired_total: f32 = desired.iter().sum();
 4802|      7|        let min_total: f32 = mins.iter().sum();
 4803|       |
 4804|      7|        let widths = if min_total >= clamped_available {
 4805|      2|            mins.iter()
 4806|      6|                .map(|m| m * (clamped_available / min_total))
                               ^2
 4807|      2|                .collect()
 4808|      5|        } else if desired_total <= clamped_available {
 4809|      3|            let slack = desired_total - min_total;
 4810|      3|            if slack <= f32::EPSILON {
 4811|      2|                let bonus = (clamped_available - min_total) / mins.len() as f32;
 4812|      4|                mins.iter().map(|m| m + bonus).collect()
                              ^2   ^2     ^2                 ^2
 4813|       |            } else {
 4814|      1|                desired.to_vec()
 4815|       |            }
 4816|       |        } else {
 4817|      2|            let mut widths = mins.to_vec();
 4818|      2|            let extra = clamped_available - min_total;
 4819|      2|            let slack: Vec<f32> = desired
 4820|      2|                .iter()
 4821|      2|                .zip(mins.iter())
 4822|      6|                .map(|(d, m)| (d - m).max(0.0))
                               ^2
 4823|      2|                .collect();
 4824|      2|            let total_slack: f32 = slack.iter().sum();
 4825|      6|            for (w, s) in widths.iter_mut().zip(slack.iter()) {
                                        ^2                ^2  ^2
 4826|      6|                *w += extra * (*s / total_slack);
 4827|      6|            }
 4828|      2|            widths
 4829|       |        };
 4830|       |
 4831|      7|        widths
 4832|      8|    }
 4833|       |
 4834|       |    /// Open URL in default browser
 4835|       |    #[cfg(not(test))]
 4836|       |    fn open_url(&self, url: &str) {
 4837|       |        if let Err(e) = webbrowser::open(url) {
 4838|       |            eprintln!("Failed to open URL {}: {}", url, e);
 4839|       |        }
 4840|       |    }
 4841|       |
 4842|       |    #[cfg(test)]
 4843|      5|    fn open_url(&self, _url: &str) {}
 4844|       |
 4845|     12|    pub(crate) fn trigger_link(&self, url: &str) {
 4846|     12|        if let Some(fragment) = Self::extract_fragment(url) {
                                  ^6
 4847|      6|            *self.pending_anchor.borrow_mut() = Some(fragment);
 4848|      6|        } else if Self::is_allowed_scheme(url) {
 4849|      5|            self.open_url(url);
 4850|      5|        } else {
 4851|      1|            eprintln!("Blocked link with unsupported scheme: {}", url);
 4852|      1|        }
 4853|     12|    }
 4854|       |
 4855|     10|    fn is_allowed_scheme(url: &str) -> bool {
 4856|     10|        url.starts_with("http://") || url.starts_with("https://") || url.starts_with("mailto:")
                                                    ^9  ^9                         ^4  ^4
 4857|     10|    }
 4858|       |
 4859|       |    /// Consume and return the last clicked internal anchor, if any
 4860|     26|    pub fn take_pending_anchor(&self) -> Option<String> {
 4861|     26|        self.pending_anchor.borrow_mut().take()
 4862|     26|    }
 4863|       |
 4864|       |    /// Lookup a header rect by its id (slug)
 4865|      3|    pub fn header_rect_for(&self, id: &str) -> Option<egui::Rect> {
 4866|      3|        self.header_rects.borrow().get(id).copied()
 4867|      3|    }
 4868|       |
 4869|       |    /// Lookup the rect for the n-th top-level element rendered in the last frame
 4870|     14|    pub fn element_rect_at(&self, index: usize) -> Option<egui::Rect> {
 4871|     14|        self.element_rects.borrow().get(index).copied()
 4872|     14|    }
 4873|       |
 4874|     19|    pub fn layout_signature(&self) -> u64 {
 4875|     19|        let rects = self.element_rects.borrow();
 4876|     19|        let mut h = DefaultHasher::new();
 4877|     19|        rects.len().hash(&mut h);
 4878|     67|        for rect in rects.iter() {
                                  ^19   ^19
 4879|     67|            let min_x = (rect.min.x * 2.0).round() as i32;
 4880|     67|            let min_y = (rect.min.y * 2.0).round() as i32;
 4881|     67|            let max_x = (rect.max.x * 2.0).round() as i32;
 4882|     67|            let max_y = (rect.max.y * 2.0).round() as i32;
 4883|     67|            (min_x, min_y, max_x, max_y).hash(&mut h);
 4884|     67|        }
 4885|     19|        h.finish()
 4886|     19|    }
 4887|       |
 4888|     10|    pub fn has_pending_renders(&self) -> bool {
 4889|     10|        self.mermaid.has_pending() || !self.image_pending.borrow().is_empty()
                                                    ^9
 4890|     10|    }
 4891|       |
 4892|       |    /// Set or clear the highlight phrase (case-insensitive)
 4893|     29|    pub fn set_highlight_phrase(&self, phrase: Option<&str>) {
 4894|     29|        let normalized = phrase
 4895|     29|            .map(|p| p.case_fold().nfkc().collect::<String>())
                                   ^9^9          ^9     ^9
 4896|     29|            .filter(|value| !value.is_empty());
                                           ^9    ^9
 4897|       |        {
 4898|     29|            let mut current = self.highlight_phrase.borrow_mut();
 4899|     29|            if *current == normalized {
 4900|     21|                return;
 4901|      8|            }
 4902|      8|            *current = normalized;
 4903|       |        }
 4904|      8|        self.table_layout_cache.borrow_mut().clear();
 4905|     29|    }
 4906|       |
 4907|    253|    pub fn clear_table_layout_cache(&self) {
 4908|    253|        self.table_layout_cache.borrow_mut().clear();
 4909|    253|        self.table_metrics.borrow_mut().clear();
 4910|    253|        self.column_stats_cache.borrow_mut().clear();
 4911|    253|    }
 4912|       |
 4913|      4|    pub fn table_layout_cache_stats(&self) -> (u64, u64) {
 4914|      4|        self.table_layout_cache.borrow().stats()
 4915|      4|    }
 4916|       |
 4917|      2|    pub fn table_render_stats(&self) -> (usize, usize) {
 4918|      2|        self.table_metrics.borrow().totals()
 4919|      2|    }
 4920|       |
 4921|       |    /// Get a plain-text representation of a markdown element (for search)
 4922|     55|    pub fn element_plain_text(element: &MarkdownElement) -> String {
 4923|     55|        match element {
 4924|     45|            MarkdownElement::Paragraph(spans) => Self::spans_plain_text(spans),
 4925|      1|            MarkdownElement::Header { spans, .. } => Self::spans_plain_text(spans),
 4926|      1|            MarkdownElement::CodeBlock { text, .. } => text.clone(),
 4927|      2|            MarkdownElement::List { items, .. } => {
 4928|      2|                let mut out = String::new();
 4929|      4|                for item in items {
                                  ^2
 4930|      5|                    for block in &item.blocks {
                                      ^3
 4931|      3|                        if !out.is_empty() {
 4932|      1|                            out.push('\n');
 4933|      2|                        }
 4934|      3|                        out.push_str(&Self::element_plain_text(block));
 4935|       |                    }
 4936|       |                }
 4937|      2|                out
 4938|       |            }
 4939|      2|            MarkdownElement::Quote { blocks, .. } => {
 4940|      2|                let mut out = String::new();
 4941|      5|                for block in blocks {
                                  ^3
 4942|      3|                    if !out.is_empty() {
 4943|      1|                        out.push('\n');
 4944|      2|                    }
 4945|      3|                    out.push_str(&Self::element_plain_text(block));
 4946|       |                }
 4947|      2|                out
 4948|       |            }
 4949|      1|            MarkdownElement::HorizontalRule => String::from("---"),
 4950|       |            MarkdownElement::Table {
 4951|      3|                headers,
 4952|      3|                rows,
 4953|       |                alignments: _,
 4954|       |            } => {
 4955|      3|                let mut out = String::new();
 4956|      7|                for h in headers {
                                  ^4
 4957|      4|                    if !out.is_empty() {
 4958|      1|                        out.push(' ');
 4959|      3|                    }
 4960|      4|                    out.push_str(&Self::spans_plain_text(h));
 4961|       |                }
 4962|      6|                for row in rows {
                                  ^3
 4963|      7|                    for cell in row {
                                      ^4
 4964|      4|                        out.push(' ');
 4965|      4|                        out.push_str(&Self::spans_plain_text(cell));
 4966|      4|                    }
 4967|       |                }
 4968|      3|                out
 4969|       |            }
 4970|       |        }
 4971|     55|    }
 4972|       |
 4973|       |    /// Set the base directory for resolving relative image paths
 4974|     74|    pub fn set_base_dir(&self, dir: Option<&Path>) {
 4975|     74|        if let Some(d) = dir {
                                  ^34
 4976|     34|            self.base_dir.borrow_mut().replace(d.to_path_buf());
 4977|     40|        } else {
 4978|     40|            self.base_dir.borrow_mut().take();
 4979|     40|        }
 4980|     74|    }
 4981|       |
 4982|     34|    fn poll_image_results(&self, ctx: &egui::Context) -> bool {
 4983|     34|        let mut changed = false;
 4984|     40|        while let Ok(result) = self.image_result_rx.try_recv() {
                                   ^6
 4985|      6|            match result {
 4986|       |                ImageLoadResult::Loaded {
 4987|      5|                    key,
 4988|      5|                    image,
 4989|      5|                    size,
 4990|      5|                    modified,
 4991|      5|                } => {
 4992|      5|                    let tex =
 4993|      5|                        ctx.load_texture(format!("img:{key}"), image, egui::TextureOptions::LINEAR);
 4994|      5|                    self.store_image_texture(&key, tex.clone(), size, modified);
 4995|      5|                    self.image_failures.borrow_mut().remove(&key);
 4996|      5|                    self.image_pending.borrow_mut().remove(&key);
 4997|      5|                    changed = true;
 4998|      5|                }
 4999|      1|                ImageLoadResult::Failed { key } => {
 5000|      1|                    self.image_pending.borrow_mut().remove(&key);
 5001|      1|                    self.note_image_failure(&key);
 5002|      1|                }
 5003|       |            }
 5004|       |        }
 5005|     34|        if changed {
 5006|      5|            ctx.request_repaint();
 5007|     29|        }
 5008|     34|        changed
 5009|     34|    }
 5010|       |
 5011|     14|    fn enqueue_image_job(&self, request: ImageLoadRequest) -> Result<(), ()> {
 5012|     14|        match self.image_job_tx.try_send(request) {
 5013|     12|            Ok(()) => Ok(()),
 5014|      1|            Err(TrySendError::Full(_)) => Err(()),
 5015|      1|            Err(TrySendError::Disconnected(_)) => Err(()),
 5016|       |        }
 5017|     14|    }
 5018|       |
 5019|     22|    fn should_retry_image(&self, key: &str) -> bool {
 5020|     22|        let mut failures = self.image_failures.borrow_mut();
 5021|     22|        if let Some(failure) = failures.get(key) {
                                  ^3
 5022|      3|            if failure.last_attempt.elapsed() < IMAGE_FAILURE_BACKOFF {
 5023|      2|                return false;
 5024|      1|            }
 5025|     19|        }
 5026|     20|        failures.remove(key);
 5027|     20|        true
 5028|     22|    }
 5029|       |
 5030|      8|    fn note_image_failure(&self, key: &str) {
 5031|      8|        self.image_failures.borrow_mut().insert(
 5032|      8|            key.to_string(),
 5033|      8|            ImageFailure {
 5034|      8|                last_attempt: Instant::now(),
 5035|      8|            },
 5036|      8|        );
 5037|      8|    }
 5038|       |
 5039|     31|    fn resolve_image_path(&self, src: &str) -> String {
 5040|     31|        if src.starts_with("http://") || src.starts_with("https://") || src.starts_with("data:") {
                                                       ^29 ^29                        ^26 ^26
 5041|       |            // Keep as-is; we don't fetch remote or parse data URIs yet
 5042|      7|            return src.to_string();
 5043|     24|        }
 5044|     24|        let p = Path::new(src);
 5045|     24|        if p.is_absolute() {
 5046|      1|            return src.to_string();
 5047|     23|        }
 5048|     23|        if let Some(base) = self.base_dir.borrow().as_ref() {
                                  ^5
 5049|      5|            let joined = base.join(p);
 5050|      5|            return joined.to_string_lossy().into_owned();
 5051|     18|        }
 5052|     18|        src.to_string()
 5053|     31|    }
 5054|       |
 5055|     48|    fn get_or_load_image_texture(
 5056|     48|        &self,
 5057|     48|        _ui: &egui::Ui,
 5058|     48|        resolved_src: &str,
 5059|     48|    ) -> Option<(egui::TextureHandle, u32, u32)> {
 5060|       |        // Reject remote for now
 5061|     48|        if resolved_src.starts_with("http://") || resolved_src.starts_with("https://") {
                                                                ^46          ^46
 5062|      7|            return None;
 5063|     41|        }
 5064|       |
 5065|     41|        let path = Path::new(resolved_src);
 5066|     41|        let embedded = Self::embedded_image_bytes(resolved_src);
 5067|       |
 5068|       |        {
 5069|     41|            let mut cache = self.image_textures.borrow_mut();
 5070|     41|            if let Some(entry) = cache.get(resolved_src) {
                                      ^16
 5071|     16|                let stale = if embedded.is_some() {
 5072|      5|                    false
 5073|       |                } else {
 5074|     11|                    Self::image_source_stale(entry.modified, path)
 5075|       |                };
 5076|     16|                if !stale {
 5077|     15|                    return Some((entry.texture.clone(), entry.size[0], entry.size[1]));
 5078|      1|                }
 5079|      1|                cache.remove(resolved_src);
 5080|     25|            }
 5081|       |        }
 5082|       |
 5083|     26|        if self.image_pending.borrow().contains(resolved_src) {
 5084|      6|            return None;
 5085|     20|        }
 5086|       |
 5087|     20|        if !self.should_retry_image(resolved_src) {
 5088|      1|            return None;
 5089|     19|        }
 5090|       |
 5091|     19|        let source = if let Some(bytes) = embedded {
                          ^13                  ^8
 5092|      8|            ImageLoadSource::Embedded(bytes)
 5093|       |        } else {
 5094|     11|            if !path.exists() {
 5095|      6|                self.note_image_failure(resolved_src);
 5096|      6|                return None;
 5097|      5|            }
 5098|      5|            ImageLoadSource::File(path.to_path_buf())
 5099|       |        };
 5100|       |
 5101|     13|        let request = ImageLoadRequest {
 5102|     13|            key: resolved_src.to_string(),
 5103|     13|            source,
 5104|     13|        };
 5105|     13|        if self.enqueue_image_job(request).is_ok() {
 5106|     12|            self.image_pending
 5107|     12|                .borrow_mut()
 5108|     12|                .insert(resolved_src.to_string());
 5109|     12|        }
                      ^1
 5110|     13|        None
 5111|     48|    }
 5112|       |
 5113|     14|    fn disk_image_timestamp(path: &Path) -> Option<SystemTime> {
 5114|     14|        std::fs::metadata(path).ok()?.modified().ok()
                                                  ^0
 5115|     14|    }
 5116|       |
 5117|     11|    fn image_source_stale_with_timestamp(
 5118|     11|        cached_modified: Option<SystemTime>,
 5119|     11|        current: Option<SystemTime>,
 5120|     11|    ) -> bool {
 5121|     11|        match (cached_modified, current) {
 5122|      8|            (Some(prev), Some(cur)) => prev != cur,
 5123|      1|            (Some(_), None) => true,
 5124|      1|            (None, Some(_)) => true,
 5125|      1|            (None, None) => false,
 5126|       |        }
 5127|     11|    }
 5128|       |
 5129|     14|    fn image_source_stale(cached_modified: Option<SystemTime>, path: &Path) -> bool {
 5130|     14|        if !path.exists() {
 5131|      6|            return cached_modified.is_some();
 5132|      8|        }
 5133|      8|        let current = Self::disk_image_timestamp(path);
 5134|      8|        Self::image_source_stale_with_timestamp(cached_modified, current)
 5135|     14|    }
 5136|       |
 5137|      7|    fn store_image_texture(
 5138|      7|        &self,
 5139|      7|        key: &str,
 5140|      7|        texture: egui::TextureHandle,
 5141|      7|        size: [u32; 2],
 5142|      7|        modified: Option<SystemTime>,
 5143|      7|    ) {
 5144|      7|        self.image_textures.borrow_mut().insert(
 5145|      7|            key.to_string(),
 5146|      7|            ImageCacheEntry {
 5147|      7|                texture,
 5148|      7|                size,
 5149|      7|                modified,
 5150|      7|            },
 5151|      7|        );
 5152|      7|    }
 5153|       |
 5154|       |    /// Return embedded image bytes for known assets used in sample files
 5155|     41|    fn embedded_image_bytes(path: &str) -> Option<&'static [u8]> {
 5156|     41|        match path.replace('\\', "/").as_str() {
 5157|       |            // Smiley PNG
 5158|     41|            "assets/emoji/1f600.png" => Some(include_bytes!("../assets/emoji/1f600.png")),
                                                      ^12
 5159|       |            // SVG logo and WEBP sample used by images.md
 5160|     29|            "assets/samples/logo.svg" => Some(include_bytes!("../assets/samples/logo.svg")),
                                                       ^2
 5161|     27|            "assets/samples/webp_sample.webp" => {
 5162|      1|                Some(include_bytes!("../assets/samples/webp_sample.webp"))
 5163|       |            }
 5164|     26|            _ => None,
 5165|       |        }
 5166|     41|    }
 5167|       |
 5168|       |    /// Find syntax definition for a given language name
 5169|       |    /// Maps common language names to their syntax definitions
 5170|     30|    fn find_syntax_for_language(&self, lang: &str) -> Option<&syntect::parsing::SyntaxReference> {
 5171|       |        // Create a mapping of common language names to their syntect equivalents
 5172|     30|        let lang_lower = lang.to_lowercase();
 5173|       |
 5174|       |        // Try direct name match first
 5175|     30|        if let Some(syntax) = self.syntax_set.find_syntax_by_name(&lang_lower) {
                                  ^1
 5176|      1|            return Some(syntax);
 5177|     29|        }
 5178|       |
 5179|       |        // Try extension-based matching
 5180|     29|        if let Some(syntax) = self.syntax_set.find_syntax_by_extension(&lang_lower) {
                                  ^9
 5181|      9|            return Some(syntax);
 5182|     20|        }
 5183|       |
 5184|       |        // Handle common language mappings
 5185|     20|        let mapped_lang = match lang_lower.as_str() {
 5186|     20|            "rust" => "rs",
                                    ^7
 5187|     13|            "python" => "py",
                                      ^1
 5188|     12|            "javascript" => "js",
                                          ^1
 5189|     11|            "typescript" => "ts",
                                          ^1
 5190|     10|            "c++" | "cpp" => "cpp",
                                           ^0
 5191|     10|            "c#" | "csharp" => "cs",
                                 ^9          ^2
 5192|      8|            "shell" | "bash" => "sh",
                                    ^6        ^2
 5193|      6|            "powershell" => "ps1",
                                          ^2
 5194|      4|            "yaml" => "yml",
                                    ^0
 5195|      4|            "markdown" => "md",
                                        ^0
 5196|      4|            "html" => "html",
                                    ^0
 5197|      4|            "css" => "css",
                                   ^0
 5198|      4|            "java" => "java",
                                    ^0
 5199|      4|            "go" => "go",
                                  ^0
 5200|      4|            "php" => "php",
                                   ^0
 5201|      4|            "ruby" => "rb",
                                    ^0
 5202|      4|            "xml" => "xml",
                                   ^0
 5203|      4|            "json" => "json",
                                    ^0
 5204|      4|            "sql" => "sql",
                                   ^0
 5205|      4|            "toml" => "toml",
                                    ^1
 5206|      3|            _ => &lang_lower,
 5207|       |        };
 5208|       |
 5209|       |        // Try mapped extension
 5210|     20|        self.syntax_set
 5211|     20|            .find_syntax_by_extension(mapped_lang)
 5212|     20|            .or_else(|| self.syntax_set.find_syntax_by_name(mapped_lang))
                                      ^7              ^7                  ^7
 5213|     30|    }
 5214|       |
 5215|       |    /// Zoom in (increase font sizes)
 5216|      7|    pub fn zoom_in(&mut self) {
 5217|      7|        self.font_sizes.body = (self.font_sizes.body * 1.1).min(32.0);
 5218|      7|        self.font_sizes.h1 = (self.font_sizes.h1 * 1.1).min(48.0);
 5219|      7|        self.font_sizes.h2 = (self.font_sizes.h2 * 1.1).min(42.0);
 5220|      7|        self.font_sizes.h3 = (self.font_sizes.h3 * 1.1).min(36.0);
 5221|      7|        self.font_sizes.h4 = (self.font_sizes.h4 * 1.1).min(32.0);
 5222|      7|        self.font_sizes.h5 = (self.font_sizes.h5 * 1.1).min(28.0);
 5223|      7|        self.font_sizes.h6 = (self.font_sizes.h6 * 1.1).min(24.0);
 5224|      7|        self.font_sizes.code = (self.font_sizes.code * 1.1).min(20.0);
 5225|      7|        self.clear_table_layout_cache();
 5226|      7|    }
 5227|       |
 5228|       |    /// Zoom out (decrease font sizes)
 5229|      7|    pub fn zoom_out(&mut self) {
 5230|      7|        self.font_sizes.body = (self.font_sizes.body * 0.9).max(8.0);
 5231|      7|        self.font_sizes.h1 = (self.font_sizes.h1 * 0.9).max(16.0);
 5232|      7|        self.font_sizes.h2 = (self.font_sizes.h2 * 0.9).max(14.0);
 5233|      7|        self.font_sizes.h3 = (self.font_sizes.h3 * 0.9).max(12.0);
 5234|      7|        self.font_sizes.h4 = (self.font_sizes.h4 * 0.9).max(11.0);
 5235|      7|        self.font_sizes.h5 = (self.font_sizes.h5 * 0.9).max(10.0);
 5236|      7|        self.font_sizes.h6 = (self.font_sizes.h6 * 0.9).max(9.0);
 5237|      7|        self.font_sizes.code = (self.font_sizes.code * 0.9).max(8.0);
 5238|      7|        self.clear_table_layout_cache();
 5239|      7|    }
 5240|       |
 5241|       |    /// Reset zoom to default
 5242|      5|    pub fn reset_zoom(&mut self) {
 5243|      5|        self.font_sizes = FontSizes::default();
 5244|      5|        self.clear_table_layout_cache();
 5245|      5|    }
 5246|       |
 5247|       |    /// Set zoom scale relative to default font sizes.
 5248|      4|    pub fn set_zoom_scale(&mut self, scale: f32) {
 5249|      4|        let scale = scale.clamp(0.5, 4.0);
 5250|      4|        let default = FontSizes::default();
 5251|      4|        self.font_sizes.body = (default.body * scale).clamp(8.0, 32.0);
 5252|      4|        self.font_sizes.h1 = (default.h1 * scale).clamp(16.0, 48.0);
 5253|      4|        self.font_sizes.h2 = (default.h2 * scale).clamp(14.0, 42.0);
 5254|      4|        self.font_sizes.h3 = (default.h3 * scale).clamp(12.0, 36.0);
 5255|      4|        self.font_sizes.h4 = (default.h4 * scale).clamp(11.0, 32.0);
 5256|      4|        self.font_sizes.h5 = (default.h5 * scale).clamp(10.0, 28.0);
 5257|      4|        self.font_sizes.h6 = (default.h6 * scale).clamp(9.0, 24.0);
 5258|      4|        self.font_sizes.code = (default.code * scale).clamp(8.0, 20.0);
 5259|      4|        self.clear_table_layout_cache();
 5260|      4|    }
 5261|       |}
 5262|       |
 5263|       |#[cfg(test)]
 5264|       |mod tests {
 5265|       |    use super::*;
 5266|       |    use crate::SAMPLE_FILES;
 5267|       |    use image::codecs::png::PngEncoder;
 5268|       |    use image::ColorType;
 5269|       |    use image::ImageEncoder;
 5270|       |    use std::env;
 5271|       |    use std::fs;
 5272|       |    use std::str::FromStr;
 5273|       |    use std::sync::Mutex;
 5274|       |    use std::time::Duration;
 5275|       |    use syntect::highlighting::{Color, FontStyle, ScopeSelectors, StyleModifier, ThemeItem};
 5276|       |    use syntect::parsing::SyntaxDefinition;
 5277|       |    use tempfile::tempdir;
 5278|       |
 5279|       |    static MERMAID_ENV_LOCK: Mutex<()> = Mutex::new(());
 5280|       |
 5281|       |    struct EnvVarGuard {
 5282|       |        key: &'static str,
 5283|       |        previous: Option<String>,
 5284|       |        _lock: std::sync::MutexGuard<'static, ()>,
 5285|       |    }
 5286|       |
 5287|       |    impl EnvVarGuard {
 5288|      3|        fn set(key: &'static str, value: &str) -> Self {
 5289|      3|            let lock = MERMAID_ENV_LOCK.lock().expect("lock mermaid env");
 5290|      3|            let previous = env::var(key).ok();
 5291|      3|            env::set_var(key, value);
 5292|      3|            Self {
 5293|      3|                key,
 5294|      3|                previous,
 5295|      3|                _lock: lock,
 5296|      3|            }
 5297|      3|        }
 5298|       |    }
 5299|       |
 5300|       |    impl Drop for EnvVarGuard {
 5301|      3|        fn drop(&mut self) {
 5302|      3|            if let Some(prev) = &self.previous {
                                      ^1
 5303|      1|                env::set_var(self.key, prev);
 5304|      2|            } else {
 5305|      2|                env::remove_var(self.key);
 5306|      2|            }
 5307|      3|        }
 5308|       |    }
 5309|       |
 5310|       |    #[test]
 5311|      1|    fn test_spawn_image_loader_handles_error_path() {
 5312|      1|        MarkdownRenderer::force_thread_spawn_error_for_test();
 5313|      1|        let (_job_tx, job_rx) = crossbeam_channel::unbounded();
 5314|      1|        let (result_tx, _result_rx) = crossbeam_channel::unbounded();
 5315|      1|        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);
 5316|      1|    }
 5317|       |
 5318|       |    struct ForcedRenderActions {
 5319|       |        actions: Vec<&'static str>,
 5320|       |    }
 5321|       |
 5322|       |    impl ForcedRenderActions {
 5323|      5|        fn new(actions: &[&'static str]) -> Self {
 5324|      5|            FORCED_RENDER_ACTIONS.with(|set| {
 5325|      5|                let mut set = set.borrow_mut();
 5326|     21|                for action in actions {
                                  ^16
 5327|     16|                    set.insert(*action);
 5328|     16|                }
 5329|      5|            });
 5330|      5|            Self {
 5331|      5|                actions: actions.to_vec(),
 5332|      5|            }
 5333|      5|        }
 5334|       |    }
 5335|       |
 5336|       |    impl Drop for ForcedRenderActions {
 5337|      5|        fn drop(&mut self) {
 5338|      5|            FORCED_RENDER_ACTIONS.with(|set| {
 5339|      5|                let mut set = set.borrow_mut();
 5340|     21|                for action in &self.actions {
                                  ^16
 5341|     16|                    set.remove(action);
 5342|     16|                }
 5343|      5|            });
 5344|      5|        }
 5345|       |    }
 5346|       |
 5347|       |    struct ForcedTablePolicies;
 5348|       |
 5349|       |    impl ForcedTablePolicies {
 5350|      5|        fn new(policies: Vec<ColumnPolicy>) -> Self {
 5351|      5|            FORCED_TABLE_POLICIES.with(|slot| {
 5352|      5|                *slot.borrow_mut() = Some(policies);
 5353|      5|            });
 5354|      5|            Self
 5355|      5|        }
 5356|       |    }
 5357|       |
 5358|       |    impl Drop for ForcedTablePolicies {
 5359|      5|        fn drop(&mut self) {
 5360|      5|            FORCED_TABLE_POLICIES.with(|slot| {
 5361|      5|                slot.borrow_mut().take();
 5362|      5|            });
 5363|      5|        }
 5364|       |    }
 5365|       |
 5366|      4|    fn paragraph_spans(element: &MarkdownElement) -> Option<&[InlineSpan]> {
 5367|      4|        if let MarkdownElement::Paragraph(spans) = element {
                                                        ^3
 5368|      3|            Some(spans)
 5369|       |        } else {
 5370|      1|            None
 5371|       |        }
 5372|      4|    }
 5373|       |
 5374|      6|    fn image_span_fields(span: &InlineSpan) -> Option<(&str, &str, Option<&str>)> {
 5375|      6|        if let InlineSpan::Image { src, alt, title } = span {
                                                 ^5   ^5   ^5
 5376|      5|            Some((src.as_str(), alt.as_str(), title.as_deref()))
 5377|       |        } else {
 5378|      1|            None
 5379|       |        }
 5380|      6|    }
 5381|       |
 5382|      2|    fn text_span_content(span: &InlineSpan) -> Option<&str> {
 5383|      2|        if let InlineSpan::Text(text) = span {
                                              ^1
 5384|      1|            Some(text.as_str())
 5385|       |        } else {
 5386|      1|            None
 5387|       |        }
 5388|      2|    }
 5389|       |
 5390|      2|    fn emoji_fragment_key<'a>(fragment: &'a CellFragment<'a>) -> Option<&'a str> {
 5391|      2|        if let CellFragment::Emoji(key) = fragment {
                                                 ^1
 5392|      1|            Some(key.as_str())
 5393|       |        } else {
 5394|      1|            None
 5395|       |        }
 5396|      2|    }
 5397|       |
 5398|     70|    fn with_test_ui<F>(f: F)
 5399|     70|    where
 5400|     70|        F: FnOnce(&egui::Context, &mut egui::Ui),
 5401|       |    {
 5402|     70|        let ctx = egui::Context::default();
 5403|     70|        let input = egui::RawInput {
 5404|     70|            screen_rect: Some(egui::Rect::from_min_size(
 5405|     70|                egui::pos2(0.0, 0.0),
 5406|     70|                egui::vec2(1024.0, 768.0),
 5407|     70|            )),
 5408|     70|            ..Default::default()
 5409|     70|        };
 5410|     70|        ctx.begin_frame(input);
 5411|     70|        egui::CentralPanel::default().show(&ctx, |ui| {
 5412|     70|            f(&ctx, ui);
 5413|     70|        });
 5414|     70|        let _ = ctx.end_frame();
 5415|     70|    }
 5416|       |
 5417|      5|    fn wait_for_image(
 5418|      5|        renderer: &MarkdownRenderer,
 5419|      5|        ctx: &egui::Context,
 5420|      5|        ui: &egui::Ui,
 5421|      5|        path: &str,
 5422|      5|    ) -> Option<(egui::TextureHandle, u32, u32)> {
 5423|      5|        wait_for_image_with_limit(renderer, ctx, ui, path, 200)
 5424|      5|    }
 5425|       |
 5426|      6|    fn wait_for_image_with_limit(
 5427|      6|        renderer: &MarkdownRenderer,
 5428|      6|        ctx: &egui::Context,
 5429|      6|        ui: &egui::Ui,
 5430|      6|        path: &str,
 5431|      6|        max_iters: usize,
 5432|      6|    ) -> Option<(egui::TextureHandle, u32, u32)> {
 5433|      6|        for _ in 0..max_iters {
 5434|     15|            if let Some(loaded) = renderer.get_or_load_image_texture(ui, path) {
                                      ^5
 5435|      5|                return Some(loaded);
 5436|     10|            }
 5437|     10|            renderer.poll_image_results(ctx);
 5438|     10|            std::thread::sleep(Duration::from_millis(10));
 5439|       |        }
 5440|      1|        renderer.get_or_load_image_texture(ui, path)
 5441|      6|    }
 5442|       |
 5443|     29|    fn run_frame_with_input<F>(ctx: &egui::Context, input: egui::RawInput, f: F)
 5444|     29|    where
 5445|     29|        F: FnOnce(&egui::Context, &mut egui::Ui),
 5446|       |    {
 5447|     29|        ctx.begin_frame(input);
 5448|     29|        egui::CentralPanel::default().show(ctx, |ui| {
 5449|     29|            f(ctx, ui);
 5450|     29|        });
 5451|     29|        let _ = ctx.end_frame();
 5452|     29|    }
 5453|       |
 5454|      8|    fn input_with_click(pos: egui::Pos2, button: egui::PointerButton) -> egui::RawInput {
 5455|      8|        let mut input = egui::RawInput {
 5456|      8|            screen_rect: Some(egui::Rect::from_min_size(
 5457|      8|                egui::pos2(0.0, 0.0),
 5458|      8|                egui::vec2(320.0, 240.0),
 5459|      8|            )),
 5460|      8|            ..Default::default()
 5461|      8|        };
 5462|      8|        input.events.push(egui::Event::PointerMoved(pos));
 5463|      8|        input.events.push(egui::Event::PointerButton {
 5464|      8|            pos,
 5465|      8|            button,
 5466|      8|            pressed: true,
 5467|      8|            modifiers: egui::Modifiers::default(),
 5468|      8|        });
 5469|      8|        input.events.push(egui::Event::PointerButton {
 5470|      8|            pos,
 5471|      8|            button,
 5472|      8|            pressed: false,
 5473|      8|            modifiers: egui::Modifiers::default(),
 5474|      8|        });
 5475|      8|        input
 5476|      8|    }
 5477|       |
 5478|      4|    fn tiny_png_bytes() -> Vec<u8> {
 5479|      4|        let width = 2u32;
 5480|      4|        let height = 2u32;
 5481|      4|        let pixels = vec![255u8; (width * height * 4) as usize];
 5482|      4|        let mut out = Vec::new();
 5483|      4|        let encoder = PngEncoder::new(&mut out);
 5484|      4|        encoder
 5485|      4|            .write_image(&pixels, width, height, ColorType::Rgba8)
 5486|      4|            .expect("encode png");
 5487|      4|        out
 5488|      4|    }
 5489|       |
 5490|       |    #[test]
 5491|      1|    fn test_image_cache_get_missing_and_insert_empty_order() {
 5492|      1|        let mut cache = ImageCache::new(1);
 5493|      1|        assert!(cache.get("missing").is_none());
 5494|       |
 5495|      1|        let mut entry_slot = None;
 5496|      1|        with_test_ui(|ctx, _ui| {
 5497|      1|            let tex = ctx.load_texture(
 5498|       |                "cache_test",
 5499|      1|                egui::ColorImage::new([1, 1], Color32::WHITE),
 5500|       |                egui::TextureOptions::LINEAR,
 5501|       |            );
 5502|      1|            entry_slot = Some(ImageCacheEntry {
 5503|      1|                texture: tex,
 5504|      1|                size: [1, 1],
 5505|      1|                modified: None,
 5506|      1|            });
 5507|      1|        });
 5508|      1|        let entry = entry_slot.expect("texture");
 5509|      1|        cache.entries.insert(
 5510|      1|            "a".to_string(),
 5511|      1|            ImageCacheEntry {
 5512|      1|                texture: entry.texture.clone(),
 5513|      1|                size: entry.size,
 5514|      1|                modified: entry.modified,
 5515|      1|            },
 5516|       |        );
 5517|      1|        cache.order.clear();
 5518|      1|        cache.insert(
 5519|      1|            "b".to_string(),
 5520|      1|            ImageCacheEntry {
 5521|      1|                texture: entry.texture.clone(),
 5522|      1|                size: entry.size,
 5523|      1|                modified: entry.modified,
 5524|      1|            },
 5525|       |        );
 5526|      1|        assert!(cache.contains_key("b"));
 5527|      1|    }
 5528|       |
 5529|       |    #[test]
 5530|      1|    fn test_image_cache_insert_existing_key_updates_entry() {
 5531|      1|        let mut cache = ImageCache::new(2);
 5532|      1|        let mut entry_slot = None;
 5533|      1|        with_test_ui(|ctx, _ui| {
 5534|      1|            let tex = ctx.load_texture(
 5535|       |                "cache_update",
 5536|      1|                egui::ColorImage::new([1, 1], Color32::WHITE),
 5537|       |                egui::TextureOptions::LINEAR,
 5538|       |            );
 5539|      1|            entry_slot = Some(ImageCacheEntry {
 5540|      1|                texture: tex,
 5541|      1|                size: [1, 1],
 5542|      1|                modified: None,
 5543|      1|            });
 5544|      1|        });
 5545|      1|        let entry = entry_slot.expect("texture");
 5546|      1|        cache.insert(
 5547|      1|            "a".to_string(),
 5548|      1|            ImageCacheEntry {
 5549|      1|                texture: entry.texture.clone(),
 5550|      1|                size: [1, 1],
 5551|      1|                modified: entry.modified,
 5552|      1|            },
 5553|       |        );
 5554|      1|        cache.insert(
 5555|      1|            "a".to_string(),
 5556|      1|            ImageCacheEntry {
 5557|      1|                texture: entry.texture.clone(),
 5558|      1|                size: [2, 2],
 5559|      1|                modified: entry.modified,
 5560|      1|            },
 5561|       |        );
 5562|      1|        let stored = cache.get("a").expect("stored");
 5563|      1|        assert_eq!(stored.size, [2, 2]);
 5564|      1|    }
 5565|       |
 5566|       |    #[test]
 5567|      1|    fn test_image_cache_evicts_oldest_entry() {
 5568|      1|        let mut cache = ImageCache::new(1);
 5569|      1|        let mut entry_slot = None;
 5570|      1|        with_test_ui(|ctx, _ui| {
 5571|      1|            let tex = ctx.load_texture(
 5572|       |                "cache_evict",
 5573|      1|                egui::ColorImage::new([1, 1], Color32::WHITE),
 5574|       |                egui::TextureOptions::LINEAR,
 5575|       |            );
 5576|      1|            entry_slot = Some(ImageCacheEntry {
 5577|      1|                texture: tex,
 5578|      1|                size: [1, 1],
 5579|      1|                modified: None,
 5580|      1|            });
 5581|      1|        });
 5582|      1|        let entry = entry_slot.expect("texture");
 5583|      1|        cache.insert(
 5584|      1|            "a".to_string(),
 5585|      1|            ImageCacheEntry {
 5586|      1|                texture: entry.texture.clone(),
 5587|      1|                size: entry.size,
 5588|      1|                modified: entry.modified,
 5589|      1|            },
 5590|       |        );
 5591|      1|        cache.insert(
 5592|      1|            "b".to_string(),
 5593|      1|            ImageCacheEntry {
 5594|      1|                texture: entry.texture.clone(),
 5595|      1|                size: entry.size,
 5596|      1|                modified: entry.modified,
 5597|      1|            },
 5598|       |        );
 5599|      1|        assert!(cache.contains_key("b"));
 5600|      1|        assert!(!cache.contains_key("a"));
 5601|      1|    }
 5602|       |
 5603|       |    #[test]
 5604|      1|    fn test_list_marker_info_rejects_empty_and_bad_numeric() {
 5605|      1|        assert!(MarkdownRenderer::list_marker_info("").is_none());
 5606|      1|        assert!(MarkdownRenderer::list_marker_info("1 abc").is_none());
 5607|      1|        assert!(MarkdownRenderer::list_marker_info("   ").is_none());
 5608|      1|    }
 5609|       |
 5610|       |    #[test]
 5611|      1|    fn test_list_marker_info_rejects_tabs_and_missing_whitespace() {
 5612|      1|        assert!(MarkdownRenderer::list_marker_info("\t- item").is_none());
 5613|      1|        assert!(MarkdownRenderer::list_marker_info("1.item").is_none());
 5614|      1|        assert!(MarkdownRenderer::list_marker_info("1)item").is_none());
 5615|      1|        assert!(MarkdownRenderer::list_marker_info("-item").is_none());
 5616|      1|    }
 5617|       |
 5618|       |    #[test]
 5619|      1|    fn test_list_marker_info_rejects_marker_only() {
 5620|      1|        assert!(MarkdownRenderer::list_marker_info("-").is_none());
 5621|      1|        assert!(MarkdownRenderer::list_marker_info("1.").is_none());
 5622|      1|    }
 5623|       |
 5624|       |    #[test]
 5625|      1|    fn test_parse_image_with_title_sets_title() {
 5626|      1|        let renderer = MarkdownRenderer::new();
 5627|      1|        let parsed = renderer
 5628|      1|            .parse("![alt](path/to/img.png \"Title\")")
 5629|      1|            .expect("parse");
 5630|      1|        let spans = paragraph_spans(&parsed[0]).expect("paragraph spans");
 5631|      1|        let (_src, _alt, title) = image_span_fields(&spans[0]).expect("image span");
 5632|      1|        assert_eq!(title, Some("Title"));
 5633|      1|    }
 5634|       |
 5635|       |    #[test]
 5636|      1|    fn test_is_external_url_variants() {
 5637|      1|        assert!(MarkdownRenderer::is_external_url("http://example.com"));
 5638|      1|        assert!(MarkdownRenderer::is_external_url("https://example.com"));
 5639|      1|        assert!(MarkdownRenderer::is_external_url("mailto:test@example.com"));
 5640|      1|        assert!(MarkdownRenderer::is_external_url("www.example.com"));
 5641|      1|        assert!(!MarkdownRenderer::is_external_url("local/path.png"));
 5642|      1|    }
 5643|       |
 5644|       |    #[test]
 5645|      1|    fn test_resolve_image_path_keeps_remote() {
 5646|      1|        let renderer = MarkdownRenderer::new();
 5647|      1|        let src = "https://example.com/image.png";
 5648|      1|        let http_src = "http://example.com/image.png";
 5649|      1|        assert_eq!(renderer.resolve_image_path(src), src);
 5650|      1|        assert_eq!(renderer.resolve_image_path(http_src), http_src);
 5651|      1|        let data_src = "data:image/png;base64,AAAA";
 5652|      1|        assert_eq!(renderer.resolve_image_path(data_src), data_src);
 5653|      1|    }
 5654|       |
 5655|       |    #[test]
 5656|      1|    fn test_compute_table_id_includes_base_dir() {
 5657|      1|        let renderer = MarkdownRenderer::new();
 5658|      1|        let headers = vec![vec![InlineSpan::Text("A".to_string())]];
 5659|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
 5660|      1|        let alignments = vec![Alignment::Left];
 5661|      1|        let base_id = renderer.compute_table_id(&headers, &rows, &alignments, 0);
 5662|       |
 5663|      1|        *renderer.base_dir.borrow_mut() = Some(PathBuf::from("C:\\tmp"));
 5664|      1|        let with_base = renderer.compute_table_id(&headers, &rows, &alignments, 0);
 5665|      1|        assert_ne!(base_id, with_base);
 5666|      1|    }
 5667|       |
 5668|       |    #[test]
 5669|      1|    fn test_render_table_early_return_on_empty_headers() {
 5670|      1|        let renderer = MarkdownRenderer::new();
 5671|      1|        with_test_ui(|_, ui| {
 5672|      1|            renderer.render_table(ui, &[], &[], &[]);
 5673|      1|        });
 5674|      1|    }
 5675|       |
 5676|       |    #[test]
 5677|      1|    fn test_extend_table_rect_handles_nan() {
 5678|      1|        let mut target = Some(egui::Rect::from_min_size(
 5679|      1|            egui::pos2(0.0, 0.0),
 5680|      1|            egui::vec2(10.0, 10.0),
 5681|      1|        ));
 5682|      1|        let nan_rect = egui::Rect::from_min_size(egui::pos2(f32::NAN, 0.0), egui::vec2(1.0, 1.0));
 5683|      1|        MarkdownRenderer::extend_table_rect(&mut target, nan_rect);
 5684|      1|        let stored = target.expect("target");
 5685|      1|        assert!(!stored.min.x.is_nan());
 5686|       |
 5687|      1|        let mut target_none = None;
 5688|      1|        MarkdownRenderer::extend_table_rect(
 5689|      1|            &mut target_none,
 5690|      1|            egui::Rect::from_min_size(egui::pos2(5.0, 6.0), egui::vec2(2.0, 2.0)),
 5691|       |        );
 5692|      1|        assert!(target_none.is_some());
 5693|      1|    }
 5694|       |
 5695|       |    #[test]
 5696|      1|    fn test_extend_table_rect_rejects_nan_components() {
 5697|      1|        let base = egui::Rect::from_min_size(egui::pos2(1.0, 2.0), egui::vec2(3.0, 4.0));
 5698|      1|        let mut target = Some(base);
 5699|      1|        let nan_min_y = egui::Rect::from_min_size(egui::pos2(0.0, f32::NAN), egui::vec2(1.0, 1.0));
 5700|      1|        MarkdownRenderer::extend_table_rect(&mut target, nan_min_y);
 5701|      1|        assert_eq!(target, Some(base));
 5702|       |
 5703|      1|        let mut target = Some(base);
 5704|      1|        let nan_max_x = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(f32::NAN, 1.0));
 5705|      1|        MarkdownRenderer::extend_table_rect(&mut target, nan_max_x);
 5706|      1|        assert_eq!(target, Some(base));
 5707|       |
 5708|      1|        let mut target = Some(base);
 5709|      1|        let nan_max_y = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(1.0, f32::NAN));
 5710|      1|        MarkdownRenderer::extend_table_rect(&mut target, nan_max_y);
 5711|      1|        assert_eq!(target, Some(base));
 5712|      1|    }
 5713|       |
 5714|       |    #[test]
 5715|      1|    fn test_persist_resizable_widths_returns_on_empty() {
 5716|      1|        let renderer = MarkdownRenderer::new();
 5717|      1|        renderer.persist_resizable_widths(1, &[], &[]);
 5718|      1|    }
 5719|       |
 5720|       |    #[test]
 5721|      1|    fn test_persist_resizable_widths_returns_on_empty_widths() {
 5722|      1|        let renderer = MarkdownRenderer::new();
 5723|      1|        let spec = ColumnSpec::new(
 5724|       |            0,
 5725|       |            "A",
 5726|      1|            ColumnPolicy::Resizable {
 5727|      1|                min: 20.0,
 5728|      1|                preferred: 80.0,
 5729|      1|                clip: false,
 5730|      1|            },
 5731|      1|            None,
 5732|       |        );
 5733|      1|        let table_id = 7u64;
 5734|      1|        renderer.persist_resizable_widths(table_id, &[spec], &[]);
 5735|      1|        let metrics = renderer.table_metrics.borrow();
 5736|      1|        assert!(metrics.entry(table_id).is_none());
 5737|      1|    }
 5738|       |
 5739|       |    #[test]
 5740|      1|    fn test_link_at_pointer_outside_rect_returns_none() {
 5741|      1|        let renderer = MarkdownRenderer::new();
 5742|      1|        let spans = vec![InlineSpan::Link {
 5743|      1|            text: "Link".to_string(),
 5744|      1|            url: "https://example.com".to_string(),
 5745|      1|        }];
 5746|      1|        let ctx = egui::Context::default();
 5747|      1|        let mut input = egui::RawInput {
 5748|      1|            screen_rect: Some(egui::Rect::from_min_size(
 5749|      1|                egui::pos2(0.0, 0.0),
 5750|      1|                egui::vec2(320.0, 240.0),
 5751|      1|            )),
 5752|      1|            ..Default::default()
 5753|      1|        };
 5754|      1|        input
 5755|      1|            .events
 5756|      1|            .push(egui::Event::PointerMoved(egui::pos2(200.0, 200.0)));
 5757|      1|        ctx.begin_frame(input);
 5758|      1|        let mut found = false;
 5759|      1|        egui::CentralPanel::default().show(&ctx, |ui| {
 5760|      1|            let response = ui.label("anchor");
 5761|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, false, Align::LEFT);
 5762|      1|            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
 5763|      1|            found = renderer
 5764|      1|                .link_at_pointer(&response, &galley, &build, egui::pos2(0.0, 0.0))
 5765|      1|                .is_some();
 5766|      1|        });
 5767|      1|        let _ = ctx.end_frame();
 5768|      1|        assert!(!found);
 5769|      1|    }
 5770|       |
 5771|       |    #[test]
 5772|      1|    fn test_spawn_image_loader_missing_file_reports_failed() {
 5773|      1|        let (job_tx, job_rx) = bounded(1);
 5774|      1|        let (result_tx, result_rx) = bounded(1);
 5775|      1|        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);
 5776|       |
 5777|      1|        let dir = tempdir().expect("temp dir");
 5778|      1|        let path = dir.path().join("missing.png");
 5779|      1|        job_tx
 5780|      1|            .send(ImageLoadRequest {
 5781|      1|                key: "missing".to_string(),
 5782|      1|                source: ImageLoadSource::File(path),
 5783|      1|            })
 5784|      1|            .expect("send");
 5785|      1|        let result = result_rx
 5786|      1|            .recv_timeout(Duration::from_secs(3))
 5787|      1|            .expect("result");
 5788|      1|        assert!(matches!(
 5789|      1|            result,
 5790|      1|            ImageLoadResult::Failed { ref key } if key == "missing"
 5791|       |        ));
 5792|      1|    }
 5793|       |
 5794|       |    #[test]
 5795|      1|    fn test_spawn_image_loader_embedded_invalid_bytes_reports_failed() {
 5796|      1|        let (job_tx, job_rx) = bounded(1);
 5797|      1|        let (result_tx, result_rx) = bounded(1);
 5798|      1|        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);
 5799|       |
 5800|      1|        job_tx
 5801|      1|            .send(ImageLoadRequest {
 5802|      1|                key: "bad-embedded".to_string(),
 5803|      1|                source: ImageLoadSource::Embedded(b"not an image"),
 5804|      1|            })
 5805|      1|            .expect("send");
 5806|      1|        let result = result_rx
 5807|      1|            .recv_timeout(Duration::from_secs(8))
 5808|      1|            .expect("result");
 5809|      1|        assert!(matches!(
 5810|      1|            result,
 5811|      1|            ImageLoadResult::Failed { ref key } if key == "bad-embedded"
 5812|       |        ));
 5813|      1|    }
 5814|       |
 5815|       |    #[test]
 5816|      1|    fn test_spawn_image_loader_file_invalid_bytes_reports_failed() -> Result<()> {
 5817|      1|        let (job_tx, job_rx) = bounded(1);
 5818|      1|        let (result_tx, result_rx) = bounded(1);
 5819|      1|        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);
 5820|       |
 5821|      1|        let dir = tempdir()?;
                                         ^0
 5822|      1|        let path = dir.path().join("bad.png");
 5823|      1|        std::fs::write(&path, b"not an image")?;
                                                            ^0
 5824|      1|        job_tx
 5825|      1|            .send(ImageLoadRequest {
 5826|      1|                key: "bad-file".to_string(),
 5827|      1|                source: ImageLoadSource::File(path),
 5828|      1|            })
 5829|      1|            .expect("send");
 5830|      1|        let result = result_rx
 5831|      1|            .recv_timeout(Duration::from_secs(3))
 5832|      1|            .expect("result");
 5833|      1|        assert!(matches!(
 5834|      1|            result,
 5835|      1|            ImageLoadResult::Failed { ref key } if key == "bad-file"
 5836|       |        ));
 5837|      1|        Ok(())
 5838|      1|    }
 5839|       |
 5840|       |    #[test]
 5841|      1|    fn test_spawn_image_loader_file_read_error_reports_failed() -> Result<()> {
 5842|      1|        let (job_tx, job_rx) = bounded(1);
 5843|      1|        let (result_tx, result_rx) = bounded(1);
 5844|      1|        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);
 5845|       |
 5846|      1|        let dir = tempdir()?;
                                         ^0
 5847|      1|        let bad_path = dir.path().join("read_error_dir");
 5848|      1|        std::fs::create_dir_all(&bad_path)?;
                                                        ^0
 5849|      1|        job_tx
 5850|      1|            .send(ImageLoadRequest {
 5851|      1|                key: "read-error".to_string(),
 5852|      1|                source: ImageLoadSource::File(bad_path),
 5853|      1|            })
 5854|      1|            .expect("send");
 5855|      1|        let result = result_rx
 5856|      1|            .recv_timeout(Duration::from_secs(1))
 5857|      1|            .expect("result");
 5858|      1|        assert!(matches!(
 5859|      1|            result,
 5860|      1|            ImageLoadResult::Failed { ref key } if key == "read-error"
 5861|       |        ));
 5862|      1|        Ok(())
 5863|      1|    }
 5864|       |
 5865|       |    #[test]
 5866|      1|    fn test_env_var_guard_removes_unset_value() {
 5867|      1|        let key = "MDMDVIEW_TEST_ENV_GUARD";
 5868|      1|        env::remove_var(key);
 5869|       |        {
 5870|      1|            let _guard = EnvVarGuard::set(key, "value");
 5871|      1|            assert_eq!(env::var(key).ok().as_deref(), Some("value"));
 5872|       |        }
 5873|      1|        assert!(env::var(key).is_err());
 5874|      1|    }
 5875|       |
 5876|       |    #[test]
 5877|      1|    fn test_parse_forced_error_returns_err_once() {
 5878|      1|        let renderer = MarkdownRenderer::new();
 5879|      1|        force_parse_error_once();
 5880|      1|        assert!(renderer.parse("hello").is_err());
 5881|      1|        assert!(renderer.parse("hello").is_ok());
 5882|      1|    }
 5883|       |
 5884|       |    #[test]
 5885|      1|    fn test_fence_helpers_cover_branches() {
 5886|      1|        assert_eq!(MarkdownRenderer::fence_start("```"), Some(('`', 3)));
 5887|      1|        assert_eq!(MarkdownRenderer::fence_start("``"), None);
 5888|      1|        assert_eq!(MarkdownRenderer::fence_start("~~~"), Some(('~', 3)));
 5889|      1|        assert!(MarkdownRenderer::is_fence_end("```", '`', 3));
 5890|      1|        assert!(!MarkdownRenderer::is_fence_end("``", '`', 3));
 5891|      1|        assert!(MarkdownRenderer::is_fence_end("   ```", '`', 3));
 5892|      1|    }
 5893|       |
 5894|       |    #[test]
 5895|      1|    fn test_restore_pipe_sentinel_round_trip() {
 5896|      1|        let input = format!("a{}b", PIPE_SENTINEL);
 5897|      1|        assert_eq!(MarkdownRenderer::restore_pipe_sentinel(&input), "a|b");
 5898|      1|        assert_eq!(MarkdownRenderer::restore_pipe_sentinel("a|b"), "a|b");
 5899|      1|    }
 5900|       |
 5901|       |    #[test]
 5902|      1|    fn test_list_marker_info_numeric_punctuation() {
 5903|      1|        let (content, _indent, _content_indent) =
 5904|      1|            MarkdownRenderer::list_marker_info("1. item").expect("dot marker");
 5905|      1|        assert_eq!(content.trim_start(), "item");
 5906|      1|        let (content, _indent, _content_indent) =
 5907|      1|            MarkdownRenderer::list_marker_info("2) item").expect("paren marker");
 5908|      1|        assert_eq!(content.trim_start(), "item");
 5909|      1|    }
 5910|       |
 5911|       |    #[test]
 5912|      1|    fn test_table_line_info_blockquote_levels() {
 5913|      1|        let (level, rest) = MarkdownRenderer::table_line_info("  >\t| a |");
 5914|      1|        assert_eq!(level, 1);
 5915|      1|        assert!(rest.trim_start().starts_with('|'));
 5916|       |
 5917|      1|        let (level, rest) = MarkdownRenderer::table_line_info("> > | b |");
 5918|      1|        assert_eq!(level, 2);
 5919|      1|        assert!(rest.trim_start().starts_with('|'));
 5920|      1|    }
 5921|       |
 5922|       |    #[test]
 5923|      1|    fn test_strip_indent_columns_indent_zero_returns_line() {
 5924|      1|        assert_eq!(
 5925|      1|            MarkdownRenderer::strip_indent_columns("content", 0),
 5926|       |            Some("content")
 5927|       |        );
 5928|      1|    }
 5929|       |
 5930|       |    #[test]
 5931|      1|    fn test_parent_list_indent_for_line_zero_index_returns_none() {
 5932|      1|        let lines = vec!["- item"];
 5933|      1|        let (level, rest) = MarkdownRenderer::table_line_info(lines[0]);
 5934|      1|        assert!(MarkdownRenderer::parent_list_indent_for_line(&lines, 0, level, rest).is_none());
 5935|      1|    }
 5936|       |
 5937|       |    #[test]
 5938|      1|    fn test_should_retry_image_backoff_respected() {
 5939|      1|        let renderer = MarkdownRenderer::new();
 5940|      1|        renderer.image_failures.borrow_mut().insert(
 5941|      1|            "recent".to_string(),
 5942|      1|            ImageFailure {
 5943|      1|                last_attempt: std::time::Instant::now(),
 5944|      1|            },
 5945|      1|        );
 5946|      1|        assert!(!renderer.should_retry_image("recent"));
 5947|       |
 5948|      1|        renderer.image_failures.borrow_mut().insert(
 5949|      1|            "old".to_string(),
 5950|      1|            ImageFailure {
 5951|      1|                last_attempt: std::time::Instant::now()
 5952|      1|                    - IMAGE_FAILURE_BACKOFF
 5953|      1|                    - Duration::from_millis(1),
 5954|      1|            },
 5955|      1|        );
 5956|      1|        assert!(renderer.should_retry_image("old"));
 5957|      1|    }
 5958|       |
 5959|       |    #[test]
 5960|      1|    fn test_extend_table_rect_accepts_valid_rect() {
 5961|      1|        let mut target = None;
 5962|      1|        let rect = egui::Rect::from_min_size(egui::pos2(1.0, 2.0), egui::vec2(3.0, 4.0));
 5963|      1|        MarkdownRenderer::extend_table_rect(&mut target, rect);
 5964|      1|        assert_eq!(target, Some(rect));
 5965|       |
 5966|      1|        let rect2 = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(10.0, 10.0));
 5967|      1|        MarkdownRenderer::extend_table_rect(&mut target, rect2);
 5968|      1|        let merged = target.expect("merged rect");
 5969|      1|        assert!(merged.contains(rect.min));
 5970|      1|        assert!(merged.contains(rect2.max));
 5971|      1|    }
 5972|       |
 5973|       |    #[test]
 5974|      1|    fn test_render_code_block_with_none_language() {
 5975|      1|        let renderer = MarkdownRenderer::new();
 5976|      1|        with_test_ui(|_, ui| {
 5977|      1|            renderer.render_code_block(ui, None, "fn main() {}");
 5978|      1|        });
 5979|      1|    }
 5980|       |
 5981|       |    #[test]
 5982|      1|    fn test_render_action_triggered_forced_paths() {
 5983|      1|        let _actions = ForcedRenderActions::new(&["forced_action"]);
 5984|      1|        assert!(render_action_triggered(false, "forced_action"));
 5985|      1|        assert!(!render_action_triggered(false, "other_action"));
 5986|      1|        assert!(render_action_triggered(true, "other_action"));
 5987|      1|    }
 5988|       |
 5989|       |    #[test]
 5990|      1|    fn test_markdown_renderer_creation() {
 5991|      1|        let renderer = MarkdownRenderer::new();
 5992|      1|        assert_eq!(renderer.font_sizes.body, 14.0);
 5993|      1|        assert_eq!(renderer.font_sizes.h1, 28.0);
 5994|      1|    }
 5995|       |
 5996|       |    #[test]
 5997|      1|    fn test_markdown_renderer_default_uses_defaults() {
 5998|      1|        let renderer = MarkdownRenderer::default();
 5999|      1|        let defaults = FontSizes::default();
 6000|      1|        assert_eq!(renderer.font_sizes.body, defaults.body);
 6001|      1|        assert_eq!(renderer.font_sizes.code, defaults.code);
 6002|      1|    }
 6003|       |
 6004|       |    #[test]
 6005|      1|    fn test_superscript_expansion_basic() {
 6006|      1|        let s = "5^th^ and m^2^";
 6007|      1|        let out = MarkdownRenderer::expand_superscripts(s);
 6008|      1|        assert!(out.contains("5"));
 6009|      1|        assert!(out.contains("m"));
 6010|      1|    }
 6011|       |
 6012|       |    #[test]
 6013|      1|    fn test_superscript_expansion_allows_plus_symbol() {
 6014|      1|        let out = MarkdownRenderer::expand_superscripts("x^+^");
 6015|      1|        assert!(out.contains('\u{207a}'));
 6016|      1|    }
 6017|       |
 6018|       |    #[test]
 6019|      1|    fn test_superscript_expansion_single_caret() {
 6020|       |        // Test that single carets (not paired) are left as-is
 6021|      1|        let s = "2^32 = 4,294,967,296";
 6022|      1|        let out = MarkdownRenderer::expand_superscripts(s);
 6023|      1|        assert_eq!(out, "2^32 = 4,294,967,296");
 6024|       |
 6025|       |        // Test the problematic line from the bug report
 6026|      1|        let problematic = "A 32-bit address bus would provide 2^32 = 4,294,967,296 bytes (4 GB) of addressable memory.";
 6027|      1|        let fixed = MarkdownRenderer::expand_superscripts(problematic);
 6028|      1|        assert_eq!(fixed, problematic);
 6029|       |
 6030|       |        // Test mixed cases
 6031|      1|        let mixed = "Use 2^32 for math and 5^th^ for ordinal";
 6032|      1|        let result = MarkdownRenderer::expand_superscripts(mixed);
 6033|      1|        assert!(result.contains("2^32"));
 6034|      1|        assert!(result.contains("5"));
 6035|      1|    }
 6036|       |
 6037|       |    #[test]
 6038|      1|    fn test_superscript_expansion_rejects_invalid_sequences() {
 6039|      1|        let s = "2^ab$^ and ^^";
 6040|      1|        let out = MarkdownRenderer::expand_superscripts(s);
 6041|      1|        assert_eq!(out, s);
 6042|      1|        let no_close = "10^abc";
 6043|      1|        let out = MarkdownRenderer::expand_superscripts(no_close);
 6044|      1|        assert_eq!(out, no_close);
 6045|      1|    }
 6046|       |
 6047|       |    #[test]
 6048|      1|    fn test_font_sizes_default() {
 6049|      1|        let sizes = FontSizes::default();
 6050|      1|        assert_eq!(sizes.body, 14.0);
 6051|      1|        assert_eq!(sizes.h1, 28.0);
 6052|      1|        assert_eq!(sizes.code, 12.0);
 6053|      1|    }
 6054|       |
 6055|       |    #[test]
 6056|      1|    fn test_zoom_functionality() {
 6057|      1|        let mut renderer = MarkdownRenderer::new();
 6058|      1|        let original_body = renderer.font_sizes.body;
 6059|       |
 6060|      1|        renderer.zoom_in();
 6061|      1|        assert!(renderer.font_sizes.body > original_body);
 6062|       |
 6063|      1|        renderer.zoom_out();
 6064|      1|        assert!(renderer.font_sizes.body < original_body * 1.1);
 6065|       |
 6066|      1|        renderer.reset_zoom();
 6067|      1|        assert_eq!(renderer.font_sizes.body, original_body);
 6068|      1|    }
 6069|       |
 6070|       |    #[test]
 6071|      1|    fn test_set_zoom_scale() {
 6072|      1|        let mut renderer = MarkdownRenderer::new();
 6073|       |
 6074|      1|        renderer.set_zoom_scale(1.5);
 6075|      1|        assert!((renderer.font_sizes.body - 21.0).abs() < 0.1);
 6076|       |
 6077|      1|        renderer.set_zoom_scale(10.0);
 6078|      1|        assert_eq!(renderer.font_sizes.body, 32.0);
 6079|       |
 6080|      1|        renderer.set_zoom_scale(0.1);
 6081|      1|        assert_eq!(renderer.font_sizes.body, 8.0);
 6082|      1|    }
 6083|       |
 6084|       |    #[test]
 6085|      1|    fn font_size_change_does_not_repersist_stale_widths() {
 6086|      1|        let mut renderer = MarkdownRenderer::new();
 6087|      1|        let table_id = 7u64;
 6088|      1|        let specs = vec![ColumnSpec::new(
 6089|       |            0,
 6090|       |            "A",
 6091|      1|            ColumnPolicy::Resizable {
 6092|      1|                min: 20.0,
 6093|      1|                preferred: 100.0,
 6094|      1|                clip: false,
 6095|      1|            },
 6096|      1|            None,
 6097|       |        )];
 6098|      1|        let widths = vec![100.0f32];
 6099|       |
 6100|       |        // Initial persist at default font size.
 6101|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
 6102|      1|        let policy_hash = specs[0].policy_hash;
 6103|       |        {
 6104|      1|            let metrics = renderer.table_metrics.borrow();
 6105|      1|            let entry = metrics.entry(table_id).expect("entry created");
 6106|      1|            assert_eq!(entry.persisted_width(policy_hash), Some(100.0));
 6107|      1|            assert_eq!(entry.persisted_font_size, Some(renderer.font_sizes.body));
 6108|       |        }
 6109|       |
 6110|       |        // Simulate zoom: font size changes but widths captured are still the old ones.
 6111|      1|        renderer.font_sizes.body = 16.0;
 6112|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
 6113|       |        {
 6114|      1|            let metrics = renderer.table_metrics.borrow();
 6115|      1|            let entry = metrics.entry(table_id).expect("entry exists");
 6116|       |            // Cleared and NOT re-saved in the same frame.
 6117|      1|            assert_eq!(entry.persisted_width(policy_hash), None);
 6118|      1|            assert_eq!(entry.persisted_font_size, Some(16.0));
 6119|       |        }
 6120|       |
 6121|       |        // Next frame with new layout widths should persist again.
 6122|      1|        let new_widths = vec![80.0f32];
 6123|      1|        renderer.persist_resizable_widths(table_id, &specs, &new_widths);
 6124|      1|        let metrics = renderer.table_metrics.borrow();
 6125|      1|        let entry = metrics.entry(table_id).expect("entry exists");
 6126|      1|        assert_eq!(entry.persisted_width(policy_hash), Some(80.0));
 6127|      1|        assert_eq!(entry.persisted_font_size, Some(16.0));
 6128|      1|    }
 6129|       |
 6130|       |    #[test]
 6131|      1|    fn highlight_phrase_keeps_persisted_table_widths() {
 6132|      1|        let renderer = MarkdownRenderer::new();
 6133|      1|        let table_id = 11u64;
 6134|      1|        let specs = vec![ColumnSpec::new(
 6135|       |            0,
 6136|       |            "A",
 6137|      1|            ColumnPolicy::Resizable {
 6138|      1|                min: 20.0,
 6139|      1|                preferred: 100.0,
 6140|      1|                clip: false,
 6141|      1|            },
 6142|      1|            None,
 6143|       |        )];
 6144|      1|        let widths = vec![120.0f32];
 6145|      1|        let policy_hash = specs[0].policy_hash;
 6146|       |
 6147|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
 6148|      1|        renderer.set_highlight_phrase(Some("alpha"));
 6149|      1|        renderer.set_highlight_phrase(Some("beta"));
 6150|       |
 6151|      1|        let metrics = renderer.table_metrics.borrow();
 6152|      1|        let entry = metrics.entry(table_id).expect("entry exists");
 6153|      1|        assert_eq!(entry.persisted_width(policy_hash), Some(120.0));
 6154|      1|    }
 6155|       |
 6156|       |    #[test]
 6157|      1|    fn test_tight_list_inline_code_and_styles() {
 6158|      1|        let renderer = MarkdownRenderer::new();
 6159|      1|        let md = "Intro\n\n- Use `code` and **bold** and *italic* and ~~strike~~\n";
 6160|      1|        let parsed = renderer.parse(md).expect("parse ok");
 6161|      1|        let (ordered, items) = parsed
 6162|      1|            .iter()
 6163|      2|            .find_map(|el| {
                           ^1
 6164|      2|                if let MarkdownElement::List { ordered, items } = el {
                                                             ^1       ^1
 6165|      1|                    Some((*ordered, items))
 6166|       |                } else {
 6167|      1|                    None
 6168|       |                }
 6169|      2|            })
 6170|      1|            .expect("list element");
 6171|      1|        assert!(!ordered);
 6172|      1|        assert_eq!(items.len(), 1);
 6173|      1|        let mut blocks = Vec::new();
 6174|      1|        blocks.push(MarkdownElement::HorizontalRule);
 6175|      1|        blocks.extend(items[0].blocks.clone());
 6176|      1|        let spans = blocks
 6177|      1|            .iter()
 6178|      2|            .find_map(|block| {
                           ^1
 6179|      2|                if let MarkdownElement::Paragraph(spans) = block {
                                                                ^1
 6180|      1|                    Some(spans)
 6181|       |                } else {
 6182|      1|                    None
 6183|       |                }
 6184|      2|            })
 6185|      1|            .expect("paragraph block");
 6186|      1|        let mut saw_code = false;
 6187|      1|        let mut saw_strong = false;
 6188|      1|        let mut saw_emphasis = false;
 6189|      1|        let mut saw_strike = false;
 6190|      1|        let mut saw_other = false;
 6191|      9|        for span in spans {
                          ^8
 6192|      8|            match span {
 6193|      1|                InlineSpan::Code(_) => saw_code = true,
 6194|      1|                InlineSpan::Strong(_) => saw_strong = true,
 6195|      1|                InlineSpan::Emphasis(_) => saw_emphasis = true,
 6196|      1|                InlineSpan::Strikethrough(_) => saw_strike = true,
 6197|      4|                _ => saw_other = true,
 6198|       |            }
 6199|       |        }
 6200|      1|        assert!(saw_code);
 6201|      1|        assert!(saw_strong);
 6202|      1|        assert!(saw_emphasis);
 6203|      1|        assert!(saw_strike);
 6204|      1|        assert!(saw_other);
 6205|      1|    }
 6206|       |
 6207|       |    #[test]
 6208|      1|    fn test_expand_shortcodes_basic() {
 6209|      1|        let rocket = MarkdownRenderer::expand_shortcodes(":rocket:");
 6210|      1|        assert_ne!(rocket, ":rocket:");
 6211|      1|        assert!(crate::emoji_catalog::image_bytes_for(&rocket).is_some());
 6212|       |
 6213|      1|        let tada = MarkdownRenderer::expand_shortcodes(":tada:");
 6214|      1|        assert_ne!(tada, ":tada:");
 6215|      1|        assert!(crate::emoji_catalog::image_bytes_for(&tada).is_some());
 6216|       |
 6217|      1|        assert_eq!(
 6218|      1|            MarkdownRenderer::expand_shortcodes("Hello :tada:!"),
 6219|      1|            format!("Hello {}!", tada)
 6220|       |        );
 6221|      1|    }
 6222|       |
 6223|       |    #[test]
 6224|      1|    fn test_expand_shortcodes_unknown_code_keeps_text() {
 6225|      1|        let input = "Unknown :notacode: stays the same.";
 6226|      1|        let out = MarkdownRenderer::expand_shortcodes(input);
 6227|      1|        assert_eq!(out, input);
 6228|      1|    }
 6229|       |
 6230|       |    #[test]
 6231|      1|    fn test_fix_unicode_chars_normalizes_basic_cases() {
 6232|      1|        let renderer = MarkdownRenderer::new();
 6233|      1|        let input = "A\u{00A0}B\u{2013}C";
 6234|      1|        let normalized = renderer.normalize_text_for_test(input);
 6235|      1|        assert_eq!(normalized, "A B-C");
 6236|       |
 6237|      1|        let arrows = renderer.normalize_text_for_test("   ");
 6238|      1|        assert_eq!(arrows, "<- -> ^ v");
 6239|       |
 6240|      1|        let untouched = renderer.normalize_text_for_test("Plain text");
 6241|      1|        assert_eq!(untouched, "Plain text");
 6242|      1|    }
 6243|       |
 6244|       |    #[test]
 6245|      1|    fn test_elements_to_plain_text_basic() {
 6246|      1|        let elements = vec![
 6247|      1|            MarkdownElement::Header {
 6248|      1|                level: 1,
 6249|      1|                spans: vec![InlineSpan::Text("Test Header".to_string())],
 6250|      1|                id: "test-header".to_string(),
 6251|      1|            },
 6252|      1|            MarkdownElement::Paragraph(vec![
 6253|      1|                InlineSpan::Text("This is a ".to_string()),
 6254|      1|                InlineSpan::Strong("bold".to_string()),
 6255|      1|                InlineSpan::Text(" paragraph.".to_string()),
 6256|      1|            ]),
 6257|       |        ];
 6258|       |
 6259|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6260|      1|        assert!(plain_text.contains("Test Header"));
 6261|      1|        assert!(plain_text.contains("This is a bold paragraph."));
 6262|      1|    }
 6263|       |
 6264|       |    #[test]
 6265|      1|    fn test_elements_to_plain_text_code_block() {
 6266|      1|        let elements = vec![MarkdownElement::CodeBlock {
 6267|      1|            language: Some("rust".to_string()),
 6268|      1|            text: "fn main() {\n    println!(\"Hello\");\n}".to_string(),
 6269|      1|        }];
 6270|       |
 6271|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6272|      1|        assert_eq!(plain_text, "fn main() {\n    println!(\"Hello\");\n}");
 6273|      1|    }
 6274|       |
 6275|       |    #[test]
 6276|      1|    fn test_elements_to_plain_text_with_links() {
 6277|      1|        let elements = vec![MarkdownElement::Paragraph(vec![
 6278|      1|            InlineSpan::Text("Visit ".to_string()),
 6279|      1|            InlineSpan::Link {
 6280|      1|                text: "GitHub".to_string(),
 6281|      1|                url: "https://github.com".to_string(),
 6282|      1|            },
 6283|      1|            InlineSpan::Text(" for more.".to_string()),
 6284|      1|        ])];
 6285|       |
 6286|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6287|      1|        assert_eq!(plain_text, "Visit GitHub for more.");
 6288|      1|    }
 6289|       |
 6290|       |    #[test]
 6291|      1|    fn test_elements_to_plain_text_horizontal_rule_after_text() {
 6292|      1|        let elements = vec![
 6293|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("Hello".to_string())]),
 6294|      1|            MarkdownElement::HorizontalRule,
 6295|       |        ];
 6296|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6297|      1|        assert_eq!(plain_text, "Hello\n---\n");
 6298|      1|    }
 6299|       |
 6300|       |    #[test]
 6301|      1|    fn test_elements_to_plain_text_mixed_blocks_adds_newlines() {
 6302|      1|        let elements = vec![
 6303|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("First".to_string())]),
 6304|      1|            MarkdownElement::List {
 6305|      1|                ordered: false,
 6306|      1|                items: vec![ListItem {
 6307|      1|                    blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6308|      1|                        "List".to_string(),
 6309|      1|                    )])],
 6310|      1|                }],
 6311|      1|            },
 6312|      1|            MarkdownElement::Quote {
 6313|      1|                depth: 1,
 6314|      1|                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6315|      1|                    "Quote".to_string(),
 6316|      1|                )])],
 6317|      1|            },
 6318|      1|            MarkdownElement::Table {
 6319|      1|                headers: vec![
 6320|      1|                    vec![InlineSpan::Text("H1".to_string())],
 6321|      1|                    vec![InlineSpan::Text("H2".to_string())],
 6322|      1|                ],
 6323|      1|                rows: vec![vec![vec![InlineSpan::Text("R1".to_string())]]],
 6324|      1|                alignments: vec![Alignment::Left, Alignment::Left],
 6325|      1|            },
 6326|      1|            MarkdownElement::HorizontalRule,
 6327|       |        ];
 6328|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6329|      1|        assert_eq!(plain_text, "First\nList\nQuote\nH1\nH2\nR1\n---\n");
 6330|      1|    }
 6331|       |
 6332|       |    #[test]
 6333|      1|    fn test_elements_to_plain_text_list_only_starts_without_newline() {
 6334|      1|        let elements = vec![MarkdownElement::List {
 6335|      1|            ordered: false,
 6336|      1|            items: vec![ListItem {
 6337|      1|                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6338|      1|                    "Item".to_string(),
 6339|      1|                )])],
 6340|      1|            }],
 6341|      1|        }];
 6342|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6343|      1|        assert_eq!(plain_text, "Item");
 6344|      1|    }
 6345|       |
 6346|       |    #[test]
 6347|      1|    fn test_elements_to_plain_text_quote_only_starts_without_newline() {
 6348|      1|        let elements = vec![MarkdownElement::Quote {
 6349|      1|            depth: 1,
 6350|      1|            blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6351|      1|                "Quote".to_string(),
 6352|      1|            )])],
 6353|      1|        }];
 6354|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6355|      1|        assert_eq!(plain_text, "Quote");
 6356|      1|    }
 6357|       |
 6358|       |    #[test]
 6359|      1|    fn test_elements_to_plain_text_table_headers_only_starts_without_newline() {
 6360|      1|        let elements = vec![MarkdownElement::Table {
 6361|      1|            headers: vec![vec![InlineSpan::Text("H".to_string())]],
 6362|      1|            rows: Vec::new(),
 6363|      1|            alignments: vec![Alignment::Left],
 6364|      1|        }];
 6365|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6366|      1|        assert_eq!(plain_text, "H");
 6367|      1|    }
 6368|       |
 6369|       |    #[test]
 6370|      1|    fn test_elements_to_plain_text_table_rows_only_starts_without_newline() {
 6371|      1|        let elements = vec![MarkdownElement::Table {
 6372|      1|            headers: Vec::new(),
 6373|      1|            rows: vec![vec![vec![InlineSpan::Text("R".to_string())]]],
 6374|      1|            alignments: vec![Alignment::Left],
 6375|      1|        }];
 6376|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6377|      1|        assert_eq!(plain_text, "R");
 6378|      1|    }
 6379|       |
 6380|       |    #[test]
 6381|      1|    fn test_spans_plain_text_image_title_without_alt() {
 6382|      1|        let spans = vec![
 6383|      1|            InlineSpan::Image {
 6384|      1|                src: "img.png".to_string(),
 6385|      1|                alt: "".to_string(),
 6386|      1|                title: Some("Title".to_string()),
 6387|      1|            },
 6388|      1|            InlineSpan::Image {
 6389|      1|                src: "img.png".to_string(),
 6390|      1|                alt: "Alt".to_string(),
 6391|      1|                title: Some("Caption".to_string()),
 6392|      1|            },
 6393|      1|            InlineSpan::Image {
 6394|      1|                src: "img.png".to_string(),
 6395|      1|                alt: "".to_string(),
 6396|      1|                title: Some("".to_string()),
 6397|      1|            },
 6398|       |        ];
 6399|      1|        let plain_text = MarkdownRenderer::spans_plain_text(&spans);
 6400|      1|        assert_eq!(plain_text, "TitleAlt Caption");
 6401|      1|    }
 6402|       |
 6403|       |    #[test]
 6404|      1|    fn test_image_source_stale_detects_file_changes() {
 6405|       |        use std::time::Duration as StdDuration;
 6406|       |
 6407|      1|        let dir = tempfile::tempdir().expect("temp dir");
 6408|      1|        let file_path = dir.path().join("image.bin");
 6409|      1|        std::fs::write(&file_path, [1u8, 2, 3, 4]).expect("write image");
 6410|      1|        let initial = MarkdownRenderer::disk_image_timestamp(&file_path);
 6411|      1|        assert!(!MarkdownRenderer::image_source_stale(initial, &file_path));
 6412|       |
 6413|      1|        std::thread::sleep(StdDuration::from_millis(5));
 6414|      1|        std::fs::write(&file_path, [4u8, 3, 2, 1]).expect("rewrite image");
 6415|       |
 6416|      1|        assert!(MarkdownRenderer::image_source_stale(initial, &file_path));
 6417|       |
 6418|      1|        std::fs::remove_file(&file_path).expect("remove image");
 6419|      1|        assert!(MarkdownRenderer::image_source_stale(initial, &file_path));
 6420|      1|    }
 6421|       |
 6422|       |    #[test]
 6423|      1|    fn test_image_source_stale_with_timestamp_combinations() {
 6424|      1|        let stamp = SystemTime::UNIX_EPOCH;
 6425|      1|        assert!(MarkdownRenderer::image_source_stale_with_timestamp(
 6426|      1|            Some(stamp),
 6427|      1|            None
 6428|       |        ));
 6429|      1|        assert!(MarkdownRenderer::image_source_stale_with_timestamp(
 6430|      1|            None,
 6431|      1|            Some(stamp)
 6432|       |        ));
 6433|      1|        assert!(!MarkdownRenderer::image_source_stale_with_timestamp(
 6434|      1|            None, None
 6435|      1|        ));
 6436|      1|    }
 6437|       |
 6438|       |    #[test]
 6439|      1|    fn test_inline_code_preserves_whitespace() {
 6440|      1|        let renderer = MarkdownRenderer::new();
 6441|      1|        let md = "Start `code` end";
 6442|      1|        let parsed = renderer.parse(md).expect("parse ok");
 6443|      1|        let non_paragraph = MarkdownElement::HorizontalRule;
 6444|      1|        let mut saw_paragraph = false;
 6445|      2|        for element in [&parsed[0], &non_paragraph] {
                                      ^1          ^1
 6446|      2|            match element {
 6447|      1|                MarkdownElement::Paragraph(spans) => {
 6448|      2|                    let code_span = spans.iter().find_map(|span| match span {
                                      ^1          ^1           ^1
 6449|      1|                        InlineSpan::Code(t) => Some(t),
 6450|      1|                        _ => None,
 6451|      2|                    });
 6452|      1|                    assert_eq!(code_span, Some(&"code".to_string()));
 6453|      1|                    saw_paragraph = true;
 6454|       |                }
 6455|      1|                _ => {}
 6456|       |            }
 6457|       |        }
 6458|      1|        assert!(saw_paragraph);
 6459|      1|    }
 6460|       |
 6461|       |    #[test]
 6462|      1|    fn test_footnote_markers_render_as_visible_text() {
 6463|      1|        let renderer = MarkdownRenderer::new();
 6464|      1|        let md = "Paragraph with footnote[^1].\n\n[^1]: footnote body.";
 6465|      1|        let parsed = renderer.parse(md).expect("parse ok");
 6466|      1|        assert_eq!(parsed.len(), 2);
 6467|      1|        let first_plain = MarkdownRenderer::element_plain_text(&parsed[0]);
 6468|      1|        assert!(first_plain.contains("footnote[^1]"));
 6469|      1|        let second_plain = MarkdownRenderer::element_plain_text(&parsed[1]);
 6470|      1|        assert!(second_plain.contains("[^1]: footnote body."));
 6471|      1|    }
 6472|       |
 6473|       |    #[test]
 6474|      1|    fn test_parse_headers_assign_ids_and_dedupe() {
 6475|      1|        let renderer = MarkdownRenderer::new();
 6476|      1|        let md = "# Getting Started\n\nParagraph text.\n\n## Getting Started\n\n### API & Usage\n\n## API & Usage\n";
 6477|      1|        let parsed = renderer.parse(md).expect("parse ok");
 6478|       |
 6479|      1|        let mut ids = vec![];
 6480|      6|        for el in parsed {
                          ^5
 6481|      5|            if let MarkdownElement::Header { id, .. } = el {
                                                           ^4
 6482|      4|                ids.push(id);
 6483|      4|            }
                          ^1
 6484|       |        }
 6485|      1|        assert_eq!(ids.len(), 4);
 6486|      1|        assert_eq!(ids[0], "getting-started");
 6487|      1|        assert_eq!(ids[1], "getting-started-1");
 6488|      1|        assert_eq!(ids[2], "api-usage");
 6489|      1|        assert_eq!(ids[3], "api-usage-1");
 6490|      1|    }
 6491|       |
 6492|       |    #[test]
 6493|      1|    fn test_formatting_sample_contains_expected_header_ids() {
 6494|      1|        let renderer = MarkdownRenderer::new();
 6495|      1|        let formatting = SAMPLE_FILES
 6496|      1|            .iter()
 6497|      2|            .find(|f| f.name == "formatting.md")
                           ^1
 6498|      1|            .expect("formatting sample present");
 6499|      1|        let parsed = renderer.parse(formatting.content).expect("parse ok");
 6500|      1|        let ids: Vec<String> = parsed
 6501|      1|            .into_iter()
 6502|     37|            .filter_map(|el| match el {
                           ^1
 6503|     18|                MarkdownElement::Header { id, .. } => Some(id),
 6504|     19|                _ => None,
 6505|     37|            })
 6506|      1|            .collect();
 6507|       |
 6508|     10|        for expected in [
 6509|       |            "markdown-formatting-guide",
 6510|      1|            "table-of-contents",
 6511|      1|            "text-formatting",
 6512|      1|            "headers",
 6513|      1|            "lists",
 6514|      1|            "links-and-images",
 6515|      1|            "emojis",
 6516|      1|            "blockquotes",
 6517|      1|            "horizontal-rules",
 6518|      1|            "tables",
 6519|       |        ] {
 6520|    101|            assert!(ids.iter().any(|id| id == expected));
                          ^10     ^10        ^10
 6521|       |        }
 6522|      1|    }
 6523|       |
 6524|       |    #[test]
 6525|      1|    fn test_inline_image_parsing() {
 6526|      1|        let renderer = MarkdownRenderer::new();
 6527|      1|        let md = "Here is an image: ![Alt text](images/pic.webp \"Title\") end.";
 6528|      1|        let parsed = renderer.parse(md).expect("parse ok");
 6529|      1|        assert_eq!(parsed.len(), 1);
 6530|      1|        assert!(matches!(&parsed[0], MarkdownElement::Paragraph(_)));
                              ^0
 6531|      1|        let non_paragraph = MarkdownElement::HorizontalRule;
 6532|      1|        let mut saw_paragraph = false;
 6533|      2|        for element in [&parsed[0], &non_paragraph] {
                                      ^1          ^1
 6534|      2|            match element {
 6535|      1|                MarkdownElement::Paragraph(spans) => {
 6536|      2|                    let img = spans.iter().find(|s| matches!(s, InlineSpan::Image { .. }));
                                      ^1    ^1           ^1
 6537|      1|                    assert!(img.is_some());
 6538|      1|                    let (src, alt, title) = image_span_fields(img.unwrap()).expect("image span");
 6539|      1|                    assert_eq!(src, "images/pic.webp");
 6540|      1|                    assert_eq!(alt, "Alt text");
 6541|      1|                    assert_eq!(title, Some("Title"));
 6542|      1|                    saw_paragraph = true;
 6543|       |                }
 6544|      1|                _ => {}
 6545|       |            }
 6546|       |        }
 6547|      1|        assert!(saw_paragraph);
 6548|      1|        assert!(image_span_fields(&InlineSpan::Text("nope".into())).is_none());
 6549|      1|    }
 6550|       |
 6551|       |    #[test]
 6552|      1|    fn test_image_text_in_plain_text_index() {
 6553|      1|        let renderer = MarkdownRenderer::new();
 6554|      1|        let md = "![Diagram](./a.png \"Flow\")";
 6555|      1|        let parsed = renderer.parse(md).expect("parse ok");
 6556|      1|        let text = MarkdownRenderer::element_plain_text(&parsed[0]);
 6557|      1|        assert!(text.contains("Diagram"));
 6558|      1|        assert!(text.contains("Flow"));
 6559|      1|    }
 6560|       |
 6561|       |    #[test]
 6562|      1|    fn test_element_plain_text_header_and_code_block() {
 6563|      1|        let header = MarkdownElement::Header {
 6564|      1|            level: 2,
 6565|      1|            spans: vec![InlineSpan::Text("Title".to_string())],
 6566|      1|            id: "title".to_string(),
 6567|      1|        };
 6568|      1|        let code = MarkdownElement::CodeBlock {
 6569|      1|            text: "fn main() {}".to_string(),
 6570|      1|            language: Some("rust".to_string()),
 6571|      1|        };
 6572|      1|        assert_eq!(
 6573|      1|            MarkdownRenderer::element_plain_text(&header),
 6574|      1|            "Title".to_string()
 6575|       |        );
 6576|      1|        assert_eq!(
 6577|      1|            MarkdownRenderer::element_plain_text(&code),
 6578|      1|            "fn main() {}".to_string()
 6579|       |        );
 6580|      1|    }
 6581|       |
 6582|       |    #[test]
 6583|      1|    fn test_cell_fragments_split_text_and_images() {
 6584|      1|        let renderer = MarkdownRenderer::new();
 6585|      1|        let spans = vec![
 6586|      1|            InlineSpan::Text("alpha".into()),
 6587|      1|            InlineSpan::Strong("beta".into()),
 6588|      1|            InlineSpan::Image {
 6589|      1|                src: "img.png".into(),
 6590|      1|                alt: "img".into(),
 6591|      1|                title: None,
 6592|      1|            },
 6593|      1|            InlineSpan::Text("gamma".into()),
 6594|       |        ];
 6595|      1|        let fragments = renderer.cell_fragments(&spans);
 6596|      1|        assert_eq!(fragments.len(), 3);
 6597|      1|        assert!(matches!(fragments[0], CellFragment::Text(_)));
                              ^0
 6598|      1|        let mut saw_first_text = false;
 6599|      2|        for fragment in [&fragments[0], &fragments[1]] {
                                       ^1             ^1
 6600|      2|            match fragment {
 6601|      1|                CellFragment::Text(slice) => {
 6602|      1|                    assert_eq!(slice.len(), 2);
 6603|      1|                    saw_first_text = true;
 6604|       |                }
 6605|      1|                _ => {}
 6606|       |            }
 6607|       |        }
 6608|      1|        assert!(saw_first_text);
 6609|      1|        assert!(matches!(fragments[1], CellFragment::Image(_)));
                              ^0
 6610|      1|        let mut saw_image = false;
 6611|      2|        for fragment in [&fragments[1], &fragments[0]] {
                                       ^1             ^1
 6612|      2|            match fragment {
 6613|      1|                CellFragment::Image(span) => {
 6614|      1|                    let (src, _alt, _title) = image_span_fields(span).expect("image span");
 6615|      1|                    assert_eq!(src, "img.png");
 6616|      1|                    saw_image = true;
 6617|       |                }
 6618|      1|                _ => {}
 6619|       |            }
 6620|       |        }
 6621|      1|        assert!(saw_image);
 6622|      1|        assert!(matches!(fragments[2], CellFragment::Text(_)));
                              ^0
 6623|      1|        let mut saw_last_text = false;
 6624|      2|        for fragment in [&fragments[2], &fragments[1]] {
                                       ^1             ^1
 6625|      2|            match fragment {
 6626|      1|                CellFragment::Text(slice) => {
 6627|      1|                    assert_eq!(slice.len(), 1);
 6628|      1|                    let content = text_span_content(&slice[0]).expect("text span");
 6629|      1|                    assert_eq!(content, "gamma");
 6630|      1|                    saw_last_text = true;
 6631|       |                }
 6632|      1|                _ => {}
 6633|       |            }
 6634|       |        }
 6635|      1|        assert!(saw_last_text);
 6636|      1|        assert!(text_span_content(&InlineSpan::Image {
 6637|      1|            src: "img.png".into(),
 6638|      1|            alt: "img".into(),
 6639|      1|            title: None,
 6640|      1|        })
 6641|      1|        .is_none());
 6642|      1|    }
 6643|       |
 6644|       |    #[test]
 6645|      1|    fn test_cell_fragments_leading_image() {
 6646|      1|        let renderer = MarkdownRenderer::new();
 6647|      1|        let spans = vec![
 6648|      1|            InlineSpan::Image {
 6649|      1|                src: "cover.png".into(),
 6650|      1|                alt: "cover".into(),
 6651|      1|                title: None,
 6652|      1|            },
 6653|      1|            InlineSpan::Text("tail".into()),
 6654|       |        ];
 6655|      1|        let fragments = renderer.cell_fragments(&spans);
 6656|      1|        assert_eq!(fragments.len(), 2);
 6657|      1|        assert!(matches!(fragments[0], CellFragment::Image(_)));
                              ^0
 6658|      1|        assert!(matches!(fragments[1], CellFragment::Text(_)));
                              ^0
 6659|      1|    }
 6660|       |
 6661|       |    #[test]
 6662|      1|    fn test_cell_fragments_detect_single_emoji_cell() {
 6663|      1|        let renderer = MarkdownRenderer::new();
 6664|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 6665|      1|            .get(":rocket:")
 6666|      1|            .expect("rocket shortcode");
 6667|      1|        let spans = vec![InlineSpan::Strong((*rocket).to_string())];
 6668|      1|        let fragments = renderer.cell_fragments(&spans);
 6669|      1|        assert_eq!(fragments.len(), 1);
 6670|      1|        let key = emoji_fragment_key(&fragments[0]).expect("emoji fragment");
 6671|      1|        assert!(!key.is_empty());
 6672|      1|        let text_spans = vec![InlineSpan::Text("plain".into())];
 6673|      1|        let fragment = CellFragment::Text(&text_spans);
 6674|      1|        assert!(emoji_fragment_key(&fragment).is_none());
 6675|      1|    }
 6676|       |
 6677|       |    #[test]
 6678|      1|    fn test_cell_single_emoji_emphasis() {
 6679|      1|        let renderer = MarkdownRenderer::new();
 6680|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 6681|      1|            .get(":rocket:")
 6682|      1|            .expect("rocket shortcode");
 6683|      1|        let spans = vec![InlineSpan::Emphasis((*rocket).to_string())];
 6684|      1|        assert!(renderer.cell_single_emoji(&spans).is_some());
 6685|      1|    }
 6686|       |
 6687|       |    #[test]
 6688|      1|    fn test_cell_single_emoji_returns_none_for_code_and_link() {
 6689|      1|        let renderer = MarkdownRenderer::new();
 6690|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 6691|      1|            .get(":rocket:")
 6692|      1|            .expect("rocket shortcode");
 6693|      1|        let code_spans = vec![InlineSpan::Code((*rocket).to_string())];
 6694|      1|        assert!(renderer.cell_single_emoji(&code_spans).is_none());
 6695|       |
 6696|      1|        let link_spans = vec![InlineSpan::Link {
 6697|      1|            text: (*rocket).to_string(),
 6698|      1|            url: "https://example.com".to_string(),
 6699|      1|        }];
 6700|      1|        assert!(renderer.cell_single_emoji(&link_spans).is_none());
 6701|      1|    }
 6702|       |
 6703|       |    #[test]
 6704|      1|    fn test_get_or_make_emoji_texture_falls_back_on_decode_error() {
 6705|      1|        let renderer = MarkdownRenderer::new();
 6706|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 6707|      1|            .get(":rocket:")
 6708|      1|            .expect("rocket shortcode");
 6709|      1|        force_emoji_decode_error_once();
 6710|      1|        with_test_ui(|_, ui| {
 6711|      1|            let _ = renderer.get_or_make_emoji_texture(ui, rocket);
 6712|      1|        });
 6713|      1|    }
 6714|       |
 6715|       |    #[test]
 6716|      1|    fn test_get_or_make_emoji_texture_generates_on_decode_error() {
 6717|      1|        let renderer = MarkdownRenderer::new();
 6718|      1|        let fallback = [
 6719|      1|            "\u{2705}",
 6720|      1|            "\u{1f389}",
 6721|      1|            "\u{1f680}",
 6722|      1|            "\u{2764}",
 6723|      1|            "\u{1f496}",
 6724|      1|            "\u{2b50}",
 6725|      1|            "\u{1f525}",
 6726|      1|        ];
 6727|      1|        let emoji = crate::emoji_catalog::shortcode_map()
 6728|      1|            .values()
 6729|      3|            .find(|emoji| {
                           ^1
 6730|      3|                !fallback.contains(emoji) && emoji_catalog::image_bytes_for(emoji).is_some()
                                                           ^1                                    ^1
 6731|      3|            })
 6732|      1|            .expect("emoji outside fallback");
 6733|      1|        assert!(emoji_assets::make_image(emoji, 64).is_none());
 6734|      1|        force_emoji_decode_error_once();
 6735|      1|        with_test_ui(|_, ui| {
 6736|      1|            let _ = renderer.get_or_make_emoji_texture(ui, emoji);
 6737|      1|        });
 6738|      1|    }
 6739|       |
 6740|       |    #[test]
 6741|      1|    fn test_cell_fragments_inline_emoji_stays_text() {
 6742|      1|        let renderer = MarkdownRenderer::new();
 6743|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 6744|      1|            .get(":rocket:")
 6745|      1|            .expect("rocket shortcode");
 6746|      1|        let spans = vec![
 6747|      1|            InlineSpan::Text((*rocket).to_string()),
 6748|      1|            InlineSpan::Text("tail".into()),
 6749|       |        ];
 6750|      1|        let fragments = renderer.cell_fragments(&spans);
 6751|      1|        assert_eq!(fragments.len(), 1);
 6752|      1|        assert!(matches!(fragments[0], CellFragment::Text(_)));
                              ^0
 6753|      1|        let dummy_span = InlineSpan::Image {
 6754|      1|            src: "dummy.png".into(),
 6755|      1|            alt: "dummy".into(),
 6756|      1|            title: None,
 6757|      1|        };
 6758|      1|        let dummy_fragment = CellFragment::Image(&dummy_span);
 6759|      1|        let mut saw_text = false;
 6760|      2|        for fragment in [&fragments[0], &dummy_fragment] {
                                       ^1             ^1
 6761|      2|            match fragment {
 6762|      1|                CellFragment::Text(slice) => {
 6763|      1|                    assert_eq!(slice.len(), 2);
 6764|      1|                    saw_text = true;
 6765|       |                }
 6766|      1|                _ => {}
 6767|       |            }
 6768|       |        }
 6769|      1|        assert!(saw_text);
 6770|      1|    }
 6771|       |
 6772|       |    #[test]
 6773|      1|    fn test_cell_fragments_keep_link_emoji_interactive() {
 6774|      1|        let renderer = MarkdownRenderer::new();
 6775|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 6776|      1|            .get(":rocket:")
 6777|      1|            .expect("rocket shortcode");
 6778|      1|        let spans = vec![InlineSpan::Link {
 6779|      1|            text: (*rocket).to_string(),
 6780|      1|            url: "https://example.com".to_string(),
 6781|      1|        }];
 6782|      1|        let fragments = renderer.cell_fragments(&spans);
 6783|      1|        assert_eq!(fragments.len(), 1);
 6784|      1|        assert!(matches!(fragments[0], CellFragment::Text(_)));
                              ^0
 6785|      1|        let dummy_span = InlineSpan::Image {
 6786|      1|            src: "dummy.png".into(),
 6787|      1|            alt: "dummy".into(),
 6788|      1|            title: None,
 6789|      1|        };
 6790|      1|        let dummy_fragment = CellFragment::Image(&dummy_span);
 6791|      1|        let mut saw_link = false;
 6792|      2|        for fragment in [&fragments[0], &dummy_fragment] {
                                       ^1             ^1
 6793|      2|            match fragment {
 6794|      1|                CellFragment::Text(slice) => {
 6795|      1|                    assert!(matches!(slice[0], InlineSpan::Link { .. }));
                                          ^0
 6796|      1|                    saw_link = true;
 6797|       |                }
 6798|      1|                _ => {}
 6799|       |            }
 6800|       |        }
 6801|      1|        assert!(saw_link);
 6802|      1|    }
 6803|       |
 6804|       |    #[test]
 6805|      1|    fn test_render_overhauled_cell_handles_emoji_fragment() {
 6806|      1|        let renderer = MarkdownRenderer::new();
 6807|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 6808|      1|            .get(":rocket:")
 6809|      1|            .expect("rocket shortcode");
 6810|      1|        let spans = vec![InlineSpan::Text((*rocket).to_string())];
 6811|      1|        let ctx = egui::Context::default();
 6812|      1|        let input = egui::RawInput {
 6813|      1|            screen_rect: Some(egui::Rect::from_min_size(
 6814|      1|                egui::pos2(0.0, 0.0),
 6815|      1|                egui::vec2(240.0, 120.0),
 6816|      1|            )),
 6817|      1|            ..Default::default()
 6818|      1|        };
 6819|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 6820|       |            let _ =
 6821|      1|                renderer.render_overhauled_cell(ui, &spans, 120.0, false, Some(0), 0, Align::LEFT);
 6822|      1|        });
 6823|      1|    }
 6824|       |
 6825|       |    #[test]
 6826|      1|    fn test_layout_job_builder_respects_wrap_width() {
 6827|      1|        let renderer = MarkdownRenderer::new();
 6828|      1|        let spans = vec![InlineSpan::Text(
 6829|      1|            "A long column entry that should wrap neatly within the supplied width.".into(),
 6830|      1|        )];
 6831|      1|        let style = egui::Style::default();
 6832|      1|        let build = renderer.build_layout_job(&style, &spans, 180.0, false, Align::LEFT);
 6833|      1|        assert_eq!(build.job.wrap.max_width, 180.0);
 6834|      1|        assert!(build.job.text.contains("column entry"));
 6835|      1|    }
 6836|       |
 6837|       |    #[test]
 6838|      1|    fn test_layout_job_builder_highlights_matches() {
 6839|      1|        let renderer = MarkdownRenderer::new();
 6840|      1|        renderer.set_highlight_phrase(Some("wrap"));
 6841|      1|        let spans = vec![InlineSpan::Text("wrap me, wrap me again".into())];
 6842|      1|        let style = egui::Style::default();
 6843|      1|        let build = renderer.build_layout_job(&style, &spans, 200.0, false, Align::LEFT);
 6844|      1|        let highlight_bg = style.visuals.selection.bg_fill;
 6845|      1|        assert!(build
 6846|      1|            .job
 6847|      1|            .sections
 6848|      1|            .iter()
 6849|      1|            .any(|s| s.format.background == highlight_bg));
 6850|      1|    }
 6851|       |
 6852|       |    #[test]
 6853|      1|    fn test_layout_job_builder_tracks_link_ranges() {
 6854|      1|        let renderer = MarkdownRenderer::new();
 6855|      1|        let spans = vec![InlineSpan::Link {
 6856|      1|            text: "Docs".into(),
 6857|      1|            url: "https://example.org/docs".into(),
 6858|      1|        }];
 6859|      1|        let style = egui::Style::default();
 6860|      1|        let build = renderer.build_layout_job(&style, &spans, 220.0, false, Align::LEFT);
 6861|      1|        assert_eq!(build.link_ranges.len(), 1);
 6862|      1|        let link = &build.link_ranges[0];
 6863|      1|        assert_eq!(link.url, "https://example.org/docs");
 6864|      1|        let char_len = link.char_range.end - link.char_range.start;
 6865|      1|        let linked_text: String = build
 6866|      1|            .job
 6867|      1|            .text
 6868|      1|            .chars()
 6869|      1|            .skip(link.char_range.start)
 6870|      1|            .take(char_len)
 6871|      1|            .collect();
 6872|      1|        assert_eq!(linked_text, "Docs");
 6873|      1|    }
 6874|       |
 6875|       |    #[test]
 6876|      1|    fn test_layout_job_builder_skips_empty_link_text() {
 6877|      1|        let renderer = MarkdownRenderer::new();
 6878|      1|        let spans = vec![InlineSpan::Link {
 6879|      1|            text: String::new(),
 6880|      1|            url: "https://example.org/docs".into(),
 6881|      1|        }];
 6882|      1|        let style = egui::Style::default();
 6883|      1|        let build = renderer.build_layout_job(&style, &spans, 220.0, false, Align::LEFT);
 6884|      1|        assert!(build.link_ranges.is_empty());
 6885|      1|    }
 6886|       |
 6887|       |    #[test]
 6888|      1|    fn test_build_layout_job_skips_images() {
 6889|      1|        let renderer = MarkdownRenderer::new();
 6890|      1|        let style = egui::Style::default();
 6891|      1|        let spans = vec![InlineSpan::Image {
 6892|      1|            src: "dummy.png".to_string(),
 6893|      1|            alt: "alt".to_string(),
 6894|      1|            title: None,
 6895|      1|        }];
 6896|       |
 6897|      1|        let build = renderer.build_layout_job(&style, &spans, 120.0, false, Align::LEFT);
 6898|      1|        assert!(build.plain_text.is_empty());
 6899|      1|    }
 6900|       |
 6901|       |    #[test]
 6902|      1|    fn test_append_spans_empty_and_code_light() {
 6903|      1|        let renderer = MarkdownRenderer::new();
 6904|      1|        let style = egui::Style::default();
 6905|      1|        let mut job = LayoutJob::default();
 6906|      1|        let mut plain_text = String::new();
 6907|       |
 6908|      1|        assert_eq!(
 6909|      1|            renderer.append_plain_span(
 6910|      1|                &style,
 6911|      1|                &mut job,
 6912|      1|                &mut plain_text,
 6913|      1|                "",
 6914|      1|                InlineStyle::default(),
 6915|      1|                None
 6916|       |            ),
 6917|       |            0
 6918|       |        );
 6919|      1|        assert_eq!(
 6920|      1|            renderer.append_code_span(&style, &mut job, &mut plain_text, ""),
 6921|       |            0
 6922|       |        );
 6923|       |
 6924|      1|        let mut light_style = style.clone();
 6925|      1|        light_style.visuals.dark_mode = false;
 6926|      1|        assert!(renderer.append_code_span(&light_style, &mut job, &mut plain_text, "code") > 0);
 6927|       |
 6928|      1|        let mut empty_job = LayoutJob::default();
 6929|      1|        let mut empty_plain = String::new();
 6930|      1|        assert_eq!(
 6931|      1|            renderer.append_text_sections(
 6932|      1|                &style,
 6933|      1|                &mut empty_job,
 6934|      1|                &mut empty_plain,
 6935|      1|                "",
 6936|       |                12.0,
 6937|      1|                InlineStyle::default(),
 6938|      1|                None
 6939|       |            ),
 6940|       |            0
 6941|       |        );
 6942|      1|    }
 6943|       |
 6944|       |    #[test]
 6945|      1|    fn test_is_html_line_break_and_indented_code_tabs() {
 6946|      1|        assert!(!MarkdownRenderer::is_html_line_break("<b"));
 6947|      1|        assert!(MarkdownRenderer::is_html_line_break("<br >"));
 6948|      1|        assert!(!MarkdownRenderer::is_html_line_break("<brx>"));
 6949|      1|        assert!(MarkdownRenderer::is_indented_code_line("\tcode"));
 6950|      1|    }
 6951|       |
 6952|       |    #[test]
 6953|      1|    fn test_is_html_line_break_rejects_missing_bracket() {
 6954|      1|        assert!(!MarkdownRenderer::is_html_line_break("<br"));
 6955|      1|        assert!(!MarkdownRenderer::is_html_line_break("<br/"));
 6956|      1|    }
 6957|       |
 6958|       |    #[test]
 6959|      1|    fn test_is_html_line_break_slash_variants() {
 6960|      1|        assert!(MarkdownRenderer::is_html_line_break("<br/>"));
 6961|      1|        assert!(!MarkdownRenderer::is_html_line_break("<br/ x>"));
 6962|      1|    }
 6963|       |
 6964|       |    #[test]
 6965|      1|    fn test_escape_pipes_inline_code_multi_backticks() {
 6966|      1|        let out = MarkdownRenderer::escape_pipes_in_inline_code_line("``code|``");
 6967|      1|        assert!(out.contains(PIPE_SENTINEL));
 6968|      1|    }
 6969|       |
 6970|       |    #[test]
 6971|      1|    fn test_escape_pipes_inline_code_line_branches() {
 6972|      1|        let plain = "no pipes here";
 6973|      1|        assert_eq!(
 6974|      1|            MarkdownRenderer::escape_pipes_in_inline_code_line(plain),
 6975|       |            plain
 6976|       |        );
 6977|       |
 6978|      1|        let line = "``code`|more``";
 6979|      1|        let escaped = MarkdownRenderer::escape_pipes_in_inline_code_line(line);
 6980|      1|        assert!(escaped.contains(PIPE_SENTINEL));
 6981|      1|    }
 6982|       |
 6983|       |    #[test]
 6984|      1|    fn test_escape_table_pipes_list_indent_with_tabs_and_table() {
 6985|      1|        let input = "- Parent\n\t- Child\n  | Head | Tail |\n  | --- | --- |\n  | a | b |\n";
 6986|      1|        let output = MarkdownRenderer::escape_table_pipes_in_inline_code(input);
 6987|      1|        assert!(output.contains("| Head | Tail |"));
 6988|      1|    }
 6989|       |
 6990|       |    #[test]
 6991|      1|    fn test_escape_pipes_inline_code_line_restores_pending_on_unclosed() {
 6992|      1|        let line = "`code|tail";
 6993|      1|        let escaped = MarkdownRenderer::escape_pipes_in_inline_code_line(line);
 6994|      1|        assert_eq!(escaped, line);
 6995|      1|    }
 6996|       |
 6997|       |    #[test]
 6998|      1|    fn test_table_width_solver_keeps_short_columns_readable() {
 6999|      1|        let mins = vec![90.0, 90.0, 90.0, 90.0];
 7000|      1|        let desired = vec![120.0, 120.0, 360.0, 160.0];
 7001|      1|        let widths = MarkdownRenderer::resolve_table_widths(420.0, &mins, &desired);
 7002|      1|        assert_eq!(widths.len(), 4);
 7003|       |        // Narrow columns should stay near their minimums even when a wide column exists
 7004|      1|        assert!(widths[0] >= 85.0);
 7005|      1|        assert!(widths[2] > widths[0]);
 7006|      1|        let sum: f32 = widths.iter().sum();
 7007|      1|        assert!((sum - 420.0).abs() < 0.5);
 7008|      1|    }
 7009|       |
 7010|       |    #[test]
 7011|      1|    fn test_table_width_solver_handles_constrained_space() {
 7012|      1|        let mins = vec![100.0, 100.0, 100.0, 100.0];
 7013|      1|        let desired = vec![200.0, 240.0, 360.0, 160.0];
 7014|      1|        let widths = MarkdownRenderer::resolve_table_widths(260.0, &mins, &desired);
 7015|      1|        assert_eq!(widths.len(), 4);
 7016|      4|        assert!(widths.iter().all(|w| *w > 0.0));
                      ^1      ^1            ^1
 7017|      1|        let sum: f32 = widths.iter().sum();
 7018|      1|        assert!((sum - 260.0).abs() < 0.5);
 7019|      1|    }
 7020|       |
 7021|       |    #[test]
 7022|      1|    fn test_row_needs_height_estimate_for_emphasis_and_strike() {
 7023|      1|        let renderer = MarkdownRenderer::new();
 7024|      1|        let row = vec![vec![
 7025|      1|            InlineSpan::Emphasis("alpha".to_string()),
 7026|      1|            InlineSpan::Strikethrough("gamma\ndelta".to_string()),
 7027|       |        ]];
 7028|      1|        assert!(renderer.row_needs_height_estimate(&row));
 7029|      1|    }
 7030|       |
 7031|       |    #[test]
 7032|      1|    fn test_row_needs_height_estimate_code_and_link_without_newlines() {
 7033|      1|        let renderer = MarkdownRenderer::new();
 7034|      1|        let row = vec![vec![
 7035|      1|            InlineSpan::Code("code".to_string()),
 7036|      1|            InlineSpan::Link {
 7037|      1|                text: "link".to_string(),
 7038|      1|                url: "https://example.com".to_string(),
 7039|      1|            },
 7040|       |        ]];
 7041|      1|        assert!(!renderer.row_needs_height_estimate(&row));
 7042|      1|    }
 7043|       |
 7044|       |    #[test]
 7045|      1|    fn test_resolve_table_rects_clip_rect_fallbacks() {
 7046|      1|        let renderer = MarkdownRenderer::new();
 7047|      1|        let widths = vec![12.0];
 7048|      1|        let body_clip = egui::Rect::from_min_max(egui::pos2(1.0, 2.0), egui::pos2(3.0, 4.0));
 7049|      1|        let (rect, clip) =
 7050|      1|            renderer.resolve_table_rects(None, None, None, None, Some(body_clip), &widths, 4.0);
 7051|      1|        assert_eq!(clip, body_clip);
 7052|       |
 7053|      1|        let (rect2, clip2) =
 7054|      1|            renderer.resolve_table_rects(None, None, None, None, None, &widths, 4.0);
 7055|      1|        assert_eq!(clip2, rect2);
 7056|      1|        assert_eq!(rect2.min, egui::pos2(0.0, 0.0));
 7057|      1|        assert_eq!(rect2.max, egui::pos2(0.0, 0.0));
 7058|      1|        assert_eq!(rect.min, egui::pos2(0.0, 0.0));
 7059|      1|    }
 7060|       |
 7061|       |    #[test]
 7062|      1|    fn test_resolve_table_rects_prefers_layout_then_header_then_body() {
 7063|      1|        let renderer = MarkdownRenderer::new();
 7064|      1|        let widths = vec![10.0, 20.0];
 7065|      1|        let layout = egui::Rect::from_min_max(egui::pos2(5.0, 6.0), egui::pos2(25.0, 26.0));
 7066|      1|        let header = egui::Rect::from_min_max(egui::pos2(1.0, 2.0), egui::pos2(9.0, 12.0));
 7067|      1|        let body = egui::Rect::from_min_max(egui::pos2(2.0, 3.0), egui::pos2(14.0, 18.0));
 7068|       |
 7069|      1|        let (rect, _) = renderer.resolve_table_rects(
 7070|      1|            Some(header),
 7071|      1|            Some(body),
 7072|      1|            Some(layout),
 7073|      1|            None,
 7074|      1|            None,
 7075|      1|            &widths,
 7076|      1|            4.0,
 7077|      1|        );
 7078|      1|        assert_eq!(rect.min.x, layout.min.x);
 7079|       |
 7080|      1|        let (rect, _) =
 7081|      1|            renderer.resolve_table_rects(Some(header), None, None, None, None, &widths, 4.0);
 7082|      1|        assert_eq!(rect.min.x, header.min.x);
 7083|       |
 7084|      1|        let (rect, _) =
 7085|      1|            renderer.resolve_table_rects(None, Some(body), None, None, None, &widths, 4.0);
 7086|      1|        assert_eq!(rect.min.x, body.min.x);
 7087|      1|    }
 7088|       |
 7089|       |    #[test]
 7090|      1|    fn test_resolve_table_rects_layout_only_fallbacks() {
 7091|      1|        let renderer = MarkdownRenderer::new();
 7092|      1|        let widths = vec![12.0];
 7093|      1|        let layout = egui::Rect::from_min_max(egui::pos2(4.0, 7.0), egui::pos2(18.0, 21.0));
 7094|      1|        let (rect, _) = renderer.resolve_table_rects(
 7095|      1|            None,
 7096|      1|            None,
 7097|      1|            Some(layout),
 7098|      1|            None,
 7099|      1|            None,
 7100|      1|            &widths,
 7101|      1|            4.0,
 7102|      1|        );
 7103|      1|        assert_eq!(rect.min.y, layout.min.y);
 7104|      1|        assert_eq!(rect.max.y, layout.max.y);
 7105|      1|    }
 7106|       |
 7107|       |    #[test]
 7108|      1|    fn table_cells_keep_images_and_formatting() {
 7109|      1|        let renderer = MarkdownRenderer::new();
 7110|      1|        let md = "\
 7111|      1|Intro
 7112|      1|
 7113|      1|| H1 | H2 |
 7114|      1|| --- | --- |
 7115|      1|| text **extra** ![Alt](img.png) | **bold** and [link](https://example.com) |";
 7116|      1|        let elements = renderer.parse(md).expect("parse ok");
 7117|      1|        let table = elements
 7118|      1|            .iter()
 7119|      2|            .find_map(|el| match el {
                           ^1
 7120|       |                MarkdownElement::Table {
 7121|       |                    headers: _,
 7122|      1|                    rows,
 7123|       |                    alignments: _,
 7124|      1|                } => Some(rows),
 7125|      1|                _ => None,
 7126|      2|            })
 7127|      1|            .expect("table present");
 7128|      1|        assert_eq!(table.len(), 1);
 7129|      1|        let row = &table[0];
 7130|      1|        let mut saw_image = false;
 7131|      1|        let mut saw_text = false;
 7132|      4|        for span in &row[0] {
                                   ^1
 7133|      4|            match span {
 7134|      1|                InlineSpan::Image { .. } => saw_image = true,
 7135|      2|                InlineSpan::Text(_) => saw_text = true,
 7136|      1|                _ => {}
 7137|       |            }
 7138|       |        }
 7139|      1|        assert!(saw_image);
 7140|      1|        assert!(saw_text);
 7141|      1|        let mut saw_strong = false;
 7142|      1|        let mut saw_link = false;
 7143|      1|        let mut saw_other = false;
 7144|      3|        for span in &row[1] {
                                   ^1
 7145|      3|            match span {
 7146|      1|                InlineSpan::Strong(_) => saw_strong = true,
 7147|      1|                InlineSpan::Link { .. } => saw_link = true,
 7148|      1|                _ => saw_other = true,
 7149|       |            }
 7150|       |        }
 7151|      1|        assert!(saw_strong);
 7152|      1|        assert!(saw_link);
 7153|      1|        assert!(saw_other);
 7154|      1|    }
 7155|       |
 7156|       |    #[test]
 7157|      1|    fn table_inline_code_keeps_pipes() {
 7158|      1|        let renderer = MarkdownRenderer::new();
 7159|      1|        let md = "\
 7160|      1|Intro
 7161|      1|
 7162|      1|| Col | Notes |
 7163|      1|| --- | --- |
 7164|      1|| code | see `a|b|c` |";
 7165|      1|        let elements = renderer.parse(md).expect("parse ok");
 7166|      1|        let rows = elements
 7167|      1|            .iter()
 7168|      2|            .find_map(|el| match el {
                           ^1
 7169|       |                MarkdownElement::Table {
 7170|       |                    headers: _,
 7171|      1|                    rows,
 7172|       |                    alignments: _,
 7173|      1|                } => Some(rows),
 7174|      1|                _ => None,
 7175|      2|            })
 7176|      1|            .expect("table present");
 7177|      1|        let code_text = rows[0][1]
 7178|      1|            .iter()
 7179|      2|            .find_map(|span| match span {
                           ^1
 7180|      1|                InlineSpan::Code(text) => Some(text.as_str()),
 7181|      1|                _ => None,
 7182|      2|            })
 7183|      1|            .expect("code span");
 7184|      1|        assert_eq!(code_text, "a|b|c");
 7185|      1|    }
 7186|       |
 7187|       |    #[test]
 7188|      1|    fn indented_code_block_table_like_preserves_pipes() {
 7189|      1|        let md = "\
 7190|      1|    | Col | Notes |
 7191|      1|    | --- | --- |
 7192|      1|    | code | `a|b|c` |";
 7193|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7194|      1|        assert!(prepared.contains("`a|b|c`"));
 7195|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7196|      1|    }
 7197|       |
 7198|       |    #[test]
 7199|      1|    fn blockquote_table_inline_code_escapes_pipes() {
 7200|      1|        let md = "\
 7201|      1|> | Col | Notes |
 7202|      1|> | --- | --- |
 7203|      1|> | code | `a|b|c` |";
 7204|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7205|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7206|      1|        assert!(prepared.contains(&expected));
 7207|      1|    }
 7208|       |
 7209|       |    #[test]
 7210|      1|    fn blockquote_tab_table_inline_code_escapes_pipes() {
 7211|      1|        let md = ">\t| Col | Notes |\n>\t| --- | --- |\n>\t| code | `a|b|c` |";
 7212|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7213|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7214|      1|        assert!(prepared.contains(&expected));
 7215|      1|    }
 7216|       |
 7217|       |    #[test]
 7218|      1|    fn blockquote_table_after_paragraph_parses() -> Result<()> {
 7219|      1|        let renderer = MarkdownRenderer::new();
 7220|      1|        let md = "\
 7221|      1|Prelude
 7222|      1|
 7223|      1|> Intro line
 7224|      1|> | Col | Notes |
 7225|      1|> | --- | --- |
 7226|      1|> | A | B |";
 7227|      1|        let elements = renderer.parse(md)?;
                                                       ^0
 7228|      1|        let blocks = elements
 7229|      1|            .iter()
 7230|      2|            .find_map(|el| match el {
                           ^1
 7231|      1|                MarkdownElement::Quote { blocks, .. } => Some(blocks),
 7232|      1|                _ => None,
 7233|      2|            })
 7234|      1|            .expect("quote block");
 7235|      1|        assert!(blocks
 7236|      1|            .iter()
 7237|      2|            .any(|block| matches!(block, MarkdownElement::Table { .. })));
                           ^1
 7238|      1|        Ok(())
 7239|      1|    }
 7240|       |
 7241|       |    #[test]
 7242|      1|    fn blockquote_list_table_after_paragraph_parses() -> Result<()> {
 7243|      1|        let renderer = MarkdownRenderer::new();
 7244|      1|        let md = "\
 7245|      1|Prelude
 7246|      1|
 7247|      1|> Note before list
 7248|      1|> - Item:
 7249|      1|>   | Key | Val |
 7250|      1|>   | --- | --- |
 7251|      1|>   | A | 1 |";
 7252|      1|        let elements = renderer.parse(md)?;
                                                       ^0
 7253|      1|        let blocks = elements
 7254|      1|            .iter()
 7255|      2|            .find_map(|el| match el {
                           ^1
 7256|      1|                MarkdownElement::Quote { blocks, .. } => Some(blocks),
 7257|      1|                _ => None,
 7258|      2|            })
 7259|      1|            .expect("quote block");
 7260|      1|        let list = blocks
 7261|      1|            .iter()
 7262|      2|            .find_map(|block| match block {
                           ^1
 7263|      1|                MarkdownElement::List { items, .. } => Some(items),
 7264|      1|                _ => None,
 7265|      2|            })
 7266|      1|            .expect("list block");
 7267|      1|        let first = list.first().expect("list item");
 7268|      1|        assert!(first
 7269|      1|            .blocks
 7270|      1|            .iter()
 7271|      2|            .any(|block| matches!(block, MarkdownElement::Table { .. })));
                           ^1
 7272|      1|        Ok(())
 7273|      1|    }
 7274|       |
 7275|       |    #[test]
 7276|      1|    fn blockquote_indented_code_block_preserves_pipes() {
 7277|      1|        let md = "\
 7278|      1|>     | Col | Notes |
 7279|      1|>     | --- | --- |
 7280|      1|>     | code | `a|b|c` |";
 7281|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7282|      1|        assert!(prepared.contains("`a|b|c`"));
 7283|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7284|      1|    }
 7285|       |
 7286|       |    #[test]
 7287|      1|    fn blockquote_fenced_code_block_preserves_pipes() {
 7288|      1|        let md = "\
 7289|      1|> ```
 7290|      1|> | Col | Notes |
 7291|      1|> | --- | --- |
 7292|      1|> | code | `a|b|c` |
 7293|      1|> ```";
 7294|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7295|      1|        assert!(prepared.contains("`a|b|c`"));
 7296|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7297|      1|    }
 7298|       |
 7299|       |    #[test]
 7300|      1|    fn list_fenced_code_block_preserves_pipes() {
 7301|      1|        let md = "\
 7302|      1|- ```
 7303|      1|  | Col | Notes |
 7304|      1|  | --- | --- |
 7305|      1|  | code | `a|b|c` |
 7306|      1|  ```";
 7307|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7308|      1|        assert!(prepared.contains("`a|b|c`"));
 7309|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7310|      1|    }
 7311|       |
 7312|       |    #[test]
 7313|      1|    fn list_blockquote_fenced_code_block_preserves_pipes() {
 7314|      1|        let md = "\
 7315|      1|- Item
 7316|      1|    > ```
 7317|      1|    > | Col | Notes |
 7318|      1|    > | --- | --- |
 7319|      1|    > | code | `a|b|c` |
 7320|      1|    > ```";
 7321|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7322|      1|        assert!(prepared.contains("`a|b|c`"));
 7323|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7324|      1|    }
 7325|       |
 7326|       |    #[test]
 7327|      1|    fn nested_list_fenced_code_block_preserves_pipes() {
 7328|      1|        let md = "\
 7329|      1|- Outer
 7330|      1|    - ```
 7331|      1|      | Col | Notes |
 7332|      1|      | --- | --- |
 7333|      1|      | code | `a|b|c` |
 7334|      1|      ```";
 7335|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7336|      1|        assert!(prepared.contains("`a|b|c`"));
 7337|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7338|      1|    }
 7339|       |
 7340|       |    #[test]
 7341|      1|    fn list_item_code_block_preserves_pipes() {
 7342|      1|        let md = "\
 7343|      1|- Item
 7344|      1|      | Col | Notes |
 7345|      1|      | --- | --- |
 7346|      1|      | code | `a|b|c` |";
 7347|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7348|      1|        assert!(prepared.contains("`a|b|c`"));
 7349|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7350|      1|    }
 7351|       |
 7352|       |    #[test]
 7353|      1|    fn nested_list_table_inline_code_escapes_pipes() {
 7354|      1|        let md = "\
 7355|      1|- Outer
 7356|      1|  - | Col | Notes |
 7357|      1|    | --- | --- |
 7358|      1|    | code | `a|b|c` |";
 7359|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7360|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7361|      1|        assert!(prepared.contains(&expected));
 7362|      1|    }
 7363|       |
 7364|       |    #[test]
 7365|      1|    fn nested_list_tab_table_inline_code_escapes_pipes() {
 7366|      1|        let md = "- Outer\n\t- | Col | Notes |\n\t  | --- | --- |\n\t  | code | `a|b|c` |";
 7367|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7368|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7369|      1|        assert!(prepared.contains(&expected));
 7370|      1|    }
 7371|       |
 7372|       |    #[test]
 7373|      1|    fn nested_list_four_space_table_inline_code_escapes_pipes() {
 7374|      1|        let md = "\
 7375|      1|- Outer
 7376|      1|    - | Col | Notes |
 7377|      1|      | --- | --- |
 7378|      1|      | code | `a|b|c` |";
 7379|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7380|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7381|      1|        assert!(prepared.contains(&expected));
 7382|      1|    }
 7383|       |
 7384|       |    #[test]
 7385|      1|    fn list_marker_four_space_table_inline_code_escapes_pipes() {
 7386|      1|        let md = "\
 7387|      1|-    | Col | Notes |
 7388|      1|     | --- | --- |
 7389|      1|     | code | `a|b|c` |";
 7390|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7391|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7392|      1|        assert!(prepared.contains(&expected));
 7393|      1|    }
 7394|       |
 7395|       |    #[test]
 7396|      1|    fn nested_list_indented_code_block_preserves_pipes() {
 7397|      1|        let md = "\
 7398|      1|- Outer
 7399|      1|      - | Col | Notes |
 7400|      1|        | --- | --- |
 7401|      1|        | code | `a|b|c` |";
 7402|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7403|      1|        assert!(prepared.contains("`a|b|c`"));
 7404|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7405|      1|    }
 7406|       |
 7407|       |    #[test]
 7408|      1|    fn deeply_nested_list_table_inline_code_escapes_pipes() {
 7409|      1|        let md = "\
 7410|      1|- Outer
 7411|      1|    - Inner
 7412|      1|        - | Col | Notes |
 7413|      1|          | --- | --- |
 7414|      1|          | code | `a|b|c` |";
 7415|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7416|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7417|      1|        assert!(prepared.contains(&expected));
 7418|      1|    }
 7419|       |
 7420|       |    #[test]
 7421|      1|    fn list_blockquote_table_inline_code_escapes_pipes() {
 7422|      1|        let md = "\
 7423|      1|- Item
 7424|      1|    > | Col | Notes |
 7425|      1|    > | --- | --- |
 7426|      1|    > | code | `a|b|c` |";
 7427|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7428|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7429|      1|        assert!(prepared.contains(&expected));
 7430|      1|    }
 7431|       |
 7432|       |    #[test]
 7433|      1|    fn list_marker_blockquote_table_inline_code_escapes_pipes() {
 7434|      1|        let md = "\
 7435|      1|- > | Col | Notes |
 7436|      1|  > | --- | --- |
 7437|      1|  > | code | `a|b|c` |";
 7438|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7439|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7440|      1|        assert!(prepared.contains(&expected));
 7441|      1|    }
 7442|       |
 7443|       |    #[test]
 7444|      1|    fn list_marker_table_dedent_does_not_escape_pipes() {
 7445|      1|        let md = "\
 7446|      1|- | Col | `a|b|c` |
 7447|      1|| --- | --- |
 7448|      1|| row | ok |";
 7449|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7450|      1|        assert!(prepared.contains("`a|b|c`"));
 7451|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7452|      1|    }
 7453|       |
 7454|       |    #[test]
 7455|      1|    fn blockquote_list_table_inline_code_escapes_pipes() {
 7456|      1|        let md = "\
 7457|      1|> - | Col | Notes |
 7458|      1|>   | --- | --- |
 7459|      1|>   | code | `a|b|c` |";
 7460|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7461|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7462|      1|        assert!(prepared.contains(&expected));
 7463|      1|    }
 7464|       |
 7465|       |    #[test]
 7466|      1|    fn list_marker_line_table_inline_code_escapes_pipes() {
 7467|      1|        let md = "\
 7468|      1|10. 
 7469|      1|    | Col | Notes |
 7470|      1|    | --- | --- |
 7471|      1|    | code | `a|b|c` |";
 7472|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7473|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7474|      1|        assert!(prepared.contains(&expected));
 7475|      1|    }
 7476|       |
 7477|       |    #[test]
 7478|      1|    fn list_marker_tab_after_marker_uses_tab_stops() {
 7479|      1|        let line = "-\titem";
 7480|      1|        let (_content, indent, content_indent) =
 7481|      1|            MarkdownRenderer::list_marker_info(line).expect("list marker");
 7482|      1|        assert_eq!(indent, 3);
 7483|      1|        assert_eq!(content_indent, 4);
 7484|      1|    }
 7485|       |
 7486|       |    #[test]
 7487|      1|    fn list_marker_any_indent_tab_stops_leading_whitespace() {
 7488|      1|        let line = " \t- item";
 7489|      1|        let (_content, _indent, _content_indent, leading) =
 7490|      1|            MarkdownRenderer::list_marker_info_any_indent(line).expect("list marker");
 7491|      1|        assert_eq!(leading, 4);
 7492|      1|    }
 7493|       |
 7494|       |    #[test]
 7495|      1|    fn table_ends_before_inline_code_paragraph() {
 7496|      1|        let md = "\
 7497|      1|| Col | Notes |
 7498|      1|| --- | --- |
 7499|      1|| code | `a|b|c` |
 7500|      1|Paragraph with `x|y` inline.";
 7501|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7502|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7503|      1|        assert!(prepared.contains(&expected));
 7504|      1|        assert!(prepared.contains("`x|y`"));
 7505|      1|    }
 7506|       |
 7507|       |    #[test]
 7508|      1|    fn table_ends_before_escaped_pipe_paragraph() {
 7509|      1|        let md = "\
 7510|      1|| Col | Notes |
 7511|      1|| --- | --- |
 7512|      1|| code | `a|b|c` |
 7513|      1|Paragraph with escaped \\| pipe.";
 7514|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7515|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7516|      1|        assert!(prepared.contains(&expected));
 7517|      1|        assert!(prepared.contains("escaped \\| pipe"));
 7518|      1|    }
 7519|       |
 7520|       |    #[test]
 7521|      1|    fn list_table_ends_on_dedent_with_pipe_paragraph() {
 7522|      1|        let md = "\
 7523|      1|- | Col | Notes |
 7524|      1|  | --- | --- |
 7525|      1|  | code | `a|b|c` |
 7526|      1|Paragraph with `x|y` and pipe | outside.";
 7527|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7528|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7529|      1|        assert!(prepared.contains(&expected));
 7530|      1|        assert!(prepared.contains("`x|y`"));
 7531|      1|    }
 7532|       |
 7533|       |    #[test]
 7534|      1|    fn nested_list_table_ends_on_dedent_with_pipe_paragraph() {
 7535|      1|        let md = "\
 7536|      1|- Outer
 7537|      1|  - | Col | Notes |
 7538|      1|    | --- | --- |
 7539|      1|    | code | `a|b|c` |
 7540|      1|  Paragraph with `x|y` and pipe | outside.";
 7541|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7542|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7543|      1|        assert!(prepared.contains(&expected));
 7544|      1|        assert!(prepared.contains("`x|y`"));
 7545|      1|    }
 7546|       |
 7547|       |    #[test]
 7548|      1|    fn list_table_tab_dedent_keeps_inline_code_unescaped() {
 7549|      1|        let md =
 7550|      1|            "- Outer\n\t- | Col | Notes |\n\t  | --- | --- |\n\t  | code | `a|b|c` |\nParagraph with `x|y` and pipe | outside.";
 7551|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7552|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7553|      1|        assert!(prepared.contains(&expected));
 7554|      1|        assert!(prepared.contains("`x|y`"));
 7555|      1|    }
 7556|       |
 7557|       |    #[test]
 7558|      1|    fn list_blank_line_table_inline_code_escapes_pipes() {
 7559|      1|        let md = "\
 7560|      1|- Item
 7561|      1|
 7562|      1|    | Col | Notes |
 7563|      1|    | --- | --- |
 7564|      1|    | code | `a|b|c` |";
 7565|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7566|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7567|      1|        assert!(prepared.contains(&expected));
 7568|      1|    }
 7569|       |
 7570|       |    #[test]
 7571|      1|    fn table_delimiter_requires_pipe() {
 7572|      1|        let md = "\
 7573|      1|`a|b` | Header
 7574|      1|---
 7575|      1|Not a table";
 7576|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7577|      1|        assert!(prepared.contains("`a|b`"));
 7578|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7579|      1|    }
 7580|       |
 7581|       |    #[test]
 7582|      1|    fn table_unmatched_backticks_do_not_escape_pipes() {
 7583|      1|        let md = "\
 7584|      1|| Col | Notes |
 7585|      1|| --- | --- |
 7586|      1|| code | `a|b |";
 7587|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7588|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7589|      1|    }
 7590|       |
 7591|       |    #[test]
 7592|      1|    fn table_escaped_backticks_do_not_escape_pipes() {
 7593|      1|        let md = "\
 7594|      1|| Col | Notes |
 7595|      1|| --- | --- |
 7596|      1|| text | \\`a|b\\` |";
 7597|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7598|      1|        assert!(prepared.contains("\\`a|b\\`"));
 7599|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7600|      1|    }
 7601|       |
 7602|       |    #[test]
 7603|      1|    fn list_parent_indent_nested_marker_table_escapes_pipes() {
 7604|      1|        let md = "\
 7605|      1|- Parent
 7606|      1|    - | Col | Notes |
 7607|      1|      | --- | --- |
 7608|      1|      | code | `a|b|c` |";
 7609|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7610|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7611|      1|        assert!(prepared.contains(&expected));
 7612|      1|    }
 7613|       |
 7614|       |    #[test]
 7615|      1|    fn list_parent_indent_table_without_marker_escapes_pipes() {
 7616|      1|        let md = "\
 7617|      1|- Parent
 7618|      1|  | Col | Notes |
 7619|      1|  | --- | --- |
 7620|      1|  | code | `a|b|c` |";
 7621|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7622|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7623|      1|        assert!(prepared.contains(&expected));
 7624|      1|    }
 7625|       |
 7626|       |    #[test]
 7627|      1|    fn table_blockquote_level_mismatch_ends_table() {
 7628|      1|        let md = "\
 7629|      1|| Col | Notes |
 7630|      1|| --- | --- |
 7631|      1|> | code | `a|b|c` |";
 7632|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7633|      1|        assert!(prepared.contains("`a|b|c`"));
 7634|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7635|      1|    }
 7636|       |
 7637|       |    #[test]
 7638|      1|    fn table_inserts_blank_line_before_header_with_crlf() {
 7639|      1|        let md = "Intro line\r\n| Col | Notes |\r\n| --- | --- |\r\n| code | `a|b|c` |\r\n";
 7640|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7641|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7642|      1|        assert!(prepared.contains("\r\n\r\n| Col | Notes |"));
 7643|      1|        assert!(prepared.contains(&expected));
 7644|      1|    }
 7645|       |
 7646|       |    #[test]
 7647|      1|    fn fenced_block_quote_level_mismatch_keeps_block_open() {
 7648|      1|        let md = "\
 7649|      1|> ```
 7650|      1|> | Col | Notes |
 7651|      1|```
 7652|      1|> | --- | --- |
 7653|      1|> | code | `a|b|c` |
 7654|      1|> ```";
 7655|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7656|      1|        assert!(prepared.contains("`a|b|c`"));
 7657|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7658|      1|    }
 7659|       |
 7660|       |    #[test]
 7661|      1|    fn table_ids_are_unique_per_position() {
 7662|      1|        let renderer = MarkdownRenderer::new();
 7663|      1|        let md = "\
 7664|      1|Intro
 7665|      1|
 7666|      1|| H |
 7667|      1|| - |
 7668|      1|| a |
 7669|      1|
 7670|      1|| H |
 7671|      1|| - |
 7672|      1|| a |";
 7673|      1|        let elements = renderer.parse(md).expect("parse ok");
 7674|      1|        let tables: Vec<_> = elements
 7675|      1|            .iter()
 7676|      1|            .enumerate()
 7677|      3|            .filter_map(|(idx, el)| match el {
                           ^1
 7678|       |                MarkdownElement::Table {
 7679|      2|                    headers,
 7680|      2|                    rows,
 7681|      2|                    alignments,
 7682|      2|                } => Some(renderer.compute_table_id(headers, rows, alignments, idx as u64)),
 7683|      1|                _ => None,
 7684|      3|            })
 7685|      1|            .collect();
 7686|      1|        assert_eq!(tables.len(), 2);
 7687|      1|        assert_ne!(tables[0], tables[1]);
 7688|      1|    }
 7689|       |
 7690|       |    #[test]
 7691|      1|    fn test_render_to_ui_rich_document_populates_rects_and_table_stats() {
 7692|      1|        let renderer = MarkdownRenderer::new();
 7693|      1|        let md = "\
 7694|      1|# Coverage Demo
 7695|      1|
 7696|      1|Paragraph with :tada: emoji and **bold** text and a [link](#target).
 7697|      1|
 7698|      1|> Quote line one
 7699|      1|> Quote line two
 7700|      1|
 7701|      1|- item one
 7702|      1|- item two
 7703|      1|
 7704|      1|---
 7705|      1|
 7706|      1|```rust
 7707|      1|fn main() {}
 7708|      1|```
 7709|      1|
 7710|      1|| Col A | Col B |
 7711|      1|| --- | --- |
 7712|      1|| A1 | B1 |
 7713|      1|| A2 | B2 |
 7714|      1|
 7715|      1|![Logo](assets/samples/logo.svg \"Logo\")
 7716|      1|![Sample](assets/samples/webp_sample.webp \"Sample\")
 7717|      1|![Missing](missing_test_image.png \"Missing\")
 7718|      1|![Remote](https://example.com/image.png \"Remote\")
 7719|      1|";
 7720|       |
 7721|      1|        let elements = renderer.parse(md).expect("parse ok");
 7722|      1|        renderer.set_highlight_phrase(Some("item"));
 7723|       |
 7724|      1|        with_test_ui(|_, ui| {
 7725|      1|            renderer.render_to_ui(ui, &elements);
 7726|      1|        });
 7727|       |
 7728|      1|        assert!(renderer.element_rect_at(0).is_some());
 7729|      1|        assert!(renderer.header_rect_for("coverage-demo").is_some());
 7730|      1|        let (rendered, total) = renderer.table_render_stats();
 7731|      1|        assert!(total > 0);
 7732|      1|        assert!(rendered > 0);
 7733|      1|        let (_hits, misses) = renderer.table_layout_cache_stats();
 7734|      1|        assert!(misses > 0);
 7735|      1|    }
 7736|       |
 7737|       |    #[test]
 7738|      1|    fn test_table_layout_cache_records_hits() {
 7739|      1|        let renderer = MarkdownRenderer::new();
 7740|      1|        let spans = vec![InlineSpan::Text("alpha".to_string())];
 7741|      1|        let style = egui::Style::default();
 7742|       |
 7743|      1|        let _ = renderer.cached_layout_job(&style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
 7744|      1|        let _ = renderer.cached_layout_job(&style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
 7745|       |
 7746|      1|        let (hits, misses) = renderer.table_layout_cache_stats();
 7747|      1|        assert!(hits >= 1);
 7748|      1|        assert!(misses >= 1);
 7749|       |
 7750|      1|        renderer.clear_table_layout_cache();
 7751|      1|        assert_eq!(renderer.table_layout_cache_stats(), (0, 0));
 7752|      1|    }
 7753|       |
 7754|       |    #[test]
 7755|      1|    fn test_cell_layout_cache_eviction() {
 7756|      1|        let mut cache = CellLayoutCache::new(2);
 7757|      1|        let build = LayoutJobBuild {
 7758|      1|            job: LayoutJob::default(),
 7759|      1|            plain_text: String::new(),
 7760|      1|            link_ranges: Vec::new(),
 7761|      1|        };
 7762|      1|        let key = |row, col| CellLayoutKey {
 7763|      3|            row: Some(row),
 7764|      3|            col,
 7765|       |            width: 120,
 7766|       |            align: 0,
 7767|       |            strong: false,
 7768|      3|            text_color: [0, 0, 0, 255],
 7769|       |            highlight_hash: 0,
 7770|      3|            content_hash: row as u64,
 7771|      3|        };
 7772|       |
 7773|      1|        let key_a = key(0, 0);
 7774|      1|        let key_b = key(1, 0);
 7775|      1|        let key_c = key(2, 0);
 7776|       |
 7777|      1|        cache.insert(key_a.clone(), build.clone());
 7778|      1|        cache.insert(key_b.clone(), build.clone());
 7779|      1|        cache.insert(key_c.clone(), build);
 7780|       |
 7781|      1|        assert!(cache.get(&key_a).is_none());
 7782|      1|        assert!(cache.get(&key_b).is_some());
 7783|      1|        assert!(cache.get(&key_c).is_some());
 7784|      1|    }
 7785|       |
 7786|       |    #[test]
 7787|      1|    fn test_cell_layout_cache_handles_empty_order() {
 7788|      1|        let mut cache = CellLayoutCache::new(1);
 7789|      1|        let build = LayoutJobBuild {
 7790|      1|            job: LayoutJob::default(),
 7791|      1|            plain_text: String::new(),
 7792|      1|            link_ranges: Vec::new(),
 7793|      1|        };
 7794|      1|        let key_a = CellLayoutKey {
 7795|      1|            row: Some(0),
 7796|      1|            col: 0,
 7797|      1|            width: 120,
 7798|      1|            align: 0,
 7799|      1|            strong: false,
 7800|      1|            text_color: [0, 0, 0, 255],
 7801|      1|            highlight_hash: 0,
 7802|      1|            content_hash: 1,
 7803|      1|        };
 7804|      1|        let key_b = CellLayoutKey {
 7805|      1|            row: Some(1),
 7806|      1|            col: 0,
 7807|      1|            width: 120,
 7808|      1|            align: 0,
 7809|      1|            strong: false,
 7810|      1|            text_color: [0, 0, 0, 255],
 7811|      1|            highlight_hash: 0,
 7812|      1|            content_hash: 2,
 7813|      1|        };
 7814|       |
 7815|      1|        cache.insert(key_a, build.clone());
 7816|      1|        cache.order.clear();
 7817|      1|        cache.insert(key_b.clone(), build);
 7818|       |
 7819|      1|        assert!(cache.get(&key_b).is_some());
 7820|      1|    }
 7821|       |
 7822|       |    #[test]
 7823|      1|    fn test_cell_layout_cache_reinsert_existing_key() {
 7824|      1|        let mut cache = CellLayoutCache::new(1);
 7825|      1|        let build = LayoutJobBuild {
 7826|      1|            job: LayoutJob::default(),
 7827|      1|            plain_text: String::new(),
 7828|      1|            link_ranges: Vec::new(),
 7829|      1|        };
 7830|      1|        let key = CellLayoutKey {
 7831|      1|            row: Some(0),
 7832|      1|            col: 0,
 7833|      1|            width: 120,
 7834|      1|            align: 0,
 7835|      1|            strong: false,
 7836|      1|            text_color: [0, 0, 0, 255],
 7837|      1|            highlight_hash: 0,
 7838|      1|            content_hash: 42,
 7839|      1|        };
 7840|      1|        cache.insert(key.clone(), build.clone());
 7841|      1|        cache.insert(key.clone(), build);
 7842|      1|        assert_eq!(cache.entries.len(), 1);
 7843|      1|        assert_eq!(cache.order.len(), 1);
 7844|      1|    }
 7845|       |
 7846|       |    #[test]
 7847|      1|    fn test_table_layout_cache_separates_text_colors() {
 7848|      1|        let renderer = MarkdownRenderer::new();
 7849|      1|        let spans = vec![InlineSpan::Text("alpha".to_string())];
 7850|      1|        let mut light_style = egui::Style::default();
 7851|      1|        let mut dark_style = egui::Style::default();
 7852|      1|        light_style.visuals.override_text_color = Some(Color32::WHITE);
 7853|      1|        dark_style.visuals.override_text_color = Some(Color32::BLACK);
 7854|       |
 7855|       |        let _ =
 7856|      1|            renderer.cached_layout_job(&light_style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
 7857|       |        let _ =
 7858|      1|            renderer.cached_layout_job(&dark_style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
 7859|       |
 7860|      1|        let (hits, misses) = renderer.table_layout_cache_stats();
 7861|      1|        assert_eq!(hits, 0);
 7862|      1|        assert_eq!(misses, 2);
 7863|      1|    }
 7864|       |
 7865|       |    #[test]
 7866|      1|    fn test_table_alignment_center_single_column() -> Result<()> {
 7867|      1|        let renderer = MarkdownRenderer::new();
 7868|      1|        let md = "Intro\n\n| Item |\n| :---: |\n| Alpha |\n";
 7869|      1|        let elements = renderer.parse(md)?;
                                                       ^0
 7870|      1|        let alignments = elements
 7871|      1|            .iter()
 7872|      2|            .find_map(|el| match el {
                           ^1
 7873|      1|                MarkdownElement::Table { alignments, .. } => Some(alignments),
 7874|      1|                _ => None,
 7875|      2|            })
 7876|      1|            .expect("table element");
 7877|      1|        assert_eq!(alignments.len(), 1);
 7878|      1|        assert_eq!(alignments[0], Alignment::Center);
 7879|      1|        Ok(())
 7880|      1|    }
 7881|       |
 7882|       |    #[test]
 7883|      1|    fn test_single_column_table_parses_one_cell_per_row() -> Result<()> {
 7884|      1|        let renderer = MarkdownRenderer::new();
 7885|      1|        let md =
 7886|      1|            "Intro\n\n| Item |\n| :---: |\n| Alpha |\n| line one<br>line two |\n| **bold** and `code` |\n";
 7887|      1|        let elements = renderer.parse(md)?;
                                                       ^0
 7888|      1|        let (headers, rows) = elements
 7889|      1|            .iter()
 7890|      2|            .find_map(|el| match el {
                           ^1
 7891|      1|                MarkdownElement::Table { headers, rows, .. } => Some((headers, rows)),
 7892|      1|                _ => None,
 7893|      2|            })
 7894|      1|            .expect("table element");
 7895|      1|        assert_eq!(headers.len(), 1);
 7896|      3|        assert!(rows.iter().all(|row| row.len() == 1));
                      ^1      ^1          ^1
 7897|      1|        Ok(())
 7898|      1|    }
 7899|       |
 7900|       |    #[test]
 7901|      1|    fn test_table_first_column_alignment_parses_three_columns() -> Result<()> {
 7902|      1|        let renderer = MarkdownRenderer::new();
 7903|      1|        let md = fs::read_to_string("tests/regression/cases/026-table-first-column-align.md")?;
                                                                                                           ^0
 7904|      1|        let elements = renderer.parse(&md)?;
                                                        ^0
 7905|      1|        let tables: Vec<_> = elements
 7906|      1|            .iter()
 7907|      7|            .filter_map(|el| match el {
                           ^1
 7908|       |                MarkdownElement::Table {
 7909|      3|                    headers,
 7910|      3|                    rows,
 7911|      3|                    alignments,
 7912|      3|                } => Some((headers, rows, alignments)),
 7913|      4|                _ => None,
 7914|      7|            })
 7915|      1|            .collect();
 7916|      1|        assert!(tables.len() >= 3);
 7917|      1|        let (first_headers, first_rows, first_alignments) = tables[0];
 7918|      3|        for (headers, rows, alignments) in tables.iter() {
                                                         ^1     ^1
 7919|      3|            assert_eq!(headers.len(), 3);
 7920|      3|            assert_eq!(alignments.len(), 3);
 7921|      8|            assert!(rows.iter().all(|row| row.len() == 3));
                          ^3      ^3          ^3
 7922|       |        }
 7923|      1|        let table_id = renderer.compute_table_id(first_headers, first_rows, first_alignments, 0);
 7924|      1|        let available = Cell::new(0.0f32);
 7925|      1|        let spacing = Cell::new(0.0f32);
 7926|      1|        let _estimated_before = {
 7927|      1|            let column_stats = renderer.column_stats_for_table(
 7928|      1|                table_id,
 7929|      1|                first_headers,
 7930|      1|                first_rows,
 7931|      1|                first_alignments,
 7932|       |            );
 7933|      1|            let ctx = TableColumnContext::new(
 7934|      1|                first_headers,
 7935|      1|                first_rows,
 7936|      1|                &column_stats,
 7937|      1|                renderer.font_sizes.body,
 7938|      1|                table_id,
 7939|       |            );
 7940|      1|            let column_specs = derive_column_specs(&ctx);
 7941|      1|            let column_spacing = 6.0f32.max(egui::Style::default().spacing.item_spacing.x);
 7942|      1|            renderer.estimate_table_total_width(table_id, &column_specs, column_spacing)
 7943|       |        };
 7944|      1|        with_test_ui(|_, ui| {
 7945|      1|            available.set(ui.available_width());
 7946|      1|            spacing.set(ui.spacing().item_spacing.x.max(6.0));
 7947|      1|            renderer.render_table_tablebuilder(
 7948|      1|                ui,
 7949|      1|                first_headers,
 7950|      1|                first_rows,
 7951|      1|                first_alignments,
 7952|      1|                table_id,
 7953|       |            );
 7954|      1|        });
 7955|      1|        let widths = renderer
 7956|      1|            .table_metrics
 7957|      1|            .borrow()
 7958|      1|            .entry(table_id)
 7959|      1|            .map(|entry| entry.current_widths().to_vec())
 7960|      1|            .unwrap_or_default();
 7961|      1|        assert_eq!(widths.len(), 3);
 7962|      3|        assert!(widths.iter().all(|w| *w > 8.0));
                      ^1      ^1            ^1
 7963|      1|        Ok(())
 7964|      1|    }
 7965|       |
 7966|       |    #[test]
 7967|      1|    fn test_trigger_link_handles_fragments_and_schemes() {
 7968|      1|        let renderer = MarkdownRenderer::new();
 7969|       |
 7970|      1|        renderer.trigger_link("#Section-One");
 7971|      1|        assert_eq!(
 7972|      1|            renderer.take_pending_anchor(),
 7973|      1|            Some("section-one".to_string())
 7974|       |        );
 7975|      1|        assert!(renderer.take_pending_anchor().is_none());
 7976|       |
 7977|      1|        renderer.trigger_link("ftp://example.com");
 7978|      1|        assert!(renderer.take_pending_anchor().is_none());
 7979|       |
 7980|      1|        renderer.trigger_link("https://example.com");
 7981|      1|        assert!(renderer.take_pending_anchor().is_none());
 7982|       |
 7983|      1|        renderer.trigger_link("mailto:hello@example.com");
 7984|      1|        assert!(renderer.take_pending_anchor().is_none());
 7985|      1|    }
 7986|       |
 7987|       |    #[test]
 7988|      1|    fn test_resolve_image_path_with_base_dir() {
 7989|      1|        let renderer = MarkdownRenderer::new();
 7990|      1|        let temp = tempdir().expect("temp dir");
 7991|      1|        renderer.set_base_dir(Some(temp.path()));
 7992|       |
 7993|      1|        let resolved = renderer.resolve_image_path("sample.png");
 7994|      1|        assert!(resolved.contains("sample.png"));
 7995|       |
 7996|      1|        let abs = temp.path().join("abs.png");
 7997|      1|        let abs_str = abs.to_string_lossy().into_owned();
 7998|      1|        assert_eq!(renderer.resolve_image_path(&abs_str), abs_str);
 7999|       |
 8000|      1|        renderer.set_base_dir(None);
 8001|      1|        assert_eq!(renderer.resolve_image_path("relative.png"), "relative.png");
 8002|      1|    }
 8003|       |
 8004|       |    #[test]
 8005|      1|    fn test_disk_image_loads_and_caches() {
 8006|      1|        let renderer = MarkdownRenderer::new();
 8007|      1|        let temp = tempdir().expect("temp dir");
 8008|      1|        let image_path = temp.path().join("disk.png");
 8009|       |
 8010|      1|        let mut img = image::RgbaImage::new(2, 2);
 8011|      4|        for pixel in img.pixels_mut() {
                                   ^1  ^1
 8012|      4|            *pixel = image::Rgba([10, 20, 30, 255]);
 8013|      4|        }
 8014|      1|        img.save(&image_path).expect("save png");
 8015|       |
 8016|      1|        renderer.set_base_dir(Some(temp.path()));
 8017|      1|        let resolved = renderer.resolve_image_path("disk.png");
 8018|      1|        with_test_ui(|ctx, ui| {
 8019|       |            // Use wait_for_image to handle async image loading
 8020|      1|            let loaded = wait_for_image(&renderer, ctx, ui, &resolved);
 8021|      1|            assert!(loaded.is_some());
 8022|      1|        });
 8023|       |
 8024|      1|        assert!(renderer.image_textures.borrow().contains_key(&resolved));
 8025|      1|    }
 8026|       |
 8027|       |    #[test]
 8028|      1|    fn test_context_menu_helpers_execute() {
 8029|      1|        let renderer = MarkdownRenderer::new();
 8030|      1|        let _actions = ForcedRenderActions::new(&[
 8031|      1|            "copy_text",
 8032|      1|            "copy_inline_code",
 8033|      1|            "copy_code_block",
 8034|      1|            "copy_code_block_lang",
 8035|      1|            "open_link",
 8036|      1|            "copy_link_text",
 8037|      1|            "copy_link_url",
 8038|      1|            "copy_cell_text",
 8039|      1|        ]);
 8040|      1|        with_test_ui(|_, ui| {
 8041|      1|            renderer.render_text_context_menu(ui, "text");
 8042|      1|            renderer.render_inline_code_context_menu(ui, "code");
 8043|      1|            renderer.render_code_block_context_menu(ui, "fn main() {}", Some("rust"));
 8044|      1|            renderer.render_link_context_menu(ui, "label", "#anchor");
 8045|      1|            renderer.render_cell_context_menu(ui, "cell");
 8046|      1|            renderer.copy_text_and_close(ui, "direct-copy");
 8047|      1|        });
 8048|      1|    }
 8049|       |
 8050|       |    #[test]
 8051|      1|    fn test_context_menu_helpers_no_actions() {
 8052|      1|        let renderer = MarkdownRenderer::new();
 8053|      1|        with_test_ui(|_, ui| {
 8054|      1|            renderer.render_text_context_menu(ui, "text");
 8055|      1|            renderer.render_inline_code_context_menu(ui, "code");
 8056|      1|            renderer.render_code_block_context_menu(ui, "fn main() {}", None);
 8057|      1|            renderer.render_link_context_menu(ui, "label", "#anchor");
 8058|      1|            renderer.render_cell_context_menu(ui, "cell");
 8059|      1|        });
 8060|      1|    }
 8061|       |
 8062|       |    #[test]
 8063|      1|    fn test_estimate_table_column_widths_scales_down() {
 8064|      1|        let renderer = MarkdownRenderer::new();
 8065|      1|        let specs = vec![
 8066|      1|            ColumnSpec::new(
 8067|       |                0,
 8068|       |                "A",
 8069|      1|                ColumnPolicy::Resizable {
 8070|      1|                    min: 100.0,
 8071|      1|                    preferred: 100.0,
 8072|      1|                    clip: false,
 8073|      1|                },
 8074|      1|                None,
 8075|       |            ),
 8076|      1|            ColumnSpec::new(
 8077|       |                1,
 8078|       |                "B",
 8079|      1|                ColumnPolicy::Resizable {
 8080|      1|                    min: 100.0,
 8081|      1|                    preferred: 100.0,
 8082|      1|                    clip: false,
 8083|      1|                },
 8084|      1|                None,
 8085|       |            ),
 8086|       |        ];
 8087|       |
 8088|      1|        let widths = renderer.estimate_table_column_widths(&specs, 150.0, 10.0);
 8089|      1|        let total = widths.iter().sum::<f32>() + 10.0;
 8090|      1|        assert!(total <= 150.5);
 8091|      1|    }
 8092|       |
 8093|       |    #[test]
 8094|      1|    fn test_estimate_table_image_height_no_scale_or_title() {
 8095|      1|        let renderer = MarkdownRenderer::new();
 8096|      1|        let span = InlineSpan::Image {
 8097|      1|            src: "missing.png".to_string(),
 8098|      1|            alt: "Alt".to_string(),
 8099|      1|            title: Some(String::new()),
 8100|      1|        };
 8101|      1|        with_test_ui(|_, ui| {
 8102|      1|            let height = renderer.estimate_table_image_height(ui, &span, 2000.0);
 8103|      1|            assert!(height > 0.0);
 8104|      1|        });
 8105|      1|    }
 8106|       |
 8107|       |    #[test]
 8108|      1|    fn test_row_height_hint_uses_fallback_for_zero_height() {
 8109|      1|        let renderer = MarkdownRenderer::new();
 8110|      1|        let table_id = 42u64;
 8111|      1|        renderer
 8112|      1|            .table_metrics
 8113|      1|            .borrow_mut()
 8114|      1|            .entry_mut(table_id)
 8115|      1|            .ensure_row(0)
 8116|      1|            .max_height = 0.0;
 8117|      1|        let height = renderer.row_height_hint(table_id, 0);
 8118|      1|        assert_eq!(height, renderer.row_height_fallback());
 8119|      1|    }
 8120|       |
 8121|       |    #[test]
 8122|      1|    fn test_build_layout_job_covers_inline_styles() {
 8123|      1|        let renderer = MarkdownRenderer::new();
 8124|      1|        renderer.set_highlight_phrase(Some("code"));
 8125|      1|        let spans = vec![
 8126|      1|            InlineSpan::Text("plain".to_string()),
 8127|      1|            InlineSpan::Strong("bold".to_string()),
 8128|      1|            InlineSpan::Emphasis("italics".to_string()),
 8129|      1|            InlineSpan::Strikethrough("strike".to_string()),
 8130|      1|            InlineSpan::Code("code".to_string()),
 8131|      1|            InlineSpan::Link {
 8132|      1|                text: "ext".to_string(),
 8133|      1|                url: "https://example.com".to_string(),
 8134|      1|            },
 8135|      1|            InlineSpan::Link {
 8136|      1|                text: "local".to_string(),
 8137|      1|                url: "#anchor".to_string(),
 8138|      1|            },
 8139|       |        ];
 8140|       |
 8141|      1|        with_test_ui(|_, ui| {
 8142|      1|            let style = ui.style().clone();
 8143|      1|            let build = renderer.build_layout_job(&style, &spans, 200.0, false, Align::LEFT);
 8144|      1|            assert!(build.plain_text.contains("plain"));
 8145|      1|            assert_eq!(build.link_ranges.len(), 2);
 8146|      1|        });
 8147|      1|    }
 8148|       |
 8149|       |    #[test]
 8150|      1|    fn test_build_layout_job_strong_uses_override_text_color() {
 8151|      1|        let renderer = MarkdownRenderer::new();
 8152|      1|        let spans = vec![InlineSpan::Text("Header".to_string())];
 8153|      1|        let mut style = egui::Style::default();
 8154|      1|        let override_color = Color32::from_rgb(10, 20, 30);
 8155|      1|        style.visuals.override_text_color = Some(override_color);
 8156|       |
 8157|      1|        let build = renderer.build_layout_job(&style, &spans, 200.0, true, Align::LEFT);
 8158|      1|        assert!(!build.job.sections.is_empty());
 8159|      1|        assert_eq!(build.job.sections[0].format.color, override_color);
 8160|      1|    }
 8161|       |
 8162|       |    #[test]
 8163|      1|    fn test_render_inline_span_variants() {
 8164|      1|        let renderer = MarkdownRenderer::new();
 8165|      1|        let temp = tempdir().expect("temp dir");
 8166|      1|        let image_path = temp.path().join("image.png");
 8167|      1|        std::fs::write(&image_path, tiny_png_bytes()).expect("write png");
 8168|      1|        renderer.set_base_dir(Some(temp.path()));
 8169|       |
 8170|      1|        let image_span = InlineSpan::Image {
 8171|      1|            src: "image.png".to_string(),
 8172|      1|            alt: "Alt".to_string(),
 8173|      1|            title: Some("Title".to_string()),
 8174|      1|        };
 8175|      1|        let missing_span = InlineSpan::Image {
 8176|      1|            src: "missing.png".to_string(),
 8177|      1|            alt: "".to_string(),
 8178|      1|            title: None,
 8179|      1|        };
 8180|      1|        let remote_span = InlineSpan::Image {
 8181|      1|            src: "https://example.com/image.png".to_string(),
 8182|      1|            alt: "Remote".to_string(),
 8183|      1|            title: None,
 8184|      1|        };
 8185|      1|        let remote_http_span = InlineSpan::Image {
 8186|      1|            src: "http://example.com/image.png".to_string(),
 8187|      1|            alt: "RemoteHttp".to_string(),
 8188|      1|            title: None,
 8189|      1|        };
 8190|       |
 8191|      1|        let _guard = ForcedRenderActions::new(&["link_hover", "link_click", "image_hover"]);
 8192|      1|        with_test_ui(|ctx, ui| {
 8193|      1|            ui.visuals_mut().dark_mode = false;
 8194|      1|            renderer.render_inline_span(ui, &InlineSpan::Code("code".to_string()), None, None);
 8195|       |
 8196|      1|            ui.visuals_mut().dark_mode = true;
 8197|      1|            renderer.render_inline_span(ui, &InlineSpan::Text("text".to_string()), None, None);
 8198|      1|            renderer.render_inline_span(ui, &InlineSpan::Strong("bold".to_string()), None, None);
 8199|      1|            renderer.render_inline_span(
 8200|      1|                ui,
 8201|      1|                &InlineSpan::Emphasis("italic".to_string()),
 8202|      1|                None,
 8203|      1|                None,
 8204|       |            );
 8205|      1|            renderer.render_inline_span(
 8206|      1|                ui,
 8207|      1|                &InlineSpan::Strikethrough("strike".to_string()),
 8208|      1|                None,
 8209|      1|                None,
 8210|       |            );
 8211|      1|            renderer.render_inline_span(
 8212|      1|                ui,
 8213|      1|                &InlineSpan::Link {
 8214|      1|                    text: "ext".to_string(),
 8215|      1|                    url: "https://example.com".to_string(),
 8216|      1|                },
 8217|      1|                None,
 8218|      1|                None,
 8219|       |            );
 8220|      1|            renderer.render_inline_span(
 8221|      1|                ui,
 8222|      1|                &InlineSpan::Link {
 8223|      1|                    text: "local".to_string(),
 8224|      1|                    url: "#anchor".to_string(),
 8225|      1|                },
 8226|      1|                None,
 8227|      1|                None,
 8228|       |            );
 8229|      1|            let resolved = renderer.resolve_image_path("image.png");
 8230|      1|            let _loaded = wait_for_image(&renderer, ctx, ui, &resolved);
 8231|      1|            renderer.render_inline_span(ui, &image_span, None, None);
 8232|      1|            renderer.render_inline_span(ui, &missing_span, None, None);
 8233|      1|            renderer.render_inline_span(ui, &remote_span, None, None);
 8234|      1|            renderer.render_inline_span(ui, &remote_http_span, None, None);
 8235|      1|        });
 8236|      1|    }
 8237|       |
 8238|       |    #[test]
 8239|      1|    fn test_has_pending_renders_with_image_pending() {
 8240|      1|        let renderer = MarkdownRenderer::new();
 8241|      1|        assert!(!renderer.has_pending_renders());
 8242|      1|        renderer
 8243|      1|            .image_pending
 8244|      1|            .borrow_mut()
 8245|      1|            .insert("queued.png".to_string());
 8246|      1|        assert!(renderer.has_pending_renders());
 8247|      1|    }
 8248|       |
 8249|       |    #[test]
 8250|      1|    fn test_has_pending_renders_with_mermaid_pending() {
 8251|      1|        let renderer = MarkdownRenderer::new();
 8252|      1|        with_test_ui(|_, ui| {
 8253|      1|            renderer.mermaid.begin_frame();
 8254|      1|            renderer
 8255|      1|                .mermaid
 8256|      1|                .render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 8257|      1|        });
 8258|      1|        assert!(renderer.has_pending_renders());
 8259|      1|    }
 8260|       |
 8261|       |    #[test]
 8262|      1|    fn test_parse_lists_and_blockquotes() {
 8263|      1|        let renderer = MarkdownRenderer::new();
 8264|      1|        let md = "\
 8265|      1|- Item 1
 8266|      1|- Item 2
 8267|      1|  - Nested
 8268|      1|
 8269|      1|1. First
 8270|      1|2. Second
 8271|      1|
 8272|      1|> Quote line
 8273|      1|> > Nested quote
 8274|      1|
 8275|      1|---";
 8276|       |
 8277|      1|        let elements = renderer.parse(md).expect("parse ok");
 8278|      1|        assert!(elements
 8279|      1|            .iter()
 8280|      1|            .any(|el| matches!(el, MarkdownElement::List { ordered: false, .. })));
 8281|      1|        assert!(elements
 8282|      1|            .iter()
 8283|      2|            .any(|el| matches!(el, MarkdownElement::List { ordered: true, .. })));
                           ^1
 8284|      1|        assert!(elements
 8285|      1|            .iter()
 8286|      3|            .any(|el| matches!(el, MarkdownElement::Quote { .. })));
                           ^1
 8287|      1|        assert!(elements
 8288|      1|            .iter()
 8289|      5|            .any(|el| matches!(el, MarkdownElement::HorizontalRule)));
                           ^1
 8290|      1|    }
 8291|       |
 8292|       |    #[test]
 8293|      1|    fn test_elements_to_plain_text_variants() {
 8294|      1|        let elements = vec![
 8295|      1|            MarkdownElement::Header {
 8296|      1|                level: 1,
 8297|      1|                spans: vec![InlineSpan::Text("Title".to_string())],
 8298|      1|                id: "title".to_string(),
 8299|      1|            },
 8300|      1|            MarkdownElement::Paragraph(vec![
 8301|      1|                InlineSpan::Text("Hello".to_string()),
 8302|      1|                InlineSpan::Code("code".to_string()),
 8303|      1|            ]),
 8304|      1|            MarkdownElement::CodeBlock {
 8305|      1|                language: Some("rust".to_string()),
 8306|      1|                text: "fn main() {}".to_string(),
 8307|      1|            },
 8308|      1|            MarkdownElement::List {
 8309|      1|                ordered: false,
 8310|      1|                items: vec![ListItem {
 8311|      1|                    blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 8312|      1|                        "Item".to_string(),
 8313|      1|                    )])],
 8314|      1|                }],
 8315|      1|            },
 8316|      1|            MarkdownElement::Quote {
 8317|      1|                depth: 1,
 8318|      1|                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 8319|      1|                    "Quote".to_string(),
 8320|      1|                )])],
 8321|      1|            },
 8322|      1|            MarkdownElement::HorizontalRule,
 8323|      1|            MarkdownElement::Table {
 8324|      1|                headers: vec![vec![InlineSpan::Text("H".to_string())]],
 8325|      1|                rows: vec![vec![vec![InlineSpan::Image {
 8326|      1|                    src: "img.png".to_string(),
 8327|      1|                    alt: "Alt".to_string(),
 8328|      1|                    title: None,
 8329|      1|                }]]],
 8330|      1|                alignments: Vec::new(),
 8331|      1|            },
 8332|       |        ];
 8333|      1|        let text = MarkdownRenderer::elements_to_plain_text(&elements);
 8334|      1|        assert!(text.contains("Title"));
 8335|      1|        assert!(text.contains("Hello"));
 8336|      1|        assert!(text.contains("fn main"));
 8337|      1|        assert!(text.contains("Item"));
 8338|      1|        assert!(text.contains("Quote"));
 8339|      1|        assert!(text.contains("Alt"));
 8340|      1|    }
 8341|       |
 8342|       |    #[test]
 8343|      1|    fn test_elements_to_plain_text_image_title_and_empty_rule() {
 8344|      1|        let elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Image {
 8345|      1|            src: "img.png".to_string(),
 8346|      1|            alt: "".to_string(),
 8347|      1|            title: Some("Diagram Title".to_string()),
 8348|      1|        }])];
 8349|      1|        let text = MarkdownRenderer::elements_to_plain_text(&elements);
 8350|      1|        assert!(text.contains("Diagram Title"));
 8351|       |
 8352|      1|        let hr_only = vec![MarkdownElement::HorizontalRule];
 8353|      1|        assert_eq!(MarkdownRenderer::elements_to_plain_text(&hr_only), "");
 8354|      1|    }
 8355|       |
 8356|       |    #[test]
 8357|      1|    fn test_table_rendering_overhaul() {
 8358|      1|        let renderer = MarkdownRenderer::new();
 8359|      1|        let headers = vec![
 8360|      1|            vec![InlineSpan::Text("H1".to_string())],
 8361|      1|            vec![InlineSpan::Text("H2".to_string())],
 8362|       |        ];
 8363|      1|        let rows = vec![vec![
 8364|      1|            vec![InlineSpan::Text("Cell".to_string())],
 8365|      1|            vec![InlineSpan::Link {
 8366|      1|                text: "Link".to_string(),
 8367|      1|                url: "https://example.com".to_string(),
 8368|      1|            }],
 8369|       |        ]];
 8370|      1|        let elements = vec![MarkdownElement::Table {
 8371|      1|            headers,
 8372|      1|            rows,
 8373|      1|            alignments: Vec::new(),
 8374|      1|        }];
 8375|       |
 8376|      1|        with_test_ui(|_, ui| {
 8377|      1|            renderer.render_to_ui(ui, &elements);
 8378|      1|        });
 8379|      1|    }
 8380|       |
 8381|       |    #[test]
 8382|      1|    fn test_measure_inline_spans_and_emoji_texture() {
 8383|      1|        let renderer = MarkdownRenderer::new();
 8384|      1|        let spans = vec![
 8385|      1|            InlineSpan::Text("Hello".to_string()),
 8386|      1|            InlineSpan::Text("".to_string()),
 8387|       |        ];
 8388|       |
 8389|      1|        with_test_ui(|_, ui| {
 8390|      1|            let width = renderer.measure_inline_spans(ui, &spans);
 8391|      1|            assert!(width > 0.0);
 8392|      1|            let tex = renderer.get_or_make_emoji_texture(ui, "");
 8393|      1|            assert!(tex.size()[0] > 0);
 8394|      1|        });
 8395|       |
 8396|      1|        let img = renderer.generate_emoji_image("", 16);
 8397|      1|        assert_eq!(img.size[0], 16);
 8398|      1|    }
 8399|       |
 8400|       |    #[test]
 8401|      1|    fn test_measure_inline_spans_respects_line_breaks() {
 8402|      1|        let renderer = MarkdownRenderer::new();
 8403|      1|        let single_line = vec![InlineSpan::Text(
 8404|      1|            "Short This is a much longer line".to_string(),
 8405|      1|        )];
 8406|      1|        let multi_line = vec![InlineSpan::Text(
 8407|      1|            "Short\nThis is a much longer line".to_string(),
 8408|      1|        )];
 8409|       |
 8410|      1|        with_test_ui(|_, ui| {
 8411|      1|            let single = renderer.measure_inline_spans(ui, &single_line);
 8412|      1|            let multi = renderer.measure_inline_spans(ui, &multi_line);
 8413|      1|            assert!(multi < single);
 8414|      1|        });
 8415|      1|    }
 8416|       |
 8417|       |    #[test]
 8418|      1|    fn test_measure_inline_spans_normalizes_unicode() {
 8419|      1|        let renderer = MarkdownRenderer::new();
 8420|      1|        let unicode = vec![InlineSpan::Text("A\u{2192}B".to_string())];
 8421|      1|        let ascii = vec![InlineSpan::Text("A->B".to_string())];
 8422|       |
 8423|      1|        with_test_ui(|_, ui| {
 8424|      1|            let unicode_width = renderer.measure_inline_spans(ui, &unicode);
 8425|      1|            let ascii_width = renderer.measure_inline_spans(ui, &ascii);
 8426|      1|            assert!((unicode_width - ascii_width).abs() < 0.5);
 8427|      1|        });
 8428|      1|    }
 8429|       |
 8430|       |    #[test]
 8431|      1|    fn test_to_superscript_full_mapping() {
 8432|      1|        let input = "0123456789+-=()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#";
 8433|      1|        let out = MarkdownRenderer::to_superscript(input);
 8434|      1|        assert_eq!(out.chars().count(), input.chars().count());
 8435|      1|        assert!(out.contains('\u{2070}'));
 8436|      1|        assert!(out.contains('\u{00b9}'));
 8437|      1|        assert!(out.contains('\u{1d43}'));
 8438|      1|        assert!(out.contains('#'));
 8439|      1|    }
 8440|       |
 8441|       |    #[test]
 8442|      1|    fn test_element_plain_text_variants() {
 8443|      1|        let list = MarkdownElement::List {
 8444|      1|            ordered: false,
 8445|      1|            items: vec![ListItem {
 8446|      1|                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 8447|      1|                    "Item".to_string(),
 8448|      1|                )])],
 8449|      1|            }],
 8450|      1|        };
 8451|      1|        let quote = MarkdownElement::Quote {
 8452|      1|            depth: 1,
 8453|      1|            blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 8454|      1|                "Quote".to_string(),
 8455|      1|            )])],
 8456|      1|        };
 8457|      1|        let table = MarkdownElement::Table {
 8458|      1|            headers: vec![vec![InlineSpan::Text("Header".to_string())]],
 8459|      1|            rows: vec![vec![vec![InlineSpan::Text("Cell".to_string())]]],
 8460|      1|            alignments: Vec::new(),
 8461|      1|        };
 8462|       |
 8463|      1|        assert!(MarkdownRenderer::element_plain_text(&list).contains("Item"));
 8464|      1|        assert!(MarkdownRenderer::element_plain_text(&quote).contains("Quote"));
 8465|      1|        assert_eq!(
 8466|      1|            MarkdownRenderer::element_plain_text(&MarkdownElement::HorizontalRule),
 8467|       |            "---"
 8468|       |        );
 8469|      1|        assert!(MarkdownRenderer::element_plain_text(&table).contains("Header"));
 8470|      1|        assert!(MarkdownRenderer::element_plain_text(&table).contains("Cell"));
 8471|      1|    }
 8472|       |
 8473|       |    #[test]
 8474|      1|    fn test_parse_element_image_outside_paragraph() {
 8475|      1|        let renderer = MarkdownRenderer::new();
 8476|      1|        let events = vec![
 8477|      1|            Event::Start(Tag::Image(
 8478|      1|                LinkType::Inline,
 8479|      1|                "img.png".into(),
 8480|      1|                "Title".into(),
 8481|      1|            )),
 8482|      1|            Event::Text("Alt".into()),
 8483|      1|            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
 8484|       |        ];
 8485|      1|        let mut elements = Vec::new();
 8486|      1|        let mut slugs = std::collections::HashMap::new();
 8487|      1|        let next = renderer
 8488|      1|            .parse_element(&events, 0, &mut elements, &mut slugs)
 8489|      1|            .expect("parse ok");
 8490|      1|        assert_eq!(next, events.len());
 8491|      1|        assert!(matches!(
                              ^0
 8492|      1|            elements.first(),
 8493|       |            Some(MarkdownElement::Paragraph(_))
 8494|       |        ));
 8495|      1|        let spans = paragraph_spans(elements.first().expect("element")).expect("paragraph spans");
 8496|      1|        let (_src, _alt, title) = image_span_fields(&spans[0]).expect("image span");
 8497|      1|        assert_eq!(title, Some("Title"));
 8498|      1|        assert!(paragraph_spans(&MarkdownElement::HorizontalRule).is_none());
 8499|      1|    }
 8500|       |
 8501|       |    #[test]
 8502|      1|    fn test_parse_element_empty_paragraph_skips() -> Result<()> {
 8503|      1|        let renderer = MarkdownRenderer::new();
 8504|      1|        let events = vec![Event::Start(Tag::Paragraph), Event::End(Tag::Paragraph)];
 8505|      1|        let mut elements = Vec::new();
 8506|      1|        let mut slugs = HashMap::new();
 8507|      1|        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs)?;
                                                                                              ^0
 8508|      1|        assert_eq!(next, events.len());
 8509|      1|        assert!(elements.is_empty());
 8510|      1|        Ok(())
 8511|      1|    }
 8512|       |
 8513|       |    #[test]
 8514|      1|    fn test_parse_element_empty_blockquote_skips() -> Result<()> {
 8515|      1|        let renderer = MarkdownRenderer::new();
 8516|      1|        let events = vec![
 8517|      1|            Event::Start(Tag::BlockQuote),
 8518|      1|            Event::Start(Tag::BlockQuote),
 8519|      1|            Event::End(Tag::BlockQuote),
 8520|      1|            Event::End(Tag::BlockQuote),
 8521|       |        ];
 8522|      1|        let mut elements = Vec::new();
 8523|      1|        let mut slugs = HashMap::new();
 8524|      1|        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs)?;
                                                                                              ^0
 8525|      1|        assert_eq!(next, events.len());
 8526|      1|        assert!(elements.is_empty());
 8527|      1|        Ok(())
 8528|      1|    }
 8529|       |
 8530|       |    #[test]
 8531|      1|    fn test_parse_list_event_variants() -> Result<()> {
 8532|      1|        let renderer = MarkdownRenderer::new();
 8533|      1|        let events = vec![
 8534|      1|            Event::Start(Tag::List(None)),
 8535|      1|            Event::Start(Tag::Item),
 8536|      1|            Event::Start(Tag::Emphasis),
 8537|      1|            Event::Text("em".into()),
 8538|      1|            Event::End(Tag::Emphasis),
 8539|      1|            Event::Start(Tag::Strong),
 8540|      1|            Event::Text("strong".into()),
 8541|      1|            Event::End(Tag::Strong),
 8542|      1|            Event::Start(Tag::Strikethrough),
 8543|      1|            Event::Text("strike".into()),
 8544|      1|            Event::End(Tag::Strikethrough),
 8545|      1|            Event::Start(Tag::Link(
 8546|      1|                LinkType::Inline,
 8547|      1|                "https://example.com".into(),
 8548|      1|                "".into(),
 8549|      1|            )),
 8550|      1|            Event::Text("link".into()),
 8551|      1|            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
 8552|      1|            Event::Start(Tag::Image(
 8553|      1|                LinkType::Inline,
 8554|      1|                "img.png".into(),
 8555|      1|                "Title".into(),
 8556|      1|            )),
 8557|      1|            Event::Text("alt".into()),
 8558|      1|            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
 8559|      1|            Event::Code("code".into()),
 8560|      1|            Event::Text("text".into()),
 8561|      1|            Event::SoftBreak,
 8562|      1|            Event::Start(Tag::List(Some(1))),
 8563|      1|            Event::Start(Tag::Item),
 8564|      1|            Event::Text("nested".into()),
 8565|      1|            Event::End(Tag::Item),
 8566|      1|            Event::End(Tag::List(Some(1))),
 8567|      1|            Event::End(Tag::Item),
 8568|      1|            Event::End(Tag::List(None)),
 8569|       |        ];
 8570|       |
 8571|      1|        let mut slugs = std::collections::HashMap::new();
 8572|      1|        let (items, next) = renderer.parse_list(&events, 1, &mut slugs)?;
                                                                                     ^0
 8573|      1|        assert_eq!(next, events.len());
 8574|      1|        assert_eq!(items.len(), 1);
 8575|      1|        let item = &items[0];
 8576|      1|        let mut blocks = Vec::new();
 8577|      1|        blocks.push(MarkdownElement::HorizontalRule);
 8578|      1|        blocks.extend(item.blocks.clone());
 8579|      1|        let spans = blocks
 8580|      1|            .iter()
 8581|      2|            .find_map(|block| match block {
                           ^1
 8582|      1|                MarkdownElement::Paragraph(spans) => Some(spans),
 8583|      1|                _ => None,
 8584|      2|            })
 8585|      1|            .expect("paragraph block");
 8586|      1|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Emphasis(_))));
 8587|      2|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Strong(_))));
                      ^1      ^1           ^1
 8588|      1|        assert!(spans
 8589|      1|            .iter()
 8590|      3|            .any(|s| matches!(s, InlineSpan::Strikethrough(_))));
                           ^1
 8591|      4|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Link { .. })));
                      ^1      ^1           ^1
 8592|      5|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Image { .. })));
                      ^1      ^1           ^1
 8593|      6|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Code(_))));
                      ^1      ^1           ^1
 8594|      1|        assert!(item
 8595|      1|            .blocks
 8596|      1|            .iter()
 8597|      2|            .any(|block| matches!(block, MarkdownElement::List { ordered: true, .. })));
                           ^1
 8598|      1|        Ok(())
 8599|      1|    }
 8600|       |
 8601|       |    #[test]
 8602|      1|    fn test_parse_inline_spans_with_breaks_variants() {
 8603|      1|        let renderer = MarkdownRenderer::new();
 8604|      1|        let events = vec![
 8605|      1|            Event::Start(Tag::Paragraph),
 8606|      1|            Event::Text("Hello".into()),
 8607|      1|            Event::SoftBreak,
 8608|      1|            Event::Code("code".into()),
 8609|      1|            Event::Start(Tag::Strong),
 8610|      1|            Event::Text("bold".into()),
 8611|      1|            Event::End(Tag::Strong),
 8612|      1|            Event::Start(Tag::Emphasis),
 8613|      1|            Event::Text("em".into()),
 8614|      1|            Event::End(Tag::Emphasis),
 8615|      1|            Event::Start(Tag::Strikethrough),
 8616|      1|            Event::Text("strike".into()),
 8617|      1|            Event::End(Tag::Strikethrough),
 8618|      1|            Event::Start(Tag::Link(
 8619|      1|                LinkType::Inline,
 8620|      1|                "https://example.com".into(),
 8621|      1|                "".into(),
 8622|      1|            )),
 8623|      1|            Event::Text("link".into()),
 8624|      1|            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
 8625|      1|            Event::Start(Tag::Image(
 8626|      1|                LinkType::Inline,
 8627|      1|                "img.png".into(),
 8628|      1|                "Title".into(),
 8629|      1|            )),
 8630|      1|            Event::Text("alt".into()),
 8631|      1|            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
 8632|      1|            Event::End(Tag::Paragraph),
 8633|       |        ];
 8634|       |
 8635|      1|        let (spans, next) =
 8636|      1|            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true);
 8637|      1|        assert_eq!(next, events.len());
 8638|      1|        let mut saw_code = false;
 8639|      1|        let mut saw_strong = false;
 8640|      1|        let mut saw_emphasis = false;
 8641|      1|        let mut saw_strike = false;
 8642|      1|        let mut saw_link = false;
 8643|      1|        let mut saw_image = false;
 8644|      1|        let mut saw_break_text = false;
 8645|      9|        for span in &spans {
                          ^8
 8646|      2|            match span {
 8647|      1|                InlineSpan::Code(_) => saw_code = true,
 8648|      1|                InlineSpan::Strong(_) => saw_strong = true,
 8649|      1|                InlineSpan::Emphasis(_) => saw_emphasis = true,
 8650|      1|                InlineSpan::Strikethrough(_) => saw_strike = true,
 8651|      1|                InlineSpan::Link { .. } => saw_link = true,
 8652|      1|                InlineSpan::Image { .. } => saw_image = true,
 8653|      2|                InlineSpan::Text(t) if t.contains('\n') => saw_break_text = true,
                                                                    ^1   ^1
 8654|      1|                _ => {}
 8655|       |            }
 8656|       |        }
 8657|      1|        assert!(saw_code);
 8658|      1|        assert!(saw_strong);
 8659|      1|        assert!(saw_emphasis);
 8660|      1|        assert!(saw_strike);
 8661|      1|        assert!(saw_link);
 8662|      1|        assert!(saw_image);
 8663|      1|        assert!(saw_break_text);
 8664|      1|    }
 8665|       |
 8666|       |    #[test]
 8667|      1|    fn test_parse_inline_spans_html_breaks() {
 8668|      1|        let renderer = MarkdownRenderer::new();
 8669|      1|        let events = vec![
 8670|      1|            Event::Start(Tag::Paragraph),
 8671|      1|            Event::Text("one".into()),
 8672|      1|            Event::Html("<br>".into()),
 8673|      1|            Event::Text("two".into()),
 8674|      1|            Event::End(Tag::Paragraph),
 8675|       |        ];
 8676|       |
 8677|      1|        let (spans, next) =
 8678|      1|            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true);
 8679|      1|        assert_eq!(next, events.len());
 8680|      1|        assert!(spans
 8681|      1|            .iter()
 8682|      2|            .any(|s| matches!(s, InlineSpan::Text(t) if t == "\n")));
                           ^1                                                 ^1
 8683|       |
 8684|      1|        let (spans_no_break, _) = renderer.parse_inline_spans(&events, 1, Tag::Paragraph);
 8685|      1|        let text = MarkdownRenderer::spans_plain_text(&spans_no_break);
 8686|      1|        assert!(text.contains("one two"));
 8687|       |
 8688|      1|        let attr_events = vec![
 8689|      1|            Event::Start(Tag::Paragraph),
 8690|      1|            Event::Text("alpha".into()),
 8691|      1|            Event::Html("<br class=\"tight\">".into()),
 8692|      1|            Event::Text("beta".into()),
 8693|      1|            Event::End(Tag::Paragraph),
 8694|       |        ];
 8695|      1|        let (spans, next) =
 8696|      1|            renderer.parse_inline_spans_with_breaks(&attr_events, 1, Tag::Paragraph, true);
 8697|      1|        assert_eq!(next, attr_events.len());
 8698|      1|        assert!(spans
 8699|      1|            .iter()
 8700|      2|            .any(|s| matches!(s, InlineSpan::Text(t) if t == "\n")));
                           ^1                                                 ^1
 8701|       |
 8702|      1|        let strong_events = vec![
 8703|      1|            Event::Start(Tag::Paragraph),
 8704|      1|            Event::Text("lead ".into()),
 8705|      1|            Event::Start(Tag::Strong),
 8706|      1|            Event::Text("alpha".into()),
 8707|      1|            Event::Html("<br>".into()),
 8708|      1|            Event::Text("beta".into()),
 8709|      1|            Event::End(Tag::Strong),
 8710|      1|            Event::End(Tag::Paragraph),
 8711|       |        ];
 8712|      1|        let (_spans, next) =
 8713|      1|            renderer.parse_inline_spans_with_breaks(&strong_events, 1, Tag::Paragraph, true);
 8714|      1|        assert_eq!(next, strong_events.len());
 8715|       |
 8716|      1|        let (spans_no_break, _) = renderer.parse_inline_spans(&strong_events, 1, Tag::Paragraph);
 8717|      1|        let mut saw_non_strong = false;
 8718|      1|        let mut strong_text = None;
 8719|      3|        for span in &spans_no_break {
                          ^2
 8720|      2|            if let InlineSpan::Strong(text) = span {
                                                    ^1
 8721|      1|                strong_text = Some(text.as_str());
 8722|      1|            } else {
 8723|      1|                saw_non_strong = true;
 8724|      1|            }
 8725|       |        }
 8726|      1|        assert!(saw_non_strong);
 8727|      1|        let mut saw_match = false;
 8728|      1|        let mut saw_miss = false;
 8729|      1|        let mut saw_none = false;
 8730|      3|        for candidate in [strong_text, Some("nope"), None] {
                                        ^1           ^1            ^1
 8731|      3|            if let Some(text) = candidate {
                                      ^2
 8732|      2|                if text.contains("alpha beta") {
 8733|      1|                    saw_match = true;
 8734|      1|                } else {
 8735|      1|                    saw_miss = true;
 8736|      1|                }
 8737|      1|            } else {
 8738|      1|                saw_none = true;
 8739|      1|            }
 8740|       |        }
 8741|      1|        assert!(saw_match);
 8742|      1|        assert!(saw_miss);
 8743|      1|        assert!(saw_none);
 8744|      1|    }
 8745|       |
 8746|       |    #[test]
 8747|      1|    fn test_parse_inline_spans_soft_break_without_keep() {
 8748|      1|        let renderer = MarkdownRenderer::new();
 8749|      1|        let events = vec![
 8750|      1|            Event::Start(Tag::Paragraph),
 8751|      1|            Event::Text("alpha".into()),
 8752|      1|            Event::SoftBreak,
 8753|      1|            Event::Text("beta".into()),
 8754|      1|            Event::End(Tag::Paragraph),
 8755|       |        ];
 8756|       |
 8757|      1|        let (spans, next) = renderer.parse_inline_spans(&events, 1, Tag::Paragraph);
 8758|      1|        assert_eq!(next, events.len());
 8759|      1|        assert_eq!(MarkdownRenderer::spans_plain_text(&spans), "alpha beta");
 8760|      1|    }
 8761|       |
 8762|       |    #[test]
 8763|      1|    fn test_collect_blockquotes_nested_and_breaks() -> Result<()> {
 8764|      1|        let renderer = MarkdownRenderer::new();
 8765|      1|        let events = vec![
 8766|      1|            Event::Start(Tag::BlockQuote),
 8767|      1|            Event::Start(Tag::Paragraph),
 8768|      1|            Event::Text("Line1\nLine2".into()),
 8769|      1|            Event::End(Tag::Paragraph),
 8770|      1|            Event::SoftBreak,
 8771|      1|            Event::Start(Tag::BlockQuote),
 8772|      1|            Event::Start(Tag::Paragraph),
 8773|      1|            Event::Text("Nested".into()),
 8774|      1|            Event::End(Tag::Paragraph),
 8775|      1|            Event::End(Tag::BlockQuote),
 8776|      1|            Event::End(Tag::BlockQuote),
 8777|       |        ];
 8778|      1|        let mut slugs = HashMap::new();
 8779|      1|        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs)?;
                                                                                                  ^0
 8780|      1|        assert_eq!(next, events.len());
 8781|      1|        assert!(quotes.iter().any(|(depth, _)| *depth == 1));
 8782|      2|        assert!(quotes.iter().any(|(depth, _)| *depth == 2));
                      ^1      ^1            ^1
 8783|      1|        Ok(())
 8784|      1|    }
 8785|       |
 8786|       |    #[test]
 8787|      1|    fn test_collect_blockquotes_event_variants() -> Result<()> {
 8788|      1|        let renderer = MarkdownRenderer::new();
 8789|      1|        let events = vec![
 8790|      1|            Event::Start(Tag::BlockQuote),
 8791|      1|            Event::Start(Tag::Paragraph),
 8792|      1|            Event::Text("para".into()),
 8793|      1|            Event::End(Tag::Paragraph),
 8794|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 8795|      1|            Event::Text("Heading".into()),
 8796|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 8797|      1|            Event::Start(Tag::List(None)),
 8798|      1|            Event::Start(Tag::Item),
 8799|      1|            Event::Text("item".into()),
 8800|      1|            Event::End(Tag::Item),
 8801|      1|            Event::End(Tag::List(None)),
 8802|      1|            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8803|      1|                "rust".into(),
 8804|      1|            ))),
 8805|      1|            Event::Text("fn main() {}\n".into()),
 8806|      1|            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8807|      1|                "rust".into(),
 8808|      1|            ))),
 8809|      1|            Event::Start(Tag::Table(vec![Alignment::Left])),
 8810|      1|            Event::Start(Tag::TableHead),
 8811|      1|            Event::Start(Tag::TableRow),
 8812|      1|            Event::Start(Tag::TableCell),
 8813|      1|            Event::Text("H".into()),
 8814|      1|            Event::End(Tag::TableCell),
 8815|      1|            Event::End(Tag::TableRow),
 8816|      1|            Event::End(Tag::TableHead),
 8817|      1|            Event::Start(Tag::TableRow),
 8818|      1|            Event::Start(Tag::TableCell),
 8819|      1|            Event::Text("R".into()),
 8820|      1|            Event::End(Tag::TableCell),
 8821|      1|            Event::End(Tag::TableRow),
 8822|      1|            Event::End(Tag::Table(vec![Alignment::Left])),
 8823|      1|            Event::Start(Tag::Emphasis),
 8824|      1|            Event::Text("em".into()),
 8825|      1|            Event::End(Tag::Emphasis),
 8826|      1|            Event::Start(Tag::Strong),
 8827|      1|            Event::Text("strong".into()),
 8828|      1|            Event::End(Tag::Strong),
 8829|      1|            Event::Start(Tag::Strikethrough),
 8830|      1|            Event::Text("strike".into()),
 8831|      1|            Event::End(Tag::Strikethrough),
 8832|      1|            Event::Start(Tag::Link(
 8833|      1|                LinkType::Inline,
 8834|      1|                "https://example.com".into(),
 8835|      1|                "".into(),
 8836|      1|            )),
 8837|      1|            Event::Text("link".into()),
 8838|      1|            Event::End(Tag::Link(
 8839|      1|                LinkType::Inline,
 8840|      1|                "https://example.com".into(),
 8841|      1|                "".into(),
 8842|      1|            )),
 8843|      1|            Event::Start(Tag::Image(
 8844|      1|                LinkType::Inline,
 8845|      1|                "img.png".into(),
 8846|      1|                "Title".into(),
 8847|      1|            )),
 8848|      1|            Event::Text("alt".into()),
 8849|      1|            Event::End(Tag::Image(
 8850|      1|                LinkType::Inline,
 8851|      1|                "img.png".into(),
 8852|      1|                "Title".into(),
 8853|      1|            )),
 8854|      1|            Event::Code("code".into()),
 8855|      1|            Event::SoftBreak,
 8856|      1|            Event::HardBreak,
 8857|      1|            Event::Html("<br>".into()),
 8858|      1|            Event::Rule,
 8859|      1|            Event::Start(Tag::BlockQuote),
 8860|      1|            Event::Start(Tag::Paragraph),
 8861|      1|            Event::Text("Nested".into()),
 8862|      1|            Event::End(Tag::Paragraph),
 8863|      1|            Event::End(Tag::BlockQuote),
 8864|      1|            Event::End(Tag::BlockQuote),
 8865|       |        ];
 8866|      1|        let mut slugs = HashMap::new();
 8867|      1|        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs)?;
                                                                                                  ^0
 8868|      1|        assert_eq!(next, events.len());
 8869|      1|        assert!(!quotes.is_empty());
 8870|      1|        Ok(())
 8871|      1|    }
 8872|       |
 8873|       |    #[test]
 8874|      1|    fn test_collect_blockquotes_empty_paragraph_and_html_ignored() -> Result<()> {
 8875|      1|        let renderer = MarkdownRenderer::new();
 8876|      1|        let events = vec![
 8877|      1|            Event::Start(Tag::BlockQuote),
 8878|      1|            Event::Start(Tag::Paragraph),
 8879|      1|            Event::End(Tag::Paragraph),
 8880|      1|            Event::Html("<span>".into()),
 8881|      1|            Event::End(Tag::BlockQuote),
 8882|       |        ];
 8883|      1|        let mut slugs = HashMap::new();
 8884|      1|        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs)?;
                                                                                                  ^0
 8885|      1|        assert_eq!(next, events.len());
 8886|      1|        assert!(quotes.is_empty());
 8887|      1|        Ok(())
 8888|      1|    }
 8889|       |
 8890|       |    #[test]
 8891|      1|    fn test_collect_blockquotes_empty_unclosed_returns_empty() -> Result<()> {
 8892|      1|        let renderer = MarkdownRenderer::new();
 8893|      1|        let events = vec![Event::Start(Tag::BlockQuote)];
 8894|      1|        let mut slugs = HashMap::new();
 8895|      1|        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs)?;
                                                                                                  ^0
 8896|      1|        assert_eq!(next, events.len());
 8897|      1|        assert!(quotes.is_empty());
 8898|      1|        Ok(())
 8899|      1|    }
 8900|       |
 8901|       |    #[test]
 8902|      1|    fn test_parse_list_block_elements() -> Result<()> {
 8903|      1|        let renderer = MarkdownRenderer::new();
 8904|      1|        let events = vec![
 8905|      1|            Event::Start(Tag::List(Some(1))),
 8906|      1|            Event::Start(Tag::Item),
 8907|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H3, None, vec![])),
 8908|      1|            Event::Text("Heading".into()),
 8909|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H3, None, vec![])),
 8910|      1|            Event::Start(Tag::Table(vec![Alignment::Left])),
 8911|      1|            Event::Start(Tag::TableHead),
 8912|      1|            Event::Start(Tag::TableRow),
 8913|      1|            Event::Start(Tag::TableCell),
 8914|      1|            Event::Text("H".into()),
 8915|      1|            Event::End(Tag::TableCell),
 8916|      1|            Event::End(Tag::TableRow),
 8917|      1|            Event::End(Tag::TableHead),
 8918|      1|            Event::Start(Tag::TableRow),
 8919|      1|            Event::Start(Tag::TableCell),
 8920|      1|            Event::Text("R".into()),
 8921|      1|            Event::End(Tag::TableCell),
 8922|      1|            Event::End(Tag::TableRow),
 8923|      1|            Event::End(Tag::Table(vec![Alignment::Left])),
 8924|      1|            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8925|      1|                "rust".into(),
 8926|      1|            ))),
 8927|      1|            Event::Text("fn main() {}\n".into()),
 8928|      1|            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8929|      1|                "rust".into(),
 8930|      1|            ))),
 8931|      1|            Event::Start(Tag::BlockQuote),
 8932|      1|            Event::Start(Tag::Paragraph),
 8933|      1|            Event::Text("Quote".into()),
 8934|      1|            Event::End(Tag::Paragraph),
 8935|      1|            Event::End(Tag::BlockQuote),
 8936|      1|            Event::Rule,
 8937|      1|            Event::HardBreak,
 8938|      1|            Event::End(Tag::Item),
 8939|      1|            Event::End(Tag::List(Some(1))),
 8940|       |        ];
 8941|      1|        let mut slugs = HashMap::new();
 8942|      1|        let (items, next) = renderer.parse_list(&events, 1, &mut slugs)?;
                                                                                     ^0
 8943|      1|        assert_eq!(next, events.len());
 8944|      1|        assert_eq!(items.len(), 1);
 8945|      1|        Ok(())
 8946|      1|    }
 8947|       |
 8948|       |    #[test]
 8949|      1|    fn test_parse_element_variants() -> Result<()> {
 8950|      1|        let renderer = MarkdownRenderer::new();
 8951|      1|        let mut slugs = HashMap::new();
 8952|      1|        let mut elements = Vec::new();
 8953|       |
 8954|      1|        let paragraph = vec![
 8955|      1|            Event::Start(Tag::Paragraph),
 8956|      1|            Event::Text("para".into()),
 8957|      1|            Event::End(Tag::Paragraph),
 8958|       |        ];
 8959|      1|        let next = renderer.parse_element(&paragraph, 0, &mut elements, &mut slugs)?;
                                                                                                 ^0
 8960|      1|        assert_eq!(next, paragraph.len());
 8961|       |
 8962|      1|        let heading = vec![
 8963|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 8964|      1|            Event::Text("Heading".into()),
 8965|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 8966|       |        ];
 8967|      1|        let next = renderer.parse_element(&heading, 0, &mut elements, &mut slugs)?;
                                                                                               ^0
 8968|      1|        assert_eq!(next, heading.len());
 8969|       |
 8970|      1|        let code_block = vec![
 8971|      1|            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8972|      1|                "rust".into(),
 8973|      1|            ))),
 8974|      1|            Event::Text("fn main() {}\n".into()),
 8975|      1|            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8976|      1|                "rust".into(),
 8977|      1|            ))),
 8978|       |        ];
 8979|      1|        let next = renderer.parse_element(&code_block, 0, &mut elements, &mut slugs)?;
                                                                                                  ^0
 8980|      1|        assert_eq!(next, code_block.len());
 8981|       |
 8982|      1|        let list = vec![
 8983|      1|            Event::Start(Tag::List(None)),
 8984|      1|            Event::Start(Tag::Item),
 8985|      1|            Event::Text("item".into()),
 8986|      1|            Event::End(Tag::Item),
 8987|      1|            Event::End(Tag::List(None)),
 8988|       |        ];
 8989|      1|        let next = renderer.parse_element(&list, 0, &mut elements, &mut slugs)?;
                                                                                            ^0
 8990|      1|        assert_eq!(next, list.len());
 8991|       |
 8992|      1|        let quote = vec![
 8993|      1|            Event::Start(Tag::BlockQuote),
 8994|      1|            Event::Start(Tag::Paragraph),
 8995|      1|            Event::Text("quote".into()),
 8996|      1|            Event::End(Tag::Paragraph),
 8997|      1|            Event::End(Tag::BlockQuote),
 8998|       |        ];
 8999|      1|        let next = renderer.parse_element(&quote, 0, &mut elements, &mut slugs)?;
                                                                                             ^0
 9000|      1|        assert_eq!(next, quote.len());
 9001|       |
 9002|      1|        let table = vec![
 9003|      1|            Event::Start(Tag::Table(vec![Alignment::Left])),
 9004|      1|            Event::Start(Tag::TableHead),
 9005|      1|            Event::Start(Tag::TableRow),
 9006|      1|            Event::Start(Tag::TableCell),
 9007|      1|            Event::Text("H".into()),
 9008|      1|            Event::End(Tag::TableCell),
 9009|      1|            Event::End(Tag::TableRow),
 9010|      1|            Event::End(Tag::TableHead),
 9011|      1|            Event::Start(Tag::TableRow),
 9012|      1|            Event::Start(Tag::TableCell),
 9013|      1|            Event::Text("R".into()),
 9014|      1|            Event::End(Tag::TableCell),
 9015|      1|            Event::End(Tag::TableRow),
 9016|      1|            Event::End(Tag::Table(vec![Alignment::Left])),
 9017|       |        ];
 9018|      1|        let next = renderer.parse_element(&table, 0, &mut elements, &mut slugs)?;
                                                                                             ^0
 9019|      1|        assert_eq!(next, table.len());
 9020|       |
 9021|      1|        let rule = vec![Event::Rule];
 9022|      1|        let next = renderer.parse_element(&rule, 0, &mut elements, &mut slugs)?;
                                                                                            ^0
 9023|      1|        assert_eq!(next, rule.len());
 9024|      1|        Ok(())
 9025|      1|    }
 9026|       |
 9027|       |    #[test]
 9028|      1|    fn test_parse_code_block_with_language() -> Result<()> {
 9029|      1|        let renderer = MarkdownRenderer::new();
 9030|      1|        let elements = renderer.parse("Intro\n\n```rust\nfn main() {}\n```")?;
                                                                                          ^0
 9031|      1|        let mut rust_lang = None;
 9032|      3|        for element in &elements {
                          ^2
 9033|      2|            if let MarkdownElement::CodeBlock { language, .. } = element {
                                                              ^1
 9034|      1|                rust_lang = language.as_deref();
 9035|      1|            }
 9036|       |        }
 9037|      1|        assert_eq!(rust_lang, Some("rust"));
 9038|      1|        Ok(())
 9039|      1|    }
 9040|       |
 9041|       |    #[test]
 9042|      1|    fn test_parse_code_block_empty_language() -> Result<()> {
 9043|      1|        let renderer = MarkdownRenderer::new();
 9044|      1|        let events = vec![
 9045|      1|            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 9046|      1|                "".into(),
 9047|      1|            ))),
 9048|      1|            Event::Text("fn main() {}".into()),
 9049|      1|            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 9050|      1|                "".into(),
 9051|      1|            ))),
 9052|       |        ];
 9053|      1|        let (code, language, next) = renderer.parse_code_block(&events, 0)?;
                                                                                        ^0
 9054|      1|        assert_eq!(language, None);
 9055|      1|        assert_eq!(code, "fn main() {}");
 9056|      1|        assert_eq!(next, events.len());
 9057|      1|        Ok(())
 9058|      1|    }
 9059|       |
 9060|       |    #[test]
 9061|      1|    fn test_parse_code_block_indented() -> Result<()> {
 9062|      1|        let renderer = MarkdownRenderer::new();
 9063|      1|        let events = vec![
 9064|      1|            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Indented)),
 9065|      1|            Event::Text("let x = 1;".into()),
 9066|      1|            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Indented)),
 9067|       |        ];
 9068|      1|        let (code, language, next) = renderer.parse_code_block(&events, 0)?;
                                                                                        ^0
 9069|      1|        assert_eq!(language, None);
 9070|      1|        assert_eq!(code, "let x = 1;");
 9071|      1|        assert_eq!(next, events.len());
 9072|      1|        Ok(())
 9073|      1|    }
 9074|       |
 9075|       |    #[test]
 9076|      1|    fn test_parse_table_from_markdown() -> Result<()> {
 9077|      1|        let renderer = MarkdownRenderer::new();
 9078|      1|        let md = "| H1 | H2 |\n| --- | --- |\n| A | B |\n| C | D |\n";
 9079|      1|        let elements = renderer.parse(md)?;
                                                       ^0
 9080|      1|        assert!(elements
 9081|      1|            .iter()
 9082|      1|            .any(|el| matches!(el, MarkdownElement::Table { .. })));
 9083|      1|        Ok(())
 9084|      1|    }
 9085|       |
 9086|       |    #[test]
 9087|      1|    fn test_hash_inline_spans_variants() {
 9088|      1|        let spans = vec![
 9089|      1|            InlineSpan::Text("t".to_string()),
 9090|      1|            InlineSpan::Code("c".to_string()),
 9091|      1|            InlineSpan::Strong("s".to_string()),
 9092|      1|            InlineSpan::Emphasis("e".to_string()),
 9093|      1|            InlineSpan::Strikethrough("x".to_string()),
 9094|      1|            InlineSpan::Link {
 9095|      1|                text: "link".to_string(),
 9096|      1|                url: "https://example.com".to_string(),
 9097|      1|            },
 9098|      1|            InlineSpan::Image {
 9099|      1|                src: "img.png".to_string(),
 9100|      1|                alt: "alt".to_string(),
 9101|      1|                title: Some("title".to_string()),
 9102|      1|            },
 9103|       |        ];
 9104|      1|        let hash = MarkdownRenderer::hash_inline_spans(&spans);
 9105|      1|        let hash2 = MarkdownRenderer::hash_inline_spans(&[InlineSpan::Text("other".to_string())]);
 9106|      1|        assert_ne!(hash, hash2);
 9107|      1|    }
 9108|       |
 9109|       |    #[test]
 9110|      1|    fn test_highlight_segments_edge_cases() {
 9111|      1|        let renderer = MarkdownRenderer::new();
 9112|      1|        assert!(renderer.highlight_segments("", Some("a")).is_empty());
 9113|      1|        assert_eq!(
 9114|      1|            renderer.highlight_segments("abc", None),
 9115|      1|            vec![(0..3, false)]
 9116|       |        );
 9117|      1|        assert_eq!(
 9118|      1|            renderer.highlight_segments("abc", Some("")),
 9119|      1|            vec![(0..3, false)]
 9120|       |        );
 9121|      1|        let segments = renderer.highlight_segments("Hello", Some("ell"));
 9122|      1|        assert!(segments.iter().any(|(_, highlighted)| *highlighted));
 9123|      1|    }
 9124|       |
 9125|       |    #[test]
 9126|      1|    fn test_resolve_table_widths_branches() {
 9127|      1|        assert!(MarkdownRenderer::resolve_table_widths(50.0, &[], &[]).is_empty());
 9128|      1|        assert_eq!(
 9129|      1|            MarkdownRenderer::resolve_table_widths(100.0, &[10.0, 10.0], &[20.0, 30.0]),
 9130|      1|            vec![20.0, 30.0]
 9131|       |        );
 9132|       |
 9133|      1|        assert_eq!(
 9134|      1|            MarkdownRenderer::resolve_table_widths(10.0, &[0.0, 0.0], &[0.0, 0.0]),
 9135|      1|            vec![5.0, 5.0]
 9136|       |        );
 9137|       |
 9138|      1|        assert_eq!(
 9139|      1|            MarkdownRenderer::resolve_table_widths(10.0, &[10.0, 10.0], &[20.0, 20.0]),
 9140|      1|            vec![5.0, 5.0]
 9141|       |        );
 9142|       |
 9143|      1|        assert_eq!(
 9144|      1|            MarkdownRenderer::resolve_table_widths(30.0, &[10.0, 10.0], &[10.0, 10.0]),
 9145|      1|            vec![15.0, 15.0]
 9146|       |        );
 9147|       |
 9148|      1|        let widths = MarkdownRenderer::resolve_table_widths(30.0, &[10.0, 10.0], &[20.0, 30.0]);
 9149|      1|        assert_eq!(widths.len(), 2);
 9150|      1|        assert!((widths[0] + widths[1] - 30.0).abs() < 0.1);
 9151|      1|    }
 9152|       |
 9153|       |    #[test]
 9154|      1|    fn test_table_line_breaks_case_parses_all_rows() -> Result<()> {
 9155|      1|        let renderer = MarkdownRenderer::new();
 9156|      1|        let md = fs::read_to_string("tests/regression/cases/017-table-line-breaks.md")?;
                                                                                                    ^0
 9157|      1|        let elements = renderer.parse(&md)?;
                                                        ^0
 9158|      2|        let rows = elements.iter().find_map(|el| match el {
                          ^1     ^1              ^1
 9159|      1|            MarkdownElement::Table { rows, .. } => Some(rows),
 9160|      1|            _ => None,
 9161|      2|        });
 9162|      1|        let rows = rows.expect("table present");
 9163|      1|        assert_eq!(rows.len(), 7);
 9164|      1|        let plain = MarkdownRenderer::elements_to_plain_text(&elements);
 9165|      1|        assert!(plain.contains("Strong"));
 9166|      1|        assert!(plain.contains("Attr"));
 9167|      1|        Ok(())
 9168|      1|    }
 9169|       |
 9170|       |    #[test]
 9171|      1|    fn test_table_line_breaks_case_renders_all_rows() -> Result<()> {
 9172|      1|        let renderer = MarkdownRenderer::new();
 9173|      1|        let md = fs::read_to_string("tests/regression/cases/017-table-line-breaks.md")?;
                                                                                                    ^0
 9174|      1|        let elements = renderer.parse(&md)?;
                                                        ^0
 9175|      1|        with_test_ui(|ctx, ui| {
 9176|      1|            ctx.set_visuals(egui::Visuals::light());
 9177|      1|            renderer.render_to_ui(ui, &elements);
 9178|      1|        });
 9179|      1|        let (rendered, total) = renderer.table_render_stats();
 9180|      1|        assert_eq!(rendered, total);
 9181|      1|        assert_eq!(rendered, 7);
 9182|      1|        Ok(())
 9183|      1|    }
 9184|       |
 9185|       |    #[test]
 9186|      1|    fn test_table_first_column_alignment_case_parses_columns() -> Result<()> {
 9187|      1|        let renderer = MarkdownRenderer::new();
 9188|      1|        let md = fs::read_to_string("tests/regression/cases/026-table-first-column-align.md")?;
                                                                                                           ^0
 9189|      1|        let elements = renderer.parse(&md)?;
                                                        ^0
 9190|      3|        let mut tables = elements.iter().filter_map(|el| match el {
                          ^1           ^1              ^1
 9191|       |            MarkdownElement::Table {
 9192|      1|                headers,
 9193|      1|                rows,
 9194|      1|                alignments,
 9195|      1|            } => Some((headers, rows, alignments)),
 9196|      2|            _ => None,
 9197|      3|        });
 9198|      1|        let (headers, rows, alignments) = tables.next().expect("expected table");
 9199|      1|        assert_eq!(headers.len(), 3);
 9200|      1|        assert_eq!(alignments.len(), 3);
 9201|      3|        assert!(rows.iter().all(|row| row.len() == 3));
                      ^1      ^1          ^1
 9202|      1|        Ok(())
 9203|      1|    }
 9204|       |
 9205|       |    #[test]
 9206|      1|    fn test_handle_width_change_requests_repaint() {
 9207|      1|        let renderer = MarkdownRenderer::new();
 9208|      1|        let ctx = egui::Context::default();
 9209|      1|        renderer.handle_width_change(&ctx, 42, WidthChange::Large);
 9210|      1|        let metrics = renderer.table_metrics.borrow();
 9211|      1|        let entry = metrics.entry(42).expect("metrics entry");
 9212|      1|        assert!(entry.last_discard_frame.is_some());
 9213|      1|    }
 9214|       |
 9215|       |    #[test]
 9216|      1|    fn test_handle_width_change_skips_duplicate_frame() {
 9217|      1|        let renderer = MarkdownRenderer::new();
 9218|      1|        let ctx = egui::Context::default();
 9219|      1|        renderer.handle_width_change(&ctx, 42, WidthChange::Large);
 9220|      1|        renderer.handle_width_change(&ctx, 42, WidthChange::Large);
 9221|      1|        let metrics = renderer.table_metrics.borrow();
 9222|      1|        let entry = metrics.entry(42).expect("metrics entry");
 9223|      1|        assert_eq!(entry.last_discard_frame, Some(ctx.frame_nr()));
 9224|      1|    }
 9225|       |
 9226|       |    #[test]
 9227|      1|    fn test_render_list_multiline_indent_and_empty() {
 9228|      1|        let renderer = MarkdownRenderer::new();
 9229|      1|        let spans = vec![InlineSpan::Text("First\n  Nested".to_string())];
 9230|      1|        let item = ListItem {
 9231|      1|            blocks: vec![MarkdownElement::Paragraph(spans.clone())],
 9232|      1|        };
 9233|      1|        with_test_ui(|ctx, ui| {
 9234|      1|            ctx.set_visuals(egui::Visuals::light());
 9235|      1|            renderer.render_list(ui, false, &[]);
 9236|      1|            renderer.render_list(ui, true, std::slice::from_ref(&item));
 9237|      1|        });
 9238|      1|    }
 9239|       |
 9240|       |    #[test]
 9241|      1|    fn test_render_list_paragraph_handles_blank_parts_and_indent() {
 9242|      1|        let renderer = MarkdownRenderer::new();
 9243|      1|        let spans = vec![
 9244|      1|            InlineSpan::Text("Line 1\n\n  indented".to_string()),
 9245|      1|            InlineSpan::Image {
 9246|      1|                src: "assets/emoji/1f600.png".to_string(),
 9247|      1|                alt: "img".to_string(),
 9248|      1|                title: None,
 9249|      1|            },
 9250|       |        ];
 9251|      1|        with_test_ui(|_, ui| {
 9252|      1|            renderer.render_list_paragraph(ui, None, Color32::WHITE, 12.0, &spans);
 9253|      1|        });
 9254|      1|    }
 9255|       |
 9256|       |    #[test]
 9257|      1|    fn test_render_list_paragraph_multiline_without_leading_spaces() {
 9258|      1|        let renderer = MarkdownRenderer::new();
 9259|      1|        let spans = vec![InlineSpan::Text("Line 1\nLine 2".to_string())];
 9260|      1|        with_test_ui(|_, ui| {
 9261|      1|            renderer.render_list_paragraph(ui, None, Color32::WHITE, 12.0, &spans);
 9262|      1|        });
 9263|      1|    }
 9264|       |
 9265|       |    #[test]
 9266|      1|    fn test_render_inline_span_image_hover_caption_uses_cached_texture() {
 9267|      1|        let renderer = MarkdownRenderer::new();
 9268|      1|        let span = InlineSpan::Image {
 9269|      1|            src: "assets/emoji/1f600.png".to_string(),
 9270|      1|            alt: "alt".to_string(),
 9271|      1|            title: Some("Caption".to_string()),
 9272|      1|        };
 9273|      1|        let _guard = ForcedRenderActions::new(&["image_hover"]);
 9274|      1|        with_test_ui(|_, ui| {
 9275|      1|            let image = egui::ColorImage::new([2, 2], Color32::WHITE);
 9276|      1|            let texture = ui.ctx().load_texture(
 9277|       |                "test-inline-image-hover",
 9278|      1|                image,
 9279|       |                egui::TextureOptions::LINEAR,
 9280|       |            );
 9281|      1|            renderer.store_image_texture("assets/emoji/1f600.png", texture, [2, 2], None);
 9282|      1|            renderer.render_inline_span(ui, &span, None, None);
 9283|      1|        });
 9284|      1|    }
 9285|       |
 9286|       |    #[test]
 9287|      1|    fn test_render_inline_span_forced_actions_and_image_title() {
 9288|      1|        let renderer = MarkdownRenderer::new();
 9289|      1|        renderer.set_highlight_phrase(Some("hi"));
 9290|      1|        let image_span = InlineSpan::Image {
 9291|      1|            src: "assets/emoji/1f600.png".to_string(),
 9292|      1|            alt: "alt".to_string(),
 9293|      1|            title: Some("Caption".to_string()),
 9294|      1|        };
 9295|      1|        let missing_span = InlineSpan::Image {
 9296|      1|            src: "missing.png".to_string(),
 9297|      1|            alt: "missing".to_string(),
 9298|      1|            title: None,
 9299|      1|        };
 9300|      1|        let link_span = InlineSpan::Link {
 9301|      1|            text: "hi link".to_string(),
 9302|      1|            url: "https://example.com".to_string(),
 9303|      1|        };
 9304|      1|        let _guard = ForcedRenderActions::new(&["link_hover", "link_click", "image_hover"]);
 9305|      1|        with_test_ui(|_, ui| {
 9306|      1|            renderer.render_inline_span(
 9307|      1|                ui,
 9308|      1|                &InlineSpan::Text("hi \u{1f600}".to_string()),
 9309|      1|                None,
 9310|      1|                None,
 9311|       |            );
 9312|      1|            renderer.render_inline_span(ui, &InlineSpan::Strong("hi".to_string()), None, None);
 9313|      1|            renderer.render_inline_span(ui, &InlineSpan::Emphasis("hi".to_string()), None, None);
 9314|      1|            renderer.render_inline_span(
 9315|      1|                ui,
 9316|      1|                &InlineSpan::Strikethrough("hi".to_string()),
 9317|      1|                None,
 9318|      1|                None,
 9319|       |            );
 9320|      1|            renderer.render_inline_span(ui, &InlineSpan::Code("code".to_string()), None, None);
 9321|      1|            renderer.render_inline_span(ui, &link_span, None, None);
 9322|      1|            renderer.render_inline_span(ui, &image_span, None, None);
 9323|      1|            renderer.render_inline_span(ui, &missing_span, None, None);
 9324|      1|        });
 9325|      1|    }
 9326|       |
 9327|       |    #[test]
 9328|      1|    fn test_get_or_load_image_texture_embedded_and_remote() {
 9329|      1|        let renderer = MarkdownRenderer::new();
 9330|      1|        with_test_ui(|ctx, ui| {
 9331|      1|            let embedded = wait_for_image(&renderer, ctx, ui, "assets/emoji/1f600.png");
 9332|      1|            assert!(embedded.is_some());
 9333|      1|            let remote = renderer.get_or_load_image_texture(ui, "https://example.com/img.png");
 9334|      1|            assert!(remote.is_none());
 9335|      1|        });
 9336|      1|    }
 9337|       |
 9338|       |    #[test]
 9339|      1|    fn test_get_or_load_image_texture_embedded_cache_hit() {
 9340|      1|        let renderer = MarkdownRenderer::new();
 9341|      1|        with_test_ui(|ctx, ui| {
 9342|      1|            let tex = ctx.load_texture(
 9343|       |                "embedded-cache",
 9344|      1|                egui::ColorImage::new([2, 2], Color32::WHITE),
 9345|      1|                Default::default(),
 9346|       |            );
 9347|      1|            renderer.store_image_texture("assets/emoji/1f600.png", tex, [2, 2], None);
 9348|      1|            let loaded = renderer.get_or_load_image_texture(ui, "assets/emoji/1f600.png");
 9349|      1|            assert!(loaded.is_some());
 9350|      1|        });
 9351|      1|    }
 9352|       |
 9353|       |    #[test]
 9354|      1|    fn test_get_or_load_image_texture_skips_recent_failure() {
 9355|      1|        let renderer = MarkdownRenderer::new();
 9356|      1|        with_test_ui(|_, ui| {
 9357|      1|            renderer.note_image_failure("missing.png");
 9358|      1|            let loaded = renderer.get_or_load_image_texture(ui, "missing.png");
 9359|      1|            assert!(loaded.is_none());
 9360|      1|            assert!(renderer.image_failures.borrow().contains_key("missing.png"));
 9361|      1|        });
 9362|      1|    }
 9363|       |
 9364|       |    #[test]
 9365|      1|    fn test_get_or_load_image_texture_skips_pending() {
 9366|      1|        let renderer = MarkdownRenderer::new();
 9367|      1|        with_test_ui(|_, ui| {
 9368|      1|            renderer
 9369|      1|                .image_pending
 9370|      1|                .borrow_mut()
 9371|      1|                .insert("pending.png".to_string());
 9372|      1|            let loaded = renderer.get_or_load_image_texture(ui, "pending.png");
 9373|      1|            assert!(loaded.is_none());
 9374|      1|        });
 9375|      1|    }
 9376|       |
 9377|       |    #[test]
 9378|      1|    fn test_render_inline_span_loaded_image_without_title() {
 9379|      1|        let renderer = MarkdownRenderer::new();
 9380|      1|        let span = InlineSpan::Image {
 9381|      1|            src: "assets/emoji/1f600.png".to_string(),
 9382|      1|            alt: "".to_string(),
 9383|      1|            title: None,
 9384|      1|        };
 9385|      1|        with_test_ui(|ctx, ui| {
 9386|      1|            let _ = wait_for_image(&renderer, ctx, ui, "assets/emoji/1f600.png");
 9387|      1|            renderer.render_inline_span(ui, &span, None, None);
 9388|      1|        });
 9389|      1|    }
 9390|       |
 9391|       |    #[test]
 9392|      1|    fn test_get_or_make_emoji_texture_cache() {
 9393|      1|        let renderer = MarkdownRenderer::new();
 9394|      1|        with_test_ui(|_, ui| {
 9395|      1|            let tex = renderer.get_or_make_emoji_texture(ui, "\u{1f600}");
 9396|      1|            assert!(tex.size()[0] > 0);
 9397|      1|            let cached = renderer.get_or_make_emoji_texture(ui, "\u{1f600}");
 9398|      1|            assert_eq!(cached.size(), tex.size());
 9399|      1|        });
 9400|      1|    }
 9401|       |
 9402|       |    #[test]
 9403|      1|    fn test_get_or_make_emoji_texture_unknown_fallbacks() {
 9404|      1|        let renderer = MarkdownRenderer::new();
 9405|      1|        with_test_ui(|_, ui| {
 9406|      1|            let tex = renderer.get_or_make_emoji_texture(ui, "not-emoji");
 9407|      1|            assert!(tex.size()[0] > 0);
 9408|      1|        });
 9409|      1|    }
 9410|       |
 9411|       |    #[test]
 9412|      1|    fn test_render_overhauled_cell_fragments() {
 9413|      1|        let renderer = MarkdownRenderer::new();
 9414|      1|        let emoji_span = InlineSpan::Text("\u{1f600}".to_string());
 9415|      1|        let image_span = InlineSpan::Image {
 9416|      1|            src: "assets/emoji/1f600.png".to_string(),
 9417|      1|            alt: "alt".to_string(),
 9418|      1|            title: None,
 9419|      1|        };
 9420|      1|        with_test_ui(|_, ui| {
 9421|      1|            renderer.render_overhauled_cell(ui, &[], 120.0, false, Some(0), 0, Align::LEFT);
 9422|      1|            renderer.render_overhauled_cell(
 9423|      1|                ui,
 9424|      1|                &[emoji_span.clone(), image_span.clone()],
 9425|       |                120.0,
 9426|       |                false,
 9427|      1|                Some(1),
 9428|       |                1,
 9429|       |                Align::LEFT,
 9430|       |            );
 9431|      1|        });
 9432|      1|    }
 9433|       |
 9434|       |    #[test]
 9435|      1|    fn test_paint_table_text_job_link_interaction() {
 9436|      1|        let renderer = MarkdownRenderer::new();
 9437|      1|        let spans = vec![InlineSpan::Link {
 9438|      1|            text: "Click here for more text".to_string(),
 9439|      1|            url: "https://example.com".to_string(),
 9440|      1|        }];
 9441|      1|        let ctx = egui::Context::default();
 9442|      1|        let click_pos = egui::pos2(5.0, 5.0);
 9443|       |
 9444|      1|        let input = input_with_click(click_pos, egui::PointerButton::Secondary);
 9445|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 9446|      1|            ui.allocate_ui_at_rect(
 9447|      1|                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
 9448|      1|                |ui| {
 9449|      1|                    let build =
 9450|      1|                        renderer.build_layout_job(ui.style(), &spans, 30.0, false, Align::LEFT);
 9451|      1|                    renderer.paint_table_text_job(ui, 120.0, build);
 9452|      1|                },
 9453|       |            );
 9454|      1|        });
 9455|       |
 9456|      1|        let input = input_with_click(click_pos, egui::PointerButton::Primary);
 9457|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 9458|      1|            ui.allocate_ui_at_rect(
 9459|      1|                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
 9460|      1|                |ui| {
 9461|      1|                    let build =
 9462|      1|                        renderer.build_layout_job(ui.style(), &spans, 30.0, false, Align::LEFT);
 9463|      1|                    renderer.paint_table_text_job(ui, 120.0, build);
 9464|      1|                },
 9465|       |            );
 9466|      1|        });
 9467|      1|    }
 9468|       |
 9469|       |    #[test]
 9470|      1|    fn test_aligned_text_origin_anchors_to_rect() {
 9471|      1|        let rect = egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(100.0, 20.0));
 9472|      1|        let galley = Arc::new(Galley {
 9473|      1|            job: Arc::new(LayoutJob::default()),
 9474|      1|            rows: Vec::new(),
 9475|      1|            elided: false,
 9476|      1|            rect: egui::Rect::from_min_max(egui::pos2(0.0, 0.0), egui::pos2(20.0, 10.0)),
 9477|      1|            mesh_bounds: egui::Rect::NOTHING,
 9478|      1|            num_vertices: 0,
 9479|      1|            num_indices: 0,
 9480|      1|            pixels_per_point: 1.0,
 9481|      1|        });
 9482|      1|        let left_origin = MarkdownRenderer::aligned_text_origin(rect, &galley, Align::LEFT);
 9483|      1|        let center_origin = MarkdownRenderer::aligned_text_origin(rect, &galley, Align::Center);
 9484|      1|        let right_origin = MarkdownRenderer::aligned_text_origin(rect, &galley, Align::RIGHT);
 9485|       |
 9486|      1|        assert_eq!(left_origin.x, rect.left());
 9487|      1|        assert_eq!(center_origin.x, rect.center().x - galley.rect.center().x);
 9488|      1|        assert_eq!(right_origin.x, rect.right() - galley.rect.right());
 9489|      1|        assert_eq!(left_origin.y, rect.top());
 9490|      1|    }
 9491|       |
 9492|       |    #[test]
 9493|      1|    fn test_layout_job_center_rect_is_origin() {
 9494|      1|        let renderer = MarkdownRenderer::new();
 9495|      1|        let spans = vec![InlineSpan::Text("Item".to_string())];
 9496|      1|        with_test_ui(|_, ui| {
 9497|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, true, Align::Center);
 9498|      1|            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
 9499|      1|            assert!(galley.rect.center().x.abs() <= 0.01);
 9500|      1|        });
 9501|      1|    }
 9502|       |
 9503|       |    #[test]
 9504|      1|    fn test_render_table_tablebuilder_variants() {
 9505|      1|        let renderer = MarkdownRenderer::new();
 9506|      1|        let headers = vec![vec![InlineSpan::Text("H1".to_string())]];
 9507|      1|        let rows = vec![vec![
 9508|      1|            vec![InlineSpan::Text("A".to_string())],
 9509|      1|            vec![InlineSpan::Text("B".to_string())],
 9510|       |        ]];
 9511|      1|        with_test_ui(|_, ui| {
 9512|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 0);
 9513|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
 9514|      1|            let empty_id = renderer.compute_table_id(&headers, &[], &[], 1);
 9515|      1|            renderer.render_table_tablebuilder(ui, &headers, &[], &[], empty_id);
 9516|      1|        });
 9517|      1|    }
 9518|       |
 9519|       |    #[test]
 9520|      1|    fn test_render_code_block_context_menu_clicks() {
 9521|      1|        let renderer = MarkdownRenderer::new();
 9522|      1|        let ctx = egui::Context::default();
 9523|      1|        let input = input_with_click(egui::pos2(5.0, 5.0), egui::PointerButton::Primary);
 9524|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 9525|      1|            ui.allocate_ui_at_rect(
 9526|      1|                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
 9527|      1|                |ui| {
 9528|      1|                    renderer.render_code_block_context_menu(ui, "code", Some("rust"));
 9529|      1|                },
 9530|       |            );
 9531|      1|        });
 9532|       |
 9533|      1|        let input = input_with_click(egui::pos2(5.0, 30.0), egui::PointerButton::Primary);
 9534|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 9535|      1|            ui.allocate_ui_at_rect(
 9536|      1|                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
 9537|      1|                |ui| {
 9538|      1|                    renderer.render_code_block_context_menu(ui, "code", Some("rust"));
 9539|      1|                },
 9540|       |            );
 9541|      1|        });
 9542|      1|    }
 9543|       |
 9544|       |    #[test]
 9545|      1|    fn test_find_syntax_for_language() {
 9546|      1|        let renderer = MarkdownRenderer::new();
 9547|      1|        assert!(renderer.find_syntax_for_language("rust").is_some());
 9548|      1|        assert!(renderer.find_syntax_for_language("nonexistent").is_none());
 9549|      1|    }
 9550|       |
 9551|       |    #[test]
 9552|      1|    fn test_find_syntax_for_language_direct_name_match() -> Result<()> {
 9553|      1|        let mut renderer = MarkdownRenderer::new();
 9554|      1|        let syntax = SyntaxDefinition::load_from_str(
 9555|      1|            r#"
 9556|      1|name: testlang
 9557|      1|scope: source.testlang
 9558|      1|file_extensions: [tst]
 9559|      1|contexts:
 9560|      1|  main:
 9561|      1|    - match: '.'
 9562|      1|      scope: source.testlang
 9563|      1|"#,
 9564|       |            true,
 9565|      1|            None,
 9566|       |        )
 9567|      1|        .expect("syntax");
 9568|      1|        let mut builder = renderer.syntax_set.clone().into_builder();
 9569|      1|        builder.add(syntax);
 9570|      1|        renderer.syntax_set = builder.build();
 9571|      1|        assert!(renderer.find_syntax_for_language("testlang").is_some());
 9572|      1|        Ok(())
 9573|      1|    }
 9574|       |
 9575|       |    #[test]
 9576|      1|    fn test_find_syntax_for_language_mappings() {
 9577|      1|        let renderer = MarkdownRenderer::new();
 9578|      1|        assert!(renderer.find_syntax_for_language("markdown").is_some());
 9579|      1|        assert!(renderer.find_syntax_for_language("shell").is_some());
 9580|      1|        assert!(renderer.find_syntax_for_language("yaml").is_some());
 9581|      1|    }
 9582|       |
 9583|       |    #[test]
 9584|      1|    fn test_find_syntax_for_language_mapped_names() {
 9585|      1|        let renderer = MarkdownRenderer::new();
 9586|      1|        let langs = [
 9587|      1|            "python",
 9588|      1|            "javascript",
 9589|      1|            "typescript",
 9590|      1|            "c++",
 9591|      1|            "cpp",
 9592|      1|            "c#",
 9593|      1|            "shell",
 9594|      1|            "bash",
 9595|      1|            "powershell",
 9596|      1|            "yaml",
 9597|      1|            "markdown",
 9598|      1|            "sql",
 9599|      1|            "toml",
 9600|      1|        ];
 9601|     14|        for lang in langs {
                          ^13
 9602|     13|            let _ = renderer.find_syntax_for_language(lang);
 9603|     13|        }
 9604|      1|    }
 9605|       |
 9606|       |    #[test]
 9607|      1|    fn test_estimate_table_image_height_with_title() {
 9608|      1|        let renderer = MarkdownRenderer::new();
 9609|      1|        let span = InlineSpan::Image {
 9610|      1|            src: "assets/samples/logo.svg".to_string(),
 9611|      1|            alt: "logo".to_string(),
 9612|      1|            title: Some("Caption".to_string()),
 9613|      1|        };
 9614|      1|        with_test_ui(|_, ui| {
 9615|      1|            let height = renderer.estimate_table_image_height(ui, &span, 120.0);
 9616|      1|            assert!(height > 0.0);
 9617|      1|            let fallback = renderer.estimate_table_image_height(
 9618|      1|                ui,
 9619|      1|                &InlineSpan::Text("text".to_string()),
 9620|       |                120.0,
 9621|       |            );
 9622|      1|            assert!(fallback > 0.0);
 9623|      1|        });
 9624|      1|    }
 9625|       |
 9626|       |    #[test]
 9627|      1|    fn test_render_table_emoji() {
 9628|      1|        let renderer = MarkdownRenderer::new();
 9629|      1|        with_test_ui(|_, ui| {
 9630|      1|            renderer.render_table_emoji(ui, "\u{1f600}");
 9631|      1|        });
 9632|      1|    }
 9633|       |
 9634|       |    #[test]
 9635|      1|    fn test_render_list_block_non_paragraph() {
 9636|      1|        let renderer = MarkdownRenderer::new();
 9637|      1|        let block = MarkdownElement::CodeBlock {
 9638|      1|            language: Some("rust".to_string()),
 9639|      1|            text: "fn main() {}".to_string(),
 9640|      1|        };
 9641|      1|        with_test_ui(|_, ui| {
 9642|      1|            renderer.render_list_block(ui, &block, 12.0, Color32::WHITE);
 9643|      1|        });
 9644|      1|    }
 9645|       |
 9646|       |    #[test]
 9647|      1|    fn test_measure_inline_spans_with_image() {
 9648|      1|        let renderer = MarkdownRenderer::new();
 9649|      1|        let spans = vec![InlineSpan::Image {
 9650|      1|            src: "assets/samples/logo.svg".to_string(),
 9651|      1|            alt: "logo".to_string(),
 9652|      1|            title: None,
 9653|      1|        }];
 9654|      1|        with_test_ui(|_, ui| {
 9655|      1|            let width = renderer.measure_inline_spans(ui, &spans);
 9656|      1|            assert!(width > 0.0);
 9657|      1|        });
 9658|      1|    }
 9659|       |
 9660|       |    #[test]
 9661|      1|    fn test_parse_blockquote_with_nested_blocks() {
 9662|      1|        let renderer = MarkdownRenderer::new();
 9663|      1|        let md = r#"> # Quote Heading
 9664|      1|> Paragraph **bold** *em* ~~strike~~ [link](https://example.com)
 9665|      1|> ![alt](assets/samples/logo.svg "Logo")
 9666|      1|> - Item one
 9667|      1|>   - Nested item
 9668|      1|> 
 9669|      1|> ```rust
 9670|      1|> let x = 1;
 9671|      1|> ```
 9672|      1|> 
 9673|      1|> | H1 | H2 |
 9674|      1|> | --- | --- |
 9675|      1|> |  | ![a](assets/samples/logo.svg "Img") |
 9676|      1|"#;
 9677|      1|        let elements = renderer.parse(md).expect("parse");
 9678|      1|        assert!(elements
 9679|      1|            .iter()
 9680|      1|            .any(|e| matches!(e, MarkdownElement::Quote { .. })));
 9681|      1|    }
 9682|       |
 9683|       |    #[test]
 9684|      1|    fn test_parse_list_with_heading_and_table() {
 9685|      1|        let renderer = MarkdownRenderer::new();
 9686|      1|        let md = r#"- # Item heading
 9687|      1|  Paragraph text with `code` and **strong**
 9688|      1|  - Nested child
 9689|      1|- | A | B |
 9690|      1|  | - | - |
 9691|      1|  | 1 | 2 |
 9692|      1|- ```rust
 9693|      1|  fn main() {}
 9694|      1|  ```
 9695|      1|- > Quote in list
 9696|      1|- ---
 9697|      1|"#;
 9698|      1|        let elements = renderer.parse(md).expect("parse");
 9699|      1|        assert!(elements
 9700|      1|            .iter()
 9701|      1|            .any(|e| matches!(e, MarkdownElement::List { .. })));
 9702|      1|    }
 9703|       |
 9704|       |    #[test]
 9705|      1|    fn test_parse_list_inline_variants() {
 9706|      1|        let renderer = MarkdownRenderer::new();
 9707|      1|        let md = r#"- Item with *em* **strong** ~~strike~~ `code` [link](https://example.com) ![alt](assets/emoji/1f600.png "title")  
 9708|      1|  next line"#;
 9709|      1|        let elements = renderer.parse(md).expect("parse");
 9710|      1|        assert!(elements
 9711|      1|            .iter()
 9712|      1|            .any(|e| matches!(e, MarkdownElement::List { .. })));
 9713|      1|    }
 9714|       |
 9715|       |    #[test]
 9716|      1|    fn test_parse_blockquote_with_varied_content() -> Result<()> {
 9717|      1|        let renderer = MarkdownRenderer::new();
 9718|      1|        let md = r#"
 9719|      1|> ### Quote Heading
 9720|      1|> Paragraph with *em* **strong** ~~strike~~ `code` [link](https://example.com) ![alt](assets/emoji/1f600.png "title")  
 9721|      1|> Next line<br>
 9722|      1|>
 9723|      1|> - item one
 9724|      1|> - item two
 9725|      1|>
 9726|      1|> | h1 | h2 |
 9727|      1|> | --- | --- |
 9728|      1|> | a | b |
 9729|      1|>
 9730|      1|> ```rust
 9731|      1|> fn main() {
 9732|      1|>     // comment
 9733|      1|> }
 9734|      1|> ```
 9735|      1|>
 9736|      1|> > Nested quote
 9737|      1|>
 9738|      1|> ---
 9739|      1|"#;
 9740|      1|        let elements = renderer.parse(md)?;
                                                       ^0
 9741|      1|        assert!(elements
 9742|      1|            .iter()
 9743|      1|            .any(|e| matches!(e, MarkdownElement::Quote { .. })));
 9744|      1|        Ok(())
 9745|      1|    }
 9746|       |
 9747|       |    #[test]
 9748|      1|    fn test_find_syntax_for_language_variants() {
 9749|      1|        let renderer = MarkdownRenderer::new();
 9750|      1|        assert!(renderer.find_syntax_for_language("rs").is_some());
 9751|      1|        let cs_ext = renderer.syntax_set.find_syntax_by_extension("cs");
 9752|      1|        let cs_lang = renderer.find_syntax_for_language("csharp");
 9753|      1|        assert_eq!(cs_lang.is_some(), cs_ext.is_some());
 9754|      1|        let ps_ext = renderer.syntax_set.find_syntax_by_extension("ps1");
 9755|      1|        let ps_lang = renderer.find_syntax_for_language("powershell");
 9756|      1|        assert_eq!(ps_lang.is_some(), ps_ext.is_some());
 9757|      1|        assert!(renderer.find_syntax_for_language("madeuplang").is_none());
 9758|      1|    }
 9759|       |
 9760|       |    #[test]
 9761|      1|    fn test_generate_emoji_image_variants() {
 9762|      1|        let renderer = MarkdownRenderer::new();
 9763|      1|        let emojis = [
 9764|      1|            "\u{1f389}",
 9765|      1|            "\u{2705}",
 9766|      1|            "\u{1f680}",
 9767|      1|            "\u{1f642}",
 9768|      1|            "\u{1f600}",
 9769|      1|            "\u{1f609}",
 9770|      1|            "\u{2b50}",
 9771|      1|            "\u{1f525}",
 9772|      1|            "\u{1f44d}",
 9773|      1|            "\u{1f44e}",
 9774|      1|            "\u{1f4a1}",
 9775|      1|            "\u{2753}",
 9776|      1|            "\u{2757}",
 9777|      1|            "\u{1f4dd}",
 9778|      1|            "\u{1f9e0}",
 9779|      1|            "\u{1f9ea}",
 9780|      1|            "\u{1f4e6}",
 9781|      1|            "\u{1f527}",
 9782|      1|            "x",
 9783|      1|        ];
 9784|     20|        for emoji in emojis {
                          ^19
 9785|     19|            let image = renderer.generate_emoji_image(emoji, 8);
 9786|     19|            assert_eq!(image.size, [8, 8]);
 9787|       |        }
 9788|      1|    }
 9789|       |
 9790|       |    #[test]
 9791|      1|    fn test_measure_inline_spans_code_and_image() {
 9792|      1|        let renderer = MarkdownRenderer::new();
 9793|      1|        with_test_ui(|ctx, ui| {
 9794|      1|            let tex = ctx.load_texture(
 9795|       |                "test-image",
 9796|      1|                egui::ColorImage::new([2, 2], Color32::WHITE),
 9797|       |                egui::TextureOptions::LINEAR,
 9798|       |            );
 9799|      1|            renderer.image_textures.borrow_mut().insert(
 9800|      1|                "image.png".to_string(),
 9801|      1|                ImageCacheEntry {
 9802|      1|                    texture: tex,
 9803|      1|                    size: [64, 32],
 9804|      1|                    modified: None,
 9805|      1|                },
 9806|      1|            );
 9807|      1|            let spans = vec![
 9808|      1|                InlineSpan::Text("Hello".to_string()),
 9809|      1|                InlineSpan::Code("line1\nline2".to_string()),
 9810|      1|                InlineSpan::Image {
 9811|      1|                    src: "image.png".to_string(),
 9812|      1|                    alt: "Alt".to_string(),
 9813|      1|                    title: None,
 9814|      1|                },
 9815|       |            ];
 9816|      1|            let width = renderer.measure_inline_spans(ui, &spans);
 9817|      1|            assert!(width > 0.0);
 9818|      1|        });
 9819|      1|    }
 9820|       |
 9821|       |    #[test]
 9822|      1|    fn test_get_or_load_image_texture_cache_and_remote() -> Result<()> {
 9823|      1|        let renderer = MarkdownRenderer::new();
 9824|      1|        with_test_ui(|_, ui| {
 9825|      1|            assert!(renderer
 9826|      1|                .get_or_load_image_texture(ui, "https://example.com/logo.png")
 9827|      1|                .is_none());
 9828|      1|        });
 9829|       |
 9830|      1|        let temp = tempdir()?;
                                          ^0
 9831|      1|        let image_path = temp.path().join("image.png");
 9832|      1|        std::fs::write(&image_path, tiny_png_bytes())?;
                                                                   ^0
 9833|      1|        let resolved = image_path.to_string_lossy().to_string();
 9834|      1|        with_test_ui(|ctx, ui| {
 9835|      1|            let first = wait_for_image(&renderer, ctx, ui, &resolved);
 9836|      1|            assert!(first.is_some());
 9837|      1|            let second = renderer.get_or_load_image_texture(ui, &resolved);
 9838|      1|            assert!(second.is_some());
 9839|      1|        });
 9840|      1|        Ok(())
 9841|      1|    }
 9842|       |
 9843|       |    #[test]
 9844|      1|    fn test_get_or_load_image_texture_stale_cache_evicted() -> Result<()> {
 9845|      1|        let renderer = MarkdownRenderer::new();
 9846|      1|        let temp = tempdir()?;
                                          ^0
 9847|      1|        let image_path = temp.path().join("image.png");
 9848|      1|        std::fs::write(&image_path, tiny_png_bytes())?;
                                                                   ^0
 9849|      1|        let resolved = image_path.to_string_lossy().to_string();
 9850|       |
 9851|      1|        with_test_ui(|ctx, ui| {
 9852|      1|            let tex = ctx.load_texture(
 9853|       |                "stale-image",
 9854|      1|                egui::ColorImage::new([2, 2], Color32::WHITE),
 9855|       |                egui::TextureOptions::LINEAR,
 9856|       |            );
 9857|      1|            renderer.image_textures.borrow_mut().insert(
 9858|      1|                resolved.clone(),
 9859|      1|                ImageCacheEntry {
 9860|      1|                    texture: tex,
 9861|      1|                    size: [2, 2],
 9862|      1|                    modified: Some(SystemTime::UNIX_EPOCH),
 9863|      1|                },
 9864|      1|            );
 9865|       |
 9866|      1|            let result = renderer.get_or_load_image_texture(ui, &resolved);
 9867|      1|            assert!(result.is_none());
 9868|      1|            assert!(!renderer.image_textures.borrow().contains_key(&resolved));
 9869|      1|            assert!(renderer.image_pending.borrow().contains(&resolved));
 9870|      1|        });
 9871|       |
 9872|      1|        Ok(())
 9873|      1|    }
 9874|       |
 9875|       |    #[test]
 9876|      1|    fn test_get_or_load_image_texture_enqueue_failure() -> Result<()> {
 9877|      1|        let mut renderer = MarkdownRenderer::new();
 9878|      1|        let (image_job_tx, image_job_rx) = bounded(0);
 9879|      1|        drop(image_job_rx);
 9880|      1|        renderer.image_job_tx = image_job_tx;
 9881|       |
 9882|      1|        let temp = tempdir()?;
                                          ^0
 9883|      1|        let image_path = temp.path().join("image.png");
 9884|      1|        std::fs::write(&image_path, tiny_png_bytes())?;
                                                                   ^0
 9885|      1|        let resolved = image_path.to_string_lossy().to_string();
 9886|       |
 9887|      1|        with_test_ui(|_, ui| {
 9888|      1|            let result = renderer.get_or_load_image_texture(ui, &resolved);
 9889|      1|            assert!(result.is_none());
 9890|      1|            assert!(!renderer.image_pending.borrow().contains(&resolved));
 9891|      1|        });
 9892|       |
 9893|      1|        Ok(())
 9894|      1|    }
 9895|       |
 9896|       |    #[test]
 9897|      1|    fn test_poll_image_results_records_failure() {
 9898|      1|        let mut renderer = MarkdownRenderer::new();
 9899|      1|        let (result_tx, result_rx) = crossbeam_channel::unbounded::<ImageLoadResult>();
 9900|      1|        renderer.image_result_rx = result_rx;
 9901|      1|        renderer
 9902|      1|            .image_pending
 9903|      1|            .borrow_mut()
 9904|      1|            .insert("failed.png".to_string());
 9905|       |
 9906|      1|        result_tx
 9907|      1|            .send(ImageLoadResult::Failed {
 9908|      1|                key: "failed.png".to_string(),
 9909|      1|            })
 9910|      1|            .expect("send");
 9911|      1|        let ctx = egui::Context::default();
 9912|      1|        renderer.poll_image_results(&ctx);
 9913|      1|        assert!(renderer.image_failures.borrow().contains_key("failed.png"));
 9914|      1|        assert!(!renderer.image_pending.borrow().contains("failed.png"));
 9915|      1|    }
 9916|       |
 9917|       |    #[test]
 9918|      1|    fn test_enqueue_image_job_full_returns_err() {
 9919|      1|        let mut renderer = MarkdownRenderer::new();
 9920|      1|        let (job_tx, job_rx) = bounded(1);
 9921|      1|        renderer.image_job_tx = job_tx;
 9922|      1|        let request = ImageLoadRequest {
 9923|      1|            key: "full".to_string(),
 9924|      1|            source: ImageLoadSource::Embedded(b"png"),
 9925|      1|        };
 9926|      1|        renderer.image_job_tx.send(request).expect("fill queue");
 9927|      1|        let request = ImageLoadRequest {
 9928|      1|            key: "full-2".to_string(),
 9929|      1|            source: ImageLoadSource::Embedded(b"png"),
 9930|      1|        };
 9931|      1|        assert!(renderer.enqueue_image_job(request).is_err());
 9932|      1|        drop(job_rx);
 9933|      1|    }
 9934|       |
 9935|       |    #[test]
 9936|      1|    fn test_wait_for_image_with_limit_returns_none() {
 9937|      1|        let renderer = MarkdownRenderer::new();
 9938|      1|        let ctx = egui::Context::default();
 9939|      1|        let input = egui::RawInput {
 9940|      1|            screen_rect: Some(egui::Rect::from_min_size(
 9941|      1|                egui::pos2(0.0, 0.0),
 9942|      1|                egui::vec2(320.0, 240.0),
 9943|      1|            )),
 9944|      1|            ..Default::default()
 9945|      1|        };
 9946|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 9947|      1|            let missing = wait_for_image_with_limit(&renderer, &ctx, ui, "missing", 0);
 9948|      1|            assert!(missing.is_none());
 9949|      1|        });
 9950|      1|    }
 9951|       |
 9952|       |    #[test]
 9953|      1|    fn test_render_table_tablebuilder_policy_mix() {
 9954|      1|        let renderer = MarkdownRenderer::new();
 9955|      1|        let headers = vec![
 9956|      1|            vec![InlineSpan::Text("Version".to_string())],
 9957|      1|            vec![InlineSpan::Text("Author".to_string())],
 9958|      1|            vec![InlineSpan::Text("Notes".to_string())],
 9959|      1|            vec![InlineSpan::Text("Example".to_string())],
 9960|      1|            vec![InlineSpan::Text("Misc".to_string())],
 9961|       |        ];
 9962|      1|        let rows = vec![vec![
 9963|      1|            vec![InlineSpan::Text("1".to_string())],
 9964|      1|            vec![InlineSpan::Text("Ada".to_string())],
 9965|      1|            vec![InlineSpan::Text("Line 1\nLine 2".to_string())],
 9966|      1|            vec![InlineSpan::Image {
 9967|      1|                src: "image.png".to_string(),
 9968|      1|                alt: "Alt".to_string(),
 9969|      1|                title: Some("Title".to_string()),
 9970|      1|            }],
 9971|      1|            vec![InlineSpan::Link {
 9972|      1|                text: "Link".to_string(),
 9973|      1|                url: "https://example.com".to_string(),
 9974|      1|            }],
 9975|       |        ]];
 9976|       |
 9977|      1|        let ctx = egui::Context::default();
 9978|      1|        let input = egui::RawInput {
 9979|      1|            screen_rect: Some(egui::Rect::from_min_size(
 9980|      1|                egui::pos2(0.0, 0.0),
 9981|      1|                egui::vec2(1200.0, 720.0),
 9982|      1|            )),
 9983|      1|            ..Default::default()
 9984|      1|        };
 9985|      1|        run_frame_with_input(&ctx, input, |ctx, ui| {
 9986|      1|            let tex = ctx.load_texture(
 9987|       |                "table-image",
 9988|      1|                egui::ColorImage::new([2, 2], Color32::WHITE),
 9989|       |                egui::TextureOptions::LINEAR,
 9990|       |            );
 9991|      1|            renderer.image_textures.borrow_mut().insert(
 9992|      1|                "image.png".to_string(),
 9993|      1|                ImageCacheEntry {
 9994|      1|                    texture: tex,
 9995|      1|                    size: [120, 80],
 9996|      1|                    modified: None,
 9997|      1|                },
 9998|      1|            );
 9999|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 12);
10000|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10001|      1|        });
10002|      1|        let input = egui::RawInput {
10003|      1|            screen_rect: Some(egui::Rect::from_min_size(
10004|      1|                egui::pos2(0.0, 0.0),
10005|      1|                egui::vec2(1200.0, 720.0),
10006|      1|            )),
10007|      1|            ..Default::default()
10008|      1|        };
10009|      1|        run_frame_with_input(&ctx, input, |_, ui| {
10010|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 12);
10011|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10012|      1|        });
10013|      1|    }
10014|       |
10015|       |    #[test]
10016|      1|    fn test_render_table_tablebuilder_extra_columns() {
10017|      1|        let renderer = MarkdownRenderer::new();
10018|      1|        let headers = vec![vec![InlineSpan::Text("H1".to_string())]];
10019|      1|        let rows = vec![vec![
10020|      1|            vec![InlineSpan::Text("C1".to_string())],
10021|      1|            vec![InlineSpan::Text("C2".to_string())],
10022|      1|            vec![InlineSpan::Text("C3".to_string())],
10023|       |        ]];
10024|      1|        with_test_ui(|_, ui| {
10025|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 13);
10026|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10027|      1|        });
10028|      1|    }
10029|       |
10030|       |    #[test]
10031|      1|    fn test_render_table_tablebuilder_forced_policies() {
10032|      1|        let renderer = MarkdownRenderer::new();
10033|      1|        let _forced = ForcedTablePolicies::new(vec![
10034|      1|            ColumnPolicy::Auto,
10035|      1|            ColumnPolicy::Fixed {
10036|      1|                width: 120.0,
10037|      1|                clip: true,
10038|      1|            },
10039|      1|            ColumnPolicy::Resizable {
10040|      1|                min: 60.0,
10041|      1|                preferred: 120.0,
10042|      1|                clip: true,
10043|      1|            },
10044|      1|            ColumnPolicy::Remainder { clip: true },
10045|       |        ]);
10046|      1|        let headers = vec![
10047|      1|            vec![InlineSpan::Text("A".to_string())],
10048|      1|            vec![InlineSpan::Text("B".to_string())],
10049|      1|            vec![InlineSpan::Text("C".to_string())],
10050|      1|            vec![InlineSpan::Text("D".to_string())],
10051|       |        ];
10052|      1|        let rows = vec![vec![
10053|      1|            vec![InlineSpan::Text("1".to_string())],
10054|      1|            vec![InlineSpan::Text("2".to_string())],
10055|      1|            vec![InlineSpan::Text("3".to_string())],
10056|      1|            vec![InlineSpan::Text("4".to_string())],
10057|       |        ]];
10058|      1|        with_test_ui(|_, ui| {
10059|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 14);
10060|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10061|      1|        });
10062|      1|    }
10063|       |
10064|       |    #[test]
10065|      1|    fn test_render_table_tablebuilder_fixed_columns_no_clip() {
10066|      1|        let renderer = MarkdownRenderer::new();
10067|      1|        let _forced = ForcedTablePolicies::new(vec![
10068|      1|            ColumnPolicy::Fixed {
10069|      1|                width: 80.0,
10070|      1|                clip: false,
10071|      1|            },
10072|      1|            ColumnPolicy::Fixed {
10073|      1|                width: 100.0,
10074|      1|                clip: false,
10075|      1|            },
10076|       |        ]);
10077|      1|        let headers = vec![
10078|      1|            vec![InlineSpan::Text("Left".to_string())],
10079|      1|            vec![InlineSpan::Text("Right".to_string())],
10080|       |        ];
10081|      1|        let rows = vec![vec![
10082|      1|            vec![InlineSpan::Text("A".to_string())],
10083|      1|            vec![InlineSpan::Text("B".to_string())],
10084|       |        ]];
10085|      1|        with_test_ui(|_, ui| {
10086|      1|            let layout = *ui.layout();
10087|      1|            ui.allocate_ui_with_layout(Vec2::new(400.0, 0.0), layout, |ui| {
10088|      1|                ui.spacing_mut().item_spacing.x = 6.0;
10089|      1|                ui.set_width(400.0);
10090|      1|                let table_id = renderer.compute_table_id(&headers, &rows, &[], 16);
10091|      1|                renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10092|      1|            });
10093|      1|        });
10094|      1|    }
10095|       |
10096|       |    #[test]
10097|      1|    fn test_render_table_tablebuilder_scaled_down_min_flex_forced() {
10098|      1|        let renderer = MarkdownRenderer::new();
10099|      1|        let _forced = ForcedTablePolicies::new(vec![
10100|      1|            ColumnPolicy::Resizable {
10101|      1|                min: 50.0,
10102|      1|                preferred: 120.0,
10103|      1|                clip: false,
10104|      1|            },
10105|      1|            ColumnPolicy::Resizable {
10106|      1|                min: 50.0,
10107|      1|                preferred: 120.0,
10108|      1|                clip: false,
10109|      1|            },
10110|       |        ]);
10111|      1|        let headers = vec![
10112|      1|            vec![InlineSpan::Text("A".to_string())],
10113|      1|            vec![InlineSpan::Text("B".to_string())],
10114|       |        ];
10115|      1|        let rows = vec![vec![
10116|      1|            vec![InlineSpan::Text("One".to_string())],
10117|      1|            vec![InlineSpan::Text("Two".to_string())],
10118|       |        ]];
10119|      1|        with_test_ui(|_, ui| {
10120|      1|            let layout = *ui.layout();
10121|      1|            ui.allocate_ui_with_layout(Vec2::new(106.0, 0.0), layout, |ui| {
10122|      1|                ui.spacing_mut().item_spacing.x = 6.0;
10123|      1|                ui.set_width(106.0);
10124|      1|                let table_id = renderer.compute_table_id(&headers, &rows, &[], 17);
10125|      1|                renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10126|      1|            });
10127|      1|        });
10128|      1|    }
10129|       |
10130|       |    #[test]
10131|      1|    fn test_render_table_tablebuilder_scaled_down_min_flex() {
10132|      1|        let renderer = MarkdownRenderer::new();
10133|      1|        let headers = vec![
10134|      1|            vec![InlineSpan::Text("Notes".to_string())],
10135|      1|            vec![InlineSpan::Text("Summary".to_string())],
10136|      1|            vec![InlineSpan::Text("Details".to_string())],
10137|       |        ];
10138|      1|        let rows = vec![vec![
10139|      1|            vec![InlineSpan::Text("Long text 1".to_string())],
10140|      1|            vec![InlineSpan::Text("Long text 2".to_string())],
10141|      1|            vec![InlineSpan::Text("Long text 3".to_string())],
10142|       |        ]];
10143|      1|        let ctx = egui::Context::default();
10144|      1|        let input = egui::RawInput {
10145|      1|            screen_rect: Some(egui::Rect::from_min_size(
10146|      1|                egui::pos2(0.0, 0.0),
10147|      1|                egui::vec2(120.0, 120.0),
10148|      1|            )),
10149|      1|            ..Default::default()
10150|      1|        };
10151|      1|        run_frame_with_input(&ctx, input, |_, ui| {
10152|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 15);
10153|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10154|      1|        });
10155|      1|    }
10156|       |
10157|       |    #[test]
10158|      1|    fn test_render_list_variants() {
10159|      1|        let renderer = MarkdownRenderer::new();
10160|      1|        let items = vec![
10161|      1|            ListItem {
10162|      1|                blocks: vec![
10163|      1|                    MarkdownElement::Paragraph(vec![InlineSpan::Text("Paragraph".to_string())]),
10164|      1|                    MarkdownElement::Header {
10165|      1|                        level: 2,
10166|      1|                        spans: vec![InlineSpan::Text("Header".to_string())],
10167|      1|                        id: "header".to_string(),
10168|      1|                    },
10169|      1|                ],
10170|      1|            },
10171|      1|            ListItem {
10172|      1|                blocks: vec![
10173|      1|                    MarkdownElement::CodeBlock {
10174|      1|                        language: None,
10175|      1|                        text: "code".to_string(),
10176|      1|                    },
10177|      1|                    MarkdownElement::Paragraph(vec![InlineSpan::Text("After".to_string())]),
10178|      1|                ],
10179|      1|            },
10180|      1|            ListItem { blocks: vec![] },
10181|       |        ];
10182|      1|        with_test_ui(|_, ui| {
10183|      1|            renderer.render_list(ui, false, &items);
10184|      1|            renderer.render_list(ui, true, &items);
10185|      1|            renderer.render_list(ui, false, &[]);
10186|      1|        });
10187|      1|    }
10188|       |
10189|       |    #[test]
10190|      1|    fn test_render_element_body_header_levels() {
10191|      1|        let renderer = MarkdownRenderer::new();
10192|      1|        with_test_ui(|_, ui| {
10193|      6|            for level in 3..=7 {
                              ^5
10194|      5|                let element = MarkdownElement::Header {
10195|      5|                    level,
10196|      5|                    spans: vec![InlineSpan::Text(format!("H{}", level))],
10197|      5|                    id: format!("h{}", level),
10198|      5|                };
10199|      5|                renderer.render_element_body(ui, &element);
10200|      5|            }
10201|      1|        });
10202|      1|    }
10203|       |
10204|       |    #[test]
10205|      1|    fn test_render_table_tablebuilder_hscroll() {
10206|      1|        let renderer = MarkdownRenderer::new();
10207|      1|        let headers: Vec<Vec<InlineSpan>> = (0..8)
10208|      8|            .map(|i| vec![InlineSpan::Text(format!("H{}", i + 1))])
                           ^1
10209|      1|            .collect();
10210|      1|        let row: Vec<Vec<InlineSpan>> = (0..8)
10211|      8|            .map(|i| vec![InlineSpan::Text(format!("col{}", i + 1))])
                           ^1
10212|      1|            .collect();
10213|      1|        let rows = vec![row];
10214|      1|        let ctx = egui::Context::default();
10215|      1|        let input = egui::RawInput {
10216|      1|            screen_rect: Some(egui::Rect::from_min_size(
10217|      1|                egui::pos2(0.0, 0.0),
10218|      1|                egui::vec2(200.0, 120.0),
10219|      1|            )),
10220|      1|            ..Default::default()
10221|      1|        };
10222|      1|        run_frame_with_input(&ctx, input, |_, ui| {
10223|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 10);
10224|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10225|      1|        });
10226|      1|    }
10227|       |
10228|       |    #[test]
10229|      1|    fn test_render_table_tablebuilder_tiny_width_hscroll() {
10230|      1|        let renderer = MarkdownRenderer::new();
10231|      1|        let headers = vec![
10232|      1|            vec![InlineSpan::Text("A".to_string())],
10233|      1|            vec![InlineSpan::Text("B".to_string())],
10234|       |        ];
10235|      1|        let rows = vec![vec![
10236|      1|            vec![InlineSpan::Text("1".to_string())],
10237|      1|            vec![InlineSpan::Text("2".to_string())],
10238|       |        ]];
10239|      1|        with_test_ui(|_, ui| {
10240|      1|            let layout = *ui.layout();
10241|      1|            ui.allocate_ui_with_layout(Vec2::new(5.0, 0.0), layout, |ui| {
10242|      1|                ui.spacing_mut().item_spacing.x = 6.0;
10243|      1|                ui.set_width(5.0);
10244|      1|                let table_id = renderer.compute_table_id(&headers, &rows, &[], 18);
10245|      1|                renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10246|      1|            });
10247|      1|        });
10248|      1|    }
10249|       |
10250|       |    #[test]
10251|      1|    fn test_render_table_tablebuilder_scaled_down() {
10252|      1|        let renderer = MarkdownRenderer::new();
10253|      1|        let headers = vec![
10254|      1|            vec![InlineSpan::Text("Wide Header One".to_string())],
10255|      1|            vec![InlineSpan::Text("Wide Header Two".to_string())],
10256|       |        ];
10257|      1|        let long_text = "W".repeat(80);
10258|      1|        let rows = vec![vec![
10259|      1|            vec![InlineSpan::Text(long_text.clone())],
10260|      1|            vec![InlineSpan::Text(long_text)],
10261|       |        ]];
10262|      1|        let ctx = egui::Context::default();
10263|      1|        let input = egui::RawInput {
10264|      1|            screen_rect: Some(egui::Rect::from_min_size(
10265|      1|                egui::pos2(0.0, 0.0),
10266|      1|                egui::vec2(180.0, 120.0),
10267|      1|            )),
10268|      1|            ..Default::default()
10269|      1|        };
10270|      1|        run_frame_with_input(&ctx, input, |_, ui| {
10271|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 11);
10272|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
10273|      1|        });
10274|      1|    }
10275|       |
10276|       |    #[test]
10277|      1|    fn test_list_marker_info_any_indent_variants() {
10278|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("").is_none());
10279|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("   ").is_none());
10280|       |
10281|      1|        let (rest, indent, content_indent, leading_cols) =
10282|      1|            MarkdownRenderer::list_marker_info_any_indent(" 1. item").expect("marker");
10283|      1|        assert_eq!(rest, "item");
10284|      1|        assert_eq!(indent, 1);
10285|      1|        assert_eq!(content_indent, 4);
10286|      1|        assert_eq!(leading_cols, 1);
10287|       |
10288|      1|        let (rest, indent, content_indent, leading_cols) =
10289|      1|            MarkdownRenderer::list_marker_info_any_indent("2)\titem").expect("marker");
10290|      1|        assert_eq!(rest, "item");
10291|      1|        assert_eq!(indent, 2);
10292|      1|        assert_eq!(content_indent, 4);
10293|      1|        assert_eq!(leading_cols, 0);
10294|      1|    }
10295|       |
10296|       |    #[test]
10297|      1|    fn test_list_marker_info_any_indent_requires_trailing_space() {
10298|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("-").is_none());
10299|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("   -").is_none());
10300|      1|    }
10301|       |
10302|       |    #[test]
10303|      1|    fn test_list_marker_info_any_indent_rejects_missing_whitespace() {
10304|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("1.item").is_none());
10305|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("1)item").is_none());
10306|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("1item").is_none());
10307|      1|    }
10308|       |
10309|       |    #[test]
10310|      1|    fn test_collect_until_tag_end_breaks_and_code() {
10311|      1|        let renderer = MarkdownRenderer::new();
10312|      1|        let events = vec![
10313|      1|            Event::Start(Tag::Emphasis),
10314|      1|            Event::Text("alpha".into()),
10315|      1|            Event::Code("beta".into()),
10316|      1|            Event::SoftBreak,
10317|      1|            Event::Html("<br>".into()),
10318|      1|            Event::HardBreak,
10319|      1|            Event::Html("<span>".into()),
10320|      1|            Event::End(Tag::Emphasis),
10321|       |        ];
10322|      1|        let (text, next) = renderer.collect_until_tag_end(&events, 1, Tag::Emphasis, true);
10323|      1|        assert_eq!(next, events.len());
10324|      1|        assert_eq!(text, "alphabeta\n\n\n");
10325|       |
10326|      1|        let (text, next) = renderer.collect_until_tag_end(&events, 1, Tag::Emphasis, false);
10327|      1|        assert_eq!(next, events.len());
10328|      1|        assert_eq!(text, "alphabeta   ");
10329|       |
10330|      1|        let unclosed = vec![Event::Text("tail".into()), Event::SoftBreak];
10331|      1|        let (text, next) = renderer.collect_until_tag_end(&unclosed, 0, Tag::Emphasis, true);
10332|      1|        assert_eq!(next, unclosed.len());
10333|      1|        assert_eq!(text, "tail\n");
10334|      1|    }
10335|       |
10336|       |    #[test]
10337|      1|    fn test_parse_inline_spans_with_breaks_link_image_and_unclosed() {
10338|      1|        let renderer = MarkdownRenderer::new();
10339|      1|        let events = vec![
10340|      1|            Event::Start(Tag::Paragraph),
10341|      1|            Event::Start(Tag::Link(
10342|      1|                LinkType::Inline,
10343|      1|                "https://example.com".into(),
10344|      1|                "".into(),
10345|      1|            )),
10346|      1|            Event::Text("link".into()),
10347|      1|            Event::End(Tag::Link(
10348|      1|                LinkType::Inline,
10349|      1|                "https://example.com".into(),
10350|      1|                "".into(),
10351|      1|            )),
10352|      1|            Event::Start(Tag::Image(
10353|      1|                LinkType::Inline,
10354|      1|                "img.png".into(),
10355|      1|                "Title".into(),
10356|      1|            )),
10357|      1|            Event::Text("alt".into()),
10358|      1|            Event::End(Tag::Image(
10359|      1|                LinkType::Inline,
10360|      1|                "img.png".into(),
10361|      1|                "Title".into(),
10362|      1|            )),
10363|      1|            Event::FootnoteReference("note".into()),
10364|      1|            Event::End(Tag::Paragraph),
10365|       |        ];
10366|      1|        let (spans, next) =
10367|      1|            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true);
10368|      1|        assert_eq!(next, events.len());
10369|      1|        assert!(spans
10370|      1|            .iter()
10371|      1|            .any(|span| matches!(span, InlineSpan::Link { .. })));
10372|      1|        assert!(spans
10373|      1|            .iter()
10374|      2|            .any(|span| matches!(span, InlineSpan::Image { .. })));
                           ^1
10375|       |
10376|      1|        let unclosed = vec![Event::Text("tail".into())];
10377|      1|        let (spans, next) =
10378|      1|            renderer.parse_inline_spans_with_breaks(&unclosed, 0, Tag::Paragraph, true);
10379|      1|        assert_eq!(next, unclosed.len());
10380|      1|        assert_eq!(MarkdownRenderer::spans_plain_text(&spans), "tail");
10381|      1|    }
10382|       |
10383|       |    #[test]
10384|      1|    fn test_parse_inline_spans_with_breaks_mismatched_end_tag() {
10385|      1|        let renderer = MarkdownRenderer::new();
10386|      1|        let events = vec![
10387|      1|            Event::Text("hello".into()),
10388|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H1, None, vec![])),
10389|       |        ];
10390|      1|        let (spans, next) =
10391|      1|            renderer.parse_inline_spans_with_breaks(&events, 0, Tag::Paragraph, true);
10392|      1|        assert_eq!(next, events.len());
10393|      1|        assert_eq!(MarkdownRenderer::spans_plain_text(&spans), "hello");
10394|      1|    }
10395|       |
10396|       |    #[test]
10397|      1|    fn test_parse_inline_spans_unclosed_image_only() {
10398|      1|        let renderer = MarkdownRenderer::new();
10399|      1|        let events = vec![
10400|      1|            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10401|      1|            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10402|       |        ];
10403|      1|        let (spans, next) =
10404|      1|            renderer.parse_inline_spans_with_breaks(&events, 0, Tag::Paragraph, true);
10405|      1|        assert_eq!(next, events.len());
10406|      1|        assert!(spans
10407|      1|            .iter()
10408|      1|            .any(|span| matches!(span, InlineSpan::Image { .. })));
10409|      1|    }
10410|       |
10411|       |    #[test]
10412|      1|    fn test_parse_inline_spans_image_only_skips_text_buffer() {
10413|      1|        let renderer = MarkdownRenderer::new();
10414|      1|        let events = vec![
10415|      1|            Event::Start(Tag::Paragraph),
10416|      1|            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10417|      1|            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10418|      1|            Event::End(Tag::Paragraph),
10419|       |        ];
10420|      1|        let (spans, next) =
10421|      1|            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true);
10422|      1|        assert_eq!(next, events.len());
10423|      1|        assert_eq!(spans.len(), 1);
10424|      1|        assert!(matches!(
10425|      1|            spans[0],
10426|      1|            InlineSpan::Image { ref alt, .. } if alt.is_empty()
10427|       |        ));
10428|      1|    }
10429|       |
10430|       |    #[test]
10431|      1|    fn test_parse_list_inline_variants_unclosed() -> Result<()> {
10432|      1|        let renderer = MarkdownRenderer::new();
10433|      1|        let events = vec![
10434|      1|            Event::Start(Tag::List(Some(1))),
10435|      1|            Event::Text("skip".into()),
10436|      1|            Event::Start(Tag::Item),
10437|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10438|      1|            Event::Text("Dup".into()),
10439|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10440|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10441|      1|            Event::Text("Dup".into()),
10442|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10443|      1|            Event::Start(Tag::Emphasis),
10444|      1|            Event::Text("em".into()),
10445|      1|            Event::End(Tag::Emphasis),
10446|      1|            Event::Start(Tag::Strong),
10447|      1|            Event::Text("strong".into()),
10448|      1|            Event::End(Tag::Strong),
10449|      1|            Event::Start(Tag::Strikethrough),
10450|      1|            Event::Text("strike".into()),
10451|      1|            Event::End(Tag::Strikethrough),
10452|      1|            Event::Start(Tag::Link(
10453|      1|                LinkType::Inline,
10454|      1|                "https://example.com".into(),
10455|      1|                "".into(),
10456|      1|            )),
10457|      1|            Event::Text("link".into()),
10458|      1|            Event::End(Tag::Link(
10459|      1|                LinkType::Inline,
10460|      1|                "https://example.com".into(),
10461|      1|                "".into(),
10462|      1|            )),
10463|      1|            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10464|      1|            Event::Text("alt".into()),
10465|      1|            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10466|      1|            Event::Text("tail".into()),
10467|      1|            Event::SoftBreak,
10468|      1|            Event::FootnoteReference("note".into()),
10469|       |        ];
10470|      1|        let mut slugs = HashMap::new();
10471|      1|        let (items, next) = renderer.parse_list(&events, 1, &mut slugs)?;
                                                                                     ^0
10472|      1|        assert_eq!(next, events.len());
10473|      1|        assert_eq!(items.len(), 1);
10474|      1|        Ok(())
10475|      1|    }
10476|       |
10477|       |    #[test]
10478|      1|    fn test_parse_list_empty_paragraph_skips_block() -> Result<()> {
10479|      1|        let renderer = MarkdownRenderer::new();
10480|      1|        let events = vec![
10481|      1|            Event::Start(Tag::List(Some(1))),
10482|      1|            Event::Start(Tag::Item),
10483|      1|            Event::Start(Tag::Paragraph),
10484|      1|            Event::End(Tag::Paragraph),
10485|      1|            Event::End(Tag::Item),
10486|      1|            Event::End(Tag::List(Some(1))),
10487|       |        ];
10488|      1|        let mut slugs = HashMap::new();
10489|      1|        let (items, next) = renderer.parse_list(&events, 1, &mut slugs)?;
                                                                                     ^0
10490|      1|        assert_eq!(next, events.len());
10491|      1|        assert_eq!(items.len(), 1);
10492|      1|        assert!(items[0].blocks.is_empty());
10493|      1|        Ok(())
10494|      1|    }
10495|       |
10496|       |    #[test]
10497|      1|    fn test_collect_blockquotes_unclosed_variants() -> Result<()> {
10498|      1|        let renderer = MarkdownRenderer::new();
10499|      1|        let events = vec![
10500|      1|            Event::Start(Tag::BlockQuote),
10501|      1|            Event::Text("plain".into()),
10502|      1|            Event::Code("code".into()),
10503|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10504|      1|            Event::Text("Dup".into()),
10505|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10506|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10507|      1|            Event::Text("Dup".into()),
10508|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
10509|      1|            Event::Start(Tag::Link(
10510|      1|                LinkType::Inline,
10511|      1|                "https://example.com".into(),
10512|      1|                "".into(),
10513|      1|            )),
10514|      1|            Event::Text("link".into()),
10515|      1|            Event::End(Tag::Link(
10516|      1|                LinkType::Inline,
10517|      1|                "https://example.com".into(),
10518|      1|                "".into(),
10519|      1|            )),
10520|      1|            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10521|      1|            Event::Text("alt".into()),
10522|      1|            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
10523|      1|            Event::FootnoteReference("note".into()),
10524|       |        ];
10525|      1|        let mut slugs = HashMap::new();
10526|      1|        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs)?;
                                                                                                  ^0
10527|      1|        assert_eq!(next, events.len());
10528|      1|        let mut ids = Vec::new();
10529|      2|        for (_, blocks) in &quotes {
                              ^1
10530|      5|            for block in blocks {
                              ^4
10531|      4|                if let MarkdownElement::Header { id, .. } = block {
                                                               ^2
10532|      2|                    ids.push(id.clone());
10533|      2|                }
10534|       |            }
10535|       |        }
10536|      1|        assert_eq!(ids.len(), 2);
10537|      1|        assert_ne!(ids[0], ids[1]);
10538|      1|        Ok(())
10539|      1|    }
10540|       |
10541|       |    #[test]
10542|      1|    fn test_render_inline_span_context_menus() {
10543|      1|        let renderer = MarkdownRenderer::new();
10544|      1|        let code_span = InlineSpan::Code("inline".to_string());
10545|      1|        let ctx = egui::Context::default();
10546|      1|        let click = input_with_click(egui::pos2(12.0, 12.0), egui::PointerButton::Secondary);
10547|      1|        run_frame_with_input(&ctx, click, |_, ui| {
10548|      1|            renderer.render_inline_span(ui, &code_span, None, None);
10549|      1|        });
10550|      1|        let input = egui::RawInput {
10551|      1|            screen_rect: Some(egui::Rect::from_min_size(
10552|      1|                egui::pos2(0.0, 0.0),
10553|      1|                egui::vec2(320.0, 240.0),
10554|      1|            )),
10555|      1|            ..Default::default()
10556|      1|        };
10557|      1|        run_frame_with_input(&ctx, input, |_, ui| {
10558|      1|            renderer.render_inline_span(ui, &code_span, None, None);
10559|      1|        });
10560|       |
10561|      1|        let link_span = InlineSpan::Link {
10562|      1|            text: "Link".to_string(),
10563|      1|            url: "https://example.com".to_string(),
10564|      1|        };
10565|      1|        let ctx = egui::Context::default();
10566|      1|        let click = input_with_click(egui::pos2(12.0, 12.0), egui::PointerButton::Secondary);
10567|      1|        run_frame_with_input(&ctx, click, |_, ui| {
10568|      1|            renderer.render_inline_span(ui, &link_span, None, None);
10569|      1|        });
10570|      1|        let input = egui::RawInput {
10571|      1|            screen_rect: Some(egui::Rect::from_min_size(
10572|      1|                egui::pos2(0.0, 0.0),
10573|      1|                egui::vec2(320.0, 240.0),
10574|      1|            )),
10575|      1|            ..Default::default()
10576|      1|        };
10577|      1|        run_frame_with_input(&ctx, input, |_, ui| {
10578|      1|            renderer.render_inline_span(ui, &link_span, None, None);
10579|      1|        });
10580|      1|    }
10581|       |
10582|       |    #[test]
10583|      1|    fn test_render_inline_span_image_scale_and_title() {
10584|      1|        let renderer = MarkdownRenderer::new();
10585|      1|        let ctx = egui::Context::default();
10586|      1|        let input = egui::RawInput {
10587|      1|            screen_rect: Some(egui::Rect::from_min_size(
10588|      1|                egui::pos2(0.0, 0.0),
10589|      1|                egui::vec2(40.0, 240.0),
10590|      1|            )),
10591|      1|            ..Default::default()
10592|      1|        };
10593|      1|        run_frame_with_input(&ctx, input, |_, ui| {
10594|      1|            let color_image = egui::ColorImage::new([200, 120], Color32::WHITE);
10595|      1|            let tex =
10596|      1|                ui.ctx()
10597|      1|                    .load_texture("img:test.png", color_image, egui::TextureOptions::LINEAR);
10598|      1|            renderer.image_textures.borrow_mut().insert(
10599|      1|                "test.png".to_string(),
10600|      1|                ImageCacheEntry {
10601|      1|                    texture: tex,
10602|      1|                    size: [200, 120],
10603|      1|                    modified: None,
10604|      1|                },
10605|      1|            );
10606|      1|            let span = InlineSpan::Image {
10607|      1|                src: "test.png".to_string(),
10608|      1|                alt: "Alt".to_string(),
10609|      1|                title: Some("Title".to_string()),
10610|      1|            };
10611|      1|            renderer.render_inline_span(ui, &span, None, None);
10612|      1|        });
10613|      1|    }
10614|       |
10615|       |    #[test]
10616|      1|    fn test_paint_table_text_job_triggers_anchor_on_click() {
10617|      1|        let renderer = MarkdownRenderer::new();
10618|      1|        let spans = vec![InlineSpan::Link {
10619|      1|            text: "Jump".to_string(),
10620|      1|            url: "#Section-One".to_string(),
10621|      1|        }];
10622|      1|        let ctx = egui::Context::default();
10623|      1|        let click_pos = std::cell::Cell::new(egui::pos2(1.0, 1.0));
10624|      1|        let layout_input = egui::RawInput {
10625|      1|            screen_rect: Some(egui::Rect::from_min_size(
10626|      1|                egui::pos2(0.0, 0.0),
10627|      1|                egui::vec2(220.0, 120.0),
10628|      1|            )),
10629|      1|            ..Default::default()
10630|      1|        };
10631|      1|        run_frame_with_input(&ctx, layout_input, |_, ui| {
10632|      1|            ui.allocate_ui_at_rect(
10633|      1|                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
10634|      1|                |ui| {
10635|      1|                    let build =
10636|      1|                        renderer.build_layout_job(ui.style(), &spans, 60.0, false, Align::LEFT);
10637|      1|                    let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
10638|      1|                    let (rect, _response) = ui.allocate_exact_size(
10639|      1|                        egui::vec2(120.0, galley.size().y),
10640|      1|                        egui::Sense::click(),
10641|      1|                    );
10642|      1|                    let text_origin =
10643|      1|                        MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
10644|      1|                    click_pos.set(text_origin + egui::vec2(2.0, 2.0));
10645|      1|                },
10646|       |            );
10647|      1|        });
10648|       |
10649|      1|        let input = input_with_click(click_pos.get(), egui::PointerButton::Primary);
10650|      1|        run_frame_with_input(&ctx, input, |_, ui| {
10651|      1|            ui.allocate_ui_at_rect(
10652|      1|                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
10653|      1|                |ui| {
10654|      1|                    let build =
10655|      1|                        renderer.build_layout_job(ui.style(), &spans, 60.0, false, Align::LEFT);
10656|      1|                    renderer.paint_table_text_job(ui, 120.0, build);
10657|      1|                },
10658|       |            );
10659|      1|        });
10660|       |
10661|      1|        assert_eq!(
10662|      1|            renderer.take_pending_anchor(),
10663|      1|            Some("section-one".to_string())
10664|       |        );
10665|      1|    }
10666|       |
10667|       |    #[test]
10668|      1|    fn test_paint_table_text_job_hover_link_does_not_trigger() {
10669|      1|        let renderer = MarkdownRenderer::new();
10670|      1|        let spans = vec![InlineSpan::Link {
10671|      1|            text: "Jump".to_string(),
10672|      1|            url: "#Section-One".to_string(),
10673|      1|        }];
10674|      1|        let ctx = egui::Context::default();
10675|      1|        let hover_pos = std::cell::Cell::new(egui::pos2(1.0, 1.0));
10676|      1|        let layout_input = egui::RawInput {
10677|      1|            screen_rect: Some(egui::Rect::from_min_size(
10678|      1|                egui::pos2(0.0, 0.0),
10679|      1|                egui::vec2(220.0, 120.0),
10680|      1|            )),
10681|      1|            ..Default::default()
10682|      1|        };
10683|      1|        run_frame_with_input(&ctx, layout_input, |_, ui| {
10684|      1|            ui.allocate_ui_at_rect(
10685|      1|                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
10686|      1|                |ui| {
10687|      1|                    let build =
10688|      1|                        renderer.build_layout_job(ui.style(), &spans, 60.0, false, Align::LEFT);
10689|      1|                    let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
10690|      1|                    let (rect, _response) = ui.allocate_exact_size(
10691|      1|                        egui::vec2(120.0, galley.size().y),
10692|      1|                        egui::Sense::click(),
10693|      1|                    );
10694|      1|                    let text_origin =
10695|      1|                        MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
10696|      1|                    hover_pos.set(text_origin + egui::vec2(2.0, 2.0));
10697|      1|                },
10698|       |            );
10699|      1|        });
10700|       |
10701|      1|        let mut input = egui::RawInput {
10702|      1|            screen_rect: Some(egui::Rect::from_min_size(
10703|      1|                egui::pos2(0.0, 0.0),
10704|      1|                egui::vec2(220.0, 120.0),
10705|      1|            )),
10706|      1|            ..Default::default()
10707|      1|        };
10708|      1|        input
10709|      1|            .events
10710|      1|            .push(egui::Event::PointerMoved(hover_pos.get()));
10711|      1|        run_frame_with_input(&ctx, input, |_, ui| {
10712|      1|            ui.allocate_ui_at_rect(
10713|      1|                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
10714|      1|                |ui| {
10715|      1|                    let build =
10716|      1|                        renderer.build_layout_job(ui.style(), &spans, 60.0, false, Align::LEFT);
10717|      1|                    renderer.paint_table_text_job(ui, 120.0, build);
10718|      1|                },
10719|       |            );
10720|      1|        });
10721|       |
10722|      1|        assert!(renderer.take_pending_anchor().is_none());
10723|      1|    }
10724|       |
10725|       |    #[test]
10726|      1|    fn test_render_inline_span_image_empty_title() {
10727|      1|        let renderer = MarkdownRenderer::new();
10728|      1|        let ctx = egui::Context::default();
10729|      1|        let input = egui::RawInput {
10730|      1|            screen_rect: Some(egui::Rect::from_min_size(
10731|      1|                egui::pos2(0.0, 0.0),
10732|      1|                egui::vec2(120.0, 120.0),
10733|      1|            )),
10734|      1|            ..Default::default()
10735|      1|        };
10736|      1|        run_frame_with_input(&ctx, input, |_, ui| {
10737|      1|            let color_image = egui::ColorImage::new([20, 12], Color32::WHITE);
10738|      1|            let tex = ui.ctx().load_texture(
10739|       |                "img:empty-title.png",
10740|      1|                color_image,
10741|       |                egui::TextureOptions::LINEAR,
10742|       |            );
10743|      1|            renderer.image_textures.borrow_mut().insert(
10744|      1|                "empty-title.png".to_string(),
10745|      1|                ImageCacheEntry {
10746|      1|                    texture: tex,
10747|      1|                    size: [20, 12],
10748|      1|                    modified: None,
10749|      1|                },
10750|      1|            );
10751|      1|            let span = InlineSpan::Image {
10752|      1|                src: "empty-title.png".to_string(),
10753|      1|                alt: "Alt".to_string(),
10754|      1|                title: Some(String::new()),
10755|      1|            };
10756|      1|            renderer.render_inline_span(ui, &span, None, None);
10757|      1|        });
10758|      1|    }
10759|       |
10760|       |    #[test]
10761|      1|    fn test_measure_inline_spans_empty_lines_and_styles() {
10762|      1|        let renderer = MarkdownRenderer::new();
10763|      1|        with_test_ui(|_, ui| {
10764|      1|            let spans = vec![
10765|      1|                InlineSpan::Strong("Bold\n\nLine".to_string()),
10766|      1|                InlineSpan::Emphasis("Em\n".to_string()),
10767|      1|                InlineSpan::Strikethrough("Strike".to_string()),
10768|      1|                InlineSpan::Link {
10769|      1|                    text: "Link\n".to_string(),
10770|      1|                    url: "https://example.com".to_string(),
10771|      1|                },
10772|      1|                InlineSpan::Code("code\n\nmore".to_string()),
10773|       |            ];
10774|      1|            let width = renderer.measure_inline_spans(ui, &spans);
10775|      1|            assert!(width > 0.0);
10776|      1|        });
10777|      1|    }
10778|       |
10779|       |    #[test]
10780|      1|    fn test_estimate_table_cell_height_variants() {
10781|      1|        let renderer = MarkdownRenderer::new();
10782|      1|        with_test_ui(|_, ui| {
10783|      1|            let style = ui.style().clone();
10784|      1|            let empty =
10785|      1|                renderer.estimate_table_cell_height(&style, ui, &[], 100.0, Align::LEFT, 18.0);
10786|      1|            assert_eq!(empty, 18.0);
10787|       |
10788|      1|            let emoji_spans = vec![InlineSpan::Text("".to_string())];
10789|      1|            let emoji_height = renderer.estimate_table_cell_height(
10790|      1|                &style,
10791|      1|                ui,
10792|      1|                &emoji_spans,
10793|       |                100.0,
10794|       |                Align::LEFT,
10795|       |                18.0,
10796|       |            );
10797|      1|            assert!(emoji_height >= 18.0);
10798|       |
10799|      1|            let spans = vec![
10800|      1|                InlineSpan::Text("alpha".to_string()),
10801|      1|                InlineSpan::Image {
10802|      1|                    src: "missing.png".to_string(),
10803|      1|                    alt: "Alt".to_string(),
10804|      1|                    title: None,
10805|      1|                },
10806|       |            ];
10807|      1|            let height =
10808|      1|                renderer.estimate_table_cell_height(&style, ui, &spans, 40.0, Align::LEFT, 18.0);
10809|      1|            assert!(height >= 18.0);
10810|      1|        });
10811|      1|    }
10812|       |
10813|       |    #[test]
10814|      1|    fn test_estimate_table_column_widths_scaling() {
10815|      1|        let renderer = MarkdownRenderer::new();
10816|      1|        let empty = renderer.estimate_table_column_widths(&[], 120.0, 6.0);
10817|      1|        assert_eq!(empty, vec![120.0]);
10818|       |
10819|      1|        let specs = vec![
10820|      1|            ColumnSpec::new(
10821|       |                0,
10822|      1|                "A".to_string(),
10823|      1|                ColumnPolicy::Fixed {
10824|      1|                    width: 100.0,
10825|      1|                    clip: false,
10826|      1|                },
10827|      1|                None,
10828|       |            ),
10829|      1|            ColumnSpec::new(
10830|       |                1,
10831|      1|                "B".to_string(),
10832|      1|                ColumnPolicy::Fixed {
10833|      1|                    width: 100.0,
10834|      1|                    clip: false,
10835|      1|                },
10836|      1|                None,
10837|       |            ),
10838|       |        ];
10839|      1|        let widths = renderer.estimate_table_column_widths(&specs, 100.0, 10.0);
10840|      1|        assert_eq!(widths.len(), 2);
10841|      1|        let sum: f32 = widths.iter().sum();
10842|      1|        assert!((sum - 90.0).abs() < 0.5);
10843|      1|    }
10844|       |
10845|       |    #[test]
10846|      1|    fn test_estimate_table_column_widths_no_scale_when_available() {
10847|      1|        let renderer = MarkdownRenderer::new();
10848|      1|        let specs = vec![
10849|      1|            ColumnSpec::new(
10850|       |                0,
10851|       |                "A",
10852|      1|                ColumnPolicy::Fixed {
10853|      1|                    width: 80.0,
10854|      1|                    clip: false,
10855|      1|                },
10856|      1|                None,
10857|       |            ),
10858|      1|            ColumnSpec::new(
10859|       |                1,
10860|       |                "B",
10861|      1|                ColumnPolicy::Fixed {
10862|      1|                    width: 60.0,
10863|      1|                    clip: false,
10864|      1|                },
10865|      1|                None,
10866|       |            ),
10867|       |        ];
10868|      1|        let widths = renderer.estimate_table_column_widths(&specs, 300.0, 10.0);
10869|      1|        assert_eq!(widths, vec![80.0, 60.0]);
10870|      1|    }
10871|       |
10872|       |    #[test]
10873|      1|    fn test_escape_table_pipes_in_inline_code_nested_lists() {
10874|      1|        let md_parent = "\
10875|      1| - Parent
10876|      1|   | Col | Notes |
10877|      1|  | --- | --- |
10878|      1|  | code | `a|b` |
10879|      1|";
10880|      1|        let escaped_parent = MarkdownRenderer::escape_table_pipes_in_inline_code(md_parent);
10881|      1|        assert!(escaped_parent.contains(PIPE_SENTINEL));
10882|       |
10883|      1|        let md_nested = "\
10884|      1|- Parent
10885|      1|    - | Col | Notes |
10886|      1|      | --- | --- |
10887|      1|      | code | `a|b` |
10888|      1|";
10889|      1|        let escaped_nested = MarkdownRenderer::escape_table_pipes_in_inline_code(md_nested);
10890|      1|        assert!(escaped_nested.contains(PIPE_SENTINEL));
10891|      1|    }
10892|       |
10893|       |    #[test]
10894|      1|    fn test_escape_table_pipes_parent_indent_list_marker_header() {
10895|      1|        let md = "\
10896|      1|- Parent
10897|      1|    - | H | I |
10898|      1|      | --- | --- |
10899|      1|      | 1 | 2 |";
10900|      1|        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
10901|      1|        assert_eq!(escaped, md);
10902|      1|    }
10903|       |
10904|       |    #[test]
10905|      1|    fn test_escape_table_pipes_parent_indent_list_marker_any_indent() {
10906|      1|        let md = "\
10907|      1|- Parent
10908|      1|    - | H | I |
10909|      1|      | --- | --- |
10910|      1|      | `a|b` | c |
10911|      1|";
10912|      1|        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
10913|      1|        assert!(escaped.contains(PIPE_SENTINEL));
10914|      1|    }
10915|       |
10916|       |    #[test]
10917|      1|    fn test_escape_table_pipes_parent_indent_marker_within_range() {
10918|      1|        let md = "\
10919|      1|- Parent
10920|      1|    - | H | I |
10921|      1|      | --- | --- |
10922|      1|      | `a|b` | c |
10923|      1|";
10924|      1|        let lines: Vec<&str> = md.split_inclusive('\n').collect();
10925|      1|        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
10926|      1|        let _parent_indent =
10927|      1|            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
10928|      1|        let _leading_spaces =
10929|      1|            MarkdownRenderer::list_marker_info_any_indent(rest).map(|(_, _, _, spaces)| spaces);
10930|      1|        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
10931|      1|        assert!(escaped.contains(PIPE_SENTINEL));
10932|      1|    }
10933|       |
10934|       |    #[test]
10935|      1|    fn test_escape_table_pipes_parent_indent_strip_without_code_indent() {
10936|      1|        let md = "\
10937|      1|- Parent
10938|      1|  continuation
10939|      1|  | H | I |
10940|      1|  | --- | --- |
10941|      1|  | `a|b` | c |
10942|      1|";
10943|      1|        let lines: Vec<&str> = md.split_inclusive('\n').collect();
10944|      1|        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
10945|      1|        let parent_indent =
10946|      1|            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
10947|      1|        let strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent);
10948|      1|        let code_strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent + 4);
10949|      1|        assert!(strip.is_some());
10950|      1|        assert!(code_strip.is_none());
10951|      1|        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
10952|      1|        assert!(escaped.contains(PIPE_SENTINEL));
10953|      1|    }
10954|       |
10955|       |    #[test]
10956|      1|    fn test_escape_table_pipes_parent_indent_strips_non_code_row() {
10957|      1|        let md = "\
10958|      1|- Parent
10959|      1|  | H | I |
10960|      1|  | --- | --- |
10961|      1|  | 1 | 2 |";
10962|      1|        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
10963|      1|        assert!(escaped.contains("| H | I |"));
10964|      1|        assert!(escaped.contains("| --- | --- |"));
10965|      1|    }
10966|       |
10967|       |    #[test]
10968|      1|    fn test_escape_table_pipes_parent_indent_out_of_range() {
10969|      1|        let md = "\
10970|      1|- Parent
10971|      1|        - Child
10972|      1|        continuation
10973|      1|";
10974|      1|        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
10975|      1|        assert_eq!(escaped, md);
10976|      1|    }
10977|       |
10978|       |    #[test]
10979|      1|    fn test_escape_table_pipes_parent_indent_marker_outside_range() {
10980|      1|        let md = "\
10981|      1|- Parent
10982|      1|      - Child
10983|      1|      continuation
10984|      1|";
10985|      1|        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
10986|      1|        assert_eq!(escaped, md);
10987|      1|    }
10988|       |
10989|       |    #[test]
10990|      1|    fn test_escape_table_pipes_parent_indent_marker_too_deep() {
10991|      1|        let md = "\
10992|      1|- Parent
10993|      1|      - Child
10994|      1|      | H | I |
10995|      1|      | --- | --- |
10996|      1|      | `a|b` | c |
10997|      1|";
10998|      1|        let lines: Vec<&str> = md.split_inclusive('\n').collect();
10999|      1|        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
11000|      1|        let _parent_indent =
11001|      1|            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
11002|      1|        let _leading_spaces =
11003|      1|            MarkdownRenderer::list_marker_info_any_indent(rest).map(|(_, _, _, spaces)| spaces);
11004|      1|        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11005|      1|        assert_eq!(escaped, md);
11006|      1|    }
11007|       |
11008|       |    #[test]
11009|      1|    fn test_escape_table_pipes_parent_indent_code_strip_present() {
11010|      1|        let md = "\
11011|      1| - Parent
11012|      1|      continuation
11013|      1|      | H | I |
11014|      1|      | --- | --- |
11015|      1|      | `a|b` | c |
11016|      1|";
11017|      1|        let lines: Vec<&str> = md.split_inclusive('\n').collect();
11018|      1|        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
11019|      1|        let parent_indent =
11020|      1|            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
11021|      1|        let strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent);
11022|      1|        let code_strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent + 4);
11023|      1|        assert!(strip.is_some());
11024|      1|        assert!(code_strip.is_some());
11025|      1|        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11026|      1|        assert_eq!(escaped, md);
11027|      1|    }
11028|       |
11029|       |    #[test]
11030|      1|    fn test_escape_table_pipes_parent_indent_strip_only() {
11031|      1|        let md = "\
11032|      1|- Parent
11033|      1|  | H | I |
11034|      1|  | --- | --- |
11035|      1|  | `a|b` | c |
11036|      1|";
11037|      1|        let lines: Vec<&str> = md.split_inclusive('\n').collect();
11038|      1|        let (level, rest) = MarkdownRenderer::table_line_info(lines[1]);
11039|      1|        let parent_indent =
11040|      1|            MarkdownRenderer::parent_list_indent_for_line(&lines, 1, level, rest).unwrap();
11041|      1|        let strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent);
11042|      1|        let code_strip = MarkdownRenderer::strip_indent_columns(rest, parent_indent + 4);
11043|      1|        assert!(strip.is_some());
11044|      1|        assert!(code_strip.is_none());
11045|      1|        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11046|      1|        assert!(escaped.contains(PIPE_SENTINEL));
11047|      1|    }
11048|       |
11049|       |    #[test]
11050|      1|    fn test_escape_table_pipes_parent_indent_marker_in_range_any_indent() {
11051|      1|        let md = "\
11052|      1|  - Parent
11053|      1|     - | H | I |
11054|      1|        | --- | --- |
11055|      1|       | `a|b` | c |
11056|      1|";
11057|      1|        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11058|      1|        assert!(escaped.contains(PIPE_SENTINEL));
11059|      1|    }
11060|       |
11061|       |    #[test]
11062|      1|    fn test_escape_table_pipes_parent_indent_deep_list_marker_table_like_lines() {
11063|      1|        let md = "\
11064|      1|- Parent
11065|      1|        - | H | I |
11066|      1|        | --- | --- |
11067|      1|        | `a|b` | c |
11068|      1|";
11069|      1|        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
11070|      1|        assert_eq!(escaped, md);
11071|      1|    }
11072|       |
11073|       |    #[test]
11074|      1|    fn test_parse_table_unclosed_and_noise() -> Result<()> {
11075|      1|        let renderer = MarkdownRenderer::new();
11076|      1|        let events = vec![
11077|      1|            Event::Start(Tag::Table(vec![Alignment::Left])),
11078|      1|            Event::Start(Tag::TableHead),
11079|      1|            Event::Start(Tag::TableRow),
11080|      1|            Event::Start(Tag::TableCell),
11081|      1|            Event::Text("H".into()),
11082|      1|            Event::End(Tag::TableCell),
11083|      1|            Event::End(Tag::TableRow),
11084|      1|            Event::End(Tag::TableHead),
11085|      1|            Event::Start(Tag::TableRow),
11086|      1|            Event::Text("noise".into()),
11087|      1|            Event::Start(Tag::TableCell),
11088|      1|            Event::Text("R".into()),
11089|      1|            Event::End(Tag::TableCell),
11090|      1|            Event::End(Tag::TableRow),
11091|      1|            Event::Text("after".into()),
11092|       |        ];
11093|      1|        let (headers, rows, next) = renderer.parse_table(&events, 1)?;
                                                                                  ^0
11094|      1|        assert_eq!(headers.len(), 1);
11095|      1|        assert_eq!(rows.len(), 1);
11096|      1|        assert_eq!(next, events.len());
11097|      1|        Ok(())
11098|      1|    }
11099|       |
11100|       |    #[test]
11101|      1|    fn test_parse_table_unclosed_head_exits_on_eof() -> Result<()> {
11102|      1|        let renderer = MarkdownRenderer::new();
11103|      1|        let events = vec![
11104|      1|            Event::Start(Tag::Table(vec![Alignment::Left])),
11105|      1|            Event::Start(Tag::TableHead),
11106|      1|            Event::Start(Tag::TableCell),
11107|      1|            Event::Text("H".into()),
11108|      1|            Event::End(Tag::TableCell),
11109|       |        ];
11110|      1|        let (headers, rows, next) = renderer.parse_table(&events, 1)?;
                                                                                  ^0
11111|      1|        assert_eq!(headers.len(), 1);
11112|      1|        assert!(rows.is_empty());
11113|      1|        assert_eq!(next, events.len());
11114|      1|        Ok(())
11115|      1|    }
11116|       |
11117|       |    #[test]
11118|      1|    fn test_parse_table_unclosed_row_exits_on_eof() -> Result<()> {
11119|      1|        let renderer = MarkdownRenderer::new();
11120|      1|        let events = vec![
11121|      1|            Event::Start(Tag::Table(vec![Alignment::Left])),
11122|      1|            Event::Start(Tag::TableRow),
11123|      1|            Event::Start(Tag::TableCell),
11124|      1|            Event::Text("R".into()),
11125|      1|            Event::End(Tag::TableCell),
11126|       |        ];
11127|      1|        let (headers, rows, next) = renderer.parse_table(&events, 1)?;
                                                                                  ^0
11128|      1|        assert!(headers.is_empty());
11129|      1|        assert!(rows.is_empty());
11130|      1|        assert_eq!(next, events.len());
11131|      1|        Ok(())
11132|      1|    }
11133|       |
11134|       |    #[test]
11135|      1|    fn test_parse_table_head_skips_noise() -> Result<()> {
11136|      1|        let renderer = MarkdownRenderer::new();
11137|      1|        let alignments = vec![Alignment::Left];
11138|      1|        let events = vec![
11139|      1|            Event::Start(Tag::Table(alignments.clone())),
11140|      1|            Event::Start(Tag::TableHead),
11141|      1|            Event::Text("noise".into()),
11142|      1|            Event::Start(Tag::TableCell),
11143|      1|            Event::Text("H".into()),
11144|      1|            Event::End(Tag::TableCell),
11145|      1|            Event::End(Tag::TableHead),
11146|      1|            Event::End(Tag::Table(alignments)),
11147|       |        ];
11148|      1|        let (headers, rows, next) = renderer.parse_table(&events, 1)?;
                                                                                  ^0
11149|      1|        assert_eq!(headers.len(), 1);
11150|      1|        assert!(rows.is_empty());
11151|      1|        assert_eq!(next, events.len());
11152|      1|        Ok(())
11153|      1|    }
11154|       |
11155|       |    #[test]
11156|      1|    fn test_parse_table_empty_row_skips_row() -> Result<()> {
11157|      1|        let renderer = MarkdownRenderer::new();
11158|      1|        let alignments = vec![Alignment::Left];
11159|      1|        let events = vec![
11160|      1|            Event::Start(Tag::Table(alignments.clone())),
11161|      1|            Event::Start(Tag::TableRow),
11162|      1|            Event::End(Tag::TableRow),
11163|      1|            Event::End(Tag::Table(alignments)),
11164|       |        ];
11165|      1|        let (headers, rows, next) = renderer.parse_table(&events, 1)?;
                                                                                  ^0
11166|      1|        assert!(headers.is_empty());
11167|      1|        assert!(rows.is_empty());
11168|      1|        assert_eq!(next, events.len());
11169|      1|        Ok(())
11170|      1|    }
11171|       |
11172|       |    #[test]
11173|      1|    fn test_parse_code_block_unclosed() -> Result<()> {
11174|      1|        let renderer = MarkdownRenderer::new();
11175|      1|        let events = vec![
11176|      1|            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
11177|      1|                "rust".into(),
11178|      1|            ))),
11179|      1|            Event::Text("fn main() {}".into()),
11180|      1|            Event::Html("<span>".into()),
11181|       |        ];
11182|      1|        let (code, language, next) = renderer.parse_code_block(&events, 0)?;
                                                                                        ^0
11183|      1|        assert_eq!(language.as_deref(), Some("rust"));
11184|      1|        assert_eq!(code, "fn main() {}");
11185|      1|        assert_eq!(next, events.len());
11186|      1|        Ok(())
11187|      1|    }
11188|       |
11189|       |    #[test]
11190|      1|    fn test_parse_code_block_without_start_tag() -> Result<()> {
11191|      1|        let renderer = MarkdownRenderer::new();
11192|      1|        let events = vec![
11193|      1|            Event::Text("fn main() {}".into()),
11194|      1|            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Indented)),
11195|       |        ];
11196|      1|        let (code, language, next) = renderer.parse_code_block(&events, 0)?;
                                                                                        ^0
11197|      1|        assert_eq!(language, None);
11198|      1|        assert_eq!(code, "fn main() {}");
11199|      1|        assert_eq!(next, events.len());
11200|      1|        Ok(())
11201|      1|    }
11202|       |
11203|       |    #[test]
11204|      1|    fn test_has_pipe_outside_inline_code_backticks() {
11205|      1|        assert!(MarkdownRenderer::has_pipe_outside_inline_code(r"\`|`"));
11206|      1|        assert!(!MarkdownRenderer::has_pipe_outside_inline_code("``a|b``"));
11207|      1|    }
11208|       |
11209|       |    #[test]
11210|      1|    fn test_row_needs_height_estimate_variants() {
11211|      1|        let renderer = MarkdownRenderer::new();
11212|      1|        let row_with_image = vec![vec![InlineSpan::Image {
11213|      1|            src: "missing.png".to_string(),
11214|      1|            alt: "Alt".to_string(),
11215|      1|            title: None,
11216|      1|        }]];
11217|      1|        assert!(renderer.row_needs_height_estimate(&row_with_image));
11218|       |
11219|      1|        let row_with_newline = vec![vec![InlineSpan::Text("line1\nline2".to_string())]];
11220|      1|        assert!(renderer.row_needs_height_estimate(&row_with_newline));
11221|       |
11222|      1|        let row_plain = vec![vec![InlineSpan::Text("plain".to_string())]];
11223|      1|        assert!(!renderer.row_needs_height_estimate(&row_plain));
11224|      1|    }
11225|       |
11226|       |    #[test]
11227|      1|    fn test_is_allowed_scheme_variants() {
11228|      1|        assert!(MarkdownRenderer::is_allowed_scheme("http://example.com"));
11229|      1|        assert!(MarkdownRenderer::is_allowed_scheme("https://example.com"));
11230|      1|        assert!(MarkdownRenderer::is_allowed_scheme(
11231|      1|            "mailto:test@example.com"
11232|       |        ));
11233|      1|        assert!(!MarkdownRenderer::is_allowed_scheme("ftp://example.com"));
11234|      1|    }
11235|       |
11236|       |    #[test]
11237|      1|    fn test_render_table_tablebuilder_scaled_down_adjustments() {
11238|      1|        let renderer = MarkdownRenderer::new();
11239|      1|        let headers = vec![
11240|      1|            vec![InlineSpan::Text("A".to_string())],
11241|      1|            vec![InlineSpan::Text("B".to_string())],
11242|      1|            vec![InlineSpan::Text("C".to_string())],
11243|       |        ];
11244|      1|        let rows = vec![vec![
11245|      1|            vec![InlineSpan::Text("row1".to_string())],
11246|      1|            vec![InlineSpan::Text("row2".to_string())],
11247|      1|            vec![InlineSpan::Text("row3".to_string())],
11248|       |        ]];
11249|      1|        let ctx = egui::Context::default();
11250|      1|        let widths = [220.0, 240.0];
11251|      2|        for (idx, width) in widths.iter().enumerate() {
                                          ^1     ^1     ^1
11252|      2|            let _forced = ForcedTablePolicies::new(vec![
11253|      2|                ColumnPolicy::Resizable {
11254|      2|                    min: 40.0,
11255|      2|                    preferred: 200.0,
11256|      2|                    clip: false,
11257|      2|                },
11258|      2|                ColumnPolicy::Auto,
11259|      2|                ColumnPolicy::Remainder { clip: false },
11260|       |            ]);
11261|      2|            let input = egui::RawInput {
11262|      2|                screen_rect: Some(egui::Rect::from_min_size(
11263|      2|                    egui::pos2(0.0, 0.0),
11264|      2|                    egui::vec2(*width, 120.0),
11265|      2|                )),
11266|      2|                ..Default::default()
11267|      2|            };
11268|      2|            run_frame_with_input(&ctx, input, |_, ui| {
11269|      2|                ui.spacing_mut().item_spacing.x = 2.0;
11270|      2|                let table_id = renderer.compute_table_id(&headers, &rows, &[], 90 + idx as u64);
11271|      2|                renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
11272|      2|            });
11273|       |        }
11274|      1|    }
11275|       |
11276|       |    #[test]
11277|      1|    fn test_render_code_block_mermaid_and_context_menu() {
11278|      1|        let renderer = MarkdownRenderer::new();
11279|      1|        let _guard = EnvVarGuard::set("MDMDVIEW_MERMAID_RENDERER", "off");
11280|      1|        with_test_ui(|_, ui| {
11281|      1|            renderer.render_code_block(ui, Some("mermaid"), "graph TD; A-->B;");
11282|      1|        });
11283|       |
11284|      1|        let ctx = egui::Context::default();
11285|      1|        let click = input_with_click(egui::pos2(12.0, 12.0), egui::PointerButton::Secondary);
11286|      1|        run_frame_with_input(&ctx, click, |_, ui| {
11287|      1|            renderer.render_code_block(ui, Some("rust"), "fn main() {}");
11288|      1|        });
11289|      1|        let input = egui::RawInput {
11290|      1|            screen_rect: Some(egui::Rect::from_min_size(
11291|      1|                egui::pos2(0.0, 0.0),
11292|      1|                egui::vec2(320.0, 240.0),
11293|      1|            )),
11294|      1|            ..Default::default()
11295|      1|        };
11296|      1|        run_frame_with_input(&ctx, input, |_, ui| {
11297|      1|            renderer.render_code_block(ui, Some("rust"), "fn main() {}");
11298|      1|        });
11299|      1|    }
11300|       |
11301|       |    #[test]
11302|      1|    fn test_render_code_block_highlight_styles() {
11303|      1|        let mut renderer = MarkdownRenderer::new();
11304|      1|        let theme = renderer
11305|      1|            .theme_set
11306|      1|            .themes
11307|      1|            .get_mut("base16-ocean.dark")
11308|      1|            .expect("theme");
11309|      1|        theme.scopes.clear();
11310|      1|        let selector = ScopeSelectors::from_str("source.rust").expect("selector");
11311|      1|        theme.scopes.push(ThemeItem {
11312|      1|            scope: selector,
11313|      1|            style: StyleModifier {
11314|      1|                foreground: Some(Color::WHITE),
11315|      1|                background: Some(Color::BLACK),
11316|      1|                font_style: Some(FontStyle::BOLD | FontStyle::ITALIC),
11317|      1|            },
11318|      1|        });
11319|      1|        with_test_ui(|_, ui| {
11320|      1|            renderer.render_code_block(ui, Some("rust"), "fn main() {}");
11321|      1|        });
11322|      1|    }
11323|       |
11324|       |    #[test]
11325|      1|    fn test_render_code_block_highlight_and_fallback() {
11326|      1|        let renderer = MarkdownRenderer::new();
11327|      1|        let code = "fn main() {\n    let value = 1;\n    // comment with  spaces\n    \n}\n";
11328|      1|        with_test_ui(|_, ui| {
11329|      1|            renderer.render_code_block(ui, Some("rust"), code);
11330|      1|        });
11331|       |
11332|      1|        let mut fallback_renderer = MarkdownRenderer::new();
11333|      1|        fallback_renderer.syntax_set = SyntaxSet::new();
11334|      1|        with_test_ui(|_, ui| {
11335|      1|            fallback_renderer.render_code_block(ui, Some("notalanguage"), "code");
11336|      1|        });
11337|      1|    }
11338|       |
11339|       |    #[test]
11340|      1|    fn test_to_superscript_maps_values() {
11341|      1|        let mapped = MarkdownRenderer::to_superscript("Abc123!");
11342|      1|        assert_ne!(mapped, "Abc123!");
11343|      1|    }
11344|       |
11345|       |    #[test]
11346|      1|    fn test_cell_single_emoji_whitespace_only() {
11347|      1|        let renderer = MarkdownRenderer::new();
11348|      1|        let spans = vec![InlineSpan::Text("   ".to_string())];
11349|      1|        assert!(renderer.cell_single_emoji(&spans).is_none());
11350|      1|    }
11351|       |
11352|       |    #[test]
11353|      1|    fn test_table_line_info_with_list_fallback_indent() {
11354|      1|        let line = "  >| A |";
11355|      1|        let (level, rest) = MarkdownRenderer::table_line_info_with_list(line, Some(2));
11356|      1|        assert_eq!(level, 1);
11357|      1|        assert!(rest.starts_with('|'));
11358|      1|    }
11359|       |
11360|       |    #[test]
11361|      1|    fn test_list_marker_info_any_indent_missing_punctuation() {
11362|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("1 item").is_none());
11363|      1|    }
11364|       |
11365|       |    #[test]
11366|      1|    fn test_strip_indent_columns_rejects_non_whitespace() {
11367|      1|        assert!(MarkdownRenderer::strip_indent_columns("x", 1).is_none());
11368|      1|    }
11369|       |
11370|       |    #[test]
11371|      1|    fn test_parse_element_image_empty_title_outside_paragraph() -> Result<()> {
11372|      1|        let renderer = MarkdownRenderer::new();
11373|      1|        let events = vec![
11374|      1|            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
11375|      1|            Event::Text("alt".into()),
11376|      1|            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
11377|       |        ];
11378|      1|        let mut elements = Vec::new();
11379|      1|        let mut slugs = HashMap::new();
11380|      1|        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs)?;
                                                                                              ^0
11381|      1|        assert_eq!(next, events.len());
11382|      1|        let spans = paragraph_spans(&elements[0]).expect("paragraph spans");
11383|      1|        let (_src, _alt, title) = image_span_fields(&spans[0]).expect("image span");
11384|      1|        assert!(title.is_none());
11385|      1|        Ok(())
11386|      1|    }
11387|       |
11388|       |    #[test]
11389|      1|    fn test_slugify_trailing_dash_trimmed() {
11390|      1|        let slug = MarkdownRenderer::slugify("Hello - ");
11391|      1|        assert_eq!(slug, "hello");
11392|      1|    }
11393|       |
11394|       |    #[test]
11395|      1|    fn test_slugify_leading_whitespace_and_internal_spaces() {
11396|      1|        let slug = MarkdownRenderer::slugify("  Hello   World ");
11397|      1|        assert_eq!(slug, "hello-world");
11398|      1|    }
11399|       |
11400|       |    #[test]
11401|      1|    fn test_render_plain_and_highlight_empty_text() {
11402|      1|        let renderer = MarkdownRenderer::new();
11403|      1|        with_test_ui(|_, ui| {
11404|      1|            ui.visuals_mut().override_text_color = Some(Color32::from_rgb(10, 20, 30));
11405|      1|            let style = InlineStyle {
11406|      1|                strong: true,
11407|      1|                ..Default::default()
11408|      1|            };
11409|      1|            renderer.render_plain_segment(ui, "", 12.0, style);
11410|      1|            renderer.render_plain_segment(ui, "Header", 12.0, style);
11411|      1|            renderer.render_highlighted_segment(ui, "", 12.0, style);
11412|      1|        });
11413|      1|    }
11414|       |
11415|       |    #[test]
11416|      1|    fn test_render_plain_segment_without_color_override() {
11417|      1|        let renderer = MarkdownRenderer::new();
11418|      1|        with_test_ui(|_, ui| {
11419|      1|            ui.visuals_mut().override_text_color = None;
11420|      1|            renderer.render_plain_segment(ui, "Plain", 12.0, InlineStyle::default());
11421|      1|        });
11422|      1|    }
11423|       |
11424|       |    #[test]
11425|      1|    fn test_emoji_key_for_grapheme_strips_vs16() {
11426|      1|        let renderer = MarkdownRenderer::new();
11427|      1|        let key = renderer.emoji_key_for_grapheme("\u{2705}\u{fe0f}");
11428|      1|        assert_eq!(key, Some("\u{2705}".to_string()));
11429|      1|    }
11430|       |
11431|       |    #[test]
11432|      1|    fn test_expand_superscripts_long_sequence_no_expand() {
11433|      1|        let input = "value^abcdefghijk^";
11434|      1|        let out = MarkdownRenderer::expand_superscripts(input);
11435|      1|        assert_eq!(out, input);
11436|      1|    }
11437|       |
11438|       |    #[test]
11439|      1|    fn test_compute_table_content_hash_stops_after_sample_rows() {
11440|      1|        let renderer = MarkdownRenderer::new();
11441|      1|        let headers = vec![vec![InlineSpan::Text("H".to_string())]];
11442|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = (0..(COLUMN_STATS_SAMPLE_ROWS + 1))
11443|    129|            .map(|idx| vec![vec![InlineSpan::Text(format!("R{idx}"))]])
                           ^1
11444|      1|            .collect();
11445|      1|        let hash = renderer.compute_table_content_hash(&headers, &rows, &[]);
11446|      1|        assert_ne!(hash, 0);
11447|      1|    }
11448|       |
11449|       |    #[test]
11450|      1|    fn test_table_width_helpers_empty_inputs() {
11451|      1|        let renderer = MarkdownRenderer::new();
11452|      1|        let table_id = 100u64;
11453|      1|        let mut specs: Vec<ColumnSpec> = Vec::new();
11454|      1|        renderer.apply_persisted_widths(table_id, &mut specs);
11455|      1|        renderer.persist_resizable_widths(table_id, &[], &[]);
11456|      1|        let change = renderer.record_resolved_widths(table_id, 0, &[]);
11457|      1|        assert!(matches!(change, WidthChange::None));
                              ^0
11458|      1|        assert!(renderer
11459|      1|            .resolve_table_column_widths(table_id, &[], 10.0)
11460|      1|            .is_empty());
11461|      1|        assert_eq!(renderer.estimate_table_total_width(table_id, &[], 6.0), 0.0);
11462|      1|        with_test_ui(|_, ui| {
11463|      1|            let style = ui.style().clone();
11464|      1|            let row = vec![vec![]];
11465|      1|            let height =
11466|      1|                renderer.estimate_table_row_height(ui, &style, &row, &[Align::LEFT], &[40.0], 12.0);
11467|      1|            assert_eq!(height, 12.0);
11468|      1|            let row = vec![
11469|      1|                vec![InlineSpan::Text("a".to_string())],
11470|      1|                vec![InlineSpan::Text("b".to_string())],
11471|       |            ];
11472|      1|            let height =
11473|      1|                renderer.estimate_table_row_height(ui, &style, &row, &[Align::LEFT], &[40.0], 12.0);
11474|      1|            assert!(height >= 12.0);
11475|      1|            let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(10.0, 10.0));
11476|      1|            renderer.paint_table_dividers(ui.painter(), ui.visuals(), rect, rect, &[], 0.0, 0.0);
11477|      1|        });
11478|      1|    }
11479|       |
11480|       |    #[test]
11481|      1|    fn test_resolve_table_column_widths_ignores_invalid_stored_widths() {
11482|      1|        let renderer = MarkdownRenderer::new();
11483|      1|        let table_id = 101u64;
11484|      1|        {
11485|      1|            let mut metrics = renderer.table_metrics.borrow_mut();
11486|      1|            let entry = metrics.entry_mut(table_id);
11487|      1|            entry.resolved_widths = vec![f32::NAN, -5.0];
11488|      1|        }
11489|      1|        let specs = vec![
11490|      1|            ColumnSpec::new(
11491|       |                0,
11492|       |                "A",
11493|      1|                ColumnPolicy::Resizable {
11494|      1|                    min: 20.0,
11495|      1|                    preferred: 40.0,
11496|      1|                    clip: false,
11497|      1|                },
11498|      1|                None,
11499|       |            ),
11500|      1|            ColumnSpec::new(1, "B", ColumnPolicy::Auto, None),
11501|       |        ];
11502|      1|        let widths = renderer.resolve_table_column_widths(table_id, &specs, 30.0);
11503|      1|        assert_eq!(widths, vec![40.0, 30.0]);
11504|      1|    }
11505|       |
11506|       |    #[test]
11507|      1|    fn test_persist_resizable_widths_stores_new_width() {
11508|      1|        let renderer = MarkdownRenderer::new();
11509|      1|        let table_id = 200u64;
11510|      1|        let specs = vec![ColumnSpec::new(
11511|       |            0,
11512|       |            "A",
11513|      1|            ColumnPolicy::Resizable {
11514|      1|                min: 20.0,
11515|      1|                preferred: 100.0,
11516|      1|                clip: false,
11517|      1|            },
11518|      1|            None,
11519|       |        )];
11520|      1|        let widths = vec![140.0f32];
11521|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
11522|      1|        let metrics = renderer.table_metrics.borrow();
11523|      1|        let entry = metrics.entry(table_id).expect("entry created");
11524|      1|        assert_eq!(entry.persisted_width(specs[0].policy_hash), Some(140.0));
11525|      1|    }
11526|       |
11527|       |    #[test]
11528|      1|    fn test_persist_resizable_widths_skips_small_delta() {
11529|      1|        let renderer = MarkdownRenderer::new();
11530|      1|        let table_id = 201u64;
11531|      1|        let spec = ColumnSpec::new(
11532|       |            0,
11533|       |            "A",
11534|      1|            ColumnPolicy::Resizable {
11535|      1|                min: 20.0,
11536|      1|                preferred: 100.0,
11537|      1|                clip: false,
11538|      1|            },
11539|      1|            None,
11540|       |        );
11541|      1|        let hash = spec.policy_hash;
11542|      1|        let specs = vec![spec];
11543|      1|        renderer.persist_resizable_widths(table_id, &specs, &[120.0]);
11544|      1|        renderer.persist_resizable_widths(table_id, &specs, &[120.2]);
11545|      1|        let metrics = renderer.table_metrics.borrow();
11546|      1|        let entry = metrics.entry(table_id).expect("entry created");
11547|      1|        let stored = entry.persisted_width(hash).unwrap_or_default();
11548|      1|        assert!((stored - 120.0).abs() < 0.01);
11549|      1|    }
11550|       |
11551|       |    #[test]
11552|      1|    fn test_persist_resizable_widths_updates_on_large_delta() {
11553|      1|        let renderer = MarkdownRenderer::new();
11554|      1|        let table_id = 202u64;
11555|      1|        let spec = ColumnSpec::new(
11556|       |            0,
11557|       |            "A",
11558|      1|            ColumnPolicy::Resizable {
11559|      1|                min: 20.0,
11560|      1|                preferred: 100.0,
11561|      1|                clip: false,
11562|      1|            },
11563|      1|            None,
11564|       |        );
11565|      1|        let hash = spec.policy_hash;
11566|      1|        let specs = vec![spec];
11567|      1|        renderer.persist_resizable_widths(table_id, &specs, &[120.0]);
11568|      1|        renderer.persist_resizable_widths(table_id, &specs, &[130.0]);
11569|      1|        let metrics = renderer.table_metrics.borrow();
11570|      1|        let entry = metrics.entry(table_id).expect("entry created");
11571|      1|        assert_eq!(entry.persisted_width(hash), Some(130.0));
11572|      1|    }
11573|       |
11574|       |    #[test]
11575|      1|    fn test_paint_table_dividers_draws_header_separator() {
11576|      1|        let renderer = MarkdownRenderer::new();
11577|      1|        with_test_ui(|_, ui| {
11578|      1|            let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(120.0, 40.0));
11579|      1|            renderer.paint_table_dividers(
11580|      1|                ui.painter(),
11581|      1|                ui.visuals(),
11582|      1|                rect,
11583|      1|                rect,
11584|      1|                &[40.0, 60.0],
11585|       |                8.0,
11586|       |                12.0,
11587|       |            );
11588|      1|        });
11589|      1|    }
11590|       |
11591|       |    #[test]
11592|      1|    fn test_paint_table_dividers_no_header_height() {
11593|      1|        let renderer = MarkdownRenderer::new();
11594|      1|        with_test_ui(|_, ui| {
11595|      1|            let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(120.0, 20.0));
11596|      1|            renderer.paint_table_dividers(
11597|      1|                ui.painter(),
11598|      1|                ui.visuals(),
11599|      1|                rect,
11600|      1|                rect,
11601|      1|                &[40.0, 60.0],
11602|       |                0.0,
11603|       |                8.0,
11604|       |            );
11605|      1|        });
11606|      1|    }
11607|       |
11608|       |    #[test]
11609|      1|    fn test_paint_table_dividers_skips_header_separator_out_of_bounds() {
11610|      1|        let renderer = MarkdownRenderer::new();
11611|      1|        with_test_ui(|_, ui| {
11612|      1|            let rect = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(120.0, 20.0));
11613|      1|            renderer.paint_table_dividers(
11614|      1|                ui.painter(),
11615|      1|                ui.visuals(),
11616|      1|                rect,
11617|      1|                rect,
11618|      1|                &[40.0, 60.0],
11619|       |                8.0,
11620|       |                60.0,
11621|       |            );
11622|      1|        });
11623|      1|    }
11624|       |
11625|       |    #[test]
11626|      1|    fn test_paint_table_text_job_adds_hover_for_wrapped_text() {
11627|      1|        let renderer = MarkdownRenderer::new();
11628|      1|        let spans = vec![InlineSpan::Text(
11629|      1|            "This is a long line that should wrap in a narrow cell.".to_string(),
11630|      1|        )];
11631|      1|        with_test_ui(|_, ui| {
11632|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 20.0, false, Align::LEFT);
11633|      1|            let _response = renderer.paint_table_text_job(ui, 20.0, build);
11634|      1|        });
11635|      1|    }
11636|       |
11637|       |    #[test]
11638|      1|    fn test_paint_table_text_job_adds_hover_for_multiline_text() {
11639|      1|        let renderer = MarkdownRenderer::new();
11640|      1|        let spans = vec![InlineSpan::Text("Line 1\nLine 2".to_string())];
11641|      1|        with_test_ui(|_, ui| {
11642|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, false, Align::LEFT);
11643|      1|            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11644|      1|            assert!(galley.rows.len() > 1);
11645|      1|            let _response = renderer.paint_table_text_job(ui, 200.0, build);
11646|      1|        });
11647|      1|    }
11648|       |
11649|       |    #[test]
11650|      1|    fn test_paint_table_text_job_skips_hover_for_short_text() {
11651|      1|        let renderer = MarkdownRenderer::new();
11652|      1|        let spans = vec![InlineSpan::Text("Short".to_string())];
11653|      1|        with_test_ui(|_, ui| {
11654|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, false, Align::LEFT);
11655|      1|            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11656|      1|            assert_eq!(galley.rows.len(), 1);
11657|      1|            assert!(galley.size().x < 200.0);
11658|      1|            let _response = renderer.paint_table_text_job(ui, 200.0, build);
11659|      1|        });
11660|      1|    }
11661|       |
11662|       |    #[test]
11663|      1|    fn test_paint_table_text_job_adds_hover_for_single_line_overflow() {
11664|      1|        let renderer = MarkdownRenderer::new();
11665|      1|        let spans = vec![InlineSpan::Text(
11666|      1|            "This is a single line that should overflow the render width.".to_string(),
11667|      1|        )];
11668|      1|        with_test_ui(|_, ui| {
11669|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 400.0, false, Align::LEFT);
11670|      1|            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11671|      1|            assert_eq!(galley.rows.len(), 1);
11672|      1|            assert!(galley.size().x > 40.0);
11673|      1|            let _response = renderer.paint_table_text_job(ui, 40.0, build);
11674|      1|        });
11675|      1|    }
11676|       |
11677|       |    #[test]
11678|      1|    fn test_link_at_pointer_outside_text_rect() {
11679|      1|        let renderer = MarkdownRenderer::new();
11680|      1|        let spans = vec![InlineSpan::Link {
11681|      1|            text: "link".to_string(),
11682|      1|            url: "https://example.com".to_string(),
11683|      1|        }];
11684|      1|        let ctx = egui::Context::default();
11685|      1|        let outside_pos = std::cell::Cell::new(egui::pos2(1.0, 1.0));
11686|      1|        let layout_input = egui::RawInput {
11687|      1|            screen_rect: Some(egui::Rect::from_min_size(
11688|      1|                egui::pos2(0.0, 0.0),
11689|      1|                egui::vec2(220.0, 120.0),
11690|      1|            )),
11691|      1|            ..Default::default()
11692|      1|        };
11693|      1|        run_frame_with_input(&ctx, layout_input, |_, ui| {
11694|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 40.0, false, Align::LEFT);
11695|      1|            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11696|      1|            let (rect, _response) =
11697|      1|                ui.allocate_exact_size(egui::vec2(200.0, galley.size().y), egui::Sense::hover());
11698|      1|            let text_origin =
11699|      1|                MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
11700|      1|            let text_rect = galley.rect.translate(text_origin.to_vec2());
11701|      1|            let pos = egui::pos2(rect.right() - 2.0, text_rect.center().y);
11702|      1|            assert!(pos.x > text_rect.right());
11703|      1|            outside_pos.set(pos);
11704|      1|        });
11705|       |
11706|      1|        let mut input = egui::RawInput {
11707|      1|            screen_rect: Some(egui::Rect::from_min_size(
11708|      1|                egui::pos2(0.0, 0.0),
11709|      1|                egui::vec2(220.0, 120.0),
11710|      1|            )),
11711|      1|            ..Default::default()
11712|      1|        };
11713|      1|        input
11714|      1|            .events
11715|      1|            .push(egui::Event::PointerMoved(outside_pos.get()));
11716|      1|        run_frame_with_input(&ctx, input, |_, ui| {
11717|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 40.0, false, Align::LEFT);
11718|      1|            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11719|      1|            let (rect, response) =
11720|      1|                ui.allocate_exact_size(egui::vec2(200.0, galley.size().y), egui::Sense::hover());
11721|      1|            let text_origin =
11722|      1|                MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
11723|      1|            let link = renderer.link_at_pointer(&response, &galley, &build, text_origin);
11724|      1|            assert!(link.is_none());
11725|      1|        });
11726|      1|    }
11727|       |
11728|       |    #[test]
11729|      1|    fn test_link_at_pointer_inside_text_rect_returns_link() {
11730|      1|        let renderer = MarkdownRenderer::new();
11731|      1|        let spans = vec![InlineSpan::Link {
11732|      1|            text: "link".to_string(),
11733|      1|            url: "#anchor".to_string(),
11734|      1|        }];
11735|      1|        let ctx = egui::Context::default();
11736|      1|        let click_pos = std::cell::Cell::new(egui::pos2(1.0, 1.0));
11737|      1|        let layout_input = egui::RawInput {
11738|      1|            screen_rect: Some(egui::Rect::from_min_size(
11739|      1|                egui::pos2(0.0, 0.0),
11740|      1|                egui::vec2(220.0, 120.0),
11741|      1|            )),
11742|      1|            ..Default::default()
11743|      1|        };
11744|      1|        run_frame_with_input(&ctx, layout_input, |_, ui| {
11745|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 40.0, false, Align::LEFT);
11746|      1|            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11747|      1|            let (rect, _response) =
11748|      1|                ui.allocate_exact_size(egui::vec2(200.0, galley.size().y), egui::Sense::hover());
11749|      1|            let text_origin =
11750|      1|                MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
11751|      1|            click_pos.set(text_origin + egui::vec2(2.0, 2.0));
11752|      1|        });
11753|       |
11754|      1|        let mut input = egui::RawInput {
11755|      1|            screen_rect: Some(egui::Rect::from_min_size(
11756|      1|                egui::pos2(0.0, 0.0),
11757|      1|                egui::vec2(220.0, 120.0),
11758|      1|            )),
11759|      1|            ..Default::default()
11760|      1|        };
11761|      1|        input
11762|      1|            .events
11763|      1|            .push(egui::Event::PointerMoved(click_pos.get()));
11764|      1|        run_frame_with_input(&ctx, input, |_, ui| {
11765|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 40.0, false, Align::LEFT);
11766|      1|            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
11767|      1|            let (rect, response) =
11768|      1|                ui.allocate_exact_size(egui::vec2(200.0, galley.size().y), egui::Sense::hover());
11769|      1|            let text_origin =
11770|      1|                MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
11771|      1|            let link = renderer.link_at_pointer(&response, &galley, &build, text_origin);
11772|      1|            assert!(link.is_some());
11773|      1|        });
11774|      1|    }
11775|       |
11776|       |    #[test]
11777|      1|    fn test_element_plain_text_list_quote_table_spacing() {
11778|      1|        let list = MarkdownElement::List {
11779|      1|            ordered: false,
11780|      1|            items: vec![ListItem {
11781|      1|                blocks: vec![
11782|      1|                    MarkdownElement::Paragraph(vec![InlineSpan::Text("One".to_string())]),
11783|      1|                    MarkdownElement::Paragraph(vec![InlineSpan::Text("Two".to_string())]),
11784|      1|                ],
11785|      1|            }],
11786|      1|        };
11787|      1|        let list_text = MarkdownRenderer::element_plain_text(&list);
11788|      1|        assert!(list_text.contains('\n'));
11789|       |
11790|      1|        let quote = MarkdownElement::Quote {
11791|      1|            depth: 1,
11792|      1|            blocks: vec![
11793|      1|                MarkdownElement::Paragraph(vec![InlineSpan::Text("Alpha".to_string())]),
11794|      1|                MarkdownElement::Paragraph(vec![InlineSpan::Text("Beta".to_string())]),
11795|      1|            ],
11796|      1|        };
11797|      1|        let quote_text = MarkdownRenderer::element_plain_text(&quote);
11798|      1|        assert!(quote_text.contains('\n'));
11799|       |
11800|      1|        let table = MarkdownElement::Table {
11801|      1|            headers: vec![
11802|      1|                vec![InlineSpan::Text("H1".to_string())],
11803|      1|                vec![InlineSpan::Text("H2".to_string())],
11804|      1|            ],
11805|      1|            rows: vec![vec![
11806|      1|                vec![InlineSpan::Text("A".to_string())],
11807|      1|                vec![InlineSpan::Text("B".to_string())],
11808|      1|            ]],
11809|      1|            alignments: vec![],
11810|      1|        };
11811|      1|        let table_text = MarkdownRenderer::element_plain_text(&table);
11812|      1|        assert_eq!(table_text, "H1 H2 A B");
11813|      1|    }
11814|       |
11815|       |    #[test]
11816|      1|    fn test_resolve_image_path_data_uri_and_remote_texture_reject() {
11817|      1|        let renderer = MarkdownRenderer::new();
11818|      1|        let data_uri = "data:image/png;base64,AAAA";
11819|      1|        assert_eq!(renderer.resolve_image_path(data_uri), data_uri);
11820|      1|        with_test_ui(|_, ui| {
11821|      1|            assert!(renderer
11822|      1|                .get_or_load_image_texture(ui, "https://example.com/image.png")
11823|      1|                .is_none());
11824|      1|            assert!(renderer
11825|      1|                .get_or_load_image_texture(ui, "http://example.com/image.png")
11826|      1|                .is_none());
11827|      1|        });
11828|      1|    }
11829|       |
11830|       |    #[test]
11831|      1|    fn test_is_html_line_break_rejects_non_br() {
11832|      1|        assert!(!MarkdownRenderer::is_html_line_break("<div>"));
11833|      1|        assert!(!MarkdownRenderer::is_html_line_break("br"));
11834|      1|    }
11835|       |
11836|       |    #[test]
11837|      1|    fn test_table_line_info_variants_cover_edges() {
11838|      1|        let (level, rest) = MarkdownRenderer::table_line_info("text");
11839|      1|        assert_eq!(level, 0);
11840|      1|        assert_eq!(rest, "text");
11841|       |
11842|      1|        let (level, rest) = MarkdownRenderer::table_line_info("   text");
11843|      1|        assert_eq!(level, 0);
11844|      1|        assert_eq!(rest, "   text");
11845|       |
11846|      1|        let (level, rest) = MarkdownRenderer::table_line_info(">abc");
11847|      1|        assert_eq!(level, 1);
11848|      1|        assert_eq!(rest, "abc");
11849|       |
11850|      1|        let (level, rest) = MarkdownRenderer::table_line_info(" >\tabc");
11851|      1|        assert_eq!(level, 1);
11852|      1|        assert_eq!(rest, "abc");
11853|       |
11854|      1|        let (level, rest) = MarkdownRenderer::table_line_info(">");
11855|      1|        assert_eq!(level, 1);
11856|      1|        assert_eq!(rest, "");
11857|      1|    }
11858|       |
11859|       |    #[test]
11860|      1|    fn test_list_marker_info_rejects_missing_delimiter_or_spacing() {
11861|      1|        assert!(MarkdownRenderer::list_marker_info("1 item").is_none());
11862|      1|        assert!(MarkdownRenderer::list_marker_info("1.item").is_none());
11863|      1|    }
11864|       |
11865|       |    #[test]
11866|      1|    fn test_list_marker_info_numeric_missing_punctuation() {
11867|      1|        assert!(MarkdownRenderer::list_marker_info("12").is_none());
11868|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("  12").is_none());
11869|      1|    }
11870|       |
11871|       |    #[test]
11872|      1|    fn test_list_marker_info_any_indent_rejects_missing_delimiter_or_spacing() {
11873|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("   1 item").is_none());
11874|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("  2.item").is_none());
11875|      1|    }
11876|       |
11877|       |    #[test]
11878|      1|    fn test_strip_indent_columns_insufficient_indent_returns_none() {
11879|      1|        assert!(MarkdownRenderer::strip_indent_columns("  text", 4).is_none());
11880|      1|    }
11881|       |
11882|       |    #[test]
11883|      1|    fn test_strip_indent_columns_whitespace_short_returns_none() {
11884|      1|        assert!(MarkdownRenderer::strip_indent_columns("  ", 4).is_none());
11885|      1|    }
11886|       |
11887|       |    #[test]
11888|      1|    fn test_has_pipe_outside_inline_code_unmatched_backticks() {
11889|      1|        let line = "`code`` | still in code";
11890|      1|        assert!(!MarkdownRenderer::has_pipe_outside_inline_code(line));
11891|      1|    }
11892|       |
11893|       |    #[test]
11894|      1|    fn test_is_table_delimiter_line_requires_dash_and_pipe() {
11895|      1|        assert!(!MarkdownRenderer::is_table_delimiter_line("----"));
11896|      1|        assert!(!MarkdownRenderer::is_table_delimiter_line("| ::: |"));
11897|      1|    }
11898|       |
11899|       |    #[test]
11900|      1|    fn test_append_text_sections_preserves_color_when_highlighted() {
11901|      1|        let renderer = MarkdownRenderer::new();
11902|      1|        let style = egui::Style::default();
11903|      1|        let mut job = LayoutJob::default();
11904|      1|        let mut plain_text = String::new();
11905|      1|        let inline_style = InlineStyle {
11906|      1|            strong: false,
11907|      1|            italics: false,
11908|      1|            strike: false,
11909|      1|            color: Some(Color32::from_rgb(10, 20, 30)),
11910|      1|        };
11911|      1|        let count = renderer.append_text_sections(
11912|      1|            &style,
11913|      1|            &mut job,
11914|      1|            &mut plain_text,
11915|      1|            "hit",
11916|      1|            renderer.font_sizes.body,
11917|      1|            inline_style,
11918|      1|            Some("hit"),
11919|       |        );
11920|      1|        assert_eq!(count, 3);
11921|      1|        assert_eq!(plain_text, "hit");
11922|      1|    }
11923|       |
11924|       |    #[test]
11925|      1|    fn test_render_text_with_emojis_leading_emoji() {
11926|      1|        let renderer = MarkdownRenderer::new();
11927|      1|        with_test_ui(|_, ui| {
11928|      1|            renderer.render_text_with_emojis(ui, " test", 14.0, InlineStyle::default());
11929|      1|        });
11930|      1|    }
11931|       |
11932|       |    #[test]
11933|      1|    fn test_persist_resizable_widths_records_change() {
11934|      1|        let renderer = MarkdownRenderer::new();
11935|      1|        let spec = ColumnSpec::new(
11936|       |            0,
11937|       |            "col",
11938|      1|            ColumnPolicy::Resizable {
11939|      1|                min: 40.0,
11940|      1|                preferred: 80.0,
11941|      1|                clip: false,
11942|      1|            },
11943|      1|            None,
11944|       |        );
11945|      1|        let hash = spec.policy_hash;
11946|      1|        renderer.persist_resizable_widths(42, &[spec], &[120.0]);
11947|      1|        let metrics = renderer.table_metrics.borrow();
11948|      1|        let entry = metrics.entry(42).expect("metrics entry");
11949|      1|        assert_eq!(entry.persisted_width(hash), Some(120.0));
11950|      1|    }
11951|       |
11952|       |    #[test]
11953|      1|    fn test_env_var_guard_restores_previous_value() {
11954|      1|        std::env::set_var("MDMDVIEW_TEST_ENV", "before");
11955|       |        {
11956|      1|            let _guard = EnvVarGuard::set("MDMDVIEW_TEST_ENV", "after");
11957|      1|            assert_eq!(
11958|      1|                std::env::var("MDMDVIEW_TEST_ENV").ok().as_deref(),
11959|       |                Some("after")
11960|       |            );
11961|       |        }
11962|      1|        assert_eq!(
11963|      1|            std::env::var("MDMDVIEW_TEST_ENV").ok().as_deref(),
11964|       |            Some("before")
11965|       |        );
11966|      1|        std::env::remove_var("MDMDVIEW_TEST_ENV");
11967|      1|    }
11968|       |
11969|       |    #[test]
11970|      1|    fn test_parse_element_skips_unhandled_event() -> Result<()> {
11971|      1|        let renderer = MarkdownRenderer::new();
11972|      1|        let events = vec![Event::Text("orphan".into())];
11973|      1|        let mut elements = Vec::new();
11974|      1|        let mut slugs = std::collections::HashMap::new();
11975|      1|        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs)?;
                                                                                              ^0
11976|      1|        assert_eq!(next, events.len());
11977|      1|        assert!(elements.is_empty());
11978|      1|        Ok(())
11979|      1|    }
11980|       |
11981|       |    #[test]
11982|      1|    fn test_parse_inline_spans_link_and_image() {
11983|      1|        let renderer = MarkdownRenderer::new();
11984|      1|        let events = vec![
11985|      1|            Event::Start(Tag::Paragraph),
11986|      1|            Event::Start(Tag::Link(
11987|      1|                LinkType::Inline,
11988|      1|                "https://example.com".into(),
11989|      1|                "".into(),
11990|      1|            )),
11991|      1|            Event::Text("Link".into()),
11992|      1|            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
11993|      1|            Event::Start(Tag::Image(
11994|      1|                LinkType::Inline,
11995|      1|                "img.png".into(),
11996|      1|                "Title".into(),
11997|      1|            )),
11998|      1|            Event::Text("Alt".into()),
11999|      1|            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
12000|      1|            Event::End(Tag::Paragraph),
12001|       |        ];
12002|      1|        let (spans, next) = renderer.parse_inline_spans(&events, 1, Tag::Paragraph);
12003|      1|        assert_eq!(next, events.len());
12004|      1|        assert!(spans
12005|      1|            .iter()
12006|      1|            .any(|span| matches!(span, InlineSpan::Link { .. })));
12007|      1|        assert!(spans
12008|      1|            .iter()
12009|      2|            .any(|span| matches!(span, InlineSpan::Image { .. })));
                           ^1
12010|      1|    }
12011|       |
12012|       |    #[test]
12013|      1|    fn test_parse_inline_spans_with_breaks_link_and_image() {
12014|      1|        let renderer = MarkdownRenderer::new();
12015|      1|        let events = vec![
12016|      1|            Event::Start(Tag::Paragraph),
12017|      1|            Event::Start(Tag::Link(
12018|      1|                LinkType::Inline,
12019|      1|                "https://example.com".into(),
12020|      1|                "".into(),
12021|      1|            )),
12022|      1|            Event::Text("Link".into()),
12023|      1|            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
12024|      1|            Event::Start(Tag::Image(
12025|      1|                LinkType::Inline,
12026|      1|                "img.png".into(),
12027|      1|                "Title".into(),
12028|      1|            )),
12029|      1|            Event::Text("Alt".into()),
12030|      1|            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
12031|      1|            Event::End(Tag::Paragraph),
12032|       |        ];
12033|      1|        let (spans, next) =
12034|      1|            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, false);
12035|      1|        assert_eq!(next, events.len());
12036|      1|        assert!(spans
12037|      1|            .iter()
12038|      1|            .any(|span| matches!(span, InlineSpan::Link { .. })));
12039|      1|        assert!(spans
12040|      1|            .iter()
12041|      2|            .any(|span| matches!(span, InlineSpan::Image { .. })));
                           ^1
12042|      1|    }
12043|       |
12044|       |    #[test]
12045|      1|    fn test_parse_list_item_heading_builds_header() -> Result<()> {
12046|      1|        let renderer = MarkdownRenderer::new();
12047|      1|        let events = vec![
12048|      1|            Event::Start(Tag::List(None)),
12049|      1|            Event::Start(Tag::Item),
12050|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
12051|      1|            Event::Text("Title".into()),
12052|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
12053|      1|            Event::End(Tag::Item),
12054|      1|            Event::End(Tag::List(None)),
12055|       |        ];
12056|      1|        let mut slugs = std::collections::HashMap::new();
12057|      1|        let (items, next) = renderer.parse_list(&events, 1, &mut slugs)?;
                                                                                     ^0
12058|      1|        assert_eq!(next, events.len());
12059|      1|        assert!(matches!(items[0].blocks[0], MarkdownElement::Header { .. }));
                              ^0
12060|      1|        Ok(())
12061|      1|    }
12062|       |
12063|       |    #[test]
12064|      1|    fn test_parse_list_inline_formats_without_paragraph() -> Result<()> {
12065|      1|        let renderer = MarkdownRenderer::new();
12066|      1|        let events = vec![
12067|      1|            Event::Start(Tag::List(None)),
12068|      1|            Event::Start(Tag::Item),
12069|      1|            Event::Start(Tag::Emphasis),
12070|      1|            Event::Text("em".into()),
12071|      1|            Event::End(Tag::Emphasis),
12072|      1|            Event::Start(Tag::Strikethrough),
12073|      1|            Event::Text("strike".into()),
12074|      1|            Event::End(Tag::Strikethrough),
12075|      1|            Event::Start(Tag::Link(
12076|      1|                LinkType::Inline,
12077|      1|                "https://example.com".into(),
12078|      1|                "".into(),
12079|      1|            )),
12080|      1|            Event::Text("link".into()),
12081|      1|            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
12082|      1|            Event::Start(Tag::Image(
12083|      1|                LinkType::Inline,
12084|      1|                "img.png".into(),
12085|      1|                "Title".into(),
12086|      1|            )),
12087|      1|            Event::Text("Alt".into()),
12088|      1|            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
12089|      1|            Event::End(Tag::Item),
12090|      1|            Event::End(Tag::List(None)),
12091|       |        ];
12092|      1|        let mut slugs = std::collections::HashMap::new();
12093|      1|        let (items, next) = renderer.parse_list(&events, 1, &mut slugs)?;
                                                                                     ^0
12094|      1|        assert_eq!(next, events.len());
12095|      1|        assert!(matches!(items[0].blocks[0], MarkdownElement::Paragraph(_)));
                              ^0
12096|      1|        let dummy = MarkdownElement::HorizontalRule;
12097|      1|        let mut saw_paragraph = false;
12098|      2|        for element in [&items[0].blocks[0], &dummy] {
                                      ^1                   ^1
12099|      2|            match element {
12100|      1|                MarkdownElement::Paragraph(spans) => {
12101|      1|                    assert!(spans
12102|      1|                        .iter()
12103|      1|                        .any(|span| matches!(span, InlineSpan::Emphasis(_))));
12104|      1|                    assert!(spans
12105|      1|                        .iter()
12106|      2|                        .any(|span| matches!(span, InlineSpan::Strikethrough(_))));
                                       ^1
12107|      1|                    assert!(spans
12108|      1|                        .iter()
12109|      3|                        .any(|span| matches!(span, InlineSpan::Link { .. })));
                                       ^1
12110|      1|                    assert!(spans
12111|      1|                        .iter()
12112|      4|                        .any(|span| matches!(span, InlineSpan::Image { .. })));
                                       ^1
12113|      1|                    saw_paragraph = true;
12114|       |                }
12115|      1|                _ => {}
12116|       |            }
12117|       |        }
12118|      1|        assert!(saw_paragraph);
12119|      1|        Ok(())
12120|      1|    }
12121|       |
12122|       |    #[test]
12123|      1|    fn test_parse_table_parses_header_and_rows() -> Result<()> {
12124|      1|        let renderer = MarkdownRenderer::new();
12125|      1|        let alignments = vec![Alignment::Left];
12126|      1|        let events = vec![
12127|      1|            Event::Start(Tag::Table(alignments.clone())),
12128|      1|            Event::Start(Tag::TableHead),
12129|      1|            Event::Start(Tag::TableRow),
12130|      1|            Event::Start(Tag::TableCell),
12131|      1|            Event::Text("H".into()),
12132|      1|            Event::End(Tag::TableCell),
12133|      1|            Event::End(Tag::TableRow),
12134|      1|            Event::End(Tag::TableHead),
12135|      1|            Event::Start(Tag::TableRow),
12136|      1|            Event::Start(Tag::TableCell),
12137|      1|            Event::Text("A".into()),
12138|      1|            Event::End(Tag::TableCell),
12139|      1|            Event::End(Tag::TableRow),
12140|      1|            Event::End(Tag::Table(alignments)),
12141|       |        ];
12142|      1|        let (headers, rows, next) = renderer.parse_table(&events, 1)?;
                                                                                  ^0
12143|      1|        assert_eq!(next, events.len());
12144|      1|        assert_eq!(headers.len(), 1);
12145|      1|        assert_eq!(rows.len(), 1);
12146|      1|        Ok(())
12147|      1|    }
12148|       |}


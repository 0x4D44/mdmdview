# High-Level Design: Table Column and Border Fixes (Revision 2)

**Date:** 2025.11.14
**Author:** Claude
**Status:** Draft - Revision 2
**Related Documents:** 2025.11.14 - RSR - Table Rendering Research.md

**Revision History:**
- **Rev 1:** Initial design (2025.11.14)
- **Rev 2:** Critical issues identified, comprehensive root cause analysis, revised solutions (2025.11.14)

---

## 0. Revision Summary

This revision addresses **10 critical issues** discovered during design review:

### Critical Issues Found in Rev 1

1. **CRITICAL: Image Measurement Bug** - `measure_inline_spans` returns full `ui.available_width()` for cells with images, completely breaking column width calculations
2. **Missing: GFM Alignment Support** - Alignment info (left/center/right) is parsed but never rendered
3. **Incomplete: Border Implementation** - Doesn't address TableBuilder response types, striping conflicts, or clipping
4. **Missing: Concrete Debugging Plan** - No verification strategy before implementing fixes
5. **Assumption: Return Type Changes** - Assumes `render_overhauled_cell` can return Rect without verification
6. **Ignored: Legacy Path** - Legacy Grid renderer still enabled, not addressed
7. **Missing: Performance Analysis** - No frame-rate impact or caching strategy
8. **Incomplete: Test Coverage** - Missing tests for images in tables, alignment, ragged tables
9. **Risk: Breaking Changes** - Return type modifications could have ripple effects
10. **Missing: Visual Verification** - No confirmation that bug actually exists as described

### Key Improvements in Rev 2

✅ **Identified image measurement as likely primary root cause**
✅ **Added concrete 3-step debugging plan BEFORE implementation**
✅ **Revised border solution to use TableBuilder's actual API**
✅ **Comprehensive test strategy including visual regression**
✅ **Performance profiling requirements**
✅ **Phased rollout with feature flags**
✅ **Legacy path migration strategy**

---

## 1. Executive Summary

This HLD addresses two table rendering bugs in mdmdview:

1. **Column Width Bug:** Columns appear "off by one" - Examples column too narrow, Description too wide
2. **Border Rendering Bug:** Table dividing lines appear in odd locations or only show single line

**Rev 2 Update:** After thorough code review, discovered **image measurement bug** as likely primary root cause, plus 9 other issues requiring resolution.

**Recommended Approach:**
1. **Phase 0: Debug & Verify** (NEW) - Confirm root causes before coding
2. **Phase 1: Fix Image Measurement** - Address critical width calculation bug
3. **Phase 2: Fix Padding Column Policy** - Ensure single remainder column
4. **Phase 3: Implement Cell Dividers** - Manual painter-based borders
5. **Phase 4: Add GFM Alignment** - Render left/center/right alignment

**Estimated Effort:** 4-5 days (increased from 2-3 due to additional scope)
**Risk Level:** Medium-High (touching core rendering, potential for regressions)
**Backwards Compatibility:** Full (all changes gated by existing feature flags)

---

## 2. Problem Statement

### 2.1 Column Width Issue

**Reported Symptom:** In threat-model table, column widths are incorrect:
- Examples column (should be widest via Remainder policy) is too narrow
- Description column is too wide
- Appearance suggests "off by one" indexing issue

**Test Case:** `examples/regressions/table-threat-model.md`

**Expected vs Actual:**
```
Expected (4 columns):
┌──────────────┬─────────┬───────────────────┬──────────────────────────┐
│ Element      │ Symbol  │ Description       │ Examples                 │
│ (Fixed ~90)  │ (Auto)  │ (Resizable ~150)  │ (Remainder - takes rest) │
└──────────────┴─────────┴───────────────────┴──────────────────────────┘

Actual (suspected):
┌──────────────┬─────────┬─────────────────────────┬───────────┐
│ Element      │ Symbol  │ Description             │ Examples  │
│              │         │ (TOO WIDE)              │ (TOO NARROW)
└──────────────┴─────────┴─────────────────────────┴───────────┘
```

### 2.2 Border Rendering Issue

**Reported Symptom:** Table dividing lines appear incorrectly:
- Sometimes only single vertical line for multi-column table
- Lines may overwrite text
- Lines in "odd locations"

**Root Cause:** egui_extras::TableBuilder provides no native cell dividers (confirmed by GitHub issues #4783, #4158).

---

## 3. Root Cause Analysis (REVISED)

### 3.1 PRIMARY SUSPECT: Image Measurement Bug

**Location:** `src/markdown_renderer.rs:2102-2106`

**Code:**
```rust
InlineSpan::Image { .. } => {
    // Approximate: image width at current scale, capped by available width.
    // We don't have the natural width here; approximate with available width.
    width += ui.available_width();  // ⚠️ BUG!
}
```

**Impact:**
- If ANY cell contains an image, `measure_inline_spans` returns `ui.available_width()`
- This makes that column's measured width equal to the ENTIRE available space
- In width resolution, this column dominates and starves other columns
- Particularly problematic for narrow columns (Symbol) with small icons

**Severity:** **CRITICAL** - This likely explains the reported symptoms entirely.

**Evidence:**
- Threat-model table has no images in markdown
- But if user's actual table has images, this bug would manifest exactly as described
- `available_width()` during measurement phase is likely the full UI width (e.g., 800px)
- Other columns get squeezed to minimums

**Fix Required:**
```rust
InlineSpan::Image { .. } => {
    // Use a reasonable image width estimate instead of available width
    // Actual images scale to fit, so use typical icon size
    width += self.font_sizes.body * 3.0;  // ~42px for 14pt font
}
```

### 3.2 SECONDARY: Padding Column Policy Bug

**Location:** `src/markdown_renderer.rs:3332-3339`

**Code:**
```rust
let mut column_specs = derive_column_specs(&ctx);
let row_max = rows.iter().map(|r| r.len()).max().unwrap_or(0);
let target_cols = column_specs.len().max(row_max).max(1);
while column_specs.len() < target_cols {
    column_specs.push(ColumnSpec::new(
        format!("Column {}", column_specs.len() + 1),
        ColumnPolicy::Remainder { clip: false },  // ⚠️ BUG: Multiple remainder columns!
    ));
}
```

**Impact:**
- For ragged tables (rows with more cells than headers), padding columns added
- ALL padding columns get `Remainder` policy
- Multiple remainder columns compete for space
- Intended remainder column (Examples) loses its exclusive space claim

**Severity:** **HIGH** for ragged tables, **LOW** for regular tables (threat-model has equal column counts)

**Fix Required:**
```rust
while column_specs.len() < target_cols {
    column_specs.push(ColumnSpec::new(
        format!("Column {}", column_specs.len() + 1),
        ColumnPolicy::Auto,  // ✓ FIX: Use Auto for padding
        None,
    ));
}
```

### 3.3 TERTIARY: Border Rendering Implementation Gap

**Current State:**

**Legacy Path** (`render_table_legacy`):
```rust
egui::Frame::none()
    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
    .show(ui, |ui| {
        egui::Grid::new("md_table").striped(true).show(ui, |ui| { ... });
    });
```

**TableBuilder Path** (`render_table_tablebuilder`):
```rust
TableBuilder::new(ui).striped(true)  // Only row striping, no borders
    .header(...).body(...);
```

**Issue:** Neither path draws cell dividers. Current Frame approach only draws outer border.

**Suspected "Odd Lines":**
- May be outer frame stroke rendering partially when table is clipped/scrolled
- Or could be Grid rendering artifacts (unlikely - Grid doesn't draw lines)
- Need visual confirmation of actual bug manifestation

---

## 4. Additional Issues Discovered

### 4.1 Missing GFM Alignment Support

**Issue:** GFM tables support column alignment via delimiter row:
```markdown
| Left | Center | Right |
|:-----|:------:|------:|
| A    | B      | C     |
```

**Current State:**
- pulldown-cmark parses alignment: `Tag::Table(alignments: Vec<Alignment>)`
- `parse_table` ignores this: `Event::End(Tag::Table(_))` (line 1504)
- Renderer always uses left alignment

**Impact:** LOW priority but would be nice to have

### 4.2 Legacy Path Technical Debt

**Issue:** `table_wrap_overhaul_enabled` flag defaults to `true`, but legacy path still exists:
- Maintenance burden for two code paths
- Legacy path has same bugs as TableBuilder path
- No migration plan

**Recommendation:** Deprecate legacy path after TableBuilder fixes stabilize.

### 4.3 Performance: Per-Frame Rendering Overhead

**Issue:** Tables re-render every frame with no change detection

**Current State:**
- `column_stats_for_table` uses caching (good!)
- `resolve_table_widths` called every frame (wasteful if table unchanged)
- Cell layout caching exists (`table_layout_cache`) but width resolution doesn't cache

**Recommendation:** Cache resolved widths per table, invalidate on window resize.

### 4.4 Test Coverage Gaps

**Missing Tests:**
- Tables with images in cells
- Ragged tables (varying cell counts)
- GFM alignment rendering
- Column width resolution algorithm
- Border painting accuracy

**Risk:** High probability of regressions without comprehensive tests.

---

## 5. Revised Solution Design

### 5.1 Phase 0: Debug & Verify (NEW)

**Purpose:** Confirm root causes BEFORE implementing fixes.

**Step 1: Add Debug Logging**

Instrument width calculation without changing logic:

```rust
fn measure_inline_spans(&self, ui: &egui::Ui, spans: &[InlineSpan]) -> f32 {
    let mut width = 0.0f32;
    let mut has_image = false;
    ui.fonts(|fonts| {
        for span in spans {
            match span {
                // ... existing code ...
                InlineSpan::Image { .. } => {
                    has_image = true;
                    let image_width = ui.available_width();
                    if cfg!(debug_assertions) {
                        eprintln!("⚠️  measure_inline_spans: Image span, using available_width = {:.1}px", image_width);
                    }
                    width += image_width;
                }
                // ... rest ...
            }
        }
    });
    if cfg!(debug_assertions) && has_image {
        eprintln!("   → Total width with image: {:.1}px", width);
    }
    width
}
```

Add to `render_table_tablebuilder`:

```rust
if cfg!(debug_assertions) {
    eprintln!("\n=== Table {} ===", table_id);
    eprintln!("Headers: {} columns", headers.len());
    eprintln!("Max row cells: {}", rows.iter().map(|r| r.len()).max().unwrap_or(0));
    for (i, spec) in column_specs.iter().enumerate() {
        eprintln!("  [{}] {}: {:?}", i, spec.ident, spec.policy);
    }
}
```

**Step 2: Run Visual Inspection**

1. Build debug: `cargo build`
2. Run with threat-model table: `cargo run -- examples/regressions/table-threat-model.md`
3. Capture screenshot of actual bug
4. Check console for debug output
5. Verify which root cause is active

**Step 3: Create Minimal Reproduction**

Based on findings, create smallest possible markdown that reproduces bug:

```markdown
<!-- Test: Image in cell -->
| A | B | C |
|---|---|---|
| Text | ![icon](image.png) | More text |

<!-- Test: Ragged table -->
| A | B |
|---|---|
| 1 | 2 | 3 | 4 |

<!-- Test: Combined -->
| Element | Symbol | Description | Examples |
|---------|--------|-------------|----------|
| Foo | ![x](x.png) | Bar | Baz |
```

### 5.2 Phase 1: Fix Image Measurement (PRIORITY 1)

**Estimated Effort:** 2 hours

**Implementation:**

```rust
fn measure_inline_spans(&self, ui: &egui::Ui, spans: &[InlineSpan]) -> f32 {
    let mut width = 0.0f32;
    ui.fonts(|fonts| {
        for span in spans {
            match span {
                // ... existing Text/Code/Strong/Emphasis handling ...

                InlineSpan::Image { .. } => {
                    // FIX: Use reasonable estimate instead of available_width()
                    // Images in tables typically render as icons or inline graphics
                    // Use 3x body font size as reasonable default (~42px at 14pt)
                    width += self.font_sizes.body * 3.0;
                }
            }
            width += 4.0; // spacing
        }
    });
    width
}
```

**Rationale:**
- `3.0 * font_size` ≈ 42px at 14pt, reasonable for icons/small images
- Prevents image cells from dominating width calculations
- Actual image rendering already handles scaling/clipping
- Conservative estimate that won't break existing tables

**Alternative Approaches Considered:**

**Option A: Use Natural Image Size**
- Requires loading image during measurement
- Performance impact (disk I/O in layout pass)
- ❌ Rejected: Too slow

**Option B: Use Fixed Pixel Value**
- `width += 64.0` or similar
- Doesn't scale with font size
- ❌ Rejected: Not adaptive

**Option C: Use Zero Width**
- `width += 0.0`
- Column would be sized by other cells
- ⚠️ Risk: Images might not fit
- ❓ Could be fallback if Option 3x fails

**Selected: Option 3x Font Size** (best balance)

**Testing:**
```rust
#[test]
fn measure_image_span_uses_reasonable_estimate() {
    let renderer = MarkdownRenderer::new();
    let spans = vec![InlineSpan::Image {
        src: "test.png".to_string(),
        alt: "Test".to_string(),
        title: None,
    }];

    // Create test UI (requires egui test harness)
    // let width = renderer.measure_inline_spans(&ui, &spans);
    // assert!(width >= 30.0 && width < 100.0, "Width should be reasonable estimate");
}
```

### 5.3 Phase 2: Fix Padding Column Policy (PRIORITY 2)

**Estimated Effort:** 1 hour

**Implementation:**

```rust
fn render_table_tablebuilder(
    &self,
    ui: &mut egui::Ui,
    headers: &[Vec<InlineSpan>],
    rows: &[Vec<Vec<InlineSpan>>],
) {
    // ... existing code ...

    let mut column_specs = derive_column_specs(&ctx);
    let row_max = rows.iter().map(|r| r.len()).max().unwrap_or(0);
    let target_cols = column_specs.len().max(row_max).max(1);

    // FIX: Use Auto policy for padding columns instead of Remainder
    while column_specs.len() < target_cols {
        let padding_idx = column_specs.len();
        if cfg!(debug_assertions) {
            eprintln!("  Adding padding column {} with Auto policy", padding_idx);
        }
        column_specs.push(ColumnSpec::new(
            format!("Padding {}", padding_idx + 1),
            ColumnPolicy::Auto,  // ✓ FIX: Changed from Remainder
            Some(format!("Auto-generated column for cell index {}", padding_idx)),
        ));
    }

    // Verify exactly one remainder column (debug assertion)
    if cfg!(debug_assertions) {
        let remainder_count = column_specs
            .iter()
            .filter(|s| matches!(s.policy, ColumnPolicy::Remainder { .. }))
            .count();
        assert_eq!(
            remainder_count, 1,
            "Table should have exactly one remainder column, found {}",
            remainder_count
        );
    }

    // ... rest of function ...
}
```

**Testing:**
```rust
#[test]
fn ragged_table_padding_uses_auto_policy() {
    let headers = vec![vec![span("A")], vec![span("B")]];
    let rows = vec![vec![
        vec![span("1")],
        vec![span("2")],
        vec![span("3")],
    ]];  // 3 cells, only 2 headers

    let stats = compute_column_stats(&headers, &rows, 32);
    let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
    let mut specs = derive_column_specs(&ctx);

    // Simulate padding
    let target_cols = 3;
    while specs.len() < target_cols {
        specs.push(ColumnSpec::new(
            format!("Padding {}", specs.len() + 1),
            ColumnPolicy::Auto,
            None,
        ));
    }

    // Verify
    let remainder_count = specs
        .iter()
        .filter(|s| matches!(s.policy, ColumnPolicy::Remainder { .. }))
        .count();
    assert_eq!(remainder_count, 1);
}
```

### 5.4 Phase 3: Implement Cell Dividers (PRIORITY 3)

**Estimated Effort:** 8-10 hours

#### 5.4.1 Investigation: TableBuilder Response Type

**First, verify TableBuilder API:**

```rust
// Check egui_extras documentation
// TableBuilder::header() returns TableHeader
// TableHeader::body() returns InnerResponse<R> where R is from the body closure

let table_response = TableBuilder::new(ui)
    .header(height, |header| { /* ... */ })
    .body(|body| { /* ... */ });

// table_response type: ?
```

**ACTION REQUIRED:** Verify actual return type before proceeding with border implementation.

#### 5.4.2 Approach A: Post-Render Manual Painting (If Response Available)

**Prerequisites:**
- TableBuilder must return usable response with rect information
- Need to track cell positions during render

**Implementation:**

```rust
fn render_table_tablebuilder(
    &self,
    ui: &mut egui::Ui,
    headers: &[Vec<InlineSpan>],
    rows: &[Vec<Vec<InlineSpan>>],
) {
    // ... column spec setup ...

    // Track cell rectangles
    let mut cell_rects: Vec<Vec<egui::Rect>> = Vec::new();
    let mut header_rects: Vec<egui::Rect> = Vec::new();

    // Build table
    let table_builder = TableBuilder::new(ui).striped(true);
    for spec in &column_specs {
        table_builder = table_builder.column(spec.as_column());
    }

    let table_start_y = ui.cursor().min.y;

    table_builder
        .header(HEADER_HEIGHT, |mut header| {
            for ci in 0..column_specs.len() {
                let rect = header.col(|ui| {
                    let before_rect = ui.max_rect();
                    // ... render header content ...
                    before_rect  // Return for tracking
                });
                header_rects.push(rect.response.rect);
            }
        })
        .body(|body| {
            body.heterogeneous_rows(row_heights.into_iter(), |mut row| {
                let idx = row.index();
                let mut row_rects: Vec<egui::Rect> = Vec::new();

                for ci in 0..column_specs.len() {
                    let rect = row.col(|ui| {
                        // ... render cell content ...
                        ui.min_rect()  // Capture rect
                    });
                    row_rects.push(rect.response.rect);
                }

                cell_rects.push(row_rects);
            });
        });

    // Paint dividers AFTER table rendering
    self.paint_table_cell_dividers(ui, &header_rects, &cell_rects, table_start_y);
}
```

**Paint Implementation:**

```rust
fn paint_table_cell_dividers(
    &self,
    ui: &mut egui::Ui,
    header_rects: &[egui::Rect],
    cell_rects: &[Vec<egui::Rect>],
    table_start_y: f32,
) {
    if header_rects.is_empty() || cell_rects.is_empty() {
        return;
    }

    let painter = ui.painter();
    let divider_color = Color32::from_rgb(60, 60, 60);
    let divider_stroke = Stroke::new(1.0, divider_color);

    // Compute table bounds
    let left = header_rects.iter().map(|r| r.left()).min_by(|a, b| a.partial_cmp(b).unwrap()).unwrap_or(0.0);
    let right = header_rects.iter().map(|r| r.right()).max_by(|a, b| a.partial_cmp(b).unwrap()).unwrap_or(0.0);
    let bottom = cell_rects.last()
        .and_then(|row| row.iter().map(|r| r.bottom()).max_by(|a, b| a.partial_cmp(b).unwrap()))
        .unwrap_or(table_start_y);

    let table_rect = egui::Rect::from_min_max(
        egui::pos2(left, table_start_y),
        egui::pos2(right, bottom),
    );

    // Outer border
    painter.rect_stroke(table_rect, 0.0, divider_stroke);

    // Horizontal divider after header
    let header_bottom = header_rects.iter()
        .map(|r| r.bottom())
        .max_by(|a, b| a.partial_cmp(b).unwrap())
        .unwrap_or(table_start_y);
    painter.hline(left..=right, header_bottom, divider_stroke);

    // Horizontal dividers between rows
    for row_rects in cell_rects {
        if let Some(row_bottom) = row_rects.iter()
            .map(|r| r.bottom())
            .max_by(|a, b| a.partial_cmp(b).unwrap())
        {
            painter.hline(left..=right, row_bottom, divider_stroke);
        }
    }

    // Vertical dividers between columns
    for ci in 1..header_rects.len() {
        // Use header rect as reference for column boundary
        let x = header_rects[ci].left();
        painter.vline(x, table_start_y..=bottom, divider_stroke);
    }
}
```

**Challenges:**
- Must track rect for every cell (memory overhead)
- Painting happens after table, may have z-order issues with striping
- Need to handle clipping carefully

#### 5.4.3 Approach B: Frame-Based Outer Border Only (Fallback)

If TableBuilder doesn't provide rect access, simplify to just fixing outer border:

```rust
fn render_table_tablebuilder(
    &self,
    ui: &mut egui::Ui,
    headers: &[Vec<InlineSpan>],
    rows: &[Vec<Vec<InlineSpan>>],
) {
    // Wrap entire table in frame
    egui::Frame::none()
        .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
        .show(ui, |ui| {
            // ... existing TableBuilder code ...
        });
}
```

**Limitations:**
- Only outer border, no cell dividers
- But at least fixes "odd lines" issue if it's frame-related

#### 5.4.4 Approach C: Custom Column Rendering with Manual Dividers (Advanced)

Use `Column::initial()` with custom rendering to inject dividers:

```rust
for (ci, spec) in column_specs.iter().enumerate() {
    table = table.column(spec.as_column());
}

// Then in cell rendering, manually paint right border:
row.col(|ui| {
    let cell_rect = ui.max_rect();
    // ... render cell content ...

    // Paint right border if not last column
    if ci < column_specs.len() - 1 {
        let divider_x = cell_rect.right();
        ui.painter().vline(
            divider_x,
            cell_rect.top()..=cell_rect.bottom(),
            Stroke::new(1.0, Color32::from_rgb(60, 60, 60)),
        );
    }
});
```

**Advantages:**
- Dividers painted alongside cells, correct z-order
- No need to track rects separately

**Disadvantages:**
- More invasive changes to cell rendering
- Harder to get row dividers (cells don't know row boundaries)

**RECOMMENDATION:** Start with Approach B (outer border fix), then implement Approach A if TableBuilder API supports it.

### 5.5 Phase 4: GFM Alignment Support (PRIORITY 4)

**Estimated Effort:** 4 hours

**Implementation:**

**Step 1: Capture Alignment During Parsing**

```rust
#[derive(Debug, Clone)]
pub struct Table {
    pub headers: Vec<Vec<InlineSpan>>,
    pub rows: Vec<Vec<Vec<InlineSpan>>>,
    pub alignments: Vec<Alignment>,  // NEW
}

fn parse_table(
    &self,
    events: &[Event],
    start: usize,
) -> Result<TableParseResult, anyhow::Error> {
    let mut headers: Vec<Vec<InlineSpan>> = Vec::new();
    let mut rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
    let mut alignments: Vec<Alignment> = Vec::new();  // NEW
    let mut i = start;

    while i < events.len() {
        match &events[i] {
            Event::End(Tag::Table(aligns)) => {
                alignments = aligns.clone();  // CAPTURE
                return Ok((headers, rows, alignments, i + 1));
            }
            // ... rest of parsing ...
        }
    }
    Ok((headers, rows, alignments, i))
}
```

**Step 2: Store in MarkdownElement**

```rust
pub enum MarkdownElement {
    // ... existing variants ...
    Table {
        headers: Vec<Vec<InlineSpan>>,
        rows: Vec<Vec<Vec<InlineSpan>>>,
        alignments: Vec<Alignment>,  // NEW
    },
    // ...
}
```

**Step 3: Apply Alignment During Rendering**

```rust
fn render_table_tablebuilder(
    &self,
    ui: &mut egui::Ui,
    headers: &[Vec<InlineSpan>],
    rows: &[Vec<Vec<InlineSpan>>],
    alignments: &[Alignment],  // NEW parameter
) {
    // ... setup ...

    table.header(HEADER_HEIGHT, |mut header| {
        for ci in 0..column_specs.len() {
            header.col(|ui| {
                let align = alignments.get(ci).unwrap_or(&Alignment::None);
                let layout = match align {
                    Alignment::None | Alignment::Left => egui::Layout::left_to_right(egui::Align::LEFT),
                    Alignment::Center => egui::Layout::left_to_right(egui::Align::Center),
                    Alignment::Right => egui::Layout::left_to_right(egui::Align::RIGHT),
                };

                ui.with_layout(layout, |ui| {
                    // ... render header with alignment ...
                });
            });
        }
    });

    // Similar for body cells
}
```

**Testing:**
```markdown
| Left | Center | Right |
|:-----|:------:|------:|
| A    | B      | C     |
| Long text | Mid | Short |
```

Expected: A left-aligned, B centered, C right-aligned.

---

## 6. Implementation Plan (REVISED)

### 6.1 Phase 0: Debug & Verify (NEW)

**Duration:** 2-4 hours

**Tasks:**
1. ✅ Add debug logging to `measure_inline_spans` (30 min)
2. ✅ Add debug logging to `render_table_tablebuilder` (30 min)
3. ✅ Build and run with threat-model table (30 min)
4. ✅ Capture screenshots of actual bug (30 min)
5. ✅ Create minimal reproduction cases (1 hour)
6. ✅ Document findings (1 hour)

**Deliverable:** Debug report confirming root causes

### 6.2 Phase 1: Fix Image Measurement

**Duration:** 2-3 hours

**Tasks:**
1. ✅ Implement fix in `measure_inline_spans` (30 min)
2. ✅ Write unit test for image measurement (1 hour)
3. ✅ Integration test with table containing images (1 hour)
4. ✅ Verify threat-model table unaffected (30 min)

**Acceptance Criteria:**
- Tables with images no longer have width calculation issues
- Image cells use reasonable width estimate (~3x font size)
- Existing tables without images render identically

### 6.3 Phase 2: Fix Padding Column Policy

**Duration:** 2-3 hours

**Tasks:**
1. ✅ Change padding policy to Auto (15 min)
2. ✅ Add debug assertion for single remainder (15 min)
3. ✅ Write unit test for ragged tables (1 hour)
4. ✅ Integration test with various table shapes (1 hour)
5. ✅ Code review and cleanup (30 min)

**Acceptance Criteria:**
- Ragged tables have exactly one remainder column
- Padding columns use Auto policy
- No regressions in regular (non-ragged) tables

### 6.4 Phase 3: Implement Cell Dividers

**Duration:** 8-12 hours

**Tasks:**
1. ✅ Investigate TableBuilder response type (1 hour)
2. ✅ Implement outer border fix (Approach B) (2 hours)
3. ✅ Test outer border rendering (1 hour)
4. ✅ Implement cell divider painting (Approach A or C) (4 hours)
5. ✅ Test divider alignment and clipping (2 hours)
6. ✅ Performance profiling (1 hour)
7. ✅ Visual regression testing (1 hour)

**Acceptance Criteria:**
- Table has visible outer border
- Cell dividers render between columns (if Approach A works)
- Row dividers render between rows (if Approach A works)
- No text overwriting
- No performance degradation on 100-row tables

### 6.5 Phase 4: GFM Alignment Support

**Duration:** 4-6 hours

**Tasks:**
1. ✅ Modify `parse_table` to capture alignments (1 hour)
2. ✅ Update `MarkdownElement::Table` signature (30 min)
3. ✅ Apply alignment in rendering (2 hours)
4. ✅ Write tests for left/center/right alignment (1 hour)
5. ✅ Update documentation (30 min)

**Acceptance Criteria:**
- Left-aligned columns render left-aligned
- Center-aligned columns render centered
- Right-aligned columns render right-aligned
- Default (no alignment) renders left-aligned

### 6.6 Phase 5: Testing & Validation

**Duration:** 6-8 hours

**Tasks:**
1. ✅ Comprehensive unit test suite (3 hours)
2. ✅ Performance benchmarking (2 hours)
3. ✅ Visual regression testing (2 hours)
4. ✅ Documentation updates (1 hour)

---

## 7. Testing Strategy (REVISED)

### 7.1 Unit Tests

**Test 1: Image Measurement**
```rust
#[test]
fn measure_image_span_reasonable_estimate() {
    // Verify image measurement uses 3x font size, not available_width
}
```

**Test 2: Padding Column Policy**
```rust
#[test]
fn ragged_table_single_remainder_column() {
    // Verify exactly one remainder column after padding
}
```

**Test 3: Width Resolution**
```rust
#[test]
fn resolve_widths_with_image_column() {
    // Verify image column doesn't dominate width allocation
}
```

**Test 4: Alignment Rendering**
```rust
#[test]
fn parse_table_captures_alignment() {
    // Verify GFM alignment parsed correctly
}
```

### 7.2 Integration Tests

**Test Case 1: Threat Model Table (Original Bug Report)**
```markdown
| Element          | Symbol        | Description                          | Examples                                            |
|------------------|---------------|--------------------------------------|-----------------------------------------------------|
| External Entity  | Rectangle     | Things outside your control          | Users, external systems, web sites                  |
```

**Expected:**
- 4 columns, all visible
- Examples column widest (remainder space)
- Description column moderate width
- No "off by one" appearance

**Test Case 2: Table with Images**
```markdown
| Icon | Name | Description |
|------|------|-------------|
| ![](icon1.png) | Item 1 | First item |
| ![](icon2.png) | Item 2 | Second item |
```

**Expected:**
- Icon column sized reasonably (~42px)
- Name and Description columns share remaining space appropriately

**Test Case 3: Ragged Table**
```markdown
| A | B |
|---|---|
| 1 | 2 | 3 | 4 |
```

**Expected:**
- 4 columns render (2 from headers, 2 padding)
- No crash or layout explosion

**Test Case 4: Aligned Table**
```markdown
| Left | Center | Right |
|:-----|:------:|------:|
| AAA  | BBB    | CCC   |
```

**Expected:**
- Left column left-aligned
- Center column centered
- Right column right-aligned

### 7.3 Visual Regression Tests

**Process:**
1. Capture screenshots of tables before implementation
2. Implement changes
3. Capture screenshots after implementation
4. Manual visual comparison
5. Document any differences

**Test Tables:**
- Simple 2x2 table
- Complex 8x20 table
- Table with images
- Table with emoji
- Table with long text
- Narrow window (force wrapping)
- Wide window (excess space)

### 7.4 Performance Tests

**Benchmark:**
```rust
#[bench]
fn bench_table_render_100_rows(b: &mut Bencher) {
    // Render 10-column table with 100 rows
    // Measure time per frame
}
```

**Acceptance:**
- No more than 5% slowdown vs baseline
- Divider painting < 1ms per table

---

## 8. Risk Assessment (REVISED)

### 8.1 Risks and Mitigations

| Risk | Probability | Impact | Mitigation |
|------|------------|---------|------------|
| **Image measurement fix breaks existing tables** | Low | High | Comprehensive test suite, visual regression testing |
| **Padding fix causes crashes on ragged tables** | Low | High | Unit tests with various ragged table shapes |
| **Border painting degrades performance** | Medium | Medium | Profiling, caching, conditional rendering |
| **Border misalignment with cell content** | Medium | Medium | Extensive visual testing, careful rect tracking |
| **Return type changes break other code** | Low | High | Grep for all call sites, compile-time verification |
| **GFM alignment breaks layouts** | Low | Low | Optional feature, can be disabled if problematic |
| **Regression in legacy Grid path** | Medium | Medium | Parallel testing of both paths, deprecation plan |
| **Discovery of additional root causes** | Medium | Medium | Phase 0 debug verification before coding |

### 8.2 Rollback Strategy

**Feature Flags (Already Exist):**
```rust
table_wrap_overhaul_enabled: bool,  // Default: true
```

**New Flags (Proposed):**
```rust
table_image_measurement_fixed: bool,     // Default: true after testing
table_cell_dividers_enabled: bool,       // Default: true after testing
table_alignment_enabled: bool,           // Default: true after testing
```

**Rollback Process:**
1. If critical bug found, set flag to `false` in code
2. Release hotfix with flag disabled
3. Investigate and fix issue
4. Re-enable flag in next release

---

## 9. Success Criteria (REVISED)

### 9.1 Functional Requirements

✅ **Column Width Fix:**
- [ ] Threat-model table renders correctly (Examples widest)
- [ ] Tables with images have reasonable column widths
- [ ] Ragged tables have exactly one remainder column
- [ ] No "off by one" appearance

✅ **Cell Dividers:**
- [ ] Outer table border renders correctly
- [ ] Cell dividers visible (if implemented)
- [ ] No text overwriting
- [ ] Dividers align with cells

✅ **GFM Alignment:**
- [ ] Left/center/right alignment respected
- [ ] Default alignment is left

### 9.2 Non-Functional Requirements

✅ **Performance:**
- [ ] < 5% performance impact on table rendering
- [ ] Border painting < 1ms per table

✅ **Compatibility:**
- [ ] No breaking changes to public API
- [ ] Existing markdown files render correctly or better
- [ ] Both TableBuilder and legacy paths work (until deprecation)

✅ **Code Quality:**
- [ ] Zero compiler warnings
- [ ] `cargo clippy` clean
- [ ] `cargo fmt` applied
- [ ] All tests pass
- [ ] Code review completed

### 9.3 Verification Checklist

**Before Release:**
- [ ] Phase 0 debug report completed and reviewed
- [ ] Image measurement fix verified with test tables
- [ ] Padding column fix verified with ragged tables
- [ ] Border rendering verified with visual inspection
- [ ] Alignment verified with GFM spec examples
- [ ] Performance benchmarks meet criteria
- [ ] Visual regression tests pass
- [ ] Documentation updated
- [ ] CLAUDE.md updated with implementation details

---

## 10. Open Questions (NEW)

### 10.1 Technical Questions

**Q1:** What does TableBuilder::header().body() actually return?
- **Action:** Check egui_extras documentation and source
- **Impact:** Determines border implementation approach

**Q2:** How do striped row backgrounds interact with painted dividers?
- **Action:** Visual testing with striping enabled
- **Impact:** May need to adjust z-order or painting approach

**Q3:** Should image measurement be configurable?
- **Action:** Discuss with stakeholders
- **Impact:** Could add `table_image_width_estimate: f32` to config

**Q4:** Should we deprecate legacy Grid path now?
- **Action:** Review feature flag usage analytics
- **Impact:** Simplifies codebase but may affect users

### 10.2 Design Questions

**Q5:** Should cell dividers be optional/configurable?
- **Proposed:** Add `table_cell_dividers: bool` to config, default `true`
- **Rationale:** Some users may prefer cleaner minimal look

**Q6:** Should alignment be per-column or per-cell?
- **GFM Spec:** Per-column (delimiter row applies to all cells in column)
- **Decision:** Implement per-column per spec

**Q7:** What color/width for dividers?
- **Current:** `Color32::from_rgb(60, 60, 60)`, 1.0px
- **Proposed:** Make configurable via theme/config

---

## 11. Future Enhancements (REVISED)

### 11.1 Short-Term (Next 1-2 Releases)

- **Configurable divider styling** (color, width, style)
- **Column resize persistence** (save user-adjusted widths)
- **Interactive column resizing** (drag dividers to resize)
- **Deprecate legacy Grid path** (reduce maintenance burden)

### 11.2 Medium-Term (Next 3-6 Months)

- **Sort by column** (click header to sort rows)
- **CSV export** (export table data to CSV)
- **Cell selection and copy** (select and copy multiple cells)
- **Fixed header scrolling** (header stays visible when scrolling)

### 11.3 Long-Term (Future)

- **Wait for egui native dividers** (when/if egui adds this)
- **Migrate to native implementation** (reduce custom code)
- **Advanced table features** (merged cells, nested tables)

---

## 12. Appendix

### 12.1 Code Locations (Updated)

| Component | File | Lines | Notes |
|-----------|------|-------|-------|
| **Image measurement** | `src/markdown_renderer.rs` | 2102-2106 | **PRIMARY BUG** |
| Padding column logic | `src/markdown_renderer.rs` | 3332-3339 | Secondary bug |
| TableBuilder render | `src/markdown_renderer.rs` | 3318-3382 | Main render path |
| Legacy Grid render | `src/markdown_renderer.rs` | 3268-3316 | Fallback path |
| Width resolution | `src/markdown_renderer.rs` | 3586-3635 | Algorithm |
| Column classification | `src/table_support/column_spec.rs` | 270-335 | Policy selection |
| Column stats | `src/table_support/column_spec.rs` | 378-447 | Metrics |
| Table parsing | `src/markdown_renderer.rs` | 1402-1510 | Alignment capture needed |

### 12.2 Related Issues

- **egui #4783:** Table cell dividers (not implemented in framework)
- **egui #4158:** Vertical column separators (not implemented in framework)

### 12.3 References

- **Research Document:** 2025.11.14 - RSR - Table Rendering Research.md
- **GFM Specification:** https://github.github.com/gfm/
- **egui TableBuilder:** https://docs.rs/egui_extras/latest/egui_extras/struct.TableBuilder.html
- **pulldown-cmark:** https://docs.rs/pulldown-cmark/

### 12.4 Revision Notes

**Changes from Rev 1 to Rev 2:**

1. **Added Phase 0:** Debug & Verify step before implementation
2. **Identified image measurement bug** as primary root cause
3. **Revised border implementation** to account for TableBuilder API limitations
4. **Added GFM alignment support** as Phase 4
5. **Expanded test coverage** to include images, alignment, ragged tables
6. **Added performance requirements** and profiling tasks
7. **Added open questions** section for unresolved issues
8. **Added rollback strategy** with feature flags
9. **Increased effort estimate** from 2-3 days to 4-5 days
10. **Added comprehensive revision tracking** for future reference

---

**End of High-Level Design (Revision 2)**

C:\language\mdmdview\src\app.rs:
    1|       |/// Main application logic for the markdown viewer
    2|       |///
    3|       |/// This module contains the primary app state, UI logic, and event handling
    4|       |/// for the markdown viewer application built with egui.
    5|       |use crate::{MarkdownElement, MarkdownRenderer, SampleFile, WindowState, SAMPLE_FILES};
    6|       |use anyhow::{bail, Result};
    7|       |use egui::text::LayoutJob;
    8|       |use egui::text::TextFormat;
    9|       |use egui::{menu, CentralPanel, Color32, Context, RichText, TopBottomPanel};
   10|       |use egui::{TextEdit, TextStyle};
   11|       |use rfd::FileDialog;
   12|       |use std::collections::VecDeque;
   13|       |use std::io::ErrorKind;
   14|       |use std::path::{Path, PathBuf};
   15|       |use unicode_casefold::UnicodeCaseFold;
   16|       |use unicode_normalization::UnicodeNormalization;
   17|       |
   18|       |/// Prefix used for application/window titles.
   19|       |pub const APP_TITLE_PREFIX: &str = "mdmdview";
   20|       |const BUILD_VERSION: &str = env!("CARGO_PKG_VERSION");
   21|       |const BUILD_TIMESTAMP: &str = env!("MDMDVIEW_BUILD_TIMESTAMP");
   22|       |
   23|       |/// Entry in navigation history for back/forward navigation
   24|       |#[derive(Clone, Debug)]
   25|       |struct HistoryEntry {
   26|       |    file_path: Option<PathBuf>,
   27|       |    title: String,
   28|       |    content: String,
   29|       |}
   30|       |
   31|       |/// Main application state and logic
   32|       |pub struct MarkdownViewerApp {
   33|       |    /// Markdown renderer instance
   34|       |    renderer: MarkdownRenderer,
   35|       |    /// Currently loaded file path
   36|       |    current_file: Option<PathBuf>,
   37|       |    /// Current markdown content as string
   38|       |    current_content: String,
   39|       |    /// Buffer for raw view (read-only for now)
   40|       |    raw_buffer: String,
   41|       |    /// Parsed markdown elements ready for rendering
   42|       |    parsed_elements: Vec<MarkdownElement>,
   43|       |    /// Application title for window
   44|       |    title: String,
   45|       |    /// Error message to display if any
   46|       |    error_message: Option<String>,
   47|       |    /// Navigation request for keyboard shortcuts
   48|       |    nav_request: Option<NavigationRequest>,
   49|       |    /// Scroll area ID for state management
   50|       |    scroll_area_id: egui::Id,
   51|       |    /// Flag to request fullscreen toggle
   52|       |    toggle_fullscreen: bool,
   53|       |    /// Current view mode
   54|       |    view_mode: ViewMode,
   55|       |    /// Wrap long lines in raw view
   56|       |    wrap_raw: bool,
   57|       |    /// Whether the table wrap overhaul renderer is active
   58|       |    table_wrap_overhaul_enabled: bool,
   59|       |    /// Write mode: allow editing in Raw view
   60|       |    write_enabled: bool,
   61|       |    /// Remember caret position in raw editor (byte index)
   62|       |    raw_cursor: Option<usize>,
   63|       |    /// Request focus for raw editor on next render
   64|       |    raw_focus_requested: bool,
   65|       |    /// Flag to request reload of current file (handled outside input context)
   66|       |    reload_requested: bool,
   67|       |    /// Defer toggling view mode to outside input context
   68|       |    view_toggle_requested: bool,
   69|       |    /// Defer toggling write mode to outside input context
   70|       |    write_toggle_requested: bool,
   71|       |    /// Last known window position (for persistence)
   72|       |    last_window_pos: Option<[f32; 2]>,
   73|       |    /// Last known window size (for persistence)
   74|       |    last_window_size: Option<[f32; 2]>,
   75|       |    /// Last known maximized state
   76|       |    last_window_maximized: bool,
   77|       |    /// Last persisted window snapshot to avoid redundant disk writes
   78|       |    last_persisted_state: Option<WindowState>,
   79|       |    /// Throttle saving window state
   80|       |    last_persist_instant: std::time::Instant,
   81|       |    // Search state
   82|       |    show_search: bool,
   83|       |    search_query: String,
   84|       |    last_query: String,
   85|       |    last_match_index: Option<usize>,
   86|       |    pending_scroll_to_element: Option<usize>,
   87|       |    search_focus_requested: bool,
   88|       |    /// Deferred caret movement (in lines) for raw editor
   89|       |    pending_raw_cursor_line_move: Option<i32>,
   90|       |    // Navigation history
   91|       |    /// History of visited files and samples for back/forward navigation
   92|       |    history: Vec<HistoryEntry>,
   93|       |    /// Current position in history
   94|       |    history_index: usize,
   95|       |    /// Maximum history entries to keep
   96|       |    max_history: usize,
   97|       |    // Drag and drop state
   98|       |    /// Visual state: file is being dragged over window
   99|       |    drag_hover: bool,
  100|       |    /// Queue of files waiting to be opened (from multi-file drop)
  101|       |    pending_files: VecDeque<PathBuf>,
  102|       |}
  103|       |
  104|       |/// Navigation request for keyboard-triggered scrolling
  105|       |#[derive(Debug, Clone)]
  106|       |enum NavigationRequest {
  107|       |    Top,
  108|       |    Bottom,
  109|       |    PageUp,
  110|       |    PageDown,
  111|       |    ScrollUp,   // Arrow up - fine scrolling
  112|       |    ScrollDown, // Arrow down - fine scrolling
  113|       |}
  114|       |
  115|       |/// Which view the user is in
  116|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
  117|       |enum ViewMode {
  118|       |    Rendered,
  119|       |    Raw,
  120|       |}
  121|       |
  122|       |impl MarkdownViewerApp {
  123|      0|    fn toggle_write_mode(&mut self, ctx: &Context) {
  124|      0|        if self.write_enabled {
  125|       |            // About to disable; capture current cursor if in Raw view
  126|      0|            if matches!(self.view_mode, ViewMode::Raw) {
  127|      0|                let editor_id = egui::Id::new("raw_editor");
  128|      0|                if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
  129|      0|                    if let Some(range) = state.cursor.char_range() {
  130|      0|                        self.raw_cursor = Some(range.primary.index);
  131|      0|                    }
  132|      0|                }
  133|      0|            }
  134|      0|            self.write_enabled = false;
  135|       |        } else {
  136|       |            // Enabling write mode: ensure the raw editor will gain focus
  137|      0|            self.write_enabled = true;
  138|      0|            if matches!(self.view_mode, ViewMode::Raw) {
  139|      0|                self.raw_focus_requested = true;
  140|      0|            }
  141|       |        }
  142|      0|    }
  143|       |
  144|      0|    fn move_raw_cursor_lines(&mut self, ctx: &Context, delta_lines: i32) {
  145|      0|        if !matches!(self.view_mode, ViewMode::Raw) || !self.write_enabled {
  146|      0|            return;
  147|      0|        }
  148|      0|        let editor_id = egui::Id::new("raw_editor");
  149|      0|        if let Some(mut state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
  150|      0|            let mut idx = state
  151|      0|                .cursor
  152|      0|                .char_range()
  153|      0|                .map(|r| r.primary.index)
  154|      0|                .unwrap_or_else(|| self.raw_cursor.unwrap_or(0))
  155|      0|                .min(self.raw_buffer.len());
  156|       |
  157|      0|            let s = self.raw_buffer.as_str();
  158|      0|            match delta_lines.cmp(&0) {
  159|       |                std::cmp::Ordering::Less => {
  160|      0|                    let mut lines = -delta_lines;
  161|       |                    // Move to start of current line
  162|      0|                    idx = s[..idx].rfind('\n').map(|p| p + 1).unwrap_or(0);
  163|      0|                    while lines > 0 && idx > 0 {
  164|      0|                        if let Some(prev_nl) = s[..idx.saturating_sub(1)].rfind('\n') {
  165|      0|                            idx = prev_nl + 1;
  166|      0|                        } else {
  167|      0|                            idx = 0;
  168|      0|                        }
  169|      0|                        lines -= 1;
  170|       |                    }
  171|       |                }
  172|       |                std::cmp::Ordering::Greater => {
  173|      0|                    let mut lines = delta_lines;
  174|       |                    // Move to start of next line
  175|      0|                    if let Some(nl) = s[idx..].find('\n') {
  176|      0|                        idx = (idx + nl + 1).min(s.len());
  177|      0|                        lines -= 1;
  178|      0|                    }
  179|      0|                    while lines > 0 && idx < s.len() {
  180|      0|                        if let Some(nl) = s[idx..].find('\n') {
  181|      0|                            idx = (idx + nl + 1).min(s.len());
  182|      0|                        } else {
  183|      0|                            idx = s.len();
  184|      0|                        }
  185|      0|                        lines -= 1;
  186|       |                    }
  187|       |                }
  188|      0|                std::cmp::Ordering::Equal => {}
  189|       |            }
  190|      0|            let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(idx));
  191|      0|            state.cursor.set_char_range(Some(cr));
  192|      0|            state.store(ctx, editor_id);
  193|      0|            self.raw_cursor = Some(idx);
  194|      0|            self.raw_focus_requested = true; // keep focus and make caret visible
  195|      0|        }
  196|      0|    }
  197|      0|    fn clear_search_state(&mut self) {
  198|      0|        self.search_query.clear();
  199|      0|        self.last_query.clear();
  200|      0|        self.last_match_index = None;
  201|      0|        self.pending_scroll_to_element = None;
  202|      0|        self.renderer.set_highlight_phrase(None);
  203|      0|    }
  204|      0|    fn find_next(&mut self) {
  205|      0|        if self.search_query.is_empty() && self.last_query.is_empty() {
  206|      0|            return;
  207|      0|        }
  208|      0|        let needle = if !self.search_query.is_empty() {
  209|      0|            self.last_query = self.search_query.clone();
  210|      0|            Self::fold_for_search(&self.search_query)
  211|       |        } else {
  212|      0|            Self::fold_for_search(&self.last_query)
  213|       |        };
  214|      0|        if needle.is_empty() {
  215|      0|            return;
  216|      0|        }
  217|      0|        let mut start = self.last_match_index.unwrap_or(usize::MAX);
  218|      0|        if start == usize::MAX {
  219|      0|            start = 0;
  220|      0|        } else {
  221|      0|            start = start.saturating_add(1);
  222|      0|        }
  223|       |        // Wrap-around search forward
  224|      0|        let total = self.parsed_elements.len();
  225|      0|        for pass in 0..2 {
  226|      0|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
  227|      0|                Box::new(start..total)
  228|       |            } else {
  229|      0|                Box::new(0..start.min(total))
  230|       |            };
  231|      0|            for idx in range {
  232|      0|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
  233|      0|                    &self.parsed_elements[idx],
  234|       |                );
  235|      0|                if Self::fold_for_search(&text).contains(&needle) {
  236|      0|                    self.last_match_index = Some(idx);
  237|      0|                    self.pending_scroll_to_element = Some(idx);
  238|      0|                    return;
  239|      0|                }
  240|       |            }
  241|       |        }
  242|      0|    }
  243|       |
  244|      0|    fn find_previous(&mut self) {
  245|      0|        if self.search_query.is_empty() && self.last_query.is_empty() {
  246|      0|            return;
  247|      0|        }
  248|      0|        let needle = if !self.search_query.is_empty() {
  249|      0|            self.last_query = self.search_query.clone();
  250|      0|            Self::fold_for_search(&self.search_query)
  251|       |        } else {
  252|      0|            Self::fold_for_search(&self.last_query)
  253|       |        };
  254|      0|        if needle.is_empty() {
  255|      0|            return;
  256|      0|        }
  257|      0|        let total = self.parsed_elements.len();
  258|      0|        let mut start = self.last_match_index.unwrap_or(0);
  259|      0|        if start == 0 {
  260|      0|            start = total.saturating_sub(1);
  261|      0|        } else {
  262|      0|            start = start.saturating_sub(1);
  263|      0|        }
  264|       |        // Wrap-around search backward
  265|      0|        for pass in 0..2 {
  266|      0|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
  267|      0|                Box::new((0..=start).rev())
  268|       |            } else {
  269|      0|                Box::new(((start + 1)..total).rev())
  270|       |            };
  271|      0|            for idx in range {
  272|      0|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
  273|      0|                    &self.parsed_elements[idx],
  274|       |                );
  275|      0|                if Self::fold_for_search(&text).contains(&needle) {
  276|      0|                    self.last_match_index = Some(idx);
  277|      0|                    self.pending_scroll_to_element = Some(idx);
  278|      0|                    return;
  279|      0|                }
  280|       |            }
  281|       |        }
  282|      0|    }
  283|       |    /// Create a new application instance
  284|     34|    pub fn new() -> Self {
  285|     34|        let mut app = Self {
  286|     34|            renderer: MarkdownRenderer::new(),
  287|     34|            current_file: None,
  288|     34|            current_content: String::new(),
  289|     34|            raw_buffer: String::new(),
  290|     34|            parsed_elements: Vec::new(),
  291|     34|            title: APP_TITLE_PREFIX.to_string(),
  292|     34|            error_message: None,
  293|     34|            nav_request: None,
  294|     34|            scroll_area_id: egui::Id::new("main_scroll_area"),
  295|     34|            toggle_fullscreen: false,
  296|     34|            view_mode: ViewMode::Rendered,
  297|     34|            wrap_raw: false,
  298|     34|            table_wrap_overhaul_enabled: true,
  299|     34|            write_enabled: false,
  300|     34|            raw_cursor: None,
  301|     34|            raw_focus_requested: false,
  302|     34|            reload_requested: false,
  303|     34|            view_toggle_requested: false,
  304|     34|            write_toggle_requested: false,
  305|     34|            last_window_pos: None,
  306|     34|            last_window_size: None,
  307|     34|            last_window_maximized: false,
  308|     34|            last_persisted_state: None,
  309|     34|            last_persist_instant: std::time::Instant::now(),
  310|     34|            show_search: false,
  311|     34|            search_query: String::new(),
  312|     34|            last_query: String::new(),
  313|     34|            last_match_index: None,
  314|     34|            pending_scroll_to_element: None,
  315|     34|            search_focus_requested: false,
  316|     34|            pending_raw_cursor_line_move: None,
  317|     34|            history: Vec::new(),
  318|     34|            history_index: 0,
  319|     34|            max_history: 50,
  320|     34|            drag_hover: false,
  321|     34|            pending_files: VecDeque::new(),
  322|     34|        };
  323|     34|        app.renderer
  324|     34|            .set_table_wrap_overhaul_enabled(app.table_wrap_overhaul_enabled);
  325|       |
  326|       |        // Load welcome content by default
  327|     34|        if let Some(welcome) = SAMPLE_FILES.iter().find(|f| f.name == "welcome.md") {
  328|     34|            app.load_content(welcome.content, Some("Welcome".to_string()));
  329|     34|        }
                      ^0
  330|       |
  331|     34|        app
  332|     34|    }
  333|       |
  334|      0|    pub fn set_table_wrap_overhaul_enabled(&mut self, enabled: bool) {
  335|      0|        self.table_wrap_overhaul_enabled = enabled;
  336|      0|        self.renderer.set_table_wrap_overhaul_enabled(enabled);
  337|      0|    }
  338|       |
  339|      0|    fn toggle_table_wrap_overhaul(&mut self) {
  340|      0|        let enabled = !self.table_wrap_overhaul_enabled;
  341|      0|        self.set_table_wrap_overhaul_enabled(enabled);
  342|      0|    }
  343|       |
  344|       |    /// Check if file has valid markdown extension
  345|     87|    fn is_valid_markdown_file(&self, path: &Path) -> bool {
  346|     87|        if let Some(ext) = path.extension() {
                                  ^86
  347|     86|            let ext = ext.to_string_lossy().to_lowercase();
  348|     86|            matches!(ext.as_str(), "md" | "markdown" | "mdown" | "mkd" | "txt")
                          ^80                           ^12          ^9        ^8      ^7
  349|       |        } else {
  350|      1|            false
  351|       |        }
  352|     87|    }
  353|       |
  354|       |    /// Handle dropped files from drag-and-drop operation
  355|      7|    fn handle_file_drop(&mut self, paths: Vec<PathBuf>) {
  356|      7|        if paths.is_empty() {
  357|      0|            return;
  358|      7|        }
  359|       |
  360|      7|        let mut valid_files = Vec::new();
  361|      7|        let mut errors = Vec::new();
  362|       |
  363|       |        // Validate all dropped files
  364|     78|        for path in paths {
                          ^71
  365|     71|            if !path.exists() {
  366|      0|                errors.push(format!("File not found: {}", path.display()));
  367|      0|                continue;
  368|     71|            }
  369|       |
  370|     71|            if path.is_dir() {
  371|       |                // Handle directory by scanning for markdown files
  372|      2|                match self.scan_directory(&path) {
  373|      2|                    Ok(dir_files) => {
  374|      2|                        if dir_files.is_empty() {
  375|      1|                            errors.push(format!(
  376|      1|                                "No markdown files in directory: {}",
  377|      1|                                path.display()
  378|      1|                            ));
  379|      1|                        } else {
  380|      1|                            valid_files.extend(dir_files);
  381|      1|                        }
  382|       |                    }
  383|      0|                    Err(e) => {
  384|      0|                        errors.push(format!("Cannot read directory {}: {}", path.display(), e));
  385|      0|                    }
  386|       |                }
  387|      2|                continue;
  388|     69|            }
  389|       |
  390|     69|            if !self.is_valid_markdown_file(&path) {
  391|      2|                errors.push(format!(
  392|      2|                    "Not a markdown file: {}",
  393|      2|                    path.file_name().unwrap_or_default().to_string_lossy()
  394|       |                ));
  395|      2|                continue;
  396|     67|            }
  397|       |
  398|     67|            valid_files.push(path);
  399|       |        }
  400|       |
  401|       |        // Limit to prevent memory issues
  402|       |        const MAX_FILES: usize = 50;
  403|      7|        if valid_files.len() > MAX_FILES {
  404|      1|            self.error_message = Some(format!(
  405|      1|                "Too many files ({}). Maximum is {}.\n\
  406|      1|                 Please drop files in smaller batches.",
  407|      1|                valid_files.len(),
  408|      1|                MAX_FILES
  409|      1|            ));
  410|      1|            return;
  411|      6|        }
  412|       |
  413|       |        // Handle valid files
  414|      6|        if !valid_files.is_empty() {
  415|       |            // Open first file immediately
  416|      4|            let first_file = valid_files.remove(0);
  417|      4|            if let Err(e) = self.load_file(first_file, true) {
                                     ^0
  418|      0|                self.error_message = Some(format!("Failed to load file: {}", e));
  419|      0|                return;
  420|      4|            }
  421|       |
  422|       |            // Queue remaining files
  423|      4|            self.pending_files.extend(valid_files.iter().cloned());
  424|       |
  425|       |            // Show info message if multiple files
  426|      4|            if !self.pending_files.is_empty() {
  427|      2|                eprintln!(
  428|      2|                    "Queued {} files. Use Alt+Right to navigate to the next file.",
  429|      2|                    self.pending_files.len()
  430|      2|                );
  431|      2|            }
  432|      2|        }
  433|       |
  434|       |        // Show errors if any
  435|      6|        if !errors.is_empty() {
  436|      3|            let valid_count = if valid_files.is_empty() {
  437|      3|                0
  438|       |            } else {
  439|      0|                valid_files.len() + 1
  440|       |            };
  441|      3|            let error_msg = if errors.len() == 1 && valid_count == 0 {
  442|      3|                errors[0].clone()
  443|      0|            } else if valid_count == 0 {
  444|       |                // All files failed
  445|      0|                format!("No valid files:\n{}", errors.join("\n"))
  446|       |            } else {
  447|       |                // Some succeeded, some failed
  448|      0|                format!(
  449|      0|                    "Opened {} files. Skipped {}:\n{}",
  450|       |                    valid_count,
  451|      0|                    errors.len(),
  452|      0|                    errors.join("\n")
  453|       |                )
  454|       |            };
  455|      3|            self.error_message = Some(error_msg);
  456|      3|        }
  457|      7|    }
  458|       |
  459|       |    /// Scan directory for markdown files (non-recursive)
  460|      4|    fn scan_directory(&self, dir: &Path) -> Result<Vec<PathBuf>> {
  461|      4|        let mut files = Vec::new();
  462|       |
  463|      4|        let entries = std::fs::read_dir(dir)?;
                                                          ^0
  464|       |
  465|     12|        for entry in entries {
                          ^8
  466|      8|            let entry = entry?;
                                           ^0
  467|      8|            let path = entry.path();
  468|       |
  469|       |            // Only include files (not subdirectories)
  470|      8|            if path.is_file() && self.is_valid_markdown_file(&path) {
                                               ^7   ^7                     ^7
  471|      6|                files.push(path);
  472|      6|            }
                          ^2
  473|       |        }
  474|       |
  475|       |        // Sort alphabetically for predictable order
  476|      4|        files.sort();
  477|       |
  478|      4|        Ok(files)
  479|      4|    }
  480|       |
  481|       |    /// Load markdown content from a string
  482|     62|    pub fn load_content(&mut self, content: &str, title: Option<String>) {
  483|     62|        self.current_content = content.to_string();
  484|     62|        self.raw_buffer = self.current_content.clone();
  485|     62|        self.error_message = None;
  486|     62|        self.nav_request = None; // Reset any pending navigation
  487|       |                                 // Ensure scroll resets to top on new content
  488|     62|        self.pending_scroll_to_element = Some(0);
  489|     62|        self.renderer.clear_table_layout_cache();
  490|       |
  491|     62|        match self.renderer.parse(content) {
  492|     62|            Ok(elements) => {
  493|     62|                self.parsed_elements = elements;
  494|     62|                if let Some(title) = title {
                                          ^61
  495|     61|                    self.title = format!("{APP_TITLE_PREFIX} - {}", title);
  496|     61|                }
                              ^1
  497|       |            }
  498|      0|            Err(e) => {
  499|      0|                self.error_message = Some(format!("Failed to parse markdown: {}", e));
  500|      0|                self.parsed_elements.clear();
  501|      0|            }
  502|       |        }
  503|     62|    }
  504|       |
  505|       |    /// Load markdown content from a file path
  506|     13|    pub fn load_file(&mut self, path: PathBuf, record_history: bool) -> Result<()> {
  507|       |        // Push current state to history before loading new file
  508|     13|        if record_history && !self.current_content.is_empty() {
                                           ^12
  509|     12|            self.push_history();
  510|     12|        }
                      ^1
  511|       |
  512|     13|        let (content, lossy) = Self::read_file_lossy(&path)?;
                           ^12      ^12                                  ^1
  513|     12|        let filename = path
  514|     12|            .file_name()
  515|     12|            .and_then(|n| n.to_str())
  516|     12|            .unwrap_or("Unknown")
  517|     12|            .to_string();
  518|       |
  519|     12|        let base = path.parent().map(|p| p.to_path_buf());
  520|     12|        self.renderer.set_base_dir(base.as_deref());
  521|     12|        self.current_file = Some(path);
  522|     12|        self.load_content(&content, Some(filename));
  523|     12|        if lossy {
  524|      1|            eprintln!("Loaded file with invalid UTF-8; replaced invalid sequences.");
  525|     11|        }
  526|     12|        Ok(())
  527|     13|    }
  528|       |
  529|       |    /// Normalize all line endings to Unix style (\n)
  530|       |    /// Handles Windows (\r\n), Unix (\n), and old Mac (\r) formats
  531|     19|    fn normalize_line_endings(s: &str) -> String {
  532|       |        // Order matters: replace \r\n first (Windows), then remaining \r (old Mac)
  533|     19|        s.replace("\r\n", "\n").replace('\r', "\n")
  534|     19|    }
  535|       |
  536|     13|    fn read_file_lossy(path: &Path) -> Result<(String, bool)> {
  537|     13|        match std::fs::read_to_string(path) {
  538|     11|            Ok(s) => Ok((Self::normalize_line_endings(&s), false)),
  539|      2|            Err(e) if e.kind() == ErrorKind::InvalidData => {
                              ^1                                     ^1
  540|      1|                let bytes = std::fs::read(path)?;
                                                             ^0
  541|      1|                let s = String::from_utf8_lossy(&bytes).into_owned();
  542|      1|                Ok((Self::normalize_line_endings(&s), true))
  543|       |            }
  544|      1|            Err(e) => Err(e.into()),
  545|       |        }
  546|     13|    }
  547|       |
  548|      1|    fn current_window_state(&self) -> Option<WindowState> {
  549|      1|        let pos = self.last_window_pos?;
                                                    ^0
  550|      1|        let size = self.last_window_size?;
                                                      ^0
  551|      1|        Some(WindowState {
  552|      1|            pos,
  553|      1|            size,
  554|      1|            maximized: self.last_window_maximized,
  555|      1|        })
  556|      1|    }
  557|       |
  558|      2|    fn compute_window_adjustment(
  559|      2|        outer_rect: Option<egui::Rect>,
  560|      2|        monitor_size: Option<egui::Vec2>,
  561|      2|    ) -> Option<(egui::Pos2, egui::Vec2)> {
  562|      2|        let outer = outer_rect?;
                                            ^0
  563|      2|        let monitor = monitor_size?;
                                                ^0
  564|       |
  565|      2|        if monitor.x <= 0.0 || monitor.y <= 0.0 {
  566|      0|            return None;
  567|      2|        }
  568|       |
  569|       |        const MIN_WIDTH: f32 = 600.0;
  570|       |        const MIN_HEIGHT: f32 = 400.0;
  571|       |        const OFFSCREEN_TOLERANCE: f32 = 32.0;
  572|       |
  573|      2|        let mut pos = outer.min;
  574|      2|        let mut size = outer.size();
  575|      2|        let mut adjusted = false;
  576|       |
  577|      2|        if !pos.x.is_finite() || !pos.y.is_finite() {
  578|      0|            pos = egui::pos2(0.0, 0.0);
  579|      0|            adjusted = true;
  580|      2|        }
  581|      2|        if !size.x.is_finite() || !size.y.is_finite() {
  582|      0|            size = egui::vec2(MIN_WIDTH, MIN_HEIGHT);
  583|      0|            adjusted = true;
  584|      2|        }
  585|       |
  586|      2|        let available_width = monitor.x.max(MIN_WIDTH);
  587|      2|        let available_height = monitor.y.max(MIN_HEIGHT);
  588|       |
  589|      2|        if size.x < MIN_WIDTH {
  590|      1|            size.x = MIN_WIDTH.min(available_width);
  591|      1|            adjusted = true;
  592|      1|        }
  593|      2|        if size.y < MIN_HEIGHT {
  594|      1|            size.y = MIN_HEIGHT.min(available_height);
  595|      1|            adjusted = true;
  596|      1|        }
  597|      2|        if size.x > available_width {
  598|      0|            size.x = available_width;
  599|      0|            adjusted = true;
  600|      2|        }
  601|      2|        if size.y > available_height {
  602|      0|            size.y = available_height;
  603|      0|            adjusted = true;
  604|      2|        }
  605|       |
  606|      2|        let max_pos = egui::pos2((monitor.x - size.x).max(0.0), (monitor.y - size.y).max(0.0));
  607|       |
  608|      2|        if pos.x <= -0.25 * size.x {
  609|      1|            pos.x = 0.0;
  610|      1|            adjusted = true;
  611|      1|        }
  612|      2|        if pos.y <= -0.25 * size.y {
  613|      1|            pos.y = 0.0;
  614|      1|            adjusted = true;
  615|      1|        }
  616|      2|        if pos.x > max_pos.x + OFFSCREEN_TOLERANCE {
  617|      1|            pos.x = max_pos.x;
  618|      1|            adjusted = true;
  619|      1|        }
  620|      2|        if pos.y > max_pos.y + OFFSCREEN_TOLERANCE {
  621|      1|            pos.y = max_pos.y;
  622|      1|            adjusted = true;
  623|      1|        }
  624|       |
  625|      2|        if adjusted {
  626|      2|            size.x = size.x.max(MIN_WIDTH.min(available_width));
  627|      2|            size.y = size.y.max(MIN_HEIGHT.min(available_height));
  628|      2|            Some((pos, size))
  629|       |        } else {
  630|      0|            None
  631|       |        }
  632|      2|    }
  633|       |
  634|      3|    fn window_state_changed(&self, new_state: &WindowState) -> bool {
  635|      3|        match &self.last_persisted_state {
  636|      2|            Some(prev) => {
  637|      2|                let pos_changed = (prev.pos[0] - new_state.pos[0]).abs() > 0.5
  638|      1|                    || (prev.pos[1] - new_state.pos[1]).abs() > 0.5;
  639|      2|                let size_changed = (prev.size[0] - new_state.size[0]).abs() > 0.5
  640|      2|                    || (prev.size[1] - new_state.size[1]).abs() > 0.5;
  641|      2|                let maximized_changed = prev.maximized != new_state.maximized;
  642|      2|                pos_changed || size_changed || maximized_changed
                                             ^1              ^1
  643|       |            }
  644|      1|            None => true,
  645|       |        }
  646|      3|    }
  647|       |
  648|      4|    fn fold_for_search(input: &str) -> String {
  649|      4|        input.case_fold().nfkc().collect()
  650|      4|    }
  651|       |
  652|       |    /// Push current state to navigation history
  653|     19|    fn push_history(&mut self) {
  654|       |        // Truncate forward history if we're not at the end
  655|     19|        if self.history_index < self.history.len() {
  656|      0|            self.history.truncate(self.history_index);
  657|     19|        }
  658|       |
  659|       |        // Create entry for current state
  660|     19|        let entry = HistoryEntry {
  661|     19|            file_path: self.current_file.clone(),
  662|     19|            title: self.title.clone(),
  663|     19|            content: self.current_content.clone(),
  664|     19|        };
  665|       |
  666|     19|        self.history.push(entry);
  667|       |
  668|       |        // Limit history size
  669|     19|        if self.history.len() > self.max_history {
  670|      0|            self.history.remove(0);
  671|     19|        } else {
  672|     19|            self.history_index = self.history.len();
  673|     19|        }
  674|     19|    }
  675|       |
  676|       |    /// Navigate back in history
  677|      0|    fn navigate_back(&mut self) -> bool {
  678|      0|        if self.history_index > 0 {
  679|      0|            self.history_index -= 1;
  680|      0|            self.restore_from_history();
  681|      0|            true
  682|       |        } else {
  683|      0|            false
  684|       |        }
  685|      0|    }
  686|       |
  687|       |    /// Navigate forward in history
  688|      1|    fn navigate_forward(&mut self) -> bool {
  689|       |        // First try pending files queue
  690|      1|        if let Some(next_file) = self.pending_files.pop_front() {
  691|       |            // Load next file from queue
  692|      1|            if let Err(e) = self.load_file(next_file, true) {
                                     ^0
  693|      0|                self.error_message = Some(format!("Failed to load file: {}", e));
  694|      1|            }
  695|      1|            return true;
  696|      0|        }
  697|       |
  698|       |        // Otherwise use history navigation (existing code)
  699|      0|        if self.history_index < self.history.len() - 1 {
  700|      0|            self.history_index += 1;
  701|      0|            self.restore_from_history();
  702|      0|            true
  703|       |        } else {
  704|      0|            false
  705|       |        }
  706|      1|    }
  707|       |
  708|       |    /// Restore state from history at current index
  709|      0|    fn restore_from_history(&mut self) {
  710|      0|        if let Some(entry) = self.history.get(self.history_index) {
  711|      0|            self.current_file = entry.file_path.clone();
  712|      0|            self.title = entry.title.clone();
  713|      0|            self.current_content = entry.content.clone();
  714|      0|            self.raw_buffer = self.current_content.clone();
  715|       |
  716|       |            // Re-parse content
  717|      0|            match self.renderer.parse(&self.current_content) {
  718|      0|                Ok(elements) => {
  719|      0|                    self.parsed_elements = elements;
  720|      0|                    self.error_message = None;
  721|      0|                }
  722|      0|                Err(e) => {
  723|      0|                    self.error_message = Some(format!("Failed to parse: {}", e));
  724|      0|                }
  725|       |            }
  726|       |
  727|       |            // Set base dir for images
  728|      0|            if let Some(ref path) = self.current_file {
  729|      0|                self.renderer.set_base_dir(path.parent());
  730|      0|            } else {
  731|      0|                self.renderer.set_base_dir(None);
  732|      0|            }
  733|       |
  734|       |            // Scroll to top
  735|      0|            self.pending_scroll_to_element = Some(0);
  736|      0|        }
  737|      0|    }
  738|       |
  739|       |    /// Check if we can navigate back
  740|      0|    fn can_navigate_back(&self) -> bool {
  741|      0|        self.history_index > 0
  742|      0|    }
  743|       |
  744|       |    /// Check if we can navigate forward
  745|      1|    fn can_navigate_forward(&self) -> bool {
  746|      1|        !self.pending_files.is_empty() || self.history_index < self.history.len().saturating_sub(1)
                                                        ^0                   ^0
  747|      1|    }
  748|       |
  749|       |    /// Request a reload of the current file (processed outside of input context)
  750|      0|    fn request_reload(&mut self) {
  751|      0|        if self.current_file.is_some() {
  752|      0|            self.reload_requested = true;
  753|      0|        } else {
  754|      0|            self.error_message = Some("No file loaded to reload".to_string());
  755|      0|        }
  756|      0|    }
  757|       |
  758|       |    /// Reload the currently opened file from disk
  759|      2|    pub fn reload_current_file(&mut self) -> Result<()> {
  760|      2|        let path = if let Some(p) = self.current_file.clone() {
                          ^1                 ^1
  761|      1|            p
  762|       |        } else {
  763|      1|            bail!("No file loaded to reload");
  764|       |        };
  765|      1|        self.load_file(path, false)
  766|      2|    }
  767|       |
  768|       |    /// Load a sample file by name
  769|      7|    pub fn load_sample(&mut self, sample: &SampleFile) {
  770|       |        // Push current state to history before loading sample
  771|      7|        if !self.current_content.is_empty() {
  772|      7|            self.push_history();
  773|      7|        }
                      ^0
  774|       |
  775|      7|        self.current_file = None;
  776|       |        // Samples have no file base-dir
  777|      7|        self.renderer.set_base_dir(None);
  778|      7|        self.load_content(sample.content, Some(sample.title.to_string()));
  779|       |        // Scroll to top for new sample
  780|      7|        self.pending_scroll_to_element = Some(0);
  781|      7|    }
  782|       |
  783|       |    /// Close the current file and return to welcome screen
  784|      1|    pub fn close_current_file(&mut self) {
  785|      1|        self.current_file = None;
  786|      1|        self.renderer.set_base_dir(None);
  787|      1|        if let Some(welcome) = SAMPLE_FILES.iter().find(|f| f.name == "welcome.md") {
  788|      1|            self.load_content(welcome.content, Some("Welcome".to_string()));
  789|      1|            self.pending_scroll_to_element = Some(0);
  790|      1|        } else {
  791|      0|            // Fallback if welcome file is missing
  792|      0|            self.current_content.clear();
  793|      0|            self.parsed_elements.clear();
  794|      0|            self.title = APP_TITLE_PREFIX.to_string();
  795|      0|            self.error_message = None;
  796|      0|        }
  797|      1|    }
  798|       |
  799|       |    /// Open file dialog to select a markdown file
  800|      0|    fn open_file_dialog(&mut self) {
  801|      0|        if let Some(path) = FileDialog::new()
  802|      0|            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
  803|      0|            .add_filter("All files", &["*"])
  804|      0|            .set_title("Open Markdown File")
  805|      0|            .pick_file()
  806|       |        {
  807|      0|            if let Err(e) = self.load_file(path, true) {
  808|      0|                self.error_message = Some(format!("Failed to open file: {}", e));
  809|      0|            }
  810|      0|        }
  811|      0|    }
  812|       |
  813|       |    /// Toggle between Rendered and Raw view
  814|      2|    fn toggle_view_mode(&mut self, ctx: &Context) {
  815|       |        // If leaving Raw view while editing, capture cursor before switching
  816|      2|        if matches!(self.view_mode, ViewMode::Raw) && self.write_enabled {
                         ^1                                         ^1
  817|      0|            let editor_id = egui::Id::new("raw_editor");
  818|      0|            if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
  819|      0|                if let Some(range) = state.cursor.char_range() {
  820|      0|                    self.raw_cursor = Some(range.primary.index);
  821|      0|                }
  822|      0|            }
  823|      2|        }
  824|      2|        self.view_mode = match self.view_mode {
  825|       |            ViewMode::Rendered => {
  826|      1|                self.raw_focus_requested = true;
  827|      1|                ViewMode::Raw
  828|       |            }
  829|      1|            ViewMode::Raw => ViewMode::Rendered,
  830|       |        };
  831|      2|    }
  832|       |
  833|       |    /// Handle keyboard shortcuts
  834|      0|    fn handle_shortcuts(&mut self, ctx: &Context) {
  835|      0|        ctx.input_mut(|i| {
  836|      0|            let in_raw_edit = matches!(self.view_mode, ViewMode::Raw) && self.write_enabled;
  837|       |            // Ctrl+O - Open file
  838|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  839|      0|                egui::Modifiers::CTRL,
  840|      0|                egui::Key::O,
  841|      0|            )) {
  842|      0|                self.open_file_dialog();
  843|      0|            }
  844|       |
  845|       |            // Alt-based accelerators for common actions (mnemonics)
  846|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  847|      0|                egui::Modifiers::ALT,
  848|      0|                egui::Key::O,
  849|      0|            )) {
  850|      0|                self.open_file_dialog();
  851|      0|            }
  852|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  853|      0|                egui::Modifiers::ALT,
  854|      0|                egui::Key::W,
  855|      0|            )) {
  856|      0|                self.close_current_file();
  857|      0|            }
  858|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  859|      0|                egui::Modifiers::ALT,
  860|      0|                egui::Key::Q,
  861|      0|            )) {
  862|      0|                ctx.send_viewport_cmd(egui::ViewportCommand::Close);
  863|      0|            }
  864|       |
  865|       |            // Ctrl+Q - Quit application
  866|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  867|      0|                egui::Modifiers::CTRL,
  868|      0|                egui::Key::Q,
  869|      0|            )) {
  870|      0|                ctx.send_viewport_cmd(egui::ViewportCommand::Close);
  871|      0|            }
  872|       |
  873|       |            // Ctrl+W - Close current file
  874|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  875|      0|                egui::Modifiers::CTRL,
  876|      0|                egui::Key::W,
  877|      0|            )) {
  878|      0|                self.close_current_file();
  879|      0|            }
  880|       |
  881|       |            // Ctrl+F - Open search dialog
  882|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  883|      0|                egui::Modifiers::CTRL,
  884|      0|                egui::Key::F,
  885|      0|            )) {
  886|      0|                self.show_search = true;
  887|      0|                if self.last_match_index.is_none() {
  888|      0|                    self.last_match_index = Some(0);
  889|      0|                }
  890|      0|                self.search_focus_requested = true;
  891|      0|            }
  892|       |
  893|       |            // F3 navigation: next / previous
  894|      0|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F3) {
  895|      0|                self.find_next();
  896|      0|            }
  897|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  898|      0|                egui::Modifiers::SHIFT,
  899|      0|                egui::Key::F3,
  900|      0|            )) || i.consume_shortcut(&egui::KeyboardShortcut::new(
  901|      0|                egui::Modifiers::ALT,
  902|      0|                egui::Key::F3,
  903|      0|            )) {
  904|      0|                self.find_previous();
  905|      0|            }
  906|       |
  907|       |            // Ctrl+Plus - Zoom in
  908|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  909|      0|                egui::Modifiers::CTRL,
  910|      0|                egui::Key::Plus,
  911|      0|            )) {
  912|      0|                self.renderer.zoom_in();
  913|      0|            }
  914|       |
  915|       |            // Ctrl+Minus - Zoom out
  916|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  917|      0|                egui::Modifiers::CTRL,
  918|      0|                egui::Key::Minus,
  919|      0|            )) {
  920|      0|                self.renderer.zoom_out();
  921|      0|            }
  922|       |
  923|       |            // Ctrl+0 - Reset zoom
  924|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  925|      0|                egui::Modifiers::CTRL,
  926|      0|                egui::Key::Num0,
  927|      0|            )) {
  928|      0|                self.renderer.reset_zoom();
  929|      0|            }
  930|       |
  931|       |            // Alt+Left - Navigate back
  932|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  933|      0|                egui::Modifiers::ALT,
  934|      0|                egui::Key::ArrowLeft,
  935|      0|            )) {
  936|      0|                self.navigate_back();
  937|      0|            }
  938|       |
  939|       |            // Alt+Right - Navigate forward
  940|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  941|      0|                egui::Modifiers::ALT,
  942|      0|                egui::Key::ArrowRight,
  943|      0|            )) {
  944|      0|                self.navigate_forward();
  945|      0|            }
  946|       |
  947|       |            // Ctrl + Mouse Wheel - Zoom
  948|      0|            if i.modifiers.ctrl {
  949|      0|                let mut total = 0.0f32;
  950|      0|                for ev in &i.events {
  951|      0|                    if let egui::Event::MouseWheel { delta, .. } = ev {
  952|      0|                        total += delta.y;
  953|      0|                    }
  954|       |                }
  955|      0|                if total.abs() > 0.0 {
  956|      0|                    if total > 0.0 {
  957|      0|                        self.renderer.zoom_in();
  958|      0|                    } else if total < 0.0 {
  959|      0|                        self.renderer.zoom_out();
  960|      0|                    }
  961|      0|                }
  962|      0|            }
  963|       |
  964|       |            // Ctrl+R - Toggle raw view
  965|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  966|      0|                egui::Modifiers::CTRL,
  967|      0|                egui::Key::R,
  968|      0|            )) {
  969|      0|                // Defer to avoid acting inside input context
  970|      0|                self.view_toggle_requested = true;
  971|      0|            }
  972|       |            // Ctrl+E - Toggle write mode (deferred)
  973|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  974|      0|                egui::Modifiers::CTRL,
  975|      0|                egui::Key::E,
  976|      0|            )) {
  977|      0|                self.write_toggle_requested = true;
  978|      0|            }
  979|       |            // Ctrl+S - Save document
  980|      0|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  981|      0|                egui::Modifiers::CTRL,
  982|      0|                egui::Key::S,
  983|      0|            )) {
  984|      0|                if let Err(e) = self.save_current_document() {
  985|      0|                    self.error_message = Some(format!("Failed to save: {}", e));
  986|      0|                }
  987|      0|            }
  988|       |            // Note: No global Alt+R to avoid conflict (File > Reload vs View > Raw)
  989|       |
  990|       |            // F11 - Toggle fullscreen (set flag to handle outside input context)
  991|      0|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F11) {
  992|      0|                self.toggle_fullscreen = true;
  993|      0|            }
  994|       |
  995|       |            // F5 - Reload current file (set flag; actual IO handled outside input context)
  996|      0|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F5) {
  997|      0|                self.request_reload();
  998|      0|            }
  999|       |
 1000|       |            // Esc - dismiss search dialog if visible
 1001|      0|            if self.show_search && i.consume_key(egui::Modifiers::NONE, egui::Key::Escape) {
 1002|      0|                self.clear_search_state();
 1003|      0|                self.show_search = false;
 1004|      0|            }
 1005|       |
 1006|       |            // Only consume navigation keys when not editing in raw view
 1007|      0|            if !in_raw_edit {
 1008|      0|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
 1009|      0|                    self.nav_request = Some(NavigationRequest::PageUp);
 1010|      0|                }
 1011|      0|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
 1012|      0|                    self.nav_request = Some(NavigationRequest::PageDown);
 1013|      0|                }
 1014|       |                // Home - Go to top of document
 1015|      0|                if i.consume_key(egui::Modifiers::NONE, egui::Key::Home) {
 1016|      0|                    self.nav_request = Some(NavigationRequest::Top);
 1017|      0|                }
 1018|       |
 1019|       |                // End - Go to bottom of document
 1020|      0|                if i.consume_key(egui::Modifiers::NONE, egui::Key::End) {
 1021|      0|                    self.nav_request = Some(NavigationRequest::Bottom);
 1022|      0|                }
 1023|       |
 1024|       |                // Arrow Up - Fine scroll up
 1025|      0|                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowUp) {
 1026|      0|                    self.nav_request = Some(NavigationRequest::ScrollUp);
 1027|      0|                }
 1028|       |
 1029|       |                // Arrow Down - Fine scroll down
 1030|      0|                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowDown) {
 1031|      0|                    self.nav_request = Some(NavigationRequest::ScrollDown);
 1032|      0|                }
 1033|       |            } else {
 1034|       |                // In raw edit mode: implement PageUp/PageDown by moving caret by ~a page of lines
 1035|       |                const PAGE_LINES: i32 = 24; // match desired_rows for the editor
 1036|      0|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
 1037|      0|                    self.pending_raw_cursor_line_move = Some(-PAGE_LINES);
 1038|      0|                    self.raw_focus_requested = true;
 1039|      0|                }
 1040|      0|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
 1041|      0|                    self.pending_raw_cursor_line_move = Some(PAGE_LINES);
 1042|      0|                    self.raw_focus_requested = true;
 1043|      0|                }
 1044|       |            }
 1045|      0|        });
 1046|      0|    }
 1047|       |
 1048|       |    /// Render the menu bar
 1049|      0|    fn render_menu_bar(&mut self, ctx: &Context) {
 1050|      0|        TopBottomPanel::top("menu_bar").show(ctx, |ui| {
 1051|      0|            let alt_pressed = ui.input(|i| i.modifiers.alt);
 1052|      0|            let menu_text_color = if ui.visuals().dark_mode {
 1053|      0|                Color32::WHITE
 1054|       |            } else {
 1055|      0|                Color32::BLACK
 1056|       |            };
 1057|      0|            menu::bar(ui, |ui| {
 1058|       |                // File menu (Alt+F mnemonic visual)
 1059|      0|                ui.menu_button(
 1060|      0|                    Self::menu_text_with_mnemonic(None, "File", 'F', alt_pressed, menu_text_color),
 1061|      0|                    |ui| {
 1062|      0|                        ui.horizontal(|ui| {
 1063|      0|                            if ui
 1064|      0|                                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1065|      0|                                    None,
 1066|      0|                                    "Open...",
 1067|      0|                                    'O',
 1068|      0|                                    alt_pressed,
 1069|      0|                                    menu_text_color,
 1070|      0|                                )))
 1071|      0|                                .clicked()
 1072|      0|                            {
 1073|      0|                                self.open_file_dialog();
 1074|      0|                                ui.close_menu();
 1075|      0|                            }
 1076|      0|                            ui.with_layout(
 1077|      0|                                egui::Layout::right_to_left(egui::Align::Center),
 1078|      0|                                |ui| {
 1079|      0|                                    ui.label(RichText::new("Ctrl+O").color(menu_text_color));
 1080|      0|                                },
 1081|       |                            );
 1082|      0|                        });
 1083|       |
 1084|      0|                        ui.horizontal(|ui| {
 1085|      0|                            let enabled = !self.current_content.is_empty();
 1086|      0|                            let button = ui.add_enabled(
 1087|      0|                                enabled,
 1088|      0|                                egui::Button::new(Self::menu_text_with_mnemonic(
 1089|      0|                                    None,
 1090|      0|                                    "Save",
 1091|       |                                    'S',
 1092|      0|                                    alt_pressed,
 1093|      0|                                    menu_text_color,
 1094|       |                                )),
 1095|       |                            );
 1096|      0|                            if button.clicked() {
 1097|      0|                                if let Err(e) = self.save_current_document() {
 1098|      0|                                    self.error_message = Some(format!("Failed to save: {}", e));
 1099|      0|                                }
 1100|      0|                                ui.close_menu();
 1101|      0|                            }
 1102|      0|                            ui.with_layout(
 1103|      0|                                egui::Layout::right_to_left(egui::Align::Center),
 1104|      0|                                |ui| {
 1105|      0|                                    ui.label(RichText::new("Ctrl+S").color(menu_text_color));
 1106|      0|                                },
 1107|       |                            );
 1108|      0|                        });
 1109|       |
 1110|      0|                        ui.horizontal(|ui| {
 1111|      0|                            if ui
 1112|      0|                                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1113|      0|                                    None,
 1114|      0|                                    "Close",
 1115|      0|                                    'C',
 1116|      0|                                    alt_pressed,
 1117|      0|                                    menu_text_color,
 1118|      0|                                )))
 1119|      0|                                .clicked()
 1120|      0|                            {
 1121|      0|                                self.close_current_file();
 1122|      0|                                ui.close_menu();
 1123|      0|                            }
 1124|      0|                            ui.with_layout(
 1125|      0|                                egui::Layout::right_to_left(egui::Align::Center),
 1126|      0|                                |ui| {
 1127|      0|                                    ui.label(RichText::new("Ctrl+W").color(menu_text_color));
 1128|      0|                                },
 1129|       |                            );
 1130|      0|                        });
 1131|       |
 1132|      0|                        ui.horizontal(|ui| {
 1133|      0|                            let enabled = self.current_file.is_some();
 1134|      0|                            let button = ui.add_enabled(
 1135|      0|                                enabled,
 1136|      0|                                egui::Button::new(Self::menu_text_with_mnemonic(
 1137|      0|                                    None,
 1138|      0|                                    "Reload",
 1139|       |                                    'R',
 1140|      0|                                    alt_pressed,
 1141|      0|                                    menu_text_color,
 1142|       |                                )),
 1143|       |                            );
 1144|      0|                            if button.clicked() {
 1145|      0|                                self.request_reload();
 1146|      0|                                ui.close_menu();
 1147|      0|                            }
 1148|      0|                            ui.with_layout(
 1149|      0|                                egui::Layout::right_to_left(egui::Align::Center),
 1150|      0|                                |ui| {
 1151|      0|                                    ui.label(RichText::new("F5").color(menu_text_color));
 1152|      0|                                },
 1153|       |                            );
 1154|      0|                        });
 1155|       |
 1156|      0|                        ui.horizontal(|ui| {
 1157|      0|                            if ui
 1158|      0|                                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1159|      0|                                    None,
 1160|      0|                                    "Find...",
 1161|      0|                                    'F',
 1162|      0|                                    alt_pressed,
 1163|      0|                                    menu_text_color,
 1164|      0|                                )))
 1165|      0|                                .clicked()
 1166|      0|                            {
 1167|      0|                                self.show_search = true;
 1168|      0|                                self.search_focus_requested = true;
 1169|      0|                                ui.close_menu();
 1170|      0|                            }
 1171|      0|                            ui.with_layout(
 1172|      0|                                egui::Layout::right_to_left(egui::Align::Center),
 1173|      0|                                |ui| {
 1174|      0|                                    ui.label(RichText::new("Ctrl+F").color(menu_text_color));
 1175|      0|                                },
 1176|       |                            );
 1177|      0|                        });
 1178|       |
 1179|      0|                        ui.separator();
 1180|       |
 1181|      0|                        ui.menu_button(
 1182|      0|                            Self::menu_text_with_mnemonic(
 1183|      0|                                None,
 1184|      0|                                "Samples",
 1185|       |                                'S',
 1186|      0|                                alt_pressed,
 1187|      0|                                menu_text_color,
 1188|       |                            ),
 1189|      0|                            |ui| {
 1190|      0|                                for sample in SAMPLE_FILES {
 1191|      0|                                    if ui.button(sample.title).clicked() {
 1192|      0|                                        self.load_sample(sample);
 1193|      0|                                        ui.close_menu();
 1194|      0|                                    }
 1195|       |                                }
 1196|      0|                            },
 1197|       |                        );
 1198|      0|                    },
 1199|       |                );
 1200|       |
 1201|       |                // View menu
 1202|      0|                ui.menu_button(
 1203|      0|                    Self::menu_text_with_mnemonic(None, "View", 'V', alt_pressed, menu_text_color),
 1204|      0|                    |ui| {
 1205|      0|                        ui.horizontal(|ui| {
 1206|      0|                            let enabled = self.can_navigate_back();
 1207|      0|                            if ui
 1208|      0|                                .add_enabled(enabled, egui::Button::new("<- Back"))
 1209|      0|                                .clicked()
 1210|      0|                            {
 1211|      0|                                self.navigate_back();
 1212|      0|                                ui.close_menu();
 1213|      0|                            }
 1214|      0|                            ui.with_layout(
 1215|      0|                                egui::Layout::right_to_left(egui::Align::Center),
 1216|      0|                                |ui| {
 1217|      0|                                    ui.label(RichText::new("Alt+Left").color(menu_text_color));
 1218|      0|                                },
 1219|       |                            );
 1220|      0|                        });
 1221|       |
 1222|      0|                        ui.horizontal(|ui| {
 1223|      0|                            let enabled = self.can_navigate_forward();
 1224|      0|                            if ui
 1225|      0|                                .add_enabled(enabled, egui::Button::new("Forward ->"))
 1226|      0|                                .clicked()
 1227|      0|                            {
 1228|      0|                                self.navigate_forward();
 1229|      0|                                ui.close_menu();
 1230|      0|                            }
 1231|      0|                            ui.with_layout(
 1232|      0|                                egui::Layout::right_to_left(egui::Align::Center),
 1233|      0|                                |ui| {
 1234|      0|                                    ui.label(RichText::new("Alt+Right").color(menu_text_color));
 1235|      0|                                },
 1236|       |                            );
 1237|      0|                        });
 1238|       |
 1239|      0|                        ui.separator();
 1240|       |
 1241|      0|                        ui.horizontal(|ui| {
 1242|      0|                            let selected = matches!(self.view_mode, ViewMode::Raw);
 1243|      0|                            if ui
 1244|      0|                                .add(egui::SelectableLabel::new(
 1245|      0|                                    selected,
 1246|      0|                                    Self::menu_text_with_mnemonic(
 1247|      0|                                        None,
 1248|      0|                                        "Raw Markdown",
 1249|      0|                                        'R',
 1250|      0|                                        alt_pressed,
 1251|      0|                                        menu_text_color,
 1252|      0|                                    ),
 1253|      0|                                ))
 1254|      0|                                .clicked()
 1255|      0|                            {
 1256|      0|                                self.toggle_view_mode(ctx);
 1257|      0|                                ui.close_menu();
 1258|      0|                            }
 1259|      0|                            ui.with_layout(
 1260|      0|                                egui::Layout::right_to_left(egui::Align::Center),
 1261|      0|                                |ui| {
 1262|      0|                                    ui.label(RichText::new("Ctrl+R").color(menu_text_color));
 1263|      0|                                },
 1264|       |                            );
 1265|      0|                        });
 1266|       |
 1267|      0|                        ui.horizontal(|ui| {
 1268|      0|                            let selected = self.write_enabled;
 1269|      0|                            if ui
 1270|      0|                                .add(egui::SelectableLabel::new(
 1271|      0|                                    selected,
 1272|      0|                                    Self::menu_text_with_mnemonic(
 1273|      0|                                        None,
 1274|      0|                                        "Write Mode",
 1275|      0|                                        'W',
 1276|      0|                                        alt_pressed,
 1277|      0|                                        menu_text_color,
 1278|      0|                                    ),
 1279|      0|                                ))
 1280|      0|                                .clicked()
 1281|      0|                            {
 1282|      0|                                self.toggle_write_mode(ctx);
 1283|      0|                                ui.close_menu();
 1284|      0|                            }
 1285|      0|                            ui.with_layout(
 1286|      0|                                egui::Layout::right_to_left(egui::Align::Center),
 1287|      0|                                |ui| {
 1288|      0|                                    ui.label(RichText::new("Ctrl+E").color(menu_text_color));
 1289|      0|                                },
 1290|       |                            );
 1291|      0|                        });
 1292|       |
 1293|      0|                        ui.horizontal(|ui| {
 1294|      0|                            if ui
 1295|      0|                                .selectable_label(self.wrap_raw, "Wrap Raw Lines")
 1296|      0|                                .clicked()
 1297|      0|                            {
 1298|      0|                                self.wrap_raw = !self.wrap_raw;
 1299|      0|                            }
 1300|      0|                        });
 1301|       |
 1302|      0|                        ui.horizontal(|ui| {
 1303|      0|                            let label = if self.table_wrap_overhaul_enabled {
 1304|      0|                                "Table Wrap Overhaul (new)"
 1305|       |                            } else {
 1306|      0|                                "Table Wrap Overhaul (legacy)"
 1307|       |                            };
 1308|      0|                            if ui
 1309|      0|                                .selectable_label(self.table_wrap_overhaul_enabled, label)
 1310|      0|                                .clicked()
 1311|      0|                            {
 1312|      0|                                self.toggle_table_wrap_overhaul();
 1313|      0|                                ui.close_menu();
 1314|      0|                            }
 1315|      0|                        });
 1316|       |
 1317|      0|                        ui.horizontal(|ui| {
 1318|      0|                            if ui.button("Zoom In").clicked() {
 1319|      0|                                self.renderer.zoom_in();
 1320|      0|                                ui.close_menu();
 1321|      0|                            }
 1322|      0|                            ui.with_layout(
 1323|      0|                                egui::Layout::right_to_left(egui::Align::Center),
 1324|      0|                                |ui| {
 1325|      0|                                    ui.label(RichText::new("Ctrl++").color(menu_text_color));
 1326|      0|                                },
 1327|       |                            );
 1328|      0|                        });
 1329|       |
 1330|      0|                        ui.horizontal(|ui| {
 1331|      0|                            if ui.button("Zoom Out").clicked() {
 1332|      0|                                self.renderer.zoom_out();
 1333|      0|                                ui.close_menu();
 1334|      0|                            }
 1335|      0|                            ui.with_layout(
 1336|      0|                                egui::Layout::right_to_left(egui::Align::Center),
 1337|      0|                                |ui| {
 1338|      0|                                    ui.label(RichText::new("Ctrl+-").color(menu_text_color));
 1339|      0|                                },
 1340|       |                            );
 1341|      0|                        });
 1342|       |
 1343|      0|                        ui.horizontal(|ui| {
 1344|      0|                            if ui.button("Reset Zoom").clicked() {
 1345|      0|                                self.renderer.reset_zoom();
 1346|      0|                                ui.close_menu();
 1347|      0|                            }
 1348|      0|                            ui.with_layout(
 1349|      0|                                egui::Layout::right_to_left(egui::Align::Center),
 1350|      0|                                |ui| {
 1351|      0|                                    ui.label(RichText::new("Ctrl+0").color(menu_text_color));
 1352|      0|                                },
 1353|       |                            );
 1354|      0|                        });
 1355|       |
 1356|      0|                        ui.separator();
 1357|       |
 1358|      0|                        ui.horizontal(|ui| {
 1359|      0|                            if ui.button("Toggle Fullscreen").clicked() {
 1360|      0|                                let is_fullscreen =
 1361|      0|                                    ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
 1362|      0|                                ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(
 1363|      0|                                    !is_fullscreen,
 1364|      0|                                ));
 1365|      0|                                ui.close_menu();
 1366|      0|                            }
 1367|      0|                            ui.with_layout(
 1368|      0|                                egui::Layout::right_to_left(egui::Align::Center),
 1369|      0|                                |ui| {
 1370|      0|                                    ui.label(RichText::new("F11").color(menu_text_color));
 1371|      0|                                },
 1372|       |                            );
 1373|      0|                        });
 1374|      0|                    },
 1375|       |                );
 1376|       |
 1377|      0|                ui.menu_button("Help", |ui| {
 1378|      0|                    if ui.button("Usage Instructions").clicked() {
 1379|      0|                        if let Some(usage) = SAMPLE_FILES.iter().find(|f| f.name == "usage.md") {
 1380|      0|                            self.load_sample(usage);
 1381|      0|                        }
 1382|      0|                        ui.close_menu();
 1383|      0|                    }
 1384|       |
 1385|      0|                    if ui.button("About").clicked() {
 1386|      0|                        if let Some(welcome) = SAMPLE_FILES.iter().find(|f| f.name == "welcome.md")
 1387|      0|                        {
 1388|      0|                            self.load_sample(welcome);
 1389|      0|                        }
 1390|      0|                        ui.close_menu();
 1391|      0|                    }
 1392|      0|                });
 1393|      0|            });
 1394|      0|        });
 1395|       |
 1396|       |        // No programmatic overlay menus; rely on pointer to open egui menus.
 1397|      0|    }
 1398|       |    /// Render the status bar
 1399|      0|    fn render_status_bar(&self, ctx: &Context) {
 1400|      0|        TopBottomPanel::bottom("status_bar").show(ctx, |ui| {
 1401|      0|            ui.horizontal(|ui| {
 1402|       |                // Current file info
 1403|      0|                if let Some(path) = &self.current_file {
 1404|      0|                    ui.label(format!("File: {}", path.display()));
 1405|      0|                } else if !self.parsed_elements.is_empty() {
 1406|      0|                    ui.label("Sample file");
 1407|      0|                } else {
 1408|      0|                    ui.label("No file loaded");
 1409|      0|                }
 1410|       |
 1411|       |                // Show pending file count if files are queued
 1412|      0|                if !self.pending_files.is_empty() {
 1413|      0|                    ui.separator();
 1414|      0|                    ui.label(
 1415|      0|                        RichText::new(format!("{} files in queue", self.pending_files.len()))
 1416|      0|                            .color(egui::Color32::from_rgb(100, 150, 255)),
 1417|      0|                    );
 1418|      0|
 1419|      0|                    ui.label(
 1420|      0|                        RichText::new("(Alt+Right for next)")
 1421|      0|                            .color(egui::Color32::GRAY)
 1422|      0|                            .italics(),
 1423|      0|                    );
 1424|      0|                }
 1425|       |
 1426|      0|                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1427|       |                    // Document stats
 1428|      0|                    let element_count = self.parsed_elements.len();
 1429|      0|                    let char_count = self.current_content.len();
 1430|      0|                    let mode = match self.view_mode {
 1431|      0|                        ViewMode::Rendered => "Rendered",
 1432|      0|                        ViewMode::Raw => "Raw",
 1433|       |                    };
 1434|      0|                    let status = format!(
 1435|      0|                        "Mode: {} | Elements: {} | Characters: {}",
 1436|       |                        mode, element_count, char_count
 1437|       |                    );
 1438|      0|                    ui.label(status).on_hover_ui(|ui| {
 1439|      0|                        ui.label(format!("Version: {}", BUILD_VERSION));
 1440|      0|                        ui.label(format!("Built: {}", BUILD_TIMESTAMP));
 1441|      0|                    });
 1442|       |
 1443|      0|                    let wrap_label = if self.table_wrap_overhaul_enabled {
 1444|      0|                        RichText::new("Wrap: Overhaul").color(Color32::from_rgb(120, 200, 255))
 1445|       |                    } else {
 1446|      0|                        RichText::new("Wrap: Legacy").color(Color32::from_rgb(140, 140, 140))
 1447|       |                    };
 1448|      0|                    let cache_tip = if self.table_wrap_overhaul_enabled {
 1449|      0|                        let (hits, misses) = self.renderer.table_layout_cache_stats();
 1450|      0|                        let (rendered_rows, total_rows) = self.renderer.table_render_stats();
 1451|      0|                        let row_info = if total_rows > 0 {
 1452|      0|                            format!("
 1453|      0|Rows rendered this frame: {} / {}", rendered_rows, total_rows)
 1454|       |                        } else {
 1455|      0|                            String::new()
 1456|       |                        };
 1457|      0|                        format!(
 1458|      0|                            "Table layout cache: {} hits / {} misses{}",
 1459|       |                            hits, misses, row_info
 1460|       |                        )
 1461|       |                    } else {
 1462|      0|                        "Legacy table renderer active. Toggle via View > Table Wrap Overhaul or CLI flag.".to_string()
 1463|       |                    };
 1464|      0|                    ui.label(wrap_label).on_hover_text(cache_tip);
 1465|      0|                });
 1466|      0|            });
 1467|      0|        });
 1468|      0|    }
 1469|       |    /// Handle drag-drop events from egui
 1470|      0|    fn handle_drag_drop_events(&mut self, ctx: &Context) {
 1471|      0|        ctx.input(|i| {
 1472|       |            // Check if files are being hovered
 1473|      0|            self.drag_hover = !i.raw.hovered_files.is_empty();
 1474|       |
 1475|       |            // Check if files were dropped
 1476|      0|            if !i.raw.dropped_files.is_empty() {
 1477|      0|                let paths: Vec<PathBuf> = i
 1478|      0|                    .raw
 1479|      0|                    .dropped_files
 1480|      0|                    .iter()
 1481|      0|                    .filter_map(|f| f.path.clone())
 1482|      0|                    .collect();
 1483|       |
 1484|      0|                self.handle_file_drop(paths);
 1485|      0|            }
 1486|      0|        });
 1487|      0|    }
 1488|       |
 1489|       |    /// Render drag-and-drop overlay when files are hovered
 1490|      0|    fn render_drag_overlay(&self, ctx: &Context) {
 1491|      0|        if !self.drag_hover {
 1492|      0|            return;
 1493|      0|        }
 1494|       |
 1495|       |        // Full-screen overlay
 1496|      0|        egui::Area::new(egui::Id::new("drag_overlay"))
 1497|      0|            .fixed_pos(egui::pos2(0.0, 0.0))
 1498|      0|            .order(egui::Order::Foreground)
 1499|      0|            .show(ctx, |ui| {
 1500|      0|                let screen_rect = ctx.screen_rect();
 1501|       |
 1502|       |                // Semi-transparent dark background
 1503|      0|                ui.painter()
 1504|      0|                    .rect_filled(screen_rect, 0.0, egui::Color32::from_black_alpha(180));
 1505|       |
 1506|       |                // Dashed border effect using rounded rect with stroke
 1507|      0|                let border_rect = screen_rect.shrink(20.0);
 1508|      0|                let border_color = egui::Color32::from_rgb(100, 150, 255);
 1509|       |
 1510|       |                // Draw border
 1511|      0|                ui.painter()
 1512|      0|                    .rect_stroke(border_rect, 8.0, egui::Stroke::new(4.0, border_color));
 1513|       |
 1514|       |                // Center text
 1515|      0|                ui.allocate_ui_at_rect(screen_rect, |ui| {
 1516|      0|                    ui.vertical_centered(|ui| {
 1517|      0|                        ui.add_space(screen_rect.height() / 2.0 - 80.0);
 1518|       |
 1519|       |                        // Main message
 1520|      0|                        ui.label(
 1521|      0|                            RichText::new("Drop files to open")
 1522|      0|                                .size(36.0)
 1523|      0|                                .color(egui::Color32::WHITE)
 1524|      0|                                .strong(),
 1525|       |                        );
 1526|       |
 1527|      0|                        ui.add_space(20.0);
 1528|       |
 1529|       |                        // Supported formats
 1530|      0|                        ui.label(
 1531|      0|                            RichText::new("Supported: .md, .markdown, .mdown, .mkd, .txt")
 1532|      0|                                .size(18.0)
 1533|      0|                                .color(egui::Color32::LIGHT_GRAY),
 1534|       |                        );
 1535|       |
 1536|      0|                        ui.add_space(10.0);
 1537|       |
 1538|       |                        // Additional hint
 1539|      0|                        ui.label(
 1540|      0|                            RichText::new("Drop multiple files to open them in sequence")
 1541|      0|                                .size(14.0)
 1542|      0|                                .color(egui::Color32::from_rgb(150, 150, 150))
 1543|      0|                                .italics(),
 1544|       |                        );
 1545|      0|                    });
 1546|      0|                });
 1547|      0|            });
 1548|      0|    }
 1549|       |}
 1550|       |
 1551|       |impl eframe::App for MarkdownViewerApp {
 1552|       |    /// Update function called every frame
 1553|      0|    fn update(&mut self, ctx: &Context, _frame: &mut eframe::Frame) {
 1554|       |        // Handle drag-drop events
 1555|      0|        self.handle_drag_drop_events(ctx);
 1556|       |
 1557|       |        // Handle keyboard shortcuts
 1558|      0|        self.handle_shortcuts(ctx);
 1559|       |
 1560|       |        // Keep native window title in sync with the current document
 1561|      0|        ctx.send_viewport_cmd(egui::ViewportCommand::Title(self.title.clone()));
 1562|       |
 1563|      0|        let (monitor_size, outer_rect, inner_rect, is_fullscreen, is_maximized) = ctx.input(|i| {
 1564|      0|            let vp = i.viewport();
 1565|      0|            (
 1566|      0|                vp.monitor_size,
 1567|      0|                vp.outer_rect,
 1568|      0|                vp.inner_rect,
 1569|      0|                vp.fullscreen.unwrap_or(false),
 1570|      0|                vp.maximized.unwrap_or(false),
 1571|      0|            )
 1572|      0|        });
 1573|       |
 1574|      0|        let mut adjusted = false;
 1575|      0|        if !is_fullscreen {
 1576|      0|            if let Some((pos, size)) = Self::compute_window_adjustment(outer_rect, monitor_size) {
 1577|      0|                adjusted = true;
 1578|      0|                ctx.send_viewport_cmd(egui::ViewportCommand::OuterPosition(pos));
 1579|      0|                ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(size));
 1580|      0|                self.last_window_pos = Some([pos.x, pos.y]);
 1581|      0|                self.last_window_size = Some([size.x, size.y]);
 1582|      0|            }
 1583|      0|        }
 1584|       |
 1585|      0|        if !adjusted {
 1586|      0|            if let Some(outer) = outer_rect {
 1587|      0|                self.last_window_pos = Some([outer.left(), outer.top()]);
 1588|      0|            }
 1589|      0|            if !is_fullscreen {
 1590|      0|                if let Some(inner) = inner_rect {
 1591|      0|                    self.last_window_size = Some([inner.width(), inner.height()]);
 1592|      0|                }
 1593|      0|            }
 1594|      0|        }
 1595|      0|        self.last_window_maximized = is_maximized;
 1596|       |
 1597|       |        // Opportunistically persist window state if it changed, throttled to once per second
 1598|      0|        if self.should_persist_window_state() {
 1599|      0|            self.persist_window_state();
 1600|      0|            self.last_persist_instant = std::time::Instant::now();
 1601|      0|        }
 1602|       |
 1603|       |        // Handle fullscreen toggle outside input context to avoid deadlocks
 1604|      0|        if self.toggle_fullscreen {
 1605|      0|            self.toggle_fullscreen = false;
 1606|      0|            let current_fullscreen = ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
 1607|      0|            ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(!current_fullscreen));
 1608|      0|        }
 1609|       |
 1610|       |        // Handle deferred view toggle outside of input context
 1611|      0|        if self.view_toggle_requested {
 1612|      0|            self.view_toggle_requested = false;
 1613|      0|            self.toggle_view_mode(ctx);
 1614|      0|        }
 1615|       |
 1616|       |        // Handle deferred write toggle outside of input context
 1617|      0|        if self.write_toggle_requested {
 1618|      0|            self.write_toggle_requested = false;
 1619|      0|            self.toggle_write_mode(ctx);
 1620|      0|        }
 1621|       |
 1622|       |        // Handle deferred caret movement for raw editor
 1623|      0|        if let Some(delta) = self.pending_raw_cursor_line_move.take() {
 1624|      0|            self.move_raw_cursor_lines(ctx, delta);
 1625|      0|        }
 1626|       |
 1627|       |        // Handle reload request outside input context to avoid blocking within input handling
 1628|      0|        if self.reload_requested {
 1629|      0|            self.reload_requested = false;
 1630|      0|            if let Err(e) = self.reload_current_file() {
 1631|      0|                self.error_message = Some(format!("Failed to reload file: {}", e));
 1632|      0|            }
 1633|      0|        }
 1634|       |
 1635|       |        // Render menu bar
 1636|      0|        self.render_menu_bar(ctx);
 1637|       |
 1638|       |        // Main content area
 1639|      0|        let central_response = CentralPanel::default().show(ctx, |ui| {
 1640|       |            // Show error message if any
 1641|      0|            if let Some(ref error) = self.error_message {
 1642|      0|                ui.colored_label(Color32::RED, format!("Error: {}", error));
 1643|      0|                ui.separator();
 1644|      0|            }
 1645|       |
 1646|       |            // Render markdown content in a scrollable area
 1647|      0|            let scroll_delta = if let Some(nav) = self.nav_request.take() {
 1648|      0|                match nav {
 1649|       |                    NavigationRequest::Top => {
 1650|       |                        // Scroll to top: use a large POSITIVE delta to reach the beginning
 1651|      0|                        egui::Vec2::new(0.0, 100000.0)
 1652|       |                    }
 1653|       |                    NavigationRequest::Bottom => {
 1654|       |                        // Scroll to bottom: use a large NEGATIVE delta to reach the end
 1655|      0|                        egui::Vec2::new(0.0, -100000.0)
 1656|       |                    }
 1657|       |                    NavigationRequest::PageUp => {
 1658|      0|                        let viewport_height = ui.available_height();
 1659|      0|                        let page_size = viewport_height * 0.8;
 1660|      0|                        egui::Vec2::new(0.0, page_size) // Positive = scroll up (show earlier content)
 1661|       |                    }
 1662|       |                    NavigationRequest::PageDown => {
 1663|      0|                        let viewport_height = ui.available_height();
 1664|      0|                        let page_size = viewport_height * 0.8;
 1665|      0|                        egui::Vec2::new(0.0, -page_size) // Negative = scroll down (show later content)
 1666|       |                    }
 1667|       |                    NavigationRequest::ScrollUp => {
 1668|      0|                        egui::Vec2::new(0.0, 40.0) // Positive = fine scroll up
 1669|       |                    }
 1670|       |                    NavigationRequest::ScrollDown => {
 1671|      0|                        egui::Vec2::new(0.0, -40.0) // Negative = fine scroll down
 1672|       |                    }
 1673|       |                }
 1674|       |            } else {
 1675|      0|                egui::Vec2::ZERO
 1676|       |            };
 1677|       |
 1678|      0|            egui::ScrollArea::vertical()
 1679|      0|                .id_source(self.scroll_area_id)
 1680|      0|                .auto_shrink([false, false])
 1681|      0|                .scroll_bar_visibility(egui::scroll_area::ScrollBarVisibility::VisibleWhenNeeded)
 1682|      0|                .show(ui, |ui| {
 1683|       |                    // Apply scroll delta if we have navigation
 1684|      0|                    if scroll_delta != egui::Vec2::ZERO {
 1685|      0|                        ui.scroll_with_delta(scroll_delta);
 1686|      0|                    }
 1687|       |
 1688|      0|                    ui.spacing_mut().item_spacing.y = 8.0;
 1689|       |
 1690|      0|                    if self.parsed_elements.is_empty() && self.error_message.is_none() {
 1691|      0|                        ui.vertical_centered(|ui| {
 1692|      0|                            ui.add_space(50.0);
 1693|      0|                            ui.label(RichText::new("Welcome to MarkdownView").size(24.0).strong());
 1694|      0|                            ui.add_space(20.0);
 1695|      0|                            ui.label("Open a markdown file or select a sample to get started.");
 1696|      0|                            ui.add_space(20.0);
 1697|       |
 1698|      0|                            if ui.button("Open File").clicked() {
 1699|      0|                                self.open_file_dialog();
 1700|      0|                            }
 1701|      0|                        });
 1702|       |                    } else {
 1703|      0|                        match self.view_mode {
 1704|       |                            ViewMode::Rendered => {
 1705|       |                                // Update highlight phrase: prefer live input, else last executed
 1706|      0|                                if self.show_search && !self.search_query.is_empty() {
 1707|      0|                                    self.renderer.set_highlight_phrase(Some(&self.search_query));
 1708|      0|                                } else if !self.last_query.is_empty() {
 1709|      0|                                    self.renderer.set_highlight_phrase(Some(&self.last_query));
 1710|      0|                                } else {
 1711|      0|                                    self.renderer.set_highlight_phrase(None);
 1712|      0|                                }
 1713|       |
 1714|      0|                                self.renderer.render_to_ui(ui, &self.parsed_elements);
 1715|       |                                // If a header anchor was clicked, scroll to it
 1716|      0|                                if let Some(anchor) = self.renderer.take_pending_anchor() {
 1717|      0|                                    if let Some(rect) = self.renderer.header_rect_for(&anchor) {
 1718|      0|                                        // Align target header to the top of the visible area
 1719|      0|                                        ui.scroll_to_rect(rect, Some(egui::Align::Min));
 1720|      0|                                    }
 1721|      0|                                }
 1722|       |                                // If a search requested a scroll, align to top of visible area
 1723|      0|                                if let Some(idx) = self.pending_scroll_to_element.take() {
 1724|      0|                                    if let Some(rect) = self.renderer.element_rect_at(idx) {
 1725|      0|                                        ui.scroll_to_rect(rect, Some(egui::Align::Min));
 1726|      0|                                    }
 1727|      0|                                }
 1728|       |                            }
 1729|       |                            ViewMode::Raw => {
 1730|       |                                // Raw markdown view; editable when write mode is enabled
 1731|      0|                                if self.write_enabled {
 1732|      0|                                    let editor_id = egui::Id::new("raw_editor");
 1733|       |                                    // If we have a remembered cursor, restore it (clamped)
 1734|      0|                                    if let Some(mut idx) = self.raw_cursor.take() {
 1735|      0|                                        idx = idx.min(self.raw_buffer.len());
 1736|      0|                                        if let Some(mut state) =
 1737|      0|                                            egui::text_edit::TextEditState::load(
 1738|      0|                                                ui.ctx(),
 1739|      0|                                                editor_id,
 1740|      0|                                            )
 1741|      0|                                        {
 1742|      0|                                            let cr = egui::text::CCursorRange::one(
 1743|      0|                                                egui::text::CCursor::new(idx),
 1744|      0|                                            );
 1745|      0|                                            state.cursor.set_char_range(Some(cr));
 1746|      0|                                            state.store(ui.ctx(), editor_id);
 1747|      0|                                        } else {
 1748|      0|                                            let mut state =
 1749|      0|                                                egui::text_edit::TextEditState::default();
 1750|      0|                                            let cr = egui::text::CCursorRange::one(
 1751|      0|                                                egui::text::CCursor::new(idx),
 1752|      0|                                            );
 1753|      0|                                            state.cursor.set_char_range(Some(cr));
 1754|      0|                                            state.store(ui.ctx(), editor_id);
 1755|      0|                                        }
 1756|      0|                                    }
 1757|      0|                                    let before = self.raw_buffer.clone();
 1758|      0|                                    let resp = ui.add(
 1759|      0|                                        TextEdit::multiline(&mut self.raw_buffer)
 1760|      0|                                            .font(TextStyle::Monospace)
 1761|      0|                                            .code_editor()
 1762|      0|                                            .lock_focus(false)
 1763|      0|                                            .interactive(true)
 1764|      0|                                            .desired_width(f32::INFINITY)
 1765|      0|                                            .desired_rows(24)
 1766|      0|                                            .id_source(editor_id),
 1767|       |                                    );
 1768|      0|                                    if self.raw_focus_requested {
 1769|      0|                                        resp.request_focus();
 1770|      0|                                        self.raw_focus_requested = false;
 1771|      0|                                    }
 1772|       |                                    // Remember cursor position for next time
 1773|      0|                                    if let Some(state) =
 1774|      0|                                        egui::text_edit::TextEditState::load(ui.ctx(), editor_id)
 1775|       |                                    {
 1776|      0|                                        if let Some(range) = state.cursor.char_range() {
 1777|      0|                                            let idx = range.primary.index;
 1778|      0|                                            self.raw_cursor = Some(idx);
 1779|      0|                                        }
 1780|      0|                                    }
 1781|      0|                                    if self.raw_buffer != before {
 1782|      0|                                        self.current_content = self.raw_buffer.clone();
 1783|      0|                                        match self.renderer.parse(&self.current_content) {
 1784|      0|                                            Ok(elements) => {
 1785|      0|                                                self.parsed_elements = elements;
 1786|      0|                                                self.error_message = None;
 1787|      0|                                            }
 1788|      0|                                            Err(e) => {
 1789|      0|                                                self.error_message = Some(format!(
 1790|      0|                                                    "Failed to parse markdown: {}",
 1791|      0|                                                    e
 1792|      0|                                                ));
 1793|      0|                                            }
 1794|       |                                        }
 1795|      0|                                    }
 1796|      0|                                } else {
 1797|      0|                                    // Read-only
 1798|      0|                                    let mut tmp = self.raw_buffer.clone();
 1799|      0|                                    ui.add(
 1800|      0|                                        TextEdit::multiline(&mut tmp)
 1801|      0|                                            .font(TextStyle::Monospace)
 1802|      0|                                            .code_editor()
 1803|      0|                                            .lock_focus(false)
 1804|      0|                                            .interactive(false)
 1805|      0|                                            .desired_width(f32::INFINITY)
 1806|      0|                                            .desired_rows(24),
 1807|      0|                                    );
 1808|      0|                                }
 1809|       |                            }
 1810|       |                        }
 1811|       |                    }
 1812|      0|                });
 1813|      0|        });
 1814|       |
 1815|       |        // Add context menu for the main panel
 1816|      0|        central_response.response.context_menu(|ui| {
 1817|      0|            ui.label("Select text, then use Ctrl+C to copy");
 1818|      0|            ui.separator();
 1819|       |
 1820|       |            // Copy All Text option
 1821|      0|            if ui.button("Copy All Text").clicked() {
 1822|      0|                let all_text = MarkdownRenderer::elements_to_plain_text(&self.parsed_elements);
 1823|      0|                ui.ctx().copy_text(all_text);
 1824|      0|                ui.close_menu();
 1825|      0|            }
 1826|       |
 1827|       |            // Copy as Markdown (Raw) option
 1828|      0|            if ui.button("Copy as Markdown").clicked() {
 1829|      0|                ui.ctx().copy_text(self.current_content.clone());
 1830|      0|                ui.close_menu();
 1831|      0|            }
 1832|       |
 1833|      0|            ui.separator();
 1834|       |
 1835|       |            // Navigation shortcuts
 1836|      0|            if ui.button("Go to Top").clicked() {
 1837|      0|                self.nav_request = Some(NavigationRequest::Top);
 1838|      0|                ui.close_menu();
 1839|      0|            }
 1840|       |
 1841|      0|            if ui.button("Go to Bottom").clicked() {
 1842|      0|                self.nav_request = Some(NavigationRequest::Bottom);
 1843|      0|                ui.close_menu();
 1844|      0|            }
 1845|      0|        });
 1846|       |
 1847|       |        // Render floating search dialog (non-modal, always on top)
 1848|      0|        self.render_search_dialog(ctx);
 1849|       |
 1850|       |        // Render status bar
 1851|      0|        self.render_status_bar(ctx);
 1852|       |
 1853|       |        // Render drag-and-drop overlay (must be last to appear on top)
 1854|      0|        self.render_drag_overlay(ctx);
 1855|      0|    }
 1856|       |
 1857|      0|    fn auto_save_interval(&self) -> std::time::Duration {
 1858|      0|        std::time::Duration::from_secs(30)
 1859|      0|    }
 1860|       |
 1861|      0|    fn save(&mut self, _storage: &mut dyn eframe::Storage) {
 1862|       |        // Persist window position and size on app save/exit
 1863|      0|        self.persist_window_state();
 1864|      0|    }
 1865|       |}
 1866|       |
 1867|       |impl MarkdownViewerApp {
 1868|       |    // Build a rich-text label with only the mnemonic character underlined (visual cue only).
 1869|      0|    fn menu_text_with_mnemonic(
 1870|      0|        prefix: Option<&str>,
 1871|      0|        label: &str,
 1872|      0|        mnemonic: char,
 1873|      0|        underline: bool,
 1874|      0|        text_color: Color32,
 1875|      0|    ) -> LayoutJob {
 1876|      0|        let mut job = LayoutJob::default();
 1877|      0|        let default_fmt = TextFormat {
 1878|      0|            color: text_color,
 1879|      0|            ..TextFormat::default()
 1880|      0|        };
 1881|      0|        if let Some(p) = prefix {
 1882|      0|            job.append(p, 0.0, default_fmt.clone());
 1883|      0|        }
 1884|      0|        let m = mnemonic.to_ascii_lowercase();
 1885|      0|        let mut applied = false;
 1886|      0|        for c in label.chars() {
 1887|      0|            let mut fmt = default_fmt.clone();
 1888|      0|            if underline && !applied && c.to_ascii_lowercase() == m {
 1889|      0|                // Use a subtle underline color; white works well on dark theme
 1890|      0|                fmt.underline = egui::Stroke::new(1.0, text_color);
 1891|      0|                applied = true;
 1892|      0|            }
 1893|      0|            let s = c.to_string();
 1894|      0|            job.append(&s, 0.0, fmt);
 1895|       |        }
 1896|      0|        job
 1897|      0|    }
 1898|      0|    fn persist_window_state(&mut self) {
 1899|      0|        if let Some(state) = self.current_window_state() {
 1900|      0|            if !self.window_state_changed(&state) {
 1901|      0|                return;
 1902|      0|            }
 1903|      0|            if crate::save_window_state(&state).is_ok() {
 1904|      0|                self.last_persist_instant = std::time::Instant::now();
 1905|      0|                self.last_persisted_state = Some(state);
 1906|      0|            }
 1907|      0|        }
 1908|      0|    }
 1909|       |
 1910|      0|    fn should_persist_window_state(&self) -> bool {
 1911|      0|        if self.last_persist_instant.elapsed() < std::time::Duration::from_secs(1) {
 1912|      0|            return false;
 1913|      0|        }
 1914|      0|        if let Some(state) = self.current_window_state() {
 1915|      0|            self.window_state_changed(&state)
 1916|       |        } else {
 1917|      0|            false
 1918|       |        }
 1919|      0|    }
 1920|       |
 1921|       |    /// Save current document. If no file is associated, prompts for a path.
 1922|      0|    fn save_current_document(&mut self) -> Result<()> {
 1923|      0|        if let Some(path) = self.current_file.clone() {
 1924|      0|            std::fs::write(&path, &self.current_content)?;
 1925|      0|            let parent = path.parent();
 1926|      0|            self.renderer.set_base_dir(parent);
 1927|      0|            Ok(())
 1928|      0|        } else if let Some(path) = FileDialog::new()
 1929|      0|            .set_title("Save Markdown File")
 1930|      0|            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
 1931|      0|            .save_file()
 1932|       |        {
 1933|      0|            std::fs::write(&path, &self.current_content)?;
 1934|      0|            let filename = path
 1935|      0|                .file_name()
 1936|      0|                .and_then(|n| n.to_str())
 1937|      0|                .unwrap_or("Unknown")
 1938|      0|                .to_string();
 1939|      0|            self.current_file = Some(path);
 1940|      0|            if let Some(parent) = self.current_file.as_ref().and_then(|p| p.parent()) {
 1941|      0|                self.renderer.set_base_dir(Some(parent));
 1942|      0|            } else {
 1943|      0|                self.renderer.set_base_dir(None);
 1944|      0|            }
 1945|      0|            self.title = format!("{APP_TITLE_PREFIX} - {}", filename);
 1946|      0|            Ok(())
 1947|       |        } else {
 1948|      0|            Ok(())
 1949|       |        }
 1950|      0|    }
 1951|       |
 1952|       |    /// Render the floating non-modal search dialog
 1953|      0|    fn render_search_dialog(&mut self, ctx: &Context) {
 1954|      0|        if !self.show_search {
 1955|      0|            return;
 1956|      0|        }
 1957|      0|        let prev_open = self.show_search;
 1958|      0|        let mut open = self.show_search;
 1959|      0|        let prev_query = self.search_query.clone();
 1960|      0|        egui::Window::new("Find")
 1961|      0|            .collapsible(false)
 1962|      0|            .resizable(false)
 1963|      0|            .default_pos(egui::pos2(80.0, 80.0))
 1964|      0|            .open(&mut open)
 1965|      0|            .show(ctx, |ui| {
 1966|      0|                let mut submitted_next = false;
 1967|      0|                ui.horizontal(|ui| {
 1968|      0|                    let text_edit = egui::TextEdit::singleline(&mut self.search_query)
 1969|      0|                        .hint_text("Search text...")
 1970|      0|                        .desired_width(240.0);
 1971|      0|                    let resp = ui.add(text_edit);
 1972|      0|                    if self.search_focus_requested {
 1973|      0|                        resp.request_focus();
 1974|      0|                        self.search_focus_requested = false;
 1975|      0|                    }
 1976|      0|                    if resp.lost_focus() && ui.input(|i| i.key_pressed(egui::Key::Enter)) {
 1977|      0|                        submitted_next = true;
 1978|      0|                    }
 1979|      0|                    if ui.button("Next (F3)").clicked() || submitted_next {
 1980|      0|                        self.find_next();
 1981|      0|                    }
 1982|      0|                    if ui.button("Prev (Shift+F3)").clicked() {
 1983|      0|                        self.find_previous();
 1984|      0|                    }
 1985|      0|                });
 1986|      0|            });
 1987|       |        // Dynamic search: scroll to first match from anchor whenever the input changes
 1988|      0|        if self.search_query != prev_query {
 1989|      0|            if self.search_query.is_empty() {
 1990|      0|                self.last_query.clear();
 1991|      0|                self.renderer.set_highlight_phrase(None);
 1992|      0|            } else {
 1993|      0|                self.last_query = self.search_query.clone();
 1994|       |                // Use current last match as baseline if set, else start of doc
 1995|      0|                let baseline = self.last_match_index.unwrap_or(0);
 1996|      0|                let needle = Self::fold_for_search(&self.search_query);
 1997|      0|                let total = self.parsed_elements.len();
 1998|      0|                let mut found: Option<usize> = None;
 1999|      0|                for pass in 0..2 {
 2000|      0|                    let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
 2001|      0|                        Box::new(baseline..total)
 2002|       |                    } else {
 2003|      0|                        Box::new(0..baseline.min(total))
 2004|       |                    };
 2005|      0|                    for idx in range {
 2006|      0|                        let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
 2007|      0|                            &self.parsed_elements[idx],
 2008|       |                        );
 2009|      0|                        if Self::fold_for_search(&text).contains(&needle) {
 2010|      0|                            found = Some(idx);
 2011|      0|                            break;
 2012|      0|                        }
 2013|       |                    }
 2014|      0|                    if found.is_some() {
 2015|      0|                        break;
 2016|      0|                    }
 2017|       |                }
 2018|      0|                if let Some(idx) = found {
 2019|      0|                    self.last_match_index = Some(idx);
 2020|      0|                    self.pending_scroll_to_element = Some(idx);
 2021|      0|                }
 2022|       |            }
 2023|      0|        }
 2024|       |        // If dialog closed via close button, clear before hiding
 2025|      0|        if prev_open && !open {
 2026|      0|            self.clear_search_state();
 2027|      0|        }
 2028|      0|        self.show_search = open;
 2029|      0|    }
 2030|       |
 2031|       |    // No overlay menu helpers; we only render egui's built-in menus.
 2032|       |}
 2033|       |
 2034|       |impl Default for MarkdownViewerApp {
 2035|      1|    fn default() -> Self {
 2036|      1|        Self::new()
 2037|      1|    }
 2038|       |}
 2039|       |
 2040|       |#[cfg(test)]
 2041|       |mod tests {
 2042|       |    use super::*;
 2043|       |    use std::io::Write;
 2044|       |    use tempfile::NamedTempFile;
 2045|       |
 2046|       |    #[test]
 2047|      1|    fn test_normalize_line_endings() {
 2048|       |        // Windows style (\r\n)
 2049|      1|        assert_eq!(
 2050|      1|            MarkdownViewerApp::normalize_line_endings("Hello\r\nWorld"),
 2051|       |            "Hello\nWorld"
 2052|       |        );
 2053|       |
 2054|       |        // Unix style (\n) - no change
 2055|      1|        assert_eq!(
 2056|      1|            MarkdownViewerApp::normalize_line_endings("Hello\nWorld"),
 2057|       |            "Hello\nWorld"
 2058|       |        );
 2059|       |
 2060|       |        // Old Mac style (\r)
 2061|      1|        assert_eq!(
 2062|      1|            MarkdownViewerApp::normalize_line_endings("Hello\rWorld"),
 2063|       |            "Hello\nWorld"
 2064|       |        );
 2065|       |
 2066|       |        // Mixed line endings
 2067|      1|        assert_eq!(
 2068|      1|            MarkdownViewerApp::normalize_line_endings("A\r\nB\nC\rD"),
 2069|       |            "A\nB\nC\nD"
 2070|       |        );
 2071|       |
 2072|       |        // Multiple blank lines with Windows endings
 2073|      1|        assert_eq!(
 2074|      1|            MarkdownViewerApp::normalize_line_endings("A\r\n\r\nB"),
 2075|       |            "A\n\nB"
 2076|       |        );
 2077|       |
 2078|       |        // Empty string
 2079|      1|        assert_eq!(MarkdownViewerApp::normalize_line_endings(""), "");
 2080|       |
 2081|       |        // No line endings
 2082|      1|        assert_eq!(
 2083|      1|            MarkdownViewerApp::normalize_line_endings("Single line"),
 2084|       |            "Single line"
 2085|       |        );
 2086|      1|    }
 2087|       |
 2088|       |    #[test]
 2089|      1|    fn test_load_file_with_windows_line_endings() -> Result<()> {
 2090|      1|        let mut app = MarkdownViewerApp::new();
 2091|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2092|       |
 2093|       |        // Write content with explicit Windows line endings
 2094|      1|        temp_file.write_all(b"Line 1\r\nLine 2\r\n\r\nParagraph text")?;
                                                                                    ^0
 2095|      1|        temp_file.flush()?;
                                       ^0
 2096|       |
 2097|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 2098|       |
 2099|       |        // Should not contain any \r characters after normalization
 2100|      1|        assert!(!app.current_content.contains('\r'));
 2101|      1|        assert!(app.current_content.contains("Line 1\nLine 2"));
 2102|      1|        assert!(app.current_content.contains("\n\nParagraph"));
 2103|      1|        Ok(())
 2104|      1|    }
 2105|       |
 2106|       |    #[test]
 2107|      1|    fn test_load_file_with_mixed_line_endings() -> Result<()> {
 2108|      1|        let mut app = MarkdownViewerApp::new();
 2109|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2110|       |
 2111|       |        // Mix of \r\n (Windows), \n (Unix), and \r (old Mac)
 2112|      1|        temp_file.write_all(b"Line 1\r\nLine 2\nLine 3\rLine 4")?;
                                                                              ^0
 2113|      1|        temp_file.flush()?;
                                       ^0
 2114|       |
 2115|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 2116|       |
 2117|       |        // All should be normalized to \n
 2118|      1|        assert!(!app.current_content.contains('\r'));
 2119|      1|        assert_eq!(app.current_content.lines().count(), 4);
 2120|      1|        let lines: Vec<&str> = app.current_content.lines().collect();
 2121|      1|        assert_eq!(lines[0], "Line 1");
 2122|      1|        assert_eq!(lines[1], "Line 2");
 2123|      1|        assert_eq!(lines[2], "Line 3");
 2124|      1|        assert_eq!(lines[3], "Line 4");
 2125|      1|        Ok(())
 2126|      1|    }
 2127|       |
 2128|       |    #[test]
 2129|      1|    fn test_app_creation() {
 2130|      1|        let app = MarkdownViewerApp::new();
 2131|      1|        assert!(!app.parsed_elements.is_empty()); // Should load welcome content
 2132|      1|        assert!(app.title.contains(APP_TITLE_PREFIX));
 2133|      1|        assert!(app.error_message.is_none());
 2134|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 2135|      1|    }
 2136|       |
 2137|       |    #[test]
 2138|      1|    fn test_load_content() {
 2139|      1|        let mut app = MarkdownViewerApp::new();
 2140|      1|        let content = "# Test Header\n\nThis is test content.";
 2141|       |
 2142|      1|        app.load_content(content, Some("Test".to_string()));
 2143|       |
 2144|      1|        assert_eq!(app.current_content, content);
 2145|      1|        assert_eq!(app.raw_buffer, content);
 2146|      1|        assert!(app.title.contains("Test"));
 2147|      1|        assert!(!app.parsed_elements.is_empty());
 2148|      1|        assert!(app.error_message.is_none());
 2149|      1|    }
 2150|       |
 2151|       |    #[test]
 2152|      1|    fn test_toggle_view_mode() {
 2153|      1|        let mut app = MarkdownViewerApp::new();
 2154|      1|        let ctx = egui::Context::default();
 2155|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 2156|      1|        app.toggle_view_mode(&ctx);
 2157|      1|        assert!(matches!(app.view_mode, ViewMode::Raw));
                              ^0
 2158|      1|        app.toggle_view_mode(&ctx);
 2159|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 2160|      1|    }
 2161|       |
 2162|       |    #[test]
 2163|      1|    fn test_load_sample() {
 2164|      1|        let mut app = MarkdownViewerApp::new();
 2165|      1|        let sample = &SAMPLE_FILES[0]; // First sample file
 2166|       |
 2167|      1|        app.load_sample(sample);
 2168|       |
 2169|      1|        assert_eq!(app.current_content, sample.content);
 2170|      1|        assert!(app.title.contains(sample.title));
 2171|      1|        assert!(!app.parsed_elements.is_empty());
 2172|      1|        assert!(app.current_file.is_none()); // Sample files don't set file path
 2173|      1|    }
 2174|       |
 2175|       |    #[test]
 2176|      1|    fn test_load_file() -> Result<()> {
 2177|      1|        let mut app = MarkdownViewerApp::new();
 2178|       |
 2179|       |        // Create a temporary markdown file
 2180|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2181|      1|        let content = "# Temporary File\n\nThis is a test markdown file.";
 2182|      1|        temp_file.write_all(content.as_bytes())?;
                                                             ^0
 2183|      1|        temp_file.flush()?;
                                       ^0
 2184|       |
 2185|      1|        let path = temp_file.path().to_path_buf();
 2186|      1|        app.load_file(path.clone(), true)?;
                                                       ^0
 2187|       |
 2188|      1|        assert_eq!(app.current_content, content);
 2189|      1|        assert_eq!(app.current_file, Some(path));
 2190|      1|        assert!(!app.parsed_elements.is_empty());
 2191|      1|        assert!(app.error_message.is_none());
 2192|       |
 2193|      1|        Ok(())
 2194|      1|    }
 2195|       |
 2196|       |    #[test]
 2197|      1|    fn test_load_invalid_markdown() {
 2198|      1|        let mut app = MarkdownViewerApp::new();
 2199|       |        // Even "invalid" markdown should parse successfully with pulldown-cmark
 2200|       |        // as it's very permissive
 2201|      1|        let content = "This is just plain text with some <invalid> HTML tags";
 2202|       |
 2203|      1|        app.load_content(content, Some("Invalid".to_string()));
 2204|       |
 2205|       |        // Should still work - pulldown-cmark is very permissive
 2206|      1|        assert_eq!(app.current_content, content);
 2207|      1|        assert!(app.error_message.is_none() || app.error_message.is_some()); // Either is ok
                                                             ^0                ^0
 2208|      1|    }
 2209|       |
 2210|       |    #[test]
 2211|      1|    fn test_load_empty_content() {
 2212|      1|        let mut app = MarkdownViewerApp::new();
 2213|      1|        app.load_content("", Some("Empty".to_string()));
 2214|       |
 2215|      1|        assert_eq!(app.current_content, "");
 2216|      1|        assert!(app.title.contains("Empty"));
 2217|      1|        assert!(app.error_message.is_none());
 2218|      1|    }
 2219|       |
 2220|       |    #[test]
 2221|      1|    fn test_load_nonexistent_file() {
 2222|      1|        let mut app = MarkdownViewerApp::new();
 2223|      1|        let fake_path = PathBuf::from("/nonexistent/file.md");
 2224|       |
 2225|      1|        let result = app.load_file(fake_path, true);
 2226|      1|        assert!(result.is_err());
 2227|      1|    }
 2228|       |
 2229|       |    #[test]
 2230|      1|    fn test_reload_current_file() -> Result<()> {
 2231|      1|        let mut app = MarkdownViewerApp::new();
 2232|       |
 2233|       |        // Create a temporary markdown file
 2234|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2235|      1|        let content1 = "# Title\n\nVersion 1";
 2236|      1|        temp_file.write_all(content1.as_bytes())?;
                                                              ^0
 2237|      1|        temp_file.flush()?;
                                       ^0
 2238|       |
 2239|      1|        let path = temp_file.path().to_path_buf();
 2240|      1|        app.load_file(path.clone(), true)?;
                                                       ^0
 2241|      1|        assert!(app.current_content.contains("Version 1"));
 2242|       |
 2243|       |        // Update file content
 2244|      1|        let content2 = "# Title\n\nVersion 2";
 2245|      1|        temp_file.as_file_mut().set_len(0)?; // clear
                                                        ^0
 2246|      1|        temp_file.write_all(content2.as_bytes())?;
                                                              ^0
 2247|      1|        temp_file.flush()?;
                                       ^0
 2248|       |
 2249|       |        // Reload and verify
 2250|      1|        app.reload_current_file()?;
                                               ^0
 2251|      1|        assert!(app.current_content.contains("Version 2"));
 2252|      1|        Ok(())
 2253|      1|    }
 2254|       |
 2255|       |    #[test]
 2256|      1|    fn test_load_file_with_invalid_utf8() -> Result<()> {
 2257|      1|        let mut app = MarkdownViewerApp::new();
 2258|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2259|      1|        let bytes = b"Hello\xFFWorld";
 2260|      1|        temp_file.write_all(bytes)?;
                                                ^0
 2261|      1|        temp_file.flush()?;
                                       ^0
 2262|       |
 2263|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 2264|       |
 2265|      1|        assert!(app.current_content.contains('\u{FFFD}'));
 2266|      1|        assert!(!app.parsed_elements.is_empty());
 2267|      1|        assert!(app.error_message.is_none());
 2268|      1|        Ok(())
 2269|      1|    }
 2270|       |
 2271|       |    #[test]
 2272|      1|    fn test_reload_without_file() {
 2273|      1|        let mut app = MarkdownViewerApp::new();
 2274|      1|        assert!(app.current_file.is_none());
 2275|      1|        let result = app.reload_current_file();
 2276|      1|        assert!(result.is_err());
 2277|      1|    }
 2278|       |
 2279|       |    #[test]
 2280|      1|    fn test_window_state_change_detection() {
 2281|      1|        let mut app = MarkdownViewerApp::new();
 2282|      1|        app.last_window_pos = Some([10.0, 10.0]);
 2283|      1|        app.last_window_size = Some([800.0, 600.0]);
 2284|      1|        app.last_window_maximized = false;
 2285|       |
 2286|      1|        let state = app.current_window_state().expect("state");
 2287|      1|        assert!(app.window_state_changed(&state));
 2288|      1|        app.last_persisted_state = Some(state);
 2289|      1|        assert!(!app.window_state_changed(&state));
 2290|       |
 2291|      1|        let mut moved = state;
 2292|      1|        moved.pos = [12.0, 10.0];
 2293|      1|        assert!(app.window_state_changed(&moved));
 2294|      1|    }
 2295|       |
 2296|       |    #[test]
 2297|      1|    fn test_fold_for_search_handles_case_and_accents() {
 2298|      1|        assert_eq!(
 2299|      1|            MarkdownViewerApp::fold_for_search("\u{00C4}\u{00DF}"),
 2300|      1|            MarkdownViewerApp::fold_for_search("\u{00E4}SS")
 2301|       |        );
 2302|      1|        assert_eq!(
 2303|      1|            MarkdownViewerApp::fold_for_search("To\u{0301}m"),
 2304|      1|            MarkdownViewerApp::fold_for_search("T\u{00D3}m")
 2305|       |        );
 2306|      1|    }
 2307|       |
 2308|       |    #[test]
 2309|      1|    fn test_title_updates() {
 2310|      1|        let mut app = MarkdownViewerApp::new();
 2311|       |
 2312|       |        // Test with custom title
 2313|      1|        app.load_content("# Test", Some("Custom Title".to_string()));
 2314|      1|        assert!(app.title.contains("Custom Title"));
 2315|       |
 2316|       |        // Test with no title (should keep existing)
 2317|      1|        let old_title = app.title.clone();
 2318|      1|        app.load_content("# Another Test", None);
 2319|      1|        assert_eq!(app.title, old_title); // Should remain unchanged
 2320|      1|    }
 2321|       |
 2322|       |    #[test]
 2323|      1|    fn test_complex_markdown_loading() {
 2324|      1|        let mut app = MarkdownViewerApp::new();
 2325|      1|        let complex_content = r#"# Complex Document
 2326|      1|
 2327|      1|## With Multiple Sections
 2328|      1|
 2329|      1|This has **bold** and *italic* text.
 2330|      1|
 2331|      1|```rust
 2332|      1|fn main() {
 2333|      1|    println!("Hello, world!");
 2334|      1|}
 2335|      1|```
 2336|      1|
 2337|      1|- List item 1
 2338|      1|- List item 2
 2339|      1|
 2340|      1|> A blockquote
 2341|      1|
 2342|      1|[A link](https://example.com)
 2343|      1|
 2344|      1|---
 2345|      1|
 2346|      1|The end.
 2347|      1|"#;
 2348|       |
 2349|      1|        app.load_content(complex_content, Some("Complex".to_string()));
 2350|       |
 2351|      1|        assert_eq!(app.current_content, complex_content);
 2352|      1|        assert!(app.title.contains("Complex"));
 2353|      1|        assert!(!app.parsed_elements.is_empty());
 2354|      1|        assert!(app.error_message.is_none());
 2355|       |
 2356|       |        // Should have parsed various element types
 2357|      1|        assert!(app.parsed_elements.len() > 5); // Complex document should have many elements
 2358|      1|    }
 2359|       |
 2360|       |    #[test]
 2361|      1|    fn test_error_handling() {
 2362|      1|        let app = MarkdownViewerApp::new();
 2363|       |
 2364|       |        // Test that app starts without errors
 2365|      1|        assert!(app.error_message.is_none());
 2366|       |
 2367|       |        // Even with the welcome content loaded, should be error-free
 2368|      1|        assert!(!app.parsed_elements.is_empty());
 2369|      1|    }
 2370|       |
 2371|       |    #[test]
 2372|      1|    fn test_default_state() {
 2373|      1|        let app = MarkdownViewerApp::default();
 2374|       |
 2375|       |        // Default should be same as new()
 2376|      1|        assert!(!app.parsed_elements.is_empty());
 2377|      1|        assert!(app.title.contains(APP_TITLE_PREFIX));
 2378|      1|        assert!(app.error_message.is_none());
 2379|      1|        assert!(app.current_file.is_none());
 2380|      1|    }
 2381|       |
 2382|       |    #[test]
 2383|      1|    fn test_sample_files_integration() {
 2384|      1|        let mut app = MarkdownViewerApp::new();
 2385|       |
 2386|       |        // Test loading each sample file
 2387|      7|        for sample in SAMPLE_FILES {
                          ^6
 2388|      6|            app.load_sample(sample);
 2389|       |
 2390|      6|            assert_eq!(app.current_content, sample.content);
 2391|      6|            assert!(app.title.contains(sample.title));
 2392|      6|            assert!(app.current_file.is_none());
 2393|      6|            assert!(app.error_message.is_none());
 2394|       |        }
 2395|      1|    }
 2396|       |
 2397|       |    #[test]
 2398|      1|    fn test_close_current_file() {
 2399|      1|        let mut app = MarkdownViewerApp::new();
 2400|       |
 2401|       |        // Load some content first
 2402|      1|        app.load_content("# Test Content", Some("Test File".to_string()));
 2403|      1|        assert!(app.title.contains("Test File"));
 2404|       |
 2405|       |        // Close the file
 2406|      1|        app.close_current_file();
 2407|       |
 2408|       |        // Should return to welcome screen
 2409|      1|        assert!(app.title.contains("Welcome"));
 2410|      1|        assert!(app.current_file.is_none());
 2411|      1|        assert!(!app.parsed_elements.is_empty()); // Should have welcome content
 2412|      1|        assert!(app.error_message.is_none());
 2413|      1|    }
 2414|       |
 2415|       |    #[test]
 2416|      1|    fn test_navigation_request_enum() {
 2417|       |        // Test that the enum values exist and are correct
 2418|      1|        let _top = NavigationRequest::Top;
 2419|      1|        let _bottom = NavigationRequest::Bottom;
 2420|      1|        let _page_up = NavigationRequest::PageUp;
 2421|      1|        let _page_down = NavigationRequest::PageDown;
 2422|      1|        let _scroll_up = NavigationRequest::ScrollUp;
 2423|      1|        let _scroll_down = NavigationRequest::ScrollDown;
 2424|       |
 2425|       |        // Ensure it's cloneable and debuggable
 2426|      1|        let nav = NavigationRequest::Top;
 2427|      1|        let _cloned = nav.clone();
 2428|      1|        let _debug = format!("{:?}", nav);
 2429|       |
 2430|       |        // Basic compilation test performed by using the enum and Debug/Clone
 2431|      1|    }
 2432|       |
 2433|       |    #[test]
 2434|      1|    fn test_navigation_state_initialization() {
 2435|      1|        let app = MarkdownViewerApp::new();
 2436|       |        // Test that nav_request is initialized to None
 2437|      1|        assert!(app.nav_request.is_none());
 2438|       |        // Test that fullscreen toggle flag is initialized to false
 2439|      1|        assert!(!app.toggle_fullscreen);
 2440|      1|    }
 2441|       |
 2442|       |    #[test]
 2443|      1|    fn test_fullscreen_toggle_flag() {
 2444|      1|        let mut app = MarkdownViewerApp::new();
 2445|       |
 2446|       |        // Initially should be false
 2447|      1|        assert!(!app.toggle_fullscreen);
 2448|       |
 2449|       |        // Simulate F11 key press (this would be set in handle_shortcuts)
 2450|      1|        app.toggle_fullscreen = true;
 2451|      1|        assert!(app.toggle_fullscreen);
 2452|       |
 2453|       |        // After handling, it should be reset to false
 2454|      1|        app.toggle_fullscreen = false;
 2455|      1|        assert!(!app.toggle_fullscreen);
 2456|      1|    }
 2457|       |
 2458|       |    #[test]
 2459|      1|    fn test_navigation_state_reset_on_load() {
 2460|      1|        let mut app = MarkdownViewerApp::new();
 2461|       |
 2462|       |        // Set a navigation request
 2463|      1|        app.nav_request = Some(NavigationRequest::Top);
 2464|      1|        assert!(app.nav_request.is_some());
 2465|       |
 2466|       |        // Load content should reset navigation state
 2467|      1|        app.load_content("# Test Content", Some("Test".to_string()));
 2468|      1|        assert!(app.nav_request.is_none());
 2469|      1|    }
 2470|       |
 2471|       |    #[test]
 2472|      1|    fn test_page_navigation_calculations() {
 2473|       |        // Test the page size calculation logic used in navigation
 2474|      1|        let viewport_height = 800.0f32;
 2475|      1|        let page_size = viewport_height * 0.8;
 2476|      1|        assert_eq!(page_size, 640.0);
 2477|       |
 2478|       |        // Test boundary conditions for Page Up
 2479|      1|        let current_offset = 100.0f32;
 2480|      1|        let new_offset_up = (current_offset - page_size).max(0.0);
 2481|      1|        assert_eq!(new_offset_up, 0.0); // Should clamp to 0
 2482|       |
 2483|       |        // Test Page Down calculation
 2484|      1|        let new_offset_down = current_offset + page_size;
 2485|      1|        assert_eq!(new_offset_down, 740.0);
 2486|       |
 2487|       |        // Test that Page Up from near top goes to 0
 2488|      1|        let near_top = 300.0f32;
 2489|      1|        let from_near_top = (near_top - page_size).max(0.0);
 2490|      1|        assert_eq!(from_near_top, 0.0);
 2491|      1|    }
 2492|       |
 2493|       |    #[test]
 2494|      1|    fn test_compute_window_adjustment_clamps_offscreen_window() {
 2495|      1|        let outer = egui::Rect::from_min_size(egui::pos2(1200.0, 900.0), egui::vec2(800.0, 600.0));
 2496|      1|        let monitor = egui::vec2(1024.0, 768.0);
 2497|      1|        let (pos, size) = MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(monitor))
 2498|      1|            .expect("should adjust window geometry");
 2499|      1|        assert!(pos.x <= monitor.x - size.x + 1.0);
 2500|      1|        assert!(pos.y <= monitor.y - size.y + 1.0);
 2501|      1|    }
 2502|       |
 2503|       |    #[test]
 2504|      1|    fn test_compute_window_adjustment_respects_min_size() {
 2505|      1|        let outer = egui::Rect::from_min_size(egui::pos2(-200.0, -100.0), egui::vec2(200.0, 100.0));
 2506|      1|        let monitor = egui::vec2(1920.0, 1080.0);
 2507|      1|        let (pos, size) = MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(monitor))
 2508|      1|            .expect("should enforce minimum window size");
 2509|      1|        assert!(size.x >= 600.0);
 2510|      1|        assert!(size.y >= 400.0);
 2511|      1|        assert!(pos.x >= 0.0);
 2512|      1|        assert!(pos.y >= 0.0);
 2513|      1|    }
 2514|       |
 2515|       |    #[test]
 2516|      1|    fn test_is_valid_markdown_file() {
 2517|      1|        let app = MarkdownViewerApp::new();
 2518|       |
 2519|       |        // Valid markdown extensions
 2520|      1|        assert!(app.is_valid_markdown_file(Path::new("test.md")));
 2521|      1|        assert!(app.is_valid_markdown_file(Path::new("test.markdown")));
 2522|      1|        assert!(app.is_valid_markdown_file(Path::new("test.mdown")));
 2523|      1|        assert!(app.is_valid_markdown_file(Path::new("test.mkd")));
 2524|      1|        assert!(app.is_valid_markdown_file(Path::new("test.txt")));
 2525|       |
 2526|       |        // Case insensitive
 2527|      1|        assert!(app.is_valid_markdown_file(Path::new("test.MD")));
 2528|      1|        assert!(app.is_valid_markdown_file(Path::new("test.Markdown")));
 2529|       |
 2530|       |        // Invalid extensions
 2531|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.pdf")));
 2532|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.docx")));
 2533|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.html")));
 2534|       |
 2535|       |        // No extension
 2536|      1|        assert!(!app.is_valid_markdown_file(Path::new("test")));
 2537|      1|    }
 2538|       |
 2539|       |    #[test]
 2540|      1|    fn test_scan_directory() -> Result<()> {
 2541|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2542|      1|        let dir_path = temp_dir.path();
 2543|       |
 2544|       |        // Create test files
 2545|      1|        std::fs::write(dir_path.join("zebra.md"), "# Z")?;
                                                                      ^0
 2546|      1|        std::fs::write(dir_path.join("alpha.md"), "# A")?;
                                                                      ^0
 2547|      1|        std::fs::write(dir_path.join("image.png"), "fake")?;
                                                                        ^0
 2548|      1|        std::fs::write(dir_path.join("beta.markdown"), "# B")?;
                                                                           ^0
 2549|       |
 2550|       |        // Create subdirectory (should be ignored)
 2551|      1|        std::fs::create_dir(dir_path.join("subdir"))?;
                                                                  ^0
 2552|      1|        std::fs::write(dir_path.join("subdir/nested.md"), "# N")?;
                                                                              ^0
 2553|       |
 2554|      1|        let app = MarkdownViewerApp::new();
 2555|      1|        let files = app.scan_directory(dir_path)?;
                                                              ^0
 2556|       |
 2557|       |        // Should find 3 markdown files (alpha, beta, zebra)
 2558|       |        // Should NOT find image.png or nested.md
 2559|      1|        assert_eq!(files.len(), 3);
 2560|       |
 2561|       |        // Should be sorted alphabetically
 2562|      1|        assert!(files[0].ends_with("alpha.md"));
 2563|      1|        assert!(files[1].ends_with("beta.markdown"));
 2564|      1|        assert!(files[2].ends_with("zebra.md"));
 2565|       |
 2566|      1|        Ok(())
 2567|      1|    }
 2568|       |
 2569|       |    #[test]
 2570|      1|    fn test_scan_empty_directory() -> Result<()> {
 2571|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2572|      1|        let app = MarkdownViewerApp::new();
 2573|      1|        let files = app.scan_directory(temp_dir.path())?;
                                                                     ^0
 2574|       |
 2575|      1|        assert_eq!(files.len(), 0);
 2576|      1|        Ok(())
 2577|      1|    }
 2578|       |
 2579|       |    #[test]
 2580|      1|    fn test_single_file_drop() -> Result<()> {
 2581|      1|        let mut app = MarkdownViewerApp::new();
 2582|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2583|      1|        let file = temp_dir.path().join("test.md");
 2584|      1|        std::fs::write(&file, "# Test")?;
                                                     ^0
 2585|       |
 2586|      1|        app.handle_file_drop(vec![file.clone()]);
 2587|       |
 2588|      1|        assert_eq!(app.current_file, Some(file));
 2589|      1|        assert!(app.pending_files.is_empty());
 2590|      1|        assert!(app.error_message.is_none());
 2591|      1|        Ok(())
 2592|      1|    }
 2593|       |
 2594|       |    #[test]
 2595|      1|    fn test_multiple_files_drop() -> Result<()> {
 2596|      1|        let mut app = MarkdownViewerApp::new();
 2597|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2598|       |
 2599|      1|        let files: Vec<PathBuf> = (0..5)
 2600|      5|            .map(|i| {
                           ^1
 2601|      5|                let path = temp_dir.path().join(format!("file{}.md", i));
 2602|      5|                std::fs::write(&path, format!("# File {}", i)).unwrap();
 2603|      5|                path
 2604|      5|            })
 2605|      1|            .collect();
 2606|       |
 2607|      1|        app.handle_file_drop(files.clone());
 2608|       |
 2609|      1|        assert_eq!(app.current_file, Some(files[0].clone()));
 2610|      1|        assert_eq!(app.pending_files.len(), 4);
 2611|      1|        Ok(())
 2612|      1|    }
 2613|       |
 2614|       |    #[test]
 2615|      1|    fn test_directory_drop() -> Result<()> {
 2616|      1|        let mut app = MarkdownViewerApp::new();
 2617|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2618|       |
 2619|       |        // Create files in directory
 2620|      1|        std::fs::write(temp_dir.path().join("a.md"), "# A")?;
                                                                         ^0
 2621|      1|        std::fs::write(temp_dir.path().join("b.md"), "# B")?;
                                                                         ^0
 2622|      1|        std::fs::write(temp_dir.path().join("c.md"), "# C")?;
                                                                         ^0
 2623|       |
 2624|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 2625|       |
 2626|      1|        assert!(app.current_file.is_some());
 2627|      1|        assert_eq!(app.pending_files.len(), 2);
 2628|      1|        Ok(())
 2629|      1|    }
 2630|       |
 2631|       |    #[test]
 2632|      1|    fn test_invalid_file_drop() {
 2633|      1|        let mut app = MarkdownViewerApp::new();
 2634|      1|        let temp_dir = tempfile::TempDir::new().unwrap();
 2635|      1|        let file = temp_dir.path().join("test.pdf");
 2636|      1|        std::fs::write(&file, "fake pdf").unwrap();
 2637|       |
 2638|      1|        app.handle_file_drop(vec![file]);
 2639|       |
 2640|       |        // Current file should remain None (or welcome sample)
 2641|      1|        assert!(app.error_message.is_some());
 2642|      1|        assert!(app
 2643|      1|            .error_message
 2644|      1|            .as_ref()
 2645|      1|            .unwrap()
 2646|      1|            .contains("Not a markdown file"));
 2647|      1|    }
 2648|       |
 2649|       |    #[test]
 2650|      1|    fn test_too_many_files() {
 2651|      1|        let mut app = MarkdownViewerApp::new();
 2652|      1|        let temp_dir = tempfile::TempDir::new().unwrap();
 2653|       |
 2654|      1|        let files: Vec<PathBuf> = (0..60)
 2655|     60|            .map(|i| {
                           ^1
 2656|     60|                let path = temp_dir.path().join(format!("file{}.md", i));
 2657|     60|                std::fs::write(&path, format!("# File {}", i)).unwrap();
 2658|     60|                path
 2659|     60|            })
 2660|      1|            .collect();
 2661|       |
 2662|      1|        app.handle_file_drop(files);
 2663|       |
 2664|      1|        assert!(app.error_message.is_some());
 2665|      1|        assert!(app
 2666|      1|            .error_message
 2667|      1|            .as_ref()
 2668|      1|            .unwrap()
 2669|      1|            .contains("Too many files"));
 2670|      1|    }
 2671|       |
 2672|       |    #[test]
 2673|      1|    fn test_queue_navigation() -> Result<()> {
 2674|      1|        let mut app = MarkdownViewerApp::new();
 2675|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2676|       |
 2677|      1|        let file1 = temp_dir.path().join("file1.md");
 2678|      1|        let file2 = temp_dir.path().join("file2.md");
 2679|       |
 2680|      1|        std::fs::write(&file1, "# File 1")?;
                                                        ^0
 2681|      1|        std::fs::write(&file2, "# File 2")?;
                                                        ^0
 2682|       |
 2683|       |        // Load first file and queue second
 2684|      1|        app.load_file(file1.clone(), true)?;
                                                        ^0
 2685|      1|        app.pending_files.push_back(file2.clone());
 2686|       |
 2687|      1|        assert!(app.can_navigate_forward());
 2688|      1|        app.navigate_forward();
 2689|      1|        assert_eq!(app.current_file, Some(file2));
 2690|      1|        assert!(app.pending_files.is_empty());
 2691|       |
 2692|      1|        Ok(())
 2693|      1|    }
 2694|       |
 2695|       |    #[test]
 2696|      1|    fn test_mixed_valid_invalid_files() -> Result<()> {
 2697|      1|        let mut app = MarkdownViewerApp::new();
 2698|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2699|       |
 2700|      1|        let md_file = temp_dir.path().join("test.md");
 2701|      1|        let pdf_file = temp_dir.path().join("test.pdf");
 2702|       |
 2703|      1|        std::fs::write(&md_file, "# Test")?;
                                                        ^0
 2704|      1|        std::fs::write(&pdf_file, "fake pdf")?;
                                                           ^0
 2705|       |
 2706|      1|        app.handle_file_drop(vec![md_file.clone(), pdf_file]);
 2707|       |
 2708|       |        // Should open the valid markdown file
 2709|      1|        assert_eq!(app.current_file, Some(md_file));
 2710|       |        // Should show error about the invalid file
 2711|      1|        assert!(app.error_message.is_some());
 2712|      1|        Ok(())
 2713|      1|    }
 2714|       |
 2715|       |    #[test]
 2716|      1|    fn test_empty_directory_drop() -> Result<()> {
 2717|      1|        let mut app = MarkdownViewerApp::new();
 2718|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 2719|       |
 2720|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 2721|       |
 2722|      1|        assert!(app.error_message.is_some());
 2723|      1|        assert!(app
 2724|      1|            .error_message
 2725|      1|            .as_ref()
 2726|      1|            .unwrap()
 2727|      1|            .contains("No markdown files"));
 2728|      1|        Ok(())
 2729|      1|    }
 2730|       |}

C:\language\mdmdview\src\emoji_assets.rs:
    1|       |use egui::Color32 as C;
    2|       |
    3|       |// Draw simple vector fallback icons for a subset of emoji.
    4|      0|pub fn make_image(emoji: &str, size: usize) -> Option<egui::ColorImage> {
    5|      0|    let mut img = egui::ColorImage::new([size, size], C::TRANSPARENT);
    6|      0|    match emoji {
    7|      0|        "\u{2705}" => {
    8|      0|            draw_circle(&mut img, size, C::from_rgb(34, 139, 34));
    9|      0|            draw_check(&mut img, size, C::WHITE);
   10|      0|            Some(img)
   11|       |        }
   12|      0|        "\u{1f389}" => {
   13|      0|            draw_circle(&mut img, size, C::from_rgb(255, 215, 0));
   14|      0|            confetti(&mut img, size);
   15|      0|            Some(img)
   16|       |        }
   17|      0|        "\u{1f680}" => {
   18|      0|            draw_circle(&mut img, size, C::from_rgb(60, 60, 170));
   19|      0|            rocket(
   20|      0|                &mut img,
   21|      0|                size,
   22|      0|                C::from_rgb(230, 230, 230),
   23|      0|                C::from_rgb(255, 110, 60),
   24|       |            );
   25|      0|            Some(img)
   26|       |        }
   27|      0|        "\u{2764}" | "\u{1f496}" => {
   28|      0|            heart(&mut img, size, C::from_rgb(220, 20, 60));
   29|      0|            Some(img)
   30|       |        }
   31|      0|        "\u{2b50}" => {
   32|      0|            star(&mut img, size, C::from_rgb(255, 215, 0));
   33|      0|            Some(img)
   34|       |        }
   35|      0|        "\u{1f525}" => {
   36|      0|            flame(&mut img, size);
   37|      0|            Some(img)
   38|       |        }
   39|      0|        _ => None,
   40|       |    }
   41|      0|}
   42|       |
   43|      0|fn draw_circle(img: &mut egui::ColorImage, size: usize, color: C) {
   44|      0|    let cx = (size as i32) / 2;
   45|      0|    let cy = cx;
   46|      0|    let r = (size as i32) / 2 - 2;
   47|      0|    for y in 0..size as i32 {
   48|      0|        for x in 0..size as i32 {
   49|      0|            let dx = x - cx;
   50|      0|            let dy = y - cy;
   51|      0|            if dx * dx + dy * dy <= r * r {
   52|      0|                img[(x as usize, y as usize)] = color;
   53|      0|            }
   54|       |        }
   55|       |    }
   56|      0|}
   57|       |
   58|      0|fn draw_check(img: &mut egui::ColorImage, size: usize, color: C) {
   59|      0|    let s = size as i32;
   60|      0|    let mut plot = |x: i32, y: i32| {
   61|      0|        if x >= 0 && y >= 0 && x < s && y < s {
   62|      0|            img[(x as usize, y as usize)] = color;
   63|      0|        }
   64|      0|    };
   65|       |    // simple check mark
   66|      0|    for i in 0..s / 3 {
   67|      0|        plot(s / 3 - i, s * 2 / 3 + i);
   68|      0|        plot(s / 3 - i + 1, s * 2 / 3 + i);
   69|      0|    }
   70|      0|    for i in 0..s / 2 {
   71|      0|        plot(s / 3 + i, s * 2 / 3 - i);
   72|      0|        plot(s / 3 + i + 1, s * 2 / 3 - i);
   73|      0|    }
   74|      0|}
   75|       |
   76|      0|fn confetti(img: &mut egui::ColorImage, size: usize) {
   77|      0|    let dots = [
   78|      0|        C::from_rgb(255, 80, 80),
   79|      0|        C::from_rgb(80, 180, 255),
   80|      0|        C::from_rgb(120, 220, 120),
   81|      0|        C::from_rgb(220, 120, 220),
   82|      0|    ];
   83|      0|    let s = size as i32;
   84|      0|    for (i, col) in dots.iter().enumerate() {
   85|      0|        let x = (s / 4) * ((i as i32) + 1);
   86|      0|        let y = (s / 5) * ((i as i32) + 1);
   87|      0|        if x < s && y < s {
   88|      0|            img[(x as usize, y as usize)] = *col;
   89|      0|        }
   90|       |    }
   91|      0|}
   92|       |
   93|      0|fn rocket(img: &mut egui::ColorImage, size: usize, body: C, flame: C) {
   94|      0|    let s = size as i32;
   95|       |    // body
   96|      0|    for y in s / 4..s * 3 / 4 {
   97|      0|        for x in s / 3..s * 2 / 3 {
   98|      0|            img[(x as usize, y as usize)] = body;
   99|      0|        }
  100|       |    }
  101|       |    // nose
  102|      0|    for i in 0..s / 6 {
  103|      0|        for x in s / 2 - i..=s / 2 + i {
  104|      0|            let y = s / 4 - i;
  105|      0|            if y >= 0 {
  106|      0|                img[(x as usize, y as usize)] = body;
  107|      0|            }
  108|       |        }
  109|       |    }
  110|       |    // flame
  111|      0|    for i in 0..s / 6 {
  112|      0|        for x in s / 2 - i..=s / 2 + i {
  113|      0|            let y = s * 3 / 4 + i;
  114|      0|            if y < s {
  115|      0|                img[(x as usize, y as usize)] = flame;
  116|      0|            }
  117|       |        }
  118|       |    }
  119|      0|}
  120|       |
  121|      0|fn heart(img: &mut egui::ColorImage, size: usize, color: C) {
  122|      0|    let s = size as i32;
  123|      0|    for y in 0..s {
  124|      0|        for x in 0..s {
  125|      0|            let dx = x - s / 2;
  126|      0|            let dy = y - s / 3;
  127|      0|            let a = (dx * dx + dy * dy - s * s / 16) < 0;
  128|      0|            let b = x > s / 4 && x < 3 * s / 4 && y > s / 3 && y < s * 3 / 4;
  129|      0|            if a || b {
  130|      0|                img[(x as usize, y as usize)] = color;
  131|      0|            }
  132|       |        }
  133|       |    }
  134|      0|}
  135|       |
  136|      0|fn star(img: &mut egui::ColorImage, size: usize, color: C) {
  137|      0|    let s = size as i32;
  138|      0|    for i in 0..s {
  139|      0|        let y = i;
  140|      0|        let x1 = s / 2;
  141|      0|        let x2 = s / 2 - i / 2;
  142|      0|        let x3 = s / 2 + i / 2;
  143|      0|        if x2 >= 0 {
  144|      0|            img[(x2 as usize, y as usize)] = color;
  145|      0|        }
  146|      0|        img[(x1 as usize, y as usize)] = color;
  147|      0|        if x3 < s {
  148|      0|            img[(x3 as usize, y as usize)] = color;
  149|      0|        }
  150|       |    }
  151|      0|}
  152|       |
  153|      0|fn flame(img: &mut egui::ColorImage, size: usize) {
  154|      0|    let s = size as i32;
  155|      0|    let base = C::from_rgb(255, 140, 0);
  156|      0|    let tip = C::from_rgb(255, 220, 120);
  157|      0|    for y in 0..s {
  158|      0|        for x in 0..s {
  159|      0|            let dx = (x - s / 2) as f32 / (s as f32 / 3.5);
  160|      0|            let dy = (y - s) as f32 / (s as f32 / 1.5);
  161|      0|            let v = (dx * dx + dy * dy).sqrt();
  162|      0|            if v < 1.0 {
  163|      0|                let t = 1.0 - v;
  164|      0|                img[(x as usize, y as usize)] = C::from_rgb(
  165|      0|                    (base.r() as f32 * t + tip.r() as f32 * (1.0 - t)) as u8,
  166|      0|                    (base.g() as f32 * t + tip.g() as f32 * (1.0 - t)) as u8,
  167|      0|                    (base.b() as f32 * t + tip.b() as f32 * (1.0 - t)) as u8,
  168|      0|                );
  169|      0|            }
  170|       |        }
  171|       |    }
  172|      0|}

C:\language\mdmdview\src\emoji_catalog.rs:
    1|       |use std::collections::HashMap;
    2|       |
    3|       |// Return embedded emoji sprites keyed by real Unicode emoji characters.
    4|      3|pub fn image_bytes_for(emoji: &str) -> Option<&'static [u8]> {
    5|      3|    match emoji {
    6|      3|        "\u{1f389}" => Some(include_bytes!(concat!(
    7|      1|            env!("CARGO_MANIFEST_DIR"),
    8|      1|            "/assets/emoji/1f389.png"
    9|      1|        ))),
   10|      2|        "\u{2705}" => Some(include_bytes!(concat!(
   11|      0|            env!("CARGO_MANIFEST_DIR"),
   12|      0|            "/assets/emoji/2705.png"
   13|      0|        ))),
   14|      2|        "\u{1f680}" => Some(include_bytes!(concat!(
   15|      2|            env!("CARGO_MANIFEST_DIR"),
   16|      2|            "/assets/emoji/1f680.png"
   17|      2|        ))),
   18|      0|        "\u{1f642}" => Some(include_bytes!(concat!(
   19|      0|            env!("CARGO_MANIFEST_DIR"),
   20|      0|            "/assets/emoji/1f642.png"
   21|      0|        ))),
   22|      0|        "\u{1f600}" => Some(include_bytes!(concat!(
   23|      0|            env!("CARGO_MANIFEST_DIR"),
   24|      0|            "/assets/emoji/1f600.png"
   25|      0|        ))),
   26|      0|        "\u{1f609}" => Some(include_bytes!(concat!(
   27|      0|            env!("CARGO_MANIFEST_DIR"),
   28|      0|            "/assets/emoji/1f609.png"
   29|      0|        ))),
   30|      0|        "\u{2b50}" => Some(include_bytes!(concat!(
   31|      0|            env!("CARGO_MANIFEST_DIR"),
   32|      0|            "/assets/emoji/2b50.png"
   33|      0|        ))),
   34|      0|        "\u{1f525}" => Some(include_bytes!(concat!(
   35|      0|            env!("CARGO_MANIFEST_DIR"),
   36|      0|            "/assets/emoji/1f525.png"
   37|      0|        ))),
   38|      0|        "\u{1f44d}" => Some(include_bytes!(concat!(
   39|      0|            env!("CARGO_MANIFEST_DIR"),
   40|      0|            "/assets/emoji/1f44d.png"
   41|      0|        ))),
   42|      0|        "\u{1f44e}" => Some(include_bytes!(concat!(
   43|      0|            env!("CARGO_MANIFEST_DIR"),
   44|      0|            "/assets/emoji/1f44e.png"
   45|      0|        ))),
   46|      0|        "\u{1f4a1}" => Some(include_bytes!(concat!(
   47|      0|            env!("CARGO_MANIFEST_DIR"),
   48|      0|            "/assets/emoji/1f4a1.png"
   49|      0|        ))),
   50|      0|        "\u{2753}" => Some(include_bytes!(concat!(
   51|      0|            env!("CARGO_MANIFEST_DIR"),
   52|      0|            "/assets/emoji/2753.png"
   53|      0|        ))),
   54|      0|        "\u{2757}" => Some(include_bytes!(concat!(
   55|      0|            env!("CARGO_MANIFEST_DIR"),
   56|      0|            "/assets/emoji/2757.png"
   57|      0|        ))),
   58|      0|        "\u{1f4dd}" => Some(include_bytes!(concat!(
   59|      0|            env!("CARGO_MANIFEST_DIR"),
   60|      0|            "/assets/emoji/1f4dd.png"
   61|      0|        ))),
   62|      0|        "\u{1f9e0}" => Some(include_bytes!(concat!(
   63|      0|            env!("CARGO_MANIFEST_DIR"),
   64|      0|            "/assets/emoji/1f9e0.png"
   65|      0|        ))),
   66|      0|        "\u{1f9ea}" => Some(include_bytes!(concat!(
   67|      0|            env!("CARGO_MANIFEST_DIR"),
   68|      0|            "/assets/emoji/1f9ea.png"
   69|      0|        ))),
   70|      0|        "\u{1f4e6}" => Some(include_bytes!(concat!(
   71|      0|            env!("CARGO_MANIFEST_DIR"),
   72|      0|            "/assets/emoji/1f4e6.png"
   73|      0|        ))),
   74|      0|        "\u{1f527}" => Some(include_bytes!(concat!(
   75|      0|            env!("CARGO_MANIFEST_DIR"),
   76|      0|            "/assets/emoji/1f527.png"
   77|      0|        ))),
   78|      0|        _ => None,
   79|       |    }
   80|      3|}
   81|       |
   82|      4|pub fn shortcode_map() -> &'static HashMap<&'static str, &'static str> {
   83|       |    use std::sync::OnceLock;
   84|       |    static MAP: OnceLock<HashMap<&'static str, &'static str>> = OnceLock::new();
   85|      4|    MAP.get_or_init(|| {
                                     ^1
   86|      1|        HashMap::from([
   87|      1|            (":tada:", "\u{1f389}"),
   88|      1|            (":white_check_mark:", "\u{2705}"),
   89|      1|            (":check_mark:", "\u{2705}"),
   90|      1|            (":rocket:", "\u{1f680}"),
   91|      1|            (":slightly_smiling_face:", "\u{1f642}"),
   92|      1|            (":grinning:", "\u{1f600}"),
   93|      1|            (":wink:", "\u{1f609}"),
   94|      1|            (":star:", "\u{2b50}"),
   95|      1|            (":fire:", "\u{1f525}"),
   96|      1|            (":thumbsup:", "\u{1f44d}"),
   97|      1|            (":thumbsdown:", "\u{1f44e}"),
   98|      1|            (":bulb:", "\u{1f4a1}"),
   99|      1|            (":question:", "\u{2753}"),
  100|      1|            (":exclamation:", "\u{2757}"),
  101|      1|            (":memo:", "\u{1f4dd}"),
  102|      1|            (":brain:", "\u{1f9e0}"),
  103|      1|            (":test_tube:", "\u{1f9ea}"),
  104|      1|            (":package:", "\u{1f4e6}"),
  105|      1|            (":wrench:", "\u{1f527}"),
  106|      1|        ])
  107|      1|    })
  108|      4|}

C:\language\mdmdview\src\main.rs:
    1|       |#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")] // Hide console in release mode
    2|       |
    3|       |/// Main entry point for the MarkdownView application
    4|       |///
    5|       |/// A simple, standalone markdown viewer for Windows built with Rust and egui.
    6|       |/// This application provides a clean interface for viewing markdown files with
    7|       |/// syntax highlighting, embedded samples, and essential viewing features.
    8|       |use mdmdview::{load_window_state, sanitize_window_state, MarkdownViewerApp, APP_TITLE_PREFIX};
    9|       |
   10|       |/// Application entry point
   11|      0|fn main() -> Result<(), eframe::Error> {
   12|       |    // Configure logging for debugging (only in debug builds)
   13|       |    #[cfg(debug_assertions)]
   14|      0|    env_logger::init();
   15|       |
   16|       |    // Parse command line arguments
   17|      0|    let mut initial_file: Option<std::path::PathBuf> = None;
   18|      0|    let mut table_wrap_cli: Option<bool> = None;
   19|      0|    for arg in std::env::args().skip(1) {
   20|      0|        match arg.as_str() {
   21|      0|            "--table-wrap" => table_wrap_cli = Some(true),
   22|      0|            "--no-table-wrap" => table_wrap_cli = Some(false),
   23|      0|            _ if initial_file.is_none() => initial_file = Some(std::path::PathBuf::from(&arg)),
   24|      0|            _ => {}
   25|       |        }
   26|       |    }
   27|      0|    let table_wrap_env = std::env::var("MDMDVIEW_TABLE_WRAP_OVERHAUL")
   28|      0|        .ok()
   29|      0|        .and_then(|value| parse_bool_flag(&value));
   30|      0|    let table_wrap_enabled = table_wrap_cli.or(table_wrap_env).unwrap_or(true);
   31|       |
   32|       |    // Set up eframe options for the native window
   33|      0|    let mut viewport = egui::ViewportBuilder::default()
   34|      0|        .with_title(format!("{APP_TITLE_PREFIX} - A Simple Markdown Viewer"))
   35|      0|        .with_inner_size(egui::Vec2::new(1000.0, 700.0))
   36|      0|        .with_min_inner_size(egui::Vec2::new(600.0, 400.0))
   37|      0|        .with_icon(create_app_icon())
   38|      0|        .with_resizable(true)
   39|      0|        .with_maximize_button(true)
   40|      0|        .with_minimize_button(true)
   41|      0|        .with_drag_and_drop(true);
   42|       |
   43|       |    // Restore previous window position/size if available
   44|      0|    if let Some(ws) = load_window_state() {
   45|      0|        if let Some(ws) = sanitize_window_state(ws) {
   46|      0|            viewport = viewport
   47|      0|                .with_inner_size(egui::Vec2::new(ws.size[0], ws.size[1]))
   48|      0|                .with_position(egui::pos2(ws.pos[0], ws.pos[1]))
   49|      0|                .with_maximized(ws.maximized);
   50|      0|        }
   51|      0|    }
   52|       |
   53|      0|    let native_options = eframe::NativeOptions {
   54|      0|        viewport,
   55|      0|        // Keep native persist as well; our explicit file handles crossplatform dirs
   56|      0|        persist_window: true,
   57|      0|        ..Default::default()
   58|      0|    };
   59|       |
   60|       |    // Launch the application
   61|      0|    eframe::run_native(
   62|      0|        APP_TITLE_PREFIX,
   63|      0|        native_options,
   64|      0|        Box::new(move |cc| {
   65|       |            // Configure egui styling for better markdown display
   66|      0|            configure_egui_style(&cc.egui_ctx);
   67|       |
   68|      0|            let mut app = MarkdownViewerApp::new();
   69|      0|            app.set_table_wrap_overhaul_enabled(table_wrap_enabled);
   70|       |
   71|       |            // Load initial file if provided via command line
   72|      0|            if let Some(file_path) = initial_file {
   73|      0|                if file_path.exists() && file_path.is_file() {
   74|      0|                    if let Err(e) = app.load_file(file_path, true) {
   75|      0|                        eprintln!("Failed to load file: {}", e);
   76|      0|                        // Continue with default welcome screen
   77|      0|                    }
   78|      0|                } else {
   79|      0|                    eprintln!("File not found: {}", file_path.display());
   80|      0|                    // Continue with default welcome screen
   81|      0|                }
   82|      0|            }
   83|       |
   84|      0|            Box::new(app)
   85|      0|        }),
   86|       |    )
   87|      0|}
   88|       |
   89|       |/// Create an application icon from embedded data
   90|      2|fn create_app_icon() -> egui::IconData {
   91|       |    // Create a 32x32 markdown-style document icon
   92|      2|    let size = 32;
   93|      2|    let mut rgba_data = Vec::with_capacity(size * size * 4);
   94|       |
   95|     64|    for y in 0..size {
                              ^2
   96|  2.04k|        for x in 0..size {
                                  ^64
   97|  2.04k|            let (r, g, b, a) = if x == 0 || x == size - 1 || y == 0 || y == size - 1 {
                                                          ^1.98k           ^1.92k    ^1.86k
   98|       |                // Border
   99|    248|                (60, 60, 60, 255)
  100|  1.80k|            } else if x == 1 || x == size - 2 || y == 1 || y == size - 2 {
                                              ^1.74k           ^1.68k    ^1.62k
  101|       |                // Inner border for depth
  102|    232|                (80, 80, 80, 255)
  103|  1.56k|            } else if (4..=8).contains(&y) && (4..=28).contains(&x) {
                                                            ^280     ^280     ^280
  104|       |                // Header area (title bar)
  105|    250|                if (6..=12).contains(&x) {
  106|     70|                    (100, 150, 255, 255) // Blue for # header
  107|    180|                } else if (14..=26).contains(&x) {
  108|    130|                    (200, 200, 200, 255) // Light text
  109|       |                } else {
  110|     50|                    (250, 250, 250, 255) // Background
  111|       |                }
  112|  1.31k|            } else if (11..=13).contains(&y) && (4..=28).contains(&x) {
                                                              ^168     ^168     ^168
  113|       |                // Text line 1
  114|    150|                if (6..=8).contains(&x) {
  115|     18|                    (150, 150, 150, 255) // Bullet point
  116|    132|                } else if (10..=24).contains(&x) {
  117|     90|                    (180, 180, 180, 255) // Text
  118|       |                } else {
  119|     42|                    (250, 250, 250, 255) // Background
  120|       |                }
  121|  1.16k|            } else if (15..=17).contains(&y) && (4..=28).contains(&x) {
                                                              ^168     ^168     ^168
  122|       |                // Text line 2
  123|    150|                if (6..=8).contains(&x) {
  124|     18|                    (150, 150, 150, 255) // Bullet point
  125|    132|                } else if (10..=22).contains(&x) {
  126|     78|                    (180, 180, 180, 255) // Text
  127|       |                } else {
  128|     54|                    (250, 250, 250, 255) // Background
  129|       |                }
  130|  1.01k|            } else if (20..=22).contains(&y) && (6..=26).contains(&x) {
                                                              ^168     ^168     ^168
  131|       |                // Code block area
  132|    126|                if (8..=24).contains(&x) {
  133|    102|                    (100, 255, 100, 255) // Green code text
  134|       |                } else {
  135|     24|                    (40, 40, 40, 255) // Dark background
  136|       |                }
  137|    892|            } else if (25..=27).contains(&y) && (4..=28).contains(&x) {
                                                              ^168     ^168     ^168
  138|       |                // Text line 3
  139|    150|                if (6..=20).contains(&x) {
  140|     90|                    (180, 180, 180, 255) // Text
  141|       |                } else {
  142|     60|                    (250, 250, 250, 255) // Background
  143|       |                }
  144|       |            } else {
  145|       |                // Document background
  146|    742|                (250, 250, 250, 255)
  147|       |            };
  148|       |
  149|  2.04k|            rgba_data.extend_from_slice(&[r, g, b, a]);
  150|       |        }
  151|       |    }
  152|       |
  153|      2|    egui::IconData {
  154|      2|        rgba: rgba_data,
  155|      2|        width: size as u32,
  156|      2|        height: size as u32,
  157|      2|    }
  158|      2|}
  159|       |
  160|       |/// Configure egui styling for optimal markdown display
  161|      0|fn configure_egui_style(ctx: &egui::Context) {
  162|      0|    let mut style = (*ctx.style()).clone();
  163|       |
  164|       |    // Configure spacing for better readability
  165|      0|    style.spacing.item_spacing = egui::Vec2::new(8.0, 8.0);
  166|      0|    style.spacing.window_margin = egui::Margin::same(8.0);
  167|      0|    style.spacing.menu_margin = egui::Margin::same(6.0);
  168|       |
  169|       |    // Configure interaction settings
  170|      0|    style.interaction.resize_grab_radius_side = 8.0;
  171|      0|    style.interaction.resize_grab_radius_corner = 12.0;
  172|       |
  173|       |    // Configure visuals for better contrast with black background
  174|      0|    style.visuals.window_rounding = egui::Rounding::same(4.0);
  175|      0|    style.visuals.menu_rounding = egui::Rounding::same(4.0);
  176|       |
  177|       |    // Set to true black background for maximum contrast
  178|      0|    if style.visuals.dark_mode {
  179|      0|        style.visuals.window_fill = egui::Color32::BLACK;
  180|      0|        style.visuals.panel_fill = egui::Color32::BLACK;
  181|      0|        style.visuals.faint_bg_color = egui::Color32::from_gray(20);
  182|      0|        style.visuals.extreme_bg_color = egui::Color32::BLACK;
  183|      0|        // The text color will be handled by egui's theme system
  184|      0|    }
  185|       |
  186|      0|    ctx.set_style(style);
  187|       |
  188|       |    // Use default fonts - egui has good built-in font support
  189|       |    // Custom fonts could be added here if needed
  190|      0|}
  191|       |
  192|      5|fn parse_bool_flag(value: &str) -> Option<bool> {
  193|      5|    match value.trim().to_ascii_lowercase().as_str() {
  194|      5|        "1" | "true" | "yes" | "on" => Some(true),
                            ^4       ^3      ^3      ^2
  195|      3|        "0" | "false" | "no" | "off" => Some(false),
                            ^2        ^1     ^1       ^2
  196|      1|        _ => None,
  197|       |    }
  198|      5|}
  199|       |
  200|       |#[cfg(test)]
  201|       |mod tests {
  202|       |    use super::*;
  203|       |
  204|       |    #[test]
  205|      1|    fn test_app_icon_creation() {
  206|      1|        let icon = create_app_icon();
  207|      1|        assert_eq!(icon.width, 32);
  208|      1|        assert_eq!(icon.height, 32);
  209|      1|        assert_eq!(icon.rgba.len(), 32 * 32 * 4); // RGBA format
  210|      1|    }
  211|       |
  212|       |    #[test]
  213|      1|    fn test_main_function_setup() {
  214|       |        // Test that the main function components work
  215|       |        // This is a basic smoke test
  216|      1|        let icon = create_app_icon();
  217|      1|        assert!(!icon.rgba.is_empty());
  218|      1|    }
  219|       |
  220|       |    #[test]
  221|      1|    fn test_parse_bool_flag() {
  222|      1|        assert_eq!(parse_bool_flag("true"), Some(true));
  223|      1|        assert_eq!(parse_bool_flag("FALSE"), Some(false));
  224|      1|        assert_eq!(parse_bool_flag("1"), Some(true));
  225|      1|        assert_eq!(parse_bool_flag("0"), Some(false));
  226|      1|        assert_eq!(parse_bool_flag("unknown"), None);
  227|      1|    }
  228|       |}

C:\language\mdmdview\src\markdown_renderer.rs:
    1|       |use crate::table_support::{
    2|       |    compute_column_stats, derive_column_specs, ColumnPolicy, ColumnSpec, ColumnStat,
    3|       |    TableColumnContext, TableMetrics, WidthChange,
    4|       |};
    5|       |use crate::{emoji_assets, emoji_catalog};
    6|       |use anyhow::Result;
    7|       |use crossbeam_channel::{
    8|       |    bounded, Receiver as KrokiJobReceiver, Sender as KrokiJobSender, TrySendError,
    9|       |};
   10|       |use egui::{
   11|       |    text::{Galley, LayoutJob, TextWrapping},
   12|       |    Align, Color32, Context, FontSelection, Painter, RichText, Stroke, Vec2, Visuals,
   13|       |};
   14|       |use egui_extras::TableBuilder;
   15|       |use pulldown_cmark::{Event, LinkType, Options, Parser, Tag};
   16|       |use std::cell::RefCell;
   17|       |use std::collections::{hash_map::DefaultHasher, HashMap, HashSet, VecDeque};
   18|       |use std::hash::{Hash, Hasher};
   19|       |use std::ops::Range;
   20|       |use std::path::{Path, PathBuf};
   21|       |use std::sync::{mpsc::Receiver, Arc};
   22|       |use std::time::{Duration, SystemTime};
   23|       |use syntect::easy::HighlightLines;
   24|       |use syntect::highlighting::ThemeSet;
   25|       |use syntect::parsing::SyntaxSet;
   26|       |use syntect::util::LinesWithEndings;
   27|       |use unicode_casefold::UnicodeCaseFold;
   28|       |use unicode_normalization::UnicodeNormalization;
   29|       |use unicode_segmentation::UnicodeSegmentation;
   30|       |
   31|       |// Embedded Mermaid JS bytes are generated in build.rs into OUT_DIR.
   32|       |// Place mermaid.min.js at assets/vendor/mermaid.min.js to embed it.
   33|       |#[cfg(feature = "mermaid-quickjs")]
   34|       |mod mermaid_embed {
   35|       |    include!(concat!(env!("OUT_DIR"), "/mermaid_js.rs"));
   36|       |}
   37|       |
   38|       |#[cfg(feature = "mermaid-quickjs")]
   39|       |struct MermaidEngine {
   40|       |    #[allow(dead_code)]
   41|       |    rt: rquickjs::Runtime,
   42|       |    ctx: rquickjs::Context,
   43|       |}
   44|       |
   45|       |#[derive(Clone, Copy, Default)]
   46|       |struct InlineStyle {
   47|       |    strong: bool,
   48|       |    italics: bool,
   49|       |    strike: bool,
   50|       |    color: Option<Color32>,
   51|       |}
   52|       |
   53|       |/// Font size configuration
   54|       |#[derive(Debug, Clone)]
   55|       |pub struct FontSizes {
   56|       |    pub body: f32,
   57|       |    pub h1: f32,
   58|       |    pub h2: f32,
   59|       |    pub h3: f32,
   60|       |    pub h4: f32,
   61|       |    pub h5: f32,
   62|       |    pub h6: f32,
   63|       |    pub code: f32,
   64|       |}
   65|       |
   66|       |impl Default for FontSizes {
   67|     56|    fn default() -> Self {
   68|     56|        Self {
   69|     56|            body: 14.0,
   70|     56|            h1: 28.0,
   71|     56|            h2: 24.0,
   72|     56|            h3: 20.0,
   73|     56|            h4: 18.0,
   74|     56|            h5: 16.0,
   75|     56|            h6: 14.0,
   76|     56|            code: 12.0,
   77|     56|        }
   78|     56|    }
   79|       |}
   80|       |
   81|       |/// Represents an inline text span with formatting
   82|       |#[derive(Debug, Clone)]
   83|       |pub enum InlineSpan {
   84|       |    Text(String),
   85|       |    Code(String),
   86|       |    Strong(String),
   87|       |    Emphasis(String),
   88|       |    Strikethrough(String),
   89|       |    Link {
   90|       |        text: String,
   91|       |        url: String,
   92|       |    },
   93|       |    Image {
   94|       |        src: String,
   95|       |        alt: String,
   96|       |        title: Option<String>,
   97|       |    },
   98|       |}
   99|       |
  100|       |impl InlineSpan {
  101|      6|    fn text_content(&self) -> Option<&str> {
  102|      6|        match self {
  103|      4|            InlineSpan::Text(t)
  104|      0|            | InlineSpan::Code(t)
  105|      1|            | InlineSpan::Strong(t)
  106|      0|            | InlineSpan::Emphasis(t)
  107|      5|            | InlineSpan::Strikethrough(t) => Some(t.as_str()),
                                                      ^0
  108|      0|            InlineSpan::Link { text, .. } => Some(text.as_str()),
  109|      1|            InlineSpan::Image { .. } => None,
  110|       |        }
  111|      6|    }
  112|       |
  113|      4|    fn is_text_like(&self) -> bool {
  114|      4|        !matches!(self, InlineSpan::Image { .. })
  115|      4|    }
  116|       |}
  117|       |
  118|       |#[cfg_attr(not(test), allow(dead_code))]
  119|       |#[derive(Debug, Clone)]
  120|       |enum CellFragment<'a> {
  121|       |    Text(&'a [InlineSpan]),
  122|       |    Emoji(String),
  123|       |    Image(&'a InlineSpan),
  124|       |}
  125|       |
  126|       |#[cfg_attr(not(test), allow(dead_code))]
  127|       |#[derive(Debug, Clone)]
  128|       |struct LayoutJobBuild {
  129|       |    job: LayoutJob,
  130|       |    #[allow(dead_code)]
  131|       |    plain_text: String,
  132|       |    #[cfg_attr(not(test), allow(dead_code))]
  133|       |    link_ranges: Vec<LinkRange>,
  134|       |}
  135|       |
  136|       |#[cfg_attr(not(test), allow(dead_code))]
  137|       |#[derive(Debug, Clone)]
  138|       |struct LinkRange {
  139|       |    char_range: Range<usize>,
  140|       |    url: String,
  141|       |}
  142|       |
  143|       |const TABLE_LAYOUT_CACHE_CAPACITY: usize = 512;
  144|       |const COLUMN_STATS_SAMPLE_ROWS: usize = 128;
  145|       |
  146|       |#[derive(Debug, Clone, Hash, PartialEq, Eq)]
  147|       |struct CellLayoutKey {
  148|       |    row: Option<usize>,
  149|       |    col: usize,
  150|       |    width: u32,
  151|       |    strong: bool,
  152|       |    highlight_hash: u64,
  153|       |    content_hash: u64,
  154|       |}
  155|       |
  156|       |struct CellLayoutCache {
  157|       |    entries: HashMap<CellLayoutKey, LayoutJobBuild>,
  158|       |    order: VecDeque<CellLayoutKey>,
  159|       |    hits: u64,
  160|       |    misses: u64,
  161|       |    capacity: usize,
  162|       |}
  163|       |
  164|       |#[derive(Clone)]
  165|       |struct ColumnStatsCacheEntry {
  166|       |    content_hash: u64,
  167|       |    stats: Vec<ColumnStat>,
  168|       |}
  169|       |
  170|       |impl CellLayoutCache {
  171|     54|    fn new(capacity: usize) -> Self {
  172|     54|        Self {
  173|     54|            entries: HashMap::new(),
  174|     54|            order: VecDeque::new(),
  175|     54|            hits: 0,
  176|     54|            misses: 0,
  177|     54|            capacity,
  178|     54|        }
  179|     54|    }
  180|       |
  181|      0|    fn get(&mut self, key: &CellLayoutKey) -> Option<LayoutJobBuild> {
  182|      0|        if let Some(build) = self.entries.get(key) {
  183|      0|            self.hits += 1;
  184|      0|            Some(build.clone())
  185|       |        } else {
  186|      0|            self.misses += 1;
  187|      0|            None
  188|       |        }
  189|      0|    }
  190|       |
  191|      0|    fn insert(&mut self, key: CellLayoutKey, build: LayoutJobBuild) {
  192|      0|        if self.entries.len() >= self.capacity && !self.entries.contains_key(&key) {
  193|      0|            while self.entries.len() >= self.capacity {
  194|      0|                if let Some(old) = self.order.pop_front() {
  195|      0|                    self.entries.remove(&old);
  196|      0|                } else {
  197|      0|                    break;
  198|       |                }
  199|       |            }
  200|      0|        }
  201|      0|        self.order.retain(|existing| existing != &key);
  202|      0|        self.order.push_back(key.clone());
  203|      0|        self.entries.insert(key, build);
  204|      0|    }
  205|       |
  206|    100|    fn clear(&mut self) {
  207|    100|        self.entries.clear();
  208|    100|        self.order.clear();
  209|    100|        self.hits = 0;
  210|    100|        self.misses = 0;
  211|    100|    }
  212|       |
  213|      0|    fn stats(&self) -> (u64, u64) {
  214|      0|        (self.hits, self.misses)
  215|      0|    }
  216|       |}
  217|       |
  218|       |/// Represents a rendered markdown element
  219|       |#[derive(Debug, Clone)]
  220|       |pub enum MarkdownElement {
  221|       |    Paragraph(Vec<InlineSpan>),
  222|       |    Header {
  223|       |        level: u8,
  224|       |        spans: Vec<InlineSpan>,
  225|       |        id: String,
  226|       |    },
  227|       |    CodeBlock {
  228|       |        language: Option<String>,
  229|       |        text: String,
  230|       |    },
  231|       |    List {
  232|       |        ordered: bool,
  233|       |        items: Vec<Vec<InlineSpan>>,
  234|       |    }, // List items are also inline spans
  235|       |    Quote {
  236|       |        depth: u8,
  237|       |        lines: Vec<Vec<InlineSpan>>,
  238|       |    },
  239|       |    HorizontalRule,
  240|       |    Table {
  241|       |        headers: Vec<Vec<InlineSpan>>,   // header cells as inline spans
  242|       |        rows: Vec<Vec<Vec<InlineSpan>>>, // rows -> cells -> spans
  243|       |    },
  244|       |}
  245|       |
  246|       |/// Type alias for table parsing result
  247|       |type TableParseResult = (Vec<Vec<InlineSpan>>, Vec<Vec<Vec<InlineSpan>>>, usize);
  248|       |
  249|       |/// Type alias for quote lines (each line is a sequence of inline spans)
  250|       |type QuoteLines = Vec<Vec<InlineSpan>>;
  251|       |
  252|       |struct ImageCacheEntry {
  253|       |    texture: egui::TextureHandle,
  254|       |    size: [u32; 2],
  255|       |    modified: Option<SystemTime>,
  256|       |}
  257|       |
  258|       |struct KrokiRequest {
  259|       |    key: u64,
  260|       |    url: String,
  261|       |    payload: String,
  262|       |}
  263|       |
  264|       |#[derive(Debug, PartialEq, Eq)]
  265|       |enum KrokiEnqueueError {
  266|       |    QueueFull,
  267|       |    Disconnected,
  268|       |}
  269|       |
  270|       |/// Markdown renderer with proper inline element handling
  271|       |pub struct MarkdownRenderer {
  272|       |    font_sizes: FontSizes,
  273|       |    syntax_set: SyntaxSet,
  274|       |    theme_set: ThemeSet,
  275|       |    emoji_textures: RefCell<HashMap<String, egui::TextureHandle>>,
  276|       |    image_textures: RefCell<HashMap<String, ImageCacheEntry>>,
  277|       |    // Mapping of header id -> last rendered rect (for in-document navigation)
  278|       |    header_rects: RefCell<HashMap<String, egui::Rect>>,
  279|       |    // Last clicked internal anchor (e.g., "getting-started") for the app to consume
  280|       |    pending_anchor: RefCell<Option<String>>,
  281|       |    // Unique counter to avoid egui Id collisions for repeated links
  282|       |    link_counter: RefCell<u64>,
  283|       |    // Per-frame rect for each top-level element in render order
  284|       |    element_rects: RefCell<Vec<egui::Rect>>,
  285|       |    // Optional highlight phrase (lowercased) for in-text highlighting
  286|       |    highlight_phrase: RefCell<Option<String>>,
  287|       |    // Cache for image/diagram textures
  288|       |    // Base directory used to resolve relative image paths
  289|       |    base_dir: RefCell<Option<PathBuf>>,
  290|       |    // Kroki (default Mermaid path) state
  291|       |    kroki_pending: RefCell<HashSet<u64>>, // code_hashes in flight
  292|       |    kroki_svg_cache: RefCell<HashMap<u64, Vec<u8>>>, // code_hash -> image bytes (PNG preferred)
  293|       |    kroki_errors: RefCell<HashMap<u64, String>>, // code_hash -> last error
  294|       |    kroki_job_tx: KrokiJobSender<KrokiRequest>, // UI -> worker queue
  295|       |    kroki_rx: Receiver<(u64, Result<Vec<u8>, String>)>, // background -> UI thread
  296|       |    #[cfg(feature = "mermaid-quickjs")]
  297|       |    mermaid_engine: RefCell<Option<MermaidEngine>>,
  298|       |    #[cfg(feature = "mermaid-quickjs")]
  299|       |    mermaid_svg_cache: RefCell<HashMap<u64, String>>, // code_hash -> SVG string
  300|       |    #[cfg(feature = "mermaid-quickjs")]
  301|       |    mermaid_failed: RefCell<HashSet<u64>>, // hashes that failed rendering; skip reattempts
  302|       |    #[cfg(feature = "mermaid-quickjs")]
  303|       |    mermaid_init_logged: RefCell<bool>,
  304|       |    #[cfg(feature = "mermaid-quickjs")]
  305|       |    mermaid_last_error: RefCell<Option<String>>,
  306|       |    table_wrap_overhaul_enabled: bool,
  307|       |    table_layout_cache: RefCell<CellLayoutCache>,
  308|       |    table_metrics: RefCell<TableMetrics>,
  309|       |    column_stats_cache: RefCell<HashMap<u64, ColumnStatsCacheEntry>>,
  310|       |}
  311|       |
  312|       |impl Default for MarkdownRenderer {
  313|      0|    fn default() -> Self {
  314|      0|        Self::new()
  315|      0|    }
  316|       |}
  317|       |
  318|       |impl MarkdownRenderer {
  319|       |    #[cfg_attr(not(test), allow(dead_code))]
  320|      2|    fn cell_fragments<'a>(&'a self, spans: &'a [InlineSpan]) -> Vec<CellFragment<'a>> {
  321|      2|        let mut fragments = Vec::new();
  322|      2|        let mut run_start: Option<usize> = None;
  323|      2|        let flush_run =
  324|      2|            |start: &mut Option<usize>, end: usize, fragments: &mut Vec<CellFragment<'a>>| {
  325|      2|                if let Some(run_begin) = start.take() {
                                          ^1
  326|      1|                    if run_begin < end {
  327|      1|                        fragments.push(CellFragment::Text(&spans[run_begin..end]));
  328|      1|                    }
                                  ^0
  329|      1|                }
  330|      2|            };
  331|       |
  332|      6|        for (idx, span) in spans.iter().enumerate() {
                                         ^2    ^2     ^2
  333|      6|            if let Some(emoji_key) = self.span_is_single_emoji(span) {
                                      ^1
  334|      1|                flush_run(&mut run_start, idx, &mut fragments);
  335|      1|                fragments.push(CellFragment::Emoji(emoji_key));
  336|      1|                continue;
  337|      5|            }
  338|       |
  339|      5|            if matches!(span, InlineSpan::Image { .. }) {
                             ^4
  340|      1|                flush_run(&mut run_start, idx, &mut fragments);
  341|      1|                fragments.push(CellFragment::Image(span));
  342|      1|                continue;
  343|      4|            }
  344|       |
  345|      4|            if span.is_text_like() && run_start.is_none() {
  346|      3|                run_start = Some(idx);
  347|      3|            }
                          ^1
  348|       |        }
  349|       |
  350|      2|        if let Some(start) = run_start {
  351|      2|            fragments.push(CellFragment::Text(&spans[start..]));
  352|      2|        }
                      ^0
  353|       |
  354|      2|        fragments
  355|      2|    }
  356|       |
  357|      6|    fn span_is_single_emoji(&self, span: &InlineSpan) -> Option<String> {
  358|      6|        let text = span.text_content()?;
                          ^5                        ^1
  359|      5|        let trimmed = text.trim();
  360|      5|        if trimmed.is_empty() {
  361|      0|            return None;
  362|      5|        }
  363|      5|        let mut graphemes = trimmed.graphemes(true);
  364|      5|        let first = graphemes.next()?;
                                                  ^0
  365|      5|        if graphemes.next().is_some() {
  366|      4|            return None;
  367|      1|        }
  368|      1|        if first != trimmed {
  369|      0|            return None;
  370|      1|        }
  371|      1|        self.emoji_key_for_grapheme(first)
  372|      6|    }
  373|       |
  374|      3|    fn highlight_segments(&self, text: &str, highlight: Option<&str>) -> Vec<(Range<usize>, bool)> {
  375|      3|        if text.is_empty() {
  376|      0|            return Vec::new();
  377|      3|        }
  378|      3|        let Some(needle) = highlight.filter(|h| !h.is_empty()) else {
                               ^1                              ^1^1
  379|      2|            return vec![(0..text.len(), false)];
  380|       |        };
  381|       |
  382|      1|        let mut folded = String::new();
  383|      1|        let mut folded_to_char: Vec<usize> = Vec::new();
  384|      1|        let mut char_ranges: Vec<(usize, usize)> = Vec::new();
  385|     22|        for (char_idx, (byte_idx, ch)) in text.char_indices().enumerate() {
                                                        ^1   ^1             ^1
  386|     22|            let folded_piece: String = ch.to_string().case_fold().nfkc().collect();
  387|     22|            let before = folded.len();
  388|     22|            folded.push_str(&folded_piece);
  389|     22|            let after = folded.len();
  390|     22|            for _ in before..after {
  391|     22|                folded_to_char.push(char_idx);
  392|     22|            }
  393|     22|            char_ranges.push((byte_idx, byte_idx + ch.len_utf8()));
  394|       |        }
  395|       |
  396|      1|        if folded.is_empty() {
  397|      0|            return vec![(0..text.len(), false)];
  398|      1|        }
  399|       |
  400|      1|        let mut segments = Vec::new();
  401|      1|        let mut rendered_until = 0usize;
  402|      1|        let mut search_at = 0usize;
  403|      3|        while let Some(pos) = folded[search_at..].find(needle) {
                                     ^2
  404|      2|            let abs = search_at + pos;
  405|      2|            if abs >= folded_to_char.len() {
  406|      0|                break;
  407|      2|            }
  408|      2|            let start_char_idx = folded_to_char[abs];
  409|      2|            let (start_byte, _) = char_ranges[start_char_idx];
  410|      2|            if start_byte > rendered_until {
  411|      1|                segments.push((rendered_until..start_byte, false));
  412|      1|            }
  413|      2|            let match_end = abs + needle.len();
  414|      2|            let end_char_idx = if match_end == 0 {
  415|      0|                start_char_idx
  416|       |            } else {
  417|      2|                folded_to_char[match_end.saturating_sub(1)]
  418|       |            };
  419|      2|            let (_, end_byte) = char_ranges[end_char_idx];
  420|      2|            segments.push((start_byte..end_byte, true));
  421|      2|            rendered_until = end_byte;
  422|      2|            search_at = match_end;
  423|       |        }
  424|       |
  425|      1|        if rendered_until < text.len() {
  426|      1|            segments.push((rendered_until..text.len(), false));
  427|      1|        }
                      ^0
  428|       |
  429|      1|        if segments.is_empty() {
  430|      0|            segments.push((0..text.len(), false));
  431|      1|        }
  432|      1|        segments
  433|      3|    }
  434|       |
  435|       |    #[cfg_attr(not(test), allow(dead_code))]
  436|      3|    fn build_layout_job(
  437|      3|        &self,
  438|      3|        style: &egui::Style,
  439|      3|        spans: &[InlineSpan],
  440|      3|        wrap_width: f32,
  441|      3|        strong_override: bool,
  442|      3|    ) -> LayoutJobBuild {
  443|      3|        let mut job = LayoutJob {
  444|      3|            wrap: TextWrapping {
  445|      3|                max_width: wrap_width.max(1.0),
  446|      3|                ..Default::default()
  447|      3|            },
  448|      3|            break_on_newline: true,
  449|      3|            halign: Align::LEFT,
  450|      3|            ..Default::default()
  451|      3|        };
  452|       |
  453|      3|        let highlight = self
  454|      3|            .highlight_phrase
  455|      3|            .borrow()
  456|      3|            .clone()
  457|      3|            .filter(|s| !s.is_empty());
                                       ^1^1
  458|       |
  459|      3|        let mut plain_text = String::new();
  460|      3|        let mut link_ranges = Vec::new();
  461|      3|        let mut job_char_offset = 0usize;
  462|       |
  463|      6|        for span in spans {
                          ^3
  464|      3|            match span {
  465|      0|                InlineSpan::Image { .. } => {}
  466|      0|                InlineSpan::Code(code) => {
  467|      0|                    job_char_offset +=
  468|      0|                        self.append_code_span(style, &mut job, &mut plain_text, code);
  469|      0|                }
  470|      1|                InlineSpan::Link { text, url } => {
  471|      1|                    let inline_style = InlineStyle {
  472|      1|                        strong: strong_override,
  473|      1|                        color: Some(if Self::is_external_url(url) {
  474|      1|                            Color32::from_rgb(120, 190, 255)
  475|       |                        } else {
  476|      0|                            Color32::LIGHT_BLUE
  477|       |                        }),
  478|      1|                        ..Default::default()
  479|       |                    };
  480|      1|                    let mut normalized = self.fix_unicode_chars(text);
  481|      1|                    normalized = Self::expand_shortcodes(&normalized);
  482|      1|                    normalized = Self::expand_superscripts(&normalized);
  483|      1|                    let appended = self.append_text_sections(
  484|      1|                        style,
  485|      1|                        &mut job,
  486|      1|                        &mut plain_text,
  487|      1|                        &normalized,
  488|      1|                        self.font_sizes.body,
  489|      1|                        inline_style,
  490|      1|                        highlight.as_deref(),
  491|       |                    );
  492|      1|                    if appended > 0 {
  493|      1|                        let start_char = job_char_offset;
  494|      1|                        job_char_offset += appended;
  495|      1|                        link_ranges.push(LinkRange {
  496|      1|                            char_range: start_char..job_char_offset,
  497|      1|                            url: url.clone(),
  498|      1|                        });
  499|      1|                    }
                                  ^0
  500|       |                }
  501|      0|                InlineSpan::Strong(text) => {
  502|      0|                    job_char_offset += self.append_plain_span(
  503|      0|                        style,
  504|      0|                        &mut job,
  505|      0|                        &mut plain_text,
  506|      0|                        text,
  507|      0|                        InlineStyle {
  508|      0|                            strong: true,
  509|      0|                            ..Default::default()
  510|      0|                        },
  511|      0|                        highlight.as_deref(),
  512|      0|                    );
  513|      0|                }
  514|      0|                InlineSpan::Emphasis(text) => {
  515|      0|                    job_char_offset += self.append_plain_span(
  516|      0|                        style,
  517|      0|                        &mut job,
  518|      0|                        &mut plain_text,
  519|      0|                        text,
  520|      0|                        InlineStyle {
  521|      0|                            italics: true,
  522|      0|                            strong: strong_override,
  523|      0|                            ..Default::default()
  524|      0|                        },
  525|      0|                        highlight.as_deref(),
  526|      0|                    );
  527|      0|                }
  528|      0|                InlineSpan::Strikethrough(text) => {
  529|      0|                    job_char_offset += self.append_plain_span(
  530|      0|                        style,
  531|      0|                        &mut job,
  532|      0|                        &mut plain_text,
  533|      0|                        text,
  534|      0|                        InlineStyle {
  535|      0|                            strike: true,
  536|      0|                            strong: strong_override,
  537|      0|                            ..Default::default()
  538|      0|                        },
  539|      0|                        highlight.as_deref(),
  540|      0|                    );
  541|      0|                }
  542|      2|                InlineSpan::Text(text) => {
  543|      2|                    job_char_offset += self.append_plain_span(
  544|      2|                        style,
  545|      2|                        &mut job,
  546|      2|                        &mut plain_text,
  547|      2|                        text,
  548|      2|                        InlineStyle {
  549|      2|                            strong: strong_override,
  550|      2|                            ..Default::default()
  551|      2|                        },
  552|      2|                        highlight.as_deref(),
  553|      2|                    );
  554|      2|                }
  555|       |            }
  556|       |        }
  557|       |
  558|      3|        LayoutJobBuild {
  559|      3|            job,
  560|      3|            plain_text,
  561|      3|            link_ranges,
  562|      3|        }
  563|      3|    }
  564|       |
  565|      2|    fn append_plain_span(
  566|      2|        &self,
  567|      2|        style: &egui::Style,
  568|      2|        job: &mut LayoutJob,
  569|      2|        plain_text: &mut String,
  570|      2|        text: &str,
  571|      2|        inline_style: InlineStyle,
  572|      2|        highlight: Option<&str>,
  573|      2|    ) -> usize {
  574|      2|        if text.is_empty() {
  575|      0|            return 0;
  576|      2|        }
  577|      2|        let mut normalized = self.fix_unicode_chars(text);
  578|      2|        normalized = Self::expand_shortcodes(&normalized);
  579|      2|        normalized = Self::expand_superscripts(&normalized);
  580|      2|        if normalized.is_empty() {
  581|      0|            return 0;
  582|      2|        }
  583|      2|        self.append_text_sections(
  584|      2|            style,
  585|      2|            job,
  586|      2|            plain_text,
  587|      2|            &normalized,
  588|      2|            self.font_sizes.body,
  589|      2|            inline_style,
  590|      2|            highlight,
  591|       |        )
  592|      2|    }
  593|       |
  594|      0|    fn append_code_span(
  595|      0|        &self,
  596|      0|        style: &egui::Style,
  597|      0|        job: &mut LayoutJob,
  598|      0|        plain_text: &mut String,
  599|      0|        code: &str,
  600|      0|    ) -> usize {
  601|      0|        if code.is_empty() {
  602|      0|            return 0;
  603|      0|        }
  604|      0|        plain_text.push_str(code);
  605|      0|        let visuals = &style.visuals;
  606|      0|        let (bg, fg) = if visuals.dark_mode {
  607|      0|            (
  608|      0|                Color32::from_rgb(30, 30, 30),
  609|      0|                Color32::from_rgb(180, 255, 180),
  610|      0|            )
  611|       |        } else {
  612|      0|            (Color32::WHITE, Color32::from_rgb(60, 80, 150))
  613|       |        };
  614|      0|        let rich = RichText::new(code.to_string())
  615|      0|            .size(self.font_sizes.code)
  616|      0|            .monospace()
  617|      0|            .background_color(bg)
  618|      0|            .color(fg);
  619|      0|        rich.append_to(job, style, FontSelection::Default, Align::LEFT);
  620|      0|        code.chars().count()
  621|      0|    }
  622|       |
  623|       |    #[allow(clippy::too_many_arguments)]
  624|      3|    fn append_text_sections(
  625|      3|        &self,
  626|      3|        style: &egui::Style,
  627|      3|        job: &mut LayoutJob,
  628|      3|        plain_text: &mut String,
  629|      3|        text: &str,
  630|      3|        font_size: f32,
  631|      3|        inline_style: InlineStyle,
  632|      3|        highlight: Option<&str>,
  633|      3|    ) -> usize {
  634|      3|        if text.is_empty() {
  635|      0|            return 0;
  636|      3|        }
  637|      3|        plain_text.push_str(text);
  638|      3|        let char_count = text.chars().count();
  639|      3|        let visuals = &style.visuals;
  640|      3|        let segments = self.highlight_segments(text, highlight);
  641|      9|        for (range, highlighted) in segments {
                           ^6     ^6
  642|      6|            if range.is_empty() {
  643|      0|                continue;
  644|      6|            }
  645|      6|            let slice = &text[range];
  646|      6|            let mut rich = RichText::new(slice.to_string()).size(font_size);
  647|      6|            if inline_style.strong {
  648|      0|                rich = rich.strong();
  649|      6|            }
  650|      6|            if inline_style.italics {
  651|      0|                rich = rich.italics();
  652|      6|            }
  653|      6|            if inline_style.strike {
  654|      0|                rich = rich.strikethrough();
  655|      6|            }
  656|      6|            let mut text_color = inline_style.color;
  657|      6|            if highlighted {
  658|      2|                rich = rich.background_color(visuals.selection.bg_fill);
  659|      2|                if text_color.is_none() {
  660|      2|                    text_color = Some(visuals.selection.stroke.color);
  661|      2|                }
                              ^0
  662|      4|            }
  663|      6|            if let Some(color) = text_color {
                                      ^3
  664|      3|                rich = rich.color(color);
  665|      3|            }
  666|      6|            rich.append_to(job, style, FontSelection::Default, Align::LEFT);
  667|       |        }
  668|      3|        char_count
  669|      3|    }
  670|       |
  671|       |    const MAX_KROKI_JOBS: usize = 4;
  672|       |
  673|       |    /// Create a new markdown renderer
  674|     54|    pub fn new() -> Self {
  675|     54|        let (tx, rx) = std::sync::mpsc::channel();
  676|     54|        let (job_tx, job_rx): (KrokiJobSender<KrokiRequest>, KrokiJobReceiver<KrokiRequest>) =
  677|     54|            bounded(Self::MAX_KROKI_JOBS * 4);
  678|    270|        for worker_idx in 0..Self::MAX_KROKI_JOBS {
                          ^216
  679|    216|            let worker_rx = job_rx.clone();
  680|    216|            let result_tx = tx.clone();
  681|    216|            if let Err(err) = std::thread::Builder::new()
                                     ^0
  682|    216|                .name(format!("mdmdview-kroki-{worker_idx}"))
  683|    216|                .spawn(move || {
  684|    216|                    let agent = ureq::AgentBuilder::new()
  685|    216|                        .timeout_connect(Duration::from_secs(5))
  686|    216|                        .timeout_read(Duration::from_secs(10))
  687|    216|                        .timeout_write(Duration::from_secs(10))
  688|    216|                        .build();
  689|    216|                    for job in worker_rx.iter() {
                                      ^0
  690|      0|                        let result = MarkdownRenderer::perform_kroki_with_agent(
  691|      0|                            &agent,
  692|      0|                            &job.url,
  693|      0|                            &job.payload,
  694|      0|                        );
  695|      0|                        let _ = result_tx.send((job.key, result));
  696|      0|                    }
  697|    216|                })
  698|      0|            {
  699|      0|                eprintln!("Failed to start Kroki worker thread: {}", err);
  700|    216|            }
  701|       |        }
  702|     54|        drop(job_rx);
  703|     54|        Self {
  704|     54|            font_sizes: FontSizes::default(),
  705|     54|            syntax_set: SyntaxSet::load_defaults_newlines(),
  706|     54|            theme_set: ThemeSet::load_defaults(),
  707|     54|            emoji_textures: RefCell::new(HashMap::new()),
  708|     54|            image_textures: RefCell::new(HashMap::new()),
  709|     54|            header_rects: RefCell::new(HashMap::new()),
  710|     54|            pending_anchor: RefCell::new(None),
  711|     54|            link_counter: RefCell::new(0),
  712|     54|            element_rects: RefCell::new(Vec::new()),
  713|     54|            highlight_phrase: RefCell::new(None),
  714|     54|            base_dir: RefCell::new(None),
  715|     54|            kroki_pending: RefCell::new(HashSet::new()),
  716|     54|            kroki_svg_cache: RefCell::new(HashMap::new()),
  717|     54|            kroki_errors: RefCell::new(HashMap::new()),
  718|     54|            kroki_job_tx: job_tx,
  719|     54|            kroki_rx: rx,
  720|     54|            #[cfg(feature = "mermaid-quickjs")]
  721|     54|            mermaid_engine: RefCell::new(None),
  722|     54|            #[cfg(feature = "mermaid-quickjs")]
  723|     54|            mermaid_svg_cache: RefCell::new(HashMap::new()),
  724|     54|            #[cfg(feature = "mermaid-quickjs")]
  725|     54|            mermaid_failed: RefCell::new(HashSet::new()),
  726|     54|            #[cfg(feature = "mermaid-quickjs")]
  727|     54|            mermaid_init_logged: RefCell::new(false),
  728|     54|            #[cfg(feature = "mermaid-quickjs")]
  729|     54|            mermaid_last_error: RefCell::new(None),
  730|     54|            table_wrap_overhaul_enabled: true,
  731|     54|            table_layout_cache: RefCell::new(CellLayoutCache::new(TABLE_LAYOUT_CACHE_CAPACITY)),
  732|     54|            table_metrics: RefCell::new(TableMetrics::default()),
  733|     54|            column_stats_cache: RefCell::new(HashMap::new()),
  734|     54|        }
  735|     54|    }
  736|       |
  737|       |    /// UI scale factor derived from body font size relative to default.
  738|       |    /// Used to scale non-text elements (e.g., images) consistently with zoom.
  739|      0|    fn ui_scale(&self) -> f32 {
  740|      0|        let default_body = FontSizes::default().body;
  741|      0|        (self.font_sizes.body / default_body).clamp(0.5, 4.0)
  742|      0|    }
  743|       |
  744|       |    /// Get current font sizes
  745|      0|    pub fn font_sizes(&self) -> &FontSizes {
  746|      0|        &self.font_sizes
  747|      0|    }
  748|       |
  749|       |    /// Parse markdown content into elements with proper inline handling
  750|     71|    pub fn parse(&self, markdown: &str) -> Result<Vec<MarkdownElement>, anyhow::Error> {
  751|     71|        let mut options = Options::empty();
  752|     71|        options.insert(Options::ENABLE_STRIKETHROUGH);
  753|     71|        options.insert(Options::ENABLE_TABLES);
  754|     71|        options.insert(Options::ENABLE_TASKLISTS);
  755|       |
  756|     71|        let parser = Parser::new_ext(markdown, options);
  757|     71|        let mut elements = Vec::new();
  758|     71|        let events = parser.collect::<Vec<_>>();
  759|       |
  760|     71|        let mut i = 0;
  761|       |        // Track header slug occurrences for stable de-duplication
  762|     71|        let mut slug_counts: HashMap<String, usize> = HashMap::new();
  763|    600|        while i < events.len() {
  764|    529|            i = self.parse_element(&events, i, &mut elements, &mut slug_counts)?;
                                                                                             ^0
  765|       |        }
  766|       |
  767|     71|        Ok(elements)
  768|     71|    }
  769|       |
  770|       |    /// Parse a single element from the event stream
  771|    529|    fn parse_element(
  772|    529|        &self,
  773|    529|        events: &[Event],
  774|    529|        start: usize,
  775|    529|        elements: &mut Vec<MarkdownElement>,
  776|    529|        slug_counts: &mut HashMap<String, usize>,
  777|    529|    ) -> Result<usize, anyhow::Error> {
  778|    529|        match &events[start] {
  779|       |            Event::Start(Tag::Paragraph) => {
  780|       |                // Always preserve line breaks in paragraphs (consistent with blockquotes)
  781|       |                // This allows poetry, lyrics, and structured content to render correctly
  782|    168|                let (spans, next_idx) =
  783|    168|                    self.parse_inline_spans_with_breaks(events, start + 1, Tag::Paragraph, true)?;
                                                                                                              ^0
  784|    168|                if !spans.is_empty() {
  785|    168|                    elements.push(MarkdownElement::Paragraph(spans));
  786|    168|                }
                              ^0
  787|    168|                Ok(next_idx)
  788|       |            }
  789|       |            // Images encountered outside paragraphs: treat as a single paragraph with an inline image
  790|      0|            Event::Start(Tag::Image(_, url, title)) => {
  791|      0|                let (alt, next_idx) = self.collect_until_tag_end(
  792|      0|                    events,
  793|      0|                    start + 1,
  794|      0|                    Tag::Image(LinkType::Inline, "".into(), "".into()),
  795|      0|                )?;
  796|      0|                let mut spans: Vec<InlineSpan> = Vec::new();
  797|      0|                spans.push(InlineSpan::Image {
  798|      0|                    src: url.to_string(),
  799|      0|                    alt,
  800|      0|                    title: if title.is_empty() {
  801|      0|                        None
  802|       |                    } else {
  803|      0|                        Some(title.to_string())
  804|       |                    },
  805|       |                });
  806|      0|                elements.push(MarkdownElement::Paragraph(spans));
  807|      0|                Ok(next_idx)
  808|       |            }
  809|    200|            Event::Start(Tag::Heading(level, _, _)) => {
  810|    200|                let (spans, next_idx) =
  811|    200|                    self.parse_inline_spans(events, start + 1, Tag::Heading(*level, None, vec![]))?;
                                                                                                                ^0
  812|    200|                let title_text = Self::spans_plain_text(&spans);
  813|    200|                let base = Self::slugify(&title_text);
  814|    200|                let count = slug_counts.entry(base.clone()).or_insert(0);
  815|    200|                let id = if *count == 0 {
  816|    198|                    base.clone()
  817|       |                } else {
  818|      2|                    format!("{}-{}", base, *count)
  819|       |                };
  820|    200|                *count += 1;
  821|    200|                elements.push(MarkdownElement::Header {
  822|    200|                    level: *level as u8,
  823|    200|                    spans,
  824|    200|                    id,
  825|    200|                });
  826|    200|                Ok(next_idx)
  827|       |            }
  828|       |            Event::Start(Tag::CodeBlock(_)) => {
  829|      6|                let (code_text, language, next_idx) = self.parse_code_block(events, start)?;
                                                                                                        ^0
  830|      6|                elements.push(MarkdownElement::CodeBlock {
  831|      6|                    language,
  832|      6|                    text: code_text,
  833|      6|                });
  834|      6|                Ok(next_idx)
  835|       |            }
  836|    100|            Event::Start(Tag::List(first_item)) => {
  837|    100|                let (items, next_idx) = self.parse_list(events, start + 1, *first_item, 0)?;
                                                                                                        ^0
  838|    100|                elements.push(MarkdownElement::List {
  839|    100|                    ordered: first_item.is_some(),
  840|    100|                    items,
  841|    100|                });
  842|    100|                Ok(next_idx)
  843|       |            }
  844|       |            Event::Rule => {
  845|     44|                elements.push(MarkdownElement::HorizontalRule);
  846|     44|                Ok(start + 1)
  847|       |            }
  848|       |            Event::Start(Tag::BlockQuote) => {
  849|      4|                let (quotes, next_idx) = self.collect_blockquotes(events, start + 1, 1)?;
                                                                                                     ^0
  850|     10|                for (depth, lines) in quotes {
                                   ^6     ^6
  851|      6|                    if !lines.is_empty() {
  852|      6|                        elements.push(MarkdownElement::Quote { depth, lines });
  853|      6|                    }
                                  ^0
  854|       |                }
  855|      4|                Ok(next_idx)
  856|       |            }
  857|       |            Event::Start(Tag::Table(_)) => {
  858|      7|                let (headers, rows, next_idx) = self.parse_table(events, start + 1)?;
                                                                                                 ^0
  859|      7|                elements.push(MarkdownElement::Table { headers, rows });
  860|      7|                Ok(next_idx)
  861|       |            }
  862|       |            _ => {
  863|       |                // Skip other events
  864|      0|                Ok(start + 1)
  865|       |            }
  866|       |        }
  867|    529|    }
  868|       |
  869|       |    // Build a slug from text similar to GitHub: lowercase, spaces->dashes, strip punctuation
  870|    200|    fn slugify(text: &str) -> String {
  871|    200|        let mut out = String::with_capacity(text.len());
  872|    200|        let mut last_dash = false;
  873|  2.62k|        for ch in text.chars() {
                                ^200 ^200
  874|  2.62k|            let c = ch.to_ascii_lowercase();
  875|  2.62k|            if c.is_ascii_alphanumeric() {
  876|  2.41k|                out.push(c);
  877|  2.41k|                last_dash = false;
  878|  2.41k|            } else if c.is_whitespace() || c == '-' {
                                    ^205^205               ^8
  879|    199|                if !last_dash && !out.is_empty() {
                                               ^195
  880|    195|                    out.push('-');
  881|    195|                    last_dash = true;
  882|    195|                }
                              ^4
  883|      6|            } else {
  884|      6|                // drop punctuation/symbols
  885|      6|            }
  886|       |        }
  887|       |        // Trim trailing dash if any
  888|    200|        if out.ends_with('-') {
  889|      0|            out.pop();
  890|    200|        }
  891|    200|        out
  892|    200|    }
  893|       |
  894|    206|    fn spans_plain_text(spans: &[InlineSpan]) -> String {
  895|    206|        let mut s = String::new();
  896|    416|        for span in spans {
                          ^210
  897|    210|            match span {
  898|    207|                InlineSpan::Text(t)
  899|      1|                | InlineSpan::Strong(t)
  900|      0|                | InlineSpan::Emphasis(t)
  901|    208|                | InlineSpan::Strikethrough(t) => s.push_str(t),
                                                          ^0
  902|      0|                InlineSpan::Code(t) => s.push_str(t),
  903|      1|                InlineSpan::Link { text, .. } => s.push_str(text),
  904|      1|                InlineSpan::Image { alt, title, .. } => {
  905|      1|                    if !alt.is_empty() {
  906|      1|                        s.push_str(alt);
  907|      1|                    }
                                  ^0
  908|      1|                    if let Some(t) = title {
  909|      1|                        if !t.is_empty() {
  910|      1|                            if !s.is_empty() {
  911|      1|                                s.push(' ');
  912|      1|                            }
                                          ^0
  913|      1|                            s.push_str(t);
  914|      0|                        }
  915|      0|                    }
  916|       |                }
  917|       |            }
  918|       |        }
  919|    206|        s
  920|    206|    }
  921|       |
  922|       |    /// Extract plain text from all markdown elements
  923|      3|    pub fn elements_to_plain_text(elements: &[MarkdownElement]) -> String {
  924|      3|        let mut result = String::new();
  925|      4|        for element in elements.iter() {
                                     ^3       ^3
  926|      4|            match element {
  927|      2|                MarkdownElement::Paragraph(spans) | MarkdownElement::Header { spans, .. } => {
                                                                                            ^1
  928|      3|                    if !result.is_empty() {
  929|      1|                        result.push('\n');
  930|      2|                    }
  931|      3|                    result.push_str(&Self::spans_plain_text(spans));
  932|       |                }
  933|      1|                MarkdownElement::CodeBlock { text, .. } => {
  934|      1|                    if !result.is_empty() {
  935|      0|                        result.push('\n');
  936|      1|                    }
  937|      1|                    result.push_str(text);
  938|       |                }
  939|      0|                MarkdownElement::List { items, .. } => {
  940|      0|                    for item in items {
  941|      0|                        if !result.is_empty() {
  942|      0|                            result.push('\n');
  943|      0|                        }
  944|      0|                        result.push_str(&Self::spans_plain_text(item));
  945|       |                    }
  946|       |                }
  947|      0|                MarkdownElement::Quote { lines, .. } => {
  948|      0|                    for line in lines {
  949|      0|                        if !result.is_empty() {
  950|      0|                            result.push('\n');
  951|      0|                        }
  952|      0|                        result.push_str(&Self::spans_plain_text(line));
  953|       |                    }
  954|       |                }
  955|      0|                MarkdownElement::Table { headers, rows } => {
  956|       |                    // Headers
  957|      0|                    for header in headers {
  958|      0|                        if !result.is_empty() {
  959|      0|                            result.push('\n');
  960|      0|                        }
  961|      0|                        result.push_str(&Self::spans_plain_text(header));
  962|       |                    }
  963|       |                    // Rows
  964|      0|                    for row in rows {
  965|      0|                        for cell in row {
  966|      0|                            if !result.is_empty() {
  967|      0|                                result.push('\n');
  968|      0|                            }
  969|      0|                            result.push_str(&Self::spans_plain_text(cell));
  970|       |                        }
  971|       |                    }
  972|       |                }
  973|       |                MarkdownElement::HorizontalRule => {
  974|      0|                    if !result.is_empty() {
  975|      0|                        result.push_str("\n---\n");
  976|      0|                    }
  977|       |                }
  978|       |            }
  979|       |        }
  980|      3|        result
  981|      3|    }
  982|       |
  983|       |    /// Collect blockquotes into (depth, lines) entries; supports nesting and multi-line content
  984|      6|    fn collect_blockquotes(
  985|      6|        &self,
  986|      6|        events: &[Event],
  987|      6|        start: usize,
  988|      6|        depth: u8,
  989|      6|    ) -> Result<(Vec<(u8, QuoteLines)>, usize), anyhow::Error> {
  990|      6|        let mut i = start;
  991|      6|        let mut result: Vec<(u8, QuoteLines)> = Vec::new();
  992|      6|        let mut lines: QuoteLines = Vec::new();
  993|      6|        let mut current: Vec<InlineSpan> = Vec::new();
  994|       |
  995|      8|        let push_line = |current: &mut Vec<InlineSpan>, lines: &mut QuoteLines| {
                          ^6
  996|      8|            lines.push(std::mem::take(current));
  997|      8|        };
  998|       |
  999|     14|        while i < events.len() {
 1000|     14|            match &events[i] {
 1001|       |                Event::Start(Tag::Paragraph) => {
 1002|      6|                    let (mut para, next) =
 1003|      6|                        self.parse_inline_spans_with_breaks(events, i + 1, Tag::Paragraph, true)?;
                                                                                                              ^0
 1004|       |                    // Split para into lines on explicit "\n"
 1005|      6|                    let mut line: Vec<InlineSpan> = Vec::new();
 1006|     20|                    while let Some(span) = para.first().cloned() {
                                                 ^14
 1007|     14|                        para.remove(0);
 1008|     12|                        match span {
 1009|     12|                            InlineSpan::Text(t) if t.contains('\n') => {
                                                           ^2                   ^2
 1010|      2|                                let parts: Vec<&str> = t.split('\n').collect();
 1011|      4|                                for (pi, part) in parts.iter().enumerate() {
                                                                ^2           ^2
 1012|      4|                                    if !part.is_empty() {
 1013|      0|                                        line.push(InlineSpan::Text(part.to_string()));
 1014|      4|                                    }
 1015|      4|                                    if pi < parts.len() - 1 {
 1016|      2|                                        push_line(&mut line, &mut lines);
 1017|      2|                                        line = Vec::new();
 1018|      2|                                    }
 1019|       |                                }
 1020|       |                            }
 1021|     12|                            other => line.push(other),
 1022|       |                        }
 1023|       |                    }
 1024|      6|                    if !line.is_empty() {
 1025|      6|                        push_line(&mut line, &mut lines);
 1026|      6|                    }
                                  ^0
 1027|      6|                    i = next;
 1028|       |                }
 1029|      0|                Event::SoftBreak | Event::HardBreak => {
 1030|      0|                    push_line(&mut current, &mut lines);
 1031|      0|                    i += 1;
 1032|      0|                }
 1033|       |                Event::Start(Tag::BlockQuote) => {
 1034|       |                    // flush current collected lines for this depth
 1035|      2|                    if !current.is_empty() {
 1036|      0|                        push_line(&mut current, &mut lines);
 1037|      2|                    }
 1038|      2|                    if !lines.is_empty() {
 1039|      2|                        result.push((depth, std::mem::take(&mut lines)));
 1040|      2|                    }
                                  ^0
 1041|       |                    // collect nested
 1042|      2|                    let (nested, next) = self.collect_blockquotes(events, i + 1, depth + 1)?;
                                                                                                         ^0
 1043|      2|                    result.extend(nested);
 1044|      2|                    i = next;
 1045|       |                }
 1046|       |                Event::End(Tag::BlockQuote) => {
 1047|      6|                    if !current.is_empty() {
 1048|      0|                        push_line(&mut current, &mut lines);
 1049|      6|                    }
 1050|      6|                    if !lines.is_empty() {
 1051|      4|                        result.push((depth, lines));
 1052|      4|                    }
                                  ^2
 1053|      6|                    return Ok((result, i + 1));
 1054|       |                }
 1055|      0|                _ => {
 1056|      0|                    i += 1;
 1057|      0|                }
 1058|       |            }
 1059|       |        }
 1060|      0|        if !current.is_empty() {
 1061|      0|            push_line(&mut current, &mut lines);
 1062|      0|        }
 1063|      0|        if !lines.is_empty() {
 1064|      0|            result.push((depth, lines));
 1065|      0|        }
 1066|      0|        Ok((result, i))
 1067|      6|    }
 1068|       |
 1069|       |    /// Parse inline spans until reaching the end tag
 1070|    456|    fn parse_inline_spans_with_breaks(
 1071|    456|        &self,
 1072|    456|        events: &[Event],
 1073|    456|        start: usize,
 1074|    456|        end_tag: Tag,
 1075|    456|        keep_breaks: bool,
 1076|    456|    ) -> Result<(Vec<InlineSpan>, usize), anyhow::Error> {
 1077|    456|        let mut spans = Vec::new();
 1078|    456|        let mut i = start;
 1079|    456|        let mut text_buffer = String::new();
 1080|       |
 1081|  1.01k|        while i < events.len() {
 1082|  1.01k|            match &events[i] {
 1083|    456|                Event::End(tag)
 1084|    456|                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
 1085|       |                {
 1086|    456|                    if !text_buffer.is_empty() {
 1087|    385|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1088|    385|                        text_buffer.clear();
 1089|    385|                    }
                                  ^71
 1090|    456|                    return Ok((spans, i + 1));
 1091|       |                }
 1092|    448|                Event::Text(text) => {
 1093|    448|                    text_buffer.push_str(text);
 1094|    448|                    i += 1;
 1095|    448|                }
 1096|       |                Event::SoftBreak | Event::HardBreak => {
 1097|     11|                    if keep_breaks {
 1098|     11|                        if !text_buffer.is_empty() {
 1099|      9|                            spans.push(InlineSpan::Text(text_buffer.clone()));
 1100|      9|                            text_buffer.clear();
 1101|      9|                        }
                                      ^2
 1102|     11|                        spans.push(InlineSpan::Text("\n".to_string()));
 1103|      0|                    } else {
 1104|      0|                        text_buffer.push(' ');
 1105|      0|                    }
 1106|     11|                    i += 1;
 1107|       |                }
 1108|     32|                Event::Code(code) => {
 1109|     32|                    if !text_buffer.is_empty() {
 1110|     15|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1111|     15|                        text_buffer.clear();
 1112|     17|                    }
 1113|     32|                    spans.push(InlineSpan::Code(code.to_string()));
 1114|     32|                    i += 1;
 1115|       |                }
 1116|       |                Event::Start(Tag::Strong) => {
 1117|      7|                    if !text_buffer.is_empty() {
 1118|      1|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1119|      1|                        text_buffer.clear();
 1120|      6|                    }
 1121|      7|                    let (inner_text, next_i) =
 1122|      7|                        self.collect_until_tag_end(events, i + 1, Tag::Strong)?;
                                                                                            ^0
 1123|      7|                    spans.push(InlineSpan::Strong(inner_text));
 1124|      7|                    i = next_i;
 1125|       |                }
 1126|       |                Event::Start(Tag::Emphasis) => {
 1127|     46|                    if !text_buffer.is_empty() {
 1128|      5|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1129|      5|                        text_buffer.clear();
 1130|     41|                    }
 1131|     46|                    let (inner_text, next_i) =
 1132|     46|                        self.collect_until_tag_end(events, i + 1, Tag::Emphasis)?;
                                                                                              ^0
 1133|     46|                    spans.push(InlineSpan::Emphasis(inner_text));
 1134|     46|                    i = next_i;
 1135|       |                }
 1136|       |                Event::Start(Tag::Strikethrough) => {
 1137|      2|                    if !text_buffer.is_empty() {
 1138|      2|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1139|      2|                        text_buffer.clear();
 1140|      2|                    }
                                  ^0
 1141|      2|                    let (inner_text, next_i) =
 1142|      2|                        self.collect_until_tag_end(events, i + 1, Tag::Strikethrough)?;
                                                                                                   ^0
 1143|      2|                    spans.push(InlineSpan::Strikethrough(inner_text));
 1144|      2|                    i = next_i;
 1145|       |                }
 1146|     10|                Event::Start(Tag::Link(_, url, _)) => {
 1147|     10|                    if !text_buffer.is_empty() {
 1148|      5|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1149|      5|                        text_buffer.clear();
 1150|      5|                    }
 1151|     10|                    let url_str = url.to_string();
 1152|     10|                    let (link_text, next_i) = self.collect_until_tag_end(
 1153|     10|                        events,
 1154|     10|                        i + 1,
 1155|     10|                        Tag::Link(LinkType::Inline, "".into(), "".into()),
 1156|      0|                    )?;
 1157|     10|                    spans.push(InlineSpan::Link {
 1158|     10|                        text: link_text,
 1159|     10|                        url: url_str,
 1160|     10|                    });
 1161|     10|                    i = next_i;
 1162|       |                }
 1163|      6|                Event::Start(Tag::Image(_, url, title)) => {
 1164|      6|                    if !text_buffer.is_empty() {
 1165|      2|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1166|      2|                        text_buffer.clear();
 1167|      4|                    }
 1168|      6|                    let url_str = url.to_string();
 1169|      6|                    let (alt_text, next_i) = self.collect_until_tag_end(
 1170|      6|                        events,
 1171|      6|                        i + 1,
 1172|      6|                        Tag::Image(LinkType::Inline, "".into(), "".into()),
 1173|      0|                    )?;
 1174|      6|                    spans.push(InlineSpan::Image {
 1175|      6|                        src: url_str,
 1176|      6|                        alt: alt_text,
 1177|      6|                        title: if title.is_empty() {
 1178|      1|                            None
 1179|       |                        } else {
 1180|      5|                            Some(title.to_string())
 1181|       |                        },
 1182|       |                    });
 1183|      6|                    i = next_i;
 1184|       |                }
 1185|      1|                _ => {
 1186|      1|                    i += 1;
 1187|      1|                }
 1188|       |            }
 1189|       |        }
 1190|       |
 1191|      0|        if !text_buffer.is_empty() {
 1192|      0|            spans.push(InlineSpan::Text(text_buffer));
 1193|      0|        }
 1194|       |
 1195|      0|        Ok((spans, i))
 1196|    456|    }
 1197|       |
 1198|       |    /// Default inline parsing without preserving explicit line breaks
 1199|    200|    fn parse_inline_spans(
 1200|    200|        &self,
 1201|    200|        events: &[Event],
 1202|    200|        start: usize,
 1203|    200|        end_tag: Tag,
 1204|    200|    ) -> Result<(Vec<InlineSpan>, usize), anyhow::Error> {
 1205|    200|        self.parse_inline_spans_with_breaks(events, start, end_tag, false)
 1206|    200|    }
 1207|       |
 1208|       |    /// Collect text until a specific end tag
 1209|    402|    fn collect_until_tag_end(
 1210|    402|        &self,
 1211|    402|        events: &[Event],
 1212|    402|        start: usize,
 1213|    402|        end_tag: Tag,
 1214|    402|    ) -> Result<(String, usize), anyhow::Error> {
 1215|    402|        let mut text = String::new();
 1216|    402|        let mut i = start;
 1217|       |
 1218|    808|        while i < events.len() {
 1219|    808|            match &events[i] {
 1220|    404|                Event::End(tag)
 1221|    404|                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
                                                                                                   ^402
 1222|       |                {
 1223|    402|                    return Ok((text, i + 1));
 1224|       |                }
 1225|    402|                Event::Text(t) => {
 1226|    402|                    text.push_str(t);
 1227|    402|                }
 1228|      0|                Event::Code(code) => {
 1229|      0|                    text.push_str(code);
 1230|      0|                }
 1231|      4|                _ => {}
 1232|       |            }
 1233|    406|            i += 1;
 1234|       |        }
 1235|       |
 1236|      0|        Ok((text, i))
 1237|    402|    }
 1238|       |
 1239|       |    /// Parse a code block
 1240|      6|    fn parse_code_block(
 1241|      6|        &self,
 1242|      6|        events: &[Event],
 1243|      6|        start: usize,
 1244|      6|    ) -> Result<(String, Option<String>, usize), anyhow::Error> {
 1245|      6|        let mut language = None;
 1246|      6|        let mut code_text = String::new();
 1247|      6|        let mut i = start;
 1248|       |
 1249|       |        // Extract language from the start tag
 1250|      6|        if let Event::Start(Tag::CodeBlock(kind)) = &events[start] {
 1251|      6|            if let pulldown_cmark::CodeBlockKind::Fenced(lang) = kind {
 1252|      6|                if !lang.is_empty() {
 1253|      6|                    language = Some(lang.to_string());
 1254|      6|                }
                              ^0
 1255|      0|            }
 1256|      6|            i += 1;
 1257|      0|        }
 1258|       |
 1259|     12|        while i < events.len() {
 1260|     12|            match &events[i] {
 1261|       |                Event::End(Tag::CodeBlock(_)) => {
 1262|      6|                    return Ok((code_text, language, i + 1));
 1263|       |                }
 1264|      6|                Event::Text(text) => {
 1265|      6|                    code_text.push_str(text);
 1266|      6|                }
 1267|      0|                _ => {}
 1268|       |            }
 1269|      6|            i += 1;
 1270|       |        }
 1271|       |
 1272|      0|        Ok((code_text, language, i))
 1273|      6|    }
 1274|       |
 1275|       |    /// Parse a list with basic nested-list flattening
 1276|    104|    fn parse_list(
 1277|    104|        &self,
 1278|    104|        events: &[Event],
 1279|    104|        start: usize,
 1280|    104|        first_item: Option<u64>,
 1281|    104|        depth: usize,
 1282|    104|    ) -> Result<(Vec<Vec<InlineSpan>>, usize), anyhow::Error> {
 1283|    104|        let mut items: Vec<Vec<InlineSpan>> = Vec::new();
 1284|    104|        let mut i = start;
 1285|    104|        let _is_ordered = first_item.is_some();
 1286|       |
 1287|    500|        while i < events.len() {
 1288|    500|            match &events[i] {
 1289|    104|                Event::End(Tag::List(_)) => return Ok((items, i + 1)),
 1290|       |                Event::Start(Tag::Item) => {
 1291|    396|                    i += 1;
 1292|    396|                    let mut spans: Vec<InlineSpan> = Vec::new();
 1293|       |                    loop {
 1294|  1.39k|                        if i >= events.len() {
 1295|      0|                            break;
 1296|  1.39k|                        }
 1297|  1.39k|                        match &events[i] {
 1298|       |                            Event::End(Tag::Item) => {
 1299|    396|                                i += 1;
 1300|    396|                                break;
 1301|       |                            }
 1302|       |                            Event::Start(Tag::Paragraph) => {
 1303|      0|                                let (ps, next) =
 1304|      0|                                    self.parse_inline_spans(events, i + 1, Tag::Paragraph)?;
 1305|      0|                                spans.extend(ps);
 1306|      0|                                i = next;
 1307|       |                            }
 1308|    147|                            Event::Code(code) => {
 1309|    147|                                spans.push(InlineSpan::Code(code.to_string()));
 1310|    147|                                i += 1;
 1311|    147|                            }
 1312|       |                            Event::Start(Tag::Emphasis) => {
 1313|      3|                                let (inner_text, next) =
 1314|      3|                                    self.collect_until_tag_end(events, i + 1, Tag::Emphasis)?;
                                                                                                          ^0
 1315|      3|                                spans.push(InlineSpan::Emphasis(inner_text));
 1316|      3|                                i = next;
 1317|       |                            }
 1318|       |                            Event::Start(Tag::Strong) => {
 1319|    303|                                let (inner_text, next) =
 1320|    303|                                    self.collect_until_tag_end(events, i + 1, Tag::Strong)?;
                                                                                                        ^0
 1321|    303|                                spans.push(InlineSpan::Strong(inner_text));
 1322|    303|                                i = next;
 1323|       |                            }
 1324|       |                            Event::Start(Tag::Strikethrough) => {
 1325|      3|                                let (inner_text, next) =
 1326|      3|                                    self.collect_until_tag_end(events, i + 1, Tag::Strikethrough)?;
                                                                                                               ^0
 1327|      3|                                spans.push(InlineSpan::Strikethrough(inner_text));
 1328|      3|                                i = next;
 1329|       |                            }
 1330|     22|                            Event::Start(Tag::Link(_, url, _)) => {
 1331|     22|                                let url_str = url.to_string();
 1332|     22|                                let (link_text, next) = self.collect_until_tag_end(
 1333|     22|                                    events,
 1334|     22|                                    i + 1,
 1335|     22|                                    Tag::Link(LinkType::Inline, "".into(), "".into()),
 1336|      0|                                )?;
 1337|     22|                                spans.push(InlineSpan::Link {
 1338|     22|                                    text: link_text,
 1339|     22|                                    url: url_str,
 1340|     22|                                });
 1341|     22|                                i = next;
 1342|       |                            }
 1343|      0|                            Event::Start(Tag::Image(_, url, title)) => {
 1344|      0|                                let url_str = url.to_string();
 1345|      0|                                let (alt_text, next) = self.collect_until_tag_end(
 1346|      0|                                    events,
 1347|      0|                                    i + 1,
 1348|      0|                                    Tag::Image(LinkType::Inline, "".into(), "".into()),
 1349|      0|                                )?;
 1350|      0|                                spans.push(InlineSpan::Image {
 1351|      0|                                    src: url_str,
 1352|      0|                                    alt: alt_text,
 1353|      0|                                    title: if title.is_empty() {
 1354|      0|                                        None
 1355|       |                                    } else {
 1356|      0|                                        Some(title.to_string())
 1357|       |                                    },
 1358|       |                                });
 1359|      0|                                i = next;
 1360|       |                            }
 1361|      4|                            Event::Start(Tag::List(child_first)) => {
 1362|      4|                                let (child_items, next) =
 1363|      4|                                    self.parse_list(events, i + 1, *child_first, depth + 1)?;
                                                                                                         ^0
 1364|      4|                                i = next;
 1365|      4|                                let ordered_child = child_first.is_some();
 1366|      8|                                for (idx, child) in child_items.into_iter().enumerate() {
                                                                  ^4          ^4          ^4
 1367|      8|                                    spans.push(InlineSpan::Text("\n".to_string()));
 1368|       |                                    // Indentation: 4 spaces per nested level
 1369|      8|                                    let indent = " ".repeat(4 * (depth + 1));
 1370|      8|                                    let marker = if ordered_child {
 1371|      4|                                        format!("{}.", idx + 1)
 1372|       |                                    } else {
 1373|      4|                                        "-".to_string()
 1374|       |                                    };
 1375|      8|                                    spans.push(InlineSpan::Text(format!("{}{} ", indent, marker)));
 1376|      8|                                    spans.extend(child);
 1377|       |                                }
 1378|       |                            }
 1379|    519|                            Event::Text(t) => {
 1380|    519|                                spans.push(InlineSpan::Text(t.to_string()));
 1381|    519|                                i += 1;
 1382|    519|                            }
 1383|      0|                            Event::SoftBreak | Event::HardBreak => {
 1384|      0|                                spans.push(InlineSpan::Text(" ".into()));
 1385|      0|                                i += 1;
 1386|      0|                            }
 1387|      0|                            _ => {
 1388|      0|                                i += 1;
 1389|      0|                            }
 1390|       |                        }
 1391|       |                    }
 1392|    396|                    items.push(spans);
 1393|       |                }
 1394|      0|                _ => i += 1,
 1395|       |            }
 1396|       |        }
 1397|       |
 1398|      0|        Ok((items, i))
 1399|    104|    }
 1400|       |
 1401|       |    /// Parse a table with headers and rows
 1402|      7|    fn parse_table(
 1403|      7|        &self,
 1404|      7|        events: &[Event],
 1405|      7|        start: usize,
 1406|      7|    ) -> Result<TableParseResult, anyhow::Error> {
 1407|      7|        let mut headers: Vec<Vec<InlineSpan>> = Vec::new();
 1408|      7|        let mut rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
 1409|      7|        let mut i = start;
 1410|       |
 1411|     44|        while i < events.len() {
 1412|     44|            match &events[i] {
 1413|       |                Event::Start(Tag::TableHead) => {
 1414|      7|                    i += 1;
 1415|     21|                    while i < events.len() {
 1416|     21|                        match &events[i] {
 1417|       |                            Event::Start(Tag::TableCell) => {
 1418|     14|                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
 1419|     14|                                    events,
 1420|     14|                                    i + 1,
 1421|     14|                                    Tag::TableCell,
 1422|       |                                    true,
 1423|      0|                                )?;
 1424|     14|                                headers.push(spans);
 1425|     14|                                i = next_idx;
 1426|       |                            }
 1427|       |                            Event::End(Tag::TableHead) => {
 1428|      7|                                i += 1;
 1429|      7|                                break;
 1430|       |                            }
 1431|      0|                            _ => i += 1,
 1432|       |                        }
 1433|       |                    }
 1434|       |                }
 1435|       |                Event::Start(Tag::TableRow) => {
 1436|     30|                    i += 1;
 1437|     30|                    let mut row: Vec<Vec<InlineSpan>> = Vec::new();
 1438|     98|                    while i < events.len() {
 1439|     98|                        match &events[i] {
 1440|       |                            Event::Start(Tag::TableCell) => {
 1441|     68|                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
 1442|     68|                                    events,
 1443|     68|                                    i + 1,
 1444|     68|                                    Tag::TableCell,
 1445|       |                                    true,
 1446|      0|                                )?;
 1447|     68|                                row.push(spans);
 1448|     68|                                i = next_idx;
 1449|       |                            }
 1450|       |                            Event::End(Tag::TableRow) => {
 1451|     30|                                i += 1;
 1452|     30|                                if !row.is_empty() {
 1453|     30|                                    rows.push(row);
 1454|     30|                                }
                                              ^0
 1455|     30|                                break;
 1456|       |                            }
 1457|      0|                            _ => i += 1,
 1458|       |                        }
 1459|       |                    }
 1460|       |                }
 1461|      7|                Event::End(Tag::Table(_)) => return Ok((headers, rows, i + 1)),
 1462|      0|                _ => i += 1,
 1463|       |            }
 1464|       |        }
 1465|      0|        Ok((headers, rows, i))
 1466|      7|    }
 1467|       |
 1468|       |    /// Render parsed markdown elements to egui UI
 1469|      0|    pub fn render_to_ui(&self, ui: &mut egui::Ui, elements: &[MarkdownElement]) {
 1470|       |        // Clear header rects before rendering a new frame
 1471|      0|        self.header_rects.borrow_mut().clear();
 1472|       |        // Reset per-frame link counter to ensure link IDs are stable across frames
 1473|      0|        *self.link_counter.borrow_mut() = 0;
 1474|       |        // Reset per-frame element rects
 1475|      0|        self.element_rects.borrow_mut().clear();
 1476|      0|        for (element_idx, element) in elements.iter().enumerate() {
 1477|       |            // Wrap each element in a no-op frame to capture its rect
 1478|      0|            let ir = egui::Frame::none().show(ui, |ui| {
 1479|      0|                match element {
 1480|      0|                    MarkdownElement::Paragraph(spans) => {
 1481|      0|                        self.render_inline_spans(ui, spans);
 1482|      0|                        ui.add_space(4.0);
 1483|      0|                    }
 1484|      0|                    MarkdownElement::Quote { depth, lines } => {
 1485|      0|                        ui.add_space(4.0);
 1486|      0|                        let bar_width = 3.0;
 1487|      0|                        let bar_gap = 6.0;
 1488|      0|                        let left_pad = 10.0 + (*depth as f32) * (bar_width + bar_gap);
 1489|       |                        // Substack-like styling: dark grey block with orange accent bars and white text
 1490|      0|                        let bg = Color32::from_rgb(24, 24, 24);
 1491|       |
 1492|      0|                        let resp = egui::Frame::none()
 1493|      0|                            .fill(bg)
 1494|      0|                            .stroke(Stroke::new(1.0, Color32::from_rgb(40, 40, 40)))
 1495|      0|                            .rounding(egui::Rounding::same(6.0))
 1496|      0|                            .inner_margin(egui::Margin {
 1497|      0|                                left: left_pad,
 1498|      0|                                right: 10.0,
 1499|      0|                                top: 8.0,
 1500|      0|                                bottom: 8.0,
 1501|      0|                            })
 1502|      0|                            .show(ui, |ui| {
 1503|      0|                                for (li, line) in lines.iter().enumerate() {
 1504|       |                                    // White text for quote content
 1505|      0|                                    ui.style_mut().visuals.override_text_color =
 1506|      0|                                        Some(Color32::WHITE);
 1507|      0|                                    self.render_inline_spans(ui, line);
 1508|      0|                                    ui.style_mut().visuals.override_text_color = None;
 1509|      0|                                    if li + 1 < lines.len() {
 1510|      0|                                        ui.add_space(3.0);
 1511|      0|                                    }
 1512|       |                                }
 1513|      0|                            });
 1514|       |
 1515|       |                        // Draw vertical orange quote bars on the left of the frame
 1516|      0|                        let rect = resp.response.rect;
 1517|      0|                        let top = rect.top() + 6.0;
 1518|      0|                        let bottom = rect.bottom() - 6.0;
 1519|      0|                        let bar_color = Color32::from_rgb(255, 103, 25); // Substack-like orange
 1520|      0|                        for d in 0..*depth {
 1521|      0|                            let x = rect.left() + 6.0 + (d as f32) * (bar_width + bar_gap);
 1522|      0|                            let bar_rect = egui::Rect::from_min_max(
 1523|      0|                                egui::pos2(x, top),
 1524|      0|                                egui::pos2(x + bar_width, bottom),
 1525|      0|                            );
 1526|      0|                            ui.painter().rect_filled(bar_rect, 2.0, bar_color);
 1527|      0|                        }
 1528|       |
 1529|      0|                        ui.add_space(6.0);
 1530|       |                    }
 1531|      0|                    MarkdownElement::Header { level, spans, id } => {
 1532|      0|                        let font_size = match level {
 1533|      0|                            1 => self.font_sizes.h1,
 1534|      0|                            2 => self.font_sizes.h2,
 1535|      0|                            3 => self.font_sizes.h3,
 1536|      0|                            4 => self.font_sizes.h4,
 1537|      0|                            5 => self.font_sizes.h5,
 1538|      0|                            6 => self.font_sizes.h6,
 1539|      0|                            _ => self.font_sizes.body,
 1540|       |                        };
 1541|       |
 1542|      0|                        ui.add_space(8.0);
 1543|      0|                        let resp = ui.horizontal_wrapped(|ui| {
 1544|       |                            // Avoid artificial gaps between header fragments
 1545|      0|                            ui.spacing_mut().item_spacing.x = 0.0;
 1546|      0|                            for span in spans {
 1547|      0|                                self.render_inline_span(ui, span, Some(font_size), Some(true));
 1548|      0|                            }
 1549|      0|                        });
 1550|       |                        // Record the header rect for in-document navigation
 1551|      0|                        self.header_rects
 1552|      0|                            .borrow_mut()
 1553|      0|                            .insert(id.clone(), resp.response.rect);
 1554|      0|                        ui.add_space(6.0);
 1555|       |                    }
 1556|      0|                    MarkdownElement::CodeBlock { language, text } => {
 1557|      0|                        self.render_code_block(ui, language.as_deref(), text);
 1558|      0|                    }
 1559|      0|                    MarkdownElement::List { ordered, items } => {
 1560|      0|                        self.render_list(ui, *ordered, items);
 1561|      0|                    }
 1562|      0|                    MarkdownElement::HorizontalRule => {
 1563|      0|                        ui.add_space(8.0);
 1564|      0|                        ui.separator();
 1565|      0|                        ui.add_space(8.0);
 1566|      0|                    }
 1567|      0|                    MarkdownElement::Table { headers, rows } => {
 1568|      0|                        self.render_table(ui, headers, rows, element_idx);
 1569|      0|                    }
 1570|       |                }
 1571|      0|            });
 1572|      0|            self.element_rects.borrow_mut().push(ir.response.rect);
 1573|       |        }
 1574|       |        // Add a little extra breathing room at the end so
 1575|       |        // the final line doesn't sit flush under the status bar.
 1576|      0|        ui.add_space(16.0);
 1577|      0|    }
 1578|       |
 1579|       |    /// Render inline spans in a wrapped horizontal layout
 1580|      0|    fn render_inline_spans(&self, ui: &mut egui::Ui, spans: &[InlineSpan]) {
 1581|      0|        ui.horizontal_wrapped(|ui| {
 1582|       |            // Avoid adding UI spacing between inline fragments
 1583|      0|            ui.spacing_mut().item_spacing.x = 0.0;
 1584|      0|            for span in spans {
 1585|      0|                self.render_inline_span(ui, span, None, None);
 1586|      0|            }
 1587|      0|        });
 1588|      0|    }
 1589|       |
 1590|       |    /// Fix Unicode characters that may not render properly in the default font
 1591|      6|    fn fix_unicode_chars(&self, text: &str) -> String {
 1592|      6|        let normalized: String = text.nfc().collect();
 1593|    109|        if !normalized.chars().any(|c| {
                          ^6                 ^6
 1594|    107|            matches!(
 1595|    109|                c,
 1596|       |                '\u{2011}'
 1597|       |                    | '\u{00AD}'
 1598|       |                    | '\u{2010}'
 1599|       |                    | '\u{2212}'
 1600|       |                    | '\u{2013}'
 1601|       |                    | '\u{2014}'
 1602|       |                    | '\u{00A0}'
 1603|       |                    | '\u{202F}'
 1604|       |                    | '\u{2190}'
 1605|       |                    | '\u{2192}'
 1606|       |                    | '\u{2191}'
 1607|       |                    | '\u{2193}'
 1608|       |            )
 1609|    109|        }) {
 1610|      4|            return normalized;
 1611|      2|        }
 1612|       |
 1613|      2|        let mut out = String::with_capacity(normalized.len());
 1614|     12|        for ch in normalized.chars() {
                                ^2         ^2
 1615|     12|            match ch {
 1616|       |                '\u{2011}' | '\u{00AD}' | '\u{2010}' | '\u{2212}' | '\u{2013}' | '\u{2014}' => {
 1617|      1|                    out.push('-')
 1618|       |                }
 1619|      1|                '\u{00A0}' | '\u{202F}' => out.push(' '),
 1620|      1|                '\u{2190}' => {
 1621|      1|                    out.push('<');
 1622|      1|                    out.push('-');
 1623|      1|                }
 1624|      1|                '\u{2192}' => {
 1625|      1|                    out.push('-');
 1626|      1|                    out.push('>');
 1627|      1|                }
 1628|      1|                '\u{2191}' => {
 1629|      1|                    out.push('^');
 1630|      1|                }
 1631|      1|                '\u{2193}' => {
 1632|      1|                    out.push('v');
 1633|      1|                }
 1634|      6|                _ => out.push(ch),
 1635|       |            }
 1636|       |        }
 1637|      2|        out
 1638|      6|    }
 1639|       |
 1640|       |    #[cfg(test)]
 1641|      3|    pub(crate) fn normalize_text_for_test(&self, text: &str) -> String {
 1642|      3|        self.fix_unicode_chars(text)
 1643|      3|    }
 1644|       |
 1645|       |    /// Render a single inline span    /// Render a single inline span
 1646|      0|    fn render_inline_span(
 1647|      0|        &self,
 1648|      0|        ui: &mut egui::Ui,
 1649|      0|        span: &InlineSpan,
 1650|      0|        font_size: Option<f32>,
 1651|      0|        strong: Option<bool>,
 1652|      0|    ) {
 1653|      0|        let size = font_size.unwrap_or(self.font_sizes.body);
 1654|      0|        let is_strong = strong.unwrap_or(false);
 1655|       |
 1656|      0|        match span {
 1657|      0|            InlineSpan::Text(text) => {
 1658|      0|                let fixed_text = self.fix_unicode_chars(text);
 1659|      0|                let style = InlineStyle {
 1660|      0|                    strong: is_strong,
 1661|      0|                    ..Default::default()
 1662|      0|                };
 1663|      0|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 1664|      0|            }
 1665|      0|            InlineSpan::Code(code) => {
 1666|       |                // Inline code: adapt style to theme (light vs dark)
 1667|      0|                ui.spacing_mut().item_spacing.x = 0.0;
 1668|      0|                let is_dark = ui.visuals().dark_mode;
 1669|      0|                let (bg, fg) = if is_dark {
 1670|      0|                    (
 1671|      0|                        Color32::from_rgb(30, 30, 30),
 1672|      0|                        Color32::from_rgb(180, 255, 180),
 1673|      0|                    )
 1674|       |                } else {
 1675|       |                    // Light theme: white background with readable code color
 1676|      0|                    (Color32::WHITE, Color32::from_rgb(60, 80, 150))
 1677|       |                };
 1678|      0|                let response = ui.add(
 1679|      0|                    egui::Label::new(
 1680|      0|                        RichText::new(code.clone())
 1681|      0|                            .size(self.font_sizes.code)
 1682|      0|                            .family(egui::FontFamily::Monospace)
 1683|      0|                            .background_color(bg)
 1684|      0|                            .color(fg),
 1685|       |                    )
 1686|      0|                    .wrap(false),
 1687|       |                );
 1688|       |
 1689|       |                // Add context menu for code
 1690|      0|                response.context_menu(|ui| {
 1691|      0|                    if ui.button("Copy Code").clicked() {
 1692|      0|                        ui.ctx().copy_text(code.clone());
 1693|      0|                        ui.close_menu();
 1694|      0|                    }
 1695|      0|                });
 1696|       |            }
 1697|      0|            InlineSpan::Strong(text) => {
 1698|      0|                let fixed_text = self.fix_unicode_chars(text);
 1699|      0|                let style = InlineStyle {
 1700|      0|                    strong: true,
 1701|      0|                    ..Default::default()
 1702|      0|                };
 1703|      0|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 1704|      0|            }
 1705|      0|            InlineSpan::Emphasis(text) => {
 1706|      0|                let fixed_text = self.fix_unicode_chars(text);
 1707|      0|                let style = InlineStyle {
 1708|      0|                    italics: true,
 1709|      0|                    strong: is_strong,
 1710|      0|                    ..Default::default()
 1711|      0|                };
 1712|      0|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 1713|      0|            }
 1714|      0|            InlineSpan::Strikethrough(text) => {
 1715|      0|                let fixed_text = self.fix_unicode_chars(text);
 1716|      0|                let style = InlineStyle {
 1717|      0|                    strike: true,
 1718|      0|                    strong: is_strong,
 1719|      0|                    ..Default::default()
 1720|      0|                };
 1721|      0|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 1722|      0|            }
 1723|      0|            InlineSpan::Link { text, url } => {
 1724|      0|                let fixed_text = self.fix_unicode_chars(text);
 1725|      0|                let group = ui.horizontal_wrapped(|ui| {
 1726|       |                    // Render link-like styled text with emoji expansion
 1727|      0|                    let color = if Self::is_external_url(url) {
 1728|       |                        // Slightly different color to indicate external website links
 1729|      0|                        Color32::from_rgb(120, 190, 255)
 1730|       |                    } else {
 1731|      0|                        Color32::LIGHT_BLUE
 1732|       |                    };
 1733|      0|                    let style = InlineStyle {
 1734|      0|                        strong: is_strong,
 1735|      0|                        color: Some(color),
 1736|      0|                        ..Default::default()
 1737|      0|                    };
 1738|      0|                    self.render_text_with_emojis(ui, &fixed_text, size, style);
 1739|      0|                });
 1740|       |                // Use a unique id per link occurrence to avoid collisions when the same URL appears multiple times
 1741|      0|                let mut counter = self.link_counter.borrow_mut();
 1742|      0|                let id = egui::Id::new(format!("link:{}:{}", *counter, url));
 1743|      0|                *counter += 1;
 1744|      0|                let r = ui.interact(group.response.rect, id, egui::Sense::click());
 1745|      0|                if r.hovered() {
 1746|      0|                    ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
 1747|      0|                }
 1748|      0|                if r.clicked() {
 1749|      0|                    self.trigger_link(url);
 1750|      0|                }
 1751|       |
 1752|       |                // Add context menu for links
 1753|      0|                r.context_menu(|ui| {
 1754|      0|                    if ui.button("Open Link").clicked() {
 1755|      0|                        self.trigger_link(url);
 1756|      0|                        ui.close_menu();
 1757|      0|                    }
 1758|      0|                    ui.separator();
 1759|      0|                    if ui.button("Copy Link Text").clicked() {
 1760|      0|                        ui.ctx().copy_text(text.clone());
 1761|      0|                        ui.close_menu();
 1762|      0|                    }
 1763|      0|                    if ui.button("Copy Link URL").clicked() {
 1764|      0|                        ui.ctx().copy_text(url.clone());
 1765|      0|                        ui.close_menu();
 1766|      0|                    }
 1767|      0|                });
 1768|       |            }
 1769|      0|            InlineSpan::Image { src, alt, title } => {
 1770|       |                // Resolve path
 1771|      0|                let resolved = self.resolve_image_path(src);
 1772|      0|                let available_w = ui.available_width().max(1.0);
 1773|       |                // Try to get or load texture
 1774|      0|                if let Some((tex, w, h)) = self.get_or_load_image_texture(ui, &resolved) {
 1775|      0|                    let (tw, th) = (w as f32, h as f32);
 1776|       |                    // Scale logic:
 1777|       |                    // - Start at UI scale (e.g., 1.0 for 100%, 1.1 for 110%).
 1778|       |                    // - Only downscale further if it would exceed available width.
 1779|      0|                    let base_scale = self.ui_scale();
 1780|      0|                    let scaled_w = tw * base_scale;
 1781|      0|                    let scale = if scaled_w > available_w {
 1782|      0|                        (available_w / tw).clamp(0.01, 4.0)
 1783|       |                    } else {
 1784|      0|                        base_scale
 1785|       |                    };
 1786|      0|                    let size = egui::vec2((tw * scale).round(), (th * scale).round());
 1787|      0|                    let image = egui::Image::new(&tex).fit_to_exact_size(size);
 1788|      0|                    let resp = ui.add(image);
 1789|      0|                    if let Some(t) = title {
 1790|      0|                        if !t.is_empty() {
 1791|      0|                            if resp.hovered() {
 1792|      0|                                resp.on_hover_text(t.clone());
 1793|      0|                            }
 1794|       |                            // Subtle caption below image
 1795|      0|                            ui.add_space(2.0);
 1796|      0|                            ui.label(
 1797|      0|                                RichText::new(t.clone())
 1798|      0|                                    .size(self.font_sizes.body - 2.0)
 1799|      0|                                    .color(Color32::from_rgb(140, 140, 140)),
 1800|       |                            );
 1801|      0|                        }
 1802|      0|                    }
 1803|      0|                    ui.add_space(6.0);
 1804|       |                } else {
 1805|       |                    // Placeholder with alt and error info
 1806|      0|                    egui::Frame::none()
 1807|      0|                        .fill(Color32::from_rgb(30, 30, 30))
 1808|      0|                        .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 1809|      0|                        .inner_margin(8.0)
 1810|      0|                        .show(ui, |ui| {
 1811|      0|                            let msg = if src.starts_with("http://") || src.starts_with("https://") {
 1812|      0|                                "Remote images are disabled"
 1813|       |                            } else {
 1814|      0|                                "Image not found or unsupported"
 1815|       |                            };
 1816|      0|                            let label = if alt.is_empty() {
 1817|      0|                                src.as_str()
 1818|       |                            } else {
 1819|      0|                                alt.as_str()
 1820|       |                            };
 1821|      0|                            ui.label(
 1822|      0|                                RichText::new(format!("{}\n{}", label, msg))
 1823|      0|                                    .size(self.font_sizes.body),
 1824|       |                            );
 1825|      0|                        });
 1826|      0|                    ui.add_space(6.0);
 1827|       |                }
 1828|       |            }
 1829|       |        }
 1830|      0|    }
 1831|       |
 1832|      0|    fn extract_fragment(url: &str) -> Option<String> {
 1833|      0|        if let Some(stripped) = url.strip_prefix('#') {
 1834|       |            // Already a fragment within current document
 1835|      0|            return Some(stripped.to_ascii_lowercase());
 1836|      0|        }
 1837|      0|        None
 1838|      0|    }
 1839|       |
 1840|      1|    fn is_external_url(url: &str) -> bool {
 1841|      1|        let lower = url.to_ascii_lowercase();
 1842|      1|        lower.starts_with("http://")
 1843|      1|            || lower.starts_with("https://")
 1844|      0|            || lower.starts_with("mailto:")
 1845|      0|            || lower.starts_with("www.")
 1846|      1|    }
 1847|       |
 1848|      0|    fn render_text_with_emojis(
 1849|      0|        &self,
 1850|      0|        ui: &mut egui::Ui,
 1851|      0|        text: &str,
 1852|      0|        size: f32,
 1853|      0|        style: InlineStyle,
 1854|      0|    ) {
 1855|      0|        let mut buffer = String::new();
 1856|      0|        for g in text.graphemes(true) {
 1857|      0|            if let Some(key) = self.emoji_key_for_grapheme(g) {
 1858|       |                // Flush buffered text first (with highlighting if active)
 1859|      0|                if !buffer.is_empty() {
 1860|      0|                    self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
 1861|      0|                    buffer.clear();
 1862|      0|                }
 1863|      0|                let handle = self.get_or_make_emoji_texture(ui, &key);
 1864|      0|                let sz = size * 1.2;
 1865|      0|                ui.add(egui::Image::new(&handle).max_width(sz).max_height(sz));
 1866|      0|            } else {
 1867|      0|                buffer.push_str(g);
 1868|      0|            }
 1869|       |        }
 1870|      0|        if !buffer.is_empty() {
 1871|      0|            self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
 1872|      0|        }
 1873|      0|    }
 1874|       |
 1875|      0|    fn render_text_segment_with_optional_highlight(
 1876|      0|        &self,
 1877|      0|        ui: &mut egui::Ui,
 1878|      0|        segment: &str,
 1879|      0|        size: f32,
 1880|      0|        style: InlineStyle,
 1881|      0|    ) {
 1882|       |        // First expand emoji shortcodes, then superscript ^...^ notation
 1883|      0|        let expanded = Self::expand_shortcodes(segment);
 1884|      0|        let expanded = Self::expand_superscripts(&expanded);
 1885|      0|        if let Some(h) = self
 1886|      0|            .highlight_phrase
 1887|      0|            .borrow()
 1888|      0|            .as_ref()
 1889|      0|            .filter(|s| !s.is_empty())
 1890|       |        {
 1891|      0|            for (range, highlighted) in self.highlight_segments(&expanded, Some(h)) {
 1892|      0|                if range.is_empty() {
 1893|      0|                    continue;
 1894|      0|                }
 1895|      0|                let slice = &expanded[range];
 1896|      0|                if highlighted {
 1897|      0|                    self.render_highlighted_segment(ui, slice, size, style);
 1898|      0|                } else {
 1899|      0|                    self.render_plain_segment(ui, slice, size, style);
 1900|      0|                }
 1901|       |            }
 1902|      0|            return;
 1903|      0|        }
 1904|      0|        self.render_plain_segment(ui, &expanded, size, style);
 1905|      0|    }
 1906|       |
 1907|      0|    fn render_plain_segment(&self, ui: &mut egui::Ui, text: &str, size: f32, style: InlineStyle) {
 1908|      0|        if text.is_empty() {
 1909|      0|            return;
 1910|      0|        }
 1911|      0|        let mut rich = RichText::new(text).size(size);
 1912|      0|        if style.strong {
 1913|      0|            rich = rich.strong();
 1914|      0|        }
 1915|      0|        if style.italics {
 1916|      0|            rich = rich.italics();
 1917|      0|        }
 1918|      0|        if style.strike {
 1919|      0|            rich = rich.strikethrough();
 1920|      0|        }
 1921|      0|        if let Some(color) = style.color {
 1922|      0|            rich = rich.color(color);
 1923|      0|        }
 1924|      0|        let response = ui.add(egui::Label::new(rich).wrap(true));
 1925|       |
 1926|       |        // Add context menu for text
 1927|       |        // Note: Due to egui limitations, selection is cleared on right-click
 1928|       |        // As a workaround, we provide "Copy Text" for the segment
 1929|      0|        response.context_menu(|ui| {
 1930|      0|            if ui.button("Copy Text").clicked() {
 1931|      0|                ui.ctx().copy_text(text.to_string());
 1932|      0|                ui.close_menu();
 1933|      0|            }
 1934|      0|            ui.label("Tip: Use Ctrl+C to copy selected text");
 1935|      0|        });
 1936|      0|    }
 1937|       |
 1938|      0|    fn render_highlighted_segment(
 1939|      0|        &self,
 1940|      0|        ui: &mut egui::Ui,
 1941|      0|        text: &str,
 1942|      0|        size: f32,
 1943|      0|        style: InlineStyle,
 1944|      0|    ) {
 1945|      0|        if text.is_empty() {
 1946|      0|            return;
 1947|      0|        }
 1948|      0|        let visuals = ui.visuals();
 1949|      0|        let bg = visuals.selection.bg_fill;
 1950|      0|        let mut text_color = style.color;
 1951|      0|        let fallback_color = visuals.selection.stroke.color;
 1952|      0|        if text_color.is_none() {
 1953|      0|            text_color = Some(fallback_color);
 1954|      0|        }
 1955|       |
 1956|      0|        let mut rich = RichText::new(text).size(size).background_color(bg);
 1957|      0|        if style.strong {
 1958|      0|            rich = rich.strong();
 1959|      0|        }
 1960|      0|        if style.italics {
 1961|      0|            rich = rich.italics();
 1962|      0|        }
 1963|      0|        if style.strike {
 1964|      0|            rich = rich.strikethrough();
 1965|      0|        }
 1966|      0|        if let Some(color) = text_color {
 1967|      0|            rich = rich.color(color);
 1968|      0|        }
 1969|      0|        let response = ui.add(egui::Label::new(rich).wrap(true));
 1970|       |
 1971|       |        // Add context menu for highlighted text
 1972|      0|        response.context_menu(|ui| {
 1973|      0|            if ui.button("Copy Text").clicked() {
 1974|      0|                ui.ctx().copy_text(text.to_string());
 1975|      0|                ui.close_menu();
 1976|      0|            }
 1977|      0|            ui.label("Tip: Use Ctrl+C to copy selected text");
 1978|      0|        });
 1979|      0|    }
 1980|       |
 1981|       |    /// Map a grapheme cluster to an emoji image key if available.
 1982|      1|    fn emoji_key_for_grapheme(&self, g: &str) -> Option<String> {
 1983|      1|        if crate::emoji_catalog::image_bytes_for(g).is_some() {
 1984|      1|            return Some(g.to_string());
 1985|      0|        }
 1986|      0|        let stripped: String = g.chars().filter(|&c| c != '\u{FE0F}').collect();
 1987|      0|        if stripped != g && crate::emoji_catalog::image_bytes_for(&stripped).is_some() {
 1988|      0|            return Some(stripped);
 1989|      0|        }
 1990|       |        // If the grapheme explicitly requests emoji presentation (contains VS16),
 1991|       |        // treat it as an emoji even if we don't have a sprite; fall back to a
 1992|       |        // generated placeholder via emoji_assets to avoid stray tofu.
 1993|      0|        if g.chars().any(|c| c == '\u{FE0F}') {
 1994|      0|            return Some(stripped); // prefer stripped as the texture key
 1995|      0|        }
 1996|      0|        None
 1997|      1|    }
 1998|       |
 1999|      0|    fn get_or_make_emoji_texture(&self, ui: &mut egui::Ui, emoji: &str) -> egui::TextureHandle {
 2000|      0|        if let Some(tex) = self.emoji_textures.borrow().get(emoji) {
 2001|      0|            return tex.clone();
 2002|      0|        }
 2003|       |
 2004|      0|        let img = if let Some(bytes) = emoji_catalog::image_bytes_for(emoji) {
 2005|      0|            match image::load_from_memory(bytes) {
 2006|      0|                Ok(dyn_img) => {
 2007|      0|                    let rgba = dyn_img.to_rgba8();
 2008|      0|                    let (w, h) = rgba.dimensions();
 2009|      0|                    let pixels = rgba.into_vec();
 2010|      0|                    egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &pixels)
 2011|       |                }
 2012|      0|                Err(_) => emoji_assets::make_image(emoji, 64)
 2013|      0|                    .unwrap_or_else(|| self.generate_emoji_image(emoji, 64)),
 2014|       |            }
 2015|       |        } else {
 2016|      0|            emoji_assets::make_image(emoji, 64)
 2017|      0|                .unwrap_or_else(|| self.generate_emoji_image(emoji, 64))
 2018|       |        };
 2019|      0|        let handle = ui.ctx().load_texture(
 2020|      0|            format!("emoji:{}", emoji),
 2021|      0|            img,
 2022|       |            egui::TextureOptions::LINEAR,
 2023|       |        );
 2024|      0|        self.emoji_textures
 2025|      0|            .borrow_mut()
 2026|      0|            .insert(emoji.to_string(), handle.clone());
 2027|      0|        handle
 2028|      0|    }
 2029|       |
 2030|       |    // Rough width measurement for inline spans without wrapping
 2031|      0|    fn measure_inline_spans(&self, ui: &egui::Ui, spans: &[InlineSpan]) -> f32 {
 2032|      0|        let mut width = 0.0f32;
 2033|      0|        ui.fonts(|fonts| {
 2034|      0|            for span in spans {
 2035|      0|                match span {
 2036|      0|                    InlineSpan::Text(t)
 2037|      0|                    | InlineSpan::Strong(t)
 2038|      0|                    | InlineSpan::Emphasis(t)
 2039|      0|                    | InlineSpan::Strikethrough(t)
 2040|      0|                    | InlineSpan::Link { text: t, .. } => {
 2041|      0|                        let body = egui::FontId::proportional(self.font_sizes.body);
 2042|       |                        // Expand shortcodes to better estimate width and count emojis
 2043|      0|                        let expanded = Self::expand_shortcodes(t);
 2044|      0|                        let galley = fonts.layout_no_wrap(expanded.clone(), body, Color32::WHITE);
 2045|      0|                        width += galley.size().x;
 2046|       |                        // Add a small extra width for emoji images (drawn larger than text)
 2047|      0|                        let emoji_extra = expanded
 2048|      0|                            .chars()
 2049|      0|                            .filter(|c| Self::is_known_emoji(*c))
 2050|      0|                            .count() as f32
 2051|      0|                            * (self.font_sizes.body * 0.2);
 2052|      0|                        width += emoji_extra;
 2053|       |                    }
 2054|      0|                    InlineSpan::Code(code) => {
 2055|      0|                        let mono = egui::FontId::monospace(self.font_sizes.code);
 2056|      0|                        let galley = fonts.layout_no_wrap(code.to_string(), mono, Color32::WHITE);
 2057|      0|                        width += galley.size().x + 6.0; // small padding for code background
 2058|      0|                    }
 2059|      0|                    InlineSpan::Image { src, .. } => {
 2060|       |                        // Use cached texture size if available; otherwise a conservative thumbnail.
 2061|      0|                        let cap = (ui.available_width() * 0.6).max(48.0);
 2062|      0|                        let cached = self
 2063|      0|                            .image_textures
 2064|      0|                            .borrow()
 2065|      0|                            .get(src)
 2066|      0|                            .map(|entry| entry.size[0] as f32 * self.ui_scale());
 2067|      0|                        let approx = cached.unwrap_or(self.font_sizes.body * 12.0);
 2068|      0|                        width += approx.min(cap);
 2069|       |                    }
 2070|       |                }
 2071|      0|                width += 4.0; // spacing between spans
 2072|       |            }
 2073|      0|        });
 2074|      0|        width
 2075|      0|    }
 2076|       |
 2077|      0|    fn is_known_emoji(c: char) -> bool {
 2078|      0|        matches!(
 2079|      0|            c,
 2080|       |            '\u{1f389}' // 
 2081|       |                | '\u{2705}' // 
 2082|       |                | '\u{1f680}' // 
 2083|       |                | '\u{1f642}' // 
 2084|       |                | '\u{1f600}' // 
 2085|       |                | '\u{1f609}' // 
 2086|       |                | '\u{2b50}'  // 
 2087|       |                | '\u{1f525}' // 
 2088|       |                | '\u{1f44d}' // 
 2089|       |                | '\u{1f44e}' // 
 2090|       |                | '\u{1f4a1}' // 
 2091|       |                | '\u{2753}'  // 
 2092|       |                | '\u{2757}'  // 
 2093|       |                | '\u{1f4dd}' // 
 2094|       |                | '\u{1f9e0}' // 
 2095|       |                | '\u{1f9ea}' // 
 2096|       |                | '\u{1f4e6}' // 
 2097|       |                | '\u{1f527}' // 
 2098|       |        )
 2099|      0|    }
 2100|       |
 2101|      6|    fn expand_shortcodes(s: &str) -> String {
 2102|       |        use crate::emoji_catalog::shortcode_map;
 2103|      6|        if !s.contains(':') {
 2104|      3|            return s.to_string();
 2105|      3|        }
 2106|      3|        let mut out = String::new();
 2107|      3|        let map = shortcode_map();
 2108|      3|        let mut i = 0;
 2109|      3|        let bytes = s.as_bytes();
 2110|     13|        while i < s.len() {
 2111|     10|            if bytes[i] == b':' {
 2112|     17|                if let Some(end_rel) = bytes[i + 1..].iter().position(|&b| b == b':') {
                                          ^3         ^3                    ^3
 2113|      3|                    let end = i + 1 + end_rel;
 2114|      3|                    let code = &s[i..=end];
 2115|      3|                    if let Some(&emoji) = map.get(code) {
 2116|      3|                        out.push_str(emoji);
 2117|      3|                        i = end + 1;
 2118|      3|                        continue;
 2119|      0|                    }
 2120|      0|                }
 2121|      7|            }
 2122|       |            // advance by one UTF-8 character
 2123|      7|            let ch = s[i..].chars().next().unwrap();
 2124|      7|            out.push(ch);
 2125|      7|            i += ch.len_utf8();
 2126|       |        }
 2127|      3|        out
 2128|      6|    }
 2129|       |
 2130|       |    // Expand ^...^ segments into Unicode superscript characters when available.
 2131|       |    // Example: "5^th^" -> "5??"
 2132|      7|    fn expand_superscripts(s: &str) -> String {
 2133|      7|        if !s.contains('^') {
 2134|      3|            return s.to_string();
 2135|      4|        }
 2136|      4|        let mut out = String::new();
 2137|      4|        let mut chars = s.chars().peekable();
 2138|    160|        while let Some(c) = chars.next() {
                                     ^156
 2139|    156|            if c == '^' {
 2140|       |                // Look ahead to see if there's a matching closing caret within reasonable bounds
 2141|      6|                let mut buf = String::new();
 2142|      6|                let mut found_closing = false;
 2143|      6|                let mut temp_chars = chars.clone();
 2144|      6|                let mut char_count = 0;
 2145|       |
 2146|     17|                while let Some(&nc) = temp_chars.peek() {
 2147|     17|                    if nc == '^' {
 2148|      3|                        found_closing = true;
 2149|      3|                        break;
 2150|     14|                    }
 2151|     14|                    if !nc.is_alphanumeric() && !matches!(nc, '+' | '-' | '=' | '(' | ')') {
                                                               ^3       ^3
 2152|      3|                        break;
 2153|     11|                    }
 2154|     11|                    if char_count >= 10 {
 2155|      0|                        break;
 2156|     11|                    }
 2157|     11|                    temp_chars.next();
 2158|     11|                    char_count += 1;
 2159|       |                }
 2160|       |
 2161|      6|                if found_closing && char_count > 0 {
                                                  ^3
 2162|      3|                    for _ in 0..char_count {
 2163|      5|                        if let Some(nc) = chars.next() {
 2164|      5|                            buf.push(nc);
 2165|      5|                        }
                                      ^0
 2166|       |                    }
 2167|       |                    // Skip the closing caret
 2168|      3|                    chars.next();
 2169|      3|                    out.push_str(&Self::to_superscript(&buf));
 2170|      3|                } else {
 2171|      3|                    out.push('^');
 2172|      3|                }
 2173|    150|            } else {
 2174|    150|                out.push(c);
 2175|    150|            }
 2176|       |        }
 2177|      4|        out
 2178|      7|    }
 2179|       |
 2180|      3|    fn to_superscript(s: &str) -> String {
 2181|      3|        s.chars()
 2182|      5|            .map(|c| match c {
                           ^3
 2183|      0|                '0' => '\u{2070}',
 2184|      0|                '1' => '\u{00b9}',
 2185|      1|                '2' => '\u{00b2}',
 2186|      0|                '3' => '\u{00b3}',
 2187|      0|                '4' => '\u{2074}',
 2188|      0|                '5' => '\u{2075}',
 2189|      0|                '6' => '\u{2076}',
 2190|      0|                '7' => '\u{2077}',
 2191|      0|                '8' => '\u{2078}',
 2192|      0|                '9' => '\u{2079}',
 2193|      0|                '+' => '\u{207a}',
 2194|      0|                '-' => '\u{207b}',
 2195|      0|                '=' => '\u{207c}',
 2196|      0|                '(' => '\u{207d}',
 2197|      0|                ')' => '\u{207e}',
 2198|      0|                'a' | 'A' => '\u{1d43}',
 2199|      0|                'b' | 'B' => '\u{1d47}',
 2200|      0|                'c' | 'C' => '\u{1d9c}',
 2201|      0|                'd' | 'D' => '\u{1d48}',
 2202|      0|                'e' | 'E' => '\u{1d49}',
 2203|      0|                'f' | 'F' => '\u{1da0}',
 2204|      0|                'g' | 'G' => '\u{1d4d}',
 2205|      2|                'h' | 'H' => '\u{02b0}',
 2206|      0|                'i' | 'I' => '\u{2071}',
 2207|      0|                'j' | 'J' => '\u{02b2}',
 2208|      0|                'k' | 'K' => '\u{1d4f}',
 2209|      0|                'l' | 'L' => '\u{02e1}',
 2210|      0|                'm' | 'M' => '\u{1d50}',
 2211|      0|                'n' | 'N' => '\u{207f}',
 2212|      0|                'o' | 'O' => '\u{1d52}',
 2213|      0|                'p' | 'P' => '\u{1d56}',
 2214|      0|                'q' | 'Q' => '\u{1d56}',
 2215|      0|                'r' | 'R' => '\u{02b3}',
 2216|      0|                's' | 'S' => '\u{02e2}',
 2217|      2|                't' | 'T' => '\u{1d57}',
 2218|      0|                'u' | 'U' => '\u{1d58}',
 2219|      0|                'v' | 'V' => '\u{1d5b}',
 2220|      0|                'w' | 'W' => '\u{02b7}',
 2221|      0|                'x' | 'X' => '\u{02e3}',
 2222|      0|                'y' | 'Y' => '\u{02b8}',
 2223|      0|                'z' | 'Z' => '\u{1dbb}',
 2224|      0|                other => other,
 2225|      5|            })
 2226|      3|            .collect()
 2227|      3|    }
 2228|       |
 2229|      0|    fn generate_emoji_image(&self, emoji: &str, size: usize) -> egui::ColorImage {
 2230|       |        // Simple procedural placeholder icons to keep binary small and avoid external assets
 2231|       |        use egui::Color32 as C;
 2232|      0|        let mut img = egui::ColorImage::new([size, size], C::TRANSPARENT);
 2233|      0|        let cx = (size as i32) / 2;
 2234|      0|        let cy = cx;
 2235|      0|        let r = (size as i32) / 2 - 2;
 2236|       |
 2237|      0|        let (base, accent) = match emoji {
 2238|      0|            "\u{1f389}" => (C::from_rgb(255, 215, 0), C::from_rgb(255, 80, 80)),
 2239|      0|            "\u{2705}" => (C::from_rgb(30, 150, 30), C::WHITE),
 2240|      0|            "\u{1f680}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 100, 100)),
 2241|      0|            "\u{1f642}" | "\u{1f600}" | "\u{1f609}" => {
 2242|      0|                (C::from_rgb(255, 205, 64), C::from_rgb(90, 60, 10))
 2243|       |            }
 2244|      0|            "\u{2b50}" => (C::from_rgb(255, 215, 0), C::WHITE),
 2245|      0|            "\u{1f525}" => (C::from_rgb(255, 120, 50), C::from_rgb(255, 200, 120)),
 2246|      0|            "\u{1f44d}" | "\u{1f44e}" => (C::from_rgb(200, 200, 200), C::from_rgb(80, 80, 80)),
 2247|      0|            "\u{1f4a1}" => (C::from_rgb(255, 240, 120), C::from_rgb(255, 255, 255)),
 2248|      0|            "\u{2753}" | "\u{2757}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 255, 255)),
 2249|      0|            "\u{1f4dd}" => (C::from_rgb(240, 240, 200), C::from_rgb(140, 140, 140)),
 2250|      0|            "\u{1f9e0}" => (C::from_rgb(220, 160, 200), C::from_rgb(255, 255, 255)),
 2251|      0|            "\u{1f9ea}" => (C::from_rgb(180, 220, 255), C::from_rgb(120, 160, 240)),
 2252|      0|            "\u{1f4e6}" => (C::from_rgb(205, 170, 125), C::from_rgb(150, 110, 70)),
 2253|      0|            "\u{1f527}" => (C::from_rgb(160, 170, 180), C::from_rgb(220, 220, 220)),
 2254|      0|            _ => (C::from_rgb(180, 180, 180), C::WHITE),
 2255|       |        };
 2256|       |
 2257|       |        // draw filled circle
 2258|      0|        for y in 0..size as i32 {
 2259|      0|            for x in 0..size as i32 {
 2260|      0|                let dx = x - cx;
 2261|      0|                let dy = y - cy;
 2262|      0|                if dx * dx + dy * dy <= r * r {
 2263|      0|                    img[(x as usize, y as usize)] = base;
 2264|      0|                }
 2265|       |            }
 2266|       |        }
 2267|       |
 2268|       |        // add a simple accent (diagonal highlight)
 2269|      0|        for t in 0..size {
 2270|      0|            let x = t as i32;
 2271|      0|            let y = (t as i32) / 2;
 2272|      0|            let xx = (x / 2 + 6).clamp(0, size as i32 - 1) as usize;
 2273|      0|            let yy = (y + 6).clamp(0, size as i32 - 1) as usize;
 2274|      0|            img[(xx, yy)] = accent;
 2275|      0|        }
 2276|       |
 2277|      0|        img
 2278|      0|    }
 2279|       |
 2280|       |    /// Render a list with proper inline formatting, including simple nested lines
 2281|       |    /// Render a list with proper inline formatting, including simple nested lines
 2282|      0|    fn render_list(&self, ui: &mut egui::Ui, ordered: bool, items: &[Vec<InlineSpan>]) {
 2283|      0|        if items.is_empty() {
 2284|      0|            return;
 2285|      0|        }
 2286|       |
 2287|      0|        ui.add_space(4.0);
 2288|       |
 2289|      0|        for (index, spans) in items.iter().enumerate() {
 2290|       |            // Split into lines on embedded '\n'
 2291|      0|            let mut lines: Vec<Vec<InlineSpan>> = vec![Vec::new()];
 2292|      0|            for s in spans.clone() {
 2293|      0|                match s {
 2294|      0|                    InlineSpan::Text(t) if t.contains('\n') => {
 2295|      0|                        let parts: Vec<&str> = t.split('\n').collect();
 2296|      0|                        for (pi, part) in parts.iter().enumerate() {
 2297|      0|                            if !part.is_empty() {
 2298|      0|                                lines
 2299|      0|                                    .last_mut()
 2300|      0|                                    .unwrap()
 2301|      0|                                    .push(InlineSpan::Text(part.to_string()));
 2302|      0|                            }
 2303|      0|                            if pi < parts.len() - 1 {
 2304|      0|                                lines.push(Vec::new());
 2305|      0|                            }
 2306|       |                        }
 2307|       |                    }
 2308|      0|                    other => lines.last_mut().unwrap().push(other),
 2309|       |                }
 2310|       |            }
 2311|       |
 2312|      0|            for (li, mut line) in lines.into_iter().enumerate() {
 2313|      0|                ui.horizontal_wrapped(|ui| {
 2314|      0|                    if li == 0 {
 2315|      0|                        let marker = if ordered {
 2316|      0|                            format!("{}.", index + 1)
 2317|       |                        } else {
 2318|      0|                            "-".to_string()
 2319|       |                        };
 2320|      0|                        let marker_color = if ui.visuals().dark_mode {
 2321|      0|                            Color32::from_rgb(180, 180, 180)
 2322|       |                        } else {
 2323|      0|                            Color32::BLACK
 2324|       |                        };
 2325|      0|                        ui.label(
 2326|      0|                            RichText::new(format!("{} ", marker))
 2327|      0|                                .size(self.font_sizes.body)
 2328|      0|                                .color(marker_color),
 2329|       |                        );
 2330|       |                    } else {
 2331|       |                        // Determine additional indentation from leading spaces in this line
 2332|      0|                        let mut leading_spaces = 0usize;
 2333|      0|                        if let Some(InlineSpan::Text(t0)) = line.first() {
 2334|      0|                            leading_spaces = t0.chars().take_while(|c| *c == ' ').count();
 2335|      0|                        }
 2336|      0|                        if leading_spaces > 0 {
 2337|      0|                            if let Some(InlineSpan::Text(t0)) = line.get_mut(0) {
 2338|      0|                                let trimmed = t0.trim_start_matches(' ').to_string();
 2339|      0|                                *t0 = trimmed;
 2340|      0|                            }
 2341|      0|                        }
 2342|      0|                        let indent_px = 18.0 + (leading_spaces as f32) * 6.0;
 2343|      0|                        ui.add_space(indent_px);
 2344|       |                    }
 2345|      0|                    ui.spacing_mut().item_spacing.x = 0.0;
 2346|      0|                    for span in &line {
 2347|      0|                        self.render_inline_span(ui, span, None, None);
 2348|      0|                    }
 2349|      0|                });
 2350|       |            }
 2351|       |        }
 2352|       |
 2353|      0|        ui.add_space(4.0);
 2354|      0|    }
 2355|       |
 2356|       |    /// Render a code block with syntax highlighting
 2357|      0|    fn render_code_block(&self, ui: &mut egui::Ui, language: Option<&str>, code: &str) {
 2358|      0|        ui.add_space(8.0);
 2359|       |
 2360|       |        // Special handling for Mermaid diagrams
 2361|      0|        if let Some(lang) = language {
 2362|      0|            if lang.eq_ignore_ascii_case("mermaid") && self.render_mermaid_block(ui, code) {
 2363|      0|                ui.add_space(8.0);
 2364|      0|                return;
 2365|      0|            }
 2366|      0|        }
 2367|       |
 2368|      0|        let frame_response = egui::Frame::none()
 2369|      0|            .fill(Color32::from_rgb(25, 25, 25))
 2370|      0|            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2371|      0|            .inner_margin(8.0)
 2372|      0|            .show(ui, |ui| {
 2373|      0|                ui.with_layout(egui::Layout::top_down(egui::Align::LEFT), |ui| {
 2374|      0|                    if let Some(lang) = language {
 2375|      0|                        ui.label(
 2376|      0|                            RichText::new(lang)
 2377|      0|                                .size(self.font_sizes.code - 1.0)
 2378|      0|                                .color(Color32::from_rgb(150, 150, 150))
 2379|      0|                                .family(egui::FontFamily::Monospace),
 2380|      0|                        );
 2381|      0|                        ui.add_space(2.0);
 2382|      0|                    }
 2383|       |
 2384|       |                    // Try syntax highlighting
 2385|      0|                    if let Some(lang) = language {
 2386|      0|                        if let Some(syntax) = self
 2387|      0|                            .find_syntax_for_language(lang)
 2388|      0|                            .or_else(|| self.syntax_set.find_syntax_by_first_line(code))
 2389|       |                        {
 2390|      0|                            let theme = &self.theme_set.themes["base16-ocean.dark"];
 2391|      0|                            let mut h = HighlightLines::new(syntax, theme);
 2392|       |
 2393|      0|                            for line in LinesWithEndings::from(code) {
 2394|      0|                                let ranges =
 2395|      0|                                    h.highlight_line(line, &self.syntax_set).unwrap_or_default();
 2396|       |
 2397|      0|                                ui.horizontal_wrapped(|ui| {
 2398|       |                                    // Remove spacing between tokens to avoid visual gaps
 2399|      0|                                    ui.spacing_mut().item_spacing.x = 0.0;
 2400|      0|                                    for (style, text) in ranges {
 2401|       |                                        // Drop newline characters completely; they're handled by the outer line loop
 2402|      0|                                        let cleaned = text.replace(['\n', '\r'], "");
 2403|       |
 2404|      0|                                        if cleaned.is_empty() {
 2405|      0|                                            continue;
 2406|      0|                                        }
 2407|       |
 2408|       |                                        // Check if this token is pure whitespace (spaces or tabs only)
 2409|      0|                                        if cleaned.chars().all(|c| c == ' ' || c == '\t') {
 2410|      0|                                            // Render whitespace as transparent to preserve layout without visual gaps
 2411|      0|                                            ui.label(
 2412|      0|                                                RichText::new(cleaned)
 2413|      0|                                                    .size(self.font_sizes.code)
 2414|      0|                                                    .color(Color32::TRANSPARENT)
 2415|      0|                                                    .family(egui::FontFamily::Monospace),
 2416|      0|                                            );
 2417|      0|                                        } else {
 2418|       |                                            // For non-whitespace, use normal highlighting but replace spaces with transparent ones
 2419|      0|                                            let color = Color32::from_rgb(
 2420|      0|                                                style.foreground.r,
 2421|      0|                                                style.foreground.g,
 2422|      0|                                                style.foreground.b,
 2423|       |                                            );
 2424|       |
 2425|       |                                            // Split by spaces and handle separately
 2426|      0|                                            let parts: Vec<&str> = cleaned.split(' ').collect();
 2427|      0|                                            for (i, part) in parts.iter().enumerate() {
 2428|      0|                                                if !part.is_empty() {
 2429|      0|                                                    let mut rich_text = RichText::new(*part)
 2430|      0|                                                        .size(self.font_sizes.code)
 2431|      0|                                                        .color(color)
 2432|      0|                                                        .family(egui::FontFamily::Monospace);
 2433|       |
 2434|      0|                                                    if style.font_style.contains(
 2435|       |                                                        syntect::highlighting::FontStyle::BOLD,
 2436|      0|                                                    ) {
 2437|      0|                                                        rich_text = rich_text.strong();
 2438|      0|                                                    }
 2439|      0|                                                    if style.font_style.contains(
 2440|       |                                                        syntect::highlighting::FontStyle::ITALIC,
 2441|      0|                                                    ) {
 2442|      0|                                                        rich_text = rich_text.italics();
 2443|      0|                                                    }
 2444|       |
 2445|      0|                                                    ui.label(rich_text);
 2446|      0|                                                }
 2447|       |
 2448|       |                                                // Add transparent space between parts (except after last part)
 2449|      0|                                                if i < parts.len() - 1 {
 2450|      0|                                                    ui.label(
 2451|      0|                                                        RichText::new(" ")
 2452|      0|                                                            .size(self.font_sizes.code)
 2453|      0|                                                            .color(Color32::TRANSPARENT)
 2454|      0|                                                            .family(egui::FontFamily::Monospace),
 2455|      0|                                                    );
 2456|      0|                                                }
 2457|       |                                            }
 2458|       |                                        }
 2459|       |                                    }
 2460|      0|                                });
 2461|       |                            }
 2462|      0|                            return; // Early return if highlighting succeeded
 2463|      0|                        }
 2464|      0|                    }
 2465|       |
 2466|       |                    // Fallback: render as plain text
 2467|      0|                    ui.label(
 2468|      0|                        RichText::new(code)
 2469|      0|                            .size(self.font_sizes.code)
 2470|      0|                            .color(Color32::from_rgb(220, 220, 220))
 2471|      0|                            .family(egui::FontFamily::Monospace),
 2472|       |                    );
 2473|      0|                });
 2474|      0|            });
 2475|       |
 2476|       |        // Add context menu for code blocks
 2477|      0|        frame_response.response.context_menu(|ui| {
 2478|      0|            if ui.button("Copy Code").clicked() {
 2479|      0|                ui.ctx().copy_text(code.to_string());
 2480|      0|                ui.close_menu();
 2481|      0|            }
 2482|      0|            if let Some(lang) = language {
 2483|      0|                if ui.button(format!("Copy as {}", lang)).clicked() {
 2484|      0|                    // Include language identifier for better pasting
 2485|      0|                    ui.ctx().copy_text(format!("```{}\n{}\n```", lang, code));
 2486|      0|                    ui.close_menu();
 2487|      0|                }
 2488|      0|            }
 2489|      0|        });
 2490|       |
 2491|      0|        ui.add_space(8.0);
 2492|      0|    }
 2493|       |
 2494|       |    /// Try to render a Mermaid diagram. Returns true if handled (rendered or placeholder drawn).
 2495|      0|    fn render_mermaid_block(&self, ui: &mut egui::Ui, code: &str) -> bool {
 2496|       |        // First, drain any completed Kroki jobs into local caches.
 2497|      0|        self.poll_kroki_results();
 2498|       |
 2499|       |        // If QuickJS feature is enabled, attempt rendering to SVG then rasterize like normal SVG.
 2500|       |        #[cfg(feature = "mermaid-quickjs")]
 2501|       |        {
 2502|       |            let key = Self::hash_str(code);
 2503|       |            if self.mermaid_failed.borrow().contains(&key) {
 2504|       |                // Previously failed; show brief diagnostics and bail
 2505|       |                let bytes = mermaid_embed::MERMAID_JS.len();
 2506|       |                let last = self.mermaid_last_error.borrow().clone().unwrap_or_default();
 2507|       |                egui::Frame::none().inner_margin(4.0).show(ui, |ui| {
 2508|       |                    ui.label(
 2509|       |                        RichText::new(format!(
 2510|       |                            "Mermaid skipped (prev fail). Bytes:{} Hash:{:016x}\n{}",
 2511|       |                            bytes, key, last
 2512|       |                        ))
 2513|       |                        .family(egui::FontFamily::Monospace)
 2514|       |                        .size(self.font_sizes.code),
 2515|       |                    );
 2516|       |                });
 2517|       |                return true;
 2518|       |            } else if let Some(tex) = self.get_or_load_mermaid_texture(ui, code) {
 2519|       |                let size = tex.size();
 2520|       |                let (tw, th) = (size[0] as f32, size[1] as f32);
 2521|       |                let available_w = ui.available_width().max(1.0);
 2522|       |                let base_scale = self.ui_scale();
 2523|       |                let scaled_w = tw * base_scale;
 2524|       |                let scale = if scaled_w > available_w {
 2525|       |                    (available_w / tw).clamp(0.01, 4.0)
 2526|       |                } else {
 2527|       |                    base_scale
 2528|       |                };
 2529|       |                let size = egui::vec2((tw * scale).round(), (th * scale).round());
 2530|       |                ui.add(egui::Image::new(&tex).fit_to_exact_size(size));
 2531|       |                return true;
 2532|       |            } else {
 2533|       |                // Mark as failed to avoid repeated attempts causing jank
 2534|       |                self.mermaid_failed.borrow_mut().insert(key);
 2535|       |                let bytes = mermaid_embed::MERMAID_JS.len();
 2536|       |                let last = self
 2537|       |                    .mermaid_last_error
 2538|       |                    .borrow()
 2539|       |                    .clone()
 2540|       |                    .unwrap_or_else(|| "unknown error".to_string());
 2541|       |                egui::Frame::none()
 2542|       |                    .fill(Color32::from_rgb(25, 25, 25))
 2543|       |                    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2544|       |                    .inner_margin(8.0)
 2545|       |                    .show(ui, |ui| {
 2546|       |                        ui.label(
 2547|       |                            RichText::new("Mermaid render failed; showing source.")
 2548|       |                                .color(Color32::from_rgb(200, 160, 80)),
 2549|       |                        );
 2550|       |                        ui.label(
 2551|       |                            RichText::new(format!(
 2552|       |                                "Embedded bytes:{}\nHash:{:016x}\nError:{}",
 2553|       |                                bytes, key, last
 2554|       |                            ))
 2555|       |                            .family(egui::FontFamily::Monospace)
 2556|       |                            .size(self.font_sizes.code)
 2557|       |                            .color(Color32::from_rgb(180, 180, 180)),
 2558|       |                        );
 2559|       |                    });
 2560|       |                // fall through to code block rendering
 2561|       |            }
 2562|       |        }
 2563|       |
 2564|       |        // Default path: render via Kroki service (non-blocking)
 2565|      0|        let key = Self::hash_str(code);
 2566|       |
 2567|      0|        if !Self::kroki_enabled() {
 2568|      0|            egui::Frame::none()
 2569|      0|                .fill(Color32::from_rgb(25, 25, 25))
 2570|      0|                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2571|      0|                .inner_margin(8.0)
 2572|      0|                .show(ui, |ui| {
 2573|      0|                    ui.label(
 2574|      0|                        RichText::new("Mermaid rendering via Kroki is disabled. Set MDMDVIEW_ENABLE_KROKI=1 to enable network rendering.")
 2575|      0|                            .color(Color32::from_rgb(200, 160, 80))
 2576|      0|                            .family(egui::FontFamily::Monospace)
 2577|      0|                            .size(self.font_sizes.code),
 2578|       |                    );
 2579|      0|                });
 2580|      0|            return false;
 2581|      0|        }
 2582|       |        // If we already have an SVG for this diagram, rasterize to a texture and draw it
 2583|      0|        if let Some(img_bytes) = self.kroki_svg_cache.borrow().get(&key) {
 2584|       |            // Use a width-bucketed texture cache key to avoid re-rasterizing too often
 2585|      0|            let width_bucket = (ui.available_width().ceil() as u32) / 32 * 32;
 2586|      0|            let cache_key = format!("mermaid:{}:w{}", key, width_bucket);
 2587|      0|            if let Some(entry) = self.image_textures.borrow().get(&cache_key) {
 2588|      0|                let tex = entry.texture.clone();
 2589|      0|                let (tw, th) = (entry.size[0] as f32, entry.size[1] as f32);
 2590|      0|                let available_w = ui.available_width().max(1.0);
 2591|      0|                let base_scale = self.ui_scale();
 2592|      0|                let scaled_w = tw * base_scale;
 2593|      0|                let scale = if scaled_w > available_w {
 2594|      0|                    (available_w / tw).clamp(0.01, 4.0)
 2595|       |                } else {
 2596|      0|                    base_scale
 2597|       |                };
 2598|      0|                let size = egui::vec2((tw * scale).round(), (th * scale).round());
 2599|      0|                ui.add(egui::Image::new(&tex).fit_to_exact_size(size));
 2600|      0|                return true;
 2601|      0|            }
 2602|       |
 2603|       |            // Decode image bytes (prefer PNG). Fallback to SVG if not raster.
 2604|      0|            if let Some((img, w, h)) =
 2605|      0|                Self::bytes_to_color_image_guess(img_bytes, Self::mermaid_bg_fill())
 2606|       |            {
 2607|      0|                let tex =
 2608|      0|                    ui.ctx()
 2609|      0|                        .load_texture(cache_key.clone(), img, egui::TextureOptions::LINEAR);
 2610|      0|                self.store_image_texture(&cache_key, tex.clone(), [w, h], None);
 2611|       |                // Draw now
 2612|      0|                let (tw, th) = (w as f32, h as f32);
 2613|      0|                let available_w = ui.available_width().max(1.0);
 2614|      0|                let base_scale = self.ui_scale();
 2615|      0|                let scaled_w = tw * base_scale;
 2616|      0|                let scale = if scaled_w > available_w {
 2617|      0|                    (available_w / tw).clamp(0.01, 4.0)
 2618|       |                } else {
 2619|      0|                    base_scale
 2620|       |                };
 2621|      0|                let size = egui::vec2((tw * scale).round(), (th * scale).round());
 2622|      0|                ui.add(egui::Image::new(&tex).fit_to_exact_size(size));
 2623|      0|                return true;
 2624|      0|            } else {
 2625|      0|                // Decode failed; record error and fall through to message/source
 2626|      0|                self.kroki_errors
 2627|      0|                    .borrow_mut()
 2628|      0|                    .insert(key, "Failed to decode diagram bytes".to_string());
 2629|      0|            }
 2630|      0|        }
 2631|       |
 2632|       |        // If there was a prior error, show diagnostics and let caller show source
 2633|      0|        if let Some(err) = self.kroki_errors.borrow().get(&key) {
 2634|      0|            egui::Frame::none()
 2635|      0|                .fill(Color32::from_rgb(25, 25, 25))
 2636|      0|                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2637|      0|                .inner_margin(8.0)
 2638|      0|                .show(ui, |ui| {
 2639|      0|                    ui.label(
 2640|      0|                        RichText::new(format!(
 2641|      0|                            "Mermaid render failed via Kroki; showing source.\n{}",
 2642|       |                            err
 2643|       |                        ))
 2644|      0|                        .color(Color32::from_rgb(200, 160, 80)),
 2645|       |                    );
 2646|      0|                });
 2647|      0|            return false; // let caller render the source block
 2648|      0|        }
 2649|       |
 2650|       |        // If no job is pending, enqueue one for the worker pool
 2651|      0|        let should_schedule = {
 2652|      0|            let pending = self.kroki_pending.borrow();
 2653|      0|            !pending.contains(&key)
 2654|       |        };
 2655|      0|        let waiting_for_slot = if should_schedule {
 2656|      0|            let inflight_before = {
 2657|      0|                let pending = self.kroki_pending.borrow();
 2658|      0|                pending.len()
 2659|       |            };
 2660|      0|            match self.spawn_kroki_job(key, code) {
 2661|       |                Ok(()) => {
 2662|      0|                    self.kroki_pending.borrow_mut().insert(key);
 2663|      0|                    ui.ctx().request_repaint();
 2664|      0|                    inflight_before >= Self::MAX_KROKI_JOBS
 2665|       |                }
 2666|       |                Err(KrokiEnqueueError::QueueFull) => {
 2667|      0|                    ui.ctx().request_repaint();
 2668|      0|                    true
 2669|       |                }
 2670|       |                Err(KrokiEnqueueError::Disconnected) => {
 2671|      0|                    self.kroki_errors
 2672|      0|                        .borrow_mut()
 2673|      0|                        .insert(key, "Mermaid worker pool unavailable".to_string());
 2674|      0|                    return false;
 2675|       |                }
 2676|       |            }
 2677|       |        } else {
 2678|      0|            let pending = self.kroki_pending.borrow();
 2679|      0|            pending.len() >= Self::MAX_KROKI_JOBS
 2680|       |        };
 2681|       |
 2682|      0|        let inflight_count = self.kroki_pending.borrow().len();
 2683|       |
 2684|       |        // Show placeholder while rendering or waiting for an available worker
 2685|      0|        egui::Frame::none()
 2686|      0|            .fill(Color32::from_rgb(25, 25, 25))
 2687|      0|            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2688|      0|            .inner_margin(8.0)
 2689|      0|            .show(ui, |ui| {
 2690|      0|                let url = self.kroki_base_url();
 2691|      0|                if waiting_for_slot {
 2692|      0|                    ui.label(
 2693|      0|                        RichText::new(format!(
 2694|      0|                            "Mermaid workers busy ({}/{}) - request queued.",
 2695|      0|                            inflight_count,
 2696|      0|                            Self::MAX_KROKI_JOBS
 2697|      0|                        ))
 2698|      0|                        .color(Color32::from_rgb(200, 160, 80))
 2699|      0|                        .family(egui::FontFamily::Monospace)
 2700|      0|                        .size(self.font_sizes.code),
 2701|      0|                    );
 2702|      0|                    ui.label(
 2703|      0|                        RichText::new(format!("Queue target: {}", url))
 2704|      0|                            .color(Color32::from_rgb(160, 200, 240)),
 2705|      0|                    );
 2706|      0|                } else {
 2707|      0|                    ui.label(
 2708|      0|                        RichText::new(format!("Rendering diagram via Kroki...\n{}", url))
 2709|      0|                            .color(Color32::from_rgb(160, 200, 240)),
 2710|      0|                    );
 2711|      0|                }
 2712|      0|            });
 2713|      0|        true
 2714|      0|    }
 2715|       |
 2716|       |    #[cfg(feature = "mermaid-quickjs")]
 2717|       |    fn render_mermaid_to_svg_string(&self, code: &str) -> Option<String> {
 2718|       |        use rquickjs::{Context, Function, Runtime};
 2719|       |        // Quick check
 2720|       |        if mermaid_embed::MERMAID_JS.is_empty() {
 2721|       |            self.mermaid_last_error
 2722|       |                .borrow_mut()
 2723|       |                .replace("No embedded Mermaid JS".to_string());
 2724|       |            return None;
 2725|       |        }
 2726|       |        // Initialize engine once
 2727|       |        if self.mermaid_engine.borrow().is_none() {
 2728|       |            let rt = Runtime::new().ok()?;
 2729|       |            let ctx = Context::full(&rt).ok()?;
 2730|       |            let engine = MermaidEngine { rt, ctx };
 2731|       |            // Load library and shim
 2732|       |            let _ = engine.ctx.with(|ctx| {
 2733|       |                let shim = r#"
 2734|       |                    var window = globalThis;
 2735|       |                    var document = {
 2736|       |                      body: {},
 2737|       |                      createElement: function(tag){
 2738|       |                        return {
 2739|       |                          innerHTML: '',
 2740|       |                          setAttribute: function(){},
 2741|       |                          getAttribute: function(){ return null; },
 2742|       |                          appendChild: function(){},
 2743|       |                          querySelector: function(){ return null; },
 2744|       |                        };
 2745|       |                      },
 2746|       |                      createElementNS: function(ns, tag){ return this.createElement(tag); },
 2747|       |                      getElementById: function(){ return null; },
 2748|       |                      querySelector: function(){ return null; },
 2749|       |                    };
 2750|       |                    window.document = document;
 2751|       |                    // Minimal timers and raf
 2752|       |                    window.setTimeout = function(fn, ms){ fn(); return 1; };
 2753|       |                    window.clearTimeout = function(id){};
 2754|       |                    window.requestAnimationFrame = function(fn){ fn(0); return 1; };
 2755|       |                    window.performance = { now: function(){ return 0; } };
 2756|       |                "#;
 2757|       |                if let Err(e) = ctx.eval::<(), _>(shim) {
 2758|       |                    self.mermaid_last_error
 2759|       |                        .borrow_mut()
 2760|       |                        .replace(format!("Shim error: {}", e));
 2761|       |                }
 2762|       |                if let Ok(js) = std::str::from_utf8(mermaid_embed::MERMAID_JS) {
 2763|       |                    if let Err(e) = ctx.eval::<(), _>(js) {
 2764|       |                        self.mermaid_last_error
 2765|       |                            .borrow_mut()
 2766|       |                            .replace(format!("Mermaid eval error: {}", e));
 2767|       |                    }
 2768|       |                    if let Err(e) = ctx.eval::<(), _>(
 2769|       |                        r#"if (window.mermaid && mermaid.mermaidAPI) {
 2770|       |                               mermaid.mermaidAPI.initialize({startOnLoad: false, securityLevel: 'loose'});
 2771|       |                           } else { throw new Error('Mermaid not available'); }
 2772|       |                        "#,
 2773|       |                    ) {
 2774|       |                        self.mermaid_last_error
 2775|       |                            .borrow_mut()
 2776|       |                            .replace(format!("Mermaid init error: {}", e));
 2777|       |                    }
 2778|       |                }
 2779|       |                Ok::<(), ()>(())
 2780|       |            });
 2781|       |            self.mermaid_engine.borrow_mut().replace(engine);
 2782|       |            // One-time log for diagnostics
 2783|       |            if !*self.mermaid_init_logged.borrow() {
 2784|       |                eprintln!(
 2785|       |                    "Mermaid embedded bytes: {}",
 2786|       |                    mermaid_embed::MERMAID_JS.len()
 2787|       |                );
 2788|       |                *self.mermaid_init_logged.borrow_mut() = true;
 2789|       |            }
 2790|       |        }
 2791|       |
 2792|       |        // Use cache if available
 2793|       |        let key = Self::hash_str(code);
 2794|       |        if let Some(svg) = self.mermaid_svg_cache.borrow().get(&key) {
 2795|       |            return Some(svg.clone());
 2796|       |        }
 2797|       |
 2798|       |        // Render fresh
 2799|       |        let svg = self.mermaid_engine.borrow().as_ref().and_then(|engine| {
 2800|       |            engine.ctx.with(|ctx| {
 2801|       |                // Minimal DOM shim sufficient for mermaid.mermaidAPI.render
 2802|       |                let wrapper = r#"
 2803|       |                (function(id, code){
 2804|       |                    var svgOut = null;
 2805|       |                    mermaid.mermaidAPI.render(id, code, function(svg){ svgOut = svg; });
 2806|       |                    if (typeof svgOut !== 'string' || svgOut.length === 0) {
 2807|       |                        throw new Error('Mermaid render returned empty');
 2808|       |                    }
 2809|       |                    return svgOut;
 2810|       |                })
 2811|       |            "#;
 2812|       |                let func: Function = match ctx.eval(wrapper) {
 2813|       |                    Ok(f) => f,
 2814|       |                    Err(e) => {
 2815|       |                        self.mermaid_last_error
 2816|       |                            .borrow_mut()
 2817|       |                            .replace(format!("Wrapper eval error: {}", e));
 2818|       |                        return None;
 2819|       |                    }
 2820|       |                };
 2821|       |                let id = format!("m{:016x}", key);
 2822|       |                let svg: String = match func.call((id.as_str(), code)) {
 2823|       |                    Ok(s) => s,
 2824|       |                    Err(e) => {
 2825|       |                        self.mermaid_last_error
 2826|       |                            .borrow_mut()
 2827|       |                            .replace(format!("Mermaid call error: {}", e));
 2828|       |                        return None;
 2829|       |                    }
 2830|       |                };
 2831|       |                Some(svg)
 2832|       |            })
 2833|       |        });
 2834|       |        if let Some(svg) = svg {
 2835|       |            self.mermaid_svg_cache.borrow_mut().insert(key, svg.clone());
 2836|       |            self.mermaid_last_error.borrow_mut().take();
 2837|       |            return Some(svg);
 2838|       |        }
 2839|       |        self.mermaid_last_error
 2840|       |            .borrow_mut()
 2841|       |            .replace("Mermaid render produced no SVG".to_string());
 2842|       |        None
 2843|       |    }
 2844|       |
 2845|       |    #[cfg(feature = "mermaid-quickjs")]
 2846|       |    fn get_or_load_mermaid_texture(
 2847|       |        &self,
 2848|       |        ui: &egui::Ui,
 2849|       |        code: &str,
 2850|       |    ) -> Option<egui::TextureHandle> {
 2851|       |        let key = Self::hash_str(code);
 2852|       |        let width_bucket = (ui.available_width().ceil() as u32).saturating_sub(0) / 16 * 16;
 2853|       |        let cache_key = format!("mermaid:{}:w{}", key, width_bucket);
 2854|       |        if let Some(entry) = self.image_textures.borrow().get(&cache_key) {
 2855|       |            return Some(entry.texture.clone());
 2856|       |        }
 2857|       |        let svg = self.render_mermaid_to_svg_string(code)?;
 2858|       |        let (img, w, h) = Self::svg_bytes_to_color_image(svg.as_bytes())?;
 2859|       |        let tex = ui
 2860|       |            .ctx()
 2861|       |            .load_texture(cache_key.clone(), img, egui::TextureOptions::LINEAR);
 2862|       |        self.store_image_texture(&cache_key, tex.clone(), [w, h], None);
 2863|       |        Some(tex)
 2864|       |    }
 2865|       |
 2866|      0|    fn hash_str(s: &str) -> u64 {
 2867|      0|        let mut h = DefaultHasher::new();
 2868|      0|        s.hash(&mut h);
 2869|      0|        h.finish()
 2870|      0|    }
 2871|       |
 2872|      4|    fn hash_inline_spans(spans: &[InlineSpan]) -> u64 {
 2873|      4|        let mut h = DefaultHasher::new();
 2874|      8|        for span in spans {
                          ^4
 2875|      4|            match span {
 2876|      4|                InlineSpan::Text(t) => {
 2877|      4|                    0u8.hash(&mut h);
 2878|      4|                    t.hash(&mut h);
 2879|      4|                }
 2880|      0|                InlineSpan::Code(t) => {
 2881|      0|                    1u8.hash(&mut h);
 2882|      0|                    t.hash(&mut h);
 2883|      0|                }
 2884|      0|                InlineSpan::Strong(t) => {
 2885|      0|                    2u8.hash(&mut h);
 2886|      0|                    t.hash(&mut h);
 2887|      0|                }
 2888|      0|                InlineSpan::Emphasis(t) => {
 2889|      0|                    3u8.hash(&mut h);
 2890|      0|                    t.hash(&mut h);
 2891|      0|                }
 2892|      0|                InlineSpan::Strikethrough(t) => {
 2893|      0|                    4u8.hash(&mut h);
 2894|      0|                    t.hash(&mut h);
 2895|      0|                }
 2896|      0|                InlineSpan::Link { text, url } => {
 2897|      0|                    5u8.hash(&mut h);
 2898|      0|                    text.hash(&mut h);
 2899|      0|                    url.hash(&mut h);
 2900|      0|                }
 2901|      0|                InlineSpan::Image { src, alt, title } => {
 2902|      0|                    6u8.hash(&mut h);
 2903|      0|                    src.hash(&mut h);
 2904|      0|                    alt.hash(&mut h);
 2905|      0|                    title.hash(&mut h);
 2906|      0|                }
 2907|       |            }
 2908|       |        }
 2909|      4|        h.finish()
 2910|      4|    }
 2911|       |
 2912|      2|    fn compute_table_id(
 2913|      2|        &self,
 2914|      2|        headers: &[Vec<InlineSpan>],
 2915|      2|        rows: &[Vec<Vec<InlineSpan>>],
 2916|      2|        element_index: usize,
 2917|      2|    ) -> u64 {
 2918|      2|        let mut hasher = DefaultHasher::new();
 2919|      2|        if let Some(base) = self.base_dir.borrow().as_ref() {
                                  ^0
 2920|      0|            base.hash(&mut hasher);
 2921|      2|        }
 2922|      2|        hasher.write_usize(element_index);
 2923|      2|        hasher.write_u64(self.compute_table_content_hash(headers, rows));
 2924|      2|        hasher.finish()
 2925|      2|    }
 2926|       |
 2927|      2|    fn compute_table_content_hash(
 2928|      2|        &self,
 2929|      2|        headers: &[Vec<InlineSpan>],
 2930|      2|        rows: &[Vec<Vec<InlineSpan>>],
 2931|      2|    ) -> u64 {
 2932|      2|        let mut hasher = DefaultHasher::new();
 2933|      2|        hasher.write_usize(headers.len());
 2934|      4|        for header in headers {
                          ^2
 2935|      2|            hasher.write_u64(Self::hash_inline_spans(header));
 2936|      2|        }
 2937|      2|        let mut counted = 0usize;
 2938|      4|        for row in rows {
                          ^2
 2939|      4|            for cell in row {
                              ^2
 2940|      2|                hasher.write_u64(Self::hash_inline_spans(cell));
 2941|      2|            }
 2942|      2|            counted += 1;
 2943|      2|            if counted >= COLUMN_STATS_SAMPLE_ROWS {
 2944|      0|                break;
 2945|      2|            }
 2946|       |        }
 2947|      2|        hasher.finish()
 2948|      2|    }
 2949|       |
 2950|      0|    fn column_stats_for_table(
 2951|      0|        &self,
 2952|      0|        table_id: u64,
 2953|      0|        headers: &[Vec<InlineSpan>],
 2954|      0|        rows: &[Vec<Vec<InlineSpan>>],
 2955|      0|    ) -> Vec<ColumnStat> {
 2956|      0|        let content_hash = self.compute_table_content_hash(headers, rows);
 2957|      0|        if let Some(entry) = self
 2958|      0|            .column_stats_cache
 2959|      0|            .borrow()
 2960|      0|            .get(&table_id)
 2961|      0|            .filter(|entry| entry.content_hash == content_hash)
 2962|       |        {
 2963|      0|            return entry.stats.clone();
 2964|      0|        }
 2965|      0|        let stats = compute_column_stats(headers, rows, COLUMN_STATS_SAMPLE_ROWS);
 2966|      0|        self.column_stats_cache.borrow_mut().insert(
 2967|      0|            table_id,
 2968|      0|            ColumnStatsCacheEntry {
 2969|      0|                content_hash,
 2970|      0|                stats: stats.clone(),
 2971|      0|            },
 2972|      0|        );
 2973|      0|        stats
 2974|      0|    }
 2975|       |
 2976|       |    // Drain any completed Kroki jobs and cache their results
 2977|      0|    fn poll_kroki_results(&self) {
 2978|       |        loop {
 2979|      0|            match self.kroki_rx.try_recv() {
 2980|      0|                Ok((key, Ok(svg))) => {
 2981|      0|                    self.kroki_svg_cache.borrow_mut().insert(key, svg);
 2982|      0|                    self.kroki_pending.borrow_mut().remove(&key);
 2983|      0|                }
 2984|      0|                Ok((key, Err(err))) => {
 2985|      0|                    self.kroki_errors.borrow_mut().insert(key, err);
 2986|      0|                    self.kroki_pending.borrow_mut().remove(&key);
 2987|      0|                }
 2988|      0|                Err(std::sync::mpsc::TryRecvError::Empty) => break,
 2989|      0|                Err(std::sync::mpsc::TryRecvError::Disconnected) => break,
 2990|       |            }
 2991|       |        }
 2992|      0|    }
 2993|       |
 2994|      3|    fn kroki_enabled() -> bool {
 2995|      3|        match std::env::var("MDMDVIEW_ENABLE_KROKI") {
 2996|      2|            Ok(value) => {
 2997|      2|                let normalized = value.trim().to_ascii_lowercase();
 2998|      2|                matches!(normalized.as_str(), "1" | "true" | "yes" | "on")
                              ^1                                           ^1      ^1
 2999|       |            }
 3000|      1|            Err(_) => false,
 3001|       |        }
 3002|      3|    }
 3003|       |
 3004|       |    #[cfg(test)]
 3005|      3|    pub(crate) fn kroki_enabled_for_tests() -> bool {
 3006|      3|        Self::kroki_enabled()
 3007|      3|    }
 3008|       |
 3009|      2|    fn kroki_base_url(&self) -> String {
 3010|      2|        std::env::var("MDMDVIEW_KROKI_URL").unwrap_or_else(|_| "https://kroki.io".to_string())
 3011|      2|    }
 3012|       |
 3013|      0|    fn perform_kroki_with_agent(
 3014|      0|        agent: &ureq::Agent,
 3015|      0|        url: &str,
 3016|      0|        payload: &str,
 3017|      0|    ) -> Result<Vec<u8>, String> {
 3018|      0|        let resp = agent
 3019|      0|            .post(url)
 3020|      0|            .set("Content-Type", "text/plain")
 3021|      0|            .send_string(payload)
 3022|      0|            .map_err(|e| format!("ureq error: {}", e))?;
 3023|      0|        if resp.status() >= 200 && resp.status() < 300 {
 3024|      0|            let mut bytes: Vec<u8> = Vec::new();
 3025|      0|            let mut reader = resp.into_reader();
 3026|       |            use std::io::Read as _;
 3027|      0|            reader
 3028|      0|                .read_to_end(&mut bytes)
 3029|      0|                .map_err(|e| format!("read body: {}", e))?;
 3030|      0|            if bytes.is_empty() {
 3031|      0|                return Err("Empty SVG from Kroki".to_string());
 3032|      0|            }
 3033|      0|            Ok(bytes)
 3034|       |        } else {
 3035|      0|            Err(format!("HTTP {} from Kroki", resp.status()))
 3036|       |        }
 3037|      0|    }
 3038|       |
 3039|      2|    fn spawn_kroki_job(&self, key: u64, code: &str) -> Result<(), KrokiEnqueueError> {
 3040|       |        // Prefer PNG to avoid client-side SVG CSS/foreignObject limitations
 3041|      2|        let url = format!("{}/mermaid/png", self.kroki_base_url());
 3042|      2|        let payload = self.wrap_mermaid_theme(code);
 3043|      2|        match self
 3044|      2|            .kroki_job_tx
 3045|      2|            .try_send(KrokiRequest { key, url, payload })
 3046|       |        {
 3047|      0|            Ok(()) => Ok(()),
 3048|      1|            Err(TrySendError::Full(_)) => Err(KrokiEnqueueError::QueueFull),
 3049|      1|            Err(TrySendError::Disconnected(_)) => Err(KrokiEnqueueError::Disconnected),
 3050|       |        }
 3051|      2|    }
 3052|       |
 3053|      2|    fn wrap_mermaid_theme(&self, code: &str) -> String {
 3054|       |        // If user already provided an init block, respect it
 3055|      2|        if code.contains("%%{") && code.contains("}%%") && code.contains("init") {
                                                 ^0   ^0                 ^0   ^0
 3056|      0|            return code.to_string();
 3057|      2|        }
 3058|       |        // Pastel palette defaults (nice contrast on dark/light UIs)
 3059|      2|        let def_main_bkg = "#FFF8DB"; // soft warm yellow
 3060|      2|        let def_primary = "#D7EEFF"; // pastel blue (nodes)
 3061|      2|        let def_primary_border = "#9BB2C8"; // muted blue border
 3062|      2|        let def_primary_text = "#1C2430"; // dark slate text
 3063|      2|        let def_secondary = "#DFF5E1"; // pastel green
 3064|      2|        let def_tertiary = "#E9E2FF"; // pastel lavender
 3065|      2|        let def_line = "#6B7A90"; // slate lines/arrows
 3066|      2|        let def_text = "#1C2430"; // general text
 3067|      2|        let def_cluster_bkg = "#FFF1C1"; // soft yellow, slightly deeper
 3068|      2|        let def_cluster_border = "#E5C07B"; // golden
 3069|      2|        let def_default_link = def_line;
 3070|      2|        let def_title = def_text;
 3071|      2|        let def_label_bg = def_main_bkg;
 3072|      2|        let def_edge_label_bg = def_main_bkg;
 3073|       |
 3074|       |        // Allow overrides via env vars (keep defaults above if absent)
 3075|      2|        let theme_name =
 3076|      2|            std::env::var("MDMDVIEW_MERMAID_THEME").unwrap_or_else(|_| "base".to_string());
 3077|      2|        let main_bkg =
 3078|      2|            std::env::var("MDMDVIEW_MERMAID_MAIN_BKG").unwrap_or_else(|_| def_main_bkg.to_string());
 3079|      2|        let primary = std::env::var("MDMDVIEW_MERMAID_PRIMARY_COLOR")
 3080|      2|            .unwrap_or_else(|_| def_primary.to_string());
 3081|      2|        let primary_border = std::env::var("MDMDVIEW_MERMAID_PRIMARY_BORDER")
 3082|      2|            .unwrap_or_else(|_| def_primary_border.to_string());
 3083|      2|        let primary_text = std::env::var("MDMDVIEW_MERMAID_PRIMARY_TEXT")
 3084|      2|            .unwrap_or_else(|_| def_primary_text.to_string());
 3085|      2|        let secondary = std::env::var("MDMDVIEW_MERMAID_SECONDARY_COLOR")
 3086|      2|            .unwrap_or_else(|_| def_secondary.to_string());
 3087|      2|        let tertiary = std::env::var("MDMDVIEW_MERMAID_TERTIARY_COLOR")
 3088|      2|            .unwrap_or_else(|_| def_tertiary.to_string());
 3089|      2|        let line =
 3090|      2|            std::env::var("MDMDVIEW_MERMAID_LINE_COLOR").unwrap_or_else(|_| def_line.to_string());
 3091|      2|        let text =
 3092|      2|            std::env::var("MDMDVIEW_MERMAID_TEXT_COLOR").unwrap_or_else(|_| def_text.to_string());
 3093|      2|        let cluster_bkg = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BKG")
 3094|      2|            .unwrap_or_else(|_| def_cluster_bkg.to_string());
 3095|      2|        let cluster_border = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BORDER")
 3096|      2|            .unwrap_or_else(|_| def_cluster_border.to_string());
 3097|      2|        let default_link = std::env::var("MDMDVIEW_MERMAID_LINK_COLOR")
 3098|      2|            .unwrap_or_else(|_| def_default_link.to_string());
 3099|      2|        let title =
 3100|      2|            std::env::var("MDMDVIEW_MERMAID_TITLE_COLOR").unwrap_or_else(|_| def_title.to_string());
 3101|      2|        let label_bg =
 3102|      2|            std::env::var("MDMDVIEW_MERMAID_LABEL_BG").unwrap_or_else(|_| def_label_bg.to_string());
 3103|      2|        let edge_label_bg = std::env::var("MDMDVIEW_MERMAID_EDGE_LABEL_BG")
 3104|      2|            .unwrap_or_else(|_| def_edge_label_bg.to_string());
 3105|       |
 3106|      2|        let theme = format!(
 3107|      2|            concat!(
 3108|       |                "%%{{init: {{\"theme\": \"{}\", \"themeVariables\": {{",
 3109|       |                "\"background\": \"{}\", ",
 3110|       |                "\"mainBkg\": \"{}\", ",
 3111|       |                "\"textColor\": \"{}\", ",
 3112|       |                "\"titleColor\": \"{}\", ",
 3113|       |                "\"primaryColor\": \"{}\", ",
 3114|       |                "\"primaryBorderColor\": \"{}\", ",
 3115|       |                "\"primaryTextColor\": \"{}\", ",
 3116|       |                "\"secondaryColor\": \"{}\", ",
 3117|       |                "\"tertiaryColor\": \"{}\", ",
 3118|       |                "\"lineColor\": \"{}\", ",
 3119|       |                "\"defaultLinkColor\": \"{}\", ",
 3120|       |                "\"clusterBkg\": \"{}\", ",
 3121|       |                "\"clusterBorder\": \"{}\", ",
 3122|       |                "\"labelBackground\": \"{}\", ",
 3123|       |                "\"edgeLabelBackground\": \"{}\"",
 3124|       |                "}} }}%%\n"
 3125|       |            ),
 3126|       |            theme_name,
 3127|       |            main_bkg,
 3128|       |            main_bkg,
 3129|       |            text,
 3130|       |            title,
 3131|       |            primary,
 3132|       |            primary_border,
 3133|       |            primary_text,
 3134|       |            secondary,
 3135|       |            tertiary,
 3136|       |            line,
 3137|       |            default_link,
 3138|       |            cluster_bkg,
 3139|       |            cluster_border,
 3140|       |            label_bg,
 3141|       |            edge_label_bg
 3142|       |        );
 3143|      2|        format!("{}{}", theme, code)
 3144|      2|    }
 3145|       |
 3146|       |    // Choose background fill for Mermaid rasterization, based on env
 3147|      0|    fn mermaid_bg_fill() -> Option<[u8; 4]> {
 3148|       |        // Preferred: explicit color
 3149|      0|        if let Ok(hex) = std::env::var("MDMDVIEW_MERMAID_BG_COLOR") {
 3150|      0|            if let Some(rgba) = Self::parse_hex_color(&hex) {
 3151|      0|                return Some(rgba);
 3152|      0|            }
 3153|      0|        }
 3154|       |        // Mode selector; default to the theme's main background
 3155|      0|        let mode = std::env::var("MDMDVIEW_MERMAID_BG").unwrap_or_else(|_| "theme".to_string());
 3156|      0|        match mode.as_str() {
 3157|      0|            "transparent" => None,
 3158|      0|            "dark" => Some([20, 20, 20, 255]),
 3159|      0|            "light" => Some([255, 255, 255, 255]),
 3160|       |            _ /* theme */ => {
 3161|      0|                let hex = std::env::var("MDMDVIEW_MERMAID_MAIN_BKG").unwrap_or_else(|_| "#FFF8DB".to_string());
 3162|      0|                Self::parse_hex_color(&hex).or(Some([255, 248, 219, 255]))
 3163|       |            }
 3164|       |        }
 3165|      0|    }
 3166|       |
 3167|      0|    fn parse_hex_color(s: &str) -> Option<[u8; 4]> {
 3168|      0|        let t = s.trim();
 3169|      0|        let hex = t.strip_prefix('#').unwrap_or(t);
 3170|      0|        let (r, g, b, a) = match hex.len() {
 3171|       |            6 => (
 3172|      0|                u8::from_str_radix(&hex[0..2], 16).ok()?,
 3173|      0|                u8::from_str_radix(&hex[2..4], 16).ok()?,
 3174|      0|                u8::from_str_radix(&hex[4..6], 16).ok()?,
 3175|       |                255,
 3176|       |            ),
 3177|       |            8 => (
 3178|      0|                u8::from_str_radix(&hex[0..2], 16).ok()?,
 3179|      0|                u8::from_str_radix(&hex[2..4], 16).ok()?,
 3180|      0|                u8::from_str_radix(&hex[4..6], 16).ok()?,
 3181|      0|                u8::from_str_radix(&hex[6..8], 16).ok()?,
 3182|       |            ),
 3183|      0|            _ => return None,
 3184|       |        };
 3185|      0|        Some([r, g, b, a])
 3186|      0|    }
 3187|       |
 3188|       |    /// Render a table using an egui Grid
 3189|      0|    fn render_table(
 3190|      0|        &self,
 3191|      0|        ui: &mut egui::Ui,
 3192|      0|        headers: &[Vec<InlineSpan>],
 3193|      0|        rows: &[Vec<Vec<InlineSpan>>],
 3194|      0|        element_index: usize,
 3195|      0|    ) {
 3196|      0|        if headers.is_empty() {
 3197|      0|            return;
 3198|      0|        }
 3199|       |
 3200|      0|        if self.table_wrap_overhaul_enabled {
 3201|      0|            self.render_table_tablebuilder(ui, headers, rows, element_index);
 3202|      0|            ui.add_space(8.0);
 3203|      0|            return;
 3204|      0|        }
 3205|       |
 3206|      0|        ui.add_space(8.0);
 3207|       |
 3208|       |        const MIN_COL_MULTIPLIER: f32 = 6.0;
 3209|       |        const HARD_MIN_COL_WIDTH: f32 = 48.0;
 3210|       |        const MAX_WRAP_MULTIPLIER: f32 = 30.0;
 3211|       |
 3212|      0|        let min_floor = (self.font_sizes.body * MIN_COL_MULTIPLIER).max(HARD_MIN_COL_WIDTH);
 3213|      0|        let wrap_cap = (self.font_sizes.body * MAX_WRAP_MULTIPLIER).min(640.0);
 3214|       |
 3215|       |        // 1) Establish baseline widths from headers so small columns don't collapse
 3216|      0|        let min_widths: Vec<f32> = headers
 3217|      0|            .iter()
 3218|      0|            .map(|h| self.measure_inline_spans(ui, h).max(min_floor))
 3219|      0|            .collect();
 3220|      0|        if min_widths.is_empty() {
 3221|      0|            return;
 3222|      0|        }
 3223|       |
 3224|       |        // 2) Allow body cells to request more width (capped so single verbose cells don't dominate)
 3225|      0|        let mut desired_widths = min_widths.clone();
 3226|      0|        for row in rows {
 3227|      0|            for (ci, cell) in row.iter().enumerate() {
 3228|      0|                if ci >= desired_widths.len() {
 3229|      0|                    break;
 3230|      0|                }
 3231|      0|                let measured = self.measure_inline_spans(ui, cell).max(min_floor);
 3232|      0|                desired_widths[ci] = desired_widths[ci].max(measured.min(wrap_cap));
 3233|       |            }
 3234|       |        }
 3235|       |
 3236|      0|        let available = ui.available_width().max(100.0);
 3237|      0|        let widths = Self::resolve_table_widths(available, &min_widths, &desired_widths);
 3238|       |
 3239|      0|        self.render_table_legacy(ui, headers, rows, &widths);
 3240|      0|        ui.add_space(8.0);
 3241|      0|    }
 3242|       |
 3243|      0|    fn render_table_legacy(
 3244|      0|        &self,
 3245|      0|        ui: &mut egui::Ui,
 3246|      0|        headers: &[Vec<InlineSpan>],
 3247|      0|        rows: &[Vec<Vec<InlineSpan>>],
 3248|      0|        widths: &[f32],
 3249|      0|    ) {
 3250|      0|        egui::Frame::none()
 3251|      0|            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 3252|      0|            .show(ui, |ui| {
 3253|      0|                egui::Grid::new("md_table").striped(true).show(ui, |ui| {
 3254|      0|                    for (ci, h) in headers.iter().enumerate() {
 3255|      0|                        let w = widths.get(ci).copied().unwrap_or(120.0);
 3256|      0|                        ui.push_id(("header", ci), |ui| {
 3257|      0|                            ui.allocate_ui_with_layout(
 3258|      0|                                Vec2::new(w, 0.0),
 3259|      0|                                egui::Layout::top_down(egui::Align::LEFT),
 3260|      0|                                |ui| {
 3261|      0|                                    ui.set_width(w);
 3262|      0|                                    ui.set_max_width(w);
 3263|      0|                                    self.render_table_cell_spans(ui, h, w, true);
 3264|      0|                                },
 3265|       |                            );
 3266|      0|                        });
 3267|       |                    }
 3268|      0|                    ui.end_row();
 3269|       |
 3270|      0|                    for (ri, row) in rows.iter().enumerate() {
 3271|      0|                        for (ci, cell) in row.iter().enumerate() {
 3272|      0|                            if ci < headers.len() {
 3273|      0|                                let w = widths.get(ci).copied().unwrap_or(120.0);
 3274|      0|                                ui.push_id(("cell", ri, ci), |ui| {
 3275|      0|                                    ui.allocate_ui_with_layout(
 3276|      0|                                        Vec2::new(w, 0.0),
 3277|      0|                                        egui::Layout::top_down(egui::Align::LEFT),
 3278|      0|                                        |ui| {
 3279|      0|                                            ui.set_width(w);
 3280|      0|                                            ui.set_max_width(w);
 3281|      0|                                            self.render_table_cell_spans(ui, cell, w, false);
 3282|      0|                                        },
 3283|       |                                    );
 3284|      0|                                });
 3285|      0|                            }
 3286|       |                        }
 3287|      0|                        ui.end_row();
 3288|       |                    }
 3289|      0|                });
 3290|      0|            });
 3291|      0|    }
 3292|       |
 3293|      0|    fn extend_table_rect(target: &mut Option<egui::Rect>, rect: egui::Rect) {
 3294|      0|        if rect.min.x.is_nan() || rect.min.y.is_nan() || rect.max.x.is_nan() || rect.max.y.is_nan()
 3295|       |        {
 3296|      0|            return;
 3297|      0|        }
 3298|      0|        if let Some(existing) = target {
 3299|      0|            existing.min.x = existing.min.x.min(rect.min.x);
 3300|      0|            existing.min.y = existing.min.y.min(rect.min.y);
 3301|      0|            existing.max.x = existing.max.x.max(rect.max.x);
 3302|      0|            existing.max.y = existing.max.y.max(rect.max.y);
 3303|      0|        } else {
 3304|      0|            *target = Some(rect);
 3305|      0|        }
 3306|      0|    }
 3307|       |
 3308|      0|    fn render_table_tablebuilder(
 3309|      0|        &self,
 3310|      0|        ui: &mut egui::Ui,
 3311|      0|        headers: &[Vec<InlineSpan>],
 3312|      0|        rows: &[Vec<Vec<InlineSpan>>],
 3313|      0|        element_index: usize,
 3314|      0|    ) {
 3315|      0|        let table_id = self.compute_table_id(headers, rows, element_index);
 3316|      0|        let column_stats = self.column_stats_for_table(table_id, headers, rows);
 3317|      0|        let ctx =
 3318|      0|            TableColumnContext::new(headers, rows, &column_stats, self.font_sizes.body, table_id);
 3319|      0|        let mut column_specs = derive_column_specs(&ctx);
 3320|      0|        let row_max = rows.iter().map(|r| r.len()).max().unwrap_or(0);
 3321|      0|        let target_cols = column_specs.len().max(row_max).max(1);
 3322|      0|        while column_specs.len() < target_cols {
 3323|      0|            column_specs.push(ColumnSpec::new(
 3324|      0|                format!("Column {}", column_specs.len() + 1),
 3325|      0|                crate::table_support::ColumnPolicy::Remainder { clip: false },
 3326|      0|                None,
 3327|      0|            ));
 3328|      0|        }
 3329|      0|        self.begin_table_pass(table_id, rows.len());
 3330|      0|        self.apply_persisted_widths(table_id, &mut column_specs);
 3331|       |
 3332|      0|        let prev_spacing = ui.spacing().item_spacing;
 3333|      0|        if prev_spacing.x < 6.0 {
 3334|      0|            ui.spacing_mut().item_spacing.x = 6.0;
 3335|      0|        }
 3336|       |
 3337|       |        // Rough header height estimation using equally divided width; refines on next frame via cache.
 3338|      0|        let mut header_height = self.row_height_fallback();
 3339|      0|        if !column_specs.is_empty() {
 3340|      0|            let approx_width = (ui.available_width() / column_specs.len() as f32)
 3341|      0|                .max(self.font_sizes.body * 6.0)
 3342|      0|                .max(48.0);
 3343|      0|            let style = ui.style().clone();
 3344|      0|            header_height = headers
 3345|      0|                .iter()
 3346|      0|                .enumerate()
 3347|      0|                .map(|(ci, spans)| {
 3348|      0|                    let build = self.cached_layout_job(&style, None, ci, spans, approx_width, true);
 3349|      0|                    ui.fonts(|f| f.layout_job(build.job.clone()).size().y + 6.0)
 3350|      0|                })
 3351|      0|                .fold(header_height, |acc, h| acc.max(h));
 3352|      0|            header_height = header_height.min(self.row_height_fallback() * 3.0);
 3353|      0|        }
 3354|       |
 3355|      0|        let mut table = TableBuilder::new(ui).striped(true);
 3356|      0|        for spec in &column_specs {
 3357|      0|            table = table.column(spec.as_column());
 3358|      0|        }
 3359|       |
 3360|      0|        let fallback_row_height = self.row_height_fallback();
 3361|      0|        let row_heights: Vec<f32> = (0..rows.len())
 3362|      0|            .map(|idx| self.row_height_hint(table_id, idx))
 3363|      0|            .collect();
 3364|       |
 3365|       |        // Use RefCell to allow capturing widths from body closure.
 3366|       |        // BUG FIX: Previously captured ui.min_rect().width() which is the cell *content* width.
 3367|       |        // Now we capture body.widths() which gives the actual *allocated* column widths.
 3368|       |        // See: https://docs.rs/egui_extras/latest/egui_extras/struct.TableBody.html#method.widths
 3369|      0|        let column_widths: RefCell<Vec<f32>> = RefCell::new(vec![0.0f32; column_specs.len()]);
 3370|       |        // Track header and body rects separately for accurate table bounds calculation.
 3371|       |        // The header rect captures the header row bounds, body_rect captures body row bounds.
 3372|       |        // These are combined after rendering to get the full table rect.
 3373|      0|        let mut header_rect: Option<egui::Rect> = None;
 3374|      0|        let mut body_rect: Option<egui::Rect> = None;
 3375|       |        // body_layout_rect captures the allocated layout region from body.max_rect(),
 3376|       |        // which is more accurate than union of cell min_rects for table width.
 3377|      0|        let body_layout_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);
 3378|       |        // Track clip rects separately for header and body, then union them.
 3379|       |        // This ensures dividers respect scroll boundaries for both regions.
 3380|      0|        let mut header_clip_rect: Option<egui::Rect> = None;
 3381|      0|        let body_clip_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);
 3382|      0|        let mut painter: Option<Painter> = None;
 3383|      0|        let mut visuals: Option<Visuals> = None;
 3384|      0|        let mut ctx_snapshot: Option<Context> = None;
 3385|       |
 3386|      0|        let mut height_growth = false;
 3387|      0|        table
 3388|      0|            .header(header_height, |mut header| {
 3389|      0|                for (ci, _) in column_specs.iter().enumerate() {
 3390|      0|                    header.col(|ui| {
 3391|      0|                        let width = ui.available_width().max(1.0);
 3392|      0|                        let spans = headers.get(ci).map(|v| v.as_slice()).unwrap_or(&[]);
 3393|      0|                        let _ = self.render_overhauled_cell(ui, spans, width, true, None, ci);
 3394|       |                        // NOTE: Do NOT capture ui.min_rect().width() here - that's the content width,
 3395|       |                        // not the column width. Column widths are captured from body.widths() below.
 3396|       |                        // Extend header_rect (not body_rect) for accurate header bounds.
 3397|      0|                        Self::extend_table_rect(&mut header_rect, ui.min_rect());
 3398|      0|                        if header_clip_rect.is_none() {
 3399|      0|                            header_clip_rect = Some(ui.clip_rect());
 3400|      0|                            painter = Some(ui.painter().clone());
 3401|      0|                            visuals = Some(ui.visuals().clone());
 3402|      0|                            ctx_snapshot = Some(ui.ctx().clone());
 3403|      0|                        }
 3404|      0|                    });
 3405|       |                }
 3406|      0|            })
 3407|      0|            .body(|body| {
 3408|       |                // Capture the actual allocated column widths from the table layout system.
 3409|       |                // This MUST be done before heterogeneous_rows() consumes the body.
 3410|      0|                *column_widths.borrow_mut() = body.widths().to_vec();
 3411|       |
 3412|       |                // Capture body's layout rect for accurate table width calculation.
 3413|       |                // This is the allocated region, not the content bounds.
 3414|      0|                *body_layout_rect.borrow_mut() = Some(body.max_rect());
 3415|       |
 3416|      0|                let row_height_hints = row_heights.clone();
 3417|      0|                body.heterogeneous_rows(row_height_hints.into_iter(), |mut row| {
 3418|      0|                    let idx = row.index();
 3419|      0|                    let row_cells = rows.get(idx);
 3420|      0|                    let mut row_height = fallback_row_height;
 3421|      0|                    for (ci, _) in column_specs.iter().enumerate() {
 3422|      0|                        let mut cell_height = fallback_row_height;
 3423|      0|                        row.col(|ui| {
 3424|      0|                            let width = ui.available_width().max(1.0);
 3425|      0|                            let spans = row_cells
 3426|      0|                                .and_then(|cells| cells.get(ci))
 3427|      0|                                .map(|cell| cell.as_slice())
 3428|      0|                                .unwrap_or(&[]);
 3429|      0|                            cell_height =
 3430|      0|                                self.render_overhauled_cell(ui, spans, width, false, Some(idx), ci);
 3431|       |                            // Extend body_rect (not header_rect) for accurate body bounds.
 3432|      0|                            Self::extend_table_rect(&mut body_rect, ui.min_rect());
 3433|      0|                            if body_clip_rect.borrow().is_none() {
 3434|      0|                                *body_clip_rect.borrow_mut() = Some(ui.clip_rect());
 3435|       |                                // Also capture painter/visuals/ctx if not already captured from header
 3436|      0|                                if painter.is_none() {
 3437|      0|                                    painter = Some(ui.painter().clone());
 3438|      0|                                    visuals = Some(ui.visuals().clone());
 3439|      0|                                    ctx_snapshot = Some(ui.ctx().clone());
 3440|      0|                                }
 3441|      0|                            }
 3442|      0|                        });
 3443|      0|                        row_height = row_height.max(cell_height);
 3444|      0|                        if cell_height > row_heights[idx] + 0.5 {
 3445|      0|                            height_growth = true;
 3446|      0|                        }
 3447|       |                    }
 3448|      0|                    self.update_row_height(table_id, idx, row_height);
 3449|      0|                    self.note_row_rendered(table_id);
 3450|      0|                });
 3451|      0|            });
 3452|       |
 3453|      0|        ui.spacing_mut().item_spacing = prev_spacing;
 3454|       |
 3455|       |        // Extract column widths from RefCell for use in divider painting
 3456|      0|        let widths = column_widths.into_inner();
 3457|      0|        let layout_rect = body_layout_rect.into_inner();
 3458|      0|        let body_clip = body_clip_rect.into_inner();
 3459|       |
 3460|       |        // Combine header and body clip rects to ensure dividers respect scroll bounds.
 3461|      0|        let clip_rect = match (header_clip_rect, body_clip) {
 3462|      0|            (Some(h), Some(b)) => Some(h.union(b)),
 3463|      0|            (Some(h), None) => Some(h),
 3464|      0|            (None, Some(b)) => Some(b),
 3465|      0|            (None, None) => None,
 3466|       |        };
 3467|       |
 3468|       |        // Calculate accurate table width from column widths.
 3469|       |        // This is more accurate than union of cell min_rects which may be smaller
 3470|       |        // than the allocated column space.
 3471|      0|        let calculated_width: f32 = widths.iter().sum();
 3472|       |
 3473|       |        // Combine header and body rects into the full table rect.
 3474|       |        // Use calculated width for accuracy when column widths are available.
 3475|      0|        let table_rect = match (header_rect, body_rect, layout_rect) {
 3476|       |            // Best case: use header for top/left, body for bottom, calculated width for right
 3477|      0|            (Some(h), Some(b), _) if calculated_width > 0.0 => {
 3478|      0|                let left = h.left().min(b.left());
 3479|      0|                let top = h.top();
 3480|      0|                let bottom = b.bottom();
 3481|      0|                let right = left + calculated_width;
 3482|      0|                Some(egui::Rect::from_min_max(
 3483|      0|                    egui::pos2(left, top),
 3484|      0|                    egui::pos2(right, bottom),
 3485|      0|                ))
 3486|       |            }
 3487|       |            // Fallback: use union of header and body
 3488|      0|            (Some(h), Some(b), _) => Some(h.union(b)),
 3489|       |            // Header only with layout rect
 3490|      0|            (Some(h), None, Some(layout)) if calculated_width > 0.0 => {
 3491|      0|                let left = h.left().min(layout.left());
 3492|      0|                let right = left + calculated_width;
 3493|      0|                Some(egui::Rect::from_min_max(
 3494|      0|                    egui::pos2(left, h.top()),
 3495|      0|                    egui::pos2(right, h.bottom()),
 3496|      0|                ))
 3497|       |            }
 3498|      0|            (Some(h), None, _) => Some(h),
 3499|      0|            (None, Some(b), _) => Some(b),
 3500|      0|            (None, None, Some(layout)) => Some(layout),
 3501|      0|            (None, None, None) => None,
 3502|       |        };
 3503|       |
 3504|      0|        if let (Some(rect), Some(clip_rect), Some(painter), Some(visuals), Some(ctx)) =
 3505|      0|            (table_rect, clip_rect, painter, visuals, ctx_snapshot)
 3506|       |        {
 3507|      0|            if column_specs.len() == widths.len() && widths.iter().any(|w| *w > 0.0) {
 3508|      0|                let frame_id = ctx.frame_nr();
 3509|      0|                let change = self.record_resolved_widths(table_id, frame_id, &widths);
 3510|      0|                self.persist_resizable_widths(table_id, &column_specs, &widths);
 3511|      0|                self.handle_width_change(&ctx, table_id, change);
 3512|      0|                self.paint_table_dividers(
 3513|      0|                    &painter,
 3514|      0|                    &visuals,
 3515|      0|                    rect,
 3516|      0|                    clip_rect,
 3517|      0|                    &widths,
 3518|      0|                    header_height,
 3519|       |                );
 3520|      0|                if height_growth {
 3521|      0|                    ctx.request_repaint();
 3522|      0|                }
 3523|      0|            }
 3524|      0|        }
 3525|      0|    }
 3526|       |
 3527|      0|    fn row_height_fallback(&self) -> f32 {
 3528|      0|        self.font_sizes.body * 1.6
 3529|      0|    }
 3530|       |
 3531|      0|    fn row_height_hint(&self, table_id: u64, idx: usize) -> f32 {
 3532|      0|        let fallback = self.row_height_fallback();
 3533|      0|        self.table_metrics
 3534|      0|            .borrow()
 3535|      0|            .entry(table_id)
 3536|      0|            .and_then(|entry| entry.row(idx))
 3537|      0|            .map(|m| {
 3538|      0|                if m.max_height > 0.0 {
 3539|      0|                    m.max_height
 3540|       |                } else {
 3541|      0|                    fallback
 3542|       |                }
 3543|      0|            })
 3544|      0|            .unwrap_or(fallback)
 3545|      0|    }
 3546|       |
 3547|      0|    fn update_row_height(&self, table_id: u64, idx: usize, height: f32) {
 3548|      0|        let clamped = height.max(self.row_height_fallback());
 3549|      0|        let mut metrics = self.table_metrics.borrow_mut();
 3550|      0|        let entry = metrics.entry_mut(table_id);
 3551|      0|        let row = entry.ensure_row(idx);
 3552|      0|        row.max_height = clamped;
 3553|      0|        row.dirty = false;
 3554|      0|    }
 3555|       |
 3556|      0|    fn begin_table_pass(&self, table_id: u64, total_rows: usize) {
 3557|      0|        let mut metrics = self.table_metrics.borrow_mut();
 3558|      0|        metrics.entry_mut(table_id).begin_pass(total_rows);
 3559|      0|    }
 3560|       |
 3561|      0|    fn note_row_rendered(&self, table_id: u64) {
 3562|      0|        let mut metrics = self.table_metrics.borrow_mut();
 3563|      0|        metrics.entry_mut(table_id).note_row_rendered();
 3564|      0|    }
 3565|       |
 3566|      0|    fn apply_persisted_widths(&self, table_id: u64, specs: &mut [ColumnSpec]) {
 3567|      0|        if specs.is_empty() {
 3568|      0|            return;
 3569|      0|        }
 3570|      0|        let mut metrics = self.table_metrics.borrow_mut();
 3571|      0|        let entry = metrics.entry_mut(table_id);
 3572|      0|        for spec in specs.iter_mut() {
 3573|      0|            if let Some(width) = entry.persisted_width(spec.policy_hash) {
 3574|      0|                spec.apply_preferred_width(width);
 3575|      0|            }
 3576|       |        }
 3577|      0|    }
 3578|       |
 3579|      3|    fn persist_resizable_widths(&self, table_id: u64, specs: &[ColumnSpec], widths: &[f32]) {
 3580|      3|        if specs.is_empty() || widths.is_empty() {
 3581|      0|            return;
 3582|      3|        }
 3583|      3|        let mut metrics = self.table_metrics.borrow_mut();
 3584|      3|        let entry = metrics.entry_mut(table_id);
 3585|       |
 3586|       |        // Check if font size changed since last persist - if so, clear old widths
 3587|       |        // to prevent size mismatch after zoom changes. Skip persisting in this
 3588|       |        // frame so the next layout can compute fresh widths before we store them.
 3589|      3|        if entry.check_font_size_change(self.font_sizes.body) {
 3590|      1|            return;
 3591|      2|        }
 3592|       |
 3593|      2|        for (spec, width) in specs.iter().zip(widths.iter()) {
 3594|      2|            if let ColumnPolicy::Resizable { .. } = spec.policy {
 3595|      2|                let stored = entry.persisted_width(spec.policy_hash).unwrap_or(-1.0);
 3596|      2|                if stored < 0.0 || (stored - width).abs() > 0.5 {
                                                 ^0
 3597|      2|                    entry.set_persisted_width(spec.policy_hash, *width);
 3598|      2|                }
                              ^0
 3599|      0|            }
 3600|       |        }
 3601|      3|    }
 3602|       |
 3603|      0|    fn record_resolved_widths(&self, table_id: u64, frame_id: u64, widths: &[f32]) -> WidthChange {
 3604|      0|        if widths.is_empty() {
 3605|      0|            return WidthChange::None;
 3606|      0|        }
 3607|      0|        let mut metrics = self.table_metrics.borrow_mut();
 3608|      0|        metrics.entry_mut(table_id).update_widths(widths, frame_id)
 3609|      0|    }
 3610|       |
 3611|      0|    fn handle_width_change(&self, ctx: &Context, table_id: u64, change: WidthChange) {
 3612|      0|        if matches!(change, WidthChange::Large) {
 3613|      0|            let frame_id = ctx.frame_nr();
 3614|      0|            let mut metrics = self.table_metrics.borrow_mut();
 3615|      0|            let entry = metrics.entry_mut(table_id);
 3616|      0|            if entry.last_discard_frame != Some(frame_id) {
 3617|      0|                ctx.request_repaint();
 3618|      0|                entry.last_discard_frame = Some(frame_id);
 3619|      0|            }
 3620|      0|        }
 3621|      0|    }
 3622|       |
 3623|       |    /// Paint vertical dividers between table columns, a horizontal header separator,
 3624|       |    /// and an outer border.
 3625|       |    ///
 3626|       |    /// # Arguments
 3627|       |    /// * `widths` - The actual allocated column widths from `TableBody::widths()`.
 3628|       |    ///   IMPORTANT: These must NOT be cell content widths from `ui.min_rect()`,
 3629|       |    ///   which would cause dividers to be misaligned.
 3630|       |    /// * `header_height` - The height of the header row. A horizontal separator is
 3631|       |    ///   drawn at this y-offset to visually separate header from body rows.
 3632|      0|    fn paint_table_dividers(
 3633|      0|        &self,
 3634|      0|        painter: &Painter,
 3635|      0|        visuals: &Visuals,
 3636|      0|        rect: egui::Rect,
 3637|      0|        clip_rect: egui::Rect,
 3638|      0|        widths: &[f32],
 3639|      0|        header_height: f32,
 3640|      0|    ) {
 3641|      0|        if widths.len() <= 1 {
 3642|      0|            return;
 3643|      0|        }
 3644|      0|        let separator_color = visuals
 3645|      0|            .widgets
 3646|      0|            .noninteractive
 3647|      0|            .bg_stroke
 3648|      0|            .color
 3649|      0|            .gamma_multiply(0.9);
 3650|      0|        let separator_stroke = Stroke::new(1.0, separator_color);
 3651|      0|        let border_stroke = visuals.window_stroke();
 3652|      0|        let painter = painter.with_clip_rect(clip_rect);
 3653|       |
 3654|       |        // Draw vertical dividers between columns
 3655|      0|        let mut x = rect.left();
 3656|      0|        for width in widths.iter().take(widths.len().saturating_sub(1)) {
 3657|      0|            x += *width;
 3658|      0|            let x_pos = (x.round() + 0.5).clamp(rect.left(), rect.right());
 3659|      0|            painter.vline(x_pos, rect.y_range(), separator_stroke);
 3660|      0|        }
 3661|       |
 3662|       |        // Draw horizontal separator below header row
 3663|      0|        if header_height > 0.0 {
 3664|      0|            let header_y = rect.top() + header_height;
 3665|      0|            if header_y > rect.top() && header_y < rect.bottom() {
 3666|      0|                painter.hline(rect.x_range(), header_y.round() + 0.5, separator_stroke);
 3667|      0|            }
 3668|      0|        }
 3669|       |
 3670|       |        // Draw outer border
 3671|      0|        painter.rect_stroke(rect, 0.0, border_stroke);
 3672|      0|    }
 3673|       |
 3674|      0|    fn render_overhauled_cell(
 3675|      0|        &self,
 3676|      0|        ui: &mut egui::Ui,
 3677|      0|        spans: &[InlineSpan],
 3678|      0|        width: f32,
 3679|      0|        is_header: bool,
 3680|      0|        row_idx: Option<usize>,
 3681|      0|        col_idx: usize,
 3682|      0|    ) -> f32 {
 3683|      0|        let fallback_height = self.row_height_fallback();
 3684|      0|        let fragments = self.cell_fragments(spans);
 3685|      0|        let inner = ui.allocate_ui_with_layout(
 3686|      0|            Vec2::new(width, 0.0),
 3687|      0|            egui::Layout::top_down(egui::Align::LEFT),
 3688|      0|            |ui| {
 3689|      0|                ui.set_width(width);
 3690|      0|                ui.set_max_width(width);
 3691|      0|                ui.spacing_mut().item_spacing = egui::vec2(4.0, 2.0);
 3692|      0|                if fragments.is_empty() {
 3693|      0|                    ui.allocate_exact_size(
 3694|      0|                        Vec2::new(width, self.font_sizes.body * 1.2),
 3695|      0|                        egui::Sense::hover(),
 3696|       |                    );
 3697|      0|                    return;
 3698|      0|                }
 3699|      0|                for fragment in fragments {
 3700|      0|                    match fragment {
 3701|      0|                        CellFragment::Text(slice) => {
 3702|      0|                            let build = self.cached_layout_job(
 3703|      0|                                ui.style(),
 3704|      0|                                row_idx,
 3705|      0|                                col_idx,
 3706|      0|                                slice,
 3707|      0|                                width,
 3708|      0|                                is_header,
 3709|      0|                            );
 3710|      0|                            self.paint_table_text_job(ui, width, build);
 3711|      0|                        }
 3712|      0|                        CellFragment::Emoji(key) => {
 3713|      0|                            self.render_table_emoji(ui, &key);
 3714|      0|                        }
 3715|      0|                        CellFragment::Image(span) => {
 3716|      0|                            self.render_inline_span(ui, span, None, Some(is_header));
 3717|      0|                        }
 3718|       |                    }
 3719|       |                }
 3720|      0|            },
 3721|       |        );
 3722|      0|        inner.response.rect.height().max(fallback_height)
 3723|      0|    }
 3724|       |
 3725|      0|    fn paint_table_text_job(
 3726|      0|        &self,
 3727|      0|        ui: &mut egui::Ui,
 3728|      0|        width: f32,
 3729|      0|        build: LayoutJobBuild,
 3730|      0|    ) -> egui::Response {
 3731|      0|        let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
 3732|      0|        let height = galley.size().y;
 3733|      0|        let (rect, mut response) =
 3734|      0|            ui.allocate_exact_size(Vec2::new(width, height), egui::Sense::click());
 3735|      0|        let text_color = ui.visuals().text_color();
 3736|      0|        ui.painter_at(rect)
 3737|      0|            .galley(rect.left_top(), galley.clone(), text_color);
 3738|      0|        if galley.rows.len() > 1 {
 3739|      0|            response = response.on_hover_text(build.plain_text.clone());
 3740|      0|        }
 3741|      0|        response.context_menu(|ui| {
 3742|      0|            if ui.button("Copy Cell Text").clicked() {
 3743|      0|                ui.ctx().copy_text(build.plain_text.clone());
 3744|      0|                ui.close_menu();
 3745|      0|            }
 3746|      0|        });
 3747|       |
 3748|      0|        if let Some(link) = self.link_at_pointer(&response, &galley, &build) {
 3749|      0|            ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
 3750|      0|            response = response.on_hover_text(link.url.clone());
 3751|      0|            if response.clicked() {
 3752|      0|                self.trigger_link(&link.url);
 3753|      0|            }
 3754|      0|        }
 3755|       |
 3756|      0|        response
 3757|      0|    }
 3758|       |
 3759|      0|    fn cached_layout_job(
 3760|      0|        &self,
 3761|      0|        style: &egui::Style,
 3762|      0|        row_idx: Option<usize>,
 3763|      0|        col_idx: usize,
 3764|      0|        spans: &[InlineSpan],
 3765|      0|        width: f32,
 3766|      0|        is_header: bool,
 3767|      0|    ) -> LayoutJobBuild {
 3768|      0|        if !self.table_wrap_overhaul_enabled {
 3769|      0|            return self.build_layout_job(style, spans, width, is_header);
 3770|      0|        }
 3771|      0|        let highlight_hash = self
 3772|      0|            .highlight_phrase
 3773|      0|            .borrow()
 3774|      0|            .as_ref()
 3775|      0|            .map(|s| Self::hash_str(s))
 3776|      0|            .unwrap_or(0);
 3777|      0|        let content_hash = Self::hash_inline_spans(spans);
 3778|      0|        let key = CellLayoutKey {
 3779|      0|            row: row_idx,
 3780|      0|            col: col_idx,
 3781|      0|            width: width.round() as u32,
 3782|      0|            strong: is_header,
 3783|      0|            highlight_hash,
 3784|      0|            content_hash,
 3785|      0|        };
 3786|      0|        if let Some(build) = self.table_layout_cache.borrow_mut().get(&key) {
 3787|      0|            return build;
 3788|      0|        }
 3789|      0|        let build = self.build_layout_job(style, spans, width, is_header);
 3790|      0|        self.table_layout_cache
 3791|      0|            .borrow_mut()
 3792|      0|            .insert(key, build.clone());
 3793|      0|        build
 3794|      0|    }
 3795|       |
 3796|      0|    fn link_at_pointer<'a>(
 3797|      0|        &self,
 3798|      0|        response: &egui::Response,
 3799|      0|        galley: &Arc<Galley>,
 3800|      0|        build: &'a LayoutJobBuild,
 3801|      0|    ) -> Option<&'a LinkRange> {
 3802|      0|        let pointer = response.hover_pos()?;
 3803|      0|        let local = pointer - response.rect.left_top();
 3804|      0|        let cursor = galley.cursor_from_pos(local);
 3805|      0|        let idx = cursor.ccursor.index;
 3806|      0|        build
 3807|      0|            .link_ranges
 3808|      0|            .iter()
 3809|      0|            .find(|range| range.char_range.contains(&idx))
 3810|      0|    }
 3811|       |
 3812|      0|    fn render_table_emoji(&self, ui: &mut egui::Ui, emoji: &str) {
 3813|      0|        let handle = self.get_or_make_emoji_texture(ui, emoji);
 3814|      0|        let size = self.font_sizes.body * 1.2;
 3815|      0|        ui.add(
 3816|      0|            egui::Image::new(&handle)
 3817|      0|                .max_size(Vec2::splat(size))
 3818|      0|                .sense(egui::Sense::hover()),
 3819|       |        );
 3820|      0|    }
 3821|       |
 3822|       |    /// Render table cell spans with proper text wrapping within the given width
 3823|      0|    fn render_table_cell_spans(
 3824|      0|        &self,
 3825|      0|        ui: &mut egui::Ui,
 3826|      0|        spans: &[InlineSpan],
 3827|      0|        max_width: f32,
 3828|      0|        is_header: bool,
 3829|      0|    ) {
 3830|       |        // Render content with wrapping, forcing exact width to ensure wrapping occurs
 3831|      0|        ui.vertical(|ui| {
 3832|      0|            ui.set_width(max_width); // Force exact width
 3833|      0|            ui.set_max_width(max_width);
 3834|      0|            ui.spacing_mut().item_spacing.y = 0.0;
 3835|       |
 3836|       |            // Render all spans in a wrapped horizontal layout
 3837|      0|            ui.horizontal_wrapped(|ui| {
 3838|      0|                ui.spacing_mut().item_spacing.x = 0.0;
 3839|      0|                ui.set_width(max_width);
 3840|      0|                for span in spans {
 3841|      0|                    self.render_inline_span(ui, span, None, Some(is_header));
 3842|      0|                }
 3843|      0|            });
 3844|      0|        });
 3845|      0|    }
 3846|       |
 3847|      2|    fn resolve_table_widths(available: f32, mins: &[f32], desired: &[f32]) -> Vec<f32> {
 3848|      2|        debug_assert_eq!(mins.len(), desired.len());
 3849|      2|        if mins.is_empty() {
 3850|      0|            return Vec::new();
 3851|      2|        }
 3852|      2|        let clamped_available = available.max(1.0);
 3853|      2|        let desired_total: f32 = desired.iter().sum();
 3854|      2|        let min_total: f32 = mins.iter().sum();
 3855|       |
 3856|      2|        let mut widths = if desired_total <= clamped_available {
 3857|      0|            desired.to_vec()
 3858|      2|        } else if min_total >= clamped_available {
 3859|      1|            if min_total <= f32::EPSILON {
 3860|      0|                vec![clamped_available / mins.len() as f32; mins.len()]
 3861|       |            } else {
 3862|      1|                mins.iter()
 3863|      4|                    .map(|m| m * (clamped_available / min_total))
                                   ^1
 3864|      1|                    .collect()
 3865|       |            }
 3866|       |        } else {
 3867|      1|            let mut widths = mins.to_vec();
 3868|      1|            let extra = clamped_available - min_total;
 3869|      1|            let slack: Vec<f32> = desired
 3870|      1|                .iter()
 3871|      1|                .zip(mins.iter())
 3872|      4|                .map(|(d, m)| (d - m).max(0.0))
                               ^1
 3873|      1|                .collect();
 3874|      1|            let total_slack: f32 = slack.iter().sum();
 3875|      1|            if total_slack <= f32::EPSILON {
 3876|      0|                let bonus = extra / widths.len() as f32;
 3877|      0|                for w in &mut widths {
 3878|      0|                    *w += bonus;
 3879|      0|                }
 3880|       |            } else {
 3881|      4|                for (w, s) in widths.iter_mut().zip(slack.iter()) {
                                            ^1                ^1  ^1
 3882|      4|                    *w += extra * (*s / total_slack);
 3883|      4|                }
 3884|       |            }
 3885|      1|            widths
 3886|       |        };
 3887|       |
 3888|      2|        let sum: f32 = widths.iter().sum();
 3889|      2|        if sum > clamped_available + 0.5 {
 3890|      0|            let ratio = clamped_available / sum;
 3891|      0|            for w in &mut widths {
 3892|      0|                *w *= ratio;
 3893|      0|            }
 3894|      2|        }
 3895|      2|        widths
 3896|      2|    }
 3897|       |
 3898|       |    /// Open URL in default browser
 3899|      0|    fn open_url(&self, url: &str) {
 3900|      0|        if let Err(e) = webbrowser::open(url) {
 3901|      0|            eprintln!("Failed to open URL {}: {}", url, e);
 3902|      0|        }
 3903|      0|    }
 3904|       |
 3905|      0|    fn trigger_link(&self, url: &str) {
 3906|      0|        if let Some(fragment) = Self::extract_fragment(url) {
 3907|      0|            *self.pending_anchor.borrow_mut() = Some(fragment);
 3908|      0|        } else if Self::is_allowed_scheme(url) {
 3909|      0|            self.open_url(url);
 3910|      0|        } else {
 3911|      0|            eprintln!("Blocked link with unsupported scheme: {}", url);
 3912|      0|        }
 3913|      0|    }
 3914|       |
 3915|      0|    fn is_allowed_scheme(url: &str) -> bool {
 3916|      0|        url.starts_with("http://") || url.starts_with("https://") || url.starts_with("mailto:")
 3917|      0|    }
 3918|       |
 3919|       |    /// Consume and return the last clicked internal anchor, if any
 3920|      0|    pub fn take_pending_anchor(&self) -> Option<String> {
 3921|      0|        self.pending_anchor.borrow_mut().take()
 3922|      0|    }
 3923|       |
 3924|       |    /// Lookup a header rect by its id (slug)
 3925|      0|    pub fn header_rect_for(&self, id: &str) -> Option<egui::Rect> {
 3926|      0|        self.header_rects.borrow().get(id).copied()
 3927|      0|    }
 3928|       |
 3929|       |    /// Lookup the rect for the n-th top-level element rendered in the last frame
 3930|      0|    pub fn element_rect_at(&self, index: usize) -> Option<egui::Rect> {
 3931|      0|        self.element_rects.borrow().get(index).copied()
 3932|      0|    }
 3933|       |
 3934|       |    /// Set or clear the highlight phrase (case-insensitive)
 3935|      1|    pub fn set_highlight_phrase(&self, phrase: Option<&str>) {
 3936|      1|        if let Some(p) = phrase {
 3937|      1|            self.highlight_phrase
 3938|      1|                .borrow_mut()
 3939|      1|                .replace(p.case_fold().nfkc().collect());
 3940|      1|        } else {
 3941|      0|            self.highlight_phrase.borrow_mut().take();
 3942|      0|        }
 3943|      1|        self.clear_table_layout_cache();
 3944|      1|    }
 3945|       |
 3946|     34|    pub fn set_table_wrap_overhaul_enabled(&mut self, enabled: bool) {
 3947|     34|        self.table_wrap_overhaul_enabled = enabled;
 3948|     34|        self.clear_table_layout_cache();
 3949|     34|    }
 3950|       |
 3951|      0|    pub fn table_wrap_overhaul_enabled(&self) -> bool {
 3952|      0|        self.table_wrap_overhaul_enabled
 3953|      0|    }
 3954|       |
 3955|    100|    pub fn clear_table_layout_cache(&self) {
 3956|    100|        self.table_layout_cache.borrow_mut().clear();
 3957|    100|        self.table_metrics.borrow_mut().clear();
 3958|    100|        self.column_stats_cache.borrow_mut().clear();
 3959|    100|    }
 3960|       |
 3961|      0|    pub fn table_layout_cache_stats(&self) -> (u64, u64) {
 3962|      0|        self.table_layout_cache.borrow().stats()
 3963|      0|    }
 3964|       |
 3965|      0|    pub fn table_render_stats(&self) -> (usize, usize) {
 3966|      0|        self.table_metrics.borrow().totals()
 3967|      0|    }
 3968|       |
 3969|       |    /// Get a plain-text representation of a markdown element (for search)
 3970|      3|    pub fn element_plain_text(element: &MarkdownElement) -> String {
 3971|      3|        match element {
 3972|      3|            MarkdownElement::Paragraph(spans) => Self::spans_plain_text(spans),
 3973|      0|            MarkdownElement::Header { spans, .. } => Self::spans_plain_text(spans),
 3974|      0|            MarkdownElement::CodeBlock { text, .. } => text.clone(),
 3975|      0|            MarkdownElement::List { items, .. } => {
 3976|      0|                let mut out = String::new();
 3977|      0|                for item in items {
 3978|      0|                    if !out.is_empty() {
 3979|      0|                        out.push('\n');
 3980|      0|                    }
 3981|      0|                    out.push_str(&Self::spans_plain_text(item));
 3982|       |                }
 3983|      0|                out
 3984|       |            }
 3985|      0|            MarkdownElement::Quote { lines, .. } => {
 3986|      0|                let mut out = String::new();
 3987|      0|                for line in lines {
 3988|      0|                    if !out.is_empty() {
 3989|      0|                        out.push('\n');
 3990|      0|                    }
 3991|      0|                    out.push_str(&Self::spans_plain_text(line));
 3992|       |                }
 3993|      0|                out
 3994|       |            }
 3995|      0|            MarkdownElement::HorizontalRule => String::from("---"),
 3996|      0|            MarkdownElement::Table { headers, rows } => {
 3997|      0|                let mut out = String::new();
 3998|      0|                for h in headers {
 3999|      0|                    if !out.is_empty() {
 4000|      0|                        out.push(' ');
 4001|      0|                    }
 4002|      0|                    out.push_str(&Self::spans_plain_text(h));
 4003|       |                }
 4004|      0|                for row in rows {
 4005|      0|                    for cell in row {
 4006|      0|                        out.push(' ');
 4007|      0|                        out.push_str(&Self::spans_plain_text(cell));
 4008|      0|                    }
 4009|       |                }
 4010|      0|                out
 4011|       |            }
 4012|       |        }
 4013|      3|    }
 4014|       |
 4015|       |    /// Set the base directory for resolving relative image paths
 4016|     20|    pub fn set_base_dir(&self, dir: Option<&Path>) {
 4017|     20|        if let Some(d) = dir {
                                  ^12
 4018|     12|            self.base_dir.borrow_mut().replace(d.to_path_buf());
 4019|     12|        } else {
 4020|      8|            self.base_dir.borrow_mut().take();
 4021|      8|        }
 4022|     20|    }
 4023|       |
 4024|      0|    fn resolve_image_path(&self, src: &str) -> String {
 4025|      0|        if src.starts_with("http://") || src.starts_with("https://") || src.starts_with("data:") {
 4026|       |            // Keep as-is; we don't fetch remote or parse data URIs yet
 4027|      0|            return src.to_string();
 4028|      0|        }
 4029|      0|        let p = Path::new(src);
 4030|      0|        if p.is_absolute() {
 4031|      0|            return src.to_string();
 4032|      0|        }
 4033|      0|        if let Some(base) = self.base_dir.borrow().as_ref() {
 4034|      0|            let joined = base.join(p);
 4035|      0|            return joined.to_string_lossy().into_owned();
 4036|      0|        }
 4037|      0|        src.to_string()
 4038|      0|    }
 4039|       |
 4040|      0|    fn get_or_load_image_texture(
 4041|      0|        &self,
 4042|      0|        ui: &egui::Ui,
 4043|      0|        resolved_src: &str,
 4044|      0|    ) -> Option<(egui::TextureHandle, u32, u32)> {
 4045|       |        // Reject remote for now
 4046|      0|        if resolved_src.starts_with("http://") || resolved_src.starts_with("https://") {
 4047|      0|            return None;
 4048|      0|        }
 4049|       |
 4050|      0|        let path = Path::new(resolved_src);
 4051|       |
 4052|      0|        if let Some(entry) = self.image_textures.borrow().get(resolved_src) {
 4053|      0|            let stale = Self::image_source_stale(entry.modified, path);
 4054|      0|            if !stale {
 4055|      0|                return Some((entry.texture.clone(), entry.size[0], entry.size[1]));
 4056|      0|            }
 4057|      0|        }
 4058|       |
 4059|       |        // Try embedded assets first
 4060|      0|        if let Some(bytes) = Self::embedded_image_bytes(resolved_src) {
 4061|      0|            if let Some((color_image, w, h)) = Self::bytes_to_color_image_guess(bytes, None) {
 4062|      0|                let tex = ui.ctx().load_texture(
 4063|      0|                    format!("img:{}", resolved_src),
 4064|      0|                    color_image,
 4065|       |                    egui::TextureOptions::LINEAR,
 4066|       |                );
 4067|      0|                self.store_image_texture(resolved_src, tex.clone(), [w, h], None);
 4068|      0|                return Some((tex, w, h));
 4069|      0|            }
 4070|      0|        }
 4071|       |
 4072|      0|        if !path.exists() {
 4073|      0|            return None;
 4074|      0|        }
 4075|       |
 4076|      0|        let bytes = std::fs::read(path).ok()?;
 4077|      0|        let (color_image, w, h) = if Self::is_svg_path(resolved_src) {
 4078|      0|            match Self::svg_bytes_to_color_image(&bytes) {
 4079|      0|                Some((ci, w, h)) => (ci, w, h),
 4080|      0|                None => return None,
 4081|       |            }
 4082|       |        } else {
 4083|      0|            let img = image::load_from_memory(&bytes).ok()?;
 4084|      0|            let rgba = img.to_rgba8();
 4085|      0|            let (w, h) = rgba.dimensions();
 4086|      0|            let ci = egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &rgba);
 4087|      0|            (ci, w, h)
 4088|       |        };
 4089|      0|        let tex = ui.ctx().load_texture(
 4090|      0|            format!("img:{}", resolved_src),
 4091|      0|            color_image,
 4092|       |            egui::TextureOptions::LINEAR,
 4093|       |        );
 4094|      0|        let modified = Self::disk_image_timestamp(path);
 4095|      0|        self.store_image_texture(resolved_src, tex.clone(), [w, h], modified);
 4096|      0|        Some((tex, w, h))
 4097|      0|    }
 4098|       |
 4099|      3|    fn disk_image_timestamp(path: &Path) -> Option<SystemTime> {
 4100|      3|        std::fs::metadata(path).ok()?.modified().ok()
                                                  ^0
 4101|      3|    }
 4102|       |
 4103|      2|    fn image_source_stale(cached_modified: Option<SystemTime>, path: &Path) -> bool {
 4104|      2|        if !path.exists() {
 4105|      0|            return false;
 4106|      2|        }
 4107|      2|        let current = Self::disk_image_timestamp(path);
 4108|      2|        match (cached_modified, current) {
 4109|      2|            (Some(prev), Some(cur)) => prev != cur,
 4110|      0|            (Some(_), None) => true,
 4111|      0|            (None, Some(_)) => true,
 4112|      0|            (None, None) => false,
 4113|       |        }
 4114|      2|    }
 4115|       |
 4116|      0|    fn store_image_texture(
 4117|      0|        &self,
 4118|      0|        key: &str,
 4119|      0|        texture: egui::TextureHandle,
 4120|      0|        size: [u32; 2],
 4121|      0|        modified: Option<SystemTime>,
 4122|      0|    ) {
 4123|      0|        self.image_textures.borrow_mut().insert(
 4124|      0|            key.to_string(),
 4125|      0|            ImageCacheEntry {
 4126|      0|                texture,
 4127|      0|                size,
 4128|      0|                modified,
 4129|      0|            },
 4130|      0|        );
 4131|      0|    }
 4132|       |
 4133|       |    /// Return embedded image bytes for known assets used in sample files
 4134|      0|    fn embedded_image_bytes(path: &str) -> Option<&'static [u8]> {
 4135|      0|        match path.replace('\\', "/").as_str() {
 4136|       |            // Smiley PNG
 4137|      0|            "assets/emoji/1f600.png" => Some(include_bytes!("../assets/emoji/1f600.png")),
 4138|       |            // SVG logo and WEBP sample used by images.md
 4139|      0|            "assets/samples/logo.svg" => Some(include_bytes!("../assets/samples/logo.svg")),
 4140|      0|            "assets/samples/webp_sample.webp" => {
 4141|      0|                Some(include_bytes!("../assets/samples/webp_sample.webp"))
 4142|       |            }
 4143|      0|            _ => None,
 4144|       |        }
 4145|      0|    }
 4146|       |
 4147|      0|    fn is_svg_path(p: &str) -> bool {
 4148|      0|        p.rsplit('.')
 4149|      0|            .next()
 4150|      0|            .map(|e| e.eq_ignore_ascii_case("svg"))
 4151|      0|            .unwrap_or(false)
 4152|      0|    }
 4153|       |
 4154|      0|    fn svg_bytes_to_color_image(bytes: &[u8]) -> Option<(egui::ColorImage, u32, u32)> {
 4155|      0|        Self::svg_bytes_to_color_image_with_bg(bytes, None)
 4156|      0|    }
 4157|       |
 4158|      0|    fn svg_bytes_to_color_image_with_bg(
 4159|      0|        bytes: &[u8],
 4160|      0|        bg: Option<[u8; 4]>,
 4161|      0|    ) -> Option<(egui::ColorImage, u32, u32)> {
 4162|       |        // Parse SVG
 4163|      0|        let mut opt = usvg::Options::default();
 4164|       |        // Load system fonts so <text> elements render via resvg
 4165|      0|        let mut db = usvg::fontdb::Database::new();
 4166|      0|        db.load_system_fonts();
 4167|      0|        opt.fontdb = std::sync::Arc::new(db);
 4168|      0|        let tree = usvg::Tree::from_data(bytes, &opt).ok()?;
 4169|       |        // Determine output size in pixels
 4170|      0|        let sz = tree.size();
 4171|      0|        let pix = sz.to_int_size();
 4172|      0|        let (mut w, mut h) = (pix.width(), pix.height());
 4173|      0|        if w == 0 || h == 0 {
 4174|      0|            // Fallback if unspecified
 4175|      0|            w = 256;
 4176|      0|            h = 256;
 4177|      0|        }
 4178|       |        // Clamp to a reasonable texture size
 4179|      0|        let max_side: u32 = 4096;
 4180|      0|        if w > max_side || h > max_side {
 4181|      0|            let scale = (max_side as f32 / w as f32).min(max_side as f32 / h as f32);
 4182|      0|            w = (w as f32 * scale) as u32;
 4183|      0|            h = (h as f32 * scale) as u32;
 4184|      0|        }
 4185|      0|        let mut pixmap = tiny_skia::Pixmap::new(w, h)?;
 4186|       |        // Optional background fill for better contrast against dark UI
 4187|      0|        if let Some([r, g, b, a]) = bg {
 4188|      0|            let color = tiny_skia::Color::from_rgba8(r, g, b, a);
 4189|      0|            pixmap.fill(color);
 4190|      0|        }
 4191|      0|        let mut pmut = pixmap.as_mut();
 4192|      0|        resvg::render(&tree, tiny_skia::Transform::identity(), &mut pmut);
 4193|      0|        let data = pixmap.data();
 4194|      0|        let img = egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], data);
 4195|      0|        Some((img, w, h))
 4196|      0|    }
 4197|       |
 4198|       |    // Try decode as raster image first (PNG/JPEG/WEBP). If that fails, try SVG.
 4199|      0|    fn bytes_to_color_image_guess(
 4200|      0|        bytes: &[u8],
 4201|      0|        bg: Option<[u8; 4]>,
 4202|      0|    ) -> Option<(egui::ColorImage, u32, u32)> {
 4203|      0|        if let Ok(img) = image::load_from_memory(bytes) {
 4204|      0|            let rgba = img.to_rgba8();
 4205|      0|            let (w, h) = rgba.dimensions();
 4206|      0|            let mut ci = egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &rgba);
 4207|      0|            if let Some([br, bgc, bb, ba]) = bg {
 4208|       |                // Composite over solid bg
 4209|      0|                for p in ci.pixels.iter_mut() {
 4210|      0|                    let a = p[3] as f32 / 255.0;
 4211|      0|                    let inv = 1.0 - a;
 4212|      0|                    p[0] = (a * p[0] as f32 + inv * br as f32) as u8;
 4213|      0|                    p[1] = (a * p[1] as f32 + inv * bgc as f32) as u8;
 4214|      0|                    p[2] = (a * p[2] as f32 + inv * bb as f32) as u8;
 4215|      0|                    p[3] = ba; // fully opaque output
 4216|      0|                }
 4217|      0|            }
 4218|      0|            return Some((ci, w, h));
 4219|      0|        }
 4220|       |        // Fallback to SVG
 4221|      0|        Self::svg_bytes_to_color_image_with_bg(bytes, bg)
 4222|      0|    }
 4223|       |
 4224|       |    /// Find syntax definition for a given language name
 4225|       |    /// Maps common language names to their syntax definitions
 4226|      0|    fn find_syntax_for_language(&self, lang: &str) -> Option<&syntect::parsing::SyntaxReference> {
 4227|       |        // Create a mapping of common language names to their syntect equivalents
 4228|      0|        let lang_lower = lang.to_lowercase();
 4229|       |
 4230|       |        // Try direct name match first
 4231|      0|        if let Some(syntax) = self.syntax_set.find_syntax_by_name(&lang_lower) {
 4232|      0|            return Some(syntax);
 4233|      0|        }
 4234|       |
 4235|       |        // Try extension-based matching
 4236|      0|        if let Some(syntax) = self.syntax_set.find_syntax_by_extension(&lang_lower) {
 4237|      0|            return Some(syntax);
 4238|      0|        }
 4239|       |
 4240|       |        // Handle common language mappings
 4241|      0|        let mapped_lang = match lang_lower.as_str() {
 4242|      0|            "rust" => "rs",
 4243|      0|            "python" => "py",
 4244|      0|            "javascript" => "js",
 4245|      0|            "typescript" => "ts",
 4246|      0|            "c++" | "cpp" => "cpp",
 4247|      0|            "c#" | "csharp" => "cs",
 4248|      0|            "shell" | "bash" => "sh",
 4249|      0|            "powershell" => "ps1",
 4250|      0|            "yaml" => "yml",
 4251|      0|            "markdown" => "md",
 4252|      0|            "html" => "html",
 4253|      0|            "css" => "css",
 4254|      0|            "java" => "java",
 4255|      0|            "go" => "go",
 4256|      0|            "php" => "php",
 4257|      0|            "ruby" => "rb",
 4258|      0|            "xml" => "xml",
 4259|      0|            "json" => "json",
 4260|      0|            "sql" => "sql",
 4261|      0|            "toml" => "toml",
 4262|      0|            _ => &lang_lower,
 4263|       |        };
 4264|       |
 4265|       |        // Try mapped extension
 4266|      0|        self.syntax_set
 4267|      0|            .find_syntax_by_extension(mapped_lang)
 4268|      0|            .or_else(|| self.syntax_set.find_syntax_by_name(mapped_lang))
 4269|      0|    }
 4270|       |
 4271|       |    /// Zoom in (increase font sizes)
 4272|      1|    pub fn zoom_in(&mut self) {
 4273|      1|        self.font_sizes.body = (self.font_sizes.body * 1.1).min(32.0);
 4274|      1|        self.font_sizes.h1 = (self.font_sizes.h1 * 1.1).min(48.0);
 4275|      1|        self.font_sizes.h2 = (self.font_sizes.h2 * 1.1).min(42.0);
 4276|      1|        self.font_sizes.h3 = (self.font_sizes.h3 * 1.1).min(36.0);
 4277|      1|        self.font_sizes.h4 = (self.font_sizes.h4 * 1.1).min(32.0);
 4278|      1|        self.font_sizes.h5 = (self.font_sizes.h5 * 1.1).min(28.0);
 4279|      1|        self.font_sizes.h6 = (self.font_sizes.h6 * 1.1).min(24.0);
 4280|      1|        self.font_sizes.code = (self.font_sizes.code * 1.1).min(20.0);
 4281|      1|        self.clear_table_layout_cache();
 4282|      1|    }
 4283|       |
 4284|       |    /// Zoom out (decrease font sizes)
 4285|      1|    pub fn zoom_out(&mut self) {
 4286|      1|        self.font_sizes.body = (self.font_sizes.body * 0.9).max(8.0);
 4287|      1|        self.font_sizes.h1 = (self.font_sizes.h1 * 0.9).max(16.0);
 4288|      1|        self.font_sizes.h2 = (self.font_sizes.h2 * 0.9).max(14.0);
 4289|      1|        self.font_sizes.h3 = (self.font_sizes.h3 * 0.9).max(12.0);
 4290|      1|        self.font_sizes.h4 = (self.font_sizes.h4 * 0.9).max(11.0);
 4291|      1|        self.font_sizes.h5 = (self.font_sizes.h5 * 0.9).max(10.0);
 4292|      1|        self.font_sizes.h6 = (self.font_sizes.h6 * 0.9).max(9.0);
 4293|      1|        self.font_sizes.code = (self.font_sizes.code * 0.9).max(8.0);
 4294|      1|        self.clear_table_layout_cache();
 4295|      1|    }
 4296|       |
 4297|       |    /// Reset zoom to default
 4298|      1|    pub fn reset_zoom(&mut self) {
 4299|      1|        self.font_sizes = FontSizes::default();
 4300|      1|        self.clear_table_layout_cache();
 4301|      1|    }
 4302|       |}
 4303|       |
 4304|       |#[cfg(test)]
 4305|       |mod tests {
 4306|       |    use super::*;
 4307|       |    use crate::SAMPLE_FILES;
 4308|       |
 4309|       |    #[test]
 4310|      1|    fn test_markdown_renderer_creation() {
 4311|      1|        let renderer = MarkdownRenderer::new();
 4312|      1|        assert_eq!(renderer.font_sizes.body, 14.0);
 4313|      1|        assert_eq!(renderer.font_sizes.h1, 28.0);
 4314|      1|    }
 4315|       |
 4316|       |    #[test]
 4317|      1|    fn test_superscript_expansion_basic() {
 4318|      1|        let s = "5^th^ and m^2^";
 4319|      1|        let out = MarkdownRenderer::expand_superscripts(s);
 4320|      1|        assert!(out.contains("5"));
 4321|      1|        assert!(out.contains("m"));
 4322|      1|    }
 4323|       |
 4324|       |    #[test]
 4325|      1|    fn test_superscript_expansion_single_caret() {
 4326|       |        // Test that single carets (not paired) are left as-is
 4327|      1|        let s = "2^32 = 4,294,967,296";
 4328|      1|        let out = MarkdownRenderer::expand_superscripts(s);
 4329|      1|        assert_eq!(
 4330|       |            out, "2^32 = 4,294,967,296",
 4331|      0|            "Single caret should be preserved"
 4332|       |        );
 4333|       |
 4334|       |        // Test the problematic line from the bug report
 4335|      1|        let problematic = "A 32-bit address bus would provide 2^32 = 4,294,967,296 bytes (4 GB) of addressable memory.";
 4336|      1|        let fixed = MarkdownRenderer::expand_superscripts(problematic);
 4337|      1|        assert_eq!(
 4338|       |            fixed, problematic,
 4339|      0|            "Text should remain unchanged when no paired carets exist"
 4340|       |        );
 4341|       |
 4342|       |        // Test mixed cases
 4343|      1|        let mixed = "Use 2^32 for math and 5^th^ for ordinal";
 4344|      1|        let result = MarkdownRenderer::expand_superscripts(mixed);
 4345|      1|        assert!(result.contains("2^32"), "Single caret should be preserved");
                                                       ^0
 4346|      1|        assert!(result.contains("5"), "Paired carets should be converted");
                                                         ^0
 4347|      1|    }
 4348|       |
 4349|       |    #[test]
 4350|      1|    fn test_font_sizes_default() {
 4351|      1|        let sizes = FontSizes::default();
 4352|      1|        assert_eq!(sizes.body, 14.0);
 4353|      1|        assert_eq!(sizes.h1, 28.0);
 4354|      1|        assert_eq!(sizes.code, 12.0);
 4355|      1|    }
 4356|       |
 4357|       |    #[test]
 4358|      1|    fn test_zoom_functionality() {
 4359|      1|        let mut renderer = MarkdownRenderer::new();
 4360|      1|        let original_body = renderer.font_sizes.body;
 4361|       |
 4362|      1|        renderer.zoom_in();
 4363|      1|        assert!(renderer.font_sizes.body > original_body);
 4364|       |
 4365|      1|        renderer.zoom_out();
 4366|      1|        assert!(renderer.font_sizes.body < original_body * 1.1);
 4367|       |
 4368|      1|        renderer.reset_zoom();
 4369|      1|        assert_eq!(renderer.font_sizes.body, original_body);
 4370|      1|    }
 4371|       |
 4372|       |    #[test]
 4373|      1|    fn font_size_change_does_not_repersist_stale_widths() {
 4374|      1|        let mut renderer = MarkdownRenderer::new();
 4375|      1|        let table_id = 7u64;
 4376|      1|        let specs = vec![ColumnSpec::new(
 4377|       |            "A",
 4378|      1|            ColumnPolicy::Resizable {
 4379|      1|                min: 20.0,
 4380|      1|                preferred: 100.0,
 4381|      1|                clip: false,
 4382|      1|            },
 4383|      1|            None,
 4384|       |        )];
 4385|      1|        let widths = vec![100.0f32];
 4386|       |
 4387|       |        // Initial persist at default font size.
 4388|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
 4389|      1|        let policy_hash = specs[0].policy_hash;
 4390|       |        {
 4391|      1|            let metrics = renderer.table_metrics.borrow();
 4392|      1|            let entry = metrics.entry(table_id).expect("entry created");
 4393|      1|            assert_eq!(entry.persisted_width(policy_hash), Some(100.0));
 4394|      1|            assert_eq!(entry.persisted_font_size, Some(renderer.font_sizes.body));
 4395|       |        }
 4396|       |
 4397|       |        // Simulate zoom: font size changes but widths captured are still the old ones.
 4398|      1|        renderer.font_sizes.body = 16.0;
 4399|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
 4400|       |        {
 4401|      1|            let metrics = renderer.table_metrics.borrow();
 4402|      1|            let entry = metrics.entry(table_id).expect("entry exists");
 4403|       |            // Cleared and NOT re-saved in the same frame.
 4404|      1|            assert_eq!(entry.persisted_width(policy_hash), None);
 4405|      1|            assert_eq!(entry.persisted_font_size, Some(16.0));
 4406|       |        }
 4407|       |
 4408|       |        // Next frame with new layout widths should persist again.
 4409|      1|        let new_widths = vec![80.0f32];
 4410|      1|        renderer.persist_resizable_widths(table_id, &specs, &new_widths);
 4411|      1|        let metrics = renderer.table_metrics.borrow();
 4412|      1|        let entry = metrics.entry(table_id).expect("entry exists");
 4413|      1|        assert_eq!(entry.persisted_width(policy_hash), Some(80.0));
 4414|      1|        assert_eq!(entry.persisted_font_size, Some(16.0));
 4415|      1|    }
 4416|       |
 4417|       |    #[test]
 4418|      1|    fn test_tight_list_inline_code_and_styles() {
 4419|      1|        let renderer = MarkdownRenderer::new();
 4420|      1|        let md = "- Use `code` and **bold** and *italic* and ~~strike~~\\n";
 4421|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4422|      1|        assert_eq!(parsed.len(), 1);
 4423|      1|        match &parsed[0] {
 4424|      1|            MarkdownElement::List { ordered, items } => {
 4425|      1|                assert!(!ordered);
 4426|      1|                assert_eq!(items.len(), 1);
 4427|      1|                let spans = &items[0];
 4428|      1|                assert!(spans
 4429|      1|                    .iter()
 4430|      1|                    .any(|s| matches!(s, InlineSpan::Code(c) if c == "code")));
 4431|      1|                assert!(spans
 4432|      1|                    .iter()
 4433|      1|                    .any(|s| matches!(s, InlineSpan::Strong(t) if t.contains("bold"))));
 4434|      1|                assert!(spans
 4435|      1|                    .iter()
 4436|      1|                    .any(|s| matches!(s, InlineSpan::Emphasis(t) if t.contains("italic"))));
 4437|      1|                assert!(spans
 4438|      1|                    .iter()
 4439|      1|                    .any(|s| matches!(s, InlineSpan::Strikethrough(t) if t.contains("strike"))));
 4440|       |            }
 4441|      0|            other => panic!("Expected List, got {:?}", other),
 4442|       |        }
 4443|      1|    }
 4444|       |
 4445|       |    #[test]
 4446|      1|    fn test_expand_shortcodes_basic() {
 4447|      1|        let rocket = MarkdownRenderer::expand_shortcodes(":rocket:");
 4448|      1|        assert_ne!(rocket, ":rocket:");
 4449|      1|        assert!(crate::emoji_catalog::image_bytes_for(&rocket).is_some());
 4450|       |
 4451|      1|        let tada = MarkdownRenderer::expand_shortcodes(":tada:");
 4452|      1|        assert_ne!(tada, ":tada:");
 4453|      1|        assert!(crate::emoji_catalog::image_bytes_for(&tada).is_some());
 4454|       |
 4455|      1|        assert_eq!(
 4456|      1|            MarkdownRenderer::expand_shortcodes("Hello :tada:!"),
 4457|      1|            format!("Hello {}!", tada)
 4458|       |        );
 4459|      1|    }
 4460|       |
 4461|       |    #[test]
 4462|      1|    fn test_fix_unicode_chars_normalizes_basic_cases() {
 4463|      1|        let renderer = MarkdownRenderer::new();
 4464|      1|        let input = "A\u{00A0}B\u{2013}C";
 4465|      1|        let normalized = renderer.normalize_text_for_test(input);
 4466|      1|        assert_eq!(normalized, "A B-C");
 4467|       |
 4468|      1|        let arrows = renderer.normalize_text_for_test("   ");
 4469|      1|        assert_eq!(arrows, "<- -> ^ v");
 4470|       |
 4471|      1|        let untouched = renderer.normalize_text_for_test("Plain text");
 4472|      1|        assert_eq!(untouched, "Plain text");
 4473|      1|    }
 4474|       |
 4475|       |    #[test]
 4476|      1|    fn test_elements_to_plain_text_basic() {
 4477|      1|        let elements = vec![
 4478|      1|            MarkdownElement::Header {
 4479|      1|                level: 1,
 4480|      1|                spans: vec![InlineSpan::Text("Test Header".to_string())],
 4481|      1|                id: "test-header".to_string(),
 4482|      1|            },
 4483|      1|            MarkdownElement::Paragraph(vec![
 4484|      1|                InlineSpan::Text("This is a ".to_string()),
 4485|      1|                InlineSpan::Strong("bold".to_string()),
 4486|      1|                InlineSpan::Text(" paragraph.".to_string()),
 4487|      1|            ]),
 4488|       |        ];
 4489|       |
 4490|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 4491|      1|        assert!(plain_text.contains("Test Header"));
 4492|      1|        assert!(plain_text.contains("This is a bold paragraph."));
 4493|      1|    }
 4494|       |
 4495|       |    #[test]
 4496|      1|    fn test_elements_to_plain_text_code_block() {
 4497|      1|        let elements = vec![MarkdownElement::CodeBlock {
 4498|      1|            language: Some("rust".to_string()),
 4499|      1|            text: "fn main() {\n    println!(\"Hello\");\n}".to_string(),
 4500|      1|        }];
 4501|       |
 4502|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 4503|      1|        assert_eq!(plain_text, "fn main() {\n    println!(\"Hello\");\n}");
 4504|      1|    }
 4505|       |
 4506|       |    #[test]
 4507|      1|    fn test_elements_to_plain_text_with_links() {
 4508|      1|        let elements = vec![MarkdownElement::Paragraph(vec![
 4509|      1|            InlineSpan::Text("Visit ".to_string()),
 4510|      1|            InlineSpan::Link {
 4511|      1|                text: "GitHub".to_string(),
 4512|      1|                url: "https://github.com".to_string(),
 4513|      1|            },
 4514|      1|            InlineSpan::Text(" for more.".to_string()),
 4515|      1|        ])];
 4516|       |
 4517|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 4518|      1|        assert_eq!(plain_text, "Visit GitHub for more.");
 4519|      1|    }
 4520|       |
 4521|       |    #[test]
 4522|      1|    fn test_image_source_stale_detects_file_changes() {
 4523|       |        use std::time::Duration as StdDuration;
 4524|       |
 4525|      1|        let dir = tempfile::tempdir().expect("temp dir");
 4526|      1|        let file_path = dir.path().join("image.bin");
 4527|      1|        std::fs::write(&file_path, [1u8, 2, 3, 4]).expect("write image");
 4528|      1|        let initial = MarkdownRenderer::disk_image_timestamp(&file_path);
 4529|      1|        assert!(!MarkdownRenderer::image_source_stale(initial, &file_path));
 4530|       |
 4531|      1|        std::thread::sleep(StdDuration::from_millis(5));
 4532|      1|        std::fs::write(&file_path, [4u8, 3, 2, 1]).expect("rewrite image");
 4533|       |
 4534|      1|        assert!(MarkdownRenderer::image_source_stale(initial, &file_path));
 4535|      1|    }
 4536|       |
 4537|       |    #[test]
 4538|      1|    fn test_inline_code_preserves_whitespace() {
 4539|      1|        let renderer = MarkdownRenderer::new();
 4540|      1|        let md = "Start `code` end";
 4541|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4542|      1|        match &parsed[0] {
 4543|      1|            MarkdownElement::Paragraph(spans) => {
 4544|      2|                let code_span = spans.iter().find_map(|span| match span {
                                  ^1          ^1           ^1
 4545|      1|                    InlineSpan::Code(t) => Some(t),
 4546|      1|                    _ => None,
 4547|      2|                });
 4548|      1|                assert_eq!(code_span, Some(&"code".to_string()));
 4549|       |            }
 4550|      0|            other => panic!("Expected Paragraph, got {:?}", other),
 4551|       |        }
 4552|      1|    }
 4553|       |
 4554|       |    #[test]
 4555|      1|    fn test_kroki_enabled_env_flag() {
 4556|      1|        std::env::remove_var("MDMDVIEW_ENABLE_KROKI");
 4557|      1|        assert!(!MarkdownRenderer::kroki_enabled_for_tests());
 4558|       |
 4559|      1|        std::env::set_var("MDMDVIEW_ENABLE_KROKI", "true");
 4560|      1|        assert!(MarkdownRenderer::kroki_enabled_for_tests());
 4561|       |
 4562|      1|        std::env::set_var("MDMDVIEW_ENABLE_KROKI", "0");
 4563|      1|        assert!(!MarkdownRenderer::kroki_enabled_for_tests());
 4564|       |
 4565|      1|        std::env::remove_var("MDMDVIEW_ENABLE_KROKI");
 4566|      1|    }
 4567|       |
 4568|       |    #[test]
 4569|      1|    fn test_spawn_kroki_job_reports_queue_disconnect() {
 4570|      1|        let mut renderer = MarkdownRenderer::new();
 4571|      1|        let (temp_tx, temp_rx) = crossbeam_channel::bounded::<KrokiRequest>(1);
 4572|      1|        drop(temp_rx);
 4573|      1|        renderer.kroki_job_tx = temp_tx;
 4574|      1|        let result = renderer.spawn_kroki_job(1, "graph TD; A-->B;");
 4575|      1|        assert!(matches!(result, Err(KrokiEnqueueError::Disconnected)));
                              ^0
 4576|      1|    }
 4577|       |
 4578|       |    #[test]
 4579|      1|    fn test_spawn_kroki_job_reports_queue_full() {
 4580|      1|        let mut renderer = MarkdownRenderer::new();
 4581|      1|        let (temp_tx, temp_rx) = crossbeam_channel::bounded::<KrokiRequest>(1);
 4582|       |        // Fill the bounded channel so subsequent sends report Full
 4583|      1|        temp_tx
 4584|      1|            .try_send(KrokiRequest {
 4585|      1|                key: 99,
 4586|      1|                url: "https://example.invalid/diagram".to_string(),
 4587|      1|                payload: "graph TD; A-->B;".to_string(),
 4588|      1|            })
 4589|      1|            .expect("pre-fill queue");
 4590|      1|        renderer.kroki_job_tx = temp_tx.clone();
 4591|       |        // Keep receiver alive (unused) to avoid disconnecting the channel
 4592|      1|        let _guard = temp_rx;
 4593|      1|        let result = renderer.spawn_kroki_job(42, "graph TD; B-->C;");
 4594|      1|        assert!(matches!(result, Err(KrokiEnqueueError::QueueFull)));
                              ^0
 4595|      1|    }
 4596|       |
 4597|       |    #[test]
 4598|      1|    fn test_footnote_markers_render_as_visible_text() {
 4599|      1|        let renderer = MarkdownRenderer::new();
 4600|      1|        let md = "Paragraph with footnote[^1].\n\n[^1]: footnote body.";
 4601|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4602|      1|        assert_eq!(parsed.len(), 2);
 4603|      1|        let first_plain = MarkdownRenderer::element_plain_text(&parsed[0]);
 4604|      1|        assert!(
 4605|      1|            first_plain.contains("footnote[^1]"),
 4606|      0|            "footnote marker should remain visible, got {first_plain}"
 4607|       |        );
 4608|      1|        let second_plain = MarkdownRenderer::element_plain_text(&parsed[1]);
 4609|      1|        assert!(
 4610|      1|            second_plain.contains("[^1]: footnote body."),
 4611|      0|            "footnote definition should remain visible, got {second_plain}"
 4612|       |        );
 4613|      1|    }
 4614|       |
 4615|       |    #[test]
 4616|      1|    fn test_parse_headers_assign_ids_and_dedupe() {
 4617|      1|        let renderer = MarkdownRenderer::new();
 4618|      1|        let md = "# Getting Started\n\n## Getting Started\n\n### API & Usage\n\n## API & Usage\n";
 4619|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4620|       |
 4621|      1|        let mut ids = vec![];
 4622|      5|        for el in parsed {
                          ^4
 4623|      4|            if let MarkdownElement::Header { id, .. } = el {
 4624|      4|                ids.push(id);
 4625|      4|            }
                          ^0
 4626|       |        }
 4627|      1|        assert_eq!(ids.len(), 4);
 4628|      1|        assert_eq!(ids[0], "getting-started");
 4629|      1|        assert_eq!(ids[1], "getting-started-1");
 4630|      1|        assert_eq!(ids[2], "api-usage");
 4631|      1|        assert_eq!(ids[3], "api-usage-1");
 4632|      1|    }
 4633|       |
 4634|       |    #[test]
 4635|      1|    fn test_formatting_sample_contains_expected_header_ids() {
 4636|      1|        let renderer = MarkdownRenderer::new();
 4637|      1|        let formatting = SAMPLE_FILES
 4638|      1|            .iter()
 4639|      2|            .find(|f| f.name == "formatting.md")
                           ^1
 4640|      1|            .expect("formatting sample present");
 4641|      1|        let parsed = renderer.parse(formatting.content).expect("parse ok");
 4642|      1|        let ids: Vec<String> = parsed
 4643|      1|            .into_iter()
 4644|     37|            .filter_map(|el| match el {
                           ^1
 4645|     18|                MarkdownElement::Header { id, .. } => Some(id),
 4646|     19|                _ => None,
 4647|     37|            })
 4648|      1|            .collect();
 4649|       |
 4650|     10|        for expected in [
 4651|       |            "markdown-formatting-guide",
 4652|      1|            "table-of-contents",
 4653|      1|            "text-formatting",
 4654|      1|            "headers",
 4655|      1|            "lists",
 4656|      1|            "links-and-images",
 4657|      1|            "emojis",
 4658|      1|            "blockquotes",
 4659|      1|            "horizontal-rules",
 4660|      1|            "tables",
 4661|       |        ] {
 4662|    101|            assert!(ids.iter().any(|id| id == expected), "missing id {expected}");
                          ^10     ^10        ^10                       ^0
 4663|       |        }
 4664|      1|    }
 4665|       |
 4666|       |    #[test]
 4667|      1|    fn test_inline_image_parsing() {
 4668|      1|        let renderer = MarkdownRenderer::new();
 4669|      1|        let md = "Here is an image: ![Alt text](images/pic.webp \"Title\") end.";
 4670|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4671|      1|        assert_eq!(parsed.len(), 1);
 4672|      1|        match &parsed[0] {
 4673|      1|            MarkdownElement::Paragraph(spans) => {
 4674|      2|                let img = spans.iter().find(|s| matches!(s, InlineSpan::Image { .. }));
                                  ^1    ^1           ^1
 4675|      1|                assert!(img.is_some(), "image inline span present");
                                                     ^0
 4676|      1|                if let InlineSpan::Image { src, alt, title } = img.unwrap() {
 4677|      1|                    assert_eq!(src, "images/pic.webp");
 4678|      1|                    assert_eq!(alt, "Alt text");
 4679|      1|                    assert_eq!(title.as_deref(), Some("Title"));
 4680|      0|                }
 4681|       |            }
 4682|      0|            other => panic!("Expected Paragraph, got {:?}", other),
 4683|       |        }
 4684|      1|    }
 4685|       |
 4686|       |    #[test]
 4687|      1|    fn test_image_text_in_plain_text_index() {
 4688|      1|        let renderer = MarkdownRenderer::new();
 4689|      1|        let md = "![Diagram](./a.png \"Flow\")";
 4690|      1|        let parsed = renderer.parse(md).expect("parse ok");
 4691|      1|        let text = MarkdownRenderer::element_plain_text(&parsed[0]);
 4692|      1|        assert!(text.contains("Diagram"));
 4693|      1|        assert!(text.contains("Flow"));
 4694|      1|    }
 4695|       |
 4696|       |    #[test]
 4697|      1|    fn test_cell_fragments_split_text_and_images() {
 4698|      1|        let renderer = MarkdownRenderer::new();
 4699|      1|        let spans = vec![
 4700|      1|            InlineSpan::Text("alpha".into()),
 4701|      1|            InlineSpan::Strong("beta".into()),
 4702|      1|            InlineSpan::Image {
 4703|      1|                src: "img.png".into(),
 4704|      1|                alt: "img".into(),
 4705|      1|                title: None,
 4706|      1|            },
 4707|      1|            InlineSpan::Text("gamma".into()),
 4708|       |        ];
 4709|      1|        let fragments = renderer.cell_fragments(&spans);
 4710|      1|        assert_eq!(fragments.len(), 3);
 4711|      1|        match &fragments[0] {
 4712|      1|            CellFragment::Text(slice) => assert_eq!(slice.len(), 2),
 4713|      0|            other => panic!("expected text fragment, got {:?}", other),
 4714|       |        }
 4715|      1|        match &fragments[1] {
 4716|      1|            CellFragment::Image(span) => {
 4717|      1|                if let InlineSpan::Image { src, .. } = span {
 4718|      1|                    assert_eq!(src, "img.png");
 4719|       |                } else {
 4720|      0|                    panic!("image fragment should point to inline image span");
 4721|       |                }
 4722|       |            }
 4723|      0|            other => panic!("second fragment should be image, got {:?}", other),
 4724|       |        }
 4725|      1|        match &fragments[2] {
 4726|      1|            CellFragment::Text(slice) => {
 4727|      1|                assert_eq!(slice.len(), 1);
 4728|      1|                if let InlineSpan::Text(content) = &slice[0] {
 4729|      1|                    assert_eq!(content, "gamma");
 4730|       |                } else {
 4731|      0|                    panic!("expected trailing text span");
 4732|       |                }
 4733|       |            }
 4734|      0|            other => panic!("expected trailing text fragment, got {:?}", other),
 4735|       |        }
 4736|      1|    }
 4737|       |
 4738|       |    #[test]
 4739|      1|    fn test_cell_fragments_detect_single_emoji_span() {
 4740|      1|        let renderer = MarkdownRenderer::new();
 4741|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 4742|      1|            .get(":rocket:")
 4743|      1|            .expect("rocket shortcode");
 4744|      1|        let spans = vec![
 4745|      1|            InlineSpan::Text((*rocket).to_string()),
 4746|      1|            InlineSpan::Text("tail".into()),
 4747|       |        ];
 4748|      1|        let fragments = renderer.cell_fragments(&spans);
 4749|      1|        assert_eq!(fragments.len(), 2);
 4750|      1|        assert!(matches!(
                              ^0
 4751|      1|            &fragments[0],
 4752|      1|            CellFragment::Emoji(e) if !e.is_empty()
 4753|       |        ));
 4754|      1|        assert!(matches!(fragments[1], CellFragment::Text(_)));
                              ^0
 4755|      1|    }
 4756|       |
 4757|       |    #[test]
 4758|      1|    fn test_layout_job_builder_respects_wrap_width() {
 4759|      1|        let renderer = MarkdownRenderer::new();
 4760|      1|        let spans = vec![InlineSpan::Text(
 4761|      1|            "A long column entry that should wrap neatly within the supplied width.".into(),
 4762|      1|        )];
 4763|      1|        let style = egui::Style::default();
 4764|      1|        let build = renderer.build_layout_job(&style, &spans, 180.0, false);
 4765|      1|        assert_eq!(build.job.wrap.max_width, 180.0);
 4766|      1|        assert!(
 4767|      1|            build.job.text.contains("column entry"),
 4768|      0|            "plain text should be preserved"
 4769|       |        );
 4770|      1|    }
 4771|       |
 4772|       |    #[test]
 4773|      1|    fn test_layout_job_builder_highlights_matches() {
 4774|      1|        let renderer = MarkdownRenderer::new();
 4775|      1|        renderer.set_highlight_phrase(Some("wrap"));
 4776|      1|        let spans = vec![InlineSpan::Text("wrap me, wrap me again".into())];
 4777|      1|        let style = egui::Style::default();
 4778|      1|        let build = renderer.build_layout_job(&style, &spans, 200.0, false);
 4779|      1|        let highlight_bg = style.visuals.selection.bg_fill;
 4780|      1|        assert!(
 4781|      1|            build
 4782|      1|                .job
 4783|      1|                .sections
 4784|      1|                .iter()
 4785|      1|                .any(|s| s.format.background == highlight_bg),
 4786|      0|            "at least one section should carry highlight background"
 4787|       |        );
 4788|      1|    }
 4789|       |
 4790|       |    #[test]
 4791|      1|    fn test_layout_job_builder_tracks_link_ranges() {
 4792|      1|        let renderer = MarkdownRenderer::new();
 4793|      1|        let spans = vec![InlineSpan::Link {
 4794|      1|            text: "Docs".into(),
 4795|      1|            url: "https://example.org/docs".into(),
 4796|      1|        }];
 4797|      1|        let style = egui::Style::default();
 4798|      1|        let build = renderer.build_layout_job(&style, &spans, 220.0, false);
 4799|      1|        assert_eq!(build.link_ranges.len(), 1);
 4800|      1|        let link = &build.link_ranges[0];
 4801|      1|        assert_eq!(link.url, "https://example.org/docs");
 4802|      1|        let char_len = link.char_range.end - link.char_range.start;
 4803|      1|        let linked_text: String = build
 4804|      1|            .job
 4805|      1|            .text
 4806|      1|            .chars()
 4807|      1|            .skip(link.char_range.start)
 4808|      1|            .take(char_len)
 4809|      1|            .collect();
 4810|      1|        assert_eq!(linked_text, "Docs");
 4811|      1|    }
 4812|       |
 4813|       |    #[test]
 4814|      1|    fn test_table_width_solver_keeps_short_columns_readable() {
 4815|      1|        let mins = vec![90.0, 90.0, 90.0, 90.0];
 4816|      1|        let desired = vec![120.0, 120.0, 360.0, 160.0];
 4817|      1|        let widths = MarkdownRenderer::resolve_table_widths(420.0, &mins, &desired);
 4818|      1|        assert_eq!(widths.len(), 4);
 4819|       |        // Narrow columns should stay near their minimums even when a wide column exists
 4820|      1|        assert!(
 4821|      1|            widths[0] >= 85.0,
 4822|      0|            "Version column shrank too far: {}",
 4823|      0|            widths[0]
 4824|       |        );
 4825|      1|        assert!(
 4826|      1|            widths[2] > widths[0],
 4827|      0|            "Wide column should retain more width"
 4828|       |        );
 4829|      1|        let sum: f32 = widths.iter().sum();
 4830|      1|        assert!(
 4831|      1|            (sum - 420.0).abs() < 0.5,
 4832|      0|            "Widths should consume available space, got {sum}"
 4833|       |        );
 4834|      1|    }
 4835|       |
 4836|       |    #[test]
 4837|      1|    fn test_table_width_solver_handles_constrained_space() {
 4838|      1|        let mins = vec![100.0, 100.0, 100.0, 100.0];
 4839|      1|        let desired = vec![200.0, 240.0, 360.0, 160.0];
 4840|      1|        let widths = MarkdownRenderer::resolve_table_widths(260.0, &mins, &desired);
 4841|      1|        assert_eq!(widths.len(), 4);
 4842|      1|        assert!(
 4843|      4|            widths.iter().all(|w| *w > 0.0),
                          ^1            ^1
 4844|      0|            "Widths must stay positive even when clamped hard"
 4845|       |        );
 4846|      1|        let sum: f32 = widths.iter().sum();
 4847|      1|        assert!(
 4848|      1|            (sum - 260.0).abs() < 0.5,
 4849|      0|            "Widths should sum to available space even under tight constraints"
 4850|       |        );
 4851|      1|    }
 4852|       |
 4853|       |    #[test]
 4854|      1|    fn table_cells_keep_images_and_formatting() {
 4855|      1|        let renderer = MarkdownRenderer::new();
 4856|      1|        let md = "\
 4857|      1|| H1 | H2 |
 4858|      1|| --- | --- |
 4859|      1|| text ![Alt](img.png) | **bold** and [link](https://example.com) |";
 4860|      1|        let elements = renderer.parse(md).expect("parse ok");
 4861|      1|        let table = elements
 4862|      1|            .iter()
 4863|      1|            .find_map(|el| match el {
 4864|      1|                MarkdownElement::Table { headers: _, rows } => Some(rows),
 4865|      0|                _ => None,
 4866|      1|            })
 4867|      1|            .expect("table present");
 4868|      1|        assert_eq!(table.len(), 1);
 4869|      1|        let row = &table[0];
 4870|      1|        assert!(row[0]
 4871|      1|            .iter()
 4872|      1|            .any(|span| matches!(span, InlineSpan::Image { src, .. } if src == "img.png")));
 4873|      1|        assert!(row[1]
 4874|      1|            .iter()
 4875|      1|            .any(|span| matches!(span, InlineSpan::Strong(text) if text.contains("bold"))));
 4876|      1|        assert!(row[1].iter().any(|span| matches!(
 4877|      1|            span,
 4878|      1|            InlineSpan::Link { url, .. } if url == "https://example.com"
 4879|       |        )));
 4880|      1|    }
 4881|       |
 4882|       |    #[test]
 4883|      1|    fn table_ids_are_unique_per_position() {
 4884|      1|        let renderer = MarkdownRenderer::new();
 4885|      1|        let md = "\
 4886|      1|| H |
 4887|      1|| - |
 4888|      1|| a |
 4889|      1|
 4890|      1|| H |
 4891|      1|| - |
 4892|      1|| a |";
 4893|      1|        let elements = renderer.parse(md).expect("parse ok");
 4894|      1|        let tables: Vec<_> = elements
 4895|      1|            .iter()
 4896|      1|            .enumerate()
 4897|      2|            .filter_map(|(idx, el)| match el {
                           ^1
 4898|      2|                MarkdownElement::Table { headers, rows } => {
 4899|      2|                    Some(renderer.compute_table_id(headers, rows, idx))
 4900|       |                }
 4901|      0|                _ => None,
 4902|      2|            })
 4903|      1|            .collect();
 4904|      1|        assert_eq!(tables.len(), 2);
 4905|      1|        assert_ne!(tables[0], tables[1], "table ids should differ by position");
                                                       ^0
 4906|      1|    }
 4907|       |}

C:\language\mdmdview\src\sample_files.rs:
    1|       |//! Sample markdown files embedded in the application
    2|       |//!
    3|       |//! These files demonstrate the markdown viewer capabilities and provide
    4|       |//! usage instructions. They are built into the executable for easy access.
    5|       |
    6|       |/// Represents a sample markdown file with metadata
    7|       |#[derive(Debug, Clone)]
    8|       |pub struct SampleFile {
    9|       |    pub name: &'static str,
   10|       |    pub title: &'static str,
   11|       |    pub content: &'static str,
   12|       |}
   13|       |
   14|       |/// Collection of all embedded sample files
   15|       |pub const SAMPLE_FILES: &[SampleFile] = &[
   16|       |    SampleFile {
   17|       |        name: "welcome.md",
   18|       |        title: "Welcome to MarkdownView",
   19|       |        content: WELCOME_CONTENT,
   20|       |    },
   21|       |    SampleFile {
   22|       |        name: "formatting.md",
   23|       |        title: "Formatting Examples",
   24|       |        content: FORMATTING_CONTENT,
   25|       |    },
   26|       |    SampleFile {
   27|       |        name: "code.md",
   28|       |        title: "Code Examples",
   29|       |        content: CODE_CONTENT,
   30|       |    },
   31|       |    SampleFile {
   32|       |        name: "usage.md",
   33|       |        title: "Usage Instructions",
   34|       |        content: USAGE_CONTENT,
   35|       |    },
   36|       |    SampleFile {
   37|       |        name: "search.md",
   38|       |        title: "Search Tips & Examples",
   39|       |        content: SEARCH_GUIDE_CONTENT,
   40|       |    },
   41|       |    SampleFile {
   42|       |        name: "images.md",
   43|       |        title: "Inline Images & Diagrams",
   44|       |        content: IMAGES_CONTENT,
   45|       |    },
   46|       |];
   47|       |
   48|       |/// Welcome content with basic introduction
   49|       |const WELCOME_CONTENT: &str = r#"# Welcome to MarkdownView
   50|       |
   51|       |A simple, fast markdown viewer for Windows built with Rust and egui.
   52|       |
   53|       |## Features
   54|       |
   55|       |- **Pure Rust Implementation** - Single executable, no dependencies
   56|       |- **Fast Rendering** - Efficient markdown parsing with pulldown-cmark
   57|       |- **Syntax Highlighting** - Code blocks with proper syntax coloring
   58|       |- **Native File Dialogs** - Seamless Windows integration
   59|       |- **Embedded Examples** - Built-in sample files to explore
   60|       |
   61|       |## Quick Start
   62|       |
   63|       |1. **Open a File**: Use `File  Open` or `Ctrl+O` to load a markdown file
   64|       |2. **Browse Samples**: Use `File  Samples` to explore built-in examples
   65|       |3. **Navigate**: Scroll to read through documents
   66|       |
   67|       |Enjoy reading your markdown files with this lightweight, efficient viewer!
   68|       |
   69|       |---
   70|       |
   71|       |*Built with  using Rust, egui, and pulldown-cmark*
   72|       |"#;
   73|       |
   74|       |const FORMATTING_CONTENT: &str = r#"# Markdown Formatting Guide
   75|       |
   76|       |This document demonstrates the various formatting options supported by MarkdownView.
   77|       |
   78|       |## Table of Contents
   79|       |
   80|       |- [Text Formatting](#text-formatting)
   81|       |- [Headers](#headers)
   82|       |- [Lists](#lists)
   83|       |- [Links and Images](#links-and-images)
   84|       |- [Emojis](#emojis)
   85|       |- [Blockquotes](#blockquotes)
   86|       |- [Horizontal Rules](#horizontal-rules)
   87|       |- [Tables](#tables)
   88|       |
   89|       |Quick jump: [Go to Lists](#lists)  [Go to Tables](#tables)
   90|       |
   91|       |## Text Formatting
   92|       |
   93|       |**Bold text** and *italic text* are supported, as well as ***bold italic***.
   94|       |
   95|       |You can also use `inline code` and ~~strikethrough~~ text.
   96|       |
   97|       |## Headers
   98|       |
   99|       |# Header 1
  100|       |## Header 2  
  101|       |### Header 3
  102|       |#### Header 4
  103|       |##### Header 5
  104|       |###### Header 6
  105|       |
  106|       |## Lists
  107|       |
  108|       |### Unordered Lists
  109|       |
  110|       |- First item
  111|       |- Second item
  112|       |  - Nested item
  113|       |  - Another nested item
  114|       |- Third item
  115|       |- Inline code in bullets works: use `--help` or `cargo run`
  116|       |- Styled + emoji in bullets: **:rocket:** launch, *:tada:* celebration, and ~~:fire:~~ warning
  117|       |- Tight list check: this item has :rocket: and `code` without blank lines between items
  118|       |
  119|       |### Ordered Lists
  120|       |
  121|       |1. First item
  122|       |2. Second item
  123|       |   1. Nested numbered item
  124|       |   2. Another nested item
  125|       |3. Third item
  126|       |
  127|       |## Links and Images
  128|       |
  129|       |[Visit Rust's website](https://rust-lang.org)
  130|       |
  131|       |Internal anchors let you jump within this document:
  132|       |- [Jump to Headers](#headers)
  133|       |- [Jump to Tables](#tables)
  134|       |- [Back to top](#markdown-formatting-guide)
  135|       |
  136|       |Links are clickable and will open in your default browser.
  137|       |
  138|       |## Emojis
  139|       |
  140|       |Unicode emojis render as normal text if your font supports them.
  141|       |Examples: Thanks!   Status:   Ship it 
  142|       |
  143|       |Shortcodes like `:rocket:` and `:tada:` are expanded to emoji images in normal text, headers, and list items.
  144|       |
  145|       |## Blockquotes
  146|       |
  147|       |> This is a blockquote.
  148|       |> It can span multiple lines.
  149|       |> 
  150|       |> > Nested blockquotes are also supported.
  151|       |
  152|       |## Horizontal Rules
  153|       |
  154|       |---
  155|       |
  156|       |## Tables
  157|       |
  158|       || Feature | Supported | Notes |
  159|       ||---------|-----------|-------|
  160|       || Headers |  | All levels 1-6 |
  161|       || Lists |  | Ordered and unordered |
  162|       || Code blocks |  | With syntax highlighting |
  163|       || Tables |  | Basic table support |
  164|       || Links |  | Opens in browser; internal anchors scroll indocument |
  165|       |
  166|       |---
  167|       |
  168|       |*This covers most of the formatting features available in MarkdownView.*  
  169|       |[Back to top](#markdown-formatting-guide)
  170|       |"#;
  171|       |
  172|       |/// Code examples with syntax highlighting
  173|       |const SEARCH_GUIDE_CONTENT: &str = concat!(
  174|       |    "# Search Tips & Examples\n\n",
  175|       |    "MarkdownView's search panel is accent-aware and case-insensitive. A single query matches multiple spellings automatically.\n\n",
  176|       |    "## Accent Folding\n\n",
  177|       |    "- Typing `resume` highlights `r\u{00e9}sum\u{00e9}`, `RESUME`, and `re\u{0301}sume` (precomposed vs. combining accent).\n",
  178|       |    "- `istanbul` matches both `\u{0130}stanbul` (Turkish dotted capital I) and `ISTANBUL`.\n",
  179|       |    "- `sao` finds `S\u{00e3}o`, `SAO`, and `Sao` regardless of combining marks.\n",
  180|       |    "- `nino` finds `Ni\u{00f1}o`, `NINO`, and `nin\u{0303}o`.\n\n",
  181|       |    "Try opening this sample, pressing `Ctrl+F`, and searching for the words below:\n\n",
  182|       |    "| Query | Matches in this document |\n",
  183|       |    "|-------|-------------------------|\n",
  184|       |    "| `resume` | r\u{00e9}sum\u{00e9}, RESUME, re\u{0301}sume |\n",
  185|       |    "| `istanbul` | \u{0130}stanbul, ISTANBUL |\n",
  186|       |    "| `sao` | S\u{00e3}o, SAO, Sao |\n",
  187|       |    "| `nino` | Ni\u{00f1}o, NINO, nin\u{0303}o |\n\n",
  188|       |    "> Tip: Use `Enter` / `Shift+Enter` to cycle through matches. The highlight respects grapheme clusters, so emoji and combined characters stay intact.\n\n",
  189|       |);
  190|       |const IMAGES_CONTENT: &str = r#"# Inline Images & Diagrams
  191|       |
  192|       |This sample demonstrates inline images and Mermaid code blocks.
  193|       |
  194|       |## PNG Image
  195|       |
  196|       |Below is a PNG image using an embedded emoji asset.
  197|       |
  198|       |![Smiley PNG](assets/emoji/1f600.png "PNG emoji sample")
  199|       |
  200|       |## SVG Image
  201|       |
  202|       |An SVG logo rendered via resvg/tiny-skia.
  203|       |
  204|       |![SVG Logo](assets/samples/logo.svg "SVG sample logo")
  205|       |
  206|       |## WEBP Image
  207|       |
  208|       |A small WEBP sample is bundled for testing.
  209|       |
  210|       |![WEBP Sample](assets/samples/webp_sample.webp "WEBP sample")
  211|       |
  212|       |## Mermaid Diagram (feature-gated)
  213|       |
  214|       |When the `mermaid-quickjs` feature is enabled, Mermaid code blocks are rendered as diagrams.
  215|       |Otherwise, the source is shown with an informational note.
  216|       |
  217|       |```mermaid
  218|       |graph TD;
  219|       |    A[Start] --> B{Is SVG supported?};
  220|       |    B -- Yes --> C[Rasterize via resvg];
  221|       |    B -- No  --> D[Show placeholder];
  222|       |    C --> E[Display egui texture];
  223|       |    D --> E;
  224|       |```
  225|       |
  226|       |## Notes
  227|       |
  228|       |- The WEBP sample is at `assets/samples/webp_sample.webp`. See `examples/webp_test.md` for a standalone test file.
  229|       |
  230|       |"#;
  231|       |
  232|       |const CODE_CONTENT: &str = r#"# Code Examples
  233|       |
  234|       |MarkdownView supports syntax highlighting for many programming languages.
  235|       |
  236|       |## Rust Code
  237|       |
  238|       |```rust
  239|       |fn main() {
  240|       |    println!("Hello, world!");
  241|       |    
  242|       |    let mut vector = vec![1, 2, 3, 4, 5];
  243|       |    vector.iter()
  244|       |        .filter(|&x| x % 2 == 0)
  245|       |        .for_each(|x| println!("Even number: {}", x));
  246|       |}
  247|       |
  248|       |// Struct definition with lifetimes
  249|       |struct Config<'a> {
  250|       |    name: &'a str,
  251|       |    version: u32,
  252|       |}
  253|       |
  254|       |impl<'a> Config<'a> {
  255|       |    fn new(name: &'a str) -> Self {
  256|       |        Config { name, version: 1 }
  257|       |    }
  258|       |}
  259|       |```
  260|       |
  261|       |## Python Code
  262|       |
  263|       |```python
  264|       |def fibonacci(n):
  265|       |    """Generate fibonacci sequence up to n"""
  266|       |    if n <= 0:
  267|       |        return []
  268|       |    elif n == 1:
  269|       |        return [0]
  270|       |    
  271|       |    sequence = [0, 1]
  272|       |    while len(sequence) < n:
  273|       |        sequence.append(sequence[-1] + sequence[-2])
  274|       |    
  275|       |    return sequence
  276|       |
  277|       |# List comprehension example
  278|       |squares = [x**2 for x in range(10) if x % 2 == 0]
  279|       |print(f"Even squares: {squares}")
  280|       |```
  281|       |
  282|       |## JavaScript Code
  283|       |
  284|       |```javascript
  285|       |// Modern JavaScript with async/await
  286|       |async function fetchUserData(userId) {
  287|       |    try {
  288|       |        const response = await fetch(`/api/users/${userId}`);
  289|       |        const userData = await response.json();
  290|       |        
  291|       |        return {
  292|       |            ...userData,
  293|       |            lastUpdated: new Date().toISOString()
  294|       |        };
  295|       |    } catch (error) {
  296|       |        console.error('Failed to fetch user data:', error);
  297|       |        throw error;
  298|       |    }
  299|       |}
  300|       |
  301|       |// Arrow functions and destructuring
  302|       |const processData = ({ name, age, email }) => ({
  303|       |    displayName: name.toUpperCase(),
  304|       |    isAdult: age >= 18,
  305|       |    emailDomain: email.split('@')[1]
  306|       |});
  307|       |```
  308|       |
  309|       |## SQL Code
  310|       |
  311|       |```sql
  312|       |-- Complex query with joins and aggregation
  313|       |SELECT 
  314|       |    u.username,
  315|       |    u.email,
  316|       |    COUNT(o.id) as total_orders,
  317|       |    SUM(oi.price * oi.quantity) as total_spent
  318|       |FROM users u
  319|       |LEFT JOIN orders o ON u.id = o.user_id
  320|       |LEFT JOIN order_items oi ON o.id = oi.order_id
  321|       |WHERE u.created_at >= '2023-01-01'
  322|       |GROUP BY u.id, u.username, u.email
  323|       |HAVING COUNT(o.id) > 5
  324|       |ORDER BY total_spent DESC
  325|       |LIMIT 20;
  326|       |```
  327|       |
  328|       |## Inline Code
  329|       |
  330|       |You can also use `inline code` within paragraphs, like `let x = 42;` or `print("hello")`.
  331|       |
  332|       |---
  333|       |
  334|       |*Syntax highlighting is powered by the syntect library, supporting dozens of languages.*
  335|       |"#;
  336|       |
  337|       |/// Usage instructions and tips
  338|       |const USAGE_CONTENT: &str = r#"# Usage Instructions
  339|       |
  340|       |## Opening Files
  341|       |
  342|       |### File Menu
  343|       |- Use `File  Open` from the menu bar
  344|       |- Keyboard shortcut: `Ctrl+O`
  345|       |- Select any `.md` or `.markdown` file from your system
  346|       |
  347|       |### Drag and Drop
  348|       |- Drag markdown files directly into the application window
  349|       |- Multiple files can be opened in sequence
  350|       |
  351|       |## Viewing Sample Files
  352|       |
  353|       |### Built-in Examples
  354|       |- Use `File  Samples` to browse embedded examples
  355|       |- These files demonstrate various markdown features
  356|       |- Perfect for testing and learning
  357|       |
  358|       |### Sample File List
  359|       |- **welcome.md** - Introduction and overview
  360|       |- **formatting.md** - Text formatting examples  
  361|       |- **code.md** - Syntax highlighting examples
  362|       |- **usage.md** - This usage guide
  363|       |
  364|       |## Navigation
  365|       |
  366|       |### Scrolling
  367|       |- Use mouse wheel or trackpad to scroll
  368|       |- Keyboard arrows for line-by-line navigation
  369|       |- Page Up/Page Down for faster scrolling
  370|       |
  371|       |### Window Controls
  372|       |- Resize the window as needed
  373|       |- Content automatically reflows
  374|       |- Minimum window size is enforced
  375|       |
  376|       |## Keyboard Shortcuts
  377|       |
  378|       || Shortcut | Action |
  379|       ||----------|--------|
  380|       || `Ctrl+O` | Open file |
  381|       || `Ctrl+W` | Close current file |
  382|       || `F5` | Reload current file |
  383|       || `Ctrl+Q` | Quit application |
  384|       || `F11` | Toggle fullscreen |
  385|       || `Ctrl++` | Zoom in (increase font size) |
  386|       || `Ctrl+-` | Zoom out (decrease font size) |
  387|       || `Ctrl` + Mouse Wheel | Zoom in/out |
  388|       || `Ctrl+0` | Reset zoom to default size |
  389|       || `Home` | Go to top of document |
  390|       || `End` | Go to bottom of document |
  391|       || `Page Up` | Scroll up one page |
  392|       || `Page Down` | Scroll down one page |
  393|       |
  394|       |## File Associations
  395|       |
  396|       |### Windows Integration
  397|       |To make MarkdownView the default for `.md` files:
  398|       |
  399|       |1. Right-click any `.md` file
  400|       |2. Select "Open with  Choose another app"
  401|       |3. Browse to the MarkdownView executable
  402|       |4. Check "Always use this app"
  403|       |
  404|       |### Supported Extensions
  405|       |- `.md` - Standard markdown files
  406|       |- `.markdown` - Alternative markdown extension
  407|       |- `.mdown` - Another common variation
  408|       |- `.mkd` - Short markdown extension
  409|       |
  410|       |## Performance
  411|       |
  412|       |### Large Files
  413|       |- Files up to several MB render efficiently
  414|       |- Very large files (>10MB) may take a moment to parse
  415|       |- Consider breaking up extremely large documents
  416|       |
  417|       |### Memory Usage
  418|       |- Minimal memory footprint
  419|       |- Parsed content is cached for fast scrolling
  420|       |- No memory leaks during normal operation
  421|       |
  422|       |## Troubleshooting
  423|       |
  424|       |### Common Issues
  425|       |
  426|       |**File won't open**
  427|       |- Check file extension is `.md` or `.markdown`
  428|       |- Ensure file isn't locked by another application
  429|       |- Verify file contains valid UTF-8 text
  430|       |
  431|       |**Display issues**
  432|       |- Try resizing the window
  433|       |- Restart the application
  434|       |- Check if file contains very long lines
  435|       |
  436|       |**Performance problems**
  437|       |- Close and reopen large files
  438|       |- Ensure adequate system memory
  439|       |- Consider breaking up large documents
  440|       |
  441|       |### Getting Help
  442|       |
  443|       |For bugs or feature requests:
  444|       |1. Check the application works with sample files
  445|       |2. Try reproducing with a minimal markdown file
  446|       |3. Note your Windows version and system specs
  447|       |
  448|       |---
  449|       |
  450|       |*Thank you for using MarkdownView! We hope it serves your markdown reading needs well.*
  451|       |"#;
  452|       |
  453|       |#[cfg(test)]
  454|       |mod tests {
  455|       |    use super::*;
  456|       |
  457|       |    #[test]
  458|      1|    fn test_sample_files_exist() {
  459|      1|        assert_eq!(SAMPLE_FILES.len(), 6);
  460|       |
  461|      1|        let names: Vec<&str> = SAMPLE_FILES.iter().map(|f| f.name).collect();
  462|      1|        assert!(names.contains(&"welcome.md"));
  463|      1|        assert!(names.contains(&"formatting.md"));
  464|      1|        assert!(names.contains(&"code.md"));
  465|      1|        assert!(names.contains(&"usage.md"));
  466|      1|        assert!(names.contains(&"search.md"));
  467|      1|        assert!(names.contains(&"images.md"));
  468|      1|    }
  469|       |
  470|       |    #[test]
  471|      1|    fn test_sample_files_content_not_empty() {
  472|      7|        for file in SAMPLE_FILES {
                          ^6
  473|      6|            assert!(
  474|      6|                !file.content.is_empty(),
  475|      0|                "File {} has empty content",
  476|       |                file.name
  477|       |            );
  478|      6|            assert!(!file.title.is_empty(), "File {} has empty title", file.name);
                                                          ^0
  479|      6|            assert!(!file.name.is_empty(), "File has empty name");
                                                         ^0
  480|       |        }
  481|      1|    }
  482|       |
  483|       |    #[test]
  484|      1|    fn test_sample_files_are_valid_markdown() {
  485|       |        use pulldown_cmark::{Options, Parser};
  486|       |
  487|      7|        for file in SAMPLE_FILES {
                          ^6
  488|      6|            let parser = Parser::new_ext(file.content, Options::all());
  489|      6|            let events: Vec<_> = parser.collect();
  490|      6|            assert!(
  491|      6|                !events.is_empty(),
  492|      0|                "File {} produces no markdown events",
  493|       |                file.name
  494|       |            );
  495|       |        }
  496|      1|    }
  497|       |
  498|       |    #[test]
  499|      1|    fn test_welcome_content_structure() {
  500|      1|        assert!(WELCOME_CONTENT.contains("# Welcome"));
  501|      1|        assert!(WELCOME_CONTENT.contains("## Features"));
  502|      1|        assert!(WELCOME_CONTENT.contains("## Quick Start"));
  503|      1|    }
  504|       |
  505|       |    #[test]
  506|      1|    fn test_formatting_content_examples() {
  507|      1|        assert!(FORMATTING_CONTENT.contains("**Bold text**"));
  508|      1|        assert!(FORMATTING_CONTENT.contains("*italic text*"));
  509|      1|        assert!(FORMATTING_CONTENT.contains("`inline code`"));
  510|      1|        assert!(FORMATTING_CONTENT.contains("| Feature | Supported |"));
  511|      1|    }
  512|       |
  513|       |    #[test]
  514|      1|    fn test_code_content_languages() {
  515|      1|        assert!(CODE_CONTENT.contains("```rust"));
  516|      1|        assert!(CODE_CONTENT.contains("```python"));
  517|      1|        assert!(CODE_CONTENT.contains("```javascript"));
  518|      1|        assert!(CODE_CONTENT.contains("```sql"));
  519|      1|    }
  520|       |
  521|       |    #[test]
  522|      1|    fn test_usage_content_sections() {
  523|      1|        assert!(USAGE_CONTENT.contains("## Opening Files"));
  524|      1|        assert!(USAGE_CONTENT.contains("## Keyboard Shortcuts"));
  525|      1|        assert!(USAGE_CONTENT.contains("## Troubleshooting"));
  526|      1|    }
  527|       |
  528|       |    #[test]
  529|      1|    fn test_search_guide_examples_present() {
  530|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("rsum"));
  531|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("stanbul"));
  532|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("So"));
  533|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("Nio"));
  534|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("Ctrl+F"));
  535|      1|    }
  536|       |}

C:\language\mdmdview\src\table_support\column_spec.rs:
    1|       |use std::cmp::max;
    2|       |use std::hash::{Hash, Hasher};
    3|       |
    4|       |use egui_extras::Column;
    5|       |use unicode_segmentation::UnicodeSegmentation;
    6|       |use unicode_width::UnicodeWidthStr;
    7|       |
    8|       |use crate::markdown_renderer::InlineSpan;
    9|       |
   10|       |const MAX_REMAINDER_COLUMNS: usize = 2;
   11|       |
   12|     17|fn normalize_body_font_px(body: f32) -> f32 {
   13|     17|    if body.is_finite() && body > 4.0 {
   14|     17|        body
   15|       |    } else {
   16|      0|        14.0
   17|       |    }
   18|     17|}
   19|       |
   20|     17|fn px(body_px: f32, factor: f32) -> f32 {
   21|     17|    normalize_body_font_px(body_px) * factor
   22|     17|}
   23|       |
   24|       |#[derive(Debug, Clone, PartialEq)]
   25|       |pub enum ColumnPolicy {
   26|       |    Auto,
   27|       |    Fixed {
   28|       |        width: f32,
   29|       |        clip: bool,
   30|       |    },
   31|       |    Remainder {
   32|       |        clip: bool,
   33|       |    },
   34|       |    Resizable {
   35|       |        min: f32,
   36|       |        preferred: f32,
   37|       |        clip: bool,
   38|       |    },
   39|       |}
   40|       |
   41|       |impl ColumnPolicy {
   42|      0|    pub fn to_column(&self) -> Column {
   43|      0|        match self {
   44|      0|            ColumnPolicy::Auto => Column::auto(),
   45|      0|            ColumnPolicy::Fixed { width, clip } => {
   46|      0|                let mut col = Column::exact(*width);
   47|      0|                if *clip {
   48|      0|                    col = col.clip(true);
   49|      0|                }
   50|      0|                col
   51|       |            }
   52|      0|            ColumnPolicy::Remainder { clip } => {
   53|      0|                let mut col = Column::remainder();
   54|      0|                if *clip {
   55|      0|                    col = col.clip(true);
   56|      0|                }
   57|      0|                col
   58|       |            }
   59|       |            ColumnPolicy::Resizable {
   60|      0|                min,
   61|      0|                preferred,
   62|      0|                clip,
   63|       |            } => {
   64|      0|                let mut col = Column::initial(*preferred).at_least(*min).resizable(true);
   65|      0|                if *clip {
   66|      0|                    col = col.clip(true);
   67|      0|                }
   68|      0|                col
   69|       |            }
   70|       |        }
   71|      0|    }
   72|       |}
   73|       |
   74|       |impl Hash for ColumnPolicy {
   75|     18|    fn hash<H: Hasher>(&self, state: &mut H) {
   76|     18|        std::mem::discriminant(self).hash(state);
   77|     18|        match self {
   78|      0|            ColumnPolicy::Auto => {}
   79|      3|            ColumnPolicy::Fixed { width, clip } => {
   80|      3|                width.to_bits().hash(state);
   81|      3|                clip.hash(state);
   82|      3|            }
   83|      7|            ColumnPolicy::Remainder { clip } => {
   84|      7|                clip.hash(state);
   85|      7|            }
   86|       |            ColumnPolicy::Resizable {
   87|      8|                min,
   88|      8|                preferred,
   89|      8|                clip,
   90|      8|            } => {
   91|      8|                min.to_bits().hash(state);
   92|      8|                preferred.to_bits().hash(state);
   93|      8|                clip.hash(state);
   94|      8|            }
   95|       |        }
   96|     18|    }
   97|       |}
   98|       |
   99|       |#[derive(Debug, Clone)]
  100|       |pub struct ColumnSpec {
  101|       |    pub ident: String,
  102|       |    pub policy: ColumnPolicy,
  103|       |    pub tooltip: Option<String>,
  104|       |    pub policy_hash: u64,
  105|       |}
  106|       |
  107|       |impl ColumnSpec {
  108|     16|    pub fn new(ident: impl Into<String>, policy: ColumnPolicy, tooltip: Option<String>) -> Self {
  109|     16|        let ident = ident.into();
  110|     16|        let policy_hash = calculate_policy_hash(&ident, &policy);
  111|     16|        Self {
  112|     16|            ident,
  113|     16|            policy,
  114|     16|            tooltip,
  115|     16|            policy_hash,
  116|     16|        }
  117|     16|    }
  118|       |
  119|      0|    pub fn as_column(&self) -> Column {
  120|      0|        self.policy.to_column()
  121|      0|    }
  122|       |
  123|      2|    pub fn set_policy(&mut self, policy: ColumnPolicy) {
  124|      2|        self.policy = policy;
  125|      2|        self.policy_hash = calculate_policy_hash(&self.ident, &self.policy);
  126|      2|    }
  127|       |
  128|      0|    pub fn apply_preferred_width(&mut self, width: f32) {
  129|       |        if let ColumnPolicy::Resizable {
  130|      0|            min,
  131|      0|            ref mut preferred,
  132|       |            ..
  133|      0|        } = self.policy
  134|      0|        {
  135|      0|            let clamped = width.max(min);
  136|      0|            *preferred = clamped;
  137|      0|            self.policy_hash = calculate_policy_hash(&self.ident, &self.policy);
  138|      0|        }
  139|      0|    }
  140|       |}
  141|       |
  142|       |#[derive(Debug, Clone, Copy, Default)]
  143|       |pub struct RichContentFlags {
  144|       |    pub has_link: bool,
  145|       |    pub has_image: bool,
  146|       |    pub has_emoji_like: bool,
  147|       |}
  148|       |
  149|       |#[derive(Debug, Clone, Default)]
  150|       |pub struct ColumnStat {
  151|       |    pub max_graphemes: usize,
  152|       |    pub longest_word: usize,
  153|       |    pub rich_content: RichContentFlags,
  154|       |}
  155|       |
  156|       |pub struct TableColumnContext<'a> {
  157|       |    pub headers: &'a [Vec<InlineSpan>],
  158|       |    pub rows: &'a [Vec<Vec<InlineSpan>>],
  159|       |    pub stats: &'a [ColumnStat],
  160|       |    pub body_font_px: f32,
  161|       |    pub table_id: u64,
  162|       |}
  163|       |
  164|       |impl<'a> TableColumnContext<'a> {
  165|      6|    pub fn new(
  166|      6|        headers: &'a [Vec<InlineSpan>],
  167|      6|        rows: &'a [Vec<Vec<InlineSpan>>],
  168|      6|        stats: &'a [ColumnStat],
  169|      6|        body_font_px: f32,
  170|      6|        table_id: u64,
  171|      6|    ) -> Self {
  172|      6|        Self {
  173|      6|            headers,
  174|      6|            rows,
  175|      6|            stats,
  176|      6|            body_font_px,
  177|      6|            table_id,
  178|      6|        }
  179|      6|    }
  180|       |
  181|     20|    pub fn column_stat(&self, idx: usize) -> Option<&ColumnStat> {
  182|     20|        self.stats.get(idx)
  183|     20|    }
  184|       |}
  185|       |
  186|     18|fn calculate_policy_hash(ident: &str, policy: &ColumnPolicy) -> u64 {
  187|     18|    let mut hasher = std::collections::hash_map::DefaultHasher::new();
  188|     18|    ident.hash(&mut hasher);
  189|     18|    policy.hash(&mut hasher);
  190|     18|    hasher.finish()
  191|     18|}
  192|       |
  193|      6|pub fn derive_column_specs(ctx: &TableColumnContext) -> Vec<ColumnSpec> {
  194|      6|    let mut remainder_assigned = 0usize;
  195|      6|    let mut fallback_idx: Option<usize> = None;
  196|      6|    let mut fallback_score: usize = 0;
  197|      6|    let column_count = ctx
  198|      6|        .stats
  199|      6|        .len()
  200|      6|        .max(ctx.headers.len())
  201|      6|        .max(ctx.rows.iter().map(|r| r.len()).max().unwrap_or(0));
                                                   ^2^2
  202|       |
  203|      6|    let mut scored_indices: Vec<(usize, usize)> = Vec::with_capacity(column_count);
  204|       |
  205|      6|    let mut specs: Vec<ColumnSpec> = (0..column_count)
  206|     15|        .map(|idx| {
                       ^6
  207|     15|            let spans = ctx.headers.get(idx).map(|v| v.as_slice()).unwrap_or(&[]);
  208|     15|            let label = header_text(spans);
  209|     15|            let stat = ctx.column_stat(idx);
  210|       |
  211|     15|            let candidate_score = stat
  212|     15|                .map(|s| {
  213|     15|                    let mut score = s.max_graphemes + s.longest_word * 2;
  214|     15|                    if s.rich_content.has_image {
  215|      0|                        score += 50;
  216|     15|                    }
  217|     15|                    if s.rich_content.has_link {
  218|      0|                        score += 25;
  219|     15|                    }
  220|     15|                    score
  221|     15|                })
  222|     15|                .unwrap_or_else(|| label.len());
                                                 ^0    ^0
  223|     15|            if candidate_score > fallback_score {
  224|     12|                fallback_score = candidate_score;
  225|     12|                fallback_idx = Some(idx);
  226|     12|            }
                          ^3
  227|     15|            scored_indices.push((idx, candidate_score));
  228|       |
  229|     15|            let policy =
  230|     15|                classify_column(&label, idx, &mut remainder_assigned, stat, ctx.body_font_px);
  231|     15|            let tooltip = column_tooltip(&label, &policy);
  232|     15|            ColumnSpec::new(label, policy, tooltip)
  233|     15|        })
  234|      6|        .collect();
  235|       |
  236|       |    // Ensure at least one remainder if none assigned and available
  237|      6|    if remainder_assigned == 0 {
  238|      1|        let mut candidate = fallback_idx;
  239|      1|        if let Some(idx) = candidate {
  240|      1|            if matches!(specs[idx].policy, ColumnPolicy::Fixed { .. }) {
                             ^0
  241|      1|                candidate = None;
  242|      1|            }
                          ^0
  243|      0|        }
  244|      1|        if candidate.is_none() {
  245|      1|            candidate = specs
  246|      1|                .iter()
  247|      1|                .enumerate()
  248|      2|                .find(|(_, spec)| !matches!(spec.policy, ColumnPolicy::Fixed { .. }))
                               ^1                ^1
  249|      1|                .map(|(idx, _)| idx);
  250|      0|        }
  251|      1|        if let Some(idx) = candidate {
  252|      1|            if let Some(spec) = specs.get_mut(idx) {
  253|      1|                spec.set_policy(ColumnPolicy::Remainder { clip: false });
  254|      1|                remainder_assigned += 1;
  255|      1|            }
                          ^0
  256|      0|        }
  257|      5|    }
  258|       |
  259|       |    // Promote additional wide columns to remainder up to the cap
  260|     13|    scored_indices.sort_by(|a, b| b.1.cmp(&a.1));
                  ^6             ^6
  261|     20|    for (idx, _) in scored_indices {
                       ^15
  262|     15|        if remainder_assigned >= MAX_REMAINDER_COLUMNS {
  263|      1|            break;
  264|     14|        }
  265|     14|        if let Some(spec) = specs.get_mut(idx) {
  266|     14|            if matches!(spec.policy, ColumnPolicy::Resizable { .. })
                             ^9
  267|      5|                && column_needs_remainder(ctx.column_stat(idx))
  268|      1|            {
  269|      1|                spec.set_policy(ColumnPolicy::Remainder { clip: false });
  270|      1|                remainder_assigned += 1;
  271|     13|            }
  272|      0|        }
  273|       |    }
  274|       |
  275|      6|    specs
  276|      6|}
  277|       |
  278|     16|fn header_text(spans: &[InlineSpan]) -> String {
  279|     16|    let mut text = String::new();
  280|     32|    for span in spans {
                      ^16
  281|     16|        match span {
  282|     16|            InlineSpan::Text(t)
  283|      0|            | InlineSpan::Strong(t)
  284|      0|            | InlineSpan::Emphasis(t)
  285|      0|            | InlineSpan::Strikethrough(t)
  286|      0|            | InlineSpan::Code(t) => {
  287|     16|                if !text.is_empty() {
  288|      0|                    text.push(' ');
  289|     16|                }
  290|     16|                text.push_str(t.trim());
  291|       |            }
  292|      0|            InlineSpan::Link { text: t, .. } => {
  293|      0|                if !text.is_empty() {
  294|      0|                    text.push(' ');
  295|      0|                }
  296|      0|                text.push_str(t.trim());
  297|       |            }
  298|      0|            InlineSpan::Image { alt, .. } => {
  299|      0|                if !text.is_empty() {
  300|      0|                    text.push(' ');
  301|      0|                }
  302|      0|                text.push_str(alt.trim());
  303|       |            }
  304|       |        }
  305|       |    }
  306|     16|    if text.trim().is_empty() {
  307|      0|        "Column".to_string()
  308|       |    } else {
  309|     16|        text.trim().to_string()
  310|       |    }
  311|     16|}
  312|       |
  313|     15|fn classify_column(
  314|     15|    label: &str,
  315|     15|    index: usize,
  316|     15|    remainder_assigned: &mut usize,
  317|     15|    stat: Option<&ColumnStat>,
  318|     15|    body_font_px: f32,
  319|     15|) -> ColumnPolicy {
  320|     15|    let lower = label.to_ascii_lowercase();
  321|     15|    if matches_any(&lower, &["version", "rev", "#", "id"]) {
  322|      1|        return ColumnPolicy::Fixed {
  323|      1|            width: px(body_font_px, 5.8).clamp(80.0, 160.0),
  324|      1|            clip: true,
  325|      1|        };
  326|     14|    }
  327|     14|    if matches_any(&lower, &["date", "time", "timestamp"]) {
  328|      0|        return ColumnPolicy::Fixed {
  329|      0|            width: px(body_font_px, 8.5).clamp(110.0, 200.0),
  330|      0|            clip: false,
  331|      0|        };
  332|     14|    }
  333|     14|    if matches_any(&lower, &["author", "owner", "assignee", "user"]) {
  334|      1|        return ColumnPolicy::Resizable {
  335|      1|            min: px(body_font_px, 7.5),
  336|      1|            preferred: px(body_font_px, 10.0),
  337|      1|            clip: false,
  338|      1|        };
  339|     13|    }
  340|     13|    if matches_any(&lower, &["status", "state"]) {
  341|      0|        return ColumnPolicy::Fixed {
  342|      0|            width: px(body_font_px, 7.0).clamp(90.0, 180.0),
  343|      0|            clip: true,
  344|      0|        };
  345|     13|    }
  346|     13|    if matches_any(
  347|     13|        &lower,
  348|     13|        &["notes", "changes", "description", "details", "summary"],
  349|       |    ) {
  350|      5|        return ColumnPolicy::Resizable {
  351|      5|            min: px(body_font_px, 10.5),
  352|      5|            preferred: px(body_font_px, 14.5),
  353|      5|            clip: false,
  354|      5|        };
  355|      8|    }
  356|      8|    if matches_any(
  357|      8|        &lower,
  358|      8|        &["example", "examples", "sample", "use case", "use cases"],
  359|       |    ) {
  360|      4|        *remainder_assigned += 1;
  361|      4|        return ColumnPolicy::Remainder { clip: false };
  362|      4|    }
  363|      4|    if index == 0 {
  364|       |        // First column typically identifiers; keep fixed only for short labels.
  365|      2|        if stat
  366|      2|            .map(|s| s.max_graphemes <= 18 && s.longest_word <= 12)
  367|      2|            .unwrap_or_else(|| label.len() <= 12)
                                             ^0    ^0
  368|       |        {
  369|      2|            return ColumnPolicy::Fixed {
  370|      2|                width: px(body_font_px, 7.0).clamp(80.0, 180.0),
  371|      2|                clip: true,
  372|      2|            };
  373|      0|        }
  374|      2|    }
  375|      2|    if *remainder_assigned < MAX_REMAINDER_COLUMNS && column_needs_remainder(stat) {
  376|      1|        *remainder_assigned += 1;
  377|      1|        return ColumnPolicy::Remainder { clip: false };
  378|      1|    }
  379|      1|    ColumnPolicy::Resizable {
  380|      1|        min: px(body_font_px, 7.0),
  381|      1|        preferred: px(body_font_px, 9.5),
  382|      1|        clip: false,
  383|      1|    }
  384|     15|}
  385|       |
  386|      7|fn column_needs_remainder(stat: Option<&ColumnStat>) -> bool {
  387|      7|    if let Some(stat) = stat {
  388|      7|        stat.rich_content.has_image
  389|      7|            || stat.longest_word > 18
  390|      7|            || stat.max_graphemes > 60
  391|      5|            || stat.rich_content.has_link
  392|       |    } else {
  393|      0|        false
  394|       |    }
  395|      7|}
  396|       |
  397|     77|fn matches_any(label: &str, needles: &[&str]) -> bool {
  398|    259|    needles.iter().any(|needle| label.contains(needle))
                  ^77            ^77
  399|     77|}
  400|       |
  401|     15|fn column_tooltip(label: &str, policy: &ColumnPolicy) -> Option<String> {
  402|     15|    let description = match policy {
  403|      0|        ColumnPolicy::Auto => "Auto-sized column".to_string(),
  404|      3|        ColumnPolicy::Fixed { width, clip } => format!(
  405|      3|            "Fixed width {:.0}px{}",
  406|       |            width,
  407|      3|            if *clip { " (clipped)" } else { "" }
                                                           ^0
  408|       |        ),
  409|      5|        ColumnPolicy::Remainder { clip } => format!(
  410|      5|            "Shared remainder width{}",
  411|      5|            if *clip { " (clipped)" } else { "" }
                                     ^0
  412|       |        ),
  413|       |        ColumnPolicy::Resizable {
  414|      7|            min,
  415|      7|            preferred,
  416|      7|            clip,
  417|      7|        } => format!(
  418|      7|            "Resizable (min {:.0}px, start {:.0}px{})",
  419|       |            min,
  420|       |            preferred,
  421|      7|            if *clip { ", clipped" } else { "" }
                                     ^0
  422|       |        ),
  423|       |    };
  424|     15|    Some(format!("{label}: {description}"))
  425|     15|}
  426|       |
  427|      8|pub fn compute_column_stats(
  428|      8|    headers: &[Vec<InlineSpan>],
  429|      8|    rows: &[Vec<Vec<InlineSpan>>],
  430|      8|    max_samples: usize,
  431|      8|) -> Vec<ColumnStat> {
  432|      8|    let column_count = max(
  433|      8|        headers.len(),
  434|      8|        rows.iter().map(|row| row.len()).max().unwrap_or(0),
                                            ^4  ^4
  435|       |    );
  436|      8|    if column_count == 0 {
  437|      0|        return Vec::new();
  438|      8|    }
  439|       |
  440|      8|    let mut stats = vec![ColumnStat::default(); column_count];
  441|       |
  442|     18|    for (idx, header) in headers.iter().enumerate() {
                                       ^8      ^8     ^8
  443|     18|        accumulate_stats_for_cell(header, &mut stats[idx]);
  444|     18|    }
  445|       |
  446|      8|    let mut sampled_rows = 0;
  447|      8|    for row in rows.iter() {
                      ^4
  448|      8|        for (idx, cell) in row.iter().enumerate().take(column_count) {
                                         ^4         ^4          ^4   ^4
  449|      8|            accumulate_stats_for_cell(cell, &mut stats[idx]);
  450|      8|        }
  451|      4|        sampled_rows += 1;
  452|      4|        if sampled_rows >= max_samples {
  453|      0|            break;
  454|      4|        }
  455|       |    }
  456|       |
  457|      8|    stats
  458|      8|}
  459|       |
  460|     26|fn accumulate_stats_for_cell(spans: &[InlineSpan], stat: &mut ColumnStat) {
  461|     26|    if stat.rich_content.has_image {
  462|      0|        // rich-content flags persist; skip repeated scans for pure images.
  463|     26|    }
  464|     26|    let mut has_link = stat.rich_content.has_link;
  465|     26|    let mut has_image = stat.rich_content.has_image;
  466|     26|    let mut has_emoji_like = stat.rich_content.has_emoji_like;
  467|       |
  468|     52|    for span in spans {
                      ^26
  469|     26|        match span {
  470|      0|            InlineSpan::Link { .. } => has_link = true,
  471|      0|            InlineSpan::Image { .. } => has_image = true,
  472|     26|            _ => {}
  473|       |        }
  474|       |    }
  475|       |
  476|     26|    let text = spans_to_text(spans);
  477|     26|    if !text.is_empty() {
  478|     26|        let graphemes = text.graphemes(true).count();
  479|     26|        let display_width = UnicodeWidthStr::width(text.as_str());
  480|     26|        stat.max_graphemes = stat.max_graphemes.max(display_width.max(graphemes));
  481|       |
  482|     60|        for word in text.split_whitespace() {
                                  ^26  ^26
  483|     60|            let word_len = UnicodeWidthStr::width(word).max(word.graphemes(true).count());
  484|     60|            stat.longest_word = stat.longest_word.max(word_len);
  485|     60|        }
  486|       |
  487|     26|        if !has_emoji_like {
  488|    374|            has_emoji_like = text.chars().any(|c| matches!(c as u32, 0x1F300..=0x1FAFF));
                                           ^26          ^26                        ^1
  489|      0|        }
  490|      0|    }
  491|       |
  492|     26|    stat.rich_content = RichContentFlags {
  493|     26|        has_link,
  494|     26|        has_image,
  495|     26|        has_emoji_like,
  496|     26|    };
  497|     26|}
  498|       |
  499|     26|fn spans_to_text(spans: &[InlineSpan]) -> String {
  500|     26|    let mut text = String::new();
  501|     52|    for span in spans {
                      ^26
  502|     26|        match span {
  503|     26|            InlineSpan::Text(t)
  504|      0|            | InlineSpan::Code(t)
  505|      0|            | InlineSpan::Strong(t)
  506|      0|            | InlineSpan::Emphasis(t)
  507|      0|            | InlineSpan::Strikethrough(t) => {
  508|     26|                if !text.is_empty() {
  509|      0|                    text.push(' ');
  510|     26|                }
  511|     26|                text.push_str(t);
  512|       |            }
  513|      0|            InlineSpan::Link { text: t, .. } => {
  514|      0|                if !text.is_empty() {
  515|      0|                    text.push(' ');
  516|      0|                }
  517|      0|                text.push_str(t);
  518|       |            }
  519|      0|            InlineSpan::Image { alt, .. } => {
  520|      0|                if !text.is_empty() {
  521|      0|                    text.push(' ');
  522|      0|                }
  523|      0|                text.push_str(alt);
  524|       |            }
  525|       |        }
  526|       |    }
  527|     26|    text.trim().to_string()
  528|     26|}
  529|       |
  530|       |#[cfg(test)]
  531|       |mod tests {
  532|       |    use super::*;
  533|       |
  534|     26|    fn span(text: &str) -> InlineSpan {
  535|     26|        InlineSpan::Text(text.to_string())
  536|     26|    }
  537|       |
  538|       |    #[test]
  539|      1|    fn classify_version_column() {
  540|      1|        let headers = vec![vec![span("Version")], vec![span("Changes")]];
  541|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  542|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  543|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  544|      1|        let specs = derive_column_specs(&ctx);
  545|      1|        assert!(
  546|      1|            matches!(specs[0].policy, ColumnPolicy::Fixed { .. }),
                          ^0
  547|      0|            "policy = {:?}",
  548|      0|            specs[0].policy
  549|       |        );
  550|      1|        assert!(
  551|      1|            matches!(specs[1].policy, ColumnPolicy::Remainder { .. }),
                          ^0
  552|      0|            "policy = {:?}",
  553|      0|            specs[1].policy
  554|       |        );
  555|      1|    }
  556|       |
  557|       |    #[test]
  558|      1|    fn classify_author_column() {
  559|      1|        let headers = vec![vec![span("Author")], vec![span("Examples")]];
  560|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  561|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  562|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  563|      1|        let specs = derive_column_specs(&ctx);
  564|      1|        assert!(
  565|      1|            matches!(specs[0].policy, ColumnPolicy::Resizable { .. }),
                          ^0
  566|      0|            "policy = {:?}",
  567|      0|            specs[0].policy
  568|       |        );
  569|      1|        assert!(
  570|      1|            matches!(specs[1].policy, ColumnPolicy::Remainder { .. }),
                          ^0
  571|      0|            "policy = {:?}",
  572|      0|            specs[1].policy
  573|       |        );
  574|      1|    }
  575|       |
  576|       |    #[test]
  577|      1|    fn classify_examples_column() {
  578|      1|        let headers = vec![
  579|      1|            vec![span("Element")],
  580|      1|            vec![span("Symbol")],
  581|      1|            vec![span("Description")],
  582|      1|            vec![span("Examples")],
  583|       |        ];
  584|      1|        assert_eq!(header_text(&headers[3]), "Examples");
  585|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  586|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  587|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  588|      1|        let specs = derive_column_specs(&ctx);
  589|      1|        assert!(
  590|      1|            matches!(specs[3].policy, ColumnPolicy::Remainder { .. }),
                          ^0
  591|      0|            "policy = {:?}",
  592|      0|            specs[3].policy
  593|       |        );
  594|      1|        assert!(
  595|      1|            matches!(specs[2].policy, ColumnPolicy::Resizable { .. }),
                          ^0
  596|      0|            "policy = {:?}",
  597|      0|            specs[2].policy
  598|       |        );
  599|      1|    }
  600|       |
  601|       |    #[test]
  602|      1|    fn compute_stats_counts_text() {
  603|      1|        let headers = vec![vec![span("Head")]];
  604|      1|        let rows = vec![vec![vec![span("Emoji  test")]]];
  605|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  606|      1|        assert_eq!(stats.len(), 1);
  607|      1|        assert!(stats[0].max_graphemes >= 4);
  608|      1|        assert!(stats[0].longest_word >= 5);
  609|      1|        assert!(stats[0].rich_content.has_emoji_like);
  610|      1|    }
  611|       |
  612|       |    #[test]
  613|      1|    fn fallback_assigns_remainder_based_on_stats() {
  614|      1|        let headers = vec![vec![span("Foo")], vec![span("Bar")]];
  615|      1|        let rows = vec![vec![
  616|      1|            vec![span("Short")],
  617|      1|            vec![span(
  618|      1|                "This column contains a very long sentence that should force remainder selection.",
  619|       |            )],
  620|       |        ]];
  621|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  622|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  623|      1|        let specs = derive_column_specs(&ctx);
  624|      1|        assert!(matches!(specs[1].policy, ColumnPolicy::Remainder { .. }));
                              ^0
  625|      1|    }
  626|       |
  627|       |    #[test]
  628|      1|    fn examples_header_prefers_remainder() {
  629|      1|        let headers = vec![vec![span("Examples")], vec![span("Description")]];
  630|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  631|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  632|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 16.0, 0);
  633|      1|        let specs = derive_column_specs(&ctx);
  634|      1|        assert!(matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
                              ^0
  635|      1|        assert!(matches!(specs[1].policy, ColumnPolicy::Resizable { .. }));
                              ^0
  636|      1|    }
  637|       |
  638|       |    #[test]
  639|      1|    fn multiple_remainder_columns_allowed() {
  640|      1|        let headers = vec![
  641|      1|            vec![span("Summary")],
  642|      1|            vec![span("Details")],
  643|      1|            vec![span("Examples")],
  644|       |        ];
  645|      1|        let rows = vec![vec![
  646|      1|            vec![span("short")],
  647|      1|            vec![span(
  648|      1|                "Long content that should trigger a remainder column due to its width and words.",
  649|       |            )],
  650|      1|            vec![span(
  651|      1|                "Another large column with links https://example.com and more text.",
  652|       |            )],
  653|       |        ]];
  654|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  655|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  656|      1|        let specs = derive_column_specs(&ctx);
  657|      1|        let remainder_count = specs
  658|      1|            .iter()
  659|      3|            .filter(|s| matches!(s.policy, ColumnPolicy::Remainder { .. }))
                           ^1
  660|      1|            .count();
  661|      1|        assert!(
  662|      1|            remainder_count >= 2,
  663|      0|            "should allow multiple remainder columns, got {remainder_count}"
  664|       |        );
  665|      1|    }
  666|       |
  667|       |    #[test]
  668|      1|    fn cjk_widths_increase_stat_estimates() {
  669|      1|        let headers = vec![vec![span("")], vec![span("Column")]];
  670|      1|        let rows = vec![vec![vec![span("")], vec![span("short")]]];
  671|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  672|      1|        assert!(stats[0].max_graphemes > stats[1].max_graphemes);
  673|      1|    }
  674|       |}

C:\language\mdmdview\src\table_support\metrics.rs:
    1|       |use std::collections::HashMap;
    2|       |
    3|       |#[allow(dead_code)]
    4|       |#[derive(Debug, Default, Clone)]
    5|       |pub struct RowMetrics {
    6|       |    pub max_height: f32,
    7|       |    pub dirty: bool,
    8|       |}
    9|       |
   10|       |#[allow(dead_code)]
   11|       |#[derive(Debug, Default, Clone)]
   12|       |pub struct TableMetricEntry {
   13|       |    pub rows: Vec<RowMetrics>,
   14|       |    pub rendered_rows: usize,
   15|       |    pub total_rows: usize,
   16|       |    pub resolved_widths: Vec<f32>,
   17|       |    pub last_width_frame: u64,
   18|       |    pub last_discard_frame: Option<u64>,
   19|       |    pub persisted_column_widths: HashMap<u64, f32>,
   20|       |    pub pending_user_resize: Option<PendingResize>,
   21|       |    /// Font size when widths were last persisted. Used to invalidate
   22|       |    /// persisted widths when zoom level changes.
   23|       |    pub persisted_font_size: Option<f32>,
   24|       |}
   25|       |
   26|       |#[derive(Debug, Clone, Copy)]
   27|       |pub struct PendingResize {
   28|       |    pub column_hash: u64,
   29|       |    pub width: f32,
   30|       |}
   31|       |
   32|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   33|       |pub enum WidthChange {
   34|       |    None,
   35|       |    Small,
   36|       |    Large,
   37|       |}
   38|       |
   39|       |const WIDTH_EPSILON: f32 = 0.15;
   40|       |const WIDTH_LARGE_DELTA: f32 = 0.75;
   41|       |
   42|       |impl TableMetricEntry {
   43|      0|    pub fn ensure_row(&mut self, index: usize) -> &mut RowMetrics {
   44|      0|        if index >= self.rows.len() {
   45|      0|            self.rows.resize_with(index + 1, RowMetrics::default);
   46|      0|        }
   47|      0|        &mut self.rows[index]
   48|      0|    }
   49|       |
   50|      0|    pub fn row(&self, index: usize) -> Option<&RowMetrics> {
   51|      0|        self.rows.get(index)
   52|      0|    }
   53|       |
   54|      0|    pub fn begin_pass(&mut self, total_rows: usize) {
   55|      0|        self.total_rows = total_rows;
   56|      0|        self.rendered_rows = 0;
   57|      0|    }
   58|       |
   59|      0|    pub fn note_row_rendered(&mut self) {
   60|      0|        self.rendered_rows += 1;
   61|      0|    }
   62|       |
   63|     10|    pub fn persisted_width(&self, key: u64) -> Option<f32> {
   64|     10|        self.persisted_column_widths.get(&key).copied()
   65|     10|    }
   66|       |
   67|      4|    pub fn set_persisted_width(&mut self, key: u64, width: f32) {
   68|      4|        self.persisted_column_widths.insert(key, width);
   69|      4|    }
   70|       |
   71|      0|    pub fn remove_persisted_width(&mut self, key: u64) {
   72|      0|        self.persisted_column_widths.remove(&key);
   73|      0|    }
   74|       |
   75|      3|    pub fn update_widths(&mut self, widths: &[f32], frame_id: u64) -> WidthChange {
   76|      3|        if widths.is_empty() {
   77|      0|            self.resolved_widths.clear();
   78|      0|            self.last_width_frame = frame_id;
   79|      0|            return WidthChange::None;
   80|      3|        }
   81|       |
   82|      3|        let first_update = self.resolved_widths.is_empty();
   83|      3|        let mut change = WidthChange::None;
   84|      3|        if !first_update && self.resolved_widths.len() != widths.len() {
                                          ^2                   ^2
   85|      0|            change = WidthChange::Large;
   86|      0|        } else {
   87|      3|            for (old, new) in self.resolved_widths.iter().zip(widths.iter()) {
   88|      3|                let delta = (old - new).abs();
   89|      3|                if delta > WIDTH_LARGE_DELTA {
   90|      1|                    change = WidthChange::Large;
   91|      1|                    break;
   92|      2|                }
   93|      2|                if delta > WIDTH_EPSILON {
   94|      2|                    change = WidthChange::Small;
   95|      2|                }
                              ^0
   96|       |            }
   97|       |        }
   98|       |
   99|      3|        self.resolved_widths.clear();
  100|      3|        self.resolved_widths.extend_from_slice(widths);
  101|      3|        self.last_width_frame = frame_id;
  102|       |
  103|      3|        change
  104|      3|    }
  105|       |
  106|      0|    pub fn current_widths(&self) -> &[f32] {
  107|      0|        &self.resolved_widths
  108|      0|    }
  109|       |
  110|       |    /// Check if font size has changed since widths were last persisted.
  111|       |    /// If so, clear all persisted widths and update the stored font size.
  112|       |    /// Returns true if widths were cleared.
  113|      6|    pub fn check_font_size_change(&mut self, current_font_size: f32) -> bool {
  114|       |        const FONT_SIZE_EPSILON: f32 = 0.5;
  115|      6|        if let Some(stored_font) = self.persisted_font_size {
                                  ^4
  116|      4|            if (stored_font - current_font_size).abs() > FONT_SIZE_EPSILON {
  117|      2|                self.persisted_column_widths.clear();
  118|      2|                self.persisted_font_size = Some(current_font_size);
  119|      2|                return true;
  120|      2|            }
  121|      2|        } else {
  122|      2|            self.persisted_font_size = Some(current_font_size);
  123|      2|        }
  124|      4|        false
  125|      6|    }
  126|       |}
  127|       |
  128|       |#[allow(dead_code)]
  129|       |#[derive(Debug, Default, Clone)]
  130|       |pub struct TableMetrics {
  131|       |    tables: HashMap<u64, TableMetricEntry>,
  132|       |}
  133|       |
  134|       |impl TableMetrics {
  135|      3|    pub fn entry_mut(&mut self, table_id: u64) -> &mut TableMetricEntry {
  136|      3|        self.tables.entry(table_id).or_default()
  137|      3|    }
  138|       |
  139|      3|    pub fn entry(&self, table_id: u64) -> Option<&TableMetricEntry> {
  140|      3|        self.tables.get(&table_id)
  141|      3|    }
  142|       |
  143|      0|    pub fn totals(&self) -> (usize, usize) {
  144|      0|        self.tables
  145|      0|            .values()
  146|      0|            .fold((0, 0), |(rendered, total), entry| {
  147|      0|                (rendered + entry.rendered_rows, total + entry.total_rows)
  148|      0|            })
  149|      0|    }
  150|       |
  151|    100|    pub fn clear(&mut self) {
  152|    100|        self.tables.clear();
  153|    100|    }
  154|       |}
  155|       |
  156|       |#[allow(dead_code)]
  157|       |#[derive(Debug, Default, Clone)]
  158|       |pub struct CacheStats {
  159|       |    pub hits: u64,
  160|       |    pub misses: u64,
  161|       |}
  162|       |
  163|       |impl CacheStats {
  164|      0|    pub fn record_hit(&mut self) {
  165|      0|        self.hits += 1;
  166|      0|    }
  167|       |
  168|      0|    pub fn record_miss(&mut self) {
  169|      0|        self.misses += 1;
  170|      0|    }
  171|       |}
  172|       |
  173|       |#[cfg(test)]
  174|       |mod tests {
  175|       |    use super::*;
  176|       |
  177|       |    #[test]
  178|      1|    fn update_widths_detects_large_change() {
  179|      1|        let mut entry = TableMetricEntry::default();
  180|      1|        assert_eq!(entry.update_widths(&[100.0, 120.0], 1), WidthChange::None);
  181|      1|        assert_eq!(entry.update_widths(&[100.2, 120.6], 2), WidthChange::Small);
  182|      1|        assert_eq!(entry.update_widths(&[140.0, 120.6], 3), WidthChange::Large);
  183|      1|    }
  184|       |
  185|       |    #[test]
  186|      1|    fn font_size_change_clears_persisted_widths() {
  187|      1|        let mut entry = TableMetricEntry::default();
  188|       |
  189|       |        // Set some persisted widths at font size 14.0
  190|      1|        entry.set_persisted_width(1, 100.0);
  191|      1|        entry.set_persisted_width(2, 150.0);
  192|      1|        assert!(!entry.check_font_size_change(14.0)); // First call sets baseline
  193|      1|        assert_eq!(entry.persisted_width(1), Some(100.0));
  194|      1|        assert_eq!(entry.persisted_width(2), Some(150.0));
  195|       |
  196|       |        // Small font size change (within epsilon) should NOT clear
  197|      1|        assert!(!entry.check_font_size_change(14.3));
  198|      1|        assert_eq!(entry.persisted_width(1), Some(100.0));
  199|       |
  200|       |        // Large font size change should clear all persisted widths
  201|      1|        assert!(entry.check_font_size_change(16.0));
  202|      1|        assert_eq!(entry.persisted_width(1), None);
  203|      1|        assert_eq!(entry.persisted_width(2), None);
  204|      1|        assert_eq!(entry.persisted_font_size, Some(16.0));
  205|      1|    }
  206|       |}

C:\language\mdmdview\src\window_state.rs:
    1|       |use std::fs;
    2|       |use std::io::{Read, Write};
    3|       |use std::path::PathBuf;
    4|       |
    5|       |#[derive(Debug, Clone, Copy)]
    6|       |pub struct WindowState {
    7|       |    pub pos: [f32; 2],
    8|       |    pub size: [f32; 2],
    9|       |    pub maximized: bool,
   10|       |}
   11|       |
   12|      0|fn config_dir() -> Option<PathBuf> {
   13|       |    // Crossplatform config dir without extra deps
   14|       |    #[cfg(target_os = "windows")]
   15|       |    {
   16|      0|        if let Ok(appdata) = std::env::var("APPDATA") {
   17|      0|            let mut p = PathBuf::from(appdata);
   18|      0|            p.push("MarkdownView");
   19|      0|            return Some(p);
   20|      0|        }
   21|       |    }
   22|       |
   23|       |    #[cfg(target_os = "macos")]
   24|       |    {
   25|       |        if let Ok(home) = std::env::var("HOME") {
   26|       |            let mut p = PathBuf::from(home);
   27|       |            p.push("Library/Application Support/MarkdownView");
   28|       |            return Some(p);
   29|       |        }
   30|       |    }
   31|       |
   32|       |    // Linux / others: XDG or ~/.config
   33|      0|    if let Ok(xdg) = std::env::var("XDG_CONFIG_HOME") {
   34|      0|        let mut p = PathBuf::from(xdg);
   35|      0|        p.push("mdmdview");
   36|      0|        return Some(p);
   37|      0|    }
   38|      0|    if let Ok(home) = std::env::var("HOME") {
   39|      0|        let mut p = PathBuf::from(home);
   40|      0|        p.push(".config/mdmdview");
   41|      0|        return Some(p);
   42|      0|    }
   43|      0|    None
   44|      0|}
   45|       |
   46|      0|fn state_path() -> Option<PathBuf> {
   47|      0|    config_dir().map(|mut dir| {
   48|      0|        dir.push("window_state.txt");
   49|      0|        dir
   50|      0|    })
   51|      0|}
   52|       |
   53|      0|pub fn load_window_state() -> Option<WindowState> {
   54|       |    #[cfg(windows)]
   55|       |    {
   56|      0|        if let Some(ws) = load_window_state_registry() {
   57|      0|            return Some(ws);
   58|      0|        }
   59|       |    }
   60|      0|    let path = state_path()?;
   61|      0|    let mut f = fs::File::open(path).ok()?;
   62|      0|    let mut s = String::new();
   63|      0|    f.read_to_string(&mut s).ok()?;
   64|       |    // expected format: "x y w h max"
   65|      0|    let parts: Vec<&str> = s.split_whitespace().collect();
   66|      0|    if parts.len() < 5 {
   67|      0|        return None;
   68|      0|    }
   69|      0|    let x = parts[0].parse::<f32>().ok()?;
   70|      0|    let y = parts[1].parse::<f32>().ok()?;
   71|      0|    let w = parts[2].parse::<f32>().ok()?;
   72|      0|    let h = parts[3].parse::<f32>().ok()?;
   73|      0|    let max = matches!(parts[4], "1" | "true" | "True");
   74|      0|    Some(WindowState {
   75|      0|        pos: [x, y],
   76|      0|        size: [w, h],
   77|      0|        maximized: max,
   78|      0|    })
   79|      0|}
   80|       |
   81|      0|pub fn save_window_state(state: &WindowState) -> std::io::Result<()> {
   82|       |    #[cfg(windows)]
   83|       |    {
   84|      0|        if let Err(e) = save_window_state_registry(state) {
   85|      0|            eprintln!("Failed to write window state to registry: {e}");
   86|      0|        }
   87|       |    }
   88|      0|    if let Some(mut dir) = config_dir() {
   89|      0|        if !dir.exists() {
   90|      0|            fs::create_dir_all(&dir)?;
   91|      0|        }
   92|      0|        dir.push("window_state.txt");
   93|      0|        let mut f = fs::File::create(&dir)?;
   94|       |        // simple whitespace separated format
   95|      0|        writeln!(
   96|      0|            f,
   97|      0|            "{} {} {} {} {}",
   98|      0|            state.pos[0], state.pos[1], state.size[0], state.size[1], state.maximized as u8
   99|      0|        )?;
  100|      0|    }
  101|      0|    Ok(())
  102|      0|}
  103|       |
  104|      0|pub fn sanitize_window_state(ws: WindowState) -> Option<WindowState> {
  105|       |    // Basic sanity: finite values
  106|      0|    if !ws.pos[0].is_finite()
  107|      0|        || !ws.pos[1].is_finite()
  108|      0|        || !ws.size[0].is_finite()
  109|      0|        || !ws.size[1].is_finite()
  110|       |    {
  111|      0|        return None;
  112|      0|    }
  113|       |
  114|       |    // Clamp to reasonable ranges
  115|      0|    let min_w = 600.0f32;
  116|      0|    let min_h = 400.0f32;
  117|      0|    let max_w = 10000.0f32;
  118|      0|    let max_h = 10000.0f32;
  119|      0|    let max_pos = 20000.0f32; // avoid absurdly large coordinates
  120|       |
  121|      0|    let w = ws.size[0].clamp(min_w, max_w);
  122|      0|    let h = ws.size[1].clamp(min_h, max_h);
  123|      0|    let x = ws.pos[0].max(0.0).min(max_pos);
  124|      0|    let y = ws.pos[1].max(0.0).min(max_pos);
  125|       |
  126|      0|    Some(WindowState {
  127|      0|        pos: [x, y],
  128|      0|        size: [w, h],
  129|      0|        maximized: ws.maximized,
  130|      0|    })
  131|      0|}
  132|       |
  133|       |#[cfg(windows)]
  134|      0|fn load_window_state_registry() -> Option<WindowState> {
  135|       |    use winreg::enums::HKEY_CURRENT_USER;
  136|       |    use winreg::RegKey;
  137|      0|    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  138|      0|    let key = hkcu.open_subkey("Software\\MarkdownView").ok()?;
  139|      0|    let x: u32 = key.get_value("PosX").ok()?;
  140|      0|    let y: u32 = key.get_value("PosY").ok()?;
  141|      0|    let w: u32 = key.get_value("Width").ok()?;
  142|      0|    let h: u32 = key.get_value("Height").ok()?;
  143|      0|    let maximized: u32 = key.get_value("Maximized").unwrap_or(0);
  144|      0|    Some(WindowState {
  145|      0|        pos: [x as f32, y as f32],
  146|      0|        size: [w as f32, h as f32],
  147|      0|        maximized: maximized != 0,
  148|      0|    })
  149|      0|}
  150|       |
  151|       |#[cfg(windows)]
  152|      0|fn save_window_state_registry(state: &WindowState) -> std::io::Result<()> {
  153|       |    use winreg::enums::{HKEY_CURRENT_USER, KEY_READ, KEY_WRITE};
  154|       |    use winreg::RegKey;
  155|      0|    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  156|      0|    let (key, _disp) =
  157|      0|        hkcu.create_subkey_with_flags("Software\\MarkdownView", KEY_READ | KEY_WRITE)?;
  158|      0|    let to_u32 = |v: f32| -> u32 {
  159|      0|        if v.is_finite() {
  160|      0|            v.max(0.0).min(u32::MAX as f32).round() as u32
  161|       |        } else {
  162|      0|            0
  163|       |        }
  164|      0|    };
  165|      0|    key.set_value("PosX", &to_u32(state.pos[0]))?;
  166|      0|    key.set_value("PosY", &to_u32(state.pos[1]))?;
  167|      0|    key.set_value("Width", &to_u32(state.size[0]))?;
  168|      0|    key.set_value("Height", &to_u32(state.size[1]))?;
  169|      0|    key.set_value("Maximized", &(state.maximized as u32))?;
  170|      0|    Ok(())
  171|      0|}

c:\language\mdmdview\target\llvm-cov-target\debug\build\glutin_egl_sys-dcef47d8a173377f\out\egl_bindings.rs:
    1|       |
    2|       |        mod __gl_imports {
    3|       |            pub use std::mem;
    4|       |            pub use std::marker::Send;
    5|       |            pub use std::os::raw;
    6|       |        }
    7|       |    
    8|       |
    9|       |        pub mod types {
   10|       |            #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)]
   11|       |    
   12|       |// platform-specific aliases are unknown
   13|       |// IMPORTANT: these are alises to the same level of the bindings
   14|       |// the values must be defined by the user
   15|       |#[allow(dead_code)]
   16|       |pub type khronos_utime_nanoseconds_t = super::khronos_utime_nanoseconds_t;
   17|       |#[allow(dead_code)]
   18|       |pub type khronos_uint64_t = super::khronos_uint64_t;
   19|       |#[allow(dead_code)]
   20|       |pub type khronos_ssize_t = super::khronos_ssize_t;
   21|       |pub type EGLNativeDisplayType = super::EGLNativeDisplayType;
   22|       |#[allow(dead_code)]
   23|       |pub type EGLNativePixmapType = super::EGLNativePixmapType;
   24|       |#[allow(dead_code)]
   25|       |pub type EGLNativeWindowType = super::EGLNativeWindowType;
   26|       |pub type EGLint = super::EGLint;
   27|       |#[allow(dead_code)]
   28|       |pub type NativeDisplayType = super::NativeDisplayType;
   29|       |#[allow(dead_code)]
   30|       |pub type NativePixmapType = super::NativePixmapType;
   31|       |#[allow(dead_code)]
   32|       |pub type NativeWindowType = super::NativeWindowType;
   33|       |
   34|       |// EGL alises
   35|       |pub type Bool = EGLBoolean; // TODO: not sure
   36|       |pub type EGLBoolean = super::__gl_imports::raw::c_uint;
   37|       |pub type EGLenum = super::__gl_imports::raw::c_uint;
   38|       |pub type EGLAttribKHR = isize;
   39|       |pub type EGLAttrib = isize;
   40|       |pub type EGLConfig = *const super::__gl_imports::raw::c_void;
   41|       |pub type EGLContext = *const super::__gl_imports::raw::c_void;
   42|       |pub type EGLDeviceEXT = *const super::__gl_imports::raw::c_void;
   43|       |pub type EGLDisplay = *const super::__gl_imports::raw::c_void;
   44|       |pub type EGLSurface = *const super::__gl_imports::raw::c_void;
   45|       |pub type EGLClientBuffer = *const super::__gl_imports::raw::c_void;
   46|       |pub enum __eglMustCastToProperFunctionPointerType_fn {}
   47|       |pub type __eglMustCastToProperFunctionPointerType =
   48|       |    *mut __eglMustCastToProperFunctionPointerType_fn;
   49|       |pub type EGLImageKHR = *const super::__gl_imports::raw::c_void;
   50|       |pub type EGLImage = *const super::__gl_imports::raw::c_void;
   51|       |pub type EGLOutputLayerEXT = *const super::__gl_imports::raw::c_void;
   52|       |pub type EGLOutputPortEXT = *const super::__gl_imports::raw::c_void;
   53|       |pub type EGLSyncKHR = *const super::__gl_imports::raw::c_void;
   54|       |pub type EGLSync = *const super::__gl_imports::raw::c_void;
   55|       |pub type EGLTimeKHR = khronos_utime_nanoseconds_t;
   56|       |pub type EGLTime = khronos_utime_nanoseconds_t;
   57|       |pub type EGLSyncNV = *const super::__gl_imports::raw::c_void;
   58|       |pub type EGLTimeNV = khronos_utime_nanoseconds_t;
   59|       |pub type EGLuint64NV = khronos_utime_nanoseconds_t;
   60|       |pub type EGLStreamKHR = *const super::__gl_imports::raw::c_void;
   61|       |pub type EGLuint64KHR = khronos_uint64_t;
   62|       |pub type EGLNativeFileDescriptorKHR = super::__gl_imports::raw::c_int;
   63|       |pub type EGLsizeiANDROID = khronos_ssize_t;
   64|       |pub type EGLSetBlobFuncANDROID = extern "system" fn(*const super::__gl_imports::raw::c_void,
   65|       |                                                    EGLsizeiANDROID,
   66|       |                                                    *const super::__gl_imports::raw::c_void,
   67|       |                                                    EGLsizeiANDROID)
   68|       |                                                    -> ();
   69|       |pub type EGLGetBlobFuncANDROID = extern "system" fn(*const super::__gl_imports::raw::c_void,
   70|       |                                                    EGLsizeiANDROID,
   71|       |                                                    *mut super::__gl_imports::raw::c_void,
   72|       |                                                    EGLsizeiANDROID)
   73|       |                                                    -> EGLsizeiANDROID;
   74|       |
   75|       |#[repr(C)]
   76|       |pub struct EGLClientPixmapHI {
   77|       |    pData: *const super::__gl_imports::raw::c_void,
   78|       |    iWidth: EGLint,
   79|       |    iHeight: EGLint,
   80|       |    iStride: EGLint,
   81|       |}
   82|       |
   83|       |}
   84|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT: types::EGLenum = 0x3088;
   85|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT_NONPRE: types::EGLenum = 0x308B;
   86|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT_PRE: types::EGLenum = 0x308C;
   87|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_MASK_SIZE: types::EGLenum = 0x303E;
   88|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_SIZE: types::EGLenum = 0x3021;
   89|       |#[allow(dead_code, non_upper_case_globals)] pub const BACK_BUFFER: types::EGLenum = 0x3084;
   90|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_ACCESS: types::EGLenum = 0x3002;
   91|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_ALLOC: types::EGLenum = 0x3003;
   92|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_ATTRIBUTE: types::EGLenum = 0x3004;
   93|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_CONFIG: types::EGLenum = 0x3005;
   94|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_CONTEXT: types::EGLenum = 0x3006;
   95|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_CURRENT_SURFACE: types::EGLenum = 0x3007;
   96|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_DEVICE_EXT: types::EGLenum = 0x322B;
   97|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_DISPLAY: types::EGLenum = 0x3008;
   98|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_MATCH: types::EGLenum = 0x3009;
   99|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_NATIVE_PIXMAP: types::EGLenum = 0x300A;
  100|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_NATIVE_WINDOW: types::EGLenum = 0x300B;
  101|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_PARAMETER: types::EGLenum = 0x300C;
  102|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_SURFACE: types::EGLenum = 0x300D;
  103|       |#[allow(dead_code, non_upper_case_globals)] pub const BIND_TO_TEXTURE_RGB: types::EGLenum = 0x3039;
  104|       |#[allow(dead_code, non_upper_case_globals)] pub const BIND_TO_TEXTURE_RGBA: types::EGLenum = 0x303A;
  105|       |#[allow(dead_code, non_upper_case_globals)] pub const BLUE_SIZE: types::EGLenum = 0x3022;
  106|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_AGE_EXT: types::EGLenum = 0x313D;
  107|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_DESTROYED: types::EGLenum = 0x3095;
  108|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_PRESERVED: types::EGLenum = 0x3094;
  109|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_SIZE: types::EGLenum = 0x3020;
  110|       |#[allow(dead_code, non_upper_case_globals)] pub const CLIENT_APIS: types::EGLenum = 0x308D;
  111|       |#[allow(dead_code, non_upper_case_globals)] pub const CL_EVENT_HANDLE: types::EGLenum = 0x309C;
  112|       |#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE: types::EGLenum = 0x3087;
  113|       |#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE_LINEAR: types::EGLenum = 0x308A;
  114|       |#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE_sRGB: types::EGLenum = 0x3089;
  115|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_BUFFER_TYPE: types::EGLenum = 0x303F;
  116|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_EXT: types::EGLenum = 0x3339;
  117|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_FIXED_EXT: types::EGLenum = 0x333A;
  118|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_FLOAT_EXT: types::EGLenum = 0x333B;
  119|       |#[allow(dead_code, non_upper_case_globals)] pub const CONDITION_SATISFIED: types::EGLenum = 0x30F6;
  120|       |#[allow(dead_code, non_upper_case_globals)] pub const CONFIG_CAVEAT: types::EGLenum = 0x3027;
  121|       |#[allow(dead_code, non_upper_case_globals)] pub const CONFIG_ID: types::EGLenum = 0x3028;
  122|       |#[allow(dead_code, non_upper_case_globals)] pub const CONFORMANT: types::EGLenum = 0x3042;
  123|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CLIENT_TYPE: types::EGLenum = 0x3097;
  124|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CLIENT_VERSION: types::EGLenum = 0x3098;
  125|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FLAGS_KHR: types::EGLenum = 0x30FC;
  126|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_LOST: types::EGLenum = 0x300E;
  127|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION: types::EGLenum = 0x3098;
  128|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION_KHR: types::EGLenum = 0x3098;
  129|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION: types::EGLenum = 0x30FB;
  130|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION_KHR: types::EGLenum = 0x30FB;
  131|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT: types::EGLenum = 0x00000002;
  132|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR: types::EGLenum = 0x00000002;
  133|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_CORE_PROFILE_BIT: types::EGLenum = 0x00000001;
  134|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR: types::EGLenum = 0x00000001;
  135|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_DEBUG: types::EGLenum = 0x31B0;
  136|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_DEBUG_BIT_KHR: types::EGLenum = 0x00000001;
  137|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_FORWARD_COMPATIBLE: types::EGLenum = 0x31B1;
  138|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR: types::EGLenum = 0x00000002;
  139|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_NO_ERROR_KHR: types::EGLenum = 0x31B3;
  140|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_PROFILE_MASK: types::EGLenum = 0x30FD;
  141|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_PROFILE_MASK_KHR: types::EGLenum = 0x30FD;
  142|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY: types::EGLenum = 0x31BD;
  143|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT: types::EGLenum = 0x3138;
  144|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR: types::EGLenum = 0x31BD;
  145|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS: types::EGLenum = 0x31B2;
  146|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR: types::EGLenum = 0x00000004;
  147|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS_EXT: types::EGLenum = 0x30BF;
  148|       |#[allow(dead_code, non_upper_case_globals)] pub const CORE_NATIVE_ENGINE: types::EGLenum = 0x305B;
  149|       |#[allow(dead_code, non_upper_case_globals)] pub const DEFAULT_DISPLAY: types::EGLNativeDisplayType = 0 as types::EGLNativeDisplayType;
  150|       |#[allow(dead_code, non_upper_case_globals)] pub const DEPTH_SIZE: types::EGLenum = 0x3025;
  151|       |#[allow(dead_code, non_upper_case_globals)] pub const DEVICE_EXT: types::EGLenum = 0x322C;
  152|       |#[allow(dead_code, non_upper_case_globals)] pub const DISPLAY_SCALING: types::EGLenum = 10000;
  153|       |#[allow(dead_code, non_upper_case_globals)] pub const DONT_CARE: types::EGLint = -1 as types::EGLint;
  154|       |#[allow(dead_code, non_upper_case_globals)] pub const DRAW: types::EGLenum = 0x3059;
  155|       |#[allow(dead_code, non_upper_case_globals)] pub const DRM_DEVICE_FILE_EXT: types::EGLenum = 0x3233;
  156|       |#[allow(dead_code, non_upper_case_globals)] pub const DRM_MASTER_FD_EXT: types::EGLenum = 0x333C;
  157|       |#[allow(dead_code, non_upper_case_globals)] pub const EXTENSIONS: types::EGLenum = 0x3055;
  158|       |#[allow(dead_code, non_upper_case_globals)] pub const FALSE: types::EGLBoolean = 0;
  159|       |#[allow(dead_code, non_upper_case_globals)] pub const FOREVER: types::EGLuint64KHR = 0xFFFFFFFFFFFFFFFF;
  160|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE: types::EGLenum = 0x309D;
  161|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE_LINEAR: types::EGLenum = 0x308A;
  162|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE_SRGB: types::EGLenum = 0x3089;
  163|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_RENDERBUFFER: types::EGLenum = 0x30B9;
  164|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_2D: types::EGLenum = 0x30B1;
  165|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_3D: types::EGLenum = 0x30B2;
  166|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_X: types::EGLenum = 0x30B4;
  167|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: types::EGLenum = 0x30B6;
  168|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: types::EGLenum = 0x30B8;
  169|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_X: types::EGLenum = 0x30B3;
  170|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Y: types::EGLenum = 0x30B5;
  171|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Z: types::EGLenum = 0x30B7;
  172|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_LEVEL: types::EGLenum = 0x30BC;
  173|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_ZOFFSET: types::EGLenum = 0x30BD;
  174|       |#[allow(dead_code, non_upper_case_globals)] pub const GREEN_SIZE: types::EGLenum = 0x3023;
  175|       |#[allow(dead_code, non_upper_case_globals)] pub const HEIGHT: types::EGLenum = 0x3056;
  176|       |#[allow(dead_code, non_upper_case_globals)] pub const HORIZONTAL_RESOLUTION: types::EGLenum = 0x3090;
  177|       |#[allow(dead_code, non_upper_case_globals)] pub const IMAGE_PRESERVED: types::EGLenum = 0x30D2;
  178|       |#[allow(dead_code, non_upper_case_globals)] pub const LARGEST_PBUFFER: types::EGLenum = 0x3058;
  179|       |#[allow(dead_code, non_upper_case_globals)] pub const LEVEL: types::EGLenum = 0x3029;
  180|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET: types::EGLenum = 0x31BF;
  181|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_EXT: types::EGLenum = 0x31BF;
  182|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_KHR: types::EGLenum = 0x31BF;
  183|       |#[allow(dead_code, non_upper_case_globals)] pub const LUMINANCE_BUFFER: types::EGLenum = 0x308F;
  184|       |#[allow(dead_code, non_upper_case_globals)] pub const LUMINANCE_SIZE: types::EGLenum = 0x303D;
  185|       |#[allow(dead_code, non_upper_case_globals)] pub const MATCH_NATIVE_PIXMAP: types::EGLenum = 0x3041;
  186|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_HEIGHT: types::EGLenum = 0x302A;
  187|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_PIXELS: types::EGLenum = 0x302B;
  188|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_WIDTH: types::EGLenum = 0x302C;
  189|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_SWAP_INTERVAL: types::EGLenum = 0x303C;
  190|       |#[allow(dead_code, non_upper_case_globals)] pub const MIN_SWAP_INTERVAL: types::EGLenum = 0x303B;
  191|       |#[allow(dead_code, non_upper_case_globals)] pub const MIPMAP_LEVEL: types::EGLenum = 0x3083;
  192|       |#[allow(dead_code, non_upper_case_globals)] pub const MIPMAP_TEXTURE: types::EGLenum = 0x3082;
  193|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE: types::EGLenum = 0x3099;
  194|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_BOX: types::EGLenum = 0x309B;
  195|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_BOX_BIT: types::EGLenum = 0x0200;
  196|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_DEFAULT: types::EGLenum = 0x309A;
  197|       |#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_RENDERABLE: types::EGLenum = 0x302D;
  198|       |#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_VISUAL_ID: types::EGLenum = 0x302E;
  199|       |#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_VISUAL_TYPE: types::EGLenum = 0x302F;
  200|       |#[allow(dead_code, non_upper_case_globals)] pub const NONE: types::EGLenum = 0x3038;
  201|       |#[allow(dead_code, non_upper_case_globals)] pub const NON_CONFORMANT_CONFIG: types::EGLenum = 0x3051;
  202|       |#[allow(dead_code, non_upper_case_globals)] pub const NOT_INITIALIZED: types::EGLenum = 0x3001;
  203|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_CONTEXT: types::EGLContext = 0 as types::EGLContext;
  204|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_DEVICE_EXT: types::EGLDeviceEXT = 0 as types::EGLDeviceEXT;
  205|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_DISPLAY: types::EGLDisplay = 0 as types::EGLDisplay;
  206|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_IMAGE: types::EGLImage = 0 as types::EGLImage;
  207|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_NATIVE_FENCE_FD_ANDROID: types::EGLint = -1;
  208|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION: types::EGLenum = 0x31BE;
  209|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_EXT: types::EGLenum = 0x31BE;
  210|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_KHR: types::EGLenum = 0x31BE;
  211|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_SURFACE: types::EGLSurface = 0 as types::EGLSurface;
  212|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_SYNC: types::EGLSync = 0 as types::EGLSync;
  213|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_TEXTURE: types::EGLenum = 0x305C;
  214|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_API: types::EGLenum = 0x30A2;
  215|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_BIT: types::EGLenum = 0x0008;
  216|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES2_BIT: types::EGLenum = 0x0004;
  217|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES3_BIT: types::EGLenum = 0x00000040;
  218|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES3_BIT_KHR: types::EGLenum = 0x00000040;
  219|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES_API: types::EGLenum = 0x30A0;
  220|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES_BIT: types::EGLenum = 0x0001;
  221|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_API: types::EGLenum = 0x30A1;
  222|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_BIT: types::EGLenum = 0x0002;
  223|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_IMAGE: types::EGLenum = 0x3096;
  224|       |#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER_BIT: types::EGLenum = 0x0001;
  225|       |#[allow(dead_code, non_upper_case_globals)] pub const PIXEL_ASPECT_RATIO: types::EGLenum = 0x3092;
  226|       |#[allow(dead_code, non_upper_case_globals)] pub const PIXMAP_BIT: types::EGLenum = 0x0002;
  227|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_ANDROID_KHR: types::EGLenum = 0x3141;
  228|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_DEVICE_EXT: types::EGLenum = 0x313F;
  229|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_GBM_KHR: types::EGLenum = 0x31D7;
  230|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_GBM_MESA: types::EGLenum = 0x31D7;
  231|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_WAYLAND_EXT: types::EGLenum = 0x31D8;
  232|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_WAYLAND_KHR: types::EGLenum = 0x31D8;
  233|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_EXT: types::EGLenum = 0x31D5;
  234|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_KHR: types::EGLenum = 0x31D5;
  235|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_SCREEN_EXT: types::EGLenum = 0x31D6;
  236|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_SCREEN_KHR: types::EGLenum = 0x31D6;
  237|       |#[allow(dead_code, non_upper_case_globals)] pub const READ: types::EGLenum = 0x305A;
  238|       |#[allow(dead_code, non_upper_case_globals)] pub const RED_SIZE: types::EGLenum = 0x3024;
  239|       |#[allow(dead_code, non_upper_case_globals)] pub const RENDERABLE_TYPE: types::EGLenum = 0x3040;
  240|       |#[allow(dead_code, non_upper_case_globals)] pub const RENDER_BUFFER: types::EGLenum = 0x3086;
  241|       |#[allow(dead_code, non_upper_case_globals)] pub const RGB_BUFFER: types::EGLenum = 0x308E;
  242|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLES: types::EGLenum = 0x3031;
  243|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLE_BUFFERS: types::EGLenum = 0x3032;
  244|       |#[allow(dead_code, non_upper_case_globals)] pub const SIGNALED: types::EGLenum = 0x30F2;
  245|       |#[allow(dead_code, non_upper_case_globals)] pub const SINGLE_BUFFER: types::EGLenum = 0x3085;
  246|       |#[allow(dead_code, non_upper_case_globals)] pub const SLOW_CONFIG: types::EGLenum = 0x3050;
  247|       |#[allow(dead_code, non_upper_case_globals)] pub const STENCIL_SIZE: types::EGLenum = 0x3026;
  248|       |#[allow(dead_code, non_upper_case_globals)] pub const SUCCESS: types::EGLenum = 0x3000;
  249|       |#[allow(dead_code, non_upper_case_globals)] pub const SURFACE_TYPE: types::EGLenum = 0x3033;
  250|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_BEHAVIOR: types::EGLenum = 0x3093;
  251|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_BEHAVIOR_PRESERVED_BIT: types::EGLenum = 0x0400;
  252|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CL_EVENT: types::EGLenum = 0x30FE;
  253|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CL_EVENT_COMPLETE: types::EGLenum = 0x30FF;
  254|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CONDITION: types::EGLenum = 0x30F8;
  255|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CONDITION_KHR: types::EGLenum = 0x30F8;
  256|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FENCE: types::EGLenum = 0x30F9;
  257|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FENCE_KHR: types::EGLenum = 0x30F9;
  258|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FLUSH_COMMANDS_BIT: types::EGLenum = 0x0001;
  259|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_ANDROID: types::EGLenum = 0x3144;
  260|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_FD_ANDROID: types::EGLenum = 0x3145;
  261|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_SIGNALED_ANDROID: types::EGLenum = 0x3146;
  262|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_PRIOR_COMMANDS_COMPLETE: types::EGLenum = 0x30F0;
  263|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_PRIOR_COMMANDS_COMPLETE_KHR: types::EGLenum = 0x30F0;
  264|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_STATUS: types::EGLenum = 0x30F1;
  265|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_TYPE: types::EGLenum = 0x30F7;
  266|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_2D: types::EGLenum = 0x305F;
  267|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_FORMAT: types::EGLenum = 0x3080;
  268|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_RGB: types::EGLenum = 0x305D;
  269|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_RGBA: types::EGLenum = 0x305E;
  270|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_TARGET: types::EGLenum = 0x3081;
  271|       |#[allow(dead_code, non_upper_case_globals)] pub const TIMEOUT_EXPIRED: types::EGLenum = 0x30F5;
  272|       |#[allow(dead_code, non_upper_case_globals)] pub const TRACK_REFERENCES_KHR: types::EGLenum = 0x3352;
  273|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_BLUE_VALUE: types::EGLenum = 0x3035;
  274|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_GREEN_VALUE: types::EGLenum = 0x3036;
  275|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RED_VALUE: types::EGLenum = 0x3037;
  276|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RGB: types::EGLenum = 0x3052;
  277|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_TYPE: types::EGLenum = 0x3034;
  278|       |#[allow(dead_code, non_upper_case_globals)] pub const TRUE: types::EGLBoolean = 1;
  279|       |#[allow(dead_code, non_upper_case_globals)] pub const UNKNOWN: types::EGLint = -1 as types::EGLint;
  280|       |#[allow(dead_code, non_upper_case_globals)] pub const UNSIGNALED: types::EGLenum = 0x30F3;
  281|       |#[allow(dead_code, non_upper_case_globals)] pub const VENDOR: types::EGLenum = 0x3053;
  282|       |#[allow(dead_code, non_upper_case_globals)] pub const VERSION: types::EGLenum = 0x3054;
  283|       |#[allow(dead_code, non_upper_case_globals)] pub const VERTICAL_RESOLUTION: types::EGLenum = 0x3091;
  284|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT: types::EGLenum = 0x3088;
  285|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_NONPRE: types::EGLenum = 0x308B;
  286|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_PRE: types::EGLenum = 0x308C;
  287|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_PRE_BIT: types::EGLenum = 0x0040;
  288|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE: types::EGLenum = 0x3087;
  289|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_LINEAR: types::EGLenum = 0x308A;
  290|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_LINEAR_BIT: types::EGLenum = 0x0020;
  291|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_sRGB: types::EGLenum = 0x3089;
  292|       |#[allow(dead_code, non_upper_case_globals)] pub const WIDTH: types::EGLenum = 0x3057;
  293|       |#[allow(dead_code, non_upper_case_globals)] pub const WINDOW_BIT: types::EGLenum = 0x0004;
  294|       |
  295|       |        #[allow(dead_code, missing_copy_implementations)]
  296|       |        #[derive(Clone)]
  297|       |        pub struct FnPtr {
  298|       |            /// The function pointer that will be used when calling the function.
  299|       |            f: *const __gl_imports::raw::c_void,
  300|       |            /// True if the pointer points to a real function, false if points to a `panic!` fn.
  301|       |            is_loaded: bool,
  302|       |        }
  303|       |
  304|       |        impl FnPtr {
  305|       |            /// Creates a `FnPtr` from a load attempt.
  306|      0|            fn new(ptr: *const __gl_imports::raw::c_void) -> FnPtr {
  307|      0|                if ptr.is_null() {
  308|      0|                    FnPtr {
  309|      0|                        f: missing_fn_panic as *const __gl_imports::raw::c_void,
  310|      0|                        is_loaded: false
  311|      0|                    }
  312|       |                } else {
  313|      0|                    FnPtr { f: ptr, is_loaded: true }
  314|       |                }
  315|      0|            }
  316|       |
  317|       |            /// Returns `true` if the function has been successfully loaded.
  318|       |            ///
  319|       |            /// If it returns `false`, calling the corresponding function will fail.
  320|       |            #[inline]
  321|       |            #[allow(dead_code)]
  322|      0|            pub fn is_loaded(&self) -> bool {
  323|      0|                self.is_loaded
  324|      0|            }
  325|       |        }
  326|       |    
  327|       |#[inline(never)]
  328|      0|        fn missing_fn_panic() -> ! {
  329|      0|            panic!("egl function was not loaded")
  330|       |        }
  331|       |
  332|       |        #[allow(non_camel_case_types, non_snake_case, dead_code)]
  333|       |        #[derive(Clone)]
  334|       |        pub struct Egl {
  335|       |pub BindAPI: FnPtr,
  336|       |pub BindTexImage: FnPtr,
  337|       |pub ChooseConfig: FnPtr,
  338|       |/// Fallbacks: ClientWaitSyncKHR
  339|       |pub ClientWaitSync: FnPtr,
  340|       |pub ClientWaitSyncKHR: FnPtr,
  341|       |pub CopyBuffers: FnPtr,
  342|       |pub CreateContext: FnPtr,
  343|       |pub CreateImage: FnPtr,
  344|       |pub CreatePbufferFromClientBuffer: FnPtr,
  345|       |pub CreatePbufferSurface: FnPtr,
  346|       |pub CreatePixmapSurface: FnPtr,
  347|       |pub CreatePlatformPixmapSurface: FnPtr,
  348|       |pub CreatePlatformPixmapSurfaceEXT: FnPtr,
  349|       |pub CreatePlatformWindowSurface: FnPtr,
  350|       |pub CreatePlatformWindowSurfaceEXT: FnPtr,
  351|       |/// Fallbacks: CreateSync64KHR
  352|       |pub CreateSync: FnPtr,
  353|       |pub CreateSyncKHR: FnPtr,
  354|       |pub CreateWindowSurface: FnPtr,
  355|       |pub DestroyContext: FnPtr,
  356|       |/// Fallbacks: DestroyImageKHR
  357|       |pub DestroyImage: FnPtr,
  358|       |pub DestroySurface: FnPtr,
  359|       |/// Fallbacks: DestroySyncKHR
  360|       |pub DestroySync: FnPtr,
  361|       |pub DestroySyncKHR: FnPtr,
  362|       |pub DupNativeFenceFDANDROID: FnPtr,
  363|       |pub GetConfigAttrib: FnPtr,
  364|       |pub GetConfigs: FnPtr,
  365|       |pub GetCurrentContext: FnPtr,
  366|       |pub GetCurrentDisplay: FnPtr,
  367|       |pub GetCurrentSurface: FnPtr,
  368|       |pub GetDisplay: FnPtr,
  369|       |pub GetError: FnPtr,
  370|       |pub GetPlatformDisplay: FnPtr,
  371|       |pub GetPlatformDisplayEXT: FnPtr,
  372|       |pub GetProcAddress: FnPtr,
  373|       |pub GetSyncAttrib: FnPtr,
  374|       |pub GetSyncAttribKHR: FnPtr,
  375|       |pub Initialize: FnPtr,
  376|       |pub MakeCurrent: FnPtr,
  377|       |pub QueryAPI: FnPtr,
  378|       |pub QueryContext: FnPtr,
  379|       |pub QueryDeviceAttribEXT: FnPtr,
  380|       |pub QueryDeviceStringEXT: FnPtr,
  381|       |pub QueryDevicesEXT: FnPtr,
  382|       |pub QueryDisplayAttribEXT: FnPtr,
  383|       |/// Fallbacks: QueryDisplayAttribEXT, QueryDisplayAttribNV
  384|       |pub QueryDisplayAttribKHR: FnPtr,
  385|       |pub QueryString: FnPtr,
  386|       |pub QuerySurface: FnPtr,
  387|       |pub ReleaseTexImage: FnPtr,
  388|       |pub ReleaseThread: FnPtr,
  389|       |pub SurfaceAttrib: FnPtr,
  390|       |pub SwapBuffers: FnPtr,
  391|       |pub SwapBuffersWithDamageEXT: FnPtr,
  392|       |pub SwapBuffersWithDamageKHR: FnPtr,
  393|       |pub SwapInterval: FnPtr,
  394|       |pub Terminate: FnPtr,
  395|       |pub WaitClient: FnPtr,
  396|       |pub WaitGL: FnPtr,
  397|       |pub WaitNative: FnPtr,
  398|       |pub WaitSync: FnPtr,
  399|       |pub WaitSyncKHR: FnPtr,
  400|       |_priv: ()
  401|       |}
  402|       |impl Egl {
  403|       |            /// Load each OpenGL symbol using a custom load function. This allows for the
  404|       |            /// use of functions like `glfwGetProcAddress` or `SDL_GL_GetProcAddress`.
  405|       |            ///
  406|       |            /// ~~~ignore
  407|       |            /// let gl = Gl::load_with(|s| glfw.get_proc_address(s));
  408|       |            /// ~~~
  409|       |            #[allow(dead_code, unused_variables)]
  410|      0|            pub fn load_with<F>(mut loadfn: F) -> Egl where F: FnMut(&'static str) -> *const __gl_imports::raw::c_void {
  411|       |                #[inline(never)]
  412|      0|                fn do_metaloadfn(loadfn: &mut dyn FnMut(&'static str) -> *const __gl_imports::raw::c_void,
  413|      0|                                 symbol: &'static str,
  414|      0|                                 symbols: &[&'static str])
  415|      0|                                 -> *const __gl_imports::raw::c_void {
  416|      0|                    let mut ptr = loadfn(symbol);
  417|      0|                    if ptr.is_null() {
  418|      0|                        for &sym in symbols {
  419|      0|                            ptr = loadfn(sym);
  420|      0|                            if !ptr.is_null() { break; }
  421|       |                        }
  422|      0|                    }
  423|      0|                    ptr
  424|      0|                }
  425|      0|                let mut metaloadfn = |symbol: &'static str, symbols: &[&'static str]| {
  426|      0|                    do_metaloadfn(&mut loadfn, symbol, symbols)
  427|      0|                };
  428|      0|                Egl {
  429|      0|BindAPI: FnPtr::new(metaloadfn("eglBindAPI", &[])),
  430|      0|BindTexImage: FnPtr::new(metaloadfn("eglBindTexImage", &[])),
  431|      0|ChooseConfig: FnPtr::new(metaloadfn("eglChooseConfig", &[])),
  432|      0|ClientWaitSync: FnPtr::new(metaloadfn("eglClientWaitSync", &["eglClientWaitSyncKHR"])),
  433|      0|ClientWaitSyncKHR: FnPtr::new(metaloadfn("eglClientWaitSyncKHR", &[])),
  434|      0|CopyBuffers: FnPtr::new(metaloadfn("eglCopyBuffers", &[])),
  435|      0|CreateContext: FnPtr::new(metaloadfn("eglCreateContext", &[])),
  436|      0|CreateImage: FnPtr::new(metaloadfn("eglCreateImage", &[])),
  437|      0|CreatePbufferFromClientBuffer: FnPtr::new(metaloadfn("eglCreatePbufferFromClientBuffer", &[])),
  438|      0|CreatePbufferSurface: FnPtr::new(metaloadfn("eglCreatePbufferSurface", &[])),
  439|      0|CreatePixmapSurface: FnPtr::new(metaloadfn("eglCreatePixmapSurface", &[])),
  440|      0|CreatePlatformPixmapSurface: FnPtr::new(metaloadfn("eglCreatePlatformPixmapSurface", &[])),
  441|      0|CreatePlatformPixmapSurfaceEXT: FnPtr::new(metaloadfn("eglCreatePlatformPixmapSurfaceEXT", &[])),
  442|      0|CreatePlatformWindowSurface: FnPtr::new(metaloadfn("eglCreatePlatformWindowSurface", &[])),
  443|      0|CreatePlatformWindowSurfaceEXT: FnPtr::new(metaloadfn("eglCreatePlatformWindowSurfaceEXT", &[])),
  444|      0|CreateSync: FnPtr::new(metaloadfn("eglCreateSync", &["eglCreateSync64KHR"])),
  445|      0|CreateSyncKHR: FnPtr::new(metaloadfn("eglCreateSyncKHR", &[])),
  446|      0|CreateWindowSurface: FnPtr::new(metaloadfn("eglCreateWindowSurface", &[])),
  447|      0|DestroyContext: FnPtr::new(metaloadfn("eglDestroyContext", &[])),
  448|      0|DestroyImage: FnPtr::new(metaloadfn("eglDestroyImage", &["eglDestroyImageKHR"])),
  449|      0|DestroySurface: FnPtr::new(metaloadfn("eglDestroySurface", &[])),
  450|      0|DestroySync: FnPtr::new(metaloadfn("eglDestroySync", &["eglDestroySyncKHR"])),
  451|      0|DestroySyncKHR: FnPtr::new(metaloadfn("eglDestroySyncKHR", &[])),
  452|      0|DupNativeFenceFDANDROID: FnPtr::new(metaloadfn("eglDupNativeFenceFDANDROID", &[])),
  453|      0|GetConfigAttrib: FnPtr::new(metaloadfn("eglGetConfigAttrib", &[])),
  454|      0|GetConfigs: FnPtr::new(metaloadfn("eglGetConfigs", &[])),
  455|      0|GetCurrentContext: FnPtr::new(metaloadfn("eglGetCurrentContext", &[])),
  456|      0|GetCurrentDisplay: FnPtr::new(metaloadfn("eglGetCurrentDisplay", &[])),
  457|      0|GetCurrentSurface: FnPtr::new(metaloadfn("eglGetCurrentSurface", &[])),
  458|      0|GetDisplay: FnPtr::new(metaloadfn("eglGetDisplay", &[])),
  459|      0|GetError: FnPtr::new(metaloadfn("eglGetError", &[])),
  460|      0|GetPlatformDisplay: FnPtr::new(metaloadfn("eglGetPlatformDisplay", &[])),
  461|      0|GetPlatformDisplayEXT: FnPtr::new(metaloadfn("eglGetPlatformDisplayEXT", &[])),
  462|      0|GetProcAddress: FnPtr::new(metaloadfn("eglGetProcAddress", &[])),
  463|      0|GetSyncAttrib: FnPtr::new(metaloadfn("eglGetSyncAttrib", &[])),
  464|      0|GetSyncAttribKHR: FnPtr::new(metaloadfn("eglGetSyncAttribKHR", &[])),
  465|      0|Initialize: FnPtr::new(metaloadfn("eglInitialize", &[])),
  466|      0|MakeCurrent: FnPtr::new(metaloadfn("eglMakeCurrent", &[])),
  467|      0|QueryAPI: FnPtr::new(metaloadfn("eglQueryAPI", &[])),
  468|      0|QueryContext: FnPtr::new(metaloadfn("eglQueryContext", &[])),
  469|      0|QueryDeviceAttribEXT: FnPtr::new(metaloadfn("eglQueryDeviceAttribEXT", &[])),
  470|      0|QueryDeviceStringEXT: FnPtr::new(metaloadfn("eglQueryDeviceStringEXT", &[])),
  471|      0|QueryDevicesEXT: FnPtr::new(metaloadfn("eglQueryDevicesEXT", &[])),
  472|      0|QueryDisplayAttribEXT: FnPtr::new(metaloadfn("eglQueryDisplayAttribEXT", &[])),
  473|      0|QueryDisplayAttribKHR: FnPtr::new(metaloadfn("eglQueryDisplayAttribKHR", &["eglQueryDisplayAttribEXT", "eglQueryDisplayAttribNV"])),
  474|      0|QueryString: FnPtr::new(metaloadfn("eglQueryString", &[])),
  475|      0|QuerySurface: FnPtr::new(metaloadfn("eglQuerySurface", &[])),
  476|      0|ReleaseTexImage: FnPtr::new(metaloadfn("eglReleaseTexImage", &[])),
  477|      0|ReleaseThread: FnPtr::new(metaloadfn("eglReleaseThread", &[])),
  478|      0|SurfaceAttrib: FnPtr::new(metaloadfn("eglSurfaceAttrib", &[])),
  479|      0|SwapBuffers: FnPtr::new(metaloadfn("eglSwapBuffers", &[])),
  480|      0|SwapBuffersWithDamageEXT: FnPtr::new(metaloadfn("eglSwapBuffersWithDamageEXT", &[])),
  481|      0|SwapBuffersWithDamageKHR: FnPtr::new(metaloadfn("eglSwapBuffersWithDamageKHR", &[])),
  482|      0|SwapInterval: FnPtr::new(metaloadfn("eglSwapInterval", &[])),
  483|      0|Terminate: FnPtr::new(metaloadfn("eglTerminate", &[])),
  484|      0|WaitClient: FnPtr::new(metaloadfn("eglWaitClient", &[])),
  485|      0|WaitGL: FnPtr::new(metaloadfn("eglWaitGL", &[])),
  486|      0|WaitNative: FnPtr::new(metaloadfn("eglWaitNative", &[])),
  487|      0|WaitSync: FnPtr::new(metaloadfn("eglWaitSync", &[])),
  488|      0|WaitSyncKHR: FnPtr::new(metaloadfn("eglWaitSyncKHR", &[])),
  489|      0|_priv: ()
  490|      0|}
  491|      0|        }
  492|       |#[allow(non_snake_case, unused_variables, dead_code)]
  493|      0|            #[inline] pub unsafe fn BindAPI(&self, api: types::EGLenum) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLenum) -> types::EGLBoolean>(self.BindAPI.f)(api) }
  494|       |#[allow(non_snake_case, unused_variables, dead_code)]
  495|      0|            #[inline] pub unsafe fn BindTexImage(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, buffer: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint) -> types::EGLBoolean>(self.BindTexImage.f)(dpy, surface, buffer) }
  496|       |#[allow(non_snake_case, unused_variables, dead_code)]
  497|      0|            #[inline] pub unsafe fn ChooseConfig(&self, dpy: types::EGLDisplay, attrib_list: *const types::EGLint, configs: *mut types::EGLConfig, config_size: types::EGLint, num_config: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, *const types::EGLint, *mut types::EGLConfig, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.ChooseConfig.f)(dpy, attrib_list, configs, config_size, num_config) }
  498|       |#[allow(non_snake_case, unused_variables, dead_code)]
  499|      0|            #[inline] pub unsafe fn ClientWaitSync(&self, dpy: types::EGLDisplay, sync: types::EGLSync, flags: types::EGLint, timeout: types::EGLTime) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync, types::EGLint, types::EGLTime) -> types::EGLint>(self.ClientWaitSync.f)(dpy, sync, flags, timeout) }
  500|       |#[allow(non_snake_case, unused_variables, dead_code)]
  501|      0|            #[inline] pub unsafe fn ClientWaitSyncKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, flags: types::EGLint, timeout: types::EGLTimeKHR) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint, types::EGLTimeKHR) -> types::EGLint>(self.ClientWaitSyncKHR.f)(dpy, sync, flags, timeout) }
  502|       |#[allow(non_snake_case, unused_variables, dead_code)]
  503|      0|            #[inline] pub unsafe fn CopyBuffers(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, target: types::EGLNativePixmapType) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLNativePixmapType) -> types::EGLBoolean>(self.CopyBuffers.f)(dpy, surface, target) }
  504|       |#[allow(non_snake_case, unused_variables, dead_code)]
  505|      0|            #[inline] pub unsafe fn CreateContext(&self, dpy: types::EGLDisplay, config: types::EGLConfig, share_context: types::EGLContext, attrib_list: *const types::EGLint) -> types::EGLContext { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLContext, *const types::EGLint) -> types::EGLContext>(self.CreateContext.f)(dpy, config, share_context, attrib_list) }
  506|       |#[allow(non_snake_case, unused_variables, dead_code)]
  507|      0|            #[inline] pub unsafe fn CreateImage(&self, dpy: types::EGLDisplay, ctx: types::EGLContext, target: types::EGLenum, buffer: types::EGLClientBuffer, attrib_list: *const types::EGLAttrib) -> types::EGLImage { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLContext, types::EGLenum, types::EGLClientBuffer, *const types::EGLAttrib) -> types::EGLImage>(self.CreateImage.f)(dpy, ctx, target, buffer, attrib_list) }
  508|       |#[allow(non_snake_case, unused_variables, dead_code)]
  509|      0|            #[inline] pub unsafe fn CreatePbufferFromClientBuffer(&self, dpy: types::EGLDisplay, buftype: types::EGLenum, buffer: types::EGLClientBuffer, config: types::EGLConfig, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLenum, types::EGLClientBuffer, types::EGLConfig, *const types::EGLint) -> types::EGLSurface>(self.CreatePbufferFromClientBuffer.f)(dpy, buftype, buffer, config, attrib_list) }
  510|       |#[allow(non_snake_case, unused_variables, dead_code)]
  511|      0|            #[inline] pub unsafe fn CreatePbufferSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *const types::EGLint) -> types::EGLSurface>(self.CreatePbufferSurface.f)(dpy, config, attrib_list) }
  512|       |#[allow(non_snake_case, unused_variables, dead_code)]
  513|      0|            #[inline] pub unsafe fn CreatePixmapSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, pixmap: types::EGLNativePixmapType, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLNativePixmapType, *const types::EGLint) -> types::EGLSurface>(self.CreatePixmapSurface.f)(dpy, config, pixmap, attrib_list) }
  514|       |#[allow(non_snake_case, unused_variables, dead_code)]
  515|      0|            #[inline] pub unsafe fn CreatePlatformPixmapSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_pixmap: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -> types::EGLSurface>(self.CreatePlatformPixmapSurface.f)(dpy, config, native_pixmap, attrib_list) }
  516|       |#[allow(non_snake_case, unused_variables, dead_code)]
  517|      0|            #[inline] pub unsafe fn CreatePlatformPixmapSurfaceEXT(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_pixmap: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLint) -> types::EGLSurface>(self.CreatePlatformPixmapSurfaceEXT.f)(dpy, config, native_pixmap, attrib_list) }
  518|       |#[allow(non_snake_case, unused_variables, dead_code)]
  519|      0|            #[inline] pub unsafe fn CreatePlatformWindowSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_window: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -> types::EGLSurface>(self.CreatePlatformWindowSurface.f)(dpy, config, native_window, attrib_list) }
  520|       |#[allow(non_snake_case, unused_variables, dead_code)]
  521|      0|            #[inline] pub unsafe fn CreatePlatformWindowSurfaceEXT(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_window: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLint) -> types::EGLSurface>(self.CreatePlatformWindowSurfaceEXT.f)(dpy, config, native_window, attrib_list) }
  522|       |#[allow(non_snake_case, unused_variables, dead_code)]
  523|      0|            #[inline] pub unsafe fn CreateSync(&self, dpy: types::EGLDisplay, type_: types::EGLenum, attrib_list: *const types::EGLAttrib) -> types::EGLSync { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLenum, *const types::EGLAttrib) -> types::EGLSync>(self.CreateSync.f)(dpy, type_, attrib_list) }
  524|       |#[allow(non_snake_case, unused_variables, dead_code)]
  525|      0|            #[inline] pub unsafe fn CreateSyncKHR(&self, dpy: types::EGLDisplay, type_: types::EGLenum, attrib_list: *const types::EGLint) -> types::EGLSyncKHR { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLenum, *const types::EGLint) -> types::EGLSyncKHR>(self.CreateSyncKHR.f)(dpy, type_, attrib_list) }
  526|       |#[allow(non_snake_case, unused_variables, dead_code)]
  527|      0|            #[inline] pub unsafe fn CreateWindowSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, win: types::EGLNativeWindowType, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLNativeWindowType, *const types::EGLint) -> types::EGLSurface>(self.CreateWindowSurface.f)(dpy, config, win, attrib_list) }
  528|       |#[allow(non_snake_case, unused_variables, dead_code)]
  529|      0|            #[inline] pub unsafe fn DestroyContext(&self, dpy: types::EGLDisplay, ctx: types::EGLContext) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLContext) -> types::EGLBoolean>(self.DestroyContext.f)(dpy, ctx) }
  530|       |#[allow(non_snake_case, unused_variables, dead_code)]
  531|      0|            #[inline] pub unsafe fn DestroyImage(&self, dpy: types::EGLDisplay, image: types::EGLImage) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLImage) -> types::EGLBoolean>(self.DestroyImage.f)(dpy, image) }
  532|       |#[allow(non_snake_case, unused_variables, dead_code)]
  533|      0|            #[inline] pub unsafe fn DestroySurface(&self, dpy: types::EGLDisplay, surface: types::EGLSurface) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface) -> types::EGLBoolean>(self.DestroySurface.f)(dpy, surface) }
  534|       |#[allow(non_snake_case, unused_variables, dead_code)]
  535|      0|            #[inline] pub unsafe fn DestroySync(&self, dpy: types::EGLDisplay, sync: types::EGLSync) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync) -> types::EGLBoolean>(self.DestroySync.f)(dpy, sync) }
  536|       |#[allow(non_snake_case, unused_variables, dead_code)]
  537|      0|            #[inline] pub unsafe fn DestroySyncKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR) -> types::EGLBoolean>(self.DestroySyncKHR.f)(dpy, sync) }
  538|       |#[allow(non_snake_case, unused_variables, dead_code)]
  539|      0|            #[inline] pub unsafe fn DupNativeFenceFDANDROID(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR) -> types::EGLint>(self.DupNativeFenceFDANDROID.f)(dpy, sync) }
  540|       |#[allow(non_snake_case, unused_variables, dead_code)]
  541|      0|            #[inline] pub unsafe fn GetConfigAttrib(&self, dpy: types::EGLDisplay, config: types::EGLConfig, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.GetConfigAttrib.f)(dpy, config, attribute, value) }
  542|       |#[allow(non_snake_case, unused_variables, dead_code)]
  543|      0|            #[inline] pub unsafe fn GetConfigs(&self, dpy: types::EGLDisplay, configs: *mut types::EGLConfig, config_size: types::EGLint, num_config: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, *mut types::EGLConfig, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.GetConfigs.f)(dpy, configs, config_size, num_config) }
  544|       |#[allow(non_snake_case, unused_variables, dead_code)]
  545|      0|            #[inline] pub unsafe fn GetCurrentContext(&self, ) -> types::EGLContext { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLContext>(self.GetCurrentContext.f)() }
  546|       |#[allow(non_snake_case, unused_variables, dead_code)]
  547|      0|            #[inline] pub unsafe fn GetCurrentDisplay(&self, ) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLDisplay>(self.GetCurrentDisplay.f)() }
  548|       |#[allow(non_snake_case, unused_variables, dead_code)]
  549|      0|            #[inline] pub unsafe fn GetCurrentSurface(&self, readdraw: types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLint) -> types::EGLSurface>(self.GetCurrentSurface.f)(readdraw) }
  550|       |#[allow(non_snake_case, unused_variables, dead_code)]
  551|      0|            #[inline] pub unsafe fn GetDisplay(&self, display_id: types::EGLNativeDisplayType) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLNativeDisplayType) -> types::EGLDisplay>(self.GetDisplay.f)(display_id) }
  552|       |#[allow(non_snake_case, unused_variables, dead_code)]
  553|      0|            #[inline] pub unsafe fn GetError(&self, ) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLint>(self.GetError.f)() }
  554|       |#[allow(non_snake_case, unused_variables, dead_code)]
  555|      0|            #[inline] pub unsafe fn GetPlatformDisplay(&self, platform: types::EGLenum, native_display: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLenum, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -> types::EGLDisplay>(self.GetPlatformDisplay.f)(platform, native_display, attrib_list) }
  556|       |#[allow(non_snake_case, unused_variables, dead_code)]
  557|      0|            #[inline] pub unsafe fn GetPlatformDisplayEXT(&self, platform: types::EGLenum, native_display: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLenum, *mut __gl_imports::raw::c_void, *const types::EGLint) -> types::EGLDisplay>(self.GetPlatformDisplayEXT.f)(platform, native_display, attrib_list) }
  558|       |#[allow(non_snake_case, unused_variables, dead_code)]
  559|      0|            #[inline] pub unsafe fn GetProcAddress(&self, procname: *const __gl_imports::raw::c_char) -> types::__eglMustCastToProperFunctionPointerType { __gl_imports::mem::transmute::<_, extern "system" fn(*const __gl_imports::raw::c_char) -> types::__eglMustCastToProperFunctionPointerType>(self.GetProcAddress.f)(procname) }
  560|       |#[allow(non_snake_case, unused_variables, dead_code)]
  561|      0|            #[inline] pub unsafe fn GetSyncAttrib(&self, dpy: types::EGLDisplay, sync: types::EGLSync, attribute: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.GetSyncAttrib.f)(dpy, sync, attribute, value) }
  562|       |#[allow(non_snake_case, unused_variables, dead_code)]
  563|      0|            #[inline] pub unsafe fn GetSyncAttribKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.GetSyncAttribKHR.f)(dpy, sync, attribute, value) }
  564|       |#[allow(non_snake_case, unused_variables, dead_code)]
  565|      0|            #[inline] pub unsafe fn Initialize(&self, dpy: types::EGLDisplay, major: *mut types::EGLint, minor: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, *mut types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.Initialize.f)(dpy, major, minor) }
  566|       |#[allow(non_snake_case, unused_variables, dead_code)]
  567|      0|            #[inline] pub unsafe fn MakeCurrent(&self, dpy: types::EGLDisplay, draw: types::EGLSurface, read: types::EGLSurface, ctx: types::EGLContext) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLSurface, types::EGLContext) -> types::EGLBoolean>(self.MakeCurrent.f)(dpy, draw, read, ctx) }
  568|       |#[allow(non_snake_case, unused_variables, dead_code)]
  569|      0|            #[inline] pub unsafe fn QueryAPI(&self, ) -> types::EGLenum { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLenum>(self.QueryAPI.f)() }
  570|       |#[allow(non_snake_case, unused_variables, dead_code)]
  571|      0|            #[inline] pub unsafe fn QueryContext(&self, dpy: types::EGLDisplay, ctx: types::EGLContext, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLContext, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.QueryContext.f)(dpy, ctx, attribute, value) }
  572|       |#[allow(non_snake_case, unused_variables, dead_code)]
  573|      0|            #[inline] pub unsafe fn QueryDeviceAttribEXT(&self, device: types::EGLDeviceEXT, attribute: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDeviceEXT, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.QueryDeviceAttribEXT.f)(device, attribute, value) }
  574|       |#[allow(non_snake_case, unused_variables, dead_code)]
  575|      0|            #[inline] pub unsafe fn QueryDeviceStringEXT(&self, device: types::EGLDeviceEXT, name: types::EGLint) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDeviceEXT, types::EGLint) -> *const __gl_imports::raw::c_char>(self.QueryDeviceStringEXT.f)(device, name) }
  576|       |#[allow(non_snake_case, unused_variables, dead_code)]
  577|      0|            #[inline] pub unsafe fn QueryDevicesEXT(&self, max_devices: types::EGLint, devices: *mut types::EGLDeviceEXT, num_devices: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLint, *mut types::EGLDeviceEXT, *mut types::EGLint) -> types::EGLBoolean>(self.QueryDevicesEXT.f)(max_devices, devices, num_devices) }
  578|       |#[allow(non_snake_case, unused_variables, dead_code)]
  579|      0|            #[inline] pub unsafe fn QueryDisplayAttribEXT(&self, dpy: types::EGLDisplay, attribute: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.QueryDisplayAttribEXT.f)(dpy, attribute, value) }
  580|       |#[allow(non_snake_case, unused_variables, dead_code)]
  581|      0|            #[inline] pub unsafe fn QueryDisplayAttribKHR(&self, dpy: types::EGLDisplay, name: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.QueryDisplayAttribKHR.f)(dpy, name, value) }
  582|       |#[allow(non_snake_case, unused_variables, dead_code)]
  583|      0|            #[inline] pub unsafe fn QueryString(&self, dpy: types::EGLDisplay, name: types::EGLint) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint) -> *const __gl_imports::raw::c_char>(self.QueryString.f)(dpy, name) }
  584|       |#[allow(non_snake_case, unused_variables, dead_code)]
  585|      0|            #[inline] pub unsafe fn QuerySurface(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.QuerySurface.f)(dpy, surface, attribute, value) }
  586|       |#[allow(non_snake_case, unused_variables, dead_code)]
  587|      0|            #[inline] pub unsafe fn ReleaseTexImage(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, buffer: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint) -> types::EGLBoolean>(self.ReleaseTexImage.f)(dpy, surface, buffer) }
  588|       |#[allow(non_snake_case, unused_variables, dead_code)]
  589|      0|            #[inline] pub unsafe fn ReleaseThread(&self, ) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLBoolean>(self.ReleaseThread.f)() }
  590|       |#[allow(non_snake_case, unused_variables, dead_code)]
  591|      0|            #[inline] pub unsafe fn SurfaceAttrib(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, attribute: types::EGLint, value: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint, types::EGLint) -> types::EGLBoolean>(self.SurfaceAttrib.f)(dpy, surface, attribute, value) }
  592|       |#[allow(non_snake_case, unused_variables, dead_code)]
  593|      0|            #[inline] pub unsafe fn SwapBuffers(&self, dpy: types::EGLDisplay, surface: types::EGLSurface) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface) -> types::EGLBoolean>(self.SwapBuffers.f)(dpy, surface) }
  594|       |#[allow(non_snake_case, unused_variables, dead_code)]
  595|      0|            #[inline] pub unsafe fn SwapBuffersWithDamageEXT(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, rects: *mut types::EGLint, n_rects: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, *mut types::EGLint, types::EGLint) -> types::EGLBoolean>(self.SwapBuffersWithDamageEXT.f)(dpy, surface, rects, n_rects) }
  596|       |#[allow(non_snake_case, unused_variables, dead_code)]
  597|      0|            #[inline] pub unsafe fn SwapBuffersWithDamageKHR(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, rects: *mut types::EGLint, n_rects: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, *mut types::EGLint, types::EGLint) -> types::EGLBoolean>(self.SwapBuffersWithDamageKHR.f)(dpy, surface, rects, n_rects) }
  598|       |#[allow(non_snake_case, unused_variables, dead_code)]
  599|      0|            #[inline] pub unsafe fn SwapInterval(&self, dpy: types::EGLDisplay, interval: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint) -> types::EGLBoolean>(self.SwapInterval.f)(dpy, interval) }
  600|       |#[allow(non_snake_case, unused_variables, dead_code)]
  601|      0|            #[inline] pub unsafe fn Terminate(&self, dpy: types::EGLDisplay) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay) -> types::EGLBoolean>(self.Terminate.f)(dpy) }
  602|       |#[allow(non_snake_case, unused_variables, dead_code)]
  603|      0|            #[inline] pub unsafe fn WaitClient(&self, ) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLBoolean>(self.WaitClient.f)() }
  604|       |#[allow(non_snake_case, unused_variables, dead_code)]
  605|      0|            #[inline] pub unsafe fn WaitGL(&self, ) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLBoolean>(self.WaitGL.f)() }
  606|       |#[allow(non_snake_case, unused_variables, dead_code)]
  607|      0|            #[inline] pub unsafe fn WaitNative(&self, engine: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLint) -> types::EGLBoolean>(self.WaitNative.f)(engine) }
  608|       |#[allow(non_snake_case, unused_variables, dead_code)]
  609|      0|            #[inline] pub unsafe fn WaitSync(&self, dpy: types::EGLDisplay, sync: types::EGLSync, flags: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync, types::EGLint) -> types::EGLBoolean>(self.WaitSync.f)(dpy, sync, flags) }
  610|       |#[allow(non_snake_case, unused_variables, dead_code)]
  611|      0|            #[inline] pub unsafe fn WaitSyncKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, flags: types::EGLint) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint) -> types::EGLint>(self.WaitSyncKHR.f)(dpy, sync, flags) }
  612|       |}
  613|       |
  614|       |        unsafe impl __gl_imports::Send for Egl {}

c:\language\mdmdview\target\llvm-cov-target\debug\build\glutin_wgl_sys-10af08ee4ccaf0a2\out\wgl_extra_bindings.rs:
    1|       |
    2|       |        mod __gl_imports {
    3|       |            pub use std::mem;
    4|       |            pub use std::marker::Send;
    5|       |            pub use std::os::raw;
    6|       |        }
    7|       |    
    8|       |
    9|       |        pub mod types {
   10|       |            #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)]
   11|       |    
   12|       |// Common types from OpenGL 1.1
   13|       |pub type GLenum = super::__gl_imports::raw::c_uint;
   14|       |pub type GLboolean = super::__gl_imports::raw::c_uchar;
   15|       |pub type GLbitfield = super::__gl_imports::raw::c_uint;
   16|       |pub type GLvoid = super::__gl_imports::raw::c_void;
   17|       |pub type GLbyte = super::__gl_imports::raw::c_char;
   18|       |pub type GLshort = super::__gl_imports::raw::c_short;
   19|       |pub type GLint = super::__gl_imports::raw::c_int;
   20|       |pub type GLclampx = super::__gl_imports::raw::c_int;
   21|       |pub type GLubyte = super::__gl_imports::raw::c_uchar;
   22|       |pub type GLushort = super::__gl_imports::raw::c_ushort;
   23|       |pub type GLuint = super::__gl_imports::raw::c_uint;
   24|       |pub type GLsizei = super::__gl_imports::raw::c_int;
   25|       |pub type GLfloat = super::__gl_imports::raw::c_float;
   26|       |pub type GLclampf = super::__gl_imports::raw::c_float;
   27|       |pub type GLdouble = super::__gl_imports::raw::c_double;
   28|       |pub type GLclampd = super::__gl_imports::raw::c_double;
   29|       |pub type GLeglImageOES = *const super::__gl_imports::raw::c_void;
   30|       |pub type GLchar = super::__gl_imports::raw::c_char;
   31|       |pub type GLcharARB = super::__gl_imports::raw::c_char;
   32|       |
   33|       |#[cfg(target_os = "macos")]
   34|       |pub type GLhandleARB = *const super::__gl_imports::raw::c_void;
   35|       |#[cfg(not(target_os = "macos"))]
   36|       |pub type GLhandleARB = super::__gl_imports::raw::c_uint;
   37|       |
   38|       |pub type GLhalfARB = super::__gl_imports::raw::c_ushort;
   39|       |pub type GLhalf = super::__gl_imports::raw::c_ushort;
   40|       |
   41|       |// Must be 32 bits
   42|       |pub type GLfixed = GLint;
   43|       |
   44|       |pub type GLintptr = isize;
   45|       |pub type GLsizeiptr = isize;
   46|       |pub type GLint64 = i64;
   47|       |pub type GLuint64 = u64;
   48|       |pub type GLintptrARB = isize;
   49|       |pub type GLsizeiptrARB = isize;
   50|       |pub type GLint64EXT = i64;
   51|       |pub type GLuint64EXT = u64;
   52|       |
   53|       |pub enum __GLsync {}
   54|       |pub type GLsync = *const __GLsync;
   55|       |
   56|       |// compatible with OpenCL cl_context
   57|       |pub enum _cl_context {}
   58|       |pub enum _cl_event {}
   59|       |
   60|       |pub type GLDEBUGPROC = Option<extern "system" fn(source: GLenum,
   61|       |                                                 gltype: GLenum,
   62|       |                                                 id: GLuint,
   63|       |                                                 severity: GLenum,
   64|       |                                                 length: GLsizei,
   65|       |                                                 message: *const GLchar,
   66|       |                                                 userParam: *mut super::__gl_imports::raw::c_void)>;
   67|       |pub type GLDEBUGPROCARB = Option<extern "system" fn(source: GLenum,
   68|       |                                                    gltype: GLenum,
   69|       |                                                    id: GLuint,
   70|       |                                                    severity: GLenum,
   71|       |                                                    length: GLsizei,
   72|       |                                                    message: *const GLchar,
   73|       |                                                    userParam: *mut super::__gl_imports::raw::c_void)>;
   74|       |pub type GLDEBUGPROCKHR = Option<extern "system" fn(source: GLenum,
   75|       |                                                    gltype: GLenum,
   76|       |                                                    id: GLuint,
   77|       |                                                    severity: GLenum,
   78|       |                                                    length: GLsizei,
   79|       |                                                    message: *const GLchar,
   80|       |                                                    userParam: *mut super::__gl_imports::raw::c_void)>;
   81|       |
   82|       |// GLES 1 types
   83|       |// "pub type GLclampx = i32;",
   84|       |
   85|       |// GLES 1/2 types (tagged for GLES 1)
   86|       |// "pub type GLbyte = i8;",
   87|       |// "pub type GLubyte = u8;",
   88|       |// "pub type GLfloat = GLfloat;",
   89|       |// "pub type GLclampf = GLfloat;",
   90|       |// "pub type GLfixed = i32;",
   91|       |// "pub type GLint64 = i64;",
   92|       |// "pub type GLuint64 = u64;",
   93|       |// "pub type GLintptr = intptr_t;",
   94|       |// "pub type GLsizeiptr = ssize_t;",
   95|       |
   96|       |// GLES 1/2 types (tagged for GLES 2 - attribute syntax is limited)
   97|       |// "pub type GLbyte = i8;",
   98|       |// "pub type GLubyte = u8;",
   99|       |// "pub type GLfloat = GLfloat;",
  100|       |// "pub type GLclampf = GLfloat;",
  101|       |// "pub type GLfixed = i32;",
  102|       |// "pub type GLint64 = i64;",
  103|       |// "pub type GLuint64 = u64;",
  104|       |// "pub type GLint64EXT = i64;",
  105|       |// "pub type GLuint64EXT = u64;",
  106|       |// "pub type GLintptr = intptr_t;",
  107|       |// "pub type GLsizeiptr = ssize_t;",
  108|       |
  109|       |// GLES 2 types (none currently)
  110|       |
  111|       |// Vendor extension types
  112|       |pub type GLDEBUGPROCAMD = Option<extern "system" fn(id: GLuint,
  113|       |                                                    category: GLenum,
  114|       |                                                    severity: GLenum,
  115|       |                                                    length: GLsizei,
  116|       |                                                    message: *const GLchar,
  117|       |                                                    userParam: *mut super::__gl_imports::raw::c_void)>;
  118|       |pub type GLhalfNV = super::__gl_imports::raw::c_ushort;
  119|       |pub type GLvdpauSurfaceNV = GLintptr;
  120|       |
  121|       |// From WinNT.h
  122|       |
  123|       |pub type CHAR = super::__gl_imports::raw::c_char;
  124|       |pub type HANDLE = PVOID;
  125|       |pub type LONG = super::__gl_imports::raw::c_long;
  126|       |pub type LPCSTR = *const super::__gl_imports::raw::c_char;
  127|       |pub type VOID = ();
  128|       |// #define DECLARE_HANDLE(name) struct name##__{int unused;}; typedef struct name##__ *name
  129|       |pub type HPBUFFERARB = *const super::__gl_imports::raw::c_void;
  130|       |pub type HPBUFFEREXT = *const super::__gl_imports::raw::c_void;
  131|       |pub type HVIDEOOUTPUTDEVICENV = *const super::__gl_imports::raw::c_void;
  132|       |pub type HPVIDEODEV = *const super::__gl_imports::raw::c_void;
  133|       |pub type HPGPUNV = *const super::__gl_imports::raw::c_void;
  134|       |pub type HGPUNV = *const super::__gl_imports::raw::c_void;
  135|       |pub type HVIDEOINPUTDEVICENV = *const super::__gl_imports::raw::c_void;
  136|       |
  137|       |// From Windef.h
  138|       |
  139|       |pub type BOOL = super::__gl_imports::raw::c_int;
  140|       |pub type BYTE = super::__gl_imports::raw::c_uchar;
  141|       |pub type COLORREF = DWORD;
  142|       |pub type FLOAT = super::__gl_imports::raw::c_float;
  143|       |pub type HDC = HANDLE;
  144|       |pub type HENHMETAFILE = HANDLE;
  145|       |pub type HGLRC = *const super::__gl_imports::raw::c_void;
  146|       |pub type INT = super::__gl_imports::raw::c_int;
  147|       |pub type PVOID = *const super::__gl_imports::raw::c_void;
  148|       |pub type LPVOID = *const super::__gl_imports::raw::c_void;
  149|       |pub enum __PROC_fn {}
  150|       |pub type PROC = *mut __PROC_fn;
  151|       |
  152|       |#[repr(C)]
  153|       |pub struct RECT {
  154|       |    left: LONG,
  155|       |    top: LONG,
  156|       |    right: LONG,
  157|       |    bottom: LONG,
  158|       |}
  159|       |
  160|       |pub type UINT = super::__gl_imports::raw::c_uint;
  161|       |pub type USHORT = super::__gl_imports::raw::c_ushort;
  162|       |pub type WORD = super::__gl_imports::raw::c_ushort;
  163|       |
  164|       |// From BaseTsd.h
  165|       |
  166|       |pub type INT32 = i32;
  167|       |pub type INT64 = i64;
  168|       |
  169|       |// From IntSafe.h
  170|       |
  171|       |pub type DWORD = super::__gl_imports::raw::c_ulong;
  172|       |
  173|       |// From Wingdi.h
  174|       |
  175|       |#[repr(C)]
  176|       |pub struct POINTFLOAT {
  177|       |    pub x: FLOAT,
  178|       |    pub y: FLOAT,
  179|       |}
  180|       |
  181|       |#[repr(C)]
  182|       |pub struct GLYPHMETRICSFLOAT {
  183|       |    pub gmfBlackBoxX: FLOAT,
  184|       |    pub gmfBlackBoxY: FLOAT,
  185|       |    pub gmfptGlyphOrigin: POINTFLOAT,
  186|       |    pub gmfCellIncX: FLOAT,
  187|       |    pub gmfCellIncY: FLOAT,
  188|       |}
  189|       |pub type LPGLYPHMETRICSFLOAT = *const GLYPHMETRICSFLOAT;
  190|       |
  191|       |#[repr(C)]
  192|       |pub struct LAYERPLANEDESCRIPTOR {
  193|       |    pub nSize: WORD,
  194|       |    pub nVersion: WORD,
  195|       |    pub dwFlags: DWORD,
  196|       |    pub iPixelType: BYTE,
  197|       |    pub cColorBits: BYTE,
  198|       |    pub cRedBits: BYTE,
  199|       |    pub cRedShift: BYTE,
  200|       |    pub cGreenBits: BYTE,
  201|       |    pub cGreenShift: BYTE,
  202|       |    pub cBlueBits: BYTE,
  203|       |    pub cBlueShift: BYTE,
  204|       |    pub cAlphaBits: BYTE,
  205|       |    pub cAlphaShift: BYTE,
  206|       |    pub cAccumBits: BYTE,
  207|       |    pub cAccumRedBits: BYTE,
  208|       |    pub cAccumGreenBits: BYTE,
  209|       |    pub cAccumBlueBits: BYTE,
  210|       |    pub cAccumAlphaBits: BYTE,
  211|       |    pub cDepthBits: BYTE,
  212|       |    pub cStencilBits: BYTE,
  213|       |    pub cAuxBuffers: BYTE,
  214|       |    pub iLayerType: BYTE,
  215|       |    pub bReserved: BYTE,
  216|       |    pub crTransparent: COLORREF,
  217|       |}
  218|       |
  219|       |#[repr(C)]
  220|       |pub struct PIXELFORMATDESCRIPTOR {
  221|       |    pub nSize: WORD,
  222|       |    pub nVersion: WORD,
  223|       |    pub dwFlags: DWORD,
  224|       |    pub iPixelType: BYTE,
  225|       |    pub cColorBits: BYTE,
  226|       |    pub cRedBits: BYTE,
  227|       |    pub cRedShift: BYTE,
  228|       |    pub cGreenBits: BYTE,
  229|       |    pub cGreenShift: BYTE,
  230|       |    pub cBlueBits: BYTE,
  231|       |    pub cBlueShift: BYTE,
  232|       |    pub cAlphaBits: BYTE,
  233|       |    pub cAlphaShift: BYTE,
  234|       |    pub cAccumBits: BYTE,
  235|       |    pub cAccumRedBits: BYTE,
  236|       |    pub cAccumGreenBits: BYTE,
  237|       |    pub cAccumBlueBits: BYTE,
  238|       |    pub cAccumAlphaBits: BYTE,
  239|       |    pub cDepthBits: BYTE,
  240|       |    pub cStencilBits: BYTE,
  241|       |    pub cAuxBuffers: BYTE,
  242|       |    pub iLayerType: BYTE,
  243|       |    pub bReserved: BYTE,
  244|       |    pub dwLayerMask: DWORD,
  245|       |    pub dwVisibleMask: DWORD,
  246|       |    pub dwDamageMask: DWORD,
  247|       |}
  248|       |
  249|       |#[repr(C)]
  250|       |pub struct _GPU_DEVICE {
  251|       |    cb: DWORD,
  252|       |    DeviceName: [CHAR; 32],
  253|       |    DeviceString: [CHAR; 128],
  254|       |    Flags: DWORD,
  255|       |    rcVirtualScreen: RECT,
  256|       |}
  257|       |
  258|       |pub struct GPU_DEVICE(_GPU_DEVICE);
  259|       |pub struct PGPU_DEVICE(*const _GPU_DEVICE);
  260|       |
  261|       |}
  262|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCELERATION_ARB: types::GLenum = 0x2003;
  263|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_ALPHA_BITS_ARB: types::GLenum = 0x2021;
  264|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_BITS_ARB: types::GLenum = 0x201D;
  265|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_BLUE_BITS_ARB: types::GLenum = 0x2020;
  266|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_GREEN_BITS_ARB: types::GLenum = 0x201F;
  267|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_RED_BITS_ARB: types::GLenum = 0x201E;
  268|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_BITS_ARB: types::GLenum = 0x201B;
  269|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_SHIFT_ARB: types::GLenum = 0x201C;
  270|       |#[allow(dead_code, non_upper_case_globals)] pub const AUX_BUFFERS_ARB: types::GLenum = 0x2024;
  271|       |#[allow(dead_code, non_upper_case_globals)] pub const BLUE_BITS_ARB: types::GLenum = 0x2019;
  272|       |#[allow(dead_code, non_upper_case_globals)] pub const BLUE_SHIFT_ARB: types::GLenum = 0x201A;
  273|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_BITS_ARB: types::GLenum = 0x2014;
  274|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB: types::GLenum = 0x00000002;
  275|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CORE_PROFILE_BIT_ARB: types::GLenum = 0x00000001;
  276|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_DEBUG_BIT_ARB: types::GLenum = 0x00000001;
  277|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_ES2_PROFILE_BIT_EXT: types::GLenum = 0x00000004;
  278|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FLAGS_ARB: types::GLenum = 0x2094;
  279|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FORWARD_COMPATIBLE_BIT_ARB: types::GLenum = 0x00000002;
  280|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_LAYER_PLANE_ARB: types::GLenum = 0x2093;
  281|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION_ARB: types::GLenum = 0x2091;
  282|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION_ARB: types::GLenum = 0x2092;
  283|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_NO_ERROR_ARB: types::GLenum = 0x31B3;
  284|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_PROFILE_MASK_ARB: types::GLenum = 0x9126;
  285|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_ARB: types::GLenum = 0x2097;
  286|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB: types::GLenum = 0x2098;
  287|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_NONE_ARB: types::GLenum = 0;
  288|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB: types::GLenum = 0x8256;
  289|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_ROBUST_ACCESS_BIT_ARB: types::GLenum = 0x00000004;
  290|       |#[allow(dead_code, non_upper_case_globals)] pub const DEPTH_BITS_ARB: types::GLenum = 0x2022;
  291|       |#[allow(dead_code, non_upper_case_globals)] pub const DOUBLE_BUFFER_ARB: types::GLenum = 0x2011;
  292|       |#[allow(dead_code, non_upper_case_globals)] pub const DRAW_TO_BITMAP_ARB: types::GLenum = 0x2002;
  293|       |#[allow(dead_code, non_upper_case_globals)] pub const DRAW_TO_WINDOW_ARB: types::GLenum = 0x2001;
  294|       |#[allow(dead_code, non_upper_case_globals)] pub const FONT_LINES: types::GLenum = 0;
  295|       |#[allow(dead_code, non_upper_case_globals)] pub const FONT_POLYGONS: types::GLenum = 1;
  296|       |#[allow(dead_code, non_upper_case_globals)] pub const FRAMEBUFFER_SRGB_CAPABLE_ARB: types::GLenum = 0x20A9;
  297|       |#[allow(dead_code, non_upper_case_globals)] pub const FRAMEBUFFER_SRGB_CAPABLE_EXT: types::GLenum = 0x20A9;
  298|       |#[allow(dead_code, non_upper_case_globals)] pub const FULL_ACCELERATION_ARB: types::GLenum = 0x2027;
  299|       |#[allow(dead_code, non_upper_case_globals)] pub const GENERIC_ACCELERATION_ARB: types::GLenum = 0x2026;
  300|       |#[allow(dead_code, non_upper_case_globals)] pub const GREEN_BITS_ARB: types::GLenum = 0x2017;
  301|       |#[allow(dead_code, non_upper_case_globals)] pub const GREEN_SHIFT_ARB: types::GLenum = 0x2018;
  302|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_ARB: types::GLenum = 0x8252;
  303|       |#[allow(dead_code, non_upper_case_globals)] pub const NEED_PALETTE_ARB: types::GLenum = 0x2004;
  304|       |#[allow(dead_code, non_upper_case_globals)] pub const NEED_SYSTEM_PALETTE_ARB: types::GLenum = 0x2005;
  305|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_ACCELERATION_ARB: types::GLenum = 0x2025;
  306|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_ARB: types::GLenum = 0x8261;
  307|       |#[allow(dead_code, non_upper_case_globals)] pub const NUMBER_OVERLAYS_ARB: types::GLenum = 0x2008;
  308|       |#[allow(dead_code, non_upper_case_globals)] pub const NUMBER_PIXEL_FORMATS_ARB: types::GLenum = 0x2000;
  309|       |#[allow(dead_code, non_upper_case_globals)] pub const NUMBER_UNDERLAYS_ARB: types::GLenum = 0x2009;
  310|       |#[allow(dead_code, non_upper_case_globals)] pub const PIXEL_TYPE_ARB: types::GLenum = 0x2013;
  311|       |#[allow(dead_code, non_upper_case_globals)] pub const RED_BITS_ARB: types::GLenum = 0x2015;
  312|       |#[allow(dead_code, non_upper_case_globals)] pub const RED_SHIFT_ARB: types::GLenum = 0x2016;
  313|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLES_ARB: types::GLenum = 0x2042;
  314|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLE_BUFFERS_ARB: types::GLenum = 0x2041;
  315|       |#[allow(dead_code, non_upper_case_globals)] pub const SHARE_ACCUM_ARB: types::GLenum = 0x200E;
  316|       |#[allow(dead_code, non_upper_case_globals)] pub const SHARE_DEPTH_ARB: types::GLenum = 0x200C;
  317|       |#[allow(dead_code, non_upper_case_globals)] pub const SHARE_STENCIL_ARB: types::GLenum = 0x200D;
  318|       |#[allow(dead_code, non_upper_case_globals)] pub const STENCIL_BITS_ARB: types::GLenum = 0x2023;
  319|       |#[allow(dead_code, non_upper_case_globals)] pub const STEREO_ARB: types::GLenum = 0x2012;
  320|       |#[allow(dead_code, non_upper_case_globals)] pub const SUPPORT_GDI_ARB: types::GLenum = 0x200F;
  321|       |#[allow(dead_code, non_upper_case_globals)] pub const SUPPORT_OPENGL_ARB: types::GLenum = 0x2010;
  322|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_COPY_ARB: types::GLenum = 0x2029;
  323|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_EXCHANGE_ARB: types::GLenum = 0x2028;
  324|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_LAYER_BUFFERS_ARB: types::GLenum = 0x2006;
  325|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_MAIN_PLANE: types::GLenum = 0x00000001;
  326|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_METHOD_ARB: types::GLenum = 0x2007;
  327|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY1: types::GLenum = 0x00000002;
  328|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY10: types::GLenum = 0x00000400;
  329|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY11: types::GLenum = 0x00000800;
  330|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY12: types::GLenum = 0x00001000;
  331|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY13: types::GLenum = 0x00002000;
  332|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY14: types::GLenum = 0x00004000;
  333|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY15: types::GLenum = 0x00008000;
  334|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY2: types::GLenum = 0x00000004;
  335|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY3: types::GLenum = 0x00000008;
  336|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY4: types::GLenum = 0x00000010;
  337|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY5: types::GLenum = 0x00000020;
  338|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY6: types::GLenum = 0x00000040;
  339|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY7: types::GLenum = 0x00000080;
  340|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY8: types::GLenum = 0x00000100;
  341|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY9: types::GLenum = 0x00000200;
  342|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDEFINED_ARB: types::GLenum = 0x202A;
  343|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY1: types::GLenum = 0x00010000;
  344|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY10: types::GLenum = 0x02000000;
  345|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY11: types::GLenum = 0x04000000;
  346|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY12: types::GLenum = 0x08000000;
  347|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY13: types::GLenum = 0x10000000;
  348|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY14: types::GLenum = 0x20000000;
  349|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY15: types::GLenum = 0x40000000;
  350|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY2: types::GLenum = 0x00020000;
  351|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY3: types::GLenum = 0x00040000;
  352|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY4: types::GLenum = 0x00080000;
  353|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY5: types::GLenum = 0x00100000;
  354|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY6: types::GLenum = 0x00200000;
  355|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY7: types::GLenum = 0x00400000;
  356|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY8: types::GLenum = 0x00800000;
  357|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY9: types::GLenum = 0x01000000;
  358|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_ALPHA_VALUE_ARB: types::GLenum = 0x203A;
  359|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_ARB: types::GLenum = 0x200A;
  360|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_BLUE_VALUE_ARB: types::GLenum = 0x2039;
  361|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_GREEN_VALUE_ARB: types::GLenum = 0x2038;
  362|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_INDEX_VALUE_ARB: types::GLenum = 0x203B;
  363|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RED_VALUE_ARB: types::GLenum = 0x2037;
  364|       |#[allow(dead_code, non_upper_case_globals)] pub const TYPE_COLORINDEX_ARB: types::GLenum = 0x202C;
  365|       |#[allow(dead_code, non_upper_case_globals)] pub const TYPE_RGBA_ARB: types::GLenum = 0x202B;
  366|       |#[allow(dead_code, non_upper_case_globals)] pub const TYPE_RGBA_FLOAT_ARB: types::GLenum = 0x21A0;
  367|       |
  368|       |        #[allow(dead_code, missing_copy_implementations)]
  369|       |        #[derive(Clone)]
  370|       |        pub struct FnPtr {
  371|       |            /// The function pointer that will be used when calling the function.
  372|       |            f: *const __gl_imports::raw::c_void,
  373|       |            /// True if the pointer points to a real function, false if points to a `panic!` fn.
  374|       |            is_loaded: bool,
  375|       |        }
  376|       |
  377|       |        impl FnPtr {
  378|       |            /// Creates a `FnPtr` from a load attempt.
  379|      0|            fn new(ptr: *const __gl_imports::raw::c_void) -> FnPtr {
  380|      0|                if ptr.is_null() {
  381|      0|                    FnPtr {
  382|      0|                        f: missing_fn_panic as *const __gl_imports::raw::c_void,
  383|      0|                        is_loaded: false
  384|      0|                    }
  385|       |                } else {
  386|      0|                    FnPtr { f: ptr, is_loaded: true }
  387|       |                }
  388|      0|            }
  389|       |
  390|       |            /// Returns `true` if the function has been successfully loaded.
  391|       |            ///
  392|       |            /// If it returns `false`, calling the corresponding function will fail.
  393|       |            #[inline]
  394|       |            #[allow(dead_code)]
  395|      0|            pub fn is_loaded(&self) -> bool {
  396|      0|                self.is_loaded
  397|      0|            }
  398|       |        }
  399|       |    
  400|       |#[inline(never)]
  401|      0|        fn missing_fn_panic() -> ! {
  402|      0|            panic!("wgl function was not loaded")
  403|       |        }
  404|       |
  405|       |        #[allow(non_camel_case_types, non_snake_case, dead_code)]
  406|       |        #[derive(Clone)]
  407|       |        pub struct Wgl {
  408|       |pub ChoosePixelFormatARB: FnPtr,
  409|       |pub CopyContext: FnPtr,
  410|       |pub CreateContext: FnPtr,
  411|       |pub CreateContextAttribsARB: FnPtr,
  412|       |pub CreateLayerContext: FnPtr,
  413|       |pub DeleteContext: FnPtr,
  414|       |pub DescribeLayerPlane: FnPtr,
  415|       |pub GetCurrentContext: FnPtr,
  416|       |pub GetCurrentDC: FnPtr,
  417|       |pub GetExtensionsStringARB: FnPtr,
  418|       |pub GetExtensionsStringEXT: FnPtr,
  419|       |pub GetLayerPaletteEntries: FnPtr,
  420|       |pub GetPixelFormatAttribfvARB: FnPtr,
  421|       |pub GetPixelFormatAttribivARB: FnPtr,
  422|       |pub GetProcAddress: FnPtr,
  423|       |pub GetSwapIntervalEXT: FnPtr,
  424|       |pub MakeCurrent: FnPtr,
  425|       |pub RealizeLayerPalette: FnPtr,
  426|       |pub SetLayerPaletteEntries: FnPtr,
  427|       |pub ShareLists: FnPtr,
  428|       |pub SwapIntervalEXT: FnPtr,
  429|       |pub SwapLayerBuffers: FnPtr,
  430|       |pub UseFontBitmaps: FnPtr,
  431|       |pub UseFontBitmapsA: FnPtr,
  432|       |pub UseFontBitmapsW: FnPtr,
  433|       |pub UseFontOutlines: FnPtr,
  434|       |pub UseFontOutlinesA: FnPtr,
  435|       |pub UseFontOutlinesW: FnPtr,
  436|       |_priv: ()
  437|       |}
  438|       |impl Wgl {
  439|       |            /// Load each OpenGL symbol using a custom load function. This allows for the
  440|       |            /// use of functions like `glfwGetProcAddress` or `SDL_GL_GetProcAddress`.
  441|       |            ///
  442|       |            /// ~~~ignore
  443|       |            /// let gl = Gl::load_with(|s| glfw.get_proc_address(s));
  444|       |            /// ~~~
  445|       |            #[allow(dead_code, unused_variables)]
  446|      0|            pub fn load_with<F>(mut loadfn: F) -> Wgl where F: FnMut(&'static str) -> *const __gl_imports::raw::c_void {
  447|       |                #[inline(never)]
  448|      0|                fn do_metaloadfn(loadfn: &mut dyn FnMut(&'static str) -> *const __gl_imports::raw::c_void,
  449|      0|                                 symbol: &'static str,
  450|      0|                                 symbols: &[&'static str])
  451|      0|                                 -> *const __gl_imports::raw::c_void {
  452|      0|                    let mut ptr = loadfn(symbol);
  453|      0|                    if ptr.is_null() {
  454|      0|                        for &sym in symbols {
  455|      0|                            ptr = loadfn(sym);
  456|      0|                            if !ptr.is_null() { break; }
  457|       |                        }
  458|      0|                    }
  459|      0|                    ptr
  460|      0|                }
  461|      0|                let mut metaloadfn = |symbol: &'static str, symbols: &[&'static str]| {
  462|      0|                    do_metaloadfn(&mut loadfn, symbol, symbols)
  463|      0|                };
  464|      0|                Wgl {
  465|      0|ChoosePixelFormatARB: FnPtr::new(metaloadfn("wglChoosePixelFormatARB", &[])),
  466|      0|CopyContext: FnPtr::new(metaloadfn("wglCopyContext", &[])),
  467|      0|CreateContext: FnPtr::new(metaloadfn("wglCreateContext", &[])),
  468|      0|CreateContextAttribsARB: FnPtr::new(metaloadfn("wglCreateContextAttribsARB", &[])),
  469|      0|CreateLayerContext: FnPtr::new(metaloadfn("wglCreateLayerContext", &[])),
  470|      0|DeleteContext: FnPtr::new(metaloadfn("wglDeleteContext", &[])),
  471|      0|DescribeLayerPlane: FnPtr::new(metaloadfn("wglDescribeLayerPlane", &[])),
  472|      0|GetCurrentContext: FnPtr::new(metaloadfn("wglGetCurrentContext", &[])),
  473|      0|GetCurrentDC: FnPtr::new(metaloadfn("wglGetCurrentDC", &[])),
  474|      0|GetExtensionsStringARB: FnPtr::new(metaloadfn("wglGetExtensionsStringARB", &[])),
  475|      0|GetExtensionsStringEXT: FnPtr::new(metaloadfn("wglGetExtensionsStringEXT", &[])),
  476|      0|GetLayerPaletteEntries: FnPtr::new(metaloadfn("wglGetLayerPaletteEntries", &[])),
  477|      0|GetPixelFormatAttribfvARB: FnPtr::new(metaloadfn("wglGetPixelFormatAttribfvARB", &[])),
  478|      0|GetPixelFormatAttribivARB: FnPtr::new(metaloadfn("wglGetPixelFormatAttribivARB", &[])),
  479|      0|GetProcAddress: FnPtr::new(metaloadfn("wglGetProcAddress", &[])),
  480|      0|GetSwapIntervalEXT: FnPtr::new(metaloadfn("wglGetSwapIntervalEXT", &[])),
  481|      0|MakeCurrent: FnPtr::new(metaloadfn("wglMakeCurrent", &[])),
  482|      0|RealizeLayerPalette: FnPtr::new(metaloadfn("wglRealizeLayerPalette", &[])),
  483|      0|SetLayerPaletteEntries: FnPtr::new(metaloadfn("wglSetLayerPaletteEntries", &[])),
  484|      0|ShareLists: FnPtr::new(metaloadfn("wglShareLists", &[])),
  485|      0|SwapIntervalEXT: FnPtr::new(metaloadfn("wglSwapIntervalEXT", &[])),
  486|      0|SwapLayerBuffers: FnPtr::new(metaloadfn("wglSwapLayerBuffers", &[])),
  487|      0|UseFontBitmaps: FnPtr::new(metaloadfn("wglUseFontBitmaps", &[])),
  488|      0|UseFontBitmapsA: FnPtr::new(metaloadfn("wglUseFontBitmapsA", &[])),
  489|      0|UseFontBitmapsW: FnPtr::new(metaloadfn("wglUseFontBitmapsW", &[])),
  490|      0|UseFontOutlines: FnPtr::new(metaloadfn("wglUseFontOutlines", &[])),
  491|      0|UseFontOutlinesA: FnPtr::new(metaloadfn("wglUseFontOutlinesA", &[])),
  492|      0|UseFontOutlinesW: FnPtr::new(metaloadfn("wglUseFontOutlinesW", &[])),
  493|      0|_priv: ()
  494|      0|}
  495|      0|        }
  496|       |#[allow(non_snake_case, unused_variables, dead_code)]
  497|      0|            #[inline] pub unsafe fn ChoosePixelFormatARB(&self, hdc: types::HDC, piAttribIList: *const __gl_imports::raw::c_int, pfAttribFList: *const types::FLOAT, nMaxFormats: types::UINT, piFormats: *mut __gl_imports::raw::c_int, nNumFormats: *mut types::UINT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, *const __gl_imports::raw::c_int, *const types::FLOAT, types::UINT, *mut __gl_imports::raw::c_int, *mut types::UINT) -> types::BOOL>(self.ChoosePixelFormatARB.f)(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats) }
  498|       |#[allow(non_snake_case, unused_variables, dead_code)]
  499|      0|            #[inline] pub unsafe fn CopyContext(&self, hglrcSrc: types::HGLRC, hglrcDst: types::HGLRC, mask: types::UINT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HGLRC, types::HGLRC, types::UINT) -> types::BOOL>(self.CopyContext.f)(hglrcSrc, hglrcDst, mask) }
  500|       |#[allow(non_snake_case, unused_variables, dead_code)]
  501|      0|            #[inline] pub unsafe fn CreateContext(&self, hDc: types::HDC) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC) -> types::HGLRC>(self.CreateContext.f)(hDc) }
  502|       |#[allow(non_snake_case, unused_variables, dead_code)]
  503|      0|            #[inline] pub unsafe fn CreateContextAttribsARB(&self, hDC: types::HDC, hShareContext: types::HGLRC, attribList: *const __gl_imports::raw::c_int) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::HGLRC, *const __gl_imports::raw::c_int) -> types::HGLRC>(self.CreateContextAttribsARB.f)(hDC, hShareContext, attribList) }
  504|       |#[allow(non_snake_case, unused_variables, dead_code)]
  505|      0|            #[inline] pub unsafe fn CreateLayerContext(&self, hDc: types::HDC, level: __gl_imports::raw::c_int) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int) -> types::HGLRC>(self.CreateLayerContext.f)(hDc, level) }
  506|       |#[allow(non_snake_case, unused_variables, dead_code)]
  507|      0|            #[inline] pub unsafe fn DeleteContext(&self, oldContext: types::HGLRC) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HGLRC) -> types::BOOL>(self.DeleteContext.f)(oldContext) }
  508|       |#[allow(non_snake_case, unused_variables, dead_code)]
  509|      0|            #[inline] pub unsafe fn DescribeLayerPlane(&self, hDc: types::HDC, pixelFormat: __gl_imports::raw::c_int, layerPlane: __gl_imports::raw::c_int, nBytes: types::UINT, plpd: *const types::LAYERPLANEDESCRIPTOR) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, types::UINT, *const types::LAYERPLANEDESCRIPTOR) -> types::BOOL>(self.DescribeLayerPlane.f)(hDc, pixelFormat, layerPlane, nBytes, plpd) }
  510|       |#[allow(non_snake_case, unused_variables, dead_code)]
  511|      0|            #[inline] pub unsafe fn GetCurrentContext(&self, ) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::HGLRC>(self.GetCurrentContext.f)() }
  512|       |#[allow(non_snake_case, unused_variables, dead_code)]
  513|      0|            #[inline] pub unsafe fn GetCurrentDC(&self, ) -> types::HDC { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::HDC>(self.GetCurrentDC.f)() }
  514|       |#[allow(non_snake_case, unused_variables, dead_code)]
  515|      0|            #[inline] pub unsafe fn GetExtensionsStringARB(&self, hdc: types::HDC) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC) -> *const __gl_imports::raw::c_char>(self.GetExtensionsStringARB.f)(hdc) }
  516|       |#[allow(non_snake_case, unused_variables, dead_code)]
  517|      0|            #[inline] pub unsafe fn GetExtensionsStringEXT(&self, ) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn() -> *const __gl_imports::raw::c_char>(self.GetExtensionsStringEXT.f)() }
  518|       |#[allow(non_snake_case, unused_variables, dead_code)]
  519|      0|            #[inline] pub unsafe fn GetLayerPaletteEntries(&self, hdc: types::HDC, iLayerPlane: __gl_imports::raw::c_int, iStart: __gl_imports::raw::c_int, cEntries: __gl_imports::raw::c_int, pcr: *const types::COLORREF) -> __gl_imports::raw::c_int { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, __gl_imports::raw::c_int, *const types::COLORREF) -> __gl_imports::raw::c_int>(self.GetLayerPaletteEntries.f)(hdc, iLayerPlane, iStart, cEntries, pcr) }
  520|       |#[allow(non_snake_case, unused_variables, dead_code)]
  521|      0|            #[inline] pub unsafe fn GetPixelFormatAttribfvARB(&self, hdc: types::HDC, iPixelFormat: __gl_imports::raw::c_int, iLayerPlane: __gl_imports::raw::c_int, nAttributes: types::UINT, piAttributes: *const __gl_imports::raw::c_int, pfValues: *mut types::FLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, types::UINT, *const __gl_imports::raw::c_int, *mut types::FLOAT) -> types::BOOL>(self.GetPixelFormatAttribfvARB.f)(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues) }
  522|       |#[allow(non_snake_case, unused_variables, dead_code)]
  523|      0|            #[inline] pub unsafe fn GetPixelFormatAttribivARB(&self, hdc: types::HDC, iPixelFormat: __gl_imports::raw::c_int, iLayerPlane: __gl_imports::raw::c_int, nAttributes: types::UINT, piAttributes: *const __gl_imports::raw::c_int, piValues: *mut __gl_imports::raw::c_int) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, types::UINT, *const __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -> types::BOOL>(self.GetPixelFormatAttribivARB.f)(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues) }
  524|       |#[allow(non_snake_case, unused_variables, dead_code)]
  525|      0|            #[inline] pub unsafe fn GetProcAddress(&self, lpszProc: types::LPCSTR) -> types::PROC { __gl_imports::mem::transmute::<_, extern "system" fn(types::LPCSTR) -> types::PROC>(self.GetProcAddress.f)(lpszProc) }
  526|       |#[allow(non_snake_case, unused_variables, dead_code)]
  527|      0|            #[inline] pub unsafe fn GetSwapIntervalEXT(&self, ) -> __gl_imports::raw::c_int { __gl_imports::mem::transmute::<_, extern "system" fn() -> __gl_imports::raw::c_int>(self.GetSwapIntervalEXT.f)() }
  528|       |#[allow(non_snake_case, unused_variables, dead_code)]
  529|      0|            #[inline] pub unsafe fn MakeCurrent(&self, hDc: types::HDC, newContext: types::HGLRC) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::HGLRC) -> types::BOOL>(self.MakeCurrent.f)(hDc, newContext) }
  530|       |#[allow(non_snake_case, unused_variables, dead_code)]
  531|      0|            #[inline] pub unsafe fn RealizeLayerPalette(&self, hdc: types::HDC, iLayerPlane: __gl_imports::raw::c_int, bRealize: types::BOOL) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, types::BOOL) -> types::BOOL>(self.RealizeLayerPalette.f)(hdc, iLayerPlane, bRealize) }
  532|       |#[allow(non_snake_case, unused_variables, dead_code)]
  533|      0|            #[inline] pub unsafe fn SetLayerPaletteEntries(&self, hdc: types::HDC, iLayerPlane: __gl_imports::raw::c_int, iStart: __gl_imports::raw::c_int, cEntries: __gl_imports::raw::c_int, pcr: *const types::COLORREF) -> __gl_imports::raw::c_int { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, __gl_imports::raw::c_int, *const types::COLORREF) -> __gl_imports::raw::c_int>(self.SetLayerPaletteEntries.f)(hdc, iLayerPlane, iStart, cEntries, pcr) }
  534|       |#[allow(non_snake_case, unused_variables, dead_code)]
  535|      0|            #[inline] pub unsafe fn ShareLists(&self, hrcSrvShare: types::HGLRC, hrcSrvSource: types::HGLRC) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HGLRC, types::HGLRC) -> types::BOOL>(self.ShareLists.f)(hrcSrvShare, hrcSrvSource) }
  536|       |#[allow(non_snake_case, unused_variables, dead_code)]
  537|      0|            #[inline] pub unsafe fn SwapIntervalEXT(&self, interval: __gl_imports::raw::c_int) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(__gl_imports::raw::c_int) -> types::BOOL>(self.SwapIntervalEXT.f)(interval) }
  538|       |#[allow(non_snake_case, unused_variables, dead_code)]
  539|      0|            #[inline] pub unsafe fn SwapLayerBuffers(&self, hdc: types::HDC, fuFlags: types::UINT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::UINT) -> types::BOOL>(self.SwapLayerBuffers.f)(hdc, fuFlags) }
  540|       |#[allow(non_snake_case, unused_variables, dead_code)]
  541|      0|            #[inline] pub unsafe fn UseFontBitmaps(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD) -> types::BOOL>(self.UseFontBitmaps.f)(hDC, first, count, listBase) }
  542|       |#[allow(non_snake_case, unused_variables, dead_code)]
  543|      0|            #[inline] pub unsafe fn UseFontBitmapsA(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD) -> types::BOOL>(self.UseFontBitmapsA.f)(hDC, first, count, listBase) }
  544|       |#[allow(non_snake_case, unused_variables, dead_code)]
  545|      0|            #[inline] pub unsafe fn UseFontBitmapsW(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD) -> types::BOOL>(self.UseFontBitmapsW.f)(hDC, first, count, listBase) }
  546|       |#[allow(non_snake_case, unused_variables, dead_code)]
  547|      0|            #[inline] pub unsafe fn UseFontOutlines(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD, deviation: types::FLOAT, extrusion: types::FLOAT, format: __gl_imports::raw::c_int, lpgmf: types::LPGLYPHMETRICSFLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD, types::FLOAT, types::FLOAT, __gl_imports::raw::c_int, types::LPGLYPHMETRICSFLOAT) -> types::BOOL>(self.UseFontOutlines.f)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf) }
  548|       |#[allow(non_snake_case, unused_variables, dead_code)]
  549|      0|            #[inline] pub unsafe fn UseFontOutlinesA(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD, deviation: types::FLOAT, extrusion: types::FLOAT, format: __gl_imports::raw::c_int, lpgmf: types::LPGLYPHMETRICSFLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD, types::FLOAT, types::FLOAT, __gl_imports::raw::c_int, types::LPGLYPHMETRICSFLOAT) -> types::BOOL>(self.UseFontOutlinesA.f)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf) }
  550|       |#[allow(non_snake_case, unused_variables, dead_code)]
  551|      0|            #[inline] pub unsafe fn UseFontOutlinesW(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD, deviation: types::FLOAT, extrusion: types::FLOAT, format: __gl_imports::raw::c_int, lpgmf: types::LPGLYPHMETRICSFLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD, types::FLOAT, types::FLOAT, __gl_imports::raw::c_int, types::LPGLYPHMETRICSFLOAT) -> types::BOOL>(self.UseFontOutlinesW.f)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf) }
  552|       |}
  553|       |
  554|       |        unsafe impl __gl_imports::Send for Wgl {}
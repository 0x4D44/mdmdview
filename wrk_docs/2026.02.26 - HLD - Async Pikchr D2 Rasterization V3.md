# HLD: Async Pikchr & D2 Rasterization (V3)

**Date**: 2026-02-26
**Status**: Draft
**Scope**: `pikchr_renderer.rs`, `d2_renderer.rs` (primary); `markdown_renderer.rs` (minor call-site changes)
**Related**: `2026.02.25 - HLD - Mermaid Resize Debounce V3.md` (established the debounce pattern)
**V2 changes**: Fixed 6 issues found during V1 review (see [Review Notes V1 → V2](#review-notes-v1--v2) at end)
**V3 changes**: Fixed 1 critical issue found during V2 review (see [Review Notes V2 → V3](#review-notes-v2--v3) at end)

---

## Problem

Resizing the application window while Pikchr or D2 diagrams are visible causes noticeable jank — a "grainy" feel compared to the buttery smooth resize seen without diagrams.

### Root Cause

Pikchr and D2 renderers perform **synchronous SVG rasterization on the main UI thread**. The usvg/resvg/tiny-skia pipeline takes 35–195ms per diagram depending on complexity. With a typical test document containing 6 Pikchr + 6 D2 diagrams, the total main-thread rasterization cost per width change is ~935ms.

The current mitigations (trailing-edge debounce + per-frame rate-limiting) reduced the problem from "unusable" to "grainy" by:
- Suppressing rasterization during active resize (150ms cooldown)
- Limiting to 1 diagram rasterization per frame after debounce expires

But even with rate-limiting, one 35–195ms synchronous rasterize per frame causes visible frame drops (60fps target = 16ms budget).

### What the User Sees

1. Resize without diagrams: silky smooth
2. Resize with diagrams: perceptibly jerky/grainy during the re-render phase after debounce expires
3. Each diagram updates one per frame over ~360ms, with a visible hitch each time

### Comparison with Mermaid

The Mermaid renderer already uses background worker threads for the heavy lifting (QuickJS execution + SVG rasterization). The main thread only handles the cheap GPU upload (~0.1–1ms). This is why Mermaid diagrams don't cause the same jank — and it's the architecture Pikchr and D2 should adopt.

---

## Current Architecture

### Pikchr Render Pipeline (Synchronous)

```
render_block() — main thread, every frame per visible diagram
│
├─ 1. Error cache check ─────────────────── O(1), cheap
├─ 2. Compute texture_key ────────────────── O(1), cheap
├─ 3. Texture cache check ───────────────── O(1), cheap → RETURN if hit
├─ 3b. Debounce gate ────────────────────── O(1), cheap → RETURN if active
├─ 4. SVG cache check / render_pikchr_to_svg ── 0–2ms (C FFI call)
└─ 5. rasterize_and_upload() ────────────── 35–88ms ← BOTTLENECK
    ├─ inject_svg_font_family() ─── string manipulation
    ├─ usvg::Tree::from_data() ──── SVG parsing
    ├─ resvg::render() ─────────── rasterization to RGBA
    └─ ctx.load_texture() ──────── GPU upload (~0.1ms)
```

### D2 Render Pipeline (Synchronous)

```
render_block() — main thread, every frame per visible diagram
│
├─ 1. Error cache check ─────────────────── O(1), cheap
├─ 2. Compute texture_key ────────────────── O(1), cheap
├─ 3. Texture cache check ───────────────── O(1), cheap → RETURN if hit
├─ 3b. Debounce gate ────────────────────── O(1), cheap → RETURN if active
├─ 4. SVG cache check / render_d2_to_svg() ── 2–20ms (Rust D2 compiler)
└─ 5. rasterize_and_upload() ────────────── 19–195ms ← BOTTLENECK
    ├─ usvg::Tree::from_data() ──── SVG parsing
    ├─ resvg::render() ─────────── rasterization to RGBA
    └─ ctx.load_texture() ──────── GPU upload (~0.1ms)
```

### What Can Move Off-Thread

| Step | Duration | Thread-safe? | Move to worker? |
|------|----------|-------------|-----------------|
| Pikchr C call (`pikchr()`) | 0–2ms | Yes — reentrant, no global state | Yes |
| D2 Rust render | 2–20ms | Yes — pure Rust, no global state | Yes |
| `inject_svg_font_family` | <0.1ms | Yes — pure string manipulation | Yes |
| `usvg::Tree::from_data()` | 5–30ms | Yes — fontdb is `Arc<Send+Sync>` | Yes |
| `resvg::render()` | 10–150ms | Yes — no global state | Yes |
| `ctx.load_texture()` | 0.1–1ms | See note below | **No** — main thread only |

**Note on `egui::Context`**: `egui::Context` is `Send + Sync` (it wraps `Arc<RwLock<...>>`). However, `ctx.load_texture()` feeds into the rendering backend (glow/OpenGL), which requires the GL context to be current on the calling thread. Since the GL context is bound to the main thread, texture uploads must happen there.

**Conclusion**: Everything except the final GPU upload can run on a background thread. The GPU upload is ~0.1–1ms — well within the 16ms frame budget even for 12 diagrams.

---

## Proposed Architecture

### Overview

Each renderer gets **one dedicated worker thread** that handles the full source→SVG→RGBA pipeline. The main thread enqueues jobs and polls for completed RGBA results, uploading them to the GPU.

```
MAIN THREAD                           WORKER THREAD
───────────                           ─────────────
begin_frame(ctx)                      loop {
  └─ poll_results(ctx)                  job = rx.recv()
       ├─ try_recv loop                 svg = render_source(code)
       ├─ cache SVG/errors              rgba = rasterize(svg)
       ├─ stale check                   tx.try_send(result) ──►
       ├─ ctx.load_texture()          }
       └─ request_repaint if pending

render_block(ui)
  ├─ cache checks
  ├─ debounce gate
  ├─ pending check
  ├─ enqueue job ──── tx.try_send() ─►
  └─ show stale/placeholder
```

### Thread Safety Analysis

**Pikchr C library** (`pikchr::Pikchr::render`):
- Calls the C `pikchr()` function which uses only stack/heap allocation — no global mutable state
- The function is documented as reentrant
- The returned `Pikchr` struct holds a raw `*const c_char` (thus `!Send`), but we immediately call `.to_string()` to get a `String` (which is `Send`)
- The `Pikchr` value is created and dropped entirely within the worker thread — never crosses a thread boundary
- **Safe to call from worker thread**

**D2 Rust crate** (`mdmdview_d2::render_d2_to_svg`):
- Pure Rust implementation, no `unsafe`, no global state
- Input: `&str` code + `&RenderOptions`; Output: `Result<RenderResult, Error>`
- All types are `Send` by construction
- **Safe to call from worker thread**

**usvg/resvg/tiny-skia**:
- Already used on worker threads by the Mermaid renderer
- `fontdb::Database` wrapped in `Arc` — `Send + Sync`
- `usvg::Tree`, `tiny_skia::Pixmap` — owned types, no shared state
- **Safe to call from worker thread**

---

## Detailed Design

### New Types

```rust
/// Job sent from main thread to worker.
struct RasterJob {
    /// Hash of the source code (for cache keying).
    code_hash: u64,
    /// Composite texture cache key (includes width, scale, theme).
    texture_key: String,
    /// Source code to render. None if SVG is provided directly.
    code: Option<String>,
    /// Pre-cached SVG string. If present, skip source→SVG step.
    svg: Option<String>,
    /// Dark mode flag (affects source→SVG for both Pikchr and D2).
    dark_mode: bool,
    /// Width bucket (32px quantized) for rasterization scaling.
    width_bucket: u32,
    /// Scale bucket (integer %, e.g., 100 = 1.0x zoom).
    scale_bucket: u32,
}

/// Result sent from worker back to main thread.
struct RasterResult {
    /// Hash of the source code (for cache keying).
    code_hash: u64,
    /// Composite texture cache key.
    texture_key: String,
    /// Dark mode flag (copied from job, for SVG cache key computation).
    dark_mode: bool,
    /// SVG string (always set on success, for caching).
    svg: Option<String>,
    /// RGBA pixel data from rasterization.
    rgba: Option<Vec<u8>>,
    /// Raster dimensions in actual pixels (for GPU upload).
    raster_size: Option<[usize; 2]>,
    /// Display dimensions in logical pixels (for UI layout).
    display_size: Option<[u32; 2]>,
    /// Error message (set on failure, mutually exclusive with rgba).
    error: Option<String>,
}
```

### Channel Configuration

```rust
// Type aliases for readability
type JobSender = crossbeam_channel::Sender<RasterJob>;
type JobReceiver = crossbeam_channel::Receiver<RasterJob>;
type ResultSender = crossbeam_channel::Sender<RasterResult>;
type ResultReceiver = crossbeam_channel::Receiver<RasterResult>;

// Bounded channels — capacity 8 is sufficient for 1 worker + debounce
const CHANNEL_CAPACITY: usize = 8;
let (job_tx, job_rx) = crossbeam_channel::bounded(CHANNEL_CAPACITY);
let (result_tx, result_rx) = crossbeam_channel::bounded(CHANNEL_CAPACITY);
```

**Why capacity 8**: With debounce suppressing enqueue during resize, at most one job per diagram is enqueued after the debounce expires. A document with ~6–8 diagrams of a given type fits within 8 slots. The bounded channel provides natural backpressure if the worker falls behind.

### Struct Changes

Both `PikchrRenderer` and `D2Renderer` gain the same new fields:

```rust
pub(crate) struct PikchrRenderer {  // (and D2Renderer)
    // --- Existing (unchanged) ---
    fontdb: Arc<usvg::fontdb::Database>,
    textures: RefCell<LruCache<String, XxxTextureEntry>>,
    svg_cache: RefCell<LruCache<u128, String>>,
    errors: RefCell<LruCache<u64, String>>,
    debounce: RefCell<HashMap<u64, DiagramDebounce>>,
    latest_texture_key: RefCell<HashMap<u64, String>>,

    // --- New ---
    /// Job sender. Wrapped in Option so Drop can close the channel
    /// before joining the worker thread (same pattern as Mermaid).
    job_tx: Option<JobSender>,
    /// Result receiver. Polled each frame in poll_results().
    result_rx: ResultReceiver,
    /// Worker thread handle. Joined on drop for clean shutdown.
    worker_handle: Option<std::thread::JoinHandle<()>>,
    /// Set of code_hashes with in-flight jobs. Keyed by code_hash (not
    /// texture_key) to prevent redundant enqueues when the width changes
    /// while a job is already pending for the same diagram.
    pending: RefCell<HashSet<u64>>,
    /// Tracks the currently desired width bucket per diagram (for stale discard).
    wanted_bucket: RefCell<HashMap<u64, u32>>,

    // --- Removed ---
    // rasterized_this_frame: Cell<bool>,  ← no longer needed
}
```

### Constructor Changes

```rust
impl PikchrRenderer {  // (and D2Renderer)
    pub(crate) fn new() -> Self {
        let mut db = usvg::fontdb::Database::new();
        db.load_system_fonts();
        let fontdb = Arc::new(db);

        let (job_tx, job_rx) = crossbeam_channel::bounded(CHANNEL_CAPACITY);
        let (result_tx, result_rx) = crossbeam_channel::bounded(CHANNEL_CAPACITY);

        // Clone fontdb for the worker thread
        let worker_fontdb = Arc::clone(&fontdb);
        let worker_handle = std::thread::Builder::new()
            .name("pikchr-raster".into())  // or "d2-raster"
            .spawn(move || {
                Self::worker_loop(worker_fontdb, job_rx, result_tx);
            })
            .expect("failed to spawn pikchr raster worker");

        Self {
            fontdb,
            textures: RefCell::new(LruCache::new(TEXTURE_CACHE_CAPACITY)),
            svg_cache: RefCell::new(LruCache::new(SVG_CACHE_CAPACITY)),
            errors: RefCell::new(LruCache::new(ERROR_CACHE_CAPACITY)),
            debounce: RefCell::new(HashMap::new()),
            latest_texture_key: RefCell::new(HashMap::new()),
            job_tx: Some(job_tx),
            result_rx,
            worker_handle: Some(worker_handle),
            pending: RefCell::new(HashSet::new()),
            wanted_bucket: RefCell::new(HashMap::new()),
        }
    }
}
```

### Worker Loop

```rust
fn worker_loop(
    fontdb: Arc<usvg::fontdb::Database>,
    job_rx: JobReceiver,
    result_tx: ResultSender,
) {
    while let Ok(job) = job_rx.recv() {
        let result = Self::process_job(&fontdb, job);
        // Use try_send to avoid blocking if result channel is full.
        // This prevents deadlock during shutdown: if Drop joins workers
        // while they're blocked on send (because result_rx isn't being
        // polled), we'd hang forever. Dropping results is acceptable —
        // the main thread still has the code_hash in the pending set, so
        // render_block will show the stale texture or placeholder and the
        // pending entry will be leaked (harmless, cleared on next
        // release_gpu_textures or app restart). Same pattern as Mermaid
        // (mermaid_renderer.rs line 1264-1269).
        let _ = result_tx.try_send(result);
    }
    // job_rx disconnected (main thread dropped job_tx) — exit
}

fn process_job(fontdb: &Arc<usvg::fontdb::Database>, job: RasterJob) -> RasterResult {
    // Step 1: Get SVG (from cache or render fresh)
    let svg = match job.svg {
        Some(cached_svg) => Ok(cached_svg),
        None => {
            let code = job.code.as_deref().unwrap_or("");
            Self::render_source_to_svg(code, job.dark_mode)
        }
    };

    let svg = match svg {
        Ok(svg) => svg,
        Err(err) => {
            return RasterResult {
                code_hash: job.code_hash,
                texture_key: job.texture_key,
                dark_mode: job.dark_mode,
                svg: None,
                rgba: None,
                raster_size: None,
                display_size: None,
                error: Some(err),
            };
        }
    };

    // Step 2: Rasterize SVG to RGBA
    match Self::rasterize_svg(fontdb, &svg, job.width_bucket, job.scale_bucket) {
        Ok(output) => RasterResult {
            code_hash: job.code_hash,
            texture_key: job.texture_key,
            dark_mode: job.dark_mode,
            svg: Some(svg),
            rgba: Some(output.rgba),
            raster_size: Some(output.raster_size),
            display_size: Some(output.display_size),
            error: None,
        },
        Err(err) => RasterResult {
            code_hash: job.code_hash,
            texture_key: job.texture_key,
            dark_mode: job.dark_mode,
            svg: Some(svg),  // SVG succeeded — cache it even if rasterize failed
            rgba: None,
            raster_size: None,
            display_size: None,
            error: Some(err),
        },
    }
}
```

### Rasterize Function (Runs on Worker Thread)

Extracted from the current `rasterize_and_upload`, minus the GPU upload:

```rust
struct RasterOutput {
    rgba: Vec<u8>,
    raster_size: [usize; 2],
    display_size: [u32; 2],
}

fn rasterize_svg(
    fontdb: &Arc<usvg::fontdb::Database>,
    svg: &str,
    width_bucket: u32,
    scale_bucket: u32,
) -> Result<RasterOutput, String> {
    // [For Pikchr only] Inject font-family declaration
    let svg = Self::inject_svg_font_family(svg);  // Pikchr only; D2 omits this

    // Parse SVG
    let opt = usvg::Options {
        fontdb: Arc::clone(fontdb),
        ..Default::default()
    };
    let tree = usvg::Tree::from_data(svg.as_bytes(), &opt)
        .map_err(|e| format!("SVG parse error: {}", e))?;

    // Compute dimensions (same logic as current rasterize_and_upload)
    let size = tree.size().to_int_size();
    let (w, h) = (size.width().max(1), size.height().max(1));
    let base_scale = scale_bucket as f32 / 100.0;
    let width_scale = if width_bucket > 0 {
        width_bucket as f32 / w.max(1) as f32
    } else {
        base_scale
    };
    let scale = base_scale.min(width_scale).clamp(0.1, 4.0);

    let display_w = (w as f32 * scale).round().max(1.0) as u32;
    let display_h = (h as f32 * scale).round().max(1.0) as u32;

    let raster_scale = scale * SUPERSAMPLE;
    let mut raster_w = (w as f32 * raster_scale).round().max(1.0) as u32;
    let mut raster_h = (h as f32 * raster_scale).round().max(1.0) as u32;

    // Clamp to MAX_RASTER_SIDE
    if raster_w > MAX_RASTER_SIDE || raster_h > MAX_RASTER_SIDE {
        let clamp = (MAX_RASTER_SIDE as f32 / raster_w as f32)
            .min(MAX_RASTER_SIDE as f32 / raster_h as f32);
        raster_w = (raster_w as f32 * clamp).round().max(1.0) as u32;
        raster_h = (raster_h as f32 * clamp).round().max(1.0) as u32;
    }

    // Rasterize
    let mut pixmap = tiny_skia::Pixmap::new(raster_w, raster_h)
        .ok_or_else(|| "Pixmap allocation failed".to_string())?;
    let transform = tiny_skia::Transform::from_scale(raster_scale, raster_scale);
    let mut pmut = pixmap.as_mut();
    resvg::render(&tree, transform, &mut pmut);

    Ok(RasterOutput {
        rgba: pixmap.data().to_vec(),
        raster_size: [raster_w as usize, raster_h as usize],
        display_size: [display_w, display_h],
    })
}
```

### poll_results (Main Thread)

Called once per frame from `begin_frame`, NOT from `render_block`. This is critical:
`render_block` only runs for visible diagrams, so if diagrams scroll off-screen while jobs
are in-flight, results would pile up in the bounded channel and eventually block the worker
thread (deadlock). Polling from `begin_frame` ensures results are always drained.

```rust
fn poll_results(&self, ctx: &egui::Context) -> bool {
    let mut any_processed = false;

    while let Ok(result) = self.result_rx.try_recv() {
        any_processed = true;

        // Remove from pending set
        self.pending.borrow_mut().remove(&result.code_hash);

        // Always cache SVG (content-addressed, width-independent)
        if let Some(ref svg) = result.svg {
            let sk = svg_cache_key(result.code_hash, result.dark_mode);
            self.svg_cache.borrow_mut().insert(sk, svg.clone());
        }

        // Always cache errors (prevents infinite retry loops)
        if let Some(ref err) = result.error {
            self.errors.borrow_mut().insert(result.code_hash, err.clone());
            continue;  // No RGBA to upload
        }

        // Stale result check: skip GPU upload if width bucket changed since enqueue
        if self.is_stale_result(&result.texture_key, result.code_hash) {
            continue;
        }

        // Upload RGBA to GPU texture
        if let (Some(rgba), Some(raster_size), Some(display_size)) =
            (result.rgba, result.raster_size, result.display_size)
        {
            let image = egui::ColorImage::from_rgba_unmultiplied(
                raster_size,
                &rgba,
            );
            let texture = ctx.load_texture(
                result.texture_key.clone(),
                image,
                egui::TextureOptions::LINEAR,
            );
            let entry = XxxTextureEntry { texture, display_size };
            self.textures.borrow_mut().insert(result.texture_key.clone(), entry);
            self.latest_texture_key
                .borrow_mut()
                .insert(result.code_hash, result.texture_key.clone());
            // Update debounce state
            if let Some(width_bucket) = Self::parse_width_from_texture_key(&result.texture_key) {
                self.debounce.borrow_mut().insert(
                    result.code_hash,
                    DiagramDebounce {
                        last_rasterized_bucket: width_bucket,
                        last_seen_bucket: width_bucket,
                        bucket_changed_at: None,
                    },
                );
            }
        }
    }

    if any_processed {
        ctx.request_repaint();
    }
    any_processed
}
```

### Updated begin_frame

```rust
pub(crate) fn begin_frame(&self, ctx: &egui::Context) {
    // Drain completed results from worker thread. Must happen here (not in
    // render_block) because render_block only runs for visible diagrams —
    // off-screen results would pile up and block the worker.
    self.poll_results(ctx);

    // If jobs are still in-flight, ensure we get another frame to poll again.
    if self.has_pending() {
        ctx.request_repaint_after(std::time::Duration::from_millis(16));
    }
}
```

This replaces the no-op begin_frame. The `request_repaint_after(16ms)` ensures egui keeps
generating frames while jobs are in-flight, even if no user input is occurring (egui is
event-driven and may otherwise idle).

### Updated render_block Flow

```rust
pub(crate) fn render_block(
    &self,
    ui: &mut egui::Ui,
    code: &str,
    ui_scale: f32,
    code_font_size: f32,
) -> bool {
    let code_hash = hash_str(code);
    let dark_mode = ui.visuals().dark_mode;
    let svg_key = svg_cache_key(code_hash, dark_mode);

    // 1. Check error cache
    let cached_err = self.errors.borrow_mut().get(&code_hash);
    if let Some(err) = cached_err {
        self.render_error_block(ui, &err, code, code_font_size);
        return true;
    }

    // 2. Compute texture key
    let available_width = ui.available_width().max(1.0);
    let width_bucket = bucket_width(available_width);
    let scale_bucket = bucket_scale(ui_scale);
    let texture_key = format!("pikchr:{:016x}:w{}:s{}:dm{}", /*...*/);

    // 2b. Update wanted_bucket (for stale discard in poll_results)
    self.wanted_bucket.borrow_mut().insert(code_hash, width_bucket);

    // 3. Check texture cache
    if let Some(entry) = self.textures.borrow_mut().get(&texture_key) {
        Self::render_texture(ui, &entry, available_width);
        return true;
    }

    // 4. Debounce gate (unchanged from current implementation)
    //    During active resize: show stale texture, suppress enqueue
    //    After cooldown: fall through to enqueue
    let db_entry = self.debounce.borrow().get(&code_hash)
        .map(|d| (d.last_rasterized_bucket, d.last_seen_bucket, d.bucket_changed_at));
    if let Some((last_rasterized, last_seen, _changed_at)) = db_entry {
        if width_bucket != last_rasterized {
            // Width changed — apply trailing-edge debounce
            if width_bucket != last_seen {
                if let Some(d) = self.debounce.borrow_mut().get_mut(&code_hash) {
                    d.last_seen_bucket = width_bucket;
                    d.bucket_changed_at = Some(Instant::now());
                }
            }
            let changed_at = self.debounce.borrow()
                .get(&code_hash)
                .and_then(|d| d.bucket_changed_at)
                .unwrap_or_else(Instant::now);
            let elapsed = changed_at.elapsed();
            let debounce_dur = Duration::from_millis(RESIZE_DEBOUNCE_MS);
            if elapsed < debounce_dur {
                // Still in cooldown — show stale texture
                if let Some(stale_key) = self.latest_texture_key.borrow().get(&code_hash).cloned() {
                    if let Some(entry) = self.textures.borrow_mut().get(&stale_key) {
                        Self::render_texture(ui, &entry, available_width);
                        ui.ctx().request_repaint_after(debounce_dur - elapsed);
                        return true;
                    }
                }
                // No stale texture — fall through to enqueue
            }
            // Debounce expired — fall through to enqueue
        }
        // width == last_rasterized: texture was evicted — fall through to enqueue
    }
    // No debounce entry: first render — fall through to enqueue

    // 5. Check if already pending for this diagram (by code_hash, not texture_key,
    //    to prevent redundant enqueues when the width changes mid-flight)
    if self.pending.borrow().contains(&code_hash) {
        return self.show_stale_or_placeholder(ui, code_hash, available_width);
    }

    // 6. Enqueue job
    let cached_svg = self.svg_cache.borrow_mut().get(&svg_key);
    let job = RasterJob {
        code_hash,
        texture_key: texture_key.clone(),
        code: if cached_svg.is_none() { Some(code.to_string()) } else { None },
        svg: cached_svg,
        dark_mode,
        width_bucket,
        scale_bucket,
    };

    match self.job_tx.as_ref().unwrap().try_send(job) {
        Ok(()) => {
            self.pending.borrow_mut().insert(code_hash);
        }
        Err(crossbeam_channel::TrySendError::Full(_)) => {
            // Queue full — will retry next frame
        }
        Err(crossbeam_channel::TrySendError::Disconnected(_)) => {
            // Worker died — show error
            self.errors.borrow_mut().insert(
                code_hash,
                "Raster worker unavailable".to_string(),
            );
            self.render_error_block(ui, "Raster worker unavailable", code, code_font_size);
            return true;
        }
    }

    // 7. Show stale texture or placeholder while waiting
    self.show_stale_or_placeholder(ui, code_hash, available_width)
}
```

### Placeholder Rendering

```rust
/// Show a stale texture (from a previous width) scaled to fit, or a
/// minimal-height placeholder if no stale texture is available.
/// Returns true (block always produces UI output).
fn show_stale_or_placeholder(
    &self,
    ui: &mut egui::Ui,
    code_hash: u64,
    available_width: f32,
) -> bool {
    // Try stale texture first (gives a good visual approximation)
    if let Some(stale_key) = self.latest_texture_key.borrow().get(&code_hash).cloned() {
        if let Some(entry) = self.textures.borrow_mut().get(&stale_key) {
            Self::render_texture(ui, &entry, available_width);
            return true;
        }
    }
    // No stale texture — show minimal placeholder (first render)
    // Use a small fixed height to reduce layout shift when the real texture arrives.
    let placeholder_height = 60.0;
    let (rect, _) = ui.allocate_exact_size(
        egui::vec2(available_width, placeholder_height),
        egui::Sense::hover(),
    );
    ui.painter().text(
        rect.center(),
        egui::Align2::CENTER_CENTER,
        "Rendering...",
        egui::FontId::proportional(12.0),
        ui.visuals().weak_text_color(),
    );
    true
}
```

### Shutdown (Drop)

```rust
impl Drop for PikchrRenderer {  // (and D2Renderer)
    fn drop(&mut self) {
        // Close job channel — worker will see Disconnected on recv() and exit.
        // The worker uses try_send for results (never blocks), so it will
        // drain remaining jobs and exit promptly once job_rx disconnects.
        self.job_tx.take();
        // Join worker thread for clean shutdown
        if let Some(handle) = self.worker_handle.take() {
            let _ = handle.join();
        }
    }
}
```

### Updated has_pending

```rust
pub(crate) fn has_pending(&self) -> bool {
    !self.pending.borrow().is_empty()
}
```

### Updated release_gpu_textures

```rust
pub(crate) fn release_gpu_textures(&self) {
    self.textures.borrow_mut().clear();
    self.debounce.borrow_mut().clear();
    self.latest_texture_key.borrow_mut().clear();
    self.wanted_bucket.borrow_mut().clear();
    self.pending.borrow_mut().clear();
    // In-flight results will be detected as stale (wanted_bucket is empty)
    // and discarded in poll_results. Clearing pending allows render_block
    // to re-enqueue jobs on restore, and prevents leaked pending entries
    // from try_send(Full) drops (see "Worker result dropped" edge case).
}
```

### Stale Result Detection

```rust
fn parse_width_from_texture_key(key: &str) -> Option<u32> {
    let w_start = key.find(":w")? + 2;
    let w_end = key[w_start..].find(':')? + w_start;
    key[w_start..w_end].parse().ok()
}

fn is_stale_result(&self, texture_key: &str, code_hash: u64) -> bool {
    let result_bucket = Self::parse_width_from_texture_key(texture_key);
    let wanted = self.wanted_bucket.borrow().get(&code_hash).copied();
    match (result_bucket, wanted) {
        (Some(rb), Some(wb)) => rb != wb,       // Width mismatch → stale
        (Some(_rb), None) => true,               // No wanted bucket (e.g. after
                                                 // release_gpu_textures) → stale
        _ => false,                              // Can't parse → assume fresh
    }
}
```

The `(Some, None)` case handles the scenario where `release_gpu_textures` clears `wanted_bucket` while a job is in-flight. Without this, the result would be uploaded to GPU only to be immediately discarded by the next `release_gpu_textures` call. On first render, `wanted_bucket` IS populated before the job completes (set in step 2b of `render_block`), so this doesn't affect normal startup.

---

## What Changes, What Stays, What Goes

| Component | Status | Notes |
|-----------|--------|-------|
| `DiagramDebounce` struct | **Stays** | Unchanged — debounce still suppresses enqueue during resize |
| `debounce` HashMap | **Stays** | Updated in `poll_results` instead of `render_block` |
| `latest_texture_key` HashMap | **Stays** | Updated in `poll_results` instead of `render_block` |
| `rasterized_this_frame` Cell | **Removed** | No longer needed — no synchronous rasterize on main thread |
| `rasterize_and_upload()` | **Split** | CPU work → `rasterize_svg()` (worker); GPU upload → `poll_results()` (main) |
| `render_block()` steps 1–3b | **Stays** | Cache checks + debounce gate unchanged |
| `render_block()` steps 4–5 | **Replaced** | Enqueue job instead of synchronous render+rasterize |
| `render_source_to_svg()` | **Stays** | Renamed from `render_pikchr_to_svg` / `render_d2_to_svg`; now called on worker |
| `render_texture()` | **Stays** | Called from cache hit path and `show_stale_or_placeholder` |
| `render_error_block()` | **Stays** | Called from error cache hit and Disconnected paths |
| `has_pending()` | **Changes** | Returns `!pending.is_empty()` instead of `false` |
| `begin_frame()` | **Changes** | Now takes `ctx: &egui::Context`, calls `poll_results`, requests repaint if pending |
| `release_gpu_textures()` | **Expands** | Also clears `wanted_bucket` and `pending` |
| Texture/SVG/error caches | **Stay** | Same types, same capacities |

---

## Call-Site Changes in markdown_renderer.rs

`begin_frame()` now takes a `ctx` parameter. The call site in `render_to_ui` changes from:

```rust
// Before
#[cfg(feature = "pikchr")]
self.pikchr.begin_frame();
#[cfg(feature = "d2")]
self.d2.begin_frame();
```

To:

```rust
// After
#[cfg(feature = "pikchr")]
self.pikchr.begin_frame(ui.ctx());
#[cfg(feature = "d2")]
self.d2.begin_frame(ui.ctx());
```

Mermaid's `begin_frame()` signature is unchanged (it does its own polling internally).

---

## Interaction with Debounce

The debounce gate and background rendering work together:

```
RESIZE STARTS          RESIZE ACTIVE           RESIZE STOPS
    │                      │                       │
    ▼                      ▼                       ▼
┌─────────┐  width     ┌──────────┐  150ms    ┌──────────┐  ~50ms   ┌──────────┐
│ stale   │  changes   │ stale    │  expires  │ enqueue  │  worker  │ upload   │
│ texture │ ─────────► │ texture  │ ────────► │ job      │ ───────► │ texture  │
│ shown   │  debounce  │ scaled   │           │ (async)  │          │ to GPU   │
│         │  resets    │ to fit   │           │          │          │          │
└─────────┘            └──────────┘           └──────────┘          └──────────┘
                                                  │
                                              main thread
                                              is FREE the
                                              whole time
```

1. **Resize starts**: Width bucket changes. Debounce activates, shows stale texture scaled to fit. No jobs enqueued.
2. **Resize continues**: Each new width bucket resets the debounce timer. Stale texture continues to display.
3. **Resize stops**: After 150ms of width stability, debounce expires. Job enqueued to worker thread.
4. **Worker processes**: Source→SVG→RGBA on background thread (~50–200ms). Main thread is completely free.
5. **Result arrives**: `poll_results()` (in next `begin_frame`) checks staleness, uploads RGBA to GPU (~0.1ms), updates caches.
6. **Display**: `render_block()` finds the texture in cache and displays it.

If the user resizes again before the worker finishes (step 4), `wanted_bucket` will have changed, so the result is detected as stale in step 5 — SVG is cached (cheap) but the expensive GPU upload is skipped. The pending check (step 5 of render_block) prevents redundant re-enqueue since it's keyed by code_hash.

---

## Edge Cases

### First render (no stale texture)

On first render, there is no stale texture to display during the worker processing time. The placeholder shows "Rendering..." text at a fixed height of 60px. Once the result arrives (~50–200ms), the real texture replaces it. `begin_frame` ensures continuous repainting via `request_repaint_after(16ms)` while pending.

### Worker queue full

If `try_send` returns `TrySendError::Full`, we skip the enqueue and show the stale texture or placeholder. The next frame will retry the enqueue. With a capacity of 8 and debounce limiting enqueue rate, this should be rare.

### Worker thread dies

If the worker panics (shouldn't happen — all error paths return `Result`), `try_send` returns `TrySendError::Disconnected`. We cache a permanent error message and display it. This is a non-recoverable error.

### Theme change

Theme changes produce new texture_keys (containing `:dm0`/`:dm1`) and new SVG cache keys (incorporating dark_mode). Stale entries are never matched — they sit in cache until LRU-evicted. No explicit cache clear is needed.

If a theme toggle happens while a job is in-flight, the result has SVG for the old theme. The SVG is cached under the old theme's key (harmless). The texture is uploaded under the old texture_key. The next `render_block` computes a new texture_key (different dm flag), misses the cache, and enqueues a new job for the correct theme. The old-theme texture sits unused until LRU-evicted. This wastes one GPU upload (~0.5ms) — acceptable for a rare event.

### Window minimize / restore

`release_gpu_textures()` clears textures, debounce, latest_texture_key, and wanted_bucket. In-flight jobs complete, but their results are detected as stale (wanted_bucket is empty, `is_stale_result` returns true for `(Some, None)`). SVG is still cached. On restore, `render_block()` encounters cache misses and enqueues fresh jobs. The SVG cache lets the worker skip source→SVG and go straight to rasterization.

### Zoom change

Scale bucket changes, producing a new texture_key. Cache miss triggers a new job. SVG cache hit means the worker only needs to rasterize (not re-render source→SVG). The stale check only compares width buckets, so an old-scale result arriving after zoom will be uploaded (width matches) — but the texture_key won't match what `render_block` looks up. The texture is uploaded but never displayed; the correct-scale job runs next. One wasted GPU upload (~0.5ms) — acceptable for a rare event.

### Diagrams scroll off-screen while jobs are in-flight

Because `poll_results` runs in `begin_frame` (not `render_block`), results are drained every frame regardless of which diagrams are visible. The worker thread is never blocked by a full result channel. When the user scrolls back, `render_block` finds the texture in cache and displays immediately.

### Worker result dropped (try_send Full)

If the worker's `try_send` fails because the result channel is full, the result is silently dropped. The main thread still has the `code_hash` in its `pending` set, so `render_block` will continue showing the stale texture or placeholder. The `pending` entry becomes a leaked entry — it will never be removed by `poll_results` since the result was dropped. This is harmless: the entry is cleared on `release_gpu_textures` (which clears `pending` would need to be added — see note below) or on app restart.

This is why `release_gpu_textures` clears `pending` in addition to the other caches (see [Updated release_gpu_textures](#updated-release_gpu_textures)). Clearing `pending` allows `render_block` to re-enqueue jobs on restore, and `wanted_bucket` being empty means any in-flight results are detected as stale and discarded.

---

## Performance Impact

### Before (synchronous)

| Event | Main thread blocked |
|-------|-------------------|
| Width bucket change | 35–195ms per diagram × N visible |
| Post-debounce re-render | ~50–195ms × 1 diagram/frame (rate-limited) |
| 12 diagrams post-debounce | ~12 frames × ~100ms avg = 1.2s of intermittent jank |

### After (async)

| Event | Main thread blocked |
|-------|-------------------|
| Width bucket change | 0ms (debounce shows stale texture) |
| Post-debounce re-render | 0ms (enqueue is O(1), ~1µs) |
| Result arrives | ~0.5ms per GPU upload × N completed |
| 12 diagrams post-debounce | ~12 × 0.5ms = 6ms total GPU upload (spread over ~1.2s of wall time) |

**Main thread improvement**: From 35–195ms per diagram (synchronous) to ~0.5ms per diagram (async GPU upload only). **~100x improvement** in main-thread frame budget impact.

**Wall-clock re-render time**: Unchanged (~50–200ms per diagram) but now fully off the main thread. With a single worker processing serially: 12 diagrams × ~100ms avg = ~1.2s total. Diagrams update one by one, but the UI remains smooth throughout.

---

## Files Changed

| File | Changes |
|------|---------|
| `src/pikchr_renderer.rs` | Worker thread, channels, `RasterJob`/`RasterResult` types, `poll_results`, split `rasterize_and_upload`, remove `rasterized_this_frame`, update `render_block`/`has_pending`/`begin_frame`/`release_gpu_textures`, add `Drop`, add `show_stale_or_placeholder`, add `is_stale_result`/`parse_width_from_texture_key`, update tests |
| `src/d2_renderer.rs` | Same changes as pikchr_renderer.rs (parallel implementation) |
| `src/markdown_renderer.rs` | Pass `ui.ctx()` to `pikchr.begin_frame()` and `d2.begin_frame()` |

---

## Testing Strategy

### Existing tests

All existing unit tests for both renderers must continue to pass. Tests that call `render_pikchr_to_svg` / `render_d2_to_svg` are unaffected (renamed to `render_source_to_svg` but same logic). No existing tests call `rasterize_and_upload` directly (it requires a live egui Context), so the split to `rasterize_svg` doesn't break any tests.

### New tests

1. **`test_worker_processes_job`** — Submit a job via channels, verify result arrives with RGBA data
2. **`test_worker_caches_svg_on_success`** — Submit job, poll result, verify SVG is in svg_cache
3. **`test_worker_caches_error`** — Submit job with invalid code, poll result, verify error is in errors cache
4. **`test_stale_result_skips_gpu_upload`** — Submit job, change wanted_bucket before polling, verify texture cache is NOT populated but SVG cache IS populated
5. **`test_stale_result_when_wanted_is_none`** — Clear wanted_bucket, poll result, verify GPU upload is skipped
6. **`test_pending_set_tracks_inflight`** — Verify pending set populated on enqueue, cleared on poll
7. **`test_has_pending_reflects_inflight`** — `has_pending()` returns true with jobs in flight, false after poll
8. **`test_debounce_suppresses_enqueue`** — Width change during cooldown does not enqueue
9. **`test_queue_full_does_not_block`** — Fill channel, verify try_send returns Full (not blocking)
10. **`test_release_gpu_clears_pending_and_wanted`** — Verify pending, wanted_bucket, and debounce cleared on release
11. **`test_parse_width_from_texture_key`** — Unit test for key parsing helper
12. **`test_shutdown_joins_worker`** — Drop renderer, verify no thread leak
13. **`test_pending_dedup_by_code_hash`** — Same code_hash pending, second enqueue is skipped
14. **`test_worker_try_send_full_does_not_block`** — Fill result channel, submit job, verify worker doesn't hang

### Manual verification

1. Open `test_stress.md` (6 Pikchr + 6 D2 diagrams)
2. Resize window — should be as smooth as resizing without diagrams
3. Diagrams update ~150ms after resize stops (debounce) + ~50–200ms (async render)
4. No "Rendering..." flash on subsequent resizes (stale texture shown during cooldown)
5. Theme toggle — all diagrams re-render correctly
6. Zoom in/out — immediate re-render (SVG cached, only rasterization needed)
7. Scroll diagrams off-screen during resize, scroll back — no freeze, textures rebuild

---

## Future Considerations

### Thread pool

If single-worker latency (~1.2s for 12 diagrams) is ever a concern, we can upgrade to a small thread pool (2–3 workers). The channel-based architecture supports this trivially — just spawn more workers reading from the same `job_rx`.

### Shared rasterization pool

Pikchr and D2 share the identical rasterization pipeline (usvg/resvg/tiny-skia). A shared thread pool could reduce total thread count. Not worth the coupling for now, but the `RasterJob`/`RasterResult` types are already pipeline-agnostic — only the source→SVG step differs.

### Priority scheduling

If the user scrolls to a different section, diagrams off-screen could be deprioritized. This would require a priority channel or cancellation mechanism. Not needed now — debounce already limits enqueue rate.

---

## Review Notes V1 → V2

### Issue 1 (Critical): Deadlock when diagrams scroll off-screen

**V1 bug**: `poll_results` was called from inside `render_block`. Since `render_block` only runs for visible diagrams, results for off-screen diagrams would pile up in the bounded result channel. Once full, the worker thread blocks on `result_tx.send()` — deadlock.

**V2 fix**: Moved `poll_results` to `begin_frame`, which runs once per frame regardless of which diagrams are visible. Removed the poll+re-check from `render_block`.

### Issue 2 (Critical): No repaint when jobs are pending

**V1 bug**: After enqueuing a job, nothing ensured egui would generate another frame to poll for results. egui is event-driven — without user input, it may idle indefinitely. Results would sit in the channel unpicked.

**V2 fix**: `begin_frame` now calls `ctx.request_repaint_after(16ms)` whenever `has_pending()` is true. This ensures continuous frame generation while jobs are in-flight.

### Issue 3 (Medium): Fragile dark_mode extraction from texture_key string

**V1 bug**: `poll_results` extracted dark_mode via `result.texture_key.ends_with(":dm1")` — fragile string parsing that would silently produce wrong SVG cache keys if the texture_key format ever changed.

**V2 fix**: Added `dark_mode: bool` field to `RasterResult`. Worker copies it from `RasterJob`.

### Issue 4 (Medium): Wrong claim about egui::Context thread safety

**V1 bug**: Stated `egui::Context` is `!Send`. It's actually `Send + Sync` (wraps `Arc<RwLock<...>>`). The real reason `ctx.load_texture()` must run on the main thread is that the underlying OpenGL context is thread-bound.

**V2 fix**: Corrected the "What Can Move Off-Thread" table and added a note explaining the real constraint.

### Issue 5 (Medium): begin_frame signature change not documented

**V1 bug**: HLD claimed "No changes expected" for `markdown_renderer.rs`, but `begin_frame` needs a `ctx` parameter for polling.

**V2 fix**: Added "Call-Site Changes in markdown_renderer.rs" section documenting the `begin_frame(ui.ctx())` change.

### Issue 6 (Low): Stale check doesn't handle release_gpu_textures

**V1 bug**: After `release_gpu_textures` clears `wanted_bucket`, in-flight results would pass the stale check (wanted=None → `false` → not stale) and upload a texture that's immediately useless.

**V2 fix**: Changed `is_stale_result` to return `true` when `wanted` is `None` (the `(Some, None)` case). This correctly discards results after GPU texture release.

---

## Review Notes V2 → V3

### Issue 7 (Critical): Worker uses blocking `send()` — shutdown deadlock

**V2 bug**: The worker called `result_tx.send(result)` which blocks if the result channel is full. During `Drop`, the shutdown sequence is:

1. `self.job_tx.take()` — drops the job sender, disconnecting the job channel
2. `handle.join()` — waits for the worker thread to exit

But if the worker is blocked on `result_tx.send()` (result channel full), it never reaches `job_rx.recv()` to see the disconnection — so `join()` blocks forever. The `result_rx` field is still alive on the struct (not yet dropped by Rust's field destruction), so `send()` doesn't get a `Disconnected` error either. This is a classic shutdown deadlock.

The Mermaid renderer explicitly avoids this pattern (`mermaid_renderer.rs:1264-1269`):
```rust
// Use try_send to avoid blocking if result channel is full.
// This prevents deadlock during shutdown: if Drop joins workers
// while they're blocked on send (because result_rx isn't being
// polled), we'd hang forever. Dropping results is acceptable
// since we're shutting down anyway.
let _ = worker_tx.try_send(payload);
```

**V3 fix**: Changed worker to use `try_send` instead of blocking `send`. If the result channel is full, the result is silently dropped. The worker proceeds to the next job (or exits when `job_rx` disconnects).

Consequence: if `try_send` drops a result, the `pending` set on the main thread has a leaked entry for that `code_hash` — `poll_results` never receives the result to remove it. To handle this, `release_gpu_textures` now also clears `pending` (safe because `wanted_bucket` is already cleared, causing any future in-flight results to be detected as stale). The leaked pending entry prevents re-enqueue until `release_gpu_textures` runs (e.g., on minimize/restore), but since the result channel being full implies the main thread isn't draining results (likely minimized or shutting down), this is the correct behavior.

Also added test `test_worker_try_send_full_does_not_block` (test #14) to verify the worker doesn't hang when the result channel is full.

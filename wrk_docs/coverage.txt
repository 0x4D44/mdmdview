C:\language\mdmdview\src\app.rs:
    1|       |/// Main application logic for the markdown viewer
    2|       |///
    3|       |/// This module contains the primary app state, UI logic, and event handling
    4|       |/// for the markdown viewer application built with egui.
    5|       |use crate::{MarkdownElement, MarkdownRenderer, SampleFile, WindowState, SAMPLE_FILES};
    6|       |use anyhow::{bail, Result};
    7|       |use crossbeam_channel::{unbounded, Receiver, Sender};
    8|       |use egui::text::LayoutJob;
    9|       |use egui::text::TextFormat;
   10|       |use egui::{menu, CentralPanel, Color32, Context, RichText, TopBottomPanel};
   11|       |use egui::{TextEdit, TextStyle};
   12|       |use image::{imageops, RgbaImage};
   13|       |#[cfg(not(test))]
   14|       |use rfd::FileDialog;
   15|       |#[cfg(test)]
   16|       |use std::cell::RefCell;
   17|       |#[cfg(test)]
   18|       |use std::collections::HashSet;
   19|       |use std::collections::VecDeque;
   20|       |use std::io::ErrorKind;
   21|       |use std::path::{Path, PathBuf};
   22|       |use std::time::{Duration, Instant};
   23|       |use unicode_casefold::UnicodeCaseFold;
   24|       |use unicode_normalization::UnicodeNormalization;
   25|       |
   26|       |/// Prefix used for application/window titles.
   27|       |pub const APP_TITLE_PREFIX: &str = "mdmdview";
   28|       |const BUILD_VERSION: &str = env!("CARGO_PKG_VERSION");
   29|       |const BUILD_TIMESTAMP: &str = env!("MDMDVIEW_BUILD_TIMESTAMP");
   30|       |const ASYNC_LOAD_THRESHOLD_BYTES: u64 = 2 * 1024 * 1024;
   31|       |
   32|       |#[cfg(test)]
   33|       |thread_local! {
   34|       |    static FORCED_APP_ACTIONS: RefCell<HashSet<&'static str>> = RefCell::new(HashSet::new());
   35|       |    static FORCED_OPEN_PATH: RefCell<Option<PathBuf>> = const { RefCell::new(None) };
   36|       |    static FORCED_SAVE_PATH: RefCell<Option<PathBuf>> = const { RefCell::new(None) };
   37|       |    static FORCED_LOAD_ERROR: RefCell<bool> = const { RefCell::new(false) };
   38|       |    static FORCED_SCAN_ERROR: RefCell<bool> = const { RefCell::new(false) };
   39|       |}
   40|       |
   41|       |#[cfg(test)]
   42|    164|fn app_action_triggered(triggered: bool, action: &'static str) -> bool {
   43|    164|    triggered || FORCED_APP_ACTIONS.with(|actions| actions.borrow().contains(action))
                               ^163               ^163           ^163             ^163     ^163
  ------------------
  |  Branch (43:5): [True: 1, False: 163]
  ------------------
   44|    164|}
   45|       |
   46|       |#[cfg(not(test))]
   47|       |fn app_action_triggered(triggered: bool, _action: &'static str) -> bool {
   48|       |    triggered
   49|       |}
   50|       |
   51|       |#[cfg(test)]
   52|      7|fn take_forced_open_path() -> Option<PathBuf> {
   53|      7|    FORCED_OPEN_PATH.with(|slot| slot.borrow_mut().take())
   54|      7|}
   55|       |
   56|       |#[cfg(test)]
   57|      3|fn take_forced_save_path() -> Option<PathBuf> {
   58|      3|    FORCED_SAVE_PATH.with(|slot| slot.borrow_mut().take())
   59|      3|}
   60|       |
   61|       |#[cfg(test)]
   62|     26|fn take_forced_load_error() -> bool {
   63|     26|    FORCED_LOAD_ERROR.with(|flag| flag.replace(false))
   64|     26|}
   65|       |
   66|       |#[cfg(test)]
   67|      6|fn take_forced_scan_error() -> bool {
   68|      6|    FORCED_SCAN_ERROR.with(|flag| flag.replace(false))
   69|      6|}
   70|       |
   71|       |/// Entry in navigation history for back/forward navigation
   72|       |#[derive(Clone, Debug)]
   73|       |struct HistoryEntry {
   74|       |    file_path: Option<PathBuf>,
   75|       |    title: String,
   76|       |    content: String,
   77|       |}
   78|       |
   79|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
   80|       |pub enum ScreenshotTheme {
   81|       |    Light,
   82|       |    Dark,
   83|       |}
   84|       |
   85|       |impl ScreenshotTheme {
   86|     11|    fn as_str(self) -> &'static str {
   87|     11|        match self {
   88|      8|            ScreenshotTheme::Light => "light",
   89|      3|            ScreenshotTheme::Dark => "dark",
   90|       |        }
   91|     11|    }
   92|       |}
   93|       |
   94|       |#[derive(Clone, Debug)]
   95|       |pub struct ScreenshotConfig {
   96|       |    pub output_path: PathBuf,
   97|       |    pub viewport_width: f32,
   98|       |    pub viewport_height: f32,
   99|       |    pub content_only: bool,
  100|       |    pub scroll_ratio: Option<f32>,
  101|       |    pub wait_ms: u64,
  102|       |    pub settle_frames: u32,
  103|       |    pub zoom: f32,
  104|       |    pub theme: ScreenshotTheme,
  105|       |    pub font_source: Option<String>,
  106|       |}
  107|       |
  108|       |impl ScreenshotConfig {
  109|     10|    fn metadata_path(&self) -> PathBuf {
  110|     10|        self.output_path.with_extension("json")
  111|     10|    }
  112|       |}
  113|       |
  114|       |#[derive(Clone, Copy, Debug)]
  115|       |struct ScrollSnapshot {
  116|       |    content_size: egui::Vec2,
  117|       |    inner_rect: egui::Rect,
  118|       |    offset_y: f32,
  119|       |}
  120|       |
  121|       |#[derive(Debug, Clone, Copy)]
  122|       |struct WindowAdjustment {
  123|       |    pos: Option<egui::Pos2>,
  124|       |    size: Option<egui::Vec2>,
  125|       |}
  126|       |
  127|       |struct FileLoadRequest {
  128|       |    id: u64,
  129|       |    path: PathBuf,
  130|       |}
  131|       |
  132|       |struct FileLoadResult {
  133|       |    id: u64,
  134|       |    content: Result<(String, bool), String>,
  135|       |}
  136|       |
  137|       |#[derive(Clone)]
  138|       |struct PendingFileLoad {
  139|       |    id: u64,
  140|       |    path: PathBuf,
  141|       |}
  142|       |
  143|       |#[derive(Debug)]
  144|       |struct ScreenshotState {
  145|       |    config: ScreenshotConfig,
  146|       |    started: Instant,
  147|       |    stable_frames: u32,
  148|       |    last_layout_hash: Option<u64>,
  149|       |    last_scroll_offset: Option<f32>,
  150|       |    scroll_offset: Option<f32>,
  151|       |    content_rect: Option<egui::Rect>,
  152|       |    last_content_size: Option<egui::Vec2>,
  153|       |    last_inner_rect: Option<egui::Rect>,
  154|       |    pixels_per_point: f32,
  155|       |    viewport_adjusted: bool,
  156|       |    requested: bool,
  157|       |    done: bool,
  158|       |    timed_out: bool,
  159|       |    pending_renders: bool,
  160|       |}
  161|       |
  162|       |#[derive(Clone, Debug)]
  163|       |struct ScreenshotSnapshot {
  164|       |    config: ScreenshotConfig,
  165|       |    content_rect: Option<egui::Rect>,
  166|       |    pixels_per_point: f32,
  167|       |    stable_frames: u32,
  168|       |    timed_out: bool,
  169|       |    pending_renders: bool,
  170|       |    last_scroll_offset: Option<f32>,
  171|       |    started: Instant,
  172|       |}
  173|       |
  174|       |impl ScreenshotState {
  175|     11|    fn new(config: ScreenshotConfig) -> Self {
  176|     11|        Self {
  177|     11|            config,
  178|     11|            started: Instant::now(),
  179|     11|            stable_frames: 0,
  180|     11|            last_layout_hash: None,
  181|     11|            last_scroll_offset: None,
  182|     11|            scroll_offset: None,
  183|     11|            content_rect: None,
  184|     11|            last_content_size: None,
  185|     11|            last_inner_rect: None,
  186|     11|            pixels_per_point: 1.0,
  187|     11|            viewport_adjusted: false,
  188|     11|            requested: false,
  189|     11|            done: false,
  190|     11|            timed_out: false,
  191|     11|            pending_renders: false,
  192|     11|        }
  193|     11|    }
  194|       |
  195|      6|    fn record_scroll(&mut self, snapshot: ScrollSnapshot) -> bool {
  196|      6|        self.last_content_size = Some(snapshot.content_size);
  197|      6|        self.last_inner_rect = Some(snapshot.inner_rect);
  198|      6|        self.last_scroll_offset = Some(snapshot.offset_y);
  199|       |
  200|      6|        if self.scroll_offset.is_none() {
  ------------------
  |  Branch (200:12): [True: 3, False: 3]
  ------------------
  201|      3|            if let Some(ratio) = self.config.scroll_ratio {
                                      ^2
  ------------------
  |  Branch (201:20): [True: 2, False: 1]
  ------------------
  202|      2|                let max_scroll = (snapshot.content_size.y - snapshot.inner_rect.height()).max(0.0);
  203|      2|                self.scroll_offset = Some((max_scroll * ratio).round());
  204|      2|                return true;
  205|      1|            }
  206|      3|        }
  207|      4|        false
  208|      6|    }
  209|       |
  210|      6|    fn scroll_ready(&self) -> bool {
  211|       |        match (
  212|      6|            self.config.scroll_ratio,
  213|      6|            self.scroll_offset,
  214|      6|            self.last_scroll_offset,
  215|       |        ) {
  216|      1|            (None, _, _) => true,
  217|      3|            (Some(_), Some(target), Some(actual)) => (actual - target).abs() <= 0.5,
  218|      2|            _ => false,
  219|       |        }
  220|      6|    }
  221|       |
  222|      6|    fn update_stability(&mut self, layout_hash: Option<u64>, scroll_offset: Option<f32>) {
  223|      6|        let mut changed = false;
  224|      6|        if let Some(hash) = layout_hash {
                                  ^4
  ------------------
  |  Branch (224:16): [True: 4, False: 2]
  ------------------
  225|      4|            if self.last_layout_hash != Some(hash) {
  ------------------
  |  Branch (225:16): [True: 3, False: 1]
  ------------------
  226|      3|                changed = true;
  227|      3|            }
                          ^1
  228|      4|            self.last_layout_hash = Some(hash);
  229|      2|        } else {
  230|      2|            changed = true;
  231|      2|        }
  232|       |
  233|      6|        if let (Some(prev), Some(current)) = (self.last_scroll_offset, scroll_offset) {
                                   ^4          ^4
  ------------------
  |  Branch (233:16): [True: 4, False: 2]
  ------------------
  234|      4|            if (prev - current).abs() > 0.5 {
  ------------------
  |  Branch (234:16): [True: 1, False: 3]
  ------------------
  235|      1|                changed = true;
  236|      3|            }
  237|      2|        }
  238|       |
  239|      6|        if changed {
  ------------------
  |  Branch (239:12): [True: 5, False: 1]
  ------------------
  240|      5|            self.stable_frames = 0;
  241|      5|        } else {
  242|      1|            self.stable_frames = self.stable_frames.saturating_add(1);
  243|      1|        }
  244|      6|    }
  245|       |}
  246|       |
  247|       |impl From<&ScreenshotState> for ScreenshotSnapshot {
  248|      2|    fn from(state: &ScreenshotState) -> Self {
  249|      2|        Self {
  250|      2|            config: state.config.clone(),
  251|      2|            content_rect: state.content_rect,
  252|      2|            pixels_per_point: state.pixels_per_point,
  253|      2|            stable_frames: state.stable_frames,
  254|      2|            timed_out: state.timed_out,
  255|      2|            pending_renders: state.pending_renders,
  256|      2|            last_scroll_offset: state.last_scroll_offset,
  257|      2|            started: state.started,
  258|      2|        }
  259|      2|    }
  260|       |}
  261|       |
  262|       |/// Main application state and logic
  263|       |pub struct MarkdownViewerApp {
  264|       |    /// Markdown renderer instance
  265|       |    renderer: MarkdownRenderer,
  266|       |    /// Currently loaded file path
  267|       |    current_file: Option<PathBuf>,
  268|       |    /// Current markdown content as string
  269|       |    current_content: String,
  270|       |    /// Buffer for raw view (read-only for now)
  271|       |    raw_buffer: String,
  272|       |    /// Parsed markdown elements ready for rendering
  273|       |    parsed_elements: Vec<MarkdownElement>,
  274|       |    /// Application title for window
  275|       |    title: String,
  276|       |    /// Error message to display if any
  277|       |    error_message: Option<String>,
  278|       |    /// Navigation request for keyboard shortcuts
  279|       |    nav_request: Option<NavigationRequest>,
  280|       |    /// Scroll area ID for state management
  281|       |    scroll_area_id: egui::Id,
  282|       |    /// Flag to request fullscreen toggle
  283|       |    toggle_fullscreen: bool,
  284|       |    /// Current view mode
  285|       |    view_mode: ViewMode,
  286|       |    /// Wrap long lines in raw view
  287|       |    wrap_raw: bool,
  288|       |    /// Write mode: allow editing in Raw view
  289|       |    write_enabled: bool,
  290|       |    /// Remember caret position in raw editor (byte index)
  291|       |    raw_cursor: Option<usize>,
  292|       |    /// Request focus for raw editor on next render
  293|       |    raw_focus_requested: bool,
  294|       |    /// Flag to request reload of current file (handled outside input context)
  295|       |    reload_requested: bool,
  296|       |    /// Defer toggling view mode to outside input context
  297|       |    view_toggle_requested: bool,
  298|       |    /// Defer toggling write mode to outside input context
  299|       |    write_toggle_requested: bool,
  300|       |    /// Last known window position (for persistence)
  301|       |    last_window_pos: Option<[f32; 2]>,
  302|       |    /// Last known window size (for persistence)
  303|       |    last_window_size: Option<[f32; 2]>,
  304|       |    /// Last known maximized state
  305|       |    last_window_maximized: bool,
  306|       |    /// Last persisted window snapshot to avoid redundant disk writes
  307|       |    last_persisted_state: Option<WindowState>,
  308|       |    /// Throttle saving window state
  309|       |    last_persist_instant: std::time::Instant,
  310|       |    file_load_tx: Sender<FileLoadRequest>,
  311|       |    file_load_rx: Receiver<FileLoadResult>,
  312|       |    pending_file_load: Option<PendingFileLoad>,
  313|       |    next_file_load_id: u64,
  314|       |    // Search state
  315|       |    show_search: bool,
  316|       |    search_query: String,
  317|       |    last_query: String,
  318|       |    last_match_index: Option<usize>,
  319|       |    pending_scroll_to_element: Option<usize>,
  320|       |    search_focus_requested: bool,
  321|       |    /// Deferred caret movement (in lines) for raw editor
  322|       |    pending_raw_cursor_line_move: Option<i32>,
  323|       |    // Navigation history
  324|       |    /// History of visited files and samples for back/forward navigation
  325|       |    history: Vec<HistoryEntry>,
  326|       |    /// Current position in history
  327|       |    history_index: usize,
  328|       |    /// Maximum history entries to keep
  329|       |    max_history: usize,
  330|       |    // Drag and drop state
  331|       |    /// Visual state: file is being dragged over window
  332|       |    drag_hover: bool,
  333|       |    /// Queue of files waiting to be opened (from multi-file drop)
  334|       |    pending_files: VecDeque<PathBuf>,
  335|       |    screenshot: Option<ScreenshotState>,
  336|       |}
  337|       |
  338|       |/// Navigation request for keyboard-triggered scrolling
  339|       |#[derive(Debug, Clone)]
  340|       |enum NavigationRequest {
  341|       |    Top,
  342|       |    Bottom,
  343|       |    PageUp,
  344|       |    PageDown,
  345|       |    ScrollUp,   // Arrow up - fine scrolling
  346|       |    ScrollDown, // Arrow down - fine scrolling
  347|       |}
  348|       |
  349|       |/// Which view the user is in
  350|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
  351|       |enum ViewMode {
  352|       |    Rendered,
  353|       |    Raw,
  354|       |}
  355|       |
  356|       |impl MarkdownViewerApp {
  357|      8|    fn toggle_write_mode(&mut self, ctx: &Context) {
  358|      8|        if self.write_enabled {
  ------------------
  |  Branch (358:12): [True: 5, False: 3]
  ------------------
  359|       |            // About to disable; capture current cursor if in Raw view
  360|      5|            if matches!(self.view_mode, ViewMode::Raw) {
                             ^1
  361|      4|                let editor_id = egui::Id::new("raw_editor");
  362|      4|                if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
                                          ^3
  ------------------
  |  Branch (362:24): [True: 3, False: 1]
  ------------------
  363|      3|                    if let Some(range) = state.cursor.char_range() {
                                              ^2
  ------------------
  |  Branch (363:28): [True: 2, False: 1]
  ------------------
  364|      2|                        self.raw_cursor = Some(range.primary.index);
  365|      2|                    }
                                  ^1
  366|      1|                }
  367|      1|            }
  368|      5|            self.write_enabled = false;
  369|       |        } else {
  370|       |            // Enabling write mode: ensure the raw editor will gain focus
  371|      3|            self.write_enabled = true;
  372|      3|            if matches!(self.view_mode, ViewMode::Raw) {
                             ^0
  373|      3|                self.raw_focus_requested = true;
  374|      3|            }
                          ^0
  375|       |        }
  376|      8|    }
  377|       |
  378|     14|    fn move_raw_cursor_lines(&mut self, ctx: &Context, delta_lines: i32) {
  379|     14|        if !matches!(self.view_mode, ViewMode::Raw) || !self.write_enabled {
                          ^2                                         ^12
  ------------------
  |  Branch (379:12): [True: 2, False: 12]
  |  Branch (379:56): [True: 1, False: 11]
  ------------------
  380|      3|            return;
  381|     11|        }
  382|     11|        let editor_id = egui::Id::new("raw_editor");
  383|     11|        if let Some(mut state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
                                  ^10
  ------------------
  |  Branch (383:16): [True: 10, False: 1]
  ------------------
  384|     10|            let mut idx = state
  385|     10|                .cursor
  386|     10|                .char_range()
  387|     10|                .map(|r| r.primary.index)
  388|     10|                .unwrap_or_else(|| self.raw_cursor.unwrap_or(0))
                                                 ^0              ^0
  389|     10|                .min(self.raw_buffer.len());
  390|       |
  391|     10|            let s = self.raw_buffer.as_str();
  392|     10|            match delta_lines.cmp(&0) {
  393|       |                std::cmp::Ordering::Less => {
  394|      3|                    let mut lines = -delta_lines;
  395|       |                    // Move to start of current line
  396|      3|                    idx = s[..idx].rfind('\n').map(|p| p + 1).unwrap_or(0);
                                                                     ^2
  397|      6|                    while lines > 0 && idx > 0 {
                                                     ^4
  ------------------
  |  Branch (397:27): [True: 4, False: 2]
  |  Branch (397:40): [True: 3, False: 1]
  ------------------
  398|      3|                        if let Some(prev_nl) = s[..idx.saturating_sub(1)].rfind('\n') {
                                                  ^1
  ------------------
  |  Branch (398:32): [True: 1, False: 2]
  ------------------
  399|      1|                            idx = prev_nl + 1;
  400|      2|                        } else {
  401|      2|                            idx = 0;
  402|      2|                        }
  403|      3|                        lines -= 1;
  404|       |                    }
  405|       |                }
  406|       |                std::cmp::Ordering::Greater => {
  407|      6|                    let mut lines = delta_lines;
  408|       |                    // Move to start of next line
  409|      6|                    if let Some(nl) = s[idx..].find('\n') {
                                              ^4
  ------------------
  |  Branch (409:28): [True: 4, False: 2]
  ------------------
  410|      4|                        idx = (idx + nl + 1).min(s.len());
  411|      4|                        lines -= 1;
  412|      4|                    }
                                  ^2
  413|      9|                    while lines > 0 && idx < s.len() {
                                                     ^4
  ------------------
  |  Branch (413:27): [True: 4, False: 5]
  |  Branch (413:40): [True: 3, False: 1]
  ------------------
  414|      3|                        if let Some(nl) = s[idx..].find('\n') {
                                                  ^1
  ------------------
  |  Branch (414:32): [True: 1, False: 2]
  ------------------
  415|      1|                            idx = (idx + nl + 1).min(s.len());
  416|      2|                        } else {
  417|      2|                            idx = s.len();
  418|      2|                        }
  419|      3|                        lines -= 1;
  420|       |                    }
  421|       |                }
  422|      1|                std::cmp::Ordering::Equal => {}
  423|       |            }
  424|     10|            let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(idx));
  425|     10|            state.cursor.set_char_range(Some(cr));
  426|     10|            state.store(ctx, editor_id);
  427|     10|            self.raw_cursor = Some(idx);
  428|     10|            self.raw_focus_requested = true; // keep focus and make caret visible
  429|      1|        }
  430|     14|    }
  431|      2|    fn clear_search_state(&mut self) {
  432|      2|        self.search_query.clear();
  433|      2|        self.last_query.clear();
  434|      2|        self.last_match_index = None;
  435|      2|        self.pending_scroll_to_element = None;
  436|      2|        self.renderer.set_highlight_phrase(None);
  437|      2|    }
  438|      8|    fn find_next(&mut self) {
  439|      8|        if self.search_query.is_empty() && self.last_query.is_empty() {
                                                         ^2              ^2
  ------------------
  |  Branch (439:12): [True: 2, False: 6]
  |  Branch (439:44): [True: 1, False: 1]
  ------------------
  440|      1|            return;
  441|      7|        }
  442|      7|        let needle = if !self.search_query.is_empty() {
  ------------------
  |  Branch (442:25): [True: 6, False: 1]
  ------------------
  443|      6|            self.last_query = self.search_query.clone();
  444|      6|            Self::fold_for_search(&self.search_query)
  445|       |        } else {
  446|      1|            Self::fold_for_search(&self.last_query)
  447|       |        };
  448|      7|        let mut start = self.last_match_index.unwrap_or(usize::MAX);
  449|      7|        if start == usize::MAX {
  ------------------
  |  Branch (449:12): [True: 5, False: 2]
  ------------------
  450|      5|            start = 0;
  451|      5|        } else {
  452|      2|            start = start.saturating_add(1);
  453|      2|        }
  454|       |        // Wrap-around search forward
  455|      7|        let total = self.parsed_elements.len();
  456|      8|        for pass in 0..2 {
  457|      8|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
  ------------------
  |  Branch (457:61): [True: 7, False: 1]
  ------------------
  458|      7|                Box::new(start..total)
  459|       |            } else {
  460|      1|                Box::new(0..start.min(total))
  461|       |            };
  462|     11|            for idx in range {
                              ^10
  463|     10|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
  464|     10|                    &self.parsed_elements[idx],
  465|       |                );
  466|     10|                if Self::fold_for_search(&text).contains(&needle) {
  ------------------
  |  Branch (466:20): [True: 7, False: 3]
  ------------------
  467|      7|                    self.last_match_index = Some(idx);
  468|      7|                    self.pending_scroll_to_element = Some(idx);
  469|      7|                    return;
  470|      3|                }
  471|       |            }
  472|       |        }
  473|      8|    }
  474|       |
  475|      3|    fn find_previous(&mut self) {
  476|      3|        if self.search_query.is_empty() && self.last_query.is_empty() {
                                                         ^2              ^2
  ------------------
  |  Branch (476:12): [True: 2, False: 1]
  |  Branch (476:44): [True: 1, False: 1]
  ------------------
  477|      1|            return;
  478|      2|        }
  479|      2|        let needle = if !self.search_query.is_empty() {
  ------------------
  |  Branch (479:25): [True: 1, False: 1]
  ------------------
  480|      1|            self.last_query = self.search_query.clone();
  481|      1|            Self::fold_for_search(&self.search_query)
  482|       |        } else {
  483|      1|            Self::fold_for_search(&self.last_query)
  484|       |        };
  485|      2|        let total = self.parsed_elements.len();
  486|      2|        let mut start = self.last_match_index.unwrap_or(0);
  487|      2|        if start == 0 {
  ------------------
  |  Branch (487:12): [True: 1, False: 1]
  ------------------
  488|      1|            start = total.saturating_sub(1);
  489|      1|        } else {
  490|      1|            start = start.saturating_sub(1);
  491|      1|        }
  492|       |        // Wrap-around search backward
  493|      3|        for pass in 0..2 {
  494|      3|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
  ------------------
  |  Branch (494:61): [True: 2, False: 1]
  ------------------
  495|      2|                Box::new((0..=start).rev())
  496|       |            } else {
  497|      1|                Box::new(((start + 1)..total).rev())
  498|       |            };
  499|      6|            for idx in range {
                              ^5
  500|      5|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
  501|      5|                    &self.parsed_elements[idx],
  502|       |                );
  503|      5|                if Self::fold_for_search(&text).contains(&needle) {
  ------------------
  |  Branch (503:20): [True: 2, False: 3]
  ------------------
  504|      2|                    self.last_match_index = Some(idx);
  505|      2|                    self.pending_scroll_to_element = Some(idx);
  506|      2|                    return;
  507|      3|                }
  508|       |            }
  509|       |        }
  510|      3|    }
  511|       |    /// Create a new application instance
  512|    125|    pub fn new() -> Self {
  513|    125|        let (file_load_tx, file_load_rx) = Self::spawn_file_loader();
  514|    125|        let mut app = Self {
  515|    125|            renderer: MarkdownRenderer::new(),
  516|    125|            current_file: None,
  517|    125|            current_content: String::new(),
  518|    125|            raw_buffer: String::new(),
  519|    125|            parsed_elements: Vec::new(),
  520|    125|            title: APP_TITLE_PREFIX.to_string(),
  521|    125|            error_message: None,
  522|    125|            nav_request: None,
  523|    125|            scroll_area_id: egui::Id::new("main_scroll_area"),
  524|    125|            toggle_fullscreen: false,
  525|    125|            view_mode: ViewMode::Rendered,
  526|    125|            wrap_raw: false,
  527|    125|            write_enabled: false,
  528|    125|            raw_cursor: None,
  529|    125|            raw_focus_requested: false,
  530|    125|            reload_requested: false,
  531|    125|            view_toggle_requested: false,
  532|    125|            write_toggle_requested: false,
  533|    125|            last_window_pos: None,
  534|    125|            last_window_size: None,
  535|    125|            last_window_maximized: false,
  536|    125|            last_persisted_state: None,
  537|    125|            last_persist_instant: std::time::Instant::now(),
  538|    125|            file_load_tx,
  539|    125|            file_load_rx,
  540|    125|            pending_file_load: None,
  541|    125|            next_file_load_id: 0,
  542|    125|            show_search: false,
  543|    125|            search_query: String::new(),
  544|    125|            last_query: String::new(),
  545|    125|            last_match_index: None,
  546|    125|            pending_scroll_to_element: None,
  547|    125|            search_focus_requested: false,
  548|    125|            pending_raw_cursor_line_move: None,
  549|    125|            history: Vec::new(),
  550|    125|            history_index: 0,
  551|    125|            max_history: 50,
  552|    125|            drag_hover: false,
  553|    125|            pending_files: VecDeque::new(),
  554|    125|            screenshot: None,
  555|    125|        };
  556|       |        // Load welcome content by default
  557|    125|        if let Some(welcome) = SAMPLE_FILES.iter().find(|f| f.name == "welcome.md") {
  ------------------
  |  Branch (557:16): [True: 125, False: 0]
  ------------------
  558|    125|            app.load_content(welcome.content, Some("Welcome".to_string()));
  559|    125|        }
                      ^0
  560|       |
  561|    125|        app
  562|    125|    }
  563|       |
  564|      1|    pub fn set_zoom_scale(&mut self, scale: f32) {
  565|      1|        self.renderer.set_zoom_scale(scale);
  566|      1|    }
  567|       |
  568|      3|    pub fn set_screenshot_mode(&mut self, config: ScreenshotConfig) {
  569|      3|        self.screenshot = Some(ScreenshotState::new(config));
  570|      3|        self.view_mode = ViewMode::Rendered;
  571|      3|        self.write_enabled = false;
  572|      3|        self.show_search = false;
  573|      3|        self.search_focus_requested = false;
  574|      3|        self.nav_request = None;
  575|      3|    }
  576|       |
  577|       |    /// Check if file has valid markdown extension
  578|    143|    fn is_valid_markdown_file(&self, path: &Path) -> bool {
  579|    143|        if let Some(ext) = path.extension() {
                                  ^142
  ------------------
  |  Branch (579:16): [True: 142, False: 1]
  ------------------
  580|    142|            let ext = ext.to_string_lossy().to_lowercase();
  581|    142|            matches!(ext.as_str(), "md" | "markdown" | "mdown" | "mkd" | "txt")
                          ^135                          ^13          ^10       ^9      ^8
  582|       |        } else {
  583|      1|            false
  584|       |        }
  585|    143|    }
  586|       |
  587|       |    /// Handle dropped files from drag-and-drop operation
  588|     16|    fn handle_file_drop(&mut self, paths: Vec<PathBuf>) {
  589|     16|        if paths.is_empty() {
  ------------------
  |  Branch (589:12): [True: 1, False: 15]
  ------------------
  590|      1|            return;
  591|     15|        }
  592|       |
  593|     15|        let mut valid_files = Vec::new();
  594|     15|        let mut errors = Vec::new();
  595|       |
  596|       |        // Validate all dropped files
  597|    147|        for path in paths {
                          ^132
  598|    132|            if !path.exists() {
  ------------------
  |  Branch (598:16): [True: 3, False: 129]
  ------------------
  599|      3|                errors.push(format!("File not found: {}", path.display()));
  600|      3|                continue;
  601|    129|            }
  602|       |
  603|    129|            if path.is_dir() {
  ------------------
  |  Branch (603:16): [True: 4, False: 125]
  ------------------
  604|       |                // Handle directory by scanning for markdown files
  605|      4|                match self.scan_directory(&path) {
  606|      3|                    Ok(dir_files) => {
  607|      3|                        if dir_files.is_empty() {
  ------------------
  |  Branch (607:28): [True: 2, False: 1]
  ------------------
  608|      2|                            errors.push(format!(
  609|      2|                                "No markdown files in directory: {}",
  610|      2|                                path.display()
  611|      2|                            ));
  612|      2|                        } else {
  613|      1|                            valid_files.extend(dir_files);
  614|      1|                        }
  615|       |                    }
  616|      1|                    Err(e) => {
  617|      1|                        errors.push(format!("Cannot read directory {}: {}", path.display(), e));
  618|      1|                    }
  619|       |                }
  620|      4|                continue;
  621|    125|            }
  622|       |
  623|    125|            if !self.is_valid_markdown_file(&path) {
  ------------------
  |  Branch (623:16): [True: 3, False: 122]
  ------------------
  624|      3|                errors.push(format!(
  625|      3|                    "Not a markdown file: {}",
  626|      3|                    path.file_name().unwrap_or_default().to_string_lossy()
  627|       |                ));
  628|      3|                continue;
  629|    122|            }
  630|       |
  631|    122|            valid_files.push(path);
  632|       |        }
  633|       |
  634|       |        // Limit to prevent memory issues
  635|       |        const MAX_FILES: usize = 50;
  636|     15|        if valid_files.len() > MAX_FILES {
  ------------------
  |  Branch (636:12): [True: 2, False: 13]
  ------------------
  637|      2|            self.error_message = Some(format!(
  638|      2|                "Too many files ({}). Maximum is {}.\n\
  639|      2|                 Please drop files in smaller batches.",
  640|      2|                valid_files.len(),
  641|      2|                MAX_FILES
  642|      2|            ));
  643|      2|            return;
  644|     13|        }
  645|       |
  646|       |        // Handle valid files
  647|     13|        if !valid_files.is_empty() {
  ------------------
  |  Branch (647:12): [True: 7, False: 6]
  ------------------
  648|       |            // Open first file immediately
  649|      7|            let first_file = valid_files.remove(0);
  650|      7|            if let Err(e) = self.load_file(first_file, true) {
                                     ^1
  ------------------
  |  Branch (650:20): [True: 1, False: 6]
  ------------------
  651|      1|                self.error_message = Some(format!("Failed to load file: {}", e));
  652|      1|                return;
  653|      6|            }
  654|       |
  655|       |            // Queue remaining files
  656|      6|            self.pending_files.extend(valid_files.iter().cloned());
  657|       |
  658|       |            // Show info message if multiple files
  659|      6|            if !self.pending_files.is_empty() {
  ------------------
  |  Branch (659:16): [True: 3, False: 3]
  ------------------
  660|      3|                eprintln!(
  661|      3|                    "Queued {} files. Use Alt+Right to navigate to the next file.",
  662|      3|                    self.pending_files.len()
  663|      3|                );
  664|      3|            }
  665|      6|        }
  666|       |
  667|       |        // Show errors if any
  668|     12|        if !errors.is_empty() {
  ------------------
  |  Branch (668:12): [True: 8, False: 4]
  ------------------
  669|      8|            let valid_count = if valid_files.is_empty() {
  ------------------
  |  Branch (669:34): [True: 7, False: 1]
  ------------------
  670|      7|                0
  671|       |            } else {
  672|      1|                valid_files.len() + 1
  673|       |            };
  674|      8|            let error_msg = if errors.len() == 1 && valid_count == 0 {
                                                                  ^7
  ------------------
  |  Branch (674:32): [True: 7, False: 1]
  |  Branch (674:53): [True: 6, False: 1]
  ------------------
  675|      6|                errors[0].clone()
  676|      2|            } else if valid_count == 0 {
  ------------------
  |  Branch (676:23): [True: 1, False: 1]
  ------------------
  677|       |                // All files failed
  678|      1|                format!("No valid files:\n{}", errors.join("\n"))
  679|       |            } else {
  680|       |                // Some succeeded, some failed
  681|      1|                format!(
  682|      1|                    "Opened {} files. Skipped {}:\n{}",
  683|       |                    valid_count,
  684|      1|                    errors.len(),
  685|      1|                    errors.join("\n")
  686|       |                )
  687|       |            };
  688|      8|            self.error_message = Some(error_msg);
  689|      4|        }
  690|     16|    }
  691|       |
  692|       |    /// Scan directory for markdown files (non-recursive)
  693|      6|    fn scan_directory(&self, dir: &Path) -> Result<Vec<PathBuf>> {
  694|       |        #[cfg(test)]
  695|      6|        if take_forced_scan_error() {
  ------------------
  |  Branch (695:12): [True: 1, False: 5]
  ------------------
  696|      1|            bail!("Forced scan error");
  697|      5|        }
  698|       |
  699|      5|        let mut files = Vec::new();
  700|       |
  701|      5|        let entries = std::fs::read_dir(dir)?;
                                                          ^0
  702|       |
  703|     13|        for entry in entries {
                          ^8
  704|      8|            let entry = entry?;
                                           ^0
  705|      8|            let path = entry.path();
  706|       |
  707|       |            // Only include files (not subdirectories)
  708|      8|            if path.is_file() && self.is_valid_markdown_file(&path) {
                                               ^7   ^7                     ^7
  ------------------
  |  Branch (708:16): [True: 7, False: 1]
  |  Branch (708:34): [True: 6, False: 1]
  ------------------
  709|      6|                files.push(path);
  710|      6|            }
                          ^2
  711|       |        }
  712|       |
  713|       |        // Sort alphabetically for predictable order
  714|      5|        files.sort();
  715|       |
  716|      5|        Ok(files)
  717|      6|    }
  718|       |
  719|       |    /// Load markdown content from a string
  720|    180|    pub fn load_content(&mut self, content: &str, title: Option<String>) {
  721|    180|        self.pending_file_load = None;
  722|    180|        self.current_content = content.to_string();
  723|    180|        self.raw_buffer = self.current_content.clone();
  724|    180|        self.error_message = None;
  725|    180|        self.nav_request = None; // Reset any pending navigation
  726|       |                                 // Ensure scroll resets to top on new content
  727|    180|        self.pending_scroll_to_element = Some(0);
  728|    180|        self.renderer.clear_table_layout_cache();
  729|       |
  730|    180|        match self.renderer.parse(content) {
  731|    179|            Ok(elements) => {
  732|    179|                self.parsed_elements = elements;
  733|    179|                if let Some(title) = title {
                                          ^178
  ------------------
  |  Branch (733:24): [True: 178, False: 1]
  ------------------
  734|    178|                    self.title = format!("{APP_TITLE_PREFIX} - {}", title);
  735|    178|                }
                              ^1
  736|       |            }
  737|      1|            Err(e) => {
  738|      1|                self.error_message = Some(format!("Failed to parse markdown: {}", e));
  739|      1|                self.parsed_elements.clear();
  740|      1|            }
  741|       |        }
  742|    180|    }
  743|       |
  744|       |    /// Load markdown content from a file path
  745|     26|    pub fn load_file(&mut self, path: PathBuf, record_history: bool) -> Result<()> {
  746|       |        #[cfg(test)]
  747|     26|        if take_forced_load_error() {
  ------------------
  |  Branch (747:12): [True: 3, False: 23]
  ------------------
  748|      3|            bail!("Forced load error");
  749|     23|        }
  750|       |
  751|       |        // Push current state to history before loading new file
  752|     23|        if record_history && !self.current_content.is_empty() {
                                           ^19
  ------------------
  |  Branch (752:12): [True: 19, False: 4]
  |  Branch (752:30): [True: 18, False: 1]
  ------------------
  753|     18|            self.push_history();
  754|     18|        }
                      ^5
  755|       |
  756|     23|        let file_size = std::fs::metadata(&path).ok().map(|m| m.len());
                                                                            ^22^22
  757|     23|        let use_async = self.screenshot.is_none()
  ------------------
  |  Branch (757:25): [True: 22, False: 1]
  ------------------
  758|     22|            && file_size.is_some_and(|size| size >= ASYNC_LOAD_THRESHOLD_BYTES);
                                                          ^21
  759|     23|        if use_async {
  ------------------
  |  Branch (759:12): [True: 2, False: 21]
  ------------------
  760|      2|            let load_id = self.next_file_load_id;
  761|      2|            self.next_file_load_id = self.next_file_load_id.wrapping_add(1);
  762|      2|            let request = FileLoadRequest {
  763|      2|                id: load_id,
  764|      2|                path: path.clone(),
  765|      2|            };
  766|      2|            if self.file_load_tx.send(request).is_ok() {
  ------------------
  |  Branch (766:16): [True: 1, False: 1]
  ------------------
  767|      1|                self.pending_file_load = Some(PendingFileLoad { id: load_id, path });
  768|      1|                return Ok(());
  769|      1|            }
  770|     21|        }
  771|       |
  772|     22|        let (content, lossy) = Self::read_file_lossy(&path)?;
                           ^21      ^21                                  ^1
  773|     21|        let filename = path
  774|     21|            .file_name()
  775|     21|            .and_then(|n| n.to_str())
  776|     21|            .unwrap_or("Unknown")
  777|     21|            .to_string();
  778|       |
  779|     21|        let base = path.parent().map(|p| p.to_path_buf());
  780|     21|        self.renderer.set_base_dir(base.as_deref());
  781|     21|        self.current_file = Some(path);
  782|     21|        self.load_content(&content, Some(filename));
  783|     21|        if lossy {
  ------------------
  |  Branch (783:12): [True: 1, False: 20]
  ------------------
  784|      1|            eprintln!("Loaded file with invalid UTF-8; replaced invalid sequences.");
  785|     20|        }
  786|     21|        Ok(())
  787|     26|    }
  788|       |
  789|       |    /// Normalize all line endings to Unix style (\n)
  790|       |    /// Handles Windows (\r\n), Unix (\n), and old Mac (\r) formats
  791|     29|    fn normalize_line_endings(s: &str) -> String {
  792|       |        // Order matters: replace \r\n first (Windows), then remaining \r (old Mac)
  793|     29|        let normalized = s.replace("\r\n", "\n").replace('\r', "\n");
  794|     29|        if let Some(stripped) = normalized.strip_prefix('\u{FEFF}') {
                                  ^1
  ------------------
  |  Branch (794:16): [True: 1, False: 28]
  ------------------
  795|      1|            stripped.to_string()
  796|       |        } else {
  797|     28|            normalized
  798|       |        }
  799|     29|    }
  800|       |
  801|     23|    fn read_file_lossy(path: &Path) -> Result<(String, bool)> {
  802|     23|        match std::fs::read_to_string(path) {
  803|     21|            Ok(s) => Ok((Self::normalize_line_endings(&s), false)),
  804|      2|            Err(e) if e.kind() == ErrorKind::InvalidData => {
                              ^1                                     ^1
  ------------------
  |  Branch (804:23): [True: 1, False: 1]
  ------------------
  805|      1|                let bytes = std::fs::read(path)?;
                                                             ^0
  806|      1|                let s = String::from_utf8_lossy(&bytes).into_owned();
  807|      1|                Ok((Self::normalize_line_endings(&s), true))
  808|       |            }
  809|      1|            Err(e) => Err(e.into()),
  810|       |        }
  811|     23|    }
  812|       |
  813|    125|    fn spawn_file_loader() -> (Sender<FileLoadRequest>, Receiver<FileLoadResult>) {
  814|    125|        let (request_tx, request_rx) = unbounded::<FileLoadRequest>();
  815|    125|        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
  816|    125|        if let Err(err) = std::thread::Builder::new()
                                 ^0
  ------------------
  |  Branch (816:16): [True: 0, False: 125]
  ------------------
  817|    125|            .name("mdmdview-file-loader".to_string())
  818|    125|            .spawn(move || {
  819|    125|                for request in request_rx.iter() {
                                  ^1
  820|      1|                    let content = MarkdownViewerApp::read_file_lossy(&request.path)
  821|      1|                        .map_err(|err| err.to_string());
                                                     ^0  ^0
  822|      1|                    let _ = result_tx.send(FileLoadResult {
  823|      1|                        id: request.id,
  824|      1|                        content,
  825|      1|                    });
  826|       |                }
  827|    125|            })
  828|      0|        {
  829|      0|            eprintln!("Failed to start file loader thread: {err}");
  830|    125|        }
  831|    125|        (request_tx, result_rx)
  832|    125|    }
  833|       |
  834|     22|    fn poll_file_loads(&mut self) {
  835|     24|        while let Ok(result) = self.file_load_rx.try_recv() {
                                   ^2
  ------------------
  |  Branch (835:19): [True: 2, False: 22]
  ------------------
  836|      2|            let pending = match &self.pending_file_load {
                              ^1
  837|      2|                Some(pending) if pending.id == result.id => pending.clone(),
                                                                     ^1   ^1      ^1
  ------------------
  |  Branch (837:34): [True: 1, False: 1]
  ------------------
  838|      1|                _ => continue,
  839|       |            };
  840|      1|            self.pending_file_load = None;
  841|      1|            match result.content {
  842|      1|                Ok((content, lossy)) => {
  843|      1|                    let filename = pending
  844|      1|                        .path
  845|      1|                        .file_name()
  846|      1|                        .and_then(|n| n.to_str())
  847|      1|                        .unwrap_or("Unknown")
  848|      1|                        .to_string();
  849|      1|                    let base = pending.path.parent().map(|p| p.to_path_buf());
  850|      1|                    self.renderer.set_base_dir(base.as_deref());
  851|      1|                    self.current_file = Some(pending.path);
  852|      1|                    self.load_content(&content, Some(filename));
  853|      1|                    if lossy {
  ------------------
  |  Branch (853:24): [True: 1, False: 0]
  ------------------
  854|      1|                        eprintln!("Loaded file with invalid UTF-8; replaced invalid sequences.");
  855|      1|                    }
                                  ^0
  856|       |                }
  857|      0|                Err(err) => {
  858|      0|                    self.error_message = Some(format!("Failed to load file: {err}"));
  859|      0|                }
  860|       |            }
  861|       |        }
  862|     22|    }
  863|       |
  864|      5|    fn current_window_state(&self) -> Option<WindowState> {
  865|      5|        let pos = self.last_window_pos?;
                          ^4                        ^1
  866|      4|        let size = self.last_window_size?;
                                                      ^0
  867|      4|        Some(WindowState {
  868|      4|            pos,
  869|      4|            size,
  870|      4|            maximized: self.last_window_maximized,
  871|      4|        })
  872|      5|    }
  873|       |
  874|     29|    fn compute_window_adjustment(
  875|     29|        outer_rect: Option<egui::Rect>,
  876|     29|        inner_rect: Option<egui::Rect>,
  877|     29|        monitor_size: Option<egui::Vec2>,
  878|     29|    ) -> Option<WindowAdjustment> {
  879|     29|        let outer = outer_rect?;
                          ^12               ^17
  880|     12|        let inner = inner_rect.unwrap_or(outer);
  881|     12|        let monitor = monitor_size?;
                                                ^0
  882|       |
  883|     12|        if monitor.x <= 0.0 || monitor.y <= 0.0 {
                                             ^11
  ------------------
  |  Branch (883:12): [True: 1, False: 11]
  |  Branch (883:32): [True: 1, False: 10]
  ------------------
  884|      2|            return None;
  885|     10|        }
  886|       |
  887|       |        const MIN_WIDTH: f32 = 600.0;
  888|       |        const MIN_HEIGHT: f32 = 400.0;
  889|       |        const OFFSCREEN_TOLERANCE: f32 = 32.0;
  890|       |
  891|     10|        let mut pos = outer.min;
  892|     10|        let mut size = inner.size();
  893|     10|        let mut pos_adjusted = false;
  894|     10|        let mut size_adjusted = false;
  895|       |
  896|     10|        if !pos.x.is_finite() || !pos.y.is_finite() {
                                               ^8
  ------------------
  |  Branch (896:12): [True: 2, False: 8]
  |  Branch (896:34): [True: 0, False: 8]
  ------------------
  897|      2|            pos = egui::pos2(0.0, 0.0);
  898|      2|            pos_adjusted = true;
  899|      8|        }
  900|     10|        if !size.x.is_finite() || !size.y.is_finite() {
                                                ^9
  ------------------
  |  Branch (900:12): [True: 1, False: 9]
  |  Branch (900:35): [True: 1, False: 8]
  ------------------
  901|      2|            size = egui::vec2(MIN_WIDTH, MIN_HEIGHT);
  902|      2|            size_adjusted = true;
  903|      8|        }
  904|       |
  905|     10|        let outer_size = outer.size();
  906|     10|        let inner_size = inner.size();
  907|     10|        let frame = egui::vec2(
  908|     10|            (outer_size.x - inner_size.x).max(0.0),
  909|     10|            (outer_size.y - inner_size.y).max(0.0),
  910|       |        );
  911|       |
  912|     10|        let available_width = (monitor.x - frame.x).max(MIN_WIDTH);
  913|     10|        let available_height = (monitor.y - frame.y).max(MIN_HEIGHT);
  914|       |
  915|     10|        if size.x < MIN_WIDTH {
  ------------------
  |  Branch (915:12): [True: 3, False: 7]
  ------------------
  916|      3|            size.x = MIN_WIDTH.min(available_width);
  917|      3|            size_adjusted = true;
  918|      7|        }
  919|     10|        if size.y < MIN_HEIGHT {
  ------------------
  |  Branch (919:12): [True: 3, False: 7]
  ------------------
  920|      3|            size.y = MIN_HEIGHT.min(available_height);
  921|      3|            size_adjusted = true;
  922|      7|        }
  923|     10|        if size.x > available_width {
  ------------------
  |  Branch (923:12): [True: 1, False: 9]
  ------------------
  924|      1|            size.x = available_width;
  925|      1|            size_adjusted = true;
  926|      9|        }
  927|     10|        if size.y > available_height {
  ------------------
  |  Branch (927:12): [True: 1, False: 9]
  ------------------
  928|      1|            size.y = available_height;
  929|      1|            size_adjusted = true;
  930|      9|        }
  931|       |
  932|     10|        let outer_size_for_bounds = size + frame;
  933|     10|        let max_pos = egui::pos2(
  934|     10|            (monitor.x - outer_size_for_bounds.x).max(0.0),
  935|     10|            (monitor.y - outer_size_for_bounds.y).max(0.0),
  936|       |        );
  937|       |
  938|     10|        if pos.x <= -0.25 * outer_size_for_bounds.x {
  ------------------
  |  Branch (938:12): [True: 1, False: 9]
  ------------------
  939|      1|            pos.x = 0.0;
  940|      1|            pos_adjusted = true;
  941|      9|        }
  942|     10|        if pos.y <= -0.25 * outer_size_for_bounds.y {
  ------------------
  |  Branch (942:12): [True: 2, False: 8]
  ------------------
  943|      2|            pos.y = 0.0;
  944|      2|            pos_adjusted = true;
  945|      8|        }
  946|     10|        if pos.x > max_pos.x + OFFSCREEN_TOLERANCE {
  ------------------
  |  Branch (946:12): [True: 2, False: 8]
  ------------------
  947|      2|            pos.x = max_pos.x;
  948|      2|            pos_adjusted = true;
  949|      8|        }
  950|     10|        if pos.y > max_pos.y + OFFSCREEN_TOLERANCE {
  ------------------
  |  Branch (950:12): [True: 2, False: 8]
  ------------------
  951|      2|            pos.y = max_pos.y;
  952|      2|            pos_adjusted = true;
  953|      8|        }
  954|       |
  955|     10|        if pos_adjusted || size_adjusted {
                                         ^4
  ------------------
  |  Branch (955:12): [True: 6, False: 4]
  |  Branch (955:28): [True: 3, False: 1]
  ------------------
  956|      9|            size.x = size.x.max(MIN_WIDTH.min(available_width));
  957|      9|            size.y = size.y.max(MIN_HEIGHT.min(available_height));
  958|      9|            Some(WindowAdjustment {
  959|      9|                pos: pos_adjusted.then_some(pos),
  960|      9|                size: size_adjusted.then_some(size),
  961|      9|            })
  962|       |        } else {
  963|      1|            None
  964|       |        }
  965|     29|    }
  966|       |
  967|      8|    fn window_state_changed(&self, new_state: &WindowState) -> bool {
  968|      8|        match &self.last_persisted_state {
  969|      5|            Some(prev) => {
  970|      5|                let pos_changed = (prev.pos[0] - new_state.pos[0]).abs() > 0.5
  ------------------
  |  Branch (970:35): [True: 1, False: 4]
  ------------------
  971|      4|                    || (prev.pos[1] - new_state.pos[1]).abs() > 0.5;
  972|      5|                let size_changed = (prev.size[0] - new_state.size[0]).abs() > 0.5
  ------------------
  |  Branch (972:36): [True: 1, False: 4]
  ------------------
  973|      4|                    || (prev.size[1] - new_state.size[1]).abs() > 0.5;
  974|      5|                let maximized_changed = prev.maximized != new_state.maximized;
  975|      5|                pos_changed || size_changed || maximized_changed
                                             ^4              ^3
  ------------------
  |  Branch (975:17): [True: 1, False: 4]
  |  Branch (975:32): [True: 1, False: 3]
  ------------------
  976|       |            }
  977|      3|            None => true,
  978|       |        }
  979|      8|    }
  980|       |
  981|     34|    fn fold_for_search(input: &str) -> String {
  982|     34|        input.case_fold().nfkc().collect()
  983|     34|    }
  984|       |
  985|       |    /// Push current state to navigation history
  986|     37|    fn push_history(&mut self) {
  987|       |        // Truncate forward history if we're not at the end
  988|     37|        if self.history_index < self.history.len() {
  ------------------
  |  Branch (988:12): [True: 2, False: 35]
  ------------------
  989|      2|            self.history.truncate(self.history_index);
  990|     35|        }
  991|       |
  992|       |        // Create entry for current state
  993|     37|        let entry = HistoryEntry {
  994|     37|            file_path: self.current_file.clone(),
  995|     37|            title: self.title.clone(),
  996|     37|            content: self.current_content.clone(),
  997|     37|        };
  998|       |
  999|     37|        self.history.push(entry);
 1000|       |
 1001|       |        // Limit history size
 1002|     37|        if self.history.len() > self.max_history {
  ------------------
  |  Branch (1002:12): [True: 1, False: 36]
  ------------------
 1003|      1|            self.history.remove(0);
 1004|     36|        } else {
 1005|     36|            self.history_index = self.history.len();
 1006|     36|        }
 1007|     37|    }
 1008|       |
 1009|       |    /// Navigate back in history
 1010|      3|    fn navigate_back(&mut self) -> bool {
 1011|      3|        if self.history_index > 0 {
  ------------------
  |  Branch (1011:12): [True: 2, False: 1]
  ------------------
 1012|      2|            self.history_index -= 1;
 1013|      2|            self.restore_from_history();
 1014|      2|            true
 1015|       |        } else {
 1016|      1|            false
 1017|       |        }
 1018|      3|    }
 1019|       |
 1020|       |    /// Navigate forward in history
 1021|      6|    fn navigate_forward(&mut self) -> bool {
 1022|       |        // First try pending files queue
 1023|      6|        if let Some(next_file) = self.pending_files.pop_front() {
                                  ^2
  ------------------
  |  Branch (1023:16): [True: 2, False: 4]
  ------------------
 1024|       |            // Load next file from queue
 1025|      2|            if let Err(e) = self.load_file(next_file, true) {
                                     ^1
  ------------------
  |  Branch (1025:20): [True: 1, False: 1]
  ------------------
 1026|      1|                self.error_message = Some(format!("Failed to load file: {}", e));
 1027|      1|            }
 1028|      2|            return true;
 1029|      4|        }
 1030|       |
 1031|       |        // Otherwise use history navigation (existing code)
 1032|      4|        if self.history_index < self.history.len().saturating_sub(1) {
  ------------------
  |  Branch (1032:12): [True: 1, False: 3]
  ------------------
 1033|      1|            self.history_index += 1;
 1034|      1|            self.restore_from_history();
 1035|      1|            true
 1036|       |        } else {
 1037|      3|            false
 1038|       |        }
 1039|      6|    }
 1040|       |
 1041|       |    /// Restore state from history at current index
 1042|      6|    fn restore_from_history(&mut self) {
 1043|      6|        if let Some(entry) = self.history.get(self.history_index) {
                                  ^5
  ------------------
  |  Branch (1043:16): [True: 5, False: 1]
  ------------------
 1044|      5|            self.current_file = entry.file_path.clone();
 1045|      5|            self.title = entry.title.clone();
 1046|      5|            self.current_content = entry.content.clone();
 1047|      5|            self.raw_buffer = self.current_content.clone();
 1048|       |
 1049|       |            // Re-parse content
 1050|      5|            match self.renderer.parse(&self.current_content) {
 1051|      4|                Ok(elements) => {
 1052|      4|                    self.parsed_elements = elements;
 1053|      4|                    self.error_message = None;
 1054|      4|                }
 1055|      1|                Err(e) => {
 1056|      1|                    self.error_message = Some(format!("Failed to parse: {}", e));
 1057|      1|                }
 1058|       |            }
 1059|       |
 1060|       |            // Set base dir for images
 1061|      5|            if let Some(ref path) = self.current_file {
                                      ^1
  ------------------
  |  Branch (1061:20): [True: 1, False: 4]
  ------------------
 1062|      1|                self.renderer.set_base_dir(path.parent());
 1063|      4|            } else {
 1064|      4|                self.renderer.set_base_dir(None);
 1065|      4|            }
 1066|       |
 1067|       |            // Scroll to top
 1068|      5|            self.pending_scroll_to_element = Some(0);
 1069|      1|        }
 1070|      6|    }
 1071|       |
 1072|       |    /// Check if we can navigate back
 1073|      3|    fn can_navigate_back(&self) -> bool {
 1074|      3|        self.history_index > 0
 1075|      3|    }
 1076|       |
 1077|       |    /// Check if we can navigate forward
 1078|      4|    fn can_navigate_forward(&self) -> bool {
 1079|      4|        !self.pending_files.is_empty() || self.history_index < self.history.len().saturating_sub(1)
                                                        ^2                   ^2
  ------------------
  |  Branch (1079:9): [True: 2, False: 2]
  ------------------
 1080|      4|    }
 1081|       |
 1082|       |    /// Request a reload of the current file (processed outside of input context)
 1083|      3|    fn request_reload(&mut self) {
 1084|      3|        if self.current_file.is_some() {
  ------------------
  |  Branch (1084:12): [True: 1, False: 2]
  ------------------
 1085|      1|            self.reload_requested = true;
 1086|      2|        } else {
 1087|      2|            self.error_message = Some("No file loaded to reload".to_string());
 1088|      2|        }
 1089|      3|    }
 1090|       |
 1091|       |    /// Reload the currently opened file from disk
 1092|      3|    pub fn reload_current_file(&mut self) -> Result<()> {
 1093|      3|        let path = if let Some(p) = self.current_file.clone() {
                          ^1                 ^1
  ------------------
  |  Branch (1093:27): [True: 1, False: 2]
  ------------------
 1094|      1|            p
 1095|       |        } else {
 1096|      2|            bail!("No file loaded to reload");
 1097|       |        };
 1098|      1|        self.load_file(path, false)
 1099|      3|    }
 1100|       |
 1101|       |    /// Load a sample file by name
 1102|     16|    pub fn load_sample(&mut self, sample: &SampleFile) {
 1103|       |        // Push current state to history before loading sample
 1104|     16|        if !self.current_content.is_empty() {
  ------------------
  |  Branch (1104:12): [True: 15, False: 1]
  ------------------
 1105|     15|            self.push_history();
 1106|     15|        }
                      ^1
 1107|       |
 1108|     16|        self.current_file = None;
 1109|       |        // Samples have no file base-dir
 1110|     16|        self.renderer.set_base_dir(None);
 1111|     16|        self.load_content(sample.content, Some(sample.title.to_string()));
 1112|       |        // Scroll to top for new sample
 1113|     16|        self.pending_scroll_to_element = Some(0);
 1114|     16|    }
 1115|       |
 1116|       |    /// Close the current file and return to welcome screen
 1117|      5|    pub fn close_current_file(&mut self) {
 1118|      5|        self.current_file = None;
 1119|      5|        self.renderer.set_base_dir(None);
 1120|      5|        if let Some(welcome) = SAMPLE_FILES.iter().find(|f| f.name == "welcome.md") {
  ------------------
  |  Branch (1120:16): [True: 5, False: 0]
  ------------------
 1121|      5|            self.load_content(welcome.content, Some("Welcome".to_string()));
 1122|      5|            self.pending_scroll_to_element = Some(0);
 1123|      5|        } else {
 1124|      0|            // Fallback if welcome file is missing
 1125|      0|            self.current_content.clear();
 1126|      0|            self.parsed_elements.clear();
 1127|      0|            self.title = APP_TITLE_PREFIX.to_string();
 1128|      0|            self.error_message = None;
 1129|      0|        }
 1130|      5|    }
 1131|       |
 1132|       |    #[cfg(not(test))]
 1133|       |    fn request_close(&self, ctx: &Context) {
 1134|       |        ctx.send_viewport_cmd(egui::ViewportCommand::Close);
 1135|       |    }
 1136|       |
 1137|       |    #[cfg(test)]
 1138|      2|    fn request_close(&self, _ctx: &Context) {}
 1139|       |
 1140|       |    #[cfg(not(test))]
 1141|       |    fn pick_open_path(&self) -> Option<PathBuf> {
 1142|       |        FileDialog::new()
 1143|       |            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
 1144|       |            .add_filter("All files", &["*"])
 1145|       |            .set_title("Open Markdown File")
 1146|       |            .pick_file()
 1147|       |    }
 1148|       |
 1149|       |    #[cfg(test)]
 1150|      7|    fn pick_open_path(&self) -> Option<PathBuf> {
 1151|      7|        take_forced_open_path()
 1152|      7|    }
 1153|       |
 1154|       |    #[cfg(not(test))]
 1155|       |    fn pick_save_path(&self) -> Option<PathBuf> {
 1156|       |        FileDialog::new()
 1157|       |            .set_title("Save Markdown File")
 1158|       |            .add_filter("Markdown files", &["md", "markdown", "mdown", "mkd"])
 1159|       |            .save_file()
 1160|       |    }
 1161|       |
 1162|       |    #[cfg(test)]
 1163|      3|    fn pick_save_path(&self) -> Option<PathBuf> {
 1164|      3|        take_forced_save_path()
 1165|      3|    }
 1166|       |
 1167|       |    /// Open file dialog to select a markdown file
 1168|      7|    fn open_file_dialog(&mut self) {
 1169|      7|        if let Some(path) = self.pick_open_path() {
                                  ^5
  ------------------
  |  Branch (1169:16): [True: 5, False: 2]
  ------------------
 1170|      5|            if let Err(e) = self.load_file(path, true) {
                                     ^1
  ------------------
  |  Branch (1170:20): [True: 1, False: 4]
  ------------------
 1171|      1|                self.error_message = Some(format!("Failed to open file: {}", e));
 1172|      4|            }
 1173|      2|        }
 1174|      7|    }
 1175|       |
 1176|       |    /// Toggle between Rendered and Raw view
 1177|      7|    fn toggle_view_mode(&mut self, ctx: &Context) {
 1178|       |        // If leaving Raw view while editing, capture cursor before switching
 1179|      7|        if matches!(self.view_mode, ViewMode::Raw) && self.write_enabled {
                         ^3                                         ^4
  ------------------
  |  Branch (1179:55): [True: 3, False: 1]
  ------------------
 1180|      3|            let editor_id = egui::Id::new("raw_editor");
 1181|      3|            if let Some(state) = egui::text_edit::TextEditState::load(ctx, editor_id) {
                                      ^1
  ------------------
  |  Branch (1181:20): [True: 1, False: 2]
  ------------------
 1182|      1|                if let Some(range) = state.cursor.char_range() {
  ------------------
  |  Branch (1182:24): [True: 1, False: 0]
  ------------------
 1183|      1|                    self.raw_cursor = Some(range.primary.index);
 1184|      1|                }
                              ^0
 1185|      2|            }
 1186|      4|        }
 1187|      7|        self.view_mode = match self.view_mode {
 1188|       |            ViewMode::Rendered => {
 1189|      3|                self.raw_focus_requested = true;
 1190|      3|                ViewMode::Raw
 1191|       |            }
 1192|      4|            ViewMode::Raw => ViewMode::Rendered,
 1193|       |        };
 1194|      7|    }
 1195|       |
 1196|       |    /// Handle keyboard shortcuts
 1197|     40|    fn handle_shortcuts(&mut self, ctx: &Context) {
 1198|     40|        ctx.input_mut(|i| {
 1199|     40|            let in_raw_edit = matches!(self.view_mode, ViewMode::Raw) && self.write_enabled;
                                            ^34                                        ^6
 1200|       |            // Ctrl+O - Open file
 1201|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1201:16): [True: 1, False: 39]
  ------------------
 1202|     40|                egui::Modifiers::CTRL,
 1203|     40|                egui::Key::O,
 1204|     40|            )) {
 1205|      1|                self.open_file_dialog();
 1206|     39|            }
 1207|       |
 1208|       |            // Alt-based accelerators for common actions (mnemonics)
 1209|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1209:16): [True: 1, False: 39]
  ------------------
 1210|     40|                egui::Modifiers::ALT,
 1211|     40|                egui::Key::O,
 1212|     40|            )) {
 1213|      1|                self.open_file_dialog();
 1214|     39|            }
 1215|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1215:16): [True: 1, False: 39]
  ------------------
 1216|     40|                egui::Modifiers::ALT,
 1217|     40|                egui::Key::W,
 1218|     40|            )) {
 1219|      1|                self.close_current_file();
 1220|     39|            }
 1221|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1221:16): [True: 1, False: 39]
  ------------------
 1222|     40|                egui::Modifiers::ALT,
 1223|     40|                egui::Key::Q,
 1224|     40|            )) {
 1225|      1|                self.request_close(ctx);
 1226|     39|            }
 1227|       |
 1228|       |            // Ctrl+Q - Quit application
 1229|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1229:16): [True: 1, False: 39]
  ------------------
 1230|     40|                egui::Modifiers::CTRL,
 1231|     40|                egui::Key::Q,
 1232|     40|            )) {
 1233|      1|                self.request_close(ctx);
 1234|     39|            }
 1235|       |
 1236|       |            // Ctrl+W - Close current file
 1237|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1237:16): [True: 1, False: 39]
  ------------------
 1238|     40|                egui::Modifiers::CTRL,
 1239|     40|                egui::Key::W,
 1240|     40|            )) {
 1241|      1|                self.close_current_file();
 1242|     39|            }
 1243|       |
 1244|       |            // Ctrl+F - Open search dialog
 1245|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1245:16): [True: 3, False: 37]
  ------------------
 1246|     40|                egui::Modifiers::CTRL,
 1247|     40|                egui::Key::F,
 1248|     40|            )) {
 1249|      3|                self.show_search = true;
 1250|      3|                if self.last_match_index.is_none() {
  ------------------
  |  Branch (1250:20): [True: 2, False: 1]
  ------------------
 1251|      2|                    self.last_match_index = Some(0);
 1252|      2|                }
                              ^1
 1253|      3|                self.search_focus_requested = true;
 1254|     37|            }
 1255|       |
 1256|       |            // F3 navigation: next / previous
 1257|     40|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F3) {
  ------------------
  |  Branch (1257:16): [True: 4, False: 36]
  ------------------
 1258|      4|                self.find_next();
 1259|     36|            }
 1260|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1260:16): [True: 0, False: 40]
  ------------------
 1261|     40|                egui::Modifiers::SHIFT,
 1262|     40|                egui::Key::F3,
 1263|     40|            )) || i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1263:19): [True: 0, False: 40]
  ------------------
 1264|     40|                egui::Modifiers::ALT,
 1265|     40|                egui::Key::F3,
 1266|     40|            )) {
 1267|      0|                self.find_previous();
 1268|     40|            }
 1269|       |
 1270|       |            // Ctrl+Plus - Zoom in
 1271|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1271:16): [True: 1, False: 39]
  ------------------
 1272|     40|                egui::Modifiers::CTRL,
 1273|     40|                egui::Key::Plus,
 1274|     40|            )) {
 1275|      1|                self.renderer.zoom_in();
 1276|     39|            }
 1277|       |
 1278|       |            // Ctrl+Minus - Zoom out
 1279|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1279:16): [True: 1, False: 39]
  ------------------
 1280|     40|                egui::Modifiers::CTRL,
 1281|     40|                egui::Key::Minus,
 1282|     40|            )) {
 1283|      1|                self.renderer.zoom_out();
 1284|     39|            }
 1285|       |
 1286|       |            // Ctrl+0 - Reset zoom
 1287|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1287:16): [True: 1, False: 39]
  ------------------
 1288|     40|                egui::Modifiers::CTRL,
 1289|     40|                egui::Key::Num0,
 1290|     40|            )) {
 1291|      1|                self.renderer.reset_zoom();
 1292|     39|            }
 1293|       |
 1294|       |            // Alt+Left - Navigate back
 1295|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1295:16): [True: 1, False: 39]
  ------------------
 1296|     40|                egui::Modifiers::ALT,
 1297|     40|                egui::Key::ArrowLeft,
 1298|     40|            )) {
 1299|      1|                self.navigate_back();
 1300|     39|            }
 1301|       |
 1302|       |            // Alt+Right - Navigate forward
 1303|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1303:16): [True: 1, False: 39]
  ------------------
 1304|     40|                egui::Modifiers::ALT,
 1305|     40|                egui::Key::ArrowRight,
 1306|     40|            )) {
 1307|      1|                self.navigate_forward();
 1308|     39|            }
 1309|       |
 1310|       |            // Ctrl + Mouse Wheel - Zoom
 1311|     40|            if i.modifiers.ctrl {
  ------------------
  |  Branch (1311:16): [True: 4, False: 36]
  ------------------
 1312|      4|                let mut total = 0.0f32;
 1313|      7|                for ev in &i.events {
                                  ^3
 1314|      3|                    if let egui::Event::MouseWheel { delta, .. } = ev {
  ------------------
  |  Branch (1314:28): [True: 3, False: 0]
  ------------------
 1315|      3|                        total += delta.y;
 1316|      3|                    }
                                  ^0
 1317|       |                }
 1318|      4|                if total.abs() > 0.0 {
  ------------------
  |  Branch (1318:20): [True: 3, False: 1]
  ------------------
 1319|      3|                    if total > 0.0 {
  ------------------
  |  Branch (1319:24): [True: 2, False: 1]
  ------------------
 1320|      2|                        self.renderer.zoom_in();
 1321|      2|                    } else if total < 0.0 {
                                            ^1
  ------------------
  |  Branch (1321:31): [True: 1, False: 0]
  ------------------
 1322|      1|                        self.renderer.zoom_out();
 1323|      1|                    }
                                  ^0
 1324|      1|                }
 1325|     36|            }
 1326|       |
 1327|       |            // Ctrl+R - Toggle raw view
 1328|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1328:16): [True: 1, False: 39]
  ------------------
 1329|     40|                egui::Modifiers::CTRL,
 1330|     40|                egui::Key::R,
 1331|     40|            )) {
 1332|      1|                // Defer to avoid acting inside input context
 1333|      1|                self.view_toggle_requested = true;
 1334|     39|            }
 1335|       |            // Ctrl+E - Toggle write mode (deferred)
 1336|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1336:16): [True: 1, False: 39]
  ------------------
 1337|     40|                egui::Modifiers::CTRL,
 1338|     40|                egui::Key::E,
 1339|     40|            )) {
 1340|      1|                self.write_toggle_requested = true;
 1341|     39|            }
 1342|       |            // Ctrl+S - Save document
 1343|     40|            if i.consume_shortcut(&egui::KeyboardShortcut::new(
  ------------------
  |  Branch (1343:16): [True: 2, False: 38]
  ------------------
 1344|     40|                egui::Modifiers::CTRL,
 1345|     40|                egui::Key::S,
 1346|     40|            )) {
 1347|      2|                if let Err(e) = self.save_current_document() {
                                         ^1
  ------------------
  |  Branch (1347:24): [True: 1, False: 1]
  ------------------
 1348|      1|                    self.error_message = Some(format!("Failed to save: {}", e));
 1349|      1|                }
 1350|     38|            }
 1351|       |            // Note: No global Alt+R to avoid conflict (File > Reload vs View > Raw)
 1352|       |
 1353|       |            // F11 - Toggle fullscreen (set flag to handle outside input context)
 1354|     40|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F11) {
  ------------------
  |  Branch (1354:16): [True: 1, False: 39]
  ------------------
 1355|      1|                self.toggle_fullscreen = true;
 1356|     39|            }
 1357|       |
 1358|       |            // F5 - Reload current file (set flag; actual IO handled outside input context)
 1359|     40|            if i.consume_key(egui::Modifiers::NONE, egui::Key::F5) {
  ------------------
  |  Branch (1359:16): [True: 1, False: 39]
  ------------------
 1360|      1|                self.request_reload();
 1361|     39|            }
 1362|       |
 1363|       |            // Esc - dismiss search dialog if visible
 1364|     40|            if self.show_search && i.consume_key(egui::Modifiers::NONE, egui::Key::Escape) {
                                                 ^5^5                                 ^5
  ------------------
  |  Branch (1364:16): [True: 5, False: 35]
  |  Branch (1364:36): [True: 1, False: 4]
  ------------------
 1365|      1|                self.clear_search_state();
 1366|      1|                self.show_search = false;
 1367|     39|            }
 1368|       |
 1369|       |            // Only consume navigation keys when not editing in raw view
 1370|     40|            if !in_raw_edit {
  ------------------
  |  Branch (1370:16): [True: 35, False: 5]
  ------------------
 1371|     35|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
  ------------------
  |  Branch (1371:20): [True: 1, False: 34]
  ------------------
 1372|      1|                    self.nav_request = Some(NavigationRequest::PageUp);
 1373|     34|                }
 1374|     35|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
  ------------------
  |  Branch (1374:20): [True: 1, False: 34]
  ------------------
 1375|      1|                    self.nav_request = Some(NavigationRequest::PageDown);
 1376|     34|                }
 1377|       |                // Home - Go to top of document
 1378|     35|                if i.consume_key(egui::Modifiers::NONE, egui::Key::Home) {
  ------------------
  |  Branch (1378:20): [True: 1, False: 34]
  ------------------
 1379|      1|                    self.nav_request = Some(NavigationRequest::Top);
 1380|     34|                }
 1381|       |
 1382|       |                // End - Go to bottom of document
 1383|     35|                if i.consume_key(egui::Modifiers::NONE, egui::Key::End) {
  ------------------
  |  Branch (1383:20): [True: 1, False: 34]
  ------------------
 1384|      1|                    self.nav_request = Some(NavigationRequest::Bottom);
 1385|     34|                }
 1386|       |
 1387|       |                // Arrow Up - Fine scroll up
 1388|     35|                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowUp) {
  ------------------
  |  Branch (1388:20): [True: 1, False: 34]
  ------------------
 1389|      1|                    self.nav_request = Some(NavigationRequest::ScrollUp);
 1390|     34|                }
 1391|       |
 1392|       |                // Arrow Down - Fine scroll down
 1393|     35|                if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowDown) {
  ------------------
  |  Branch (1393:20): [True: 1, False: 34]
  ------------------
 1394|      1|                    self.nav_request = Some(NavigationRequest::ScrollDown);
 1395|     34|                }
 1396|       |            } else {
 1397|       |                // In raw edit mode: implement PageUp/PageDown by moving caret by ~a page of lines
 1398|       |                const PAGE_LINES: i32 = 24; // match desired_rows for the editor
 1399|      5|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
  ------------------
  |  Branch (1399:20): [True: 1, False: 4]
  ------------------
 1400|      1|                    self.pending_raw_cursor_line_move = Some(-PAGE_LINES);
 1401|      1|                    self.raw_focus_requested = true;
 1402|      4|                }
 1403|      5|                if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
  ------------------
  |  Branch (1403:20): [True: 1, False: 4]
  ------------------
 1404|      1|                    self.pending_raw_cursor_line_move = Some(PAGE_LINES);
 1405|      1|                    self.raw_focus_requested = true;
 1406|      4|                }
 1407|       |            }
 1408|     40|        });
 1409|     40|    }
 1410|       |
 1411|      4|    fn render_file_menu_contents(
 1412|      4|        &mut self,
 1413|      4|        ui: &mut egui::Ui,
 1414|      4|        alt_pressed: bool,
 1415|      4|        menu_text_color: Color32,
 1416|      4|    ) {
 1417|      4|        ui.horizontal(|ui| {
 1418|      4|            let clicked = ui
 1419|      4|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1420|      4|                    None,
 1421|      4|                    "Open...",
 1422|      4|                    'O',
 1423|      4|                    alt_pressed,
 1424|      4|                    menu_text_color,
 1425|      4|                )))
 1426|      4|                .clicked();
 1427|      4|            if app_action_triggered(clicked, "menu_open") {
  ------------------
  |  Branch (1427:16): [True: 2, False: 2]
  ------------------
 1428|      2|                self.open_file_dialog();
 1429|      2|                ui.close_menu();
 1430|      2|            }
 1431|      4|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1432|      4|                ui.label(RichText::new("Ctrl+O").color(menu_text_color));
 1433|      4|            });
 1434|      4|        });
 1435|       |
 1436|      4|        ui.horizontal(|ui| {
 1437|      4|            let enabled = !self.current_content.is_empty();
 1438|      4|            let button = ui.add_enabled(
 1439|      4|                enabled,
 1440|      4|                egui::Button::new(Self::menu_text_with_mnemonic(
 1441|      4|                    None,
 1442|      4|                    "Save",
 1443|       |                    'S',
 1444|      4|                    alt_pressed,
 1445|      4|                    menu_text_color,
 1446|       |                )),
 1447|       |            );
 1448|      4|            if app_action_triggered(button.clicked(), "menu_save") {
  ------------------
  |  Branch (1448:16): [True: 3, False: 1]
  ------------------
 1449|      3|                if let Err(e) = self.save_current_document() {
                                         ^1
  ------------------
  |  Branch (1449:24): [True: 1, False: 2]
  ------------------
 1450|      1|                    self.error_message = Some(format!("Failed to save: {}", e));
 1451|      2|                }
 1452|      3|                ui.close_menu();
 1453|      1|            }
 1454|      4|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1455|      4|                ui.label(RichText::new("Ctrl+S").color(menu_text_color));
 1456|      4|            });
 1457|      4|        });
 1458|       |
 1459|      4|        ui.horizontal(|ui| {
 1460|      4|            let clicked = ui
 1461|      4|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1462|      4|                    None,
 1463|      4|                    "Close",
 1464|      4|                    'C',
 1465|      4|                    alt_pressed,
 1466|      4|                    menu_text_color,
 1467|      4|                )))
 1468|      4|                .clicked();
 1469|      4|            if app_action_triggered(clicked, "menu_close") {
  ------------------
  |  Branch (1469:16): [True: 2, False: 2]
  ------------------
 1470|      2|                self.close_current_file();
 1471|      2|                ui.close_menu();
 1472|      2|            }
 1473|      4|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1474|      4|                ui.label(RichText::new("Ctrl+W").color(menu_text_color));
 1475|      4|            });
 1476|      4|        });
 1477|       |
 1478|      4|        ui.horizontal(|ui| {
 1479|      4|            let enabled = self.current_file.is_some();
 1480|      4|            let button = ui.add_enabled(
 1481|      4|                enabled,
 1482|      4|                egui::Button::new(Self::menu_text_with_mnemonic(
 1483|      4|                    None,
 1484|      4|                    "Reload",
 1485|       |                    'R',
 1486|      4|                    alt_pressed,
 1487|      4|                    menu_text_color,
 1488|       |                )),
 1489|       |            );
 1490|      4|            if app_action_triggered(button.clicked(), "menu_reload") {
  ------------------
  |  Branch (1490:16): [True: 2, False: 2]
  ------------------
 1491|      2|                self.request_reload();
 1492|      2|                ui.close_menu();
 1493|      2|            }
 1494|      4|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1495|      4|                ui.label(RichText::new("F5").color(menu_text_color));
 1496|      4|            });
 1497|      4|        });
 1498|       |
 1499|      4|        ui.horizontal(|ui| {
 1500|      4|            let clicked = ui
 1501|      4|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1502|      4|                    None,
 1503|      4|                    "Find...",
 1504|      4|                    'F',
 1505|      4|                    alt_pressed,
 1506|      4|                    menu_text_color,
 1507|      4|                )))
 1508|      4|                .clicked();
 1509|      4|            if app_action_triggered(clicked, "menu_find") {
  ------------------
  |  Branch (1509:16): [True: 2, False: 2]
  ------------------
 1510|      2|                self.show_search = true;
 1511|      2|                self.search_focus_requested = true;
 1512|      2|                ui.close_menu();
 1513|      2|            }
 1514|      4|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1515|      4|                ui.label(RichText::new("Ctrl+F").color(menu_text_color));
 1516|      4|            });
 1517|      4|        });
 1518|       |
 1519|      4|        ui.separator();
 1520|       |
 1521|      4|        ui.menu_button(
 1522|      4|            Self::menu_text_with_mnemonic(None, "Samples", 'S', alt_pressed, menu_text_color),
 1523|      0|            |ui| {
 1524|      0|                self.render_samples_menu_contents(ui);
 1525|      0|            },
 1526|       |        );
 1527|      4|        if app_action_triggered(false, "menu_samples") {
  ------------------
  |  Branch (1527:12): [True: 2, False: 2]
  ------------------
 1528|      2|            self.render_samples_menu_contents(ui);
 1529|      2|        }
 1530|      4|    }
 1531|       |
 1532|      2|    fn render_samples_menu_contents(&mut self, ui: &mut egui::Ui) {
 1533|     14|        for sample in SAMPLE_FILES {
                          ^12
 1534|     12|            if app_action_triggered(ui.button(sample.title).clicked(), sample.name) {
  ------------------
  |  Branch (1534:16): [True: 4, False: 8]
  ------------------
 1535|      4|                self.load_sample(sample);
 1536|      4|                ui.close_menu();
 1537|      8|            }
 1538|       |        }
 1539|      2|    }
 1540|       |
 1541|      3|    fn render_view_menu_contents(
 1542|      3|        &mut self,
 1543|      3|        ui: &mut egui::Ui,
 1544|      3|        ctx: &Context,
 1545|      3|        alt_pressed: bool,
 1546|      3|        menu_text_color: Color32,
 1547|      3|    ) {
 1548|      3|        ui.horizontal(|ui| {
 1549|      3|            let enabled = self.can_navigate_back();
 1550|      3|            let clicked = ui
 1551|      3|                .add_enabled(enabled, egui::Button::new("<- Back"))
 1552|      3|                .clicked();
 1553|      3|            if app_action_triggered(clicked, "menu_back") {
  ------------------
  |  Branch (1553:16): [True: 2, False: 1]
  ------------------
 1554|      2|                self.navigate_back();
 1555|      2|                ui.close_menu();
 1556|      2|            }
                          ^1
 1557|      3|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1558|      3|                ui.label(RichText::new("Alt+Left").color(menu_text_color));
 1559|      3|            });
 1560|      3|        });
 1561|       |
 1562|      3|        ui.horizontal(|ui| {
 1563|      3|            let enabled = self.can_navigate_forward();
 1564|      3|            let clicked = ui
 1565|      3|                .add_enabled(enabled, egui::Button::new("Forward ->"))
 1566|      3|                .clicked();
 1567|      3|            if app_action_triggered(clicked, "menu_forward") {
  ------------------
  |  Branch (1567:16): [True: 2, False: 1]
  ------------------
 1568|      2|                self.navigate_forward();
 1569|      2|                ui.close_menu();
 1570|      2|            }
                          ^1
 1571|      3|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1572|      3|                ui.label(RichText::new("Alt+Right").color(menu_text_color));
 1573|      3|            });
 1574|      3|        });
 1575|       |
 1576|      3|        ui.separator();
 1577|       |
 1578|      3|        ui.horizontal(|ui| {
 1579|      3|            let selected = matches!(self.view_mode, ViewMode::Raw);
                                         ^2
 1580|      3|            let clicked = ui
 1581|      3|                .add(egui::SelectableLabel::new(
 1582|      3|                    selected,
 1583|      3|                    Self::menu_text_with_mnemonic(
 1584|      3|                        None,
 1585|      3|                        "Raw Markdown",
 1586|      3|                        'R',
 1587|      3|                        alt_pressed,
 1588|      3|                        menu_text_color,
 1589|      3|                    ),
 1590|      3|                ))
 1591|      3|                .clicked();
 1592|      3|            if app_action_triggered(clicked, "menu_raw") {
  ------------------
  |  Branch (1592:16): [True: 2, False: 1]
  ------------------
 1593|      2|                self.toggle_view_mode(ctx);
 1594|      2|                ui.close_menu();
 1595|      2|            }
                          ^1
 1596|      3|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1597|      3|                ui.label(RichText::new("Ctrl+R").color(menu_text_color));
 1598|      3|            });
 1599|      3|        });
 1600|       |
 1601|      3|        ui.horizontal(|ui| {
 1602|      3|            let selected = self.write_enabled;
 1603|      3|            let clicked = ui
 1604|      3|                .add(egui::SelectableLabel::new(
 1605|      3|                    selected,
 1606|      3|                    Self::menu_text_with_mnemonic(
 1607|      3|                        None,
 1608|      3|                        "Write Mode",
 1609|      3|                        'W',
 1610|      3|                        alt_pressed,
 1611|      3|                        menu_text_color,
 1612|      3|                    ),
 1613|      3|                ))
 1614|      3|                .clicked();
 1615|      3|            if app_action_triggered(clicked, "menu_write") {
  ------------------
  |  Branch (1615:16): [True: 2, False: 1]
  ------------------
 1616|      2|                self.toggle_write_mode(ctx);
 1617|      2|                ui.close_menu();
 1618|      2|            }
                          ^1
 1619|      3|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1620|      3|                ui.label(RichText::new("Ctrl+E").color(menu_text_color));
 1621|      3|            });
 1622|      3|        });
 1623|       |
 1624|      3|        ui.horizontal(|ui| {
 1625|      3|            let clicked = ui
 1626|      3|                .add(egui::SelectableLabel::new(
 1627|      3|                    self.wrap_raw,
 1628|      3|                    Self::menu_text_with_mnemonic(
 1629|      3|                        None,
 1630|      3|                        "Wrap Raw Lines",
 1631|      3|                        'L',
 1632|      3|                        alt_pressed,
 1633|      3|                        menu_text_color,
 1634|      3|                    ),
 1635|      3|                ))
 1636|      3|                .clicked();
 1637|      3|            if app_action_triggered(clicked, "menu_wrap_raw") {
  ------------------
  |  Branch (1637:16): [True: 2, False: 1]
  ------------------
 1638|      2|                self.wrap_raw = !self.wrap_raw;
 1639|      2|            }
                          ^1
 1640|      3|        });
 1641|       |
 1642|      3|        ui.horizontal(|ui| {
 1643|      3|            let clicked = ui
 1644|      3|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1645|      3|                    None,
 1646|      3|                    "Zoom In",
 1647|      3|                    'I',
 1648|      3|                    alt_pressed,
 1649|      3|                    menu_text_color,
 1650|      3|                )))
 1651|      3|                .clicked();
 1652|      3|            if app_action_triggered(clicked, "menu_zoom_in") {
  ------------------
  |  Branch (1652:16): [True: 2, False: 1]
  ------------------
 1653|      2|                self.renderer.zoom_in();
 1654|      2|                ui.close_menu();
 1655|      2|            }
                          ^1
 1656|      3|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1657|      3|                ui.label(RichText::new("Ctrl++").color(menu_text_color));
 1658|      3|            });
 1659|      3|        });
 1660|       |
 1661|      3|        ui.horizontal(|ui| {
 1662|      3|            let clicked = ui
 1663|      3|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1664|      3|                    None,
 1665|      3|                    "Zoom Out",
 1666|      3|                    'O',
 1667|      3|                    alt_pressed,
 1668|      3|                    menu_text_color,
 1669|      3|                )))
 1670|      3|                .clicked();
 1671|      3|            if app_action_triggered(clicked, "menu_zoom_out") {
  ------------------
  |  Branch (1671:16): [True: 2, False: 1]
  ------------------
 1672|      2|                self.renderer.zoom_out();
 1673|      2|                ui.close_menu();
 1674|      2|            }
                          ^1
 1675|      3|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1676|      3|                ui.label(RichText::new("Ctrl+-").color(menu_text_color));
 1677|      3|            });
 1678|      3|        });
 1679|       |
 1680|      3|        ui.horizontal(|ui| {
 1681|      3|            let clicked = ui
 1682|      3|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1683|      3|                    None,
 1684|      3|                    "Reset Zoom",
 1685|      3|                    'Z',
 1686|      3|                    alt_pressed,
 1687|      3|                    menu_text_color,
 1688|      3|                )))
 1689|      3|                .clicked();
 1690|      3|            if app_action_triggered(clicked, "menu_zoom_reset") {
  ------------------
  |  Branch (1690:16): [True: 2, False: 1]
  ------------------
 1691|      2|                self.renderer.reset_zoom();
 1692|      2|                ui.close_menu();
 1693|      2|            }
                          ^1
 1694|      3|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1695|      3|                ui.label(RichText::new("Ctrl+0").color(menu_text_color));
 1696|      3|            });
 1697|      3|        });
 1698|       |
 1699|      3|        ui.separator();
 1700|       |
 1701|      3|        ui.horizontal(|ui| {
 1702|      3|            let clicked = ui
 1703|      3|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1704|      3|                    None,
 1705|      3|                    "Toggle Fullscreen",
 1706|      3|                    'T',
 1707|      3|                    alt_pressed,
 1708|      3|                    menu_text_color,
 1709|      3|                )))
 1710|      3|                .clicked();
 1711|      3|            if app_action_triggered(clicked, "menu_fullscreen") {
  ------------------
  |  Branch (1711:16): [True: 2, False: 1]
  ------------------
 1712|      2|                let is_fullscreen = ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
 1713|      2|                ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(!is_fullscreen));
 1714|      2|                ui.close_menu();
 1715|      1|            }
 1716|      3|            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1717|      3|                ui.label(RichText::new("F11").color(menu_text_color));
 1718|      3|            });
 1719|      3|        });
 1720|      3|    }
 1721|       |
 1722|      3|    fn render_help_menu_contents(
 1723|      3|        &mut self,
 1724|      3|        ui: &mut egui::Ui,
 1725|      3|        alt_pressed: bool,
 1726|      3|        menu_text_color: Color32,
 1727|      3|    ) {
 1728|      3|        ui.horizontal(|ui| {
 1729|      3|            let clicked = ui
 1730|      3|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1731|      3|                    None,
 1732|      3|                    "Usage Instructions",
 1733|      3|                    'U',
 1734|      3|                    alt_pressed,
 1735|      3|                    menu_text_color,
 1736|      3|                )))
 1737|      3|                .clicked();
 1738|      3|            if app_action_triggered(clicked, "menu_help_usage") {
  ------------------
  |  Branch (1738:16): [True: 2, False: 1]
  ------------------
 1739|      8|                if let Some(usage) = SAMPLE_FILES.iter().find(|f| f.name == "usage.md") {
                                          ^2       ^2                  ^2
  ------------------
  |  Branch (1739:24): [True: 2, False: 0]
  ------------------
 1740|      2|                    self.load_sample(usage);
 1741|      2|                }
                              ^0
 1742|      2|                ui.close_menu();
 1743|      1|            }
 1744|      3|        });
 1745|       |
 1746|      3|        ui.horizontal(|ui| {
 1747|      3|            let clicked = ui
 1748|      3|                .add(egui::Button::new(Self::menu_text_with_mnemonic(
 1749|      3|                    None,
 1750|      3|                    "About",
 1751|      3|                    'A',
 1752|      3|                    alt_pressed,
 1753|      3|                    menu_text_color,
 1754|      3|                )))
 1755|      3|                .clicked();
 1756|      3|            if app_action_triggered(clicked, "menu_help_about") {
  ------------------
  |  Branch (1756:16): [True: 2, False: 1]
  ------------------
 1757|      2|                if let Some(welcome) = SAMPLE_FILES.iter().find(|f| f.name == "welcome.md") {
  ------------------
  |  Branch (1757:24): [True: 2, False: 0]
  ------------------
 1758|      2|                    self.load_sample(welcome);
 1759|      2|                }
                              ^0
 1760|      2|                ui.close_menu();
 1761|      1|            }
 1762|      3|        });
 1763|      3|    }
 1764|       |
 1765|       |    /// Render the menu bar
 1766|     19|    fn render_menu_bar(&mut self, ctx: &Context) {
 1767|     19|        TopBottomPanel::top("menu_bar").show(ctx, |ui| {
 1768|     19|            let alt_pressed = ui.input(|i| i.modifiers.alt);
 1769|     19|            let menu_text_color = if ui.visuals().dark_mode {
  ------------------
  |  Branch (1769:38): [True: 19, False: 0]
  ------------------
 1770|     19|                Color32::WHITE
 1771|       |            } else {
 1772|      0|                Color32::BLACK
 1773|       |            };
 1774|     19|            menu::bar(ui, |ui| {
 1775|       |                // File menu (Alt+F mnemonic visual)
 1776|     19|                ui.menu_button(
 1777|     19|                    Self::menu_text_with_mnemonic(None, "File", 'F', alt_pressed, menu_text_color),
 1778|      0|                    |ui| {
 1779|      0|                        self.render_file_menu_contents(ui, alt_pressed, menu_text_color);
 1780|      0|                    },
 1781|       |                );
 1782|     19|                if app_action_triggered(false, "menu_bar_file") {
  ------------------
  |  Branch (1782:20): [True: 1, False: 18]
  ------------------
 1783|      1|                    self.render_file_menu_contents(ui, alt_pressed, menu_text_color);
 1784|     18|                }
 1785|       |
 1786|       |                // View menu
 1787|     19|                ui.menu_button(
 1788|     19|                    Self::menu_text_with_mnemonic(None, "View", 'V', alt_pressed, menu_text_color),
 1789|      0|                    |ui| {
 1790|      0|                        self.render_view_menu_contents(ui, ctx, alt_pressed, menu_text_color);
 1791|      0|                    },
 1792|       |                );
 1793|     19|                if app_action_triggered(false, "menu_bar_view") {
  ------------------
  |  Branch (1793:20): [True: 1, False: 18]
  ------------------
 1794|      1|                    self.render_view_menu_contents(ui, ctx, alt_pressed, menu_text_color);
 1795|     18|                }
 1796|       |
 1797|     19|                ui.menu_button(
 1798|     19|                    Self::menu_text_with_mnemonic(None, "Help", 'H', alt_pressed, menu_text_color),
 1799|      0|                    |ui| {
 1800|      0|                        self.render_help_menu_contents(ui, alt_pressed, menu_text_color);
 1801|      0|                    },
 1802|       |                );
 1803|     19|                if app_action_triggered(false, "menu_bar_help") {
  ------------------
  |  Branch (1803:20): [True: 1, False: 18]
  ------------------
 1804|      1|                    self.render_help_menu_contents(ui, alt_pressed, menu_text_color);
 1805|     18|                }
 1806|     19|            });
 1807|     19|        });
 1808|       |
 1809|       |        // No programmatic overlay menus; rely on pointer to open egui menus.
 1810|     19|    }
 1811|       |
 1812|      1|    fn render_main_context_menu(&mut self, ui: &mut egui::Ui) {
 1813|      1|        ui.label("Select text, then use Ctrl+C to copy");
 1814|      1|        ui.separator();
 1815|       |
 1816|       |        // Copy All Text option
 1817|      1|        if app_action_triggered(ui.button("Copy All Text").clicked(), "ctx_copy_all") {
  ------------------
  |  Branch (1817:12): [True: 1, False: 0]
  ------------------
 1818|      1|            let all_text = MarkdownRenderer::elements_to_plain_text(&self.parsed_elements);
 1819|      1|            ui.ctx().copy_text(all_text);
 1820|      1|            ui.close_menu();
 1821|      1|        }
                      ^0
 1822|       |
 1823|       |        // Copy as Markdown (Raw) option
 1824|      1|        if app_action_triggered(ui.button("Copy as Markdown").clicked(), "ctx_copy_markdown") {
  ------------------
  |  Branch (1824:12): [True: 1, False: 0]
  ------------------
 1825|      1|            ui.ctx().copy_text(self.current_content.clone());
 1826|      1|            ui.close_menu();
 1827|      1|        }
                      ^0
 1828|       |
 1829|      1|        ui.separator();
 1830|       |
 1831|       |        // Navigation shortcuts
 1832|      1|        if app_action_triggered(ui.button("Go to Top").clicked(), "ctx_nav_top") {
  ------------------
  |  Branch (1832:12): [True: 1, False: 0]
  ------------------
 1833|      1|            self.nav_request = Some(NavigationRequest::Top);
 1834|      1|            ui.close_menu();
 1835|      1|        }
                      ^0
 1836|       |
 1837|      1|        if app_action_triggered(ui.button("Go to Bottom").clicked(), "ctx_nav_bottom") {
  ------------------
  |  Branch (1837:12): [True: 1, False: 0]
  ------------------
 1838|      1|            self.nav_request = Some(NavigationRequest::Bottom);
 1839|      1|            ui.close_menu();
 1840|      1|        }
                      ^0
 1841|      1|    }
 1842|       |    /// Render the status bar
 1843|     22|    fn render_status_bar(&self, ctx: &Context) {
 1844|     22|        TopBottomPanel::bottom("status_bar").show(ctx, |ui| {
 1845|     22|            ui.horizontal(|ui| {
 1846|       |                // Current file info
 1847|     22|                if let Some(path) = &self.current_file {
                                          ^2
  ------------------
  |  Branch (1847:24): [True: 2, False: 20]
  ------------------
 1848|      2|                    ui.label(format!("File: {}", path.display()));
 1849|     20|                } else if !self.parsed_elements.is_empty() {
  ------------------
  |  Branch (1849:27): [True: 19, False: 1]
  ------------------
 1850|     19|                    ui.label("Sample file");
 1851|     19|                } else {
 1852|      1|                    ui.label("No file loaded");
 1853|      1|                }
 1854|       |
 1855|     22|                if let Some(pending) = &self.pending_file_load {
                                          ^0
  ------------------
  |  Branch (1855:24): [True: 0, False: 22]
  ------------------
 1856|      0|                    ui.separator();
 1857|      0|                    ui.label(
 1858|      0|                        RichText::new(format!("Loading {}", pending.path.display()))
 1859|      0|                            .color(Color32::from_rgb(120, 200, 255)),
 1860|      0|                    );
 1861|     22|                }
 1862|       |
 1863|       |                // Show pending file count if files are queued
 1864|     22|                if !self.pending_files.is_empty() {
  ------------------
  |  Branch (1864:20): [True: 1, False: 21]
  ------------------
 1865|      1|                    ui.separator();
 1866|      1|                    ui.label(
 1867|      1|                        RichText::new(format!("{} files in queue", self.pending_files.len()))
 1868|      1|                            .color(egui::Color32::from_rgb(100, 150, 255)),
 1869|      1|                    );
 1870|      1|
 1871|      1|                    ui.label(
 1872|      1|                        RichText::new("(Alt+Right for next)")
 1873|      1|                            .color(egui::Color32::GRAY)
 1874|      1|                            .italics(),
 1875|      1|                    );
 1876|     21|                }
 1877|       |
 1878|     22|                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
 1879|       |                    // Document stats
 1880|     22|                    let element_count = self.parsed_elements.len();
 1881|     22|                    let char_count = self.current_content.len();
 1882|     22|                    let mode = match self.view_mode {
 1883|     16|                        ViewMode::Rendered => "Rendered",
 1884|      6|                        ViewMode::Raw => "Raw",
 1885|       |                    };
 1886|     22|                    let status = format!(
 1887|     22|                        "Mode: {} | Elements: {} | Characters: {}",
 1888|       |                        mode, element_count, char_count
 1889|       |                    );
 1890|     22|                    ui.label(status)
 1891|     22|                        .on_hover_ui(|ui| self.render_status_tooltip(ui));
                                                        ^0   ^0                    ^0
 1892|     22|                    if app_action_triggered(false, "status_hover") {
  ------------------
  |  Branch (1892:24): [True: 2, False: 20]
  ------------------
 1893|      2|                        self.render_status_tooltip(ui);
 1894|     20|                    }
 1895|     22|                });
 1896|     22|            });
 1897|     22|        });
 1898|     22|    }
 1899|       |
 1900|      2|    fn render_status_tooltip(&self, ui: &mut egui::Ui) {
 1901|      2|        ui.label(format!("Version: {}", BUILD_VERSION));
 1902|      2|        ui.label(format!("Built: {}", BUILD_TIMESTAMP));
 1903|      2|    }
 1904|       |    /// Handle drag-drop events from egui
 1905|     18|    fn handle_drag_drop_events(&mut self, ctx: &Context) {
 1906|     18|        ctx.input(|i| {
 1907|       |            // Check if files are being hovered
 1908|     18|            self.drag_hover = !i.raw.hovered_files.is_empty();
 1909|       |
 1910|       |            // Check if files were dropped
 1911|     18|            if !i.raw.dropped_files.is_empty() {
  ------------------
  |  Branch (1911:16): [True: 1, False: 17]
  ------------------
 1912|      1|                let paths: Vec<PathBuf> = i
 1913|      1|                    .raw
 1914|      1|                    .dropped_files
 1915|      1|                    .iter()
 1916|      1|                    .filter_map(|f| f.path.clone())
 1917|      1|                    .collect();
 1918|       |
 1919|      1|                self.handle_file_drop(paths);
 1920|     17|            }
 1921|     18|        });
 1922|     18|    }
 1923|       |
 1924|       |    /// Render drag-and-drop overlay when files are hovered
 1925|     19|    fn render_drag_overlay(&self, ctx: &Context) {
 1926|     19|        if !self.drag_hover {
  ------------------
  |  Branch (1926:12): [True: 17, False: 2]
  ------------------
 1927|     17|            return;
 1928|      2|        }
 1929|       |
 1930|       |        // Full-screen overlay
 1931|      2|        egui::Area::new(egui::Id::new("drag_overlay"))
 1932|      2|            .fixed_pos(egui::pos2(0.0, 0.0))
 1933|      2|            .order(egui::Order::Foreground)
 1934|      2|            .show(ctx, |ui| {
 1935|      2|                let screen_rect = ctx.screen_rect();
 1936|       |
 1937|       |                // Semi-transparent dark background
 1938|      2|                ui.painter()
 1939|      2|                    .rect_filled(screen_rect, 0.0, egui::Color32::from_black_alpha(180));
 1940|       |
 1941|       |                // Dashed border effect using rounded rect with stroke
 1942|      2|                let border_rect = screen_rect.shrink(20.0);
 1943|      2|                let border_color = egui::Color32::from_rgb(100, 150, 255);
 1944|       |
 1945|       |                // Draw border
 1946|      2|                ui.painter()
 1947|      2|                    .rect_stroke(border_rect, 8.0, egui::Stroke::new(4.0, border_color));
 1948|       |
 1949|       |                // Center text
 1950|      2|                ui.allocate_ui_at_rect(screen_rect, |ui| {
 1951|      2|                    ui.vertical_centered(|ui| {
 1952|      2|                        ui.add_space(screen_rect.height() / 2.0 - 80.0);
 1953|       |
 1954|       |                        // Main message
 1955|      2|                        ui.label(
 1956|      2|                            RichText::new("Drop files to open")
 1957|      2|                                .size(36.0)
 1958|      2|                                .color(egui::Color32::WHITE)
 1959|      2|                                .strong(),
 1960|       |                        );
 1961|       |
 1962|      2|                        ui.add_space(20.0);
 1963|       |
 1964|       |                        // Supported formats
 1965|      2|                        ui.label(
 1966|      2|                            RichText::new("Supported: .md, .markdown, .mdown, .mkd, .txt")
 1967|      2|                                .size(18.0)
 1968|      2|                                .color(egui::Color32::LIGHT_GRAY),
 1969|       |                        );
 1970|       |
 1971|      2|                        ui.add_space(10.0);
 1972|       |
 1973|       |                        // Additional hint
 1974|      2|                        ui.label(
 1975|      2|                            RichText::new("Drop multiple files to open them in sequence")
 1976|      2|                                .size(14.0)
 1977|      2|                                .color(egui::Color32::from_rgb(150, 150, 150))
 1978|      2|                                .italics(),
 1979|       |                        );
 1980|      2|                    });
 1981|      2|                });
 1982|      2|            });
 1983|     19|    }
 1984|       |
 1985|     20|    fn update_impl(&mut self, ctx: &Context) {
 1986|     20|        self.handle_screenshot_events(ctx);
 1987|     20|        self.poll_file_loads();
 1988|     20|        if self.screenshot.as_ref().is_some_and(|state| state.done) {
  ------------------
  |  Branch (1988:12): [True: 1, False: 19]
  ------------------
 1989|      1|            return;
 1990|     19|        }
 1991|       |
 1992|     19|        let screenshot_active = self.screenshot.is_some();
 1993|     19|        let hide_chrome = screenshot_active;
 1994|       |
 1995|       |        // Handle drag-drop events
 1996|     19|        if !screenshot_active {
  ------------------
  |  Branch (1996:12): [True: 18, False: 1]
  ------------------
 1997|     18|            self.handle_drag_drop_events(ctx);
 1998|     18|        }
                      ^1
 1999|       |
 2000|       |        // Handle keyboard shortcuts
 2001|     19|        if !screenshot_active {
  ------------------
  |  Branch (2001:12): [True: 18, False: 1]
  ------------------
 2002|     18|            self.handle_shortcuts(ctx);
 2003|     18|        }
                      ^1
 2004|       |
 2005|       |        // Keep native window title in sync with the current document
 2006|     19|        ctx.send_viewport_cmd(egui::ViewportCommand::Title(self.title.clone()));
 2007|       |
 2008|     19|        let (monitor_size, outer_rect, inner_rect, is_fullscreen, is_maximized) = ctx.input(|i| {
 2009|     19|            let vp = i.viewport();
 2010|     19|            (
 2011|     19|                vp.monitor_size,
 2012|     19|                vp.outer_rect,
 2013|     19|                vp.inner_rect,
 2014|     19|                vp.fullscreen.unwrap_or(false),
 2015|     19|                vp.maximized.unwrap_or(false),
 2016|     19|            )
 2017|     19|        });
 2018|       |
 2019|     19|        let mut pos_adjusted = false;
 2020|     19|        let mut size_adjusted = false;
 2021|     19|        if !is_fullscreen {
  ------------------
  |  Branch (2021:12): [True: 19, False: 0]
  ------------------
 2022|      2|            if let Some(adjustment) =
  ------------------
  |  Branch (2022:20): [True: 2, False: 17]
  ------------------
 2023|     19|                Self::compute_window_adjustment(outer_rect, inner_rect, monitor_size)
 2024|       |            {
 2025|      2|                if let Some(pos) = adjustment.pos {
                                          ^1
  ------------------
  |  Branch (2025:24): [True: 1, False: 1]
  ------------------
 2026|      1|                    pos_adjusted = true;
 2027|      1|                    ctx.send_viewport_cmd(egui::ViewportCommand::OuterPosition(pos));
 2028|      1|                    self.last_window_pos = Some([pos.x, pos.y]);
 2029|      1|                }
 2030|      2|                if let Some(size) = adjustment.size {
                                          ^1
  ------------------
  |  Branch (2030:24): [True: 1, False: 1]
  ------------------
 2031|      1|                    size_adjusted = true;
 2032|      1|                    ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(size));
 2033|      1|                    self.last_window_size = Some([size.x, size.y]);
 2034|      1|                }
 2035|     17|            }
 2036|      0|        }
 2037|       |
 2038|     19|        if !pos_adjusted {
  ------------------
  |  Branch (2038:12): [True: 18, False: 1]
  ------------------
 2039|     18|            if let Some(outer) = outer_rect {
                                      ^1
  ------------------
  |  Branch (2039:20): [True: 1, False: 17]
  ------------------
 2040|      1|                self.last_window_pos = Some([outer.left(), outer.top()]);
 2041|     17|            }
 2042|      1|        }
 2043|     19|        if !size_adjusted && !is_fullscreen {
                                           ^18
  ------------------
  |  Branch (2043:12): [True: 18, False: 1]
  |  Branch (2043:30): [True: 18, False: 0]
  ------------------
 2044|     18|            if let Some(inner) = inner_rect {
                                      ^1
  ------------------
  |  Branch (2044:20): [True: 1, False: 17]
  ------------------
 2045|      1|                self.last_window_size = Some([inner.width(), inner.height()]);
 2046|     17|            }
 2047|      1|        }
 2048|     19|        self.last_window_maximized = is_maximized;
 2049|       |
 2050|       |        // Opportunistically persist window state if it changed, throttled to once per second
 2051|     19|        if self.should_persist_window_state() {
  ------------------
  |  Branch (2051:12): [True: 0, False: 19]
  ------------------
 2052|      0|            self.persist_window_state();
 2053|      0|            self.last_persist_instant = std::time::Instant::now();
 2054|     19|        }
 2055|       |
 2056|       |        // Handle fullscreen toggle outside input context to avoid deadlocks
 2057|     19|        if self.toggle_fullscreen {
  ------------------
  |  Branch (2057:12): [True: 1, False: 18]
  ------------------
 2058|      1|            self.toggle_fullscreen = false;
 2059|      1|            let current_fullscreen = ctx.input(|i| i.viewport().fullscreen.unwrap_or(false));
 2060|      1|            ctx.send_viewport_cmd(egui::ViewportCommand::Fullscreen(!current_fullscreen));
 2061|     18|        }
 2062|       |
 2063|       |        // Handle deferred view toggle outside of input context
 2064|     19|        if self.view_toggle_requested {
  ------------------
  |  Branch (2064:12): [True: 1, False: 18]
  ------------------
 2065|      1|            self.view_toggle_requested = false;
 2066|      1|            self.toggle_view_mode(ctx);
 2067|     18|        }
 2068|       |
 2069|       |        // Handle deferred write toggle outside of input context
 2070|     19|        if self.write_toggle_requested {
  ------------------
  |  Branch (2070:12): [True: 1, False: 18]
  ------------------
 2071|      1|            self.write_toggle_requested = false;
 2072|      1|            self.toggle_write_mode(ctx);
 2073|     18|        }
 2074|       |
 2075|       |        // Handle deferred caret movement for raw editor
 2076|     19|        if let Some(delta) = self.pending_raw_cursor_line_move.take() {
                                  ^1
  ------------------
  |  Branch (2076:16): [True: 1, False: 18]
  ------------------
 2077|      1|            self.move_raw_cursor_lines(ctx, delta);
 2078|     18|        }
 2079|       |
 2080|       |        // Handle reload request outside input context to avoid blocking within input handling
 2081|     19|        if self.reload_requested {
  ------------------
  |  Branch (2081:12): [True: 1, False: 18]
  ------------------
 2082|      1|            self.reload_requested = false;
 2083|      1|            if let Err(e) = self.reload_current_file() {
  ------------------
  |  Branch (2083:20): [True: 1, False: 0]
  ------------------
 2084|      1|                self.error_message = Some(format!("Failed to reload file: {}", e));
 2085|      1|            }
                          ^0
 2086|     18|        }
 2087|       |
 2088|       |        // Render menu bar
 2089|     19|        if !hide_chrome {
  ------------------
  |  Branch (2089:12): [True: 18, False: 1]
  ------------------
 2090|     18|            self.render_menu_bar(ctx);
 2091|     18|        }
                      ^1
 2092|       |
 2093|     19|        let mut layout_signature: Option<u64> = None;
 2094|     19|        let mut scroll_snapshot: Option<ScrollSnapshot> = None;
 2095|     19|        let screenshot_scroll_offset = self
 2096|     19|            .screenshot
 2097|     19|            .as_ref()
 2098|     19|            .and_then(|state| state.scroll_offset);
 2099|       |
 2100|       |        // Main content area
 2101|     19|        let central_response = CentralPanel::default().show(ctx, |ui| {
 2102|       |            // Show error message if any
 2103|     19|            if let Some(ref error) = self.error_message {
                                      ^1
  ------------------
  |  Branch (2103:20): [True: 1, False: 18]
  ------------------
 2104|      1|                ui.colored_label(Color32::RED, format!("Error: {}", error));
 2105|      1|                ui.separator();
 2106|     18|            }
 2107|       |
 2108|       |            // Render markdown content in a scrollable area
 2109|     19|            let scroll_delta = if let Some(nav) = self.nav_request.take() {
                                                         ^6
  ------------------
  |  Branch (2109:39): [True: 6, False: 13]
  ------------------
 2110|      6|                match nav {
 2111|       |                    NavigationRequest::Top => {
 2112|       |                        // Scroll to top: use a large POSITIVE delta to reach the beginning
 2113|      1|                        egui::Vec2::new(0.0, 100000.0)
 2114|       |                    }
 2115|       |                    NavigationRequest::Bottom => {
 2116|       |                        // Scroll to bottom: use a large NEGATIVE delta to reach the end
 2117|      1|                        egui::Vec2::new(0.0, -100000.0)
 2118|       |                    }
 2119|       |                    NavigationRequest::PageUp => {
 2120|      1|                        let viewport_height = ui.available_height();
 2121|      1|                        let page_size = viewport_height * 0.8;
 2122|      1|                        egui::Vec2::new(0.0, page_size) // Positive = scroll up (show earlier content)
 2123|       |                    }
 2124|       |                    NavigationRequest::PageDown => {
 2125|      1|                        let viewport_height = ui.available_height();
 2126|      1|                        let page_size = viewport_height * 0.8;
 2127|      1|                        egui::Vec2::new(0.0, -page_size) // Negative = scroll down (show later content)
 2128|       |                    }
 2129|       |                    NavigationRequest::ScrollUp => {
 2130|      1|                        egui::Vec2::new(0.0, 40.0) // Positive = fine scroll up
 2131|       |                    }
 2132|       |                    NavigationRequest::ScrollDown => {
 2133|      1|                        egui::Vec2::new(0.0, -40.0) // Negative = fine scroll down
 2134|       |                    }
 2135|       |                }
 2136|       |            } else {
 2137|     13|                egui::Vec2::ZERO
 2138|       |            };
 2139|       |
 2140|     19|            let mut scroll_area = egui::ScrollArea::vertical()
 2141|     19|                .id_source(self.scroll_area_id)
 2142|     19|                .auto_shrink([false, false])
 2143|     19|                .scroll_bar_visibility(egui::scroll_area::ScrollBarVisibility::VisibleWhenNeeded);
 2144|     19|            if let Some(offset) = screenshot_scroll_offset {
                                      ^1
  ------------------
  |  Branch (2144:20): [True: 1, False: 18]
  ------------------
 2145|      1|                scroll_area = scroll_area.vertical_scroll_offset(offset);
 2146|     18|            }
 2147|     19|            if screenshot_active {
  ------------------
  |  Branch (2147:16): [True: 1, False: 18]
  ------------------
 2148|      1|                scroll_area = scroll_area.enable_scrolling(false);
 2149|     18|            }
 2150|     19|            let scroll_output = scroll_area.show(ui, |ui| {
 2151|       |                // Apply scroll delta if we have navigation
 2152|     19|                if scroll_delta != egui::Vec2::ZERO {
  ------------------
  |  Branch (2152:20): [True: 6, False: 13]
  ------------------
 2153|      6|                    ui.scroll_with_delta(scroll_delta);
 2154|     13|                }
 2155|       |
 2156|     19|                ui.spacing_mut().item_spacing.y = 8.0;
 2157|       |
 2158|     19|                if self.parsed_elements.is_empty() && self.error_message.is_none() {
                                                                    ^1                 ^1
  ------------------
  |  Branch (2158:20): [True: 1, False: 18]
  |  Branch (2158:55): [True: 1, False: 0]
  ------------------
 2159|      1|                    ui.vertical_centered(|ui| {
 2160|      1|                        ui.add_space(50.0);
 2161|      1|                        ui.label(RichText::new("Welcome to MarkdownView").size(24.0).strong());
 2162|      1|                        ui.add_space(20.0);
 2163|      1|                        ui.label("Open a markdown file or select a sample to get started.");
 2164|      1|                        ui.add_space(20.0);
 2165|       |
 2166|      1|                        if app_action_triggered(ui.button("Open File").clicked(), "welcome_open") {
  ------------------
  |  Branch (2166:28): [True: 1, False: 0]
  ------------------
 2167|      1|                            self.open_file_dialog();
 2168|      1|                        }
                                      ^0
 2169|      1|                    });
 2170|       |                } else {
 2171|     18|                    match self.view_mode {
 2172|       |                        ViewMode::Rendered => {
 2173|       |                            // Update highlight phrase: prefer live input, else last executed
 2174|     12|                            if self.show_search && !self.search_query.is_empty() {
                                                                 ^1
  ------------------
  |  Branch (2174:32): [True: 1, False: 11]
  |  Branch (2174:52): [True: 1, False: 0]
  ------------------
 2175|      1|                                self.renderer.set_highlight_phrase(Some(&self.search_query));
 2176|     11|                            } else if !self.last_query.is_empty() {
  ------------------
  |  Branch (2176:39): [True: 1, False: 10]
  ------------------
 2177|      1|                                self.renderer.set_highlight_phrase(Some(&self.last_query));
 2178|     10|                            } else {
 2179|     10|                                self.renderer.set_highlight_phrase(None);
 2180|     10|                            }
 2181|       |
 2182|     12|                            self.renderer.render_to_ui(ui, &self.parsed_elements);
 2183|       |                            // If a header anchor was clicked, scroll to it
 2184|     12|                            if let Some(anchor) = self.renderer.take_pending_anchor() {
                                                      ^1
  ------------------
  |  Branch (2184:36): [True: 1, False: 11]
  ------------------
 2185|      1|                                if let Some(rect) = self.renderer.header_rect_for(&anchor) {
  ------------------
  |  Branch (2185:40): [True: 1, False: 0]
  ------------------
 2186|      1|                                    // Align target header to the top of the visible area
 2187|      1|                                    ui.scroll_to_rect(rect, Some(egui::Align::Min));
 2188|      1|                                }
                                              ^0
 2189|     11|                            }
 2190|       |                            // If a search requested a scroll, align to top of visible area
 2191|     12|                            if let Some(idx) = self.pending_scroll_to_element.take() {
                                                      ^6
  ------------------
  |  Branch (2191:36): [True: 6, False: 6]
  ------------------
 2192|      6|                                if let Some(rect) = self.renderer.element_rect_at(idx) {
  ------------------
  |  Branch (2192:40): [True: 6, False: 0]
  ------------------
 2193|      6|                                    ui.scroll_to_rect(rect, Some(egui::Align::Min));
 2194|      6|                                }
                                              ^0
 2195|      6|                            }
 2196|     12|                            layout_signature = Some(self.renderer.layout_signature());
 2197|       |                        }
 2198|       |                        ViewMode::Raw => {
 2199|       |                            // Raw markdown view; editable when write mode is enabled
 2200|      6|                            if self.write_enabled {
  ------------------
  |  Branch (2200:32): [True: 5, False: 1]
  ------------------
 2201|      5|                                let editor_id = egui::Id::new("raw_editor");
 2202|       |                                // If we have a remembered cursor, restore it (clamped)
 2203|      5|                                if let Some(mut idx) = self.raw_cursor.take() {
                                                          ^2
  ------------------
  |  Branch (2203:40): [True: 2, False: 3]
  ------------------
 2204|      2|                                    idx = idx.min(self.raw_buffer.len());
 2205|      1|                                    if let Some(mut state) =
  ------------------
  |  Branch (2205:44): [True: 1, False: 1]
  ------------------
 2206|      2|                                        egui::text_edit::TextEditState::load(ui.ctx(), editor_id)
 2207|      1|                                    {
 2208|      1|                                        let cr = egui::text::CCursorRange::one(
 2209|      1|                                            egui::text::CCursor::new(idx),
 2210|      1|                                        );
 2211|      1|                                        state.cursor.set_char_range(Some(cr));
 2212|      1|                                        state.store(ui.ctx(), editor_id);
 2213|      1|                                    } else {
 2214|      1|                                        let mut state = egui::text_edit::TextEditState::default();
 2215|      1|                                        let cr = egui::text::CCursorRange::one(
 2216|      1|                                            egui::text::CCursor::new(idx),
 2217|      1|                                        );
 2218|      1|                                        state.cursor.set_char_range(Some(cr));
 2219|      1|                                        state.store(ui.ctx(), editor_id);
 2220|      1|                                    }
 2221|      3|                                }
 2222|      5|                                let before = self.raw_buffer.clone();
 2223|      5|                                let resp = ui.add(
 2224|      5|                                    TextEdit::multiline(&mut self.raw_buffer)
 2225|      5|                                        .font(TextStyle::Monospace)
 2226|      5|                                        .code_editor()
 2227|      5|                                        .lock_focus(false)
 2228|      5|                                        .interactive(true)
 2229|      5|                                        .desired_width(f32::INFINITY)
 2230|      5|                                        .desired_rows(24)
 2231|      5|                                        .id_source(editor_id),
 2232|       |                                );
 2233|      5|                                if self.raw_focus_requested {
  ------------------
  |  Branch (2233:36): [True: 3, False: 2]
  ------------------
 2234|      3|                                    resp.request_focus();
 2235|      3|                                    self.raw_focus_requested = false;
 2236|      3|                                }
                                              ^2
 2237|       |                                // Remember cursor position for next time
 2238|      2|                                if let Some(state) =
  ------------------
  |  Branch (2238:40): [True: 2, False: 3]
  ------------------
 2239|      5|                                    egui::text_edit::TextEditState::load(ui.ctx(), editor_id)
 2240|       |                                {
 2241|      2|                                    if let Some(range) = state.cursor.char_range() {
  ------------------
  |  Branch (2241:44): [True: 2, False: 0]
  ------------------
 2242|      2|                                        let idx = range.primary.index;
 2243|      2|                                        self.raw_cursor = Some(idx);
 2244|      2|                                    }
                                                  ^0
 2245|      3|                                }
 2246|      5|                                if self.raw_buffer != before {
  ------------------
  |  Branch (2246:36): [True: 1, False: 4]
  ------------------
 2247|      1|                                    self.current_content = self.raw_buffer.clone();
 2248|      1|                                    match self.renderer.parse(&self.current_content) {
 2249|      1|                                        Ok(elements) => {
 2250|      1|                                            self.parsed_elements = elements;
 2251|      1|                                            self.error_message = None;
 2252|      1|                                        }
 2253|      0|                                        Err(e) => {
 2254|      0|                                            self.error_message =
 2255|      0|                                                Some(format!("Failed to parse markdown: {}", e));
 2256|      0|                                        }
 2257|       |                                    }
 2258|      4|                                }
 2259|      1|                            } else {
 2260|      1|                                // Read-only
 2261|      1|                                let mut tmp = self.raw_buffer.clone();
 2262|      1|                                ui.add(
 2263|      1|                                    TextEdit::multiline(&mut tmp)
 2264|      1|                                        .font(TextStyle::Monospace)
 2265|      1|                                        .code_editor()
 2266|      1|                                        .lock_focus(false)
 2267|      1|                                        .interactive(false)
 2268|      1|                                        .desired_width(f32::INFINITY)
 2269|      1|                                        .desired_rows(24),
 2270|      1|                                );
 2271|      1|                            }
 2272|       |                        }
 2273|       |                    }
 2274|       |                }
 2275|     19|            });
 2276|     19|            scroll_snapshot = Some(ScrollSnapshot {
 2277|     19|                content_size: scroll_output.content_size,
 2278|     19|                inner_rect: scroll_output.inner_rect,
 2279|     19|                offset_y: scroll_output.state.offset.y,
 2280|     19|            });
 2281|     19|        });
 2282|       |
 2283|       |        // Add context menu for the main panel
 2284|     19|        central_response
 2285|     19|            .response
 2286|     19|            .context_menu(|ui| self.render_main_context_menu(ui));
                                             ^0   ^0                       ^0
 2287|       |
 2288|     19|        if let Some(state) = self.screenshot.as_mut() {
                                  ^1
  ------------------
  |  Branch (2288:16): [True: 1, False: 18]
  ------------------
 2289|      1|            state.content_rect = Some(central_response.response.rect);
 2290|     18|        }
 2291|     19|        self.update_screenshot_state(ctx, layout_signature, scroll_snapshot);
 2292|       |
 2293|     19|        if !hide_chrome {
  ------------------
  |  Branch (2293:12): [True: 18, False: 1]
  ------------------
 2294|     18|            // Render floating search dialog (non-modal, always on top)
 2295|     18|            self.render_search_dialog(ctx);
 2296|     18|
 2297|     18|            // Render status bar
 2298|     18|            self.render_status_bar(ctx);
 2299|     18|
 2300|     18|            // Render drag-and-drop overlay (must be last to appear on top)
 2301|     18|            self.render_drag_overlay(ctx);
 2302|     18|        }
                      ^1
 2303|     20|    }
 2304|       |}
 2305|       |
 2306|       |impl eframe::App for MarkdownViewerApp {
 2307|       |    /// Update function called every frame
 2308|      0|    fn update(&mut self, ctx: &Context, _frame: &mut eframe::Frame) {
 2309|      0|        self.update_impl(ctx);
 2310|      0|    }
 2311|       |
 2312|      0|    fn auto_save_interval(&self) -> std::time::Duration {
 2313|      0|        std::time::Duration::from_secs(30)
 2314|      0|    }
 2315|       |
 2316|      2|    fn save(&mut self, _storage: &mut dyn eframe::Storage) {
 2317|       |        // Persist window position and size on app save/exit
 2318|      2|        if self.screenshot.is_none() {
  ------------------
  |  Branch (2318:12): [True: 1, False: 1]
  ------------------
 2319|      1|            self.persist_window_state();
 2320|      1|        }
 2321|      2|    }
 2322|       |}
 2323|       |
 2324|       |impl MarkdownViewerApp {
 2325|       |    // Build a rich-text label with only the mnemonic character underlined (visual cue only).
 2326|    110|    fn menu_text_with_mnemonic(
 2327|    110|        prefix: Option<&str>,
 2328|    110|        label: &str,
 2329|    110|        mnemonic: char,
 2330|    110|        underline: bool,
 2331|    110|        text_color: Color32,
 2332|    110|    ) -> LayoutJob {
 2333|    110|        let mut job = LayoutJob::default();
 2334|    110|        let default_fmt = TextFormat {
 2335|    110|            color: text_color,
 2336|    110|            ..TextFormat::default()
 2337|    110|        };
 2338|    110|        if let Some(p) = prefix {
                                  ^1
  ------------------
  |  Branch (2338:16): [True: 1, False: 109]
  ------------------
 2339|      1|            job.append(p, 0.0, default_fmt.clone());
 2340|    109|        }
 2341|    110|        let m = mnemonic.to_ascii_lowercase();
 2342|    110|        let mut applied = false;
 2343|    683|        for c in label.chars() {
                               ^110  ^110
 2344|    683|            let mut fmt = default_fmt.clone();
 2345|    683|            if underline && !applied && c.to_ascii_lowercase() == m {
                                          ^4          ^1
  ------------------
  |  Branch (2345:16): [True: 4, False: 679]
  |  Branch (2345:29): [True: 1, False: 3]
  |  Branch (2345:41): [True: 1, False: 0]
  ------------------
 2346|      1|                // Use a subtle underline color; white works well on dark theme
 2347|      1|                fmt.underline = egui::Stroke::new(1.0, text_color);
 2348|      1|                applied = true;
 2349|    682|            }
 2350|    683|            let s = c.to_string();
 2351|    683|            job.append(&s, 0.0, fmt);
 2352|       |        }
 2353|    110|        job
 2354|    110|    }
 2355|      3|    fn persist_window_state(&mut self) {
 2356|      3|        if let Some(state) = self.current_window_state() {
  ------------------
  |  Branch (2356:16): [True: 3, False: 0]
  ------------------
 2357|      3|            if !self.window_state_changed(&state) {
  ------------------
  |  Branch (2357:16): [True: 1, False: 2]
  ------------------
 2358|      1|                return;
 2359|      2|            }
 2360|      2|            if crate::save_window_state(&state).is_ok() {
  ------------------
  |  Branch (2360:16): [True: 2, False: 0]
  ------------------
 2361|      2|                self.last_persist_instant = std::time::Instant::now();
 2362|      2|                self.last_persisted_state = Some(state);
 2363|      2|            }
                          ^0
 2364|      0|        }
 2365|      3|    }
 2366|       |
 2367|     22|    fn should_persist_window_state(&self) -> bool {
 2368|     22|        if self.screenshot.is_some() {
  ------------------
  |  Branch (2368:12): [True: 2, False: 20]
  ------------------
 2369|      2|            return false;
 2370|     20|        }
 2371|     20|        if self.last_persist_instant.elapsed() < std::time::Duration::from_secs(1) {
  ------------------
  |  Branch (2371:12): [True: 19, False: 1]
  ------------------
 2372|     19|            return false;
 2373|      1|        }
 2374|      1|        if let Some(state) = self.current_window_state() {
                                  ^0
  ------------------
  |  Branch (2374:16): [True: 0, False: 1]
  ------------------
 2375|      0|            self.window_state_changed(&state)
 2376|       |        } else {
 2377|      1|            false
 2378|       |        }
 2379|     22|    }
 2380|       |
 2381|       |    /// Save current document. If no file is associated, prompts for a path.
 2382|      8|    fn save_current_document(&mut self) -> Result<()> {
 2383|      8|        if let Some(path) = self.current_file.clone() {
                                  ^5
  ------------------
  |  Branch (2383:16): [True: 5, False: 3]
  ------------------
 2384|      5|            std::fs::write(&path, &self.current_content)?;
                                                                      ^2
 2385|      3|            let parent = path.parent();
 2386|      3|            self.renderer.set_base_dir(parent);
 2387|      3|            Ok(())
 2388|      3|        } else if let Some(path) = self.pick_save_path() {
  ------------------
  |  Branch (2388:23): [True: 3, False: 0]
  ------------------
 2389|      3|            std::fs::write(&path, &self.current_content)?;
                                                                      ^0
 2390|      3|            let filename = path
 2391|      3|                .file_name()
 2392|      3|                .and_then(|n| n.to_str())
 2393|      3|                .unwrap_or("Unknown")
 2394|      3|                .to_string();
 2395|      3|            self.current_file = Some(path);
 2396|      3|            if let Some(parent) = self.current_file.as_ref().and_then(|p| p.parent()) {
  ------------------
  |  Branch (2396:20): [True: 3, False: 0]
  ------------------
 2397|      3|                self.renderer.set_base_dir(Some(parent));
 2398|      3|            } else {
 2399|      0|                self.renderer.set_base_dir(None);
 2400|      0|            }
 2401|      3|            self.title = format!("{APP_TITLE_PREFIX} - {}", filename);
 2402|      3|            Ok(())
 2403|       |        } else {
 2404|      0|            Ok(())
 2405|       |        }
 2406|      8|    }
 2407|       |
 2408|       |    /// Render the floating non-modal search dialog
 2409|     20|    fn render_search_dialog(&mut self, ctx: &Context) {
 2410|     20|        if !self.show_search {
  ------------------
  |  Branch (2410:12): [True: 17, False: 3]
  ------------------
 2411|     17|            return;
 2412|      3|        }
 2413|      3|        let prev_open = self.show_search;
 2414|      3|        let mut open = self.show_search;
 2415|      3|        let prev_query = self.search_query.clone();
 2416|      3|        egui::Window::new("Find")
 2417|      3|            .collapsible(false)
 2418|      3|            .resizable(false)
 2419|      3|            .default_pos(egui::pos2(80.0, 80.0))
 2420|      3|            .open(&mut open)
 2421|      3|            .show(ctx, |ui| {
 2422|      3|                let mut submitted_next = false;
 2423|      3|                ui.horizontal(|ui| {
 2424|      3|                    let text_edit = egui::TextEdit::singleline(&mut self.search_query)
 2425|      3|                        .hint_text("Search text...")
 2426|      3|                        .desired_width(240.0);
 2427|      3|                    let resp = ui.add(text_edit);
 2428|      3|                    if self.search_focus_requested {
  ------------------
  |  Branch (2428:24): [True: 1, False: 2]
  ------------------
 2429|      1|                        resp.request_focus();
 2430|      1|                        self.search_focus_requested = false;
 2431|      2|                    }
 2432|      3|                    if resp.lost_focus() && ui.input(|i| i.key_pressed(egui::Key::Enter)) {
                                                          ^0 ^0        ^0^0          ^0
  ------------------
  |  Branch (2432:24): [True: 0, False: 3]
  |  Branch (2432:45): [True: 0, False: 0]
  ------------------
 2433|      0|                        submitted_next = true;
 2434|      3|                    }
 2435|      3|                    let next_clicked = ui.button("Next (F3)").clicked();
 2436|      3|                    if app_action_triggered(next_clicked, "search_next") || submitted_next {
                                                                                          ^2
  ------------------
  |  Branch (2436:24): [True: 1, False: 2]
  |  Branch (2436:77): [True: 0, False: 2]
  ------------------
 2437|      1|                        self.find_next();
 2438|      2|                    }
 2439|      3|                    let prev_clicked = ui.button("Prev (Shift+F3)").clicked();
 2440|      3|                    if app_action_triggered(prev_clicked, "search_prev") {
  ------------------
  |  Branch (2440:24): [True: 1, False: 2]
  ------------------
 2441|      1|                        self.find_previous();
 2442|      2|                    }
 2443|      3|                });
 2444|      3|            });
 2445|      3|        if app_action_triggered(false, "search_close") {
  ------------------
  |  Branch (2445:12): [True: 1, False: 2]
  ------------------
 2446|      1|            open = false;
 2447|      2|        }
 2448|      3|        self.update_search_results(&prev_query);
 2449|       |        // If dialog closed via close button, clear before hiding
 2450|      3|        if prev_open && !open {
  ------------------
  |  Branch (2450:12): [True: 3, False: 0]
  |  Branch (2450:25): [True: 1, False: 2]
  ------------------
 2451|      1|            self.clear_search_state();
 2452|      2|        }
 2453|      3|        self.show_search = open;
 2454|     20|    }
 2455|       |
 2456|      6|    fn update_search_results(&mut self, prev_query: &str) {
 2457|      6|        if self.search_query == prev_query {
  ------------------
  |  Branch (2457:12): [True: 3, False: 3]
  ------------------
 2458|      3|            return;
 2459|      3|        }
 2460|      3|        if self.search_query.is_empty() {
  ------------------
  |  Branch (2460:12): [True: 1, False: 2]
  ------------------
 2461|      1|            self.last_query.clear();
 2462|      1|            self.renderer.set_highlight_phrase(None);
 2463|      1|            return;
 2464|      2|        }
 2465|      2|        self.last_query = self.search_query.clone();
 2466|       |        // Use current last match as baseline if set, else start of doc
 2467|      2|        let baseline = self.last_match_index.unwrap_or(0);
 2468|      2|        let needle = Self::fold_for_search(&self.search_query);
 2469|      2|        let total = self.parsed_elements.len();
 2470|      2|        let mut found: Option<usize> = None;
 2471|      3|        for pass in 0..2 {
 2472|      3|            let range: Box<dyn Iterator<Item = usize>> = if pass == 0 {
  ------------------
  |  Branch (2472:61): [True: 2, False: 1]
  ------------------
 2473|      2|                Box::new(baseline..total)
 2474|       |            } else {
 2475|      1|                Box::new(0..baseline.min(total))
 2476|       |            };
 2477|      5|            for idx in range {
                              ^4
 2478|      4|                let text = crate::markdown_renderer::MarkdownRenderer::element_plain_text(
 2479|      4|                    &self.parsed_elements[idx],
 2480|       |                );
 2481|      4|                if Self::fold_for_search(&text).contains(&needle) {
  ------------------
  |  Branch (2481:20): [True: 2, False: 2]
  ------------------
 2482|      2|                    found = Some(idx);
 2483|      2|                    break;
 2484|      2|                }
 2485|       |            }
 2486|      3|            if found.is_some() {
  ------------------
  |  Branch (2486:16): [True: 2, False: 1]
  ------------------
 2487|      2|                break;
 2488|      1|            }
 2489|       |        }
 2490|      2|        if let Some(idx) = found {
  ------------------
  |  Branch (2490:16): [True: 2, False: 0]
  ------------------
 2491|      2|            self.last_match_index = Some(idx);
 2492|      2|            self.pending_scroll_to_element = Some(idx);
 2493|      2|        }
                      ^0
 2494|      6|    }
 2495|       |
 2496|     24|    fn handle_screenshot_events(&mut self, ctx: &Context) {
 2497|     24|        let screenshot = ctx.input(|i| {
 2498|     24|            i.events.iter().find_map(|event| {
                                                           ^6
 2499|      6|                if let egui::Event::Screenshot { image, .. } = event {
                                                               ^4
  ------------------
  |  Branch (2499:24): [True: 4, False: 2]
  ------------------
 2500|      4|                    Some(std::sync::Arc::clone(image))
 2501|       |                } else {
 2502|      2|                    None
 2503|       |                }
 2504|      6|            })
 2505|     24|        });
 2506|     24|        let Some(image) = screenshot else {
                               ^4
  ------------------
  |  Branch (2506:13): [True: 4, False: 20]
  ------------------
 2507|     20|            return;
 2508|       |        };
 2509|      2|        let snapshot = {
 2510|      4|            let Some(state) = self.screenshot.as_ref() else {
                                   ^3
  ------------------
  |  Branch (2510:17): [True: 3, False: 1]
  ------------------
 2511|      1|                return;
 2512|       |            };
 2513|      3|            if state.done {
  ------------------
  |  Branch (2513:16): [True: 1, False: 2]
  ------------------
 2514|      1|                return;
 2515|      2|            }
 2516|      2|            ScreenshotSnapshot::from(state)
 2517|       |        };
 2518|      2|        if let Err(err) = Self::save_screenshot_image(&image, &snapshot) {
                                 ^1
  ------------------
  |  Branch (2518:16): [True: 1, False: 1]
  ------------------
 2519|      1|            eprintln!("Failed to save screenshot: {err}");
 2520|      1|        }
 2521|      2|        if let Some(state) = self.screenshot.as_mut() {
  ------------------
  |  Branch (2521:16): [True: 2, False: 0]
  ------------------
 2522|      2|            state.done = true;
 2523|      2|        }
                      ^0
 2524|      2|        ctx.send_viewport_cmd(egui::ViewportCommand::Close);
 2525|     24|    }
 2526|       |
 2527|     22|    fn update_screenshot_state(
 2528|     22|        &mut self,
 2529|     22|        ctx: &Context,
 2530|     22|        layout_signature: Option<u64>,
 2531|     22|        scroll_snapshot: Option<ScrollSnapshot>,
 2532|     22|    ) {
 2533|     22|        let Some(state) = self.screenshot.as_mut() else {
                               ^4
  ------------------
  |  Branch (2533:13): [True: 4, False: 18]
  ------------------
 2534|     18|            return;
 2535|       |        };
 2536|      4|        let native_ppp = ctx
 2537|      4|            .input(|i| i.viewport().native_pixels_per_point)
 2538|      4|            .unwrap_or(1.0);
 2539|      4|        ctx.set_pixels_per_point(1.0);
 2540|      4|        state.pixels_per_point = ctx.input(|i| i.pixels_per_point);
 2541|       |
 2542|      4|        if !state.viewport_adjusted {
  ------------------
  |  Branch (2542:12): [True: 3, False: 1]
  ------------------
 2543|      3|            let width_points = (state.config.viewport_width / native_ppp).max(1.0);
 2544|      3|            let height_points = (state.config.viewport_height / native_ppp).max(1.0);
 2545|      3|            ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(egui::vec2(
 2546|      3|                width_points,
 2547|      3|                height_points,
 2548|      3|            )));
 2549|      3|            state.viewport_adjusted = true;
 2550|      3|            ctx.request_repaint();
 2551|      3|        }
                      ^1
 2552|       |
 2553|      4|        let mut scroll_offset = None;
 2554|      4|        let mut scroll_changed = false;
 2555|      4|        if let Some(snapshot) = scroll_snapshot {
                                  ^3
  ------------------
  |  Branch (2555:16): [True: 3, False: 1]
  ------------------
 2556|      3|            scroll_offset = Some(snapshot.offset_y);
 2557|      3|            scroll_changed = state.record_scroll(snapshot);
 2558|      3|        }
                      ^1
 2559|       |
 2560|      4|        state.update_stability(layout_signature, scroll_offset);
 2561|       |
 2562|      4|        let pending = self.renderer.has_pending_renders();
 2563|      4|        state.pending_renders = pending;
 2564|      4|        let elapsed = state.started.elapsed();
 2565|      4|        let timed_out = elapsed >= Duration::from_millis(state.config.wait_ms);
 2566|      4|        let stable =
 2567|      4|            state.scroll_ready() && state.stable_frames >= state.config.settle_frames && !pending;
                                                  ^2                                                   ^2
  ------------------
  |  Branch (2567:13): [True: 2, False: 2]
  |  Branch (2567:37): [True: 2, False: 0]
  ------------------
 2568|       |
 2569|      4|        if stable || timed_out {
                                   ^2
  ------------------
  |  Branch (2569:12): [True: 2, False: 2]
  |  Branch (2569:22): [True: 1, False: 1]
  ------------------
 2570|      3|            if timed_out && !stable {
  ------------------
  |  Branch (2570:16): [True: 3, False: 0]
  |  Branch (2570:29): [True: 1, False: 2]
  ------------------
 2571|      1|                state.timed_out = true;
 2572|      2|            }
 2573|      3|            if !state.requested {
  ------------------
  |  Branch (2573:16): [True: 2, False: 1]
  ------------------
 2574|      2|                ctx.send_viewport_cmd(egui::ViewportCommand::Screenshot);
 2575|      2|                state.requested = true;
 2576|      2|            }
                          ^1
 2577|      1|        } else {
 2578|      1|            ctx.request_repaint_after(Duration::from_millis(16));
 2579|      1|        }
 2580|       |
 2581|      4|        if scroll_changed {
  ------------------
  |  Branch (2581:12): [True: 1, False: 3]
  ------------------
 2582|      1|            ctx.request_repaint();
 2583|      3|        }
 2584|      4|        if state.requested && !state.done {
                                            ^3
  ------------------
  |  Branch (2584:12): [True: 3, False: 1]
  |  Branch (2584:31): [True: 3, False: 0]
  ------------------
 2585|      3|            ctx.request_repaint();
 2586|      3|        }
                      ^1
 2587|     22|    }
 2588|       |
 2589|     10|    fn save_screenshot_image(image: &egui::ColorImage, state: &ScreenshotSnapshot) -> Result<()> {
 2590|     10|        let full_width = image.size[0] as u32;
 2591|     10|        let full_height = image.size[1] as u32;
 2592|     10|        let mut rgba = Self::color_image_to_rgba(image);
 2593|       |
 2594|     10|        let mut crop_x = 0u32;
 2595|     10|        let mut crop_y = 0u32;
 2596|     10|        let mut crop_w = full_width;
 2597|     10|        let mut crop_h = full_height;
 2598|       |
 2599|     10|        if state.config.content_only {
  ------------------
  |  Branch (2599:12): [True: 6, False: 4]
  ------------------
 2600|      6|            if let Some(rect) = state.content_rect {
  ------------------
  |  Branch (2600:20): [True: 6, False: 0]
  ------------------
 2601|      6|                let pixels_per_point = state.pixels_per_point.max(0.1);
 2602|      6|                let min_x = (rect.min.x * pixels_per_point).round() as i32;
 2603|      6|                let min_y = (rect.min.y * pixels_per_point).round() as i32;
 2604|      6|                let max_x = (rect.max.x * pixels_per_point).round() as i32;
 2605|      6|                let max_y = (rect.max.y * pixels_per_point).round() as i32;
 2606|       |
 2607|      6|                let min_x = min_x.clamp(0, full_width as i32);
 2608|      6|                let min_y = min_y.clamp(0, full_height as i32);
 2609|      6|                let max_x = max_x.clamp(min_x, full_width as i32);
 2610|      6|                let max_y = max_y.clamp(min_y, full_height as i32);
 2611|       |
 2612|      6|                let width = (max_x - min_x) as u32;
 2613|      6|                let height = (max_y - min_y) as u32;
 2614|      6|                if width > 0 && height > 0 {
                                              ^5
  ------------------
  |  Branch (2614:20): [True: 5, False: 1]
  |  Branch (2614:33): [True: 5, False: 0]
  ------------------
 2615|      5|                    crop_x = min_x as u32;
 2616|      5|                    crop_y = min_y as u32;
 2617|      5|                    crop_w = width;
 2618|      5|                    crop_h = height;
 2619|      5|                }
                              ^1
 2620|      0|            }
 2621|      4|        }
 2622|       |
 2623|     10|        if crop_x != 0 || crop_y != 0 || crop_w != full_width || crop_h != full_height {
                                        ^8             ^7                      ^6
  ------------------
  |  Branch (2623:12): [True: 2, False: 8]
  |  Branch (2623:27): [True: 1, False: 7]
  |  Branch (2623:42): [True: 1, False: 6]
  |  Branch (2623:66): [True: 1, False: 5]
  ------------------
 2624|      5|            rgba = imageops::crop_imm(&rgba, crop_x, crop_y, crop_w, crop_h).to_image();
 2625|      5|        }
 2626|       |
 2627|     10|        if let Some(parent) = state.config.output_path.parent() {
  ------------------
  |  Branch (2627:16): [True: 10, False: 0]
  ------------------
 2628|     10|            std::fs::create_dir_all(parent)?;
                                                         ^0
 2629|      0|        }
 2630|     10|        rgba.save(&state.config.output_path)?;
                                                          ^1
 2631|       |
 2632|      9|        let metadata = Self::screenshot_metadata(state, full_width, full_height, crop_w, crop_h);
 2633|      9|        std::fs::write(state.config.metadata_path(), metadata)?;
                                                                            ^0
 2634|      9|        Ok(())
 2635|     10|    }
 2636|       |
 2637|      9|    fn screenshot_metadata(
 2638|      9|        state: &ScreenshotSnapshot,
 2639|      9|        full_width: u32,
 2640|      9|        full_height: u32,
 2641|      9|        crop_width: u32,
 2642|      9|        crop_height: u32,
 2643|      9|    ) -> String {
 2644|      9|        let output_path = Self::json_escape(&state.config.output_path.to_string_lossy());
 2645|      9|        let font_source = state
 2646|      9|            .config
 2647|      9|            .font_source
 2648|      9|            .as_ref()
 2649|      9|            .map(|value| format!("\"{}\"", Self::json_escape(value)))
                                       ^1      ^1        ^1                ^1
 2650|      9|            .unwrap_or_else(|| "null".to_string());
                                             ^8     ^8
 2651|      9|        let scroll_ratio = Self::json_opt_f32(state.config.scroll_ratio);
 2652|      9|        let scroll_offset = Self::json_opt_f32(state.last_scroll_offset);
 2653|      9|        let elapsed_ms = state.started.elapsed().as_millis();
 2654|       |
 2655|      9|        format!(
 2656|      9|            "{{\n  \"version\": \"{}\",\n  \"build_timestamp\": \"{}\",\n  \"output\": \"{}\",\n  \"theme\": \"{}\",\n  \"zoom\": {:.3},\n  \"content_only\": {},\n  \"scroll_ratio\": {},\n  \"scroll_offset\": {},\n  \"viewport_px\": {{\"width\": {}, \"height\": {}}},\n  \"content_px\": {{\"width\": {}, \"height\": {}}},\n  \"pixels_per_point\": {:.3},\n  \"wait_ms\": {},\n  \"settle_frames\": {},\n  \"stable_frames\": {},\n  \"timed_out\": {},\n  \"pending_renders\": {},\n  \"font_source\": {},\n  \"elapsed_ms\": {}\n}}\n",
 2657|       |            BUILD_VERSION,
 2658|       |            BUILD_TIMESTAMP,
 2659|       |            output_path,
 2660|      9|            state.config.theme.as_str(),
 2661|       |            state.config.zoom,
 2662|       |            state.config.content_only,
 2663|       |            scroll_ratio,
 2664|       |            scroll_offset,
 2665|       |            full_width,
 2666|       |            full_height,
 2667|       |            crop_width,
 2668|       |            crop_height,
 2669|       |            state.pixels_per_point,
 2670|       |            state.config.wait_ms,
 2671|       |            state.config.settle_frames,
 2672|       |            state.stable_frames,
 2673|       |            state.timed_out,
 2674|       |            state.pending_renders,
 2675|       |            font_source,
 2676|       |            elapsed_ms
 2677|       |        )
 2678|      9|    }
 2679|       |
 2680|     10|    fn color_image_to_rgba(image: &egui::ColorImage) -> RgbaImage {
 2681|     10|        let width = image.size[0] as u32;
 2682|     10|        let height = image.size[1] as u32;
 2683|     10|        let mut data = Vec::with_capacity(image.pixels.len() * 4);
 2684|  7.91k|        for pixel in &image.pixels {
                          ^7.90k
 2685|  7.90k|            data.extend_from_slice(&[pixel.r(), pixel.g(), pixel.b(), pixel.a()]);
 2686|  7.90k|        }
 2687|     10|        RgbaImage::from_raw(width, height, data).unwrap_or_else(|| RgbaImage::new(width, height))
                                                                                 ^0             ^0     ^0
 2688|     10|    }
 2689|       |
 2690|     11|    fn json_escape(value: &str) -> String {
 2691|     11|        let mut out = String::with_capacity(value.len() + 8);
 2692|    533|        for ch in value.chars() {
                                ^11   ^11
 2693|    533|            match ch {
 2694|     65|                '\\' => out.push_str("\\\\"),
 2695|      1|                '"' => out.push_str("\\\""),
 2696|      1|                '\n' => out.push_str("\\n"),
 2697|      1|                '\r' => out.push_str("\\r"),
 2698|      1|                '\t' => out.push_str("\\t"),
 2699|    464|                _ => out.push(ch),
 2700|       |            }
 2701|       |        }
 2702|     11|        out
 2703|     11|    }
 2704|       |
 2705|     20|    fn json_opt_f32(value: Option<f32>) -> String {
 2706|     20|        value
 2707|     20|            .map(|v| format!("{v:.3}"))
                                   ^3      ^3
 2708|     20|            .unwrap_or_else(|| "null".to_string())
                                             ^17    ^17
 2709|     20|    }
 2710|       |
 2711|       |    // No overlay menu helpers; we only render egui's built-in menus.
 2712|       |}
 2713|       |
 2714|       |impl Default for MarkdownViewerApp {
 2715|      1|    fn default() -> Self {
 2716|      1|        Self::new()
 2717|      1|    }
 2718|       |}
 2719|       |
 2720|       |#[cfg(test)]
 2721|       |mod tests {
 2722|       |    use super::*;
 2723|       |    use crate::markdown_renderer::InlineSpan;
 2724|       |    use eframe::App;
 2725|       |    use std::io::Write;
 2726|       |    use std::sync::{Arc, Mutex, OnceLock};
 2727|       |    use tempfile::{NamedTempFile, TempDir};
 2728|       |
 2729|     20|    fn run_app_frame(app: &mut MarkdownViewerApp, ctx: &egui::Context, input: egui::RawInput) {
 2730|     20|        let _ = ctx.run(input, |ctx| {
 2731|     20|            app.update_impl(ctx);
 2732|     20|        });
 2733|     20|    }
 2734|       |
 2735|     46|    fn default_input() -> egui::RawInput {
 2736|     46|        egui::RawInput {
 2737|     46|            screen_rect: Some(egui::Rect::from_min_size(
 2738|     46|                egui::pos2(0.0, 0.0),
 2739|     46|                egui::vec2(960.0, 640.0),
 2740|     46|            )),
 2741|     46|            ..Default::default()
 2742|     46|        }
 2743|     46|    }
 2744|       |
 2745|      4|    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
 2746|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
 2747|      4|        ENV_LOCK
 2748|      4|            .get_or_init(|| Mutex::new(()))
                                          ^1         ^1
 2749|      4|            .lock()
 2750|      4|            .expect("env lock")
 2751|      4|    }
 2752|       |
 2753|       |    struct EnvGuard {
 2754|       |        key: &'static str,
 2755|       |        original: Option<String>,
 2756|       |    }
 2757|       |
 2758|       |    impl EnvGuard {
 2759|      4|        fn set(key: &'static str, value: &str) -> Self {
 2760|      4|            let original = std::env::var(key).ok();
 2761|      4|            std::env::set_var(key, value);
 2762|      4|            Self { key, original }
 2763|      4|        }
 2764|       |    }
 2765|       |
 2766|       |    impl Drop for EnvGuard {
 2767|      4|        fn drop(&mut self) {
 2768|      4|            if let Some(value) = &self.original {
                                      ^3
  ------------------
  |  Branch (2768:20): [True: 3, False: 1]
  ------------------
 2769|      3|                std::env::set_var(self.key, value);
 2770|      3|            } else {
 2771|      1|                std::env::remove_var(self.key);
 2772|      1|            }
 2773|      4|        }
 2774|       |    }
 2775|       |
 2776|       |    #[derive(Default)]
 2777|       |    struct DummyStorage;
 2778|       |
 2779|       |    impl eframe::Storage for DummyStorage {
 2780|      0|        fn get_string(&self, _key: &str) -> Option<String> {
 2781|      0|            None
 2782|      0|        }
 2783|       |
 2784|      0|        fn set_string(&mut self, _key: &str, _value: String) {}
 2785|       |
 2786|      0|        fn flush(&mut self) {}
 2787|       |    }
 2788|       |
 2789|       |    struct ForcedAppActions {
 2790|       |        actions: Vec<&'static str>,
 2791|       |    }
 2792|       |
 2793|       |    impl ForcedAppActions {
 2794|      5|        fn new(actions: &[&'static str]) -> Self {
 2795|      5|            FORCED_APP_ACTIONS.with(|set| {
 2796|      5|                let mut set = set.borrow_mut();
 2797|     40|                for action in actions {
                                  ^35
 2798|     35|                    set.insert(*action);
 2799|     35|                }
 2800|      5|            });
 2801|      5|            Self {
 2802|      5|                actions: actions.to_vec(),
 2803|      5|            }
 2804|      5|        }
 2805|       |    }
 2806|       |
 2807|       |    impl Drop for ForcedAppActions {
 2808|      5|        fn drop(&mut self) {
 2809|      5|            FORCED_APP_ACTIONS.with(|set| {
 2810|      5|                let mut set = set.borrow_mut();
 2811|     40|                for action in &self.actions {
                                  ^35
 2812|     35|                    set.remove(action);
 2813|     35|                }
 2814|      5|            });
 2815|      5|        }
 2816|       |    }
 2817|       |
 2818|       |    struct ForcedDialogPaths;
 2819|       |
 2820|       |    impl ForcedDialogPaths {
 2821|      7|        fn new(open: Option<PathBuf>, save: Option<PathBuf>) -> Self {
 2822|      7|            FORCED_OPEN_PATH.with(|slot| {
 2823|      7|                *slot.borrow_mut() = open;
 2824|      7|            });
 2825|      7|            FORCED_SAVE_PATH.with(|slot| {
 2826|      7|                *slot.borrow_mut() = save;
 2827|      7|            });
 2828|      7|            Self
 2829|      7|        }
 2830|       |    }
 2831|       |
 2832|       |    impl Drop for ForcedDialogPaths {
 2833|      7|        fn drop(&mut self) {
 2834|      7|            FORCED_OPEN_PATH.with(|slot| {
 2835|      7|                slot.borrow_mut().take();
 2836|      7|            });
 2837|      7|            FORCED_SAVE_PATH.with(|slot| {
 2838|      7|                slot.borrow_mut().take();
 2839|      7|            });
 2840|      7|        }
 2841|       |    }
 2842|       |
 2843|       |    struct ForcedLoadError;
 2844|       |
 2845|       |    impl ForcedLoadError {
 2846|      3|        fn new() -> Self {
 2847|      3|            FORCED_LOAD_ERROR.with(|flag| {
 2848|      3|                *flag.borrow_mut() = true;
 2849|      3|            });
 2850|      3|            Self
 2851|      3|        }
 2852|       |    }
 2853|       |
 2854|       |    impl Drop for ForcedLoadError {
 2855|      3|        fn drop(&mut self) {
 2856|      3|            FORCED_LOAD_ERROR.with(|flag| {
 2857|      3|                *flag.borrow_mut() = false;
 2858|      3|            });
 2859|      3|        }
 2860|       |    }
 2861|       |
 2862|       |    struct ForcedScanError;
 2863|       |
 2864|       |    impl ForcedScanError {
 2865|      1|        fn new() -> Self {
 2866|      1|            FORCED_SCAN_ERROR.with(|flag| {
 2867|      1|                *flag.borrow_mut() = true;
 2868|      1|            });
 2869|      1|            Self
 2870|      1|        }
 2871|       |    }
 2872|       |
 2873|       |    impl Drop for ForcedScanError {
 2874|      1|        fn drop(&mut self) {
 2875|      1|            FORCED_SCAN_ERROR.with(|flag| {
 2876|      1|                *flag.borrow_mut() = false;
 2877|      1|            });
 2878|      1|        }
 2879|       |    }
 2880|       |
 2881|       |    #[test]
 2882|      1|    fn test_app_action_triggered_with_forced_action() {
 2883|      1|        let _guard = ForcedAppActions::new(&["menu_open"]);
 2884|      1|        assert!(app_action_triggered(false, "menu_open"));
 2885|      1|        assert!(app_action_triggered(true, "menu_open"));
 2886|      1|    }
 2887|       |
 2888|       |    #[test]
 2889|      1|    fn test_normalize_line_endings() {
 2890|       |        // Windows style (\r\n)
 2891|      1|        assert_eq!(
 2892|      1|            MarkdownViewerApp::normalize_line_endings("Hello\r\nWorld"),
 2893|       |            "Hello\nWorld"
 2894|       |        );
 2895|       |
 2896|       |        // Unix style (\n) - no change
 2897|      1|        assert_eq!(
 2898|      1|            MarkdownViewerApp::normalize_line_endings("Hello\nWorld"),
 2899|       |            "Hello\nWorld"
 2900|       |        );
 2901|       |
 2902|       |        // Old Mac style (\r)
 2903|      1|        assert_eq!(
 2904|      1|            MarkdownViewerApp::normalize_line_endings("Hello\rWorld"),
 2905|       |            "Hello\nWorld"
 2906|       |        );
 2907|       |
 2908|       |        // Mixed line endings
 2909|      1|        assert_eq!(
 2910|      1|            MarkdownViewerApp::normalize_line_endings("A\r\nB\nC\rD"),
 2911|       |            "A\nB\nC\nD"
 2912|       |        );
 2913|       |
 2914|       |        // Multiple blank lines with Windows endings
 2915|      1|        assert_eq!(
 2916|      1|            MarkdownViewerApp::normalize_line_endings("A\r\n\r\nB"),
 2917|       |            "A\n\nB"
 2918|       |        );
 2919|       |
 2920|       |        // Empty string
 2921|      1|        assert_eq!(MarkdownViewerApp::normalize_line_endings(""), "");
 2922|       |
 2923|       |        // No line endings
 2924|      1|        assert_eq!(
 2925|      1|            MarkdownViewerApp::normalize_line_endings("Single line"),
 2926|       |            "Single line"
 2927|       |        );
 2928|      1|    }
 2929|       |
 2930|       |    #[test]
 2931|      1|    fn test_load_file_with_windows_line_endings() -> Result<()> {
 2932|      1|        let mut app = MarkdownViewerApp::new();
 2933|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2934|       |
 2935|       |        // Write content with explicit Windows line endings
 2936|      1|        temp_file.write_all(b"Line 1\r\nLine 2\r\n\r\nParagraph text")?;
                                                                                    ^0
 2937|      1|        temp_file.flush()?;
                                       ^0
 2938|       |
 2939|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 2940|       |
 2941|       |        // Should not contain any \r characters after normalization
 2942|      1|        assert!(!app.current_content.contains('\r'));
 2943|      1|        assert!(app.current_content.contains("Line 1\nLine 2"));
 2944|      1|        assert!(app.current_content.contains("\n\nParagraph"));
 2945|      1|        Ok(())
 2946|      1|    }
 2947|       |
 2948|       |    #[test]
 2949|      1|    fn test_load_file_with_mixed_line_endings() -> Result<()> {
 2950|      1|        let mut app = MarkdownViewerApp::new();
 2951|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2952|       |
 2953|       |        // Mix of \r\n (Windows), \n (Unix), and \r (old Mac)
 2954|      1|        temp_file.write_all(b"Line 1\r\nLine 2\nLine 3\rLine 4")?;
                                                                              ^0
 2955|      1|        temp_file.flush()?;
                                       ^0
 2956|       |
 2957|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 2958|       |
 2959|       |        // All should be normalized to \n
 2960|      1|        assert!(!app.current_content.contains('\r'));
 2961|      1|        assert_eq!(app.current_content.lines().count(), 4);
 2962|      1|        let lines: Vec<&str> = app.current_content.lines().collect();
 2963|      1|        assert_eq!(lines[0], "Line 1");
 2964|      1|        assert_eq!(lines[1], "Line 2");
 2965|      1|        assert_eq!(lines[2], "Line 3");
 2966|      1|        assert_eq!(lines[3], "Line 4");
 2967|      1|        Ok(())
 2968|      1|    }
 2969|       |
 2970|       |    #[test]
 2971|      1|    fn test_load_file_strips_bom() -> Result<()> {
 2972|      1|        let mut app = MarkdownViewerApp::new();
 2973|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 2974|       |
 2975|      1|        temp_file.write_all(b"\xEF\xBB\xBF# Heading\nContent")?;
                                                                            ^0
 2976|      1|        temp_file.flush()?;
                                       ^0
 2977|       |
 2978|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 2979|       |
 2980|      1|        assert!(!app.current_content.starts_with('\u{FEFF}'));
 2981|      1|        assert!(app.current_content.starts_with("# Heading"));
 2982|      1|        Ok(())
 2983|      1|    }
 2984|       |
 2985|       |    #[test]
 2986|      1|    fn test_app_creation() {
 2987|      1|        let app = MarkdownViewerApp::new();
 2988|      1|        assert!(!app.parsed_elements.is_empty()); // Should load welcome content
 2989|      1|        assert!(app.title.contains(APP_TITLE_PREFIX));
 2990|      1|        assert!(app.error_message.is_none());
 2991|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 2992|      1|    }
 2993|       |
 2994|       |    #[test]
 2995|      1|    fn test_load_content() {
 2996|      1|        let mut app = MarkdownViewerApp::new();
 2997|      1|        let content = "# Test Header\n\nThis is test content.";
 2998|       |
 2999|      1|        app.load_content(content, Some("Test".to_string()));
 3000|       |
 3001|      1|        assert_eq!(app.current_content, content);
 3002|      1|        assert_eq!(app.raw_buffer, content);
 3003|      1|        assert!(app.title.contains("Test"));
 3004|      1|        assert!(!app.parsed_elements.is_empty());
 3005|      1|        assert!(app.error_message.is_none());
 3006|      1|    }
 3007|       |
 3008|       |    #[test]
 3009|      1|    fn test_toggle_view_mode() {
 3010|      1|        let mut app = MarkdownViewerApp::new();
 3011|      1|        let ctx = egui::Context::default();
 3012|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 3013|      1|        app.toggle_view_mode(&ctx);
 3014|      1|        assert!(matches!(app.view_mode, ViewMode::Raw));
                              ^0
 3015|      1|        app.toggle_view_mode(&ctx);
 3016|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 3017|      1|    }
 3018|       |
 3019|       |    #[test]
 3020|      1|    fn test_toggle_view_mode_without_text_state() {
 3021|      1|        let mut app = MarkdownViewerApp::new();
 3022|      1|        app.view_mode = ViewMode::Raw;
 3023|      1|        app.write_enabled = true;
 3024|      1|        let ctx = egui::Context::default();
 3025|      1|        app.toggle_view_mode(&ctx);
 3026|      1|        assert!(matches!(app.view_mode, ViewMode::Rendered));
                              ^0
 3027|      1|        assert!(app.raw_cursor.is_none());
 3028|      1|    }
 3029|       |
 3030|       |    #[test]
 3031|      1|    fn test_load_sample() {
 3032|      1|        let mut app = MarkdownViewerApp::new();
 3033|      1|        let sample = &SAMPLE_FILES[0]; // First sample file
 3034|       |
 3035|      1|        app.load_sample(sample);
 3036|       |
 3037|      1|        assert_eq!(app.current_content, sample.content);
 3038|      1|        assert!(app.title.contains(sample.title));
 3039|      1|        assert!(!app.parsed_elements.is_empty());
 3040|      1|        assert!(app.current_file.is_none()); // Sample files don't set file path
 3041|      1|    }
 3042|       |
 3043|       |    #[test]
 3044|      1|    fn test_load_sample_without_existing_content_skips_history() {
 3045|      1|        let mut app = MarkdownViewerApp::new();
 3046|      1|        app.current_content.clear();
 3047|      1|        app.raw_buffer.clear();
 3048|      1|        app.history.clear();
 3049|      1|        app.history_index = 0;
 3050|      1|        let sample = &SAMPLE_FILES[0];
 3051|       |
 3052|      1|        app.load_sample(sample);
 3053|       |
 3054|      1|        assert!(app.history.is_empty());
 3055|      1|    }
 3056|       |
 3057|       |    #[test]
 3058|      1|    fn test_load_file() -> Result<()> {
 3059|      1|        let mut app = MarkdownViewerApp::new();
 3060|       |
 3061|       |        // Create a temporary markdown file
 3062|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3063|      1|        let content = "# Temporary File\n\nThis is a test markdown file.";
 3064|      1|        temp_file.write_all(content.as_bytes())?;
                                                             ^0
 3065|      1|        temp_file.flush()?;
                                       ^0
 3066|       |
 3067|      1|        let path = temp_file.path().to_path_buf();
 3068|      1|        app.load_file(path.clone(), true)?;
                                                       ^0
 3069|       |
 3070|      1|        assert_eq!(app.current_content, content);
 3071|      1|        assert_eq!(app.current_file, Some(path));
 3072|      1|        assert!(!app.parsed_elements.is_empty());
 3073|      1|        assert!(app.error_message.is_none());
 3074|       |
 3075|      1|        Ok(())
 3076|      1|    }
 3077|       |
 3078|       |    #[test]
 3079|      1|    fn test_load_file_async_sends_request() -> Result<()> {
 3080|      1|        let mut app = MarkdownViewerApp::new();
 3081|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3082|      1|        let payload = vec![b'a'; ASYNC_LOAD_THRESHOLD_BYTES as usize];
 3083|      1|        temp_file.write_all(&payload)?;
                                                   ^0
 3084|      1|        temp_file.flush()?;
                                       ^0
 3085|       |
 3086|      1|        let path = temp_file.path().to_path_buf();
 3087|      1|        app.load_file(path.clone(), false)?;
                                                        ^0
 3088|      1|        assert!(app.pending_file_load.is_some());
 3089|      1|        assert_eq!(
 3090|      1|            app.pending_file_load.as_ref().expect("pending").path,
 3091|       |            path
 3092|       |        );
 3093|      1|        Ok(())
 3094|      1|    }
 3095|       |
 3096|       |    #[test]
 3097|      1|    fn test_load_file_skips_async_when_screenshot_active() -> Result<()> {
 3098|      1|        let mut app = MarkdownViewerApp::new();
 3099|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3100|      1|        let payload = vec![b'a'; ASYNC_LOAD_THRESHOLD_BYTES as usize];
 3101|      1|        temp_file.write_all(&payload)?;
                                                   ^0
 3102|      1|        temp_file.flush()?;
                                       ^0
 3103|       |
 3104|      1|        let config = ScreenshotConfig {
 3105|      1|            output_path: temp_file.path().with_extension("png"),
 3106|      1|            viewport_width: 120.0,
 3107|      1|            viewport_height: 80.0,
 3108|      1|            content_only: false,
 3109|      1|            scroll_ratio: None,
 3110|      1|            wait_ms: 0,
 3111|      1|            settle_frames: 0,
 3112|      1|            zoom: 1.0,
 3113|      1|            theme: ScreenshotTheme::Light,
 3114|      1|            font_source: None,
 3115|      1|        };
 3116|      1|        app.screenshot = Some(ScreenshotState::new(config));
 3117|       |
 3118|      1|        let path = temp_file.path().to_path_buf();
 3119|      1|        app.load_file(path.clone(), false)?;
                                                        ^0
 3120|       |
 3121|      1|        assert!(app.pending_file_load.is_none());
 3122|      1|        assert_eq!(app.current_file, Some(path));
 3123|      1|        Ok(())
 3124|      1|    }
 3125|       |
 3126|       |    #[test]
 3127|      1|    fn test_load_file_async_falls_back_when_channel_closed() -> Result<()> {
 3128|      1|        let mut app = MarkdownViewerApp::new();
 3129|      1|        let (tx, rx) = unbounded::<FileLoadRequest>();
 3130|      1|        drop(rx);
 3131|      1|        app.file_load_tx = tx;
 3132|       |
 3133|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3134|      1|        let payload = vec![b'a'; ASYNC_LOAD_THRESHOLD_BYTES as usize];
 3135|      1|        temp_file.write_all(&payload)?;
                                                   ^0
 3136|      1|        temp_file.flush()?;
                                       ^0
 3137|       |
 3138|      1|        let path = temp_file.path().to_path_buf();
 3139|      1|        app.load_file(path.clone(), false)?;
                                                        ^0
 3140|      1|        assert_eq!(app.current_file, Some(path));
 3141|      1|        assert!(app.pending_file_load.is_none());
 3142|      1|        Ok(())
 3143|      1|    }
 3144|       |
 3145|       |    #[test]
 3146|      1|    fn test_poll_file_loads_handles_mismatch_and_lossy() {
 3147|      1|        let mut app = MarkdownViewerApp::new();
 3148|      1|        let (result_tx, result_rx) = unbounded::<FileLoadResult>();
 3149|      1|        app.file_load_rx = result_rx;
 3150|       |
 3151|      1|        let temp = NamedTempFile::new().expect("temp");
 3152|      1|        let path = temp.path().to_path_buf();
 3153|      1|        app.pending_file_load = Some(PendingFileLoad { id: 1, path: path.clone() });
 3154|       |
 3155|      1|        result_tx
 3156|      1|            .send(FileLoadResult {
 3157|      1|                id: 2,
 3158|      1|                content: Ok(("ignored".to_string(), false)),
 3159|      1|            })
 3160|      1|            .expect("send mismatch");
 3161|      1|        app.poll_file_loads();
 3162|      1|        assert!(app.pending_file_load.is_some());
 3163|       |
 3164|      1|        result_tx
 3165|      1|            .send(FileLoadResult {
 3166|      1|                id: 1,
 3167|      1|                content: Ok(("loaded".to_string(), true)),
 3168|      1|            })
 3169|      1|            .expect("send match");
 3170|      1|        app.poll_file_loads();
 3171|      1|        assert!(app.pending_file_load.is_none());
 3172|      1|        assert_eq!(app.current_file, Some(path));
 3173|      1|    }
 3174|       |
 3175|       |    #[test]
 3176|      1|    fn test_load_invalid_markdown() {
 3177|      1|        let mut app = MarkdownViewerApp::new();
 3178|       |        // Even "invalid" markdown should parse successfully with pulldown-cmark
 3179|       |        // as it's very permissive
 3180|      1|        let content = "This is just plain text with some <invalid> HTML tags";
 3181|       |
 3182|      1|        app.load_content(content, Some("Invalid".to_string()));
 3183|       |
 3184|       |        // Should still work - pulldown-cmark is very permissive
 3185|      1|        assert_eq!(app.current_content, content);
 3186|      1|        assert!(app.error_message.is_none());
 3187|      1|    }
 3188|       |
 3189|       |    #[test]
 3190|      1|    fn test_load_content_parse_error_sets_message() {
 3191|      1|        let mut app = MarkdownViewerApp::new();
 3192|      1|        crate::markdown_renderer::force_parse_error_once();
 3193|       |
 3194|      1|        app.load_content("# Bad Parse", Some("Bad".to_string()));
 3195|       |
 3196|      1|        assert!(app
 3197|      1|            .error_message
 3198|      1|            .as_ref()
 3199|      1|            .is_some_and(|msg| msg.contains("Failed to parse markdown")));
 3200|      1|        assert!(app.parsed_elements.is_empty());
 3201|      1|    }
 3202|       |
 3203|       |    #[test]
 3204|      1|    fn test_load_empty_content() {
 3205|      1|        let mut app = MarkdownViewerApp::new();
 3206|      1|        app.load_content("", Some("Empty".to_string()));
 3207|       |
 3208|      1|        assert_eq!(app.current_content, "");
 3209|      1|        assert!(app.title.contains("Empty"));
 3210|      1|        assert!(app.error_message.is_none());
 3211|      1|    }
 3212|       |
 3213|       |    #[test]
 3214|      1|    fn test_load_nonexistent_file() {
 3215|      1|        let mut app = MarkdownViewerApp::new();
 3216|      1|        let fake_path = PathBuf::from("/nonexistent/file.md");
 3217|       |
 3218|      1|        let result = app.load_file(fake_path, true);
 3219|      1|        assert!(result.is_err());
 3220|      1|    }
 3221|       |
 3222|       |    #[test]
 3223|      1|    fn test_reload_current_file() -> Result<()> {
 3224|      1|        let mut app = MarkdownViewerApp::new();
 3225|       |
 3226|       |        // Create a temporary markdown file
 3227|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3228|      1|        let content1 = "# Title\n\nVersion 1";
 3229|      1|        temp_file.write_all(content1.as_bytes())?;
                                                              ^0
 3230|      1|        temp_file.flush()?;
                                       ^0
 3231|       |
 3232|      1|        let path = temp_file.path().to_path_buf();
 3233|      1|        app.load_file(path.clone(), true)?;
                                                       ^0
 3234|      1|        assert!(app.current_content.contains("Version 1"));
 3235|       |
 3236|       |        // Update file content
 3237|      1|        let content2 = "# Title\n\nVersion 2";
 3238|      1|        temp_file.as_file_mut().set_len(0)?; // clear
                                                        ^0
 3239|      1|        temp_file.write_all(content2.as_bytes())?;
                                                              ^0
 3240|      1|        temp_file.flush()?;
                                       ^0
 3241|       |
 3242|       |        // Reload and verify
 3243|      1|        app.reload_current_file()?;
                                               ^0
 3244|      1|        assert!(app.current_content.contains("Version 2"));
 3245|      1|        Ok(())
 3246|      1|    }
 3247|       |
 3248|       |    #[test]
 3249|      1|    fn test_load_file_with_invalid_utf8() -> Result<()> {
 3250|      1|        let mut app = MarkdownViewerApp::new();
 3251|      1|        let mut temp_file = NamedTempFile::new()?;
                                                              ^0
 3252|      1|        let bytes = b"Hello\xFFWorld";
 3253|      1|        temp_file.write_all(bytes)?;
                                                ^0
 3254|      1|        temp_file.flush()?;
                                       ^0
 3255|       |
 3256|      1|        app.load_file(temp_file.path().to_path_buf(), true)?;
                                                                         ^0
 3257|       |
 3258|      1|        assert!(app.current_content.contains('\u{FFFD}'));
 3259|      1|        assert!(!app.parsed_elements.is_empty());
 3260|      1|        assert!(app.error_message.is_none());
 3261|      1|        Ok(())
 3262|      1|    }
 3263|       |
 3264|       |    #[test]
 3265|      1|    fn test_reload_without_file() {
 3266|      1|        let mut app = MarkdownViewerApp::new();
 3267|      1|        assert!(app.current_file.is_none());
 3268|      1|        let result = app.reload_current_file();
 3269|      1|        assert!(result.is_err());
 3270|      1|    }
 3271|       |
 3272|       |    #[test]
 3273|      1|    fn test_window_state_change_detection() {
 3274|      1|        let mut app = MarkdownViewerApp::new();
 3275|      1|        app.last_window_pos = Some([10.0, 10.0]);
 3276|      1|        app.last_window_size = Some([800.0, 600.0]);
 3277|      1|        app.last_window_maximized = false;
 3278|       |
 3279|      1|        let state = app.current_window_state().expect("state");
 3280|      1|        assert!(app.window_state_changed(&state));
 3281|      1|        app.last_persisted_state = Some(state);
 3282|      1|        assert!(!app.window_state_changed(&state));
 3283|       |
 3284|      1|        let mut moved = state;
 3285|      1|        moved.pos = [12.0, 10.0];
 3286|      1|        assert!(app.window_state_changed(&moved));
 3287|       |
 3288|      1|        let mut resized = state;
 3289|      1|        resized.size = [820.0, 610.0];
 3290|      1|        assert!(app.window_state_changed(&resized));
 3291|       |
 3292|      1|        let mut maximized = state;
 3293|      1|        maximized.maximized = true;
 3294|      1|        assert!(app.window_state_changed(&maximized));
 3295|      1|    }
 3296|       |
 3297|       |    #[test]
 3298|      1|    fn test_fold_for_search_handles_case_and_accents() {
 3299|      1|        assert_eq!(
 3300|      1|            MarkdownViewerApp::fold_for_search("\u{00C4}\u{00DF}"),
 3301|      1|            MarkdownViewerApp::fold_for_search("\u{00E4}SS")
 3302|       |        );
 3303|      1|        assert_eq!(
 3304|      1|            MarkdownViewerApp::fold_for_search("To\u{0301}m"),
 3305|      1|            MarkdownViewerApp::fold_for_search("T\u{00D3}m")
 3306|       |        );
 3307|      1|    }
 3308|       |
 3309|       |    #[test]
 3310|      1|    fn test_title_updates() {
 3311|      1|        let mut app = MarkdownViewerApp::new();
 3312|       |
 3313|       |        // Test with custom title
 3314|      1|        app.load_content("# Test", Some("Custom Title".to_string()));
 3315|      1|        assert!(app.title.contains("Custom Title"));
 3316|       |
 3317|       |        // Test with no title (should keep existing)
 3318|      1|        let old_title = app.title.clone();
 3319|      1|        app.load_content("# Another Test", None);
 3320|      1|        assert_eq!(app.title, old_title); // Should remain unchanged
 3321|      1|    }
 3322|       |
 3323|       |    #[test]
 3324|      1|    fn test_complex_markdown_loading() {
 3325|      1|        let mut app = MarkdownViewerApp::new();
 3326|      1|        let complex_content = r#"# Complex Document
 3327|      1|
 3328|      1|## With Multiple Sections
 3329|      1|
 3330|      1|This has **bold** and *italic* text.
 3331|      1|
 3332|      1|```rust
 3333|      1|fn main() {
 3334|      1|    println!("Hello, world!");
 3335|      1|}
 3336|      1|```
 3337|      1|
 3338|      1|- List item 1
 3339|      1|- List item 2
 3340|      1|
 3341|      1|> A blockquote
 3342|      1|
 3343|      1|[A link](https://example.com)
 3344|      1|
 3345|      1|---
 3346|      1|
 3347|      1|The end.
 3348|      1|"#;
 3349|       |
 3350|      1|        app.load_content(complex_content, Some("Complex".to_string()));
 3351|       |
 3352|      1|        assert_eq!(app.current_content, complex_content);
 3353|      1|        assert!(app.title.contains("Complex"));
 3354|      1|        assert!(!app.parsed_elements.is_empty());
 3355|      1|        assert!(app.error_message.is_none());
 3356|       |
 3357|       |        // Should have parsed various element types
 3358|      1|        assert!(app.parsed_elements.len() > 5); // Complex document should have many elements
 3359|      1|    }
 3360|       |
 3361|       |    #[test]
 3362|      1|    fn test_error_handling() {
 3363|      1|        let app = MarkdownViewerApp::new();
 3364|       |
 3365|       |        // Test that app starts without errors
 3366|      1|        assert!(app.error_message.is_none());
 3367|       |
 3368|       |        // Even with the welcome content loaded, should be error-free
 3369|      1|        assert!(!app.parsed_elements.is_empty());
 3370|      1|    }
 3371|       |
 3372|       |    #[test]
 3373|      1|    fn test_default_state() {
 3374|      1|        let app = MarkdownViewerApp::default();
 3375|       |
 3376|       |        // Default should be same as new()
 3377|      1|        assert!(!app.parsed_elements.is_empty());
 3378|      1|        assert!(app.title.contains(APP_TITLE_PREFIX));
 3379|      1|        assert!(app.error_message.is_none());
 3380|      1|        assert!(app.current_file.is_none());
 3381|      1|    }
 3382|       |
 3383|       |    #[test]
 3384|      1|    fn test_sample_files_integration() {
 3385|      1|        let mut app = MarkdownViewerApp::new();
 3386|       |
 3387|       |        // Test loading each sample file
 3388|      7|        for sample in SAMPLE_FILES {
                          ^6
 3389|      6|            app.load_sample(sample);
 3390|       |
 3391|      6|            assert_eq!(app.current_content, sample.content);
 3392|      6|            assert!(app.title.contains(sample.title));
 3393|      6|            assert!(app.current_file.is_none());
 3394|      6|            assert!(app.error_message.is_none());
 3395|       |        }
 3396|      1|    }
 3397|       |
 3398|       |    #[test]
 3399|      1|    fn test_close_current_file() {
 3400|      1|        let mut app = MarkdownViewerApp::new();
 3401|       |
 3402|       |        // Load some content first
 3403|      1|        app.load_content("# Test Content", Some("Test File".to_string()));
 3404|      1|        assert!(app.title.contains("Test File"));
 3405|       |
 3406|       |        // Close the file
 3407|      1|        app.close_current_file();
 3408|       |
 3409|       |        // Should return to welcome screen
 3410|      1|        assert!(app.title.contains("Welcome"));
 3411|      1|        assert!(app.current_file.is_none());
 3412|      1|        assert!(!app.parsed_elements.is_empty()); // Should have welcome content
 3413|      1|        assert!(app.error_message.is_none());
 3414|      1|    }
 3415|       |
 3416|       |    #[test]
 3417|      1|    fn test_navigation_request_enum() {
 3418|       |        // Test that the enum values exist and are correct
 3419|      1|        let _top = NavigationRequest::Top;
 3420|      1|        let _bottom = NavigationRequest::Bottom;
 3421|      1|        let _page_up = NavigationRequest::PageUp;
 3422|      1|        let _page_down = NavigationRequest::PageDown;
 3423|      1|        let _scroll_up = NavigationRequest::ScrollUp;
 3424|      1|        let _scroll_down = NavigationRequest::ScrollDown;
 3425|       |
 3426|       |        // Ensure it's cloneable and debuggable
 3427|      1|        let nav = NavigationRequest::Top;
 3428|      1|        let _cloned = nav.clone();
 3429|      1|        let _debug = format!("{:?}", nav);
 3430|       |
 3431|       |        // Basic compilation test performed by using the enum and Debug/Clone
 3432|      1|    }
 3433|       |
 3434|       |    #[test]
 3435|      1|    fn test_navigation_state_initialization() {
 3436|      1|        let app = MarkdownViewerApp::new();
 3437|       |        // Test that nav_request is initialized to None
 3438|      1|        assert!(app.nav_request.is_none());
 3439|       |        // Test that fullscreen toggle flag is initialized to false
 3440|      1|        assert!(!app.toggle_fullscreen);
 3441|      1|    }
 3442|       |
 3443|       |    #[test]
 3444|      1|    fn test_fullscreen_toggle_flag() {
 3445|      1|        let mut app = MarkdownViewerApp::new();
 3446|       |
 3447|       |        // Initially should be false
 3448|      1|        assert!(!app.toggle_fullscreen);
 3449|       |
 3450|       |        // Simulate F11 key press (this would be set in handle_shortcuts)
 3451|      1|        app.toggle_fullscreen = true;
 3452|      1|        assert!(app.toggle_fullscreen);
 3453|       |
 3454|       |        // After handling, it should be reset to false
 3455|      1|        app.toggle_fullscreen = false;
 3456|      1|        assert!(!app.toggle_fullscreen);
 3457|      1|    }
 3458|       |
 3459|       |    #[test]
 3460|      1|    fn test_navigation_state_reset_on_load() {
 3461|      1|        let mut app = MarkdownViewerApp::new();
 3462|       |
 3463|       |        // Set a navigation request
 3464|      1|        app.nav_request = Some(NavigationRequest::Top);
 3465|      1|        assert!(app.nav_request.is_some());
 3466|       |
 3467|       |        // Load content should reset navigation state
 3468|      1|        app.load_content("# Test Content", Some("Test".to_string()));
 3469|      1|        assert!(app.nav_request.is_none());
 3470|      1|    }
 3471|       |
 3472|       |    #[test]
 3473|      1|    fn test_page_navigation_calculations() {
 3474|       |        // Test the page size calculation logic used in navigation
 3475|      1|        let viewport_height = 800.0f32;
 3476|      1|        let page_size = viewport_height * 0.8;
 3477|      1|        assert_eq!(page_size, 640.0);
 3478|       |
 3479|       |        // Test boundary conditions for Page Up
 3480|      1|        let current_offset = 100.0f32;
 3481|      1|        let new_offset_up = (current_offset - page_size).max(0.0);
 3482|      1|        assert_eq!(new_offset_up, 0.0); // Should clamp to 0
 3483|       |
 3484|       |        // Test Page Down calculation
 3485|      1|        let new_offset_down = current_offset + page_size;
 3486|      1|        assert_eq!(new_offset_down, 740.0);
 3487|       |
 3488|       |        // Test that Page Up from near top goes to 0
 3489|      1|        let near_top = 300.0f32;
 3490|      1|        let from_near_top = (near_top - page_size).max(0.0);
 3491|      1|        assert_eq!(from_near_top, 0.0);
 3492|      1|    }
 3493|       |
 3494|       |    #[test]
 3495|      1|    fn test_compute_window_adjustment_clamps_offscreen_window() {
 3496|      1|        let outer = egui::Rect::from_min_size(egui::pos2(1200.0, 900.0), egui::vec2(800.0, 600.0));
 3497|      1|        let monitor = egui::vec2(1024.0, 768.0);
 3498|      1|        let adjustment =
 3499|      1|            MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), Some(monitor))
 3500|      1|                .expect("should adjust window geometry");
 3501|      1|        let pos = adjustment.pos.expect("expected position adjustment");
 3502|      1|        let size = adjustment.size.unwrap_or_else(|| outer.size());
 3503|      1|        assert!(pos.x <= monitor.x - size.x + 1.0);
 3504|      1|        assert!(pos.y <= monitor.y - size.y + 1.0);
 3505|      1|        assert!(adjustment.size.is_none());
 3506|      1|    }
 3507|       |
 3508|       |    #[test]
 3509|      1|    fn test_compute_window_adjustment_respects_min_size() {
 3510|      1|        let outer = egui::Rect::from_min_size(egui::pos2(-200.0, -100.0), egui::vec2(200.0, 100.0));
 3511|      1|        let monitor = egui::vec2(1920.0, 1080.0);
 3512|      1|        let adjustment =
 3513|      1|            MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), Some(monitor))
 3514|      1|                .expect("should enforce minimum window size");
 3515|      1|        let pos = adjustment.pos.unwrap_or(outer.min);
 3516|      1|        let size = adjustment.size.expect("expected size adjustment");
 3517|      1|        assert!(size.x >= 600.0);
 3518|      1|        assert!(size.y >= 400.0);
 3519|      1|        assert!(pos.x >= 0.0);
 3520|      1|        assert!(pos.y >= 0.0);
 3521|      1|    }
 3522|       |
 3523|       |    #[test]
 3524|      1|    fn test_is_valid_markdown_file() {
 3525|      1|        let app = MarkdownViewerApp::new();
 3526|       |
 3527|       |        // Valid markdown extensions
 3528|      1|        assert!(app.is_valid_markdown_file(Path::new("test.md")));
 3529|      1|        assert!(app.is_valid_markdown_file(Path::new("test.markdown")));
 3530|      1|        assert!(app.is_valid_markdown_file(Path::new("test.mdown")));
 3531|      1|        assert!(app.is_valid_markdown_file(Path::new("test.mkd")));
 3532|      1|        assert!(app.is_valid_markdown_file(Path::new("test.txt")));
 3533|       |
 3534|       |        // Case insensitive
 3535|      1|        assert!(app.is_valid_markdown_file(Path::new("test.MD")));
 3536|      1|        assert!(app.is_valid_markdown_file(Path::new("test.Markdown")));
 3537|       |
 3538|       |        // Invalid extensions
 3539|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.pdf")));
 3540|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.docx")));
 3541|      1|        assert!(!app.is_valid_markdown_file(Path::new("test.html")));
 3542|       |
 3543|       |        // No extension
 3544|      1|        assert!(!app.is_valid_markdown_file(Path::new("test")));
 3545|      1|    }
 3546|       |
 3547|       |    #[test]
 3548|      1|    fn test_scan_directory() -> Result<()> {
 3549|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3550|      1|        let dir_path = temp_dir.path();
 3551|       |
 3552|       |        // Create test files
 3553|      1|        std::fs::write(dir_path.join("zebra.md"), "# Z")?;
                                                                      ^0
 3554|      1|        std::fs::write(dir_path.join("alpha.md"), "# A")?;
                                                                      ^0
 3555|      1|        std::fs::write(dir_path.join("image.png"), "fake")?;
                                                                        ^0
 3556|      1|        std::fs::write(dir_path.join("beta.markdown"), "# B")?;
                                                                           ^0
 3557|       |
 3558|       |        // Create subdirectory (should be ignored)
 3559|      1|        std::fs::create_dir(dir_path.join("subdir"))?;
                                                                  ^0
 3560|      1|        std::fs::write(dir_path.join("subdir/nested.md"), "# N")?;
                                                                              ^0
 3561|       |
 3562|      1|        let app = MarkdownViewerApp::new();
 3563|      1|        let files = app.scan_directory(dir_path)?;
                                                              ^0
 3564|       |
 3565|       |        // Should find 3 markdown files (alpha, beta, zebra)
 3566|       |        // Should NOT find image.png or nested.md
 3567|      1|        assert_eq!(files.len(), 3);
 3568|       |
 3569|       |        // Should be sorted alphabetically
 3570|      1|        assert!(files[0].ends_with("alpha.md"));
 3571|      1|        assert!(files[1].ends_with("beta.markdown"));
 3572|      1|        assert!(files[2].ends_with("zebra.md"));
 3573|       |
 3574|      1|        Ok(())
 3575|      1|    }
 3576|       |
 3577|       |    #[test]
 3578|      1|    fn test_scan_empty_directory() -> Result<()> {
 3579|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3580|      1|        let app = MarkdownViewerApp::new();
 3581|      1|        let files = app.scan_directory(temp_dir.path())?;
                                                                     ^0
 3582|       |
 3583|      1|        assert_eq!(files.len(), 0);
 3584|      1|        Ok(())
 3585|      1|    }
 3586|       |
 3587|       |    #[test]
 3588|      1|    fn test_single_file_drop() -> Result<()> {
 3589|      1|        let mut app = MarkdownViewerApp::new();
 3590|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3591|      1|        let file = temp_dir.path().join("test.md");
 3592|      1|        std::fs::write(&file, "# Test")?;
                                                     ^0
 3593|       |
 3594|      1|        app.handle_file_drop(vec![file.clone()]);
 3595|       |
 3596|      1|        assert_eq!(app.current_file, Some(file));
 3597|      1|        assert!(app.pending_files.is_empty());
 3598|      1|        assert!(app.error_message.is_none());
 3599|      1|        Ok(())
 3600|      1|    }
 3601|       |
 3602|       |    #[test]
 3603|      1|    fn test_multiple_files_drop() -> Result<()> {
 3604|      1|        let mut app = MarkdownViewerApp::new();
 3605|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3606|       |
 3607|      1|        let files: Vec<PathBuf> = (0..5)
 3608|      5|            .map(|i| {
                           ^1
 3609|      5|                let path = temp_dir.path().join(format!("file{}.md", i));
 3610|      5|                std::fs::write(&path, format!("# File {}", i)).unwrap();
 3611|      5|                path
 3612|      5|            })
 3613|      1|            .collect();
 3614|       |
 3615|      1|        app.handle_file_drop(files.clone());
 3616|       |
 3617|      1|        assert_eq!(app.current_file, Some(files[0].clone()));
 3618|      1|        assert_eq!(app.pending_files.len(), 4);
 3619|      1|        Ok(())
 3620|      1|    }
 3621|       |
 3622|       |    #[test]
 3623|      1|    fn test_directory_drop() -> Result<()> {
 3624|      1|        let mut app = MarkdownViewerApp::new();
 3625|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3626|       |
 3627|       |        // Create files in directory
 3628|      1|        std::fs::write(temp_dir.path().join("a.md"), "# A")?;
                                                                         ^0
 3629|      1|        std::fs::write(temp_dir.path().join("b.md"), "# B")?;
                                                                         ^0
 3630|      1|        std::fs::write(temp_dir.path().join("c.md"), "# C")?;
                                                                         ^0
 3631|       |
 3632|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 3633|       |
 3634|      1|        assert!(app.current_file.is_some());
 3635|      1|        assert_eq!(app.pending_files.len(), 2);
 3636|      1|        Ok(())
 3637|      1|    }
 3638|       |
 3639|       |    #[test]
 3640|      1|    fn test_invalid_file_drop() {
 3641|      1|        let mut app = MarkdownViewerApp::new();
 3642|      1|        let temp_dir = tempfile::TempDir::new().unwrap();
 3643|      1|        let file = temp_dir.path().join("test.pdf");
 3644|      1|        std::fs::write(&file, "fake pdf").unwrap();
 3645|       |
 3646|      1|        app.handle_file_drop(vec![file]);
 3647|       |
 3648|       |        // Current file should remain None (or welcome sample)
 3649|      1|        assert!(app.error_message.is_some());
 3650|      1|        assert!(app
 3651|      1|            .error_message
 3652|      1|            .as_ref()
 3653|      1|            .unwrap()
 3654|      1|            .contains("Not a markdown file"));
 3655|      1|    }
 3656|       |
 3657|       |    #[test]
 3658|      1|    fn test_too_many_files() {
 3659|      1|        let mut app = MarkdownViewerApp::new();
 3660|      1|        let temp_dir = tempfile::TempDir::new().unwrap();
 3661|       |
 3662|      1|        let files: Vec<PathBuf> = (0..60)
 3663|     60|            .map(|i| {
                           ^1
 3664|     60|                let path = temp_dir.path().join(format!("file{}.md", i));
 3665|     60|                std::fs::write(&path, format!("# File {}", i)).unwrap();
 3666|     60|                path
 3667|     60|            })
 3668|      1|            .collect();
 3669|       |
 3670|      1|        app.handle_file_drop(files);
 3671|       |
 3672|      1|        assert!(app.error_message.is_some());
 3673|      1|        assert!(app
 3674|      1|            .error_message
 3675|      1|            .as_ref()
 3676|      1|            .unwrap()
 3677|      1|            .contains("Too many files"));
 3678|      1|    }
 3679|       |
 3680|       |    #[test]
 3681|      1|    fn test_queue_navigation() -> Result<()> {
 3682|      1|        let mut app = MarkdownViewerApp::new();
 3683|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3684|       |
 3685|      1|        let file1 = temp_dir.path().join("file1.md");
 3686|      1|        let file2 = temp_dir.path().join("file2.md");
 3687|       |
 3688|      1|        std::fs::write(&file1, "# File 1")?;
                                                        ^0
 3689|      1|        std::fs::write(&file2, "# File 2")?;
                                                        ^0
 3690|       |
 3691|       |        // Load first file and queue second
 3692|      1|        app.load_file(file1.clone(), true)?;
                                                        ^0
 3693|      1|        app.pending_files.push_back(file2.clone());
 3694|       |
 3695|      1|        assert!(app.can_navigate_forward());
 3696|      1|        app.navigate_forward();
 3697|      1|        assert_eq!(app.current_file, Some(file2));
 3698|      1|        assert!(app.pending_files.is_empty());
 3699|       |
 3700|      1|        Ok(())
 3701|      1|    }
 3702|       |
 3703|       |    #[test]
 3704|      1|    fn test_mixed_valid_invalid_files() -> Result<()> {
 3705|      1|        let mut app = MarkdownViewerApp::new();
 3706|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3707|       |
 3708|      1|        let md_file = temp_dir.path().join("test.md");
 3709|      1|        let pdf_file = temp_dir.path().join("test.pdf");
 3710|       |
 3711|      1|        std::fs::write(&md_file, "# Test")?;
                                                        ^0
 3712|      1|        std::fs::write(&pdf_file, "fake pdf")?;
                                                           ^0
 3713|       |
 3714|      1|        app.handle_file_drop(vec![md_file.clone(), pdf_file]);
 3715|       |
 3716|       |        // Should open the valid markdown file
 3717|      1|        assert_eq!(app.current_file, Some(md_file));
 3718|       |        // Should show error about the invalid file
 3719|      1|        assert!(app.error_message.is_some());
 3720|      1|        Ok(())
 3721|      1|    }
 3722|       |
 3723|       |    #[test]
 3724|      1|    fn test_empty_directory_drop() -> Result<()> {
 3725|      1|        let mut app = MarkdownViewerApp::new();
 3726|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3727|       |
 3728|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 3729|       |
 3730|      1|        assert!(app.error_message.is_some());
 3731|      1|        assert!(app
 3732|      1|            .error_message
 3733|      1|            .as_ref()
 3734|      1|            .unwrap()
 3735|      1|            .contains("No markdown files"));
 3736|      1|        Ok(())
 3737|      1|    }
 3738|       |
 3739|       |    #[test]
 3740|      1|    fn test_toggle_write_mode_tracks_cursor_and_focus() {
 3741|      1|        let mut app = MarkdownViewerApp::new();
 3742|      1|        app.view_mode = ViewMode::Raw;
 3743|      1|        app.write_enabled = false;
 3744|      1|        app.raw_focus_requested = false;
 3745|       |
 3746|      1|        let ctx = egui::Context::default();
 3747|      1|        let editor_id = egui::Id::new("raw_editor");
 3748|      1|        let mut state = egui::text_edit::TextEditState::default();
 3749|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(3));
 3750|      1|        state.cursor.set_char_range(Some(cr));
 3751|      1|        state.store(&ctx, editor_id);
 3752|       |
 3753|      1|        app.toggle_write_mode(&ctx);
 3754|      1|        assert!(app.write_enabled);
 3755|      1|        assert!(app.raw_focus_requested);
 3756|       |
 3757|      1|        app.toggle_write_mode(&ctx);
 3758|      1|        assert!(!app.write_enabled);
 3759|      1|        assert_eq!(app.raw_cursor, Some(3));
 3760|      1|    }
 3761|       |
 3762|       |    #[test]
 3763|      1|    fn test_find_next_and_previous_wraps() {
 3764|      1|        let mut app = MarkdownViewerApp::new();
 3765|      1|        app.load_content("Alpha\n\nBeta\n\nGamma", Some("Search".to_string()));
 3766|      1|        app.search_query = "beta".to_string();
 3767|       |
 3768|      1|        app.find_next();
 3769|      1|        assert_eq!(app.last_match_index, Some(1));
 3770|      1|        assert_eq!(app.pending_scroll_to_element, Some(1));
 3771|       |
 3772|      1|        app.find_next();
 3773|      1|        assert_eq!(app.last_match_index, Some(1));
 3774|       |
 3775|      1|        app.find_previous();
 3776|      1|        assert_eq!(app.last_match_index, Some(1));
 3777|      1|    }
 3778|       |
 3779|       |    #[test]
 3780|      1|    fn test_update_impl_rendered_view_runs() -> Result<()> {
 3781|      1|        let mut app = MarkdownViewerApp::new();
 3782|      1|        app.nav_request = Some(NavigationRequest::PageDown);
 3783|      1|        app.toggle_fullscreen = true;
 3784|       |
 3785|      1|        let mut temp_file = tempfile::Builder::new().suffix(".md").tempfile()?;
                                                                                           ^0
 3786|      1|        temp_file.write_all(b"# Dropped\nContent")?;
                                                                ^0
 3787|      1|        temp_file.flush()?;
                                       ^0
 3788|       |
 3789|      1|        let ctx = egui::Context::default();
 3790|      1|        let mut input = default_input();
 3791|      1|        if let Some(vp) = input.viewports.get_mut(&egui::ViewportId::ROOT) {
  ------------------
  |  Branch (3791:16): [True: 1, False: 0]
  ------------------
 3792|      1|            vp.monitor_size = Some(egui::vec2(1024.0, 768.0));
 3793|      1|            vp.outer_rect = Some(egui::Rect::from_min_size(
 3794|      1|                egui::pos2(1200.0, 900.0),
 3795|      1|                egui::vec2(800.0, 600.0),
 3796|      1|            ));
 3797|      1|            vp.inner_rect = Some(egui::Rect::from_min_size(
 3798|      1|                egui::pos2(0.0, 0.0),
 3799|      1|                egui::vec2(800.0, 600.0),
 3800|      1|            ));
 3801|      1|            vp.fullscreen = Some(false);
 3802|      1|            vp.maximized = Some(false);
 3803|      1|        }
                      ^0
 3804|      1|        input.hovered_files.push(egui::HoveredFile {
 3805|      1|            path: Some(temp_file.path().to_path_buf()),
 3806|      1|            ..Default::default()
 3807|      1|        });
 3808|      1|        input.dropped_files.push(egui::DroppedFile {
 3809|      1|            path: Some(temp_file.path().to_path_buf()),
 3810|      1|            ..Default::default()
 3811|      1|        });
 3812|       |
 3813|      1|        run_app_frame(&mut app, &ctx, input);
 3814|       |
 3815|      1|        assert!(app.drag_hover);
 3816|      1|        assert!(app.current_file.is_some());
 3817|      1|        assert!(app.last_window_pos.is_some());
 3818|      1|        assert!(app.last_window_size.is_some());
 3819|      1|        Ok(())
 3820|      1|    }
 3821|       |
 3822|       |    #[test]
 3823|      1|    fn test_update_impl_applies_size_adjustment() {
 3824|      1|        let mut app = MarkdownViewerApp::new();
 3825|      1|        let ctx = egui::Context::default();
 3826|      1|        let mut input = default_input();
 3827|      1|        if let Some(vp) = input.viewports.get_mut(&egui::ViewportId::ROOT) {
  ------------------
  |  Branch (3827:16): [True: 1, False: 0]
  ------------------
 3828|      1|            vp.monitor_size = Some(egui::vec2(800.0, 600.0));
 3829|      1|            vp.outer_rect = Some(egui::Rect::from_min_size(
 3830|      1|                egui::pos2(10.0, 10.0),
 3831|      1|                egui::vec2(800.0, 600.0),
 3832|      1|            ));
 3833|      1|            vp.inner_rect = Some(egui::Rect::from_min_size(
 3834|      1|                egui::pos2(0.0, 0.0),
 3835|      1|                egui::vec2(200.0, 100.0),
 3836|      1|            ));
 3837|      1|            vp.fullscreen = Some(false);
 3838|      1|            vp.maximized = Some(false);
 3839|      1|        }
                      ^0
 3840|       |
 3841|      1|        run_app_frame(&mut app, &ctx, input);
 3842|       |
 3843|      1|        assert!(app.last_window_size.is_some());
 3844|      1|        assert!(app.last_window_pos.is_some());
 3845|      1|    }
 3846|       |
 3847|       |    #[test]
 3848|      1|    fn test_update_impl_applies_deferred_toggles() {
 3849|      1|        let mut app = MarkdownViewerApp::new();
 3850|      1|        app.view_toggle_requested = true;
 3851|      1|        app.write_toggle_requested = true;
 3852|       |
 3853|      1|        let ctx = egui::Context::default();
 3854|      1|        run_app_frame(&mut app, &ctx, default_input());
 3855|       |
 3856|      1|        assert_eq!(app.view_mode, ViewMode::Raw);
 3857|      1|        assert!(app.write_enabled);
 3858|      1|    }
 3859|       |
 3860|       |    #[test]
 3861|      1|    fn test_update_impl_reload_without_file_sets_error() {
 3862|      1|        let mut app = MarkdownViewerApp::new();
 3863|      1|        app.reload_requested = true;
 3864|       |
 3865|      1|        let ctx = egui::Context::default();
 3866|      1|        let input = default_input();
 3867|      1|        run_app_frame(&mut app, &ctx, input);
 3868|       |
 3869|      1|        assert!(app.error_message.is_some());
 3870|      1|    }
 3871|       |
 3872|       |    #[test]
 3873|      1|    fn test_update_impl_raw_read_only_renders() {
 3874|      1|        let mut app = MarkdownViewerApp::new();
 3875|      1|        app.view_mode = ViewMode::Raw;
 3876|      1|        app.write_enabled = false;
 3877|      1|        app.raw_buffer = "Line 1\nLine 2".to_string();
 3878|      1|        app.current_content = app.raw_buffer.clone();
 3879|       |
 3880|      1|        let ctx = egui::Context::default();
 3881|      1|        let input = default_input();
 3882|      1|        run_app_frame(&mut app, &ctx, input);
 3883|       |
 3884|      1|        assert_eq!(app.raw_buffer, "Line 1\nLine 2");
 3885|      1|    }
 3886|       |
 3887|       |    #[test]
 3888|      1|    fn test_update_impl_moves_raw_cursor() {
 3889|      1|        let mut app = MarkdownViewerApp::new();
 3890|      1|        app.view_mode = ViewMode::Raw;
 3891|      1|        app.write_enabled = true;
 3892|      1|        app.raw_buffer = "Line 1\nLine 2\nLine 3".to_string();
 3893|      1|        app.current_content = app.raw_buffer.clone();
 3894|      1|        app.pending_raw_cursor_line_move = Some(1);
 3895|       |
 3896|      1|        let ctx = egui::Context::default();
 3897|      1|        let editor_id = egui::Id::new("raw_editor");
 3898|      1|        let mut state = egui::text_edit::TextEditState::default();
 3899|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 3900|      1|        state.cursor.set_char_range(Some(cr));
 3901|      1|        state.store(&ctx, editor_id);
 3902|       |
 3903|      1|        let input = default_input();
 3904|      1|        run_app_frame(&mut app, &ctx, input);
 3905|       |
 3906|      1|        assert!(app.raw_cursor.unwrap_or(0) > 0);
 3907|      1|    }
 3908|       |
 3909|       |    #[test]
 3910|      1|    fn test_json_helpers_escape_and_opt() {
 3911|      1|        assert_eq!(
 3912|      1|            MarkdownViewerApp::json_escape("a\"b\\c\n\t\r"),
 3913|       |            "a\\\"b\\\\c\\n\\t\\r"
 3914|       |        );
 3915|      1|        assert_eq!(MarkdownViewerApp::json_opt_f32(Some(1.23456)), "1.235");
 3916|      1|        assert_eq!(MarkdownViewerApp::json_opt_f32(None), "null");
 3917|      1|    }
 3918|       |
 3919|       |    #[test]
 3920|      1|    fn test_save_screenshot_image_crops_and_writes_metadata() -> Result<()> {
 3921|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 3922|      1|        let output_path = temp_dir.path().join("shot.png");
 3923|      1|        let config = ScreenshotConfig {
 3924|      1|            output_path: output_path.clone(),
 3925|      1|            viewport_width: 80.0,
 3926|      1|            viewport_height: 60.0,
 3927|      1|            content_only: true,
 3928|      1|            scroll_ratio: Some(0.5),
 3929|      1|            wait_ms: 0,
 3930|      1|            settle_frames: 0,
 3931|      1|            zoom: 1.0,
 3932|      1|            theme: ScreenshotTheme::Light,
 3933|      1|            font_source: Some("TestFont".to_string()),
 3934|      1|        };
 3935|      1|        let snapshot = ScreenshotSnapshot {
 3936|      1|            config,
 3937|      1|            content_rect: Some(egui::Rect::from_min_size(
 3938|      1|                egui::pos2(10.0, 5.0),
 3939|      1|                egui::vec2(20.0, 10.0),
 3940|      1|            )),
 3941|      1|            pixels_per_point: 1.0,
 3942|      1|            stable_frames: 3,
 3943|      1|            timed_out: false,
 3944|      1|            pending_renders: false,
 3945|      1|            last_scroll_offset: Some(12.0),
 3946|      1|            started: Instant::now(),
 3947|      1|        };
 3948|       |
 3949|      1|        let mut image = egui::ColorImage::new([80, 60], Color32::BLACK);
 3950|      1|        image.pixels[0] = Color32::from_rgb(10, 20, 30);
 3951|       |
 3952|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
                                                                                 ^0
 3953|       |
 3954|      1|        let saved = image::open(&output_path)?;
                                                           ^0
 3955|      1|        assert_eq!(saved.width(), 20);
 3956|      1|        assert_eq!(saved.height(), 10);
 3957|       |
 3958|      1|        let metadata = std::fs::read_to_string(output_path.with_extension("json"))?;
                                                                                                ^0
 3959|      1|        assert!(metadata.contains("\"content_only\": true"));
 3960|      1|        assert!(metadata.contains("\"font_source\": \"TestFont\""));
 3961|      1|        Ok(())
 3962|      1|    }
 3963|       |
 3964|       |    #[test]
 3965|      1|    fn test_update_screenshot_state_requests_and_scrolls() {
 3966|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 3967|      1|        let config = ScreenshotConfig {
 3968|      1|            output_path: temp_dir.path().join("shot.png"),
 3969|      1|            viewport_width: 100.0,
 3970|      1|            viewport_height: 80.0,
 3971|      1|            content_only: false,
 3972|      1|            scroll_ratio: Some(0.5),
 3973|      1|            wait_ms: 0,
 3974|      1|            settle_frames: 0,
 3975|      1|            zoom: 1.0,
 3976|      1|            theme: ScreenshotTheme::Dark,
 3977|      1|            font_source: None,
 3978|      1|        };
 3979|       |
 3980|      1|        let mut app = MarkdownViewerApp::new();
 3981|      1|        app.set_screenshot_mode(config);
 3982|       |
 3983|      1|        let ctx = egui::Context::default();
 3984|      1|        let snapshot = ScrollSnapshot {
 3985|      1|            content_size: egui::vec2(100.0, 200.0),
 3986|      1|            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(100.0, 100.0)),
 3987|      1|            offset_y: 0.0,
 3988|      1|        };
 3989|      1|        app.update_screenshot_state(&ctx, Some(1), Some(snapshot));
 3990|       |
 3991|      1|        let target_offset = app
 3992|      1|            .screenshot
 3993|      1|            .as_ref()
 3994|      1|            .and_then(|state| state.scroll_offset)
 3995|      1|            .unwrap_or(0.0);
 3996|      1|        let snapshot_ready = ScrollSnapshot {
 3997|      1|            content_size: egui::vec2(100.0, 200.0),
 3998|      1|            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(100.0, 100.0)),
 3999|      1|            offset_y: target_offset,
 4000|      1|        };
 4001|      1|        app.update_screenshot_state(&ctx, Some(1), Some(snapshot_ready));
 4002|       |
 4003|      1|        let state = app.screenshot.as_ref().expect("screenshot state");
 4004|      1|        assert!(state.viewport_adjusted);
 4005|      1|        assert!(state.requested);
 4006|      1|        assert!(state.scroll_ready());
 4007|      1|    }
 4008|       |
 4009|       |    #[test]
 4010|      1|    fn test_save_persists_window_state_when_no_screenshot() {
 4011|      1|        let _lock = env_lock();
 4012|      1|        let temp_dir = TempDir::new().expect("temp dir");
 4013|      1|        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());
 4014|       |
 4015|      1|        let mut app = MarkdownViewerApp::new();
 4016|      1|        app.last_window_pos = Some([10.0, 20.0]);
 4017|      1|        app.last_window_size = Some([800.0, 600.0]);
 4018|      1|        let mut storage = DummyStorage::default();
 4019|      1|        app.save(&mut storage);
 4020|       |
 4021|      1|        let path = temp_dir.path().join("MarkdownView").join("window_state.txt");
 4022|      1|        assert!(path.exists());
 4023|      1|    }
 4024|       |
 4025|       |    #[test]
 4026|      1|    fn test_save_skips_persist_when_screenshot_active() {
 4027|      1|        let _lock = env_lock();
 4028|      1|        let temp_dir = TempDir::new().expect("temp dir");
 4029|      1|        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());
 4030|       |
 4031|      1|        let mut app = MarkdownViewerApp::new();
 4032|      1|        let config = ScreenshotConfig {
 4033|      1|            output_path: temp_dir.path().join("shot.png"),
 4034|      1|            viewport_width: 10.0,
 4035|      1|            viewport_height: 10.0,
 4036|      1|            content_only: false,
 4037|      1|            scroll_ratio: None,
 4038|      1|            wait_ms: 0,
 4039|      1|            settle_frames: 0,
 4040|      1|            zoom: 1.0,
 4041|      1|            theme: ScreenshotTheme::Light,
 4042|      1|            font_source: None,
 4043|      1|        };
 4044|      1|        app.set_screenshot_mode(config);
 4045|      1|        let mut storage = DummyStorage::default();
 4046|      1|        app.save(&mut storage);
 4047|       |
 4048|      1|        let path = temp_dir.path().join("MarkdownView").join("window_state.txt");
 4049|      1|        assert!(!path.exists());
 4050|      1|    }
 4051|       |
 4052|       |    #[test]
 4053|      1|    fn test_save_screenshot_image_crops_content_rect() -> Result<()> {
 4054|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 4055|      1|        let output_path = temp_dir.path().join("shot.png");
 4056|      1|        let config = ScreenshotConfig {
 4057|      1|            output_path: output_path.clone(),
 4058|      1|            viewport_width: 100.0,
 4059|      1|            viewport_height: 80.0,
 4060|      1|            content_only: true,
 4061|      1|            scroll_ratio: None,
 4062|      1|            wait_ms: 0,
 4063|      1|            settle_frames: 0,
 4064|      1|            zoom: 1.0,
 4065|      1|            theme: ScreenshotTheme::Dark,
 4066|      1|            font_source: None,
 4067|      1|        };
 4068|      1|        let snapshot = ScreenshotSnapshot {
 4069|      1|            config,
 4070|      1|            content_rect: Some(egui::Rect::from_min_max(
 4071|      1|                egui::pos2(2.0, 2.0),
 4072|      1|                egui::pos2(8.0, 8.0),
 4073|      1|            )),
 4074|      1|            pixels_per_point: 1.0,
 4075|      1|            stable_frames: 0,
 4076|      1|            timed_out: false,
 4077|      1|            pending_renders: false,
 4078|      1|            last_scroll_offset: None,
 4079|      1|            started: std::time::Instant::now(),
 4080|      1|        };
 4081|      1|        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4082|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
                                                                                 ^0
 4083|      1|        assert!(output_path.exists());
 4084|      1|        assert!(output_path.with_extension("json").exists());
 4085|      1|        Ok(())
 4086|      1|    }
 4087|       |
 4088|       |    #[test]
 4089|      1|    fn test_save_screenshot_image_no_crop() -> Result<()> {
 4090|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 4091|      1|        let output_path = temp_dir.path().join("shot.png");
 4092|      1|        let config = ScreenshotConfig {
 4093|      1|            output_path: output_path.clone(),
 4094|      1|            viewport_width: 100.0,
 4095|      1|            viewport_height: 80.0,
 4096|      1|            content_only: false,
 4097|      1|            scroll_ratio: None,
 4098|      1|            wait_ms: 0,
 4099|      1|            settle_frames: 0,
 4100|      1|            zoom: 1.0,
 4101|      1|            theme: ScreenshotTheme::Light,
 4102|      1|            font_source: None,
 4103|      1|        };
 4104|      1|        let snapshot = ScreenshotSnapshot {
 4105|      1|            config,
 4106|      1|            content_rect: None,
 4107|      1|            pixels_per_point: 1.0,
 4108|      1|            stable_frames: 0,
 4109|      1|            timed_out: false,
 4110|      1|            pending_renders: false,
 4111|      1|            last_scroll_offset: None,
 4112|      1|            started: std::time::Instant::now(),
 4113|      1|        };
 4114|      1|        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4115|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
                                                                                 ^0
 4116|      1|        assert!(output_path.exists());
 4117|      1|        Ok(())
 4118|      1|    }
 4119|       |
 4120|       |    #[test]
 4121|      1|    fn test_save_screenshot_image_zero_content_rect_ignored() -> Result<()> {
 4122|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 4123|      1|        let output_path = temp_dir.path().join("shot.png");
 4124|      1|        let config = ScreenshotConfig {
 4125|      1|            output_path: output_path.clone(),
 4126|      1|            viewport_width: 100.0,
 4127|      1|            viewport_height: 80.0,
 4128|      1|            content_only: true,
 4129|      1|            scroll_ratio: None,
 4130|      1|            wait_ms: 0,
 4131|      1|            settle_frames: 0,
 4132|      1|            zoom: 1.0,
 4133|      1|            theme: ScreenshotTheme::Dark,
 4134|      1|            font_source: None,
 4135|      1|        };
 4136|      1|        let snapshot = ScreenshotSnapshot {
 4137|      1|            config,
 4138|      1|            content_rect: Some(egui::Rect::from_min_max(
 4139|      1|                egui::pos2(5.0, 5.0),
 4140|      1|                egui::pos2(5.0, 5.0),
 4141|      1|            )),
 4142|      1|            pixels_per_point: 1.0,
 4143|      1|            stable_frames: 0,
 4144|      1|            timed_out: false,
 4145|      1|            pending_renders: false,
 4146|      1|            last_scroll_offset: None,
 4147|      1|            started: std::time::Instant::now(),
 4148|      1|        };
 4149|      1|        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4150|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
                                                                                 ^0
 4151|      1|        let saved = image::open(&output_path)?;
                                                           ^0
 4152|      1|        assert_eq!(saved.width(), 10);
 4153|      1|        assert_eq!(saved.height(), 10);
 4154|      1|        Ok(())
 4155|      1|    }
 4156|       |
 4157|       |    #[test]
 4158|      1|    fn test_save_screenshot_image_crop_condition_variants() -> Result<()> {
 4159|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 4160|      1|        let image = egui::ColorImage::new([10, 10], Color32::from_rgb(10, 20, 30));
 4161|       |
 4162|      1|        let make_config = |name: &str| ScreenshotConfig {
 4163|      3|            output_path: temp_dir.path().join(name),
 4164|       |            viewport_width: 100.0,
 4165|       |            viewport_height: 80.0,
 4166|       |            content_only: true,
 4167|      3|            scroll_ratio: None,
 4168|       |            wait_ms: 0,
 4169|       |            settle_frames: 0,
 4170|       |            zoom: 1.0,
 4171|      3|            theme: ScreenshotTheme::Light,
 4172|      3|            font_source: None,
 4173|      3|        };
 4174|       |
 4175|      1|        let snapshot_y = ScreenshotSnapshot {
 4176|      1|            config: make_config("shot_y.png"),
 4177|      1|            content_rect: Some(egui::Rect::from_min_max(
 4178|      1|                egui::pos2(0.0, 2.0),
 4179|      1|                egui::pos2(10.0, 9.0),
 4180|      1|            )),
 4181|      1|            pixels_per_point: 1.0,
 4182|      1|            stable_frames: 0,
 4183|      1|            timed_out: false,
 4184|      1|            pending_renders: false,
 4185|      1|            last_scroll_offset: None,
 4186|      1|            started: std::time::Instant::now(),
 4187|      1|        };
 4188|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot_y)?;
                                                                                   ^0
 4189|       |
 4190|      1|        let snapshot_w = ScreenshotSnapshot {
 4191|      1|            config: make_config("shot_w.png"),
 4192|      1|            content_rect: Some(egui::Rect::from_min_max(
 4193|      1|                egui::pos2(0.0, 0.0),
 4194|      1|                egui::pos2(6.0, 10.0),
 4195|      1|            )),
 4196|      1|            pixels_per_point: 1.0,
 4197|      1|            stable_frames: 0,
 4198|      1|            timed_out: false,
 4199|      1|            pending_renders: false,
 4200|      1|            last_scroll_offset: None,
 4201|      1|            started: std::time::Instant::now(),
 4202|      1|        };
 4203|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot_w)?;
                                                                                   ^0
 4204|       |
 4205|      1|        let snapshot_h = ScreenshotSnapshot {
 4206|      1|            config: make_config("shot_h.png"),
 4207|      1|            content_rect: Some(egui::Rect::from_min_max(
 4208|      1|                egui::pos2(0.0, 0.0),
 4209|      1|                egui::pos2(10.0, 6.0),
 4210|      1|            )),
 4211|      1|            pixels_per_point: 1.0,
 4212|      1|            stable_frames: 0,
 4213|      1|            timed_out: false,
 4214|      1|            pending_renders: false,
 4215|      1|            last_scroll_offset: None,
 4216|      1|            started: std::time::Instant::now(),
 4217|      1|        };
 4218|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot_h)?;
                                                                                   ^0
 4219|       |
 4220|      1|        assert!(temp_dir.path().join("shot_y.png").exists());
 4221|      1|        assert!(temp_dir.path().join("shot_w.png").exists());
 4222|      1|        assert!(temp_dir.path().join("shot_h.png").exists());
 4223|      1|        Ok(())
 4224|      1|    }
 4225|       |
 4226|       |    #[test]
 4227|      1|    fn test_handle_screenshot_event_saves_file() -> Result<()> {
 4228|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 4229|      1|        let output_path = temp_dir.path().join("shot.png");
 4230|      1|        let config = ScreenshotConfig {
 4231|      1|            output_path: output_path.clone(),
 4232|      1|            viewport_width: 40.0,
 4233|      1|            viewport_height: 30.0,
 4234|      1|            content_only: false,
 4235|      1|            scroll_ratio: None,
 4236|      1|            wait_ms: 0,
 4237|      1|            settle_frames: 0,
 4238|      1|            zoom: 1.0,
 4239|      1|            theme: ScreenshotTheme::Light,
 4240|      1|            font_source: None,
 4241|      1|        };
 4242|       |
 4243|      1|        let mut app = MarkdownViewerApp::new();
 4244|      1|        app.set_screenshot_mode(config);
 4245|       |
 4246|      1|        let mut input = default_input();
 4247|      1|        let image = egui::ColorImage::new([40, 30], Color32::WHITE);
 4248|      1|        input.events.push(egui::Event::Screenshot {
 4249|      1|            viewport_id: egui::ViewportId::ROOT,
 4250|      1|            image: Arc::new(image),
 4251|      1|        });
 4252|       |
 4253|      1|        let ctx = egui::Context::default();
 4254|      1|        run_app_frame(&mut app, &ctx, input);
 4255|       |
 4256|      1|        assert!(output_path.exists());
 4257|      1|        assert!(output_path.with_extension("json").exists());
 4258|      1|        assert!(app.screenshot.as_ref().is_some_and(|state| state.done));
 4259|      1|        Ok(())
 4260|      1|    }
 4261|       |
 4262|       |    #[test]
 4263|      1|    fn test_handle_shortcuts_sets_flags() {
 4264|      1|        let mut app = MarkdownViewerApp::new();
 4265|      1|        app.load_content("Alpha\n\nBeta\n\nGamma", Some("Search".to_string()));
 4266|      1|        app.search_query = "beta".to_string();
 4267|      1|        app.current_file = Some(PathBuf::from("dummy.md"));
 4268|       |
 4269|      1|        let mut input = default_input();
 4270|      1|        input.events.extend([
 4271|      1|            egui::Event::Key {
 4272|      1|                key: egui::Key::F,
 4273|      1|                physical_key: None,
 4274|      1|                pressed: true,
 4275|      1|                repeat: false,
 4276|      1|                modifiers: egui::Modifiers::CTRL,
 4277|      1|            },
 4278|      1|            egui::Event::Key {
 4279|      1|                key: egui::Key::R,
 4280|      1|                physical_key: None,
 4281|      1|                pressed: true,
 4282|      1|                repeat: false,
 4283|      1|                modifiers: egui::Modifiers::CTRL,
 4284|      1|            },
 4285|      1|            egui::Event::Key {
 4286|      1|                key: egui::Key::E,
 4287|      1|                physical_key: None,
 4288|      1|                pressed: true,
 4289|      1|                repeat: false,
 4290|      1|                modifiers: egui::Modifiers::CTRL,
 4291|      1|            },
 4292|      1|            egui::Event::Key {
 4293|      1|                key: egui::Key::Plus,
 4294|      1|                physical_key: None,
 4295|      1|                pressed: true,
 4296|      1|                repeat: false,
 4297|      1|                modifiers: egui::Modifiers::CTRL,
 4298|      1|            },
 4299|      1|            egui::Event::Key {
 4300|      1|                key: egui::Key::Minus,
 4301|      1|                physical_key: None,
 4302|      1|                pressed: true,
 4303|      1|                repeat: false,
 4304|      1|                modifiers: egui::Modifiers::CTRL,
 4305|      1|            },
 4306|      1|            egui::Event::Key {
 4307|      1|                key: egui::Key::Num0,
 4308|      1|                physical_key: None,
 4309|      1|                pressed: true,
 4310|      1|                repeat: false,
 4311|      1|                modifiers: egui::Modifiers::CTRL,
 4312|      1|            },
 4313|      1|            egui::Event::Key {
 4314|      1|                key: egui::Key::ArrowLeft,
 4315|      1|                physical_key: None,
 4316|      1|                pressed: true,
 4317|      1|                repeat: false,
 4318|      1|                modifiers: egui::Modifiers::ALT,
 4319|      1|            },
 4320|      1|            egui::Event::Key {
 4321|      1|                key: egui::Key::ArrowRight,
 4322|      1|                physical_key: None,
 4323|      1|                pressed: true,
 4324|      1|                repeat: false,
 4325|      1|                modifiers: egui::Modifiers::ALT,
 4326|      1|            },
 4327|      1|            egui::Event::Key {
 4328|      1|                key: egui::Key::F3,
 4329|      1|                physical_key: None,
 4330|      1|                pressed: true,
 4331|      1|                repeat: false,
 4332|      1|                modifiers: egui::Modifiers::NONE,
 4333|      1|            },
 4334|      1|            egui::Event::Key {
 4335|      1|                key: egui::Key::F3,
 4336|      1|                physical_key: None,
 4337|      1|                pressed: true,
 4338|      1|                repeat: false,
 4339|      1|                modifiers: egui::Modifiers::SHIFT,
 4340|      1|            },
 4341|      1|            egui::Event::Key {
 4342|      1|                key: egui::Key::F11,
 4343|      1|                physical_key: None,
 4344|      1|                pressed: true,
 4345|      1|                repeat: false,
 4346|      1|                modifiers: egui::Modifiers::NONE,
 4347|      1|            },
 4348|      1|            egui::Event::Key {
 4349|      1|                key: egui::Key::F5,
 4350|      1|                physical_key: None,
 4351|      1|                pressed: true,
 4352|      1|                repeat: false,
 4353|      1|                modifiers: egui::Modifiers::NONE,
 4354|      1|            },
 4355|      1|        ]);
 4356|       |
 4357|      1|        let ctx = egui::Context::default();
 4358|      1|        let _ = ctx.run(input, |ctx| {
 4359|      1|            app.handle_shortcuts(ctx);
 4360|      1|        });
 4361|       |
 4362|      1|        assert!(app.show_search);
 4363|      1|        assert!(app.search_focus_requested);
 4364|      1|        assert!(app.view_toggle_requested);
 4365|      1|        assert!(app.write_toggle_requested);
 4366|      1|        assert!(app.toggle_fullscreen);
 4367|      1|        assert!(app.reload_requested);
 4368|      1|        assert!(app.last_match_index.is_some());
 4369|      1|    }
 4370|       |
 4371|       |    #[test]
 4372|      1|    fn test_handle_shortcuts_navigation_keys() {
 4373|      1|        let mut app = MarkdownViewerApp::new();
 4374|      1|        let ctx = egui::Context::default();
 4375|       |
 4376|      1|        let mut input = default_input();
 4377|      1|        input.events.push(egui::Event::Key {
 4378|      1|            key: egui::Key::PageUp,
 4379|      1|            physical_key: None,
 4380|      1|            pressed: true,
 4381|      1|            repeat: false,
 4382|      1|            modifiers: egui::Modifiers::NONE,
 4383|      1|        });
 4384|      1|        let _ = ctx.run(input, |ctx| {
 4385|      1|            app.handle_shortcuts(ctx);
 4386|      1|        });
 4387|      1|        assert!(matches!(app.nav_request, Some(NavigationRequest::PageUp)));
                              ^0
 4388|       |
 4389|      1|        app.nav_request = None;
 4390|      1|        let mut input = default_input();
 4391|      1|        input.events.push(egui::Event::Key {
 4392|      1|            key: egui::Key::PageDown,
 4393|      1|            physical_key: None,
 4394|      1|            pressed: true,
 4395|      1|            repeat: false,
 4396|      1|            modifiers: egui::Modifiers::NONE,
 4397|      1|        });
 4398|      1|        let _ = ctx.run(input, |ctx| {
 4399|      1|            app.handle_shortcuts(ctx);
 4400|      1|        });
 4401|      1|        assert!(matches!(app.nav_request, Some(NavigationRequest::PageDown)));
                              ^0
 4402|       |
 4403|      1|        app.nav_request = None;
 4404|      1|        let mut input = default_input();
 4405|      1|        input.events.push(egui::Event::Key {
 4406|      1|            key: egui::Key::Home,
 4407|      1|            physical_key: None,
 4408|      1|            pressed: true,
 4409|      1|            repeat: false,
 4410|      1|            modifiers: egui::Modifiers::NONE,
 4411|      1|        });
 4412|      1|        let _ = ctx.run(input, |ctx| {
 4413|      1|            app.handle_shortcuts(ctx);
 4414|      1|        });
 4415|      1|        assert!(matches!(app.nav_request, Some(NavigationRequest::Top)));
                              ^0
 4416|       |
 4417|      1|        app.nav_request = None;
 4418|      1|        let mut input = default_input();
 4419|      1|        input.events.push(egui::Event::Key {
 4420|      1|            key: egui::Key::End,
 4421|      1|            physical_key: None,
 4422|      1|            pressed: true,
 4423|      1|            repeat: false,
 4424|      1|            modifiers: egui::Modifiers::NONE,
 4425|      1|        });
 4426|      1|        let _ = ctx.run(input, |ctx| {
 4427|      1|            app.handle_shortcuts(ctx);
 4428|      1|        });
 4429|      1|        assert!(matches!(app.nav_request, Some(NavigationRequest::Bottom)));
                              ^0
 4430|       |
 4431|      1|        app.nav_request = None;
 4432|      1|        let mut input = default_input();
 4433|      1|        input.events.push(egui::Event::Key {
 4434|      1|            key: egui::Key::ArrowUp,
 4435|      1|            physical_key: None,
 4436|      1|            pressed: true,
 4437|      1|            repeat: false,
 4438|      1|            modifiers: egui::Modifiers::NONE,
 4439|      1|        });
 4440|      1|        let _ = ctx.run(input, |ctx| {
 4441|      1|            app.handle_shortcuts(ctx);
 4442|      1|        });
 4443|      1|        assert!(matches!(app.nav_request, Some(NavigationRequest::ScrollUp)));
                              ^0
 4444|       |
 4445|      1|        app.nav_request = None;
 4446|      1|        let mut input = default_input();
 4447|      1|        input.events.push(egui::Event::Key {
 4448|      1|            key: egui::Key::ArrowDown,
 4449|      1|            physical_key: None,
 4450|      1|            pressed: true,
 4451|      1|            repeat: false,
 4452|      1|            modifiers: egui::Modifiers::NONE,
 4453|      1|        });
 4454|      1|        let _ = ctx.run(input, |ctx| {
 4455|      1|            app.handle_shortcuts(ctx);
 4456|      1|        });
 4457|      1|        assert!(matches!(
                              ^0
 4458|      1|            app.nav_request,
 4459|       |            Some(NavigationRequest::ScrollDown)
 4460|       |        ));
 4461|      1|    }
 4462|       |
 4463|       |    #[test]
 4464|      1|    fn test_handle_shortcuts_escape_clears_search() {
 4465|      1|        let mut app = MarkdownViewerApp::new();
 4466|      1|        app.show_search = true;
 4467|      1|        app.search_query = "alpha".to_string();
 4468|      1|        app.last_query = "alpha".to_string();
 4469|      1|        app.last_match_index = Some(0);
 4470|      1|        app.pending_scroll_to_element = Some(1);
 4471|       |
 4472|      1|        let mut input = default_input();
 4473|      1|        input.events.push(egui::Event::Key {
 4474|      1|            key: egui::Key::Escape,
 4475|      1|            physical_key: None,
 4476|      1|            pressed: true,
 4477|      1|            repeat: false,
 4478|      1|            modifiers: egui::Modifiers::NONE,
 4479|      1|        });
 4480|       |
 4481|      1|        let ctx = egui::Context::default();
 4482|      1|        let _ = ctx.run(input, |ctx| {
 4483|      1|            app.handle_shortcuts(ctx);
 4484|      1|        });
 4485|       |
 4486|      1|        assert!(!app.show_search);
 4487|      1|        assert!(app.search_query.is_empty());
 4488|      1|        assert!(app.last_query.is_empty());
 4489|      1|        assert!(app.last_match_index.is_none());
 4490|      1|        assert!(app.pending_scroll_to_element.is_none());
 4491|      1|    }
 4492|       |
 4493|       |    #[test]
 4494|      1|    fn test_update_search_results_updates_matches() {
 4495|      1|        let mut app = MarkdownViewerApp::new();
 4496|      1|        app.load_content("Alpha\n\nBeta\n\nGamma", Some("Search".to_string()));
 4497|       |
 4498|      1|        app.search_query = "beta".to_string();
 4499|      1|        app.update_search_results("");
 4500|      1|        assert_eq!(app.last_query, "beta");
 4501|      1|        assert_eq!(app.last_match_index, Some(1));
 4502|      1|        assert_eq!(app.pending_scroll_to_element, Some(1));
 4503|       |
 4504|      1|        app.search_query.clear();
 4505|      1|        app.update_search_results("beta");
 4506|      1|        assert!(app.last_query.is_empty());
 4507|      1|    }
 4508|       |
 4509|       |    #[test]
 4510|      1|    fn test_handle_shortcuts_ctrl_mouse_wheel_zoom() {
 4511|      1|        let mut app = MarkdownViewerApp::new();
 4512|      1|        let mut input = default_input();
 4513|      1|        input.modifiers = egui::Modifiers::CTRL;
 4514|      1|        input.events.push(egui::Event::MouseWheel {
 4515|      1|            unit: egui::MouseWheelUnit::Point,
 4516|      1|            delta: egui::vec2(0.0, 20.0),
 4517|      1|            modifiers: egui::Modifiers::CTRL,
 4518|      1|        });
 4519|       |
 4520|      1|        let ctx = egui::Context::default();
 4521|      1|        let _ = ctx.run(input, |ctx| {
 4522|      1|            app.handle_shortcuts(ctx);
 4523|      1|        });
 4524|      1|    }
 4525|       |
 4526|       |    #[test]
 4527|      1|    fn test_handle_shortcuts_raw_page_moves() {
 4528|      1|        let mut app = MarkdownViewerApp::new();
 4529|      1|        app.view_mode = ViewMode::Raw;
 4530|      1|        app.write_enabled = true;
 4531|       |
 4532|      1|        let mut input = default_input();
 4533|      1|        input.events.extend([
 4534|      1|            egui::Event::Key {
 4535|      1|                key: egui::Key::PageUp,
 4536|      1|                physical_key: None,
 4537|      1|                pressed: true,
 4538|      1|                repeat: false,
 4539|      1|                modifiers: egui::Modifiers::NONE,
 4540|      1|            },
 4541|      1|            egui::Event::Key {
 4542|      1|                key: egui::Key::PageDown,
 4543|      1|                physical_key: None,
 4544|      1|                pressed: true,
 4545|      1|                repeat: false,
 4546|      1|                modifiers: egui::Modifiers::NONE,
 4547|      1|            },
 4548|      1|        ]);
 4549|       |
 4550|      1|        let ctx = egui::Context::default();
 4551|      1|        let _ = ctx.run(input, |ctx| {
 4552|      1|            app.handle_shortcuts(ctx);
 4553|      1|        });
 4554|       |
 4555|      1|        assert!(app.pending_raw_cursor_line_move.is_some());
 4556|      1|        assert!(app.raw_focus_requested);
 4557|      1|    }
 4558|       |
 4559|       |    #[test]
 4560|      1|    fn test_render_helpers_cover_ui_paths() {
 4561|      1|        let mut app = MarkdownViewerApp::new();
 4562|      1|        app.current_content = "Hello".to_string();
 4563|      1|        app.pending_files.push_back(PathBuf::from("queued.md"));
 4564|      1|        app.drag_hover = true;
 4565|      1|        app.show_search = true;
 4566|      1|        app.search_query = "welcome".to_string();
 4567|       |
 4568|      1|        let ctx = egui::Context::default();
 4569|      1|        let _ = ctx.run(default_input(), |ctx| {
 4570|      1|            CentralPanel::default().show(ctx, |ui| {
 4571|      1|                app.render_file_menu_contents(ui, false, Color32::WHITE);
 4572|      1|                app.render_view_menu_contents(ui, ctx, false, Color32::WHITE);
 4573|      1|                app.render_help_menu_contents(ui, false, Color32::WHITE);
 4574|      1|            });
 4575|      1|            app.render_status_bar(ctx);
 4576|      1|            app.render_search_dialog(ctx);
 4577|      1|            app.render_drag_overlay(ctx);
 4578|      1|        });
 4579|       |
 4580|      1|        assert!(app.show_search);
 4581|      1|    }
 4582|       |
 4583|       |    #[test]
 4584|      1|    fn test_screenshot_config_helpers() {
 4585|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 4586|      1|        let output_path = temp_dir.path().join("shot.png");
 4587|      1|        let config = ScreenshotConfig {
 4588|      1|            output_path: output_path.clone(),
 4589|      1|            viewport_width: 100.0,
 4590|      1|            viewport_height: 80.0,
 4591|      1|            content_only: true,
 4592|      1|            scroll_ratio: None,
 4593|      1|            wait_ms: 0,
 4594|      1|            settle_frames: 0,
 4595|      1|            zoom: 1.0,
 4596|      1|            theme: ScreenshotTheme::Light,
 4597|      1|            font_source: None,
 4598|      1|        };
 4599|       |
 4600|      1|        assert_eq!(config.metadata_path(), output_path.with_extension("json"));
 4601|      1|        assert_eq!(config.theme.as_str(), "light");
 4602|      1|        assert_eq!(ScreenshotTheme::Dark.as_str(), "dark");
 4603|      1|    }
 4604|       |
 4605|       |    #[test]
 4606|      1|    fn test_open_file_dialog_forced_path() -> Result<()> {
 4607|      1|        let mut app = MarkdownViewerApp::new();
 4608|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 4609|      1|        let file_path = temp_dir.path().join("open.md");
 4610|      1|        std::fs::write(&file_path, "# Open")?;
                                                          ^0
 4611|      1|        let _forced = ForcedDialogPaths::new(Some(file_path.clone()), None);
 4612|       |
 4613|      1|        app.open_file_dialog();
 4614|       |
 4615|      1|        assert_eq!(app.current_file, Some(file_path));
 4616|      1|        assert!(app.error_message.is_none());
 4617|      1|        Ok(())
 4618|      1|    }
 4619|       |
 4620|       |    #[test]
 4621|      1|    fn test_save_current_document_existing_path() -> Result<()> {
 4622|      1|        let mut app = MarkdownViewerApp::new();
 4623|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 4624|      1|        let file_path = temp_dir.path().join("save.md");
 4625|      1|        app.current_file = Some(file_path.clone());
 4626|      1|        app.current_content = "Saved content".to_string();
 4627|       |
 4628|      1|        app.save_current_document()?;
                                                 ^0
 4629|       |
 4630|      1|        let saved = std::fs::read_to_string(&file_path)?;
                                                                     ^0
 4631|      1|        assert_eq!(saved, "Saved content");
 4632|      1|        Ok(())
 4633|      1|    }
 4634|       |
 4635|       |    #[test]
 4636|      1|    fn test_save_current_document_forced_path() -> Result<()> {
 4637|      1|        let mut app = MarkdownViewerApp::new();
 4638|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 4639|      1|        let file_path = temp_dir.path().join("save_forced.md");
 4640|      1|        let _forced = ForcedDialogPaths::new(None, Some(file_path.clone()));
 4641|      1|        app.current_content = "Forced save".to_string();
 4642|       |
 4643|      1|        app.save_current_document()?;
                                                 ^0
 4644|       |
 4645|      1|        assert_eq!(app.current_file, Some(file_path.clone()));
 4646|      1|        assert!(app.title.contains("save_forced.md"));
 4647|      1|        let saved = std::fs::read_to_string(&file_path)?;
                                                                     ^0
 4648|      1|        assert_eq!(saved, "Forced save");
 4649|      1|        Ok(())
 4650|      1|    }
 4651|       |
 4652|       |    #[test]
 4653|      1|    fn test_restore_from_history_sets_state() {
 4654|      1|        let mut app = MarkdownViewerApp::new();
 4655|      1|        app.current_content = "first".to_string();
 4656|      1|        app.current_file = Some(PathBuf::from("first.md"));
 4657|      1|        app.title = "mdmdview - first".to_string();
 4658|      1|        app.push_history();
 4659|       |
 4660|      1|        app.current_content = "second".to_string();
 4661|      1|        app.current_file = None;
 4662|      1|        app.title = "mdmdview - second".to_string();
 4663|      1|        app.push_history();
 4664|       |
 4665|      1|        app.history_index = 0;
 4666|      1|        app.restore_from_history();
 4667|       |
 4668|      1|        assert_eq!(app.current_file, Some(PathBuf::from("first.md")));
 4669|      1|        assert_eq!(app.current_content, "first");
 4670|      1|        assert_eq!(app.pending_scroll_to_element, Some(0));
 4671|      1|    }
 4672|       |
 4673|       |    #[test]
 4674|      1|    fn test_restore_from_history_out_of_range_no_change() {
 4675|      1|        let mut app = MarkdownViewerApp::new();
 4676|      1|        app.current_content = "current".to_string();
 4677|      1|        app.history_index = 3;
 4678|       |
 4679|      1|        app.restore_from_history();
 4680|       |
 4681|      1|        assert_eq!(app.current_content, "current");
 4682|      1|        assert!(app.current_file.is_none());
 4683|      1|    }
 4684|       |
 4685|       |    #[test]
 4686|      1|    fn test_handle_file_drop_mixed_files() -> Result<()> {
 4687|      1|        let mut app = MarkdownViewerApp::new();
 4688|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 4689|      1|        let good1 = temp_dir.path().join("good1.md");
 4690|      1|        let good2 = temp_dir.path().join("good2.md");
 4691|      1|        let bad = temp_dir.path().join("bad.pdf");
 4692|      1|        std::fs::write(&good1, "# Good1")?;
                                                       ^0
 4693|      1|        std::fs::write(&good2, "# Good2")?;
                                                       ^0
 4694|      1|        std::fs::write(&bad, "nope")?;
                                                  ^0
 4695|       |
 4696|      1|        app.handle_file_drop(vec![bad, good1.clone(), good2.clone()]);
 4697|       |
 4698|      1|        assert_eq!(app.current_file, Some(good1));
 4699|      1|        assert!(app.pending_files.contains(&good2));
 4700|      1|        assert!(app.error_message.is_some());
 4701|      1|        Ok(())
 4702|      1|    }
 4703|       |
 4704|       |    #[test]
 4705|      1|    fn test_handle_file_drop_directory_no_markdown() -> Result<()> {
 4706|      1|        let mut app = MarkdownViewerApp::new();
 4707|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 4708|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 4709|      1|        assert!(app.error_message.is_some());
 4710|      1|        Ok(())
 4711|      1|    }
 4712|       |
 4713|       |    #[test]
 4714|      1|    fn test_handle_file_drop_too_many_files() -> Result<()> {
 4715|      1|        let mut app = MarkdownViewerApp::new();
 4716|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 4717|      1|        let mut files = Vec::new();
 4718|     52|        for idx in 0..51 {
                          ^51
 4719|     51|            let path = temp_dir.path().join(format!("file{}.md", idx));
 4720|     51|            std::fs::write(&path, "# Test")?;
                                                         ^0
 4721|     51|            files.push(path);
 4722|       |        }
 4723|       |
 4724|      1|        app.handle_file_drop(files);
 4725|       |
 4726|      1|        assert!(app.error_message.is_some());
 4727|      1|        Ok(())
 4728|      1|    }
 4729|       |
 4730|       |    #[test]
 4731|      1|    fn test_move_raw_cursor_lines_up_and_down() {
 4732|      1|        let mut app = MarkdownViewerApp::new();
 4733|      1|        app.view_mode = ViewMode::Raw;
 4734|      1|        app.write_enabled = true;
 4735|      1|        app.raw_buffer = "Line 1\nLine 2\nLine 3".to_string();
 4736|      1|        app.current_content = app.raw_buffer.clone();
 4737|       |
 4738|      1|        let ctx = egui::Context::default();
 4739|      1|        let editor_id = egui::Id::new("raw_editor");
 4740|      1|        let mut state = egui::text_edit::TextEditState::default();
 4741|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 4742|      1|        state.cursor.set_char_range(Some(cr));
 4743|      1|        state.store(&ctx, editor_id);
 4744|       |
 4745|      1|        app.move_raw_cursor_lines(&ctx, 1);
 4746|      1|        let down_idx = app.raw_cursor.unwrap_or(0);
 4747|      1|        assert!(down_idx > 0);
 4748|       |
 4749|      1|        app.move_raw_cursor_lines(&ctx, -1);
 4750|      1|        let up_idx = app.raw_cursor.unwrap_or(0);
 4751|      1|        assert!(up_idx <= down_idx);
 4752|      1|    }
 4753|       |
 4754|       |    #[test]
 4755|      1|    fn test_move_raw_cursor_lines_early_return_when_not_raw() {
 4756|      1|        let mut app = MarkdownViewerApp::new();
 4757|      1|        app.view_mode = ViewMode::Rendered;
 4758|      1|        app.write_enabled = true;
 4759|      1|        app.raw_cursor = Some(2);
 4760|       |
 4761|      1|        let ctx = egui::Context::default();
 4762|      1|        app.move_raw_cursor_lines(&ctx, 1);
 4763|       |
 4764|      1|        assert_eq!(app.raw_cursor, Some(2));
 4765|      1|    }
 4766|       |
 4767|       |    #[test]
 4768|      1|    fn test_move_raw_cursor_lines_write_disabled_returns() {
 4769|      1|        let mut app = MarkdownViewerApp::new();
 4770|      1|        app.view_mode = ViewMode::Raw;
 4771|      1|        app.write_enabled = false;
 4772|      1|        app.raw_cursor = Some(1);
 4773|       |
 4774|      1|        let ctx = egui::Context::default();
 4775|      1|        app.move_raw_cursor_lines(&ctx, 1);
 4776|       |
 4777|      1|        assert_eq!(app.raw_cursor, Some(1));
 4778|      1|    }
 4779|       |
 4780|       |    #[test]
 4781|      1|    fn test_move_raw_cursor_lines_without_text_state() {
 4782|      1|        let mut app = MarkdownViewerApp::new();
 4783|      1|        app.view_mode = ViewMode::Raw;
 4784|      1|        app.write_enabled = true;
 4785|      1|        app.raw_buffer = "Line".to_string();
 4786|      1|        app.current_content = app.raw_buffer.clone();
 4787|       |
 4788|      1|        let ctx = egui::Context::default();
 4789|      1|        app.move_raw_cursor_lines(&ctx, 1);
 4790|       |
 4791|      1|        assert!(app.raw_cursor.is_none());
 4792|      1|    }
 4793|       |
 4794|       |    #[test]
 4795|      1|    fn test_move_raw_cursor_lines_negative_at_start_no_loop() {
 4796|      1|        let mut app = MarkdownViewerApp::new();
 4797|      1|        app.view_mode = ViewMode::Raw;
 4798|      1|        app.write_enabled = true;
 4799|      1|        app.raw_buffer = "Line 1\nLine 2".to_string();
 4800|      1|        app.current_content = app.raw_buffer.clone();
 4801|       |
 4802|      1|        let ctx = egui::Context::default();
 4803|      1|        let editor_id = egui::Id::new("raw_editor");
 4804|      1|        let mut state = egui::text_edit::TextEditState::default();
 4805|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 4806|      1|        state.cursor.set_char_range(Some(cr));
 4807|      1|        state.store(&ctx, editor_id);
 4808|       |
 4809|      1|        app.move_raw_cursor_lines(&ctx, -1);
 4810|      1|        assert_eq!(app.raw_cursor, Some(0));
 4811|      1|    }
 4812|       |
 4813|       |    #[test]
 4814|      1|    fn test_move_raw_cursor_lines_down_without_newline() {
 4815|      1|        let mut app = MarkdownViewerApp::new();
 4816|      1|        app.view_mode = ViewMode::Raw;
 4817|      1|        app.write_enabled = true;
 4818|      1|        app.raw_buffer = "Line".to_string();
 4819|      1|        app.current_content = app.raw_buffer.clone();
 4820|       |
 4821|      1|        let ctx = egui::Context::default();
 4822|      1|        let editor_id = egui::Id::new("raw_editor");
 4823|      1|        let mut state = egui::text_edit::TextEditState::default();
 4824|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 4825|      1|        state.cursor.set_char_range(Some(cr));
 4826|      1|        state.store(&ctx, editor_id);
 4827|       |
 4828|      1|        app.move_raw_cursor_lines(&ctx, 1);
 4829|      1|        assert_eq!(app.raw_cursor, Some(app.raw_buffer.len()));
 4830|      1|    }
 4831|       |
 4832|       |    #[test]
 4833|      1|    fn test_move_raw_cursor_lines_down_at_end_no_loop() {
 4834|      1|        let mut app = MarkdownViewerApp::new();
 4835|      1|        app.view_mode = ViewMode::Raw;
 4836|      1|        app.write_enabled = true;
 4837|      1|        app.raw_buffer = "Line 1\nLine 2".to_string();
 4838|      1|        app.current_content = app.raw_buffer.clone();
 4839|       |
 4840|      1|        let ctx = egui::Context::default();
 4841|      1|        let editor_id = egui::Id::new("raw_editor");
 4842|      1|        let mut state = egui::text_edit::TextEditState::default();
 4843|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(app.raw_buffer.len()));
 4844|      1|        state.cursor.set_char_range(Some(cr));
 4845|      1|        state.store(&ctx, editor_id);
 4846|       |
 4847|      1|        app.move_raw_cursor_lines(&ctx, 1);
 4848|      1|        assert_eq!(app.raw_cursor, Some(app.raw_buffer.len()));
 4849|      1|    }
 4850|       |
 4851|       |    #[test]
 4852|      1|    fn test_handle_shortcuts_open_accelerators() -> Result<()> {
 4853|      1|        let mut app = MarkdownViewerApp::new();
 4854|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 4855|      1|        let open_path = temp_dir.path().join("open.md");
 4856|      1|        std::fs::write(&open_path, "# Open")?;
                                                          ^0
 4857|      1|        let _forced = ForcedDialogPaths::new(Some(open_path.clone()), None);
 4858|       |
 4859|      1|        let mut input = default_input();
 4860|      1|        input.events.extend([
 4861|      1|            egui::Event::Key {
 4862|      1|                key: egui::Key::O,
 4863|      1|                physical_key: None,
 4864|      1|                pressed: true,
 4865|      1|                repeat: false,
 4866|      1|                modifiers: egui::Modifiers::CTRL,
 4867|      1|            },
 4868|      1|            egui::Event::Key {
 4869|      1|                key: egui::Key::O,
 4870|      1|                physical_key: None,
 4871|      1|                pressed: true,
 4872|      1|                repeat: false,
 4873|      1|                modifiers: egui::Modifiers::ALT,
 4874|      1|            },
 4875|      1|        ]);
 4876|       |
 4877|      1|        let ctx = egui::Context::default();
 4878|      1|        let _ = ctx.run(input, |ctx| {
 4879|      1|            app.handle_shortcuts(ctx);
 4880|      1|        });
 4881|       |
 4882|      1|        assert_eq!(app.current_file, Some(open_path));
 4883|      1|        Ok(())
 4884|      1|    }
 4885|       |
 4886|       |    #[test]
 4887|      1|    fn test_handle_shortcuts_close_accelerators() {
 4888|      1|        let mut app = MarkdownViewerApp::new();
 4889|      1|        app.current_file = Some(PathBuf::from("dummy.md"));
 4890|      1|        app.current_content = "# Dummy".to_string();
 4891|       |
 4892|      1|        let mut input = default_input();
 4893|      1|        input.events.extend([
 4894|      1|            egui::Event::Key {
 4895|      1|                key: egui::Key::W,
 4896|      1|                physical_key: None,
 4897|      1|                pressed: true,
 4898|      1|                repeat: false,
 4899|      1|                modifiers: egui::Modifiers::ALT,
 4900|      1|            },
 4901|      1|            egui::Event::Key {
 4902|      1|                key: egui::Key::W,
 4903|      1|                physical_key: None,
 4904|      1|                pressed: true,
 4905|      1|                repeat: false,
 4906|      1|                modifiers: egui::Modifiers::CTRL,
 4907|      1|            },
 4908|      1|            egui::Event::Key {
 4909|      1|                key: egui::Key::Q,
 4910|      1|                physical_key: None,
 4911|      1|                pressed: true,
 4912|      1|                repeat: false,
 4913|      1|                modifiers: egui::Modifiers::ALT,
 4914|      1|            },
 4915|      1|            egui::Event::Key {
 4916|      1|                key: egui::Key::Q,
 4917|      1|                physical_key: None,
 4918|      1|                pressed: true,
 4919|      1|                repeat: false,
 4920|      1|                modifiers: egui::Modifiers::CTRL,
 4921|      1|            },
 4922|      1|        ]);
 4923|       |
 4924|      1|        let ctx = egui::Context::default();
 4925|      1|        let _ = ctx.run(input, |ctx| {
 4926|      1|            app.handle_shortcuts(ctx);
 4927|      1|        });
 4928|       |
 4929|      1|        assert!(app.current_file.is_none());
 4930|      1|    }
 4931|       |
 4932|       |    #[test]
 4933|      1|    fn test_handle_shortcuts_ctrl_save() -> Result<()> {
 4934|      1|        let mut app = MarkdownViewerApp::new();
 4935|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 4936|      1|        let file_path = temp_dir.path().join("save.md");
 4937|      1|        app.current_file = Some(file_path.clone());
 4938|      1|        app.current_content = "Saved".to_string();
 4939|       |
 4940|      1|        let mut input = default_input();
 4941|      1|        input.events.push(egui::Event::Key {
 4942|      1|            key: egui::Key::S,
 4943|      1|            physical_key: None,
 4944|      1|            pressed: true,
 4945|      1|            repeat: false,
 4946|      1|            modifiers: egui::Modifiers::CTRL,
 4947|      1|        });
 4948|       |
 4949|      1|        let ctx = egui::Context::default();
 4950|      1|        let _ = ctx.run(input, |ctx| {
 4951|      1|            app.handle_shortcuts(ctx);
 4952|      1|        });
 4953|       |
 4954|      1|        let saved = std::fs::read_to_string(&file_path)?;
                                                                     ^0
 4955|      1|        assert_eq!(saved, "Saved");
 4956|      1|        Ok(())
 4957|      1|    }
 4958|       |
 4959|       |    #[test]
 4960|      1|    fn test_compute_window_adjustment_clamps() {
 4961|      1|        let outer = egui::Rect::from_min_size(egui::pos2(-100.0, -100.0), egui::vec2(200.0, 100.0));
 4962|      1|        let monitor = egui::vec2(800.0, 600.0);
 4963|      1|        let adjusted =
 4964|      1|            MarkdownViewerApp::compute_window_adjustment(Some(outer), Some(outer), Some(monitor));
 4965|      1|        assert!(adjusted.is_some());
 4966|       |
 4967|      1|        let outer_ok = egui::Rect::from_min_size(egui::pos2(10.0, 10.0), egui::vec2(800.0, 600.0));
 4968|      1|        let unchanged = MarkdownViewerApp::compute_window_adjustment(
 4969|      1|            Some(outer_ok),
 4970|      1|            Some(outer_ok),
 4971|      1|            Some(monitor),
 4972|       |        );
 4973|      1|        assert!(unchanged.is_none());
 4974|      1|    }
 4975|       |
 4976|       |    #[test]
 4977|      1|    fn test_persist_window_state_updates_cache() {
 4978|      1|        let _lock = env_lock();
 4979|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 4980|      1|        let _guard = EnvGuard::set("APPDATA", temp_dir.path().to_string_lossy().as_ref());
 4981|      1|        let mut app = MarkdownViewerApp::new();
 4982|      1|        app.last_window_pos = Some([10.0, 20.0]);
 4983|      1|        app.last_window_size = Some([800.0, 600.0]);
 4984|      1|        app.last_window_maximized = true;
 4985|       |
 4986|      1|        app.persist_window_state();
 4987|       |
 4988|      1|        assert!(app.last_persisted_state.is_some());
 4989|      1|    }
 4990|       |
 4991|       |    #[test]
 4992|      1|    fn test_render_actions_trigger_menu_and_context() {
 4993|      1|        let mut app = MarkdownViewerApp::new();
 4994|      1|        app.current_content = "Hello".to_string();
 4995|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 4996|      1|            "Hello".to_string(),
 4997|      1|        )])];
 4998|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 4999|      1|        let open_path = temp_dir.path().join("open.md");
 5000|      1|        std::fs::write(&open_path, "# Open").expect("write");
 5001|      1|        let save_path = temp_dir.path().join("save.md");
 5002|      1|        let _forced = ForcedDialogPaths::new(Some(open_path), Some(save_path));
 5003|      1|        let _actions = ForcedAppActions::new(&[
 5004|      1|            "menu_open",
 5005|      1|            "menu_save",
 5006|      1|            "menu_close",
 5007|      1|            "menu_reload",
 5008|      1|            "menu_find",
 5009|      1|            "menu_samples",
 5010|      1|            "menu_bar_file",
 5011|      1|            "menu_bar_view",
 5012|      1|            "menu_bar_help",
 5013|      1|            "menu_help_usage",
 5014|      1|            "menu_help_about",
 5015|      1|            "menu_back",
 5016|      1|            "menu_forward",
 5017|      1|            "menu_raw",
 5018|      1|            "menu_write",
 5019|      1|            "menu_wrap_raw",
 5020|      1|            "menu_zoom_in",
 5021|      1|            "menu_zoom_out",
 5022|      1|            "menu_zoom_reset",
 5023|      1|            "menu_fullscreen",
 5024|      1|            "ctx_copy_all",
 5025|      1|            "ctx_copy_markdown",
 5026|      1|            "ctx_nav_top",
 5027|      1|            "ctx_nav_bottom",
 5028|      1|            "search_next",
 5029|      1|            "search_prev",
 5030|      1|            "search_close",
 5031|      1|            "status_hover",
 5032|      1|            "welcome_open",
 5033|      1|            "welcome.md",
 5034|      1|            "usage.md",
 5035|      1|        ]);
 5036|       |
 5037|      1|        let ctx = egui::Context::default();
 5038|      1|        let _ = ctx.run(default_input(), |ctx| {
 5039|      1|            CentralPanel::default().show(ctx, |ui| {
 5040|      1|                app.render_file_menu_contents(ui, false, Color32::WHITE);
 5041|      1|                app.render_view_menu_contents(ui, ctx, false, Color32::WHITE);
 5042|      1|                app.render_help_menu_contents(ui, false, Color32::WHITE);
 5043|      1|                app.render_main_context_menu(ui);
 5044|      1|            });
 5045|      1|            app.show_search = true;
 5046|      1|            app.render_search_dialog(ctx);
 5047|      1|            app.render_menu_bar(ctx);
 5048|      1|            app.render_status_bar(ctx);
 5049|      1|        });
 5050|      1|    }
 5051|       |
 5052|       |    #[test]
 5053|      1|    fn test_handle_file_drop_empty_and_missing() {
 5054|      1|        let mut app = MarkdownViewerApp::new();
 5055|      1|        app.handle_file_drop(Vec::new());
 5056|       |
 5057|      1|        app.handle_file_drop(vec![PathBuf::from("missing.md")]);
 5058|      1|        assert!(app
 5059|      1|            .error_message
 5060|      1|            .as_ref()
 5061|      1|            .is_some_and(|msg| msg.contains("File not found")));
 5062|      1|    }
 5063|       |
 5064|       |    #[test]
 5065|      1|    fn test_handle_file_drop_scan_error() -> Result<()> {
 5066|      1|        let mut app = MarkdownViewerApp::new();
 5067|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5068|      1|        let _forced = ForcedScanError::new();
 5069|       |
 5070|      1|        app.handle_file_drop(vec![temp_dir.path().to_path_buf()]);
 5071|       |
 5072|      1|        assert!(app.error_message.is_some());
 5073|      1|        Ok(())
 5074|      1|    }
 5075|       |
 5076|       |    #[test]
 5077|      1|    fn test_handle_file_drop_load_failure() -> Result<()> {
 5078|      1|        let mut app = MarkdownViewerApp::new();
 5079|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5080|      1|        let file_path = temp_dir.path().join("fail.md");
 5081|      1|        std::fs::write(&file_path, "# Fail")?;
                                                          ^0
 5082|      1|        let _forced = ForcedLoadError::new();
 5083|       |
 5084|      1|        app.handle_file_drop(vec![file_path]);
 5085|       |
 5086|      1|        assert!(app
 5087|      1|            .error_message
 5088|      1|            .as_ref()
 5089|      1|            .is_some_and(|msg| msg.contains("Failed to load file")));
 5090|      1|        Ok(())
 5091|      1|    }
 5092|       |
 5093|       |    #[test]
 5094|      1|    fn test_handle_shortcuts_ctrl_f_sets_match_index() {
 5095|      1|        let mut app = MarkdownViewerApp::new();
 5096|      1|        app.last_match_index = None;
 5097|       |
 5098|      1|        let mut input = default_input();
 5099|      1|        input.events.push(egui::Event::Key {
 5100|      1|            key: egui::Key::F,
 5101|      1|            physical_key: None,
 5102|      1|            pressed: true,
 5103|      1|            repeat: false,
 5104|      1|            modifiers: egui::Modifiers::CTRL,
 5105|      1|        });
 5106|       |
 5107|      1|        let ctx = egui::Context::default();
 5108|      1|        let _ = ctx.run(input, |ctx| {
 5109|      1|            app.handle_shortcuts(ctx);
 5110|      1|        });
 5111|       |
 5112|      1|        assert_eq!(app.last_match_index, Some(0));
 5113|      1|    }
 5114|       |
 5115|       |    #[test]
 5116|      1|    fn test_handle_shortcuts_ctrl_f_preserves_match_index() {
 5117|      1|        let mut app = MarkdownViewerApp::new();
 5118|      1|        app.last_match_index = Some(2);
 5119|       |
 5120|      1|        let mut input = default_input();
 5121|      1|        input.events.push(egui::Event::Key {
 5122|      1|            key: egui::Key::F,
 5123|      1|            physical_key: None,
 5124|      1|            pressed: true,
 5125|      1|            repeat: false,
 5126|      1|            modifiers: egui::Modifiers::CTRL,
 5127|      1|        });
 5128|       |
 5129|      1|        let ctx = egui::Context::default();
 5130|      1|        let _ = ctx.run(input, |ctx| {
 5131|      1|            app.handle_shortcuts(ctx);
 5132|      1|        });
 5133|       |
 5134|      1|        assert_eq!(app.last_match_index, Some(2));
 5135|      1|    }
 5136|       |
 5137|       |    #[test]
 5138|      1|    fn test_handle_shortcuts_ctrl_mouse_wheel_zoom_directions() {
 5139|      1|        let mut app = MarkdownViewerApp::new();
 5140|      1|        let ctx = egui::Context::default();
 5141|       |
 5142|      1|        let mut input = default_input();
 5143|      1|        input.modifiers = egui::Modifiers::CTRL;
 5144|      1|        input.events.push(egui::Event::MouseWheel {
 5145|      1|            unit: egui::MouseWheelUnit::Point,
 5146|      1|            delta: egui::vec2(0.0, 20.0),
 5147|      1|            modifiers: egui::Modifiers::CTRL,
 5148|      1|        });
 5149|      1|        let _ = ctx.run(input, |ctx| {
 5150|      1|            app.handle_shortcuts(ctx);
 5151|      1|        });
 5152|       |
 5153|      1|        let mut input = default_input();
 5154|      1|        input.modifiers = egui::Modifiers::CTRL;
 5155|      1|        input.events.push(egui::Event::MouseWheel {
 5156|      1|            unit: egui::MouseWheelUnit::Point,
 5157|      1|            delta: egui::vec2(0.0, -20.0),
 5158|      1|            modifiers: egui::Modifiers::CTRL,
 5159|      1|        });
 5160|      1|        let _ = ctx.run(input, |ctx| {
 5161|      1|            app.handle_shortcuts(ctx);
 5162|      1|        });
 5163|      1|    }
 5164|       |
 5165|       |    #[test]
 5166|      1|    fn test_handle_shortcuts_ctrl_mouse_wheel_without_events() {
 5167|      1|        let mut app = MarkdownViewerApp::new();
 5168|      1|        let ctx = egui::Context::default();
 5169|      1|        let mut input = default_input();
 5170|      1|        input.modifiers = egui::Modifiers::CTRL;
 5171|      1|        let _ = ctx.run(input, |ctx| {
 5172|      1|            app.handle_shortcuts(ctx);
 5173|      1|        });
 5174|      1|    }
 5175|       |
 5176|       |    #[test]
 5177|      1|    fn test_handle_shortcuts_ctrl_save_error() {
 5178|      1|        let mut app = MarkdownViewerApp::new();
 5179|      1|        app.current_file = Some(PathBuf::from("missing_dir\\save.md"));
 5180|      1|        app.current_content = "Data".to_string();
 5181|       |
 5182|      1|        let mut input = default_input();
 5183|      1|        input.events.push(egui::Event::Key {
 5184|      1|            key: egui::Key::S,
 5185|      1|            physical_key: None,
 5186|      1|            pressed: true,
 5187|      1|            repeat: false,
 5188|      1|            modifiers: egui::Modifiers::CTRL,
 5189|      1|        });
 5190|       |
 5191|      1|        let ctx = egui::Context::default();
 5192|      1|        let _ = ctx.run(input, |ctx| {
 5193|      1|            app.handle_shortcuts(ctx);
 5194|      1|        });
 5195|       |
 5196|      1|        assert!(app.error_message.is_some());
 5197|      1|    }
 5198|       |
 5199|       |    #[test]
 5200|      1|    fn test_move_raw_cursor_lines_edge_cases() {
 5201|      1|        let mut app = MarkdownViewerApp::new();
 5202|      1|        app.raw_buffer = "Line 1\nLine 2\nLine 3\nLine 4".to_string();
 5203|      1|        app.current_content = app.raw_buffer.clone();
 5204|       |
 5205|      1|        let ctx = egui::Context::default();
 5206|      1|        app.move_raw_cursor_lines(&ctx, 1);
 5207|       |
 5208|      1|        app.view_mode = ViewMode::Raw;
 5209|      1|        app.write_enabled = true;
 5210|      1|        let editor_id = egui::Id::new("raw_editor");
 5211|      1|        let mut state = egui::text_edit::TextEditState::default();
 5212|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(3));
 5213|      1|        state.cursor.set_char_range(Some(cr));
 5214|      1|        state.store(&ctx, editor_id);
 5215|       |
 5216|      1|        app.move_raw_cursor_lines(&ctx, 0);
 5217|      1|        app.move_raw_cursor_lines(&ctx, 2);
 5218|      1|        app.move_raw_cursor_lines(&ctx, -2);
 5219|      1|    }
 5220|       |
 5221|       |    #[test]
 5222|      1|    fn test_render_status_bar_no_file_and_tooltip() {
 5223|      1|        let mut app = MarkdownViewerApp::new();
 5224|      1|        app.current_file = None;
 5225|      1|        app.parsed_elements.clear();
 5226|       |
 5227|      1|        let _actions = ForcedAppActions::new(&["status_hover"]);
 5228|      1|        let ctx = egui::Context::default();
 5229|      1|        let _ = ctx.run(default_input(), |ctx| {
 5230|      1|            app.render_status_bar(ctx);
 5231|      1|        });
 5232|      1|    }
 5233|       |
 5234|       |    #[test]
 5235|      1|    fn test_render_status_bar_table_stats() {
 5236|      1|        let mut app = MarkdownViewerApp::new();
 5237|      1|        app.current_file = None;
 5238|      1|        app.parsed_elements = vec![MarkdownElement::Table {
 5239|      1|            headers: vec![vec![InlineSpan::Text("H".to_string())]],
 5240|      1|            rows: vec![vec![vec![InlineSpan::Text("C".to_string())]]],
 5241|      1|            alignments: vec![pulldown_cmark::Alignment::Left],
 5242|      1|        }];
 5243|       |
 5244|      1|        let ctx = egui::Context::default();
 5245|      1|        let _ = ctx.run(default_input(), |ctx| {
 5246|      1|            CentralPanel::default().show(ctx, |ui| {
 5247|      1|                app.renderer.render_to_ui(ui, &app.parsed_elements);
 5248|      1|            });
 5249|      1|            app.render_status_bar(ctx);
 5250|      1|        });
 5251|      1|    }
 5252|       |
 5253|       |    #[test]
 5254|      1|    fn test_update_impl_welcome_open_button() -> Result<()> {
 5255|      1|        let mut app = MarkdownViewerApp::new();
 5256|      1|        app.parsed_elements.clear();
 5257|      1|        app.current_content.clear();
 5258|      1|        app.error_message = None;
 5259|       |
 5260|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5261|      1|        let file_path = temp_dir.path().join("welcome.md");
 5262|      1|        std::fs::write(&file_path, "# Welcome")?;
                                                             ^0
 5263|      1|        let _forced = ForcedDialogPaths::new(Some(file_path.clone()), None);
 5264|      1|        let _actions = ForcedAppActions::new(&["welcome_open"]);
 5265|       |
 5266|      1|        let ctx = egui::Context::default();
 5267|      1|        run_app_frame(&mut app, &ctx, default_input());
 5268|       |
 5269|      1|        assert_eq!(app.current_file, Some(file_path));
 5270|      1|        Ok(())
 5271|      1|    }
 5272|       |
 5273|       |    #[test]
 5274|      1|    fn test_update_impl_navigation_requests() {
 5275|      1|        let mut app = MarkdownViewerApp::new();
 5276|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5277|      1|            "Nav".to_string(),
 5278|      1|        )])];
 5279|      1|        let ctx = egui::Context::default();
 5280|      1|        let input = default_input();
 5281|      1|        let navs = [
 5282|      1|            NavigationRequest::Top,
 5283|      1|            NavigationRequest::Bottom,
 5284|      1|            NavigationRequest::PageUp,
 5285|      1|            NavigationRequest::PageDown,
 5286|      1|            NavigationRequest::ScrollUp,
 5287|      1|            NavigationRequest::ScrollDown,
 5288|      1|        ];
 5289|      7|        for nav in navs {
                          ^6
 5290|      6|            app.nav_request = Some(nav);
 5291|      6|            run_app_frame(&mut app, &ctx, input.clone());
 5292|      6|        }
 5293|      1|    }
 5294|       |
 5295|       |    #[test]
 5296|      1|    fn test_update_impl_anchor_and_search_highlight() {
 5297|      1|        let mut app = MarkdownViewerApp::new();
 5298|      1|        app.parsed_elements = vec![MarkdownElement::Header {
 5299|      1|            level: 1,
 5300|      1|            spans: vec![InlineSpan::Text("Section".to_string())],
 5301|      1|            id: "section".to_string(),
 5302|      1|        }];
 5303|      1|        app.current_content = "# Section".to_string();
 5304|      1|        app.show_search = true;
 5305|      1|        app.search_query = "Section".to_string();
 5306|      1|        app.pending_scroll_to_element = Some(0);
 5307|      1|        app.renderer.trigger_link("#section");
 5308|       |
 5309|      1|        let ctx = egui::Context::default();
 5310|      1|        run_app_frame(&mut app, &ctx, default_input());
 5311|       |
 5312|      1|        app.show_search = false;
 5313|      1|        app.search_query.clear();
 5314|      1|        app.last_query = "Section".to_string();
 5315|      1|        run_app_frame(&mut app, &ctx, default_input());
 5316|      1|    }
 5317|       |
 5318|       |    #[test]
 5319|      1|    fn test_update_impl_raw_cursor_restore_without_state() {
 5320|      1|        let mut app = MarkdownViewerApp::new();
 5321|      1|        app.view_mode = ViewMode::Raw;
 5322|      1|        app.write_enabled = true;
 5323|      1|        app.raw_buffer = "Line 1\nLine 2".to_string();
 5324|      1|        app.current_content = app.raw_buffer.clone();
 5325|      1|        app.raw_cursor = Some(3);
 5326|       |
 5327|      1|        let ctx = egui::Context::default();
 5328|      1|        run_app_frame(&mut app, &ctx, default_input());
 5329|      1|    }
 5330|       |
 5331|       |    #[test]
 5332|      1|    fn test_update_impl_raw_edit_updates_content() {
 5333|      1|        let mut app = MarkdownViewerApp::new();
 5334|      1|        app.view_mode = ViewMode::Raw;
 5335|      1|        app.write_enabled = true;
 5336|      1|        app.raw_focus_requested = true;
 5337|      1|        app.raw_buffer = "Line".to_string();
 5338|      1|        app.current_content = app.raw_buffer.clone();
 5339|       |
 5340|      1|        let ctx = egui::Context::default();
 5341|      1|        let mut input = default_input();
 5342|      1|        input.focused = true;
 5343|      1|        run_app_frame(&mut app, &ctx, input);
 5344|       |
 5345|      1|        let mut input = default_input();
 5346|      1|        input.focused = true;
 5347|      1|        input.events.push(egui::Event::Text("X".to_string()));
 5348|      1|        run_app_frame(&mut app, &ctx, input);
 5349|       |
 5350|      1|        assert!(app.current_content.contains('X'));
 5351|      1|    }
 5352|       |
 5353|       |    #[test]
 5354|      1|    fn test_update_impl_screenshot_scroll_offset() {
 5355|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 5356|      1|        let config = ScreenshotConfig {
 5357|      1|            output_path: temp_dir.path().join("shot.png"),
 5358|      1|            viewport_width: 80.0,
 5359|      1|            viewport_height: 60.0,
 5360|      1|            content_only: false,
 5361|      1|            scroll_ratio: None,
 5362|      1|            wait_ms: 0,
 5363|      1|            settle_frames: 0,
 5364|      1|            zoom: 1.0,
 5365|      1|            theme: ScreenshotTheme::Light,
 5366|      1|            font_source: None,
 5367|      1|        };
 5368|      1|        let mut app = MarkdownViewerApp::new();
 5369|      1|        app.screenshot = Some(ScreenshotState::new(config));
 5370|      1|        if let Some(state) = app.screenshot.as_mut() {
  ------------------
  |  Branch (5370:16): [True: 1, False: 0]
  ------------------
 5371|      1|            state.scroll_offset = Some(10.0);
 5372|      1|        }
                      ^0
 5373|       |
 5374|      1|        let ctx = egui::Context::default();
 5375|      1|        run_app_frame(&mut app, &ctx, default_input());
 5376|      1|    }
 5377|       |
 5378|       |    #[test]
 5379|      1|    fn test_save_screenshot_image_creates_parent_dir() -> Result<()> {
 5380|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5381|      1|        let nested = temp_dir.path().join("nested").join("shot.png");
 5382|      1|        let config = ScreenshotConfig {
 5383|      1|            output_path: nested.clone(),
 5384|      1|            viewport_width: 40.0,
 5385|      1|            viewport_height: 30.0,
 5386|      1|            content_only: false,
 5387|      1|            scroll_ratio: None,
 5388|      1|            wait_ms: 0,
 5389|      1|            settle_frames: 0,
 5390|      1|            zoom: 1.0,
 5391|      1|            theme: ScreenshotTheme::Light,
 5392|      1|            font_source: None,
 5393|      1|        };
 5394|      1|        let snapshot = ScreenshotSnapshot {
 5395|      1|            config,
 5396|      1|            content_rect: None,
 5397|      1|            pixels_per_point: 1.0,
 5398|      1|            stable_frames: 0,
 5399|      1|            timed_out: false,
 5400|      1|            pending_renders: false,
 5401|      1|            last_scroll_offset: None,
 5402|      1|            started: Instant::now(),
 5403|      1|        };
 5404|      1|        let image = egui::ColorImage::new([40, 30], Color32::WHITE);
 5405|      1|        MarkdownViewerApp::save_screenshot_image(&image, &snapshot)?;
                                                                                 ^0
 5406|      1|        assert!(nested.exists());
 5407|      1|        assert!(nested.with_extension("json").exists());
 5408|      1|        Ok(())
 5409|      1|    }
 5410|       |
 5411|       |    #[test]
 5412|      1|    fn test_handle_screenshot_events_branches() {
 5413|      1|        let mut app = MarkdownViewerApp::new();
 5414|      1|        let ctx = egui::Context::default();
 5415|       |
 5416|      1|        let mut input = default_input();
 5417|      1|        input.events.push(egui::Event::Key {
 5418|      1|            key: egui::Key::A,
 5419|      1|            physical_key: None,
 5420|      1|            pressed: true,
 5421|      1|            repeat: false,
 5422|      1|            modifiers: egui::Modifiers::NONE,
 5423|      1|        });
 5424|      1|        let _ = ctx.run(input, |ctx| {
 5425|      1|            app.handle_screenshot_events(ctx);
 5426|      1|        });
 5427|       |
 5428|      1|        let image = egui::ColorImage::new([10, 10], Color32::WHITE);
 5429|      1|        let mut input = default_input();
 5430|      1|        input.events.push(egui::Event::Screenshot {
 5431|      1|            viewport_id: egui::ViewportId::ROOT,
 5432|      1|            image: std::sync::Arc::new(image),
 5433|      1|        });
 5434|      1|        let _ = ctx.run(input, |ctx| {
 5435|      1|            app.handle_screenshot_events(ctx);
 5436|      1|        });
 5437|       |
 5438|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 5439|      1|        let config = ScreenshotConfig {
 5440|      1|            output_path: temp_dir.path().to_path_buf(),
 5441|      1|            viewport_width: 40.0,
 5442|      1|            viewport_height: 30.0,
 5443|      1|            content_only: false,
 5444|      1|            scroll_ratio: None,
 5445|      1|            wait_ms: 0,
 5446|      1|            settle_frames: 0,
 5447|      1|            zoom: 1.0,
 5448|      1|            theme: ScreenshotTheme::Light,
 5449|      1|            font_source: None,
 5450|      1|        };
 5451|      1|        app.screenshot = Some(ScreenshotState::new(config));
 5452|      1|        if let Some(state) = app.screenshot.as_mut() {
  ------------------
  |  Branch (5452:16): [True: 1, False: 0]
  ------------------
 5453|      1|            state.done = true;
 5454|      1|        }
                      ^0
 5455|      1|        let image = egui::ColorImage::new([10, 10], Color32::WHITE);
 5456|      1|        let mut input = default_input();
 5457|      1|        input.events.push(egui::Event::Screenshot {
 5458|      1|            viewport_id: egui::ViewportId::ROOT,
 5459|      1|            image: std::sync::Arc::new(image),
 5460|      1|        });
 5461|      1|        let _ = ctx.run(input, |ctx| {
 5462|      1|            app.handle_screenshot_events(ctx);
 5463|      1|        });
 5464|      1|    }
 5465|       |
 5466|       |    #[test]
 5467|      1|    fn test_screenshot_state_helpers() {
 5468|      1|        let config = ScreenshotConfig {
 5469|      1|            output_path: PathBuf::from("dummy.png"),
 5470|      1|            viewport_width: 120.0,
 5471|      1|            viewport_height: 80.0,
 5472|      1|            content_only: false,
 5473|      1|            scroll_ratio: Some(0.5),
 5474|      1|            wait_ms: 500,
 5475|      1|            settle_frames: 2,
 5476|      1|            zoom: 1.0,
 5477|      1|            theme: ScreenshotTheme::Light,
 5478|      1|            font_source: None,
 5479|      1|        };
 5480|      1|        let mut state = ScreenshotState::new(config);
 5481|      1|        assert!(!state.scroll_ready());
 5482|       |
 5483|      1|        let snapshot = ScrollSnapshot {
 5484|      1|            content_size: egui::vec2(200.0, 400.0),
 5485|      1|            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 200.0)),
 5486|      1|            offset_y: 0.0,
 5487|      1|        };
 5488|      1|        assert!(state.record_scroll(snapshot));
 5489|      1|        assert!(!state.record_scroll(snapshot));
 5490|       |
 5491|      1|        state.update_stability(None, None);
 5492|      1|        state.last_scroll_offset = Some(0.0);
 5493|      1|        state.update_stability(Some(1), Some(10.0));
 5494|      1|    }
 5495|       |
 5496|       |    #[test]
 5497|      1|    fn test_record_scroll_without_ratio_returns_false() {
 5498|      1|        let config = ScreenshotConfig {
 5499|      1|            output_path: PathBuf::from("dummy.png"),
 5500|      1|            viewport_width: 120.0,
 5501|      1|            viewport_height: 80.0,
 5502|      1|            content_only: false,
 5503|      1|            scroll_ratio: None,
 5504|      1|            wait_ms: 500,
 5505|      1|            settle_frames: 2,
 5506|      1|            zoom: 1.0,
 5507|      1|            theme: ScreenshotTheme::Light,
 5508|      1|            font_source: None,
 5509|      1|        };
 5510|      1|        let mut state = ScreenshotState::new(config);
 5511|      1|        let snapshot = ScrollSnapshot {
 5512|      1|            content_size: egui::vec2(200.0, 400.0),
 5513|      1|            inner_rect: egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 200.0)),
 5514|      1|            offset_y: 0.0,
 5515|      1|        };
 5516|      1|        assert!(!state.record_scroll(snapshot));
 5517|      1|        assert!(state.scroll_offset.is_none());
 5518|      1|    }
 5519|       |
 5520|       |    #[test]
 5521|      1|    fn test_toggle_write_mode_captures_cursor() {
 5522|      1|        let mut app = MarkdownViewerApp::new();
 5523|      1|        app.view_mode = ViewMode::Raw;
 5524|      1|        app.write_enabled = true;
 5525|       |
 5526|      1|        let ctx = egui::Context::default();
 5527|      1|        let editor_id = egui::Id::new("raw_editor");
 5528|      1|        let mut state = egui::text_edit::TextEditState::default();
 5529|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(2));
 5530|      1|        state.cursor.set_char_range(Some(cr));
 5531|      1|        state.store(&ctx, editor_id);
 5532|       |
 5533|      1|        app.toggle_write_mode(&ctx);
 5534|      1|        assert!(!app.write_enabled);
 5535|      1|        assert_eq!(app.raw_cursor, Some(2));
 5536|      1|    }
 5537|       |
 5538|       |    #[test]
 5539|      1|    fn test_toggle_write_mode_without_text_state() {
 5540|      1|        let mut app = MarkdownViewerApp::new();
 5541|      1|        app.view_mode = ViewMode::Raw;
 5542|      1|        app.write_enabled = true;
 5543|       |
 5544|      1|        let ctx = egui::Context::default();
 5545|      1|        app.toggle_write_mode(&ctx);
 5546|      1|        assert!(!app.write_enabled);
 5547|      1|        assert!(app.raw_cursor.is_none());
 5548|      1|    }
 5549|       |
 5550|       |    #[test]
 5551|      1|    fn test_toggle_write_mode_without_cursor_range() {
 5552|      1|        let mut app = MarkdownViewerApp::new();
 5553|      1|        app.view_mode = ViewMode::Raw;
 5554|      1|        app.write_enabled = true;
 5555|       |
 5556|      1|        let ctx = egui::Context::default();
 5557|      1|        let editor_id = egui::Id::new("raw_editor");
 5558|      1|        let mut state = egui::text_edit::TextEditState::default();
 5559|      1|        state.cursor.set_char_range(None);
 5560|      1|        state.store(&ctx, editor_id);
 5561|       |
 5562|      1|        app.toggle_write_mode(&ctx);
 5563|      1|        assert!(!app.write_enabled);
 5564|      1|        assert!(app.raw_cursor.is_none());
 5565|      1|    }
 5566|       |
 5567|       |    #[test]
 5568|      1|    fn test_move_raw_cursor_lines_moves_to_end() {
 5569|      1|        let mut app = MarkdownViewerApp::new();
 5570|      1|        app.view_mode = ViewMode::Raw;
 5571|      1|        app.write_enabled = true;
 5572|      1|        app.raw_buffer = "Line 1\nLine 2".to_string();
 5573|      1|        app.current_content = app.raw_buffer.clone();
 5574|       |
 5575|      1|        let ctx = egui::Context::default();
 5576|      1|        let editor_id = egui::Id::new("raw_editor");
 5577|      1|        let mut state = egui::text_edit::TextEditState::default();
 5578|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(0));
 5579|      1|        state.cursor.set_char_range(Some(cr));
 5580|      1|        state.store(&ctx, editor_id);
 5581|       |
 5582|      1|        app.move_raw_cursor_lines(&ctx, 2);
 5583|      1|        assert_eq!(app.raw_cursor, Some(app.raw_buffer.len()));
 5584|      1|    }
 5585|       |
 5586|       |    #[test]
 5587|      1|    fn test_find_next_uses_last_query() {
 5588|      1|        let mut app = MarkdownViewerApp::new();
 5589|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5590|      1|            "Hello".to_string(),
 5591|      1|        )])];
 5592|      1|        app.search_query.clear();
 5593|      1|        app.last_query = "Hello".to_string();
 5594|       |
 5595|      1|        app.find_next();
 5596|      1|        assert_eq!(app.last_match_index, Some(0));
 5597|      1|    }
 5598|       |
 5599|       |    #[test]
 5600|      1|    fn test_find_previous_wraps_from_start() {
 5601|      1|        let mut app = MarkdownViewerApp::new();
 5602|      1|        app.parsed_elements = vec![
 5603|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
 5604|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("Other".to_string())]),
 5605|       |        ];
 5606|      1|        app.search_query.clear();
 5607|      1|        app.last_query = "Match".to_string();
 5608|      1|        app.last_match_index = Some(0);
 5609|       |
 5610|      1|        app.find_previous();
 5611|      1|        assert_eq!(app.last_match_index, Some(0));
 5612|      1|    }
 5613|       |
 5614|       |    #[test]
 5615|      1|    fn test_set_zoom_scale_on_app() {
 5616|      1|        let mut app = MarkdownViewerApp::new();
 5617|      1|        let before = app.renderer.font_sizes().body;
 5618|      1|        app.set_zoom_scale(1.5);
 5619|      1|        assert_ne!(app.renderer.font_sizes().body, before);
 5620|      1|    }
 5621|       |
 5622|       |    #[test]
 5623|      1|    fn test_handle_file_drop_no_valid_files() {
 5624|      1|        let mut app = MarkdownViewerApp::new();
 5625|      1|        app.handle_file_drop(vec![
 5626|      1|            PathBuf::from("missing1.md"),
 5627|      1|            PathBuf::from("missing2.md"),
 5628|       |        ]);
 5629|      1|        assert!(app
 5630|      1|            .error_message
 5631|      1|            .as_ref()
 5632|      1|            .is_some_and(|msg| msg.contains("No valid files")));
 5633|      1|    }
 5634|       |
 5635|       |    #[test]
 5636|      1|    fn test_compute_window_adjustment_invalid_monitor_returns_none() {
 5637|      1|        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 100.0));
 5638|      1|        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 5639|      1|            Some(outer),
 5640|      1|            Some(outer),
 5641|      1|            Some(egui::vec2(0.0, 0.0)),
 5642|       |        );
 5643|      1|        assert!(adjusted.is_none());
 5644|      1|    }
 5645|       |
 5646|       |    #[test]
 5647|      1|    fn test_compute_window_adjustment_invalid_monitor_height_returns_none() {
 5648|      1|        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 100.0));
 5649|      1|        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 5650|      1|            Some(outer),
 5651|      1|            Some(outer),
 5652|      1|            Some(egui::vec2(800.0, 0.0)),
 5653|       |        );
 5654|      1|        assert!(adjusted.is_none());
 5655|      1|    }
 5656|       |
 5657|       |    #[test]
 5658|      1|    fn test_compute_window_adjustment_handles_nan_and_clamps() {
 5659|      1|        let outer = egui::Rect::from_min_size(
 5660|      1|            egui::pos2(f32::NAN, f32::NAN),
 5661|      1|            egui::vec2(f32::NAN, f32::NAN),
 5662|       |        );
 5663|      1|        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 5664|      1|            Some(outer),
 5665|      1|            Some(outer),
 5666|      1|            Some(egui::vec2(800.0, 600.0)),
 5667|       |        );
 5668|      1|        assert!(adjusted.is_some());
 5669|       |
 5670|      1|        let outer = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(5000.0, 4000.0));
 5671|      1|        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 5672|      1|            Some(outer),
 5673|      1|            Some(outer),
 5674|      1|            Some(egui::vec2(800.0, 600.0)),
 5675|       |        );
 5676|      1|        assert!(adjusted.is_some());
 5677|      1|    }
 5678|       |
 5679|       |    #[test]
 5680|      1|    fn test_compute_window_adjustment_invalid_pos_only() {
 5681|      1|        let outer = egui::Rect::from_min_size(egui::pos2(f32::NAN, 0.0), egui::vec2(800.0, 600.0));
 5682|      1|        let inner =
 5683|      1|            egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(800.0, 600.0));
 5684|      1|        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 5685|      1|            Some(outer),
 5686|      1|            Some(inner),
 5687|      1|            Some(egui::vec2(1200.0, 900.0)),
 5688|       |        )
 5689|      1|        .expect("adjustment");
 5690|      1|        assert!(adjusted.pos.is_some());
 5691|      1|        assert!(adjusted.size.is_none());
 5692|      1|    }
 5693|       |
 5694|       |    #[test]
 5695|      1|    fn test_compute_window_adjustment_invalid_size_only() {
 5696|      1|        let outer = egui::Rect::from_min_size(
 5697|      1|            egui::pos2(10.0, 20.0),
 5698|      1|            egui::vec2(800.0, f32::NAN),
 5699|       |        );
 5700|      1|        let adjusted = MarkdownViewerApp::compute_window_adjustment(
 5701|      1|            Some(outer),
 5702|      1|            Some(outer),
 5703|      1|            Some(egui::vec2(1200.0, 900.0)),
 5704|       |        )
 5705|      1|        .expect("adjustment");
 5706|      1|        assert!(adjusted.pos.is_none());
 5707|      1|        assert!(adjusted.size.is_some());
 5708|      1|    }
 5709|       |
 5710|       |    #[test]
 5711|      1|    fn test_push_history_caps_max() {
 5712|      1|        let mut app = MarkdownViewerApp::new();
 5713|      1|        app.max_history = 1;
 5714|      1|        app.current_content = "First".to_string();
 5715|      1|        app.title = "First".to_string();
 5716|      1|        app.push_history();
 5717|       |
 5718|      1|        app.current_content = "Second".to_string();
 5719|      1|        app.title = "Second".to_string();
 5720|      1|        app.push_history();
 5721|       |
 5722|      1|        assert_eq!(app.history.len(), 1);
 5723|      1|        assert_eq!(app.history[0].content, "Second");
 5724|      1|    }
 5725|       |
 5726|       |    #[test]
 5727|      1|    fn test_navigate_forward_pending_error() {
 5728|      1|        let mut app = MarkdownViewerApp::new();
 5729|      1|        let _forced = ForcedLoadError::new();
 5730|      1|        app.pending_files.push_back(PathBuf::from("missing.md"));
 5731|       |
 5732|      1|        assert!(app.navigate_forward());
 5733|      1|        assert!(app.error_message.is_some());
 5734|      1|    }
 5735|       |
 5736|       |    #[test]
 5737|      1|    fn test_navigate_forward_history() {
 5738|      1|        let mut app = MarkdownViewerApp::new();
 5739|      1|        app.history = vec![
 5740|      1|            HistoryEntry {
 5741|      1|                file_path: None,
 5742|      1|                title: "One".to_string(),
 5743|      1|                content: "One".to_string(),
 5744|      1|            },
 5745|      1|            HistoryEntry {
 5746|      1|                file_path: None,
 5747|      1|                title: "Two".to_string(),
 5748|      1|                content: "Two".to_string(),
 5749|      1|            },
 5750|       |        ];
 5751|      1|        app.history_index = 0;
 5752|       |
 5753|      1|        assert!(app.navigate_forward());
 5754|      1|        assert_eq!(app.history_index, 1);
 5755|      1|        assert_eq!(app.current_content, "Two");
 5756|      1|    }
 5757|       |
 5758|       |    #[test]
 5759|      1|    fn test_restore_from_history_parse_error() {
 5760|      1|        let mut app = MarkdownViewerApp::new();
 5761|      1|        app.history = vec![HistoryEntry {
 5762|      1|            file_path: None,
 5763|      1|            title: "Bad".to_string(),
 5764|      1|            content: "Bad".to_string(),
 5765|      1|        }];
 5766|      1|        app.history_index = 0;
 5767|      1|        crate::markdown_renderer::force_parse_error_once();
 5768|       |
 5769|      1|        app.restore_from_history();
 5770|      1|        assert!(app.error_message.is_some());
 5771|      1|    }
 5772|       |
 5773|       |    #[test]
 5774|      1|    fn test_open_file_dialog_load_error() -> Result<()> {
 5775|      1|        let mut app = MarkdownViewerApp::new();
 5776|      1|        let temp_dir = tempfile::TempDir::new()?;
                                                             ^0
 5777|      1|        let open_path = temp_dir.path().join("open.md");
 5778|      1|        std::fs::write(&open_path, "# Open")?;
                                                          ^0
 5779|      1|        let _forced_path = ForcedDialogPaths::new(Some(open_path), None);
 5780|      1|        let _forced_load = ForcedLoadError::new();
 5781|       |
 5782|      1|        app.open_file_dialog();
 5783|      1|        assert!(app
 5784|      1|            .error_message
 5785|      1|            .as_ref()
 5786|      1|            .is_some_and(|msg| msg.contains("Failed to open file")));
 5787|      1|        Ok(())
 5788|      1|    }
 5789|       |
 5790|       |    #[test]
 5791|      1|    fn test_toggle_view_mode_captures_cursor() {
 5792|      1|        let mut app = MarkdownViewerApp::new();
 5793|      1|        app.view_mode = ViewMode::Raw;
 5794|      1|        app.write_enabled = true;
 5795|       |
 5796|      1|        let ctx = egui::Context::default();
 5797|      1|        let editor_id = egui::Id::new("raw_editor");
 5798|      1|        let mut state = egui::text_edit::TextEditState::default();
 5799|      1|        let cr = egui::text::CCursorRange::one(egui::text::CCursor::new(4));
 5800|      1|        state.cursor.set_char_range(Some(cr));
 5801|      1|        state.store(&ctx, editor_id);
 5802|       |
 5803|      1|        app.toggle_view_mode(&ctx);
 5804|      1|        assert_eq!(app.raw_cursor, Some(4));
 5805|      1|        assert_eq!(app.view_mode, ViewMode::Rendered);
 5806|      1|    }
 5807|       |
 5808|       |    #[test]
 5809|      1|    fn test_handle_shortcuts_shift_f3_triggers_previous() {
 5810|      1|        let mut app = MarkdownViewerApp::new();
 5811|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5812|      1|            "Nav".to_string(),
 5813|      1|        )])];
 5814|      1|        app.search_query = "Nav".to_string();
 5815|       |
 5816|      1|        let mut input = default_input();
 5817|      1|        input.events.push(egui::Event::Key {
 5818|      1|            key: egui::Key::F3,
 5819|      1|            physical_key: None,
 5820|      1|            pressed: true,
 5821|      1|            repeat: false,
 5822|      1|            modifiers: egui::Modifiers::SHIFT,
 5823|      1|        });
 5824|       |
 5825|      1|        let ctx = egui::Context::default();
 5826|      1|        let _ = ctx.run(input, |ctx| {
 5827|      1|            app.handle_shortcuts(ctx);
 5828|      1|        });
 5829|       |
 5830|      1|        assert_eq!(app.last_match_index, Some(0));
 5831|      1|    }
 5832|       |
 5833|       |    #[test]
 5834|      1|    fn test_handle_shortcuts_f3_triggers_next() {
 5835|      1|        let mut app = MarkdownViewerApp::new();
 5836|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5837|      1|            "Nav".to_string(),
 5838|      1|        )])];
 5839|      1|        app.search_query = "Nav".to_string();
 5840|       |
 5841|      1|        let mut input = default_input();
 5842|      1|        input.events.push(egui::Event::Key {
 5843|      1|            key: egui::Key::F3,
 5844|      1|            physical_key: None,
 5845|      1|            pressed: true,
 5846|      1|            repeat: false,
 5847|      1|            modifiers: egui::Modifiers::NONE,
 5848|      1|        });
 5849|       |
 5850|      1|        let ctx = egui::Context::default();
 5851|      1|        let _ = ctx.run(input, |ctx| {
 5852|      1|            app.handle_shortcuts(ctx);
 5853|      1|        });
 5854|       |
 5855|      1|        assert_eq!(app.last_match_index, Some(0));
 5856|      1|    }
 5857|       |
 5858|       |    #[test]
 5859|      1|    fn test_handle_shortcuts_alt_f3_triggers_previous() {
 5860|      1|        let mut app = MarkdownViewerApp::new();
 5861|      1|        app.parsed_elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 5862|      1|            "Nav".to_string(),
 5863|      1|        )])];
 5864|      1|        app.search_query = "Nav".to_string();
 5865|       |
 5866|      1|        let mut input = default_input();
 5867|      1|        input.events.push(egui::Event::Key {
 5868|      1|            key: egui::Key::F3,
 5869|      1|            physical_key: None,
 5870|      1|            pressed: true,
 5871|      1|            repeat: false,
 5872|      1|            modifiers: egui::Modifiers::ALT,
 5873|      1|        });
 5874|       |
 5875|      1|        let ctx = egui::Context::default();
 5876|      1|        let _ = ctx.run(input, |ctx| {
 5877|      1|            app.handle_shortcuts(ctx);
 5878|      1|        });
 5879|       |
 5880|      1|        assert_eq!(app.last_match_index, Some(0));
 5881|      1|    }
 5882|       |
 5883|       |    #[test]
 5884|      1|    fn test_render_file_menu_save_error_sets_message() {
 5885|      1|        let mut app = MarkdownViewerApp::new();
 5886|      1|        app.current_file = Some(PathBuf::from("missing_dir\\save.md"));
 5887|      1|        app.current_content = "Data".to_string();
 5888|      1|        let _actions = ForcedAppActions::new(&["menu_save"]);
 5889|       |
 5890|      1|        let ctx = egui::Context::default();
 5891|      1|        let _ = ctx.run(default_input(), |ctx| {
 5892|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 5893|      1|                app.render_file_menu_contents(ui, false, Color32::WHITE);
 5894|      1|            });
 5895|      1|        });
 5896|       |
 5897|      1|        assert!(app.error_message.is_some());
 5898|      1|    }
 5899|       |
 5900|       |    #[test]
 5901|      1|    fn test_menu_text_with_mnemonic_prefix_and_underline() {
 5902|      1|        let job = MarkdownViewerApp::menu_text_with_mnemonic(
 5903|      1|            Some("Alt+"),
 5904|      1|            "Open",
 5905|       |            'O',
 5906|       |            true,
 5907|       |            Color32::WHITE,
 5908|       |        );
 5909|      1|        assert!(!job.sections.is_empty());
 5910|      1|    }
 5911|       |
 5912|       |    #[test]
 5913|      1|    fn test_menu_text_with_mnemonic_no_underline() {
 5914|      1|        let job =
 5915|      1|            MarkdownViewerApp::menu_text_with_mnemonic(None, "Save", 'S', false, Color32::WHITE);
 5916|      1|        assert!(!job.sections.is_empty());
 5917|      1|    }
 5918|       |
 5919|       |    #[test]
 5920|      1|    fn test_persist_window_state_no_change_returns_early() {
 5921|      1|        let mut app = MarkdownViewerApp::new();
 5922|      1|        app.last_window_pos = Some([10.0, 10.0]);
 5923|      1|        app.last_window_size = Some([800.0, 600.0]);
 5924|      1|        app.last_window_maximized = false;
 5925|      1|        app.last_persisted_state = Some(WindowState {
 5926|      1|            pos: [10.0, 10.0],
 5927|      1|            size: [800.0, 600.0],
 5928|      1|            maximized: false,
 5929|      1|        });
 5930|       |
 5931|      1|        app.persist_window_state();
 5932|      1|        assert!(app.last_persisted_state.is_some());
 5933|      1|    }
 5934|       |
 5935|       |    #[test]
 5936|      1|    fn test_should_persist_window_state_screenshot_blocks() {
 5937|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 5938|      1|        let config = ScreenshotConfig {
 5939|      1|            output_path: temp_dir.path().join("shot.png"),
 5940|      1|            viewport_width: 80.0,
 5941|      1|            viewport_height: 60.0,
 5942|      1|            content_only: false,
 5943|      1|            scroll_ratio: None,
 5944|      1|            wait_ms: 0,
 5945|      1|            settle_frames: 0,
 5946|      1|            zoom: 1.0,
 5947|      1|            theme: ScreenshotTheme::Light,
 5948|      1|            font_source: None,
 5949|      1|        };
 5950|      1|        let mut app = MarkdownViewerApp::new();
 5951|      1|        app.screenshot = Some(ScreenshotState::new(config));
 5952|      1|        assert!(!app.should_persist_window_state());
 5953|      1|    }
 5954|       |
 5955|       |    #[test]
 5956|      1|    fn test_should_persist_window_state_recently_persisted() {
 5957|      1|        let mut app = MarkdownViewerApp::new();
 5958|      1|        app.last_window_pos = Some([10.0, 10.0]);
 5959|      1|        app.last_window_size = Some([800.0, 600.0]);
 5960|      1|        app.last_persist_instant = std::time::Instant::now();
 5961|      1|        assert!(!app.should_persist_window_state());
 5962|      1|    }
 5963|       |
 5964|       |    #[test]
 5965|      1|    fn test_should_persist_window_state_without_window_state() {
 5966|      1|        let mut app = MarkdownViewerApp::new();
 5967|      1|        app.last_persist_instant =
 5968|      1|            std::time::Instant::now() - std::time::Duration::from_secs(2);
 5969|      1|        assert!(!app.should_persist_window_state());
 5970|      1|    }
 5971|       |
 5972|       |    #[test]
 5973|      1|    fn test_save_current_document_parentless_path() -> Result<()> {
 5974|      1|        let mut app = MarkdownViewerApp::new();
 5975|      1|        app.current_content = "Saved".to_string();
 5976|      1|        let filename = format!("save_parentless_{}.md", std::process::id());
 5977|      1|        let _forced = ForcedDialogPaths::new(None, Some(PathBuf::from(&filename)));
 5978|       |
 5979|      1|        app.save_current_document()?;
                                                 ^0
 5980|      1|        assert_eq!(app.current_file, Some(PathBuf::from(&filename)));
 5981|      1|        std::fs::remove_file(&filename)?;
                                                     ^0
 5982|      1|        Ok(())
 5983|      1|    }
 5984|       |
 5985|       |    #[test]
 5986|      1|    fn test_update_search_results_wraps() {
 5987|      1|        let mut app = MarkdownViewerApp::new();
 5988|      1|        app.parsed_elements = vec![
 5989|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("Match".to_string())]),
 5990|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("Other".to_string())]),
 5991|       |        ];
 5992|      1|        app.search_query = "Match".to_string();
 5993|      1|        app.last_match_index = Some(1);
 5994|       |
 5995|      1|        app.update_search_results("");
 5996|      1|        assert_eq!(app.last_match_index, Some(0));
 5997|      1|    }
 5998|       |
 5999|       |    #[test]
 6000|      1|    fn test_handle_screenshot_events_save_error() {
 6001|      1|        let mut app = MarkdownViewerApp::new();
 6002|      1|        let ctx = egui::Context::default();
 6003|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 6004|      1|        let config = ScreenshotConfig {
 6005|      1|            output_path: temp_dir.path().to_path_buf(),
 6006|      1|            viewport_width: 40.0,
 6007|      1|            viewport_height: 30.0,
 6008|      1|            content_only: false,
 6009|      1|            scroll_ratio: None,
 6010|      1|            wait_ms: 0,
 6011|      1|            settle_frames: 0,
 6012|      1|            zoom: 1.0,
 6013|      1|            theme: ScreenshotTheme::Light,
 6014|      1|            font_source: None,
 6015|      1|        };
 6016|      1|        app.screenshot = Some(ScreenshotState::new(config));
 6017|       |
 6018|      1|        let image = egui::ColorImage::new([10, 10], Color32::WHITE);
 6019|      1|        let mut input = default_input();
 6020|      1|        input.events.push(egui::Event::Screenshot {
 6021|      1|            viewport_id: egui::ViewportId::ROOT,
 6022|      1|            image: std::sync::Arc::new(image),
 6023|      1|        });
 6024|      1|        let _ = ctx.run(input, |ctx| {
 6025|      1|            app.handle_screenshot_events(ctx);
 6026|      1|        });
 6027|       |
 6028|      1|        assert!(app.screenshot.as_ref().is_some_and(|state| state.done));
 6029|      1|    }
 6030|       |
 6031|       |    #[test]
 6032|      1|    fn test_update_screenshot_state_requests_repaint() {
 6033|      1|        let temp_dir = tempfile::TempDir::new().expect("temp dir");
 6034|      1|        let config = ScreenshotConfig {
 6035|      1|            output_path: temp_dir.path().join("shot.png"),
 6036|      1|            viewport_width: 200.0,
 6037|      1|            viewport_height: 100.0,
 6038|      1|            content_only: false,
 6039|      1|            scroll_ratio: Some(0.5),
 6040|      1|            wait_ms: 1000,
 6041|      1|            settle_frames: 5,
 6042|      1|            zoom: 1.0,
 6043|      1|            theme: ScreenshotTheme::Light,
 6044|      1|            font_source: None,
 6045|      1|        };
 6046|      1|        let mut app = MarkdownViewerApp::new();
 6047|      1|        app.screenshot = Some(ScreenshotState::new(config));
 6048|       |
 6049|      1|        let ctx = egui::Context::default();
 6050|      1|        app.update_screenshot_state(&ctx, None, None);
 6051|      1|    }
 6052|       |
 6053|       |    #[test]
 6054|      1|    fn test_env_guard_removes_unset_key() {
 6055|      1|        let _lock = env_lock();
 6056|      1|        std::env::remove_var("MDMDVIEW_TMP_ENV");
 6057|      1|        {
 6058|      1|            let _guard = EnvGuard::set("MDMDVIEW_TMP_ENV", "value");
 6059|      1|        }
 6060|      1|        assert!(std::env::var("MDMDVIEW_TMP_ENV").is_err());
 6061|      1|    }
 6062|       |}

C:\language\mdmdview\src\emoji_assets.rs:
    1|       |use egui::Color32 as C;
    2|       |
    3|       |// Draw simple vector fallback icons for a subset of emoji.
    4|     12|pub fn make_image(emoji: &str, size: usize) -> Option<egui::ColorImage> {
    5|     12|    let mut img = egui::ColorImage::new([size, size], C::TRANSPARENT);
    6|     12|    match emoji {
    7|     12|        "\u{2705}" => {
    8|      1|            draw_circle(&mut img, size, C::from_rgb(34, 139, 34));
    9|      1|            draw_check(&mut img, size, C::WHITE);
   10|      1|            Some(img)
   11|       |        }
   12|     11|        "\u{1f389}" => {
   13|      1|            draw_circle(&mut img, size, C::from_rgb(255, 215, 0));
   14|      1|            confetti(&mut img, size);
   15|      1|            Some(img)
   16|       |        }
   17|     10|        "\u{1f680}" => {
   18|      1|            draw_circle(&mut img, size, C::from_rgb(60, 60, 170));
   19|      1|            rocket(
   20|      1|                &mut img,
   21|      1|                size,
   22|      1|                C::from_rgb(230, 230, 230),
   23|      1|                C::from_rgb(255, 110, 60),
   24|       |            );
   25|      1|            Some(img)
   26|       |        }
   27|      9|        "\u{2764}" | "\u{1f496}" => {
                                   ^5
   28|      5|            heart(&mut img, size, C::from_rgb(220, 20, 60));
   29|      5|            Some(img)
   30|       |        }
   31|      4|        "\u{2b50}" => {
   32|      1|            star(&mut img, size, C::from_rgb(255, 215, 0));
   33|      1|            Some(img)
   34|       |        }
   35|      3|        "\u{1f525}" => {
   36|      1|            flame(&mut img, size);
   37|      1|            Some(img)
   38|       |        }
   39|      2|        _ => None,
   40|       |    }
   41|     12|}
   42|       |
   43|      3|fn draw_circle(img: &mut egui::ColorImage, size: usize, color: C) {
   44|      3|    let cx = (size as i32) / 2;
   45|      3|    let cy = cx;
   46|      3|    let r = (size as i32) / 2 - 2;
   47|     72|    for y in 0..size as i32 {
                              ^3
   48|  1.72k|        for x in 0..size as i32 {
                                  ^72
   49|  1.72k|            let dx = x - cx;
   50|  1.72k|            let dy = y - cy;
   51|  1.72k|            if dx * dx + dy * dy <= r * r {
  ------------------
  |  Branch (51:16): [True: 951, False: 777]
  ------------------
   52|    951|                img[(x as usize, y as usize)] = color;
   53|    951|            }
                          ^777
   54|       |        }
   55|       |    }
   56|      3|}
   57|       |
   58|      1|fn draw_check(img: &mut egui::ColorImage, size: usize, color: C) {
   59|      1|    let s = size as i32;
   60|     40|    let mut plot = |x: i32, y: i32| {
                      ^1
   61|     40|        img[(x as usize, y as usize)] = color;
   62|     40|    };
   63|       |    // simple check mark
   64|      8|    for i in 0..s / 3 {
                              ^1
   65|      8|        plot(s / 3 - i, s * 2 / 3 + i);
   66|      8|        plot(s / 3 - i + 1, s * 2 / 3 + i);
   67|      8|    }
   68|     12|    for i in 0..s / 2 {
                              ^1
   69|     12|        plot(s / 3 + i, s * 2 / 3 - i);
   70|     12|        plot(s / 3 + i + 1, s * 2 / 3 - i);
   71|     12|    }
   72|      1|}
   73|       |
   74|      1|fn confetti(img: &mut egui::ColorImage, size: usize) {
   75|      1|    let dots = [
   76|      1|        C::from_rgb(255, 80, 80),
   77|      1|        C::from_rgb(80, 180, 255),
   78|      1|        C::from_rgb(120, 220, 120),
   79|      1|        C::from_rgb(220, 120, 220),
   80|      1|    ];
   81|      1|    let s = size as i32;
   82|      4|    for (i, col) in dots.iter().enumerate() {
                                  ^1   ^1     ^1
   83|      4|        let x = (s / 4) * ((i as i32) + 1);
   84|      4|        let y = (s / 5) * ((i as i32) + 1);
   85|      4|        if x < s {
  ------------------
  |  Branch (85:12): [True: 3, False: 1]
  ------------------
   86|      3|            img[(x as usize, y as usize)] = *col;
   87|      3|        }
                      ^1
   88|       |    }
   89|      1|}
   90|       |
   91|      1|fn rocket(img: &mut egui::ColorImage, size: usize, body: C, flame: C) {
   92|      1|    let s = size as i32;
   93|       |    // body
   94|     12|    for y in s / 4..s * 3 / 4 {
                           ^1     ^1
   95|     96|        for x in s / 3..s * 2 / 3 {
                               ^12    ^12
   96|     96|            img[(x as usize, y as usize)] = body;
   97|     96|        }
   98|       |    }
   99|       |    // nose
  100|      4|    for i in 0..s / 6 {
                              ^1
  101|     16|        for x in s / 2 - i..=s / 2 + i {
                               ^4          ^4
  102|     16|            let y = s / 4 - i;
  103|     16|            img[(x as usize, y as usize)] = body;
  104|     16|        }
  105|       |    }
  106|       |    // flame
  107|      4|    for i in 0..s / 6 {
                              ^1
  108|     16|        for x in s / 2 - i..=s / 2 + i {
                               ^4          ^4
  109|     16|            let y = s * 3 / 4 + i;
  110|     16|            img[(x as usize, y as usize)] = flame;
  111|     16|        }
  112|       |    }
  113|      1|}
  114|       |
  115|      5|fn heart(img: &mut egui::ColorImage, size: usize, color: C) {
  116|      5|    let s = size as i32;
  117|    240|    for y in 0..s {
                              ^5
  118|  13.4k|        for x in 0..s {
                                  ^240
  119|  13.4k|            let dx = x - s / 2;
  120|  13.4k|            let dy = y - s / 3;
  121|  13.4k|            let a = (dx * dx + dy * dy - s * s / 16) < 0;
  122|  13.4k|            let b = x > s / 4 && x < 3 * s / 4 && y > s / 3 && y < s * 3 / 4;
                                               ^9.84k           ^6.48k       ^4.23k
  ------------------
  |  Branch (122:21): [True: 9.84k, False: 3.60k]
  |  Branch (122:34): [True: 6.48k, False: 3.36k]
  |  Branch (122:51): [True: 4.23k, False: 2.24k]
  ------------------
  123|  13.4k|            if a || b {
                                  ^10.8k
  ------------------
  |  Branch (123:16): [True: 2.59k, False: 10.8k]
  |  Branch (123:21): [True: 1.37k, False: 9.46k]
  ------------------
  124|  3.97k|                img[(x as usize, y as usize)] = color;
  125|  9.46k|            }
  126|       |        }
  127|       |    }
  128|      5|}
  129|       |
  130|      1|fn star(img: &mut egui::ColorImage, size: usize, color: C) {
  131|      1|    let s = size as i32;
  132|     24|    for i in 0..s {
                              ^1
  133|     24|        let y = i;
  134|     24|        let x1 = s / 2;
  135|     24|        let x2 = s / 2 - i / 2;
  136|     24|        let x3 = s / 2 + i / 2;
  137|     24|        img[(x2 as usize, y as usize)] = color;
  138|     24|        img[(x1 as usize, y as usize)] = color;
  139|     24|        img[(x3 as usize, y as usize)] = color;
  140|     24|    }
  141|      1|}
  142|       |
  143|      1|fn flame(img: &mut egui::ColorImage, size: usize) {
  144|      1|    let s = size as i32;
  145|      1|    let base = C::from_rgb(255, 140, 0);
  146|      1|    let tip = C::from_rgb(255, 220, 120);
  147|     24|    for y in 0..s {
                              ^1
  148|    576|        for x in 0..s {
                                  ^24
  149|    576|            let dx = (x - s / 2) as f32 / (s as f32 / 3.5);
  150|    576|            let dy = (y - s) as f32 / (s as f32 / 1.5);
  151|    576|            let v = (dx * dx + dy * dy).sqrt();
  152|    576|            if v < 1.0 {
  ------------------
  |  Branch (152:16): [True: 161, False: 415]
  ------------------
  153|    161|                let t = 1.0 - v;
  154|    161|                img[(x as usize, y as usize)] = C::from_rgb(
  155|    161|                    (base.r() as f32 * t + tip.r() as f32 * (1.0 - t)) as u8,
  156|    161|                    (base.g() as f32 * t + tip.g() as f32 * (1.0 - t)) as u8,
  157|    161|                    (base.b() as f32 * t + tip.b() as f32 * (1.0 - t)) as u8,
  158|    161|                );
  159|    415|            }
  160|       |        }
  161|       |    }
  162|      1|}
  163|       |
  164|       |#[cfg(test)]
  165|       |mod tests {
  166|       |    use super::*;
  167|       |
  168|      7|    fn has_non_transparent_pixel(img: &egui::ColorImage) -> bool {
  169|    587|        img.pixels.iter().any(|p| p.a() != 0)
                      ^7                ^7
  170|      7|    }
  171|       |
  172|       |    #[test]
  173|      1|    fn test_make_image_known_emojis_produce_pixels() {
  174|      1|        let emojis = [
  175|      1|            "\u{2705}",
  176|      1|            "\u{1f389}",
  177|      1|            "\u{1f680}",
  178|      1|            "\u{2764}",
  179|      1|            "\u{1f496}",
  180|      1|            "\u{2b50}",
  181|      1|            "\u{1f525}",
  182|      1|        ];
  183|       |
  184|      8|        for emoji in emojis {
                          ^7
  185|      7|            let img = make_image(emoji, 24).expect("expected fallback image");
  186|      7|            assert!(has_non_transparent_pixel(&img));
  187|       |        }
  188|      1|    }
  189|       |
  190|       |    #[test]
  191|      1|    fn test_make_image_unknown_returns_none() {
  192|      1|        assert!(make_image("\u{1f47d}", 24).is_none());
  193|      1|    }
  194|       |}

C:\language\mdmdview\src\emoji_catalog.rs:
    1|       |use std::collections::HashMap;
    2|       |
    3|       |// Return embedded emoji sprites keyed by real Unicode emoji characters.
    4|  2.30k|pub fn image_bytes_for(emoji: &str) -> Option<&'static [u8]> {
    5|  2.30k|    match emoji {
    6|  2.30k|        "\u{1f389}" => Some(include_bytes!(concat!(
    7|      2|            env!("CARGO_MANIFEST_DIR"),
    8|      2|            "/assets/emoji/1f389.png"
    9|      2|        ))),
   10|  2.30k|        "\u{2705}" => Some(include_bytes!(concat!(
   11|      2|            env!("CARGO_MANIFEST_DIR"),
   12|      2|            "/assets/emoji/2705.png"
   13|      2|        ))),
   14|  2.30k|        "\u{1f680}" => Some(include_bytes!(concat!(
   15|      4|            env!("CARGO_MANIFEST_DIR"),
   16|      4|            "/assets/emoji/1f680.png"
   17|      4|        ))),
   18|  2.29k|        "\u{1f642}" => Some(include_bytes!(concat!(
   19|      1|            env!("CARGO_MANIFEST_DIR"),
   20|      1|            "/assets/emoji/1f642.png"
   21|      1|        ))),
   22|  2.29k|        "\u{1f600}" => Some(include_bytes!(concat!(
   23|      8|            env!("CARGO_MANIFEST_DIR"),
   24|      8|            "/assets/emoji/1f600.png"
   25|      8|        ))),
   26|  2.29k|        "\u{1f609}" => Some(include_bytes!(concat!(
   27|      1|            env!("CARGO_MANIFEST_DIR"),
   28|      1|            "/assets/emoji/1f609.png"
   29|      1|        ))),
   30|  2.28k|        "\u{2b50}" => Some(include_bytes!(concat!(
   31|      1|            env!("CARGO_MANIFEST_DIR"),
   32|      1|            "/assets/emoji/2b50.png"
   33|      1|        ))),
   34|  2.28k|        "\u{1f525}" => Some(include_bytes!(concat!(
   35|      1|            env!("CARGO_MANIFEST_DIR"),
   36|      1|            "/assets/emoji/1f525.png"
   37|      1|        ))),
   38|  2.28k|        "\u{1f44d}" => Some(include_bytes!(concat!(
   39|      1|            env!("CARGO_MANIFEST_DIR"),
   40|      1|            "/assets/emoji/1f44d.png"
   41|      1|        ))),
   42|  2.28k|        "\u{1f44e}" => Some(include_bytes!(concat!(
   43|      1|            env!("CARGO_MANIFEST_DIR"),
   44|      1|            "/assets/emoji/1f44e.png"
   45|      1|        ))),
   46|  2.28k|        "\u{1f4a1}" => Some(include_bytes!(concat!(
   47|      1|            env!("CARGO_MANIFEST_DIR"),
   48|      1|            "/assets/emoji/1f4a1.png"
   49|      1|        ))),
   50|  2.28k|        "\u{2753}" => Some(include_bytes!(concat!(
   51|      1|            env!("CARGO_MANIFEST_DIR"),
   52|      1|            "/assets/emoji/2753.png"
   53|      1|        ))),
   54|  2.28k|        "\u{2757}" => Some(include_bytes!(concat!(
   55|      1|            env!("CARGO_MANIFEST_DIR"),
   56|      1|            "/assets/emoji/2757.png"
   57|      1|        ))),
   58|  2.28k|        "\u{1f4dd}" => Some(include_bytes!(concat!(
   59|      1|            env!("CARGO_MANIFEST_DIR"),
   60|      1|            "/assets/emoji/1f4dd.png"
   61|      1|        ))),
   62|  2.28k|        "\u{1f9e0}" => Some(include_bytes!(concat!(
   63|      1|            env!("CARGO_MANIFEST_DIR"),
   64|      1|            "/assets/emoji/1f9e0.png"
   65|      1|        ))),
   66|  2.28k|        "\u{1f9ea}" => Some(include_bytes!(concat!(
   67|      1|            env!("CARGO_MANIFEST_DIR"),
   68|      1|            "/assets/emoji/1f9ea.png"
   69|      1|        ))),
   70|  2.27k|        "\u{1f4e6}" => Some(include_bytes!(concat!(
   71|      1|            env!("CARGO_MANIFEST_DIR"),
   72|      1|            "/assets/emoji/1f4e6.png"
   73|      1|        ))),
   74|  2.27k|        "\u{1f527}" => Some(include_bytes!(concat!(
   75|      1|            env!("CARGO_MANIFEST_DIR"),
   76|      1|            "/assets/emoji/1f527.png"
   77|      1|        ))),
   78|  2.27k|        _ => None,
   79|       |    }
   80|  2.30k|}
   81|       |
   82|     20|pub fn shortcode_map() -> &'static HashMap<&'static str, &'static str> {
   83|       |    use std::sync::OnceLock;
   84|       |    static MAP: OnceLock<HashMap<&'static str, &'static str>> = OnceLock::new();
   85|     20|    MAP.get_or_init(|| {
                                     ^1
   86|      1|        HashMap::from([
   87|      1|            (":tada:", "\u{1f389}"),
   88|      1|            (":white_check_mark:", "\u{2705}"),
   89|      1|            (":check_mark:", "\u{2705}"),
   90|      1|            (":rocket:", "\u{1f680}"),
   91|      1|            (":slightly_smiling_face:", "\u{1f642}"),
   92|      1|            (":grinning:", "\u{1f600}"),
   93|      1|            (":wink:", "\u{1f609}"),
   94|      1|            (":star:", "\u{2b50}"),
   95|      1|            (":fire:", "\u{1f525}"),
   96|      1|            (":thumbsup:", "\u{1f44d}"),
   97|      1|            (":thumbsdown:", "\u{1f44e}"),
   98|      1|            (":bulb:", "\u{1f4a1}"),
   99|      1|            (":question:", "\u{2753}"),
  100|      1|            (":exclamation:", "\u{2757}"),
  101|      1|            (":memo:", "\u{1f4dd}"),
  102|      1|            (":brain:", "\u{1f9e0}"),
  103|      1|            (":test_tube:", "\u{1f9ea}"),
  104|      1|            (":package:", "\u{1f4e6}"),
  105|      1|            (":wrench:", "\u{1f527}"),
  106|      1|        ])
  107|      1|    })
  108|     20|}
  109|       |
  110|       |#[cfg(test)]
  111|       |mod tests {
  112|       |    use super::*;
  113|       |
  114|       |    #[test]
  115|      1|    fn test_image_bytes_for_known_emojis() {
  116|      1|        let emojis = [
  117|      1|            "\u{1f389}",
  118|      1|            "\u{2705}",
  119|      1|            "\u{1f680}",
  120|      1|            "\u{1f642}",
  121|      1|            "\u{1f600}",
  122|      1|            "\u{1f609}",
  123|      1|            "\u{2b50}",
  124|      1|            "\u{1f525}",
  125|      1|            "\u{1f44d}",
  126|      1|            "\u{1f44e}",
  127|      1|            "\u{1f4a1}",
  128|      1|            "\u{2753}",
  129|      1|            "\u{2757}",
  130|      1|            "\u{1f4dd}",
  131|      1|            "\u{1f9e0}",
  132|      1|            "\u{1f9ea}",
  133|      1|            "\u{1f4e6}",
  134|      1|            "\u{1f527}",
  135|      1|        ];
  136|       |
  137|     19|        for emoji in emojis {
                          ^18
  138|     18|            let bytes = image_bytes_for(emoji).expect("expected embedded emoji bytes");
  139|     18|            assert!(!bytes.is_empty());
  140|       |        }
  141|      1|    }
  142|       |
  143|       |    #[test]
  144|      1|    fn test_image_bytes_for_unknown_emoji() {
  145|      1|        assert!(image_bytes_for("\u{1f47d}").is_none());
  146|      1|    }
  147|       |
  148|       |    #[test]
  149|      1|    fn test_shortcode_map_contains_expected_entries() {
  150|      1|        let map = shortcode_map();
  151|      1|        assert_eq!(map.get(":tada:"), Some(&"\u{1f389}"));
  152|      1|        assert_eq!(map.get(":white_check_mark:"), Some(&"\u{2705}"));
  153|      1|        assert_eq!(map.get(":rocket:"), Some(&"\u{1f680}"));
  154|      1|        assert_eq!(map.get(":fire:"), Some(&"\u{1f525}"));
  155|      1|        assert_eq!(map.get(":wrench:"), Some(&"\u{1f527}"));
  156|      1|        assert!(map.get(":does_not_exist:").is_none());
  157|      1|    }
  158|       |}

C:\language\mdmdview\src\image_decode.rs:
    1|       |use egui::ColorImage;
    2|       |#[cfg(test)]
    3|       |use std::cell::RefCell;
    4|       |use std::io::Cursor;
    5|       |
    6|       |#[cfg(test)]
    7|       |thread_local! {
    8|       |    static FORCED_ZERO_SVG_DIMENSIONS: RefCell<bool> = const { RefCell::new(false) };
    9|       |}
   10|       |
   11|       |#[cfg(test)]
   12|      6|fn take_forced_zero_svg_dimensions() -> bool {
   13|      6|    FORCED_ZERO_SVG_DIMENSIONS.with(|flag| flag.replace(false))
   14|      6|}
   15|       |
   16|       |const MAX_IMAGE_SIDE: u32 = 4096;
   17|       |const MAX_IMAGE_PIXELS: u64 = MAX_IMAGE_SIDE as u64 * MAX_IMAGE_SIDE as u64;
   18|       |const MAX_IMAGE_BYTES: usize = 64 * 1024 * 1024;
   19|       |
   20|       |#[cfg(test)]
   21|      1|pub(crate) fn svg_bytes_to_color_image(bytes: &[u8]) -> Option<(ColorImage, u32, u32)> {
   22|      1|    svg_bytes_to_color_image_with_bg(bytes, None)
   23|      1|}
   24|       |
   25|     14|fn raster_dimensions(bytes: &[u8]) -> Option<(u32, u32)> {
   26|     14|    let reader = image::io::Reader::new(Cursor::new(bytes))
   27|     14|        .with_guessed_format()
   28|     14|        .ok()?;
                           ^0
   29|     14|    reader.into_dimensions().ok()
   30|     14|}
   31|       |
   32|     26|fn raster_exceeds_limits(w: u32, h: u32) -> bool {
   33|     26|    if w == 0 || h == 0 {
                               ^25
  ------------------
  |  Branch (33:8): [True: 1, False: 25]
  |  Branch (33:18): [True: 1, False: 24]
  ------------------
   34|      2|        return true;
   35|     24|    }
   36|     24|    if w > MAX_IMAGE_SIDE || h > MAX_IMAGE_SIDE {
                                           ^22
  ------------------
  |  Branch (36:8): [True: 2, False: 22]
  |  Branch (36:30): [True: 1, False: 21]
  ------------------
   37|      3|        return true;
   38|     21|    }
   39|     21|    let pixels = (w as u64).saturating_mul(h as u64);
   40|     21|    pixels > MAX_IMAGE_PIXELS
   41|     26|}
   42|       |
   43|     15|pub(crate) fn raster_bytes_to_color_image_with_bg(
   44|     15|    bytes: &[u8],
   45|     15|    bg: Option<[u8; 4]>,
   46|     15|) -> Option<(ColorImage, u32, u32)> {
   47|     15|    if bytes.len() > MAX_IMAGE_BYTES {
  ------------------
  |  Branch (47:8): [True: 1, False: 14]
  ------------------
   48|      1|        return None;
   49|     14|    }
   50|     14|    if let Some((w, h)) = raster_dimensions(bytes) {
                               ^11^11
  ------------------
  |  Branch (50:12): [True: 11, False: 3]
  ------------------
   51|     11|        if raster_exceeds_limits(w, h) {
  ------------------
  |  Branch (51:12): [True: 1, False: 10]
  ------------------
   52|      1|            return None;
   53|     10|        }
   54|      3|    }
   55|     13|    let img = image::load_from_memory(bytes).ok()?;
                      ^10                                      ^3
   56|     10|    let rgba = img.to_rgba8();
   57|     10|    let (w, h) = rgba.dimensions();
   58|     10|    if raster_exceeds_limits(w, h) {
  ------------------
  |  Branch (58:8): [True: 0, False: 10]
  ------------------
   59|      0|        return None;
   60|     10|    }
   61|     10|    let mut ci = ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &rgba);
   62|     10|    if let Some([br, bgc, bb, ba]) = bg {
                               ^1  ^1   ^1  ^1
  ------------------
  |  Branch (62:12): [True: 1, False: 9]
  ------------------
   63|      1|        for p in ci.pixels.iter_mut() {
   64|      1|            let a = p[3] as f32 / 255.0;
   65|      1|            let inv = 1.0 - a;
   66|      1|            p[0] = (a * p[0] as f32 + inv * br as f32) as u8;
   67|      1|            p[1] = (a * p[1] as f32 + inv * bgc as f32) as u8;
   68|      1|            p[2] = (a * p[2] as f32 + inv * bb as f32) as u8;
   69|      1|            p[3] = ba;
   70|      1|        }
   71|      9|    }
   72|     10|    Some((ci, w, h))
   73|     15|}
   74|       |
   75|      7|pub(crate) fn svg_bytes_to_color_image_with_bg(
   76|      7|    bytes: &[u8],
   77|      7|    bg: Option<[u8; 4]>,
   78|      7|) -> Option<(ColorImage, u32, u32)> {
   79|      7|    let mut opt = usvg::Options::default();
   80|      7|    let mut db = usvg::fontdb::Database::new();
   81|      7|    db.load_system_fonts();
   82|      7|    opt.fontdb = std::sync::Arc::new(db);
   83|      7|    let tree = usvg::Tree::from_data(bytes, &opt).ok()?;
                      ^6                                            ^1
   84|      6|    let sz = tree.size();
   85|      6|    let pix = sz.to_int_size();
   86|      6|    let (mut w, mut h) = (pix.width(), pix.height());
   87|       |    #[cfg(test)]
   88|      6|    if take_forced_zero_svg_dimensions() {
  ------------------
  |  Branch (88:8): [True: 1, False: 5]
  ------------------
   89|      1|        w = 0;
   90|      1|        h = 0;
   91|      5|    }
   92|      6|    if w == 0 || h == 0 {
                               ^5
  ------------------
  |  Branch (92:8): [True: 1, False: 5]
  |  Branch (92:18): [True: 0, False: 5]
  ------------------
   93|      1|        w = 256;
   94|      1|        h = 256;
   95|      5|    }
   96|      6|    let max_side: u32 = MAX_IMAGE_SIDE;
   97|      6|    if w > max_side || h > max_side {
                                     ^4
  ------------------
  |  Branch (97:8): [True: 2, False: 4]
  |  Branch (97:24): [True: 0, False: 4]
  ------------------
   98|      2|        let scale = (max_side as f32 / w as f32).min(max_side as f32 / h as f32);
   99|      2|        w = (w as f32 * scale) as u32;
  100|      2|        h = (h as f32 * scale) as u32;
  101|      4|    }
  102|      6|    let mut pixmap = tiny_skia::Pixmap::new(w, h)?;
                                                               ^0
  103|      6|    if let Some([r, g, b, a]) = bg {
                               ^1 ^1 ^1 ^1
  ------------------
  |  Branch (103:12): [True: 1, False: 5]
  ------------------
  104|      1|        let color = tiny_skia::Color::from_rgba8(r, g, b, a);
  105|      1|        pixmap.fill(color);
  106|      5|    }
  107|      6|    let mut pmut = pixmap.as_mut();
  108|      6|    resvg::render(&tree, tiny_skia::Transform::identity(), &mut pmut);
  109|      6|    let data = pixmap.data();
  110|      6|    let img = ColorImage::from_rgba_unmultiplied([w as usize, h as usize], data);
  111|      6|    Some((img, w, h))
  112|      7|}
  113|       |
  114|     13|pub(crate) fn bytes_to_color_image_guess(
  115|     13|    bytes: &[u8],
  116|     13|    bg: Option<[u8; 4]>,
  117|     13|) -> Option<(ColorImage, u32, u32)> {
  118|     13|    if let Some(img) = raster_bytes_to_color_image_with_bg(bytes, bg) {
                              ^10
  ------------------
  |  Branch (118:12): [True: 10, False: 3]
  ------------------
  119|     10|        return Some(img);
  120|      3|    }
  121|      3|    svg_bytes_to_color_image_with_bg(bytes, bg)
  122|     13|}
  123|       |
  124|       |#[cfg(test)]
  125|       |mod tests {
  126|       |    use super::*;
  127|       |    use image::{ImageOutputFormat, RgbaImage};
  128|       |    use std::io::Cursor;
  129|       |
  130|       |    struct ForcedZeroSvgDimensions;
  131|       |
  132|       |    impl ForcedZeroSvgDimensions {
  133|      1|        fn new() -> Self {
  134|      1|            FORCED_ZERO_SVG_DIMENSIONS.with(|flag| flag.replace(true));
  135|      1|            Self
  136|      1|        }
  137|       |    }
  138|       |
  139|      2|    fn encode_png(rgba: &RgbaImage) -> Vec<u8> {
  140|      2|        let mut bytes = Vec::new();
  141|      2|        let mut cursor = Cursor::new(&mut bytes);
  142|      2|        image::DynamicImage::ImageRgba8(rgba.clone())
  143|      2|            .write_to(&mut cursor, ImageOutputFormat::Png)
  144|      2|            .expect("encode png");
  145|      2|        bytes
  146|      2|    }
  147|       |
  148|       |    #[test]
  149|      1|    fn test_bytes_to_color_image_guess_png_blends_background() {
  150|      1|        let mut rgba = RgbaImage::new(1, 1);
  151|      1|        rgba.put_pixel(0, 0, image::Rgba([255, 0, 0, 255]));
  152|      1|        let bytes = encode_png(&rgba);
  153|       |
  154|      1|        let bg = [0, 0, 255, 200];
  155|      1|        let (img, w, h) = bytes_to_color_image_guess(&bytes, Some(bg)).expect("png decode");
  156|      1|        assert_eq!((w, h), (1, 1));
  157|       |
  158|      1|        let px = img.pixels[0];
  159|      1|        assert_eq!(px[0], 255);
  160|      1|        assert_eq!(px[1], 0);
  161|      1|        assert_eq!(px[2], 0);
  162|      1|        assert_eq!(px[3], bg[3]);
  163|      1|    }
  164|       |
  165|       |    #[test]
  166|      1|    fn test_svg_bytes_to_color_image_scales_and_fills_bg() {
  167|      1|        let svg = r#"<svg width="5000" height="3000" xmlns="http://www.w3.org/2000/svg">
  168|      1|<rect width="5000" height="3000" fill="red"/>
  169|      1|</svg>"#;
  170|      1|        let bg = Some([1, 2, 3, 255]);
  171|      1|        let (_img, w, h) =
  172|      1|            svg_bytes_to_color_image_with_bg(svg.as_bytes(), bg).expect("svg decode");
  173|      1|        assert!(w > 0);
  174|      1|        assert!(h > 0);
  175|      1|        assert!(w <= 4096);
  176|      1|        assert!(h <= 4096);
  177|      1|    }
  178|       |
  179|       |    #[test]
  180|      1|    fn test_svg_bytes_to_color_image_invalid_returns_none() {
  181|      1|        assert!(svg_bytes_to_color_image(b"not svg").is_none());
  182|      1|    }
  183|       |
  184|       |    #[test]
  185|      1|    fn test_raster_bytes_rejects_large_dimensions() {
  186|      1|        let mut rgba = RgbaImage::new(5000, 1);
  187|      1|        rgba.put_pixel(0, 0, image::Rgba([0, 0, 0, 255]));
  188|      1|        let bytes = encode_png(&rgba);
  189|      1|        assert!(raster_bytes_to_color_image_with_bg(&bytes, None).is_none());
  190|      1|    }
  191|       |
  192|       |    #[test]
  193|      1|    fn test_bytes_to_color_image_guess_svg_fallback() {
  194|      1|        let svg = r#"<svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">
  195|      1|<circle cx="32" cy="32" r="20" fill="blue"/>
  196|      1|</svg>"#;
  197|      1|        let (_img, w, h) = bytes_to_color_image_guess(svg.as_bytes(), None).expect("svg fallback");
  198|      1|        assert_eq!((w, h), (64, 64));
  199|      1|    }
  200|       |
  201|       |    #[test]
  202|      1|    fn test_raster_exceeds_limits_zero_dimensions() {
  203|      1|        assert!(raster_exceeds_limits(0, 10));
  204|      1|        assert!(raster_exceeds_limits(10, 0));
  205|      1|    }
  206|       |
  207|       |    #[test]
  208|      1|    fn test_raster_exceeds_limits_large_sides() {
  209|      1|        assert!(raster_exceeds_limits(MAX_IMAGE_SIDE + 1, 1));
  210|      1|        assert!(raster_exceeds_limits(1, MAX_IMAGE_SIDE + 1));
  211|      1|    }
  212|       |
  213|       |    #[test]
  214|      1|    fn test_raster_exceeds_limits_within_bounds() {
  215|      1|        assert!(!raster_exceeds_limits(MAX_IMAGE_SIDE, MAX_IMAGE_SIDE));
  216|      1|    }
  217|       |
  218|       |    #[test]
  219|      1|    fn test_raster_bytes_rejects_large_buffer() {
  220|      1|        let bytes = vec![0u8; MAX_IMAGE_BYTES + 1];
  221|      1|        assert!(raster_bytes_to_color_image_with_bg(&bytes, None).is_none());
  222|      1|    }
  223|       |
  224|       |    #[test]
  225|      1|    fn test_svg_zero_dimensions_defaults_to_256() {
  226|      1|        let _forced = ForcedZeroSvgDimensions::new();
  227|      1|        let svg = r#"<svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">
  228|      1|<rect width="64" height="64" fill="red"/>
  229|      1|</svg>"#;
  230|      1|        let (_img, w, h) =
  231|      1|            svg_bytes_to_color_image_with_bg(svg.as_bytes(), None).expect("svg decode");
  232|      1|        assert_eq!((w, h), (256, 256));
  233|      1|    }
  234|       |
  235|       |    #[test]
  236|      1|    fn test_svg_bytes_to_color_image_scales_large_dimensions() {
  237|      1|        let svg = r#"<svg width="8192" height="8192" xmlns="http://www.w3.org/2000/svg">
  238|      1|<rect width="8192" height="8192" fill="red"/>
  239|      1|</svg>"#;
  240|      1|        let (_img, w, h) =
  241|      1|            svg_bytes_to_color_image_with_bg(svg.as_bytes(), None).expect("svg decode");
  242|      1|        assert!(w <= 4096);
  243|      1|        assert!(h <= 4096);
  244|      1|        assert!(w > 0);
  245|      1|        assert!(h > 0);
  246|      1|    }
  247|       |}

C:\language\mdmdview\src\main.rs:
    1|       |#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")] // Hide console in release mode
    2|       |
    3|       |#[cfg(not(test))]
    4|       |use mdmdview::app::{ScreenshotConfig, ScreenshotTheme};
    5|       |/// Main entry point for the MarkdownView application
    6|       |///
    7|       |/// A simple, standalone markdown viewer for Windows built with Rust and egui.
    8|       |/// This application provides a clean interface for viewing markdown files with
    9|       |/// syntax highlighting, embedded samples, and essential viewing features.
   10|       |#[cfg(not(test))]
   11|       |use mdmdview::{load_window_state, sanitize_window_state, MarkdownViewerApp, APP_TITLE_PREFIX};
   12|       |#[cfg(not(test))]
   13|       |use std::path::Path;
   14|       |use std::path::PathBuf;
   15|       |
   16|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
   17|       |enum ThemeChoice {
   18|       |    Light,
   19|       |    Dark,
   20|       |}
   21|       |
   22|       |#[derive(Default)]
   23|       |struct CliOptions {
   24|       |    initial_file: Option<PathBuf>,
   25|       |    screenshot: bool,
   26|       |    screenshot_output: Option<PathBuf>,
   27|       |    width: Option<f32>,
   28|       |    height: Option<f32>,
   29|       |    theme: Option<ThemeChoice>,
   30|       |    zoom: Option<f32>,
   31|       |    content_only: bool,
   32|       |    scroll: Option<f32>,
   33|       |    wait_ms: Option<u64>,
   34|       |    settle_frames: Option<u32>,
   35|       |    test_fonts: Option<PathBuf>,
   36|       |}
   37|       |
   38|       |#[cfg(not(test))]
   39|       |fn parse_cli_args() -> Result<CliOptions, String> {
   40|       |    parse_cli_from(std::env::args().skip(1))
   41|       |}
   42|       |
   43|     10|fn parse_cli_from<I>(args: I) -> Result<CliOptions, String>
   44|     10|where
   45|     10|    I: IntoIterator<Item = String>,
   46|       |{
   47|     10|    let mut opts = CliOptions::default();
   48|     10|    let mut iter = args.into_iter();
   49|       |
   50|     30|    while let Some(arg) = iter.next() {
                                 ^24
  ------------------
  |  Branch (50:15): [True: 24, False: 6]
  ------------------
   51|     24|        match arg.as_str() {
   52|     24|            "--screenshot" => {
   53|      4|                opts.screenshot = true;
   54|      4|                let value = next_value(&mut iter, "--screenshot")?;
                                  ^3                                           ^1
   55|      3|                opts.initial_file = Some(PathBuf::from(value));
   56|       |            }
   57|     20|            "--output" => {
   58|      2|                let value = next_value(&mut iter, "--output")?;
                                                                           ^0
   59|      2|                opts.screenshot_output = Some(PathBuf::from(value));
   60|       |            }
   61|     18|            "--width" => {
   62|      2|                let value = next_value(&mut iter, "--width")?;
                                                                          ^0
   63|      2|                opts.width = Some(parse_f32("--width", &value)?);
                                                                            ^1
   64|       |            }
   65|     16|            "--height" => {
   66|      2|                let value = next_value(&mut iter, "--height")?;
                                  ^1                                       ^1
   67|      1|                opts.height = Some(parse_f32("--height", &value)?);
                                                                              ^0
   68|       |            }
   69|     14|            "--theme" => {
   70|      3|                let value = next_value(&mut iter, "--theme")?;
                                                                          ^0
   71|      3|                opts.theme = Some(parse_theme(&value)?);
                                                                   ^1
   72|       |            }
   73|     11|            "--zoom" => {
   74|      1|                let value = next_value(&mut iter, "--zoom")?;
                                                                         ^0
   75|      1|                opts.zoom = Some(parse_f32("--zoom", &value)?);
                                                                          ^0
   76|       |            }
   77|     10|            "--content-only" => opts.content_only = true,
                                              ^1
   78|      9|            "--scroll" => {
   79|      2|                let value = next_value(&mut iter, "--scroll")?;
                                                                           ^0
   80|      2|                let ratio = parse_f32("--scroll", &value)?.clamp(0.0, 1.0);
                                                                       ^0
   81|      2|                opts.scroll = Some(ratio);
   82|       |            }
   83|      7|            "--wait-ms" => {
   84|      1|                let value = next_value(&mut iter, "--wait-ms")?;
                                                                            ^0
   85|      1|                opts.wait_ms = Some(parse_u64("--wait-ms", &value)?);
                                                                                ^0
   86|       |            }
   87|      6|            "--settle-frames" => {
   88|      1|                let value = next_value(&mut iter, "--settle-frames")?;
                                                                                  ^0
   89|      1|                opts.settle_frames = Some(parse_u32("--settle-frames", &value)?);
                                                                                            ^0
   90|       |            }
   91|      5|            "--test-fonts" => {
   92|      1|                let value = next_value(&mut iter, "--test-fonts")?;
                                                                               ^0
   93|      1|                opts.test_fonts = Some(PathBuf::from(value));
   94|       |            }
   95|      4|            _ if opts.initial_file.is_none() => opts.initial_file = Some(PathBuf::from(arg)),
                                                         ^3   ^3
  ------------------
  |  Branch (95:18): [True: 3, False: 1]
  ------------------
   96|      1|            _ => {}
   97|       |        }
   98|       |    }
   99|       |
  100|      6|    if opts.screenshot {
  ------------------
  |  Branch (100:8): [True: 3, False: 3]
  ------------------
  101|      3|        if opts.screenshot_output.is_none() {
  ------------------
  |  Branch (101:12): [True: 1, False: 2]
  ------------------
  102|      1|            return Err("Missing --output for screenshot mode".to_string());
  103|      2|        }
  104|      3|    }
  105|       |
  106|      5|    Ok(opts)
  107|     10|}
  108|       |
  109|     19|fn next_value<I>(iter: &mut I, flag: &str) -> Result<String, String>
  110|     19|where
  111|     19|    I: Iterator<Item = String>,
  112|       |{
  113|     19|    iter.next()
  114|     19|        .ok_or_else(|| format!("{flag} requires a value"))
                                     ^2      ^2
  115|     19|}
  116|       |
  117|      3|fn parse_theme(value: &str) -> Result<ThemeChoice, String> {
  118|      3|    match value.trim().to_ascii_lowercase().as_str() {
  119|      3|        "light" => Ok(ThemeChoice::Light),
                                 ^1
  120|      2|        "dark" => Ok(ThemeChoice::Dark),
                                ^1
  121|      1|        _ => Err(format!("Unsupported theme: {value}")),
  122|       |    }
  123|      3|}
  124|       |
  125|      4|fn parse_hex_color32(value: &str) -> Option<egui::Color32> {
  126|      4|    let hex = value.trim().trim_start_matches('#');
  127|      4|    if hex.len() != 6 {
  ------------------
  |  Branch (127:8): [True: 2, False: 2]
  ------------------
  128|      2|        return None;
  129|      2|    }
  130|      2|    let r = u8::from_str_radix(&hex[0..2], 16).ok()?;
                                                                 ^0
  131|      2|    let g = u8::from_str_radix(&hex[2..4], 16).ok()?;
                                                                 ^0
  132|      2|    let b = u8::from_str_radix(&hex[4..6], 16).ok()?;
                                                                 ^0
  133|      2|    Some(egui::Color32::from_rgb(r, g, b))
  134|      4|}
  135|       |
  136|      3|fn screenshot_background_color() -> egui::Color32 {
  137|      3|    if let Ok(hex) = std::env::var("MDMDVIEW_MERMAID_MAIN_BKG") {
                            ^2
  ------------------
  |  Branch (137:12): [True: 2, False: 1]
  ------------------
  138|      2|        if let Some(color) = parse_hex_color32(&hex) {
                                  ^1
  ------------------
  |  Branch (138:16): [True: 1, False: 1]
  ------------------
  139|      1|            return color;
  140|      1|        }
  141|      1|    }
  142|      2|    egui::Color32::from_rgb(255, 248, 219)
  143|      3|}
  144|       |
  145|      6|fn parse_f32(flag: &str, value: &str) -> Result<f32, String> {
  146|      6|    value
  147|      6|        .parse::<f32>()
  148|      6|        .map_err(|_| format!("Invalid {flag} value: {value}"))
                                   ^1      ^1
  149|      6|}
  150|       |
  151|      1|fn parse_u32(flag: &str, value: &str) -> Result<u32, String> {
  152|      1|    value
  153|      1|        .parse::<u32>()
  154|      1|        .map_err(|_| format!("Invalid {flag} value: {value}"))
                                   ^0      ^0
  155|      1|}
  156|       |
  157|      1|fn parse_u64(flag: &str, value: &str) -> Result<u64, String> {
  158|      1|    value
  159|      1|        .parse::<u64>()
  160|      1|        .map_err(|_| format!("Invalid {flag} value: {value}"))
                                   ^0      ^0
  161|      1|}
  162|       |
  163|       |#[cfg(not(test))]
  164|       |fn load_fonts_from_dir(ctx: &egui::Context, dir: &Path) -> Result<(), String> {
  165|       |    let mut font_paths: Vec<PathBuf> = std::fs::read_dir(dir)
  166|       |        .map_err(|e| format!("Failed to read font dir {dir:?}: {e}"))?
  167|       |        .filter_map(|entry| entry.ok().map(|e| e.path()))
  168|       |        .filter(|path| {
  169|       |            path.extension()
  170|       |                .and_then(|ext| ext.to_str())
  171|       |                .map(|ext| matches!(ext.to_ascii_lowercase().as_str(), "ttf" | "otf"))
  172|       |                .unwrap_or(false)
  173|       |        })
  174|       |        .collect();
  175|       |
  176|       |    if font_paths.is_empty() {
  177|       |        return Err(format!("No font files found in {dir:?}"));
  178|       |    }
  179|       |
  180|       |    font_paths.sort_by(|a, b| a.to_string_lossy().cmp(&b.to_string_lossy()));
  181|       |
  182|       |    let mut fonts = egui::FontDefinitions::default();
  183|       |    let mut prop_names = Vec::new();
  184|       |    let mut mono_names = Vec::new();
  185|       |    let mut used_names = std::collections::HashSet::new();
  186|       |
  187|       |    for path in font_paths {
  188|       |        let bytes =
  189|       |            std::fs::read(&path).map_err(|e| format!("Failed to read font {path:?}: {e}"))?;
  190|       |        let name = path
  191|       |            .file_stem()
  192|       |            .and_then(|stem| stem.to_str())
  193|       |            .map(|stem| stem.to_string())
  194|       |            .unwrap_or_else(|| format!("font-{}", prop_names.len() + mono_names.len()));
  195|       |        let base = format!("test-{name}");
  196|       |        let mut name = base.clone();
  197|       |        let mut counter = 1usize;
  198|       |        while used_names.contains(&name) {
  199|       |            name = format!("{base}-{counter}");
  200|       |            counter += 1;
  201|       |        }
  202|       |        used_names.insert(name.clone());
  203|       |
  204|       |        fonts
  205|       |            .font_data
  206|       |            .insert(name.clone(), egui::FontData::from_owned(bytes));
  207|       |
  208|       |        let lower = name.to_ascii_lowercase();
  209|       |        if lower.contains("mono") || lower.contains("code") {
  210|       |            mono_names.push(name);
  211|       |        } else {
  212|       |            prop_names.push(name);
  213|       |        }
  214|       |    }
  215|       |
  216|       |    if prop_names.is_empty() {
  217|       |        prop_names = mono_names.clone();
  218|       |    }
  219|       |    if mono_names.is_empty() {
  220|       |        mono_names = prop_names.clone();
  221|       |    }
  222|       |
  223|       |    if let Some(family) = fonts.families.get_mut(&egui::FontFamily::Proportional) {
  224|       |        for name in prop_names.iter().rev() {
  225|       |            family.insert(0, name.clone());
  226|       |        }
  227|       |    }
  228|       |    if let Some(family) = fonts.families.get_mut(&egui::FontFamily::Monospace) {
  229|       |        for name in mono_names.iter().rev() {
  230|       |            family.insert(0, name.clone());
  231|       |        }
  232|       |    }
  233|       |
  234|       |    ctx.set_fonts(fonts);
  235|       |    Ok(())
  236|       |}
  237|       |
  238|       |/// Application entry point
  239|       |#[cfg(not(test))]
  240|       |fn main() -> Result<(), eframe::Error> {
  241|       |    // Configure logging for debugging (only in debug builds)
  242|       |    #[cfg(debug_assertions)]
  243|       |    env_logger::init();
  244|       |
  245|       |    let cli = match parse_cli_args() {
  246|       |        Ok(opts) => opts,
  247|       |        Err(err) => {
  248|       |            eprintln!("{err}");
  249|       |            return Ok(());
  250|       |        }
  251|       |    };
  252|       |
  253|       |    let screenshot_enabled = cli.screenshot;
  254|       |    let resolved_theme = if screenshot_enabled {
  255|       |        Some(cli.theme.unwrap_or(ThemeChoice::Light))
  256|       |    } else {
  257|       |        cli.theme
  258|       |    };
  259|       |    let screenshot_zoom = cli.zoom.unwrap_or(1.0);
  260|       |
  261|       |    let default_width = if screenshot_enabled { 1280.0 } else { 1000.0 };
  262|       |    let default_height = if screenshot_enabled { 720.0 } else { 700.0 };
  263|       |    let window_width = cli.width.unwrap_or(default_width);
  264|       |    let window_height = cli.height.unwrap_or(default_height);
  265|       |
  266|       |    // Set up eframe options for the native window
  267|       |    let mut viewport = egui::ViewportBuilder::default()
  268|       |        .with_title(format!("{APP_TITLE_PREFIX} - A Simple Markdown Viewer"))
  269|       |        .with_inner_size(egui::Vec2::new(window_width, window_height))
  270|       |        .with_min_inner_size(egui::Vec2::new(
  271|       |            if screenshot_enabled { 100.0 } else { 600.0 },
  272|       |            if screenshot_enabled { 100.0 } else { 400.0 },
  273|       |        ))
  274|       |        .with_icon(create_app_icon())
  275|       |        .with_resizable(!screenshot_enabled)
  276|       |        .with_maximize_button(!screenshot_enabled)
  277|       |        .with_minimize_button(!screenshot_enabled)
  278|       |        .with_drag_and_drop(!screenshot_enabled);
  279|       |
  280|       |    // Restore previous window position/size if available
  281|       |    if !screenshot_enabled {
  282|       |        if let Some(ws) = load_window_state() {
  283|       |            if let Some(ws) = sanitize_window_state(ws) {
  284|       |                viewport = viewport
  285|       |                    .with_inner_size(egui::Vec2::new(ws.size[0], ws.size[1]))
  286|       |                    .with_position(egui::pos2(ws.pos[0], ws.pos[1]))
  287|       |                    .with_maximized(ws.maximized);
  288|       |            }
  289|       |        }
  290|       |    }
  291|       |
  292|       |    let native_options = eframe::NativeOptions {
  293|       |        viewport,
  294|       |        // Disable eframe's built-in window persistence - we handle it ourselves via
  295|       |        // load_window_state/save_window_state to avoid conflicts
  296|       |        persist_window: false,
  297|       |        ..Default::default()
  298|       |    };
  299|       |
  300|       |    let initial_file = cli.initial_file.clone();
  301|       |    let test_fonts = cli.test_fonts.clone();
  302|       |    let screenshot_config = if screenshot_enabled {
  303|       |        let theme = match resolved_theme.unwrap_or(ThemeChoice::Light) {
  304|       |            ThemeChoice::Light => ScreenshotTheme::Light,
  305|       |            ThemeChoice::Dark => ScreenshotTheme::Dark,
  306|       |        };
  307|       |        Some(ScreenshotConfig {
  308|       |            output_path: cli
  309|       |                .screenshot_output
  310|       |                .clone()
  311|       |                .expect("screenshot output required"),
  312|       |            viewport_width: window_width,
  313|       |            viewport_height: window_height,
  314|       |            content_only: cli.content_only,
  315|       |            scroll_ratio: cli.scroll,
  316|       |            wait_ms: cli.wait_ms.unwrap_or(2000),
  317|       |            settle_frames: cli.settle_frames.unwrap_or(3),
  318|       |            zoom: screenshot_zoom,
  319|       |            theme,
  320|       |            font_source: test_fonts
  321|       |                .as_ref()
  322|       |                .map(|path| path.to_string_lossy().to_string()),
  323|       |        })
  324|       |    } else {
  325|       |        None
  326|       |    };
  327|       |
  328|       |    // Launch the application
  329|       |    eframe::run_native(
  330|       |        APP_TITLE_PREFIX,
  331|       |        native_options,
  332|       |        Box::new(move |cc| {
  333|       |            if let Some(theme) = resolved_theme {
  334|       |                let mut visuals = match theme {
  335|       |                    ThemeChoice::Light => egui::Visuals::light(),
  336|       |                    ThemeChoice::Dark => egui::Visuals::dark(),
  337|       |                };
  338|       |                if screenshot_enabled {
  339|       |                    let bg = screenshot_background_color();
  340|       |                    visuals.panel_fill = bg;
  341|       |                    visuals.window_fill = bg;
  342|       |                    visuals.extreme_bg_color = bg;
  343|       |                    visuals.faint_bg_color = bg;
  344|       |                }
  345|       |                cc.egui_ctx.set_visuals(visuals);
  346|       |            }
  347|       |
  348|       |            // Configure egui styling for better markdown display
  349|       |            configure_egui_style(&cc.egui_ctx);
  350|       |            if let Some(font_dir) = test_fonts.as_ref() {
  351|       |                if let Err(err) = load_fonts_from_dir(&cc.egui_ctx, font_dir) {
  352|       |                    eprintln!("{err}");
  353|       |                }
  354|       |            }
  355|       |
  356|       |            let mut app = MarkdownViewerApp::new();
  357|       |            if screenshot_zoom != 1.0 {
  358|       |                app.set_zoom_scale(screenshot_zoom);
  359|       |            }
  360|       |            if let Some(config) = screenshot_config {
  361|       |                app.set_screenshot_mode(config);
  362|       |            }
  363|       |
  364|       |            // Load initial file if provided via command line
  365|       |            if let Some(file_path) = initial_file {
  366|       |                if file_path.exists() && file_path.is_file() {
  367|       |                    if let Err(e) = app.load_file(file_path, true) {
  368|       |                        eprintln!("Failed to load file: {}", e);
  369|       |                        // Continue with default welcome screen
  370|       |                    }
  371|       |                } else {
  372|       |                    eprintln!("File not found: {}", file_path.display());
  373|       |                    // Continue with default welcome screen
  374|       |                }
  375|       |            }
  376|       |
  377|       |            Box::new(app)
  378|       |        }),
  379|       |    )
  380|       |}
  381|       |
  382|       |#[cfg(test)]
  383|      1|fn main() {}
  384|       |
  385|       |/// Create an application icon from embedded data
  386|      2|fn create_app_icon() -> egui::IconData {
  387|       |    // Create a 32x32 markdown-style document icon
  388|      2|    let size = 32;
  389|      2|    let mut rgba_data = Vec::with_capacity(size * size * 4);
  390|       |
  391|     64|    for y in 0..size {
                              ^2
  392|  2.04k|        for x in 0..size {
                                  ^64
  393|  2.04k|            let (r, g, b, a) = if x == 0 || x == size - 1 || y == 0 || y == size - 1 {
                                                          ^1.98k           ^1.92k    ^1.86k
  ------------------
  |  Branch (393:35): [True: 64, False: 1.98k]
  |  Branch (393:45): [True: 64, False: 1.92k]
  |  Branch (393:62): [True: 60, False: 1.86k]
  |  Branch (393:72): [True: 60, False: 1.80k]
  ------------------
  394|       |                // Border
  395|    248|                (60, 60, 60, 255)
  396|  1.80k|            } else if x == 1 || x == size - 2 || y == 1 || y == size - 2 {
                                              ^1.74k           ^1.68k    ^1.62k
  ------------------
  |  Branch (396:23): [True: 60, False: 1.74k]
  |  Branch (396:33): [True: 60, False: 1.68k]
  |  Branch (396:50): [True: 56, False: 1.62k]
  |  Branch (396:60): [True: 56, False: 1.56k]
  ------------------
  397|       |                // Inner border for depth
  398|    232|                (80, 80, 80, 255)
  399|  1.56k|            } else if (4..=8).contains(&y) && (4..=28).contains(&x) {
                                                             ^280    ^280     ^280
  ------------------
  |  Branch (399:23): [True: 280, False: 1.28k]
  |  Branch (399:47): [True: 250, False: 30]
  ------------------
  400|       |                // Header area (title bar)
  401|    250|                if (6..=12).contains(&x) {
  ------------------
  |  Branch (401:20): [True: 70, False: 180]
  ------------------
  402|     70|                    (100, 150, 255, 255) // Blue for # header
  403|    180|                } else if (14..=26).contains(&x) {
  ------------------
  |  Branch (403:27): [True: 130, False: 50]
  ------------------
  404|    130|                    (200, 200, 200, 255) // Light text
  405|       |                } else {
  406|     50|                    (250, 250, 250, 255) // Background
  407|       |                }
  408|  1.31k|            } else if (11..=13).contains(&y) && (4..=28).contains(&x) {
                                                               ^168    ^168     ^168
  ------------------
  |  Branch (408:23): [True: 168, False: 1.15k]
  |  Branch (408:49): [True: 150, False: 18]
  ------------------
  409|       |                // Text line 1
  410|    150|                if (6..=8).contains(&x) {
  ------------------
  |  Branch (410:20): [True: 18, False: 132]
  ------------------
  411|     18|                    (150, 150, 150, 255) // Bullet point
  412|    132|                } else if (10..=24).contains(&x) {
  ------------------
  |  Branch (412:27): [True: 90, False: 42]
  ------------------
  413|     90|                    (180, 180, 180, 255) // Text
  414|       |                } else {
  415|     42|                    (250, 250, 250, 255) // Background
  416|       |                }
  417|  1.16k|            } else if (15..=17).contains(&y) && (4..=28).contains(&x) {
                                                               ^168    ^168     ^168
  ------------------
  |  Branch (417:23): [True: 168, False: 1.00k]
  |  Branch (417:49): [True: 150, False: 18]
  ------------------
  418|       |                // Text line 2
  419|    150|                if (6..=8).contains(&x) {
  ------------------
  |  Branch (419:20): [True: 18, False: 132]
  ------------------
  420|     18|                    (150, 150, 150, 255) // Bullet point
  421|    132|                } else if (10..=22).contains(&x) {
  ------------------
  |  Branch (421:27): [True: 78, False: 54]
  ------------------
  422|     78|                    (180, 180, 180, 255) // Text
  423|       |                } else {
  424|     54|                    (250, 250, 250, 255) // Background
  425|       |                }
  426|  1.01k|            } else if (20..=22).contains(&y) && (6..=26).contains(&x) {
                                                               ^168    ^168     ^168
  ------------------
  |  Branch (426:23): [True: 168, False: 850]
  |  Branch (426:49): [True: 126, False: 42]
  ------------------
  427|       |                // Code block area
  428|    126|                if (8..=24).contains(&x) {
  ------------------
  |  Branch (428:20): [True: 102, False: 24]
  ------------------
  429|    102|                    (100, 255, 100, 255) // Green code text
  430|       |                } else {
  431|     24|                    (40, 40, 40, 255) // Dark background
  432|       |                }
  433|    892|            } else if (25..=27).contains(&y) && (4..=28).contains(&x) {
                                                               ^168    ^168     ^168
  ------------------
  |  Branch (433:23): [True: 168, False: 724]
  |  Branch (433:49): [True: 150, False: 18]
  ------------------
  434|       |                // Text line 3
  435|    150|                if (6..=20).contains(&x) {
  ------------------
  |  Branch (435:20): [True: 90, False: 60]
  ------------------
  436|     90|                    (180, 180, 180, 255) // Text
  437|       |                } else {
  438|     60|                    (250, 250, 250, 255) // Background
  439|       |                }
  440|       |            } else {
  441|       |                // Document background
  442|    742|                (250, 250, 250, 255)
  443|       |            };
  444|       |
  445|  2.04k|            rgba_data.extend_from_slice(&[r, g, b, a]);
  446|       |        }
  447|       |    }
  448|       |
  449|      2|    egui::IconData {
  450|      2|        rgba: rgba_data,
  451|      2|        width: size as u32,
  452|      2|        height: size as u32,
  453|      2|    }
  454|      2|}
  455|       |
  456|       |/// Configure egui styling for optimal markdown display
  457|      2|fn configure_egui_style(ctx: &egui::Context) {
  458|      2|    let mut style = (*ctx.style()).clone();
  459|       |
  460|       |    // Configure spacing for better readability
  461|      2|    style.spacing.item_spacing = egui::Vec2::new(8.0, 8.0);
  462|      2|    style.spacing.window_margin = egui::Margin::same(8.0);
  463|      2|    style.spacing.menu_margin = egui::Margin::same(6.0);
  464|       |
  465|       |    // Configure interaction settings
  466|      2|    style.interaction.resize_grab_radius_side = 8.0;
  467|      2|    style.interaction.resize_grab_radius_corner = 12.0;
  468|       |
  469|       |    // Configure visuals for better contrast with black background
  470|      2|    style.visuals.window_rounding = egui::Rounding::same(4.0);
  471|      2|    style.visuals.menu_rounding = egui::Rounding::same(4.0);
  472|       |
  473|       |    // Set to true black background for maximum contrast
  474|      2|    if style.visuals.dark_mode {
  ------------------
  |  Branch (474:8): [True: 1, False: 1]
  ------------------
  475|      1|        style.visuals.window_fill = egui::Color32::BLACK;
  476|      1|        style.visuals.panel_fill = egui::Color32::BLACK;
  477|      1|        style.visuals.faint_bg_color = egui::Color32::from_gray(20);
  478|      1|        style.visuals.extreme_bg_color = egui::Color32::BLACK;
  479|      1|        // The text color will be handled by egui's theme system
  480|      1|    }
  481|       |
  482|      2|    ctx.set_style(style);
  483|       |
  484|       |    // Use default fonts - egui has good built-in font support
  485|       |    // Custom fonts could be added here if needed
  486|      2|}
  487|       |
  488|       |#[cfg(test)]
  489|       |mod tests {
  490|       |    use super::*;
  491|       |    use std::sync::{Mutex, OnceLock};
  492|       |
  493|      5|    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
  494|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
  495|      5|        ENV_LOCK
  496|      5|            .get_or_init(|| Mutex::new(()))
                                          ^1         ^1
  497|      5|            .lock()
  498|      5|            .expect("env lock")
  499|      5|    }
  500|       |
  501|       |    struct EnvGuard {
  502|       |        key: &'static str,
  503|       |        original: Option<String>,
  504|       |        _lock: std::sync::MutexGuard<'static, ()>,
  505|       |    }
  506|       |
  507|       |    impl EnvGuard {
  508|      2|        fn set(key: &'static str, value: &str) -> Self {
  509|      2|            let lock = env_lock();
  510|      2|            let original = std::env::var(key).ok();
  511|      2|            std::env::set_var(key, value);
  512|      2|            Self {
  513|      2|                key,
  514|      2|                original,
  515|      2|                _lock: lock,
  516|      2|            }
  517|      2|        }
  518|       |
  519|      1|        fn unset(key: &'static str) -> Self {
  520|      1|            let lock = env_lock();
  521|      1|            let original = std::env::var(key).ok();
  522|      1|            std::env::remove_var(key);
  523|      1|            Self {
  524|      1|                key,
  525|      1|                original,
  526|      1|                _lock: lock,
  527|      1|            }
  528|      1|        }
  529|       |    }
  530|       |
  531|       |    impl Drop for EnvGuard {
  532|      4|        fn drop(&mut self) {
  533|      4|            if let Some(prev) = &self.original {
                                      ^1
  ------------------
  |  Branch (533:20): [True: 1, False: 3]
  ------------------
  534|      1|                std::env::set_var(self.key, prev);
  535|      3|            } else {
  536|      3|                std::env::remove_var(self.key);
  537|      3|            }
  538|      4|        }
  539|       |    }
  540|       |
  541|       |    #[test]
  542|      1|    fn test_app_icon_creation() {
  543|      1|        let icon = create_app_icon();
  544|      1|        assert_eq!(icon.width, 32);
  545|      1|        assert_eq!(icon.height, 32);
  546|      1|        assert_eq!(icon.rgba.len(), 32 * 32 * 4); // RGBA format
  547|      1|    }
  548|       |
  549|       |    #[test]
  550|      1|    fn test_main_function_setup() {
  551|       |        // Test that the main function components work
  552|       |        // This is a basic smoke test
  553|      1|        let icon = create_app_icon();
  554|      1|        assert!(!icon.rgba.is_empty());
  555|      1|    }
  556|       |
  557|       |    #[test]
  558|      1|    fn test_configure_egui_style_dark_mode() {
  559|      1|        let ctx = egui::Context::default();
  560|      1|        let mut style = (*ctx.style()).clone();
  561|      1|        style.visuals.dark_mode = true;
  562|      1|        ctx.set_style(style);
  563|       |
  564|      1|        configure_egui_style(&ctx);
  565|       |
  566|      1|        let style = ctx.style();
  567|      1|        assert_eq!(style.spacing.item_spacing, egui::Vec2::new(8.0, 8.0));
  568|      1|        assert_eq!(style.spacing.window_margin, egui::Margin::same(8.0));
  569|      1|        assert_eq!(style.spacing.menu_margin, egui::Margin::same(6.0));
  570|      1|        assert_eq!(style.visuals.window_rounding, egui::Rounding::same(4.0));
  571|      1|        assert_eq!(style.visuals.menu_rounding, egui::Rounding::same(4.0));
  572|      1|        assert_eq!(style.visuals.window_fill, egui::Color32::BLACK);
  573|      1|        assert_eq!(style.visuals.panel_fill, egui::Color32::BLACK);
  574|      1|        assert_eq!(style.visuals.faint_bg_color, egui::Color32::from_gray(20));
  575|      1|        assert_eq!(style.visuals.extreme_bg_color, egui::Color32::BLACK);
  576|      1|    }
  577|       |
  578|       |    #[test]
  579|      1|    fn test_configure_egui_style_light_mode() {
  580|      1|        let ctx = egui::Context::default();
  581|      1|        let mut style = (*ctx.style()).clone();
  582|      1|        style.visuals.dark_mode = false;
  583|      1|        style.visuals.window_fill = egui::Color32::from_rgb(1, 2, 3);
  584|      1|        style.visuals.panel_fill = egui::Color32::from_rgb(4, 5, 6);
  585|      1|        style.visuals.faint_bg_color = egui::Color32::from_rgb(7, 8, 9);
  586|      1|        style.visuals.extreme_bg_color = egui::Color32::from_rgb(10, 11, 12);
  587|      1|        ctx.set_style(style);
  588|       |
  589|      1|        configure_egui_style(&ctx);
  590|       |
  591|      1|        let style = ctx.style();
  592|      1|        assert_eq!(style.spacing.item_spacing, egui::Vec2::new(8.0, 8.0));
  593|      1|        assert_eq!(style.spacing.window_margin, egui::Margin::same(8.0));
  594|      1|        assert_eq!(style.spacing.menu_margin, egui::Margin::same(6.0));
  595|      1|        assert_eq!(style.visuals.window_rounding, egui::Rounding::same(4.0));
  596|      1|        assert_eq!(style.visuals.menu_rounding, egui::Rounding::same(4.0));
  597|      1|        assert_eq!(style.visuals.window_fill, egui::Color32::from_rgb(1, 2, 3));
  598|      1|        assert_eq!(style.visuals.panel_fill, egui::Color32::from_rgb(4, 5, 6));
  599|      1|        assert_eq!(
  600|      1|            style.visuals.faint_bg_color,
  601|      1|            egui::Color32::from_rgb(7, 8, 9)
  602|       |        );
  603|      1|        assert_eq!(
  604|      1|            style.visuals.extreme_bg_color,
  605|      1|            egui::Color32::from_rgb(10, 11, 12)
  606|       |        );
  607|      1|    }
  608|       |
  609|       |    #[test]
  610|      1|    fn test_parse_cli_sets_initial_file_from_arg() {
  611|      1|        let opts = parse_cli_from(vec!["readme.md".to_string()]).expect("parse");
  612|      1|        assert_eq!(opts.initial_file, Some(PathBuf::from("readme.md")));
  613|      1|    }
  614|       |
  615|       |    #[test]
  616|      1|    fn test_parse_cli_screenshot_args() {
  617|      1|        let args = vec![
  618|      1|            "--screenshot".to_string(),
  619|      1|            "doc.md".to_string(),
  620|      1|            "--output".to_string(),
  621|      1|            "out.png".to_string(),
  622|      1|            "--width".to_string(),
  623|      1|            "800".to_string(),
  624|      1|            "--height".to_string(),
  625|      1|            "600".to_string(),
  626|      1|            "--theme".to_string(),
  627|      1|            "dark".to_string(),
  628|      1|            "--scroll".to_string(),
  629|      1|            "0.5".to_string(),
  630|       |        ];
  631|      1|        let opts = parse_cli_from(args).expect("parse");
  632|      1|        assert!(opts.screenshot);
  633|      1|        assert_eq!(opts.initial_file, Some(PathBuf::from("doc.md")));
  634|      1|        assert_eq!(opts.screenshot_output, Some(PathBuf::from("out.png")));
  635|      1|        assert_eq!(opts.width, Some(800.0));
  636|      1|        assert_eq!(opts.height, Some(600.0));
  637|      1|        assert_eq!(opts.theme, Some(ThemeChoice::Dark));
  638|      1|        assert_eq!(opts.scroll, Some(0.5));
  639|      1|    }
  640|       |
  641|       |    #[test]
  642|      1|    fn test_parse_cli_missing_screenshot_input() {
  643|      1|        let args = vec!["--screenshot".to_string()];
  644|      1|        let err = parse_cli_from(args)
  645|      1|            .err()
  646|      1|            .expect("expected missing screenshot input error");
  647|      1|        assert!(err.contains("--screenshot requires a value"));
  648|      1|    }
  649|       |
  650|       |    #[test]
  651|      1|    fn test_parse_cli_missing_screenshot_output() {
  652|      1|        let args = vec!["--screenshot".to_string(), "doc.md".to_string()];
  653|      1|        let err = parse_cli_from(args)
  654|      1|            .err()
  655|      1|            .expect("expected missing output error");
  656|      1|        assert!(err.contains("Missing --output"));
  657|      1|    }
  658|       |
  659|       |    #[test]
  660|      1|    fn test_parse_cli_invalid_values() {
  661|      1|        let args = vec!["--width".to_string(), "nope".to_string()];
  662|      1|        let err = parse_cli_from(args)
  663|      1|            .err()
  664|      1|            .expect("expected invalid width error");
  665|      1|        assert!(err.contains("Invalid --width"));
  666|       |
  667|      1|        let args = vec!["--theme".to_string(), "blue".to_string()];
  668|      1|        let err = parse_cli_from(args)
  669|      1|            .err()
  670|      1|            .expect("expected invalid theme error");
  671|      1|        assert!(err.contains("Unsupported theme"));
  672|      1|    }
  673|       |
  674|       |    #[test]
  675|      1|    fn test_parse_cli_missing_flag_value() {
  676|      1|        let args = vec!["--height".to_string()];
  677|      1|        let err = parse_cli_from(args)
  678|      1|            .err()
  679|      1|            .expect("expected missing height value error");
  680|      1|        assert!(err.contains("--height requires a value"));
  681|      1|    }
  682|       |
  683|       |    #[test]
  684|      1|    fn test_parse_cli_scroll_clamps() {
  685|      1|        let args = vec![
  686|      1|            "--scroll".to_string(),
  687|      1|            "2.5".to_string(),
  688|      1|            "doc.md".to_string(),
  689|       |        ];
  690|      1|        let opts = parse_cli_from(args).expect("parse");
  691|      1|        assert_eq!(opts.scroll, Some(1.0));
  692|      1|        assert_eq!(opts.initial_file, Some(PathBuf::from("doc.md")));
  693|      1|    }
  694|       |
  695|       |    #[test]
  696|      1|    fn test_parse_cli_additional_flags() {
  697|      1|        let args = vec![
  698|      1|            "--screenshot".to_string(),
  699|      1|            "doc.md".to_string(),
  700|      1|            "--output".to_string(),
  701|      1|            "out.png".to_string(),
  702|      1|            "--content-only".to_string(),
  703|      1|            "--wait-ms".to_string(),
  704|      1|            "1200".to_string(),
  705|      1|            "--settle-frames".to_string(),
  706|      1|            "3".to_string(),
  707|      1|            "--zoom".to_string(),
  708|      1|            "1.5".to_string(),
  709|      1|            "--theme".to_string(),
  710|      1|            "light".to_string(),
  711|      1|            "--test-fonts".to_string(),
  712|      1|            "fonts".to_string(),
  713|       |        ];
  714|      1|        let opts = parse_cli_from(args).expect("parse");
  715|      1|        assert!(opts.screenshot);
  716|      1|        assert!(opts.content_only);
  717|      1|        assert_eq!(opts.wait_ms, Some(1200));
  718|      1|        assert_eq!(opts.settle_frames, Some(3));
  719|      1|        assert_eq!(opts.zoom, Some(1.5));
  720|      1|        assert_eq!(opts.theme, Some(ThemeChoice::Light));
  721|      1|        assert_eq!(opts.test_fonts, Some(PathBuf::from("fonts")));
  722|      1|    }
  723|       |
  724|       |    #[test]
  725|      1|    fn test_parse_cli_ignores_extra_args() {
  726|      1|        let args = vec!["doc.md".to_string(), "extra.md".to_string()];
  727|      1|        let opts = parse_cli_from(args).expect("parse");
  728|      1|        assert_eq!(opts.initial_file, Some(PathBuf::from("doc.md")));
  729|      1|    }
  730|       |
  731|       |    #[test]
  732|      1|    fn test_parse_hex_color32() {
  733|      1|        let color = parse_hex_color32("#FFF8DB").expect("color");
  734|      1|        assert_eq!(color, egui::Color32::from_rgb(255, 248, 219));
  735|      1|        assert!(parse_hex_color32("#XYZ").is_none());
  736|      1|    }
  737|       |
  738|       |    #[test]
  739|      1|    fn test_screenshot_background_color_env() {
  740|       |        {
  741|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "#112233");
  742|      1|            let color = screenshot_background_color();
  743|      1|            assert_eq!(color, egui::Color32::from_rgb(17, 34, 51));
  744|       |        }
  745|       |        {
  746|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "bad");
  747|      1|            let color = screenshot_background_color();
  748|      1|            assert_eq!(color, egui::Color32::from_rgb(255, 248, 219));
  749|       |        }
  750|      1|    }
  751|       |
  752|       |    #[test]
  753|      1|    fn test_screenshot_background_color_default_when_unset() {
  754|      1|        let _guard = EnvGuard::unset("MDMDVIEW_MERMAID_MAIN_BKG");
  755|      1|        let color = screenshot_background_color();
  756|      1|        assert_eq!(color, egui::Color32::from_rgb(255, 248, 219));
  757|      1|    }
  758|       |
  759|       |    #[test]
  760|      1|    fn test_env_guard_restores_previous_value() {
  761|      1|        let key = "MDMDVIEW_MERMAID_MAIN_BKG";
  762|      1|        let previous = std::env::var(key).ok();
  763|      1|        {
  764|      1|            let lock = env_lock();
  765|      1|            std::env::set_var(key, "orig");
  766|      1|            let guard = EnvGuard {
  767|      1|                key,
  768|      1|                original: Some("orig".to_string()),
  769|      1|                _lock: lock,
  770|      1|            };
  771|      1|            std::env::set_var(key, "new");
  772|      1|            drop(guard);
  773|      1|        }
  774|      1|        assert_eq!(std::env::var(key).ok().as_deref(), Some("orig"));
  775|      1|        let _lock = env_lock();
  776|      1|        match previous {
  777|      0|            Some(value) => std::env::set_var(key, value),
  778|      1|            None => std::env::remove_var(key),
  779|       |        }
  780|      1|    }
  781|       |
  782|       |    #[test]
  783|      1|    fn test_main_stub_executes() {
  784|      1|        super::main();
  785|      1|    }
  786|       |}

C:\language\mdmdview\src\markdown_renderer.rs:
    1|       |use crate::image_decode;
    2|       |use crate::mermaid_renderer::MermaidRenderer;
    3|       |use crate::table_support::{
    4|       |    compute_column_stats, derive_column_specs, ColumnPolicy, ColumnSpec, ColumnStat,
    5|       |    TableColumnContext, TableMetrics, WidthChange,
    6|       |};
    7|       |use crate::{emoji_assets, emoji_catalog};
    8|       |use anyhow::Result;
    9|       |use crossbeam_channel::{bounded, Receiver, Sender, TrySendError};
   10|       |use egui::{
   11|       |    text::{Galley, LayoutJob, TextWrapping},
   12|       |    Align, Color32, Context, FontSelection, Painter, RichText, Stroke, Vec2, Visuals,
   13|       |};
   14|       |use egui_extras::{Column, TableBuilder};
   15|       |use pulldown_cmark::{Alignment, Event, LinkType, Options, Parser, Tag};
   16|       |use std::cell::{Cell, RefCell};
   17|       |use std::collections::{hash_map::DefaultHasher, HashMap, HashSet, VecDeque};
   18|       |use std::hash::{Hash, Hasher};
   19|       |use std::ops::Range;
   20|       |use std::path::{Path, PathBuf};
   21|       |use std::sync::Arc;
   22|       |use std::time::{Duration, Instant, SystemTime};
   23|       |use syntect::easy::HighlightLines;
   24|       |use syntect::highlighting::ThemeSet;
   25|       |use syntect::parsing::SyntaxSet;
   26|       |use syntect::util::LinesWithEndings;
   27|       |use unicode_casefold::UnicodeCaseFold;
   28|       |use unicode_normalization::UnicodeNormalization;
   29|       |use unicode_segmentation::UnicodeSegmentation;
   30|       |
   31|       |#[derive(Clone, Copy, Default)]
   32|       |struct InlineStyle {
   33|       |    strong: bool,
   34|       |    italics: bool,
   35|       |    strike: bool,
   36|       |    color: Option<Color32>,
   37|       |}
   38|       |
   39|       |#[cfg(test)]
   40|       |thread_local! {
   41|       |    static FORCED_RENDER_ACTIONS: RefCell<HashSet<&'static str>> = RefCell::new(HashSet::new());
   42|       |    static FORCED_TABLE_POLICIES: RefCell<Option<Vec<ColumnPolicy>>> = const { RefCell::new(None) };
   43|       |    static FORCED_PARSE_ERROR: RefCell<bool> = const { RefCell::new(false) };
   44|       |}
   45|       |
   46|       |#[cfg(test)]
   47|     31|fn render_action_triggered(triggered: bool, action: &'static str) -> bool {
   48|     31|    triggered || FORCED_RENDER_ACTIONS.with(|actions| actions.borrow().contains(action))
                               ^29                   ^29            ^29              ^29      ^29
  ------------------
  |  Branch (48:5): [True: 2, False: 29]
  ------------------
   49|     31|}
   50|       |
   51|       |#[cfg(not(test))]
   52|       |fn render_action_triggered(triggered: bool, _action: &'static str) -> bool {
   53|       |    triggered
   54|       |}
   55|       |
   56|       |#[cfg(test)]
   57|     16|fn take_forced_table_policies() -> Option<Vec<ColumnPolicy>> {
   58|     16|    FORCED_TABLE_POLICIES.with(|policies| policies.borrow_mut().take())
   59|     16|}
   60|       |
   61|       |#[cfg(test)]
   62|      3|pub(crate) fn force_parse_error_once() {
   63|      3|    FORCED_PARSE_ERROR.with(|flag| flag.replace(true));
   64|      3|}
   65|       |
   66|       |#[cfg(test)]
   67|    215|fn take_forced_parse_error() -> bool {
   68|    215|    FORCED_PARSE_ERROR.with(|flag| flag.replace(false))
   69|    215|}
   70|       |
   71|       |/// Font size configuration
   72|       |#[derive(Debug, Clone)]
   73|       |pub struct FontSizes {
   74|       |    pub body: f32,
   75|       |    pub h1: f32,
   76|       |    pub h2: f32,
   77|       |    pub h3: f32,
   78|       |    pub h4: f32,
   79|       |    pub h5: f32,
   80|       |    pub h6: f32,
   81|       |    pub code: f32,
   82|       |}
   83|       |
   84|       |impl Default for FontSizes {
   85|    289|    fn default() -> Self {
   86|    289|        Self {
   87|    289|            body: 14.0,
   88|    289|            h1: 28.0,
   89|    289|            h2: 24.0,
   90|    289|            h3: 20.0,
   91|    289|            h4: 18.0,
   92|    289|            h5: 16.0,
   93|    289|            h6: 14.0,
   94|    289|            code: 12.0,
   95|    289|        }
   96|    289|    }
   97|       |}
   98|       |
   99|       |/// Represents an inline text span with formatting
  100|       |#[derive(Debug, Clone)]
  101|       |pub enum InlineSpan {
  102|       |    Text(String),
  103|       |    Code(String),
  104|       |    Strong(String),
  105|       |    Emphasis(String),
  106|       |    Strikethrough(String),
  107|       |    Link {
  108|       |        text: String,
  109|       |        url: String,
  110|       |    },
  111|       |    Image {
  112|       |        src: String,
  113|       |        alt: String,
  114|       |        title: Option<String>,
  115|       |    },
  116|       |}
  117|       |
  118|       |#[cfg_attr(not(test), allow(dead_code))]
  119|       |#[derive(Debug, Clone)]
  120|       |enum CellFragment<'a> {
  121|       |    Text(&'a [InlineSpan]),
  122|       |    Emoji(String),
  123|       |    Image(&'a InlineSpan),
  124|       |}
  125|       |
  126|       |#[cfg_attr(not(test), allow(dead_code))]
  127|       |#[derive(Debug, Clone)]
  128|       |struct LayoutJobBuild {
  129|       |    job: LayoutJob,
  130|       |    #[allow(dead_code)]
  131|       |    plain_text: String,
  132|       |    #[cfg_attr(not(test), allow(dead_code))]
  133|       |    link_ranges: Vec<LinkRange>,
  134|       |}
  135|       |
  136|       |#[cfg_attr(not(test), allow(dead_code))]
  137|       |#[derive(Debug, Clone)]
  138|       |struct LinkRange {
  139|       |    char_range: Range<usize>,
  140|       |    url: String,
  141|       |}
  142|       |
  143|       |const TABLE_LAYOUT_CACHE_CAPACITY: usize = 512;
  144|       |const COLUMN_STATS_SAMPLE_ROWS: usize = 128;
  145|       |const PIPE_SENTINEL: char = '\u{1F}';
  146|       |const IMAGE_TEXTURE_CACHE_CAPACITY: usize = 256;
  147|       |const IMAGE_MAX_PENDING: usize = 64;
  148|       |const IMAGE_FAILURE_BACKOFF: Duration = Duration::from_secs(5);
  149|       |
  150|       |#[derive(Debug, Clone, Hash, PartialEq, Eq)]
  151|       |struct CellLayoutKey {
  152|       |    row: Option<usize>,
  153|       |    col: usize,
  154|       |    width: u32,
  155|       |    align: u8,
  156|       |    strong: bool,
  157|       |    text_color: [u8; 4],
  158|       |    highlight_hash: u64,
  159|       |    content_hash: u64,
  160|       |}
  161|       |
  162|       |struct CellLayoutCache {
  163|       |    entries: HashMap<CellLayoutKey, LayoutJobBuild>,
  164|       |    order: VecDeque<CellLayoutKey>,
  165|       |    hits: u64,
  166|       |    misses: u64,
  167|       |    capacity: usize,
  168|       |}
  169|       |
  170|       |#[derive(Clone)]
  171|       |struct ColumnStatsCacheEntry {
  172|       |    content_hash: u64,
  173|       |    stats: Vec<ColumnStat>,
  174|       |}
  175|       |
  176|       |impl CellLayoutCache {
  177|    272|    fn new(capacity: usize) -> Self {
  178|    272|        Self {
  179|    272|            entries: HashMap::new(),
  180|    272|            order: VecDeque::new(),
  181|    272|            hits: 0,
  182|    272|            misses: 0,
  183|    272|            capacity,
  184|    272|        }
  185|    272|    }
  186|       |
  187|    162|    fn get(&mut self, key: &CellLayoutKey) -> Option<LayoutJobBuild> {
  188|    162|        if let Some(build) = self.entries.get(key) {
                                  ^16
  ------------------
  |  Branch (188:16): [True: 16, False: 146]
  ------------------
  189|     16|            self.hits += 1;
  190|     16|            Some(build.clone())
  191|       |        } else {
  192|    146|            self.misses += 1;
  193|    146|            None
  194|       |        }
  195|    162|    }
  196|       |
  197|    152|    fn insert(&mut self, key: CellLayoutKey, build: LayoutJobBuild) {
  198|    152|        if self.entries.len() >= self.capacity && !self.entries.contains_key(&key) {
                                                                ^3^3
  ------------------
  |  Branch (198:12): [True: 3, False: 149]
  |  Branch (198:51): [True: 2, False: 1]
  ------------------
  199|      3|            while self.entries.len() >= self.capacity {
  ------------------
  |  Branch (199:19): [True: 2, False: 1]
  ------------------
  200|      2|                if let Some(old) = self.order.pop_front() {
                                          ^1
  ------------------
  |  Branch (200:24): [True: 1, False: 1]
  ------------------
  201|      1|                    self.entries.remove(&old);
  202|      1|                } else {
  203|      1|                    break;
  204|       |                }
  205|       |            }
  206|    150|        }
  207|    932|        self.order.retain(|existing| existing != &key);
                      ^152       ^152
  208|    152|        self.order.push_back(key.clone());
  209|    152|        self.entries.insert(key, build);
  210|    152|    }
  211|       |
  212|    207|    fn clear(&mut self) {
  213|    207|        self.entries.clear();
  214|    207|        self.order.clear();
  215|    207|        self.hits = 0;
  216|    207|        self.misses = 0;
  217|    207|    }
  218|       |
  219|      4|    fn stats(&self) -> (u64, u64) {
  220|      4|        (self.hits, self.misses)
  221|      4|    }
  222|       |}
  223|       |
  224|       |#[derive(Debug, Clone)]
  225|       |pub struct ListItem {
  226|       |    pub blocks: Vec<MarkdownElement>,
  227|       |}
  228|       |
  229|       |/// Represents a rendered markdown element
  230|       |#[derive(Debug, Clone)]
  231|       |pub enum MarkdownElement {
  232|       |    Paragraph(Vec<InlineSpan>),
  233|       |    Header {
  234|       |        level: u8,
  235|       |        spans: Vec<InlineSpan>,
  236|       |        id: String,
  237|       |    },
  238|       |    CodeBlock {
  239|       |        language: Option<String>,
  240|       |        text: String,
  241|       |    },
  242|       |    List {
  243|       |        ordered: bool,
  244|       |        items: Vec<ListItem>,
  245|       |    }, // List items can contain block elements
  246|       |    Quote {
  247|       |        depth: u8,
  248|       |        blocks: Vec<MarkdownElement>,
  249|       |    },
  250|       |    HorizontalRule,
  251|       |    Table {
  252|       |        headers: Vec<Vec<InlineSpan>>,   // header cells as inline spans
  253|       |        rows: Vec<Vec<Vec<InlineSpan>>>, // rows -> cells -> spans
  254|       |        alignments: Vec<Alignment>,
  255|       |    },
  256|       |}
  257|       |
  258|       |/// Type alias for table parsing result
  259|       |type TableParseResult = (Vec<Vec<InlineSpan>>, Vec<Vec<Vec<InlineSpan>>>, usize);
  260|       |
  261|       |/// Type alias for quote blocks (nested markdown elements)
  262|       |type QuoteBlocks = Vec<MarkdownElement>;
  263|       |
  264|       |#[derive(Clone)]
  265|       |struct ImageCacheEntry {
  266|       |    texture: egui::TextureHandle,
  267|       |    size: [u32; 2],
  268|       |    modified: Option<SystemTime>,
  269|       |}
  270|       |
  271|       |struct ImageCache {
  272|       |    entries: HashMap<String, ImageCacheEntry>,
  273|       |    order: VecDeque<String>,
  274|       |    capacity: usize,
  275|       |}
  276|       |
  277|       |impl ImageCache {
  278|    272|    fn new(capacity: usize) -> Self {
  279|    272|        Self {
  280|    272|            entries: HashMap::new(),
  281|    272|            order: VecDeque::new(),
  282|    272|            capacity: capacity.max(1),
  283|    272|        }
  284|    272|    }
  285|       |
  286|     40|    fn get(&mut self, key: &str) -> Option<ImageCacheEntry> {
  287|     40|        let entry = self.entries.get(key).cloned();
  288|     40|        if entry.is_some() {
  ------------------
  |  Branch (288:12): [True: 15, False: 25]
  ------------------
  289|     15|            self.touch(key);
  290|     25|        }
  291|     40|        entry
  292|     40|    }
  293|       |
  294|     14|    fn insert(&mut self, key: String, entry: ImageCacheEntry) {
  295|     14|        if self.entries.contains_key(&key) {
  ------------------
  |  Branch (295:12): [True: 1, False: 13]
  ------------------
  296|      1|            self.entries.insert(key.clone(), entry);
  297|      1|            self.touch(&key);
  298|      1|            return;
  299|     13|        }
  300|     14|        while self.entries.len() >= self.capacity {
  ------------------
  |  Branch (300:15): [True: 2, False: 12]
  ------------------
  301|      2|            if let Some(old) = self.order.pop_front() {
                                      ^1
  ------------------
  |  Branch (301:20): [True: 1, False: 1]
  ------------------
  302|      1|                self.entries.remove(&old);
  303|      1|            } else {
  304|      1|                break;
  305|       |            }
  306|       |        }
  307|     13|        self.order.push_back(key.clone());
  308|     13|        self.entries.insert(key, entry);
  309|     14|    }
  310|       |
  311|      0|    fn remove(&mut self, key: &str) {
  312|      0|        self.entries.remove(key);
  313|      0|        self.order.retain(|entry| entry != key);
  314|      0|    }
  315|       |
  316|       |    #[cfg(test)]
  317|      4|    fn contains_key(&self, key: &str) -> bool {
  318|      4|        self.entries.contains_key(key)
  319|      4|    }
  320|       |
  321|     16|    fn touch(&mut self, key: &str) {
  322|     16|        self.order.retain(|entry| entry != key);
  323|     16|        self.order.push_back(key.to_string());
  324|     16|    }
  325|       |}
  326|       |
  327|       |struct ImageFailure {
  328|       |    last_attempt: Instant,
  329|       |}
  330|       |
  331|       |enum ImageLoadSource {
  332|       |    Embedded(&'static [u8]),
  333|       |    File(PathBuf),
  334|       |}
  335|       |
  336|       |struct ImageLoadRequest {
  337|       |    key: String,
  338|       |    source: ImageLoadSource,
  339|       |}
  340|       |
  341|       |enum ImageLoadResult {
  342|       |    Loaded {
  343|       |        key: String,
  344|       |        image: egui::ColorImage,
  345|       |        size: [u32; 2],
  346|       |        modified: Option<SystemTime>,
  347|       |    },
  348|       |    Failed {
  349|       |        key: String,
  350|       |    },
  351|       |}
  352|       |
  353|       |/// Markdown renderer with proper inline element handling
  354|       |pub struct MarkdownRenderer {
  355|       |    font_sizes: FontSizes,
  356|       |    syntax_set: SyntaxSet,
  357|       |    theme_set: ThemeSet,
  358|       |    emoji_textures: RefCell<HashMap<String, egui::TextureHandle>>,
  359|       |    image_textures: RefCell<ImageCache>,
  360|       |    image_pending: RefCell<HashSet<String>>,
  361|       |    image_failures: RefCell<HashMap<String, ImageFailure>>,
  362|       |    image_job_tx: Sender<ImageLoadRequest>,
  363|       |    image_result_rx: Receiver<ImageLoadResult>,
  364|       |    // Mapping of header id -> last rendered rect (for in-document navigation)
  365|       |    header_rects: RefCell<HashMap<String, egui::Rect>>,
  366|       |    // Last clicked internal anchor (e.g., "getting-started") for the app to consume
  367|       |    pending_anchor: RefCell<Option<String>>,
  368|       |    // Unique counter to avoid egui Id collisions for repeated links
  369|       |    link_counter: RefCell<u64>,
  370|       |    // Per-frame table counter to build stable table ids in render order
  371|       |    table_counter: RefCell<u64>,
  372|       |    // Per-frame rect for each top-level element in render order
  373|       |    element_rects: RefCell<Vec<egui::Rect>>,
  374|       |    // Optional highlight phrase (lowercased) for in-text highlighting
  375|       |    highlight_phrase: RefCell<Option<String>>,
  376|       |    // Cache for image/diagram textures
  377|       |    // Base directory used to resolve relative image paths
  378|       |    base_dir: RefCell<Option<PathBuf>>,
  379|       |    mermaid: MermaidRenderer,
  380|       |    table_layout_cache: RefCell<CellLayoutCache>,
  381|       |    table_metrics: RefCell<TableMetrics>,
  382|       |    column_stats_cache: RefCell<HashMap<u64, ColumnStatsCacheEntry>>,
  383|       |}
  384|       |
  385|       |impl Default for MarkdownRenderer {
  386|      1|    fn default() -> Self {
  387|      1|        Self::new()
  388|      1|    }
  389|       |}
  390|       |
  391|       |impl MarkdownRenderer {
  392|       |    #[cfg_attr(not(test), allow(dead_code))]
  393|    145|    fn cell_fragments<'a>(&'a self, spans: &'a [InlineSpan]) -> Vec<CellFragment<'a>> {
  394|    145|        if let Some(emoji) = self.cell_single_emoji(spans) {
                                  ^2
  ------------------
  |  Branch (394:16): [True: 2, False: 143]
  ------------------
  395|      2|            return vec![CellFragment::Emoji(emoji)];
  396|    143|        }
  397|    143|        let mut fragments = Vec::new();
  398|    143|        let mut run_start: Option<usize> = None;
  399|    143|        let flush_run =
  400|      7|            |start: &mut Option<usize>, end: usize, fragments: &mut Vec<CellFragment<'a>>| {
  401|      7|                if let Some(run_begin) = start.take() {
                                          ^3
  ------------------
  |  Branch (401:24): [True: 3, False: 4]
  ------------------
  402|      3|                    fragments.push(CellFragment::Text(&spans[run_begin..end]));
  403|      4|                }
  404|      7|            };
  405|       |
  406|    176|        for (idx, span) in spans.iter().enumerate() {
                                         ^143  ^143   ^143
  407|    176|            if matches!(span, InlineSpan::Image { .. }) {
                             ^169
  408|      7|                flush_run(&mut run_start, idx, &mut fragments);
  409|      7|                fragments.push(CellFragment::Image(span));
  410|      7|                continue;
  411|    169|            }
  412|       |
  413|    169|            if run_start.is_none() {
  ------------------
  |  Branch (413:16): [True: 137, False: 32]
  ------------------
  414|    137|                run_start = Some(idx);
  415|    137|            }
                          ^32
  416|       |        }
  417|       |
  418|    143|        if let Some(start) = run_start {
                                  ^134
  ------------------
  |  Branch (418:16): [True: 134, False: 9]
  ------------------
  419|    134|            fragments.push(CellFragment::Text(&spans[start..]));
  420|    134|        }
                      ^9
  421|       |
  422|    143|        fragments
  423|    145|    }
  424|       |
  425|    149|    fn cell_single_emoji(&self, spans: &[InlineSpan]) -> Option<String> {
  426|    149|        let mut text = String::new();
  427|    315|        for span in spans {
                          ^180
  428|    180|            match span {
  429|    157|                InlineSpan::Text(t)
  430|      8|                | InlineSpan::Strong(t)
  431|      1|                | InlineSpan::Emphasis(t)
  432|    166|                | InlineSpan::Strikethrough(t) => text.push_str(t),
                                                          ^0
  433|       |                InlineSpan::Code(_) | InlineSpan::Link { .. } | InlineSpan::Image { .. } => {
  434|     14|                    return None;
  435|       |                }
  436|       |            }
  437|       |        }
  438|       |
  439|    135|        let trimmed = text.trim();
  440|    135|        if trimmed.is_empty() {
  ------------------
  |  Branch (440:12): [True: 5, False: 130]
  ------------------
  441|      5|            return None;
  442|    130|        }
  443|    130|        let mut graphemes = trimmed.graphemes(true);
  444|    130|        let first = graphemes.next()?;
                                                  ^0
  445|    130|        if graphemes.next().is_some() {
  ------------------
  |  Branch (445:12): [True: 106, False: 24]
  ------------------
  446|    106|            return None;
  447|     24|        }
  448|     24|        self.emoji_key_for_grapheme(first)
  449|    149|    }
  450|       |
  451|    236|    fn highlight_segments(&self, text: &str, highlight: Option<&str>) -> Vec<(Range<usize>, bool)> {
  452|    236|        if text.is_empty() {
  ------------------
  |  Branch (452:12): [True: 1, False: 235]
  ------------------
  453|      1|            return Vec::new();
  454|    235|        }
  455|    235|        let Some(needle) = highlight.filter(|h| !h.is_empty()) else {
                               ^38                             ^39^39
  ------------------
  |  Branch (455:13): [True: 38, False: 197]
  ------------------
  456|    197|            return vec![(0..text.len(), false)];
  457|       |        };
  458|       |
  459|     38|        let mut folded = String::new();
  460|     38|        let mut folded_to_char: Vec<usize> = Vec::new();
  461|     38|        let mut char_ranges: Vec<(usize, usize)> = Vec::new();
  462|    227|        for (char_idx, (byte_idx, ch)) in text.char_indices().enumerate() {
                                                        ^38  ^38            ^38
  463|    227|            let folded_piece: String = ch.to_string().case_fold().nfkc().collect();
  464|    227|            let before = folded.len();
  465|    227|            folded.push_str(&folded_piece);
  466|    227|            let after = folded.len();
  467|    230|            for _ in before..after {
                                   ^227    ^227
  468|    230|                folded_to_char.push(char_idx);
  469|    230|            }
  470|    227|            char_ranges.push((byte_idx, byte_idx + ch.len_utf8()));
  471|       |        }
  472|       |
  473|     38|        let mut segments = Vec::new();
  474|     38|        let mut rendered_until = 0usize;
  475|     38|        let mut search_at = 0usize;
  476|     51|        while let Some(pos) = folded[search_at..].find(needle) {
                                     ^13
  ------------------
  |  Branch (476:19): [True: 13, False: 38]
  ------------------
  477|     13|            let abs = search_at + pos;
  478|     13|            let start_char_idx = folded_to_char[abs];
  479|     13|            let (start_byte, _) = char_ranges[start_char_idx];
  480|     13|            if start_byte > rendered_until {
  ------------------
  |  Branch (480:16): [True: 2, False: 11]
  ------------------
  481|      2|                segments.push((rendered_until..start_byte, false));
  482|     11|            }
  483|     13|            let match_end = abs + needle.len();
  484|     13|            let end_char_idx = folded_to_char[match_end.saturating_sub(1)];
  485|     13|            let (_, end_byte) = char_ranges[end_char_idx];
  486|     13|            segments.push((start_byte..end_byte, true));
  487|     13|            rendered_until = end_byte;
  488|     13|            search_at = match_end;
  489|       |        }
  490|       |
  491|     38|        if rendered_until < text.len() {
  ------------------
  |  Branch (491:12): [True: 32, False: 6]
  ------------------
  492|     32|            segments.push((rendered_until..text.len(), false));
  493|     32|        }
                      ^6
  494|       |
  495|     38|        segments
  496|    236|    }
  497|       |
  498|       |    #[cfg_attr(not(test), allow(dead_code))]
  499|    177|    fn build_layout_job(
  500|    177|        &self,
  501|    177|        style: &egui::Style,
  502|    177|        spans: &[InlineSpan],
  503|    177|        wrap_width: f32,
  504|    177|        strong_override: bool,
  505|    177|        halign: Align,
  506|    177|    ) -> LayoutJobBuild {
  507|    177|        let mut job = LayoutJob {
  508|    177|            wrap: TextWrapping {
  509|    177|                max_width: wrap_width.max(1.0),
  510|    177|                ..Default::default()
  511|    177|            },
  512|    177|            break_on_newline: true,
  513|    177|            halign,
  514|    177|            ..Default::default()
  515|    177|        };
  516|       |
  517|    177|        let highlight = self
  518|    177|            .highlight_phrase
  519|    177|            .borrow()
  520|    177|            .clone()
  521|    177|            .filter(|s| !s.is_empty());
                                       ^10^10
  522|       |
  523|    177|        let mut plain_text = String::new();
  524|    177|        let mut link_ranges = Vec::new();
  525|    177|        let mut job_char_offset = 0usize;
  526|       |
  527|    390|        for span in spans {
                          ^213
  528|    213|            match span {
  529|      1|                InlineSpan::Image { .. } => {}
  530|      1|                InlineSpan::Code(code) => {
  531|      1|                    job_char_offset +=
  532|      1|                        self.append_code_span(style, &mut job, &mut plain_text, code);
  533|      1|                }
  534|     11|                InlineSpan::Link { text, url } => {
  535|     11|                    let inline_style = InlineStyle {
  536|     11|                        strong: strong_override,
  537|     11|                        color: Some(if Self::is_external_url(url) {
  ------------------
  |  Branch (537:40): [True: 10, False: 1]
  ------------------
  538|     10|                            Color32::from_rgb(120, 190, 255)
  539|       |                        } else {
  540|      1|                            Color32::LIGHT_BLUE
  541|       |                        }),
  542|     11|                        ..Default::default()
  543|       |                    };
  544|     11|                    let mut normalized = self.fix_unicode_chars(text);
  545|     11|                    normalized = Self::expand_shortcodes(&normalized);
  546|     11|                    normalized = Self::expand_superscripts(&normalized);
  547|     11|                    let appended = self.append_text_sections(
  548|     11|                        style,
  549|     11|                        &mut job,
  550|     11|                        &mut plain_text,
  551|     11|                        &normalized,
  552|     11|                        self.font_sizes.body,
  553|     11|                        inline_style,
  554|     11|                        highlight.as_deref(),
  555|       |                    );
  556|     11|                    if appended > 0 {
  ------------------
  |  Branch (556:24): [True: 10, False: 1]
  ------------------
  557|     10|                        let start_char = job_char_offset;
  558|     10|                        job_char_offset += appended;
  559|     10|                        link_ranges.push(LinkRange {
  560|     10|                            char_range: start_char..job_char_offset,
  561|     10|                            url: url.clone(),
  562|     10|                        });
  563|     10|                    }
                                  ^1
  564|       |                }
  565|      7|                InlineSpan::Strong(text) => {
  566|      7|                    job_char_offset += self.append_plain_span(
  567|      7|                        style,
  568|      7|                        &mut job,
  569|      7|                        &mut plain_text,
  570|      7|                        text,
  571|      7|                        InlineStyle {
  572|      7|                            strong: true,
  573|      7|                            ..Default::default()
  574|      7|                        },
  575|      7|                        highlight.as_deref(),
  576|      7|                    );
  577|      7|                }
  578|      1|                InlineSpan::Emphasis(text) => {
  579|      1|                    job_char_offset += self.append_plain_span(
  580|      1|                        style,
  581|      1|                        &mut job,
  582|      1|                        &mut plain_text,
  583|      1|                        text,
  584|      1|                        InlineStyle {
  585|      1|                            italics: true,
  586|      1|                            strong: strong_override,
  587|      1|                            ..Default::default()
  588|      1|                        },
  589|      1|                        highlight.as_deref(),
  590|      1|                    );
  591|      1|                }
  592|      1|                InlineSpan::Strikethrough(text) => {
  593|      1|                    job_char_offset += self.append_plain_span(
  594|      1|                        style,
  595|      1|                        &mut job,
  596|      1|                        &mut plain_text,
  597|      1|                        text,
  598|      1|                        InlineStyle {
  599|      1|                            strike: true,
  600|      1|                            strong: strong_override,
  601|      1|                            ..Default::default()
  602|      1|                        },
  603|      1|                        highlight.as_deref(),
  604|      1|                    );
  605|      1|                }
  606|    191|                InlineSpan::Text(text) => {
  607|    191|                    job_char_offset += self.append_plain_span(
  608|    191|                        style,
  609|    191|                        &mut job,
  610|    191|                        &mut plain_text,
  611|    191|                        text,
  612|    191|                        InlineStyle {
  613|    191|                            strong: strong_override,
  614|    191|                            ..Default::default()
  615|    191|                        },
  616|    191|                        highlight.as_deref(),
  617|    191|                    );
  618|    191|                }
  619|       |            }
  620|       |        }
  621|       |
  622|    177|        LayoutJobBuild {
  623|    177|            job,
  624|    177|            plain_text,
  625|    177|            link_ranges,
  626|    177|        }
  627|    177|    }
  628|       |
  629|    201|    fn append_plain_span(
  630|    201|        &self,
  631|    201|        style: &egui::Style,
  632|    201|        job: &mut LayoutJob,
  633|    201|        plain_text: &mut String,
  634|    201|        text: &str,
  635|    201|        inline_style: InlineStyle,
  636|    201|        highlight: Option<&str>,
  637|    201|    ) -> usize {
  638|    201|        if text.is_empty() {
  ------------------
  |  Branch (638:12): [True: 1, False: 200]
  ------------------
  639|      1|            return 0;
  640|    200|        }
  641|    200|        let mut normalized = self.fix_unicode_chars(text);
  642|    200|        normalized = Self::expand_shortcodes(&normalized);
  643|    200|        normalized = Self::expand_superscripts(&normalized);
  644|    200|        self.append_text_sections(
  645|    200|            style,
  646|    200|            job,
  647|    200|            plain_text,
  648|    200|            &normalized,
  649|    200|            self.font_sizes.body,
  650|    200|            inline_style,
  651|    200|            highlight,
  652|       |        )
  653|    201|    }
  654|       |
  655|      3|    fn append_code_span(
  656|      3|        &self,
  657|      3|        style: &egui::Style,
  658|      3|        job: &mut LayoutJob,
  659|      3|        plain_text: &mut String,
  660|      3|        code: &str,
  661|      3|    ) -> usize {
  662|      3|        if code.is_empty() {
  ------------------
  |  Branch (662:12): [True: 1, False: 2]
  ------------------
  663|      1|            return 0;
  664|      2|        }
  665|      2|        plain_text.push_str(code);
  666|      2|        let visuals = &style.visuals;
  667|      2|        let (bg, fg) = if visuals.dark_mode {
  ------------------
  |  Branch (667:27): [True: 1, False: 1]
  ------------------
  668|      1|            (
  669|      1|                Color32::from_rgb(30, 30, 30),
  670|      1|                Color32::from_rgb(180, 255, 180),
  671|      1|            )
  672|       |        } else {
  673|      1|            (Color32::WHITE, Color32::from_rgb(60, 80, 150))
  674|       |        };
  675|      2|        let rich = RichText::new(code.to_string())
  676|      2|            .size(self.font_sizes.code)
  677|      2|            .monospace()
  678|      2|            .background_color(bg)
  679|      2|            .color(fg);
  680|      2|        rich.append_to(job, style, FontSelection::Default, Align::LEFT);
  681|      2|        code.chars().count()
  682|      3|    }
  683|       |
  684|       |    #[allow(clippy::too_many_arguments)]
  685|    213|    fn append_text_sections(
  686|    213|        &self,
  687|    213|        style: &egui::Style,
  688|    213|        job: &mut LayoutJob,
  689|    213|        plain_text: &mut String,
  690|    213|        text: &str,
  691|    213|        font_size: f32,
  692|    213|        inline_style: InlineStyle,
  693|    213|        highlight: Option<&str>,
  694|    213|    ) -> usize {
  695|    213|        if text.is_empty() {
  ------------------
  |  Branch (695:12): [True: 2, False: 211]
  ------------------
  696|      2|            return 0;
  697|    211|        }
  698|    211|        plain_text.push_str(text);
  699|    211|        let char_count = text.chars().count();
  700|    211|        let visuals = &style.visuals;
  701|    211|        let segments = self.highlight_segments(text, highlight);
  702|    425|        for (range, highlighted) in segments {
                           ^214   ^214
  703|    214|            let slice = &text[range];
  704|    214|            let mut rich = RichText::new(slice.to_string()).size(font_size);
  705|    214|            if inline_style.strong {
  ------------------
  |  Branch (705:16): [True: 88, False: 126]
  ------------------
  706|     88|                rich = rich.strong();
  707|    126|            }
  708|    214|            if inline_style.italics {
  ------------------
  |  Branch (708:16): [True: 1, False: 213]
  ------------------
  709|      1|                rich = rich.italics();
  710|    213|            }
  711|    214|            if inline_style.strike {
  ------------------
  |  Branch (711:16): [True: 1, False: 213]
  ------------------
  712|      1|                rich = rich.strikethrough();
  713|    213|            }
  714|    214|            let mut text_color = inline_style.color;
  715|    214|            if highlighted {
  ------------------
  |  Branch (715:16): [True: 3, False: 211]
  ------------------
  716|      3|                rich = rich.background_color(visuals.selection.bg_fill);
  717|      3|                if text_color.is_none() {
  ------------------
  |  Branch (717:20): [True: 2, False: 1]
  ------------------
  718|      2|                    text_color = Some(visuals.selection.stroke.color);
  719|      2|                }
                              ^1
  720|    211|            } else if text_color.is_none() && inline_style.strong {
                                                            ^201
  ------------------
  |  Branch (720:23): [True: 201, False: 10]
  |  Branch (720:47): [True: 88, False: 113]
  ------------------
  721|     88|                if let Some(override_color) = visuals.override_text_color {
                                          ^1
  ------------------
  |  Branch (721:24): [True: 1, False: 87]
  ------------------
  722|      1|                    text_color = Some(override_color);
  723|     87|                }
  724|    123|            }
  725|    214|            if let Some(color) = text_color {
                                      ^14
  ------------------
  |  Branch (725:20): [True: 14, False: 200]
  ------------------
  726|     14|                rich = rich.color(color);
  727|    200|            }
  728|    214|            rich.append_to(job, style, FontSelection::Default, Align::LEFT);
  729|       |        }
  730|    211|        char_count
  731|    213|    }
  732|       |
  733|       |    /// Create a new markdown renderer
  734|    269|    pub fn new() -> Self {
  735|    269|        let mermaid = MermaidRenderer::new();
  736|    269|        let (image_job_tx, image_job_rx) = bounded(IMAGE_MAX_PENDING.max(1));
  737|    269|        let (image_result_tx, image_result_rx) = bounded(IMAGE_MAX_PENDING.max(1) * 2);
  738|    269|        Self::spawn_image_loader(image_job_rx, image_result_tx);
  739|    269|        Self {
  740|    269|            font_sizes: FontSizes::default(),
  741|    269|            syntax_set: SyntaxSet::load_defaults_newlines(),
  742|    269|            theme_set: ThemeSet::load_defaults(),
  743|    269|            emoji_textures: RefCell::new(HashMap::new()),
  744|    269|            image_textures: RefCell::new(ImageCache::new(IMAGE_TEXTURE_CACHE_CAPACITY)),
  745|    269|            image_pending: RefCell::new(HashSet::new()),
  746|    269|            image_failures: RefCell::new(HashMap::new()),
  747|    269|            image_job_tx,
  748|    269|            image_result_rx,
  749|    269|            header_rects: RefCell::new(HashMap::new()),
  750|    269|            pending_anchor: RefCell::new(None),
  751|    269|            link_counter: RefCell::new(0),
  752|    269|            table_counter: RefCell::new(0),
  753|    269|            element_rects: RefCell::new(Vec::new()),
  754|    269|            highlight_phrase: RefCell::new(None),
  755|    269|            base_dir: RefCell::new(None),
  756|    269|            mermaid,
  757|    269|            table_layout_cache: RefCell::new(CellLayoutCache::new(TABLE_LAYOUT_CACHE_CAPACITY)),
  758|    269|            table_metrics: RefCell::new(TableMetrics::default()),
  759|    269|            column_stats_cache: RefCell::new(HashMap::new()),
  760|    269|        }
  761|    269|    }
  762|       |
  763|    270|    fn spawn_image_loader(job_rx: Receiver<ImageLoadRequest>, result_tx: Sender<ImageLoadResult>) {
  764|    270|        if let Err(err) = std::thread::Builder::new()
                                 ^0
  ------------------
  |  Branch (764:16): [True: 0, False: 270]
  ------------------
  765|    270|            .name("mdmdview-image-loader".to_string())
  766|    270|            .spawn(move || {
  767|    270|                for request in job_rx.iter() {
                                  ^12
  768|     12|                    let ImageLoadRequest { key, source } = request;
  769|     12|                    let result = match source {
  770|      8|                        ImageLoadSource::Embedded(bytes) => {
  771|      8|                            match image_decode::bytes_to_color_image_guess(bytes, None) {
  772|      8|                                Some((image, w, h)) => ImageLoadResult::Loaded {
  773|      8|                                    key,
  774|      8|                                    image,
  775|      8|                                    size: [w, h],
  776|      8|                                    modified: None,
  777|      8|                                },
  778|      0|                                None => ImageLoadResult::Failed { key },
  779|       |                            }
  780|       |                        }
  781|      4|                        ImageLoadSource::File(path) => {
  782|      4|                            if !path.exists() {
  ------------------
  |  Branch (782:32): [True: 1, False: 3]
  ------------------
  783|      1|                                ImageLoadResult::Failed { key }
  784|       |                            } else {
  785|      3|                                match std::fs::read(&path) {
  786|      3|                                    Ok(bytes) => {
  787|      3|                                        let modified = Self::disk_image_timestamp(&path);
  788|      3|                                        match image_decode::bytes_to_color_image_guess(&bytes, None)
  789|       |                                        {
  790|      3|                                            Some((image, w, h)) => ImageLoadResult::Loaded {
  791|      3|                                                key,
  792|      3|                                                image,
  793|      3|                                                size: [w, h],
  794|      3|                                                modified,
  795|      3|                                            },
  796|      0|                                            None => ImageLoadResult::Failed { key },
  797|       |                                        }
  798|       |                                    }
  799|      0|                                    Err(_) => ImageLoadResult::Failed { key },
  800|       |                                }
  801|       |                            }
  802|       |                        }
  803|       |                    };
  804|     12|                    let _ = result_tx.send(result);
  805|       |                }
  806|    270|            })
  807|      0|        {
  808|      0|            eprintln!("Failed to start image loader thread: {err}");
  809|    270|        }
  810|    270|    }
  811|       |
  812|       |    /// UI scale factor derived from body font size relative to default.
  813|       |    /// Used to scale non-text elements (e.g., images) consistently with zoom.
  814|     10|    fn ui_scale(&self) -> f32 {
  815|     10|        let default_body = FontSizes::default().body;
  816|     10|        (self.font_sizes.body / default_body).clamp(0.5, 4.0)
  817|     10|    }
  818|       |
  819|       |    /// Get current font sizes
  820|      2|    pub fn font_sizes(&self) -> &FontSizes {
  821|      2|        &self.font_sizes
  822|      2|    }
  823|       |
  824|    250|    fn escape_table_pipes_in_inline_code(markdown: &str) -> String {
  825|    250|        let mut out = String::with_capacity(markdown.len());
  826|    250|        let mut in_table = false;
  827|    250|        let mut table_blockquote_level: Option<usize> = None;
  828|    250|        let mut table_list_indent: Option<usize> = None;
  829|    250|        let mut in_fenced_block = false;
  830|    250|        let mut fence_char = '\0';
  831|    250|        let mut fence_len = 0usize;
  832|    250|        let mut fence_blockquote_level: Option<usize> = None;
  833|       |
  834|    250|        let lines: Vec<&str> = markdown.split_inclusive('\n').collect();
  835|    250|        let mut i = 0;
  836|  4.75k|        while i < lines.len() {
  ------------------
  |  Branch (836:15): [True: 4.50k, False: 250]
  ------------------
  837|  4.50k|            let line = lines[i];
  838|  4.50k|            let (blockquote_level, rest) = Self::table_line_info(line);
  839|  4.50k|            let list_info = Self::list_marker_info(rest);
  840|  4.50k|            let mut list_indent = list_info.map(|(_, _, content_indent)| content_indent);
  841|  4.50k|            let mut list_stripped = list_info.map(|(content, _, _)| content).unwrap_or(rest);
  842|  4.50k|            let mut list_marker_present = list_info.is_some();
  843|  4.50k|            let mut parent_list_indent = None;
  844|       |
  845|  4.50k|            if !list_marker_present && i > 0 {
                                                     ^3.07k
  ------------------
  |  Branch (845:16): [True: 3.07k, False: 1.43k]
  |  Branch (845:40): [True: 2.85k, False: 219]
  ------------------
  846|  2.85k|                parent_list_indent =
  847|  2.85k|                    Self::parent_list_indent_for_line(&lines, i, blockquote_level, rest);
  848|  2.85k|                if let Some(parent_indent) = parent_list_indent {
                                          ^61
  ------------------
  |  Branch (848:24): [True: 61, False: 2.79k]
  ------------------
  849|     11|                    if let Some((content, _indent_after, content_indent, leading_spaces)) =
  ------------------
  |  Branch (849:28): [True: 11, False: 50]
  ------------------
  850|     61|                        Self::list_marker_info_any_indent(rest)
  851|       |                    {
  852|     11|                        if leading_spaces >= parent_indent && leading_spaces < parent_indent + 4 {
  ------------------
  |  Branch (852:28): [True: 11, False: 0]
  |  Branch (852:63): [True: 9, False: 2]
  ------------------
  853|      9|                            list_marker_present = true;
  854|      9|                            list_indent = Some(content_indent);
  855|      9|                            list_stripped = content;
  856|      9|                        }
                                      ^2
  857|     50|                    }
  858|     61|                    if list_indent.is_none() {
  ------------------
  |  Branch (858:24): [True: 52, False: 9]
  ------------------
  859|     52|                        let strip = Self::strip_indent_columns(rest, parent_indent);
  860|     52|                        let code_strip = Self::strip_indent_columns(rest, parent_indent + 4);
  861|     52|                        if strip.is_some() && code_strip.is_none() {
  ------------------
  |  Branch (861:28): [True: 52, False: 0]
  |  Branch (861:47): [True: 46, False: 6]
  ------------------
  862|     46|                            list_indent = Some(parent_indent);
  863|     46|                        }
                                      ^6
  864|      9|                    }
  865|  2.79k|                }
  866|  1.65k|            }
  867|  4.50k|            let (fence_line_level, fence_line_rest) = if list_marker_present {
  ------------------
  |  Branch (867:58): [True: 1.44k, False: 3.06k]
  ------------------
  868|  1.44k|                let (nested_level, nested_rest) = Self::table_line_info(list_stripped);
  869|  1.44k|                (blockquote_level + nested_level, nested_rest)
  870|       |            } else {
  871|  3.06k|                Self::table_line_info_with_list(line, list_indent)
  872|       |            };
  873|  4.50k|            let trimmed_fence = fence_line_rest.trim_start();
  874|       |
  875|  4.50k|            if in_fenced_block {
  ------------------
  |  Branch (875:16): [True: 120, False: 4.38k]
  ------------------
  876|    120|                let fence_end = fence_blockquote_level == Some(fence_line_level)
  ------------------
  |  Branch (876:33): [True: 119, False: 1]
  ------------------
  877|    119|                    && Self::is_fence_end(trimmed_fence, fence_char, fence_len);
  878|    120|                if fence_end {
  ------------------
  |  Branch (878:20): [True: 16, False: 104]
  ------------------
  879|     16|                    in_fenced_block = false;
  880|     16|                    fence_char = '\0';
  881|     16|                    fence_len = 0;
  882|     16|                    fence_blockquote_level = None;
  883|    104|                }
  884|    120|                out.push_str(line);
  885|    120|                i += 1;
  886|    120|                continue;
  887|  4.38k|            }
  888|       |
  889|  4.38k|            if let Some((ch, len)) = Self::fence_start(trimmed_fence) {
                                       ^16 ^16
  ------------------
  |  Branch (889:20): [True: 16, False: 4.36k]
  ------------------
  890|     16|                in_fenced_block = true;
  891|     16|                fence_char = ch;
  892|     16|                fence_len = len;
  893|     16|                fence_blockquote_level = Some(fence_line_level);
  894|     16|                out.push_str(line);
  895|     16|                i += 1;
  896|     16|                continue;
  897|  4.36k|            }
  898|       |
  899|  4.36k|            if in_table {
  ------------------
  |  Branch (899:16): [True: 173, False: 4.19k]
  ------------------
  900|    173|                if let Some((level, rest)) = Self::table_line_info_in_list(line, table_list_indent)
                                           ^169   ^169
  ------------------
  |  Branch (900:24): [True: 169, False: 4]
  ------------------
  901|       |                {
  902|    169|                    if table_blockquote_level == Some(level) {
  ------------------
  |  Branch (902:24): [True: 168, False: 1]
  ------------------
  903|    168|                        let candidate = Some(rest);
  904|    168|                        if candidate.is_some_and(Self::is_table_row_candidate) {
  ------------------
  |  Branch (904:28): [True: 151, False: 17]
  ------------------
  905|    151|                            out.push_str(&Self::escape_pipes_in_inline_code_line(line));
  906|    151|                            i += 1;
  907|    151|                            continue;
  908|     17|                        }
  909|      1|                    }
  910|      4|                }
  911|     22|                in_table = false;
  912|     22|                table_blockquote_level = None;
  913|     22|                table_list_indent = None;
  914|     22|                out.push_str(line);
  915|     22|                i += 1;
  916|     22|                continue;
  917|  4.19k|            }
  918|       |
  919|  4.19k|            if i + 1 < lines.len() {
  ------------------
  |  Branch (919:16): [True: 3.99k, False: 204]
  ------------------
  920|  3.99k|                let mut header_line = if list_marker_present {
  ------------------
  |  Branch (920:42): [True: 1.43k, False: 2.55k]
  ------------------
  921|  1.43k|                    Some(list_stripped)
  922|       |                } else {
  923|  2.55k|                    Some(rest)
  924|       |                };
  925|  3.99k|                let mut header_from_list_marker = list_marker_present;
  926|       |
  927|  3.99k|                if !list_marker_present {
  ------------------
  |  Branch (927:20): [True: 2.55k, False: 1.43k]
  ------------------
  928|  2.55k|                    if let Some(parent_indent) = parent_list_indent {
                                              ^13
  ------------------
  |  Branch (928:28): [True: 13, False: 2.54k]
  ------------------
  929|      2|                        if let Some((content, _indent_after, content_indent, leading_spaces)) =
  ------------------
  |  Branch (929:32): [True: 2, False: 11]
  ------------------
  930|     13|                            Self::list_marker_info_any_indent(rest)
  931|       |                        {
  932|      2|                            if leading_spaces >= parent_indent && leading_spaces < parent_indent + 4
  ------------------
  |  Branch (932:32): [True: 2, False: 0]
  |  Branch (932:67): [True: 0, False: 2]
  ------------------
  933|      0|                            {
  934|      0|                                list_indent = Some(content_indent);
  935|      0|                                header_line = Some(content);
  936|      0|                                header_from_list_marker = true;
  937|      2|                            }
  938|     11|                        }
  939|     13|                        if list_indent.is_none() {
  ------------------
  |  Branch (939:28): [True: 4, False: 9]
  ------------------
  940|      4|                            let strip = Self::strip_indent_columns(rest, parent_indent);
  941|      4|                            let code_strip = Self::strip_indent_columns(rest, parent_indent + 4);
  942|      4|                            if strip.is_some() && code_strip.is_none() {
  ------------------
  |  Branch (942:32): [True: 4, False: 0]
  |  Branch (942:51): [True: 0, False: 4]
  ------------------
  943|      0|                                list_indent = Some(parent_indent);
  944|      0|                                header_line = strip;
  945|      4|                            }
  946|      9|                        }
  947|  2.54k|                    }
  948|  1.43k|                }
  949|       |
  950|  3.99k|                let (level, rest) = if list_marker_present {
  ------------------
  |  Branch (950:40): [True: 1.43k, False: 2.55k]
  ------------------
  951|  1.43k|                    let (nested_level, nested_rest) = Self::table_line_info(list_stripped);
  952|  1.43k|                    (blockquote_level + nested_level, nested_rest)
  953|       |                } else {
  954|  2.55k|                    Self::table_line_info_with_list(line, list_indent)
  955|       |                };
  956|  3.99k|                let next_info = if list_indent.is_some() {
  ------------------
  |  Branch (956:36): [True: 1.44k, False: 2.54k]
  ------------------
  957|  1.44k|                    Self::table_line_info_in_list(lines[i + 1], list_indent)
  958|       |                } else {
  959|  2.54k|                    Some(Self::table_line_info(lines[i + 1]))
  960|       |                };
  961|  3.99k|                if let Some(line) = header_line {
  ------------------
  |  Branch (961:24): [True: 3.99k, False: 0]
  ------------------
  962|  3.99k|                    if header_from_list_marker {
  ------------------
  |  Branch (962:24): [True: 1.43k, False: 2.55k]
  ------------------
  963|  1.43k|                        let (_, stripped) = Self::table_line_info(line);
  964|  1.43k|                        header_line = Some(stripped);
  965|  2.55k|                    } else {
  966|  2.55k|                        header_line = Some(rest);
  967|  2.55k|                    }
  968|      0|                }
  969|       |
  970|  3.99k|                if let Some((next_level, next_rest)) = next_info {
                                           ^2.59k      ^2.59k
  ------------------
  |  Branch (970:24): [True: 2.59k, False: 1.39k]
  ------------------
  971|  2.59k|                    if level == next_level && header_line.is_some_and(Self::is_table_row_candidate)
                                                            ^2.57k      ^2.57k
  ------------------
  |  Branch (971:24): [True: 2.57k, False: 19]
  |  Branch (971:47): [True: 61, False: 2.51k]
  ------------------
  972|       |                    {
  973|     61|                        let delimiter_line = Some(next_rest);
  974|     61|                        if delimiter_line.is_some_and(Self::is_table_delimiter_line) {
  ------------------
  |  Branch (974:28): [True: 55, False: 6]
  ------------------
  975|     55|                            if !header_from_list_marker && i > 0 {
                                                                         ^42
  ------------------
  |  Branch (975:32): [True: 42, False: 13]
  |  Branch (975:60): [True: 29, False: 13]
  ------------------
  976|     29|                                let (prev_level, prev_rest) =
  977|     29|                                    Self::table_line_info_with_list(lines[i - 1], list_indent);
  978|     29|                                if prev_level == level && !prev_rest.trim().is_empty() {
                                                                        ^28
  ------------------
  |  Branch (978:36): [True: 28, False: 1]
  |  Branch (978:59): [True: 7, False: 21]
  ------------------
  979|      7|                                    let prefix_len = line.len().saturating_sub(rest.len());
  980|      7|                                    out.push_str(&line[..prefix_len]);
  981|      7|                                    let newline =
  982|      7|                                        if line.ends_with("\r\n") { "\r\n" } else { "\n" };
                                                                                  ^1              ^6
  ------------------
  |  Branch (982:44): [True: 1, False: 6]
  ------------------
  983|      7|                                    out.push_str(newline);
  984|     22|                                }
  985|     26|                            }
  986|     55|                            out.push_str(&Self::escape_pipes_in_inline_code_line(line));
  987|     55|                            out.push_str(lines[i + 1]);
  988|     55|                            in_table = true;
  989|     55|                            table_blockquote_level = Some(level);
  990|     55|                            table_list_indent = list_indent;
  991|     55|                            i += 2;
  992|     55|                            continue;
  993|      6|                        }
  994|  2.53k|                    }
  995|  1.39k|                }
  996|    204|            }
  997|       |
  998|  4.14k|            out.push_str(line);
  999|  4.14k|            i += 1;
 1000|       |        }
 1001|       |
 1002|    250|        out
 1003|    250|    }
 1004|       |
 1005|    210|    fn escape_pipes_in_inline_code_line(line: &str) -> String {
 1006|    210|        if !line.contains('|') || !line.contains('`') {
                                                ^209
  ------------------
  |  Branch (1006:12): [True: 1, False: 209]
  |  Branch (1006:35): [True: 111, False: 98]
  ------------------
 1007|    112|            return line.to_string();
 1008|     98|        }
 1009|     98|        let mut out: Vec<char> = Vec::with_capacity(line.len());
 1010|     98|        let mut in_code = false;
 1011|     98|        let mut delimiter_len = 0usize;
 1012|     98|        let mut pending_pipes: Vec<usize> = Vec::new();
 1013|     98|        let mut backslash_run = 0usize;
 1014|     98|        let mut chars = line.chars().peekable();
 1015|       |
 1016|  3.15k|        while let Some(ch) = chars.next() {
                                     ^3.05k
  ------------------
  |  Branch (1016:19): [True: 3.05k, False: 98]
  ------------------
 1017|  3.05k|            if ch == '\\' {
  ------------------
  |  Branch (1017:16): [True: 2, False: 3.05k]
  ------------------
 1018|      2|                backslash_run += 1;
 1019|      2|                out.push(ch);
 1020|      2|                continue;
 1021|  3.05k|            }
 1022|       |
 1023|  3.05k|            let escaped = !in_code && backslash_run % 2 == 1;
                                                    ^2.45k
  ------------------
  |  Branch (1023:27): [True: 2.45k, False: 600]
  ------------------
 1024|  3.05k|            backslash_run = 0;
 1025|       |
 1026|  3.05k|            if ch == '`' {
  ------------------
  |  Branch (1026:16): [True: 195, False: 2.85k]
  ------------------
 1027|    195|                if escaped {
  ------------------
  |  Branch (1027:20): [True: 2, False: 193]
  ------------------
 1028|      2|                    out.push('`');
 1029|      2|                    continue;
 1030|    193|                }
 1031|    193|                let mut run_len = 1usize;
 1032|    197|                while matches!(chars.peek(), Some('`')) {
                                    ^193
 1033|      4|                    chars.next();
 1034|      4|                    run_len += 1;
 1035|      4|                }
 1036|    193|                if in_code {
  ------------------
  |  Branch (1036:20): [True: 96, False: 97]
  ------------------
 1037|     96|                    if run_len == delimiter_len {
  ------------------
  |  Branch (1037:24): [True: 95, False: 1]
  ------------------
 1038|     95|                        in_code = false;
 1039|     95|                        delimiter_len = 0;
 1040|     95|                        pending_pipes.clear();
 1041|     95|                    }
                                  ^1
 1042|     97|                } else {
 1043|     97|                    in_code = true;
 1044|     97|                    delimiter_len = run_len;
 1045|     97|                    pending_pipes.clear();
 1046|     97|                }
 1047|    193|                out.extend(std::iter::repeat_n('`', run_len));
 1048|    193|                continue;
 1049|  2.85k|            }
 1050|       |
 1051|  2.85k|            if in_code && ch == '|' {
                                        ^504
  ------------------
  |  Branch (1051:16): [True: 504, False: 2.35k]
  |  Branch (1051:27): [True: 49, False: 455]
  ------------------
 1052|     49|                pending_pipes.push(out.len());
 1053|     49|                out.push(PIPE_SENTINEL);
 1054|  2.81k|            } else {
 1055|  2.81k|                out.push(ch);
 1056|  2.81k|            }
 1057|       |        }
 1058|       |
 1059|     98|        if in_code {
  ------------------
  |  Branch (1059:12): [True: 2, False: 96]
  ------------------
 1060|      5|            for idx in pending_pipes {
                              ^3
 1061|      3|                out[idx] = '|';
 1062|      3|            }
 1063|     96|        }
 1064|       |
 1065|     98|        out.into_iter().collect()
 1066|    210|    }
 1067|       |
 1068|     39|    fn is_html_line_break(html: &str) -> bool {
 1069|     39|        let trimmed = html.trim();
 1070|     39|        if trimmed.len() < 4 {
  ------------------
  |  Branch (1070:12): [True: 3, False: 36]
  ------------------
 1071|      3|            return false;
 1072|     36|        }
 1073|     36|        let normalized = trimmed.to_ascii_lowercase();
 1074|     36|        if !normalized.starts_with("<br") || !normalized.ends_with('>') {
                                                           ^31
  ------------------
  |  Branch (1074:12): [True: 5, False: 31]
  |  Branch (1074:46): [True: 1, False: 30]
  ------------------
 1075|      6|            return false;
 1076|     30|        }
 1077|     30|        let rest = &normalized[3..];
 1078|     30|        let first = rest.chars().next();
 1079|      7|        match first {
 1080|     19|            Some('>') => true,
 1081|      4|            Some('/') => rest[1..].trim_start().starts_with('>'),
 1082|      7|            Some(ch) if ch.is_whitespace() => true,
                               ^6                      ^6   ^6
  ------------------
  |  Branch (1082:25): [True: 6, False: 1]
  ------------------
 1083|      1|            _ => false,
 1084|       |        }
 1085|     39|    }
 1086|       |
 1087|     37|    fn tab_advance(col: usize) -> usize {
 1088|     37|        let rem = col % 4;
 1089|     37|        if rem == 0 {
  ------------------
  |  Branch (1089:12): [True: 34, False: 3]
  ------------------
 1090|     34|            4
 1091|       |        } else {
 1092|      3|            4 - rem
 1093|       |        }
 1094|     37|    }
 1095|       |
 1096|  2.80k|    fn is_indented_code_line(line: &str) -> bool {
 1097|  2.80k|        let mut col = 0usize;
 1098|  2.84k|        for ch in line.chars() {
                                ^2.80k^2.80k
 1099|  2.84k|            match ch {
 1100|       |                ' ' => {
 1101|     39|                    col += 1;
 1102|     39|                    if col >= 4 {
  ------------------
  |  Branch (1102:24): [True: 8, False: 31]
  ------------------
 1103|      8|                        return true;
 1104|     31|                    }
 1105|       |                }
 1106|       |                '\t' => {
 1107|      1|                    col += Self::tab_advance(col);
 1108|      1|                    return col >= 4;
 1109|       |                }
 1110|  2.80k|                _ => break,
 1111|       |            }
 1112|       |        }
 1113|  2.80k|        col >= 4
 1114|  2.80k|    }
 1115|       |
 1116|  26.4k|    fn table_line_info(line: &str) -> (usize, &str) {
 1117|  26.4k|        let mut rest = line;
 1118|  26.4k|        let mut level = 0usize;
 1119|       |        loop {
 1120|  26.8k|            let bytes = rest.as_bytes();
 1121|  26.8k|            let mut idx = 0usize;
 1122|  28.6k|            while idx < bytes.len() && idx < 3 && bytes[idx] == b' ' {
                                                     ^28.6k     ^28.1k
  ------------------
  |  Branch (1122:19): [True: 28.6k, False: 1]
  |  Branch (1122:40): [True: 28.1k, False: 519]
  |  Branch (1122:51): [True: 1.85k, False: 26.3k]
  ------------------
 1123|  1.85k|                idx += 1;
 1124|  1.85k|            }
 1125|  26.8k|            if idx < bytes.len() && bytes[idx] == b'>' {
                                                  ^26.8k
  ------------------
  |  Branch (1125:16): [True: 26.8k, False: 1]
  |  Branch (1125:37): [True: 386, False: 26.4k]
  ------------------
 1126|    386|                idx += 1;
 1127|    386|                if idx < bytes.len() && (bytes[idx] == b' ' || bytes[idx] == b'\t') {
                                                       ^385                  ^40
  ------------------
  |  Branch (1127:20): [True: 385, False: 1]
  |  Branch (1127:42): [True: 345, False: 40]
  |  Branch (1127:64): [True: 10, False: 30]
  ------------------
 1128|    355|                    idx += 1;
 1129|    355|                }
                              ^31
 1130|    386|                level += 1;
 1131|    386|                rest = &rest[idx..];
 1132|    386|                continue;
 1133|  26.4k|            }
 1134|  26.4k|            break;
 1135|       |        }
 1136|  26.4k|        (level, rest)
 1137|  26.4k|    }
 1138|       |
 1139|  5.64k|    fn table_line_info_with_list(line: &str, list_indent: Option<usize>) -> (usize, &str) {
 1140|  5.64k|        let (level, rest) = Self::table_line_info(line);
 1141|  5.64k|        if let Some(indent) = list_indent {
                                  ^63
  ------------------
  |  Branch (1141:16): [True: 63, False: 5.58k]
  ------------------
 1142|     63|            if let Some(stripped) = Self::strip_indent_columns(rest, indent) {
                                      ^56
  ------------------
  |  Branch (1142:20): [True: 56, False: 7]
  ------------------
 1143|     56|                let (nested_level, nested_rest) = Self::table_line_info(stripped);
 1144|     56|                return (level + nested_level, nested_rest);
 1145|      7|            }
 1146|      7|            if let Some(stripped) = Self::strip_indent_columns(line, indent) {
                                      ^1
  ------------------
  |  Branch (1146:20): [True: 1, False: 6]
  ------------------
 1147|      1|                return Self::table_line_info(stripped);
 1148|      6|            }
 1149|  5.58k|        }
 1150|  5.59k|        (level, rest)
 1151|  5.64k|    }
 1152|       |
 1153|  1.61k|    fn table_line_info_in_list(line: &str, list_indent: Option<usize>) -> Option<(usize, &str)> {
 1154|  1.61k|        let (level, rest) = Self::table_line_info(line);
 1155|  1.61k|        if let Some(indent) = list_indent {
                                  ^1.47k
  ------------------
  |  Branch (1155:16): [True: 1.47k, False: 149]
  ------------------
 1156|  1.47k|            if let Some(stripped) = Self::strip_indent_columns(rest, indent) {
                                      ^68
  ------------------
  |  Branch (1156:20): [True: 68, False: 1.40k]
  ------------------
 1157|     68|                let (nested_level, nested_rest) = Self::table_line_info(stripped);
 1158|     68|                return Some((level + nested_level, nested_rest));
 1159|  1.40k|            }
 1160|  1.40k|            let stripped = Self::strip_indent_columns(line, indent)?;
                              ^2                                                 ^1.40k
 1161|      2|            return Some(Self::table_line_info(stripped));
 1162|    149|        }
 1163|    149|        Some((level, rest))
 1164|  1.61k|    }
 1165|       |
 1166|  10.4k|    fn list_marker_info(line: &str) -> Option<(&str, usize, usize)> {
 1167|  10.4k|        let bytes = line.as_bytes();
 1168|  10.4k|        let mut idx = 0usize;
 1169|  10.4k|        let mut spaces = 0usize;
 1170|  11.5k|        while idx < bytes.len() && spaces < 3 && bytes[idx] == b' ' {
                                                 ^11.5k        ^11.2k
  ------------------
  |  Branch (1170:15): [True: 11.5k, False: 2]
  |  Branch (1170:36): [True: 11.2k, False: 348]
  |  Branch (1170:50): [True: 1.17k, False: 10.0k]
  ------------------
 1171|  1.17k|            idx += 1;
 1172|  1.17k|            spaces += 1;
 1173|  1.17k|        }
 1174|  10.4k|        if idx < bytes.len() && bytes[idx] == b'\t' {
                                              ^10.4k
  ------------------
  |  Branch (1174:12): [True: 10.4k, False: 2]
  |  Branch (1174:33): [True: 15, False: 10.4k]
  ------------------
 1175|     15|            return None;
 1176|  10.4k|        }
 1177|  10.4k|        if idx >= bytes.len() {
  ------------------
  |  Branch (1177:12): [True: 2, False: 10.4k]
  ------------------
 1178|      2|            return None;
 1179|  10.4k|        }
 1180|  10.4k|        let marker_start = idx;
 1181|  10.4k|        match bytes[idx] {
 1182|  3.55k|            b'-' | b'+' | b'*' => {
 1183|  3.55k|                idx += 1;
 1184|  3.55k|            }
 1185|  3.03k|            b'0'..=b'9' => {
 1186|  2.83k|                while idx < bytes.len() && bytes[idx].is_ascii_digit() {
                                                         ^2.83k     ^2.83k
  ------------------
  |  Branch (1186:23): [True: 2.83k, False: 1]
  |  Branch (1186:44): [True: 1.42k, False: 1.41k]
  ------------------
 1187|  1.42k|                    idx += 1;
 1188|  1.42k|                }
 1189|  1.41k|                if idx < bytes.len() && (bytes[idx] == b'.' || bytes[idx] == b')') {
                                                       ^1.41k                ^10
  ------------------
  |  Branch (1189:20): [True: 1.41k, False: 1]
  |  Branch (1189:42): [True: 1.40k, False: 10]
  |  Branch (1189:64): [True: 2, False: 8]
  ------------------
 1190|  1.40k|                    idx += 1;
 1191|  1.40k|                } else {
 1192|      9|                    return None;
 1193|       |                }
 1194|       |            }
 1195|  5.43k|            _ => return None,
 1196|       |        }
 1197|  4.96k|        let marker_width = idx.saturating_sub(marker_start);
 1198|  4.96k|        let mut indent = 0usize;
 1199|  4.96k|        let mut has_ws = false;
 1200|  4.96k|        let mut col = spaces + marker_width;
 1201|  9.26k|        while idx < bytes.len() {
  ------------------
  |  Branch (1201:15): [True: 9.26k, False: 0]
  ------------------
 1202|  9.26k|            match bytes[idx] {
 1203|  4.30k|                b' ' => {
 1204|  4.30k|                    indent += 1;
 1205|  4.30k|                    col += 1;
 1206|  4.30k|                    idx += 1;
 1207|  4.30k|                    has_ws = true;
 1208|  4.30k|                }
 1209|      1|                b'\t' => {
 1210|      1|                    let advance = Self::tab_advance(col);
 1211|      1|                    indent += advance;
 1212|      1|                    col += advance;
 1213|      1|                    idx += 1;
 1214|      1|                    has_ws = true;
 1215|      1|                }
 1216|  4.96k|                _ => break,
 1217|       |            }
 1218|       |        }
 1219|  4.96k|        if !has_ws {
  ------------------
  |  Branch (1219:12): [True: 665, False: 4.29k]
  ------------------
 1220|    665|            return None;
 1221|  4.29k|        }
 1222|  4.29k|        let content_indent = col;
 1223|  4.29k|        Some((&line[idx..], indent, content_indent))
 1224|  10.4k|    }
 1225|       |
 1226|  3.12k|    fn list_marker_info_any_indent(line: &str) -> Option<(&str, usize, usize, usize)> {
 1227|  3.12k|        let bytes = line.as_bytes();
 1228|  3.12k|        let mut idx = 0usize;
 1229|  3.12k|        let mut leading_cols = 0usize;
 1230|  4.89k|        while idx < bytes.len() {
  ------------------
  |  Branch (1230:15): [True: 4.89k, False: 2]
  ------------------
 1231|  4.89k|            match bytes[idx] {
 1232|  1.75k|                b' ' => {
 1233|  1.75k|                    idx += 1;
 1234|  1.75k|                    leading_cols += 1;
 1235|  1.75k|                }
 1236|     15|                b'\t' => {
 1237|     15|                    let advance = Self::tab_advance(leading_cols);
 1238|     15|                    idx += 1;
 1239|     15|                    leading_cols += advance;
 1240|     15|                }
 1241|  3.12k|                _ => break,
 1242|       |            }
 1243|       |        }
 1244|  3.12k|        if idx >= bytes.len() {
  ------------------
  |  Branch (1244:12): [True: 2, False: 3.12k]
  ------------------
 1245|      2|            return None;
 1246|  3.12k|        }
 1247|  3.12k|        let marker_start = idx;
 1248|  3.12k|        match bytes[idx] {
 1249|    375|            b'-' | b'+' | b'*' => {
 1250|    375|                idx += 1;
 1251|    375|            }
 1252|  1.27k|            b'0'..=b'9' => {
 1253|     27|                while idx < bytes.len() && bytes[idx].is_ascii_digit() {
                                                         ^26        ^26
  ------------------
  |  Branch (1253:23): [True: 26, False: 1]
  |  Branch (1253:44): [True: 16, False: 10]
  ------------------
 1254|     16|                    idx += 1;
 1255|     16|                }
 1256|     11|                if idx < bytes.len() && (bytes[idx] == b'.' || bytes[idx] == b')') {
                                                       ^10                   ^7
  ------------------
  |  Branch (1256:20): [True: 10, False: 1]
  |  Branch (1256:42): [True: 3, False: 7]
  |  Branch (1256:64): [True: 2, False: 5]
  ------------------
 1257|      5|                    idx += 1;
 1258|      5|                } else {
 1259|      6|                    return None;
 1260|       |                }
 1261|       |            }
 1262|  2.74k|            _ => return None,
 1263|       |        }
 1264|    380|        let marker_width = idx.saturating_sub(marker_start);
 1265|    380|        let mut indent = 0usize;
 1266|    380|        let mut has_ws = false;
 1267|    380|        let mut col = leading_cols + marker_width;
 1268|    413|        while idx < bytes.len() {
  ------------------
  |  Branch (1268:15): [True: 411, False: 2]
  ------------------
 1269|    411|            match bytes[idx] {
 1270|     32|                b' ' => {
 1271|     32|                    indent += 1;
 1272|     32|                    col += 1;
 1273|     32|                    idx += 1;
 1274|     32|                    has_ws = true;
 1275|     32|                }
 1276|      1|                b'\t' => {
 1277|      1|                    let advance = Self::tab_advance(col);
 1278|      1|                    indent += advance;
 1279|      1|                    col += advance;
 1280|      1|                    idx += 1;
 1281|      1|                    has_ws = true;
 1282|      1|                }
 1283|    378|                _ => break,
 1284|       |            }
 1285|       |        }
 1286|    380|        if !has_ws {
  ------------------
  |  Branch (1286:12): [True: 347, False: 33]
  ------------------
 1287|    347|            return None;
 1288|     33|        }
 1289|     33|        let content_indent = col;
 1290|     33|        Some((&line[idx..], indent, content_indent, leading_cols))
 1291|  3.12k|    }
 1292|       |
 1293|  2.85k|    fn parent_list_indent_for_line(
 1294|  2.85k|        lines: &[&str],
 1295|  2.85k|        idx: usize,
 1296|  2.85k|        level: usize,
 1297|  2.85k|        line_rest: &str,
 1298|  2.85k|    ) -> Option<usize> {
 1299|  2.85k|        if idx == 0 {
  ------------------
  |  Branch (1299:12): [True: 1, False: 2.85k]
  ------------------
 1300|      1|            return None;
 1301|  2.85k|        }
 1302|  7.67k|        for back_idx in (0..idx).rev() {
                                       ^2.85k  ^2.85k
 1303|  7.67k|            let (prev_level, prev_rest) = Self::table_line_info(lines[back_idx]);
 1304|  7.67k|            if prev_level < level {
  ------------------
  |  Branch (1304:16): [True: 13, False: 7.65k]
  ------------------
 1305|     13|                break;
 1306|  7.65k|            }
 1307|  7.65k|            if prev_level > level {
  ------------------
  |  Branch (1307:16): [True: 33, False: 7.62k]
  ------------------
 1308|     33|                continue;
 1309|  7.62k|            }
 1310|  7.62k|            if prev_rest.trim().is_empty() {
  ------------------
  |  Branch (1310:16): [True: 1.72k, False: 5.89k]
  ------------------
 1311|  1.72k|                continue;
 1312|  5.89k|            }
 1313|  5.89k|            if let Some((_, _, content_indent)) = Self::list_marker_info(prev_rest) {
                                             ^2.85k
  ------------------
  |  Branch (1313:20): [True: 2.85k, False: 3.04k]
  ------------------
 1314|  2.85k|                if Self::strip_indent_columns(line_rest, content_indent).is_some() {
  ------------------
  |  Branch (1314:20): [True: 48, False: 2.81k]
  ------------------
 1315|     48|                    return Some(content_indent);
 1316|  2.81k|                }
 1317|     17|            } else if let Some((_, _, content_indent, _)) =
  ------------------
  |  Branch (1317:27): [True: 17, False: 3.02k]
  ------------------
 1318|  3.04k|                Self::list_marker_info_any_indent(prev_rest)
 1319|       |            {
 1320|     17|                if Self::strip_indent_columns(line_rest, content_indent).is_some() {
  ------------------
  |  Branch (1320:20): [True: 13, False: 4]
  ------------------
 1321|     13|                    return Some(content_indent);
 1322|      4|                }
 1323|  3.02k|            } else if !prev_rest.starts_with(' ') && !prev_rest.starts_with('\t') {
                                                                   ^2.77k
  ------------------
  |  Branch (1323:23): [True: 2.77k, False: 253]
  |  Branch (1323:54): [True: 2.76k, False: 4]
  ------------------
 1324|  2.76k|                break;
 1325|    257|            }
 1326|       |        }
 1327|  2.79k|        None
 1328|  2.85k|    }
 1329|       |
 1330|  5.93k|    fn strip_indent_columns(line: &str, indent: usize) -> Option<&str> {
 1331|  5.93k|        if indent == 0 {
  ------------------
  |  Branch (1331:12): [True: 1, False: 5.93k]
  ------------------
 1332|      1|            return Some(line);
 1333|  5.93k|        }
 1334|  5.93k|        let mut col = 0usize;
 1335|  5.93k|        let mut cut = 0usize;
 1336|  6.96k|        for (idx, ch) in line.char_indices() {
                                       ^5.93k^5.93k
 1337|  6.96k|            if col >= indent {
  ------------------
  |  Branch (1337:16): [True: 254, False: 6.70k]
  ------------------
 1338|    254|                break;
 1339|  6.70k|            }
 1340|  6.70k|            match ch {
 1341|  1.01k|                ' ' => {
 1342|  1.01k|                    col += 1;
 1343|  1.01k|                    cut = idx + ch.len_utf8();
 1344|  1.01k|                }
 1345|     19|                '\t' => {
 1346|     19|                    col += Self::tab_advance(col);
 1347|     19|                    cut = idx + ch.len_utf8();
 1348|     19|                }
 1349|  5.67k|                _ => return None,
 1350|       |            }
 1351|       |        }
 1352|    255|        if col >= indent {
  ------------------
  |  Branch (1352:12): [True: 254, False: 1]
  ------------------
 1353|    254|            Some(&line[cut..])
 1354|       |        } else {
 1355|      1|            None
 1356|       |        }
 1357|  5.93k|    }
 1358|       |
 1359|  1.35k|    fn has_pipe_outside_inline_code(line: &str) -> bool {
 1360|  1.35k|        if !line.contains('|') {
  ------------------
  |  Branch (1360:12): [True: 1.13k, False: 217]
  ------------------
 1361|  1.13k|            return false;
 1362|    217|        }
 1363|    217|        let mut in_code = false;
 1364|    217|        let mut delimiter_len = 0usize;
 1365|    217|        let mut backslash_run = 0usize;
 1366|    217|        let mut chars = line.chars().peekable();
 1367|       |
 1368|    412|        while let Some(ch) = chars.next() {
                                     ^408
  ------------------
  |  Branch (1368:19): [True: 408, False: 4]
  ------------------
 1369|    408|            if ch == '\\' {
  ------------------
  |  Branch (1369:16): [True: 2, False: 406]
  ------------------
 1370|      2|                backslash_run += 1;
 1371|      2|                continue;
 1372|    406|            }
 1373|       |
 1374|    406|            let escaped = !in_code && backslash_run % 2 == 1;
                                                    ^373
  ------------------
  |  Branch (1374:27): [True: 373, False: 33]
  ------------------
 1375|    406|            backslash_run = 0;
 1376|       |
 1377|    406|            if ch == '`' {
  ------------------
  |  Branch (1377:16): [True: 9, False: 397]
  ------------------
 1378|      9|                if escaped {
  ------------------
  |  Branch (1378:20): [True: 1, False: 8]
  ------------------
 1379|      1|                    continue;
 1380|      8|                }
 1381|      8|                let mut run_len = 1usize;
 1382|     11|                while matches!(chars.peek(), Some('`')) {
                                    ^8
 1383|      3|                    chars.next();
 1384|      3|                    run_len += 1;
 1385|      3|                }
 1386|      8|                if in_code {
  ------------------
  |  Branch (1386:20): [True: 4, False: 4]
  ------------------
 1387|      4|                    if run_len == delimiter_len {
  ------------------
  |  Branch (1387:24): [True: 3, False: 1]
  ------------------
 1388|      3|                        in_code = false;
 1389|      3|                        delimiter_len = 0;
 1390|      3|                    }
                                  ^1
 1391|      4|                } else {
 1392|      4|                    in_code = true;
 1393|      4|                    delimiter_len = run_len;
 1394|      4|                }
 1395|      8|                continue;
 1396|    397|            }
 1397|       |
 1398|    397|            if ch == '|' && !in_code && !escaped {
                                          ^218        ^214
  ------------------
  |  Branch (1398:16): [True: 218, False: 179]
  |  Branch (1398:29): [True: 214, False: 4]
  |  Branch (1398:41): [True: 213, False: 1]
  ------------------
 1399|    213|                return true;
 1400|    184|            }
 1401|       |        }
 1402|       |
 1403|      4|        false
 1404|  1.35k|    }
 1405|       |
 1406|  2.74k|    fn is_table_row_candidate(line: &str) -> bool {
 1407|  2.74k|        if Self::is_indented_code_line(line) {
  ------------------
  |  Branch (1407:12): [True: 7, False: 2.73k]
  ------------------
 1408|      7|            return false;
 1409|  2.73k|        }
 1410|  2.73k|        let trimmed_line = line.trim_end_matches(['\r', '\n']);
 1411|  2.73k|        if trimmed_line.trim().is_empty() {
  ------------------
  |  Branch (1411:12): [True: 1.39k, False: 1.34k]
  ------------------
 1412|  1.39k|            return false;
 1413|  1.34k|        }
 1414|  1.34k|        Self::has_pipe_outside_inline_code(trimmed_line)
 1415|  2.74k|    }
 1416|       |
 1417|     63|    fn is_table_delimiter_line(line: &str) -> bool {
 1418|     63|        if Self::is_indented_code_line(line) {
  ------------------
  |  Branch (1418:12): [True: 1, False: 62]
  ------------------
 1419|      1|            return false;
 1420|     62|        }
 1421|     62|        let trimmed = line.trim_end_matches(['\r', '\n']).trim();
 1422|     62|        if trimmed.is_empty() {
  ------------------
  |  Branch (1422:12): [True: 2, False: 60]
  ------------------
 1423|      2|            return false;
 1424|     60|        }
 1425|     60|        let mut has_dash = false;
 1426|     60|        let mut has_pipe = false;
 1427|    857|        for ch in trimmed.chars() {
                                ^60     ^60
 1428|    857|            match ch {
 1429|    463|                '-' => has_dash = true,
 1430|    169|                '|' => has_pipe = true,
 1431|    223|                ':' | ' ' | '\t' => {}
 1432|      2|                _ => return false,
 1433|       |            }
 1434|       |        }
 1435|     58|        has_dash && has_pipe
                                  ^57
  ------------------
  |  Branch (1435:9): [True: 57, False: 1]
  ------------------
 1436|     63|    }
 1437|       |
 1438|  4.38k|    fn fence_start(line: &str) -> Option<(char, usize)> {
 1439|  4.38k|        let trimmed = line.trim_start();
 1440|  4.38k|        let mut chars = trimmed.chars();
 1441|  4.38k|        let first = chars.next()?;
                          ^2.98k              ^1.40k
 1442|  2.98k|        if first != '`' && first != '~' {
                                         ^2.94k
  ------------------
  |  Branch (1442:12): [True: 2.94k, False: 42]
  |  Branch (1442:28): [True: 2.94k, False: 1]
  ------------------
 1443|  2.94k|            return None;
 1444|     43|        }
 1445|     43|        let mut count = 1usize;
 1446|     80|        for ch in chars {
                          ^77
 1447|     77|            if ch == first {
  ------------------
  |  Branch (1447:16): [True: 37, False: 40]
  ------------------
 1448|     37|                count += 1;
 1449|     37|            } else {
 1450|     40|                break;
 1451|       |            }
 1452|       |        }
 1453|     43|        if count >= 3 {
  ------------------
  |  Branch (1453:12): [True: 18, False: 25]
  ------------------
 1454|     18|            Some((first, count))
 1455|       |        } else {
 1456|     25|            None
 1457|       |        }
 1458|  4.38k|    }
 1459|       |
 1460|    122|    fn is_fence_end(line: &str, fence_char: char, fence_len: usize) -> bool {
 1461|    122|        let trimmed = line.trim_start();
 1462|    122|        let mut count = 0usize;
 1463|    161|        for ch in trimmed.chars() {
                                ^122    ^122
 1464|    161|            if ch == fence_char {
  ------------------
  |  Branch (1464:16): [True: 56, False: 105]
  ------------------
 1465|     56|                count += 1;
 1466|     56|            } else {
 1467|    105|                break;
 1468|       |            }
 1469|       |        }
 1470|    122|        count >= fence_len
 1471|    122|    }
 1472|       |
 1473|  2.93k|    fn restore_pipe_sentinel(text: &str) -> String {
 1474|  2.93k|        if text.contains(PIPE_SENTINEL) {
  ------------------
  |  Branch (1474:12): [True: 2, False: 2.93k]
  ------------------
 1475|      2|            text.chars()
 1476|      8|                .map(|ch| if ch == PIPE_SENTINEL { '|' } else { ch })
                               ^2                                ^3           ^5
  ------------------
  |  Branch (1476:30): [True: 3, False: 5]
  ------------------
 1477|      2|                .collect()
 1478|       |        } else {
 1479|  2.93k|            text.to_string()
 1480|       |        }
 1481|  2.93k|    }
 1482|       |
 1483|       |    /// Parse markdown content into elements with proper inline handling
 1484|    215|    pub fn parse(&self, markdown: &str) -> Result<Vec<MarkdownElement>, anyhow::Error> {
 1485|       |        #[cfg(test)]
 1486|    215|        if take_forced_parse_error() {
  ------------------
  |  Branch (1486:12): [True: 3, False: 212]
  ------------------
 1487|      3|            return Err(anyhow::anyhow!("forced parse error"));
 1488|    212|        }
 1489|       |
 1490|    212|        let mut options = Options::empty();
 1491|    212|        options.insert(Options::ENABLE_STRIKETHROUGH);
 1492|    212|        options.insert(Options::ENABLE_TABLES);
 1493|    212|        options.insert(Options::ENABLE_TASKLISTS);
 1494|       |
 1495|    212|        let prepared = Self::escape_table_pipes_in_inline_code(markdown);
 1496|    212|        let parser = Parser::new_ext(&prepared, options);
 1497|    212|        let mut elements = Vec::new();
 1498|    212|        let events = parser.collect::<Vec<_>>();
 1499|       |
 1500|    212|        let mut i = 0;
 1501|       |        // Track header slug occurrences for stable de-duplication
 1502|    212|        let mut slug_counts: HashMap<String, usize> = HashMap::new();
 1503|  1.89k|        while i < events.len() {
  ------------------
  |  Branch (1503:15): [True: 1.68k, False: 212]
  ------------------
 1504|  1.68k|            i = self.parse_element(&events, i, &mut elements, &mut slug_counts)?;
                                                                                             ^0
 1505|       |        }
 1506|       |
 1507|    212|        Ok(elements)
 1508|    215|    }
 1509|       |
 1510|       |    /// Parse a single element from the event stream
 1511|  1.69k|    fn parse_element(
 1512|  1.69k|        &self,
 1513|  1.69k|        events: &[Event],
 1514|  1.69k|        start: usize,
 1515|  1.69k|        elements: &mut Vec<MarkdownElement>,
 1516|  1.69k|        slug_counts: &mut HashMap<String, usize>,
 1517|  1.69k|    ) -> Result<usize, anyhow::Error> {
 1518|  1.69k|        match &events[start] {
 1519|       |            Event::Start(Tag::Paragraph) => {
 1520|       |                // Always preserve line breaks in paragraphs (consistent with blockquotes)
 1521|       |                // This allows poetry, lyrics, and structured content to render correctly
 1522|    526|                let (spans, next_idx) =
 1523|    526|                    self.parse_inline_spans_with_breaks(events, start + 1, Tag::Paragraph, true)?;
                                                                                                              ^0
 1524|    526|                if !spans.is_empty() {
  ------------------
  |  Branch (1524:20): [True: 526, False: 0]
  ------------------
 1525|    526|                    elements.push(MarkdownElement::Paragraph(spans));
 1526|    526|                }
                              ^0
 1527|    526|                Ok(next_idx)
 1528|       |            }
 1529|       |            // Images encountered outside paragraphs: treat as a single paragraph with an inline image
 1530|      2|            Event::Start(Tag::Image(_, url, title)) => {
 1531|      2|                let (alt, next_idx) = self.collect_until_tag_end(
 1532|      2|                    events,
 1533|      2|                    start + 1,
 1534|      2|                    Tag::Image(LinkType::Inline, "".into(), "".into()),
 1535|       |                    false,
 1536|      0|                )?;
 1537|      2|                let mut spans: Vec<InlineSpan> = Vec::new();
 1538|      2|                spans.push(InlineSpan::Image {
 1539|      2|                    src: url.to_string(),
 1540|      2|                    alt,
 1541|      2|                    title: if title.is_empty() {
  ------------------
  |  Branch (1541:31): [True: 1, False: 1]
  ------------------
 1542|      1|                        None
 1543|       |                    } else {
 1544|      1|                        Some(title.to_string())
 1545|       |                    },
 1546|       |                });
 1547|      2|                elements.push(MarkdownElement::Paragraph(spans));
 1548|      2|                Ok(next_idx)
 1549|       |            }
 1550|    599|            Event::Start(Tag::Heading(level, _, _)) => {
 1551|    599|                let (spans, next_idx) =
 1552|    599|                    self.parse_inline_spans(events, start + 1, Tag::Heading(*level, None, vec![]))?;
                                                                                                                ^0
 1553|    599|                let title_text = Self::spans_plain_text(&spans);
 1554|    599|                let base = Self::slugify(&title_text);
 1555|    599|                let count = slug_counts.entry(base.clone()).or_insert(0);
 1556|    599|                let id = if *count == 0 {
  ------------------
  |  Branch (1556:29): [True: 597, False: 2]
  ------------------
 1557|    597|                    base.clone()
 1558|       |                } else {
 1559|      2|                    format!("{}-{}", base, *count)
 1560|       |                };
 1561|    599|                *count += 1;
 1562|    599|                elements.push(MarkdownElement::Header {
 1563|    599|                    level: *level as u8,
 1564|    599|                    spans,
 1565|    599|                    id,
 1566|    599|                });
 1567|    599|                Ok(next_idx)
 1568|       |            }
 1569|       |            Event::Start(Tag::CodeBlock(_)) => {
 1570|      9|                let (code_text, language, next_idx) = self.parse_code_block(events, start)?;
                                                                                                        ^0
 1571|      9|                elements.push(MarkdownElement::CodeBlock {
 1572|      9|                    language,
 1573|      9|                    text: code_text,
 1574|      9|                });
 1575|      9|                Ok(next_idx)
 1576|       |            }
 1577|    366|            Event::Start(Tag::List(first_item)) => {
 1578|    366|                let (items, next_idx) = self.parse_list(events, start + 1, slug_counts)?;
                                                                                                     ^0
 1579|    366|                elements.push(MarkdownElement::List {
 1580|    366|                    ordered: first_item.is_some(),
 1581|    366|                    items,
 1582|    366|                });
 1583|    366|                Ok(next_idx)
 1584|       |            }
 1585|       |            Event::Rule => {
 1586|    154|                elements.push(MarkdownElement::HorizontalRule);
 1587|    154|                Ok(start + 1)
 1588|       |            }
 1589|       |            Event::Start(Tag::BlockQuote) => {
 1590|     11|                let (quotes, next_idx) =
 1591|     11|                    self.collect_blockquotes(events, start + 1, 1, slug_counts)?;
                                                                                             ^0
 1592|     27|                for (depth, blocks) in quotes {
                                   ^16    ^16
 1593|     16|                    if !blocks.is_empty() {
  ------------------
  |  Branch (1593:24): [True: 16, False: 0]
  ------------------
 1594|     16|                        elements.push(MarkdownElement::Quote { depth, blocks });
 1595|     16|                    }
                                  ^0
 1596|       |                }
 1597|     11|                Ok(next_idx)
 1598|       |            }
 1599|     25|            Event::Start(Tag::Table(alignments)) => {
 1600|     25|                let (headers, rows, next_idx) = self.parse_table(events, start + 1)?;
                                                                                                 ^0
 1601|     25|                elements.push(MarkdownElement::Table {
 1602|     25|                    headers,
 1603|     25|                    rows,
 1604|     25|                    alignments: alignments.to_vec(),
 1605|     25|                });
 1606|     25|                Ok(next_idx)
 1607|       |            }
 1608|       |            _ => {
 1609|       |                // Skip other events
 1610|      0|                Ok(start + 1)
 1611|       |            }
 1612|       |        }
 1613|  1.69k|    }
 1614|       |
 1615|       |    // Build a slug from text similar to GitHub: lowercase, spaces->dashes, strip punctuation
 1616|    610|    fn slugify(text: &str) -> String {
 1617|    610|        let mut out = String::with_capacity(text.len());
 1618|    610|        let mut last_dash = false;
 1619|  8.28k|        for ch in text.chars() {
                                ^610 ^610
 1620|  8.28k|            let c = ch.to_ascii_lowercase();
 1621|  8.28k|            if c.is_ascii_alphanumeric() {
  ------------------
  |  Branch (1621:16): [True: 7.67k, False: 613]
  ------------------
 1622|  7.67k|                out.push(c);
 1623|  7.67k|                last_dash = false;
 1624|  7.67k|            } else if c.is_whitespace() || c == '-' {
                                    ^613^613               ^12
  ------------------
  |  Branch (1624:23): [True: 601, False: 12]
  |  Branch (1624:44): [True: 6, False: 6]
  ------------------
 1625|    607|                if !last_dash && !out.is_empty() {
                                               ^599
  ------------------
  |  Branch (1625:20): [True: 599, False: 8]
  |  Branch (1625:34): [True: 597, False: 2]
  ------------------
 1626|    597|                    out.push('-');
 1627|    597|                    last_dash = true;
 1628|    597|                }
                              ^10
 1629|      6|            } else {
 1630|      6|                // drop punctuation/symbols
 1631|      6|            }
 1632|       |        }
 1633|       |        // Trim trailing dash if any
 1634|    610|        if out.ends_with('-') {
  ------------------
  |  Branch (1634:12): [True: 2, False: 608]
  ------------------
 1635|      2|            out.pop();
 1636|    608|        }
 1637|    610|        out
 1638|    610|    }
 1639|       |
 1640|    699|    fn spans_plain_text(spans: &[InlineSpan]) -> String {
 1641|    699|        let mut s = String::new();
 1642|  1.43k|        for span in spans {
                          ^735
 1643|    735|            match span {
 1644|    711|                InlineSpan::Text(t)
 1645|     12|                | InlineSpan::Strong(t)
 1646|      1|                | InlineSpan::Emphasis(t)
 1647|    724|                | InlineSpan::Strikethrough(t) => s.push_str(t),
                                                          ^0
 1648|      4|                InlineSpan::Code(t) => s.push_str(t),
 1649|      1|                InlineSpan::Link { text, .. } => s.push_str(text),
 1650|      6|                InlineSpan::Image { alt, title, .. } => {
 1651|      6|                    if !alt.is_empty() {
  ------------------
  |  Branch (1651:24): [True: 3, False: 3]
  ------------------
 1652|      3|                        s.push_str(alt);
 1653|      3|                    }
 1654|      6|                    if let Some(t) = title {
                                              ^5
  ------------------
  |  Branch (1654:28): [True: 5, False: 1]
  ------------------
 1655|      5|                        if !t.is_empty() {
  ------------------
  |  Branch (1655:28): [True: 4, False: 1]
  ------------------
 1656|      4|                            if !s.is_empty() {
  ------------------
  |  Branch (1656:32): [True: 2, False: 2]
  ------------------
 1657|      2|                                s.push(' ');
 1658|      2|                            }
 1659|      4|                            s.push_str(t);
 1660|      1|                        }
 1661|      1|                    }
 1662|       |                }
 1663|       |            }
 1664|       |        }
 1665|    699|        s
 1666|    699|    }
 1667|       |
 1668|       |    /// Extract plain text from all markdown elements
 1669|     14|    pub fn elements_to_plain_text(elements: &[MarkdownElement]) -> String {
 1670|     14|        let mut result = String::new();
 1671|     35|        for element in elements.iter() {
                                     ^14      ^14
 1672|     35|            match element {
 1673|      9|                MarkdownElement::Paragraph(spans) | MarkdownElement::Header { spans, .. } => {
                                                                                            ^6
 1674|     15|                    if !result.is_empty() {
  ------------------
  |  Branch (1674:24): [True: 7, False: 8]
  ------------------
 1675|      7|                        result.push('\n');
 1676|      8|                    }
 1677|     15|                    result.push_str(&Self::spans_plain_text(spans));
 1678|       |                }
 1679|      2|                MarkdownElement::CodeBlock { text, .. } => {
 1680|      2|                    if !result.is_empty() {
  ------------------
  |  Branch (1680:24): [True: 1, False: 1]
  ------------------
 1681|      1|                        result.push('\n');
 1682|      1|                    }
 1683|      2|                    result.push_str(text);
 1684|       |                }
 1685|      5|                MarkdownElement::List { items, .. } => {
 1686|     16|                    for item in items {
                                      ^11
 1687|     22|                        for block in &item.blocks {
                                          ^11
 1688|     11|                            if !result.is_empty() {
  ------------------
  |  Branch (1688:32): [True: 10, False: 1]
  ------------------
 1689|     10|                                result.push('\n');
 1690|     10|                            }
                                          ^1
 1691|     11|                            result.push_str(&Self::element_plain_text(block));
 1692|       |                        }
 1693|       |                    }
 1694|       |                }
 1695|      3|                MarkdownElement::Quote { blocks, .. } => {
 1696|      6|                    for block in blocks {
                                      ^3
 1697|      3|                        if !result.is_empty() {
  ------------------
  |  Branch (1697:28): [True: 2, False: 1]
  ------------------
 1698|      2|                            result.push('\n');
 1699|      2|                        }
                                      ^1
 1700|      3|                        result.push_str(&Self::element_plain_text(block));
 1701|       |                    }
 1702|       |                }
 1703|       |                MarkdownElement::Table {
 1704|      5|                    headers,
 1705|      5|                    rows,
 1706|       |                    alignments: _,
 1707|       |                } => {
 1708|       |                    // Headers
 1709|     11|                    for header in headers {
                                      ^6
 1710|      6|                        if !result.is_empty() {
  ------------------
  |  Branch (1710:28): [True: 5, False: 1]
  ------------------
 1711|      5|                            result.push('\n');
 1712|      5|                        }
                                      ^1
 1713|      6|                        result.push_str(&Self::spans_plain_text(header));
 1714|       |                    }
 1715|       |                    // Rows
 1716|     15|                    for row in rows {
                                      ^10
 1717|     27|                        for cell in row {
                                          ^17
 1718|     17|                            if !result.is_empty() {
  ------------------
  |  Branch (1718:32): [True: 16, False: 1]
  ------------------
 1719|     16|                                result.push('\n');
 1720|     16|                            }
                                          ^1
 1721|     17|                            result.push_str(&Self::spans_plain_text(cell));
 1722|       |                        }
 1723|       |                    }
 1724|       |                }
 1725|       |                MarkdownElement::HorizontalRule => {
 1726|      5|                    if !result.is_empty() {
  ------------------
  |  Branch (1726:24): [True: 4, False: 1]
  ------------------
 1727|      4|                        result.push_str("\n---\n");
 1728|      4|                    }
                                  ^1
 1729|       |                }
 1730|       |            }
 1731|       |        }
 1732|     14|        result
 1733|     14|    }
 1734|       |
 1735|       |    /// Collect blockquotes into (depth, blocks) entries; supports nesting and block elements.
 1736|     24|    fn collect_blockquotes(
 1737|     24|        &self,
 1738|     24|        events: &[Event],
 1739|     24|        start: usize,
 1740|     24|        depth: u8,
 1741|     24|        slug_counts: &mut HashMap<String, usize>,
 1742|     24|    ) -> Result<(Vec<(u8, QuoteBlocks)>, usize), anyhow::Error> {
 1743|     24|        let mut i = start;
 1744|     24|        let mut result: Vec<(u8, QuoteBlocks)> = Vec::new();
 1745|     24|        let mut blocks: QuoteBlocks = Vec::new();
 1746|     24|        let mut spans: Vec<InlineSpan> = Vec::new();
 1747|       |
 1748|     69|        let flush_inline = |blocks: &mut QuoteBlocks, spans: &mut Vec<InlineSpan>| {
                          ^24
 1749|     69|            if !spans.is_empty() {
  ------------------
  |  Branch (1749:16): [True: 4, False: 65]
  ------------------
 1750|      4|                blocks.push(MarkdownElement::Paragraph(std::mem::take(spans)));
 1751|     65|            }
 1752|     69|        };
 1753|       |
 1754|     85|        while i < events.len() {
  ------------------
  |  Branch (1754:15): [True: 83, False: 2]
  ------------------
 1755|     83|            match &events[i] {
 1756|       |                Event::Start(Tag::Paragraph) => {
 1757|     21|                    flush_inline(&mut blocks, &mut spans);
 1758|     21|                    let (ps, next) =
 1759|     21|                        self.parse_inline_spans_with_breaks(events, i + 1, Tag::Paragraph, true)?;
                                                                                                              ^0
 1760|     21|                    if !ps.is_empty() {
  ------------------
  |  Branch (1760:24): [True: 20, False: 1]
  ------------------
 1761|     20|                        blocks.push(MarkdownElement::Paragraph(ps));
 1762|     20|                    }
                                  ^1
 1763|     21|                    i = next;
 1764|       |                }
 1765|      5|                Event::Start(Tag::Heading(level, _, _)) => {
 1766|      5|                    flush_inline(&mut blocks, &mut spans);
 1767|      5|                    let (ps, next) =
 1768|      5|                        self.parse_inline_spans(events, i + 1, Tag::Heading(*level, None, vec![]))?;
                                                                                                                ^0
 1769|      5|                    let title_text = Self::spans_plain_text(&ps);
 1770|      5|                    let base = Self::slugify(&title_text);
 1771|      5|                    let count = slug_counts.entry(base.clone()).or_insert(0);
 1772|      5|                    let id = if *count == 0 {
  ------------------
  |  Branch (1772:33): [True: 4, False: 1]
  ------------------
 1773|      4|                        base.clone()
 1774|       |                    } else {
 1775|      1|                        format!("{}-{}", base, *count)
 1776|       |                    };
 1777|      5|                    *count += 1;
 1778|      5|                    blocks.push(MarkdownElement::Header {
 1779|      5|                        level: *level as u8,
 1780|      5|                        spans: ps,
 1781|      5|                        id,
 1782|      5|                    });
 1783|      5|                    i = next;
 1784|       |                }
 1785|      4|                Event::Start(Tag::Table(alignments)) => {
 1786|      4|                    flush_inline(&mut blocks, &mut spans);
 1787|      4|                    let (headers, rows, next_idx) = self.parse_table(events, i + 1)?;
                                                                                                 ^0
 1788|      4|                    blocks.push(MarkdownElement::Table {
 1789|      4|                        headers,
 1790|      4|                        rows,
 1791|      4|                        alignments: alignments.to_vec(),
 1792|      4|                    });
 1793|      4|                    i = next_idx;
 1794|       |                }
 1795|      4|                Event::Start(Tag::List(first_item)) => {
 1796|      4|                    flush_inline(&mut blocks, &mut spans);
 1797|      4|                    let (items, next_idx) = self.parse_list(events, i + 1, slug_counts)?;
                                                                                                     ^0
 1798|      4|                    blocks.push(MarkdownElement::List {
 1799|      4|                        ordered: first_item.is_some(),
 1800|      4|                        items,
 1801|      4|                    });
 1802|      4|                    i = next_idx;
 1803|       |                }
 1804|       |                Event::Start(Tag::CodeBlock(_)) => {
 1805|      3|                    flush_inline(&mut blocks, &mut spans);
 1806|      3|                    let (code_text, language, next_idx) = self.parse_code_block(events, i)?;
                                                                                                        ^0
 1807|      3|                    blocks.push(MarkdownElement::CodeBlock {
 1808|      3|                        language,
 1809|      3|                        text: code_text,
 1810|      3|                    });
 1811|      3|                    i = next_idx;
 1812|       |                }
 1813|      2|                Event::Rule => {
 1814|      2|                    flush_inline(&mut blocks, &mut spans);
 1815|      2|                    blocks.push(MarkdownElement::HorizontalRule);
 1816|      2|                    i += 1;
 1817|      2|                }
 1818|       |                Event::Start(Tag::BlockQuote) => {
 1819|      6|                    flush_inline(&mut blocks, &mut spans);
 1820|      6|                    if !blocks.is_empty() {
  ------------------
  |  Branch (1820:24): [True: 6, False: 0]
  ------------------
 1821|      6|                        result.push((depth, std::mem::take(&mut blocks)));
 1822|      6|                    }
                                  ^0
 1823|      6|                    let (nested, next) =
 1824|      6|                        self.collect_blockquotes(events, i + 1, depth + 1, slug_counts)?;
                                                                                                     ^0
 1825|      6|                    result.extend(nested);
 1826|      6|                    i = next;
 1827|       |                }
 1828|       |                Event::End(Tag::BlockQuote) => {
 1829|     22|                    flush_inline(&mut blocks, &mut spans);
 1830|     22|                    if !blocks.is_empty() {
  ------------------
  |  Branch (1830:24): [True: 16, False: 6]
  ------------------
 1831|     16|                        result.push((depth, blocks));
 1832|     16|                    }
                                  ^6
 1833|     22|                    return Ok((result, i + 1));
 1834|       |                }
 1835|      1|                Event::Text(t) => {
 1836|      1|                    spans.push(InlineSpan::Text(Self::restore_pipe_sentinel(t)));
 1837|      1|                    i += 1;
 1838|      1|                }
 1839|      2|                Event::Code(code) => {
 1840|      2|                    spans.push(InlineSpan::Code(Self::restore_pipe_sentinel(code)));
 1841|      2|                    i += 1;
 1842|      2|                }
 1843|       |                Event::Start(Tag::Emphasis) => {
 1844|      1|                    let (inner_text, next) =
 1845|      1|                        self.collect_until_tag_end(events, i + 1, Tag::Emphasis, true)?;
                                                                                                    ^0
 1846|      1|                    spans.push(InlineSpan::Emphasis(inner_text));
 1847|      1|                    i = next;
 1848|       |                }
 1849|       |                Event::Start(Tag::Strong) => {
 1850|      1|                    let (inner_text, next) =
 1851|      1|                        self.collect_until_tag_end(events, i + 1, Tag::Strong, true)?;
                                                                                                  ^0
 1852|      1|                    spans.push(InlineSpan::Strong(inner_text));
 1853|      1|                    i = next;
 1854|       |                }
 1855|       |                Event::Start(Tag::Strikethrough) => {
 1856|      1|                    let (inner_text, next) =
 1857|      1|                        self.collect_until_tag_end(events, i + 1, Tag::Strikethrough, true)?;
                                                                                                         ^0
 1858|      1|                    spans.push(InlineSpan::Strikethrough(inner_text));
 1859|      1|                    i = next;
 1860|       |                }
 1861|      2|                Event::Start(Tag::Link(_, url, _)) => {
 1862|      2|                    let url_str = url.to_string();
 1863|      2|                    let (link_text, next) = self.collect_until_tag_end(
 1864|      2|                        events,
 1865|      2|                        i + 1,
 1866|      2|                        Tag::Link(LinkType::Inline, "".into(), "".into()),
 1867|       |                        true,
 1868|      0|                    )?;
 1869|      2|                    spans.push(InlineSpan::Link {
 1870|      2|                        text: link_text,
 1871|      2|                        url: url_str,
 1872|      2|                    });
 1873|      2|                    i = next;
 1874|       |                }
 1875|      2|                Event::Start(Tag::Image(_, url, title)) => {
 1876|      2|                    let url_str = url.to_string();
 1877|      2|                    let (alt_text, next) = self.collect_until_tag_end(
 1878|      2|                        events,
 1879|      2|                        i + 1,
 1880|      2|                        Tag::Image(LinkType::Inline, "".into(), "".into()),
 1881|       |                        true,
 1882|      0|                    )?;
 1883|      2|                    spans.push(InlineSpan::Image {
 1884|      2|                        src: url_str,
 1885|      2|                        alt: alt_text,
 1886|      2|                        title: if title.is_empty() {
  ------------------
  |  Branch (1886:35): [True: 1, False: 1]
  ------------------
 1887|      1|                            None
 1888|       |                        } else {
 1889|      1|                            Some(title.to_string())
 1890|       |                        },
 1891|       |                    });
 1892|      2|                    i = next;
 1893|       |                }
 1894|      3|                Event::SoftBreak | Event::HardBreak => {
 1895|      3|                    spans.push(InlineSpan::Text("\n".to_string()));
 1896|      3|                    i += 1;
 1897|      3|                }
 1898|      2|                Event::Html(html) => {
 1899|      2|                    if Self::is_html_line_break(html) {
  ------------------
  |  Branch (1899:24): [True: 1, False: 1]
  ------------------
 1900|      1|                        spans.push(InlineSpan::Text("\n".to_string()));
 1901|      1|                    }
 1902|      2|                    i += 1;
 1903|       |                }
 1904|      1|                _ => {
 1905|      1|                    i += 1;
 1906|      1|                }
 1907|       |            }
 1908|       |        }
 1909|       |
 1910|      2|        flush_inline(&mut blocks, &mut spans);
 1911|      2|        if !blocks.is_empty() {
  ------------------
  |  Branch (1911:12): [True: 1, False: 1]
  ------------------
 1912|      1|            result.push((depth, blocks));
 1913|      1|        }
 1914|      2|        Ok((result, i))
 1915|     24|    }
 1916|       |
 1917|       |    /// Parse inline spans until reaching the end tag
 1918|  1.50k|    fn parse_inline_spans_with_breaks(
 1919|  1.50k|        &self,
 1920|  1.50k|        events: &[Event],
 1921|  1.50k|        start: usize,
 1922|  1.50k|        end_tag: Tag,
 1923|  1.50k|        keep_breaks: bool,
 1924|  1.50k|    ) -> Result<(Vec<InlineSpan>, usize), anyhow::Error> {
 1925|  1.50k|        let mut spans = Vec::new();
 1926|  1.50k|        let mut i = start;
 1927|  1.50k|        let mut text_buffer = String::new();
 1928|       |
 1929|  3.27k|        while i < events.len() {
  ------------------
  |  Branch (1929:15): [True: 3.27k, False: 1]
  ------------------
 1930|  3.27k|            match &events[i] {
 1931|  1.50k|                Event::End(tag)
 1932|  1.50k|                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
  ------------------
  |  Branch (1932:24): [True: 1.50k, False: 0]
  ------------------
 1933|       |                {
 1934|  1.50k|                    if !text_buffer.is_empty() {
  ------------------
  |  Branch (1934:24): [True: 1.25k, False: 252]
  ------------------
 1935|  1.25k|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1936|  1.25k|                        text_buffer.clear();
 1937|  1.25k|                    }
                                  ^252
 1938|  1.50k|                    return Ok((spans, i + 1));
 1939|       |                }
 1940|  1.40k|                Event::Text(text) => {
 1941|  1.40k|                    let restored = Self::restore_pipe_sentinel(text);
 1942|  1.40k|                    text_buffer.push_str(&restored);
 1943|  1.40k|                    i += 1;
 1944|  1.40k|                }
 1945|       |                Event::SoftBreak | Event::HardBreak => {
 1946|     19|                    if keep_breaks {
  ------------------
  |  Branch (1946:24): [True: 18, False: 1]
  ------------------
 1947|     18|                        if !text_buffer.is_empty() {
  ------------------
  |  Branch (1947:28): [True: 11, False: 7]
  ------------------
 1948|     11|                            spans.push(InlineSpan::Text(text_buffer.clone()));
 1949|     11|                            text_buffer.clear();
 1950|     11|                        }
                                      ^7
 1951|     18|                        spans.push(InlineSpan::Text("\n".to_string()));
 1952|      1|                    } else {
 1953|      1|                        text_buffer.push(' ');
 1954|      1|                    }
 1955|     19|                    i += 1;
 1956|       |                }
 1957|     94|                Event::Code(code) => {
 1958|     94|                    if !text_buffer.is_empty() {
  ------------------
  |  Branch (1958:24): [True: 23, False: 71]
  ------------------
 1959|     23|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1960|     23|                        text_buffer.clear();
 1961|     71|                    }
 1962|     94|                    spans.push(InlineSpan::Code(Self::restore_pipe_sentinel(code)));
 1963|     94|                    i += 1;
 1964|       |                }
 1965|     20|                Event::Html(html) => {
 1966|     20|                    if Self::is_html_line_break(html) {
  ------------------
  |  Branch (1966:24): [True: 19, False: 1]
  ------------------
 1967|     19|                        if keep_breaks {
  ------------------
  |  Branch (1967:28): [True: 18, False: 1]
  ------------------
 1968|     18|                            if !text_buffer.is_empty() {
  ------------------
  |  Branch (1968:32): [True: 16, False: 2]
  ------------------
 1969|     16|                                spans.push(InlineSpan::Text(text_buffer.clone()));
 1970|     16|                                text_buffer.clear();
 1971|     16|                            }
                                          ^2
 1972|     18|                            spans.push(InlineSpan::Text("\n".to_string()));
 1973|      1|                        } else {
 1974|      1|                            text_buffer.push(' ');
 1975|      1|                        }
 1976|      1|                    }
 1977|     20|                    i += 1;
 1978|       |                }
 1979|       |                Event::Start(Tag::Strong) => {
 1980|     33|                    if !text_buffer.is_empty() {
  ------------------
  |  Branch (1980:24): [True: 4, False: 29]
  ------------------
 1981|      4|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1982|      4|                        text_buffer.clear();
 1983|     29|                    }
 1984|     33|                    let (inner_text, next_i) =
 1985|     33|                        self.collect_until_tag_end(events, i + 1, Tag::Strong, keep_breaks)?;
                                                                                                         ^0
 1986|     33|                    spans.push(InlineSpan::Strong(inner_text));
 1987|     33|                    i = next_i;
 1988|       |                }
 1989|       |                Event::Start(Tag::Emphasis) => {
 1990|    156|                    if !text_buffer.is_empty() {
  ------------------
  |  Branch (1990:24): [True: 7, False: 149]
  ------------------
 1991|      7|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 1992|      7|                        text_buffer.clear();
 1993|    149|                    }
 1994|    156|                    let (inner_text, next_i) =
 1995|    156|                        self.collect_until_tag_end(events, i + 1, Tag::Emphasis, keep_breaks)?;
                                                                                                           ^0
 1996|    156|                    spans.push(InlineSpan::Emphasis(inner_text));
 1997|    156|                    i = next_i;
 1998|       |                }
 1999|       |                Event::Start(Tag::Strikethrough) => {
 2000|      6|                    if !text_buffer.is_empty() {
  ------------------
  |  Branch (2000:24): [True: 4, False: 2]
  ------------------
 2001|      4|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 2002|      4|                        text_buffer.clear();
 2003|      4|                    }
                                  ^2
 2004|      6|                    let (inner_text, next_i) =
 2005|      6|                        self.collect_until_tag_end(events, i + 1, Tag::Strikethrough, keep_breaks)?;
                                                                                                                ^0
 2006|      6|                    spans.push(InlineSpan::Strikethrough(inner_text));
 2007|      6|                    i = next_i;
 2008|       |                }
 2009|     16|                Event::Start(Tag::Link(_, url, _)) => {
 2010|     16|                    if !text_buffer.is_empty() {
  ------------------
  |  Branch (2010:24): [True: 8, False: 8]
  ------------------
 2011|      8|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 2012|      8|                        text_buffer.clear();
 2013|      8|                    }
 2014|     16|                    let url_str = url.to_string();
 2015|     16|                    let (link_text, next_i) = self.collect_until_tag_end(
 2016|     16|                        events,
 2017|     16|                        i + 1,
 2018|     16|                        Tag::Link(LinkType::Inline, "".into(), "".into()),
 2019|     16|                        keep_breaks,
 2020|      0|                    )?;
 2021|     16|                    spans.push(InlineSpan::Link {
 2022|     16|                        text: link_text,
 2023|     16|                        url: url_str,
 2024|     16|                    });
 2025|     16|                    i = next_i;
 2026|       |                }
 2027|     17|                Event::Start(Tag::Image(_, url, title)) => {
 2028|     17|                    if !text_buffer.is_empty() {
  ------------------
  |  Branch (2028:24): [True: 3, False: 14]
  ------------------
 2029|      3|                        spans.push(InlineSpan::Text(text_buffer.clone()));
 2030|      3|                        text_buffer.clear();
 2031|     14|                    }
 2032|     17|                    let url_str = url.to_string();
 2033|     17|                    let (alt_text, next_i) = self.collect_until_tag_end(
 2034|     17|                        events,
 2035|     17|                        i + 1,
 2036|     17|                        Tag::Image(LinkType::Inline, "".into(), "".into()),
 2037|     17|                        keep_breaks,
 2038|      0|                    )?;
 2039|     17|                    spans.push(InlineSpan::Image {
 2040|     17|                        src: url_str,
 2041|     17|                        alt: alt_text,
 2042|     17|                        title: if title.is_empty() {
  ------------------
  |  Branch (2042:35): [True: 1, False: 16]
  ------------------
 2043|      1|                            None
 2044|       |                        } else {
 2045|     16|                            Some(title.to_string())
 2046|       |                        },
 2047|       |                    });
 2048|     17|                    i = next_i;
 2049|       |                }
 2050|      1|                _ => {
 2051|      1|                    i += 1;
 2052|      1|                }
 2053|       |            }
 2054|       |        }
 2055|       |
 2056|      1|        if !text_buffer.is_empty() {
  ------------------
  |  Branch (2056:12): [True: 1, False: 0]
  ------------------
 2057|      1|            spans.push(InlineSpan::Text(text_buffer));
 2058|      1|        }
                      ^0
 2059|       |
 2060|      1|        Ok((spans, i))
 2061|  1.50k|    }
 2062|       |
 2063|       |    /// Default inline parsing without preserving explicit line breaks
 2064|    612|    fn parse_inline_spans(
 2065|    612|        &self,
 2066|    612|        events: &[Event],
 2067|    612|        start: usize,
 2068|    612|        end_tag: Tag,
 2069|    612|    ) -> Result<(Vec<InlineSpan>, usize), anyhow::Error> {
 2070|    612|        self.parse_inline_spans_with_breaks(events, start, end_tag, false)
 2071|    612|    }
 2072|       |
 2073|       |    /// Collect text until a specific end tag
 2074|  1.41k|    fn collect_until_tag_end(
 2075|  1.41k|        &self,
 2076|  1.41k|        events: &[Event],
 2077|  1.41k|        start: usize,
 2078|  1.41k|        end_tag: Tag,
 2079|  1.41k|        keep_breaks: bool,
 2080|  1.41k|    ) -> Result<(String, usize), anyhow::Error> {
 2081|  1.41k|        let mut text = String::new();
 2082|  1.41k|        let mut i = start;
 2083|       |
 2084|  2.86k|        while i < events.len() {
  ------------------
  |  Branch (2084:15): [True: 2.86k, False: 1]
  ------------------
 2085|  2.86k|            match &events[i] {
 2086|  1.42k|                Event::End(tag)
 2087|  1.42k|                    if std::mem::discriminant(tag) == std::mem::discriminant(&end_tag) =>
                                                                                                   ^1.41k
  ------------------
  |  Branch (2087:24): [True: 1.41k, False: 2]
  ------------------
 2088|       |                {
 2089|  1.41k|                    return Ok((text, i + 1));
 2090|       |                }
 2091|  1.42k|                Event::Text(t) => {
 2092|  1.42k|                    let restored = Self::restore_pipe_sentinel(t);
 2093|  1.42k|                    text.push_str(&restored);
 2094|  1.42k|                }
 2095|      2|                Event::Code(code) => {
 2096|      2|                    let restored = Self::restore_pipe_sentinel(code);
 2097|      2|                    text.push_str(&restored);
 2098|      2|                }
 2099|       |                Event::SoftBreak | Event::HardBreak => {
 2100|      5|                    if keep_breaks {
  ------------------
  |  Branch (2100:24): [True: 3, False: 2]
  ------------------
 2101|      3|                        text.push('\n');
 2102|      3|                    } else {
 2103|      2|                        text.push(' ');
 2104|      2|                    }
 2105|       |                }
 2106|      8|                Event::Html(html) => {
 2107|      8|                    if Self::is_html_line_break(html) {
  ------------------
  |  Branch (2107:24): [True: 6, False: 2]
  ------------------
 2108|      6|                        if keep_breaks {
  ------------------
  |  Branch (2108:28): [True: 4, False: 2]
  ------------------
 2109|      4|                            text.push('\n');
 2110|      4|                        } else {
 2111|      2|                            text.push(' ');
 2112|      2|                        }
 2113|      2|                    }
 2114|       |                }
 2115|      4|                _ => {}
 2116|       |            }
 2117|  1.44k|            i += 1;
 2118|       |        }
 2119|       |
 2120|      1|        Ok((text, i))
 2121|  1.41k|    }
 2122|       |
 2123|       |    /// Parse a code block
 2124|     15|    fn parse_code_block(
 2125|     15|        &self,
 2126|     15|        events: &[Event],
 2127|     15|        start: usize,
 2128|     15|    ) -> Result<(String, Option<String>, usize), anyhow::Error> {
 2129|     15|        let mut language = None;
 2130|     15|        let mut code_text = String::new();
 2131|     15|        let mut i = start;
 2132|       |
 2133|       |        // Extract language from the start tag
 2134|     15|        if let Event::Start(Tag::CodeBlock(kind)) = &events[start] {
  ------------------
  |  Branch (2134:16): [True: 15, False: 0]
  ------------------
 2135|     15|            if let pulldown_cmark::CodeBlockKind::Fenced(lang) = kind {
  ------------------
  |  Branch (2135:20): [True: 15, False: 0]
  ------------------
 2136|     15|                if !lang.is_empty() {
  ------------------
  |  Branch (2136:20): [True: 15, False: 0]
  ------------------
 2137|     15|                    language = Some(lang.to_string());
 2138|     15|                }
                              ^0
 2139|      0|            }
 2140|     15|            i += 1;
 2141|      0|        }
 2142|       |
 2143|     33|        while i < events.len() {
  ------------------
  |  Branch (2143:15): [True: 32, False: 1]
  ------------------
 2144|     32|            match &events[i] {
 2145|       |                Event::End(Tag::CodeBlock(_)) => {
 2146|     14|                    return Ok((code_text, language, i + 1));
 2147|       |                }
 2148|     17|                Event::Text(text) => {
 2149|     17|                    code_text.push_str(text);
 2150|     17|                }
 2151|      1|                _ => {}
 2152|       |            }
 2153|     18|            i += 1;
 2154|       |        }
 2155|       |
 2156|      1|        Ok((code_text, language, i))
 2157|     15|    }
 2158|       |
 2159|       |    /// Parse a list item into block-level markdown elements.
 2160|    381|    fn parse_list(
 2161|    381|        &self,
 2162|    381|        events: &[Event],
 2163|    381|        start: usize,
 2164|    381|        slug_counts: &mut HashMap<String, usize>,
 2165|    381|    ) -> Result<(Vec<ListItem>, usize), anyhow::Error> {
 2166|    381|        let mut items: Vec<ListItem> = Vec::new();
 2167|    381|        let mut i = start;
 2168|       |
 2169|  1.79k|        while i < events.len() {
  ------------------
  |  Branch (2169:15): [True: 1.79k, False: 1]
  ------------------
 2170|  1.79k|            match &events[i] {
 2171|    380|                Event::End(Tag::List(_)) => return Ok((items, i + 1)),
 2172|       |                Event::Start(Tag::Item) => {
 2173|  1.41k|                    i += 1;
 2174|  1.41k|                    let mut blocks: Vec<MarkdownElement> = Vec::new();
 2175|  1.41k|                    let mut spans: Vec<InlineSpan> = Vec::new();
 2176|  1.41k|                    let flush_inline =
 2177|  1.43k|                        |blocks: &mut Vec<MarkdownElement>, spans: &mut Vec<InlineSpan>| {
 2178|  1.43k|                            if !spans.is_empty() {
  ------------------
  |  Branch (2178:32): [True: 1.40k, False: 25]
  ------------------
 2179|  1.40k|                                blocks.push(MarkdownElement::Paragraph(std::mem::take(spans)));
 2180|  1.40k|                            }
                                          ^25
 2181|  1.43k|                        };
 2182|       |
 2183|       |                    loop {
 2184|  4.98k|                        if i >= events.len() {
  ------------------
  |  Branch (2184:28): [True: 1, False: 4.98k]
  ------------------
 2185|      1|                            break;
 2186|  4.98k|                        }
 2187|  4.98k|                        match &events[i] {
 2188|       |                            Event::End(Tag::Item) => {
 2189|  1.41k|                                i += 1;
 2190|  1.41k|                                break;
 2191|       |                            }
 2192|       |                            Event::Start(Tag::Paragraph) => {
 2193|      1|                                flush_inline(&mut blocks, &mut spans);
 2194|      1|                                let (ps, next) =
 2195|      1|                                    self.parse_inline_spans(events, i + 1, Tag::Paragraph)?;
                                                                                                        ^0
 2196|      1|                                if !ps.is_empty() {
  ------------------
  |  Branch (2196:36): [True: 1, False: 0]
  ------------------
 2197|      1|                                    blocks.push(MarkdownElement::Paragraph(ps));
 2198|      1|                                }
                                              ^0
 2199|      1|                                i = next;
 2200|       |                            }
 2201|      4|                            Event::Start(Tag::Heading(level, _, _)) => {
 2202|      4|                                flush_inline(&mut blocks, &mut spans);
 2203|      4|                                let (ps, next) = self.parse_inline_spans(
 2204|      4|                                    events,
 2205|      4|                                    i + 1,
 2206|      4|                                    Tag::Heading(*level, None, vec![]),
 2207|      0|                                )?;
 2208|      4|                                let title_text = Self::spans_plain_text(&ps);
 2209|      4|                                let base = Self::slugify(&title_text);
 2210|      4|                                let count = slug_counts.entry(base.clone()).or_insert(0);
 2211|      4|                                let id = if *count == 0 {
  ------------------
  |  Branch (2211:45): [True: 3, False: 1]
  ------------------
 2212|      3|                                    base.clone()
 2213|       |                                } else {
 2214|      1|                                    format!("{}-{}", base, *count)
 2215|       |                                };
 2216|      4|                                *count += 1;
 2217|      4|                                blocks.push(MarkdownElement::Header {
 2218|      4|                                    level: *level as u8,
 2219|      4|                                    spans: ps,
 2220|      4|                                    id,
 2221|      4|                                });
 2222|      4|                                i = next;
 2223|       |                            }
 2224|      3|                            Event::Start(Tag::Table(alignments)) => {
 2225|      3|                                flush_inline(&mut blocks, &mut spans);
 2226|      3|                                let (headers, rows, next_idx) = self.parse_table(events, i + 1)?;
                                                                                                             ^0
 2227|      3|                                blocks.push(MarkdownElement::Table {
 2228|      3|                                    headers,
 2229|      3|                                    rows,
 2230|      3|                                    alignments: alignments.to_vec(),
 2231|      3|                                });
 2232|      3|                                i = next_idx;
 2233|       |                            }
 2234|       |                            Event::Start(Tag::CodeBlock(_)) => {
 2235|      2|                                flush_inline(&mut blocks, &mut spans);
 2236|      2|                                let (code_text, language, next_idx) =
 2237|      2|                                    self.parse_code_block(events, i)?;
                                                                                  ^0
 2238|      2|                                blocks.push(MarkdownElement::CodeBlock {
 2239|      2|                                    language,
 2240|      2|                                    text: code_text,
 2241|      2|                                });
 2242|      2|                                i = next_idx;
 2243|       |                            }
 2244|       |                            Event::Start(Tag::BlockQuote) => {
 2245|      2|                                flush_inline(&mut blocks, &mut spans);
 2246|      2|                                let (quotes, next_idx) =
 2247|      2|                                    self.collect_blockquotes(events, i + 1, 1, slug_counts)?;
                                                                                                         ^0
 2248|      4|                                for (depth, quote_blocks) in quotes {
                                                   ^2     ^2
 2249|      2|                                    if !quote_blocks.is_empty() {
  ------------------
  |  Branch (2249:40): [True: 2, False: 0]
  ------------------
 2250|      2|                                        blocks.push(MarkdownElement::Quote {
 2251|      2|                                            depth,
 2252|      2|                                            blocks: quote_blocks,
 2253|      2|                                        });
 2254|      2|                                    }
                                                  ^0
 2255|       |                                }
 2256|      2|                                i = next_idx;
 2257|       |                            }
 2258|      8|                            Event::Start(Tag::List(child_first)) => {
 2259|      8|                                flush_inline(&mut blocks, &mut spans);
 2260|      8|                                let (child_items, next) =
 2261|      8|                                    self.parse_list(events, i + 1, slug_counts)?;
                                                                                             ^0
 2262|      8|                                blocks.push(MarkdownElement::List {
 2263|      8|                                    ordered: child_first.is_some(),
 2264|      8|                                    items: child_items,
 2265|      8|                                });
 2266|      8|                                i = next;
 2267|       |                            }
 2268|      1|                            Event::Rule => {
 2269|      1|                                flush_inline(&mut blocks, &mut spans);
 2270|      1|                                blocks.push(MarkdownElement::HorizontalRule);
 2271|      1|                                i += 1;
 2272|      1|                            }
 2273|    504|                            Event::Code(code) => {
 2274|    504|                                spans.push(InlineSpan::Code(code.to_string()));
 2275|    504|                                i += 1;
 2276|    504|                            }
 2277|       |                            Event::Start(Tag::Emphasis) => {
 2278|      6|                                let (inner_text, next) = self.collect_until_tag_end(
 2279|      6|                                    events,
 2280|      6|                                    i + 1,
 2281|      6|                                    Tag::Emphasis,
 2282|       |                                    false,
 2283|      0|                                )?;
 2284|      6|                                spans.push(InlineSpan::Emphasis(inner_text));
 2285|      6|                                i = next;
 2286|       |                            }
 2287|       |                            Event::Start(Tag::Strong) => {
 2288|  1.13k|                                let (inner_text, next) =
 2289|  1.13k|                                    self.collect_until_tag_end(events, i + 1, Tag::Strong, false)?;
                                                                                                               ^0
 2290|  1.13k|                                spans.push(InlineSpan::Strong(inner_text));
 2291|  1.13k|                                i = next;
 2292|       |                            }
 2293|       |                            Event::Start(Tag::Strikethrough) => {
 2294|      6|                                let (inner_text, next) = self.collect_until_tag_end(
 2295|      6|                                    events,
 2296|      6|                                    i + 1,
 2297|      6|                                    Tag::Strikethrough,
 2298|       |                                    false,
 2299|      0|                                )?;
 2300|      6|                                spans.push(InlineSpan::Strikethrough(inner_text));
 2301|      6|                                i = next;
 2302|       |                            }
 2303|     25|                            Event::Start(Tag::Link(_, url, _)) => {
 2304|     25|                                let url_str = url.to_string();
 2305|     25|                                let (link_text, next) = self.collect_until_tag_end(
 2306|     25|                                    events,
 2307|     25|                                    i + 1,
 2308|     25|                                    Tag::Link(LinkType::Inline, "".into(), "".into()),
 2309|       |                                    false,
 2310|      0|                                )?;
 2311|     25|                                spans.push(InlineSpan::Link {
 2312|     25|                                    text: link_text,
 2313|     25|                                    url: url_str,
 2314|     25|                                });
 2315|     25|                                i = next;
 2316|       |                            }
 2317|      3|                            Event::Start(Tag::Image(_, url, title)) => {
 2318|      3|                                let url_str = url.to_string();
 2319|      3|                                let (alt_text, next) = self.collect_until_tag_end(
 2320|      3|                                    events,
 2321|      3|                                    i + 1,
 2322|      3|                                    Tag::Image(LinkType::Inline, "".into(), "".into()),
 2323|       |                                    false,
 2324|      0|                                )?;
 2325|      3|                                spans.push(InlineSpan::Image {
 2326|      3|                                    src: url_str,
 2327|      3|                                    alt: alt_text,
 2328|      3|                                    title: if title.is_empty() {
  ------------------
  |  Branch (2328:47): [True: 1, False: 2]
  ------------------
 2329|      1|                                        None
 2330|       |                                    } else {
 2331|      2|                                        Some(title.to_string())
 2332|       |                                    },
 2333|       |                                });
 2334|      3|                                i = next;
 2335|       |                            }
 2336|  1.86k|                            Event::Text(t) => {
 2337|  1.86k|                                spans.push(InlineSpan::Text(t.to_string()));
 2338|  1.86k|                                i += 1;
 2339|  1.86k|                            }
 2340|      4|                            Event::SoftBreak | Event::HardBreak => {
 2341|      4|                                spans.push(InlineSpan::Text(" ".into()));
 2342|      4|                                i += 1;
 2343|      4|                            }
 2344|      1|                            _ => {
 2345|      1|                                i += 1;
 2346|      1|                            }
 2347|       |                        }
 2348|       |                    }
 2349|       |
 2350|  1.41k|                    flush_inline(&mut blocks, &mut spans);
 2351|  1.41k|                    items.push(ListItem { blocks });
 2352|       |                }
 2353|      1|                _ => i += 1,
 2354|       |            }
 2355|       |        }
 2356|       |
 2357|      1|        Ok((items, i))
 2358|    381|    }
 2359|       |
 2360|       |    /// Parse a table with headers and rows
 2361|     33|    fn parse_table(
 2362|     33|        &self,
 2363|     33|        events: &[Event],
 2364|     33|        start: usize,
 2365|     33|    ) -> Result<TableParseResult, anyhow::Error> {
 2366|     33|        let mut headers: Vec<Vec<InlineSpan>> = Vec::new();
 2367|     33|        let mut rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
 2368|     33|        let mut i = start;
 2369|       |
 2370|    197|        while i < events.len() {
  ------------------
  |  Branch (2370:15): [True: 196, False: 1]
  ------------------
 2371|    196|            match &events[i] {
 2372|       |                Event::Start(Tag::TableHead) => {
 2373|     33|                    i += 1;
 2374|    107|                    while i < events.len() {
  ------------------
  |  Branch (2374:27): [True: 107, False: 0]
  ------------------
 2375|    107|                        match &events[i] {
 2376|       |                            Event::Start(Tag::TableCell) => {
 2377|     66|                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
 2378|     66|                                    events,
 2379|     66|                                    i + 1,
 2380|     66|                                    Tag::TableCell,
 2381|       |                                    true,
 2382|      0|                                )?;
 2383|     66|                                headers.push(spans);
 2384|     66|                                i = next_idx;
 2385|       |                            }
 2386|       |                            Event::End(Tag::TableHead) => {
 2387|     33|                                i += 1;
 2388|     33|                                break;
 2389|       |                            }
 2390|      8|                            _ => i += 1,
 2391|       |                        }
 2392|       |                    }
 2393|       |                }
 2394|       |                Event::Start(Tag::TableRow) => {
 2395|    130|                    i += 1;
 2396|    130|                    let mut row: Vec<Vec<InlineSpan>> = Vec::new();
 2397|    407|                    while i < events.len() {
  ------------------
  |  Branch (2397:27): [True: 407, False: 0]
  ------------------
 2398|    407|                        match &events[i] {
 2399|       |                            Event::Start(Tag::TableCell) => {
 2400|    276|                                let (spans, next_idx) = self.parse_inline_spans_with_breaks(
 2401|    276|                                    events,
 2402|    276|                                    i + 1,
 2403|    276|                                    Tag::TableCell,
 2404|       |                                    true,
 2405|      0|                                )?;
 2406|    276|                                row.push(spans);
 2407|    276|                                i = next_idx;
 2408|       |                            }
 2409|       |                            Event::End(Tag::TableRow) => {
 2410|    130|                                i += 1;
 2411|    130|                                if !row.is_empty() {
  ------------------
  |  Branch (2411:36): [True: 130, False: 0]
  ------------------
 2412|    130|                                    rows.push(row);
 2413|    130|                                }
                                              ^0
 2414|    130|                                break;
 2415|       |                            }
 2416|      1|                            _ => i += 1,
 2417|       |                        }
 2418|       |                    }
 2419|       |                }
 2420|     32|                Event::End(Tag::Table(_)) => return Ok((headers, rows, i + 1)),
 2421|      1|                _ => i += 1,
 2422|       |            }
 2423|       |        }
 2424|      1|        Ok((headers, rows, i))
 2425|     33|    }
 2426|       |
 2427|     57|    fn render_element_body(&self, ui: &mut egui::Ui, element: &MarkdownElement) {
 2428|     57|        match element {
 2429|     19|            MarkdownElement::Paragraph(spans) => {
 2430|     19|                self.render_inline_spans(ui, spans);
 2431|     19|                ui.add_space(4.0);
 2432|     19|            }
 2433|      1|            MarkdownElement::Quote { depth, blocks } => {
 2434|      1|                ui.add_space(4.0);
 2435|      1|                let bar_width = 3.0;
 2436|      1|                let bar_gap = 6.0;
 2437|      1|                let left_pad = 10.0 + (*depth as f32) * (bar_width + bar_gap);
 2438|       |                // Substack-like styling: dark grey block with orange accent bars and white text
 2439|      1|                let bg = Color32::from_rgb(24, 24, 24);
 2440|       |
 2441|      1|                let resp = egui::Frame::none()
 2442|      1|                    .fill(bg)
 2443|      1|                    .stroke(Stroke::new(1.0, Color32::from_rgb(40, 40, 40)))
 2444|      1|                    .rounding(egui::Rounding::same(6.0))
 2445|      1|                    .inner_margin(egui::Margin {
 2446|      1|                        left: left_pad,
 2447|      1|                        right: 10.0,
 2448|      1|                        top: 8.0,
 2449|      1|                        bottom: 8.0,
 2450|      1|                    })
 2451|      1|                    .show(ui, |ui| {
 2452|      1|                        let prev_override = ui.style().visuals.override_text_color;
 2453|       |                        // White text for quote content
 2454|      1|                        ui.style_mut().visuals.override_text_color = Some(Color32::WHITE);
 2455|      2|                        for block in blocks {
                                          ^1
 2456|      1|                            self.render_element_body(ui, block);
 2457|      1|                        }
 2458|      1|                        ui.style_mut().visuals.override_text_color = prev_override;
 2459|      1|                    });
 2460|       |
 2461|       |                // Draw vertical orange quote bars on the left of the frame
 2462|      1|                let rect = resp.response.rect;
 2463|      1|                let top = rect.top() + 6.0;
 2464|      1|                let bottom = rect.bottom() - 6.0;
 2465|      1|                let bar_color = Color32::from_rgb(255, 103, 25); // Substack-like orange
 2466|      1|                for d in 0..*depth {
 2467|      1|                    let x = rect.left() + 6.0 + (d as f32) * (bar_width + bar_gap);
 2468|      1|                    let bar_rect = egui::Rect::from_min_max(
 2469|      1|                        egui::pos2(x, top),
 2470|      1|                        egui::pos2(x + bar_width, bottom),
 2471|      1|                    );
 2472|      1|                    ui.painter().rect_filled(bar_rect, 2.0, bar_color);
 2473|      1|                }
 2474|       |
 2475|      1|                ui.add_space(6.0);
 2476|       |            }
 2477|     20|            MarkdownElement::Header { level, spans, id } => {
 2478|     20|                let font_size = match level {
 2479|      8|                    1 => self.font_sizes.h1,
 2480|      8|                    2 => self.font_sizes.h2,
 2481|      1|                    3 => self.font_sizes.h3,
 2482|      1|                    4 => self.font_sizes.h4,
 2483|      1|                    5 => self.font_sizes.h5,
 2484|      1|                    6 => self.font_sizes.h6,
 2485|      0|                    _ => self.font_sizes.body,
 2486|       |                };
 2487|       |
 2488|     20|                ui.add_space(8.0);
 2489|     20|                let resp = ui.horizontal_wrapped(|ui| {
 2490|       |                    // Avoid artificial gaps between header fragments
 2491|     20|                    ui.spacing_mut().item_spacing.x = 0.0;
 2492|     40|                    for span in spans {
                                      ^20
 2493|     20|                        self.render_inline_span(ui, span, Some(font_size), Some(true));
 2494|     20|                    }
 2495|     20|                });
 2496|       |                // Record the header rect for in-document navigation
 2497|     20|                self.header_rects
 2498|     20|                    .borrow_mut()
 2499|     20|                    .insert(id.clone(), resp.response.rect);
 2500|     20|                ui.add_space(6.0);
 2501|       |            }
 2502|      2|            MarkdownElement::CodeBlock { language, text } => {
 2503|      2|                self.render_code_block(ui, language.as_deref(), text);
 2504|      2|            }
 2505|      7|            MarkdownElement::List { ordered, items } => {
 2506|      7|                self.render_list(ui, *ordered, items);
 2507|      7|            }
 2508|      4|            MarkdownElement::HorizontalRule => {
 2509|      4|                ui.add_space(8.0);
 2510|      4|                ui.separator();
 2511|      4|                ui.add_space(8.0);
 2512|      4|            }
 2513|       |            MarkdownElement::Table {
 2514|      4|                headers,
 2515|      4|                rows,
 2516|      4|                alignments,
 2517|      4|            } => {
 2518|      4|                self.render_table(ui, headers, rows, alignments);
 2519|      4|            }
 2520|       |        }
 2521|     57|    }
 2522|       |
 2523|       |    /// Render parsed markdown elements to egui UI
 2524|     16|    pub fn render_to_ui(&self, ui: &mut egui::Ui, elements: &[MarkdownElement]) {
 2525|     16|        self.poll_image_results(ui.ctx());
 2526|     16|        self.mermaid.begin_frame();
 2527|       |        // Clear header rects before rendering a new frame
 2528|     16|        self.header_rects.borrow_mut().clear();
 2529|       |        // Reset per-frame link counter to ensure link IDs are stable across frames
 2530|     16|        *self.link_counter.borrow_mut() = 0;
 2531|       |        // Reset per-frame table counter
 2532|     16|        *self.table_counter.borrow_mut() = 0;
 2533|       |        // Reset per-frame element rects
 2534|     16|        self.element_rects.borrow_mut().clear();
 2535|     49|        for element in elements.iter() {
                                     ^16      ^16
 2536|       |            // Wrap each element in a no-op frame to capture its rect
 2537|     49|            let ir = egui::Frame::none().show(ui, |ui| {
 2538|     49|                self.render_element_body(ui, element);
 2539|     49|            });
 2540|     49|            self.element_rects.borrow_mut().push(ir.response.rect);
 2541|       |        }
 2542|       |        // Add a little extra breathing room at the end so
 2543|       |        // the final line doesn't sit flush under the status bar.
 2544|     16|        ui.add_space(16.0);
 2545|     16|    }
 2546|       |
 2547|       |    /// Render inline spans in a wrapped horizontal layout
 2548|     19|    fn render_inline_spans(&self, ui: &mut egui::Ui, spans: &[InlineSpan]) {
 2549|     19|        ui.horizontal_wrapped(|ui| {
 2550|       |            // Avoid adding UI spacing between inline fragments
 2551|     19|            ui.spacing_mut().item_spacing.x = 0.0;
 2552|     50|            for span in spans {
                              ^31
 2553|     31|                self.render_inline_span(ui, span, None, None);
 2554|     31|            }
 2555|     19|        });
 2556|     19|    }
 2557|       |
 2558|       |    /// Fix Unicode characters that may not render properly in the default font
 2559|    348|    fn fix_unicode_chars(&self, text: &str) -> String {
 2560|    348|        let normalized: String = text.nfc().collect();
 2561|  3.56k|        if !normalized.chars().any(|c| {
                          ^348               ^348
  ------------------
  |  Branch (2561:12): [True: 345, False: 3]
  ------------------
 2562|  3.55k|            matches!(
 2563|  3.56k|                c,
 2564|       |                '\u{2011}'
 2565|       |                    | '\u{00AD}'
 2566|       |                    | '\u{2010}'
 2567|       |                    | '\u{2212}'
 2568|       |                    | '\u{2013}'
 2569|       |                    | '\u{2014}'
 2570|       |                    | '\u{00A0}'
 2571|       |                    | '\u{202F}'
 2572|       |                    | '\u{2190}'
 2573|       |                    | '\u{2192}'
 2574|       |                    | '\u{2191}'
 2575|       |                    | '\u{2193}'
 2576|       |            )
 2577|  3.56k|        }) {
 2578|    345|            return normalized;
 2579|      3|        }
 2580|       |
 2581|      3|        let mut out = String::with_capacity(normalized.len());
 2582|     15|        for ch in normalized.chars() {
                                ^3         ^3
 2583|     15|            match ch {
 2584|       |                '\u{2011}' | '\u{00AD}' | '\u{2010}' | '\u{2212}' | '\u{2013}' | '\u{2014}' => {
 2585|      1|                    out.push('-')
 2586|       |                }
 2587|      1|                '\u{00A0}' | '\u{202F}' => out.push(' '),
 2588|      1|                '\u{2190}' => {
 2589|      1|                    out.push('<');
 2590|      1|                    out.push('-');
 2591|      1|                }
 2592|      2|                '\u{2192}' => {
 2593|      2|                    out.push('-');
 2594|      2|                    out.push('>');
 2595|      2|                }
 2596|      1|                '\u{2191}' => {
 2597|      1|                    out.push('^');
 2598|      1|                }
 2599|      1|                '\u{2193}' => {
 2600|      1|                    out.push('v');
 2601|      1|                }
 2602|      8|                _ => out.push(ch),
 2603|       |            }
 2604|       |        }
 2605|      3|        out
 2606|    348|    }
 2607|       |
 2608|       |    #[cfg(test)]
 2609|      3|    pub(crate) fn normalize_text_for_test(&self, text: &str) -> String {
 2610|      3|        self.fix_unicode_chars(text)
 2611|      3|    }
 2612|       |
 2613|       |    /// Render a single inline span    /// Render a single inline span
 2614|    152|    fn render_inline_span(
 2615|    152|        &self,
 2616|    152|        ui: &mut egui::Ui,
 2617|    152|        span: &InlineSpan,
 2618|    152|        font_size: Option<f32>,
 2619|    152|        strong: Option<bool>,
 2620|    152|    ) {
 2621|    152|        let size = font_size.unwrap_or(self.font_sizes.body);
 2622|    152|        let is_strong = strong.unwrap_or(false);
 2623|       |
 2624|    152|        match span {
 2625|     83|            InlineSpan::Text(text) => {
 2626|     83|                let fixed_text = self.fix_unicode_chars(text);
 2627|     83|                let style = InlineStyle {
 2628|     83|                    strong: is_strong,
 2629|     83|                    ..Default::default()
 2630|     83|                };
 2631|     83|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 2632|     83|            }
 2633|     13|            InlineSpan::Code(code) => {
 2634|       |                // Inline code: adapt style to theme (light vs dark)
 2635|     13|                ui.spacing_mut().item_spacing.x = 0.0;
 2636|     13|                let is_dark = ui.visuals().dark_mode;
 2637|     13|                let (bg, fg) = if is_dark {
  ------------------
  |  Branch (2637:35): [True: 12, False: 1]
  ------------------
 2638|     12|                    (
 2639|     12|                        Color32::from_rgb(30, 30, 30),
 2640|     12|                        Color32::from_rgb(180, 255, 180),
 2641|     12|                    )
 2642|       |                } else {
 2643|       |                    // Light theme: white background with readable code color
 2644|      1|                    (Color32::WHITE, Color32::from_rgb(60, 80, 150))
 2645|       |                };
 2646|     13|                let response = ui.add(
 2647|     13|                    egui::Label::new(
 2648|     13|                        RichText::new(code.clone())
 2649|     13|                            .size(self.font_sizes.code)
 2650|     13|                            .family(egui::FontFamily::Monospace)
 2651|     13|                            .background_color(bg)
 2652|     13|                            .color(fg),
 2653|       |                    )
 2654|     13|                    .wrap(false),
 2655|       |                );
 2656|       |
 2657|       |                // Add context menu for code
 2658|     13|                response.context_menu(|ui| {
                                                         ^0
 2659|      0|                    self.render_inline_code_context_menu(ui, code);
 2660|      0|                });
 2661|       |            }
 2662|     27|            InlineSpan::Strong(text) => {
 2663|     27|                let fixed_text = self.fix_unicode_chars(text);
 2664|     27|                let style = InlineStyle {
 2665|     27|                    strong: true,
 2666|     27|                    ..Default::default()
 2667|     27|                };
 2668|     27|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 2669|     27|            }
 2670|      5|            InlineSpan::Emphasis(text) => {
 2671|      5|                let fixed_text = self.fix_unicode_chars(text);
 2672|      5|                let style = InlineStyle {
 2673|      5|                    italics: true,
 2674|      5|                    strong: is_strong,
 2675|      5|                    ..Default::default()
 2676|      5|                };
 2677|      5|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 2678|      5|            }
 2679|      2|            InlineSpan::Strikethrough(text) => {
 2680|      2|                let fixed_text = self.fix_unicode_chars(text);
 2681|      2|                let style = InlineStyle {
 2682|      2|                    strike: true,
 2683|      2|                    strong: is_strong,
 2684|      2|                    ..Default::default()
 2685|      2|                };
 2686|      2|                self.render_text_with_emojis(ui, &fixed_text, size, style);
 2687|      2|            }
 2688|      6|            InlineSpan::Link { text, url } => {
 2689|      6|                let fixed_text = self.fix_unicode_chars(text);
 2690|      6|                let group = ui.horizontal_wrapped(|ui| {
 2691|       |                    // Render link-like styled text with emoji expansion
 2692|      6|                    let color = if Self::is_external_url(url) {
  ------------------
  |  Branch (2692:36): [True: 4, False: 2]
  ------------------
 2693|       |                        // Slightly different color to indicate external website links
 2694|      4|                        Color32::from_rgb(120, 190, 255)
 2695|       |                    } else {
 2696|      2|                        Color32::LIGHT_BLUE
 2697|       |                    };
 2698|      6|                    let style = InlineStyle {
 2699|      6|                        strong: is_strong,
 2700|      6|                        color: Some(color),
 2701|      6|                        ..Default::default()
 2702|      6|                    };
 2703|      6|                    self.render_text_with_emojis(ui, &fixed_text, size, style);
 2704|      6|                });
 2705|       |                // Use a unique id per link occurrence to avoid collisions when the same URL appears multiple times
 2706|      6|                let mut counter = self.link_counter.borrow_mut();
 2707|      6|                let id = egui::Id::new(format!("link:{}:{}", *counter, url));
 2708|      6|                *counter += 1;
 2709|      6|                let r = ui.interact(group.response.rect, id, egui::Sense::click());
 2710|      6|                if render_action_triggered(r.hovered(), "link_hover") {
  ------------------
  |  Branch (2710:20): [True: 3, False: 3]
  ------------------
 2711|      3|                    ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
 2712|      3|                }
 2713|      6|                if render_action_triggered(r.clicked(), "link_click") {
  ------------------
  |  Branch (2713:20): [True: 3, False: 3]
  ------------------
 2714|      3|                    self.trigger_link(url);
 2715|      3|                }
 2716|       |
 2717|       |                // Add context menu for links
 2718|      6|                r.context_menu(|ui| {
                                                  ^0
 2719|      0|                    self.render_link_context_menu(ui, text, url);
 2720|      0|                });
 2721|       |            }
 2722|     16|            InlineSpan::Image { src, alt, title } => {
 2723|       |                // Resolve path
 2724|     16|                let resolved = self.resolve_image_path(src);
 2725|     16|                let available_w = ui.available_width().max(1.0);
 2726|       |                // Try to get or load texture
 2727|     16|                if let Some((tex, w, h)) = self.get_or_load_image_texture(ui, &resolved) {
                                           ^5   ^5 ^5
  ------------------
  |  Branch (2727:24): [True: 5, False: 11]
  ------------------
 2728|      5|                    let (tw, th) = (w as f32, h as f32);
 2729|       |                    // Scale logic:
 2730|       |                    // - Start at UI scale (e.g., 1.0 for 100%, 1.1 for 110%).
 2731|       |                    // - Only downscale further if it would exceed available width.
 2732|      5|                    let base_scale = self.ui_scale();
 2733|      5|                    let scaled_w = tw * base_scale;
 2734|      5|                    let scale = if scaled_w > available_w {
  ------------------
  |  Branch (2734:36): [True: 1, False: 4]
  ------------------
 2735|      1|                        (available_w / tw).clamp(0.01, 4.0)
 2736|       |                    } else {
 2737|      4|                        base_scale
 2738|       |                    };
 2739|      5|                    let size = egui::vec2((tw * scale).round(), (th * scale).round());
 2740|      5|                    let image = egui::Image::new(&tex).fit_to_exact_size(size);
 2741|      5|                    let resp = ui.add(image);
 2742|      5|                    if let Some(t) = title {
                                              ^4
  ------------------
  |  Branch (2742:28): [True: 4, False: 1]
  ------------------
 2743|      4|                        if !t.is_empty() {
  ------------------
  |  Branch (2743:28): [True: 4, False: 0]
  ------------------
 2744|      4|                            if render_action_triggered(resp.hovered(), "image_hover") {
  ------------------
  |  Branch (2744:32): [True: 1, False: 3]
  ------------------
 2745|      1|                                resp.on_hover_text(t.clone());
 2746|      3|                            }
 2747|       |                            // Subtle caption below image
 2748|      4|                            ui.add_space(2.0);
 2749|      4|                            ui.label(
 2750|      4|                                RichText::new(t.clone())
 2751|      4|                                    .size(self.font_sizes.body - 2.0)
 2752|      4|                                    .color(Color32::from_rgb(140, 140, 140)),
 2753|       |                            );
 2754|      0|                        }
 2755|      1|                    }
 2756|      5|                    ui.add_space(6.0);
 2757|       |                } else {
 2758|       |                    // Placeholder with alt and error info
 2759|     11|                    egui::Frame::none()
 2760|     11|                        .fill(Color32::from_rgb(30, 30, 30))
 2761|     11|                        .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 2762|     11|                        .inner_margin(8.0)
 2763|     11|                        .show(ui, |ui| {
 2764|     11|                            let pending = self.image_pending.borrow().contains(&resolved);
 2765|     11|                            let msg = if pending {
  ------------------
  |  Branch (2765:42): [True: 5, False: 6]
  ------------------
 2766|      5|                                "Loading image..."
 2767|      6|                            } else if src.starts_with("http://") || src.starts_with("https://") {
                                                                                  ^5
  ------------------
  |  Branch (2767:39): [True: 1, False: 5]
  |  Branch (2767:69): [True: 2, False: 3]
  ------------------
 2768|      3|                                "Remote images are disabled"
 2769|       |                            } else {
 2770|      3|                                "Image not found or unsupported"
 2771|       |                            };
 2772|     11|                            let label = if alt.is_empty() {
  ------------------
  |  Branch (2772:44): [True: 1, False: 10]
  ------------------
 2773|      1|                                src.as_str()
 2774|       |                            } else {
 2775|     10|                                alt.as_str()
 2776|       |                            };
 2777|     11|                            ui.label(
 2778|     11|                                RichText::new(format!("{}\n{}", label, msg))
 2779|     11|                                    .size(self.font_sizes.body),
 2780|       |                            );
 2781|     11|                        });
 2782|     11|                    ui.add_space(6.0);
 2783|       |                }
 2784|       |            }
 2785|       |        }
 2786|    152|    }
 2787|       |
 2788|     10|    fn extract_fragment(url: &str) -> Option<String> {
 2789|     10|        if let Some(stripped) = url.strip_prefix('#') {
                                  ^4
  ------------------
  |  Branch (2789:16): [True: 4, False: 6]
  ------------------
 2790|       |            // Already a fragment within current document
 2791|      4|            return Some(stripped.to_ascii_lowercase());
 2792|      6|        }
 2793|      6|        None
 2794|     10|    }
 2795|       |
 2796|     22|    fn is_external_url(url: &str) -> bool {
 2797|     22|        let lower = url.to_ascii_lowercase();
 2798|     22|        lower.starts_with("http://")
  ------------------
  |  Branch (2798:9): [True: 1, False: 21]
  ------------------
 2799|     21|            || lower.starts_with("https://")
  ------------------
  |  Branch (2799:16): [True: 15, False: 6]
  ------------------
 2800|      6|            || lower.starts_with("mailto:")
  ------------------
  |  Branch (2800:16): [True: 1, False: 5]
  ------------------
 2801|      5|            || lower.starts_with("www.")
 2802|     22|    }
 2803|       |
 2804|    124|    fn render_text_with_emojis(
 2805|    124|        &self,
 2806|    124|        ui: &mut egui::Ui,
 2807|    124|        text: &str,
 2808|    124|        size: f32,
 2809|    124|        style: InlineStyle,
 2810|    124|    ) {
 2811|    124|        let mut buffer = String::new();
 2812|  2.24k|        for g in text.graphemes(true) {
                               ^124 ^124
 2813|  2.24k|            if let Some(key) = self.emoji_key_for_grapheme(g) {
                                      ^5
  ------------------
  |  Branch (2813:20): [True: 5, False: 2.24k]
  ------------------
 2814|       |                // Flush buffered text first (with highlighting if active)
 2815|      5|                if !buffer.is_empty() {
  ------------------
  |  Branch (2815:20): [True: 4, False: 1]
  ------------------
 2816|      4|                    self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
 2817|      4|                    buffer.clear();
 2818|      4|                }
                              ^1
 2819|      5|                let handle = self.get_or_make_emoji_texture(ui, &key);
 2820|      5|                let sz = size * 1.2;
 2821|      5|                ui.add(egui::Image::new(&handle).max_width(sz).max_height(sz));
 2822|  2.24k|            } else {
 2823|  2.24k|                buffer.push_str(g);
 2824|  2.24k|            }
 2825|       |        }
 2826|    124|        if !buffer.is_empty() {
  ------------------
  |  Branch (2826:12): [True: 123, False: 1]
  ------------------
 2827|    123|            self.render_text_segment_with_optional_highlight(ui, &buffer, size, style);
 2828|    123|        }
                      ^1
 2829|    124|    }
 2830|       |
 2831|    127|    fn render_text_segment_with_optional_highlight(
 2832|    127|        &self,
 2833|    127|        ui: &mut egui::Ui,
 2834|    127|        segment: &str,
 2835|    127|        size: f32,
 2836|    127|        style: InlineStyle,
 2837|    127|    ) {
 2838|       |        // First expand emoji shortcodes, then superscript ^...^ notation
 2839|    127|        let expanded = Self::expand_shortcodes(segment);
 2840|    127|        let expanded = Self::expand_superscripts(&expanded);
 2841|    127|        if let Some(h) = self
                                  ^21
  ------------------
  |  Branch (2841:16): [True: 21, False: 106]
  ------------------
 2842|    127|            .highlight_phrase
 2843|    127|            .borrow()
 2844|    127|            .as_ref()
 2845|    127|            .filter(|s| !s.is_empty())
                                       ^21^21
 2846|       |        {
 2847|     25|            for (range, highlighted) in self.highlight_segments(&expanded, Some(h)) {
                                                      ^21  ^21                ^21        ^21
 2848|     25|                if range.is_empty() {
  ------------------
  |  Branch (2848:20): [True: 0, False: 25]
  ------------------
 2849|      0|                    continue;
 2850|     25|                }
 2851|     25|                let slice = &expanded[range];
 2852|     25|                if highlighted {
  ------------------
  |  Branch (2852:20): [True: 9, False: 16]
  ------------------
 2853|      9|                    self.render_highlighted_segment(ui, slice, size, style);
 2854|     16|                } else {
 2855|     16|                    self.render_plain_segment(ui, slice, size, style);
 2856|     16|                }
 2857|       |            }
 2858|     21|            return;
 2859|    106|        }
 2860|    106|        self.render_plain_segment(ui, &expanded, size, style);
 2861|    127|    }
 2862|       |
 2863|    124|    fn render_plain_segment(&self, ui: &mut egui::Ui, text: &str, size: f32, style: InlineStyle) {
 2864|    124|        if text.is_empty() {
  ------------------
  |  Branch (2864:12): [True: 1, False: 123]
  ------------------
 2865|      1|            return;
 2866|    123|        }
 2867|    123|        let mut rich = RichText::new(text).size(size);
 2868|    123|        if style.strong {
  ------------------
  |  Branch (2868:12): [True: 45, False: 78]
  ------------------
 2869|     45|            rich = rich.strong();
 2870|     78|        }
 2871|    123|        if style.italics {
  ------------------
  |  Branch (2871:12): [True: 7, False: 116]
  ------------------
 2872|      7|            rich = rich.italics();
 2873|    116|        }
 2874|    123|        if style.strike {
  ------------------
  |  Branch (2874:12): [True: 1, False: 122]
  ------------------
 2875|      1|            rich = rich.strikethrough();
 2876|    122|        }
 2877|    123|        let mut text_color = style.color;
 2878|    123|        if text_color.is_none() && style.strong {
                                                 ^117
  ------------------
  |  Branch (2878:12): [True: 117, False: 6]
  |  Branch (2878:36): [True: 45, False: 72]
  ------------------
 2879|     45|            if let Some(override_color) = ui.visuals().override_text_color {
                                      ^1
  ------------------
  |  Branch (2879:20): [True: 1, False: 44]
  ------------------
 2880|      1|                text_color = Some(override_color);
 2881|     44|            }
 2882|     78|        }
 2883|    123|        if let Some(color) = text_color {
                                  ^7
  ------------------
  |  Branch (2883:16): [True: 7, False: 116]
  ------------------
 2884|      7|            rich = rich.color(color);
 2885|    116|        }
 2886|    123|        let response = ui.add(egui::Label::new(rich).wrap(true));
 2887|       |
 2888|       |        // Add context menu for text
 2889|       |        // Note: Due to egui limitations, selection is cleared on right-click
 2890|       |        // As a workaround, we provide "Copy Text" for the segment
 2891|    123|        response.context_menu(|ui| {
                                                 ^0
 2892|      0|            self.render_text_context_menu(ui, text);
 2893|      0|        });
 2894|    124|    }
 2895|       |
 2896|     10|    fn render_highlighted_segment(
 2897|     10|        &self,
 2898|     10|        ui: &mut egui::Ui,
 2899|     10|        text: &str,
 2900|     10|        size: f32,
 2901|     10|        style: InlineStyle,
 2902|     10|    ) {
 2903|     10|        if text.is_empty() {
  ------------------
  |  Branch (2903:12): [True: 1, False: 9]
  ------------------
 2904|      1|            return;
 2905|      9|        }
 2906|      9|        let visuals = ui.visuals();
 2907|      9|        let bg = visuals.selection.bg_fill;
 2908|      9|        let mut text_color = style.color;
 2909|      9|        let fallback_color = visuals.selection.stroke.color;
 2910|      9|        if text_color.is_none() {
  ------------------
  |  Branch (2910:12): [True: 8, False: 1]
  ------------------
 2911|      8|            text_color = Some(fallback_color);
 2912|      8|        }
                      ^1
 2913|       |
 2914|      9|        let mut rich = RichText::new(text).size(size).background_color(bg);
 2915|      9|        if style.strong {
  ------------------
  |  Branch (2915:12): [True: 3, False: 6]
  ------------------
 2916|      3|            rich = rich.strong();
 2917|      6|        }
 2918|      9|        if style.italics {
  ------------------
  |  Branch (2918:12): [True: 1, False: 8]
  ------------------
 2919|      1|            rich = rich.italics();
 2920|      8|        }
 2921|      9|        if style.strike {
  ------------------
  |  Branch (2921:12): [True: 1, False: 8]
  ------------------
 2922|      1|            rich = rich.strikethrough();
 2923|      8|        }
 2924|      9|        if let Some(color) = text_color {
  ------------------
  |  Branch (2924:16): [True: 9, False: 0]
  ------------------
 2925|      9|            rich = rich.color(color);
 2926|      9|        }
                      ^0
 2927|      9|        let response = ui.add(egui::Label::new(rich).wrap(true));
 2928|       |
 2929|       |        // Add context menu for highlighted text
 2930|      9|        response.context_menu(|ui| {
                                                 ^0
 2931|      0|            self.render_text_context_menu(ui, text);
 2932|      0|        });
 2933|     10|    }
 2934|       |
 2935|      1|    fn render_text_context_menu(&self, ui: &mut egui::Ui, text: &str) {
 2936|      1|        if render_action_triggered(ui.button("Copy Text").clicked(), "copy_text") {
  ------------------
  |  Branch (2936:12): [True: 1, False: 0]
  ------------------
 2937|      1|            self.copy_text_and_close(ui, text);
 2938|      1|        }
                      ^0
 2939|      1|        ui.label("Tip: Use Ctrl+C to copy selected text");
 2940|      1|    }
 2941|       |
 2942|      1|    fn render_inline_code_context_menu(&self, ui: &mut egui::Ui, code: &str) {
 2943|      1|        if render_action_triggered(ui.button("Copy Code").clicked(), "copy_inline_code") {
  ------------------
  |  Branch (2943:12): [True: 1, False: 0]
  ------------------
 2944|      1|            self.copy_text_and_close(ui, code);
 2945|      1|        }
                      ^0
 2946|      1|    }
 2947|       |
 2948|      3|    fn render_code_block_context_menu(
 2949|      3|        &self,
 2950|      3|        ui: &mut egui::Ui,
 2951|      3|        code: &str,
 2952|      3|        language: Option<&str>,
 2953|      3|    ) {
 2954|      3|        if render_action_triggered(ui.button("Copy Code").clicked(), "copy_code_block") {
  ------------------
  |  Branch (2954:12): [True: 1, False: 2]
  ------------------
 2955|      1|            self.copy_text_and_close(ui, code);
 2956|      2|        }
 2957|      3|        if let Some(lang) = language {
  ------------------
  |  Branch (2957:16): [True: 3, False: 0]
  ------------------
 2958|      3|            if render_action_triggered(
  ------------------
  |  Branch (2958:16): [True: 2, False: 1]
  ------------------
 2959|      3|                ui.button(format!("Copy as {}", lang)).clicked(),
 2960|       |                "copy_code_block_lang",
 2961|      2|            ) {
 2962|      2|                self.copy_text_and_close(ui, &format!("```{}\n{}\n```", lang, code));
 2963|      2|            }
                          ^1
 2964|      0|        }
 2965|      3|    }
 2966|       |
 2967|      1|    fn render_link_context_menu(&self, ui: &mut egui::Ui, text: &str, url: &str) {
 2968|      1|        if render_action_triggered(ui.button("Open Link").clicked(), "open_link") {
  ------------------
  |  Branch (2968:12): [True: 1, False: 0]
  ------------------
 2969|      1|            self.trigger_link(url);
 2970|      1|            ui.close_menu();
 2971|      1|        }
                      ^0
 2972|      1|        ui.separator();
 2973|      1|        if render_action_triggered(ui.button("Copy Link Text").clicked(), "copy_link_text") {
  ------------------
  |  Branch (2973:12): [True: 1, False: 0]
  ------------------
 2974|      1|            self.copy_text_and_close(ui, text);
 2975|      1|        }
                      ^0
 2976|      1|        if render_action_triggered(ui.button("Copy Link URL").clicked(), "copy_link_url") {
  ------------------
  |  Branch (2976:12): [True: 1, False: 0]
  ------------------
 2977|      1|            self.copy_text_and_close(ui, url);
 2978|      1|        }
                      ^0
 2979|      1|    }
 2980|       |
 2981|      1|    fn render_cell_context_menu(&self, ui: &mut egui::Ui, text: &str) {
 2982|      1|        if render_action_triggered(ui.button("Copy Cell Text").clicked(), "copy_cell_text") {
  ------------------
  |  Branch (2982:12): [True: 1, False: 0]
  ------------------
 2983|      1|            self.copy_text_and_close(ui, text);
 2984|      1|        }
                      ^0
 2985|      1|    }
 2986|       |
 2987|      9|    fn copy_text_and_close(&self, ui: &mut egui::Ui, text: &str) {
 2988|      9|        ui.ctx().copy_text(text.to_string());
 2989|      9|        ui.close_menu();
 2990|      9|    }
 2991|       |
 2992|       |    /// Map a grapheme cluster to an emoji image key if available.
 2993|  2.27k|    fn emoji_key_for_grapheme(&self, g: &str) -> Option<String> {
 2994|  2.27k|        if crate::emoji_catalog::image_bytes_for(g).is_some() {
  ------------------
  |  Branch (2994:12): [True: 5, False: 2.26k]
  ------------------
 2995|      5|            return Some(g.to_string());
 2996|  2.26k|        }
 2997|  2.27k|        let stripped: String = g.chars().filter(|&c| c != '\u{FE0F}').collect();
                          ^2.26k    ^2.26k   ^2.26k^2.26k  ^2.26k                       ^2.26k
 2998|  2.26k|        if stripped != g && crate::emoji_catalog::image_bytes_for(&stripped).is_some() {
                                          ^4                                               ^4
  ------------------
  |  Branch (2998:12): [True: 4, False: 2.26k]
  |  Branch (2998:29): [True: 1, False: 3]
  ------------------
 2999|      1|            return Some(stripped);
 3000|  2.26k|        }
 3001|       |        // If the grapheme explicitly requests emoji presentation (contains VS16),
 3002|       |        // treat it as an emoji even if we don't have a sprite; fall back to a
 3003|       |        // generated placeholder via emoji_assets to avoid stray tofu.
 3004|  2.27k|        if g.chars().any(|c| c == '\u{FE0F}') {
                         ^2.26k    ^2.26k
  ------------------
  |  Branch (3004:12): [True: 3, False: 2.26k]
  ------------------
 3005|      3|            return Some(stripped); // prefer stripped as the texture key
 3006|  2.26k|        }
 3007|  2.26k|        None
 3008|  2.27k|    }
 3009|       |
 3010|      9|    fn get_or_make_emoji_texture(&self, ui: &mut egui::Ui, emoji: &str) -> egui::TextureHandle {
 3011|      9|        if let Some(tex) = self.emoji_textures.borrow().get(emoji) {
                                  ^1
  ------------------
  |  Branch (3011:16): [True: 1, False: 8]
  ------------------
 3012|      1|            return tex.clone();
 3013|      8|        }
 3014|       |
 3015|      8|        let img = if let Some(bytes) = emoji_catalog::image_bytes_for(emoji) {
                                            ^4
  ------------------
  |  Branch (3015:26): [True: 4, False: 4]
  ------------------
 3016|      4|            match image::load_from_memory(bytes) {
 3017|      4|                Ok(dyn_img) => {
 3018|      4|                    let rgba = dyn_img.to_rgba8();
 3019|      4|                    let (w, h) = rgba.dimensions();
 3020|      4|                    let pixels = rgba.into_vec();
 3021|      4|                    egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &pixels)
 3022|       |                }
 3023|      0|                Err(_) => emoji_assets::make_image(emoji, 64)
 3024|      0|                    .unwrap_or_else(|| self.generate_emoji_image(emoji, 64)),
 3025|       |            }
 3026|       |        } else {
 3027|      4|            emoji_assets::make_image(emoji, 64)
 3028|      4|                .unwrap_or_else(|| self.generate_emoji_image(emoji, 64))
                                                 ^1   ^1                   ^1
 3029|       |        };
 3030|      8|        let handle = ui.ctx().load_texture(
 3031|      8|            format!("emoji:{}", emoji),
 3032|      8|            img,
 3033|       |            egui::TextureOptions::LINEAR,
 3034|       |        );
 3035|      8|        self.emoji_textures
 3036|      8|            .borrow_mut()
 3037|      8|            .insert(emoji.to_string(), handle.clone());
 3038|      8|        handle
 3039|      9|    }
 3040|       |
 3041|       |    #[cfg(test)]
 3042|       |    // Rough width measurement for inline spans without wrapping
 3043|      8|    fn measure_inline_spans(&self, ui: &egui::Ui, spans: &[InlineSpan]) -> f32 {
 3044|      8|        let mut max_line_width = 0.0f32;
 3045|      8|        let mut current_line_width = 0.0f32;
 3046|      8|        ui.fonts(|fonts| {
 3047|      8|            let body = egui::FontId::proportional(self.font_sizes.body);
 3048|      8|            let mono = egui::FontId::monospace(self.font_sizes.code);
 3049|     23|            for span in spans {
                              ^15
 3050|     15|                match span {
 3051|      7|                    InlineSpan::Text(t)
 3052|      1|                    | InlineSpan::Strong(t)
 3053|      1|                    | InlineSpan::Emphasis(t)
 3054|      1|                    | InlineSpan::Strikethrough(t)
 3055|      1|                    | InlineSpan::Link { text: t, .. } => {
 3056|       |                        // Normalize to match render path before measuring.
 3057|     11|                        let mut normalized = self.fix_unicode_chars(t);
 3058|     11|                        normalized = Self::expand_shortcodes(&normalized);
 3059|     11|                        normalized = Self::expand_superscripts(&normalized);
 3060|     16|                        for (line_idx, line) in normalized.split('\n').enumerate() {
                                                              ^11                    ^11
 3061|     16|                            if line_idx > 0 {
  ------------------
  |  Branch (3061:32): [True: 5, False: 11]
  ------------------
 3062|      5|                                max_line_width = max_line_width.max(current_line_width);
 3063|      5|                                current_line_width = 0.0;
 3064|     11|                            }
 3065|     16|                            if line.is_empty() {
  ------------------
  |  Branch (3065:32): [True: 3, False: 13]
  ------------------
 3066|      3|                                continue;
 3067|     13|                            }
 3068|     13|                            let galley = fonts.layout_no_wrap(
 3069|     13|                                line.to_string(),
 3070|     13|                                body.clone(),
 3071|       |                                Color32::WHITE,
 3072|       |                            );
 3073|     13|                            let mut line_width = galley.size().x;
 3074|       |                            // Add a small extra width for emoji images (drawn larger than text).
 3075|     13|                            let emoji_extra =
 3076|    102|                                line.chars().filter(|c| Self::is_known_emoji(*c)).count() as f32
                                              ^13  ^13     ^13                                  ^13
 3077|     13|                                    * (self.font_sizes.body * 0.2);
 3078|     13|                            line_width += emoji_extra;
 3079|     13|                            if current_line_width > 0.0 {
  ------------------
  |  Branch (3079:32): [True: 3, False: 10]
  ------------------
 3080|      3|                                current_line_width += 4.0;
 3081|     10|                            }
 3082|     13|                            current_line_width += line_width;
 3083|       |                        }
 3084|       |                    }
 3085|      2|                    InlineSpan::Code(code) => {
 3086|      5|                        for (line_idx, line) in code.split('\n').enumerate() {
                                                              ^2               ^2
 3087|      5|                            if line_idx > 0 {
  ------------------
  |  Branch (3087:32): [True: 3, False: 2]
  ------------------
 3088|      3|                                max_line_width = max_line_width.max(current_line_width);
 3089|      3|                                current_line_width = 0.0;
 3090|      3|                            }
                                          ^2
 3091|      5|                            if line.is_empty() {
  ------------------
  |  Branch (3091:32): [True: 1, False: 4]
  ------------------
 3092|      1|                                continue;
 3093|      4|                            }
 3094|      4|                            let galley = fonts.layout_no_wrap(
 3095|      4|                                line.to_string(),
 3096|      4|                                mono.clone(),
 3097|       |                                Color32::WHITE,
 3098|       |                            );
 3099|      4|                            let line_width = galley.size().x + 6.0; // padding for code background
 3100|      4|                            if current_line_width > 0.0 {
  ------------------
  |  Branch (3100:32): [True: 1, False: 3]
  ------------------
 3101|      1|                                current_line_width += 4.0;
 3102|      3|                            }
 3103|      4|                            current_line_width += line_width;
 3104|       |                        }
 3105|       |                    }
 3106|      2|                    InlineSpan::Image { src, .. } => {
 3107|       |                        // Use cached texture size if available; otherwise a conservative thumbnail.
 3108|      2|                        let cap = (ui.available_width() * 0.6).max(48.0);
 3109|      2|                        let cached = self
 3110|      2|                            .image_textures
 3111|      2|                            .borrow_mut()
 3112|      2|                            .get(src)
 3113|      2|                            .map(|entry| entry.size[0] as f32 * self.ui_scale());
                                                       ^1                     ^1   ^1
 3114|      2|                        let approx = cached.unwrap_or(self.font_sizes.body * 12.0);
 3115|      2|                        let line_width = approx.min(cap);
 3116|      2|                        if current_line_width > 0.0 {
  ------------------
  |  Branch (3116:28): [True: 1, False: 1]
  ------------------
 3117|      1|                            current_line_width += 4.0;
 3118|      1|                        }
 3119|      2|                        current_line_width += line_width;
 3120|       |                    }
 3121|       |                }
 3122|       |            }
 3123|      8|        });
 3124|      8|        max_line_width.max(current_line_width)
 3125|      8|    }
 3126|       |
 3127|       |    #[cfg(test)]
 3128|    102|    fn is_known_emoji(c: char) -> bool {
 3129|    101|        matches!(
 3130|    102|            c,
 3131|       |            '\u{1f389}' // 
 3132|       |                | '\u{2705}' // 
 3133|       |                | '\u{1f680}' // 
 3134|       |                | '\u{1f642}' // 
 3135|       |                | '\u{1f600}' // 
 3136|       |                | '\u{1f609}' // 
 3137|       |                | '\u{2b50}'  // 
 3138|       |                | '\u{1f525}' // 
 3139|       |                | '\u{1f44d}' // 
 3140|       |                | '\u{1f44e}' // 
 3141|       |                | '\u{1f4a1}' // 
 3142|       |                | '\u{2753}'  // 
 3143|       |                | '\u{2757}'  // 
 3144|       |                | '\u{1f4dd}' // 
 3145|       |                | '\u{1f9e0}' // 
 3146|       |                | '\u{1f9ea}' // 
 3147|       |                | '\u{1f4e6}' // 
 3148|       |                | '\u{1f527}' // 
 3149|       |        )
 3150|    102|    }
 3151|       |
 3152|    353|    fn expand_shortcodes(s: &str) -> String {
 3153|       |        use crate::emoji_catalog::shortcode_map;
 3154|    353|        if !s.contains(':') {
  ------------------
  |  Branch (3154:12): [True: 339, False: 14]
  ------------------
 3155|    339|            return s.to_string();
 3156|     14|        }
 3157|     14|        let mut out = String::new();
 3158|     14|        let map = shortcode_map();
 3159|     14|        let mut i = 0;
 3160|     14|        let bytes = s.as_bytes();
 3161|    223|        while i < s.len() {
  ------------------
  |  Branch (3161:15): [True: 209, False: 14]
  ------------------
 3162|    209|            if bytes[i] == b':' {
  ------------------
  |  Branch (3162:16): [True: 15, False: 194]
  ------------------
 3163|    176|                if let Some(end_rel) = bytes[i + 1..].iter().position(|&b| b == b':') {
                                          ^5         ^15                   ^15
  ------------------
  |  Branch (3163:24): [True: 5, False: 10]
  ------------------
 3164|      5|                    let end = i + 1 + end_rel;
 3165|      5|                    let code = &s[i..=end];
 3166|      5|                    if let Some(&emoji) = map.get(code) {
                                               ^4
  ------------------
  |  Branch (3166:28): [True: 4, False: 1]
  ------------------
 3167|      4|                        out.push_str(emoji);
 3168|      4|                        i = end + 1;
 3169|      4|                        continue;
 3170|      1|                    }
 3171|     10|                }
 3172|    194|            }
 3173|       |            // advance by one UTF-8 character
 3174|    205|            let ch = s[i..].chars().next().unwrap();
 3175|    205|            out.push(ch);
 3176|    205|            i += ch.len_utf8();
 3177|       |        }
 3178|     14|        out
 3179|    353|    }
 3180|       |
 3181|       |    // Expand ^...^ segments into Unicode superscript characters when available.
 3182|       |    // Example: "5^th^" -> "5??"
 3183|    357|    fn expand_superscripts(s: &str) -> String {
 3184|    357|        if !s.contains('^') {
  ------------------
  |  Branch (3184:12): [True: 349, False: 8]
  ------------------
 3185|    349|            return s.to_string();
 3186|      8|        }
 3187|      8|        let mut out = String::new();
 3188|      8|        let mut chars = s.chars().peekable();
 3189|    203|        while let Some(c) = chars.next() {
                                     ^195
  ------------------
  |  Branch (3189:19): [True: 195, False: 8]
  ------------------
 3190|    195|            if c == '^' {
  ------------------
  |  Branch (3190:16): [True: 14, False: 181]
  ------------------
 3191|       |                // Look ahead to see if there's a matching closing caret within reasonable bounds
 3192|     14|                let mut buf = String::new();
 3193|     14|                let mut found_closing = false;
 3194|     14|                let mut temp_chars = chars.clone();
 3195|     14|                let mut char_count = 0;
 3196|       |
 3197|     41|                while let Some(&nc) = temp_chars.peek() {
                                              ^38
  ------------------
  |  Branch (3197:27): [True: 38, False: 3]
  ------------------
 3198|     38|                    if nc == '^' {
  ------------------
  |  Branch (3198:24): [True: 5, False: 33]
  ------------------
 3199|      5|                        found_closing = true;
 3200|      5|                        break;
 3201|     33|                    }
 3202|     33|                    if !nc.is_alphanumeric() && !matches!(nc, '+' | '-' | '=' | '(' | ')') {
                                                               ^5       ^6
  ------------------
  |  Branch (3202:24): [True: 6, False: 27]
  |  Branch (3202:49): [True: 5, False: 1]
  ------------------
 3203|      5|                        break;
 3204|     28|                    }
 3205|     28|                    if char_count >= 10 {
  ------------------
  |  Branch (3205:24): [True: 1, False: 27]
  ------------------
 3206|      1|                        break;
 3207|     27|                    }
 3208|     27|                    temp_chars.next();
 3209|     27|                    char_count += 1;
 3210|       |                }
 3211|       |
 3212|     14|                if found_closing && char_count > 0 {
                                                  ^5
  ------------------
  |  Branch (3212:20): [True: 5, False: 9]
  |  Branch (3212:37): [True: 4, False: 1]
  ------------------
 3213|      6|                    for nc in chars.by_ref().take(char_count) {
                                            ^4             ^4   ^4
 3214|      6|                        buf.push(nc);
 3215|      6|                    }
 3216|       |                    // Skip the closing caret
 3217|      4|                    chars.next();
 3218|      4|                    out.push_str(&Self::to_superscript(&buf));
 3219|     10|                } else {
 3220|     10|                    out.push('^');
 3221|     10|                }
 3222|    181|            } else {
 3223|    181|                out.push(c);
 3224|    181|            }
 3225|       |        }
 3226|      8|        out
 3227|    357|    }
 3228|       |
 3229|      6|    fn to_superscript(s: &str) -> String {
 3230|      6|        s.chars()
 3231|     81|            .map(|c| match c {
                           ^6
 3232|      1|                '0' => '\u{2070}',
 3233|      2|                '1' => '\u{00b9}',
 3234|      3|                '2' => '\u{00b2}',
 3235|      2|                '3' => '\u{00b3}',
 3236|      1|                '4' => '\u{2074}',
 3237|      1|                '5' => '\u{2075}',
 3238|      1|                '6' => '\u{2076}',
 3239|      1|                '7' => '\u{2077}',
 3240|      1|                '8' => '\u{2078}',
 3241|      1|                '9' => '\u{2079}',
 3242|      2|                '+' => '\u{207a}',
 3243|      1|                '-' => '\u{207b}',
 3244|      1|                '=' => '\u{207c}',
 3245|      1|                '(' => '\u{207d}',
 3246|      1|                ')' => '\u{207e}',
 3247|      3|                'a' | 'A' => '\u{1d43}',
 3248|      3|                'b' | 'B' => '\u{1d47}',
 3249|      3|                'c' | 'C' => '\u{1d9c}',
 3250|      2|                'd' | 'D' => '\u{1d48}',
 3251|      2|                'e' | 'E' => '\u{1d49}',
 3252|      2|                'f' | 'F' => '\u{1da0}',
 3253|      2|                'g' | 'G' => '\u{1d4d}',
 3254|      4|                'h' | 'H' => '\u{02b0}',
 3255|      2|                'i' | 'I' => '\u{2071}',
 3256|      2|                'j' | 'J' => '\u{02b2}',
 3257|      2|                'k' | 'K' => '\u{1d4f}',
 3258|      2|                'l' | 'L' => '\u{02e1}',
 3259|      2|                'm' | 'M' => '\u{1d50}',
 3260|      2|                'n' | 'N' => '\u{207f}',
 3261|      2|                'o' | 'O' => '\u{1d52}',
 3262|      2|                'p' | 'P' => '\u{1d56}',
 3263|      2|                'q' | 'Q' => '\u{1d56}',
 3264|      2|                'r' | 'R' => '\u{02b3}',
 3265|      2|                's' | 'S' => '\u{02e2}',
 3266|      4|                't' | 'T' => '\u{1d57}',
 3267|      2|                'u' | 'U' => '\u{1d58}',
 3268|      2|                'v' | 'V' => '\u{1d5b}',
 3269|      2|                'w' | 'W' => '\u{02b7}',
 3270|      2|                'x' | 'X' => '\u{02e3}',
 3271|      2|                'y' | 'Y' => '\u{02b8}',
 3272|      2|                'z' | 'Z' => '\u{1dbb}',
 3273|      2|                other => other,
 3274|     81|            })
 3275|      6|            .collect()
 3276|      6|    }
 3277|       |
 3278|     21|    fn generate_emoji_image(&self, emoji: &str, size: usize) -> egui::ColorImage {
 3279|       |        // Simple procedural placeholder icons to keep binary small and avoid external assets
 3280|       |        use egui::Color32 as C;
 3281|     21|        let mut img = egui::ColorImage::new([size, size], C::TRANSPARENT);
 3282|     21|        let cx = (size as i32) / 2;
 3283|     21|        let cy = cx;
 3284|     21|        let r = (size as i32) / 2 - 2;
 3285|       |
 3286|     21|        let (base, accent) = match emoji {
 3287|     21|            "\u{1f389}" => (C::from_rgb(255, 215, 0), C::from_rgb(255, 80, 80)),
                                         ^1
 3288|     20|            "\u{2705}" => (C::from_rgb(30, 150, 30), C::WHITE),
                                        ^1
 3289|     19|            "\u{1f680}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 100, 100)),
                                         ^1
 3290|     18|            "\u{1f642}" | "\u{1f600}" | "\u{1f609}" => {
                                        ^17           ^16
 3291|      3|                (C::from_rgb(255, 205, 64), C::from_rgb(90, 60, 10))
 3292|       |            }
 3293|     15|            "\u{2b50}" => (C::from_rgb(255, 215, 0), C::WHITE),
                                        ^1
 3294|     14|            "\u{1f525}" => (C::from_rgb(255, 120, 50), C::from_rgb(255, 200, 120)),
                                         ^1
 3295|     13|            "\u{1f44d}" | "\u{1f44e}" => (C::from_rgb(200, 200, 200), C::from_rgb(80, 80, 80)),
                                        ^12            ^2
 3296|     11|            "\u{1f4a1}" => (C::from_rgb(255, 240, 120), C::from_rgb(255, 255, 255)),
                                         ^1
 3297|     10|            "\u{2753}" | "\u{2757}" => (C::from_rgb(70, 70, 200), C::from_rgb(255, 255, 255)),
                                       ^9            ^2
 3298|      8|            "\u{1f4dd}" => (C::from_rgb(240, 240, 200), C::from_rgb(140, 140, 140)),
                                         ^1
 3299|      7|            "\u{1f9e0}" => (C::from_rgb(220, 160, 200), C::from_rgb(255, 255, 255)),
                                         ^1
 3300|      6|            "\u{1f9ea}" => (C::from_rgb(180, 220, 255), C::from_rgb(120, 160, 240)),
                                         ^1
 3301|      5|            "\u{1f4e6}" => (C::from_rgb(205, 170, 125), C::from_rgb(150, 110, 70)),
                                         ^1
 3302|      4|            "\u{1f527}" => (C::from_rgb(160, 170, 180), C::from_rgb(220, 220, 220)),
                                         ^1
 3303|      3|            _ => (C::from_rgb(180, 180, 180), C::WHITE),
 3304|       |        };
 3305|       |
 3306|       |        // draw filled circle
 3307|    232|        for y in 0..size as i32 {
                                  ^21
 3308|  5.56k|            for x in 0..size as i32 {
                                      ^232
 3309|  5.56k|                let dx = x - cx;
 3310|  5.56k|                let dy = y - cy;
 3311|  5.56k|                if dx * dx + dy * dy <= r * r {
  ------------------
  |  Branch (3311:20): [True: 3.18k, False: 2.38k]
  ------------------
 3312|  3.18k|                    img[(x as usize, y as usize)] = base;
 3313|  3.18k|                }
                              ^2.38k
 3314|       |            }
 3315|       |        }
 3316|       |
 3317|       |        // add a simple accent (diagonal highlight)
 3318|    232|        for t in 0..size {
                                  ^21
 3319|    232|            let x = t as i32;
 3320|    232|            let y = (t as i32) / 2;
 3321|    232|            let xx = (x / 2 + 6).clamp(0, size as i32 - 1) as usize;
 3322|    232|            let yy = (y + 6).clamp(0, size as i32 - 1) as usize;
 3323|    232|            img[(xx, yy)] = accent;
 3324|    232|        }
 3325|       |
 3326|     21|        img
 3327|     21|    }
 3328|       |
 3329|     28|    fn render_list_paragraph(
 3330|     28|        &self,
 3331|     28|        ui: &mut egui::Ui,
 3332|     28|        marker: Option<&str>,
 3333|     28|        marker_color: Color32,
 3334|     28|        indent_px: f32,
 3335|     28|        spans: &[InlineSpan],
 3336|     28|    ) {
 3337|       |        // Split into lines on embedded '\n'
 3338|     28|        let mut lines: Vec<Vec<InlineSpan>> = vec![Vec::new()];
 3339|     71|        for s in spans.iter().cloned() {
                               ^28   ^28    ^28
 3340|     37|            match s {
 3341|     37|                InlineSpan::Text(t) if t.contains('\n') => {
                                               ^2                   ^2
  ------------------
  |  Branch (3341:40): [True: 2, False: 35]
  ------------------
 3342|      2|                    let parts: Vec<&str> = t.split('\n').collect();
 3343|      5|                    for (pi, part) in parts.iter().enumerate() {
                                                    ^2           ^2
 3344|      5|                        if !part.is_empty() {
  ------------------
  |  Branch (3344:28): [True: 4, False: 1]
  ------------------
 3345|      4|                            lines
 3346|      4|                                .last_mut()
 3347|      4|                                .unwrap()
 3348|      4|                                .push(InlineSpan::Text(part.to_string()));
 3349|      4|                        }
                                      ^1
 3350|      5|                        if pi < parts.len() - 1 {
  ------------------
  |  Branch (3350:28): [True: 3, False: 2]
  ------------------
 3351|      3|                            lines.push(Vec::new());
 3352|      3|                        }
                                      ^2
 3353|       |                    }
 3354|       |                }
 3355|     69|                other => lines.last_mut().unwrap().push(other),
 3356|       |            }
 3357|       |        }
 3358|       |
 3359|     31|        for (li, mut line) in lines.into_iter().enumerate() {
                                            ^28   ^28         ^28
 3360|     31|            ui.horizontal_wrapped(|ui| {
 3361|     31|                if li == 0 {
  ------------------
  |  Branch (3361:20): [True: 28, False: 3]
  ------------------
 3362|     28|                    if let Some(marker) = marker {
                                              ^27
  ------------------
  |  Branch (3362:28): [True: 27, False: 1]
  ------------------
 3363|     27|                        ui.label(
 3364|     27|                            RichText::new(format!("{} ", marker))
 3365|     27|                                .size(self.font_sizes.body)
 3366|     27|                                .color(marker_color),
 3367|     27|                        );
 3368|     27|                    } else {
 3369|      1|                        ui.add_space(indent_px);
 3370|      1|                    }
 3371|       |                } else {
 3372|       |                    // Determine additional indentation from leading spaces in this line
 3373|      3|                    let mut leading_spaces = 0usize;
 3374|      3|                    if let Some(InlineSpan::Text(t0)) = line.first() {
                                                               ^2
  ------------------
  |  Branch (3374:28): [True: 2, False: 1]
  ------------------
 3375|      6|                        leading_spaces = t0.chars().take_while(|c| *c == ' ').count();
                                                       ^2         ^2                        ^2
 3376|      1|                    }
 3377|      3|                    if leading_spaces > 0 {
  ------------------
  |  Branch (3377:24): [True: 2, False: 1]
  ------------------
 3378|      2|                        if let Some(InlineSpan::Text(t0)) = line.get_mut(0) {
  ------------------
  |  Branch (3378:32): [True: 2, False: 0]
  ------------------
 3379|      2|                            let trimmed = t0.trim_start_matches(' ').to_string();
 3380|      2|                            *t0 = trimmed;
 3381|      2|                        }
                                      ^0
 3382|      1|                    }
 3383|      3|                    let indent = indent_px + (leading_spaces as f32) * 6.0;
 3384|      3|                    ui.add_space(indent);
 3385|       |                }
 3386|     31|                ui.spacing_mut().item_spacing.x = 0.0;
 3387|    104|                for span in &line {
                                  ^73
 3388|     73|                    self.render_inline_span(ui, span, None, None);
 3389|     73|                }
 3390|     31|            });
 3391|       |        }
 3392|     28|    }
 3393|       |
 3394|       |    /// Render a list with proper inline formatting, including nested block content
 3395|     12|    fn render_list(&self, ui: &mut egui::Ui, ordered: bool, items: &[ListItem]) {
 3396|     12|        if items.is_empty() {
  ------------------
  |  Branch (3396:12): [True: 2, False: 10]
  ------------------
 3397|      2|            return;
 3398|     10|        }
 3399|       |
 3400|     10|        ui.add_space(4.0);
 3401|     10|        let marker_color = ui.visuals().text_color();
 3402|     10|        let indent_px = 18.0;
 3403|       |
 3404|     31|        for (index, item) in items.iter().enumerate() {
                                           ^10   ^10    ^10
 3405|     31|            let marker = if ordered {
  ------------------
  |  Branch (3405:29): [True: 12, False: 19]
  ------------------
 3406|     12|                format!("{}.", index + 1)
 3407|       |            } else {
 3408|     19|                "-".to_string()
 3409|       |            };
 3410|       |
 3411|     31|            let mut blocks = item.blocks.iter();
 3412|     31|            if let Some(first_block) = blocks.next() {
                                      ^29
  ------------------
  |  Branch (3412:20): [True: 29, False: 2]
  ------------------
 3413|     29|                match first_block {
 3414|     27|                    MarkdownElement::Paragraph(spans) => {
 3415|     27|                        self.render_list_paragraph(
 3416|     27|                            ui,
 3417|     27|                            Some(&marker),
 3418|     27|                            marker_color,
 3419|     27|                            indent_px,
 3420|     27|                            spans,
 3421|     27|                        );
 3422|     27|                    }
 3423|       |                    _ => {
 3424|      2|                        ui.horizontal_wrapped(|ui| {
 3425|      2|                            ui.label(
 3426|      2|                                RichText::new(format!("{} ", marker))
 3427|      2|                                    .size(self.font_sizes.body)
 3428|      2|                                    .color(marker_color),
 3429|       |                            );
 3430|      2|                        });
 3431|      2|                        self.render_list_block(ui, first_block, indent_px, marker_color);
 3432|       |                    }
 3433|       |                }
 3434|       |            } else {
 3435|      2|                ui.horizontal_wrapped(|ui| {
 3436|      2|                    ui.label(
 3437|      2|                        RichText::new(format!("{} ", marker))
 3438|      2|                            .size(self.font_sizes.body)
 3439|      2|                            .color(marker_color),
 3440|       |                    );
 3441|      2|                });
 3442|       |            }
 3443|       |
 3444|     31|            for block in blocks {
                              ^0
 3445|      0|                self.render_list_block(ui, block, indent_px, marker_color);
 3446|      0|            }
 3447|       |        }
 3448|       |
 3449|     10|        ui.add_space(4.0);
 3450|     12|    }
 3451|       |
 3452|      3|    fn render_list_block(
 3453|      3|        &self,
 3454|      3|        ui: &mut egui::Ui,
 3455|      3|        block: &MarkdownElement,
 3456|      3|        indent_px: f32,
 3457|      3|        marker_color: Color32,
 3458|      3|    ) {
 3459|      3|        match block {
 3460|      0|            MarkdownElement::Paragraph(spans) => {
 3461|      0|                self.render_list_paragraph(ui, None, marker_color, indent_px, spans);
 3462|      0|            }
 3463|       |            _ => {
 3464|      3|                ui.horizontal(|ui| {
 3465|      3|                    ui.add_space(indent_px);
 3466|      3|                    ui.vertical(|ui| {
 3467|      3|                        self.render_element_body(ui, block);
 3468|      3|                    });
 3469|      3|                });
 3470|       |            }
 3471|       |        }
 3472|      3|    }
 3473|       |
 3474|       |    /// Render a code block with syntax highlighting
 3475|      9|    fn render_code_block(&self, ui: &mut egui::Ui, language: Option<&str>, code: &str) {
 3476|      9|        ui.add_space(8.0);
 3477|       |
 3478|       |        // Special handling for Mermaid diagrams
 3479|      9|        if let Some(lang) = language {
                                  ^8
  ------------------
  |  Branch (3479:16): [True: 8, False: 1]
  ------------------
 3480|      8|            if lang.eq_ignore_ascii_case("mermaid") && self.render_mermaid_block(ui, code) {
                                                                     ^1   ^1                   ^1  ^1
  ------------------
  |  Branch (3480:16): [True: 1, False: 7]
  |  Branch (3480:56): [True: 1, False: 0]
  ------------------
 3481|      1|                ui.add_space(8.0);
 3482|      1|                return;
 3483|      7|            }
 3484|      1|        }
 3485|       |
 3486|      8|        let frame_response = egui::Frame::none()
 3487|      8|            .fill(Color32::from_rgb(25, 25, 25))
 3488|      8|            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
 3489|      8|            .inner_margin(8.0)
 3490|      8|            .show(ui, |ui| {
 3491|      8|                ui.with_layout(egui::Layout::top_down(egui::Align::LEFT), |ui| {
 3492|      8|                    if let Some(lang) = language {
                                              ^7
  ------------------
  |  Branch (3492:28): [True: 7, False: 1]
  ------------------
 3493|      7|                        ui.label(
 3494|      7|                            RichText::new(lang)
 3495|      7|                                .size(self.font_sizes.code - 1.0)
 3496|      7|                                .color(Color32::from_rgb(150, 150, 150))
 3497|      7|                                .family(egui::FontFamily::Monospace),
 3498|      7|                        );
 3499|      7|                        ui.add_space(2.0);
 3500|      7|                    }
                                  ^1
 3501|       |
 3502|       |                    // Try syntax highlighting
 3503|      8|                    if let Some(lang) = language {
                                              ^7
  ------------------
  |  Branch (3503:28): [True: 7, False: 1]
  ------------------
 3504|      7|                        if let Some(syntax) = self
                                                  ^6
  ------------------
  |  Branch (3504:32): [True: 6, False: 1]
  ------------------
 3505|      7|                            .find_syntax_for_language(lang)
 3506|      7|                            .or_else(|| self.syntax_set.find_syntax_by_first_line(code))
                                                      ^1              ^1                        ^1
 3507|       |                        {
 3508|      6|                            let theme = &self.theme_set.themes["base16-ocean.dark"];
 3509|      6|                            let mut h = HighlightLines::new(syntax, theme);
 3510|       |
 3511|     10|                            for line in LinesWithEndings::from(code) {
                                                      ^6                     ^6
 3512|     10|                                let ranges =
 3513|     10|                                    h.highlight_line(line, &self.syntax_set).unwrap_or_default();
 3514|       |
 3515|     10|                                ui.horizontal_wrapped(|ui| {
 3516|       |                                    // Remove spacing between tokens to avoid visual gaps
 3517|     10|                                    ui.spacing_mut().item_spacing.x = 0.0;
 3518|     73|                                    for (style, text) in ranges {
                                                       ^63    ^63
 3519|       |                                        // Drop newline characters completely; they're handled by the outer line loop
 3520|     63|                                        let cleaned = text.replace(['\n', '\r'], "");
 3521|       |
 3522|     63|                                        if cleaned.is_empty() {
  ------------------
  |  Branch (3522:44): [True: 4, False: 59]
  ------------------
 3523|      4|                                            continue;
 3524|     59|                                        }
 3525|       |
 3526|       |                                        // Check if this token is pure whitespace (spaces or tabs only)
 3527|     70|                                        if cleaned.chars().all(|c| c == ' ' || c == '\t') {
                                                         ^59             ^59                 ^43
  ------------------
  |  Branch (3527:68): [True: 27, False: 43]
  ------------------
  |  Branch (3527:44): [True: 16, False: 43]
  ------------------
 3528|     16|                                            // Render whitespace as transparent to preserve layout without visual gaps
 3529|     16|                                            ui.label(
 3530|     16|                                                RichText::new(cleaned)
 3531|     16|                                                    .size(self.font_sizes.code)
 3532|     16|                                                    .color(Color32::TRANSPARENT)
 3533|     16|                                                    .family(egui::FontFamily::Monospace),
 3534|     16|                                            );
 3535|     16|                                        } else {
 3536|       |                                            // For non-whitespace, use normal highlighting but replace spaces with transparent ones
 3537|     43|                                            let color = Color32::from_rgb(
 3538|     43|                                                style.foreground.r,
 3539|     43|                                                style.foreground.g,
 3540|     43|                                                style.foreground.b,
 3541|       |                                            );
 3542|       |
 3543|       |                                            // Split by spaces and handle separately
 3544|     43|                                            let parts: Vec<&str> = cleaned.split(' ').collect();
 3545|     49|                                            for (i, part) in parts.iter().enumerate() {
                                                                           ^43          ^43
 3546|     49|                                                if !part.is_empty() {
  ------------------
  |  Branch (3546:52): [True: 45, False: 4]
  ------------------
 3547|     45|                                                    let mut rich_text = RichText::new(*part)
 3548|     45|                                                        .size(self.font_sizes.code)
 3549|     45|                                                        .color(color)
 3550|     45|                                                        .family(egui::FontFamily::Monospace);
 3551|       |
 3552|     45|                                                    if style.font_style.contains(
  ------------------
  |  Branch (3552:56): [True: 6, False: 39]
  ------------------
 3553|       |                                                        syntect::highlighting::FontStyle::BOLD,
 3554|      6|                                                    ) {
 3555|      6|                                                        rich_text = rich_text.strong();
 3556|     39|                                                    }
 3557|     45|                                                    if style.font_style.contains(
  ------------------
  |  Branch (3557:56): [True: 6, False: 39]
  ------------------
 3558|       |                                                        syntect::highlighting::FontStyle::ITALIC,
 3559|      6|                                                    ) {
 3560|      6|                                                        rich_text = rich_text.italics();
 3561|     39|                                                    }
 3562|       |
 3563|     45|                                                    ui.label(rich_text);
 3564|      4|                                                }
 3565|       |
 3566|       |                                                // Add transparent space between parts (except after last part)
 3567|     49|                                                if i < parts.len() - 1 {
  ------------------
  |  Branch (3567:52): [True: 6, False: 43]
  ------------------
 3568|      6|                                                    ui.label(
 3569|      6|                                                        RichText::new(" ")
 3570|      6|                                                            .size(self.font_sizes.code)
 3571|      6|                                                            .color(Color32::TRANSPARENT)
 3572|      6|                                                            .family(egui::FontFamily::Monospace),
 3573|      6|                                                    );
 3574|     43|                                                }
 3575|       |                                            }
 3576|       |                                        }
 3577|       |                                    }
 3578|     10|                                });
 3579|       |                            }
 3580|      6|                            return; // Early return if highlighting succeeded
 3581|      1|                        }
 3582|      1|                    }
 3583|       |
 3584|       |                    // Fallback: render as plain text
 3585|      2|                    ui.label(
 3586|      2|                        RichText::new(code)
 3587|      2|                            .size(self.font_sizes.code)
 3588|      2|                            .color(Color32::from_rgb(220, 220, 220))
 3589|      2|                            .family(egui::FontFamily::Monospace),
 3590|       |                    );
 3591|      8|                });
 3592|      8|            });
 3593|       |
 3594|       |        // Add context menu for code blocks
 3595|      8|        frame_response.response.context_menu(|ui| {
                                                                ^0
 3596|      0|            self.render_code_block_context_menu(ui, code, language);
 3597|      0|        });
 3598|       |
 3599|      8|        ui.add_space(8.0);
 3600|      9|    }
 3601|       |
 3602|       |    /// Try to render a Mermaid diagram. Returns true if handled (rendered or placeholder drawn).
 3603|      1|    fn render_mermaid_block(&self, ui: &mut egui::Ui, code: &str) -> bool {
 3604|      1|        self.mermaid
 3605|      1|            .render_block(ui, code, self.ui_scale(), self.font_sizes.code)
 3606|      1|    }
 3607|       |
 3608|      8|    fn hash_str(s: &str) -> u64 {
 3609|      8|        let mut h = DefaultHasher::new();
 3610|      8|        s.hash(&mut h);
 3611|      8|        h.finish()
 3612|      8|    }
 3613|       |
 3614|    535|    fn hash_inline_spans(spans: &[InlineSpan]) -> u64 {
 3615|    535|        let mut h = DefaultHasher::new();
 3616|  1.12k|        for span in spans {
                          ^586
 3617|    586|            match span {
 3618|    558|                InlineSpan::Text(t) => {
 3619|    558|                    0u8.hash(&mut h);
 3620|    558|                    t.hash(&mut h);
 3621|    558|                }
 3622|      1|                InlineSpan::Code(t) => {
 3623|      1|                    1u8.hash(&mut h);
 3624|      1|                    t.hash(&mut h);
 3625|      1|                }
 3626|     10|                InlineSpan::Strong(t) => {
 3627|     10|                    2u8.hash(&mut h);
 3628|     10|                    t.hash(&mut h);
 3629|     10|                }
 3630|      1|                InlineSpan::Emphasis(t) => {
 3631|      1|                    3u8.hash(&mut h);
 3632|      1|                    t.hash(&mut h);
 3633|      1|                }
 3634|      1|                InlineSpan::Strikethrough(t) => {
 3635|      1|                    4u8.hash(&mut h);
 3636|      1|                    t.hash(&mut h);
 3637|      1|                }
 3638|     10|                InlineSpan::Link { text, url } => {
 3639|     10|                    5u8.hash(&mut h);
 3640|     10|                    text.hash(&mut h);
 3641|     10|                    url.hash(&mut h);
 3642|     10|                }
 3643|      5|                InlineSpan::Image { src, alt, title } => {
 3644|      5|                    6u8.hash(&mut h);
 3645|      5|                    src.hash(&mut h);
 3646|      5|                    alt.hash(&mut h);
 3647|      5|                    title.hash(&mut h);
 3648|      5|                }
 3649|       |            }
 3650|       |        }
 3651|    535|        h.finish()
 3652|    535|    }
 3653|       |
 3654|     23|    fn alignment_hash(align: Alignment) -> u8 {
 3655|     23|        match align {
 3656|     10|            Alignment::None => 0,
 3657|      7|            Alignment::Left => 1,
 3658|      3|            Alignment::Center => 2,
 3659|      3|            Alignment::Right => 3,
 3660|       |        }
 3661|     23|    }
 3662|       |
 3663|      8|    fn alignment_to_egui(align: Alignment) -> Align {
 3664|      8|        match align {
 3665|      1|            Alignment::Center => Align::Center,
 3666|      1|            Alignment::Right => Align::RIGHT,
 3667|      6|            Alignment::Left | Alignment::None => Align::LEFT,
 3668|       |        }
 3669|      8|    }
 3670|       |
 3671|     49|    fn alignment_for_column(alignments: &[Alignment], col_idx: usize) -> Align {
 3672|     49|        alignments
 3673|     49|            .get(col_idx)
 3674|     49|            .copied()
 3675|     49|            .map(Self::alignment_to_egui)
 3676|     49|            .unwrap_or(Align::LEFT)
 3677|     49|    }
 3678|       |
 3679|    158|    fn align_to_u8(align: Align) -> u8 {
 3680|    158|        if align == Align::LEFT {
  ------------------
  |  Branch (3680:12): [True: 148, False: 10]
  ------------------
 3681|    148|            0
 3682|     10|        } else if align == Align::Center {
  ------------------
  |  Branch (3682:19): [True: 5, False: 5]
  ------------------
 3683|      5|            1
 3684|       |        } else {
 3685|      5|            2
 3686|       |        }
 3687|    158|    }
 3688|       |
 3689|      4|    fn next_table_index(&self) -> u64 {
 3690|      4|        let mut counter = self.table_counter.borrow_mut();
 3691|      4|        let idx = *counter;
 3692|      4|        *counter += 1;
 3693|      4|        idx
 3694|      4|    }
 3695|       |
 3696|     20|    fn compute_table_id(
 3697|     20|        &self,
 3698|     20|        headers: &[Vec<InlineSpan>],
 3699|     20|        rows: &[Vec<Vec<InlineSpan>>],
 3700|     20|        alignments: &[Alignment],
 3701|     20|        table_index: u64,
 3702|     20|    ) -> u64 {
 3703|     20|        let mut hasher = DefaultHasher::new();
 3704|     20|        if let Some(base) = self.base_dir.borrow().as_ref() {
                                  ^1
  ------------------
  |  Branch (3704:16): [True: 1, False: 19]
  ------------------
 3705|      1|            base.hash(&mut hasher);
 3706|     19|        }
 3707|     20|        hasher.write_u64(table_index);
 3708|     20|        hasher.write_u64(self.compute_table_content_hash(headers, rows, alignments));
 3709|     20|        hasher.finish()
 3710|     20|    }
 3711|       |
 3712|     38|    fn compute_table_content_hash(
 3713|     38|        &self,
 3714|     38|        headers: &[Vec<InlineSpan>],
 3715|     38|        rows: &[Vec<Vec<InlineSpan>>],
 3716|     38|        alignments: &[Alignment],
 3717|     38|    ) -> u64 {
 3718|     38|        let mut hasher = DefaultHasher::new();
 3719|     38|        hasher.write_usize(headers.len());
 3720|    138|        for header in headers {
                          ^100
 3721|    100|            hasher.write_u64(Self::hash_inline_spans(header));
 3722|    100|        }
 3723|     38|        hasher.write_usize(alignments.len());
 3724|     61|        for align in alignments {
                          ^23
 3725|     23|            hasher.write_u8(Self::alignment_hash(*align));
 3726|     23|        }
 3727|     38|        let mut counted = 0usize;
 3728|    218|        for row in rows {
                          ^181
 3729|    456|            for cell in row {
                              ^275
 3730|    275|                hasher.write_u64(Self::hash_inline_spans(cell));
 3731|    275|            }
 3732|    181|            counted += 1;
 3733|    181|            if counted >= COLUMN_STATS_SAMPLE_ROWS {
  ------------------
  |  Branch (3733:16): [True: 1, False: 180]
  ------------------
 3734|      1|                break;
 3735|    180|            }
 3736|       |        }
 3737|     38|        hasher.finish()
 3738|     38|    }
 3739|       |
 3740|     17|    fn column_stats_for_table(
 3741|     17|        &self,
 3742|     17|        table_id: u64,
 3743|     17|        headers: &[Vec<InlineSpan>],
 3744|     17|        rows: &[Vec<Vec<InlineSpan>>],
 3745|     17|        alignments: &[Alignment],
 3746|     17|    ) -> Vec<ColumnStat> {
 3747|     17|        let content_hash = self.compute_table_content_hash(headers, rows, alignments);
 3748|     17|        if let Some(entry) = self
                                  ^2
  ------------------
  |  Branch (3748:16): [True: 2, False: 15]
  ------------------
 3749|     17|            .column_stats_cache
 3750|     17|            .borrow()
 3751|     17|            .get(&table_id)
 3752|     17|            .filter(|entry| entry.content_hash == content_hash)
                                          ^2                    ^2
 3753|       |        {
 3754|      2|            return entry.stats.clone();
 3755|     15|        }
 3756|     15|        let stats = compute_column_stats(headers, rows, COLUMN_STATS_SAMPLE_ROWS);
 3757|     15|        self.column_stats_cache.borrow_mut().insert(
 3758|     15|            table_id,
 3759|     15|            ColumnStatsCacheEntry {
 3760|     15|                content_hash,
 3761|     15|                stats: stats.clone(),
 3762|     15|            },
 3763|     15|        );
 3764|     15|        stats
 3765|     17|    }
 3766|       |
 3767|       |    /// Render a table using an egui Grid
 3768|      5|    fn render_table(
 3769|      5|        &self,
 3770|      5|        ui: &mut egui::Ui,
 3771|      5|        headers: &[Vec<InlineSpan>],
 3772|      5|        rows: &[Vec<Vec<InlineSpan>>],
 3773|      5|        alignments: &[Alignment],
 3774|      5|    ) {
 3775|      5|        if headers.is_empty() {
  ------------------
  |  Branch (3775:12): [True: 1, False: 4]
  ------------------
 3776|      1|            return;
 3777|      4|        }
 3778|       |
 3779|      4|        let table_index = self.next_table_index();
 3780|      4|        let table_id = self.compute_table_id(headers, rows, alignments, table_index);
 3781|      4|        self.render_table_tablebuilder(ui, headers, rows, alignments, table_id);
 3782|      4|        ui.add_space(8.0);
 3783|      5|    }
 3784|       |
 3785|    124|    fn extend_table_rect(target: &mut Option<egui::Rect>, rect: egui::Rect) {
 3786|    124|        if rect.min.x.is_nan() || rect.min.y.is_nan() || rect.max.x.is_nan() || rect.max.y.is_nan()
                                                ^123       ^123        ^122       ^122        ^121       ^121
  ------------------
  |  Branch (3786:12): [True: 1, False: 123]
  |  Branch (3786:35): [True: 1, False: 122]
  |  Branch (3786:58): [True: 1, False: 121]
  |  Branch (3786:81): [True: 1, False: 120]
  ------------------
 3787|       |        {
 3788|      4|            return;
 3789|    120|        }
 3790|    120|        if let Some(existing) = target {
                                  ^87
  ------------------
  |  Branch (3790:16): [True: 87, False: 33]
  ------------------
 3791|     87|            existing.min.x = existing.min.x.min(rect.min.x);
 3792|     87|            existing.min.y = existing.min.y.min(rect.min.y);
 3793|     87|            existing.max.x = existing.max.x.max(rect.max.x);
 3794|     87|            existing.max.y = existing.max.y.max(rect.max.y);
 3795|     87|        } else {
 3796|     33|            *target = Some(rect);
 3797|     33|        }
 3798|    124|    }
 3799|       |
 3800|     16|    fn render_table_tablebuilder(
 3801|     16|        &self,
 3802|     16|        ui: &mut egui::Ui,
 3803|     16|        headers: &[Vec<InlineSpan>],
 3804|     16|        rows: &[Vec<Vec<InlineSpan>>],
 3805|     16|        alignments: &[Alignment],
 3806|     16|        table_id: u64,
 3807|     16|    ) {
 3808|     16|        let column_stats = self.column_stats_for_table(table_id, headers, rows, alignments);
 3809|     16|        let ctx =
 3810|     16|            TableColumnContext::new(headers, rows, &column_stats, self.font_sizes.body, table_id);
 3811|     16|        let mut column_specs = derive_column_specs(&ctx);
 3812|       |        #[cfg(test)]
 3813|     16|        if let Some(policies) = take_forced_table_policies() {
                                  ^3
  ------------------
  |  Branch (3813:16): [True: 3, False: 13]
  ------------------
 3814|     10|            for (spec, policy) in column_specs.iter_mut().zip(policies.into_iter()) {
                                                ^3                      ^3  ^3       ^3
 3815|     10|                spec.set_policy(policy);
 3816|     10|            }
 3817|     13|        }
 3818|     16|        self.apply_persisted_widths(table_id, &mut column_specs);
 3819|     16|        let column_aligns: Vec<Align> = (0..column_specs.len())
 3820|     49|            .map(|ci| Self::alignment_for_column(alignments, ci))
                           ^16
 3821|     16|            .collect();
 3822|       |
 3823|     16|        let column_spacing = ui.spacing().item_spacing.x.max(6.0);
 3824|     16|        let available_width = ui.available_width().max(1.0);
 3825|     16|        let min_floor = self.table_min_column_width();
 3826|     16|        let resolved_widths = self.resolve_table_column_widths(table_id, &column_specs, min_floor);
 3827|     16|        let min_widths: Vec<f32> = column_specs
 3828|     16|            .iter()
 3829|     49|            .map(|spec| match spec.policy {
                           ^16
 3830|     13|                ColumnPolicy::Fixed { width, .. } => width,
 3831|     18|                ColumnPolicy::Resizable { min, .. } => min,
 3832|     18|                ColumnPolicy::Remainder { .. } | ColumnPolicy::Auto => min_floor,
 3833|     49|            })
 3834|     16|            .collect();
 3835|     16|        let spacing_total = column_spacing * column_specs.len().saturating_sub(1) as f32;
 3836|     16|        let available_for_columns = available_width - spacing_total;
 3837|     16|        let mut fixed_total = 0.0;
 3838|     16|        let mut flexible_indices: Vec<usize> = Vec::new();
 3839|     16|        let mut remainder_indices: Vec<usize> = Vec::new();
 3840|     49|        for (idx, spec) in column_specs.iter().enumerate() {
                                         ^16                 ^16
 3841|     49|            match spec.policy {
 3842|     13|                ColumnPolicy::Fixed { width, .. } => fixed_total += width,
 3843|     18|                ColumnPolicy::Resizable { .. } => flexible_indices.push(idx),
 3844|     15|                ColumnPolicy::Remainder { .. } => {
 3845|     15|                    flexible_indices.push(idx);
 3846|     15|                    remainder_indices.push(idx);
 3847|     15|                }
 3848|      3|                ColumnPolicy::Auto => flexible_indices.push(idx),
 3849|       |            }
 3850|       |        }
 3851|     36|        let min_flex_total: f32 = flexible_indices.iter().map(|idx| min_widths[*idx]).sum();
                          ^16             ^16   ^16                     ^16                         ^16
 3852|     16|        let desired_total_width = resolved_widths.iter().sum::<f32>() + spacing_total;
 3853|     16|        let content_width = desired_total_width.max(available_width);
 3854|     16|        let remaining_for_flex = available_for_columns - fixed_total;
 3855|     16|        let use_hscroll = available_for_columns <= 0.0
  ------------------
  |  Branch (3855:27): [True: 0, False: 16]
  ------------------
 3856|     16|            || fixed_total > available_for_columns + 0.5
  ------------------
  |  Branch (3856:16): [True: 1, False: 15]
  ------------------
 3857|     15|            || remaining_for_flex < min_flex_total - 0.5;
 3858|     16|        let mut adjusted_widths = resolved_widths.clone();
 3859|     16|        let mut scaled_down = false;
 3860|     16|        if !use_hscroll {
  ------------------
  |  Branch (3860:12): [True: 12, False: 4]
  ------------------
 3861|     12|            let remaining = remaining_for_flex.max(0.0);
 3862|     12|            let flex_total: f32 = flexible_indices
 3863|     12|                .iter()
 3864|     23|                .map(|idx| resolved_widths[*idx])
                               ^12
 3865|     12|                .sum();
 3866|     12|            if flex_total > remaining + 0.5 && flex_total > 0.0 {
                                                             ^1
  ------------------
  |  Branch (3866:16): [True: 1, False: 11]
  |  Branch (3866:48): [True: 1, False: 0]
  ------------------
 3867|      1|                if remaining <= min_flex_total + 0.5 {
  ------------------
  |  Branch (3867:20): [True: 0, False: 1]
  ------------------
 3868|      0|                    for idx in &flexible_indices {
 3869|      0|                        adjusted_widths[*idx] = min_widths[*idx].max(1.0);
 3870|      0|                    }
 3871|      1|                } else if flex_total > min_flex_total {
  ------------------
  |  Branch (3871:27): [True: 1, False: 0]
  ------------------
 3872|      1|                    let extra_total = flex_total - min_flex_total;
 3873|      1|                    let extra_scale = ((remaining - min_flex_total) / extra_total).clamp(0.0, 1.0);
 3874|      4|                    for idx in &flexible_indices {
                                      ^3
 3875|      3|                        let min_width = min_widths[*idx];
 3876|      3|                        let desired = resolved_widths[*idx];
 3877|      3|                        let extra = (desired - min_width).max(0.0);
 3878|      3|                        adjusted_widths[*idx] = (min_width + extra * extra_scale).max(1.0);
 3879|      3|                    }
 3880|      0|                }
 3881|      1|                scaled_down = true;
 3882|     11|            }
 3883|      4|        }
 3884|     16|        let column_layout: Vec<Column> = if use_hscroll {
  ------------------
  |  Branch (3884:45): [True: 4, False: 12]
  ------------------
 3885|     16|            column_specs.iter().map(|spec| spec.as_column()).collect()
                          ^4                  ^4                           ^4
 3886|       |        } else {
 3887|     12|            column_specs
 3888|     12|                .iter()
 3889|     12|                .enumerate()
 3890|     33|                .map(|(idx, spec)| {
                               ^12
 3891|     33|                    let width = adjusted_widths
 3892|     33|                        .get(idx)
 3893|     33|                        .copied()
 3894|     33|                        .unwrap_or(min_floor)
 3895|     33|                        .max(1.0);
 3896|     33|                    match spec.policy {
 3897|     10|                        ColumnPolicy::Fixed { width, clip } => {
 3898|     10|                            let mut col = Column::exact(width);
 3899|     10|                            if clip {
  ------------------
  |  Branch (3899:32): [True: 10, False: 0]
  ------------------
 3900|     10|                                col = col.clip(true);
 3901|     10|                            }
                                          ^0
 3902|     10|                            col
 3903|       |                        }
 3904|      9|                        ColumnPolicy::Resizable { min, clip, .. } => {
 3905|      9|                            let mut col = Column::initial(width)
 3906|      9|                                .at_least(min.min(width))
 3907|      9|                                .resizable(true);
 3908|      9|                            if clip {
  ------------------
  |  Branch (3908:32): [True: 1, False: 8]
  ------------------
 3909|      1|                                col = col.clip(true);
 3910|      8|                            }
 3911|      9|                            col
 3912|       |                        }
 3913|     12|                        ColumnPolicy::Remainder { clip } => {
 3914|     12|                            let mut col = if scaled_down {
  ------------------
  |  Branch (3914:46): [True: 1, False: 11]
  ------------------
 3915|      1|                                Column::initial(width).at_least(min_floor.min(width))
 3916|       |                            } else {
 3917|     11|                                Column::remainder().at_least(min_floor)
 3918|       |                            };
 3919|     12|                            if clip {
  ------------------
  |  Branch (3919:32): [True: 1, False: 11]
  ------------------
 3920|      1|                                col = col.clip(true);
 3921|     11|                            }
 3922|     12|                            col
 3923|       |                        }
 3924|       |                        ColumnPolicy::Auto => {
 3925|      2|                            if scaled_down {
  ------------------
  |  Branch (3925:32): [True: 1, False: 1]
  ------------------
 3926|      1|                                Column::initial(width).at_least(min_floor.min(width))
 3927|       |                            } else {
 3928|      1|                                Column::auto_with_initial_suggestion(width).at_least(min_floor)
 3929|       |                            }
 3930|       |                        }
 3931|       |                    }
 3932|     33|                })
 3933|     12|                .collect()
 3934|       |        };
 3935|       |
 3936|     16|        let render_table = |ui: &mut egui::Ui, max_width: f32| {
 3937|     16|            let width_bucket = max_width.round() as i32;
 3938|     16|            ui.push_id((table_id, width_bucket), |ui| {
 3939|     16|                let layout = *ui.layout();
 3940|     16|                ui.allocate_ui_with_layout(Vec2::new(max_width, 0.0), layout, |ui| {
 3941|     16|                    ui.set_width(max_width);
 3942|     16|                    let needs_estimate = {
 3943|     16|                        let metrics = self.table_metrics.borrow();
 3944|     16|                        metrics
 3945|     16|                            .entry(table_id)
 3946|     16|                            .is_none_or(|entry| entry.rows.is_empty())
 3947|       |                    };
 3948|     16|                    self.begin_table_pass(table_id, rows.len());
 3949|       |
 3950|     16|                    let prev_spacing = ui.spacing().item_spacing;
 3951|     16|                    if (prev_spacing.x - column_spacing).abs() > f32::EPSILON {
  ------------------
  |  Branch (3951:24): [True: 2, False: 14]
  ------------------
 3952|      2|                        ui.spacing_mut().item_spacing.x = column_spacing;
 3953|     14|                    }
 3954|       |
 3955|     16|                    let cached_header_height = self
 3956|     16|                        .table_metrics
 3957|     16|                        .borrow()
 3958|     16|                        .entry(table_id)
 3959|     16|                        .and_then(|entry| entry.header_height());
 3960|       |                    // Rough header height estimation using equally divided width; refines on next frame via cache.
 3961|     16|                    let header_height = cached_header_height.unwrap_or_else(|| {
                                                                                             ^15
 3962|     15|                        let mut estimate = self.row_height_fallback();
 3963|     15|                        if !column_specs.is_empty() {
  ------------------
  |  Branch (3963:28): [True: 15, False: 0]
  ------------------
 3964|     15|                            let approx_width = (ui.available_width() / column_specs.len() as f32)
 3965|     15|                                .max(self.font_sizes.body * 6.0)
 3966|     15|                                .max(48.0);
 3967|     15|                            let style = ui.style().clone();
 3968|     15|                            estimate = headers
 3969|     15|                                .iter()
 3970|     15|                                .enumerate()
 3971|     41|                                .map(|(ci, spans)| {
                                               ^15
 3972|     41|                                    let halign =
 3973|     41|                                        column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
 3974|     41|                                    let build = self.cached_layout_job(
 3975|     41|                                        &style,
 3976|     41|                                        None,
 3977|     41|                                        ci,
 3978|     41|                                        spans,
 3979|     41|                                        approx_width,
 3980|       |                                        true,
 3981|     41|                                        halign,
 3982|       |                                    );
 3983|     41|                                    ui.fonts(|f| f.layout_job(build.job.clone()).size().y + 6.0)
 3984|     41|                                })
 3985|     41|                                .fold(estimate, |acc, h| acc.max(h));
                                               ^15  ^15
 3986|     15|                            estimate = estimate.min(self.row_height_fallback() * 3.0);
 3987|      0|                        }
 3988|     15|                        estimate
 3989|     15|                    });
 3990|       |
 3991|     16|                    let fallback_row_height = self.row_height_fallback();
 3992|     16|                    let mut row_heights: Vec<f32> = (0..rows.len())
 3993|     24|                        .map(|idx| self.row_height_hint(table_id, idx))
                                       ^16
 3994|     16|                        .collect();
 3995|     16|                    if needs_estimate {
  ------------------
  |  Branch (3995:24): [True: 15, False: 1]
  ------------------
 3996|     15|                        let approx_widths = self.estimate_table_column_widths(
 3997|     15|                            &column_specs,
 3998|     15|                            max_width,
 3999|     15|                            column_spacing,
 4000|       |                        );
 4001|     15|                        let style = ui.style().clone();
 4002|     23|                        for (idx, row) in rows.iter().enumerate() {
                                                        ^15  ^15    ^15
 4003|     23|                            if self.row_needs_height_estimate(row) {
  ------------------
  |  Branch (4003:32): [True: 8, False: 15]
  ------------------
 4004|      8|                                let estimate = self.estimate_table_row_height(
 4005|      8|                                    ui,
 4006|      8|                                    &style,
 4007|      8|                                    row,
 4008|      8|                                    &column_aligns,
 4009|      8|                                    &approx_widths,
 4010|      8|                                    fallback_row_height,
 4011|       |                                );
 4012|      8|                                if estimate > row_heights[idx] {
  ------------------
  |  Branch (4012:36): [True: 8, False: 0]
  ------------------
 4013|      8|                                    row_heights[idx] = estimate;
 4014|      8|                                }
                                              ^0
 4015|     15|                            }
 4016|       |                        }
 4017|      1|                    }
 4018|       |
 4019|       |                    // Capture painter from outer UI BEFORE TableBuilder to ensure dividers
 4020|       |                    // paint on top of both header and body (fixes header divider visibility).
 4021|     16|                    let outer_painter = ui.painter().clone();
 4022|     16|                    let outer_visuals = ui.visuals().clone();
 4023|     16|                    let outer_ctx = ui.ctx().clone();
 4024|       |
 4025|     16|                    let mut table = TableBuilder::new(ui).striped(true).vscroll(false);
 4026|     65|                    for column in &column_layout {
                                      ^49
 4027|     49|                        table = table.column(*column);
 4028|     49|                    }
 4029|       |
 4030|       |                    // Use RefCell to allow capturing widths from body closure.
 4031|       |                    // BUG FIX: Previously captured ui.min_rect().width() which is the cell *content* width.
 4032|       |                    // Now we capture body.widths() which gives the actual *allocated* column widths.
 4033|       |                    // See: https://docs.rs/egui_extras/latest/egui_extras/struct.TableBody.html#method.widths
 4034|     16|                    let column_widths: RefCell<Vec<f32>> =
 4035|     16|                        RefCell::new(vec![0.0f32; column_specs.len()]);
 4036|       |                    // Track header and body rects separately for accurate table bounds calculation.
 4037|       |                    // The header rect captures the header row bounds, body_rect captures body row bounds.
 4038|       |                    // These are combined after rendering to get the full table rect.
 4039|     16|                    let mut header_rect: Option<egui::Rect> = None;
 4040|     16|                    let mut body_rect: Option<egui::Rect> = None;
 4041|       |                    // body_layout_rect captures the allocated layout region from body.max_rect(),
 4042|       |                    // which is more accurate than union of cell min_rects for table width.
 4043|     16|                    let body_layout_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);
 4044|       |                    // Track clip rects separately for header and body, then union them.
 4045|       |                    // This ensures dividers respect scroll boundaries for both regions.
 4046|     16|                    let mut header_clip_rect: Option<egui::Rect> = None;
 4047|     16|                    let body_clip_rect: RefCell<Option<egui::Rect>> = RefCell::new(None);
 4048|       |
 4049|     16|                    let mut height_change = false;
 4050|     16|                    let header_height_actual = Cell::new(0.0f32);
 4051|     16|                    table
 4052|     16|                        .header(header_height, |mut header| {
 4053|     49|                            for (ci, _) in column_specs.iter().enumerate() {
                                                         ^16                 ^16
 4054|     49|                                header.col(|ui| {
 4055|     49|                                    let width = ui.available_width().max(1.0);
 4056|     49|                                    let spans =
 4057|     49|                                        headers.get(ci).map(|v| v.as_slice()).unwrap_or(&[]);
                                                                              ^46^46
 4058|     49|                                    let halign =
 4059|     49|                                        column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
 4060|     49|                                    let cell_height = self.render_overhauled_cell(
 4061|     49|                                        ui, spans, width, true, None, ci, halign,
 4062|       |                                    );
 4063|     49|                                    header_height_actual
 4064|     49|                                        .set(header_height_actual.get().max(cell_height));
 4065|       |                                    // NOTE: Do NOT capture ui.min_rect().width() here - that's the content width,
 4066|       |                                    // not the column width. Column widths are captured from body.widths() below.
 4067|       |                                    // Extend header_rect (not body_rect) for accurate header bounds.
 4068|     49|                                    Self::extend_table_rect(&mut header_rect, ui.min_rect());
 4069|     49|                                    if header_clip_rect.is_none() {
  ------------------
  |  Branch (4069:40): [True: 16, False: 33]
  ------------------
 4070|     16|                                        header_clip_rect = Some(ui.clip_rect());
 4071|     33|                                    }
 4072|     49|                                });
 4073|       |                            }
 4074|     16|                        })
 4075|     16|                        .body(|body| {
 4076|       |                            // Capture the actual allocated column widths from the table layout system.
 4077|       |                            // This MUST be done before heterogeneous_rows() consumes the body.
 4078|     16|                            *column_widths.borrow_mut() = body.widths().to_vec();
 4079|       |
 4080|       |                            // Capture body's layout rect for accurate table width calculation.
 4081|       |                            // This is the allocated region, not the content bounds.
 4082|     16|                            *body_layout_rect.borrow_mut() = Some(body.max_rect());
 4083|       |
 4084|     16|                            let row_height_hints = row_heights.clone();
 4085|     24|                            body.heterogeneous_rows(row_height_hints.into_iter(), |mut row| {
                                          ^16  ^16                ^16              ^16
 4086|     24|                                let idx = row.index();
 4087|     24|                                let row_cells = rows.get(idx);
 4088|     24|                                let mut row_height = fallback_row_height;
 4089|     68|                                for (ci, _) in column_specs.iter().enumerate() {
                                                             ^24                 ^24
 4090|     68|                                    let mut cell_height = fallback_row_height;
 4091|     68|                                    row.col(|ui| {
 4092|     68|                                        let width = ui.available_width().max(1.0);
 4093|     68|                                        let spans = row_cells
 4094|     68|                                            .and_then(|cells| cells.get(ci))
 4095|     68|                                            .map(|cell| cell.as_slice())
 4096|     68|                                            .unwrap_or(&[]);
 4097|     68|                                        let halign =
 4098|     68|                                            column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
 4099|     68|                                        cell_height = self.render_overhauled_cell(
 4100|     68|                                            ui,
 4101|     68|                                            spans,
 4102|     68|                                            width,
 4103|     68|                                            false,
 4104|     68|                                            Some(idx),
 4105|     68|                                            ci,
 4106|     68|                                            halign,
 4107|     68|                                        );
 4108|       |                                        // Extend body_rect (not header_rect) for accurate body bounds.
 4109|     68|                                        Self::extend_table_rect(&mut body_rect, ui.min_rect());
 4110|     68|                                        if body_clip_rect.borrow().is_none() {
  ------------------
  |  Branch (4110:44): [True: 15, False: 53]
  ------------------
 4111|     15|                                            *body_clip_rect.borrow_mut() = Some(ui.clip_rect());
 4112|     53|                                        }
 4113|     68|                                    });
 4114|     68|                                    row_height = row_height.max(cell_height);
 4115|       |                                }
 4116|     24|                                if (row_height - row_heights[idx]).abs() > 0.5 {
  ------------------
  |  Branch (4116:36): [True: 3, False: 21]
  ------------------
 4117|      3|                                    height_change = true;
 4118|     21|                                }
 4119|     24|                                self.update_row_height(table_id, idx, row_height);
 4120|     24|                                self.note_row_rendered(table_id);
 4121|     24|                            });
 4122|     16|                        });
 4123|       |
 4124|     16|                    ui.spacing_mut().item_spacing = prev_spacing;
 4125|       |
 4126|       |                    // Extract column widths from RefCell for use in divider painting
 4127|     16|                    let widths = column_widths.into_inner();
 4128|     16|                    let layout_rect = body_layout_rect.into_inner();
 4129|     16|                    let body_clip = body_clip_rect.into_inner();
 4130|     16|                    let measured_header_height = header_height_actual.get();
 4131|     16|                    if measured_header_height > 0.0
  ------------------
  |  Branch (4131:24): [True: 16, False: 0]
  ------------------
 4132|     16|                        && self.update_header_height(table_id, measured_header_height)
  ------------------
  |  Branch (4132:28): [True: 15, False: 1]
  ------------------
 4133|     15|                    {
 4134|     15|                        ui.ctx().request_repaint();
 4135|     15|                    }
                                  ^1
 4136|       |
 4137|       |                    // Combine header and body clip rects to ensure dividers respect scroll bounds.
 4138|     16|                    let clip_rect = match (header_clip_rect, body_clip) {
 4139|     15|                        (Some(h), Some(b)) => Some(h.union(b)),
 4140|      1|                        (Some(h), None) => Some(h),
 4141|      0|                        (None, Some(b)) => Some(b),
 4142|      0|                        (None, None) => None,
 4143|       |                    };
 4144|       |
 4145|       |                    // Calculate accurate table width from column widths.
 4146|       |                    // This is more accurate than union of cell min_rects which may be smaller
 4147|       |                    // than the allocated column space.
 4148|     16|                    let calculated_width: f32 = widths.iter().sum::<f32>()
 4149|     16|                        + column_spacing * widths.len().saturating_sub(1) as f32;
 4150|       |
 4151|       |                    // Combine header/body bounds with layout bounds for accurate borders,
 4152|       |                    // especially when the first column is centered or right-aligned.
 4153|     16|                    let table_rect = if calculated_width > 0.0 {
  ------------------
  |  Branch (4153:41): [True: 16, False: 0]
  ------------------
 4154|     16|                        let left = layout_rect
 4155|     16|                            .map(|rect| rect.left())
 4156|     16|                            .or_else(|| header_rect.map(|rect| rect.left()))
                                                      ^0          ^0         ^0   ^0
 4157|     16|                            .or_else(|| body_rect.map(|rect| rect.left()));
                                                      ^0        ^0         ^0   ^0
 4158|     16|                        let right = left.map(|value| value + calculated_width);
 4159|     16|                        let top = header_rect
 4160|     16|                            .map(|rect| rect.top())
 4161|     16|                            .or_else(|| body_rect.map(|rect| rect.top()))
                                                      ^0        ^0         ^0   ^0
 4162|     16|                            .or_else(|| layout_rect.map(|rect| rect.top()));
                                                      ^0          ^0         ^0   ^0
 4163|     16|                        let bottom = body_rect
 4164|     16|                            .map(|rect| rect.bottom())
                                                      ^15  ^15
 4165|     16|                            .or_else(|| header_rect.map(|rect| rect.bottom()))
                                                      ^1          ^1         ^1   ^1
 4166|     16|                            .or_else(|| layout_rect.map(|rect| rect.bottom()));
                                                      ^0          ^0         ^0   ^0
 4167|     16|                        match (left, right, top, bottom) {
 4168|     16|                            (Some(left), Some(right), Some(top), Some(bottom)) => {
 4169|     16|                                Some(egui::Rect::from_min_max(
 4170|     16|                                    egui::pos2(left, top),
 4171|     16|                                    egui::pos2(right, bottom),
 4172|     16|                                ))
 4173|       |                            }
 4174|      0|                            _ => None,
 4175|       |                        }
 4176|       |                    } else {
 4177|      0|                        match (header_rect, body_rect, layout_rect) {
 4178|      0|                            (Some(h), Some(b), _) => Some(h.union(b)),
 4179|      0|                            (Some(h), None, _) => Some(h),
 4180|      0|                            (None, Some(b), _) => Some(b),
 4181|      0|                            (None, None, Some(layout)) => Some(layout),
 4182|      0|                            (None, None, None) => None,
 4183|       |                        }
 4184|       |                    };
 4185|       |
 4186|     16|                    if let (Some(rect), Some(clip_rect)) = (table_rect, clip_rect) {
  ------------------
  |  Branch (4186:28): [True: 16, False: 0]
  ------------------
 4187|     16|                        if column_specs.len() == widths.len() && widths.iter().any(|w| *w > 0.0) {
  ------------------
  |  Branch (4187:28): [True: 16, False: 0]
  |  Branch (4187:66): [True: 16, False: 0]
  ------------------
 4188|     16|                            let frame_id = outer_ctx.frame_nr();
 4189|     16|                            let change = self.record_resolved_widths(table_id, frame_id, &widths);
 4190|     16|                            self.persist_resizable_widths(table_id, &column_specs, &widths);
 4191|     16|                            self.handle_width_change(&outer_ctx, table_id, change);
 4192|     16|                            // Use outer_painter (captured before TableBuilder) to ensure
 4193|     16|                            // dividers paint on top of both header and body.
 4194|     16|                            self.paint_table_dividers(
 4195|     16|                                &outer_painter,
 4196|     16|                                &outer_visuals,
 4197|     16|                                rect,
 4198|     16|                                clip_rect,
 4199|     16|                                &widths,
 4200|     16|                                header_height,
 4201|     16|                                column_spacing,
 4202|     16|                            );
 4203|     16|                        }
                                      ^0
 4204|      0|                    }
 4205|     16|                    if height_change {
  ------------------
  |  Branch (4205:24): [True: 3, False: 13]
  ------------------
 4206|      3|                        ui.ctx().request_repaint();
 4207|     13|                    }
 4208|     16|                });
 4209|     16|            });
 4210|     16|        };
 4211|       |
 4212|     16|        if use_hscroll {
  ------------------
  |  Branch (4212:12): [True: 4, False: 12]
  ------------------
 4213|      4|            egui::ScrollArea::horizontal()
 4214|      4|                .id_source(("md_table_hscroll_overhaul", table_id))
 4215|      4|                .auto_shrink([false, true])
 4216|      4|                .scroll_bar_visibility(egui::scroll_area::ScrollBarVisibility::VisibleWhenNeeded)
 4217|      4|                .show(ui, |ui| {
 4218|      4|                    ui.set_min_width(content_width);
 4219|      4|                    render_table(ui, content_width);
 4220|      4|                });
 4221|     12|        } else {
 4222|     12|            render_table(ui, available_width);
 4223|     12|        }
 4224|     16|    }
 4225|       |
 4226|     26|    fn row_needs_height_estimate(&self, row: &[Vec<InlineSpan>]) -> bool {
 4227|     64|        row.iter().any(|cell| {
                      ^26        ^26
 4228|     70|            cell.iter().any(|span| match span {
                          ^64         ^64
 4229|      1|                InlineSpan::Image { .. } => true,
 4230|     67|                InlineSpan::Text(text)
 4231|      0|                | InlineSpan::Code(text)
 4232|      1|                | InlineSpan::Strong(text)
 4233|      0|                | InlineSpan::Emphasis(text)
 4234|      0|                | InlineSpan::Strikethrough(text)
 4235|     69|                | InlineSpan::Link { text, .. } => text.contains('\n'),
                                                   ^1
 4236|     70|            })
 4237|     64|        })
 4238|     26|    }
 4239|       |
 4240|     34|    fn table_min_column_width(&self) -> f32 {
 4241|     34|        (self.font_sizes.body * 6.0).max(48.0)
 4242|     34|    }
 4243|       |
 4244|     18|    fn resolve_table_column_widths(
 4245|     18|        &self,
 4246|     18|        table_id: u64,
 4247|     18|        column_specs: &[ColumnSpec],
 4248|     18|        min_floor: f32,
 4249|     18|    ) -> Vec<f32> {
 4250|     18|        if column_specs.is_empty() {
  ------------------
  |  Branch (4250:12): [True: 1, False: 17]
  ------------------
 4251|      1|            return Vec::new();
 4252|     17|        }
 4253|       |
 4254|     17|        let stored_widths = {
 4255|     17|            let metrics = self.table_metrics.borrow();
 4256|     17|            metrics
 4257|     17|                .entry(table_id)
 4258|     17|                .map(|entry| entry.current_widths().to_vec())
                                           ^16                    ^16
 4259|     17|                .unwrap_or_default()
 4260|       |        };
 4261|       |
 4262|     17|        column_specs
 4263|     17|            .iter()
 4264|     17|            .enumerate()
 4265|     52|            .map(|(idx, spec)| {
                           ^17
 4266|     52|                let stored = stored_widths
 4267|     52|                    .get(idx)
 4268|     52|                    .copied()
 4269|     52|                    .filter(|width| width.is_finite() && *width > 0.0);
                                                  ^5    ^5             ^5
  ------------------
  |  Branch (4269:37): [True: 5, False: 0]
  ------------------
 4270|     52|                let width = match spec.policy {
 4271|     13|                    ColumnPolicy::Fixed { width, .. } => width,
 4272|     20|                    ColumnPolicy::Resizable { min, preferred, .. } => {
 4273|     20|                        stored.unwrap_or(preferred.max(min)).max(min)
 4274|       |                    }
 4275|     16|                    ColumnPolicy::Remainder { .. } => min_floor,
 4276|      3|                    ColumnPolicy::Auto => stored.unwrap_or(min_floor).max(min_floor),
 4277|       |                };
 4278|     52|                width.max(1.0)
 4279|     52|            })
 4280|     17|            .collect()
 4281|     18|    }
 4282|       |
 4283|     17|    fn estimate_table_column_widths(
 4284|     17|        &self,
 4285|     17|        column_specs: &[ColumnSpec],
 4286|     17|        max_width: f32,
 4287|     17|        column_spacing: f32,
 4288|     17|    ) -> Vec<f32> {
 4289|     17|        let column_count = column_specs.len().max(1);
 4290|     17|        let spacing_total = column_spacing * column_count.saturating_sub(1) as f32;
 4291|     17|        let available = (max_width - spacing_total).max(1.0);
 4292|     17|        let min_floor = self.table_min_column_width();
 4293|     17|        let mut widths: Vec<f32> = column_specs
 4294|     17|            .iter()
 4295|     46|            .map(|spec| match spec.policy {
                           ^17
 4296|     14|                ColumnPolicy::Fixed { width, .. } => width,
 4297|     16|                ColumnPolicy::Resizable { min, .. } => min,
 4298|     13|                ColumnPolicy::Remainder { .. } => min_floor,
 4299|      3|                ColumnPolicy::Auto => min_floor,
 4300|     46|            })
 4301|     46|            .map(|width| width.max(1.0))
                           ^17
 4302|     17|            .collect();
 4303|       |
 4304|     17|        if widths.is_empty() {
  ------------------
  |  Branch (4304:12): [True: 1, False: 16]
  ------------------
 4305|      1|            return vec![available];
 4306|     16|        }
 4307|     16|        let sum: f32 = widths.iter().sum();
 4308|     16|        if sum > available && sum > 0.0 {
                                            ^1
  ------------------
  |  Branch (4308:12): [True: 1, False: 15]
  |  Branch (4308:31): [True: 1, False: 0]
  ------------------
 4309|      1|            let scale = available / sum;
 4310|      3|            for width in &mut widths {
                              ^2
 4311|      2|                *width = (*width * scale).max(1.0);
 4312|      2|            }
 4313|     15|        }
 4314|     16|        widths
 4315|     17|    }
 4316|       |
 4317|       |    #[cfg(test)]
 4318|      2|    fn estimate_table_total_width(
 4319|      2|        &self,
 4320|      2|        table_id: u64,
 4321|      2|        column_specs: &[ColumnSpec],
 4322|      2|        column_spacing: f32,
 4323|      2|    ) -> f32 {
 4324|      2|        if column_specs.is_empty() {
  ------------------
  |  Branch (4324:12): [True: 1, False: 1]
  ------------------
 4325|      1|            return 0.0;
 4326|      1|        }
 4327|      1|        let min_floor = self.table_min_column_width();
 4328|      1|        let widths = self.resolve_table_column_widths(table_id, column_specs, min_floor);
 4329|      1|        let spacing_total = column_spacing * widths.len().saturating_sub(1) as f32;
 4330|      1|        widths.iter().sum::<f32>() + spacing_total
 4331|      2|    }
 4332|       |
 4333|      9|    fn estimate_table_row_height(
 4334|      9|        &self,
 4335|      9|        ui: &egui::Ui,
 4336|      9|        style: &egui::Style,
 4337|      9|        row: &[Vec<InlineSpan>],
 4338|      9|        column_aligns: &[Align],
 4339|      9|        widths: &[f32],
 4340|      9|        fallback: f32,
 4341|      9|    ) -> f32 {
 4342|      9|        let mut max_height = fallback;
 4343|      9|        let column_count = widths.len().max(row.len()).max(1);
 4344|     20|        for ci in 0..column_count {
                                   ^9
 4345|     20|            let spans = row.get(ci).map(|cell| cell.as_slice()).unwrap_or(&[]);
 4346|     20|            if spans.is_empty() {
  ------------------
  |  Branch (4346:16): [True: 1, False: 19]
  ------------------
 4347|      1|                continue;
 4348|     19|            }
 4349|     19|            let width = widths
 4350|     19|                .get(ci)
 4351|     19|                .copied()
 4352|     19|                .or_else(|| widths.last().copied())
                                          ^0     ^0     ^0
 4353|     19|                .unwrap_or(1.0);
 4354|     19|            let halign = column_aligns.get(ci).copied().unwrap_or(Align::LEFT);
 4355|     19|            let height = self.estimate_table_cell_height(style, ui, spans, width, halign, fallback);
 4356|     19|            max_height = max_height.max(height);
 4357|       |        }
 4358|      9|        max_height
 4359|      9|    }
 4360|       |
 4361|     22|    fn estimate_table_cell_height(
 4362|     22|        &self,
 4363|     22|        style: &egui::Style,
 4364|     22|        ui: &egui::Ui,
 4365|     22|        spans: &[InlineSpan],
 4366|     22|        width: f32,
 4367|     22|        halign: Align,
 4368|     22|        fallback: f32,
 4369|     22|    ) -> f32 {
 4370|     22|        if spans.is_empty() {
  ------------------
  |  Branch (4370:12): [True: 1, False: 21]
  ------------------
 4371|      1|            return fallback;
 4372|     21|        }
 4373|     21|        let fragments = self.cell_fragments(spans);
 4374|     21|        let mut total = 0.0;
 4375|     22|        for (idx, fragment) in fragments.into_iter().enumerate() {
                                             ^21       ^21         ^21
 4376|     22|            if idx > 0 {
  ------------------
  |  Branch (4376:16): [True: 1, False: 21]
  ------------------
 4377|      1|                total += 2.0;
 4378|     21|            }
 4379|     22|            match fragment {
 4380|     19|                CellFragment::Text(slice) => {
 4381|     19|                    let build = self.build_layout_job(style, slice, width, false, halign);
 4382|     19|                    let height = ui.fonts(|f| f.layout_job(build.job.clone()).size().y);
 4383|     19|                    total += height;
 4384|       |                }
 4385|      1|                CellFragment::Emoji(_) => {
 4386|      1|                    total += self.font_sizes.body * 1.2;
 4387|      1|                }
 4388|      2|                CellFragment::Image(span) => {
 4389|      2|                    total += self.estimate_table_image_height(ui, span, width);
 4390|      2|                }
 4391|       |            }
 4392|       |        }
 4393|     21|        total.max(fallback)
 4394|     22|    }
 4395|       |
 4396|      4|    fn estimate_table_image_height(
 4397|      4|        &self,
 4398|      4|        ui: &egui::Ui,
 4399|      4|        span: &InlineSpan,
 4400|      4|        available_w: f32,
 4401|      4|    ) -> f32 {
 4402|      4|        let InlineSpan::Image { src, title, .. } = span else {
                                              ^3   ^3
  ------------------
  |  Branch (4402:13): [True: 3, False: 1]
  ------------------
 4403|      1|            return self.font_sizes.body * 1.2;
 4404|       |        };
 4405|      3|        let resolved = self.resolve_image_path(src);
 4406|      3|        let (tw, th) = self
 4407|      3|            .get_or_load_image_texture(ui, &resolved)
 4408|      3|            .map(|(_, w, h)| (w as f32, h as f32))
                                            ^1        ^1
 4409|      3|            .unwrap_or((self.font_sizes.body * 12.0, self.font_sizes.body * 8.0));
 4410|      3|        let base_scale = self.ui_scale();
 4411|      3|        let scaled_w = tw * base_scale;
 4412|      3|        let scale = if scaled_w > available_w {
  ------------------
  |  Branch (4412:24): [True: 3, False: 0]
  ------------------
 4413|      3|            (available_w / tw).clamp(0.01, 4.0)
 4414|       |        } else {
 4415|      0|            base_scale
 4416|       |        };
 4417|      3|        let mut height = (th * scale).round();
 4418|      3|        if let Some(text) = title {
                                  ^2
  ------------------
  |  Branch (4418:16): [True: 2, False: 1]
  ------------------
 4419|      2|            if !text.is_empty() {
  ------------------
  |  Branch (4419:16): [True: 2, False: 0]
  ------------------
 4420|      2|                height += 2.0 + (self.font_sizes.body - 2.0).max(1.0);
 4421|      2|            }
                          ^0
 4422|      1|        }
 4423|      3|        height + 6.0
 4424|      4|    }
 4425|       |
 4426|    213|    fn row_height_fallback(&self) -> f32 {
 4427|    213|        self.font_sizes.body * 1.6
 4428|    213|    }
 4429|       |
 4430|     24|    fn row_height_hint(&self, table_id: u64, idx: usize) -> f32 {
 4431|     24|        let fallback = self.row_height_fallback();
 4432|     24|        self.table_metrics
 4433|     24|            .borrow()
 4434|     24|            .entry(table_id)
 4435|     24|            .and_then(|entry| entry.row(idx))
 4436|     24|            .map(|m| {
                                   ^1
 4437|      1|                if m.max_height > 0.0 {
  ------------------
  |  Branch (4437:20): [True: 1, False: 0]
  ------------------
 4438|      1|                    m.max_height
 4439|       |                } else {
 4440|      0|                    fallback
 4441|       |                }
 4442|      1|            })
 4443|     24|            .unwrap_or(fallback)
 4444|     24|    }
 4445|       |
 4446|     24|    fn update_row_height(&self, table_id: u64, idx: usize, height: f32) {
 4447|     24|        let clamped = height.max(self.row_height_fallback());
 4448|     24|        let mut metrics = self.table_metrics.borrow_mut();
 4449|     24|        let entry = metrics.entry_mut(table_id);
 4450|     24|        let row = entry.ensure_row(idx);
 4451|     24|        row.max_height = clamped;
 4452|     24|        row.dirty = false;
 4453|     24|    }
 4454|       |
 4455|     16|    fn update_header_height(&self, table_id: u64, height: f32) -> bool {
 4456|     16|        let mut metrics = self.table_metrics.borrow_mut();
 4457|     16|        let entry = metrics.entry_mut(table_id);
 4458|     16|        entry.update_header_height(height)
 4459|     16|    }
 4460|       |
 4461|     16|    fn begin_table_pass(&self, table_id: u64, total_rows: usize) {
 4462|     16|        let mut metrics = self.table_metrics.borrow_mut();
 4463|     16|        metrics.entry_mut(table_id).begin_pass(total_rows);
 4464|     16|    }
 4465|       |
 4466|     24|    fn note_row_rendered(&self, table_id: u64) {
 4467|     24|        let mut metrics = self.table_metrics.borrow_mut();
 4468|     24|        metrics.entry_mut(table_id).note_row_rendered();
 4469|     24|    }
 4470|       |
 4471|     17|    fn apply_persisted_widths(&self, table_id: u64, specs: &mut [ColumnSpec]) {
 4472|     17|        if specs.is_empty() {
  ------------------
  |  Branch (4472:12): [True: 1, False: 16]
  ------------------
 4473|      1|            return;
 4474|     16|        }
 4475|     16|        let mut metrics = self.table_metrics.borrow_mut();
 4476|     16|        let entry = metrics.entry_mut(table_id);
 4477|     49|        for spec in specs.iter_mut() {
                                  ^16   ^16
 4478|     49|            if let Some(width) = entry.persisted_width(spec.policy_hash) {
                                      ^2
  ------------------
  |  Branch (4478:20): [True: 2, False: 47]
  ------------------
 4479|      2|                spec.apply_preferred_width(width);
 4480|     47|            }
 4481|       |        }
 4482|     17|    }
 4483|       |
 4484|     24|    fn persist_resizable_widths(&self, table_id: u64, specs: &[ColumnSpec], widths: &[f32]) {
 4485|     24|        if specs.is_empty() || widths.is_empty() {
                                             ^22    ^22
  ------------------
  |  Branch (4485:12): [True: 2, False: 22]
  |  Branch (4485:32): [True: 0, False: 22]
  ------------------
 4486|      2|            return;
 4487|     22|        }
 4488|     22|        let mut metrics = self.table_metrics.borrow_mut();
 4489|     22|        let entry = metrics.entry_mut(table_id);
 4490|       |
 4491|       |        // Check if font size changed since last persist - if so, clear old widths
 4492|       |        // to prevent size mismatch after zoom changes. Skip persisting in this
 4493|       |        // frame so the next layout can compute fresh widths before we store them.
 4494|     22|        if entry.check_font_size_change(self.font_sizes.body) {
  ------------------
  |  Branch (4494:12): [True: 1, False: 21]
  ------------------
 4495|      1|            return;
 4496|     21|        }
 4497|       |
 4498|     54|        for (spec, width) in specs.iter().zip(widths.iter()) {
                                           ^21   ^21    ^21 ^21    ^21
 4499|     54|            if let ColumnPolicy::Resizable { .. } = spec.policy {
  ------------------
  |  Branch (4499:20): [True: 23, False: 31]
  ------------------
 4500|     23|                let stored = entry.persisted_width(spec.policy_hash).unwrap_or(-1.0);
 4501|     23|                if stored < 0.0 || (stored - width).abs() > 0.5 {
                                                 ^2
  ------------------
  |  Branch (4501:20): [True: 21, False: 2]
  |  Branch (4501:36): [True: 0, False: 2]
  ------------------
 4502|     21|                    entry.set_persisted_width(spec.policy_hash, *width);
 4503|     21|                }
                              ^2
 4504|     31|            }
 4505|       |        }
 4506|     24|    }
 4507|       |
 4508|     17|    fn record_resolved_widths(&self, table_id: u64, frame_id: u64, widths: &[f32]) -> WidthChange {
 4509|     17|        if widths.is_empty() {
  ------------------
  |  Branch (4509:12): [True: 1, False: 16]
  ------------------
 4510|      1|            return WidthChange::None;
 4511|     16|        }
 4512|     16|        let mut metrics = self.table_metrics.borrow_mut();
 4513|     16|        metrics.entry_mut(table_id).update_widths(widths, frame_id)
 4514|     17|    }
 4515|       |
 4516|     17|    fn handle_width_change(&self, ctx: &Context, table_id: u64, change: WidthChange) {
 4517|     17|        if matches!(change, WidthChange::Large) {
                         ^16
 4518|      1|            let frame_id = ctx.frame_nr();
 4519|      1|            let mut metrics = self.table_metrics.borrow_mut();
 4520|      1|            let entry = metrics.entry_mut(table_id);
 4521|      1|            if entry.last_discard_frame != Some(frame_id) {
  ------------------
  |  Branch (4521:16): [True: 1, False: 0]
  ------------------
 4522|      1|                ctx.request_repaint();
 4523|      1|                entry.last_discard_frame = Some(frame_id);
 4524|      1|            }
                          ^0
 4525|     16|        }
 4526|     17|    }
 4527|       |
 4528|       |    /// Paint vertical dividers between table columns, a horizontal header separator,
 4529|       |    /// and an outer border.
 4530|       |    ///
 4531|       |    /// # Arguments
 4532|       |    /// * `widths` - The actual allocated column widths from `TableBody::widths()`.
 4533|       |    ///   IMPORTANT: These must NOT be cell content widths from `ui.min_rect()`,
 4534|       |    ///   which would cause dividers to be misaligned.
 4535|       |    /// * `header_height` - The height of the header row. A horizontal separator is
 4536|       |    ///   drawn at this y-offset to visually separate header from body rows.
 4537|       |    #[allow(clippy::too_many_arguments)]
 4538|     17|    fn paint_table_dividers(
 4539|     17|        &self,
 4540|     17|        painter: &Painter,
 4541|     17|        visuals: &Visuals,
 4542|     17|        rect: egui::Rect,
 4543|     17|        clip_rect: egui::Rect,
 4544|     17|        widths: &[f32],
 4545|     17|        header_height: f32,
 4546|     17|        column_spacing: f32,
 4547|     17|    ) {
 4548|     17|        if widths.is_empty() {
  ------------------
  |  Branch (4548:12): [True: 1, False: 16]
  ------------------
 4549|      1|            return;
 4550|     16|        }
 4551|     16|        let separator_color = visuals
 4552|     16|            .widgets
 4553|     16|            .noninteractive
 4554|     16|            .bg_stroke
 4555|     16|            .color
 4556|     16|            .gamma_multiply(0.9);
 4557|     16|        let separator_stroke = Stroke::new(1.0, separator_color);
 4558|     16|        let border_stroke = visuals.window_stroke();
 4559|       |        // Expand clip_rect to include the full table rect so borders aren't clipped.
 4560|       |        // The cell clip_rect may not include the outer border area.
 4561|     16|        let expanded_clip = clip_rect.union(rect);
 4562|     16|        let painter = painter.with_clip_rect(expanded_clip);
 4563|       |
 4564|       |        // Draw vertical dividers between columns
 4565|     16|        if widths.len() > 1 {
  ------------------
  |  Branch (4565:12): [True: 14, False: 2]
  ------------------
 4566|     14|            let mut x = rect.left();
 4567|     33|            for (idx, width) in widths
                                              ^14
 4568|     14|                .iter()
 4569|     14|                .take(widths.len().saturating_sub(1))
 4570|     14|                .enumerate()
 4571|     33|            {
 4572|     33|                x += *width;
 4573|     33|                let divider_x = x + column_spacing * (idx as f32 + 0.5);
 4574|     33|                let x_pos = (divider_x.round() + 0.5).clamp(rect.left(), rect.right());
 4575|     33|                painter.vline(x_pos, rect.y_range(), separator_stroke);
 4576|     33|            }
 4577|      2|        }
 4578|       |
 4579|       |        // Draw horizontal separator below header row
 4580|     16|        if header_height > 0.0 {
  ------------------
  |  Branch (4580:12): [True: 16, False: 0]
  ------------------
 4581|     16|            let header_y = rect.top() + header_height;
 4582|     16|            if header_y > rect.top() && header_y < rect.bottom() {
  ------------------
  |  Branch (4582:16): [True: 16, False: 0]
  |  Branch (4582:41): [True: 15, False: 1]
  ------------------
 4583|     15|                painter.hline(rect.x_range(), header_y.round() + 0.5, separator_stroke);
 4584|     15|            }
                          ^1
 4585|      0|        }
 4586|       |
 4587|       |        // Draw outer border
 4588|     16|        painter.rect_stroke(rect, 0.0, border_stroke);
 4589|     17|    }
 4590|       |
 4591|       |    #[allow(clippy::too_many_arguments)]
 4592|    119|    fn render_overhauled_cell(
 4593|    119|        &self,
 4594|    119|        ui: &mut egui::Ui,
 4595|    119|        spans: &[InlineSpan],
 4596|    119|        width: f32,
 4597|    119|        is_header: bool,
 4598|    119|        row_idx: Option<usize>,
 4599|    119|        col_idx: usize,
 4600|    119|        halign: Align,
 4601|    119|    ) -> f32 {
 4602|    119|        let fallback_height = self.row_height_fallback();
 4603|    119|        let fragments = self.cell_fragments(spans);
 4604|    119|        let inner = ui.allocate_ui_with_layout(
 4605|    119|            Vec2::new(width, 0.0),
 4606|    119|            egui::Layout::top_down(halign),
 4607|    119|            |ui| {
 4608|    119|                ui.set_width(width);
 4609|    119|                ui.set_max_width(width);
 4610|    119|                ui.spacing_mut().item_spacing = egui::vec2(4.0, 2.0);
 4611|    119|                if fragments.is_empty() {
  ------------------
  |  Branch (4611:20): [True: 4, False: 115]
  ------------------
 4612|      4|                    ui.allocate_exact_size(
 4613|      4|                        Vec2::new(width, self.font_sizes.body * 1.2),
 4614|      4|                        egui::Sense::hover(),
 4615|       |                    );
 4616|      4|                    return;
 4617|    115|                }
 4618|    231|                for fragment in fragments {
                                  ^116
 4619|    116|                    match fragment {
 4620|    113|                        CellFragment::Text(slice) => {
 4621|    113|                            let build = self.cached_layout_job(
 4622|    113|                                ui.style(),
 4623|    113|                                row_idx,
 4624|    113|                                col_idx,
 4625|    113|                                slice,
 4626|    113|                                width,
 4627|    113|                                is_header,
 4628|    113|                                halign,
 4629|    113|                            );
 4630|    113|                            self.paint_table_text_job(ui, width, build);
 4631|    113|                        }
 4632|      0|                        CellFragment::Emoji(key) => {
 4633|      0|                            self.render_table_emoji(ui, &key);
 4634|      0|                        }
 4635|      3|                        CellFragment::Image(span) => {
 4636|      3|                            self.render_inline_span(ui, span, None, Some(is_header));
 4637|      3|                        }
 4638|       |                    }
 4639|       |                }
 4640|    119|            },
 4641|       |        );
 4642|    119|        inner.response.rect.height().max(fallback_height)
 4643|    119|    }
 4644|       |
 4645|    116|    fn paint_table_text_job(
 4646|    116|        &self,
 4647|    116|        ui: &mut egui::Ui,
 4648|    116|        width: f32,
 4649|    116|        build: LayoutJobBuild,
 4650|    116|    ) -> egui::Response {
 4651|    116|        let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
 4652|    116|        let height = galley.size().y;
 4653|    116|        let (rect, mut response) =
 4654|    116|            ui.allocate_exact_size(Vec2::new(width, height), egui::Sense::click());
 4655|    116|        let text_color = ui.visuals().text_color();
 4656|    116|        let text_origin = Self::aligned_text_origin(rect, &galley, build.job.halign);
 4657|    116|        ui.painter_at(rect)
 4658|    116|            .galley(text_origin, galley.clone(), text_color);
 4659|    116|        if galley.rows.len() > 1 || galley.size().x > width + 0.5 {
                                                  ^99
  ------------------
  |  Branch (4659:12): [True: 17, False: 99]
  |  Branch (4659:37): [True: 0, False: 99]
  ------------------
 4660|     17|            response = response.on_hover_text(build.plain_text.clone());
 4661|     99|        }
 4662|    116|        response.context_menu(|ui| {
                                                 ^0
 4663|      0|            self.render_cell_context_menu(ui, &build.plain_text);
 4664|      0|        });
 4665|       |
 4666|    116|        if let Some(link) = self.link_at_pointer(&response, &galley, &build, text_origin) {
                                  ^1
  ------------------
  |  Branch (4666:16): [True: 1, False: 115]
  ------------------
 4667|      1|            ui.output_mut(|o| o.cursor_icon = egui::CursorIcon::PointingHand);
 4668|      1|            response = response.on_hover_text(link.url.clone());
 4669|      1|            if response.clicked() {
  ------------------
  |  Branch (4669:16): [True: 1, False: 0]
  ------------------
 4670|      1|                self.trigger_link(&link.url);
 4671|      1|            }
                          ^0
 4672|    115|        }
 4673|       |
 4674|    116|        response
 4675|    116|    }
 4676|       |
 4677|       |    #[allow(clippy::too_many_arguments)]
 4678|    158|    fn cached_layout_job(
 4679|    158|        &self,
 4680|    158|        style: &egui::Style,
 4681|    158|        row_idx: Option<usize>,
 4682|    158|        col_idx: usize,
 4683|    158|        spans: &[InlineSpan],
 4684|    158|        width: f32,
 4685|    158|        is_header: bool,
 4686|    158|        halign: Align,
 4687|    158|    ) -> LayoutJobBuild {
 4688|    158|        let highlight_hash = self
 4689|    158|            .highlight_phrase
 4690|    158|            .borrow()
 4691|    158|            .as_ref()
 4692|    158|            .map(|s| Self::hash_str(s))
                                   ^8             ^8
 4693|    158|            .unwrap_or(0);
 4694|    158|        let content_hash = Self::hash_inline_spans(spans);
 4695|    158|        let text_color = style.visuals.text_color().to_array();
 4696|    158|        let key = CellLayoutKey {
 4697|    158|            row: row_idx,
 4698|    158|            col: col_idx,
 4699|    158|            width: width.round() as u32,
 4700|    158|            align: Self::align_to_u8(halign),
 4701|    158|            strong: is_header,
 4702|    158|            text_color,
 4703|    158|            highlight_hash,
 4704|    158|            content_hash,
 4705|    158|        };
 4706|    158|        if let Some(build) = self.table_layout_cache.borrow_mut().get(&key) {
                                  ^13
  ------------------
  |  Branch (4706:16): [True: 13, False: 145]
  ------------------
 4707|     13|            return build;
 4708|    145|        }
 4709|    145|        let build = self.build_layout_job(style, spans, width, is_header, halign);
 4710|    145|        self.table_layout_cache
 4711|    145|            .borrow_mut()
 4712|    145|            .insert(key, build.clone());
 4713|    145|        build
 4714|    158|    }
 4715|       |
 4716|    118|    fn link_at_pointer<'a>(
 4717|    118|        &self,
 4718|    118|        response: &egui::Response,
 4719|    118|        galley: &Arc<Galley>,
 4720|    118|        build: &'a LayoutJobBuild,
 4721|    118|        text_origin: egui::Pos2,
 4722|    118|    ) -> Option<&'a LinkRange> {
 4723|    118|        let pointer = response.hover_pos()?;
                          ^1                            ^117
 4724|      1|        let text_rect = galley.rect.translate(text_origin.to_vec2());
 4725|      1|        if !text_rect.contains(pointer) {
  ------------------
  |  Branch (4725:12): [True: 0, False: 1]
  ------------------
 4726|      0|            return None;
 4727|      1|        }
 4728|      1|        let local = pointer - text_origin;
 4729|      1|        let cursor = galley.cursor_from_pos(local);
 4730|      1|        let idx = cursor.ccursor.index;
 4731|      1|        build
 4732|      1|            .link_ranges
 4733|      1|            .iter()
 4734|      1|            .find(|range| range.char_range.contains(&idx))
 4735|    118|    }
 4736|       |
 4737|    120|    fn aligned_text_origin(rect: egui::Rect, galley: &Galley, halign: Align) -> egui::Pos2 {
 4738|    120|        let galley_rect = galley.rect;
 4739|    120|        let x = if halign == Align::RIGHT {
  ------------------
  |  Branch (4739:20): [True: 5, False: 115]
  ------------------
 4740|      5|            rect.right() - galley_rect.right()
 4741|    115|        } else if halign == Align::Center {
  ------------------
  |  Branch (4741:19): [True: 5, False: 110]
  ------------------
 4742|      5|            rect.center().x - galley_rect.center().x
 4743|       |        } else {
 4744|    110|            rect.left() - galley_rect.left()
 4745|       |        };
 4746|    120|        egui::pos2(x, rect.top() - galley_rect.top())
 4747|    120|    }
 4748|       |
 4749|      1|    fn render_table_emoji(&self, ui: &mut egui::Ui, emoji: &str) {
 4750|      1|        let handle = self.get_or_make_emoji_texture(ui, emoji);
 4751|      1|        let size = self.font_sizes.body * 1.2;
 4752|      1|        ui.add(
 4753|      1|            egui::Image::new(&handle)
 4754|      1|                .max_size(Vec2::splat(size))
 4755|      1|                .sense(egui::Sense::hover()),
 4756|       |        );
 4757|      1|    }
 4758|       |
 4759|       |    #[cfg(test)]
 4760|      8|    fn resolve_table_widths(available: f32, mins: &[f32], desired: &[f32]) -> Vec<f32> {
 4761|      8|        debug_assert_eq!(mins.len(), desired.len());
 4762|      8|        if mins.is_empty() {
  ------------------
  |  Branch (4762:12): [True: 1, False: 7]
  ------------------
 4763|      1|            return Vec::new();
 4764|      7|        }
 4765|      7|        let clamped_available = available.max(1.0);
 4766|      7|        let desired_total: f32 = desired.iter().sum();
 4767|      7|        let min_total: f32 = mins.iter().sum();
 4768|       |
 4769|      7|        let widths = if min_total >= clamped_available {
  ------------------
  |  Branch (4769:25): [True: 2, False: 5]
  ------------------
 4770|      2|            mins.iter()
 4771|      6|                .map(|m| m * (clamped_available / min_total))
                               ^2
 4772|      2|                .collect()
 4773|      5|        } else if desired_total <= clamped_available {
  ------------------
  |  Branch (4773:19): [True: 3, False: 2]
  ------------------
 4774|      3|            let slack = desired_total - min_total;
 4775|      3|            if slack <= f32::EPSILON {
  ------------------
  |  Branch (4775:16): [True: 2, False: 1]
  ------------------
 4776|      2|                let bonus = (clamped_available - min_total) / mins.len() as f32;
 4777|      4|                mins.iter().map(|m| m + bonus).collect()
                              ^2   ^2     ^2                 ^2
 4778|       |            } else {
 4779|      1|                desired.to_vec()
 4780|       |            }
 4781|       |        } else {
 4782|      2|            let mut widths = mins.to_vec();
 4783|      2|            let extra = clamped_available - min_total;
 4784|      2|            let slack: Vec<f32> = desired
 4785|      2|                .iter()
 4786|      2|                .zip(mins.iter())
 4787|      6|                .map(|(d, m)| (d - m).max(0.0))
                               ^2
 4788|      2|                .collect();
 4789|      2|            let total_slack: f32 = slack.iter().sum();
 4790|      6|            for (w, s) in widths.iter_mut().zip(slack.iter()) {
                                        ^2                ^2  ^2
 4791|      6|                *w += extra * (*s / total_slack);
 4792|      6|            }
 4793|      2|            widths
 4794|       |        };
 4795|       |
 4796|      7|        widths
 4797|      8|    }
 4798|       |
 4799|       |    /// Open URL in default browser
 4800|       |    #[cfg(not(test))]
 4801|       |    fn open_url(&self, url: &str) {
 4802|       |        if let Err(e) = webbrowser::open(url) {
 4803|       |            eprintln!("Failed to open URL {}: {}", url, e);
 4804|       |        }
 4805|       |    }
 4806|       |
 4807|       |    #[cfg(test)]
 4808|      5|    fn open_url(&self, _url: &str) {}
 4809|       |
 4810|     10|    pub(crate) fn trigger_link(&self, url: &str) {
 4811|     10|        if let Some(fragment) = Self::extract_fragment(url) {
                                  ^4
  ------------------
  |  Branch (4811:16): [True: 4, False: 6]
  ------------------
 4812|      4|            *self.pending_anchor.borrow_mut() = Some(fragment);
 4813|      6|        } else if Self::is_allowed_scheme(url) {
  ------------------
  |  Branch (4813:19): [True: 5, False: 1]
  ------------------
 4814|      5|            self.open_url(url);
 4815|      5|        } else {
 4816|      1|            eprintln!("Blocked link with unsupported scheme: {}", url);
 4817|      1|        }
 4818|     10|    }
 4819|       |
 4820|     10|    fn is_allowed_scheme(url: &str) -> bool {
 4821|     10|        url.starts_with("http://") || url.starts_with("https://") || url.starts_with("mailto:")
                                                    ^9  ^9                         ^4  ^4
  ------------------
  |  Branch (4821:9): [True: 1, False: 9]
  |  Branch (4821:39): [True: 5, False: 4]
  ------------------
 4822|     10|    }
 4823|       |
 4824|       |    /// Consume and return the last clicked internal anchor, if any
 4825|     17|    pub fn take_pending_anchor(&self) -> Option<String> {
 4826|     17|        self.pending_anchor.borrow_mut().take()
 4827|     17|    }
 4828|       |
 4829|       |    /// Lookup a header rect by its id (slug)
 4830|      2|    pub fn header_rect_for(&self, id: &str) -> Option<egui::Rect> {
 4831|      2|        self.header_rects.borrow().get(id).copied()
 4832|      2|    }
 4833|       |
 4834|       |    /// Lookup the rect for the n-th top-level element rendered in the last frame
 4835|      7|    pub fn element_rect_at(&self, index: usize) -> Option<egui::Rect> {
 4836|      7|        self.element_rects.borrow().get(index).copied()
 4837|      7|    }
 4838|       |
 4839|     12|    pub fn layout_signature(&self) -> u64 {
 4840|     12|        let rects = self.element_rects.borrow();
 4841|     12|        let mut h = DefaultHasher::new();
 4842|     12|        rects.len().hash(&mut h);
 4843|     37|        for rect in rects.iter() {
                                  ^12   ^12
 4844|     37|            let min_x = (rect.min.x * 2.0).round() as i32;
 4845|     37|            let min_y = (rect.min.y * 2.0).round() as i32;
 4846|     37|            let max_x = (rect.max.x * 2.0).round() as i32;
 4847|     37|            let max_y = (rect.max.y * 2.0).round() as i32;
 4848|     37|            (min_x, min_y, max_x, max_y).hash(&mut h);
 4849|     37|        }
 4850|     12|        h.finish()
 4851|     12|    }
 4852|       |
 4853|      6|    pub fn has_pending_renders(&self) -> bool {
 4854|      6|        self.mermaid.has_pending() || !self.image_pending.borrow().is_empty()
  ------------------
  |  Branch (4854:9): [True: 0, False: 6]
  ------------------
 4855|      6|    }
 4856|       |
 4857|       |    /// Set or clear the highlight phrase (case-insensitive)
 4858|     21|    pub fn set_highlight_phrase(&self, phrase: Option<&str>) {
 4859|     21|        let normalized = phrase
 4860|     21|            .map(|p| p.case_fold().nfkc().collect::<String>())
                                   ^8^8          ^8     ^8
 4861|     21|            .filter(|value| !value.is_empty());
                                           ^8    ^8
 4862|       |        {
 4863|     21|            let mut current = self.highlight_phrase.borrow_mut();
 4864|     21|            if *current == normalized {
  ------------------
  |  Branch (4864:16): [True: 14, False: 7]
  ------------------
 4865|     14|                return;
 4866|      7|            }
 4867|      7|            *current = normalized;
 4868|       |        }
 4869|      7|        self.table_layout_cache.borrow_mut().clear();
 4870|     21|    }
 4871|       |
 4872|    200|    pub fn clear_table_layout_cache(&self) {
 4873|    200|        self.table_layout_cache.borrow_mut().clear();
 4874|    200|        self.table_metrics.borrow_mut().clear();
 4875|    200|        self.column_stats_cache.borrow_mut().clear();
 4876|    200|    }
 4877|       |
 4878|      4|    pub fn table_layout_cache_stats(&self) -> (u64, u64) {
 4879|      4|        self.table_layout_cache.borrow().stats()
 4880|      4|    }
 4881|       |
 4882|      2|    pub fn table_render_stats(&self) -> (usize, usize) {
 4883|      2|        self.table_metrics.borrow().totals()
 4884|      2|    }
 4885|       |
 4886|       |    /// Get a plain-text representation of a markdown element (for search)
 4887|     50|    pub fn element_plain_text(element: &MarkdownElement) -> String {
 4888|     50|        match element {
 4889|     42|            MarkdownElement::Paragraph(spans) => Self::spans_plain_text(spans),
 4890|      0|            MarkdownElement::Header { spans, .. } => Self::spans_plain_text(spans),
 4891|      0|            MarkdownElement::CodeBlock { text, .. } => text.clone(),
 4892|      2|            MarkdownElement::List { items, .. } => {
 4893|      2|                let mut out = String::new();
 4894|      4|                for item in items {
                                  ^2
 4895|      5|                    for block in &item.blocks {
                                      ^3
 4896|      3|                        if !out.is_empty() {
  ------------------
  |  Branch (4896:28): [True: 1, False: 2]
  ------------------
 4897|      1|                            out.push('\n');
 4898|      2|                        }
 4899|      3|                        out.push_str(&Self::element_plain_text(block));
 4900|       |                    }
 4901|       |                }
 4902|      2|                out
 4903|       |            }
 4904|      2|            MarkdownElement::Quote { blocks, .. } => {
 4905|      2|                let mut out = String::new();
 4906|      5|                for block in blocks {
                                  ^3
 4907|      3|                    if !out.is_empty() {
  ------------------
  |  Branch (4907:24): [True: 1, False: 2]
  ------------------
 4908|      1|                        out.push('\n');
 4909|      2|                    }
 4910|      3|                    out.push_str(&Self::element_plain_text(block));
 4911|       |                }
 4912|      2|                out
 4913|       |            }
 4914|      1|            MarkdownElement::HorizontalRule => String::from("---"),
 4915|       |            MarkdownElement::Table {
 4916|      3|                headers,
 4917|      3|                rows,
 4918|       |                alignments: _,
 4919|       |            } => {
 4920|      3|                let mut out = String::new();
 4921|      7|                for h in headers {
                                  ^4
 4922|      4|                    if !out.is_empty() {
  ------------------
  |  Branch (4922:24): [True: 1, False: 3]
  ------------------
 4923|      1|                        out.push(' ');
 4924|      3|                    }
 4925|      4|                    out.push_str(&Self::spans_plain_text(h));
 4926|       |                }
 4927|      6|                for row in rows {
                                  ^3
 4928|      7|                    for cell in row {
                                      ^4
 4929|      4|                        out.push(' ');
 4930|      4|                        out.push_str(&Self::spans_plain_text(cell));
 4931|      4|                    }
 4932|       |                }
 4933|      3|                out
 4934|       |            }
 4935|       |        }
 4936|     50|    }
 4937|       |
 4938|       |    /// Set the base directory for resolving relative image paths
 4939|     58|    pub fn set_base_dir(&self, dir: Option<&Path>) {
 4940|     58|        if let Some(d) = dir {
                                  ^32
  ------------------
  |  Branch (4940:16): [True: 32, False: 26]
  ------------------
 4941|     32|            self.base_dir.borrow_mut().replace(d.to_path_buf());
 4942|     32|        } else {
 4943|     26|            self.base_dir.borrow_mut().take();
 4944|     26|        }
 4945|     58|    }
 4946|       |
 4947|     27|    fn poll_image_results(&self, ctx: &egui::Context) -> bool {
 4948|     27|        let mut changed = false;
 4949|     32|        while let Ok(result) = self.image_result_rx.try_recv() {
                                   ^5
  ------------------
  |  Branch (4949:19): [True: 5, False: 27]
  ------------------
 4950|      5|            match result {
 4951|       |                ImageLoadResult::Loaded {
 4952|      5|                    key,
 4953|      5|                    image,
 4954|      5|                    size,
 4955|      5|                    modified,
 4956|      5|                } => {
 4957|      5|                    let tex =
 4958|      5|                        ctx.load_texture(format!("img:{key}"), image, egui::TextureOptions::LINEAR);
 4959|      5|                    self.store_image_texture(&key, tex.clone(), size, modified);
 4960|      5|                    self.image_failures.borrow_mut().remove(&key);
 4961|      5|                    self.image_pending.borrow_mut().remove(&key);
 4962|      5|                    changed = true;
 4963|      5|                }
 4964|      0|                ImageLoadResult::Failed { key } => {
 4965|      0|                    self.image_pending.borrow_mut().remove(&key);
 4966|      0|                    self.note_image_failure(&key);
 4967|      0|                }
 4968|       |            }
 4969|       |        }
 4970|     27|        if changed {
  ------------------
  |  Branch (4970:12): [True: 5, False: 22]
  ------------------
 4971|      5|            ctx.request_repaint();
 4972|     22|        }
 4973|     27|        changed
 4974|     27|    }
 4975|       |
 4976|     11|    fn enqueue_image_job(&self, request: ImageLoadRequest) -> Result<(), ()> {
 4977|     11|        match self.image_job_tx.try_send(request) {
 4978|     11|            Ok(()) => Ok(()),
 4979|      0|            Err(TrySendError::Full(_)) => Err(()),
 4980|      0|            Err(TrySendError::Disconnected(_)) => Err(()),
 4981|       |        }
 4982|     11|    }
 4983|       |
 4984|     18|    fn should_retry_image(&self, key: &str) -> bool {
 4985|     18|        let mut failures = self.image_failures.borrow_mut();
 4986|     18|        if let Some(failure) = failures.get(key) {
                                  ^3
  ------------------
  |  Branch (4986:16): [True: 3, False: 15]
  ------------------
 4987|      3|            if failure.last_attempt.elapsed() < IMAGE_FAILURE_BACKOFF {
  ------------------
  |  Branch (4987:16): [True: 2, False: 1]
  ------------------
 4988|      2|                return false;
 4989|      1|            }
 4990|     15|        }
 4991|     16|        failures.remove(key);
 4992|     16|        true
 4993|     18|    }
 4994|       |
 4995|      5|    fn note_image_failure(&self, key: &str) {
 4996|      5|        self.image_failures.borrow_mut().insert(
 4997|      5|            key.to_string(),
 4998|      5|            ImageFailure {
 4999|      5|                last_attempt: Instant::now(),
 5000|      5|            },
 5001|      5|        );
 5002|      5|    }
 5003|       |
 5004|     28|    fn resolve_image_path(&self, src: &str) -> String {
 5005|     28|        if src.starts_with("http://") || src.starts_with("https://") || src.starts_with("data:") {
                                                       ^26 ^26                        ^23 ^23
  ------------------
  |  Branch (5005:12): [True: 2, False: 26]
  |  Branch (5005:42): [True: 3, False: 23]
  |  Branch (5005:73): [True: 2, False: 21]
  ------------------
 5006|       |            // Keep as-is; we don't fetch remote or parse data URIs yet
 5007|      7|            return src.to_string();
 5008|     21|        }
 5009|     21|        let p = Path::new(src);
 5010|     21|        if p.is_absolute() {
  ------------------
  |  Branch (5010:12): [True: 1, False: 20]
  ------------------
 5011|      1|            return src.to_string();
 5012|     20|        }
 5013|     20|        if let Some(base) = self.base_dir.borrow().as_ref() {
                                  ^5
  ------------------
  |  Branch (5013:16): [True: 5, False: 15]
  ------------------
 5014|      5|            let joined = base.join(p);
 5015|      5|            return joined.to_string_lossy().into_owned();
 5016|     15|        }
 5017|     15|        src.to_string()
 5018|     28|    }
 5019|       |
 5020|     43|    fn get_or_load_image_texture(
 5021|     43|        &self,
 5022|     43|        _ui: &egui::Ui,
 5023|     43|        resolved_src: &str,
 5024|     43|    ) -> Option<(egui::TextureHandle, u32, u32)> {
 5025|       |        // Reject remote for now
 5026|     43|        if resolved_src.starts_with("http://") || resolved_src.starts_with("https://") {
                                                                ^41          ^41
  ------------------
  |  Branch (5026:12): [True: 2, False: 41]
  |  Branch (5026:51): [True: 5, False: 36]
  ------------------
 5027|      7|            return None;
 5028|     36|        }
 5029|       |
 5030|     36|        let path = Path::new(resolved_src);
 5031|     36|        let embedded = Self::embedded_image_bytes(resolved_src);
 5032|       |
 5033|       |        {
 5034|     36|            let mut cache = self.image_textures.borrow_mut();
 5035|     36|            if let Some(entry) = cache.get(resolved_src) {
                                      ^13
  ------------------
  |  Branch (5035:20): [True: 13, False: 23]
  ------------------
 5036|     13|                let stale = if embedded.is_some() {
  ------------------
  |  Branch (5036:32): [True: 4, False: 9]
  ------------------
 5037|      4|                    false
 5038|       |                } else {
 5039|      9|                    Self::image_source_stale(entry.modified, path)
 5040|       |                };
 5041|     13|                if !stale {
  ------------------
  |  Branch (5041:20): [True: 13, False: 0]
  ------------------
 5042|     13|                    return Some((entry.texture.clone(), entry.size[0], entry.size[1]));
 5043|      0|                }
 5044|      0|                cache.remove(resolved_src);
 5045|     23|            }
 5046|       |        }
 5047|       |
 5048|     23|        if self.image_pending.borrow().contains(resolved_src) {
  ------------------
  |  Branch (5048:12): [True: 7, False: 16]
  ------------------
 5049|      7|            return None;
 5050|     16|        }
 5051|       |
 5052|     16|        if !self.should_retry_image(resolved_src) {
  ------------------
  |  Branch (5052:12): [True: 1, False: 15]
  ------------------
 5053|      1|            return None;
 5054|     15|        }
 5055|       |
 5056|     15|        let source = if let Some(bytes) = embedded {
                          ^11                  ^8
  ------------------
  |  Branch (5056:29): [True: 8, False: 7]
  ------------------
 5057|      8|            ImageLoadSource::Embedded(bytes)
 5058|       |        } else {
 5059|      7|            if !path.exists() {
  ------------------
  |  Branch (5059:16): [True: 4, False: 3]
  ------------------
 5060|      4|                self.note_image_failure(resolved_src);
 5061|      4|                return None;
 5062|      3|            }
 5063|      3|            ImageLoadSource::File(path.to_path_buf())
 5064|       |        };
 5065|       |
 5066|     11|        let request = ImageLoadRequest {
 5067|     11|            key: resolved_src.to_string(),
 5068|     11|            source,
 5069|     11|        };
 5070|     11|        if self.enqueue_image_job(request).is_ok() {
  ------------------
  |  Branch (5070:12): [True: 11, False: 0]
  ------------------
 5071|     11|            self.image_pending
 5072|     11|                .borrow_mut()
 5073|     11|                .insert(resolved_src.to_string());
 5074|     11|        }
                      ^0
 5075|     11|        None
 5076|     43|    }
 5077|       |
 5078|     11|    fn disk_image_timestamp(path: &Path) -> Option<SystemTime> {
 5079|     11|        std::fs::metadata(path).ok()?.modified().ok()
                                                  ^0
 5080|     11|    }
 5081|       |
 5082|     12|    fn image_source_stale(cached_modified: Option<SystemTime>, path: &Path) -> bool {
 5083|     12|        if !path.exists() {
  ------------------
  |  Branch (5083:12): [True: 5, False: 7]
  ------------------
 5084|      5|            return cached_modified.is_some();
 5085|      7|        }
 5086|      7|        let current = Self::disk_image_timestamp(path);
 5087|      7|        match (cached_modified, current) {
 5088|      7|            (Some(prev), Some(cur)) => prev != cur,
 5089|      0|            (Some(_), None) => true,
 5090|      0|            (None, Some(_)) => true,
 5091|      0|            (None, None) => false,
 5092|       |        }
 5093|     12|    }
 5094|       |
 5095|      6|    fn store_image_texture(
 5096|      6|        &self,
 5097|      6|        key: &str,
 5098|      6|        texture: egui::TextureHandle,
 5099|      6|        size: [u32; 2],
 5100|      6|        modified: Option<SystemTime>,
 5101|      6|    ) {
 5102|      6|        self.image_textures.borrow_mut().insert(
 5103|      6|            key.to_string(),
 5104|      6|            ImageCacheEntry {
 5105|      6|                texture,
 5106|      6|                size,
 5107|      6|                modified,
 5108|      6|            },
 5109|      6|        );
 5110|      6|    }
 5111|       |
 5112|       |    /// Return embedded image bytes for known assets used in sample files
 5113|     36|    fn embedded_image_bytes(path: &str) -> Option<&'static [u8]> {
 5114|     36|        match path.replace('\\', "/").as_str() {
 5115|       |            // Smiley PNG
 5116|     36|            "assets/emoji/1f600.png" => Some(include_bytes!("../assets/emoji/1f600.png")),
                                                      ^12
 5117|       |            // SVG logo and WEBP sample used by images.md
 5118|     24|            "assets/samples/logo.svg" => Some(include_bytes!("../assets/samples/logo.svg")),
                                                       ^2
 5119|     22|            "assets/samples/webp_sample.webp" => {
 5120|      1|                Some(include_bytes!("../assets/samples/webp_sample.webp"))
 5121|       |            }
 5122|     21|            _ => None,
 5123|       |        }
 5124|     36|    }
 5125|       |
 5126|       |    /// Find syntax definition for a given language name
 5127|       |    /// Maps common language names to their syntax definitions
 5128|     29|    fn find_syntax_for_language(&self, lang: &str) -> Option<&syntect::parsing::SyntaxReference> {
 5129|       |        // Create a mapping of common language names to their syntect equivalents
 5130|     29|        let lang_lower = lang.to_lowercase();
 5131|       |
 5132|       |        // Try direct name match first
 5133|     29|        if let Some(syntax) = self.syntax_set.find_syntax_by_name(&lang_lower) {
                                  ^0
  ------------------
  |  Branch (5133:16): [True: 0, False: 29]
  ------------------
 5134|      0|            return Some(syntax);
 5135|     29|        }
 5136|       |
 5137|       |        // Try extension-based matching
 5138|     29|        if let Some(syntax) = self.syntax_set.find_syntax_by_extension(&lang_lower) {
                                  ^9
  ------------------
  |  Branch (5138:16): [True: 9, False: 20]
  ------------------
 5139|      9|            return Some(syntax);
 5140|     20|        }
 5141|       |
 5142|       |        // Handle common language mappings
 5143|     20|        let mapped_lang = match lang_lower.as_str() {
 5144|     20|            "rust" => "rs",
                                    ^7
 5145|     13|            "python" => "py",
                                      ^1
 5146|     12|            "javascript" => "js",
                                          ^1
 5147|     11|            "typescript" => "ts",
                                          ^1
 5148|     10|            "c++" | "cpp" => "cpp",
                                           ^0
 5149|     10|            "c#" | "csharp" => "cs",
                                 ^9          ^2
 5150|      8|            "shell" | "bash" => "sh",
                                    ^6        ^2
 5151|      6|            "powershell" => "ps1",
                                          ^2
 5152|      4|            "yaml" => "yml",
                                    ^0
 5153|      4|            "markdown" => "md",
                                        ^0
 5154|      4|            "html" => "html",
                                    ^0
 5155|      4|            "css" => "css",
                                   ^0
 5156|      4|            "java" => "java",
                                    ^0
 5157|      4|            "go" => "go",
                                  ^0
 5158|      4|            "php" => "php",
                                   ^0
 5159|      4|            "ruby" => "rb",
                                    ^0
 5160|      4|            "xml" => "xml",
                                   ^0
 5161|      4|            "json" => "json",
                                    ^0
 5162|      4|            "sql" => "sql",
                                   ^0
 5163|      4|            "toml" => "toml",
                                    ^1
 5164|      3|            _ => &lang_lower,
 5165|       |        };
 5166|       |
 5167|       |        // Try mapped extension
 5168|     20|        self.syntax_set
 5169|     20|            .find_syntax_by_extension(mapped_lang)
 5170|     20|            .or_else(|| self.syntax_set.find_syntax_by_name(mapped_lang))
                                      ^7              ^7                  ^7
 5171|     29|    }
 5172|       |
 5173|       |    /// Zoom in (increase font sizes)
 5174|      6|    pub fn zoom_in(&mut self) {
 5175|      6|        self.font_sizes.body = (self.font_sizes.body * 1.1).min(32.0);
 5176|      6|        self.font_sizes.h1 = (self.font_sizes.h1 * 1.1).min(48.0);
 5177|      6|        self.font_sizes.h2 = (self.font_sizes.h2 * 1.1).min(42.0);
 5178|      6|        self.font_sizes.h3 = (self.font_sizes.h3 * 1.1).min(36.0);
 5179|      6|        self.font_sizes.h4 = (self.font_sizes.h4 * 1.1).min(32.0);
 5180|      6|        self.font_sizes.h5 = (self.font_sizes.h5 * 1.1).min(28.0);
 5181|      6|        self.font_sizes.h6 = (self.font_sizes.h6 * 1.1).min(24.0);
 5182|      6|        self.font_sizes.code = (self.font_sizes.code * 1.1).min(20.0);
 5183|      6|        self.clear_table_layout_cache();
 5184|      6|    }
 5185|       |
 5186|       |    /// Zoom out (decrease font sizes)
 5187|      5|    pub fn zoom_out(&mut self) {
 5188|      5|        self.font_sizes.body = (self.font_sizes.body * 0.9).max(8.0);
 5189|      5|        self.font_sizes.h1 = (self.font_sizes.h1 * 0.9).max(16.0);
 5190|      5|        self.font_sizes.h2 = (self.font_sizes.h2 * 0.9).max(14.0);
 5191|      5|        self.font_sizes.h3 = (self.font_sizes.h3 * 0.9).max(12.0);
 5192|      5|        self.font_sizes.h4 = (self.font_sizes.h4 * 0.9).max(11.0);
 5193|      5|        self.font_sizes.h5 = (self.font_sizes.h5 * 0.9).max(10.0);
 5194|      5|        self.font_sizes.h6 = (self.font_sizes.h6 * 0.9).max(9.0);
 5195|      5|        self.font_sizes.code = (self.font_sizes.code * 0.9).max(8.0);
 5196|      5|        self.clear_table_layout_cache();
 5197|      5|    }
 5198|       |
 5199|       |    /// Reset zoom to default
 5200|      4|    pub fn reset_zoom(&mut self) {
 5201|      4|        self.font_sizes = FontSizes::default();
 5202|      4|        self.clear_table_layout_cache();
 5203|      4|    }
 5204|       |
 5205|       |    /// Set zoom scale relative to default font sizes.
 5206|      4|    pub fn set_zoom_scale(&mut self, scale: f32) {
 5207|      4|        let scale = scale.clamp(0.5, 4.0);
 5208|      4|        let default = FontSizes::default();
 5209|      4|        self.font_sizes.body = (default.body * scale).clamp(8.0, 32.0);
 5210|      4|        self.font_sizes.h1 = (default.h1 * scale).clamp(16.0, 48.0);
 5211|      4|        self.font_sizes.h2 = (default.h2 * scale).clamp(14.0, 42.0);
 5212|      4|        self.font_sizes.h3 = (default.h3 * scale).clamp(12.0, 36.0);
 5213|      4|        self.font_sizes.h4 = (default.h4 * scale).clamp(11.0, 32.0);
 5214|      4|        self.font_sizes.h5 = (default.h5 * scale).clamp(10.0, 28.0);
 5215|      4|        self.font_sizes.h6 = (default.h6 * scale).clamp(9.0, 24.0);
 5216|      4|        self.font_sizes.code = (default.code * scale).clamp(8.0, 20.0);
 5217|      4|        self.clear_table_layout_cache();
 5218|      4|    }
 5219|       |}
 5220|       |
 5221|       |#[cfg(test)]
 5222|       |mod tests {
 5223|       |    use super::*;
 5224|       |    use crate::SAMPLE_FILES;
 5225|       |    use image::codecs::png::PngEncoder;
 5226|       |    use image::ColorType;
 5227|       |    use image::ImageEncoder;
 5228|       |    use std::env;
 5229|       |    use std::fs;
 5230|       |    use std::str::FromStr;
 5231|       |    use std::sync::Mutex;
 5232|       |    use std::time::Duration;
 5233|       |    use syntect::highlighting::{Color, FontStyle, ScopeSelectors, StyleModifier, ThemeItem};
 5234|       |    use tempfile::tempdir;
 5235|       |
 5236|       |    static MERMAID_ENV_LOCK: Mutex<()> = Mutex::new(());
 5237|       |
 5238|       |    struct EnvVarGuard {
 5239|       |        key: &'static str,
 5240|       |        previous: Option<String>,
 5241|       |        _lock: std::sync::MutexGuard<'static, ()>,
 5242|       |    }
 5243|       |
 5244|       |    impl EnvVarGuard {
 5245|      3|        fn set(key: &'static str, value: &str) -> Self {
 5246|      3|            let lock = MERMAID_ENV_LOCK.lock().expect("lock mermaid env");
 5247|      3|            let previous = env::var(key).ok();
 5248|      3|            env::set_var(key, value);
 5249|      3|            Self {
 5250|      3|                key,
 5251|      3|                previous,
 5252|      3|                _lock: lock,
 5253|      3|            }
 5254|      3|        }
 5255|       |    }
 5256|       |
 5257|       |    impl Drop for EnvVarGuard {
 5258|      3|        fn drop(&mut self) {
 5259|      3|            if let Some(prev) = &self.previous {
                                      ^1
  ------------------
  |  Branch (5259:20): [True: 1, False: 2]
  ------------------
 5260|      1|                env::set_var(self.key, prev);
 5261|      2|            } else {
 5262|      2|                env::remove_var(self.key);
 5263|      2|            }
 5264|      3|        }
 5265|       |    }
 5266|       |
 5267|       |    struct ForcedRenderActions {
 5268|       |        actions: Vec<&'static str>,
 5269|       |    }
 5270|       |
 5271|       |    impl ForcedRenderActions {
 5272|      4|        fn new(actions: &[&'static str]) -> Self {
 5273|      4|            FORCED_RENDER_ACTIONS.with(|set| {
 5274|      4|                let mut set = set.borrow_mut();
 5275|     19|                for action in actions {
                                  ^15
 5276|     15|                    set.insert(*action);
 5277|     15|                }
 5278|      4|            });
 5279|      4|            Self {
 5280|      4|                actions: actions.to_vec(),
 5281|      4|            }
 5282|      4|        }
 5283|       |    }
 5284|       |
 5285|       |    impl Drop for ForcedRenderActions {
 5286|      4|        fn drop(&mut self) {
 5287|      4|            FORCED_RENDER_ACTIONS.with(|set| {
 5288|      4|                let mut set = set.borrow_mut();
 5289|     19|                for action in &self.actions {
                                  ^15
 5290|     15|                    set.remove(action);
 5291|     15|                }
 5292|      4|            });
 5293|      4|        }
 5294|       |    }
 5295|       |
 5296|       |    struct ForcedTablePolicies;
 5297|       |
 5298|       |    impl ForcedTablePolicies {
 5299|      3|        fn new(policies: Vec<ColumnPolicy>) -> Self {
 5300|      3|            FORCED_TABLE_POLICIES.with(|slot| {
 5301|      3|                *slot.borrow_mut() = Some(policies);
 5302|      3|            });
 5303|      3|            Self
 5304|      3|        }
 5305|       |    }
 5306|       |
 5307|       |    impl Drop for ForcedTablePolicies {
 5308|      3|        fn drop(&mut self) {
 5309|      3|            FORCED_TABLE_POLICIES.with(|slot| {
 5310|      3|                slot.borrow_mut().take();
 5311|      3|            });
 5312|      3|        }
 5313|       |    }
 5314|       |
 5315|     50|    fn with_test_ui<F>(f: F)
 5316|     50|    where
 5317|     50|        F: FnOnce(&egui::Context, &mut egui::Ui),
 5318|       |    {
 5319|     50|        let ctx = egui::Context::default();
 5320|     50|        let input = egui::RawInput {
 5321|     50|            screen_rect: Some(egui::Rect::from_min_size(
 5322|     50|                egui::pos2(0.0, 0.0),
 5323|     50|                egui::vec2(1024.0, 768.0),
 5324|     50|            )),
 5325|     50|            ..Default::default()
 5326|     50|        };
 5327|     50|        ctx.begin_frame(input);
 5328|     50|        egui::CentralPanel::default().show(&ctx, |ui| {
 5329|     50|            f(&ctx, ui);
 5330|     50|        });
 5331|     50|        let _ = ctx.end_frame();
 5332|     50|    }
 5333|       |
 5334|      5|    fn wait_for_image(
 5335|      5|        renderer: &MarkdownRenderer,
 5336|      5|        ctx: &egui::Context,
 5337|      5|        ui: &egui::Ui,
 5338|      5|        path: &str,
 5339|      5|    ) -> Option<(egui::TextureHandle, u32, u32)> {
 5340|     16|        for _ in 0..10 {
 5341|     16|            if let Some(loaded) = renderer.get_or_load_image_texture(ui, path) {
                                      ^5
  ------------------
  |  Branch (5341:20): [True: 5, False: 11]
  ------------------
 5342|      5|                return Some(loaded);
 5343|     11|            }
 5344|     11|            renderer.poll_image_results(ctx);
 5345|     11|            std::thread::sleep(Duration::from_millis(10));
 5346|       |        }
 5347|      0|        renderer.get_or_load_image_texture(ui, path)
 5348|      5|    }
 5349|       |
 5350|     19|    fn run_frame_with_input<F>(ctx: &egui::Context, input: egui::RawInput, f: F)
 5351|     19|    where
 5352|     19|        F: FnOnce(&egui::Context, &mut egui::Ui),
 5353|       |    {
 5354|     19|        ctx.begin_frame(input);
 5355|     19|        egui::CentralPanel::default().show(ctx, |ui| {
 5356|     19|            f(ctx, ui);
 5357|     19|        });
 5358|     19|        let _ = ctx.end_frame();
 5359|     19|    }
 5360|       |
 5361|      7|    fn input_with_click(pos: egui::Pos2, button: egui::PointerButton) -> egui::RawInput {
 5362|      7|        let mut input = egui::RawInput {
 5363|      7|            screen_rect: Some(egui::Rect::from_min_size(
 5364|      7|                egui::pos2(0.0, 0.0),
 5365|      7|                egui::vec2(320.0, 240.0),
 5366|      7|            )),
 5367|      7|            ..Default::default()
 5368|      7|        };
 5369|      7|        input.events.push(egui::Event::PointerMoved(pos));
 5370|      7|        input.events.push(egui::Event::PointerButton {
 5371|      7|            pos,
 5372|      7|            button,
 5373|      7|            pressed: true,
 5374|      7|            modifiers: egui::Modifiers::default(),
 5375|      7|        });
 5376|      7|        input.events.push(egui::Event::PointerButton {
 5377|      7|            pos,
 5378|      7|            button,
 5379|      7|            pressed: false,
 5380|      7|            modifiers: egui::Modifiers::default(),
 5381|      7|        });
 5382|      7|        input
 5383|      7|    }
 5384|       |
 5385|      2|    fn tiny_png_bytes() -> Vec<u8> {
 5386|      2|        let width = 2u32;
 5387|      2|        let height = 2u32;
 5388|      2|        let pixels = vec![255u8; (width * height * 4) as usize];
 5389|      2|        let mut out = Vec::new();
 5390|      2|        let encoder = PngEncoder::new(&mut out);
 5391|      2|        encoder
 5392|      2|            .write_image(&pixels, width, height, ColorType::Rgba8)
 5393|      2|            .expect("encode png");
 5394|      2|        out
 5395|      2|    }
 5396|       |
 5397|       |    #[test]
 5398|      1|    fn test_image_cache_get_missing_and_insert_empty_order() {
 5399|      1|        let mut cache = ImageCache::new(1);
 5400|      1|        assert!(cache.get("missing").is_none());
 5401|       |
 5402|      1|        let mut entry_slot = None;
 5403|      1|        with_test_ui(|ctx, _ui| {
 5404|      1|            let tex = ctx.load_texture(
 5405|       |                "cache_test",
 5406|      1|                egui::ColorImage::new([1, 1], Color32::WHITE),
 5407|       |                egui::TextureOptions::LINEAR,
 5408|       |            );
 5409|      1|            entry_slot = Some(ImageCacheEntry {
 5410|      1|                texture: tex,
 5411|      1|                size: [1, 1],
 5412|      1|                modified: None,
 5413|      1|            });
 5414|      1|        });
 5415|      1|        let entry = entry_slot.expect("texture");
 5416|      1|        cache.entries.insert("a".to_string(), ImageCacheEntry {
 5417|      1|            texture: entry.texture.clone(),
 5418|      1|            size: entry.size,
 5419|      1|            modified: entry.modified,
 5420|      1|        });
 5421|      1|        cache.order.clear();
 5422|      1|        cache.insert(
 5423|      1|            "b".to_string(),
 5424|      1|            ImageCacheEntry {
 5425|      1|                texture: entry.texture.clone(),
 5426|      1|                size: entry.size,
 5427|      1|                modified: entry.modified,
 5428|      1|            },
 5429|       |        );
 5430|      1|        assert!(cache.contains_key("b"));
 5431|      1|    }
 5432|       |
 5433|       |    #[test]
 5434|      1|    fn test_image_cache_insert_existing_key_updates_entry() {
 5435|      1|        let mut cache = ImageCache::new(2);
 5436|      1|        let mut entry_slot = None;
 5437|      1|        with_test_ui(|ctx, _ui| {
 5438|      1|            let tex = ctx.load_texture(
 5439|       |                "cache_update",
 5440|      1|                egui::ColorImage::new([1, 1], Color32::WHITE),
 5441|       |                egui::TextureOptions::LINEAR,
 5442|       |            );
 5443|      1|            entry_slot = Some(ImageCacheEntry {
 5444|      1|                texture: tex,
 5445|      1|                size: [1, 1],
 5446|      1|                modified: None,
 5447|      1|            });
 5448|      1|        });
 5449|      1|        let entry = entry_slot.expect("texture");
 5450|      1|        cache.insert(
 5451|      1|            "a".to_string(),
 5452|      1|            ImageCacheEntry {
 5453|      1|                texture: entry.texture.clone(),
 5454|      1|                size: [1, 1],
 5455|      1|                modified: entry.modified,
 5456|      1|            },
 5457|       |        );
 5458|      1|        cache.insert(
 5459|      1|            "a".to_string(),
 5460|      1|            ImageCacheEntry {
 5461|      1|                texture: entry.texture.clone(),
 5462|      1|                size: [2, 2],
 5463|      1|                modified: entry.modified,
 5464|      1|            },
 5465|       |        );
 5466|      1|        let stored = cache.get("a").expect("stored");
 5467|      1|        assert_eq!(stored.size, [2, 2]);
 5468|      1|    }
 5469|       |
 5470|       |    #[test]
 5471|      1|    fn test_image_cache_evicts_oldest_entry() {
 5472|      1|        let mut cache = ImageCache::new(1);
 5473|      1|        let mut entry_slot = None;
 5474|      1|        with_test_ui(|ctx, _ui| {
 5475|      1|            let tex = ctx.load_texture(
 5476|       |                "cache_evict",
 5477|      1|                egui::ColorImage::new([1, 1], Color32::WHITE),
 5478|       |                egui::TextureOptions::LINEAR,
 5479|       |            );
 5480|      1|            entry_slot = Some(ImageCacheEntry {
 5481|      1|                texture: tex,
 5482|      1|                size: [1, 1],
 5483|      1|                modified: None,
 5484|      1|            });
 5485|      1|        });
 5486|      1|        let entry = entry_slot.expect("texture");
 5487|      1|        cache.insert(
 5488|      1|            "a".to_string(),
 5489|      1|            ImageCacheEntry {
 5490|      1|                texture: entry.texture.clone(),
 5491|      1|                size: entry.size,
 5492|      1|                modified: entry.modified,
 5493|      1|            },
 5494|       |        );
 5495|      1|        cache.insert(
 5496|      1|            "b".to_string(),
 5497|      1|            ImageCacheEntry {
 5498|      1|                texture: entry.texture.clone(),
 5499|      1|                size: entry.size,
 5500|      1|                modified: entry.modified,
 5501|      1|            },
 5502|       |        );
 5503|      1|        assert!(cache.contains_key("b"));
 5504|      1|        assert!(!cache.contains_key("a"));
 5505|      1|    }
 5506|       |
 5507|       |    #[test]
 5508|      1|    fn test_list_marker_info_rejects_empty_and_bad_numeric() {
 5509|      1|        assert!(MarkdownRenderer::list_marker_info("").is_none());
 5510|      1|        assert!(MarkdownRenderer::list_marker_info("1 abc").is_none());
 5511|      1|        assert!(MarkdownRenderer::list_marker_info("   ").is_none());
 5512|      1|    }
 5513|       |
 5514|       |    #[test]
 5515|      1|    fn test_list_marker_info_rejects_tabs_and_missing_whitespace() {
 5516|      1|        assert!(MarkdownRenderer::list_marker_info("\t- item").is_none());
 5517|      1|        assert!(MarkdownRenderer::list_marker_info("1.item").is_none());
 5518|      1|        assert!(MarkdownRenderer::list_marker_info("1)item").is_none());
 5519|      1|        assert!(MarkdownRenderer::list_marker_info("-item").is_none());
 5520|      1|    }
 5521|       |
 5522|       |    #[test]
 5523|      1|    fn test_parse_image_with_title_sets_title() {
 5524|      1|        let renderer = MarkdownRenderer::new();
 5525|      1|        let parsed = renderer
 5526|      1|            .parse("![alt](path/to/img.png \"Title\")")
 5527|      1|            .expect("parse");
 5528|      1|        let MarkdownElement::Paragraph(spans) = &parsed[0] else {
  ------------------
  |  Branch (5528:13): [True: 1, False: 0]
  ------------------
 5529|      0|            panic!("expected paragraph");
 5530|       |        };
 5531|      1|        let InlineSpan::Image { title, .. } = &spans[0] else {
  ------------------
  |  Branch (5531:13): [True: 1, False: 0]
  ------------------
 5532|      0|            panic!("expected image span");
 5533|       |        };
 5534|      1|        assert_eq!(title.as_deref(), Some("Title"));
 5535|      1|    }
 5536|       |
 5537|       |    #[test]
 5538|      1|    fn test_is_external_url_variants() {
 5539|      1|        assert!(MarkdownRenderer::is_external_url("http://example.com"));
 5540|      1|        assert!(MarkdownRenderer::is_external_url("https://example.com"));
 5541|      1|        assert!(MarkdownRenderer::is_external_url("mailto:test@example.com"));
 5542|      1|        assert!(MarkdownRenderer::is_external_url("www.example.com"));
 5543|      1|        assert!(!MarkdownRenderer::is_external_url("local/path.png"));
 5544|      1|    }
 5545|       |
 5546|       |    #[test]
 5547|      1|    fn test_resolve_image_path_keeps_remote() {
 5548|      1|        let renderer = MarkdownRenderer::new();
 5549|      1|        let src = "https://example.com/image.png";
 5550|      1|        let http_src = "http://example.com/image.png";
 5551|      1|        assert_eq!(renderer.resolve_image_path(src), src);
 5552|      1|        assert_eq!(renderer.resolve_image_path(http_src), http_src);
 5553|      1|        let data_src = "data:image/png;base64,AAAA";
 5554|      1|        assert_eq!(renderer.resolve_image_path(data_src), data_src);
 5555|      1|    }
 5556|       |
 5557|       |    #[test]
 5558|      1|    fn test_compute_table_id_includes_base_dir() {
 5559|      1|        let renderer = MarkdownRenderer::new();
 5560|      1|        let headers = vec![vec![InlineSpan::Text("A".to_string())]];
 5561|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
 5562|      1|        let alignments = vec![Alignment::Left];
 5563|      1|        let base_id = renderer.compute_table_id(&headers, &rows, &alignments, 0);
 5564|       |
 5565|      1|        *renderer.base_dir.borrow_mut() = Some(PathBuf::from("C:\\tmp"));
 5566|      1|        let with_base = renderer.compute_table_id(&headers, &rows, &alignments, 0);
 5567|      1|        assert_ne!(base_id, with_base);
 5568|      1|    }
 5569|       |
 5570|       |    #[test]
 5571|      1|    fn test_render_table_early_return_on_empty_headers() {
 5572|      1|        let renderer = MarkdownRenderer::new();
 5573|      1|        with_test_ui(|_, ui| {
 5574|      1|            renderer.render_table(ui, &[], &[], &[]);
 5575|      1|        });
 5576|      1|    }
 5577|       |
 5578|       |    #[test]
 5579|      1|    fn test_extend_table_rect_handles_nan() {
 5580|      1|        let mut target = Some(egui::Rect::from_min_size(
 5581|      1|            egui::pos2(0.0, 0.0),
 5582|      1|            egui::vec2(10.0, 10.0),
 5583|      1|        ));
 5584|      1|        let nan_rect = egui::Rect::from_min_size(
 5585|      1|            egui::pos2(f32::NAN, 0.0),
 5586|      1|            egui::vec2(1.0, 1.0),
 5587|       |        );
 5588|      1|        MarkdownRenderer::extend_table_rect(&mut target, nan_rect);
 5589|      1|        let stored = target.expect("target");
 5590|      1|        assert!(!stored.min.x.is_nan());
 5591|       |
 5592|      1|        let mut target_none = None;
 5593|      1|        MarkdownRenderer::extend_table_rect(
 5594|      1|            &mut target_none,
 5595|      1|            egui::Rect::from_min_size(egui::pos2(5.0, 6.0), egui::vec2(2.0, 2.0)),
 5596|       |        );
 5597|      1|        assert!(target_none.is_some());
 5598|      1|    }
 5599|       |
 5600|       |    #[test]
 5601|      1|    fn test_extend_table_rect_rejects_nan_components() {
 5602|      1|        let base = egui::Rect::from_min_size(egui::pos2(1.0, 2.0), egui::vec2(3.0, 4.0));
 5603|      1|        let mut target = Some(base);
 5604|      1|        let nan_min_y = egui::Rect::from_min_size(
 5605|      1|            egui::pos2(0.0, f32::NAN),
 5606|      1|            egui::vec2(1.0, 1.0),
 5607|       |        );
 5608|      1|        MarkdownRenderer::extend_table_rect(&mut target, nan_min_y);
 5609|      1|        assert_eq!(target, Some(base));
 5610|       |
 5611|      1|        let mut target = Some(base);
 5612|      1|        let nan_max_x = egui::Rect::from_min_size(
 5613|      1|            egui::pos2(0.0, 0.0),
 5614|      1|            egui::vec2(f32::NAN, 1.0),
 5615|       |        );
 5616|      1|        MarkdownRenderer::extend_table_rect(&mut target, nan_max_x);
 5617|      1|        assert_eq!(target, Some(base));
 5618|       |
 5619|      1|        let mut target = Some(base);
 5620|      1|        let nan_max_y = egui::Rect::from_min_size(
 5621|      1|            egui::pos2(0.0, 0.0),
 5622|      1|            egui::vec2(1.0, f32::NAN),
 5623|       |        );
 5624|      1|        MarkdownRenderer::extend_table_rect(&mut target, nan_max_y);
 5625|      1|        assert_eq!(target, Some(base));
 5626|      1|    }
 5627|       |
 5628|       |    #[test]
 5629|      1|    fn test_persist_resizable_widths_returns_on_empty() {
 5630|      1|        let renderer = MarkdownRenderer::new();
 5631|      1|        renderer.persist_resizable_widths(1, &[], &[]);
 5632|      1|    }
 5633|       |
 5634|       |    #[test]
 5635|      1|    fn test_link_at_pointer_outside_rect_returns_none() {
 5636|      1|        let renderer = MarkdownRenderer::new();
 5637|      1|        let spans = vec![InlineSpan::Link {
 5638|      1|            text: "Link".to_string(),
 5639|      1|            url: "https://example.com".to_string(),
 5640|      1|        }];
 5641|      1|        let ctx = egui::Context::default();
 5642|      1|        let mut input = egui::RawInput {
 5643|      1|            screen_rect: Some(egui::Rect::from_min_size(
 5644|      1|                egui::pos2(0.0, 0.0),
 5645|      1|                egui::vec2(320.0, 240.0),
 5646|      1|            )),
 5647|      1|            ..Default::default()
 5648|      1|        };
 5649|      1|        input.events.push(egui::Event::PointerMoved(egui::pos2(200.0, 200.0)));
 5650|      1|        ctx.begin_frame(input);
 5651|      1|        let mut found = false;
 5652|      1|        egui::CentralPanel::default().show(&ctx, |ui| {
 5653|      1|            let response = ui.label("anchor");
 5654|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, false, Align::LEFT);
 5655|      1|            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
 5656|      1|            found = renderer
 5657|      1|                .link_at_pointer(&response, &galley, &build, egui::pos2(0.0, 0.0))
 5658|      1|                .is_some();
 5659|      1|        });
 5660|      1|        let _ = ctx.end_frame();
 5661|      1|        assert!(!found);
 5662|      1|    }
 5663|       |
 5664|       |    #[test]
 5665|      1|    fn test_spawn_image_loader_missing_file_reports_failed() {
 5666|      1|        let (job_tx, job_rx) = bounded(1);
 5667|      1|        let (result_tx, result_rx) = bounded(1);
 5668|      1|        MarkdownRenderer::spawn_image_loader(job_rx, result_tx);
 5669|       |
 5670|      1|        let dir = tempdir().expect("temp dir");
 5671|      1|        let path = dir.path().join("missing.png");
 5672|      1|        job_tx
 5673|      1|            .send(ImageLoadRequest {
 5674|      1|                key: "missing".to_string(),
 5675|      1|                source: ImageLoadSource::File(path),
 5676|      1|            })
 5677|      1|            .expect("send");
 5678|      1|        let result = result_rx
 5679|      1|            .recv_timeout(Duration::from_secs(1))
 5680|      1|            .expect("result");
 5681|      1|        match result {
 5682|      1|            ImageLoadResult::Failed { key } => assert_eq!(key, "missing"),
 5683|      0|            _ => panic!("expected failed result"),
 5684|       |        }
 5685|      1|    }
 5686|       |
 5687|       |    #[test]
 5688|      1|    fn test_env_var_guard_removes_unset_value() {
 5689|      1|        let key = "MDMDVIEW_TEST_ENV_GUARD";
 5690|      1|        env::remove_var(key);
 5691|       |        {
 5692|      1|            let _guard = EnvVarGuard::set(key, "value");
 5693|      1|            assert_eq!(env::var(key).ok().as_deref(), Some("value"));
 5694|       |        }
 5695|      1|        assert!(env::var(key).is_err());
 5696|      1|    }
 5697|       |
 5698|       |    #[test]
 5699|      1|    fn test_parse_forced_error_returns_err_once() {
 5700|      1|        let renderer = MarkdownRenderer::new();
 5701|      1|        force_parse_error_once();
 5702|      1|        assert!(renderer.parse("hello").is_err());
 5703|      1|        assert!(renderer.parse("hello").is_ok());
 5704|      1|    }
 5705|       |
 5706|       |    #[test]
 5707|      1|    fn test_fence_helpers_cover_branches() {
 5708|      1|        assert_eq!(MarkdownRenderer::fence_start("```"), Some(('`', 3)));
 5709|      1|        assert_eq!(MarkdownRenderer::fence_start("``"), None);
 5710|      1|        assert_eq!(MarkdownRenderer::fence_start("~~~"), Some(('~', 3)));
 5711|      1|        assert!(MarkdownRenderer::is_fence_end("```", '`', 3));
 5712|      1|        assert!(!MarkdownRenderer::is_fence_end("``", '`', 3));
 5713|      1|        assert!(MarkdownRenderer::is_fence_end("   ```", '`', 3));
 5714|      1|    }
 5715|       |
 5716|       |    #[test]
 5717|      1|    fn test_restore_pipe_sentinel_round_trip() {
 5718|      1|        let input = format!("a{}b", PIPE_SENTINEL);
 5719|      1|        assert_eq!(MarkdownRenderer::restore_pipe_sentinel(&input), "a|b");
 5720|      1|        assert_eq!(MarkdownRenderer::restore_pipe_sentinel("a|b"), "a|b");
 5721|      1|    }
 5722|       |
 5723|       |    #[test]
 5724|      1|    fn test_list_marker_info_numeric_punctuation() {
 5725|      1|        let (content, _indent, _content_indent) =
 5726|      1|            MarkdownRenderer::list_marker_info("1. item").expect("dot marker");
 5727|      1|        assert_eq!(content.trim_start(), "item");
 5728|      1|        let (content, _indent, _content_indent) =
 5729|      1|            MarkdownRenderer::list_marker_info("2) item").expect("paren marker");
 5730|      1|        assert_eq!(content.trim_start(), "item");
 5731|      1|    }
 5732|       |
 5733|       |    #[test]
 5734|      1|    fn test_table_line_info_blockquote_levels() {
 5735|      1|        let (level, rest) = MarkdownRenderer::table_line_info("  >\t| a |");
 5736|      1|        assert_eq!(level, 1);
 5737|      1|        assert!(rest.trim_start().starts_with('|'));
 5738|       |
 5739|      1|        let (level, rest) = MarkdownRenderer::table_line_info("> > | b |");
 5740|      1|        assert_eq!(level, 2);
 5741|      1|        assert!(rest.trim_start().starts_with('|'));
 5742|      1|    }
 5743|       |
 5744|       |    #[test]
 5745|      1|    fn test_strip_indent_columns_indent_zero_returns_line() {
 5746|      1|        assert_eq!(
 5747|      1|            MarkdownRenderer::strip_indent_columns("content", 0),
 5748|       |            Some("content")
 5749|       |        );
 5750|      1|    }
 5751|       |
 5752|       |    #[test]
 5753|      1|    fn test_parent_list_indent_for_line_zero_index_returns_none() {
 5754|      1|        let lines = vec!["- item"];
 5755|      1|        let (level, rest) = MarkdownRenderer::table_line_info(lines[0]);
 5756|      1|        assert!(MarkdownRenderer::parent_list_indent_for_line(&lines, 0, level, rest).is_none());
 5757|      1|    }
 5758|       |
 5759|       |    #[test]
 5760|      1|    fn test_should_retry_image_backoff_respected() {
 5761|      1|        let renderer = MarkdownRenderer::new();
 5762|      1|        renderer.image_failures.borrow_mut().insert(
 5763|      1|            "recent".to_string(),
 5764|      1|            ImageFailure {
 5765|      1|                last_attempt: std::time::Instant::now(),
 5766|      1|            },
 5767|      1|        );
 5768|      1|        assert!(!renderer.should_retry_image("recent"));
 5769|       |
 5770|      1|        renderer.image_failures.borrow_mut().insert(
 5771|      1|            "old".to_string(),
 5772|      1|            ImageFailure {
 5773|      1|                last_attempt: std::time::Instant::now() - IMAGE_FAILURE_BACKOFF - Duration::from_millis(1),
 5774|      1|            },
 5775|      1|        );
 5776|      1|        assert!(renderer.should_retry_image("old"));
 5777|      1|    }
 5778|       |
 5779|       |    #[test]
 5780|      1|    fn test_extend_table_rect_accepts_valid_rect() {
 5781|      1|        let mut target = None;
 5782|      1|        let rect = egui::Rect::from_min_size(egui::pos2(1.0, 2.0), egui::vec2(3.0, 4.0));
 5783|      1|        MarkdownRenderer::extend_table_rect(&mut target, rect);
 5784|      1|        assert_eq!(target, Some(rect));
 5785|       |
 5786|      1|        let rect2 = egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(10.0, 10.0));
 5787|      1|        MarkdownRenderer::extend_table_rect(&mut target, rect2);
 5788|      1|        let merged = target.expect("merged rect");
 5789|      1|        assert!(merged.contains(rect.min));
 5790|      1|        assert!(merged.contains(rect2.max));
 5791|      1|    }
 5792|       |
 5793|       |    #[test]
 5794|      1|    fn test_render_code_block_with_none_language() {
 5795|      1|        let renderer = MarkdownRenderer::new();
 5796|      1|        with_test_ui(|_, ui| {
 5797|      1|            renderer.render_code_block(ui, None, "fn main() {}");
 5798|      1|        });
 5799|      1|    }
 5800|       |
 5801|       |    #[test]
 5802|      1|    fn test_render_action_triggered_forced_paths() {
 5803|      1|        let _actions = ForcedRenderActions::new(&["forced_action"]);
 5804|      1|        assert!(render_action_triggered(false, "forced_action"));
 5805|      1|        assert!(!render_action_triggered(false, "other_action"));
 5806|      1|        assert!(render_action_triggered(true, "other_action"));
 5807|      1|    }
 5808|       |
 5809|       |    #[test]
 5810|      1|    fn test_markdown_renderer_creation() {
 5811|      1|        let renderer = MarkdownRenderer::new();
 5812|      1|        assert_eq!(renderer.font_sizes.body, 14.0);
 5813|      1|        assert_eq!(renderer.font_sizes.h1, 28.0);
 5814|      1|    }
 5815|       |
 5816|       |    #[test]
 5817|      1|    fn test_markdown_renderer_default_uses_defaults() {
 5818|      1|        let renderer = MarkdownRenderer::default();
 5819|      1|        let defaults = FontSizes::default();
 5820|      1|        assert_eq!(renderer.font_sizes.body, defaults.body);
 5821|      1|        assert_eq!(renderer.font_sizes.code, defaults.code);
 5822|      1|    }
 5823|       |
 5824|       |    #[test]
 5825|      1|    fn test_superscript_expansion_basic() {
 5826|      1|        let s = "5^th^ and m^2^";
 5827|      1|        let out = MarkdownRenderer::expand_superscripts(s);
 5828|      1|        assert!(out.contains("5"));
 5829|      1|        assert!(out.contains("m"));
 5830|      1|    }
 5831|       |
 5832|       |    #[test]
 5833|      1|    fn test_superscript_expansion_allows_plus_symbol() {
 5834|      1|        let out = MarkdownRenderer::expand_superscripts("x^+^");
 5835|      1|        assert!(out.contains('\u{207a}'));
 5836|      1|    }
 5837|       |
 5838|       |    #[test]
 5839|      1|    fn test_superscript_expansion_single_caret() {
 5840|       |        // Test that single carets (not paired) are left as-is
 5841|      1|        let s = "2^32 = 4,294,967,296";
 5842|      1|        let out = MarkdownRenderer::expand_superscripts(s);
 5843|      1|        assert_eq!(out, "2^32 = 4,294,967,296");
 5844|       |
 5845|       |        // Test the problematic line from the bug report
 5846|      1|        let problematic = "A 32-bit address bus would provide 2^32 = 4,294,967,296 bytes (4 GB) of addressable memory.";
 5847|      1|        let fixed = MarkdownRenderer::expand_superscripts(problematic);
 5848|      1|        assert_eq!(fixed, problematic);
 5849|       |
 5850|       |        // Test mixed cases
 5851|      1|        let mixed = "Use 2^32 for math and 5^th^ for ordinal";
 5852|      1|        let result = MarkdownRenderer::expand_superscripts(mixed);
 5853|      1|        assert!(result.contains("2^32"));
 5854|      1|        assert!(result.contains("5"));
 5855|      1|    }
 5856|       |
 5857|       |    #[test]
 5858|      1|    fn test_superscript_expansion_rejects_invalid_sequences() {
 5859|      1|        let s = "2^ab$^ and ^^";
 5860|      1|        let out = MarkdownRenderer::expand_superscripts(s);
 5861|      1|        assert_eq!(out, s);
 5862|      1|        let no_close = "10^abc";
 5863|      1|        let out = MarkdownRenderer::expand_superscripts(no_close);
 5864|      1|        assert_eq!(out, no_close);
 5865|      1|    }
 5866|       |
 5867|       |    #[test]
 5868|      1|    fn test_font_sizes_default() {
 5869|      1|        let sizes = FontSizes::default();
 5870|      1|        assert_eq!(sizes.body, 14.0);
 5871|      1|        assert_eq!(sizes.h1, 28.0);
 5872|      1|        assert_eq!(sizes.code, 12.0);
 5873|      1|    }
 5874|       |
 5875|       |    #[test]
 5876|      1|    fn test_zoom_functionality() {
 5877|      1|        let mut renderer = MarkdownRenderer::new();
 5878|      1|        let original_body = renderer.font_sizes.body;
 5879|       |
 5880|      1|        renderer.zoom_in();
 5881|      1|        assert!(renderer.font_sizes.body > original_body);
 5882|       |
 5883|      1|        renderer.zoom_out();
 5884|      1|        assert!(renderer.font_sizes.body < original_body * 1.1);
 5885|       |
 5886|      1|        renderer.reset_zoom();
 5887|      1|        assert_eq!(renderer.font_sizes.body, original_body);
 5888|      1|    }
 5889|       |
 5890|       |    #[test]
 5891|      1|    fn test_set_zoom_scale() {
 5892|      1|        let mut renderer = MarkdownRenderer::new();
 5893|       |
 5894|      1|        renderer.set_zoom_scale(1.5);
 5895|      1|        assert!((renderer.font_sizes.body - 21.0).abs() < 0.1);
 5896|       |
 5897|      1|        renderer.set_zoom_scale(10.0);
 5898|      1|        assert_eq!(renderer.font_sizes.body, 32.0);
 5899|       |
 5900|      1|        renderer.set_zoom_scale(0.1);
 5901|      1|        assert_eq!(renderer.font_sizes.body, 8.0);
 5902|      1|    }
 5903|       |
 5904|       |    #[test]
 5905|      1|    fn font_size_change_does_not_repersist_stale_widths() {
 5906|      1|        let mut renderer = MarkdownRenderer::new();
 5907|      1|        let table_id = 7u64;
 5908|      1|        let specs = vec![ColumnSpec::new(
 5909|       |            0,
 5910|       |            "A",
 5911|      1|            ColumnPolicy::Resizable {
 5912|      1|                min: 20.0,
 5913|      1|                preferred: 100.0,
 5914|      1|                clip: false,
 5915|      1|            },
 5916|      1|            None,
 5917|       |        )];
 5918|      1|        let widths = vec![100.0f32];
 5919|       |
 5920|       |        // Initial persist at default font size.
 5921|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
 5922|      1|        let policy_hash = specs[0].policy_hash;
 5923|       |        {
 5924|      1|            let metrics = renderer.table_metrics.borrow();
 5925|      1|            let entry = metrics.entry(table_id).expect("entry created");
 5926|      1|            assert_eq!(entry.persisted_width(policy_hash), Some(100.0));
 5927|      1|            assert_eq!(entry.persisted_font_size, Some(renderer.font_sizes.body));
 5928|       |        }
 5929|       |
 5930|       |        // Simulate zoom: font size changes but widths captured are still the old ones.
 5931|      1|        renderer.font_sizes.body = 16.0;
 5932|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
 5933|       |        {
 5934|      1|            let metrics = renderer.table_metrics.borrow();
 5935|      1|            let entry = metrics.entry(table_id).expect("entry exists");
 5936|       |            // Cleared and NOT re-saved in the same frame.
 5937|      1|            assert_eq!(entry.persisted_width(policy_hash), None);
 5938|      1|            assert_eq!(entry.persisted_font_size, Some(16.0));
 5939|       |        }
 5940|       |
 5941|       |        // Next frame with new layout widths should persist again.
 5942|      1|        let new_widths = vec![80.0f32];
 5943|      1|        renderer.persist_resizable_widths(table_id, &specs, &new_widths);
 5944|      1|        let metrics = renderer.table_metrics.borrow();
 5945|      1|        let entry = metrics.entry(table_id).expect("entry exists");
 5946|      1|        assert_eq!(entry.persisted_width(policy_hash), Some(80.0));
 5947|      1|        assert_eq!(entry.persisted_font_size, Some(16.0));
 5948|      1|    }
 5949|       |
 5950|       |    #[test]
 5951|      1|    fn highlight_phrase_keeps_persisted_table_widths() {
 5952|      1|        let renderer = MarkdownRenderer::new();
 5953|      1|        let table_id = 11u64;
 5954|      1|        let specs = vec![ColumnSpec::new(
 5955|       |            0,
 5956|       |            "A",
 5957|      1|            ColumnPolicy::Resizable {
 5958|      1|                min: 20.0,
 5959|      1|                preferred: 100.0,
 5960|      1|                clip: false,
 5961|      1|            },
 5962|      1|            None,
 5963|       |        )];
 5964|      1|        let widths = vec![120.0f32];
 5965|      1|        let policy_hash = specs[0].policy_hash;
 5966|       |
 5967|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
 5968|      1|        renderer.set_highlight_phrase(Some("alpha"));
 5969|      1|        renderer.set_highlight_phrase(Some("beta"));
 5970|       |
 5971|      1|        let metrics = renderer.table_metrics.borrow();
 5972|      1|        let entry = metrics.entry(table_id).expect("entry exists");
 5973|      1|        assert_eq!(entry.persisted_width(policy_hash), Some(120.0));
 5974|      1|    }
 5975|       |
 5976|       |    #[test]
 5977|      1|    fn test_tight_list_inline_code_and_styles() {
 5978|      1|        let renderer = MarkdownRenderer::new();
 5979|      1|        let md = "- Use `code` and **bold** and *italic* and ~~strike~~\\n";
 5980|      1|        let parsed = renderer.parse(md).expect("parse ok");
 5981|      1|        assert_eq!(parsed.len(), 1);
 5982|      1|        match &parsed[0] {
 5983|      1|            MarkdownElement::List { ordered, items } => {
 5984|      1|                assert!(!ordered);
 5985|      1|                assert_eq!(items.len(), 1);
 5986|      1|                let spans = match items[0].blocks.as_slice() {
 5987|      1|                    [MarkdownElement::Paragraph(spans)] => spans,
 5988|      0|                    other => panic!("Expected paragraph block, got {:?}", other),
 5989|       |                };
 5990|      1|                assert!(spans
 5991|      1|                    .iter()
 5992|      1|                    .any(|s| matches!(s, InlineSpan::Code(c) if c == "code")));
  ------------------
  |  Branch (5992:65): [True: 1, False: 0]
  ------------------
 5993|      1|                assert!(spans
 5994|      1|                    .iter()
 5995|      1|                    .any(|s| matches!(s, InlineSpan::Strong(t) if t.contains("bold"))));
  ------------------
  |  Branch (5995:67): [True: 1, False: 0]
  ------------------
 5996|      1|                assert!(spans
 5997|      1|                    .iter()
 5998|      1|                    .any(|s| matches!(s, InlineSpan::Emphasis(t) if t.contains("italic"))));
  ------------------
  |  Branch (5998:69): [True: 1, False: 0]
  ------------------
 5999|      1|                assert!(spans
 6000|      1|                    .iter()
 6001|      1|                    .any(|s| matches!(s, InlineSpan::Strikethrough(t) if t.contains("strike"))));
  ------------------
  |  Branch (6001:74): [True: 1, False: 0]
  ------------------
 6002|       |            }
 6003|      0|            other => panic!("Expected List, got {:?}", other),
 6004|       |        }
 6005|      1|    }
 6006|       |
 6007|       |    #[test]
 6008|      1|    fn test_expand_shortcodes_basic() {
 6009|      1|        let rocket = MarkdownRenderer::expand_shortcodes(":rocket:");
 6010|      1|        assert_ne!(rocket, ":rocket:");
 6011|      1|        assert!(crate::emoji_catalog::image_bytes_for(&rocket).is_some());
 6012|       |
 6013|      1|        let tada = MarkdownRenderer::expand_shortcodes(":tada:");
 6014|      1|        assert_ne!(tada, ":tada:");
 6015|      1|        assert!(crate::emoji_catalog::image_bytes_for(&tada).is_some());
 6016|       |
 6017|      1|        assert_eq!(
 6018|      1|            MarkdownRenderer::expand_shortcodes("Hello :tada:!"),
 6019|      1|            format!("Hello {}!", tada)
 6020|       |        );
 6021|      1|    }
 6022|       |
 6023|       |    #[test]
 6024|      1|    fn test_expand_shortcodes_unknown_code_keeps_text() {
 6025|      1|        let input = "Unknown :notacode: stays the same.";
 6026|      1|        let out = MarkdownRenderer::expand_shortcodes(input);
 6027|      1|        assert_eq!(out, input);
 6028|      1|    }
 6029|       |
 6030|       |    #[test]
 6031|      1|    fn test_fix_unicode_chars_normalizes_basic_cases() {
 6032|      1|        let renderer = MarkdownRenderer::new();
 6033|      1|        let input = "A\u{00A0}B\u{2013}C";
 6034|      1|        let normalized = renderer.normalize_text_for_test(input);
 6035|      1|        assert_eq!(normalized, "A B-C");
 6036|       |
 6037|      1|        let arrows = renderer.normalize_text_for_test("   ");
 6038|      1|        assert_eq!(arrows, "<- -> ^ v");
 6039|       |
 6040|      1|        let untouched = renderer.normalize_text_for_test("Plain text");
 6041|      1|        assert_eq!(untouched, "Plain text");
 6042|      1|    }
 6043|       |
 6044|       |    #[test]
 6045|      1|    fn test_elements_to_plain_text_basic() {
 6046|      1|        let elements = vec![
 6047|      1|            MarkdownElement::Header {
 6048|      1|                level: 1,
 6049|      1|                spans: vec![InlineSpan::Text("Test Header".to_string())],
 6050|      1|                id: "test-header".to_string(),
 6051|      1|            },
 6052|      1|            MarkdownElement::Paragraph(vec![
 6053|      1|                InlineSpan::Text("This is a ".to_string()),
 6054|      1|                InlineSpan::Strong("bold".to_string()),
 6055|      1|                InlineSpan::Text(" paragraph.".to_string()),
 6056|      1|            ]),
 6057|       |        ];
 6058|       |
 6059|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6060|      1|        assert!(plain_text.contains("Test Header"));
 6061|      1|        assert!(plain_text.contains("This is a bold paragraph."));
 6062|      1|    }
 6063|       |
 6064|       |    #[test]
 6065|      1|    fn test_elements_to_plain_text_code_block() {
 6066|      1|        let elements = vec![MarkdownElement::CodeBlock {
 6067|      1|            language: Some("rust".to_string()),
 6068|      1|            text: "fn main() {\n    println!(\"Hello\");\n}".to_string(),
 6069|      1|        }];
 6070|       |
 6071|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6072|      1|        assert_eq!(plain_text, "fn main() {\n    println!(\"Hello\");\n}");
 6073|      1|    }
 6074|       |
 6075|       |    #[test]
 6076|      1|    fn test_elements_to_plain_text_with_links() {
 6077|      1|        let elements = vec![MarkdownElement::Paragraph(vec![
 6078|      1|            InlineSpan::Text("Visit ".to_string()),
 6079|      1|            InlineSpan::Link {
 6080|      1|                text: "GitHub".to_string(),
 6081|      1|                url: "https://github.com".to_string(),
 6082|      1|            },
 6083|      1|            InlineSpan::Text(" for more.".to_string()),
 6084|      1|        ])];
 6085|       |
 6086|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6087|      1|        assert_eq!(plain_text, "Visit GitHub for more.");
 6088|      1|    }
 6089|       |
 6090|       |    #[test]
 6091|      1|    fn test_elements_to_plain_text_horizontal_rule_after_text() {
 6092|      1|        let elements = vec![
 6093|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("Hello".to_string())]),
 6094|      1|            MarkdownElement::HorizontalRule,
 6095|       |        ];
 6096|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6097|      1|        assert_eq!(plain_text, "Hello\n---\n");
 6098|      1|    }
 6099|       |
 6100|       |    #[test]
 6101|      1|    fn test_elements_to_plain_text_mixed_blocks_adds_newlines() {
 6102|      1|        let elements = vec![
 6103|      1|            MarkdownElement::Paragraph(vec![InlineSpan::Text("First".to_string())]),
 6104|      1|            MarkdownElement::List {
 6105|      1|                ordered: false,
 6106|      1|                items: vec![ListItem {
 6107|      1|                    blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6108|      1|                        "List".to_string(),
 6109|      1|                    )])],
 6110|      1|                }],
 6111|      1|            },
 6112|      1|            MarkdownElement::Quote {
 6113|      1|                depth: 1,
 6114|      1|                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6115|      1|                    "Quote".to_string(),
 6116|      1|                )])],
 6117|      1|            },
 6118|      1|            MarkdownElement::Table {
 6119|      1|                headers: vec![
 6120|      1|                    vec![InlineSpan::Text("H1".to_string())],
 6121|      1|                    vec![InlineSpan::Text("H2".to_string())],
 6122|      1|                ],
 6123|      1|                rows: vec![vec![vec![InlineSpan::Text("R1".to_string())]]],
 6124|      1|                alignments: vec![Alignment::Left, Alignment::Left],
 6125|      1|            },
 6126|      1|            MarkdownElement::HorizontalRule,
 6127|       |        ];
 6128|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6129|      1|        assert_eq!(plain_text, "First\nList\nQuote\nH1\nH2\nR1\n---\n");
 6130|      1|    }
 6131|       |
 6132|       |    #[test]
 6133|      1|    fn test_elements_to_plain_text_list_only_starts_without_newline() {
 6134|      1|        let elements = vec![MarkdownElement::List {
 6135|      1|            ordered: false,
 6136|      1|            items: vec![ListItem {
 6137|      1|                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6138|      1|                    "Item".to_string(),
 6139|      1|                )])],
 6140|      1|            }],
 6141|      1|        }];
 6142|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6143|      1|        assert_eq!(plain_text, "Item");
 6144|      1|    }
 6145|       |
 6146|       |    #[test]
 6147|      1|    fn test_elements_to_plain_text_quote_only_starts_without_newline() {
 6148|      1|        let elements = vec![MarkdownElement::Quote {
 6149|      1|            depth: 1,
 6150|      1|            blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 6151|      1|                "Quote".to_string(),
 6152|      1|            )])],
 6153|      1|        }];
 6154|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6155|      1|        assert_eq!(plain_text, "Quote");
 6156|      1|    }
 6157|       |
 6158|       |    #[test]
 6159|      1|    fn test_elements_to_plain_text_table_headers_only_starts_without_newline() {
 6160|      1|        let elements = vec![MarkdownElement::Table {
 6161|      1|            headers: vec![vec![InlineSpan::Text("H".to_string())]],
 6162|      1|            rows: Vec::new(),
 6163|      1|            alignments: vec![Alignment::Left],
 6164|      1|        }];
 6165|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6166|      1|        assert_eq!(plain_text, "H");
 6167|      1|    }
 6168|       |
 6169|       |    #[test]
 6170|      1|    fn test_elements_to_plain_text_table_rows_only_starts_without_newline() {
 6171|      1|        let elements = vec![MarkdownElement::Table {
 6172|      1|            headers: Vec::new(),
 6173|      1|            rows: vec![vec![vec![InlineSpan::Text("R".to_string())]]],
 6174|      1|            alignments: vec![Alignment::Left],
 6175|      1|        }];
 6176|      1|        let plain_text = MarkdownRenderer::elements_to_plain_text(&elements);
 6177|      1|        assert_eq!(plain_text, "R");
 6178|      1|    }
 6179|       |
 6180|       |    #[test]
 6181|      1|    fn test_spans_plain_text_image_title_without_alt() {
 6182|      1|        let spans = vec![
 6183|      1|            InlineSpan::Image {
 6184|      1|                src: "img.png".to_string(),
 6185|      1|                alt: "".to_string(),
 6186|      1|                title: Some("Title".to_string()),
 6187|      1|            },
 6188|      1|            InlineSpan::Image {
 6189|      1|                src: "img.png".to_string(),
 6190|      1|                alt: "Alt".to_string(),
 6191|      1|                title: Some("Caption".to_string()),
 6192|      1|            },
 6193|      1|            InlineSpan::Image {
 6194|      1|                src: "img.png".to_string(),
 6195|      1|                alt: "".to_string(),
 6196|      1|                title: Some("".to_string()),
 6197|      1|            },
 6198|       |        ];
 6199|      1|        let plain_text = MarkdownRenderer::spans_plain_text(&spans);
 6200|      1|        assert_eq!(plain_text, "TitleAlt Caption");
 6201|      1|    }
 6202|       |
 6203|       |    #[test]
 6204|      1|    fn test_image_source_stale_detects_file_changes() {
 6205|       |        use std::time::Duration as StdDuration;
 6206|       |
 6207|      1|        let dir = tempfile::tempdir().expect("temp dir");
 6208|      1|        let file_path = dir.path().join("image.bin");
 6209|      1|        std::fs::write(&file_path, [1u8, 2, 3, 4]).expect("write image");
 6210|      1|        let initial = MarkdownRenderer::disk_image_timestamp(&file_path);
 6211|      1|        assert!(!MarkdownRenderer::image_source_stale(initial, &file_path));
 6212|       |
 6213|      1|        std::thread::sleep(StdDuration::from_millis(5));
 6214|      1|        std::fs::write(&file_path, [4u8, 3, 2, 1]).expect("rewrite image");
 6215|       |
 6216|      1|        assert!(MarkdownRenderer::image_source_stale(initial, &file_path));
 6217|       |
 6218|      1|        std::fs::remove_file(&file_path).expect("remove image");
 6219|      1|        assert!(MarkdownRenderer::image_source_stale(initial, &file_path));
 6220|      1|    }
 6221|       |
 6222|       |    #[test]
 6223|      1|    fn test_inline_code_preserves_whitespace() {
 6224|      1|        let renderer = MarkdownRenderer::new();
 6225|      1|        let md = "Start `code` end";
 6226|      1|        let parsed = renderer.parse(md).expect("parse ok");
 6227|      1|        match &parsed[0] {
 6228|      1|            MarkdownElement::Paragraph(spans) => {
 6229|      2|                let code_span = spans.iter().find_map(|span| match span {
                                  ^1          ^1           ^1
 6230|      1|                    InlineSpan::Code(t) => Some(t),
 6231|      1|                    _ => None,
 6232|      2|                });
 6233|      1|                assert_eq!(code_span, Some(&"code".to_string()));
 6234|       |            }
 6235|      0|            other => panic!("Expected Paragraph, got {:?}", other),
 6236|       |        }
 6237|      1|    }
 6238|       |
 6239|       |    #[test]
 6240|      1|    fn test_footnote_markers_render_as_visible_text() {
 6241|      1|        let renderer = MarkdownRenderer::new();
 6242|      1|        let md = "Paragraph with footnote[^1].\n\n[^1]: footnote body.";
 6243|      1|        let parsed = renderer.parse(md).expect("parse ok");
 6244|      1|        assert_eq!(parsed.len(), 2);
 6245|      1|        let first_plain = MarkdownRenderer::element_plain_text(&parsed[0]);
 6246|      1|        assert!(first_plain.contains("footnote[^1]"));
 6247|      1|        let second_plain = MarkdownRenderer::element_plain_text(&parsed[1]);
 6248|      1|        assert!(second_plain.contains("[^1]: footnote body."));
 6249|      1|    }
 6250|       |
 6251|       |    #[test]
 6252|      1|    fn test_parse_headers_assign_ids_and_dedupe() {
 6253|      1|        let renderer = MarkdownRenderer::new();
 6254|      1|        let md = "# Getting Started\n\n## Getting Started\n\n### API & Usage\n\n## API & Usage\n";
 6255|      1|        let parsed = renderer.parse(md).expect("parse ok");
 6256|       |
 6257|      1|        let mut ids = vec![];
 6258|      5|        for el in parsed {
                          ^4
 6259|      4|            if let MarkdownElement::Header { id, .. } = el {
  ------------------
  |  Branch (6259:20): [True: 4, False: 0]
  ------------------
 6260|      4|                ids.push(id);
 6261|      4|            }
                          ^0
 6262|       |        }
 6263|      1|        assert_eq!(ids.len(), 4);
 6264|      1|        assert_eq!(ids[0], "getting-started");
 6265|      1|        assert_eq!(ids[1], "getting-started-1");
 6266|      1|        assert_eq!(ids[2], "api-usage");
 6267|      1|        assert_eq!(ids[3], "api-usage-1");
 6268|      1|    }
 6269|       |
 6270|       |    #[test]
 6271|      1|    fn test_formatting_sample_contains_expected_header_ids() {
 6272|      1|        let renderer = MarkdownRenderer::new();
 6273|      1|        let formatting = SAMPLE_FILES
 6274|      1|            .iter()
 6275|      2|            .find(|f| f.name == "formatting.md")
                           ^1
 6276|      1|            .expect("formatting sample present");
 6277|      1|        let parsed = renderer.parse(formatting.content).expect("parse ok");
 6278|      1|        let ids: Vec<String> = parsed
 6279|      1|            .into_iter()
 6280|     37|            .filter_map(|el| match el {
                           ^1
 6281|     18|                MarkdownElement::Header { id, .. } => Some(id),
 6282|     19|                _ => None,
 6283|     37|            })
 6284|      1|            .collect();
 6285|       |
 6286|     10|        for expected in [
 6287|       |            "markdown-formatting-guide",
 6288|      1|            "table-of-contents",
 6289|      1|            "text-formatting",
 6290|      1|            "headers",
 6291|      1|            "lists",
 6292|      1|            "links-and-images",
 6293|      1|            "emojis",
 6294|      1|            "blockquotes",
 6295|      1|            "horizontal-rules",
 6296|      1|            "tables",
 6297|       |        ] {
 6298|    101|            assert!(ids.iter().any(|id| id == expected));
                          ^10     ^10        ^10
 6299|       |        }
 6300|      1|    }
 6301|       |
 6302|       |    #[test]
 6303|      1|    fn test_inline_image_parsing() {
 6304|      1|        let renderer = MarkdownRenderer::new();
 6305|      1|        let md = "Here is an image: ![Alt text](images/pic.webp \"Title\") end.";
 6306|      1|        let parsed = renderer.parse(md).expect("parse ok");
 6307|      1|        assert_eq!(parsed.len(), 1);
 6308|      1|        match &parsed[0] {
 6309|      1|            MarkdownElement::Paragraph(spans) => {
 6310|      2|                let img = spans.iter().find(|s| matches!(s, InlineSpan::Image { .. }));
                                  ^1    ^1           ^1
 6311|      1|                assert!(img.is_some());
 6312|      1|                if let InlineSpan::Image { src, alt, title } = img.unwrap() {
  ------------------
  |  Branch (6312:24): [True: 1, False: 0]
  ------------------
 6313|      1|                    assert_eq!(src, "images/pic.webp");
 6314|      1|                    assert_eq!(alt, "Alt text");
 6315|      1|                    assert_eq!(title.as_deref(), Some("Title"));
 6316|      0|                }
 6317|       |            }
 6318|      0|            other => panic!("Expected Paragraph, got {:?}", other),
 6319|       |        }
 6320|      1|    }
 6321|       |
 6322|       |    #[test]
 6323|      1|    fn test_image_text_in_plain_text_index() {
 6324|      1|        let renderer = MarkdownRenderer::new();
 6325|      1|        let md = "![Diagram](./a.png \"Flow\")";
 6326|      1|        let parsed = renderer.parse(md).expect("parse ok");
 6327|      1|        let text = MarkdownRenderer::element_plain_text(&parsed[0]);
 6328|      1|        assert!(text.contains("Diagram"));
 6329|      1|        assert!(text.contains("Flow"));
 6330|      1|    }
 6331|       |
 6332|       |    #[test]
 6333|      1|    fn test_cell_fragments_split_text_and_images() {
 6334|      1|        let renderer = MarkdownRenderer::new();
 6335|      1|        let spans = vec![
 6336|      1|            InlineSpan::Text("alpha".into()),
 6337|      1|            InlineSpan::Strong("beta".into()),
 6338|      1|            InlineSpan::Image {
 6339|      1|                src: "img.png".into(),
 6340|      1|                alt: "img".into(),
 6341|      1|                title: None,
 6342|      1|            },
 6343|      1|            InlineSpan::Text("gamma".into()),
 6344|       |        ];
 6345|      1|        let fragments = renderer.cell_fragments(&spans);
 6346|      1|        assert_eq!(fragments.len(), 3);
 6347|      1|        match &fragments[0] {
 6348|      1|            CellFragment::Text(slice) => assert_eq!(slice.len(), 2),
 6349|      0|            other => panic!("expected text fragment, got {:?}", other),
 6350|       |        }
 6351|      1|        match &fragments[1] {
 6352|      1|            CellFragment::Image(span) => {
 6353|      1|                if let InlineSpan::Image { src, .. } = span {
  ------------------
  |  Branch (6353:24): [True: 1, False: 0]
  ------------------
 6354|      1|                    assert_eq!(src, "img.png");
 6355|       |                } else {
 6356|      0|                    panic!("image fragment should point to inline image span");
 6357|       |                }
 6358|       |            }
 6359|      0|            other => panic!("second fragment should be image, got {:?}", other),
 6360|       |        }
 6361|      1|        match &fragments[2] {
 6362|      1|            CellFragment::Text(slice) => {
 6363|      1|                assert_eq!(slice.len(), 1);
 6364|      1|                if let InlineSpan::Text(content) = &slice[0] {
  ------------------
  |  Branch (6364:24): [True: 1, False: 0]
  ------------------
 6365|      1|                    assert_eq!(content, "gamma");
 6366|       |                } else {
 6367|      0|                    panic!("expected trailing text span");
 6368|       |                }
 6369|       |            }
 6370|      0|            other => panic!("expected trailing text fragment, got {:?}", other),
 6371|       |        }
 6372|      1|    }
 6373|       |
 6374|       |    #[test]
 6375|      1|    fn test_cell_fragments_leading_image() {
 6376|      1|        let renderer = MarkdownRenderer::new();
 6377|      1|        let spans = vec![
 6378|      1|            InlineSpan::Image {
 6379|      1|                src: "cover.png".into(),
 6380|      1|                alt: "cover".into(),
 6381|      1|                title: None,
 6382|      1|            },
 6383|      1|            InlineSpan::Text("tail".into()),
 6384|       |        ];
 6385|      1|        let fragments = renderer.cell_fragments(&spans);
 6386|      1|        assert_eq!(fragments.len(), 2);
 6387|      1|        assert!(matches!(fragments[0], CellFragment::Image(_)));
                              ^0
 6388|      1|        assert!(matches!(fragments[1], CellFragment::Text(_)));
                              ^0
 6389|      1|    }
 6390|       |
 6391|       |    #[test]
 6392|      1|    fn test_cell_fragments_detect_single_emoji_cell() {
 6393|      1|        let renderer = MarkdownRenderer::new();
 6394|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 6395|      1|            .get(":rocket:")
 6396|      1|            .expect("rocket shortcode");
 6397|      1|        let spans = vec![InlineSpan::Strong((*rocket).to_string())];
 6398|      1|        let fragments = renderer.cell_fragments(&spans);
 6399|      1|        assert_eq!(fragments.len(), 1);
 6400|      1|        assert!(matches!(
                              ^0
 6401|      1|            &fragments[0],
 6402|      1|            CellFragment::Emoji(e) if !e.is_empty()
  ------------------
  |  Branch (6402:39): [True: 1, False: 0]
  ------------------
 6403|       |        ));
 6404|      1|    }
 6405|       |
 6406|       |    #[test]
 6407|      1|    fn test_cell_single_emoji_emphasis() {
 6408|      1|        let renderer = MarkdownRenderer::new();
 6409|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 6410|      1|            .get(":rocket:")
 6411|      1|            .expect("rocket shortcode");
 6412|      1|        let spans = vec![InlineSpan::Emphasis((*rocket).to_string())];
 6413|      1|        assert!(renderer.cell_single_emoji(&spans).is_some());
 6414|      1|    }
 6415|       |
 6416|       |    #[test]
 6417|      1|    fn test_cell_single_emoji_returns_none_for_code_and_link() {
 6418|      1|        let renderer = MarkdownRenderer::new();
 6419|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 6420|      1|            .get(":rocket:")
 6421|      1|            .expect("rocket shortcode");
 6422|      1|        let code_spans = vec![InlineSpan::Code((*rocket).to_string())];
 6423|      1|        assert!(renderer.cell_single_emoji(&code_spans).is_none());
 6424|       |
 6425|      1|        let link_spans = vec![InlineSpan::Link {
 6426|      1|            text: (*rocket).to_string(),
 6427|      1|            url: "https://example.com".to_string(),
 6428|      1|        }];
 6429|      1|        assert!(renderer.cell_single_emoji(&link_spans).is_none());
 6430|      1|    }
 6431|       |
 6432|       |    #[test]
 6433|      1|    fn test_cell_fragments_inline_emoji_stays_text() {
 6434|      1|        let renderer = MarkdownRenderer::new();
 6435|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 6436|      1|            .get(":rocket:")
 6437|      1|            .expect("rocket shortcode");
 6438|      1|        let spans = vec![
 6439|      1|            InlineSpan::Text((*rocket).to_string()),
 6440|      1|            InlineSpan::Text("tail".into()),
 6441|       |        ];
 6442|      1|        let fragments = renderer.cell_fragments(&spans);
 6443|      1|        assert_eq!(fragments.len(), 1);
 6444|      1|        match &fragments[0] {
 6445|      1|            CellFragment::Text(slice) => assert_eq!(slice.len(), 2),
 6446|      0|            other => panic!("expected text fragment, got {:?}", other),
 6447|       |        }
 6448|      1|    }
 6449|       |
 6450|       |    #[test]
 6451|      1|    fn test_cell_fragments_keep_link_emoji_interactive() {
 6452|      1|        let renderer = MarkdownRenderer::new();
 6453|      1|        let rocket = crate::emoji_catalog::shortcode_map()
 6454|      1|            .get(":rocket:")
 6455|      1|            .expect("rocket shortcode");
 6456|      1|        let spans = vec![InlineSpan::Link {
 6457|      1|            text: (*rocket).to_string(),
 6458|      1|            url: "https://example.com".to_string(),
 6459|      1|        }];
 6460|      1|        let fragments = renderer.cell_fragments(&spans);
 6461|      1|        assert_eq!(fragments.len(), 1);
 6462|      1|        match &fragments[0] {
 6463|      1|            CellFragment::Text(slice) => assert!(matches!(slice[0], InlineSpan::Link { .. })),
                                                               ^0
 6464|      0|            other => panic!("expected text fragment, got {:?}", other),
 6465|       |        }
 6466|      1|    }
 6467|       |
 6468|       |    #[test]
 6469|      1|    fn test_layout_job_builder_respects_wrap_width() {
 6470|      1|        let renderer = MarkdownRenderer::new();
 6471|      1|        let spans = vec![InlineSpan::Text(
 6472|      1|            "A long column entry that should wrap neatly within the supplied width.".into(),
 6473|      1|        )];
 6474|      1|        let style = egui::Style::default();
 6475|      1|        let build = renderer.build_layout_job(&style, &spans, 180.0, false, Align::LEFT);
 6476|      1|        assert_eq!(build.job.wrap.max_width, 180.0);
 6477|      1|        assert!(build.job.text.contains("column entry"));
 6478|      1|    }
 6479|       |
 6480|       |    #[test]
 6481|      1|    fn test_layout_job_builder_highlights_matches() {
 6482|      1|        let renderer = MarkdownRenderer::new();
 6483|      1|        renderer.set_highlight_phrase(Some("wrap"));
 6484|      1|        let spans = vec![InlineSpan::Text("wrap me, wrap me again".into())];
 6485|      1|        let style = egui::Style::default();
 6486|      1|        let build = renderer.build_layout_job(&style, &spans, 200.0, false, Align::LEFT);
 6487|      1|        let highlight_bg = style.visuals.selection.bg_fill;
 6488|      1|        assert!(build
 6489|      1|            .job
 6490|      1|            .sections
 6491|      1|            .iter()
 6492|      1|            .any(|s| s.format.background == highlight_bg));
 6493|      1|    }
 6494|       |
 6495|       |    #[test]
 6496|      1|    fn test_layout_job_builder_tracks_link_ranges() {
 6497|      1|        let renderer = MarkdownRenderer::new();
 6498|      1|        let spans = vec![InlineSpan::Link {
 6499|      1|            text: "Docs".into(),
 6500|      1|            url: "https://example.org/docs".into(),
 6501|      1|        }];
 6502|      1|        let style = egui::Style::default();
 6503|      1|        let build = renderer.build_layout_job(&style, &spans, 220.0, false, Align::LEFT);
 6504|      1|        assert_eq!(build.link_ranges.len(), 1);
 6505|      1|        let link = &build.link_ranges[0];
 6506|      1|        assert_eq!(link.url, "https://example.org/docs");
 6507|      1|        let char_len = link.char_range.end - link.char_range.start;
 6508|      1|        let linked_text: String = build
 6509|      1|            .job
 6510|      1|            .text
 6511|      1|            .chars()
 6512|      1|            .skip(link.char_range.start)
 6513|      1|            .take(char_len)
 6514|      1|            .collect();
 6515|      1|        assert_eq!(linked_text, "Docs");
 6516|      1|    }
 6517|       |
 6518|       |    #[test]
 6519|      1|    fn test_layout_job_builder_skips_empty_link_text() {
 6520|      1|        let renderer = MarkdownRenderer::new();
 6521|      1|        let spans = vec![InlineSpan::Link {
 6522|      1|            text: String::new(),
 6523|      1|            url: "https://example.org/docs".into(),
 6524|      1|        }];
 6525|      1|        let style = egui::Style::default();
 6526|      1|        let build = renderer.build_layout_job(&style, &spans, 220.0, false, Align::LEFT);
 6527|      1|        assert!(build.link_ranges.is_empty());
 6528|      1|    }
 6529|       |
 6530|       |    #[test]
 6531|      1|    fn test_build_layout_job_skips_images() {
 6532|      1|        let renderer = MarkdownRenderer::new();
 6533|      1|        let style = egui::Style::default();
 6534|      1|        let spans = vec![InlineSpan::Image {
 6535|      1|            src: "dummy.png".to_string(),
 6536|      1|            alt: "alt".to_string(),
 6537|      1|            title: None,
 6538|      1|        }];
 6539|       |
 6540|      1|        let build = renderer.build_layout_job(&style, &spans, 120.0, false, Align::LEFT);
 6541|      1|        assert!(build.plain_text.is_empty());
 6542|      1|    }
 6543|       |
 6544|       |    #[test]
 6545|      1|    fn test_append_spans_empty_and_code_light() {
 6546|      1|        let renderer = MarkdownRenderer::new();
 6547|      1|        let style = egui::Style::default();
 6548|      1|        let mut job = LayoutJob::default();
 6549|      1|        let mut plain_text = String::new();
 6550|       |
 6551|      1|        assert_eq!(
 6552|      1|            renderer.append_plain_span(
 6553|      1|                &style,
 6554|      1|                &mut job,
 6555|      1|                &mut plain_text,
 6556|      1|                "",
 6557|      1|                InlineStyle::default(),
 6558|      1|                None
 6559|       |            ),
 6560|       |            0
 6561|       |        );
 6562|      1|        assert_eq!(
 6563|      1|            renderer.append_code_span(&style, &mut job, &mut plain_text, ""),
 6564|       |            0
 6565|       |        );
 6566|       |
 6567|      1|        let mut light_style = style.clone();
 6568|      1|        light_style.visuals.dark_mode = false;
 6569|      1|        assert!(renderer.append_code_span(&light_style, &mut job, &mut plain_text, "code") > 0);
 6570|       |
 6571|      1|        let mut empty_job = LayoutJob::default();
 6572|      1|        let mut empty_plain = String::new();
 6573|      1|        assert_eq!(
 6574|      1|            renderer.append_text_sections(
 6575|      1|                &style,
 6576|      1|                &mut empty_job,
 6577|      1|                &mut empty_plain,
 6578|      1|                "",
 6579|       |                12.0,
 6580|      1|                InlineStyle::default(),
 6581|      1|                None
 6582|       |            ),
 6583|       |            0
 6584|       |        );
 6585|      1|    }
 6586|       |
 6587|       |    #[test]
 6588|      1|    fn test_is_html_line_break_and_indented_code_tabs() {
 6589|      1|        assert!(!MarkdownRenderer::is_html_line_break("<b"));
 6590|      1|        assert!(MarkdownRenderer::is_html_line_break("<br >"));
 6591|      1|        assert!(!MarkdownRenderer::is_html_line_break("<brx>"));
 6592|      1|        assert!(MarkdownRenderer::is_indented_code_line("\tcode"));
 6593|      1|    }
 6594|       |
 6595|       |    #[test]
 6596|      1|    fn test_is_html_line_break_rejects_missing_bracket() {
 6597|      1|        assert!(!MarkdownRenderer::is_html_line_break("<br"));
 6598|      1|        assert!(!MarkdownRenderer::is_html_line_break("<br/"));
 6599|      1|    }
 6600|       |
 6601|       |    #[test]
 6602|      1|    fn test_is_html_line_break_slash_variants() {
 6603|      1|        assert!(MarkdownRenderer::is_html_line_break("<br/>"));
 6604|      1|        assert!(!MarkdownRenderer::is_html_line_break("<br/ x>"));
 6605|      1|    }
 6606|       |
 6607|       |    #[test]
 6608|      1|    fn test_escape_pipes_inline_code_multi_backticks() {
 6609|      1|        let out = MarkdownRenderer::escape_pipes_in_inline_code_line("``code|``");
 6610|      1|        assert!(out.contains(PIPE_SENTINEL));
 6611|      1|    }
 6612|       |
 6613|       |    #[test]
 6614|      1|    fn test_escape_pipes_inline_code_line_branches() {
 6615|      1|        let plain = "no pipes here";
 6616|      1|        assert_eq!(MarkdownRenderer::escape_pipes_in_inline_code_line(plain), plain);
 6617|       |
 6618|      1|        let line = "``code`|more``";
 6619|      1|        let escaped = MarkdownRenderer::escape_pipes_in_inline_code_line(line);
 6620|      1|        assert!(escaped.contains(PIPE_SENTINEL));
 6621|      1|    }
 6622|       |
 6623|       |    #[test]
 6624|      1|    fn test_escape_table_pipes_list_indent_with_tabs_and_table() {
 6625|      1|        let input = "- Parent\n\t- Child\n  | Head | Tail |\n  | --- | --- |\n  | a | b |\n";
 6626|      1|        let output = MarkdownRenderer::escape_table_pipes_in_inline_code(input);
 6627|      1|        assert!(output.contains("| Head | Tail |"));
 6628|      1|    }
 6629|       |
 6630|       |    #[test]
 6631|      1|    fn test_escape_pipes_inline_code_line_restores_pending_on_unclosed() {
 6632|      1|        let line = "`code|tail";
 6633|      1|        let escaped = MarkdownRenderer::escape_pipes_in_inline_code_line(line);
 6634|      1|        assert_eq!(escaped, line);
 6635|      1|    }
 6636|       |
 6637|       |    #[test]
 6638|      1|    fn test_table_width_solver_keeps_short_columns_readable() {
 6639|      1|        let mins = vec![90.0, 90.0, 90.0, 90.0];
 6640|      1|        let desired = vec![120.0, 120.0, 360.0, 160.0];
 6641|      1|        let widths = MarkdownRenderer::resolve_table_widths(420.0, &mins, &desired);
 6642|      1|        assert_eq!(widths.len(), 4);
 6643|       |        // Narrow columns should stay near their minimums even when a wide column exists
 6644|      1|        assert!(widths[0] >= 85.0);
 6645|      1|        assert!(widths[2] > widths[0]);
 6646|      1|        let sum: f32 = widths.iter().sum();
 6647|      1|        assert!((sum - 420.0).abs() < 0.5);
 6648|      1|    }
 6649|       |
 6650|       |    #[test]
 6651|      1|    fn test_table_width_solver_handles_constrained_space() {
 6652|      1|        let mins = vec![100.0, 100.0, 100.0, 100.0];
 6653|      1|        let desired = vec![200.0, 240.0, 360.0, 160.0];
 6654|      1|        let widths = MarkdownRenderer::resolve_table_widths(260.0, &mins, &desired);
 6655|      1|        assert_eq!(widths.len(), 4);
 6656|      4|        assert!(widths.iter().all(|w| *w > 0.0));
                      ^1      ^1            ^1
 6657|      1|        let sum: f32 = widths.iter().sum();
 6658|      1|        assert!((sum - 260.0).abs() < 0.5);
 6659|      1|    }
 6660|       |
 6661|       |    #[test]
 6662|      1|    fn table_cells_keep_images_and_formatting() {
 6663|      1|        let renderer = MarkdownRenderer::new();
 6664|      1|        let md = "\
 6665|      1|| H1 | H2 |
 6666|      1|| --- | --- |
 6667|      1|| text ![Alt](img.png) | **bold** and [link](https://example.com) |";
 6668|      1|        let elements = renderer.parse(md).expect("parse ok");
 6669|      1|        let table = elements
 6670|      1|            .iter()
 6671|      1|            .find_map(|el| match el {
 6672|       |                MarkdownElement::Table {
 6673|       |                    headers: _,
 6674|      1|                    rows,
 6675|       |                    alignments: _,
 6676|      1|                } => Some(rows),
 6677|      0|                _ => None,
 6678|      1|            })
 6679|      1|            .expect("table present");
 6680|      1|        assert_eq!(table.len(), 1);
 6681|      1|        let row = &table[0];
 6682|      1|        assert!(row[0]
 6683|      1|            .iter()
 6684|      1|            .any(|span| matches!(span, InlineSpan::Image { src, .. } if src == "img.png")));
  ------------------
  |  Branch (6684:73): [True: 1, False: 0]
  ------------------
 6685|      1|        assert!(row[1]
 6686|      1|            .iter()
 6687|      1|            .any(|span| matches!(span, InlineSpan::Strong(text) if text.contains("bold"))));
  ------------------
  |  Branch (6687:68): [True: 1, False: 0]
  ------------------
 6688|      1|        assert!(row[1].iter().any(|span| matches!(
 6689|      1|            span,
 6690|      1|            InlineSpan::Link { url, .. } if url == "https://example.com"
  ------------------
  |  Branch (6690:45): [True: 1, False: 0]
  ------------------
 6691|       |        )));
 6692|      1|    }
 6693|       |
 6694|       |    #[test]
 6695|      1|    fn table_inline_code_keeps_pipes() {
 6696|      1|        let renderer = MarkdownRenderer::new();
 6697|      1|        let md = "\
 6698|      1|| Col | Notes |
 6699|      1|| --- | --- |
 6700|      1|| code | `a|b|c` |";
 6701|      1|        let elements = renderer.parse(md).expect("parse ok");
 6702|      1|        let rows = elements
 6703|      1|            .iter()
 6704|      1|            .find_map(|el| match el {
 6705|       |                MarkdownElement::Table {
 6706|       |                    headers: _,
 6707|      1|                    rows,
 6708|       |                    alignments: _,
 6709|      1|                } => Some(rows),
 6710|      0|                _ => None,
 6711|      1|            })
 6712|      1|            .expect("table present");
 6713|      1|        let code_text = rows[0][1]
 6714|      1|            .iter()
 6715|      1|            .find_map(|span| match span {
 6716|      1|                InlineSpan::Code(text) => Some(text.as_str()),
 6717|      0|                _ => None,
 6718|      1|            })
 6719|      1|            .expect("code span");
 6720|      1|        assert_eq!(code_text, "a|b|c");
 6721|      1|    }
 6722|       |
 6723|       |    #[test]
 6724|      1|    fn indented_code_block_table_like_preserves_pipes() {
 6725|      1|        let md = "\
 6726|      1|    | Col | Notes |
 6727|      1|    | --- | --- |
 6728|      1|    | code | `a|b|c` |";
 6729|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6730|      1|        assert!(prepared.contains("`a|b|c`"));
 6731|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 6732|      1|    }
 6733|       |
 6734|       |    #[test]
 6735|      1|    fn blockquote_table_inline_code_escapes_pipes() {
 6736|      1|        let md = "\
 6737|      1|> | Col | Notes |
 6738|      1|> | --- | --- |
 6739|      1|> | code | `a|b|c` |";
 6740|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6741|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 6742|      1|        assert!(prepared.contains(&expected));
 6743|      1|    }
 6744|       |
 6745|       |    #[test]
 6746|      1|    fn blockquote_tab_table_inline_code_escapes_pipes() {
 6747|      1|        let md = ">\t| Col | Notes |\n>\t| --- | --- |\n>\t| code | `a|b|c` |";
 6748|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6749|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 6750|      1|        assert!(prepared.contains(&expected));
 6751|      1|    }
 6752|       |
 6753|       |    #[test]
 6754|      1|    fn blockquote_table_after_paragraph_parses() -> Result<()> {
 6755|      1|        let renderer = MarkdownRenderer::new();
 6756|      1|        let md = "\
 6757|      1|> Intro line
 6758|      1|> | Col | Notes |
 6759|      1|> | --- | --- |
 6760|      1|> | A | B |";
 6761|      1|        let elements = renderer.parse(md)?;
                                                       ^0
 6762|      1|        let blocks = elements
 6763|      1|            .iter()
 6764|      1|            .find_map(|el| match el {
 6765|      1|                MarkdownElement::Quote { blocks, .. } => Some(blocks),
 6766|      0|                _ => None,
 6767|      1|            })
 6768|      1|            .expect("quote block");
 6769|      1|        assert!(blocks
 6770|      1|            .iter()
 6771|      2|            .any(|block| matches!(block, MarkdownElement::Table { .. })));
                           ^1
 6772|      1|        Ok(())
 6773|      1|    }
 6774|       |
 6775|       |    #[test]
 6776|      1|    fn blockquote_list_table_after_paragraph_parses() -> Result<()> {
 6777|      1|        let renderer = MarkdownRenderer::new();
 6778|      1|        let md = "\
 6779|      1|> - Item:
 6780|      1|>   | Key | Val |
 6781|      1|>   | --- | --- |
 6782|      1|>   | A | 1 |";
 6783|      1|        let elements = renderer.parse(md)?;
                                                       ^0
 6784|      1|        let blocks = elements
 6785|      1|            .iter()
 6786|      1|            .find_map(|el| match el {
 6787|      1|                MarkdownElement::Quote { blocks, .. } => Some(blocks),
 6788|      0|                _ => None,
 6789|      1|            })
 6790|      1|            .expect("quote block");
 6791|      1|        let list = blocks
 6792|      1|            .iter()
 6793|      1|            .find_map(|block| match block {
 6794|      1|                MarkdownElement::List { items, .. } => Some(items),
 6795|      0|                _ => None,
 6796|      1|            })
 6797|      1|            .expect("list block");
 6798|      1|        let first = list.first().expect("list item");
 6799|      1|        assert!(first
 6800|      1|            .blocks
 6801|      1|            .iter()
 6802|      2|            .any(|block| matches!(block, MarkdownElement::Table { .. })));
                           ^1
 6803|      1|        Ok(())
 6804|      1|    }
 6805|       |
 6806|       |    #[test]
 6807|      1|    fn blockquote_indented_code_block_preserves_pipes() {
 6808|      1|        let md = "\
 6809|      1|>     | Col | Notes |
 6810|      1|>     | --- | --- |
 6811|      1|>     | code | `a|b|c` |";
 6812|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6813|      1|        assert!(prepared.contains("`a|b|c`"));
 6814|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 6815|      1|    }
 6816|       |
 6817|       |    #[test]
 6818|      1|    fn blockquote_fenced_code_block_preserves_pipes() {
 6819|      1|        let md = "\
 6820|      1|> ```
 6821|      1|> | Col | Notes |
 6822|      1|> | --- | --- |
 6823|      1|> | code | `a|b|c` |
 6824|      1|> ```";
 6825|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6826|      1|        assert!(prepared.contains("`a|b|c`"));
 6827|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 6828|      1|    }
 6829|       |
 6830|       |    #[test]
 6831|      1|    fn list_fenced_code_block_preserves_pipes() {
 6832|      1|        let md = "\
 6833|      1|- ```
 6834|      1|  | Col | Notes |
 6835|      1|  | --- | --- |
 6836|      1|  | code | `a|b|c` |
 6837|      1|  ```";
 6838|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6839|      1|        assert!(prepared.contains("`a|b|c`"));
 6840|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 6841|      1|    }
 6842|       |
 6843|       |    #[test]
 6844|      1|    fn list_blockquote_fenced_code_block_preserves_pipes() {
 6845|      1|        let md = "\
 6846|      1|- Item
 6847|      1|    > ```
 6848|      1|    > | Col | Notes |
 6849|      1|    > | --- | --- |
 6850|      1|    > | code | `a|b|c` |
 6851|      1|    > ```";
 6852|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6853|      1|        assert!(prepared.contains("`a|b|c`"));
 6854|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 6855|      1|    }
 6856|       |
 6857|       |    #[test]
 6858|      1|    fn nested_list_fenced_code_block_preserves_pipes() {
 6859|      1|        let md = "\
 6860|      1|- Outer
 6861|      1|    - ```
 6862|      1|      | Col | Notes |
 6863|      1|      | --- | --- |
 6864|      1|      | code | `a|b|c` |
 6865|      1|      ```";
 6866|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6867|      1|        assert!(prepared.contains("`a|b|c`"));
 6868|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 6869|      1|    }
 6870|       |
 6871|       |    #[test]
 6872|      1|    fn list_item_code_block_preserves_pipes() {
 6873|      1|        let md = "\
 6874|      1|- Item
 6875|      1|      | Col | Notes |
 6876|      1|      | --- | --- |
 6877|      1|      | code | `a|b|c` |";
 6878|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6879|      1|        assert!(prepared.contains("`a|b|c`"));
 6880|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 6881|      1|    }
 6882|       |
 6883|       |    #[test]
 6884|      1|    fn nested_list_table_inline_code_escapes_pipes() {
 6885|      1|        let md = "\
 6886|      1|- Outer
 6887|      1|  - | Col | Notes |
 6888|      1|    | --- | --- |
 6889|      1|    | code | `a|b|c` |";
 6890|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6891|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 6892|      1|        assert!(prepared.contains(&expected));
 6893|      1|    }
 6894|       |
 6895|       |    #[test]
 6896|      1|    fn nested_list_tab_table_inline_code_escapes_pipes() {
 6897|      1|        let md = "- Outer\n\t- | Col | Notes |\n\t  | --- | --- |\n\t  | code | `a|b|c` |";
 6898|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6899|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 6900|      1|        assert!(prepared.contains(&expected));
 6901|      1|    }
 6902|       |
 6903|       |    #[test]
 6904|      1|    fn nested_list_four_space_table_inline_code_escapes_pipes() {
 6905|      1|        let md = "\
 6906|      1|- Outer
 6907|      1|    - | Col | Notes |
 6908|      1|      | --- | --- |
 6909|      1|      | code | `a|b|c` |";
 6910|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6911|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 6912|      1|        assert!(prepared.contains(&expected));
 6913|      1|    }
 6914|       |
 6915|       |    #[test]
 6916|      1|    fn list_marker_four_space_table_inline_code_escapes_pipes() {
 6917|      1|        let md = "\
 6918|      1|-    | Col | Notes |
 6919|      1|     | --- | --- |
 6920|      1|     | code | `a|b|c` |";
 6921|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6922|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 6923|      1|        assert!(prepared.contains(&expected));
 6924|      1|    }
 6925|       |
 6926|       |    #[test]
 6927|      1|    fn nested_list_indented_code_block_preserves_pipes() {
 6928|      1|        let md = "\
 6929|      1|- Outer
 6930|      1|      - | Col | Notes |
 6931|      1|        | --- | --- |
 6932|      1|        | code | `a|b|c` |";
 6933|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6934|      1|        assert!(prepared.contains("`a|b|c`"));
 6935|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 6936|      1|    }
 6937|       |
 6938|       |    #[test]
 6939|      1|    fn deeply_nested_list_table_inline_code_escapes_pipes() {
 6940|      1|        let md = "\
 6941|      1|- Outer
 6942|      1|    - Inner
 6943|      1|        - | Col | Notes |
 6944|      1|          | --- | --- |
 6945|      1|          | code | `a|b|c` |";
 6946|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6947|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 6948|      1|        assert!(prepared.contains(&expected));
 6949|      1|    }
 6950|       |
 6951|       |    #[test]
 6952|      1|    fn list_blockquote_table_inline_code_escapes_pipes() {
 6953|      1|        let md = "\
 6954|      1|- Item
 6955|      1|    > | Col | Notes |
 6956|      1|    > | --- | --- |
 6957|      1|    > | code | `a|b|c` |";
 6958|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6959|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 6960|      1|        assert!(prepared.contains(&expected));
 6961|      1|    }
 6962|       |
 6963|       |    #[test]
 6964|      1|    fn list_marker_blockquote_table_inline_code_escapes_pipes() {
 6965|      1|        let md = "\
 6966|      1|- > | Col | Notes |
 6967|      1|  > | --- | --- |
 6968|      1|  > | code | `a|b|c` |";
 6969|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6970|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 6971|      1|        assert!(prepared.contains(&expected));
 6972|      1|    }
 6973|       |
 6974|       |    #[test]
 6975|      1|    fn list_marker_table_dedent_does_not_escape_pipes() {
 6976|      1|        let md = "\
 6977|      1|- | Col | `a|b|c` |
 6978|      1|| --- | --- |
 6979|      1|| row | ok |";
 6980|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6981|      1|        assert!(prepared.contains("`a|b|c`"));
 6982|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 6983|      1|    }
 6984|       |
 6985|       |    #[test]
 6986|      1|    fn blockquote_list_table_inline_code_escapes_pipes() {
 6987|      1|        let md = "\
 6988|      1|> - | Col | Notes |
 6989|      1|>   | --- | --- |
 6990|      1|>   | code | `a|b|c` |";
 6991|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 6992|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 6993|      1|        assert!(prepared.contains(&expected));
 6994|      1|    }
 6995|       |
 6996|       |    #[test]
 6997|      1|    fn list_marker_line_table_inline_code_escapes_pipes() {
 6998|      1|        let md = "\
 6999|      1|10. 
 7000|      1|    | Col | Notes |
 7001|      1|    | --- | --- |
 7002|      1|    | code | `a|b|c` |";
 7003|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7004|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7005|      1|        assert!(prepared.contains(&expected));
 7006|      1|    }
 7007|       |
 7008|       |    #[test]
 7009|      1|    fn list_marker_tab_after_marker_uses_tab_stops() {
 7010|      1|        let line = "-\titem";
 7011|      1|        let (_content, indent, content_indent) =
 7012|      1|            MarkdownRenderer::list_marker_info(line).expect("list marker");
 7013|      1|        assert_eq!(indent, 3);
 7014|      1|        assert_eq!(content_indent, 4);
 7015|      1|    }
 7016|       |
 7017|       |    #[test]
 7018|      1|    fn list_marker_any_indent_tab_stops_leading_whitespace() {
 7019|      1|        let line = " \t- item";
 7020|      1|        let (_content, _indent, _content_indent, leading) =
 7021|      1|            MarkdownRenderer::list_marker_info_any_indent(line).expect("list marker");
 7022|      1|        assert_eq!(leading, 4);
 7023|      1|    }
 7024|       |
 7025|       |    #[test]
 7026|      1|    fn table_ends_before_inline_code_paragraph() {
 7027|      1|        let md = "\
 7028|      1|| Col | Notes |
 7029|      1|| --- | --- |
 7030|      1|| code | `a|b|c` |
 7031|      1|Paragraph with `x|y` inline.";
 7032|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7033|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7034|      1|        assert!(prepared.contains(&expected));
 7035|      1|        assert!(prepared.contains("`x|y`"));
 7036|      1|    }
 7037|       |
 7038|       |    #[test]
 7039|      1|    fn table_ends_before_escaped_pipe_paragraph() {
 7040|      1|        let md = "\
 7041|      1|| Col | Notes |
 7042|      1|| --- | --- |
 7043|      1|| code | `a|b|c` |
 7044|      1|Paragraph with escaped \\| pipe.";
 7045|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7046|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7047|      1|        assert!(prepared.contains(&expected));
 7048|      1|        assert!(prepared.contains("escaped \\| pipe"));
 7049|      1|    }
 7050|       |
 7051|       |    #[test]
 7052|      1|    fn list_table_ends_on_dedent_with_pipe_paragraph() {
 7053|      1|        let md = "\
 7054|      1|- | Col | Notes |
 7055|      1|  | --- | --- |
 7056|      1|  | code | `a|b|c` |
 7057|      1|Paragraph with `x|y` and pipe | outside.";
 7058|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7059|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7060|      1|        assert!(prepared.contains(&expected));
 7061|      1|        assert!(prepared.contains("`x|y`"));
 7062|      1|    }
 7063|       |
 7064|       |    #[test]
 7065|      1|    fn nested_list_table_ends_on_dedent_with_pipe_paragraph() {
 7066|      1|        let md = "\
 7067|      1|- Outer
 7068|      1|  - | Col | Notes |
 7069|      1|    | --- | --- |
 7070|      1|    | code | `a|b|c` |
 7071|      1|  Paragraph with `x|y` and pipe | outside.";
 7072|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7073|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7074|      1|        assert!(prepared.contains(&expected));
 7075|      1|        assert!(prepared.contains("`x|y`"));
 7076|      1|    }
 7077|       |
 7078|       |    #[test]
 7079|      1|    fn list_table_tab_dedent_keeps_inline_code_unescaped() {
 7080|      1|        let md =
 7081|      1|            "- Outer\n\t- | Col | Notes |\n\t  | --- | --- |\n\t  | code | `a|b|c` |\nParagraph with `x|y` and pipe | outside.";
 7082|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7083|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7084|      1|        assert!(prepared.contains(&expected));
 7085|      1|        assert!(prepared.contains("`x|y`"));
 7086|      1|    }
 7087|       |
 7088|       |    #[test]
 7089|      1|    fn list_blank_line_table_inline_code_escapes_pipes() {
 7090|      1|        let md = "\
 7091|      1|- Item
 7092|      1|
 7093|      1|    | Col | Notes |
 7094|      1|    | --- | --- |
 7095|      1|    | code | `a|b|c` |";
 7096|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7097|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7098|      1|        assert!(prepared.contains(&expected));
 7099|      1|    }
 7100|       |
 7101|       |    #[test]
 7102|      1|    fn table_delimiter_requires_pipe() {
 7103|      1|        let md = "\
 7104|      1|`a|b` | Header
 7105|      1|---
 7106|      1|Not a table";
 7107|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7108|      1|        assert!(prepared.contains("`a|b`"));
 7109|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7110|      1|    }
 7111|       |
 7112|       |    #[test]
 7113|      1|    fn table_unmatched_backticks_do_not_escape_pipes() {
 7114|      1|        let md = "\
 7115|      1|| Col | Notes |
 7116|      1|| --- | --- |
 7117|      1|| code | `a|b |";
 7118|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7119|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7120|      1|    }
 7121|       |
 7122|       |    #[test]
 7123|      1|    fn table_escaped_backticks_do_not_escape_pipes() {
 7124|      1|        let md = "\
 7125|      1|| Col | Notes |
 7126|      1|| --- | --- |
 7127|      1|| text | \\`a|b\\` |";
 7128|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7129|      1|        assert!(prepared.contains("\\`a|b\\`"));
 7130|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7131|      1|    }
 7132|       |
 7133|       |    #[test]
 7134|      1|    fn list_parent_indent_nested_marker_table_escapes_pipes() {
 7135|      1|        let md = "\
 7136|      1|- Parent
 7137|      1|    - | Col | Notes |
 7138|      1|      | --- | --- |
 7139|      1|      | code | `a|b|c` |";
 7140|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7141|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7142|      1|        assert!(prepared.contains(&expected));
 7143|      1|    }
 7144|       |
 7145|       |    #[test]
 7146|      1|    fn list_parent_indent_table_without_marker_escapes_pipes() {
 7147|      1|        let md = "\
 7148|      1|- Parent
 7149|      1|  | Col | Notes |
 7150|      1|  | --- | --- |
 7151|      1|  | code | `a|b|c` |";
 7152|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7153|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7154|      1|        assert!(prepared.contains(&expected));
 7155|      1|    }
 7156|       |
 7157|       |    #[test]
 7158|      1|    fn table_blockquote_level_mismatch_ends_table() {
 7159|      1|        let md = "\
 7160|      1|| Col | Notes |
 7161|      1|| --- | --- |
 7162|      1|> | code | `a|b|c` |";
 7163|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7164|      1|        assert!(prepared.contains("`a|b|c`"));
 7165|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7166|      1|    }
 7167|       |
 7168|       |    #[test]
 7169|      1|    fn table_inserts_blank_line_before_header_with_crlf() {
 7170|      1|        let md = "Intro line\r\n| Col | Notes |\r\n| --- | --- |\r\n| code | `a|b|c` |\r\n";
 7171|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7172|      1|        let expected = format!("`a{}b{}c`", PIPE_SENTINEL, PIPE_SENTINEL);
 7173|      1|        assert!(prepared.contains("\r\n\r\n| Col | Notes |"));
 7174|      1|        assert!(prepared.contains(&expected));
 7175|      1|    }
 7176|       |
 7177|       |    #[test]
 7178|      1|    fn fenced_block_quote_level_mismatch_keeps_block_open() {
 7179|      1|        let md = "\
 7180|      1|> ```
 7181|      1|> | Col | Notes |
 7182|      1|```
 7183|      1|> | --- | --- |
 7184|      1|> | code | `a|b|c` |
 7185|      1|> ```";
 7186|      1|        let prepared = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 7187|      1|        assert!(prepared.contains("`a|b|c`"));
 7188|      1|        assert!(!prepared.contains(PIPE_SENTINEL));
 7189|      1|    }
 7190|       |
 7191|       |    #[test]
 7192|      1|    fn table_ids_are_unique_per_position() {
 7193|      1|        let renderer = MarkdownRenderer::new();
 7194|      1|        let md = "\
 7195|      1|| H |
 7196|      1|| - |
 7197|      1|| a |
 7198|      1|
 7199|      1|| H |
 7200|      1|| - |
 7201|      1|| a |";
 7202|      1|        let elements = renderer.parse(md).expect("parse ok");
 7203|      1|        let tables: Vec<_> = elements
 7204|      1|            .iter()
 7205|      1|            .enumerate()
 7206|      2|            .filter_map(|(idx, el)| match el {
                           ^1
 7207|       |                MarkdownElement::Table {
 7208|      2|                    headers,
 7209|      2|                    rows,
 7210|      2|                    alignments,
 7211|      2|                } => Some(renderer.compute_table_id(headers, rows, alignments, idx as u64)),
 7212|      0|                _ => None,
 7213|      2|            })
 7214|      1|            .collect();
 7215|      1|        assert_eq!(tables.len(), 2);
 7216|      1|        assert_ne!(tables[0], tables[1]);
 7217|      1|    }
 7218|       |
 7219|       |    #[test]
 7220|      1|    fn test_render_to_ui_rich_document_populates_rects_and_table_stats() {
 7221|      1|        let renderer = MarkdownRenderer::new();
 7222|      1|        let md = "\
 7223|      1|# Coverage Demo
 7224|      1|
 7225|      1|Paragraph with :tada: emoji and **bold** text and a [link](#target).
 7226|      1|
 7227|      1|> Quote line one
 7228|      1|> Quote line two
 7229|      1|
 7230|      1|- item one
 7231|      1|- item two
 7232|      1|
 7233|      1|---
 7234|      1|
 7235|      1|```rust
 7236|      1|fn main() {}
 7237|      1|```
 7238|      1|
 7239|      1|| Col A | Col B |
 7240|      1|| --- | --- |
 7241|      1|| A1 | B1 |
 7242|      1|| A2 | B2 |
 7243|      1|
 7244|      1|![Logo](assets/samples/logo.svg \"Logo\")
 7245|      1|![Sample](assets/samples/webp_sample.webp \"Sample\")
 7246|      1|![Missing](missing_test_image.png \"Missing\")
 7247|      1|![Remote](https://example.com/image.png \"Remote\")
 7248|      1|";
 7249|       |
 7250|      1|        let elements = renderer.parse(md).expect("parse ok");
 7251|      1|        renderer.set_highlight_phrase(Some("item"));
 7252|       |
 7253|      1|        with_test_ui(|_, ui| {
 7254|      1|            renderer.render_to_ui(ui, &elements);
 7255|      1|        });
 7256|       |
 7257|      1|        assert!(renderer.element_rect_at(0).is_some());
 7258|      1|        assert!(renderer.header_rect_for("coverage-demo").is_some());
 7259|      1|        let (rendered, total) = renderer.table_render_stats();
 7260|      1|        assert!(total > 0);
 7261|      1|        assert!(rendered > 0);
 7262|      1|        let (_hits, misses) = renderer.table_layout_cache_stats();
 7263|      1|        assert!(misses > 0);
 7264|      1|    }
 7265|       |
 7266|       |    #[test]
 7267|      1|    fn test_table_layout_cache_records_hits() {
 7268|      1|        let renderer = MarkdownRenderer::new();
 7269|      1|        let spans = vec![InlineSpan::Text("alpha".to_string())];
 7270|      1|        let style = egui::Style::default();
 7271|       |
 7272|      1|        let _ = renderer.cached_layout_job(&style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
 7273|      1|        let _ = renderer.cached_layout_job(&style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
 7274|       |
 7275|      1|        let (hits, misses) = renderer.table_layout_cache_stats();
 7276|      1|        assert!(hits >= 1);
 7277|      1|        assert!(misses >= 1);
 7278|       |
 7279|      1|        renderer.clear_table_layout_cache();
 7280|      1|        assert_eq!(renderer.table_layout_cache_stats(), (0, 0));
 7281|      1|    }
 7282|       |
 7283|       |    #[test]
 7284|      1|    fn test_cell_layout_cache_eviction() {
 7285|      1|        let mut cache = CellLayoutCache::new(2);
 7286|      1|        let build = LayoutJobBuild {
 7287|      1|            job: LayoutJob::default(),
 7288|      1|            plain_text: String::new(),
 7289|      1|            link_ranges: Vec::new(),
 7290|      1|        };
 7291|      1|        let key = |row, col| CellLayoutKey {
 7292|      3|            row: Some(row),
 7293|      3|            col,
 7294|       |            width: 120,
 7295|       |            align: 0,
 7296|       |            strong: false,
 7297|      3|            text_color: [0, 0, 0, 255],
 7298|       |            highlight_hash: 0,
 7299|      3|            content_hash: row as u64,
 7300|      3|        };
 7301|       |
 7302|      1|        let key_a = key(0, 0);
 7303|      1|        let key_b = key(1, 0);
 7304|      1|        let key_c = key(2, 0);
 7305|       |
 7306|      1|        cache.insert(key_a.clone(), build.clone());
 7307|      1|        cache.insert(key_b.clone(), build.clone());
 7308|      1|        cache.insert(key_c.clone(), build);
 7309|       |
 7310|      1|        assert!(cache.get(&key_a).is_none());
 7311|      1|        assert!(cache.get(&key_b).is_some());
 7312|      1|        assert!(cache.get(&key_c).is_some());
 7313|      1|    }
 7314|       |
 7315|       |    #[test]
 7316|      1|    fn test_cell_layout_cache_handles_empty_order() {
 7317|      1|        let mut cache = CellLayoutCache::new(1);
 7318|      1|        let build = LayoutJobBuild {
 7319|      1|            job: LayoutJob::default(),
 7320|      1|            plain_text: String::new(),
 7321|      1|            link_ranges: Vec::new(),
 7322|      1|        };
 7323|      1|        let key_a = CellLayoutKey {
 7324|      1|            row: Some(0),
 7325|      1|            col: 0,
 7326|      1|            width: 120,
 7327|      1|            align: 0,
 7328|      1|            strong: false,
 7329|      1|            text_color: [0, 0, 0, 255],
 7330|      1|            highlight_hash: 0,
 7331|      1|            content_hash: 1,
 7332|      1|        };
 7333|      1|        let key_b = CellLayoutKey {
 7334|      1|            row: Some(1),
 7335|      1|            col: 0,
 7336|      1|            width: 120,
 7337|      1|            align: 0,
 7338|      1|            strong: false,
 7339|      1|            text_color: [0, 0, 0, 255],
 7340|      1|            highlight_hash: 0,
 7341|      1|            content_hash: 2,
 7342|      1|        };
 7343|       |
 7344|      1|        cache.insert(key_a, build.clone());
 7345|      1|        cache.order.clear();
 7346|      1|        cache.insert(key_b.clone(), build);
 7347|       |
 7348|      1|        assert!(cache.get(&key_b).is_some());
 7349|      1|    }
 7350|       |
 7351|       |    #[test]
 7352|      1|    fn test_cell_layout_cache_reinsert_existing_key() {
 7353|      1|        let mut cache = CellLayoutCache::new(1);
 7354|      1|        let build = LayoutJobBuild {
 7355|      1|            job: LayoutJob::default(),
 7356|      1|            plain_text: String::new(),
 7357|      1|            link_ranges: Vec::new(),
 7358|      1|        };
 7359|      1|        let key = CellLayoutKey {
 7360|      1|            row: Some(0),
 7361|      1|            col: 0,
 7362|      1|            width: 120,
 7363|      1|            align: 0,
 7364|      1|            strong: false,
 7365|      1|            text_color: [0, 0, 0, 255],
 7366|      1|            highlight_hash: 0,
 7367|      1|            content_hash: 42,
 7368|      1|        };
 7369|      1|        cache.insert(key.clone(), build.clone());
 7370|      1|        cache.insert(key.clone(), build);
 7371|      1|        assert_eq!(cache.entries.len(), 1);
 7372|      1|        assert_eq!(cache.order.len(), 1);
 7373|      1|    }
 7374|       |
 7375|       |    #[test]
 7376|      1|    fn test_table_layout_cache_separates_text_colors() {
 7377|      1|        let renderer = MarkdownRenderer::new();
 7378|      1|        let spans = vec![InlineSpan::Text("alpha".to_string())];
 7379|      1|        let mut light_style = egui::Style::default();
 7380|      1|        let mut dark_style = egui::Style::default();
 7381|      1|        light_style.visuals.override_text_color = Some(Color32::WHITE);
 7382|      1|        dark_style.visuals.override_text_color = Some(Color32::BLACK);
 7383|       |
 7384|       |        let _ =
 7385|      1|            renderer.cached_layout_job(&light_style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
 7386|       |        let _ =
 7387|      1|            renderer.cached_layout_job(&dark_style, Some(0), 0, &spans, 120.0, false, Align::LEFT);
 7388|       |
 7389|      1|        let (hits, misses) = renderer.table_layout_cache_stats();
 7390|      1|        assert_eq!(hits, 0);
 7391|      1|        assert_eq!(misses, 2);
 7392|      1|    }
 7393|       |
 7394|       |    #[test]
 7395|      1|    fn test_table_alignment_center_single_column() -> Result<()> {
 7396|      1|        let renderer = MarkdownRenderer::new();
 7397|      1|        let md = "| Item |\n| :---: |\n| Alpha |\n";
 7398|      1|        let elements = renderer.parse(md)?;
                                                       ^0
 7399|      1|        let alignments = elements
 7400|      1|            .iter()
 7401|      1|            .find_map(|el| match el {
 7402|      1|                MarkdownElement::Table { alignments, .. } => Some(alignments),
 7403|      0|                _ => None,
 7404|      1|            })
 7405|      1|            .expect("table element");
 7406|      1|        assert_eq!(alignments.len(), 1);
 7407|      1|        assert_eq!(alignments[0], Alignment::Center);
 7408|      1|        Ok(())
 7409|      1|    }
 7410|       |
 7411|       |    #[test]
 7412|      1|    fn test_single_column_table_parses_one_cell_per_row() -> Result<()> {
 7413|      1|        let renderer = MarkdownRenderer::new();
 7414|      1|        let md =
 7415|      1|            "| Item |\n| :---: |\n| Alpha |\n| line one<br>line two |\n| **bold** and `code` |\n";
 7416|      1|        let elements = renderer.parse(md)?;
                                                       ^0
 7417|      1|        let (headers, rows) = elements
 7418|      1|            .iter()
 7419|      1|            .find_map(|el| match el {
 7420|      1|                MarkdownElement::Table { headers, rows, .. } => Some((headers, rows)),
 7421|      0|                _ => None,
 7422|      1|            })
 7423|      1|            .expect("table element");
 7424|      1|        assert_eq!(headers.len(), 1);
 7425|      3|        assert!(rows.iter().all(|row| row.len() == 1));
                      ^1      ^1          ^1
 7426|      1|        Ok(())
 7427|      1|    }
 7428|       |
 7429|       |    #[test]
 7430|      1|    fn test_table_first_column_alignment_parses_three_columns() -> Result<()> {
 7431|      1|        let renderer = MarkdownRenderer::new();
 7432|      1|        let md = fs::read_to_string("tests/regression/cases/026-table-first-column-align.md")?;
                                                                                                           ^0
 7433|      1|        let elements = renderer.parse(&md)?;
                                                        ^0
 7434|      1|        let tables: Vec<_> = elements
 7435|      1|            .iter()
 7436|      7|            .filter_map(|el| match el {
                           ^1
 7437|       |                MarkdownElement::Table {
 7438|      3|                    headers,
 7439|      3|                    rows,
 7440|      3|                    alignments,
 7441|      3|                } => Some((headers, rows, alignments)),
 7442|      4|                _ => None,
 7443|      7|            })
 7444|      1|            .collect();
 7445|      1|        assert!(tables.len() >= 3);
 7446|      1|        let (first_headers, first_rows, first_alignments) = tables[0];
 7447|      3|        for (headers, rows, alignments) in tables.iter() {
                                                         ^1     ^1
 7448|      3|            assert_eq!(headers.len(), 3);
 7449|      3|            assert_eq!(alignments.len(), 3);
 7450|      8|            assert!(rows.iter().all(|row| row.len() == 3));
                          ^3      ^3          ^3
 7451|       |        }
 7452|      1|        let table_id = renderer.compute_table_id(first_headers, first_rows, first_alignments, 0);
 7453|      1|        let available = Cell::new(0.0f32);
 7454|      1|        let spacing = Cell::new(0.0f32);
 7455|      1|        let estimated_before = {
 7456|      1|            let column_stats = renderer.column_stats_for_table(
 7457|      1|                table_id,
 7458|      1|                first_headers,
 7459|      1|                first_rows,
 7460|      1|                first_alignments,
 7461|       |            );
 7462|      1|            let ctx = TableColumnContext::new(
 7463|      1|                first_headers,
 7464|      1|                first_rows,
 7465|      1|                &column_stats,
 7466|      1|                renderer.font_sizes.body,
 7467|      1|                table_id,
 7468|       |            );
 7469|      1|            let column_specs = derive_column_specs(&ctx);
 7470|      1|            let column_spacing = 6.0f32.max(egui::Style::default().spacing.item_spacing.x);
 7471|      1|            renderer.estimate_table_total_width(table_id, &column_specs, column_spacing)
 7472|       |        };
 7473|      1|        with_test_ui(|_, ui| {
 7474|      1|            available.set(ui.available_width());
 7475|      1|            spacing.set(ui.spacing().item_spacing.x.max(6.0));
 7476|      1|            renderer.render_table_tablebuilder(
 7477|      1|                ui,
 7478|      1|                first_headers,
 7479|      1|                first_rows,
 7480|      1|                first_alignments,
 7481|      1|                table_id,
 7482|       |            );
 7483|      1|        });
 7484|      1|        let widths = renderer
 7485|      1|            .table_metrics
 7486|      1|            .borrow()
 7487|      1|            .entry(table_id)
 7488|      1|            .map(|entry| entry.current_widths().to_vec())
 7489|      1|            .unwrap_or_default();
 7490|      1|        assert_eq!(widths.len(), 3);
 7491|      3|        assert!(widths.iter().all(|w| *w > 8.0));
                      ^1      ^1            ^1
 7492|      1|        let total_width =
 7493|      1|            widths.iter().sum::<f32>() + spacing.get() * widths.len().saturating_sub(1) as f32;
 7494|      1|        assert!(
 7495|      1|            !(total_width > available.get() + 1.0 && estimated_before <= available.get() + 0.5)
                                                                   ^0
  ------------------
  |  Branch (7495:15): [True: 0, False: 1]
  |  Branch (7495:54): [True: 0, False: 0]
  ------------------
 7496|       |        );
 7497|      1|        Ok(())
 7498|      1|    }
 7499|       |
 7500|       |    #[test]
 7501|      1|    fn test_trigger_link_handles_fragments_and_schemes() {
 7502|      1|        let renderer = MarkdownRenderer::new();
 7503|       |
 7504|      1|        renderer.trigger_link("#Section-One");
 7505|      1|        assert_eq!(
 7506|      1|            renderer.take_pending_anchor(),
 7507|      1|            Some("section-one".to_string())
 7508|       |        );
 7509|      1|        assert!(renderer.take_pending_anchor().is_none());
 7510|       |
 7511|      1|        renderer.trigger_link("ftp://example.com");
 7512|      1|        assert!(renderer.take_pending_anchor().is_none());
 7513|       |
 7514|      1|        renderer.trigger_link("https://example.com");
 7515|      1|        assert!(renderer.take_pending_anchor().is_none());
 7516|       |
 7517|      1|        renderer.trigger_link("mailto:hello@example.com");
 7518|      1|        assert!(renderer.take_pending_anchor().is_none());
 7519|      1|    }
 7520|       |
 7521|       |    #[test]
 7522|      1|    fn test_resolve_image_path_with_base_dir() {
 7523|      1|        let renderer = MarkdownRenderer::new();
 7524|      1|        let temp = tempdir().expect("temp dir");
 7525|      1|        renderer.set_base_dir(Some(temp.path()));
 7526|       |
 7527|      1|        let resolved = renderer.resolve_image_path("sample.png");
 7528|      1|        assert!(resolved.contains("sample.png"));
 7529|       |
 7530|      1|        let abs = temp.path().join("abs.png");
 7531|      1|        let abs_str = abs.to_string_lossy().into_owned();
 7532|      1|        assert_eq!(renderer.resolve_image_path(&abs_str), abs_str);
 7533|       |
 7534|      1|        renderer.set_base_dir(None);
 7535|      1|        assert_eq!(renderer.resolve_image_path("relative.png"), "relative.png");
 7536|      1|    }
 7537|       |
 7538|       |    #[test]
 7539|      1|    fn test_disk_image_loads_and_caches() {
 7540|      1|        let renderer = MarkdownRenderer::new();
 7541|      1|        let temp = tempdir().expect("temp dir");
 7542|      1|        let image_path = temp.path().join("disk.png");
 7543|       |
 7544|      1|        let mut img = image::RgbaImage::new(2, 2);
 7545|      4|        for pixel in img.pixels_mut() {
                                   ^1  ^1
 7546|      4|            *pixel = image::Rgba([10, 20, 30, 255]);
 7547|      4|        }
 7548|      1|        img.save(&image_path).expect("save png");
 7549|       |
 7550|      1|        renderer.set_base_dir(Some(temp.path()));
 7551|      1|        let resolved = renderer.resolve_image_path("disk.png");
 7552|      1|        with_test_ui(|ctx, ui| {
 7553|       |            // Use wait_for_image to handle async image loading
 7554|      1|            let loaded = wait_for_image(&renderer, ctx, ui, &resolved);
 7555|      1|            assert!(loaded.is_some());
 7556|      1|        });
 7557|       |
 7558|      1|        assert!(renderer.image_textures.borrow().contains_key(&resolved));
 7559|      1|    }
 7560|       |
 7561|       |    #[test]
 7562|      1|    fn test_context_menu_helpers_execute() {
 7563|      1|        let renderer = MarkdownRenderer::new();
 7564|      1|        let _actions = ForcedRenderActions::new(&[
 7565|      1|            "copy_text",
 7566|      1|            "copy_inline_code",
 7567|      1|            "copy_code_block",
 7568|      1|            "copy_code_block_lang",
 7569|      1|            "open_link",
 7570|      1|            "copy_link_text",
 7571|      1|            "copy_link_url",
 7572|      1|            "copy_cell_text",
 7573|      1|        ]);
 7574|      1|        with_test_ui(|_, ui| {
 7575|      1|            renderer.render_text_context_menu(ui, "text");
 7576|      1|            renderer.render_inline_code_context_menu(ui, "code");
 7577|      1|            renderer.render_code_block_context_menu(ui, "fn main() {}", Some("rust"));
 7578|      1|            renderer.render_link_context_menu(ui, "label", "#anchor");
 7579|      1|            renderer.render_cell_context_menu(ui, "cell");
 7580|      1|            renderer.copy_text_and_close(ui, "direct-copy");
 7581|      1|        });
 7582|      1|    }
 7583|       |
 7584|       |    #[test]
 7585|      1|    fn test_build_layout_job_covers_inline_styles() {
 7586|      1|        let renderer = MarkdownRenderer::new();
 7587|      1|        renderer.set_highlight_phrase(Some("code"));
 7588|      1|        let spans = vec![
 7589|      1|            InlineSpan::Text("plain".to_string()),
 7590|      1|            InlineSpan::Strong("bold".to_string()),
 7591|      1|            InlineSpan::Emphasis("italics".to_string()),
 7592|      1|            InlineSpan::Strikethrough("strike".to_string()),
 7593|      1|            InlineSpan::Code("code".to_string()),
 7594|      1|            InlineSpan::Link {
 7595|      1|                text: "ext".to_string(),
 7596|      1|                url: "https://example.com".to_string(),
 7597|      1|            },
 7598|      1|            InlineSpan::Link {
 7599|      1|                text: "local".to_string(),
 7600|      1|                url: "#anchor".to_string(),
 7601|      1|            },
 7602|       |        ];
 7603|       |
 7604|      1|        with_test_ui(|_, ui| {
 7605|      1|            let style = ui.style().clone();
 7606|      1|            let build = renderer.build_layout_job(&style, &spans, 200.0, false, Align::LEFT);
 7607|      1|            assert!(build.plain_text.contains("plain"));
 7608|      1|            assert_eq!(build.link_ranges.len(), 2);
 7609|      1|        });
 7610|      1|    }
 7611|       |
 7612|       |    #[test]
 7613|      1|    fn test_build_layout_job_strong_uses_override_text_color() {
 7614|      1|        let renderer = MarkdownRenderer::new();
 7615|      1|        let spans = vec![InlineSpan::Text("Header".to_string())];
 7616|      1|        let mut style = egui::Style::default();
 7617|      1|        let override_color = Color32::from_rgb(10, 20, 30);
 7618|      1|        style.visuals.override_text_color = Some(override_color);
 7619|       |
 7620|      1|        let build = renderer.build_layout_job(&style, &spans, 200.0, true, Align::LEFT);
 7621|      1|        assert!(!build.job.sections.is_empty());
 7622|      1|        assert_eq!(build.job.sections[0].format.color, override_color);
 7623|      1|    }
 7624|       |
 7625|       |    #[test]
 7626|      1|    fn test_render_inline_span_variants() {
 7627|      1|        let renderer = MarkdownRenderer::new();
 7628|      1|        let temp = tempdir().expect("temp dir");
 7629|      1|        let image_path = temp.path().join("image.png");
 7630|      1|        std::fs::write(&image_path, tiny_png_bytes()).expect("write png");
 7631|      1|        renderer.set_base_dir(Some(temp.path()));
 7632|       |
 7633|      1|        let image_span = InlineSpan::Image {
 7634|      1|            src: "image.png".to_string(),
 7635|      1|            alt: "Alt".to_string(),
 7636|      1|            title: Some("Title".to_string()),
 7637|      1|        };
 7638|      1|        let missing_span = InlineSpan::Image {
 7639|      1|            src: "missing.png".to_string(),
 7640|      1|            alt: "".to_string(),
 7641|      1|            title: None,
 7642|      1|        };
 7643|      1|        let remote_span = InlineSpan::Image {
 7644|      1|            src: "https://example.com/image.png".to_string(),
 7645|      1|            alt: "Remote".to_string(),
 7646|      1|            title: None,
 7647|      1|        };
 7648|      1|        let remote_http_span = InlineSpan::Image {
 7649|      1|            src: "http://example.com/image.png".to_string(),
 7650|      1|            alt: "RemoteHttp".to_string(),
 7651|      1|            title: None,
 7652|      1|        };
 7653|       |
 7654|      1|        let _guard = ForcedRenderActions::new(&["link_hover", "link_click", "image_hover"]);
 7655|      1|        with_test_ui(|ctx, ui| {
 7656|      1|            ui.visuals_mut().dark_mode = false;
 7657|      1|            renderer.render_inline_span(ui, &InlineSpan::Code("code".to_string()), None, None);
 7658|       |
 7659|      1|            ui.visuals_mut().dark_mode = true;
 7660|      1|            renderer.render_inline_span(ui, &InlineSpan::Text("text".to_string()), None, None);
 7661|      1|            renderer.render_inline_span(ui, &InlineSpan::Strong("bold".to_string()), None, None);
 7662|      1|            renderer.render_inline_span(
 7663|      1|                ui,
 7664|      1|                &InlineSpan::Emphasis("italic".to_string()),
 7665|      1|                None,
 7666|      1|                None,
 7667|       |            );
 7668|      1|            renderer.render_inline_span(
 7669|      1|                ui,
 7670|      1|                &InlineSpan::Strikethrough("strike".to_string()),
 7671|      1|                None,
 7672|      1|                None,
 7673|       |            );
 7674|      1|            renderer.render_inline_span(
 7675|      1|                ui,
 7676|      1|                &InlineSpan::Link {
 7677|      1|                    text: "ext".to_string(),
 7678|      1|                    url: "https://example.com".to_string(),
 7679|      1|                },
 7680|      1|                None,
 7681|      1|                None,
 7682|       |            );
 7683|      1|            renderer.render_inline_span(
 7684|      1|                ui,
 7685|      1|                &InlineSpan::Link {
 7686|      1|                    text: "local".to_string(),
 7687|      1|                    url: "#anchor".to_string(),
 7688|      1|                },
 7689|      1|                None,
 7690|      1|                None,
 7691|       |            );
 7692|      1|            let resolved = renderer.resolve_image_path("image.png");
 7693|      1|            let _loaded = wait_for_image(&renderer, ctx, ui, &resolved);
 7694|      1|            renderer.render_inline_span(ui, &image_span, None, None);
 7695|      1|            renderer.render_inline_span(ui, &missing_span, None, None);
 7696|      1|            renderer.render_inline_span(ui, &remote_span, None, None);
 7697|      1|            renderer.render_inline_span(ui, &remote_http_span, None, None);
 7698|      1|        });
 7699|      1|    }
 7700|       |
 7701|       |    #[test]
 7702|      1|    fn test_has_pending_renders_with_image_pending() {
 7703|      1|        let renderer = MarkdownRenderer::new();
 7704|      1|        assert!(!renderer.has_pending_renders());
 7705|      1|        renderer
 7706|      1|            .image_pending
 7707|      1|            .borrow_mut()
 7708|      1|            .insert("queued.png".to_string());
 7709|      1|        assert!(renderer.has_pending_renders());
 7710|      1|    }
 7711|       |
 7712|       |    #[test]
 7713|      1|    fn test_parse_lists_and_blockquotes() {
 7714|      1|        let renderer = MarkdownRenderer::new();
 7715|      1|        let md = "\
 7716|      1|- Item 1
 7717|      1|- Item 2
 7718|      1|  - Nested
 7719|      1|
 7720|      1|1. First
 7721|      1|2. Second
 7722|      1|
 7723|      1|> Quote line
 7724|      1|> > Nested quote
 7725|      1|
 7726|      1|---";
 7727|       |
 7728|      1|        let elements = renderer.parse(md).expect("parse ok");
 7729|      1|        assert!(elements
 7730|      1|            .iter()
 7731|      1|            .any(|el| matches!(el, MarkdownElement::List { ordered: false, .. })));
 7732|      1|        assert!(elements
 7733|      1|            .iter()
 7734|      2|            .any(|el| matches!(el, MarkdownElement::List { ordered: true, .. })));
                           ^1
 7735|      1|        assert!(elements
 7736|      1|            .iter()
 7737|      3|            .any(|el| matches!(el, MarkdownElement::Quote { .. })));
                           ^1
 7738|      1|        assert!(elements
 7739|      1|            .iter()
 7740|      5|            .any(|el| matches!(el, MarkdownElement::HorizontalRule)));
                           ^1
 7741|      1|    }
 7742|       |
 7743|       |    #[test]
 7744|      1|    fn test_elements_to_plain_text_variants() {
 7745|      1|        let elements = vec![
 7746|      1|            MarkdownElement::Header {
 7747|      1|                level: 1,
 7748|      1|                spans: vec![InlineSpan::Text("Title".to_string())],
 7749|      1|                id: "title".to_string(),
 7750|      1|            },
 7751|      1|            MarkdownElement::Paragraph(vec![
 7752|      1|                InlineSpan::Text("Hello".to_string()),
 7753|      1|                InlineSpan::Code("code".to_string()),
 7754|      1|            ]),
 7755|      1|            MarkdownElement::CodeBlock {
 7756|      1|                language: Some("rust".to_string()),
 7757|      1|                text: "fn main() {}".to_string(),
 7758|      1|            },
 7759|      1|            MarkdownElement::List {
 7760|      1|                ordered: false,
 7761|      1|                items: vec![ListItem {
 7762|      1|                    blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 7763|      1|                        "Item".to_string(),
 7764|      1|                    )])],
 7765|      1|                }],
 7766|      1|            },
 7767|      1|            MarkdownElement::Quote {
 7768|      1|                depth: 1,
 7769|      1|                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 7770|      1|                    "Quote".to_string(),
 7771|      1|                )])],
 7772|      1|            },
 7773|      1|            MarkdownElement::HorizontalRule,
 7774|      1|            MarkdownElement::Table {
 7775|      1|                headers: vec![vec![InlineSpan::Text("H".to_string())]],
 7776|      1|                rows: vec![vec![vec![InlineSpan::Image {
 7777|      1|                    src: "img.png".to_string(),
 7778|      1|                    alt: "Alt".to_string(),
 7779|      1|                    title: None,
 7780|      1|                }]]],
 7781|      1|                alignments: Vec::new(),
 7782|      1|            },
 7783|       |        ];
 7784|      1|        let text = MarkdownRenderer::elements_to_plain_text(&elements);
 7785|      1|        assert!(text.contains("Title"));
 7786|      1|        assert!(text.contains("Hello"));
 7787|      1|        assert!(text.contains("fn main"));
 7788|      1|        assert!(text.contains("Item"));
 7789|      1|        assert!(text.contains("Quote"));
 7790|      1|        assert!(text.contains("Alt"));
 7791|      1|    }
 7792|       |
 7793|       |    #[test]
 7794|      1|    fn test_elements_to_plain_text_image_title_and_empty_rule() {
 7795|      1|        let elements = vec![MarkdownElement::Paragraph(vec![InlineSpan::Image {
 7796|      1|            src: "img.png".to_string(),
 7797|      1|            alt: "".to_string(),
 7798|      1|            title: Some("Diagram Title".to_string()),
 7799|      1|        }])];
 7800|      1|        let text = MarkdownRenderer::elements_to_plain_text(&elements);
 7801|      1|        assert!(text.contains("Diagram Title"));
 7802|       |
 7803|      1|        let hr_only = vec![MarkdownElement::HorizontalRule];
 7804|      1|        assert_eq!(MarkdownRenderer::elements_to_plain_text(&hr_only), "");
 7805|      1|    }
 7806|       |
 7807|       |    #[test]
 7808|      1|    fn test_table_rendering_overhaul() {
 7809|      1|        let renderer = MarkdownRenderer::new();
 7810|      1|        let headers = vec![
 7811|      1|            vec![InlineSpan::Text("H1".to_string())],
 7812|      1|            vec![InlineSpan::Text("H2".to_string())],
 7813|       |        ];
 7814|      1|        let rows = vec![vec![
 7815|      1|            vec![InlineSpan::Text("Cell".to_string())],
 7816|      1|            vec![InlineSpan::Link {
 7817|      1|                text: "Link".to_string(),
 7818|      1|                url: "https://example.com".to_string(),
 7819|      1|            }],
 7820|       |        ]];
 7821|      1|        let elements = vec![MarkdownElement::Table {
 7822|      1|            headers,
 7823|      1|            rows,
 7824|      1|            alignments: Vec::new(),
 7825|      1|        }];
 7826|       |
 7827|      1|        with_test_ui(|_, ui| {
 7828|      1|            renderer.render_to_ui(ui, &elements);
 7829|      1|        });
 7830|      1|    }
 7831|       |
 7832|       |    #[test]
 7833|      1|    fn test_measure_inline_spans_and_emoji_texture() {
 7834|      1|        let renderer = MarkdownRenderer::new();
 7835|      1|        let spans = vec![
 7836|      1|            InlineSpan::Text("Hello".to_string()),
 7837|      1|            InlineSpan::Text("".to_string()),
 7838|       |        ];
 7839|       |
 7840|      1|        with_test_ui(|_, ui| {
 7841|      1|            let width = renderer.measure_inline_spans(ui, &spans);
 7842|      1|            assert!(width > 0.0);
 7843|      1|            let tex = renderer.get_or_make_emoji_texture(ui, "");
 7844|      1|            assert!(tex.size()[0] > 0);
 7845|      1|        });
 7846|       |
 7847|      1|        let img = renderer.generate_emoji_image("", 16);
 7848|      1|        assert_eq!(img.size[0], 16);
 7849|      1|    }
 7850|       |
 7851|       |    #[test]
 7852|      1|    fn test_measure_inline_spans_respects_line_breaks() {
 7853|      1|        let renderer = MarkdownRenderer::new();
 7854|      1|        let single_line = vec![InlineSpan::Text(
 7855|      1|            "Short This is a much longer line".to_string(),
 7856|      1|        )];
 7857|      1|        let multi_line = vec![InlineSpan::Text(
 7858|      1|            "Short\nThis is a much longer line".to_string(),
 7859|      1|        )];
 7860|       |
 7861|      1|        with_test_ui(|_, ui| {
 7862|      1|            let single = renderer.measure_inline_spans(ui, &single_line);
 7863|      1|            let multi = renderer.measure_inline_spans(ui, &multi_line);
 7864|      1|            assert!(multi < single);
 7865|      1|        });
 7866|      1|    }
 7867|       |
 7868|       |    #[test]
 7869|      1|    fn test_measure_inline_spans_normalizes_unicode() {
 7870|      1|        let renderer = MarkdownRenderer::new();
 7871|      1|        let unicode = vec![InlineSpan::Text("A\u{2192}B".to_string())];
 7872|      1|        let ascii = vec![InlineSpan::Text("A->B".to_string())];
 7873|       |
 7874|      1|        with_test_ui(|_, ui| {
 7875|      1|            let unicode_width = renderer.measure_inline_spans(ui, &unicode);
 7876|      1|            let ascii_width = renderer.measure_inline_spans(ui, &ascii);
 7877|      1|            assert!((unicode_width - ascii_width).abs() < 0.5);
 7878|      1|        });
 7879|      1|    }
 7880|       |
 7881|       |    #[test]
 7882|      1|    fn test_to_superscript_full_mapping() {
 7883|      1|        let input = "0123456789+-=()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#";
 7884|      1|        let out = MarkdownRenderer::to_superscript(input);
 7885|      1|        assert_eq!(out.chars().count(), input.chars().count());
 7886|      1|        assert!(out.contains('\u{2070}'));
 7887|      1|        assert!(out.contains('\u{00b9}'));
 7888|      1|        assert!(out.contains('\u{1d43}'));
 7889|      1|        assert!(out.contains('#'));
 7890|      1|    }
 7891|       |
 7892|       |    #[test]
 7893|      1|    fn test_element_plain_text_variants() {
 7894|      1|        let list = MarkdownElement::List {
 7895|      1|            ordered: false,
 7896|      1|            items: vec![ListItem {
 7897|      1|                blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 7898|      1|                    "Item".to_string(),
 7899|      1|                )])],
 7900|      1|            }],
 7901|      1|        };
 7902|      1|        let quote = MarkdownElement::Quote {
 7903|      1|            depth: 1,
 7904|      1|            blocks: vec![MarkdownElement::Paragraph(vec![InlineSpan::Text(
 7905|      1|                "Quote".to_string(),
 7906|      1|            )])],
 7907|      1|        };
 7908|      1|        let table = MarkdownElement::Table {
 7909|      1|            headers: vec![vec![InlineSpan::Text("Header".to_string())]],
 7910|      1|            rows: vec![vec![vec![InlineSpan::Text("Cell".to_string())]]],
 7911|      1|            alignments: Vec::new(),
 7912|      1|        };
 7913|       |
 7914|      1|        assert!(MarkdownRenderer::element_plain_text(&list).contains("Item"));
 7915|      1|        assert!(MarkdownRenderer::element_plain_text(&quote).contains("Quote"));
 7916|      1|        assert_eq!(
 7917|      1|            MarkdownRenderer::element_plain_text(&MarkdownElement::HorizontalRule),
 7918|       |            "---"
 7919|       |        );
 7920|      1|        assert!(MarkdownRenderer::element_plain_text(&table).contains("Header"));
 7921|      1|        assert!(MarkdownRenderer::element_plain_text(&table).contains("Cell"));
 7922|      1|    }
 7923|       |
 7924|       |    #[test]
 7925|      1|    fn test_parse_element_image_outside_paragraph() {
 7926|      1|        let renderer = MarkdownRenderer::new();
 7927|      1|        let events = vec![
 7928|      1|            Event::Start(Tag::Image(
 7929|      1|                LinkType::Inline,
 7930|      1|                "img.png".into(),
 7931|      1|                "Title".into(),
 7932|      1|            )),
 7933|      1|            Event::Text("Alt".into()),
 7934|      1|            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
 7935|       |        ];
 7936|      1|        let mut elements = Vec::new();
 7937|      1|        let mut slugs = std::collections::HashMap::new();
 7938|      1|        let next = renderer
 7939|      1|            .parse_element(&events, 0, &mut elements, &mut slugs)
 7940|      1|            .expect("parse ok");
 7941|      1|        assert_eq!(next, events.len());
 7942|      1|        assert!(matches!(
                              ^0
 7943|      1|            elements.first(),
 7944|       |            Some(MarkdownElement::Paragraph(_))
 7945|       |        ));
 7946|      1|        if let Some(MarkdownElement::Paragraph(spans)) = elements.first() {
  ------------------
  |  Branch (7946:16): [True: 1, False: 0]
  ------------------
 7947|      1|            assert!(matches!(
 7948|      1|                spans.first(),
 7949|      1|                Some(InlineSpan::Image { title: Some(t), .. }) if t == "Title"
  ------------------
  |  Branch (7949:67): [True: 1, False: 0]
  ------------------
 7950|       |            ));
 7951|      0|        }
 7952|      1|    }
 7953|       |
 7954|       |    #[test]
 7955|      1|    fn test_parse_list_event_variants() -> Result<()> {
 7956|      1|        let renderer = MarkdownRenderer::new();
 7957|      1|        let events = vec![
 7958|      1|            Event::Start(Tag::List(None)),
 7959|      1|            Event::Start(Tag::Item),
 7960|      1|            Event::Start(Tag::Emphasis),
 7961|      1|            Event::Text("em".into()),
 7962|      1|            Event::End(Tag::Emphasis),
 7963|      1|            Event::Start(Tag::Strong),
 7964|      1|            Event::Text("strong".into()),
 7965|      1|            Event::End(Tag::Strong),
 7966|      1|            Event::Start(Tag::Strikethrough),
 7967|      1|            Event::Text("strike".into()),
 7968|      1|            Event::End(Tag::Strikethrough),
 7969|      1|            Event::Start(Tag::Link(
 7970|      1|                LinkType::Inline,
 7971|      1|                "https://example.com".into(),
 7972|      1|                "".into(),
 7973|      1|            )),
 7974|      1|            Event::Text("link".into()),
 7975|      1|            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
 7976|      1|            Event::Start(Tag::Image(
 7977|      1|                LinkType::Inline,
 7978|      1|                "img.png".into(),
 7979|      1|                "Title".into(),
 7980|      1|            )),
 7981|      1|            Event::Text("alt".into()),
 7982|      1|            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
 7983|      1|            Event::Code("code".into()),
 7984|      1|            Event::Text("text".into()),
 7985|      1|            Event::SoftBreak,
 7986|      1|            Event::Start(Tag::List(Some(1))),
 7987|      1|            Event::Start(Tag::Item),
 7988|      1|            Event::Text("nested".into()),
 7989|      1|            Event::End(Tag::Item),
 7990|      1|            Event::End(Tag::List(Some(1))),
 7991|      1|            Event::End(Tag::Item),
 7992|      1|            Event::End(Tag::List(None)),
 7993|       |        ];
 7994|       |
 7995|      1|        let mut slugs = std::collections::HashMap::new();
 7996|      1|        let (items, next) = renderer.parse_list(&events, 1, &mut slugs)?;
                                                                                     ^0
 7997|      1|        assert_eq!(next, events.len());
 7998|      1|        assert_eq!(items.len(), 1);
 7999|      1|        let item = &items[0];
 8000|      1|        let spans = item
 8001|      1|            .blocks
 8002|      1|            .iter()
 8003|      1|            .find_map(|block| match block {
 8004|      1|                MarkdownElement::Paragraph(spans) => Some(spans),
 8005|      0|                _ => None,
 8006|      1|            })
 8007|      1|            .expect("paragraph block");
 8008|      1|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Emphasis(_))));
 8009|      2|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Strong(_))));
                      ^1      ^1           ^1
 8010|      1|        assert!(spans
 8011|      1|            .iter()
 8012|      3|            .any(|s| matches!(s, InlineSpan::Strikethrough(_))));
                           ^1
 8013|      4|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Link { .. })));
                      ^1      ^1           ^1
 8014|      5|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Image { .. })));
                      ^1      ^1           ^1
 8015|      6|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Code(_))));
                      ^1      ^1           ^1
 8016|      1|        assert!(item
 8017|      1|            .blocks
 8018|      1|            .iter()
 8019|      2|            .any(|block| matches!(block, MarkdownElement::List { ordered: true, .. })));
                           ^1
 8020|      1|        Ok(())
 8021|      1|    }
 8022|       |
 8023|       |    #[test]
 8024|      1|    fn test_parse_inline_spans_with_breaks_variants() -> Result<()> {
 8025|      1|        let renderer = MarkdownRenderer::new();
 8026|      1|        let events = vec![
 8027|      1|            Event::Start(Tag::Paragraph),
 8028|      1|            Event::Text("Hello".into()),
 8029|      1|            Event::SoftBreak,
 8030|      1|            Event::Code("code".into()),
 8031|      1|            Event::Start(Tag::Strong),
 8032|      1|            Event::Text("bold".into()),
 8033|      1|            Event::End(Tag::Strong),
 8034|      1|            Event::Start(Tag::Emphasis),
 8035|      1|            Event::Text("em".into()),
 8036|      1|            Event::End(Tag::Emphasis),
 8037|      1|            Event::Start(Tag::Strikethrough),
 8038|      1|            Event::Text("strike".into()),
 8039|      1|            Event::End(Tag::Strikethrough),
 8040|      1|            Event::Start(Tag::Link(
 8041|      1|                LinkType::Inline,
 8042|      1|                "https://example.com".into(),
 8043|      1|                "".into(),
 8044|      1|            )),
 8045|      1|            Event::Text("link".into()),
 8046|      1|            Event::End(Tag::Link(LinkType::Inline, "".into(), "".into())),
 8047|      1|            Event::Start(Tag::Image(
 8048|      1|                LinkType::Inline,
 8049|      1|                "img.png".into(),
 8050|      1|                "Title".into(),
 8051|      1|            )),
 8052|      1|            Event::Text("alt".into()),
 8053|      1|            Event::End(Tag::Image(LinkType::Inline, "".into(), "".into())),
 8054|      1|            Event::End(Tag::Paragraph),
 8055|       |        ];
 8056|       |
 8057|      1|        let (spans, next) =
 8058|      1|            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true)?;
                                                                                                   ^0
 8059|      1|        assert_eq!(next, events.len());
 8060|      3|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Code(_))));
                      ^1      ^1           ^1
 8061|      4|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Strong(_))));
                      ^1      ^1           ^1
 8062|      5|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Emphasis(_))));
                      ^1      ^1           ^1
 8063|      1|        assert!(spans
 8064|      1|            .iter()
 8065|      6|            .any(|s| matches!(s, InlineSpan::Strikethrough(_))));
                           ^1
 8066|      7|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Link { .. })));
                      ^1      ^1           ^1
 8067|      8|        assert!(spans.iter().any(|s| matches!(s, InlineSpan::Image { .. })));
                      ^1      ^1           ^1
 8068|      1|        assert!(spans
 8069|      1|            .iter()
 8070|      2|            .any(|s| matches!(s, InlineSpan::Text(t) if t.contains('\n'))));
                           ^1                                                        ^1
  ------------------
  |  Branch (8070:57): [True: 1, False: 1]
  ------------------
 8071|       |
 8072|      1|        let (spans_no_break, _) = renderer.parse_inline_spans(&events, 1, Tag::Paragraph)?;
                                                                                                       ^0
 8073|      1|        assert!(spans_no_break
 8074|      1|            .iter()
 8075|      1|            .any(|s| matches!(s, InlineSpan::Text(t) if t.contains(' '))));
  ------------------
  |  Branch (8075:57): [True: 1, False: 0]
  ------------------
 8076|      1|        Ok(())
 8077|      1|    }
 8078|       |
 8079|       |    #[test]
 8080|      1|    fn test_parse_inline_spans_html_breaks() -> Result<()> {
 8081|      1|        let renderer = MarkdownRenderer::new();
 8082|      1|        let events = vec![
 8083|      1|            Event::Start(Tag::Paragraph),
 8084|      1|            Event::Text("one".into()),
 8085|      1|            Event::Html("<br>".into()),
 8086|      1|            Event::Text("two".into()),
 8087|      1|            Event::End(Tag::Paragraph),
 8088|       |        ];
 8089|       |
 8090|      1|        let (spans, next) =
 8091|      1|            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true)?;
                                                                                                   ^0
 8092|      1|        assert_eq!(next, events.len());
 8093|      1|        assert!(spans
 8094|      1|            .iter()
 8095|      2|            .any(|s| matches!(s, InlineSpan::Text(t) if t == "\n")));
                           ^1                                                 ^1
  ------------------
  |  Branch (8095:57): [True: 1, False: 1]
  ------------------
 8096|       |
 8097|      1|        let (spans_no_break, _) = renderer.parse_inline_spans(&events, 1, Tag::Paragraph)?;
                                                                                                       ^0
 8098|      1|        let text = MarkdownRenderer::spans_plain_text(&spans_no_break);
 8099|      1|        assert!(text.contains("one two"));
 8100|       |
 8101|      1|        let attr_events = vec![
 8102|      1|            Event::Start(Tag::Paragraph),
 8103|      1|            Event::Text("alpha".into()),
 8104|      1|            Event::Html("<br class=\"tight\">".into()),
 8105|      1|            Event::Text("beta".into()),
 8106|      1|            Event::End(Tag::Paragraph),
 8107|       |        ];
 8108|      1|        let (spans, next) =
 8109|      1|            renderer.parse_inline_spans_with_breaks(&attr_events, 1, Tag::Paragraph, true)?;
                                                                                                        ^0
 8110|      1|        assert_eq!(next, attr_events.len());
 8111|      1|        assert!(spans
 8112|      1|            .iter()
 8113|      2|            .any(|s| matches!(s, InlineSpan::Text(t) if t == "\n")));
                           ^1                                                 ^1
  ------------------
  |  Branch (8113:57): [True: 1, False: 1]
  ------------------
 8114|       |
 8115|      1|        let strong_events = vec![
 8116|      1|            Event::Start(Tag::Paragraph),
 8117|      1|            Event::Start(Tag::Strong),
 8118|      1|            Event::Text("alpha".into()),
 8119|      1|            Event::Html("<br>".into()),
 8120|      1|            Event::Text("beta".into()),
 8121|      1|            Event::End(Tag::Strong),
 8122|      1|            Event::End(Tag::Paragraph),
 8123|       |        ];
 8124|      1|        let (spans, next) =
 8125|      1|            renderer.parse_inline_spans_with_breaks(&strong_events, 1, Tag::Paragraph, true)?;
                                                                                                          ^0
 8126|      1|        assert_eq!(next, strong_events.len());
 8127|      1|        assert!(spans
 8128|      1|            .iter()
 8129|      1|            .any(|s| { matches!(s, InlineSpan::Strong(text) if text.contains('\n')) }));
  ------------------
  |  Branch (8129:64): [True: 1, False: 0]
  ------------------
 8130|       |
 8131|      1|        let (spans_no_break, _) = renderer.parse_inline_spans(&strong_events, 1, Tag::Paragraph)?;
                                                                                                              ^0
 8132|      1|        let strong_text = spans_no_break.iter().find_map(|span| {
 8133|      1|            if let InlineSpan::Strong(text) = span {
  ------------------
  |  Branch (8133:20): [True: 1, False: 0]
  ------------------
 8134|      1|                Some(text.as_str())
 8135|       |            } else {
 8136|      0|                None
 8137|       |            }
 8138|      1|        });
 8139|      1|        assert!(matches!(strong_text, Some(text) if text.contains("alpha beta")));
  ------------------
  |  Branch (8139:53): [True: 1, False: 0]
  ------------------
 8140|      1|        Ok(())
 8141|      1|    }
 8142|       |
 8143|       |    #[test]
 8144|      1|    fn test_collect_blockquotes_nested_and_breaks() -> Result<()> {
 8145|      1|        let renderer = MarkdownRenderer::new();
 8146|      1|        let events = vec![
 8147|      1|            Event::Start(Tag::BlockQuote),
 8148|      1|            Event::Start(Tag::Paragraph),
 8149|      1|            Event::Text("Line1\nLine2".into()),
 8150|      1|            Event::End(Tag::Paragraph),
 8151|      1|            Event::SoftBreak,
 8152|      1|            Event::Start(Tag::BlockQuote),
 8153|      1|            Event::Start(Tag::Paragraph),
 8154|      1|            Event::Text("Nested".into()),
 8155|      1|            Event::End(Tag::Paragraph),
 8156|      1|            Event::End(Tag::BlockQuote),
 8157|      1|            Event::End(Tag::BlockQuote),
 8158|       |        ];
 8159|      1|        let mut slugs = HashMap::new();
 8160|      1|        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs)?;
                                                                                                  ^0
 8161|      1|        assert_eq!(next, events.len());
 8162|      1|        assert!(quotes.iter().any(|(depth, _)| *depth == 1));
 8163|      2|        assert!(quotes.iter().any(|(depth, _)| *depth == 2));
                      ^1      ^1            ^1
 8164|      1|        Ok(())
 8165|      1|    }
 8166|       |
 8167|       |    #[test]
 8168|      1|    fn test_collect_blockquotes_event_variants() -> Result<()> {
 8169|      1|        let renderer = MarkdownRenderer::new();
 8170|      1|        let events = vec![
 8171|      1|            Event::Start(Tag::BlockQuote),
 8172|      1|            Event::Start(Tag::Paragraph),
 8173|      1|            Event::Text("para".into()),
 8174|      1|            Event::End(Tag::Paragraph),
 8175|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 8176|      1|            Event::Text("Heading".into()),
 8177|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 8178|      1|            Event::Start(Tag::List(None)),
 8179|      1|            Event::Start(Tag::Item),
 8180|      1|            Event::Text("item".into()),
 8181|      1|            Event::End(Tag::Item),
 8182|      1|            Event::End(Tag::List(None)),
 8183|      1|            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8184|      1|                "rust".into(),
 8185|      1|            ))),
 8186|      1|            Event::Text("fn main() {}\n".into()),
 8187|      1|            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8188|      1|                "rust".into(),
 8189|      1|            ))),
 8190|      1|            Event::Start(Tag::Table(vec![Alignment::Left])),
 8191|      1|            Event::Start(Tag::TableHead),
 8192|      1|            Event::Start(Tag::TableRow),
 8193|      1|            Event::Start(Tag::TableCell),
 8194|      1|            Event::Text("H".into()),
 8195|      1|            Event::End(Tag::TableCell),
 8196|      1|            Event::End(Tag::TableRow),
 8197|      1|            Event::End(Tag::TableHead),
 8198|      1|            Event::Start(Tag::TableRow),
 8199|      1|            Event::Start(Tag::TableCell),
 8200|      1|            Event::Text("R".into()),
 8201|      1|            Event::End(Tag::TableCell),
 8202|      1|            Event::End(Tag::TableRow),
 8203|      1|            Event::End(Tag::Table(vec![Alignment::Left])),
 8204|      1|            Event::Start(Tag::Emphasis),
 8205|      1|            Event::Text("em".into()),
 8206|      1|            Event::End(Tag::Emphasis),
 8207|      1|            Event::Start(Tag::Strong),
 8208|      1|            Event::Text("strong".into()),
 8209|      1|            Event::End(Tag::Strong),
 8210|      1|            Event::Start(Tag::Strikethrough),
 8211|      1|            Event::Text("strike".into()),
 8212|      1|            Event::End(Tag::Strikethrough),
 8213|      1|            Event::Start(Tag::Link(
 8214|      1|                LinkType::Inline,
 8215|      1|                "https://example.com".into(),
 8216|      1|                "".into(),
 8217|      1|            )),
 8218|      1|            Event::Text("link".into()),
 8219|      1|            Event::End(Tag::Link(
 8220|      1|                LinkType::Inline,
 8221|      1|                "https://example.com".into(),
 8222|      1|                "".into(),
 8223|      1|            )),
 8224|      1|            Event::Start(Tag::Image(
 8225|      1|                LinkType::Inline,
 8226|      1|                "img.png".into(),
 8227|      1|                "Title".into(),
 8228|      1|            )),
 8229|      1|            Event::Text("alt".into()),
 8230|      1|            Event::End(Tag::Image(
 8231|      1|                LinkType::Inline,
 8232|      1|                "img.png".into(),
 8233|      1|                "Title".into(),
 8234|      1|            )),
 8235|      1|            Event::Code("code".into()),
 8236|      1|            Event::SoftBreak,
 8237|      1|            Event::HardBreak,
 8238|      1|            Event::Html("<br>".into()),
 8239|      1|            Event::Rule,
 8240|      1|            Event::Start(Tag::BlockQuote),
 8241|      1|            Event::Start(Tag::Paragraph),
 8242|      1|            Event::Text("Nested".into()),
 8243|      1|            Event::End(Tag::Paragraph),
 8244|      1|            Event::End(Tag::BlockQuote),
 8245|      1|            Event::End(Tag::BlockQuote),
 8246|       |        ];
 8247|      1|        let mut slugs = HashMap::new();
 8248|      1|        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs)?;
                                                                                                  ^0
 8249|      1|        assert_eq!(next, events.len());
 8250|      1|        assert!(!quotes.is_empty());
 8251|      1|        Ok(())
 8252|      1|    }
 8253|       |
 8254|       |    #[test]
 8255|      1|    fn test_collect_blockquotes_empty_paragraph_and_html_ignored() -> Result<()> {
 8256|      1|        let renderer = MarkdownRenderer::new();
 8257|      1|        let events = vec![
 8258|      1|            Event::Start(Tag::BlockQuote),
 8259|      1|            Event::Start(Tag::Paragraph),
 8260|      1|            Event::End(Tag::Paragraph),
 8261|      1|            Event::Html("<span>".into()),
 8262|      1|            Event::End(Tag::BlockQuote),
 8263|       |        ];
 8264|      1|        let mut slugs = HashMap::new();
 8265|      1|        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs)?;
                                                                                                  ^0
 8266|      1|        assert_eq!(next, events.len());
 8267|      1|        assert!(quotes.is_empty());
 8268|      1|        Ok(())
 8269|      1|    }
 8270|       |
 8271|       |    #[test]
 8272|      1|    fn test_collect_blockquotes_empty_unclosed_returns_empty() -> Result<()> {
 8273|      1|        let renderer = MarkdownRenderer::new();
 8274|      1|        let events = vec![Event::Start(Tag::BlockQuote)];
 8275|      1|        let mut slugs = HashMap::new();
 8276|      1|        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs)?;
                                                                                                  ^0
 8277|      1|        assert_eq!(next, events.len());
 8278|      1|        assert!(quotes.is_empty());
 8279|      1|        Ok(())
 8280|      1|    }
 8281|       |
 8282|       |    #[test]
 8283|      1|    fn test_parse_list_block_elements() -> Result<()> {
 8284|      1|        let renderer = MarkdownRenderer::new();
 8285|      1|        let events = vec![
 8286|      1|            Event::Start(Tag::List(Some(1))),
 8287|      1|            Event::Start(Tag::Item),
 8288|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H3, None, vec![])),
 8289|      1|            Event::Text("Heading".into()),
 8290|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H3, None, vec![])),
 8291|      1|            Event::Start(Tag::Table(vec![Alignment::Left])),
 8292|      1|            Event::Start(Tag::TableHead),
 8293|      1|            Event::Start(Tag::TableRow),
 8294|      1|            Event::Start(Tag::TableCell),
 8295|      1|            Event::Text("H".into()),
 8296|      1|            Event::End(Tag::TableCell),
 8297|      1|            Event::End(Tag::TableRow),
 8298|      1|            Event::End(Tag::TableHead),
 8299|      1|            Event::Start(Tag::TableRow),
 8300|      1|            Event::Start(Tag::TableCell),
 8301|      1|            Event::Text("R".into()),
 8302|      1|            Event::End(Tag::TableCell),
 8303|      1|            Event::End(Tag::TableRow),
 8304|      1|            Event::End(Tag::Table(vec![Alignment::Left])),
 8305|      1|            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8306|      1|                "rust".into(),
 8307|      1|            ))),
 8308|      1|            Event::Text("fn main() {}\n".into()),
 8309|      1|            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8310|      1|                "rust".into(),
 8311|      1|            ))),
 8312|      1|            Event::Start(Tag::BlockQuote),
 8313|      1|            Event::Start(Tag::Paragraph),
 8314|      1|            Event::Text("Quote".into()),
 8315|      1|            Event::End(Tag::Paragraph),
 8316|      1|            Event::End(Tag::BlockQuote),
 8317|      1|            Event::Rule,
 8318|      1|            Event::HardBreak,
 8319|      1|            Event::End(Tag::Item),
 8320|      1|            Event::End(Tag::List(Some(1))),
 8321|       |        ];
 8322|      1|        let mut slugs = HashMap::new();
 8323|      1|        let (items, next) = renderer.parse_list(&events, 1, &mut slugs)?;
                                                                                     ^0
 8324|      1|        assert_eq!(next, events.len());
 8325|      1|        assert_eq!(items.len(), 1);
 8326|      1|        Ok(())
 8327|      1|    }
 8328|       |
 8329|       |    #[test]
 8330|      1|    fn test_parse_element_variants() -> Result<()> {
 8331|      1|        let renderer = MarkdownRenderer::new();
 8332|      1|        let mut slugs = HashMap::new();
 8333|      1|        let mut elements = Vec::new();
 8334|       |
 8335|      1|        let paragraph = vec![
 8336|      1|            Event::Start(Tag::Paragraph),
 8337|      1|            Event::Text("para".into()),
 8338|      1|            Event::End(Tag::Paragraph),
 8339|       |        ];
 8340|      1|        let next = renderer.parse_element(&paragraph, 0, &mut elements, &mut slugs)?;
                                                                                                 ^0
 8341|      1|        assert_eq!(next, paragraph.len());
 8342|       |
 8343|      1|        let heading = vec![
 8344|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 8345|      1|            Event::Text("Heading".into()),
 8346|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 8347|       |        ];
 8348|      1|        let next = renderer.parse_element(&heading, 0, &mut elements, &mut slugs)?;
                                                                                               ^0
 8349|      1|        assert_eq!(next, heading.len());
 8350|       |
 8351|      1|        let code_block = vec![
 8352|      1|            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8353|      1|                "rust".into(),
 8354|      1|            ))),
 8355|      1|            Event::Text("fn main() {}\n".into()),
 8356|      1|            Event::End(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 8357|      1|                "rust".into(),
 8358|      1|            ))),
 8359|       |        ];
 8360|      1|        let next = renderer.parse_element(&code_block, 0, &mut elements, &mut slugs)?;
                                                                                                  ^0
 8361|      1|        assert_eq!(next, code_block.len());
 8362|       |
 8363|      1|        let list = vec![
 8364|      1|            Event::Start(Tag::List(None)),
 8365|      1|            Event::Start(Tag::Item),
 8366|      1|            Event::Text("item".into()),
 8367|      1|            Event::End(Tag::Item),
 8368|      1|            Event::End(Tag::List(None)),
 8369|       |        ];
 8370|      1|        let next = renderer.parse_element(&list, 0, &mut elements, &mut slugs)?;
                                                                                            ^0
 8371|      1|        assert_eq!(next, list.len());
 8372|       |
 8373|      1|        let quote = vec![
 8374|      1|            Event::Start(Tag::BlockQuote),
 8375|      1|            Event::Start(Tag::Paragraph),
 8376|      1|            Event::Text("quote".into()),
 8377|      1|            Event::End(Tag::Paragraph),
 8378|      1|            Event::End(Tag::BlockQuote),
 8379|       |        ];
 8380|      1|        let next = renderer.parse_element(&quote, 0, &mut elements, &mut slugs)?;
                                                                                             ^0
 8381|      1|        assert_eq!(next, quote.len());
 8382|       |
 8383|      1|        let table = vec![
 8384|      1|            Event::Start(Tag::Table(vec![Alignment::Left])),
 8385|      1|            Event::Start(Tag::TableHead),
 8386|      1|            Event::Start(Tag::TableRow),
 8387|      1|            Event::Start(Tag::TableCell),
 8388|      1|            Event::Text("H".into()),
 8389|      1|            Event::End(Tag::TableCell),
 8390|      1|            Event::End(Tag::TableRow),
 8391|      1|            Event::End(Tag::TableHead),
 8392|      1|            Event::Start(Tag::TableRow),
 8393|      1|            Event::Start(Tag::TableCell),
 8394|      1|            Event::Text("R".into()),
 8395|      1|            Event::End(Tag::TableCell),
 8396|      1|            Event::End(Tag::TableRow),
 8397|      1|            Event::End(Tag::Table(vec![Alignment::Left])),
 8398|       |        ];
 8399|      1|        let next = renderer.parse_element(&table, 0, &mut elements, &mut slugs)?;
                                                                                             ^0
 8400|      1|        assert_eq!(next, table.len());
 8401|       |
 8402|      1|        let rule = vec![Event::Rule];
 8403|      1|        let next = renderer.parse_element(&rule, 0, &mut elements, &mut slugs)?;
                                                                                            ^0
 8404|      1|        assert_eq!(next, rule.len());
 8405|      1|        Ok(())
 8406|      1|    }
 8407|       |
 8408|       |    #[test]
 8409|      1|    fn test_parse_code_block_with_language() -> Result<()> {
 8410|      1|        let renderer = MarkdownRenderer::new();
 8411|      1|        let elements = renderer.parse("```rust\nfn main() {}\n```")?;
                                                                                 ^0
 8412|      1|        assert!(elements.iter().any(|el| matches!(
 8413|      1|            el,
 8414|       |            MarkdownElement::CodeBlock {
 8415|      1|                language: Some(lang),
 8416|       |                ..
 8417|      1|            } if lang == "rust"
  ------------------
  |  Branch (8417:18): [True: 1, False: 0]
  ------------------
 8418|       |        )));
 8419|      1|        Ok(())
 8420|      1|    }
 8421|       |
 8422|       |    #[test]
 8423|      1|    fn test_parse_table_from_markdown() -> Result<()> {
 8424|      1|        let renderer = MarkdownRenderer::new();
 8425|      1|        let md = "| H1 | H2 |\n| --- | --- |\n| A | B |\n| C | D |\n";
 8426|      1|        let elements = renderer.parse(md)?;
                                                       ^0
 8427|      1|        assert!(elements
 8428|      1|            .iter()
 8429|      1|            .any(|el| matches!(el, MarkdownElement::Table { .. })));
 8430|      1|        Ok(())
 8431|      1|    }
 8432|       |
 8433|       |    #[test]
 8434|      1|    fn test_hash_inline_spans_variants() {
 8435|      1|        let spans = vec![
 8436|      1|            InlineSpan::Text("t".to_string()),
 8437|      1|            InlineSpan::Code("c".to_string()),
 8438|      1|            InlineSpan::Strong("s".to_string()),
 8439|      1|            InlineSpan::Emphasis("e".to_string()),
 8440|      1|            InlineSpan::Strikethrough("x".to_string()),
 8441|      1|            InlineSpan::Link {
 8442|      1|                text: "link".to_string(),
 8443|      1|                url: "https://example.com".to_string(),
 8444|      1|            },
 8445|      1|            InlineSpan::Image {
 8446|      1|                src: "img.png".to_string(),
 8447|      1|                alt: "alt".to_string(),
 8448|      1|                title: Some("title".to_string()),
 8449|      1|            },
 8450|       |        ];
 8451|      1|        let hash = MarkdownRenderer::hash_inline_spans(&spans);
 8452|      1|        let hash2 = MarkdownRenderer::hash_inline_spans(&[InlineSpan::Text("other".to_string())]);
 8453|      1|        assert_ne!(hash, hash2);
 8454|      1|    }
 8455|       |
 8456|       |    #[test]
 8457|      1|    fn test_highlight_segments_edge_cases() {
 8458|      1|        let renderer = MarkdownRenderer::new();
 8459|      1|        assert!(renderer.highlight_segments("", Some("a")).is_empty());
 8460|      1|        assert_eq!(
 8461|      1|            renderer.highlight_segments("abc", None),
 8462|      1|            vec![(0..3, false)]
 8463|       |        );
 8464|      1|        assert_eq!(
 8465|      1|            renderer.highlight_segments("abc", Some("")),
 8466|      1|            vec![(0..3, false)]
 8467|       |        );
 8468|      1|        let segments = renderer.highlight_segments("Hello", Some("ell"));
 8469|      1|        assert!(segments.iter().any(|(_, highlighted)| *highlighted));
 8470|      1|    }
 8471|       |
 8472|       |    #[test]
 8473|      1|    fn test_resolve_table_widths_branches() {
 8474|      1|        assert!(MarkdownRenderer::resolve_table_widths(50.0, &[], &[]).is_empty());
 8475|      1|        assert_eq!(
 8476|      1|            MarkdownRenderer::resolve_table_widths(100.0, &[10.0, 10.0], &[20.0, 30.0]),
 8477|      1|            vec![20.0, 30.0]
 8478|       |        );
 8479|       |
 8480|      1|        assert_eq!(
 8481|      1|            MarkdownRenderer::resolve_table_widths(10.0, &[0.0, 0.0], &[0.0, 0.0]),
 8482|      1|            vec![5.0, 5.0]
 8483|       |        );
 8484|       |
 8485|      1|        assert_eq!(
 8486|      1|            MarkdownRenderer::resolve_table_widths(10.0, &[10.0, 10.0], &[20.0, 20.0]),
 8487|      1|            vec![5.0, 5.0]
 8488|       |        );
 8489|       |
 8490|      1|        assert_eq!(
 8491|      1|            MarkdownRenderer::resolve_table_widths(30.0, &[10.0, 10.0], &[10.0, 10.0]),
 8492|      1|            vec![15.0, 15.0]
 8493|       |        );
 8494|       |
 8495|      1|        let widths = MarkdownRenderer::resolve_table_widths(30.0, &[10.0, 10.0], &[20.0, 30.0]);
 8496|      1|        assert_eq!(widths.len(), 2);
 8497|      1|        assert!((widths[0] + widths[1] - 30.0).abs() < 0.1);
 8498|      1|    }
 8499|       |
 8500|       |    #[test]
 8501|      1|    fn test_table_line_breaks_case_parses_all_rows() -> Result<()> {
 8502|      1|        let renderer = MarkdownRenderer::new();
 8503|      1|        let md = fs::read_to_string("tests/regression/cases/017-table-line-breaks.md")?;
                                                                                                    ^0
 8504|      1|        let elements = renderer.parse(&md)?;
                                                        ^0
 8505|      2|        let rows = elements.iter().find_map(|el| match el {
                          ^1     ^1              ^1
 8506|      1|            MarkdownElement::Table { rows, .. } => Some(rows),
 8507|      1|            _ => None,
 8508|      2|        });
 8509|      1|        let rows = rows.expect("table present");
 8510|      1|        assert_eq!(rows.len(), 7);
 8511|      1|        let plain = MarkdownRenderer::elements_to_plain_text(&elements);
 8512|      1|        assert!(plain.contains("Strong"));
 8513|      1|        assert!(plain.contains("Attr"));
 8514|      1|        Ok(())
 8515|      1|    }
 8516|       |
 8517|       |    #[test]
 8518|      1|    fn test_table_line_breaks_case_renders_all_rows() -> Result<()> {
 8519|      1|        let renderer = MarkdownRenderer::new();
 8520|      1|        let md = fs::read_to_string("tests/regression/cases/017-table-line-breaks.md")?;
                                                                                                    ^0
 8521|      1|        let elements = renderer.parse(&md)?;
                                                        ^0
 8522|      1|        with_test_ui(|ctx, ui| {
 8523|      1|            ctx.set_visuals(egui::Visuals::light());
 8524|      1|            renderer.render_to_ui(ui, &elements);
 8525|      1|        });
 8526|      1|        let (rendered, total) = renderer.table_render_stats();
 8527|      1|        assert_eq!(rendered, total);
 8528|      1|        assert_eq!(rendered, 7);
 8529|      1|        Ok(())
 8530|      1|    }
 8531|       |
 8532|       |    #[test]
 8533|      1|    fn test_table_first_column_alignment_case_parses_columns() -> Result<()> {
 8534|      1|        let renderer = MarkdownRenderer::new();
 8535|      1|        let md = fs::read_to_string("tests/regression/cases/026-table-first-column-align.md")?;
                                                                                                           ^0
 8536|      1|        let elements = renderer.parse(&md)?;
                                                        ^0
 8537|      3|        let mut tables = elements.iter().filter_map(|el| match el {
                          ^1           ^1              ^1
 8538|       |            MarkdownElement::Table {
 8539|      1|                headers,
 8540|      1|                rows,
 8541|      1|                alignments,
 8542|      1|            } => Some((headers, rows, alignments)),
 8543|      2|            _ => None,
 8544|      3|        });
 8545|      1|        let (headers, rows, alignments) = tables.next().expect("expected table");
 8546|      1|        assert_eq!(headers.len(), 3);
 8547|      1|        assert_eq!(alignments.len(), 3);
 8548|      3|        assert!(rows.iter().all(|row| row.len() == 3));
                      ^1      ^1          ^1
 8549|      1|        Ok(())
 8550|      1|    }
 8551|       |
 8552|       |    #[test]
 8553|      1|    fn test_handle_width_change_requests_repaint() {
 8554|      1|        let renderer = MarkdownRenderer::new();
 8555|      1|        let ctx = egui::Context::default();
 8556|      1|        renderer.handle_width_change(&ctx, 42, WidthChange::Large);
 8557|      1|        let metrics = renderer.table_metrics.borrow();
 8558|      1|        let entry = metrics.entry(42).expect("metrics entry");
 8559|      1|        assert!(entry.last_discard_frame.is_some());
 8560|      1|    }
 8561|       |
 8562|       |    #[test]
 8563|      1|    fn test_render_list_multiline_indent_and_empty() {
 8564|      1|        let renderer = MarkdownRenderer::new();
 8565|      1|        let spans = vec![InlineSpan::Text("First\n  Nested".to_string())];
 8566|      1|        let item = ListItem {
 8567|      1|            blocks: vec![MarkdownElement::Paragraph(spans.clone())],
 8568|      1|        };
 8569|      1|        with_test_ui(|ctx, ui| {
 8570|      1|            ctx.set_visuals(egui::Visuals::light());
 8571|      1|            renderer.render_list(ui, false, &[]);
 8572|      1|            renderer.render_list(ui, true, std::slice::from_ref(&item));
 8573|      1|        });
 8574|      1|    }
 8575|       |
 8576|       |    #[test]
 8577|      1|    fn test_render_list_paragraph_handles_blank_parts_and_indent() {
 8578|      1|        let renderer = MarkdownRenderer::new();
 8579|      1|        let spans = vec![
 8580|      1|            InlineSpan::Text("Line 1\n\n  indented".to_string()),
 8581|      1|            InlineSpan::Image {
 8582|      1|                src: "assets/emoji/1f600.png".to_string(),
 8583|      1|                alt: "img".to_string(),
 8584|      1|                title: None,
 8585|      1|            },
 8586|       |        ];
 8587|      1|        with_test_ui(|_, ui| {
 8588|      1|            renderer.render_list_paragraph(ui, None, Color32::WHITE, 12.0, &spans);
 8589|      1|        });
 8590|      1|    }
 8591|       |
 8592|       |    #[test]
 8593|      1|    fn test_render_inline_span_forced_actions_and_image_title() {
 8594|      1|        let renderer = MarkdownRenderer::new();
 8595|      1|        renderer.set_highlight_phrase(Some("hi"));
 8596|      1|        let image_span = InlineSpan::Image {
 8597|      1|            src: "assets/emoji/1f600.png".to_string(),
 8598|      1|            alt: "alt".to_string(),
 8599|      1|            title: Some("Caption".to_string()),
 8600|      1|        };
 8601|      1|        let missing_span = InlineSpan::Image {
 8602|      1|            src: "missing.png".to_string(),
 8603|      1|            alt: "missing".to_string(),
 8604|      1|            title: None,
 8605|      1|        };
 8606|      1|        let link_span = InlineSpan::Link {
 8607|      1|            text: "hi link".to_string(),
 8608|      1|            url: "https://example.com".to_string(),
 8609|      1|        };
 8610|      1|        let _guard = ForcedRenderActions::new(&["link_hover", "link_click", "image_hover"]);
 8611|      1|        with_test_ui(|_, ui| {
 8612|      1|            renderer.render_inline_span(
 8613|      1|                ui,
 8614|      1|                &InlineSpan::Text("hi \u{1f600}".to_string()),
 8615|      1|                None,
 8616|      1|                None,
 8617|       |            );
 8618|      1|            renderer.render_inline_span(ui, &InlineSpan::Strong("hi".to_string()), None, None);
 8619|      1|            renderer.render_inline_span(ui, &InlineSpan::Emphasis("hi".to_string()), None, None);
 8620|      1|            renderer.render_inline_span(
 8621|      1|                ui,
 8622|      1|                &InlineSpan::Strikethrough("hi".to_string()),
 8623|      1|                None,
 8624|      1|                None,
 8625|       |            );
 8626|      1|            renderer.render_inline_span(ui, &InlineSpan::Code("code".to_string()), None, None);
 8627|      1|            renderer.render_inline_span(ui, &link_span, None, None);
 8628|      1|            renderer.render_inline_span(ui, &image_span, None, None);
 8629|      1|            renderer.render_inline_span(ui, &missing_span, None, None);
 8630|      1|        });
 8631|      1|    }
 8632|       |
 8633|       |    #[test]
 8634|      1|    fn test_get_or_load_image_texture_embedded_and_remote() {
 8635|      1|        let renderer = MarkdownRenderer::new();
 8636|      1|        with_test_ui(|ctx, ui| {
 8637|      1|            let embedded = wait_for_image(&renderer, ctx, ui, "assets/emoji/1f600.png");
 8638|      1|            assert!(embedded.is_some());
 8639|      1|            let remote = renderer.get_or_load_image_texture(ui, "https://example.com/img.png");
 8640|      1|            assert!(remote.is_none());
 8641|      1|        });
 8642|      1|    }
 8643|       |
 8644|       |    #[test]
 8645|      1|    fn test_get_or_load_image_texture_embedded_cache_hit() {
 8646|      1|        let renderer = MarkdownRenderer::new();
 8647|      1|        with_test_ui(|ctx, ui| {
 8648|      1|            let tex = ctx.load_texture(
 8649|       |                "embedded-cache",
 8650|      1|                egui::ColorImage::new([2, 2], Color32::WHITE),
 8651|      1|                Default::default(),
 8652|       |            );
 8653|      1|            renderer.store_image_texture("assets/emoji/1f600.png", tex, [2, 2], None);
 8654|      1|            let loaded = renderer.get_or_load_image_texture(ui, "assets/emoji/1f600.png");
 8655|      1|            assert!(loaded.is_some());
 8656|      1|        });
 8657|      1|    }
 8658|       |
 8659|       |    #[test]
 8660|      1|    fn test_get_or_load_image_texture_skips_recent_failure() {
 8661|      1|        let renderer = MarkdownRenderer::new();
 8662|      1|        with_test_ui(|_, ui| {
 8663|      1|            renderer.note_image_failure("missing.png");
 8664|      1|            let loaded = renderer.get_or_load_image_texture(ui, "missing.png");
 8665|      1|            assert!(loaded.is_none());
 8666|      1|            assert!(renderer.image_failures.borrow().contains_key("missing.png"));
 8667|      1|        });
 8668|      1|    }
 8669|       |
 8670|       |    #[test]
 8671|      1|    fn test_get_or_load_image_texture_skips_pending() {
 8672|      1|        let renderer = MarkdownRenderer::new();
 8673|      1|        with_test_ui(|_, ui| {
 8674|      1|            renderer
 8675|      1|                .image_pending
 8676|      1|                .borrow_mut()
 8677|      1|                .insert("pending.png".to_string());
 8678|      1|            let loaded = renderer.get_or_load_image_texture(ui, "pending.png");
 8679|      1|            assert!(loaded.is_none());
 8680|      1|        });
 8681|      1|    }
 8682|       |
 8683|       |    #[test]
 8684|      1|    fn test_render_inline_span_loaded_image_without_title() {
 8685|      1|        let renderer = MarkdownRenderer::new();
 8686|      1|        let span = InlineSpan::Image {
 8687|      1|            src: "assets/emoji/1f600.png".to_string(),
 8688|      1|            alt: "".to_string(),
 8689|      1|            title: None,
 8690|      1|        };
 8691|      1|        with_test_ui(|ctx, ui| {
 8692|      1|            let _ = wait_for_image(&renderer, ctx, ui, "assets/emoji/1f600.png");
 8693|      1|            renderer.render_inline_span(ui, &span, None, None);
 8694|      1|        });
 8695|      1|    }
 8696|       |
 8697|       |    #[test]
 8698|      1|    fn test_get_or_make_emoji_texture_cache() {
 8699|      1|        let renderer = MarkdownRenderer::new();
 8700|      1|        with_test_ui(|_, ui| {
 8701|      1|            let tex = renderer.get_or_make_emoji_texture(ui, "\u{1f600}");
 8702|      1|            assert!(tex.size()[0] > 0);
 8703|      1|            let cached = renderer.get_or_make_emoji_texture(ui, "\u{1f600}");
 8704|      1|            assert_eq!(cached.size(), tex.size());
 8705|      1|        });
 8706|      1|    }
 8707|       |
 8708|       |    #[test]
 8709|      1|    fn test_render_overhauled_cell_fragments() {
 8710|      1|        let renderer = MarkdownRenderer::new();
 8711|      1|        let emoji_span = InlineSpan::Text("\u{1f600}".to_string());
 8712|      1|        let image_span = InlineSpan::Image {
 8713|      1|            src: "assets/emoji/1f600.png".to_string(),
 8714|      1|            alt: "alt".to_string(),
 8715|      1|            title: None,
 8716|      1|        };
 8717|      1|        with_test_ui(|_, ui| {
 8718|      1|            renderer.render_overhauled_cell(ui, &[], 120.0, false, Some(0), 0, Align::LEFT);
 8719|      1|            renderer.render_overhauled_cell(
 8720|      1|                ui,
 8721|      1|                &[emoji_span.clone(), image_span.clone()],
 8722|       |                120.0,
 8723|       |                false,
 8724|      1|                Some(1),
 8725|       |                1,
 8726|       |                Align::LEFT,
 8727|       |            );
 8728|      1|        });
 8729|      1|    }
 8730|       |
 8731|       |    #[test]
 8732|      1|    fn test_paint_table_text_job_link_interaction() {
 8733|      1|        let renderer = MarkdownRenderer::new();
 8734|      1|        let spans = vec![InlineSpan::Link {
 8735|      1|            text: "Click here for more text".to_string(),
 8736|      1|            url: "https://example.com".to_string(),
 8737|      1|        }];
 8738|      1|        let ctx = egui::Context::default();
 8739|      1|        let click_pos = egui::pos2(5.0, 5.0);
 8740|       |
 8741|      1|        let input = input_with_click(click_pos, egui::PointerButton::Secondary);
 8742|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 8743|      1|            ui.allocate_ui_at_rect(
 8744|      1|                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
 8745|      1|                |ui| {
 8746|      1|                    let build =
 8747|      1|                        renderer.build_layout_job(ui.style(), &spans, 30.0, false, Align::LEFT);
 8748|      1|                    renderer.paint_table_text_job(ui, 120.0, build);
 8749|      1|                },
 8750|       |            );
 8751|      1|        });
 8752|       |
 8753|      1|        let input = input_with_click(click_pos, egui::PointerButton::Primary);
 8754|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 8755|      1|            ui.allocate_ui_at_rect(
 8756|      1|                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
 8757|      1|                |ui| {
 8758|      1|                    let build =
 8759|      1|                        renderer.build_layout_job(ui.style(), &spans, 30.0, false, Align::LEFT);
 8760|      1|                    renderer.paint_table_text_job(ui, 120.0, build);
 8761|      1|                },
 8762|       |            );
 8763|      1|        });
 8764|      1|    }
 8765|       |
 8766|       |    #[test]
 8767|      1|    fn test_aligned_text_origin_anchors_to_rect() {
 8768|      1|        let rect = egui::Rect::from_min_size(egui::pos2(10.0, 20.0), egui::vec2(100.0, 20.0));
 8769|      1|        let galley = Arc::new(Galley {
 8770|      1|            job: Arc::new(LayoutJob::default()),
 8771|      1|            rows: Vec::new(),
 8772|      1|            elided: false,
 8773|      1|            rect: egui::Rect::from_min_max(egui::pos2(0.0, 0.0), egui::pos2(20.0, 10.0)),
 8774|      1|            mesh_bounds: egui::Rect::NOTHING,
 8775|      1|            num_vertices: 0,
 8776|      1|            num_indices: 0,
 8777|      1|            pixels_per_point: 1.0,
 8778|      1|        });
 8779|      1|        let left_origin = MarkdownRenderer::aligned_text_origin(rect, &galley, Align::LEFT);
 8780|      1|        let center_origin = MarkdownRenderer::aligned_text_origin(rect, &galley, Align::Center);
 8781|      1|        let right_origin = MarkdownRenderer::aligned_text_origin(rect, &galley, Align::RIGHT);
 8782|       |
 8783|      1|        assert_eq!(left_origin.x, rect.left());
 8784|      1|        assert_eq!(center_origin.x, rect.center().x - galley.rect.center().x);
 8785|      1|        assert_eq!(right_origin.x, rect.right() - galley.rect.right());
 8786|      1|        assert_eq!(left_origin.y, rect.top());
 8787|      1|    }
 8788|       |
 8789|       |    #[test]
 8790|      1|    fn test_layout_job_center_rect_is_origin() {
 8791|      1|        let renderer = MarkdownRenderer::new();
 8792|      1|        let spans = vec![InlineSpan::Text("Item".to_string())];
 8793|      1|        with_test_ui(|_, ui| {
 8794|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, true, Align::Center);
 8795|      1|            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
 8796|      1|            assert!(galley.rect.center().x.abs() <= 0.01);
 8797|      1|        });
 8798|      1|    }
 8799|       |
 8800|       |    #[test]
 8801|      1|    fn test_render_table_tablebuilder_variants() {
 8802|      1|        let renderer = MarkdownRenderer::new();
 8803|      1|        let headers = vec![vec![InlineSpan::Text("H1".to_string())]];
 8804|      1|        let rows = vec![vec![
 8805|      1|            vec![InlineSpan::Text("A".to_string())],
 8806|      1|            vec![InlineSpan::Text("B".to_string())],
 8807|       |        ]];
 8808|      1|        with_test_ui(|_, ui| {
 8809|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 0);
 8810|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
 8811|      1|            let empty_id = renderer.compute_table_id(&headers, &[], &[], 1);
 8812|      1|            renderer.render_table_tablebuilder(ui, &headers, &[], &[], empty_id);
 8813|      1|        });
 8814|      1|    }
 8815|       |
 8816|       |    #[test]
 8817|      1|    fn test_render_code_block_context_menu_clicks() {
 8818|      1|        let renderer = MarkdownRenderer::new();
 8819|      1|        let ctx = egui::Context::default();
 8820|      1|        let input = input_with_click(egui::pos2(5.0, 5.0), egui::PointerButton::Primary);
 8821|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 8822|      1|            ui.allocate_ui_at_rect(
 8823|      1|                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
 8824|      1|                |ui| {
 8825|      1|                    renderer.render_code_block_context_menu(ui, "code", Some("rust"));
 8826|      1|                },
 8827|       |            );
 8828|      1|        });
 8829|       |
 8830|      1|        let input = input_with_click(egui::pos2(5.0, 30.0), egui::PointerButton::Primary);
 8831|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 8832|      1|            ui.allocate_ui_at_rect(
 8833|      1|                egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(200.0, 80.0)),
 8834|      1|                |ui| {
 8835|      1|                    renderer.render_code_block_context_menu(ui, "code", Some("rust"));
 8836|      1|                },
 8837|       |            );
 8838|      1|        });
 8839|      1|    }
 8840|       |
 8841|       |    #[test]
 8842|      1|    fn test_find_syntax_for_language() {
 8843|      1|        let renderer = MarkdownRenderer::new();
 8844|      1|        assert!(renderer.find_syntax_for_language("rust").is_some());
 8845|      1|        assert!(renderer.find_syntax_for_language("nonexistent").is_none());
 8846|      1|    }
 8847|       |
 8848|       |    #[test]
 8849|      1|    fn test_find_syntax_for_language_mappings() {
 8850|      1|        let renderer = MarkdownRenderer::new();
 8851|      1|        assert!(renderer.find_syntax_for_language("markdown").is_some());
 8852|      1|        assert!(renderer.find_syntax_for_language("shell").is_some());
 8853|      1|        assert!(renderer.find_syntax_for_language("yaml").is_some());
 8854|      1|    }
 8855|       |
 8856|       |    #[test]
 8857|      1|    fn test_find_syntax_for_language_mapped_names() {
 8858|      1|        let renderer = MarkdownRenderer::new();
 8859|      1|        let langs = [
 8860|      1|            "python",
 8861|      1|            "javascript",
 8862|      1|            "typescript",
 8863|      1|            "c++",
 8864|      1|            "cpp",
 8865|      1|            "c#",
 8866|      1|            "shell",
 8867|      1|            "bash",
 8868|      1|            "powershell",
 8869|      1|            "yaml",
 8870|      1|            "markdown",
 8871|      1|            "sql",
 8872|      1|            "toml",
 8873|      1|        ];
 8874|     14|        for lang in langs {
                          ^13
 8875|     13|            let _ = renderer.find_syntax_for_language(lang);
 8876|     13|        }
 8877|      1|    }
 8878|       |
 8879|       |    #[test]
 8880|      1|    fn test_estimate_table_image_height_with_title() {
 8881|      1|        let renderer = MarkdownRenderer::new();
 8882|      1|        let span = InlineSpan::Image {
 8883|      1|            src: "assets/samples/logo.svg".to_string(),
 8884|      1|            alt: "logo".to_string(),
 8885|      1|            title: Some("Caption".to_string()),
 8886|      1|        };
 8887|      1|        with_test_ui(|_, ui| {
 8888|      1|            let height = renderer.estimate_table_image_height(ui, &span, 120.0);
 8889|      1|            assert!(height > 0.0);
 8890|      1|            let fallback = renderer.estimate_table_image_height(
 8891|      1|                ui,
 8892|      1|                &InlineSpan::Text("text".to_string()),
 8893|       |                120.0,
 8894|       |            );
 8895|      1|            assert!(fallback > 0.0);
 8896|      1|        });
 8897|      1|    }
 8898|       |
 8899|       |    #[test]
 8900|      1|    fn test_render_table_emoji() {
 8901|      1|        let renderer = MarkdownRenderer::new();
 8902|      1|        with_test_ui(|_, ui| {
 8903|      1|            renderer.render_table_emoji(ui, "\u{1f600}");
 8904|      1|        });
 8905|      1|    }
 8906|       |
 8907|       |    #[test]
 8908|      1|    fn test_render_list_block_non_paragraph() {
 8909|      1|        let renderer = MarkdownRenderer::new();
 8910|      1|        let block = MarkdownElement::CodeBlock {
 8911|      1|            language: Some("rust".to_string()),
 8912|      1|            text: "fn main() {}".to_string(),
 8913|      1|        };
 8914|      1|        with_test_ui(|_, ui| {
 8915|      1|            renderer.render_list_block(ui, &block, 12.0, Color32::WHITE);
 8916|      1|        });
 8917|      1|    }
 8918|       |
 8919|       |    #[test]
 8920|      1|    fn test_measure_inline_spans_with_image() {
 8921|      1|        let renderer = MarkdownRenderer::new();
 8922|      1|        let spans = vec![InlineSpan::Image {
 8923|      1|            src: "assets/samples/logo.svg".to_string(),
 8924|      1|            alt: "logo".to_string(),
 8925|      1|            title: None,
 8926|      1|        }];
 8927|      1|        with_test_ui(|_, ui| {
 8928|      1|            let width = renderer.measure_inline_spans(ui, &spans);
 8929|      1|            assert!(width > 0.0);
 8930|      1|        });
 8931|      1|    }
 8932|       |
 8933|       |    #[test]
 8934|      1|    fn test_parse_blockquote_with_nested_blocks() {
 8935|      1|        let renderer = MarkdownRenderer::new();
 8936|      1|        let md = r#"> # Quote Heading
 8937|      1|> Paragraph **bold** *em* ~~strike~~ [link](https://example.com)
 8938|      1|> ![alt](assets/samples/logo.svg "Logo")
 8939|      1|> - Item one
 8940|      1|>   - Nested item
 8941|      1|> 
 8942|      1|> ```rust
 8943|      1|> let x = 1;
 8944|      1|> ```
 8945|      1|> 
 8946|      1|> | H1 | H2 |
 8947|      1|> | --- | --- |
 8948|      1|> |  | ![a](assets/samples/logo.svg "Img") |
 8949|      1|"#;
 8950|      1|        let elements = renderer.parse(md).expect("parse");
 8951|      1|        assert!(elements
 8952|      1|            .iter()
 8953|      1|            .any(|e| matches!(e, MarkdownElement::Quote { .. })));
 8954|      1|    }
 8955|       |
 8956|       |    #[test]
 8957|      1|    fn test_parse_list_with_heading_and_table() {
 8958|      1|        let renderer = MarkdownRenderer::new();
 8959|      1|        let md = r#"- # Item heading
 8960|      1|  Paragraph text with `code` and **strong**
 8961|      1|  - Nested child
 8962|      1|- | A | B |
 8963|      1|  | - | - |
 8964|      1|  | 1 | 2 |
 8965|      1|- ```rust
 8966|      1|  fn main() {}
 8967|      1|  ```
 8968|      1|- > Quote in list
 8969|      1|- ---
 8970|      1|"#;
 8971|      1|        let elements = renderer.parse(md).expect("parse");
 8972|      1|        assert!(elements
 8973|      1|            .iter()
 8974|      1|            .any(|e| matches!(e, MarkdownElement::List { .. })));
 8975|      1|    }
 8976|       |
 8977|       |    #[test]
 8978|      1|    fn test_parse_list_inline_variants() {
 8979|      1|        let renderer = MarkdownRenderer::new();
 8980|      1|        let md = r#"- Item with *em* **strong** ~~strike~~ `code` [link](https://example.com) ![alt](assets/emoji/1f600.png "title")  
 8981|      1|  next line"#;
 8982|      1|        let elements = renderer.parse(md).expect("parse");
 8983|      1|        assert!(elements
 8984|      1|            .iter()
 8985|      1|            .any(|e| matches!(e, MarkdownElement::List { .. })));
 8986|      1|    }
 8987|       |
 8988|       |    #[test]
 8989|      1|    fn test_parse_blockquote_with_varied_content() -> Result<()> {
 8990|      1|        let renderer = MarkdownRenderer::new();
 8991|      1|        let md = r#"
 8992|      1|> ### Quote Heading
 8993|      1|> Paragraph with *em* **strong** ~~strike~~ `code` [link](https://example.com) ![alt](assets/emoji/1f600.png "title")  
 8994|      1|> Next line<br>
 8995|      1|>
 8996|      1|> - item one
 8997|      1|> - item two
 8998|      1|>
 8999|      1|> | h1 | h2 |
 9000|      1|> | --- | --- |
 9001|      1|> | a | b |
 9002|      1|>
 9003|      1|> ```rust
 9004|      1|> fn main() {
 9005|      1|>     // comment
 9006|      1|> }
 9007|      1|> ```
 9008|      1|>
 9009|      1|> > Nested quote
 9010|      1|>
 9011|      1|> ---
 9012|      1|"#;
 9013|      1|        let elements = renderer.parse(md)?;
                                                       ^0
 9014|      1|        assert!(elements
 9015|      1|            .iter()
 9016|      1|            .any(|e| matches!(e, MarkdownElement::Quote { .. })));
 9017|      1|        Ok(())
 9018|      1|    }
 9019|       |
 9020|       |    #[test]
 9021|      1|    fn test_find_syntax_for_language_variants() {
 9022|      1|        let renderer = MarkdownRenderer::new();
 9023|      1|        assert!(renderer.find_syntax_for_language("rs").is_some());
 9024|      1|        let cs_ext = renderer.syntax_set.find_syntax_by_extension("cs");
 9025|      1|        let cs_lang = renderer.find_syntax_for_language("csharp");
 9026|      1|        assert_eq!(cs_lang.is_some(), cs_ext.is_some());
 9027|      1|        let ps_ext = renderer.syntax_set.find_syntax_by_extension("ps1");
 9028|      1|        let ps_lang = renderer.find_syntax_for_language("powershell");
 9029|      1|        assert_eq!(ps_lang.is_some(), ps_ext.is_some());
 9030|      1|        assert!(renderer.find_syntax_for_language("madeuplang").is_none());
 9031|      1|    }
 9032|       |
 9033|       |    #[test]
 9034|      1|    fn test_generate_emoji_image_variants() {
 9035|      1|        let renderer = MarkdownRenderer::new();
 9036|      1|        let emojis = [
 9037|      1|            "\u{1f389}",
 9038|      1|            "\u{2705}",
 9039|      1|            "\u{1f680}",
 9040|      1|            "\u{1f642}",
 9041|      1|            "\u{1f600}",
 9042|      1|            "\u{1f609}",
 9043|      1|            "\u{2b50}",
 9044|      1|            "\u{1f525}",
 9045|      1|            "\u{1f44d}",
 9046|      1|            "\u{1f44e}",
 9047|      1|            "\u{1f4a1}",
 9048|      1|            "\u{2753}",
 9049|      1|            "\u{2757}",
 9050|      1|            "\u{1f4dd}",
 9051|      1|            "\u{1f9e0}",
 9052|      1|            "\u{1f9ea}",
 9053|      1|            "\u{1f4e6}",
 9054|      1|            "\u{1f527}",
 9055|      1|            "x",
 9056|      1|        ];
 9057|     20|        for emoji in emojis {
                          ^19
 9058|     19|            let image = renderer.generate_emoji_image(emoji, 8);
 9059|     19|            assert_eq!(image.size, [8, 8]);
 9060|       |        }
 9061|      1|    }
 9062|       |
 9063|       |    #[test]
 9064|      1|    fn test_measure_inline_spans_code_and_image() {
 9065|      1|        let renderer = MarkdownRenderer::new();
 9066|      1|        with_test_ui(|ctx, ui| {
 9067|      1|            let tex = ctx.load_texture(
 9068|       |                "test-image",
 9069|      1|                egui::ColorImage::new([2, 2], Color32::WHITE),
 9070|       |                egui::TextureOptions::LINEAR,
 9071|       |            );
 9072|      1|            renderer.image_textures.borrow_mut().insert(
 9073|      1|                "image.png".to_string(),
 9074|      1|                ImageCacheEntry {
 9075|      1|                    texture: tex,
 9076|      1|                    size: [64, 32],
 9077|      1|                    modified: None,
 9078|      1|                },
 9079|      1|            );
 9080|      1|            let spans = vec![
 9081|      1|                InlineSpan::Text("Hello".to_string()),
 9082|      1|                InlineSpan::Code("line1\nline2".to_string()),
 9083|      1|                InlineSpan::Image {
 9084|      1|                    src: "image.png".to_string(),
 9085|      1|                    alt: "Alt".to_string(),
 9086|      1|                    title: None,
 9087|      1|                },
 9088|       |            ];
 9089|      1|            let width = renderer.measure_inline_spans(ui, &spans);
 9090|      1|            assert!(width > 0.0);
 9091|      1|        });
 9092|      1|    }
 9093|       |
 9094|       |    #[test]
 9095|      1|    fn test_get_or_load_image_texture_cache_and_remote() -> Result<()> {
 9096|      1|        let renderer = MarkdownRenderer::new();
 9097|      1|        with_test_ui(|_, ui| {
 9098|      1|            assert!(renderer
 9099|      1|                .get_or_load_image_texture(ui, "https://example.com/logo.png")
 9100|      1|                .is_none());
 9101|      1|        });
 9102|       |
 9103|      1|        let temp = tempdir()?;
                                          ^0
 9104|      1|        let image_path = temp.path().join("image.png");
 9105|      1|        std::fs::write(&image_path, tiny_png_bytes())?;
                                                                   ^0
 9106|      1|        let resolved = image_path.to_string_lossy().to_string();
 9107|      1|        with_test_ui(|ctx, ui| {
 9108|      1|            let first = wait_for_image(&renderer, ctx, ui, &resolved);
 9109|      1|            assert!(first.is_some());
 9110|      1|            let second = renderer.get_or_load_image_texture(ui, &resolved);
 9111|      1|            assert!(second.is_some());
 9112|      1|        });
 9113|      1|        Ok(())
 9114|      1|    }
 9115|       |
 9116|       |    #[test]
 9117|      1|    fn test_render_table_tablebuilder_policy_mix() {
 9118|      1|        let renderer = MarkdownRenderer::new();
 9119|      1|        let headers = vec![
 9120|      1|            vec![InlineSpan::Text("Version".to_string())],
 9121|      1|            vec![InlineSpan::Text("Author".to_string())],
 9122|      1|            vec![InlineSpan::Text("Notes".to_string())],
 9123|      1|            vec![InlineSpan::Text("Example".to_string())],
 9124|      1|            vec![InlineSpan::Text("Misc".to_string())],
 9125|       |        ];
 9126|      1|        let rows = vec![vec![
 9127|      1|            vec![InlineSpan::Text("1".to_string())],
 9128|      1|            vec![InlineSpan::Text("Ada".to_string())],
 9129|      1|            vec![InlineSpan::Text("Line 1\nLine 2".to_string())],
 9130|      1|            vec![InlineSpan::Image {
 9131|      1|                src: "image.png".to_string(),
 9132|      1|                alt: "Alt".to_string(),
 9133|      1|                title: Some("Title".to_string()),
 9134|      1|            }],
 9135|      1|            vec![InlineSpan::Link {
 9136|      1|                text: "Link".to_string(),
 9137|      1|                url: "https://example.com".to_string(),
 9138|      1|            }],
 9139|       |        ]];
 9140|       |
 9141|      1|        let ctx = egui::Context::default();
 9142|      1|        let input = egui::RawInput {
 9143|      1|            screen_rect: Some(egui::Rect::from_min_size(
 9144|      1|                egui::pos2(0.0, 0.0),
 9145|      1|                egui::vec2(1200.0, 720.0),
 9146|      1|            )),
 9147|      1|            ..Default::default()
 9148|      1|        };
 9149|      1|        run_frame_with_input(&ctx, input, |ctx, ui| {
 9150|      1|            let tex = ctx.load_texture(
 9151|       |                "table-image",
 9152|      1|                egui::ColorImage::new([2, 2], Color32::WHITE),
 9153|       |                egui::TextureOptions::LINEAR,
 9154|       |            );
 9155|      1|            renderer.image_textures.borrow_mut().insert(
 9156|      1|                "image.png".to_string(),
 9157|      1|                ImageCacheEntry {
 9158|      1|                    texture: tex,
 9159|      1|                    size: [120, 80],
 9160|      1|                    modified: None,
 9161|      1|                },
 9162|      1|            );
 9163|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 12);
 9164|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
 9165|      1|        });
 9166|      1|        let input = egui::RawInput {
 9167|      1|            screen_rect: Some(egui::Rect::from_min_size(
 9168|      1|                egui::pos2(0.0, 0.0),
 9169|      1|                egui::vec2(1200.0, 720.0),
 9170|      1|            )),
 9171|      1|            ..Default::default()
 9172|      1|        };
 9173|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 9174|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 12);
 9175|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
 9176|      1|        });
 9177|      1|    }
 9178|       |
 9179|       |    #[test]
 9180|      1|    fn test_render_table_tablebuilder_extra_columns() {
 9181|      1|        let renderer = MarkdownRenderer::new();
 9182|      1|        let headers = vec![vec![InlineSpan::Text("H1".to_string())]];
 9183|      1|        let rows = vec![vec![
 9184|      1|            vec![InlineSpan::Text("C1".to_string())],
 9185|      1|            vec![InlineSpan::Text("C2".to_string())],
 9186|      1|            vec![InlineSpan::Text("C3".to_string())],
 9187|       |        ]];
 9188|      1|        with_test_ui(|_, ui| {
 9189|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 13);
 9190|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
 9191|      1|        });
 9192|      1|    }
 9193|       |
 9194|       |    #[test]
 9195|      1|    fn test_render_table_tablebuilder_forced_policies() {
 9196|      1|        let renderer = MarkdownRenderer::new();
 9197|      1|        let _forced = ForcedTablePolicies::new(vec![
 9198|      1|            ColumnPolicy::Auto,
 9199|      1|            ColumnPolicy::Fixed {
 9200|      1|                width: 120.0,
 9201|      1|                clip: true,
 9202|      1|            },
 9203|      1|            ColumnPolicy::Resizable {
 9204|      1|                min: 60.0,
 9205|      1|                preferred: 120.0,
 9206|      1|                clip: true,
 9207|      1|            },
 9208|      1|            ColumnPolicy::Remainder { clip: true },
 9209|       |        ]);
 9210|      1|        let headers = vec![
 9211|      1|            vec![InlineSpan::Text("A".to_string())],
 9212|      1|            vec![InlineSpan::Text("B".to_string())],
 9213|      1|            vec![InlineSpan::Text("C".to_string())],
 9214|      1|            vec![InlineSpan::Text("D".to_string())],
 9215|       |        ];
 9216|      1|        let rows = vec![vec![
 9217|      1|            vec![InlineSpan::Text("1".to_string())],
 9218|      1|            vec![InlineSpan::Text("2".to_string())],
 9219|      1|            vec![InlineSpan::Text("3".to_string())],
 9220|      1|            vec![InlineSpan::Text("4".to_string())],
 9221|       |        ]];
 9222|      1|        with_test_ui(|_, ui| {
 9223|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 14);
 9224|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
 9225|      1|        });
 9226|      1|    }
 9227|       |
 9228|       |    #[test]
 9229|      1|    fn test_render_table_tablebuilder_scaled_down_min_flex() {
 9230|      1|        let renderer = MarkdownRenderer::new();
 9231|      1|        let headers = vec![
 9232|      1|            vec![InlineSpan::Text("Notes".to_string())],
 9233|      1|            vec![InlineSpan::Text("Summary".to_string())],
 9234|      1|            vec![InlineSpan::Text("Details".to_string())],
 9235|       |        ];
 9236|      1|        let rows = vec![vec![
 9237|      1|            vec![InlineSpan::Text("Long text 1".to_string())],
 9238|      1|            vec![InlineSpan::Text("Long text 2".to_string())],
 9239|      1|            vec![InlineSpan::Text("Long text 3".to_string())],
 9240|       |        ]];
 9241|      1|        let ctx = egui::Context::default();
 9242|      1|        let input = egui::RawInput {
 9243|      1|            screen_rect: Some(egui::Rect::from_min_size(
 9244|      1|                egui::pos2(0.0, 0.0),
 9245|      1|                egui::vec2(120.0, 120.0),
 9246|      1|            )),
 9247|      1|            ..Default::default()
 9248|      1|        };
 9249|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 9250|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 15);
 9251|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
 9252|      1|        });
 9253|      1|    }
 9254|       |
 9255|       |    #[test]
 9256|      1|    fn test_render_list_variants() {
 9257|      1|        let renderer = MarkdownRenderer::new();
 9258|      1|        let items = vec![
 9259|      1|            ListItem {
 9260|      1|                blocks: vec![MarkdownElement::Header {
 9261|      1|                    level: 2,
 9262|      1|                    spans: vec![InlineSpan::Text("Header".to_string())],
 9263|      1|                    id: "header".to_string(),
 9264|      1|                }],
 9265|      1|            },
 9266|      1|            ListItem { blocks: vec![] },
 9267|       |        ];
 9268|      1|        with_test_ui(|_, ui| {
 9269|      1|            renderer.render_list(ui, false, &items);
 9270|      1|            renderer.render_list(ui, true, &items);
 9271|      1|            renderer.render_list(ui, false, &[]);
 9272|      1|        });
 9273|      1|    }
 9274|       |
 9275|       |    #[test]
 9276|      1|    fn test_render_element_body_header_levels() {
 9277|      1|        let renderer = MarkdownRenderer::new();
 9278|      1|        with_test_ui(|_, ui| {
 9279|      5|            for level in 3..=6 {
                              ^4
 9280|      4|                let element = MarkdownElement::Header {
 9281|      4|                    level,
 9282|      4|                    spans: vec![InlineSpan::Text(format!("H{}", level))],
 9283|      4|                    id: format!("h{}", level),
 9284|      4|                };
 9285|      4|                renderer.render_element_body(ui, &element);
 9286|      4|            }
 9287|      1|        });
 9288|      1|    }
 9289|       |
 9290|       |    #[test]
 9291|      1|    fn test_render_table_tablebuilder_hscroll() {
 9292|      1|        let renderer = MarkdownRenderer::new();
 9293|      1|        let headers: Vec<Vec<InlineSpan>> = (0..8)
 9294|      8|            .map(|i| vec![InlineSpan::Text(format!("H{}", i + 1))])
                           ^1
 9295|      1|            .collect();
 9296|      1|        let row: Vec<Vec<InlineSpan>> = (0..8)
 9297|      8|            .map(|i| vec![InlineSpan::Text(format!("col{}", i + 1))])
                           ^1
 9298|      1|            .collect();
 9299|      1|        let rows = vec![row];
 9300|      1|        let ctx = egui::Context::default();
 9301|      1|        let input = egui::RawInput {
 9302|      1|            screen_rect: Some(egui::Rect::from_min_size(
 9303|      1|                egui::pos2(0.0, 0.0),
 9304|      1|                egui::vec2(200.0, 120.0),
 9305|      1|            )),
 9306|      1|            ..Default::default()
 9307|      1|        };
 9308|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 9309|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 10);
 9310|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
 9311|      1|        });
 9312|      1|    }
 9313|       |
 9314|       |    #[test]
 9315|      1|    fn test_render_table_tablebuilder_scaled_down() {
 9316|      1|        let renderer = MarkdownRenderer::new();
 9317|      1|        let headers = vec![
 9318|      1|            vec![InlineSpan::Text("Wide Header One".to_string())],
 9319|      1|            vec![InlineSpan::Text("Wide Header Two".to_string())],
 9320|       |        ];
 9321|      1|        let long_text = "W".repeat(80);
 9322|      1|        let rows = vec![vec![
 9323|      1|            vec![InlineSpan::Text(long_text.clone())],
 9324|      1|            vec![InlineSpan::Text(long_text)],
 9325|       |        ]];
 9326|      1|        let ctx = egui::Context::default();
 9327|      1|        let input = egui::RawInput {
 9328|      1|            screen_rect: Some(egui::Rect::from_min_size(
 9329|      1|                egui::pos2(0.0, 0.0),
 9330|      1|                egui::vec2(180.0, 120.0),
 9331|      1|            )),
 9332|      1|            ..Default::default()
 9333|      1|        };
 9334|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 9335|      1|            let table_id = renderer.compute_table_id(&headers, &rows, &[], 11);
 9336|      1|            renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
 9337|      1|        });
 9338|      1|    }
 9339|       |
 9340|       |    #[test]
 9341|      1|    fn test_list_marker_info_any_indent_variants() {
 9342|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("").is_none());
 9343|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("   ").is_none());
 9344|       |
 9345|      1|        let (rest, indent, content_indent, leading_cols) =
 9346|      1|            MarkdownRenderer::list_marker_info_any_indent(" 1. item").expect("marker");
 9347|      1|        assert_eq!(rest, "item");
 9348|      1|        assert_eq!(indent, 1);
 9349|      1|        assert_eq!(content_indent, 4);
 9350|      1|        assert_eq!(leading_cols, 1);
 9351|       |
 9352|      1|        let (rest, indent, content_indent, leading_cols) =
 9353|      1|            MarkdownRenderer::list_marker_info_any_indent("2)\titem").expect("marker");
 9354|      1|        assert_eq!(rest, "item");
 9355|      1|        assert_eq!(indent, 2);
 9356|      1|        assert_eq!(content_indent, 4);
 9357|      1|        assert_eq!(leading_cols, 0);
 9358|      1|    }
 9359|       |
 9360|       |    #[test]
 9361|      1|    fn test_list_marker_info_any_indent_requires_trailing_space() {
 9362|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("-").is_none());
 9363|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("   -").is_none());
 9364|      1|    }
 9365|       |
 9366|       |    #[test]
 9367|      1|    fn test_list_marker_info_any_indent_rejects_missing_whitespace() {
 9368|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("1.item").is_none());
 9369|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("1)item").is_none());
 9370|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("1item").is_none());
 9371|      1|    }
 9372|       |
 9373|       |    #[test]
 9374|      1|    fn test_collect_until_tag_end_breaks_and_code() -> Result<()> {
 9375|      1|        let renderer = MarkdownRenderer::new();
 9376|      1|        let events = vec![
 9377|      1|            Event::Start(Tag::Emphasis),
 9378|      1|            Event::Text("alpha".into()),
 9379|      1|            Event::Code("beta".into()),
 9380|      1|            Event::SoftBreak,
 9381|      1|            Event::Html("<br>".into()),
 9382|      1|            Event::HardBreak,
 9383|      1|            Event::Html("<span>".into()),
 9384|      1|            Event::End(Tag::Emphasis),
 9385|       |        ];
 9386|      1|        let (text, next) = renderer.collect_until_tag_end(&events, 1, Tag::Emphasis, true)?;
                                                                                                        ^0
 9387|      1|        assert_eq!(next, events.len());
 9388|      1|        assert_eq!(text, "alphabeta\n\n\n");
 9389|       |
 9390|      1|        let (text, next) = renderer.collect_until_tag_end(&events, 1, Tag::Emphasis, false)?;
                                                                                                         ^0
 9391|      1|        assert_eq!(next, events.len());
 9392|      1|        assert_eq!(text, "alphabeta   ");
 9393|       |
 9394|      1|        let unclosed = vec![Event::Text("tail".into()), Event::SoftBreak];
 9395|      1|        let (text, next) = renderer.collect_until_tag_end(&unclosed, 0, Tag::Emphasis, true)?;
                                                                                                          ^0
 9396|      1|        assert_eq!(next, unclosed.len());
 9397|      1|        assert_eq!(text, "tail\n");
 9398|      1|        Ok(())
 9399|      1|    }
 9400|       |
 9401|       |    #[test]
 9402|      1|    fn test_parse_inline_spans_with_breaks_link_image_and_unclosed() -> Result<()> {
 9403|      1|        let renderer = MarkdownRenderer::new();
 9404|      1|        let events = vec![
 9405|      1|            Event::Start(Tag::Paragraph),
 9406|      1|            Event::Start(Tag::Link(
 9407|      1|                LinkType::Inline,
 9408|      1|                "https://example.com".into(),
 9409|      1|                "".into(),
 9410|      1|            )),
 9411|      1|            Event::Text("link".into()),
 9412|      1|            Event::End(Tag::Link(
 9413|      1|                LinkType::Inline,
 9414|      1|                "https://example.com".into(),
 9415|      1|                "".into(),
 9416|      1|            )),
 9417|      1|            Event::Start(Tag::Image(
 9418|      1|                LinkType::Inline,
 9419|      1|                "img.png".into(),
 9420|      1|                "Title".into(),
 9421|      1|            )),
 9422|      1|            Event::Text("alt".into()),
 9423|      1|            Event::End(Tag::Image(
 9424|      1|                LinkType::Inline,
 9425|      1|                "img.png".into(),
 9426|      1|                "Title".into(),
 9427|      1|            )),
 9428|      1|            Event::FootnoteReference("note".into()),
 9429|      1|            Event::End(Tag::Paragraph),
 9430|       |        ];
 9431|      1|        let (spans, next) =
 9432|      1|            renderer.parse_inline_spans_with_breaks(&events, 1, Tag::Paragraph, true)?;
                                                                                                   ^0
 9433|      1|        assert_eq!(next, events.len());
 9434|      1|        assert!(spans
 9435|      1|            .iter()
 9436|      1|            .any(|span| matches!(span, InlineSpan::Link { .. })));
 9437|      1|        assert!(spans
 9438|      1|            .iter()
 9439|      2|            .any(|span| matches!(span, InlineSpan::Image { .. })));
                           ^1
 9440|       |
 9441|      1|        let unclosed = vec![Event::Text("tail".into())];
 9442|      1|        let (spans, next) =
 9443|      1|            renderer.parse_inline_spans_with_breaks(&unclosed, 0, Tag::Paragraph, true)?;
                                                                                                     ^0
 9444|      1|        assert_eq!(next, unclosed.len());
 9445|      1|        assert_eq!(MarkdownRenderer::spans_plain_text(&spans), "tail");
 9446|      1|        Ok(())
 9447|      1|    }
 9448|       |
 9449|       |    #[test]
 9450|      1|    fn test_parse_list_inline_variants_unclosed() -> Result<()> {
 9451|      1|        let renderer = MarkdownRenderer::new();
 9452|      1|        let events = vec![
 9453|      1|            Event::Start(Tag::List(Some(1))),
 9454|      1|            Event::Text("skip".into()),
 9455|      1|            Event::Start(Tag::Item),
 9456|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 9457|      1|            Event::Text("Dup".into()),
 9458|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 9459|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 9460|      1|            Event::Text("Dup".into()),
 9461|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 9462|      1|            Event::Start(Tag::Emphasis),
 9463|      1|            Event::Text("em".into()),
 9464|      1|            Event::End(Tag::Emphasis),
 9465|      1|            Event::Start(Tag::Strong),
 9466|      1|            Event::Text("strong".into()),
 9467|      1|            Event::End(Tag::Strong),
 9468|      1|            Event::Start(Tag::Strikethrough),
 9469|      1|            Event::Text("strike".into()),
 9470|      1|            Event::End(Tag::Strikethrough),
 9471|      1|            Event::Start(Tag::Link(
 9472|      1|                LinkType::Inline,
 9473|      1|                "https://example.com".into(),
 9474|      1|                "".into(),
 9475|      1|            )),
 9476|      1|            Event::Text("link".into()),
 9477|      1|            Event::End(Tag::Link(
 9478|      1|                LinkType::Inline,
 9479|      1|                "https://example.com".into(),
 9480|      1|                "".into(),
 9481|      1|            )),
 9482|      1|            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
 9483|      1|            Event::Text("alt".into()),
 9484|      1|            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
 9485|      1|            Event::Text("tail".into()),
 9486|      1|            Event::SoftBreak,
 9487|      1|            Event::FootnoteReference("note".into()),
 9488|       |        ];
 9489|      1|        let mut slugs = HashMap::new();
 9490|      1|        let (items, next) = renderer.parse_list(&events, 1, &mut slugs)?;
                                                                                     ^0
 9491|      1|        assert_eq!(next, events.len());
 9492|      1|        assert_eq!(items.len(), 1);
 9493|      1|        Ok(())
 9494|      1|    }
 9495|       |
 9496|       |    #[test]
 9497|      1|    fn test_collect_blockquotes_unclosed_variants() -> Result<()> {
 9498|      1|        let renderer = MarkdownRenderer::new();
 9499|      1|        let events = vec![
 9500|      1|            Event::Start(Tag::BlockQuote),
 9501|      1|            Event::Text("plain".into()),
 9502|      1|            Event::Code("code".into()),
 9503|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 9504|      1|            Event::Text("Dup".into()),
 9505|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 9506|      1|            Event::Start(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 9507|      1|            Event::Text("Dup".into()),
 9508|      1|            Event::End(Tag::Heading(pulldown_cmark::HeadingLevel::H2, None, vec![])),
 9509|      1|            Event::Start(Tag::Link(
 9510|      1|                LinkType::Inline,
 9511|      1|                "https://example.com".into(),
 9512|      1|                "".into(),
 9513|      1|            )),
 9514|      1|            Event::Text("link".into()),
 9515|      1|            Event::End(Tag::Link(
 9516|      1|                LinkType::Inline,
 9517|      1|                "https://example.com".into(),
 9518|      1|                "".into(),
 9519|      1|            )),
 9520|      1|            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
 9521|      1|            Event::Text("alt".into()),
 9522|      1|            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
 9523|      1|            Event::FootnoteReference("note".into()),
 9524|       |        ];
 9525|      1|        let mut slugs = HashMap::new();
 9526|      1|        let (quotes, next) = renderer.collect_blockquotes(&events, 1, 1, &mut slugs)?;
                                                                                                  ^0
 9527|      1|        assert_eq!(next, events.len());
 9528|      1|        let mut ids = Vec::new();
 9529|      2|        for (_, blocks) in &quotes {
                              ^1
 9530|      5|            for block in blocks {
                              ^4
 9531|      4|                if let MarkdownElement::Header { id, .. } = block {
                                                               ^2
  ------------------
  |  Branch (9531:24): [True: 2, False: 2]
  ------------------
 9532|      2|                    ids.push(id.clone());
 9533|      2|                }
 9534|       |            }
 9535|       |        }
 9536|      1|        assert_eq!(ids.len(), 2);
 9537|      1|        assert_ne!(ids[0], ids[1]);
 9538|      1|        Ok(())
 9539|      1|    }
 9540|       |
 9541|       |    #[test]
 9542|      1|    fn test_render_inline_span_context_menus() {
 9543|      1|        let renderer = MarkdownRenderer::new();
 9544|      1|        let code_span = InlineSpan::Code("inline".to_string());
 9545|      1|        let ctx = egui::Context::default();
 9546|      1|        let click = input_with_click(egui::pos2(12.0, 12.0), egui::PointerButton::Secondary);
 9547|      1|        run_frame_with_input(&ctx, click, |_, ui| {
 9548|      1|            renderer.render_inline_span(ui, &code_span, None, None);
 9549|      1|        });
 9550|      1|        let input = egui::RawInput {
 9551|      1|            screen_rect: Some(egui::Rect::from_min_size(
 9552|      1|                egui::pos2(0.0, 0.0),
 9553|      1|                egui::vec2(320.0, 240.0),
 9554|      1|            )),
 9555|      1|            ..Default::default()
 9556|      1|        };
 9557|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 9558|      1|            renderer.render_inline_span(ui, &code_span, None, None);
 9559|      1|        });
 9560|       |
 9561|      1|        let link_span = InlineSpan::Link {
 9562|      1|            text: "Link".to_string(),
 9563|      1|            url: "https://example.com".to_string(),
 9564|      1|        };
 9565|      1|        let ctx = egui::Context::default();
 9566|      1|        let click = input_with_click(egui::pos2(12.0, 12.0), egui::PointerButton::Secondary);
 9567|      1|        run_frame_with_input(&ctx, click, |_, ui| {
 9568|      1|            renderer.render_inline_span(ui, &link_span, None, None);
 9569|      1|        });
 9570|      1|        let input = egui::RawInput {
 9571|      1|            screen_rect: Some(egui::Rect::from_min_size(
 9572|      1|                egui::pos2(0.0, 0.0),
 9573|      1|                egui::vec2(320.0, 240.0),
 9574|      1|            )),
 9575|      1|            ..Default::default()
 9576|      1|        };
 9577|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 9578|      1|            renderer.render_inline_span(ui, &link_span, None, None);
 9579|      1|        });
 9580|      1|    }
 9581|       |
 9582|       |    #[test]
 9583|      1|    fn test_render_inline_span_image_scale_and_title() {
 9584|      1|        let renderer = MarkdownRenderer::new();
 9585|      1|        let ctx = egui::Context::default();
 9586|      1|        let input = egui::RawInput {
 9587|      1|            screen_rect: Some(egui::Rect::from_min_size(
 9588|      1|                egui::pos2(0.0, 0.0),
 9589|      1|                egui::vec2(40.0, 240.0),
 9590|      1|            )),
 9591|      1|            ..Default::default()
 9592|      1|        };
 9593|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 9594|      1|            let color_image = egui::ColorImage::new([200, 120], Color32::WHITE);
 9595|      1|            let tex =
 9596|      1|                ui.ctx()
 9597|      1|                    .load_texture("img:test.png", color_image, egui::TextureOptions::LINEAR);
 9598|      1|            renderer.image_textures.borrow_mut().insert(
 9599|      1|                "test.png".to_string(),
 9600|      1|                ImageCacheEntry {
 9601|      1|                    texture: tex,
 9602|      1|                    size: [200, 120],
 9603|      1|                    modified: None,
 9604|      1|                },
 9605|      1|            );
 9606|      1|            let span = InlineSpan::Image {
 9607|      1|                src: "test.png".to_string(),
 9608|      1|                alt: "Alt".to_string(),
 9609|      1|                title: Some("Title".to_string()),
 9610|      1|            };
 9611|      1|            renderer.render_inline_span(ui, &span, None, None);
 9612|      1|        });
 9613|      1|    }
 9614|       |
 9615|       |    #[test]
 9616|      1|    fn test_measure_inline_spans_empty_lines_and_styles() {
 9617|      1|        let renderer = MarkdownRenderer::new();
 9618|      1|        with_test_ui(|_, ui| {
 9619|      1|            let spans = vec![
 9620|      1|                InlineSpan::Strong("Bold\n\nLine".to_string()),
 9621|      1|                InlineSpan::Emphasis("Em\n".to_string()),
 9622|      1|                InlineSpan::Strikethrough("Strike".to_string()),
 9623|      1|                InlineSpan::Link {
 9624|      1|                    text: "Link\n".to_string(),
 9625|      1|                    url: "https://example.com".to_string(),
 9626|      1|                },
 9627|      1|                InlineSpan::Code("code\n\nmore".to_string()),
 9628|       |            ];
 9629|      1|            let width = renderer.measure_inline_spans(ui, &spans);
 9630|      1|            assert!(width > 0.0);
 9631|      1|        });
 9632|      1|    }
 9633|       |
 9634|       |    #[test]
 9635|      1|    fn test_estimate_table_cell_height_variants() {
 9636|      1|        let renderer = MarkdownRenderer::new();
 9637|      1|        with_test_ui(|_, ui| {
 9638|      1|            let style = ui.style().clone();
 9639|      1|            let empty =
 9640|      1|                renderer.estimate_table_cell_height(&style, ui, &[], 100.0, Align::LEFT, 18.0);
 9641|      1|            assert_eq!(empty, 18.0);
 9642|       |
 9643|      1|            let emoji_spans = vec![InlineSpan::Text("".to_string())];
 9644|      1|            let emoji_height = renderer.estimate_table_cell_height(
 9645|      1|                &style,
 9646|      1|                ui,
 9647|      1|                &emoji_spans,
 9648|       |                100.0,
 9649|       |                Align::LEFT,
 9650|       |                18.0,
 9651|       |            );
 9652|      1|            assert!(emoji_height >= 18.0);
 9653|       |
 9654|      1|            let spans = vec![
 9655|      1|                InlineSpan::Text("alpha".to_string()),
 9656|      1|                InlineSpan::Image {
 9657|      1|                    src: "missing.png".to_string(),
 9658|      1|                    alt: "Alt".to_string(),
 9659|      1|                    title: None,
 9660|      1|                },
 9661|       |            ];
 9662|      1|            let height =
 9663|      1|                renderer.estimate_table_cell_height(&style, ui, &spans, 40.0, Align::LEFT, 18.0);
 9664|      1|            assert!(height >= 18.0);
 9665|      1|        });
 9666|      1|    }
 9667|       |
 9668|       |    #[test]
 9669|      1|    fn test_estimate_table_column_widths_scaling() {
 9670|      1|        let renderer = MarkdownRenderer::new();
 9671|      1|        let empty = renderer.estimate_table_column_widths(&[], 120.0, 6.0);
 9672|      1|        assert_eq!(empty, vec![120.0]);
 9673|       |
 9674|      1|        let specs = vec![
 9675|      1|            ColumnSpec::new(
 9676|       |                0,
 9677|      1|                "A".to_string(),
 9678|      1|                ColumnPolicy::Fixed {
 9679|      1|                    width: 100.0,
 9680|      1|                    clip: false,
 9681|      1|                },
 9682|      1|                None,
 9683|       |            ),
 9684|      1|            ColumnSpec::new(
 9685|       |                1,
 9686|      1|                "B".to_string(),
 9687|      1|                ColumnPolicy::Fixed {
 9688|      1|                    width: 100.0,
 9689|      1|                    clip: false,
 9690|      1|                },
 9691|      1|                None,
 9692|       |            ),
 9693|       |        ];
 9694|      1|        let widths = renderer.estimate_table_column_widths(&specs, 100.0, 10.0);
 9695|      1|        assert_eq!(widths.len(), 2);
 9696|      1|        let sum: f32 = widths.iter().sum();
 9697|      1|        assert!((sum - 90.0).abs() < 0.5);
 9698|      1|    }
 9699|       |
 9700|       |    #[test]
 9701|      1|    fn test_escape_table_pipes_in_inline_code_nested_lists() {
 9702|      1|        let md_parent = "\
 9703|      1| - Parent
 9704|      1|   | Col | Notes |
 9705|      1|  | --- | --- |
 9706|      1|  | code | `a|b` |
 9707|      1|";
 9708|      1|        let escaped_parent = MarkdownRenderer::escape_table_pipes_in_inline_code(md_parent);
 9709|      1|        assert!(escaped_parent.contains(PIPE_SENTINEL));
 9710|       |
 9711|      1|        let md_nested = "\
 9712|      1|- Parent
 9713|      1|    - | Col | Notes |
 9714|      1|      | --- | --- |
 9715|      1|      | code | `a|b` |
 9716|      1|";
 9717|      1|        let escaped_nested = MarkdownRenderer::escape_table_pipes_in_inline_code(md_nested);
 9718|      1|        assert!(escaped_nested.contains(PIPE_SENTINEL));
 9719|      1|    }
 9720|       |
 9721|       |    #[test]
 9722|      1|    fn test_escape_table_pipes_parent_indent_out_of_range() {
 9723|      1|        let md = "\
 9724|      1|- Parent
 9725|      1|        - Child
 9726|      1|        continuation
 9727|      1|";
 9728|      1|        let escaped = MarkdownRenderer::escape_table_pipes_in_inline_code(md);
 9729|      1|        assert_eq!(escaped, md);
 9730|      1|    }
 9731|       |
 9732|       |    #[test]
 9733|      1|    fn test_parse_table_unclosed_and_noise() -> Result<()> {
 9734|      1|        let renderer = MarkdownRenderer::new();
 9735|      1|        let events = vec![
 9736|      1|            Event::Start(Tag::Table(vec![Alignment::Left])),
 9737|      1|            Event::Start(Tag::TableHead),
 9738|      1|            Event::Start(Tag::TableRow),
 9739|      1|            Event::Start(Tag::TableCell),
 9740|      1|            Event::Text("H".into()),
 9741|      1|            Event::End(Tag::TableCell),
 9742|      1|            Event::End(Tag::TableRow),
 9743|      1|            Event::End(Tag::TableHead),
 9744|      1|            Event::Start(Tag::TableRow),
 9745|      1|            Event::Text("noise".into()),
 9746|      1|            Event::Start(Tag::TableCell),
 9747|      1|            Event::Text("R".into()),
 9748|      1|            Event::End(Tag::TableCell),
 9749|      1|            Event::End(Tag::TableRow),
 9750|      1|            Event::Text("after".into()),
 9751|       |        ];
 9752|      1|        let (headers, rows, next) = renderer.parse_table(&events, 1)?;
                                                                                  ^0
 9753|      1|        assert_eq!(headers.len(), 1);
 9754|      1|        assert_eq!(rows.len(), 1);
 9755|      1|        assert_eq!(next, events.len());
 9756|      1|        Ok(())
 9757|      1|    }
 9758|       |
 9759|       |    #[test]
 9760|      1|    fn test_parse_code_block_unclosed() -> Result<()> {
 9761|      1|        let renderer = MarkdownRenderer::new();
 9762|      1|        let events = vec![
 9763|      1|            Event::Start(Tag::CodeBlock(pulldown_cmark::CodeBlockKind::Fenced(
 9764|      1|                "rust".into(),
 9765|      1|            ))),
 9766|      1|            Event::Text("fn main() {}".into()),
 9767|      1|            Event::Html("<span>".into()),
 9768|       |        ];
 9769|      1|        let (code, language, next) = renderer.parse_code_block(&events, 0)?;
                                                                                        ^0
 9770|      1|        assert_eq!(language.as_deref(), Some("rust"));
 9771|      1|        assert_eq!(code, "fn main() {}");
 9772|      1|        assert_eq!(next, events.len());
 9773|      1|        Ok(())
 9774|      1|    }
 9775|       |
 9776|       |    #[test]
 9777|      1|    fn test_has_pipe_outside_inline_code_backticks() {
 9778|      1|        assert!(MarkdownRenderer::has_pipe_outside_inline_code(r"\`|`"));
 9779|      1|        assert!(!MarkdownRenderer::has_pipe_outside_inline_code("``a|b``"));
 9780|      1|    }
 9781|       |
 9782|       |    #[test]
 9783|      1|    fn test_row_needs_height_estimate_variants() {
 9784|      1|        let renderer = MarkdownRenderer::new();
 9785|      1|        let row_with_image = vec![vec![InlineSpan::Image {
 9786|      1|            src: "missing.png".to_string(),
 9787|      1|            alt: "Alt".to_string(),
 9788|      1|            title: None,
 9789|      1|        }]];
 9790|      1|        assert!(renderer.row_needs_height_estimate(&row_with_image));
 9791|       |
 9792|      1|        let row_with_newline = vec![vec![InlineSpan::Text("line1\nline2".to_string())]];
 9793|      1|        assert!(renderer.row_needs_height_estimate(&row_with_newline));
 9794|       |
 9795|      1|        let row_plain = vec![vec![InlineSpan::Text("plain".to_string())]];
 9796|      1|        assert!(!renderer.row_needs_height_estimate(&row_plain));
 9797|      1|    }
 9798|       |
 9799|       |    #[test]
 9800|      1|    fn test_is_allowed_scheme_variants() {
 9801|      1|        assert!(MarkdownRenderer::is_allowed_scheme("http://example.com"));
 9802|      1|        assert!(MarkdownRenderer::is_allowed_scheme("https://example.com"));
 9803|      1|        assert!(MarkdownRenderer::is_allowed_scheme(
 9804|      1|            "mailto:test@example.com"
 9805|       |        ));
 9806|      1|        assert!(!MarkdownRenderer::is_allowed_scheme("ftp://example.com"));
 9807|      1|    }
 9808|       |
 9809|       |    #[test]
 9810|      1|    fn test_render_table_tablebuilder_scaled_down_adjustments() {
 9811|      1|        let renderer = MarkdownRenderer::new();
 9812|      1|        let headers = vec![
 9813|      1|            vec![InlineSpan::Text("A".to_string())],
 9814|      1|            vec![InlineSpan::Text("B".to_string())],
 9815|      1|            vec![InlineSpan::Text("C".to_string())],
 9816|       |        ];
 9817|      1|        let rows = vec![vec![
 9818|      1|            vec![InlineSpan::Text("row1".to_string())],
 9819|      1|            vec![InlineSpan::Text("row2".to_string())],
 9820|      1|            vec![InlineSpan::Text("row3".to_string())],
 9821|       |        ]];
 9822|      1|        let ctx = egui::Context::default();
 9823|      1|        let widths = [220.0, 240.0];
 9824|      2|        for (idx, width) in widths.iter().enumerate() {
                                          ^1     ^1     ^1
 9825|      2|            let _forced = ForcedTablePolicies::new(vec![
 9826|      2|                ColumnPolicy::Resizable {
 9827|      2|                    min: 40.0,
 9828|      2|                    preferred: 200.0,
 9829|      2|                    clip: false,
 9830|      2|                },
 9831|      2|                ColumnPolicy::Auto,
 9832|      2|                ColumnPolicy::Remainder { clip: false },
 9833|       |            ]);
 9834|      2|            let input = egui::RawInput {
 9835|      2|                screen_rect: Some(egui::Rect::from_min_size(
 9836|      2|                    egui::pos2(0.0, 0.0),
 9837|      2|                    egui::vec2(*width, 120.0),
 9838|      2|                )),
 9839|      2|                ..Default::default()
 9840|      2|            };
 9841|      2|            run_frame_with_input(&ctx, input, |_, ui| {
 9842|      2|                ui.spacing_mut().item_spacing.x = 2.0;
 9843|      2|                let table_id = renderer.compute_table_id(&headers, &rows, &[], 90 + idx as u64);
 9844|      2|                renderer.render_table_tablebuilder(ui, &headers, &rows, &[], table_id);
 9845|      2|            });
 9846|       |        }
 9847|      1|    }
 9848|       |
 9849|       |    #[test]
 9850|      1|    fn test_render_code_block_mermaid_and_context_menu() {
 9851|      1|        let renderer = MarkdownRenderer::new();
 9852|      1|        let _guard = EnvVarGuard::set("MDMDVIEW_MERMAID_RENDERER", "off");
 9853|      1|        with_test_ui(|_, ui| {
 9854|      1|            renderer.render_code_block(ui, Some("mermaid"), "graph TD; A-->B;");
 9855|      1|        });
 9856|       |
 9857|      1|        let ctx = egui::Context::default();
 9858|      1|        let click = input_with_click(egui::pos2(12.0, 12.0), egui::PointerButton::Secondary);
 9859|      1|        run_frame_with_input(&ctx, click, |_, ui| {
 9860|      1|            renderer.render_code_block(ui, Some("rust"), "fn main() {}");
 9861|      1|        });
 9862|      1|        let input = egui::RawInput {
 9863|      1|            screen_rect: Some(egui::Rect::from_min_size(
 9864|      1|                egui::pos2(0.0, 0.0),
 9865|      1|                egui::vec2(320.0, 240.0),
 9866|      1|            )),
 9867|      1|            ..Default::default()
 9868|      1|        };
 9869|      1|        run_frame_with_input(&ctx, input, |_, ui| {
 9870|      1|            renderer.render_code_block(ui, Some("rust"), "fn main() {}");
 9871|      1|        });
 9872|      1|    }
 9873|       |
 9874|       |    #[test]
 9875|      1|    fn test_render_code_block_highlight_styles() {
 9876|      1|        let mut renderer = MarkdownRenderer::new();
 9877|      1|        let theme = renderer
 9878|      1|            .theme_set
 9879|      1|            .themes
 9880|      1|            .get_mut("base16-ocean.dark")
 9881|      1|            .expect("theme");
 9882|      1|        theme.scopes.clear();
 9883|      1|        let selector = ScopeSelectors::from_str("source.rust").expect("selector");
 9884|      1|        theme.scopes.push(ThemeItem {
 9885|      1|            scope: selector,
 9886|      1|            style: StyleModifier {
 9887|      1|                foreground: Some(Color::WHITE),
 9888|      1|                background: Some(Color::BLACK),
 9889|      1|                font_style: Some(FontStyle::BOLD | FontStyle::ITALIC),
 9890|      1|            },
 9891|      1|        });
 9892|      1|        with_test_ui(|_, ui| {
 9893|      1|            renderer.render_code_block(ui, Some("rust"), "fn main() {}");
 9894|      1|        });
 9895|      1|    }
 9896|       |
 9897|       |    #[test]
 9898|      1|    fn test_render_code_block_highlight_and_fallback() {
 9899|      1|        let renderer = MarkdownRenderer::new();
 9900|      1|        let code = "fn main() {\n    let value = 1;\n    // comment with  spaces\n    \n}\n";
 9901|      1|        with_test_ui(|_, ui| {
 9902|      1|            renderer.render_code_block(ui, Some("rust"), code);
 9903|      1|        });
 9904|       |
 9905|      1|        let mut fallback_renderer = MarkdownRenderer::new();
 9906|      1|        fallback_renderer.syntax_set = SyntaxSet::new();
 9907|      1|        with_test_ui(|_, ui| {
 9908|      1|            fallback_renderer.render_code_block(ui, Some("notalanguage"), "code");
 9909|      1|        });
 9910|      1|    }
 9911|       |
 9912|       |    #[test]
 9913|      1|    fn test_to_superscript_maps_values() {
 9914|      1|        let mapped = MarkdownRenderer::to_superscript("Abc123!");
 9915|      1|        assert_ne!(mapped, "Abc123!");
 9916|      1|    }
 9917|       |
 9918|       |    #[test]
 9919|      1|    fn test_cell_single_emoji_whitespace_only() {
 9920|      1|        let renderer = MarkdownRenderer::new();
 9921|      1|        let spans = vec![InlineSpan::Text("   ".to_string())];
 9922|      1|        assert!(renderer.cell_single_emoji(&spans).is_none());
 9923|      1|    }
 9924|       |
 9925|       |    #[test]
 9926|      1|    fn test_table_line_info_with_list_fallback_indent() {
 9927|      1|        let line = "  >| A |";
 9928|      1|        let (level, rest) = MarkdownRenderer::table_line_info_with_list(line, Some(2));
 9929|      1|        assert_eq!(level, 1);
 9930|      1|        assert!(rest.starts_with('|'));
 9931|      1|    }
 9932|       |
 9933|       |    #[test]
 9934|      1|    fn test_list_marker_info_any_indent_missing_punctuation() {
 9935|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("1 item").is_none());
 9936|      1|    }
 9937|       |
 9938|       |    #[test]
 9939|      1|    fn test_strip_indent_columns_rejects_non_whitespace() {
 9940|      1|        assert!(MarkdownRenderer::strip_indent_columns("x", 1).is_none());
 9941|      1|    }
 9942|       |
 9943|       |    #[test]
 9944|      1|    fn test_parse_element_image_empty_title_outside_paragraph() -> Result<()> {
 9945|      1|        let renderer = MarkdownRenderer::new();
 9946|      1|        let events = vec![
 9947|      1|            Event::Start(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
 9948|      1|            Event::Text("alt".into()),
 9949|      1|            Event::End(Tag::Image(LinkType::Inline, "img.png".into(), "".into())),
 9950|       |        ];
 9951|      1|        let mut elements = Vec::new();
 9952|      1|        let mut slugs = HashMap::new();
 9953|      1|        let next = renderer.parse_element(&events, 0, &mut elements, &mut slugs)?;
                                                                                              ^0
 9954|      1|        assert_eq!(next, events.len());
 9955|      1|        let MarkdownElement::Paragraph(spans) = &elements[0] else {
  ------------------
  |  Branch (9955:13): [True: 1, False: 0]
  ------------------
 9956|      0|            panic!("expected paragraph");
 9957|       |        };
 9958|      1|        let InlineSpan::Image { title, .. } = &spans[0] else {
  ------------------
  |  Branch (9958:13): [True: 1, False: 0]
  ------------------
 9959|      0|            panic!("expected image span");
 9960|       |        };
 9961|      1|        assert!(title.is_none());
 9962|      1|        Ok(())
 9963|      1|    }
 9964|       |
 9965|       |    #[test]
 9966|      1|    fn test_slugify_trailing_dash_trimmed() {
 9967|      1|        let slug = MarkdownRenderer::slugify("Hello - ");
 9968|      1|        assert_eq!(slug, "hello");
 9969|      1|    }
 9970|       |
 9971|       |    #[test]
 9972|      1|    fn test_slugify_leading_whitespace_and_internal_spaces() {
 9973|      1|        let slug = MarkdownRenderer::slugify("  Hello   World ");
 9974|      1|        assert_eq!(slug, "hello-world");
 9975|      1|    }
 9976|       |
 9977|       |    #[test]
 9978|      1|    fn test_render_plain_and_highlight_empty_text() {
 9979|      1|        let renderer = MarkdownRenderer::new();
 9980|      1|        with_test_ui(|_, ui| {
 9981|      1|            ui.visuals_mut().override_text_color = Some(Color32::from_rgb(10, 20, 30));
 9982|      1|            let style = InlineStyle {
 9983|      1|                strong: true,
 9984|      1|                ..Default::default()
 9985|      1|            };
 9986|      1|            renderer.render_plain_segment(ui, "", 12.0, style);
 9987|      1|            renderer.render_plain_segment(ui, "Header", 12.0, style);
 9988|      1|            renderer.render_highlighted_segment(ui, "", 12.0, style);
 9989|      1|        });
 9990|      1|    }
 9991|       |
 9992|       |    #[test]
 9993|      1|    fn test_emoji_key_for_grapheme_strips_vs16() {
 9994|      1|        let renderer = MarkdownRenderer::new();
 9995|      1|        let key = renderer.emoji_key_for_grapheme("\u{2705}\u{fe0f}");
 9996|      1|        assert_eq!(key, Some("\u{2705}".to_string()));
 9997|      1|    }
 9998|       |
 9999|       |    #[test]
10000|      1|    fn test_expand_superscripts_long_sequence_no_expand() {
10001|      1|        let input = "value^abcdefghijk^";
10002|      1|        let out = MarkdownRenderer::expand_superscripts(input);
10003|      1|        assert_eq!(out, input);
10004|      1|    }
10005|       |
10006|       |    #[test]
10007|      1|    fn test_compute_table_content_hash_stops_after_sample_rows() {
10008|      1|        let renderer = MarkdownRenderer::new();
10009|      1|        let headers = vec![vec![InlineSpan::Text("H".to_string())]];
10010|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = (0..(COLUMN_STATS_SAMPLE_ROWS + 1))
10011|    129|            .map(|idx| vec![vec![InlineSpan::Text(format!("R{idx}"))]])
                           ^1
10012|      1|            .collect();
10013|      1|        let hash = renderer.compute_table_content_hash(&headers, &rows, &[]);
10014|      1|        assert_ne!(hash, 0);
10015|      1|    }
10016|       |
10017|       |    #[test]
10018|      1|    fn test_table_width_helpers_empty_inputs() {
10019|      1|        let renderer = MarkdownRenderer::new();
10020|      1|        let table_id = 100u64;
10021|      1|        let mut specs: Vec<ColumnSpec> = Vec::new();
10022|      1|        renderer.apply_persisted_widths(table_id, &mut specs);
10023|      1|        renderer.persist_resizable_widths(table_id, &[], &[]);
10024|      1|        let change = renderer.record_resolved_widths(table_id, 0, &[]);
10025|      1|        assert!(matches!(change, WidthChange::None));
                              ^0
10026|      1|        assert!(renderer
10027|      1|            .resolve_table_column_widths(table_id, &[], 10.0)
10028|      1|            .is_empty());
10029|      1|        assert_eq!(renderer.estimate_table_total_width(table_id, &[], 6.0), 0.0);
10030|      1|        with_test_ui(|_, ui| {
10031|      1|            let style = ui.style().clone();
10032|      1|            let row = vec![vec![]];
10033|      1|            let height = renderer.estimate_table_row_height(
10034|      1|                ui,
10035|      1|                &style,
10036|      1|                &row,
10037|      1|                &[Align::LEFT],
10038|      1|                &[40.0],
10039|       |                12.0,
10040|       |            );
10041|      1|            assert_eq!(height, 12.0);
10042|      1|            let rect = egui::Rect::from_min_size(
10043|      1|                egui::pos2(0.0, 0.0),
10044|      1|                egui::vec2(10.0, 10.0),
10045|       |            );
10046|      1|            renderer.paint_table_dividers(ui.painter(), ui.visuals(), rect, rect, &[], 0.0, 0.0);
10047|      1|        });
10048|      1|    }
10049|       |
10050|       |    #[test]
10051|      1|    fn test_persist_resizable_widths_stores_new_width() {
10052|      1|        let renderer = MarkdownRenderer::new();
10053|      1|        let table_id = 200u64;
10054|      1|        let specs = vec![ColumnSpec::new(
10055|       |            0,
10056|       |            "A",
10057|      1|            ColumnPolicy::Resizable {
10058|      1|                min: 20.0,
10059|      1|                preferred: 100.0,
10060|      1|                clip: false,
10061|      1|            },
10062|      1|            None,
10063|       |        )];
10064|      1|        let widths = vec![140.0f32];
10065|      1|        renderer.persist_resizable_widths(table_id, &specs, &widths);
10066|      1|        let metrics = renderer.table_metrics.borrow();
10067|      1|        let entry = metrics.entry(table_id).expect("entry created");
10068|      1|        assert_eq!(entry.persisted_width(specs[0].policy_hash), Some(140.0));
10069|      1|    }
10070|       |
10071|       |    #[test]
10072|      1|    fn test_paint_table_text_job_adds_hover_for_wrapped_text() {
10073|      1|        let renderer = MarkdownRenderer::new();
10074|      1|        let spans = vec![InlineSpan::Text(
10075|      1|            "This is a long line that should wrap in a narrow cell.".to_string(),
10076|      1|        )];
10077|      1|        with_test_ui(|_, ui| {
10078|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 20.0, false, Align::LEFT);
10079|      1|            let _response = renderer.paint_table_text_job(ui, 20.0, build);
10080|      1|        });
10081|      1|    }
10082|       |
10083|       |    #[test]
10084|      1|    fn test_link_at_pointer_outside_text_rect() {
10085|      1|        let renderer = MarkdownRenderer::new();
10086|      1|        let spans = vec![InlineSpan::Link {
10087|      1|            text: "link".to_string(),
10088|      1|            url: "https://example.com".to_string(),
10089|      1|        }];
10090|      1|        let ctx = egui::Context::default();
10091|      1|        let mut input = egui::RawInput {
10092|      1|            screen_rect: Some(egui::Rect::from_min_size(
10093|      1|                egui::pos2(0.0, 0.0),
10094|      1|                egui::vec2(220.0, 120.0),
10095|      1|            )),
10096|      1|            ..Default::default()
10097|      1|        };
10098|      1|        input
10099|      1|            .events
10100|      1|            .push(egui::Event::PointerMoved(egui::pos2(150.0, 10.0)));
10101|      1|        run_frame_with_input(&ctx, input, |_, ui| {
10102|      1|            let build = renderer.build_layout_job(ui.style(), &spans, 200.0, false, Align::LEFT);
10103|      1|            let galley = ui.fonts(|f| f.layout_job(build.job.clone()));
10104|      1|            let (rect, response) =
10105|      1|                ui.allocate_exact_size(egui::vec2(200.0, galley.size().y), egui::Sense::hover());
10106|      1|            let text_origin = MarkdownRenderer::aligned_text_origin(rect, &galley, build.job.halign);
10107|      1|            let link = renderer.link_at_pointer(&response, &galley, &build, text_origin);
10108|      1|            assert!(link.is_none());
10109|      1|        });
10110|      1|    }
10111|       |
10112|       |    #[test]
10113|      1|    fn test_element_plain_text_list_quote_table_spacing() {
10114|      1|        let list = MarkdownElement::List {
10115|      1|            ordered: false,
10116|      1|            items: vec![ListItem {
10117|      1|                blocks: vec![
10118|      1|                    MarkdownElement::Paragraph(vec![InlineSpan::Text("One".to_string())]),
10119|      1|                    MarkdownElement::Paragraph(vec![InlineSpan::Text("Two".to_string())]),
10120|      1|                ],
10121|      1|            }],
10122|      1|        };
10123|      1|        let list_text = MarkdownRenderer::element_plain_text(&list);
10124|      1|        assert!(list_text.contains('\n'));
10125|       |
10126|      1|        let quote = MarkdownElement::Quote {
10127|      1|            depth: 1,
10128|      1|            blocks: vec![
10129|      1|                MarkdownElement::Paragraph(vec![InlineSpan::Text("Alpha".to_string())]),
10130|      1|                MarkdownElement::Paragraph(vec![InlineSpan::Text("Beta".to_string())]),
10131|      1|            ],
10132|      1|        };
10133|      1|        let quote_text = MarkdownRenderer::element_plain_text(&quote);
10134|      1|        assert!(quote_text.contains('\n'));
10135|       |
10136|      1|        let table = MarkdownElement::Table {
10137|      1|            headers: vec![
10138|      1|                vec![InlineSpan::Text("H1".to_string())],
10139|      1|                vec![InlineSpan::Text("H2".to_string())],
10140|      1|            ],
10141|      1|            rows: vec![vec![
10142|      1|                vec![InlineSpan::Text("A".to_string())],
10143|      1|                vec![InlineSpan::Text("B".to_string())],
10144|      1|            ]],
10145|      1|            alignments: vec![],
10146|      1|        };
10147|      1|        let table_text = MarkdownRenderer::element_plain_text(&table);
10148|      1|        assert_eq!(table_text, "H1 H2 A B");
10149|      1|    }
10150|       |
10151|       |    #[test]
10152|      1|    fn test_resolve_image_path_data_uri_and_remote_texture_reject() {
10153|      1|        let renderer = MarkdownRenderer::new();
10154|      1|        let data_uri = "data:image/png;base64,AAAA";
10155|      1|        assert_eq!(renderer.resolve_image_path(data_uri), data_uri);
10156|      1|        with_test_ui(|_, ui| {
10157|      1|            assert!(renderer
10158|      1|                .get_or_load_image_texture(ui, "https://example.com/image.png")
10159|      1|                .is_none());
10160|      1|            assert!(renderer
10161|      1|                .get_or_load_image_texture(ui, "http://example.com/image.png")
10162|      1|                .is_none());
10163|      1|        });
10164|      1|    }
10165|       |
10166|       |    #[test]
10167|      1|    fn test_is_html_line_break_rejects_non_br() {
10168|      1|        assert!(!MarkdownRenderer::is_html_line_break("<div>"));
10169|      1|        assert!(!MarkdownRenderer::is_html_line_break("br"));
10170|      1|    }
10171|       |
10172|       |    #[test]
10173|      1|    fn test_table_line_info_variants_cover_edges() {
10174|      1|        let (level, rest) = MarkdownRenderer::table_line_info("text");
10175|      1|        assert_eq!(level, 0);
10176|      1|        assert_eq!(rest, "text");
10177|       |
10178|      1|        let (level, rest) = MarkdownRenderer::table_line_info("   text");
10179|      1|        assert_eq!(level, 0);
10180|      1|        assert_eq!(rest, "   text");
10181|       |
10182|      1|        let (level, rest) = MarkdownRenderer::table_line_info(">abc");
10183|      1|        assert_eq!(level, 1);
10184|      1|        assert_eq!(rest, "abc");
10185|       |
10186|      1|        let (level, rest) = MarkdownRenderer::table_line_info(" >\tabc");
10187|      1|        assert_eq!(level, 1);
10188|      1|        assert_eq!(rest, "abc");
10189|       |
10190|      1|        let (level, rest) = MarkdownRenderer::table_line_info(">");
10191|      1|        assert_eq!(level, 1);
10192|      1|        assert_eq!(rest, "");
10193|      1|    }
10194|       |
10195|       |    #[test]
10196|      1|    fn test_list_marker_info_rejects_missing_delimiter_or_spacing() {
10197|      1|        assert!(MarkdownRenderer::list_marker_info("1 item").is_none());
10198|      1|        assert!(MarkdownRenderer::list_marker_info("1.item").is_none());
10199|      1|    }
10200|       |
10201|       |    #[test]
10202|      1|    fn test_list_marker_info_numeric_missing_punctuation() {
10203|      1|        assert!(MarkdownRenderer::list_marker_info("12").is_none());
10204|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("  12").is_none());
10205|      1|    }
10206|       |
10207|       |    #[test]
10208|      1|    fn test_list_marker_info_any_indent_rejects_missing_delimiter_or_spacing() {
10209|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("   1 item").is_none());
10210|      1|        assert!(MarkdownRenderer::list_marker_info_any_indent("  2.item").is_none());
10211|      1|    }
10212|       |
10213|       |    #[test]
10214|      1|    fn test_strip_indent_columns_insufficient_indent_returns_none() {
10215|      1|        assert!(MarkdownRenderer::strip_indent_columns("  text", 4).is_none());
10216|      1|    }
10217|       |
10218|       |    #[test]
10219|      1|    fn test_strip_indent_columns_whitespace_short_returns_none() {
10220|      1|        assert!(MarkdownRenderer::strip_indent_columns("  ", 4).is_none());
10221|      1|    }
10222|       |
10223|       |    #[test]
10224|      1|    fn test_has_pipe_outside_inline_code_unmatched_backticks() {
10225|      1|        let line = "`code`` | still in code";
10226|      1|        assert!(!MarkdownRenderer::has_pipe_outside_inline_code(line));
10227|      1|    }
10228|       |
10229|       |    #[test]
10230|      1|    fn test_is_table_delimiter_line_requires_dash_and_pipe() {
10231|      1|        assert!(!MarkdownRenderer::is_table_delimiter_line("----"));
10232|      1|        assert!(!MarkdownRenderer::is_table_delimiter_line("| ::: |"));
10233|      1|    }
10234|       |
10235|       |    #[test]
10236|      1|    fn test_append_text_sections_preserves_color_when_highlighted() {
10237|      1|        let renderer = MarkdownRenderer::new();
10238|      1|        let style = egui::Style::default();
10239|      1|        let mut job = LayoutJob::default();
10240|      1|        let mut plain_text = String::new();
10241|      1|        let inline_style = InlineStyle {
10242|      1|            strong: false,
10243|      1|            italics: false,
10244|      1|            strike: false,
10245|      1|            color: Some(Color32::from_rgb(10, 20, 30)),
10246|      1|        };
10247|      1|        let count = renderer.append_text_sections(
10248|      1|            &style,
10249|      1|            &mut job,
10250|      1|            &mut plain_text,
10251|      1|            "hit",
10252|      1|            renderer.font_sizes.body,
10253|      1|            inline_style,
10254|      1|            Some("hit"),
10255|       |        );
10256|      1|        assert_eq!(count, 3);
10257|      1|        assert_eq!(plain_text, "hit");
10258|      1|    }
10259|       |
10260|       |    #[test]
10261|      1|    fn test_render_text_with_emojis_leading_emoji() {
10262|      1|        let renderer = MarkdownRenderer::new();
10263|      1|        with_test_ui(|_, ui| {
10264|      1|            renderer.render_text_with_emojis(ui, " test", 14.0, InlineStyle::default());
10265|      1|        });
10266|      1|    }
10267|       |
10268|       |    #[test]
10269|      1|    fn test_persist_resizable_widths_records_change() {
10270|      1|        let renderer = MarkdownRenderer::new();
10271|      1|        let spec = ColumnSpec::new(
10272|       |            0,
10273|       |            "col",
10274|      1|            ColumnPolicy::Resizable {
10275|      1|                min: 40.0,
10276|      1|                preferred: 80.0,
10277|      1|                clip: false,
10278|      1|            },
10279|      1|            None,
10280|       |        );
10281|      1|        let hash = spec.policy_hash;
10282|      1|        renderer.persist_resizable_widths(42, &[spec], &[120.0]);
10283|      1|        let metrics = renderer.table_metrics.borrow();
10284|      1|        let entry = metrics.entry(42).expect("metrics entry");
10285|      1|        assert_eq!(entry.persisted_width(hash), Some(120.0));
10286|      1|    }
10287|       |
10288|       |    #[test]
10289|      1|    fn test_env_var_guard_restores_previous_value() {
10290|      1|        std::env::set_var("MDMDVIEW_TEST_ENV", "before");
10291|       |        {
10292|      1|            let _guard = EnvVarGuard::set("MDMDVIEW_TEST_ENV", "after");
10293|      1|            assert_eq!(
10294|      1|                std::env::var("MDMDVIEW_TEST_ENV").ok().as_deref(),
10295|       |                Some("after")
10296|       |            );
10297|       |        }
10298|      1|        assert_eq!(
10299|      1|            std::env::var("MDMDVIEW_TEST_ENV").ok().as_deref(),
10300|       |            Some("before")
10301|       |        );
10302|      1|        std::env::remove_var("MDMDVIEW_TEST_ENV");
10303|      1|    }
10304|       |}

C:\language\mdmdview\src\mermaid_renderer.rs:
    1|       |#[cfg(feature = "mermaid-quickjs")]
    2|       |use crossbeam_channel::{bounded, Receiver, Sender, TrySendError};
    3|       |use egui::{Color32, RichText, Stroke};
    4|       |#[cfg(feature = "mermaid-quickjs")]
    5|       |use std::cell::{Cell, RefCell};
    6|       |#[cfg(feature = "mermaid-quickjs")]
    7|       |use std::collections::HashSet;
    8|       |#[cfg(any(test, feature = "mermaid-quickjs"))]
    9|       |use std::collections::{hash_map::DefaultHasher, HashMap, VecDeque};
   10|       |#[cfg(any(test, feature = "mermaid-quickjs"))]
   11|       |use std::hash::{Hash, Hasher};
   12|       |
   13|       |#[cfg(feature = "mermaid-quickjs")]
   14|       |use std::path::PathBuf;
   15|       |#[cfg(feature = "mermaid-quickjs")]
   16|       |use std::sync::{
   17|       |    atomic::{AtomicU64, Ordering},
   18|       |    Arc,
   19|       |};
   20|       |#[cfg(feature = "mermaid-quickjs")]
   21|       |use std::thread::JoinHandle;
   22|       |#[cfg(feature = "mermaid-quickjs")]
   23|       |use std::time::{SystemTime, UNIX_EPOCH};
   24|       |
   25|       |#[cfg(feature = "mermaid-quickjs")]
   26|       |mod mermaid_embed {
   27|       |    include!(concat!(env!("OUT_DIR"), "/mermaid_js.rs"));
   28|       |}
   29|       |
   30|       |#[cfg(feature = "mermaid-quickjs")]
   31|       |const MERMAID_JS_EMPTY: bool = mermaid_embed::MERMAID_JS.is_empty();
   32|       |
   33|       |#[cfg(feature = "mermaid-quickjs")]
   34|       |struct MermaidEngine {
   35|       |    #[allow(dead_code)]
   36|       |    rt: rquickjs::Runtime,
   37|       |    ctx: rquickjs::Context,
   38|       |}
   39|       |
   40|       |#[cfg(feature = "mermaid-quickjs")]
   41|       |type MermaidJobSender = Sender<MermaidRequest>;
   42|       |#[cfg(feature = "mermaid-quickjs")]
   43|       |type MermaidJobReceiver = Receiver<MermaidRequest>;
   44|       |#[cfg(feature = "mermaid-quickjs")]
   45|       |type MermaidResultSender = Sender<MermaidResult>;
   46|       |#[cfg(feature = "mermaid-quickjs")]
   47|       |type MermaidResultReceiver = Receiver<MermaidResult>;
   48|       |
   49|       |#[cfg(feature = "mermaid-quickjs")]
   50|       |#[derive(Clone)]
   51|       |struct MermaidTextureEntry {
   52|       |    texture: egui::TextureHandle,
   53|       |    size: [u32; 2],
   54|       |}
   55|       |
   56|       |#[cfg(any(test, feature = "mermaid-quickjs"))]
   57|       |struct LruCache<K, V> {
   58|       |    entries: HashMap<K, V>,
   59|       |    order: VecDeque<K>,
   60|       |    capacity: usize,
   61|       |}
   62|       |
   63|       |#[cfg(any(test, feature = "mermaid-quickjs"))]
   64|       |impl<K, V> LruCache<K, V>
   65|       |where
   66|       |    K: Eq + std::hash::Hash + Clone,
   67|       |    V: Clone,
   68|       |{
   69|  1.13k|    fn new(capacity: usize) -> Self {
   70|  1.13k|        Self {
   71|  1.13k|            entries: HashMap::new(),
   72|  1.13k|            order: VecDeque::new(),
   73|  1.13k|            capacity: capacity.max(1),
   74|  1.13k|        }
   75|  1.13k|    }
   76|       |
   77|     50|    fn get(&mut self, key: &K) -> Option<V> {
   78|     50|        let value = self.entries.get(key).cloned();
   79|     50|        if value.is_some() {
  ------------------
  |  Branch (79:12): [True: 3, False: 10]
  ------------------
  |  Branch (79:12): [True: 4, False: 8]
  ------------------
  |  Branch (79:12): [True: 2, False: 2]
  ------------------
  |  Branch (79:12): [True: 1, False: 0]
  ------------------
  |  Branch (79:12): [True: 5, False: 15]
  ------------------
   80|     15|            self.touch(key);
   81|     35|        }
   82|     50|        value
   83|     50|    }
   84|       |
   85|     32|    fn insert(&mut self, key: K, value: V) {
   86|     32|        if self.entries.contains_key(&key) {
  ------------------
  |  Branch (86:12): [True: 1, False: 5]
  ------------------
  |  Branch (86:12): [True: 2, False: 4]
  ------------------
  |  Branch (86:12): [True: 1, False: 6]
  ------------------
  |  Branch (86:12): [True: 1, False: 2]
  ------------------
  |  Branch (86:12): [True: 1, False: 9]
  ------------------
   87|      6|            self.entries.insert(key.clone(), value);
   88|      6|            self.touch(&key);
   89|      6|            return;
   90|     26|        }
   91|     30|        while self.entries.len() >= self.capacity {
  ------------------
  |  Branch (91:15): [True: 2, False: 4]
  ------------------
  |  Branch (91:15): [True: 1, False: 4]
  ------------------
  |  Branch (91:15): [True: 2, False: 5]
  ------------------
  |  Branch (91:15): [True: 1, False: 1]
  ------------------
  |  Branch (91:15): [True: 1, False: 9]
  ------------------
   92|      7|            if let Some(old) = self.order.pop_front() {
                                      ^4
  ------------------
  |  Branch (92:20): [True: 1, False: 1]
  ------------------
  |  Branch (92:20): [True: 1, False: 0]
  ------------------
  |  Branch (92:20): [True: 1, False: 1]
  ------------------
  |  Branch (92:20): [True: 0, False: 1]
  ------------------
  |  Branch (92:20): [True: 1, False: 0]
  ------------------
   93|      4|                self.entries.remove(&old);
   94|      4|            } else {
   95|      3|                break;
   96|       |            }
   97|       |        }
   98|     26|        self.order.push_back(key.clone());
   99|     26|        self.entries.insert(key, value);
  100|     32|    }
  101|       |
  102|       |    #[cfg(feature = "mermaid-quickjs")]
  103|      4|    fn remove(&mut self, key: &K) {
  104|      4|        self.entries.remove(key);
  105|      4|        self.order.retain(|entry| entry != key);
                                                ^3       ^3
  106|      4|    }
  107|       |
  108|       |    #[cfg(test)]
  109|      6|    fn len(&self) -> usize {
  110|      6|        self.entries.len()
  111|      6|    }
  112|       |
  113|     21|    fn touch(&mut self, key: &K) {
  114|     25|        self.order.retain(|entry| entry != key);
                      ^21        ^21
  115|     21|        self.order.push_back(key.clone());
  116|     21|    }
  117|       |}
  118|       |
  119|       |#[cfg(feature = "mermaid-quickjs")]
  120|       |struct MermaidRequest {
  121|       |    svg_key: u64,
  122|       |    texture_key: String,
  123|       |    code: Option<String>,
  124|       |    svg: Option<String>,
  125|       |    width_bucket: u32,
  126|       |    scale_bucket: u32,
  127|       |    viewport_width: u32,
  128|       |    viewport_height: u32,
  129|       |    bg: Option<[u8; 4]>,
  130|       |}
  131|       |
  132|       |#[cfg(feature = "mermaid-quickjs")]
  133|       |struct MermaidResult {
  134|       |    svg_key: u64,
  135|       |    texture_key: String,
  136|       |    svg: Option<String>,
  137|       |    rgba: Option<Vec<u8>>,
  138|       |    size: Option<(u32, u32)>,
  139|       |    error: Option<String>,
  140|       |}
  141|       |
  142|       |#[cfg(feature = "mermaid-quickjs")]
  143|       |#[derive(Debug, PartialEq, Eq)]
  144|       |enum MermaidEnqueueError {
  145|       |    QueueFull,
  146|       |    Disconnected,
  147|       |}
  148|       |
  149|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
  150|       |enum MermaidRenderPreference {
  151|       |    Embedded,
  152|       |    Off,
  153|       |}
  154|       |
  155|       |#[cfg(feature = "mermaid-quickjs")]
  156|       |struct MermaidThemeValues {
  157|       |    theme_name: String,
  158|       |    main_bkg: String,
  159|       |    primary: String,
  160|       |    primary_border: String,
  161|       |    primary_text: String,
  162|       |    secondary: String,
  163|       |    tertiary: String,
  164|       |    line: String,
  165|       |    text: String,
  166|       |    cluster_bkg: String,
  167|       |    cluster_border: String,
  168|       |    default_link: String,
  169|       |    title: String,
  170|       |    label_bg: String,
  171|       |    edge_label_bg: String,
  172|       |    font_family: Option<String>,
  173|       |}
  174|       |
  175|       |pub(crate) struct MermaidRenderer {
  176|       |    #[cfg(feature = "mermaid-quickjs")]
  177|       |    mermaid_textures: RefCell<LruCache<String, MermaidTextureEntry>>,
  178|       |    #[cfg(feature = "mermaid-quickjs")]
  179|       |    mermaid_pending: RefCell<HashSet<String>>,
  180|       |    #[cfg(feature = "mermaid-quickjs")]
  181|       |    mermaid_frame_pending: Cell<bool>,
  182|       |    #[cfg(feature = "mermaid-quickjs")]
  183|       |    mermaid_svg_cache: RefCell<LruCache<u64, String>>,
  184|       |    #[cfg(feature = "mermaid-quickjs")]
  185|       |    mermaid_errors: RefCell<LruCache<u64, String>>,
  186|       |    #[cfg(feature = "mermaid-quickjs")]
  187|       |    mermaid_texture_errors: RefCell<LruCache<String, String>>,
  188|       |    /// Job sender wrapped in Option so Drop can take and drop it first,
  189|       |    /// closing the channel before joining worker threads.
  190|       |    #[cfg(feature = "mermaid-quickjs")]
  191|       |    mermaid_job_tx: Option<MermaidJobSender>,
  192|       |    #[cfg(feature = "mermaid-quickjs")]
  193|       |    mermaid_result_rx: MermaidResultReceiver,
  194|       |    /// Worker thread handles for cleanup on drop.
  195|       |    /// When MermaidRenderer is dropped, we join all worker threads to ensure
  196|       |    /// they exit cleanly and release memory (font database, QuickJS runtime).
  197|       |    #[cfg(feature = "mermaid-quickjs")]
  198|       |    worker_handles: Vec<JoinHandle<()>>,
  199|       |}
  200|       |
  201|       |impl MermaidRenderer {
  202|       |    #[cfg(feature = "mermaid-quickjs")]
  203|       |    const MERMAID_TEXTURE_CACHE_CAPACITY: usize = 128;
  204|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  205|       |    const MERMAID_WIDTH_BUCKET_STEP: u32 = 32;
  206|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  207|       |    const MERMAID_SCALE_BUCKET_FACTOR: f32 = 100.0;
  208|       |    #[cfg(feature = "mermaid-quickjs")]
  209|       |    const MAX_MERMAID_JOBS: usize = 4;
  210|       |    #[cfg(feature = "mermaid-quickjs")]
  211|       |    const MERMAID_SVG_CACHE_CAPACITY: usize = 64;
  212|       |    #[cfg(feature = "mermaid-quickjs")]
  213|       |    const MERMAID_ERROR_CACHE_CAPACITY: usize = 64;
  214|       |    #[cfg(feature = "mermaid-quickjs")]
  215|       |    const MERMAID_TEXTURE_ERROR_CACHE_CAPACITY: usize = 64;
  216|       |    #[cfg(feature = "mermaid-quickjs")]
  217|       |    const MERMAID_MAX_TEXT_SIZE: u32 = 50_000;
  218|       |    #[cfg(feature = "mermaid-quickjs")]
  219|       |    const MERMAID_MAX_RENDER_SIDE: u32 = 4096;
  220|       |
  221|    275|    pub(crate) fn new() -> Self {
  222|       |        #[cfg(feature = "mermaid-quickjs")]
  223|    275|        let (mermaid_job_tx, mermaid_job_rx): (MermaidJobSender, MermaidJobReceiver) =
  224|    275|            bounded(Self::MAX_MERMAID_JOBS * 4);
  225|       |        #[cfg(feature = "mermaid-quickjs")]
  226|    275|        let (mermaid_result_tx, mermaid_result_rx): (
  227|    275|            MermaidResultSender,
  228|    275|            MermaidResultReceiver,
  229|    275|        ) = bounded(Self::MAX_MERMAID_JOBS * 4);
  230|       |        #[cfg(feature = "mermaid-quickjs")]
  231|    275|        let worker_handles = Self::spawn_mermaid_workers(mermaid_job_rx, mermaid_result_tx);
  232|    275|        Self {
  233|    275|            #[cfg(feature = "mermaid-quickjs")]
  234|    275|            mermaid_textures: RefCell::new(LruCache::new(Self::MERMAID_TEXTURE_CACHE_CAPACITY)),
  235|    275|            #[cfg(feature = "mermaid-quickjs")]
  236|    275|            mermaid_pending: RefCell::new(HashSet::new()),
  237|    275|            #[cfg(feature = "mermaid-quickjs")]
  238|    275|            mermaid_frame_pending: Cell::new(false),
  239|    275|            #[cfg(feature = "mermaid-quickjs")]
  240|    275|            mermaid_svg_cache: RefCell::new(LruCache::new(Self::MERMAID_SVG_CACHE_CAPACITY)),
  241|    275|            #[cfg(feature = "mermaid-quickjs")]
  242|    275|            mermaid_errors: RefCell::new(LruCache::new(Self::MERMAID_ERROR_CACHE_CAPACITY)),
  243|    275|            #[cfg(feature = "mermaid-quickjs")]
  244|    275|            mermaid_texture_errors: RefCell::new(LruCache::new(
  245|    275|                Self::MERMAID_TEXTURE_ERROR_CACHE_CAPACITY,
  246|    275|            )),
  247|    275|            #[cfg(feature = "mermaid-quickjs")]
  248|    275|            mermaid_job_tx: Some(mermaid_job_tx),
  249|    275|            #[cfg(feature = "mermaid-quickjs")]
  250|    275|            mermaid_result_rx,
  251|    275|            #[cfg(feature = "mermaid-quickjs")]
  252|    275|            worker_handles,
  253|    275|        }
  254|    275|    }
  255|       |
  256|      4|    fn default_mermaid_preference() -> MermaidRenderPreference {
  257|       |        #[cfg(feature = "mermaid-quickjs")]
  258|       |        {
  259|      4|            MermaidRenderPreference::Embedded
  260|       |        }
  261|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  262|       |        {
  263|       |            MermaidRenderPreference::Off
  264|       |        }
  265|      4|    }
  266|       |
  267|     16|    fn mermaid_renderer_preference() -> (MermaidRenderPreference, bool) {
  268|     16|        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_RENDERER") {
                                ^13
  ------------------
  |  Branch (268:16): [True: 13, False: 3]
  ------------------
  269|     13|            let normalized = raw.trim().to_ascii_lowercase();
  270|     13|            return match normalized.as_str() {
  271|     13|                "off" => (MermaidRenderPreference::Off, true),
                                       ^3
  272|     10|                "embedded" => (MermaidRenderPreference::Embedded, true),
                                            ^9
  273|      1|                _ => (Self::default_mermaid_preference(), false),
  274|       |            };
  275|      3|        }
  276|      3|        (Self::default_mermaid_preference(), false)
  277|     16|    }
  278|       |
  279|      9|    pub(crate) fn has_pending(&self) -> bool {
  280|       |        #[cfg(feature = "mermaid-quickjs")]
  281|       |        {
  282|      9|            return self.mermaid_frame_pending.get()
  ------------------
  |  Branch (282:20): [True: 1, False: 8]
  ------------------
  283|      8|                || !self.mermaid_pending.borrow().is_empty();
  284|       |        }
  285|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  286|       |        {
  287|       |            false
  288|       |        }
  289|      9|    }
  290|       |
  291|     16|    pub(crate) fn begin_frame(&self) {
  292|       |        #[cfg(feature = "mermaid-quickjs")]
  293|     16|        self.mermaid_frame_pending.set(false);
  294|     16|    }
  295|       |
  296|     12|    pub(crate) fn render_block(
  297|     12|        &self,
  298|     12|        ui: &mut egui::Ui,
  299|     12|        code: &str,
  300|     12|        ui_scale: f32,
  301|     12|        code_font_size: f32,
  302|     12|    ) -> bool {
  303|     12|        let (preference, _explicit) = Self::mermaid_renderer_preference();
  304|       |
  305|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  306|       |        {
  307|       |            let _ = code;
  308|       |            let _ = ui_scale;
  309|       |        }
  310|       |
  311|     12|        if preference == MermaidRenderPreference::Off {
  ------------------
  |  Branch (311:12): [True: 2, False: 10]
  ------------------
  312|      2|            egui::Frame::none()
  313|      2|                .fill(Color32::from_rgb(25, 25, 25))
  314|      2|                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  315|      2|                .inner_margin(8.0)
  316|      2|                .show(ui, |ui| {
  317|      2|                    ui.label(
  318|      2|                        RichText::new(
  319|       |                            "Mermaid rendering is disabled. Set MDMDVIEW_MERMAID_RENDERER=embedded to enable.",
  320|       |                        )
  321|      2|                        .color(Color32::from_rgb(200, 160, 80))
  322|      2|                        .family(egui::FontFamily::Monospace)
  323|      2|                        .size(code_font_size),
  324|       |                    );
  325|      2|                    ui.add_space(6.0);
  326|      2|                    ui.label(
  327|      2|                        RichText::new(code)
  328|      2|                            .family(egui::FontFamily::Monospace)
  329|      2|                            .size(code_font_size)
  330|      2|                            .color(Color32::from_rgb(180, 180, 180)),
  331|       |                    );
  332|      2|                });
  333|      2|            return true;
  334|     10|        }
  335|       |
  336|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  337|       |        if _explicit && preference == MermaidRenderPreference::Embedded {
  338|       |            egui::Frame::none()
  339|       |                .fill(Color32::from_rgb(25, 25, 25))
  340|       |                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  341|       |                .inner_margin(8.0)
  342|       |                .show(ui, |ui| {
  343|       |                    ui.label(
  344|       |                        RichText::new(
  345|       |                            "Mermaid rendering via embedded JS is unavailable (feature not enabled).",
  346|       |                        )
  347|       |                        .color(Color32::from_rgb(200, 160, 80))
  348|       |                        .family(egui::FontFamily::Monospace)
  349|       |                        .size(code_font_size),
  350|       |                    );
  351|       |                    ui.add_space(6.0);
  352|       |                    ui.label(
  353|       |                        RichText::new(code)
  354|       |                            .family(egui::FontFamily::Monospace)
  355|       |                            .size(code_font_size)
  356|       |                            .color(Color32::from_rgb(180, 180, 180)),
  357|       |                    );
  358|       |                });
  359|       |            return true;
  360|       |        }
  361|       |
  362|       |        #[cfg(feature = "mermaid-quickjs")]
  363|       |        {
  364|     10|            if preference == MermaidRenderPreference::Embedded && MERMAID_JS_EMPTY {
  ------------------
  |  Branch (364:16): [True: 10, False: 0]
  |  Branch (364:67): [Folded, False: 10]
  ------------------
  365|      0|                egui::Frame::none()
  366|      0|                    .fill(Color32::from_rgb(25, 25, 25))
  367|      0|                    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  368|      0|                    .inner_margin(8.0)
  369|      0|                    .show(ui, |ui| {
  370|      0|                        ui.label(
  371|      0|                            RichText::new(
  372|       |                                "Mermaid rendering is unavailable (embedded JS missing).",
  373|       |                            )
  374|      0|                            .color(Color32::from_rgb(200, 160, 80))
  375|      0|                            .family(egui::FontFamily::Monospace)
  376|      0|                            .size(code_font_size),
  377|       |                        );
  378|      0|                        ui.add_space(6.0);
  379|      0|                        ui.label(
  380|      0|                            RichText::new(code)
  381|      0|                                .family(egui::FontFamily::Monospace)
  382|      0|                                .size(code_font_size)
  383|      0|                                .color(Color32::from_rgb(180, 180, 180)),
  384|       |                        );
  385|      0|                    });
  386|      0|                return true;
  387|     10|            }
  388|     10|            let svg_key = Self::hash_str(code);
  389|     10|            let mut available_width = ui.available_width();
  390|     10|            let orig_available_width = available_width;
  391|     10|            if available_width <= Self::MERMAID_WIDTH_BUCKET_STEP as f32 {
  ------------------
  |  Branch (391:16): [True: 3, False: 7]
  ------------------
  392|      3|                let fallback = ui.ctx().available_rect().width();
  393|      3|                if fallback > available_width {
  ------------------
  |  Branch (393:20): [True: 3, False: 0]
  ------------------
  394|      3|                    available_width = fallback;
  395|      3|                }
                              ^0
  396|      7|            }
  397|     10|            if std::env::var("MDMDVIEW_MERMAID_LOG_WIDTH").is_ok() {
  ------------------
  |  Branch (397:16): [True: 2, False: 8]
  ------------------
  398|      2|                eprintln!(
  399|      2|                    "Mermaid width: avail={:.2} fallback={:.2}",
  400|      2|                    orig_available_width, available_width
  401|      2|                );
  402|      8|            }
  403|     10|            let width_bucket = Self::width_bucket(available_width);
  404|     10|            let scale_bucket = Self::scale_bucket(ui_scale);
  405|     10|            let mut viewport_width = available_width.round().max(1.0) as u32;
  406|     10|            let mut viewport_height = ui
  407|     10|                .ctx()
  408|     10|                .input(|i| i.screen_rect().height())
  409|     10|                .round()
  410|     10|                .max(1.0) as u32;
  411|     10|            if let Some(kind) = Self::mermaid_diagram_kind(code) {
                                      ^9
  ------------------
  |  Branch (411:20): [True: 9, False: 1]
  ------------------
  412|      9|                if kind == "timeline" {
  ------------------
  |  Branch (412:20): [True: 2, False: 7]
  ------------------
  413|      2|                    viewport_width = viewport_width.min(1000);
  414|      2|                    viewport_height = viewport_height.min(700);
  415|      7|                }
  416|      1|            }
  417|     10|            let bg = Self::mermaid_bg_fill();
  418|     10|            let texture_key = Self::texture_key(svg_key, width_bucket, scale_bucket, bg);
  419|       |
  420|     10|            if self.poll_mermaid_results(ui.ctx()) {
  ------------------
  |  Branch (420:16): [True: 1, False: 9]
  ------------------
  421|      1|                ui.ctx().request_repaint();
  422|      9|            }
  423|       |
  424|     10|            if let Some(entry) = self.mermaid_textures.borrow_mut().get(&texture_key) {
                                      ^2
  ------------------
  |  Branch (424:20): [True: 2, False: 8]
  ------------------
  425|      2|                let (tw, th) = (entry.size[0] as f32, entry.size[1] as f32);
  426|      2|                let available_w = ui.available_width().max(1.0);
  427|      2|                let scale = if tw > available_w {
  ------------------
  |  Branch (427:32): [True: 1, False: 1]
  ------------------
  428|      1|                    (available_w / tw).clamp(0.01, 4.0)
  429|       |                } else {
  430|      1|                    1.0
  431|       |                };
  432|      2|                let size = egui::vec2((tw * scale).round(), (th * scale).round());
  433|      2|                ui.add(egui::Image::new(&entry.texture).fit_to_exact_size(size));
  434|      2|                return true;
  435|      8|            }
  436|       |
  437|      8|            let svg_error = self.mermaid_errors.borrow_mut().get(&svg_key);
  438|      8|            let texture_error = self.mermaid_texture_errors.borrow_mut().get(&texture_key);
  439|      8|            if let Some(err) = svg_error.or(texture_error) {
                                      ^1
  ------------------
  |  Branch (439:20): [True: 1, False: 7]
  ------------------
  440|      1|                egui::Frame::none()
  441|      1|                    .fill(Color32::from_rgb(25, 25, 25))
  442|      1|                    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  443|      1|                    .inner_margin(8.0)
  444|      1|                    .show(ui, |ui| {
  445|      1|                        ui.label(
  446|      1|                            RichText::new("Mermaid render failed; showing source.")
  447|      1|                                .color(Color32::from_rgb(200, 160, 80)),
  448|       |                        );
  449|      1|                        ui.label(
  450|      1|                            RichText::new(format!(
  451|      1|                                "Embedded bytes:{}\nHash:{:016x}\nError:{}",
  452|      1|                                mermaid_embed::MERMAID_JS.len(),
  453|       |                                svg_key,
  454|       |                                err
  455|       |                            ))
  456|      1|                            .family(egui::FontFamily::Monospace)
  457|      1|                            .size(code_font_size)
  458|      1|                            .color(Color32::from_rgb(180, 180, 180)),
  459|       |                        );
  460|      1|                        ui.add_space(6.0);
  461|      1|                        ui.label(
  462|      1|                            RichText::new(code)
  463|      1|                                .family(egui::FontFamily::Monospace)
  464|      1|                                .size(code_font_size)
  465|      1|                                .color(Color32::from_rgb(180, 180, 180)),
  466|       |                        );
  467|      1|                    });
  468|      1|                return true;
  469|      7|            }
  470|      7|            let svg = self.mermaid_svg_cache.borrow_mut().get(&svg_key);
  471|      7|            let pending = self.mermaid_pending.borrow().contains(&texture_key);
  472|      7|            let mut waiting_for_slot = false;
  473|       |
  474|      7|            if !pending {
  ------------------
  |  Branch (474:16): [True: 6, False: 1]
  ------------------
  475|      6|                let (request_code, request_svg) = match svg {
  476|      0|                    Some(svg) => (None, Some(svg)),
  477|      6|                    None => (Some(code.to_string()), None),
  478|       |                };
  479|      6|                let request = MermaidRequest {
  480|      6|                    svg_key,
  481|      6|                    texture_key: texture_key.clone(),
  482|      6|                    code: request_code,
  483|      6|                    svg: request_svg,
  484|      6|                    width_bucket,
  485|      6|                    scale_bucket,
  486|      6|                    viewport_width,
  487|      6|                    viewport_height,
  488|      6|                    bg,
  489|      6|                };
  490|      6|                match self.enqueue_mermaid_job(request) {
  491|      4|                    Ok(()) => {
  492|      4|                        self.mermaid_pending
  493|      4|                            .borrow_mut()
  494|      4|                            .insert(texture_key.clone());
  495|      4|                        ui.ctx().request_repaint();
  496|      4|                    }
  497|      1|                    Err(MermaidEnqueueError::QueueFull) => {
  498|      1|                        waiting_for_slot = true;
  499|      1|                        ui.ctx().request_repaint();
  500|      1|                    }
  501|       |                    Err(MermaidEnqueueError::Disconnected) => {
  502|      1|                        self.mermaid_errors
  503|      1|                            .borrow_mut()
  504|      1|                            .insert(svg_key, "Mermaid worker pool unavailable".to_string());
  505|      1|                        egui::Frame::none()
  506|      1|                            .fill(Color32::from_rgb(25, 25, 25))
  507|      1|                            .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  508|      1|                            .inner_margin(8.0)
  509|      1|                            .show(ui, |ui| {
  510|      1|                                ui.label(
  511|      1|                                    RichText::new("Mermaid worker pool unavailable.")
  512|      1|                                        .color(Color32::from_rgb(200, 160, 80))
  513|      1|                                        .family(egui::FontFamily::Monospace)
  514|      1|                                        .size(code_font_size),
  515|       |                                );
  516|      1|                                ui.add_space(6.0);
  517|      1|                                ui.label(
  518|      1|                                    RichText::new(code)
  519|      1|                                        .family(egui::FontFamily::Monospace)
  520|      1|                                        .size(code_font_size)
  521|      1|                                        .color(Color32::from_rgb(180, 180, 180)),
  522|       |                                );
  523|      1|                            });
  524|      1|                        return true;
  525|       |                    }
  526|       |                }
  527|      1|            }
  528|       |
  529|      6|            let inflight = self.mermaid_pending.borrow().len();
  530|      6|            self.mermaid_frame_pending.set(true);
  531|      6|            egui::Frame::none()
  532|      6|                .fill(Color32::from_rgb(25, 25, 25))
  533|      6|                .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
  534|      6|                .inner_margin(8.0)
  535|      6|                .show(ui, |ui| {
  536|      6|                    if waiting_for_slot {
  ------------------
  |  Branch (536:24): [True: 1, False: 5]
  ------------------
  537|      1|                        ui.label(
  538|      1|                            RichText::new(format!(
  539|      1|                                "Mermaid workers busy ({}/{}) - request queued.",
  540|      1|                                inflight,
  541|      1|                                Self::MAX_MERMAID_JOBS
  542|      1|                            ))
  543|      1|                            .color(Color32::from_rgb(200, 160, 80))
  544|      1|                            .family(egui::FontFamily::Monospace)
  545|      1|                            .size(code_font_size),
  546|      1|                        );
  547|      5|                    } else {
  548|      5|                        ui.label(
  549|      5|                            RichText::new("Rendering diagram locally...")
  550|      5|                                .color(Color32::from_rgb(160, 200, 240)),
  551|      5|                        );
  552|      5|                    }
  553|      6|                });
  554|      6|            return true;
  555|       |        }
  556|       |        #[cfg(not(feature = "mermaid-quickjs"))]
  557|       |        {
  558|       |            false
  559|       |        }
  560|     12|    }
  561|       |
  562|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  563|     15|    fn width_bucket(available_width: f32) -> u32 {
  564|     15|        let step = Self::MERMAID_WIDTH_BUCKET_STEP;
  565|     15|        let width = available_width.max(1.0).ceil() as u32;
  566|     15|        width.div_ceil(step) * step
  567|     15|    }
  568|       |
  569|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  570|     31|    fn scale_bucket(ui_scale: f32) -> u32 {
  571|     31|        let clamped = ui_scale.clamp(0.5, 4.0);
  572|     31|        (clamped * Self::MERMAID_SCALE_BUCKET_FACTOR).round() as u32
  573|     31|    }
  574|       |
  575|     12|    fn mermaid_diagram_kind(code: &str) -> Option<String> {
  576|     17|        for line in code.lines() {
                                  ^12  ^12
  577|     17|            let trimmed = line.trim();
  578|     17|            if trimmed.is_empty() {
  ------------------
  |  Branch (578:16): [True: 3, False: 14]
  ------------------
  579|      3|                continue;
  580|     14|            }
  581|     14|            if trimmed.starts_with("%%") {
  ------------------
  |  Branch (581:16): [True: 4, False: 10]
  ------------------
  582|      4|                continue;
  583|     10|            }
  584|     10|            return trimmed
  585|     10|                .split_whitespace()
  586|     10|                .next()
  587|     10|                .map(|token| token.to_ascii_lowercase());
  588|       |        }
  589|      2|        None
  590|     12|    }
  591|       |
  592|       |    #[cfg(feature = "mermaid-quickjs")]
  593|     13|    fn scale_from_bucket(scale_bucket: u32) -> f32 {
  594|     13|        let scale = scale_bucket as f32 / Self::MERMAID_SCALE_BUCKET_FACTOR;
  595|     13|        scale.clamp(0.5, 4.0)
  596|     13|    }
  597|       |
  598|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  599|     17|    fn mermaid_bg_key(bg: Option<[u8; 4]>) -> String {
  600|     17|        match bg {
  601|     16|            Some([r, g, b, a]) => format!("{:02x}{:02x}{:02x}{:02x}", r, g, b, a),
  602|      1|            None => "none".to_string(),
  603|       |        }
  604|     17|    }
  605|       |
  606|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  607|     15|    fn texture_key(
  608|     15|        svg_key: u64,
  609|     15|        width_bucket: u32,
  610|     15|        scale_bucket: u32,
  611|     15|        bg: Option<[u8; 4]>,
  612|     15|    ) -> String {
  613|     15|        let bg_key = Self::mermaid_bg_key(bg);
  614|     15|        format!(
  615|     15|            "mermaid:{:016x}:w{}:s{}:bg{}",
  616|       |            svg_key, width_bucket, scale_bucket, bg_key
  617|       |        )
  618|     15|    }
  619|       |
  620|       |    #[cfg(feature = "mermaid-quickjs")]
  621|     15|    fn poll_mermaid_results(&self, ctx: &egui::Context) -> bool {
  622|     15|        let mut changed = false;
  623|     21|        while let Ok(result) = self.mermaid_result_rx.try_recv() {
                                   ^6
  ------------------
  |  Branch (623:19): [True: 6, False: 15]
  ------------------
  624|       |            let MermaidResult {
  625|      6|                svg_key,
  626|      6|                texture_key,
  627|      6|                svg,
  628|      6|                rgba,
  629|      6|                size,
  630|      6|                error,
  631|      6|            } = result;
  632|      6|            let has_svg = svg.is_some();
  633|      6|            self.mermaid_pending.borrow_mut().remove(&texture_key);
  634|       |
  635|      6|            if let Some(svg) = svg {
                                      ^3
  ------------------
  |  Branch (635:20): [True: 3, False: 3]
  ------------------
  636|      3|                self.mermaid_svg_cache.borrow_mut().insert(svg_key, svg);
  637|      3|                self.mermaid_errors.borrow_mut().remove(&svg_key);
  638|      3|            }
  639|       |
  640|      6|            if let Some(rgba) = rgba {
                                      ^2
  ------------------
  |  Branch (640:20): [True: 2, False: 4]
  ------------------
  641|      2|                if let Some((w, h)) = size {
                                           ^1 ^1
  ------------------
  |  Branch (641:24): [True: 1, False: 1]
  ------------------
  642|      1|                    let img =
  643|      1|                        egui::ColorImage::from_rgba_unmultiplied([w as usize, h as usize], &rgba);
  644|      1|                    let tex =
  645|      1|                        ctx.load_texture(texture_key.clone(), img, egui::TextureOptions::LINEAR);
  646|      1|                    self.store_mermaid_texture(&texture_key, tex.clone(), [w, h]);
  647|      1|                    self.mermaid_texture_errors
  648|      1|                        .borrow_mut()
  649|      1|                        .remove(&texture_key);
  650|      1|                } else {
  651|      1|                    self.mermaid_texture_errors.borrow_mut().insert(
  652|      1|                        texture_key.clone(),
  653|      1|                        "Mermaid rasterization failed (missing size)".to_string(),
  654|      1|                    );
  655|      1|                }
  656|      4|            }
  657|       |
  658|      6|            if let Some(err) = error {
                                      ^2
  ------------------
  |  Branch (658:20): [True: 2, False: 4]
  ------------------
  659|      2|                if !has_svg {
  ------------------
  |  Branch (659:20): [True: 1, False: 1]
  ------------------
  660|      1|                    self.mermaid_errors.borrow_mut().insert(svg_key, err);
  661|      1|                } else {
  662|      1|                    self.mermaid_texture_errors
  663|      1|                        .borrow_mut()
  664|      1|                        .insert(texture_key, err);
  665|      1|                }
  666|      4|            }
  667|       |
  668|      6|            changed = true;
  669|       |        }
  670|     15|        changed
  671|     15|    }
  672|       |
  673|       |    #[cfg(feature = "mermaid-quickjs")]
  674|      6|    fn enqueue_mermaid_job(&self, request: MermaidRequest) -> Result<(), MermaidEnqueueError> {
  675|      6|        let Some(ref tx) = self.mermaid_job_tx else {
                               ^5
  ------------------
  |  Branch (675:13): [True: 5, False: 1]
  ------------------
  676|      1|            return Err(MermaidEnqueueError::Disconnected);
  677|       |        };
  678|      5|        match tx.try_send(request) {
  679|      4|            Ok(()) => Ok(()),
  680|      1|            Err(TrySendError::Full(_)) => Err(MermaidEnqueueError::QueueFull),
  681|      0|            Err(TrySendError::Disconnected(_)) => Err(MermaidEnqueueError::Disconnected),
  682|       |        }
  683|      6|    }
  684|       |
  685|       |    #[cfg(feature = "mermaid-quickjs")]
  686|    278|    fn mermaid_worker_count() -> usize {
  687|    278|        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_WORKERS") {
                                ^3
  ------------------
  |  Branch (687:16): [True: 3, False: 275]
  ------------------
  688|      3|            if let Ok(value) = raw.trim().parse::<usize>() {
                                    ^2
  ------------------
  |  Branch (688:20): [True: 2, False: 1]
  ------------------
  689|      2|                return value.clamp(1, 16);
  690|      1|            }
  691|    275|        }
  692|    276|        let default = std::thread::available_parallelism()
  693|    276|            .map(|n| n.get())
  694|    276|            .unwrap_or(1);
  695|    276|        default.min(Self::MAX_MERMAID_JOBS.max(1))
  696|    278|    }
  697|       |
  698|       |    #[cfg(feature = "mermaid-quickjs")]
  699|     11|    fn mermaid_timeout_ms() -> u64 {
  700|     11|        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_TIMEOUT_MS") {
                                ^3
  ------------------
  |  Branch (700:16): [True: 3, False: 8]
  ------------------
  701|      3|            if let Ok(value) = raw.trim().parse::<u64>() {
                                    ^2
  ------------------
  |  Branch (701:20): [True: 2, False: 1]
  ------------------
  702|      2|                return value.max(100);
  703|      1|            }
  704|      8|        }
  705|      9|        30_000
  706|     11|    }
  707|       |
  708|       |    #[cfg(feature = "mermaid-quickjs")]
  709|    275|    fn spawn_mermaid_workers(
  710|    275|        job_rx: MermaidJobReceiver,
  711|    275|        result_tx: MermaidResultSender,
  712|    275|    ) -> Vec<JoinHandle<()>> {
  713|    275|        let worker_count = Self::mermaid_worker_count();
  714|    275|        let mut fontdb = usvg::fontdb::Database::new();
  715|    275|        fontdb.load_system_fonts();
  716|    275|        let fontdb = Arc::new(fontdb);
  717|    275|        let mut handles = Vec::with_capacity(worker_count);
  718|  1.10k|        for worker_idx in 0..worker_count {
                                           ^275
  719|  1.10k|            let worker_rx = job_rx.clone();
  720|  1.10k|            let worker_tx = result_tx.clone();
  721|  1.10k|            let worker_fontdb = Arc::clone(&fontdb);
  722|  1.10k|            match std::thread::Builder::new()
  723|  1.10k|                .name(format!("mdmdview-mermaid-{worker_idx}"))
  724|  1.10k|                .spawn(move || {
  725|  1.10k|                    let mut worker = MermaidWorker::new(worker_idx, worker_fontdb).map_err(|e| {
                                                                                                             ^0
  726|      0|                        eprintln!("Mermaid worker init failed: {}", e);
  727|      0|                        e
  728|      0|                    });
  729|  1.10k|                    for job in worker_rx.iter() {
                                      ^3
  730|      3|                        let payload = match &mut worker {
  731|      3|                            Ok(state) => state.process_job(job),
  732|      0|                            Err(err) => {
  733|       |                                let MermaidRequest {
  734|      0|                                    svg_key,
  735|      0|                                    texture_key,
  736|      0|                                    svg,
  737|       |                                    ..
  738|      0|                                } = job;
  739|      0|                                MermaidResult {
  740|      0|                                    svg_key,
  741|      0|                                    texture_key,
  742|      0|                                    svg,
  743|      0|                                    rgba: None,
  744|      0|                                    size: None,
  745|      0|                                    error: Some(err.clone()),
  746|      0|                                }
  747|       |                            }
  748|       |                        };
  749|      3|                        let _ = worker_tx.send(payload);
  750|       |                    }
  751|  1.10k|                }) {
  752|  1.10k|                Ok(handle) => handles.push(handle),
  753|      0|                Err(err) => eprintln!("Failed to start Mermaid worker thread: {}", err),
  754|       |            }
  755|       |        }
  756|    275|        drop(job_rx);
  757|    275|        handles
  758|    275|    }
  759|       |
  760|       |    #[cfg(feature = "mermaid-quickjs")]
  761|      1|    fn store_mermaid_texture(&self, key: &str, texture: egui::TextureHandle, size: [u32; 2]) {
  762|      1|        self.mermaid_textures
  763|      1|            .borrow_mut()
  764|      1|            .insert(key.to_string(), MermaidTextureEntry { texture, size });
  765|      1|    }
  766|       |
  767|       |    #[cfg(feature = "mermaid-quickjs")]
  768|     17|    fn mermaid_theme_values() -> MermaidThemeValues {
  769|     17|        let def_main_bkg = "#FFF8DB";
  770|     17|        let def_primary = "#D7EEFF";
  771|     17|        let def_primary_border = "#9BB2C8";
  772|     17|        let def_primary_text = "#1C2430";
  773|     17|        let def_secondary = "#DFF5E1";
  774|     17|        let def_tertiary = "#E9E2FF";
  775|     17|        let def_line = "#6B7A90";
  776|     17|        let def_text = "#1C2430";
  777|     17|        let def_cluster_bkg = "#FFF1C1";
  778|     17|        let def_cluster_border = "#E5C07B";
  779|     17|        let def_default_link = def_line;
  780|     17|        let def_title = def_text;
  781|     17|        let def_label_bg = def_main_bkg;
  782|     17|        let def_edge_label_bg = def_main_bkg;
  783|       |
  784|     17|        let theme_name =
  785|     17|            std::env::var("MDMDVIEW_MERMAID_THEME").unwrap_or_else(|_| "base".to_string());
  786|     17|        let main_bkg =
  787|     17|            std::env::var("MDMDVIEW_MERMAID_MAIN_BKG").unwrap_or_else(|_| def_main_bkg.to_string());
  788|     17|        let primary = std::env::var("MDMDVIEW_MERMAID_PRIMARY_COLOR")
  789|     17|            .unwrap_or_else(|_| def_primary.to_string());
  790|     17|        let primary_border = std::env::var("MDMDVIEW_MERMAID_PRIMARY_BORDER")
  791|     17|            .unwrap_or_else(|_| def_primary_border.to_string());
  792|     17|        let primary_text = std::env::var("MDMDVIEW_MERMAID_PRIMARY_TEXT")
  793|     17|            .unwrap_or_else(|_| def_primary_text.to_string());
  794|     17|        let secondary = std::env::var("MDMDVIEW_MERMAID_SECONDARY_COLOR")
  795|     17|            .unwrap_or_else(|_| def_secondary.to_string());
  796|     17|        let tertiary = std::env::var("MDMDVIEW_MERMAID_TERTIARY_COLOR")
  797|     17|            .unwrap_or_else(|_| def_tertiary.to_string());
  798|     17|        let line =
  799|     17|            std::env::var("MDMDVIEW_MERMAID_LINE_COLOR").unwrap_or_else(|_| def_line.to_string());
  800|     17|        let text =
  801|     17|            std::env::var("MDMDVIEW_MERMAID_TEXT_COLOR").unwrap_or_else(|_| def_text.to_string());
  802|     17|        let cluster_bkg = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BKG")
  803|     17|            .unwrap_or_else(|_| def_cluster_bkg.to_string());
  804|     17|        let cluster_border = std::env::var("MDMDVIEW_MERMAID_CLUSTER_BORDER")
  805|     17|            .unwrap_or_else(|_| def_cluster_border.to_string());
  806|     17|        let default_link = std::env::var("MDMDVIEW_MERMAID_LINK_COLOR")
  807|     17|            .unwrap_or_else(|_| def_default_link.to_string());
  808|     17|        let title =
  809|     17|            std::env::var("MDMDVIEW_MERMAID_TITLE_COLOR").unwrap_or_else(|_| def_title.to_string());
  810|     17|        let label_bg =
  811|     17|            std::env::var("MDMDVIEW_MERMAID_LABEL_BG").unwrap_or_else(|_| def_label_bg.to_string());
  812|     17|        let edge_label_bg = std::env::var("MDMDVIEW_MERMAID_EDGE_LABEL_BG")
  813|     17|            .unwrap_or_else(|_| def_edge_label_bg.to_string());
  814|     17|        let font_family = std::env::var("MDMDVIEW_MERMAID_FONT_FAMILY")
  815|     17|            .ok()
  816|     17|            .map(|value| value.trim().to_string())
                                       ^3           ^3
  817|     17|            .filter(|value| !value.is_empty());
                                           ^3    ^3
  818|       |
  819|     17|        MermaidThemeValues {
  820|     17|            theme_name,
  821|     17|            main_bkg,
  822|     17|            primary,
  823|     17|            primary_border,
  824|     17|            primary_text,
  825|     17|            secondary,
  826|     17|            tertiary,
  827|     17|            line,
  828|     17|            text,
  829|     17|            cluster_bkg,
  830|     17|            cluster_border,
  831|     17|            default_link,
  832|     17|            title,
  833|     17|            label_bg,
  834|     17|            edge_label_bg,
  835|     17|            font_family,
  836|     17|        }
  837|     17|    }
  838|       |
  839|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  840|     14|    fn mermaid_security_level() -> String {
  841|     14|        if let Ok(raw) = std::env::var("MDMDVIEW_MERMAID_SECURITY") {
                                ^3
  ------------------
  |  Branch (841:16): [True: 3, False: 11]
  ------------------
  842|      3|            let normalized = raw.trim().to_ascii_lowercase();
  843|      3|            if normalized == "loose" {
  ------------------
  |  Branch (843:16): [True: 2, False: 1]
  ------------------
  844|      2|                return "loose".to_string();
  845|      1|            }
  846|     11|        }
  847|     12|        "strict".to_string()
  848|     14|    }
  849|       |
  850|       |    #[cfg(feature = "mermaid-quickjs")]
  851|     11|    fn mermaid_site_config_json(svg_key: u64) -> String {
  852|     11|        let theme = Self::mermaid_theme_values();
  853|     11|        let security = Self::mermaid_security_level();
  854|     11|        let seed = format!("m{:016x}", svg_key);
  855|     11|        let mut entries = Vec::new();
  856|       |
  857|     11|        entries.push("\"startOnLoad\":false".to_string());
  858|     11|        entries.push(format!(
  859|     11|            "\"securityLevel\":\"{}\"",
  860|     11|            Self::json_escape(&security)
  861|       |        ));
  862|     11|        entries.push("\"deterministicIds\":true".to_string());
  863|     11|        entries.push(format!(
  864|     11|            "\"deterministicIDSeed\":\"{}\"",
  865|     11|            Self::json_escape(&seed)
  866|       |        ));
  867|     11|        entries.push(format!("\"maxTextSize\":{}", Self::MERMAID_MAX_TEXT_SIZE));
  868|     11|        if security == "strict" {
  ------------------
  |  Branch (868:12): [True: 10, False: 1]
  ------------------
  869|     10|            entries.push("\"htmlLabels\":false".to_string());
  870|     10|            entries.push("\"flowchart\":{\"htmlLabels\":false}".to_string());
  871|     10|        }
                      ^1
  872|     11|        entries.push(format!(
  873|     11|            "\"theme\":\"{}\"",
  874|     11|            Self::json_escape(&theme.theme_name)
  875|       |        ));
  876|       |
  877|     11|        let mut theme_vars = format!(
  878|     11|            concat!(
  879|       |                "\"background\":\"{}\",",
  880|       |                "\"mainBkg\":\"{}\",",
  881|       |                "\"textColor\":\"{}\",",
  882|       |                "\"titleColor\":\"{}\",",
  883|       |                "\"primaryColor\":\"{}\",",
  884|       |                "\"primaryBorderColor\":\"{}\",",
  885|       |                "\"primaryTextColor\":\"{}\",",
  886|       |                "\"secondaryColor\":\"{}\",",
  887|       |                "\"tertiaryColor\":\"{}\",",
  888|       |                "\"lineColor\":\"{}\",",
  889|       |                "\"defaultLinkColor\":\"{}\",",
  890|       |                "\"clusterBkg\":\"{}\",",
  891|       |                "\"clusterBorder\":\"{}\",",
  892|       |                "\"labelBackground\":\"{}\",",
  893|       |                "\"edgeLabelBackground\":\"{}\""
  894|       |            ),
  895|     11|            Self::json_escape(&theme.main_bkg),
  896|     11|            Self::json_escape(&theme.main_bkg),
  897|     11|            Self::json_escape(&theme.text),
  898|     11|            Self::json_escape(&theme.title),
  899|     11|            Self::json_escape(&theme.primary),
  900|     11|            Self::json_escape(&theme.primary_border),
  901|     11|            Self::json_escape(&theme.primary_text),
  902|     11|            Self::json_escape(&theme.secondary),
  903|     11|            Self::json_escape(&theme.tertiary),
  904|     11|            Self::json_escape(&theme.line),
  905|     11|            Self::json_escape(&theme.default_link),
  906|     11|            Self::json_escape(&theme.cluster_bkg),
  907|     11|            Self::json_escape(&theme.cluster_border),
  908|     11|            Self::json_escape(&theme.label_bg),
  909|     11|            Self::json_escape(&theme.edge_label_bg)
  910|       |        );
  911|     11|        if let Some(font_family) = theme.font_family.as_ref() {
                                  ^1
  ------------------
  |  Branch (911:16): [True: 1, False: 10]
  ------------------
  912|      1|            theme_vars.push_str(&format!(
  913|      1|                ",\"fontFamily\":\"{}\"",
  914|      1|                Self::json_escape(font_family)
  915|      1|            ));
  916|     10|        }
  917|     11|        entries.push(format!("\"themeVariables\":{{{}}}", theme_vars));
  918|       |
  919|     11|        format!("{{{}}}", entries.join(","))
  920|     11|    }
  921|       |
  922|       |    #[cfg(feature = "mermaid-quickjs")]
  923|    200|    fn json_escape(input: &str) -> String {
  924|    200|        let mut out = String::with_capacity(input.len());
  925|  1.50k|        for ch in input.chars() {
                                ^200  ^200
  926|  1.50k|            match ch {
  927|      1|                '\\' => out.push_str("\\\\"),
  928|      1|                '"' => out.push_str("\\\""),
  929|      1|                '\n' => out.push_str("\\n"),
  930|      1|                '\r' => out.push_str("\\r"),
  931|      1|                '\t' => out.push_str("\\t"),
  932|  1.49k|                _ => out.push(ch),
  933|       |            }
  934|       |        }
  935|    200|        out
  936|    200|    }
  937|       |
  938|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  939|     21|    fn mermaid_bg_fill() -> Option<[u8; 4]> {
  940|     21|        if let Ok(hex) = std::env::var("MDMDVIEW_MERMAID_BG_COLOR") {
                                ^3
  ------------------
  |  Branch (940:16): [True: 3, False: 18]
  ------------------
  941|      3|            if let Some(rgba) = Self::parse_hex_color(&hex) {
                                      ^2
  ------------------
  |  Branch (941:20): [True: 2, False: 1]
  ------------------
  942|      2|                return Some(rgba);
  943|      1|            }
  944|     18|        }
  945|     19|        let mode = std::env::var("MDMDVIEW_MERMAID_BG").unwrap_or_else(|_| "theme".to_string());
                                                                                         ^13     ^13
  946|     19|        match mode.as_str() {
  947|     19|            "transparent" => None,
                                           ^1
  948|     18|            "dark" => Some([20, 20, 20, 255]),
                                    ^2
  949|     16|            "light" => Some([255, 255, 255, 255]),
                                     ^1
  950|       |            _ => {
  951|     15|                let hex = std::env::var("MDMDVIEW_MERMAID_MAIN_BKG")
  952|     15|                    .unwrap_or_else(|_| "#FFF8DB".to_string());
                                                      ^13       ^13
  953|     15|                Self::parse_hex_color(&hex).or(Some([255, 248, 219, 255]))
  954|       |            }
  955|       |        }
  956|     21|    }
  957|       |
  958|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  959|     21|    fn parse_hex_color(s: &str) -> Option<[u8; 4]> {
  960|     21|        let t = s.trim();
  961|     21|        let hex = t.strip_prefix('#').unwrap_or(t);
  962|     21|        let (r, g, b, a) = match hex.len() {
                           ^18^18^18^18
  963|       |            6 => (
  964|     16|                u8::from_str_radix(&hex[0..2], 16).ok()?,
                                                                     ^0
  965|     16|                u8::from_str_radix(&hex[2..4], 16).ok()?,
                                                                     ^0
  966|     16|                u8::from_str_radix(&hex[4..6], 16).ok()?,
                                                                     ^0
  967|       |                255,
  968|       |            ),
  969|       |            8 => (
  970|      2|                u8::from_str_radix(&hex[0..2], 16).ok()?,
                                                                     ^0
  971|      2|                u8::from_str_radix(&hex[2..4], 16).ok()?,
                                                                     ^0
  972|      2|                u8::from_str_radix(&hex[4..6], 16).ok()?,
                                                                     ^0
  973|      2|                u8::from_str_radix(&hex[6..8], 16).ok()?,
                                                                     ^0
  974|       |            ),
  975|      3|            _ => return None,
  976|       |        };
  977|     18|        Some([r, g, b, a])
  978|     21|    }
  979|       |
  980|       |    #[cfg(any(test, feature = "mermaid-quickjs"))]
  981|     21|    fn hash_str(s: &str) -> u64 {
  982|     21|        let mut h = DefaultHasher::new();
  983|     21|        s.hash(&mut h);
  984|     21|        h.finish()
  985|     21|    }
  986|       |}
  987|       |
  988|       |#[cfg(feature = "mermaid-quickjs")]
  989|       |impl Drop for MermaidRenderer {
  990|    281|    fn drop(&mut self) {
  991|       |        // First, drop the job sender to close the channel.
  992|       |        // This signals workers to exit their `for job in worker_rx.iter()` loop.
  993|    281|        drop(self.mermaid_job_tx.take());
  994|       |
  995|       |        // Now join all worker threads to ensure they've fully exited
  996|       |        // and released their resources (font database, QuickJS runtime).
  997|  1.10k|        for handle in self.worker_handles.drain(..) {
                                    ^281                ^281  ^281
  998|  1.10k|            let _ = handle.join();
  999|  1.10k|        }
 1000|    281|    }
 1001|       |}
 1002|       |
 1003|       |#[cfg(feature = "mermaid-quickjs")]
 1004|       |struct TextMeasurer {
 1005|       |    fontdb: Arc<usvg::fontdb::Database>,
 1006|       |    face_id: Option<usvg::fontdb::ID>,
 1007|       |    bold_face_id: Option<usvg::fontdb::ID>,
 1008|       |}
 1009|       |
 1010|       |#[cfg(feature = "mermaid-quickjs")]
 1011|       |impl TextMeasurer {
 1012|       |    const BOLD_WIDTH_FALLBACK: f32 = 1.07;
 1013|       |    const BOLD_WIDTH_SCALE: f32 = 1.03;
 1014|       |    const LINE_HEIGHT_SCALE: f32 = 1.0;
 1015|       |
 1016|  1.12k|    fn new(fontdb: Arc<usvg::fontdb::Database>) -> Self {
 1017|  1.12k|        let families = [
 1018|  1.12k|            usvg::fontdb::Family::Name("Trebuchet MS"),
 1019|  1.12k|            usvg::fontdb::Family::Name("Verdana"),
 1020|  1.12k|            usvg::fontdb::Family::Name("Arial"),
 1021|  1.12k|            usvg::fontdb::Family::SansSerif,
 1022|  1.12k|        ];
 1023|  1.12k|        let query = usvg::fontdb::Query {
 1024|  1.12k|            families: &families,
 1025|  1.12k|            ..Default::default()
 1026|  1.12k|        };
 1027|  1.12k|        let face_id = fontdb.query(&query);
 1028|  1.12k|        let bold_query = usvg::fontdb::Query {
 1029|  1.12k|            families: &families,
 1030|  1.12k|            weight: usvg::fontdb::Weight::BOLD,
 1031|  1.12k|            ..Default::default()
 1032|  1.12k|        };
 1033|  1.12k|        let bold_face_id = fontdb.query(&bold_query).or(face_id);
 1034|  1.12k|        Self {
 1035|  1.12k|            fontdb,
 1036|  1.12k|            face_id,
 1037|  1.12k|            bold_face_id,
 1038|  1.12k|        }
 1039|  1.12k|    }
 1040|       |
 1041|     37|    fn measure_text(&self, text: &str, font_size: f32, font_weight: Option<f32>) -> (f32, f32) {
 1042|     37|        if text.is_empty() {
  ------------------
  |  Branch (1042:12): [True: 1, False: 36]
  ------------------
 1043|      1|            return (0.0, 0.0);
 1044|     36|        }
 1045|     36|        let size = if font_size.is_finite() && font_size > 0.0 {
                                                             ^35
  ------------------
  |  Branch (1045:23): [True: 35, False: 1]
  |  Branch (1045:48): [True: 34, False: 1]
  ------------------
 1046|     34|            font_size
 1047|       |        } else {
 1048|      2|            16.0
 1049|       |        };
 1050|     36|        let use_bold = font_weight.unwrap_or(400.0) >= 600.0;
 1051|     36|        let face_id = if use_bold {
  ------------------
  |  Branch (1051:26): [True: 4, False: 32]
  ------------------
 1052|      4|            self.bold_face_id.or(self.face_id)
 1053|       |        } else {
 1054|     32|            self.face_id
 1055|       |        };
 1056|     36|        if let Some((width, height)) = self.measure_with_face(face_id, text, size) {
                                   ^35    ^35
  ------------------
  |  Branch (1056:16): [True: 35, False: 1]
  ------------------
 1057|     35|            if use_bold {
  ------------------
  |  Branch (1057:16): [True: 3, False: 32]
  ------------------
 1058|      3|                let mut adjusted = width * Self::BOLD_WIDTH_SCALE;
 1059|      3|                if self.bold_face_id == self.face_id {
  ------------------
  |  Branch (1059:20): [True: 1, False: 2]
  ------------------
 1060|      1|                    adjusted *= Self::BOLD_WIDTH_FALLBACK;
 1061|      2|                }
 1062|      3|                return (adjusted, height);
 1063|     32|            }
 1064|     32|            return (width, height);
 1065|      1|        }
 1066|      1|        Self::fallback_measure(text, size)
 1067|     37|    }
 1068|       |
 1069|     36|    fn measure_with_face(
 1070|     36|        &self,
 1071|     36|        face_id: Option<usvg::fontdb::ID>,
 1072|     36|        text: &str,
 1073|     36|        font_size: f32,
 1074|     36|    ) -> Option<(f32, f32)> {
 1075|     36|        let face_id = face_id?;
                          ^35              ^1
 1076|     35|        self.fontdb
 1077|     35|            .with_face_data(face_id, |data, index| {
 1078|     35|                let face = ttf_parser::Face::parse(data, index).ok()?;
                                                                                  ^0
 1079|     35|                let units_per_em = face.units_per_em() as f32;
 1080|     35|                if !units_per_em.is_finite() || units_per_em <= 0.0 {
  ------------------
  |  Branch (1080:20): [True: 0, False: 35]
  |  Branch (1080:49): [True: 0, False: 35]
  ------------------
 1081|      0|                    return None;
 1082|     35|                }
 1083|     35|                let scale = font_size / units_per_em;
 1084|     35|                let fallback_advance = units_per_em * 0.5;
 1085|     35|                let kern_subtables: Vec<_> = face
 1086|     35|                    .tables()
 1087|     35|                    .kern
 1088|     35|                    .map(|kern| {
 1089|     35|                        kern.subtables
 1090|     35|                            .into_iter()
 1091|     35|                            .filter(|table| {
 1092|     35|                                table.horizontal
  ------------------
  |  Branch (1092:33): [True: 35, False: 0]
  ------------------
 1093|     35|                                    && !table.has_cross_stream
  ------------------
  |  Branch (1093:40): [True: 35, False: 0]
  ------------------
 1094|     35|                                    && !table.variable
  ------------------
  |  Branch (1094:40): [True: 35, False: 0]
  ------------------
 1095|     35|                                    && !table.has_state_machine
 1096|     35|                            })
 1097|     35|                            .collect()
 1098|     35|                    })
 1099|     35|                    .unwrap_or_default();
 1100|     35|                let mut max_width_units = 0.0_f32;
 1101|     35|                let mut line_count = 0u32;
 1102|       |
 1103|     35|                for line in text.split('\n') {
 1104|     35|                    line_count += 1;
 1105|     35|                    let mut width_units = 0.0_f32;
 1106|     35|                    let mut prev = None;
 1107|    152|                    for ch in line.chars() {
                                            ^35  ^35
 1108|    152|                        if let Some(glyph) = face.glyph_index(ch) {
                                                  ^151
  ------------------
  |  Branch (1108:32): [True: 151, False: 1]
  ------------------
 1109|    151|                            if let Some(prev_glyph) = prev {
                                                      ^117
  ------------------
  |  Branch (1109:36): [True: 117, False: 34]
  ------------------
 1110|    117|                                let mut kern = 0.0_f32;
 1111|    234|                                for table in &kern_subtables {
                                                  ^117
 1112|    117|                                    if let Some(value) = table.glyphs_kerning(prev_glyph, glyph) {
                                                              ^6
  ------------------
  |  Branch (1112:44): [True: 6, False: 111]
  ------------------
 1113|      6|                                        kern += value as f32;
 1114|    111|                                    }
 1115|       |                                }
 1116|    117|                                width_units += kern;
 1117|     34|                            }
 1118|    151|                            if let Some(adv) = face.glyph_hor_advance(glyph) {
  ------------------
  |  Branch (1118:36): [True: 151, False: 0]
  ------------------
 1119|    151|                                width_units += adv as f32;
 1120|    151|                            } else {
 1121|      0|                                width_units += fallback_advance;
 1122|      0|                            }
 1123|    151|                            prev = Some(glyph);
 1124|      1|                        } else {
 1125|      1|                            width_units += fallback_advance;
 1126|      1|                            prev = None;
 1127|      1|                        }
 1128|       |                    }
 1129|     35|                    if width_units > max_width_units {
  ------------------
  |  Branch (1129:24): [True: 35, False: 0]
  ------------------
 1130|     35|                        max_width_units = width_units;
 1131|     35|                    }
                                  ^0
 1132|       |                }
 1133|       |
 1134|     35|                let ascender = face.ascender() as f32;
 1135|     35|                let descender = face.descender() as f32;
 1136|     35|                let line_gap = face.line_gap() as f32;
 1137|     35|                let mut line_height_units = ascender - descender + line_gap;
 1138|     35|                if !line_height_units.is_finite() || line_height_units <= 0.0 {
  ------------------
  |  Branch (1138:20): [True: 0, False: 35]
  |  Branch (1138:54): [True: 0, False: 35]
  ------------------
 1139|      0|                    line_height_units = units_per_em;
 1140|     35|                }
 1141|     35|                let line_height = line_height_units * scale * Self::LINE_HEIGHT_SCALE;
 1142|     35|                let width = max_width_units * scale;
 1143|     35|                let height = line_height * line_count as f32;
 1144|     35|                if width.is_finite() && height.is_finite() {
  ------------------
  |  Branch (1144:20): [True: 35, False: 0]
  |  Branch (1144:41): [True: 35, False: 0]
  ------------------
 1145|     35|                    Some((width, height))
 1146|       |                } else {
 1147|      0|                    None
 1148|       |                }
 1149|     35|            })
 1150|     35|            .flatten()
 1151|     36|    }
 1152|       |
 1153|      1|    fn fallback_measure(text: &str, font_size: f32) -> (f32, f32) {
 1154|      1|        let mut max_len = 0usize;
 1155|      1|        let mut lines = 0usize;
 1156|      1|        for line in text.split('\n') {
 1157|      1|            lines += 1;
 1158|      1|            let len = line.chars().count();
 1159|      1|            if len > max_len {
  ------------------
  |  Branch (1159:16): [True: 1, False: 0]
  ------------------
 1160|      1|                max_len = len;
 1161|      1|            }
                          ^0
 1162|       |        }
 1163|      1|        let width = max_len as f32 * font_size * 0.5;
 1164|      1|        let height = lines as f32 * font_size * 1.2;
 1165|      1|        (width, height)
 1166|      1|    }
 1167|       |}
 1168|       |
 1169|       |#[cfg(feature = "mermaid-quickjs")]
 1170|       |struct MermaidWorker {
 1171|       |    engine: MermaidEngine,
 1172|       |    deadline_ms: Arc<AtomicU64>,
 1173|       |    fontdb: Arc<usvg::fontdb::Database>,
 1174|       |    #[allow(dead_code)]
 1175|       |    text_measurer: Arc<TextMeasurer>,
 1176|       |}
 1177|       |
 1178|       |#[cfg(feature = "mermaid-quickjs")]
 1179|       |impl MermaidWorker {
 1180|       |    const MEMORY_LIMIT_BYTES: usize = 2 * 1024 * 1024 * 1024;
 1181|       |    const STACK_LIMIT_BYTES: usize = 4 * 1024 * 1024;
 1182|       |
 1183|       |    // DOMPurify expects a real browser DOM; stub sanitize for the QuickJS shim.
 1184|  1.12k|    fn patch_mermaid_js(js: &str) -> String {
 1185|       |        const TARGET: &str = "var hD=wRe();";
 1186|       |        const PATCH: &str =
 1187|       |            "var hD=wRe();if(!hD||typeof hD.sanitize!==\"function\"){hD={sanitize:function(html){return String(html);},addHook:function(){},removeHook:function(){},removeHooks:function(){},removeAllHooks:function(){},isSupported:true};}";
 1188|       |        const D3_TARGET: &str = "FY.prototype={constructor:FY,appendChild:function(i){return this._parent.insertBefore(i,this._next)},insertBefore:function(i,s){return this._parent.insertBefore(i,s)},querySelector:function(i){return this._parent.querySelector(i)},querySelectorAll:function(i){return this._parent.querySelectorAll(i)}};";
 1189|       |        const D3_PATCH: &str = "FY.prototype={constructor:FY,appendChild:function(i){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p?p.insertBefore(i,this._next):i},insertBefore:function(i,s){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p?p.insertBefore(i,s):i},querySelector:function(i){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p&&p.querySelector?p.querySelector(i):null},querySelectorAll:function(i){var p=this._parent||((typeof document!==\"undefined\"&&document.body)?document.body:null);return p&&p.querySelectorAll?p.querySelectorAll(i):[]}};";
 1190|       |        const D3_CTOR_TARGET: &str =
 1191|       |            "function FY(i,s){this.ownerDocument=i.ownerDocument,this.namespaceURI=i.namespaceURI,this._next=null,this._parent=i,this.__data__=s}";
 1192|       |        const D3_CTOR_PATCH: &str =
 1193|       |            "function FY(i,s){i=i||((typeof document!==\"undefined\"&&document.body)?document.body:null);this.ownerDocument=i&&i.ownerDocument?i.ownerDocument:(typeof document!==\"undefined\"?document:null);this.namespaceURI=i&&i.namespaceURI?i.namespaceURI:null;this._next=null;this._parent=i;this.__data__=s}";
 1194|       |        const TEXT_WRAP_TARGET: &str = "u.text().split(/(\\s+|<br>)/).reverse()";
 1195|       |        const TEXT_WRAP_PATCH: &str = concat!(
 1196|       |            "String(typeof u.text===\"function\"?u.text():(u.textContent||\"\"))",
 1197|       |            ".split(/(\\s+|<br>)/).reverse()"
 1198|       |        );
 1199|       |        const MINDMAP_LAYOUT_TARGET: &str =
 1200|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 1201|       |        const MINDMAP_LAYOUT_PATCH: &str =
 1202|       |            "p.layout({name:\"breadthfirst\",directed:!0,spacingFactor:1.4,animate:!1}).run()";
 1203|       |        const MINDMAP_READY_TARGET: &str =
 1204|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run(),p.ready(v=>{Xe.info(\"Ready\",v),u(p)})";
 1205|       |        const MINDMAP_READY_PATCH: &str =
 1206|       |            "p.layout({name:\"breadthfirst\",directed:!0,spacingFactor:1.4,animate:!1}).run(),u(p)";
 1207|       |        const MINDMAP_CYTO_TARGET: &str =
 1208|       |            "p=fWe({container:document.getElementById(\"cy\"),style:[{selector:\"edge\",style:{\"curve-style\":\"bezier\"}}]});";
 1209|       |        const MINDMAP_CYTO_PATCH: &str =
 1210|       |            "p=__mdmdview_cytoscape_stub({container:document.getElementById(\"cy\")});";
 1211|       |        const TIMELINE_BOUNDS_TARGET: &str = "const se=_.node().getBBox();";
 1212|       |        const TIMELINE_BOUNDS_PATCH: &str = concat!(
 1213|       |            "const se=_.node().getBBox();",
 1214|       |            "if(se&&typeof se.width===\"number\"&&typeof v===\"number\"){",
 1215|       |            "se.width=Math.max(0,se.width-2*v);",
 1216|       |            "}"
 1217|       |        );
 1218|  1.12k|        let mut out = if js.contains(TARGET) {
  ------------------
  |  Branch (1218:26): [True: 1.11k, False: 4]
  ------------------
 1219|  1.11k|            js.replacen(TARGET, PATCH, 1)
 1220|       |        } else {
 1221|      4|            js.to_string()
 1222|       |        };
 1223|  1.12k|        let debug = std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG").is_ok();
 1224|  1.12k|        if out.contains(D3_CTOR_TARGET) {
  ------------------
  |  Branch (1224:12): [True: 1.11k, False: 4]
  ------------------
 1225|  1.11k|            out = out.replacen(D3_CTOR_TARGET, D3_CTOR_PATCH, 1);
 1226|  1.11k|            if debug {
  ------------------
  |  Branch (1226:16): [True: 1, False: 1.11k]
  ------------------
 1227|      1|                eprintln!("Mermaid patch: D3 ctor applied");
 1228|  1.11k|            }
 1229|      4|        } else if debug {
  ------------------
  |  Branch (1229:19): [True: 2, False: 2]
  ------------------
 1230|      2|            eprintln!("Mermaid patch: D3 ctor not found");
 1231|      2|        }
 1232|  1.12k|        if out.contains(D3_TARGET) {
  ------------------
  |  Branch (1232:12): [True: 1.11k, False: 4]
  ------------------
 1233|  1.11k|            out = out.replacen(D3_TARGET, D3_PATCH, 1);
 1234|  1.11k|            if debug {
  ------------------
  |  Branch (1234:16): [True: 1, False: 1.11k]
  ------------------
 1235|      1|                eprintln!("Mermaid patch: D3 enter applied");
 1236|  1.11k|            }
 1237|      4|        } else if debug {
  ------------------
  |  Branch (1237:19): [True: 2, False: 2]
  ------------------
 1238|      2|            eprintln!("Mermaid patch: D3 enter not found");
 1239|      2|        }
 1240|  1.12k|        if out.contains(TEXT_WRAP_TARGET) {
  ------------------
  |  Branch (1240:12): [True: 1.11k, False: 4]
  ------------------
 1241|  1.11k|            out = out.replacen(TEXT_WRAP_TARGET, TEXT_WRAP_PATCH, 1);
 1242|  1.11k|            if debug {
  ------------------
  |  Branch (1242:16): [True: 1, False: 1.11k]
  ------------------
 1243|      1|                eprintln!("Mermaid patch: D3 text wrap applied");
 1244|  1.11k|            }
 1245|      4|        } else if debug {
  ------------------
  |  Branch (1245:19): [True: 2, False: 2]
  ------------------
 1246|      2|            eprintln!("Mermaid patch: D3 text wrap not found");
 1247|      2|        }
 1248|  1.12k|        let mut mindmap_layout_patched = false;
 1249|  1.12k|        if out.contains(MINDMAP_CYTO_TARGET) {
  ------------------
  |  Branch (1249:12): [True: 1.11k, False: 4]
  ------------------
 1250|  1.11k|            out = out.replacen(MINDMAP_CYTO_TARGET, MINDMAP_CYTO_PATCH, 1);
 1251|  1.11k|            if debug {
  ------------------
  |  Branch (1251:16): [True: 1, False: 1.11k]
  ------------------
 1252|      1|                eprintln!("Mermaid patch: mindmap cytoscape stub applied");
 1253|  1.11k|            }
 1254|      4|        } else if debug {
  ------------------
  |  Branch (1254:19): [True: 2, False: 2]
  ------------------
 1255|      2|            eprintln!("Mermaid patch: mindmap cytoscape stub not found");
 1256|      2|        }
 1257|  1.12k|        if out.contains(MINDMAP_READY_TARGET) {
  ------------------
  |  Branch (1257:12): [True: 1.11k, False: 4]
  ------------------
 1258|  1.11k|            out = out.replacen(MINDMAP_READY_TARGET, MINDMAP_READY_PATCH, 1);
 1259|  1.11k|            mindmap_layout_patched = true;
 1260|  1.11k|            if debug {
  ------------------
  |  Branch (1260:16): [True: 1, False: 1.11k]
  ------------------
 1261|      1|                eprintln!("Mermaid patch: mindmap ready patch applied");
 1262|  1.11k|            }
 1263|      4|        } else if out.contains(MINDMAP_LAYOUT_TARGET) {
  ------------------
  |  Branch (1263:19): [True: 3, False: 1]
  ------------------
 1264|      3|            out = out.replacen(MINDMAP_LAYOUT_TARGET, MINDMAP_LAYOUT_PATCH, 1);
 1265|      3|            mindmap_layout_patched = true;
 1266|      3|            if debug {
  ------------------
  |  Branch (1266:16): [True: 1, False: 2]
  ------------------
 1267|      1|                eprintln!("Mermaid patch: mindmap layout applied");
 1268|      2|            }
 1269|      1|        }
 1270|  1.12k|        if !mindmap_layout_patched && debug {
                                                    ^1
  ------------------
  |  Branch (1270:12): [True: 1, False: 1.12k]
  |  Branch (1270:39): [True: 1, False: 0]
  ------------------
 1271|      1|            eprintln!("Mermaid patch: mindmap layout not found");
 1272|  1.12k|        }
 1273|  1.12k|        if out.contains(TIMELINE_BOUNDS_TARGET) {
  ------------------
  |  Branch (1273:12): [True: 1.11k, False: 4]
  ------------------
 1274|  1.11k|            out = out.replacen(TIMELINE_BOUNDS_TARGET, TIMELINE_BOUNDS_PATCH, 1);
 1275|  1.11k|            if debug {
  ------------------
  |  Branch (1275:16): [True: 1, False: 1.11k]
  ------------------
 1276|      1|                eprintln!("Mermaid patch: timeline bounds applied");
 1277|  1.11k|            }
 1278|      4|        } else if debug {
  ------------------
  |  Branch (1278:19): [True: 2, False: 2]
  ------------------
 1279|      2|            eprintln!("Mermaid patch: timeline bounds not found");
 1280|      2|        }
 1281|  1.12k|        out
 1282|  1.12k|    }
 1283|       |
 1284|     17|    fn format_js_error(ctx: &rquickjs::Ctx<'_>, err: rquickjs::Error) -> String {
 1285|     17|        if let rquickjs::Error::Exception = err {
  ------------------
  |  Branch (1285:16): [True: 16, False: 1]
  ------------------
 1286|     16|            let value = ctx.catch();
 1287|     16|            if let Some(exception) = value.as_exception() {
                                      ^9
  ------------------
  |  Branch (1287:20): [True: 9, False: 7]
  ------------------
 1288|      9|                let message = exception.message();
 1289|      9|                let stack = exception.stack();
 1290|      9|                if let Some(stack) = stack {
                                          ^8
  ------------------
  |  Branch (1290:24): [True: 8, False: 1]
  ------------------
 1291|      8|                    if let Some(message) = message {
                                              ^7
  ------------------
  |  Branch (1291:28): [True: 7, False: 1]
  ------------------
 1292|      7|                        if stack.contains(&message) {
  ------------------
  |  Branch (1292:28): [True: 1, False: 6]
  ------------------
 1293|      1|                            return stack;
 1294|      6|                        }
 1295|      6|                        if !stack.trim().is_empty() {
  ------------------
  |  Branch (1295:28): [True: 4, False: 2]
  ------------------
 1296|      4|                            return format!("{}\n{}", message, stack);
 1297|      2|                        }
 1298|      2|                        if !message.trim().is_empty() {
  ------------------
  |  Branch (1298:28): [True: 2, False: 0]
  ------------------
 1299|      2|                            return message;
 1300|      0|                        }
 1301|      1|                    } else if !stack.trim().is_empty() {
  ------------------
  |  Branch (1301:31): [True: 1, False: 0]
  ------------------
 1302|      1|                        return stack;
 1303|      0|                    }
 1304|      1|                } else if let Some(message) = message {
  ------------------
  |  Branch (1304:31): [True: 1, False: 0]
  ------------------
 1305|      1|                    if !message.trim().is_empty() {
  ------------------
  |  Branch (1305:24): [True: 1, False: 0]
  ------------------
 1306|      1|                        return message;
 1307|      0|                    }
 1308|      0|                }
 1309|      7|            }
 1310|      7|            if let Some(js_string) = value.as_string().and_then(|s| s.to_string().ok()) {
                                      ^1                                          ^1^1          ^1
  ------------------
  |  Branch (1310:20): [True: 1, False: 6]
  ------------------
 1311|      1|                return js_string;
 1312|      6|            }
 1313|      6|            if let Some(number) = value.as_int() {
                                      ^1
  ------------------
  |  Branch (1313:20): [True: 1, False: 5]
  ------------------
 1314|      1|                return number.to_string();
 1315|      5|            }
 1316|      5|            if let Some(number) = value.as_float() {
                                      ^1
  ------------------
  |  Branch (1316:20): [True: 1, False: 4]
  ------------------
 1317|      1|                return number.to_string();
 1318|      4|            }
 1319|      4|            if let Some(flag) = value.as_bool() {
                                      ^1
  ------------------
  |  Branch (1319:20): [True: 1, False: 3]
  ------------------
 1320|      1|                return flag.to_string();
 1321|      3|            }
 1322|      3|            return format!("{:?}", value);
 1323|      1|        }
 1324|      1|        err.to_string()
 1325|     17|    }
 1326|       |
 1327|  1.11k|    fn new(worker_idx: usize, fontdb: Arc<usvg::fontdb::Database>) -> Result<Self, String> {
 1328|       |        use rquickjs::{Context, Function, Runtime};
 1329|  1.11k|        if mermaid_embed::MERMAID_JS.is_empty() {
  ------------------
  |  Branch (1329:12): [True: 0, False: 1.11k]
  ------------------
 1330|      0|            return Err("No embedded Mermaid JS".to_string());
 1331|  1.11k|        }
 1332|  1.11k|        let rt = Runtime::new().map_err(|e| format!("Mermaid runtime init error: {}", e))?;
                                                          ^0      ^0                                   ^0
 1333|  1.11k|        rt.set_memory_limit(Self::MEMORY_LIMIT_BYTES);
 1334|  1.11k|        rt.set_max_stack_size(Self::STACK_LIMIT_BYTES);
 1335|  1.11k|        let deadline_ms = Arc::new(AtomicU64::new(0));
 1336|  1.11k|        let deadline_guard = Arc::clone(&deadline_ms);
 1337|  32.6k|        rt.set_interrupt_handler(Some(Box::new(move || {
                      ^1.11k^1.11k                     ^1.11k
 1338|  32.6k|            let deadline = deadline_guard.load(Ordering::Relaxed);
 1339|  32.6k|            if deadline == 0 {
  ------------------
  |  Branch (1339:16): [True: 32.3k, False: 295]
  ------------------
 1340|  32.3k|                return false;
 1341|    295|            }
 1342|    295|            Self::now_ms() >= deadline
 1343|  32.6k|        })));
 1344|  1.11k|        let ctx = Context::full(&rt).map_err(|e| format!("Mermaid context init error: {}", e))?;
                                                               ^0      ^0                                   ^0
 1345|  1.11k|        let engine = MermaidEngine { rt, ctx };
 1346|  1.11k|        let text_measurer = Arc::new(TextMeasurer::new(Arc::clone(&fontdb)));
 1347|  1.11k|        let js = std::str::from_utf8(mermaid_embed::MERMAID_JS)
 1348|  1.11k|            .map_err(|_| "Mermaid JS is not valid UTF-8".to_string())?;
                                       ^0                              ^0          ^0
 1349|  1.11k|        let js = Self::patch_mermaid_js(js);
 1350|  1.11k|        let init_result: Result<(), String> = engine.ctx.with(|ctx| {
 1351|  1.11k|            let measurer = Arc::clone(&text_measurer);
 1352|  1.11k|            let measure_fn = Function::new(
 1353|  1.11k|                ctx.clone(),
 1354|     29|                move |text: String, font_size: f64, font_weight: Option<f64>| {
 1355|     29|                    let weight = font_weight.map(|value| value as f32);
 1356|     29|                    let (width, height) = measurer.measure_text(&text, font_size as f32, weight);
 1357|     29|                    vec![width as f64, height as f64]
 1358|     29|                },
 1359|       |            )
 1360|  1.11k|            .map_err(|err| {
                                         ^0
 1361|      0|                format!(
 1362|      0|                    "Mermaid text measure init error: {}",
 1363|      0|                    MermaidWorker::format_js_error(&ctx, err)
 1364|       |                )
 1365|      0|            })?;
 1366|  1.11k|            ctx.globals()
 1367|  1.11k|                .set("__mdmdview_measure_text_native", measure_fn)
 1368|  1.11k|                .map_err(|err| {
                                             ^0
 1369|      0|                    format!(
 1370|      0|                        "Mermaid text measure init error: {}",
 1371|      0|                        MermaidWorker::format_js_error(&ctx, err)
 1372|       |                    )
 1373|      0|                })?;
 1374|  3.34k|            let eval = |label: &str, source: &str| -> Result<(), String> {
                              ^1.11k
 1375|  3.34k|                ctx.eval::<(), _>(source).map_err(|err| {
                                                                      ^0
 1376|      0|                    format!("{}: {}", label, MermaidWorker::format_js_error(&ctx, err))
 1377|      0|                })
 1378|  3.34k|            };
 1379|  1.11k|            eval("Mermaid DOM shim", MERMAID_DOM_SHIM)?;
                                                                    ^0
 1380|  1.11k|            eval("Mermaid JS", &js)?;
                                                 ^0
 1381|  1.11k|            eval("Mermaid init", MERMAID_INIT_SNIPPET)?;
                                                                    ^0
 1382|  1.11k|            if std::env::var("MDMDVIEW_MERMAID_DOM_DEBUG").is_ok() {
  ------------------
  |  Branch (1382:16): [True: 55, False: 1.06k]
  ------------------
 1383|     55|                let dom_ok = ctx
 1384|     55|                    .eval::<bool, _>(
 1385|     55|                        "var root=document.querySelector('body');var d=document.createElement('div');d.setAttribute('id','__mdmdview_dom_test');root.appendChild(d);var f=document.getElementById('__mdmdview_dom_test');!!(f&&f===d);",
 1386|     55|                    )
 1387|     55|                    .unwrap_or(false);
 1388|     55|                eprintln!("Mermaid DOM debug: {}", dom_ok);
 1389|  1.06k|            }
 1390|  1.11k|            Ok(())
 1391|  1.11k|        });
 1392|  1.11k|        if let Err(err) = init_result {
                                 ^0
  ------------------
  |  Branch (1392:16): [True: 0, False: 1.11k]
  ------------------
 1393|      0|            return Err(format!("Mermaid init error: {}", err));
 1394|  1.11k|        }
 1395|  1.11k|        if worker_idx == 0 {
  ------------------
  |  Branch (1395:12): [True: 290, False: 825]
  ------------------
 1396|    290|            eprintln!(
 1397|    290|                "Mermaid embedded bytes: {}",
 1398|    290|                mermaid_embed::MERMAID_JS.len()
 1399|    290|            );
 1400|    825|        }
 1401|  1.11k|        Ok(Self {
 1402|  1.11k|            engine,
 1403|  1.11k|            deadline_ms,
 1404|  1.11k|            fontdb,
 1405|  1.11k|            text_measurer,
 1406|  1.11k|        })
 1407|  1.11k|    }
 1408|       |
 1409|      8|    fn render_svg(
 1410|      8|        &mut self,
 1411|      8|        key: u64,
 1412|      8|        code: &str,
 1413|      8|        viewport_width: u32,
 1414|      8|        viewport_height: u32,
 1415|      8|    ) -> Result<String, String> {
 1416|       |        use rquickjs::{promise::MaybePromise, Function};
 1417|      8|        let timeout_ms = MermaidRenderer::mermaid_timeout_ms();
 1418|      8|        let deadline = Self::now_ms().saturating_add(timeout_ms);
 1419|      8|        self.deadline_ms.store(deadline, Ordering::Relaxed);
 1420|      8|        let result = self.engine.ctx.with(|ctx| {
 1421|      8|            let wrapper = MERMAID_RENDER_WRAPPER;
 1422|      8|            let func: Function = ctx
 1423|      8|                .eval(wrapper)
 1424|      8|                .map_err(|err| MermaidWorker::format_js_error(&ctx, err))?;
                                             ^0                             ^0    ^0   ^0
 1425|      8|            let id = format!("m{:016x}", key);
 1426|      8|            let site_config = MermaidRenderer::mermaid_site_config_json(key);
 1427|      8|            let maybe: MaybePromise = func
 1428|      8|                .call((
 1429|      8|                    id.as_str(),
 1430|      8|                    code,
 1431|      8|                    site_config.as_str(),
 1432|      8|                    viewport_width,
 1433|      8|                    viewport_height,
 1434|      8|                ))
 1435|      8|                .map_err(|err| MermaidWorker::format_js_error(&ctx, err))?;
                                             ^0                             ^0    ^0   ^0
 1436|      8|            maybe
 1437|      8|                .finish::<String>()
 1438|      8|                .map_err(|err| MermaidWorker::format_js_error(&ctx, err))
                                             ^1                             ^1    ^1
 1439|      8|        });
 1440|      8|        self.deadline_ms.store(0, Ordering::Relaxed);
 1441|      8|        match result {
 1442|      7|            Ok(svg) => Ok(svg),
 1443|      1|            Err(err) => {
 1444|      1|                if Self::now_ms() >= deadline {
  ------------------
  |  Branch (1444:20): [True: 0, False: 1]
  ------------------
 1445|      0|                    return Err("Mermaid render timed out".to_string());
 1446|      1|                }
 1447|      1|                Err(format!("Mermaid render error: {}", err))
 1448|       |            }
 1449|       |        }
 1450|      8|    }
 1451|       |
 1452|      9|    fn maybe_dump_svg(svg_key: u64, code: Option<&str>, svg: &str) {
 1453|      9|        let dir = match std::env::var("MDMDVIEW_MERMAID_DUMP_DIR") {
                          ^4
 1454|      5|            Ok(value) if !value.trim().is_empty() => value,
                             ^4                               ^4   ^4
  ------------------
  |  Branch (1454:26): [True: 4, False: 1]
  ------------------
 1455|      5|            _ => return,
 1456|       |        };
 1457|      4|        let dir = PathBuf::from(dir);
 1458|      4|        if std::fs::create_dir_all(&dir).is_err() {
  ------------------
  |  Branch (1458:12): [True: 1, False: 3]
  ------------------
 1459|      1|            return;
 1460|      3|        }
 1461|      3|        let label = code
 1462|      3|            .and_then(|snippet| snippet.lines().next())
 1463|      3|            .unwrap_or("mermaid");
 1464|      3|        let mut name = String::new();
 1465|     45|        for ch in label.chars() {
                                ^3    ^3
 1466|     45|            if name.len() >= 32 {
  ------------------
  |  Branch (1466:16): [True: 1, False: 44]
  ------------------
 1467|      1|                break;
 1468|     44|            }
 1469|     44|            if ch.is_ascii_alphanumeric() || ch == '-' || ch == '_' {
                                                           ^2           ^1
  ------------------
  |  Branch (1469:16): [True: 42, False: 2]
  |  Branch (1469:46): [True: 1, False: 1]
  |  Branch (1469:59): [True: 0, False: 1]
  ------------------
 1470|     43|                name.push(ch);
 1471|     43|            } else {
 1472|      1|                name.push('_');
 1473|      1|            }
 1474|       |        }
 1475|      3|        if name.is_empty() {
  ------------------
  |  Branch (1475:12): [True: 1, False: 2]
  ------------------
 1476|      1|            name.push_str("mermaid");
 1477|      2|        }
 1478|      3|        let filename = format!("{:016x}_{}.svg", svg_key, name);
 1479|      3|        let path = dir.join(filename);
 1480|      3|        let _ = std::fs::write(path, svg);
 1481|      9|    }
 1482|       |
 1483|      9|    fn maybe_dump_error(svg_key: u64, code: Option<&str>, err: &str) {
 1484|      9|        let dir = match std::env::var("MDMDVIEW_MERMAID_DUMP_DIR") {
                          ^5
 1485|      6|            Ok(value) if !value.trim().is_empty() => value,
                             ^5                               ^5   ^5
  ------------------
  |  Branch (1485:26): [True: 5, False: 1]
  ------------------
 1486|      4|            _ => return,
 1487|       |        };
 1488|      5|        let dir = PathBuf::from(dir);
 1489|      5|        if std::fs::create_dir_all(&dir).is_err() {
  ------------------
  |  Branch (1489:12): [True: 1, False: 4]
  ------------------
 1490|      1|            return;
 1491|      4|        }
 1492|      4|        let label = code
 1493|      4|            .and_then(|snippet| snippet.lines().next())
                                              ^3              ^3
 1494|      4|            .unwrap_or("mermaid");
 1495|      4|        let mut name = String::new();
 1496|     63|        for ch in label.chars() {
                                ^4    ^4
 1497|     63|            if name.len() >= 32 {
  ------------------
  |  Branch (1497:16): [True: 1, False: 62]
  ------------------
 1498|      1|                break;
 1499|     62|            }
 1500|     62|            if ch.is_ascii_alphanumeric() || ch == '-' || ch == '_' {
                                                           ^6           ^6
  ------------------
  |  Branch (1500:16): [True: 56, False: 6]
  |  Branch (1500:46): [True: 0, False: 6]
  |  Branch (1500:59): [True: 1, False: 5]
  ------------------
 1501|     57|                name.push(ch);
 1502|     57|            } else {
 1503|      5|                name.push('_');
 1504|      5|            }
 1505|       |        }
 1506|      4|        if name.is_empty() {
  ------------------
  |  Branch (1506:12): [True: 0, False: 4]
  ------------------
 1507|      0|            name.push_str("mermaid");
 1508|      4|        }
 1509|      4|        let filename = format!("{:016x}_{}.err.txt", svg_key, name);
 1510|      4|        let path = dir.join(filename);
 1511|      4|        let mut payload = String::new();
 1512|      4|        payload.push_str("error: ");
 1513|      4|        payload.push_str(err);
 1514|      4|        payload.push('\n');
 1515|      4|        if let Some(code) = code {
                                  ^3
  ------------------
  |  Branch (1515:16): [True: 3, False: 1]
  ------------------
 1516|      3|            payload.push_str("\n---\n");
 1517|      3|            payload.push_str(code);
 1518|      3|            payload.push('\n');
 1519|      3|        }
                      ^1
 1520|      4|        let _ = std::fs::write(path, payload);
 1521|      9|    }
 1522|       |
 1523|      8|    fn normalize_svg_size(svg: &str) -> String {
 1524|      8|        let start = match svg.find("<svg") {
                          ^7
 1525|      7|            Some(idx) => idx,
 1526|      1|            None => return svg.to_string(),
 1527|       |        };
 1528|      7|        let end = match svg[start..].find('>') {
 1529|      7|            Some(idx) => start + idx,
 1530|      0|            None => return svg.to_string(),
 1531|       |        };
 1532|      7|        let tag = &svg[start..=end];
 1533|      7|        let viewbox = match Self::find_svg_attr(tag, "viewBox") {
                          ^6
 1534|      6|            Some(v) => v,
 1535|      1|            None => return svg.to_string(),
 1536|       |        };
 1537|      6|        let dims = Self::parse_viewbox_dims(&viewbox);
 1538|      6|        let (width, height) = match dims {
 1539|      6|            Some(pair) => pair,
 1540|      0|            None => return svg.to_string(),
 1541|       |        };
 1542|      6|        let mut new_tag = tag.to_string();
 1543|      6|        let width_attr = Self::find_svg_attr(&new_tag, "width");
 1544|      6|        if width_attr
  ------------------
  |  Branch (1544:12): [True: 4, False: 2]
  ------------------
 1545|      6|            .as_deref()
 1546|      6|            .map(|val| val.trim().ends_with('%'))
                                     ^5         ^5
 1547|      6|            .unwrap_or(true)
 1548|       |        {
 1549|      4|            let value = Self::format_dim(width);
 1550|      4|            new_tag = if width_attr.is_some() {
  ------------------
  |  Branch (1550:26): [True: 3, False: 1]
  ------------------
 1551|      3|                Self::replace_svg_attr(&new_tag, "width", &value)
 1552|       |            } else {
 1553|      1|                Self::insert_svg_attr(&new_tag, "width", &value)
 1554|       |            };
 1555|      2|        }
 1556|      6|        let height_attr = Self::find_svg_attr(&new_tag, "height");
 1557|      6|        if height_attr
  ------------------
  |  Branch (1557:12): [True: 4, False: 2]
  ------------------
 1558|      6|            .as_deref()
 1559|      6|            .map(|val| val.trim().ends_with('%'))
                                     ^4         ^4
 1560|      6|            .unwrap_or(true)
 1561|       |        {
 1562|      4|            let value = Self::format_dim(height);
 1563|      4|            new_tag = if height_attr.is_some() {
  ------------------
  |  Branch (1563:26): [True: 2, False: 2]
  ------------------
 1564|      2|                Self::replace_svg_attr(&new_tag, "height", &value)
 1565|       |            } else {
 1566|      2|                Self::insert_svg_attr(&new_tag, "height", &value)
 1567|       |            };
 1568|      2|        }
 1569|      6|        if new_tag == tag {
  ------------------
  |  Branch (1569:12): [True: 2, False: 4]
  ------------------
 1570|      2|            return svg.to_string();
 1571|      4|        }
 1572|      4|        let mut out = String::with_capacity(svg.len() + 32);
 1573|      4|        out.push_str(&svg[..start]);
 1574|      4|        out.push_str(&new_tag);
 1575|      4|        out.push_str(&svg[end + 1..]);
 1576|      4|        out
 1577|      8|    }
 1578|       |
 1579|     28|    fn replace_attr(tag: &str, name: &str, value: &str) -> String {
 1580|     28|        let needle = format!("{name}=\"");
 1581|     28|        let start = match tag.find(&needle) {
                          ^27
 1582|     27|            Some(idx) => idx + needle.len(),
 1583|      1|            None => return tag.to_string(),
 1584|       |        };
 1585|     27|        let end = match tag[start..].find('"') {
 1586|     27|            Some(idx) => start + idx,
 1587|      0|            None => return tag.to_string(),
 1588|       |        };
 1589|     27|        let mut out = String::with_capacity(tag.len() + value.len());
 1590|     27|        out.push_str(&tag[..start]);
 1591|     27|        out.push_str(value);
 1592|     27|        out.push_str(&tag[end..]);
 1593|     27|        out
 1594|     28|    }
 1595|       |
 1596|     22|    fn upsert_attr(tag: &str, name: &str, value: &str) -> String {
 1597|     22|        let needle = format!("{name}=\"");
 1598|     22|        if tag.contains(&needle) {
  ------------------
  |  Branch (1598:12): [True: 18, False: 4]
  ------------------
 1599|     18|            return Self::replace_attr(tag, name, value);
 1600|      4|        }
 1601|      4|        let insert_at = match tag.rfind('>') {
 1602|      4|            Some(pos) => pos,
 1603|      0|            None => return tag.to_string(),
 1604|       |        };
 1605|      4|        let mut out = String::with_capacity(tag.len() + name.len() + value.len() + 4);
 1606|      4|        out.push_str(&tag[..insert_at]);
 1607|      4|        out.push(' ');
 1608|      4|        out.push_str(name);
 1609|      4|        out.push_str("=\"");
 1610|      4|        out.push_str(value);
 1611|      4|        out.push('"');
 1612|      4|        out.push_str(&tag[insert_at..]);
 1613|      4|        out
 1614|     22|    }
 1615|       |
 1616|      8|    fn flatten_svg_switches(svg: &str) -> Option<String> {
 1617|      8|        if !svg.contains("<switch") {
  ------------------
  |  Branch (1617:12): [True: 4, False: 4]
  ------------------
 1618|      4|            return None;
 1619|      4|        }
 1620|      4|        let mut out = String::with_capacity(svg.len());
 1621|      4|        let mut remaining = svg;
 1622|      4|        let mut changed = false;
 1623|      7|        while let Some(start) = remaining.find("<switch") {
                                     ^4
  ------------------
  |  Branch (1623:19): [True: 4, False: 3]
  ------------------
 1624|      4|            let (before, after) = remaining.split_at(start);
 1625|      4|            out.push_str(before);
 1626|      4|            let open_end = match after.find('>') {
 1627|      4|                Some(pos) => pos + 1,
 1628|       |                None => {
 1629|      0|                    out.push_str(after);
 1630|      0|                    remaining = "";
 1631|      0|                    break;
 1632|       |                }
 1633|       |            };
 1634|      4|            let after_open = &after[open_end..];
 1635|      4|            let close_rel = match after_open.find("</switch>") {
                              ^3
 1636|      3|                Some(pos) => pos,
 1637|       |                None => {
 1638|      1|                    out.push_str(after);
 1639|      1|                    remaining = "";
 1640|      1|                    break;
 1641|       |                }
 1642|       |            };
 1643|      3|            let inner = &after_open[..close_rel];
 1644|      3|            let mut inner_out = String::with_capacity(inner.len());
 1645|      3|            let mut inner_remaining = inner;
 1646|      5|            while let Some(fo_start) = inner_remaining.find("<foreignObject") {
                                         ^3
  ------------------
  |  Branch (1646:23): [True: 3, False: 2]
  ------------------
 1647|      3|                let (inner_before, inner_after) = inner_remaining.split_at(fo_start);
 1648|      3|                inner_out.push_str(inner_before);
 1649|      3|                if let Some(fo_end_rel) = inner_after.find("</foreignObject>") {
                                          ^2
  ------------------
  |  Branch (1649:24): [True: 2, False: 1]
  ------------------
 1650|      2|                    inner_remaining =
 1651|      2|                        &inner_after[fo_end_rel + "</foreignObject>".len()..];
 1652|      2|                } else {
 1653|      1|                    inner_remaining = "";
 1654|      1|                    break;
 1655|       |                }
 1656|       |            }
 1657|      3|            inner_out.push_str(inner_remaining);
 1658|      3|            out.push_str(&inner_out);
 1659|      3|            changed = true;
 1660|      3|            remaining = &after_open[close_rel + "</switch>".len()..];
 1661|       |        }
 1662|      4|        out.push_str(remaining);
 1663|      4|        if changed { Some(out) } else { None }
                                   ^3                 ^1
  ------------------
  |  Branch (1663:12): [True: 3, False: 1]
  ------------------
 1664|      8|    }
 1665|       |
 1666|     10|    fn fix_journey_section_text(svg: &str, fill: &str) -> Option<String> {
 1667|     10|        if !svg.contains("journey-section") {
  ------------------
  |  Branch (1667:12): [True: 4, False: 6]
  ------------------
 1668|      4|            return None;
 1669|      6|        }
 1670|      6|        let mut out = String::with_capacity(svg.len() + 64);
 1671|      6|        let mut remaining = svg;
 1672|      6|        let mut changed = false;
 1673|     13|        while let Some(idx) = remaining.find("<text") {
                                     ^7
  ------------------
  |  Branch (1673:19): [True: 7, False: 6]
  ------------------
 1674|      7|            let (before, after) = remaining.split_at(idx);
 1675|      7|            out.push_str(before);
 1676|      7|            let end = match after.find('>') {
 1677|      7|                Some(pos) => pos + 1,
 1678|       |                None => {
 1679|      0|                    out.push_str(after);
 1680|      0|                    remaining = "";
 1681|      0|                    break;
 1682|       |                }
 1683|       |            };
 1684|      7|            let (tag, rest) = after.split_at(end);
 1685|      7|            if tag.contains("journey-section") {
  ------------------
  |  Branch (1685:16): [True: 6, False: 1]
  ------------------
 1686|      6|                let mut updated = tag.to_string();
 1687|      6|                if let Some(style_start) = updated.find(" style=\"") {
                                          ^4
  ------------------
  |  Branch (1687:24): [True: 4, False: 2]
  ------------------
 1688|      4|                    let value_start = style_start + " style=\"".len();
 1689|      4|                    if let Some(style_end) = updated[value_start..].find('"') {
                                              ^3
  ------------------
  |  Branch (1689:28): [True: 3, False: 1]
  ------------------
 1690|      3|                        let style_end = value_start + style_end;
 1691|      3|                        let mut style = updated[value_start..style_end].to_string();
 1692|      3|                        let parts: Vec<&str> = style.split(';').collect();
 1693|      3|                        let mut rebuilt: Vec<String> = Vec::new();
 1694|      9|                        for part in parts {
                                          ^6
 1695|      6|                            let trimmed = part.trim();
 1696|      6|                            if trimmed.is_empty() {
  ------------------
  |  Branch (1696:32): [True: 1, False: 5]
  ------------------
 1697|      1|                                continue;
 1698|      5|                            }
 1699|      5|                            if trimmed.starts_with("fill:") {
  ------------------
  |  Branch (1699:32): [True: 3, False: 2]
  ------------------
 1700|      3|                                continue;
 1701|      2|                            }
 1702|      2|                            rebuilt.push(trimmed.to_string());
 1703|       |                        }
 1704|      3|                        rebuilt.push(format!("fill:{}", fill));
 1705|      3|                        style = rebuilt.join(";");
 1706|      3|                        updated.replace_range(value_start..style_end, &style);
 1707|      3|                        out.push_str(&updated);
 1708|      3|                        changed = true;
 1709|      1|                    } else {
 1710|      1|                        out.push_str(tag);
 1711|      1|                    }
 1712|      2|                } else {
 1713|      2|                    let insert_at = updated.len().saturating_sub(1);
 1714|      2|                    updated.insert_str(insert_at, &format!(" style=\"fill:{};\"", fill));
 1715|      2|                    out.push_str(&updated);
 1716|      2|                    changed = true;
 1717|      2|                }
 1718|      1|            } else {
 1719|      1|                out.push_str(tag);
 1720|      1|            }
 1721|      7|            remaining = rest;
 1722|       |        }
 1723|      6|        out.push_str(remaining);
 1724|      6|        if changed { Some(out) } else { None }
                                   ^5                 ^1
  ------------------
  |  Branch (1724:12): [True: 5, False: 1]
  ------------------
 1725|     10|    }
 1726|       |
 1727|     10|    fn find_circle_tag(body: &str, class_name: &str) -> Option<(usize, usize, String)> {
 1728|     10|        let needle = format!("class=\"{class_name}\"");
 1729|     10|        let class_idx = body.find(&needle)?;
                                                        ^0
 1730|     10|        let start = body[..class_idx].rfind("<circle")?;
                                                                    ^0
 1731|     10|        let end = body[class_idx..].find('>')? + class_idx + 1;
                                                           ^0
 1732|     10|        Some((start, end, body[start..end].to_string()))
 1733|     10|    }
 1734|       |
 1735|     10|    fn read_r_value(tag: &str) -> Option<String> {
 1736|     10|        let needle = "r=\"";
 1737|     10|        let start = tag.find(needle)? + needle.len();
                                                  ^0
 1738|     10|        let end = tag[start..].find('"')? + start;
                                                      ^0
 1739|     10|        Some(tag[start..end].to_string())
 1740|     10|    }
 1741|       |
 1742|      9|    fn fix_state_end_circles(svg: &str) -> Option<String> {
 1743|      9|        if !svg.contains("state-end") {
  ------------------
  |  Branch (1743:12): [True: 4, False: 5]
  ------------------
 1744|      4|            return None;
 1745|      5|        }
 1746|      5|        let mut out = String::with_capacity(svg.len());
 1747|      5|        let mut cursor = 0;
 1748|      5|        let mut changed = false;
 1749|     11|        while let Some(g_pos_rel) = svg[cursor..].find("<g") {
                                     ^6
  ------------------
  |  Branch (1749:19): [True: 6, False: 5]
  ------------------
 1750|      6|            let g_pos = cursor + g_pos_rel;
 1751|      6|            out.push_str(&svg[cursor..g_pos]);
 1752|      6|            let g_end = match svg[g_pos..].find('>') {
 1753|      6|                Some(pos) => g_pos + pos + 1,
 1754|       |                None => {
 1755|      0|                    out.push_str(&svg[g_pos..]);
 1756|      0|                    cursor = svg.len();
 1757|      0|                    break;
 1758|       |                }
 1759|       |            };
 1760|      6|            let g_tag = &svg[g_pos..g_end];
 1761|      6|            let is_end_group = g_tag.contains("root_end") || g_tag.contains("state-end");
                                                                           ^1    ^1
  ------------------
  |  Branch (1761:32): [True: 5, False: 1]
  ------------------
 1762|      6|            if !is_end_group {
  ------------------
  |  Branch (1762:16): [True: 1, False: 5]
  ------------------
 1763|      1|                out.push_str(g_tag);
 1764|      1|                cursor = g_end;
 1765|      1|                continue;
 1766|      5|            }
 1767|      5|            let close_rel = match svg[g_end..].find("</g>") {
 1768|      5|                Some(pos) => pos,
 1769|       |                None => {
 1770|      0|                    out.push_str(&svg[g_pos..]);
 1771|      0|                    cursor = svg.len();
 1772|      0|                    break;
 1773|       |                }
 1774|       |            };
 1775|      5|            let body_end = g_end + close_rel;
 1776|      5|            let body = &svg[g_end..body_end];
 1777|      5|            let mut body_out = body.to_string();
 1778|      5|            if let (Some((s_start, s_end, state_end_tag)), Some((t_start, t_end, state_start_tag))) =
  ------------------
  |  Branch (1778:20): [True: 5, False: 0]
  ------------------
 1779|      5|                (Self::find_circle_tag(body, "state-end"), Self::find_circle_tag(body, "state-start"))
 1780|       |            {
 1781|      5|                if let (Some(end_r), Some(start_r)) =
  ------------------
  |  Branch (1781:24): [True: 5, False: 0]
  ------------------
 1782|      5|                    (Self::read_r_value(&state_end_tag), Self::read_r_value(&state_start_tag))
 1783|       |                {
 1784|      5|                    let end_val = end_r.parse::<f32>().ok();
 1785|      5|                    let start_val = start_r.parse::<f32>().ok();
 1786|      5|                    if let (Some(end_val), Some(start_val)) = (end_val, start_val) {
  ------------------
  |  Branch (1786:28): [True: 5, False: 0]
  ------------------
 1787|      5|                        if end_val < start_val {
  ------------------
  |  Branch (1787:28): [True: 4, False: 1]
  ------------------
 1788|      4|                            let end_dim = Self::format_dim(start_val * 2.0);
 1789|      4|                            let start_dim = Self::format_dim(end_val * 2.0);
 1790|      4|                            let mut new_end_tag =
 1791|      4|                                Self::replace_attr(&state_end_tag, "r", &start_r);
 1792|      4|                            let mut new_start_tag =
 1793|      4|                                Self::replace_attr(&state_start_tag, "r", &end_r);
 1794|      4|                            new_end_tag = Self::upsert_attr(&new_end_tag, "width", &end_dim);
 1795|      4|                            new_end_tag = Self::upsert_attr(&new_end_tag, "height", &end_dim);
 1796|      4|                            new_start_tag =
 1797|      4|                                Self::upsert_attr(&new_start_tag, "width", &start_dim);
 1798|      4|                            new_start_tag =
 1799|      4|                                Self::upsert_attr(&new_start_tag, "height", &start_dim);
 1800|      4|                            if new_start_tag.contains("state-start") {
  ------------------
  |  Branch (1800:32): [True: 4, False: 0]
  ------------------
 1801|      4|                                new_start_tag =
 1802|      4|                                    new_start_tag.replace("state-start", "end-state-inner");
 1803|      4|                            }
                                          ^0
 1804|      4|                            let mut rebuilt = String::with_capacity(body.len() + 16);
 1805|      4|                            let (first_start, first_end, first_tag, second_start, second_end, second_tag) =
 1806|      4|                                if s_start <= t_start {
  ------------------
  |  Branch (1806:36): [True: 3, False: 1]
  ------------------
 1807|      3|                                    (s_start, s_end, new_end_tag, t_start, t_end, new_start_tag)
 1808|       |                                } else {
 1809|      1|                                    (t_start, t_end, new_start_tag, s_start, s_end, new_end_tag)
 1810|       |                                };
 1811|      4|                            rebuilt.push_str(&body[..first_start]);
 1812|      4|                            rebuilt.push_str(&first_tag);
 1813|      4|                            rebuilt.push_str(&body[first_end..second_start]);
 1814|      4|                            rebuilt.push_str(&second_tag);
 1815|      4|                            rebuilt.push_str(&body[second_end..]);
 1816|      4|                            body_out = rebuilt;
 1817|      4|                            changed = true;
 1818|      1|                        }
 1819|      0|                    }
 1820|      0|                }
 1821|      0|            }
 1822|      5|            out.push_str(g_tag);
 1823|      5|            out.push_str(&body_out);
 1824|      5|            out.push_str("</g>");
 1825|      5|            cursor = body_end + 4;
 1826|       |        }
 1827|      5|        out.push_str(&svg[cursor..]);
 1828|      5|        if changed { Some(out) } else { None }
                                   ^4                 ^1
  ------------------
  |  Branch (1828:12): [True: 4, False: 1]
  ------------------
 1829|      9|    }
 1830|       |
 1831|      7|    fn fix_er_attribute_fills(svg: &str) -> Option<String> {
 1832|      7|        if !svg.contains("attributeBoxOdd") && !svg.contains("attributeBoxEven") {
                                                             ^4
  ------------------
  |  Branch (1832:12): [True: 4, False: 3]
  |  Branch (1832:48): [True: 4, False: 0]
  ------------------
 1833|      4|            return None;
 1834|      3|        }
 1835|      3|        let mut out = String::with_capacity(svg.len() + 32);
 1836|      3|        let mut remaining = svg;
 1837|      3|        let mut changed = false;
 1838|      7|        while let Some(idx) = remaining.find("<rect") {
                                     ^4
  ------------------
  |  Branch (1838:19): [True: 4, False: 3]
  ------------------
 1839|      4|            let (before, after) = remaining.split_at(idx);
 1840|      4|            out.push_str(before);
 1841|      4|            let end = match after.find('>') {
 1842|      4|                Some(pos) => pos + 1,
 1843|       |                None => {
 1844|      0|                    out.push_str(after);
 1845|      0|                    remaining = "";
 1846|      0|                    break;
 1847|       |                }
 1848|       |            };
 1849|      4|            let (tag, rest) = after.split_at(end);
 1850|      4|            let mut updated = tag.to_string();
 1851|      4|            if tag.contains("attributeBoxOdd") {
  ------------------
  |  Branch (1851:16): [True: 3, False: 1]
  ------------------
 1852|      3|                updated = Self::upsert_attr(&updated, "fill", "#ffffff");
 1853|      3|            } else if tag.contains("attributeBoxEven") {
                                    ^1  ^1
  ------------------
  |  Branch (1853:23): [True: 1, False: 0]
  ------------------
 1854|      1|                updated = Self::upsert_attr(&updated, "fill", "#f2f2f2");
 1855|      1|            }
                          ^0
 1856|      4|            if updated != tag {
  ------------------
  |  Branch (1856:16): [True: 3, False: 1]
  ------------------
 1857|      3|                changed = true;
 1858|      3|            }
                          ^1
 1859|      4|            out.push_str(&updated);
 1860|      4|            remaining = rest;
 1861|       |        }
 1862|      3|        out.push_str(remaining);
 1863|      3|        if changed { Some(out) } else { None }
                                   ^2                 ^1
  ------------------
  |  Branch (1863:12): [True: 2, False: 1]
  ------------------
 1864|      7|    }
 1865|       |
 1866|     32|    fn find_svg_attr(tag: &str, name: &str) -> Option<String> {
 1867|     32|        let needle = format!("{name}=\"");
 1868|     32|        let start = tag.find(&needle)? + needle.len();
                          ^24                      ^8  ^24    ^24
 1869|     24|        let end = tag[start..].find('"')? + start;
                                                      ^0
 1870|     24|        Some(tag[start..end].to_string())
 1871|     32|    }
 1872|       |
 1873|      5|    fn replace_svg_attr(tag: &str, name: &str, value: &str) -> String {
 1874|      5|        let needle = format!("{name}=\"");
 1875|      5|        let start = match tag.find(&needle) {
 1876|      5|            Some(idx) => idx + needle.len(),
 1877|      0|            None => return tag.to_string(),
 1878|       |        };
 1879|      5|        let end = match tag[start..].find('"') {
 1880|      5|            Some(idx) => start + idx,
 1881|      0|            None => return tag.to_string(),
 1882|       |        };
 1883|      5|        let mut out = String::with_capacity(tag.len() + value.len());
 1884|      5|        out.push_str(&tag[..start]);
 1885|      5|        out.push_str(value);
 1886|      5|        out.push_str(&tag[end..]);
 1887|      5|        out
 1888|      5|    }
 1889|       |
 1890|     19|    fn remove_svg_attr(tag: &str, name: &str) -> String {
 1891|     19|        let needle = format!("{name}=\"");
 1892|     19|        let start = match tag.find(&needle) {
                          ^13
 1893|     13|            Some(idx) => idx,
 1894|      6|            None => return tag.to_string(),
 1895|       |        };
 1896|     13|        let value_start = start + needle.len();
 1897|     13|        let end = match tag[value_start..].find('"') {
                          ^12
 1898|     12|            Some(idx) => value_start + idx + 1,
 1899|      1|            None => return tag.to_string(),
 1900|       |        };
 1901|     12|        let mut out = String::with_capacity(tag.len());
 1902|     12|        out.push_str(&tag[..start]);
 1903|     12|        let rest = &tag[end..];
 1904|     12|        if out.ends_with(' ') && rest.starts_with(' ') {
  ------------------
  |  Branch (1904:12): [True: 12, False: 0]
  |  Branch (1904:34): [True: 11, False: 1]
  ------------------
 1905|     11|            out.pop();
 1906|     11|        }
                      ^1
 1907|     12|        out.push_str(rest);
 1908|     12|        out
 1909|     19|    }
 1910|       |
 1911|     15|    fn strip_svg_attr(svg: &str, name: &str) -> Option<String> {
 1912|     15|        let start = svg.find("<svg")?;
                                                  ^0
 1913|     15|        let end = svg[start..].find('>')? + start;
                                                      ^0
 1914|     15|        let tag = &svg[start..=end];
 1915|     15|        let new_tag = Self::remove_svg_attr(tag, name);
 1916|     15|        if new_tag == tag {
  ------------------
  |  Branch (1916:12): [True: 5, False: 10]
  ------------------
 1917|      5|            return None;
 1918|     10|        }
 1919|     10|        let mut out = String::with_capacity(svg.len());
 1920|     10|        out.push_str(&svg[..start]);
 1921|     10|        out.push_str(&new_tag);
 1922|     10|        out.push_str(&svg[end + 1..]);
 1923|     10|        Some(out)
 1924|     15|    }
 1925|       |
 1926|      4|    fn insert_svg_attr(tag: &str, name: &str, value: &str) -> String {
 1927|      4|        let insert_pos = match tag.find("<svg") {
 1928|      4|            Some(idx) => idx + 4,
 1929|      0|            None => return tag.to_string(),
 1930|       |        };
 1931|      4|        let mut out = String::with_capacity(tag.len() + name.len() + value.len() + 4);
 1932|      4|        out.push_str(&tag[..insert_pos]);
 1933|      4|        out.push_str(&format!(" {name}=\"{value}\""));
 1934|      4|        out.push_str(&tag[insert_pos..]);
 1935|      4|        out
 1936|      4|    }
 1937|       |
 1938|     21|    fn parse_viewbox_dims(viewbox: &str) -> Option<(f32, f32)> {
 1939|     21|        let mut nums = Vec::new();
 1940|     81|        for part in viewbox
                                  ^21
 1941|    286|            .split(|c: char| c.is_whitespace() || c == ',')
                           ^21                                  ^232
  ------------------
  |  Branch (1941:30): [True: 54, False: 232]
  ------------------
 1942|     81|            .filter(|part| !part.is_empty())
                           ^21
 1943|       |        {
 1944|     81|            if let Ok(value) = part.parse::<f32>() {
                                    ^80
  ------------------
  |  Branch (1944:20): [True: 80, False: 1]
  ------------------
 1945|     80|                nums.push(value);
 1946|     80|            }
                          ^1
 1947|       |        }
 1948|     21|        if nums.len() < 4 {
  ------------------
  |  Branch (1948:12): [True: 1, False: 20]
  ------------------
 1949|      1|            return None;
 1950|     20|        }
 1951|     20|        let width = nums[2];
 1952|     20|        let height = nums[3];
 1953|     20|        if width.is_finite() && height.is_finite() && width > 0.0 && height > 0.0 {
                                              ^19    ^19            ^19            ^17
  ------------------
  |  Branch (1953:12): [True: 19, False: 1]
  |  Branch (1953:33): [True: 19, False: 0]
  |  Branch (1953:55): [True: 17, False: 2]
  |  Branch (1953:70): [True: 16, False: 1]
  ------------------
 1954|     16|            Some((width, height))
 1955|       |        } else {
 1956|      4|            None
 1957|       |        }
 1958|     21|    }
 1959|       |
 1960|     20|    fn format_dim(value: f32) -> String {
 1961|     20|        let mut out = format!("{:.3}", value);
 1962|     64|        while out.contains('.') && out.ends_with('0') {
  ------------------
  |  Branch (1962:15): [True: 64, False: 0]
  |  Branch (1962:36): [True: 44, False: 20]
  ------------------
 1963|     44|            out.pop();
 1964|     44|        }
 1965|     20|        if out.ends_with('.') {
  ------------------
  |  Branch (1965:12): [True: 14, False: 6]
  ------------------
 1966|     14|            out.pop();
 1967|     14|        }
                      ^6
 1968|     20|        out
 1969|     20|    }
 1970|       |
 1971|      6|    fn process_job(&mut self, job: MermaidRequest) -> MermaidResult {
 1972|       |        let MermaidRequest {
 1973|      6|            svg_key,
 1974|      6|            texture_key,
 1975|      6|            code,
 1976|      6|            svg,
 1977|      6|            width_bucket,
 1978|      6|            scale_bucket,
 1979|      6|            viewport_width,
 1980|      6|            viewport_height,
 1981|      6|            bg,
 1982|      6|        } = job;
 1983|      6|        let code_ref = code.as_deref();
 1984|      6|        let svg_result = match svg {
 1985|      2|            Some(svg) => Ok(svg),
 1986|      4|            None => match code_ref {
 1987|      3|                Some(code) => self.render_svg(svg_key, code, viewport_width, viewport_height),
 1988|      1|                None => Err("Mermaid render request missing code".to_string()),
 1989|       |            },
 1990|       |        };
 1991|       |
 1992|      6|        match svg_result {
 1993|      4|            Ok(svg) => {
 1994|      4|                let mut svg = Self::normalize_svg_size(&svg);
 1995|      4|                if let Some(updated) = Self::flatten_svg_switches(&svg) {
                                          ^1
  ------------------
  |  Branch (1995:24): [True: 1, False: 3]
  ------------------
 1996|      1|                    svg = updated;
 1997|      3|                }
 1998|      4|                let theme = MermaidRenderer::mermaid_theme_values();
 1999|      4|                if let Some(updated) = Self::fix_journey_section_text(&svg, &theme.text) {
                                          ^1
  ------------------
  |  Branch (1999:24): [True: 1, False: 3]
  ------------------
 2000|      1|                    svg = updated;
 2001|      3|                }
 2002|      4|                if let Some(updated) = Self::fix_state_end_circles(&svg) {
                                          ^1
  ------------------
  |  Branch (2002:24): [True: 1, False: 3]
  ------------------
 2003|      1|                    svg = updated;
 2004|      3|                }
 2005|      4|                if let Some(updated) = Self::fix_er_attribute_fills(&svg) {
                                          ^1
  ------------------
  |  Branch (2005:24): [True: 1, False: 3]
  ------------------
 2006|      1|                    svg = updated;
 2007|      3|                }
 2008|      4|                Self::maybe_dump_svg(svg_key, code_ref, &svg);
 2009|      4|                match self.rasterize_svg(&svg, width_bucket, scale_bucket, bg) {
 2010|      3|                    Ok((rgba, w, h)) => MermaidResult {
 2011|      3|                        svg_key,
 2012|      3|                        texture_key,
 2013|      3|                        svg: Some(svg),
 2014|      3|                        rgba: Some(rgba),
 2015|      3|                        size: Some((w, h)),
 2016|      3|                        error: None,
 2017|      3|                    },
 2018|      1|                    Err(err) => {
 2019|      1|                        Self::maybe_dump_error(svg_key, code_ref, &err);
 2020|      1|                        MermaidResult {
 2021|      1|                            svg_key,
 2022|      1|                            texture_key,
 2023|      1|                            svg: Some(svg),
 2024|      1|                            rgba: None,
 2025|      1|                            size: None,
 2026|      1|                            error: Some(err),
 2027|      1|                        }
 2028|       |                    }
 2029|       |                }
 2030|       |            }
 2031|      2|            Err(err) => {
 2032|      2|                Self::maybe_dump_error(svg_key, code_ref, &err);
 2033|      2|                MermaidResult {
 2034|      2|                    svg_key,
 2035|      2|                    texture_key,
 2036|      2|                    svg: None,
 2037|      2|                    rgba: None,
 2038|      2|                    size: None,
 2039|      2|                    error: Some(err),
 2040|      2|                }
 2041|       |            }
 2042|       |        }
 2043|      6|    }
 2044|       |
 2045|     15|    fn rasterize_svg(
 2046|     15|        &self,
 2047|     15|        svg: &str,
 2048|     15|        width_bucket: u32,
 2049|     15|        scale_bucket: u32,
 2050|     15|        bg: Option<[u8; 4]>,
 2051|     15|    ) -> Result<(Vec<u8>, u32, u32), String> {
 2052|     15|        let opt = usvg::Options {
 2053|     15|            resources_dir: None,
 2054|     15|            fontdb: Arc::clone(&self.fontdb),
 2055|     15|            image_href_resolver: Self::image_href_resolver(),
 2056|     15|            ..Default::default()
 2057|     15|        };
 2058|       |
 2059|     15|        let tree = usvg::Tree::from_data(svg.as_bytes(), &opt).map_err(|e| format!("{}", e))?;
                          ^13                                                            ^2      ^2       ^2
 2060|     13|        let mut tree = tree;
 2061|     13|        let sz = tree.size().to_int_size();
 2062|     13|        let (mut w, mut h) = (sz.width(), sz.height());
 2063|     13|        let viewbox_dims = Self::find_svg_attr(svg, "viewBox")
 2064|     13|            .and_then(|value| Self::parse_viewbox_dims(&value))
                                            ^9                       ^9
 2065|     13|            .filter(|(vw, vh)| *vw > 0.5 && *vh > 0.5);
                                             ^8           ^7
  ------------------
  |  Branch (2065:32): [True: 7, False: 1]
  ------------------
 2066|     13|        if let Some((vw, vh)) = viewbox_dims {
                                   ^7  ^7
  ------------------
  |  Branch (2066:16): [True: 7, False: 6]
  ------------------
 2067|      7|            w = vw.ceil() as u32;
 2068|      7|            h = vh.ceil() as u32;
 2069|      7|        }
                      ^6
 2070|     13|        let mut translate_x = 0.0_f32;
 2071|     13|        let mut translate_y = 0.0_f32;
 2072|       |
 2073|     13|        let mut bbox = tree.root().abs_stroke_bounding_box();
 2074|     13|        let mut bbox_w = bbox.width();
 2075|     13|        let mut bbox_h = bbox.height();
 2076|     13|        let mut bbox_valid = bbox_w.is_finite()
  ------------------
  |  Branch (2076:30): [True: 13, False: 0]
  ------------------
 2077|     13|            && bbox_h.is_finite()
  ------------------
  |  Branch (2077:16): [True: 13, False: 0]
  ------------------
 2078|     13|            && bbox_w > 0.5
  ------------------
  |  Branch (2078:16): [True: 6, False: 7]
  ------------------
 2079|      6|            && bbox_h > 0.5
  ------------------
  |  Branch (2079:16): [True: 6, False: 0]
  ------------------
 2080|      6|            && bbox.x().is_finite()
  ------------------
  |  Branch (2080:16): [True: 6, False: 0]
  ------------------
 2081|      6|            && bbox.y().is_finite();
 2082|     13|        let mut force_bbox_resize = false;
 2083|       |
 2084|     13|        let oversize_cap = 6.0_f32;
 2085|     13|        if let Some(raw_svg) = Self::strip_svg_attr(svg, "viewBox") {
                                  ^9
  ------------------
  |  Branch (2085:16): [True: 9, False: 4]
  ------------------
 2086|      9|            if let Ok(raw_tree) = usvg::Tree::from_data(raw_svg.as_bytes(), &opt) {
  ------------------
  |  Branch (2086:20): [True: 9, False: 0]
  ------------------
 2087|      9|                let raw_bbox = raw_tree.root().abs_stroke_bounding_box();
 2088|      9|                let raw_w = raw_bbox.width();
 2089|      9|                let raw_h = raw_bbox.height();
 2090|      9|                let raw_valid = raw_w.is_finite()
  ------------------
  |  Branch (2090:33): [True: 9, False: 0]
  ------------------
 2091|      9|                    && raw_h.is_finite()
  ------------------
  |  Branch (2091:24): [True: 9, False: 0]
  ------------------
 2092|      9|                    && raw_w > 0.5
  ------------------
  |  Branch (2092:24): [True: 7, False: 2]
  ------------------
 2093|      7|                    && raw_h > 0.5
  ------------------
  |  Branch (2093:24): [True: 7, False: 0]
  ------------------
 2094|      7|                    && raw_bbox.x().is_finite()
  ------------------
  |  Branch (2094:24): [True: 7, False: 0]
  ------------------
 2095|      7|                    && raw_bbox.y().is_finite();
 2096|      9|                let size_w = w as f32;
 2097|      9|                let size_h = h as f32;
 2098|      9|                let oversize_ok = raw_w <= size_w * oversize_cap && raw_h <= size_h * oversize_cap;
  ------------------
  |  Branch (2098:35): [True: 9, False: 0]
  ------------------
 2099|      9|                let oversized = raw_valid
  ------------------
  |  Branch (2099:33): [True: 7, False: 2]
  ------------------
 2100|      7|                    && oversize_ok
  ------------------
  |  Branch (2100:24): [True: 7, False: 0]
  ------------------
 2101|      7|                    && (size_w == 0.0
  ------------------
  |  Branch (2101:25): [True: 0, False: 7]
  ------------------
 2102|      7|                        || size_h == 0.0
  ------------------
  |  Branch (2102:28): [True: 0, False: 7]
  ------------------
 2103|      7|                        || raw_w > size_w * 1.2
  ------------------
  |  Branch (2103:28): [True: 1, False: 6]
  ------------------
 2104|      6|                        || raw_h > size_h * 1.2);
 2105|      9|                if oversized {
  ------------------
  |  Branch (2105:20): [True: 1, False: 8]
  ------------------
 2106|      1|                    tree = raw_tree;
 2107|      1|                    bbox = raw_bbox;
 2108|      1|                    bbox_w = raw_w;
 2109|      1|                    bbox_h = raw_h;
 2110|      1|                    bbox_valid = raw_valid;
 2111|      1|                    force_bbox_resize = true;
 2112|      8|                }
 2113|      0|            }
 2114|      4|        }
 2115|     13|        if bbox_valid {
  ------------------
  |  Branch (2115:12): [True: 6, False: 7]
  ------------------
 2116|      6|            let w_f = w as f32;
 2117|      6|            let h_f = h as f32;
 2118|      6|            let oversize_ok = bbox_w <= w_f * oversize_cap && bbox_h <= h_f * oversize_cap;
  ------------------
  |  Branch (2118:31): [True: 6, False: 0]
  ------------------
 2119|      6|            let oversize = (force_bbox_resize && oversize_ok)
                                                               ^1
  ------------------
  |  Branch (2119:29): [True: 1, False: 5]
  |  Branch (2119:50): [True: 1, False: 0]
  ------------------
 2120|      5|                || w == 0
  ------------------
  |  Branch (2120:20): [True: 0, False: 5]
  ------------------
 2121|      5|                || h == 0
  ------------------
  |  Branch (2121:20): [True: 0, False: 5]
  ------------------
 2122|      5|                || (oversize_ok && (bbox_w > w_f * 1.2 || bbox_h > h_f * 1.2));
                                                                        ^4
  ------------------
  |  Branch (2122:21): [True: 5, False: 0]
  |  Branch (2122:37): [True: 1, False: 4]
  ------------------
 2123|      6|            if oversize {
  ------------------
  |  Branch (2123:16): [True: 2, False: 4]
  ------------------
 2124|      2|                let padding = 4.0_f32;
 2125|      2|                let padded_w = (bbox_w + padding * 2.0).max(1.0);
 2126|      2|                let padded_h = (bbox_h + padding * 2.0).max(1.0);
 2127|      2|                w = padded_w.ceil() as u32;
 2128|      2|                h = padded_h.ceil() as u32;
 2129|      2|                translate_x = -bbox.x() + padding;
 2130|      2|                translate_y = -bbox.y() + padding;
 2131|      4|            }
 2132|      7|        }
 2133|       |
 2134|     13|        if w == 0 || h == 0 {
  ------------------
  |  Branch (2134:12): [True: 0, False: 13]
  |  Branch (2134:22): [True: 0, False: 13]
  ------------------
 2135|      0|            w = 256;
 2136|      0|            h = 256;
 2137|     13|        }
 2138|       |
 2139|     13|        let base_scale = MermaidRenderer::scale_from_bucket(scale_bucket);
 2140|     13|        let mut scale = base_scale;
 2141|     13|        if width_bucket > 0 {
  ------------------
  |  Branch (2141:12): [True: 3, False: 10]
  ------------------
 2142|      3|            let width_scale = width_bucket as f32 / w.max(1) as f32;
 2143|      3|            scale = scale.min(width_scale);
 2144|     10|        }
 2145|     13|        scale = scale.clamp(0.01, 4.0);
 2146|     13|        let adjustment = Self::scale_adjustment_for_svg(svg);
 2147|     13|        scale = (scale * adjustment).clamp(0.01, 4.0);
 2148|       |
 2149|     13|        let mut target_w = (w as f32 * scale).round() as u32;
 2150|     13|        let mut target_h = (h as f32 * scale).round() as u32;
 2151|     13|        target_w = target_w.max(1);
 2152|     13|        target_h = target_h.max(1);
 2153|       |
 2154|     13|        if std::env::var("MDMDVIEW_MERMAID_LOG_RASTER").is_ok() {
  ------------------
  |  Branch (2154:12): [True: 11, False: 2]
  ------------------
 2155|     11|            eprintln!(
 2156|     11|                "Mermaid raster: svg={}x{} target={}x{} scale={:.3} bbox_valid={} bbox=({:.2},{:.2},{:.2},{:.2})",
 2157|     11|                w,
 2158|     11|                h,
 2159|     11|                target_w,
 2160|     11|                target_h,
 2161|     11|                scale,
 2162|     11|                bbox_valid,
 2163|     11|                bbox.x(),
 2164|     11|                bbox.y(),
 2165|     11|                bbox_w,
 2166|     11|                bbox_h
 2167|     11|            );
 2168|     11|        }
                      ^2
 2169|       |
 2170|     13|        let max_side = MermaidRenderer::MERMAID_MAX_RENDER_SIDE;
 2171|     13|        if target_w > max_side || target_h > max_side {
                                                ^11
  ------------------
  |  Branch (2171:12): [True: 2, False: 11]
  |  Branch (2171:35): [True: 0, False: 11]
  ------------------
 2172|      2|            let clamp_scale =
 2173|      2|                (max_side as f32 / target_w as f32).min(max_side as f32 / target_h as f32);
 2174|      2|            scale = (scale * clamp_scale).clamp(0.01, 4.0);
 2175|      2|            target_w = (w as f32 * scale).round() as u32;
 2176|      2|            target_h = (h as f32 * scale).round() as u32;
 2177|     11|        }
 2178|       |
 2179|     13|        let mut pixmap = tiny_skia::Pixmap::new(target_w, target_h)
 2180|     13|            .ok_or_else(|| "Pixmap alloc failed".to_string())?;
                                         ^0                    ^0          ^0
 2181|     13|        if let Some([r, g, b, a]) = bg {
                                   ^3 ^3 ^3 ^3
  ------------------
  |  Branch (2181:16): [True: 3, False: 10]
  ------------------
 2182|      3|            let color = tiny_skia::Color::from_rgba8(r, g, b, a);
 2183|      3|            pixmap.fill(color);
 2184|     10|        }
 2185|       |
 2186|     13|        let mut pmut = pixmap.as_mut();
 2187|     13|        let mut transform = tiny_skia::Transform::from_scale(scale, scale);
 2188|     13|        if translate_x != 0.0 || translate_y != 0.0 {
                                               ^11
  ------------------
  |  Branch (2188:12): [True: 2, False: 11]
  |  Branch (2188:34): [True: 0, False: 11]
  ------------------
 2189|      2|            transform = transform.pre_translate(translate_x, translate_y);
 2190|     11|        }
 2191|     13|        resvg::render(&tree, transform, &mut pmut);
 2192|     13|        let data = pixmap.data().to_vec();
 2193|     13|        Ok((data, target_w, target_h))
 2194|     15|    }
 2195|       |
 2196|     16|    fn image_href_resolver() -> usvg::ImageHrefResolver<'static> {
 2197|     16|        let resolve_data = usvg::ImageHrefResolver::default_data_resolver();
 2198|     16|        let resolve_string = Box::new(|_: &str, _: &usvg::Options| None);
 2199|     16|        usvg::ImageHrefResolver {
 2200|     16|            resolve_data,
 2201|     16|            resolve_string,
 2202|     16|        }
 2203|     16|    }
 2204|       |
 2205|     16|    fn scale_adjustment_for_svg(svg: &str) -> f32 {
 2206|     16|        if svg.contains("aria-roledescription=\"er\"")
  ------------------
  |  Branch (2206:12): [True: 1, False: 15]
  ------------------
 2207|     15|            || svg.contains("aria-roledescription='er'")
  ------------------
  |  Branch (2207:16): [True: 1, False: 14]
  ------------------
 2208|       |        {
 2209|      2|            0.94
 2210|       |        } else {
 2211|     14|            1.0
 2212|       |        }
 2213|     16|    }
 2214|       |
 2215|    304|    fn now_ms() -> u64 {
 2216|    304|        SystemTime::now()
 2217|    304|            .duration_since(UNIX_EPOCH)
 2218|    304|            .unwrap_or_default()
 2219|    304|            .as_millis() as u64
 2220|    304|    }
 2221|       |}
 2222|       |
 2223|       |#[cfg(feature = "mermaid-quickjs")]
 2224|       |const MERMAID_DOM_SHIM: &str = r#"
 2225|       |var window = globalThis;
 2226|       |var __mdmdview_text_cache = {};
 2227|       |window.__mdmdview_bbox_rev = 0;
 2228|       |function __mdmdview_bump_bbox_rev() {
 2229|       |  window.__mdmdview_bbox_rev = (window.__mdmdview_bbox_rev || 0) + 1;
 2230|       |}
 2231|       |function __mdmdview_measure_text(text, fontSize, fontWeight) {
 2232|       |  var size = fontSize || 16;
 2233|       |  var raw = text ? String(text) : '';
 2234|       |  if (!raw.length) {
 2235|       |    return { width: 0, height: 0 };
 2236|       |  }
 2237|       |  var weight = (typeof fontWeight === 'number' && !isNaN(fontWeight)) ? fontWeight : null;
 2238|       |  var key = size + '|' + (weight || 0) + '|' + raw;
 2239|       |  var hit = __mdmdview_text_cache[key];
 2240|       |  if (hit) { return hit; }
 2241|       |  if (typeof __mdmdview_measure_text_native === 'function') {
 2242|       |    try {
 2243|       |      var native = __mdmdview_measure_text_native(raw, size, weight);
 2244|       |      if (native && typeof native.width === 'number' && typeof native.height === 'number') {
 2245|       |        __mdmdview_text_cache[key] = native;
 2246|       |        return native;
 2247|       |      }
 2248|       |      if (native && typeof native.length === 'number' && native.length >= 2) {
 2249|       |        var w = Number(native[0]);
 2250|       |        var h = Number(native[1]);
 2251|       |        if (isFinite(w) && isFinite(h)) {
 2252|       |          var converted = { width: w, height: h };
 2253|       |          __mdmdview_text_cache[key] = converted;
 2254|       |          return converted;
 2255|       |        }
 2256|       |      }
 2257|       |    } catch (e) {}
 2258|       |  }
 2259|       |  var lines = raw.split(/\n/);
 2260|       |  var maxLen = 0;
 2261|       |  for (var i = 0; i < lines.length; i++) {
 2262|       |    if (lines[i].length > maxLen) { maxLen = lines[i].length; }
 2263|       |  }
 2264|       |  var width = maxLen * size * 0.5;
 2265|       |  var height = lines.length * size * 1.2;
 2266|       |  var res = { width: width, height: height };
 2267|       |  __mdmdview_text_cache[key] = res;
 2268|       |  return res;
 2269|       |}
 2270|       |function __mdmdview_parse_font_size(value, baseSize) {
 2271|       |  if (value === null || value === undefined) { return baseSize; }
 2272|       |  var raw = String(value).trim();
 2273|       |  if (!raw) { return baseSize; }
 2274|       |  var num = parseFloat(raw);
 2275|       |  if (isNaN(num)) { return baseSize; }
 2276|       |  if (raw.indexOf('em') >= 0) {
 2277|       |    var base = baseSize || 16;
 2278|       |    return num * base;
 2279|       |  }
 2280|       |  if (raw.indexOf('ex') >= 0) {
 2281|       |    var baseEx = baseSize || 16;
 2282|       |    return num * baseEx * 0.5;
 2283|       |  }
 2284|       |  return num;
 2285|       |}
 2286|       |function __mdmdview_parse_font_weight_value(value) {
 2287|       |  if (value === null || value === undefined) { return null; }
 2288|       |  var raw = String(value).trim().toLowerCase();
 2289|       |  if (!raw) { return null; }
 2290|       |  if (raw === 'normal') { return 400; }
 2291|       |  if (raw === 'bold' || raw === 'bolder') { return 700; }
 2292|       |  if (raw === 'lighter') { return 300; }
 2293|       |  var num = parseFloat(raw);
 2294|       |  if (isNaN(num)) { return null; }
 2295|       |  return num;
 2296|       |}
 2297|       |function __mdmdview_parse_css_font_sizes(cssText, cache) {
 2298|       |  if (!cssText || !cache) { return; }
 2299|       |  var chunks = String(cssText).split('}');
 2300|       |  for (var i = 0; i < chunks.length; i++) {
 2301|       |    var rule = chunks[i];
 2302|       |    var parts = rule.split('{');
 2303|       |    if (parts.length < 2) { continue; }
 2304|       |    var selector = parts[0];
 2305|       |    var body = parts.slice(1).join('{');
 2306|       |    if (!selector || !body) { continue; }
 2307|       |    var sizeMatch = body.match(/font-size\s*:\s*([^;]+)/i);
 2308|       |    if (!sizeMatch) { continue; }
 2309|       |    var sizeValue = sizeMatch[1];
 2310|       |    var size = __mdmdview_parse_font_size(sizeValue, 16);
 2311|       |    if (!size || isNaN(size)) { continue; }
 2312|       |    var selectors = selector.split(',');
 2313|       |    for (var s = 0; s < selectors.length; s++) {
 2314|       |      var sel = selectors[s].trim();
 2315|       |      if (!sel) { continue; }
 2316|       |      if (sel.indexOf(':') >= 0) { continue; }
 2317|       |      var classMatches = sel.match(/\\.([A-Za-z0-9_-]+)/g);
 2318|       |      if (!classMatches || classMatches.length !== 1) { continue; }
 2319|       |      var cls = classMatches[0].slice(1);
 2320|       |      if (!cls) { continue; }
 2321|       |      if (!cache[cls] || cache[cls] < size) {
 2322|       |        cache[cls] = size;
 2323|       |      }
 2324|       |    }
 2325|       |  }
 2326|       |}
 2327|       |function __mdmdview_parse_css_font_weights(cssText, cache) {
 2328|       |  if (!cssText || !cache) { return; }
 2329|       |  var chunks = String(cssText).split('}');
 2330|       |  for (var i = 0; i < chunks.length; i++) {
 2331|       |    var rule = chunks[i];
 2332|       |    var parts = rule.split('{');
 2333|       |    if (parts.length < 2) { continue; }
 2334|       |    var selector = parts[0];
 2335|       |    var body = parts.slice(1).join('{');
 2336|       |    if (!selector || !body) { continue; }
 2337|       |    var weightMatch = body.match(/font-weight\s*:\s*([^;]+)/i);
 2338|       |    if (!weightMatch) { continue; }
 2339|       |    var weightValue = weightMatch[1];
 2340|       |    var weight = __mdmdview_parse_font_weight_value(weightValue);
 2341|       |    if (!weight || isNaN(weight)) { continue; }
 2342|       |    var selectors = selector.split(',');
 2343|       |    for (var s = 0; s < selectors.length; s++) {
 2344|       |      var sel = selectors[s].trim();
 2345|       |      if (!sel) { continue; }
 2346|       |      if (sel.indexOf(':') >= 0) { continue; }
 2347|       |      var classMatches = sel.match(/\\.([A-Za-z0-9_-]+)/g);
 2348|       |      if (!classMatches || classMatches.length !== 1) { continue; }
 2349|       |      var cls = classMatches[0].slice(1);
 2350|       |      if (!cls) { continue; }
 2351|       |      if (!cache[cls] || cache[cls] < weight) {
 2352|       |        cache[cls] = weight;
 2353|       |      }
 2354|       |    }
 2355|       |  }
 2356|       |}
 2357|       |function __mdmdview_collect_style_texts(node, out) {
 2358|       |  if (!node || !out) { return; }
 2359|       |  var name = (node.tagName || '').toLowerCase();
 2360|       |  if (name === 'style') {
 2361|       |    var text = __mdmdview_collect_text(node);
 2362|       |    if (text) { out.push(text); }
 2363|       |  }
 2364|       |  if (!node.children) { return; }
 2365|       |  for (var i = 0; i < node.children.length; i++) {
 2366|       |    __mdmdview_collect_style_texts(node.children[i], out);
 2367|       |  }
 2368|       |}
 2369|       |function __mdmdview_find_root_node(node) {
 2370|       |  if (!node) { return null; }
 2371|       |  var current = node;
 2372|       |  var last = node;
 2373|       |  var depth = 0;
 2374|       |  while (current && depth < 120) {
 2375|       |    last = current;
 2376|       |    if (!current.__mdmdview_parent_set) { break; }
 2377|       |    current = current.parentNode;
 2378|       |    depth += 1;
 2379|       |  }
 2380|       |  return last;
 2381|       |}
 2382|       |function __mdmdview_style_cache() {
 2383|       |  var rev = window.__mdmdview_bbox_rev || 0;
 2384|       |  if (window.__mdmdview_font_cache && window.__mdmdview_font_cache_rev === rev) {
 2385|       |    return window.__mdmdview_font_cache;
 2386|       |  }
 2387|       |  var cache = {};
 2388|       |  if (typeof document !== 'undefined' && document && document.getElementsByTagName) {
 2389|       |    var styles = document.getElementsByTagName('style') || [];
 2390|       |    for (var i = 0; i < styles.length; i++) {
 2391|       |      var text = styles[i] ? __mdmdview_collect_text(styles[i]) : '';
 2392|       |      __mdmdview_parse_css_font_sizes(text, cache);
 2393|       |    }
 2394|       |  }
 2395|       |  window.__mdmdview_font_cache = cache;
 2396|       |  window.__mdmdview_font_cache_rev = rev;
 2397|       |  window.__mdmdview_font_cache_root = null;
 2398|       |  window.__mdmdview_font_cache_root_rev = rev;
 2399|       |  return cache;
 2400|       |}
 2401|       |function __mdmdview_style_cache_for_node(node) {
 2402|       |  var cache = __mdmdview_style_cache();
 2403|       |  if (!node) { return cache; }
 2404|       |  var rev = window.__mdmdview_bbox_rev || 0;
 2405|       |  var root = __mdmdview_find_root_node(node);
 2406|       |  if (!root) { return cache; }
 2407|       |  if (window.__mdmdview_font_cache_root === root && window.__mdmdview_font_cache_root_rev === rev) {
 2408|       |    return cache;
 2409|       |  }
 2410|       |  var texts = [];
 2411|       |  __mdmdview_collect_style_texts(root, texts);
 2412|       |  for (var i = 0; i < texts.length; i++) {
 2413|       |    __mdmdview_parse_css_font_sizes(texts[i], cache);
 2414|       |  }
 2415|       |  window.__mdmdview_font_cache_root = root;
 2416|       |  window.__mdmdview_font_cache_root_rev = rev;
 2417|       |  return cache;
 2418|       |}
 2419|       |function __mdmdview_style_weight_cache() {
 2420|       |  var rev = window.__mdmdview_bbox_rev || 0;
 2421|       |  if (window.__mdmdview_font_weight_cache && window.__mdmdview_font_weight_cache_rev === rev) {
 2422|       |    return window.__mdmdview_font_weight_cache;
 2423|       |  }
 2424|       |  var cache = {};
 2425|       |  if (typeof document !== 'undefined' && document && document.getElementsByTagName) {
 2426|       |    var styles = document.getElementsByTagName('style') || [];
 2427|       |    for (var i = 0; i < styles.length; i++) {
 2428|       |      var text = styles[i] ? __mdmdview_collect_text(styles[i]) : '';
 2429|       |      __mdmdview_parse_css_font_weights(text, cache);
 2430|       |    }
 2431|       |  }
 2432|       |  window.__mdmdview_font_weight_cache = cache;
 2433|       |  window.__mdmdview_font_weight_cache_rev = rev;
 2434|       |  window.__mdmdview_font_weight_cache_root = null;
 2435|       |  window.__mdmdview_font_weight_cache_root_rev = rev;
 2436|       |  return cache;
 2437|       |}
 2438|       |function __mdmdview_style_weight_cache_for_node(node) {
 2439|       |  var cache = __mdmdview_style_weight_cache();
 2440|       |  if (!node) { return cache; }
 2441|       |  var rev = window.__mdmdview_bbox_rev || 0;
 2442|       |  var root = __mdmdview_find_root_node(node);
 2443|       |  if (!root) { return cache; }
 2444|       |  if (window.__mdmdview_font_weight_cache_root === root && window.__mdmdview_font_weight_cache_root_rev === rev) {
 2445|       |    return cache;
 2446|       |  }
 2447|       |  var texts = [];
 2448|       |  __mdmdview_collect_style_texts(root, texts);
 2449|       |  for (var i = 0; i < texts.length; i++) {
 2450|       |    __mdmdview_parse_css_font_weights(texts[i], cache);
 2451|       |  }
 2452|       |  window.__mdmdview_font_weight_cache_root = root;
 2453|       |  window.__mdmdview_font_weight_cache_root_rev = rev;
 2454|       |  return cache;
 2455|       |}
 2456|       |function __mdmdview_class_font_size(el) {
 2457|       |  if (!el) { return null; }
 2458|       |  var cache = __mdmdview_style_cache_for_node(el);
 2459|       |  if (!cache) { return null; }
 2460|       |  var list = __mdmdview_get_class_list(el);
 2461|       |  for (var i = 0; i < list.length; i++) {
 2462|       |    var size = cache[list[i]];
 2463|       |    if (size && !isNaN(size)) { return size; }
 2464|       |  }
 2465|       |  return null;
 2466|       |}
 2467|       |function __mdmdview_class_font_weight(el) {
 2468|       |  if (!el) { return null; }
 2469|       |  var cache = __mdmdview_style_weight_cache_for_node(el);
 2470|       |  if (!cache) { return null; }
 2471|       |  var list = __mdmdview_get_class_list(el);
 2472|       |  for (var i = 0; i < list.length; i++) {
 2473|       |    var weight = cache[list[i]];
 2474|       |    if (weight && !isNaN(weight)) { return weight; }
 2475|       |  }
 2476|       |  return null;
 2477|       |}
 2478|       |function __mdmdview_get_font_size(el) {
 2479|       |  var size = 16;
 2480|       |  if (el && el.style && el.style.fontSize) {
 2481|       |    size = __mdmdview_parse_font_size(el.style.fontSize, size);
 2482|       |    if (!isNaN(size)) { return size; }
 2483|       |  }
 2484|       |  if (el && el.style && el.style['font-size']) {
 2485|       |    size = __mdmdview_parse_font_size(el.style['font-size'], size);
 2486|       |    if (!isNaN(size)) { return size; }
 2487|       |  }
 2488|       |  if (el && el.getAttribute) {
 2489|       |    var attr = el.getAttribute('font-size');
 2490|       |    if (attr) {
 2491|       |      var a = __mdmdview_parse_font_size(attr, size);
 2492|       |      if (!isNaN(a)) { size = a; }
 2493|       |    }
 2494|       |  }
 2495|       |  var classSize = __mdmdview_class_font_size(el);
 2496|       |  if (classSize && !isNaN(classSize)) { return classSize; }
 2497|       |  var classList = __mdmdview_get_class_list(el);
 2498|       |  for (var c = 0; c < classList.length; c++) {
 2499|       |    var cls = classList[c];
 2500|       |    if (cls === 'commit-label' || cls === 'commit-label-bkg' || cls === 'tag-label' || cls === 'tag-label-bkg') {
 2501|       |      return 10;
 2502|       |    }
 2503|       |    if (cls === 'gitTitleText') {
 2504|       |      return 18;
 2505|       |    }
 2506|       |  }
 2507|       |  var ancestor = el;
 2508|       |  var steps = 0;
 2509|       |  while (ancestor && steps < 6) {
 2510|       |    if (__mdmdview_has_class(ancestor, 'commit-labels') || __mdmdview_has_class(ancestor, 'tag-labels')) {
 2511|       |      return 10;
 2512|       |    }
 2513|       |    ancestor = ancestor.parentNode;
 2514|       |    steps += 1;
 2515|       |  }
 2516|       |  var current = el;
 2517|       |  var depth = 0;
 2518|       |  while (current && depth < 4) {
 2519|       |    current = current.parentNode;
 2520|       |    if (!current) { break; }
 2521|       |    var parentSize = __mdmdview_class_font_size(current);
 2522|       |    if (parentSize && !isNaN(parentSize)) { return parentSize; }
 2523|       |    depth += 1;
 2524|       |  }
 2525|       |  var tag = (el && el.tagName) ? String(el.tagName).toLowerCase() : '';
 2526|       |  if (tag === 'text' || tag === 'tspan') {
 2527|       |    return size;
 2528|       |  }
 2529|       |  return size;
 2530|       |}
 2531|       |function __mdmdview_get_font_weight_raw(el) {
 2532|       |  if (el && el.style) {
 2533|       |    if (el.style.fontWeight) {
 2534|       |      var sw = __mdmdview_parse_font_weight_value(el.style.fontWeight);
 2535|       |      if (sw && !isNaN(sw)) { return sw; }
 2536|       |    }
 2537|       |    if (el.style['font-weight']) {
 2538|       |      var sw2 = __mdmdview_parse_font_weight_value(el.style['font-weight']);
 2539|       |      if (sw2 && !isNaN(sw2)) { return sw2; }
 2540|       |    }
 2541|       |  }
 2542|       |  if (el && el.getAttribute) {
 2543|       |    var attr = el.getAttribute('font-weight');
 2544|       |    if (attr) {
 2545|       |      var aw = __mdmdview_parse_font_weight_value(attr);
 2546|       |      if (aw && !isNaN(aw)) { return aw; }
 2547|       |    }
 2548|       |  }
 2549|       |  var classWeight = __mdmdview_class_font_weight(el);
 2550|       |  if (classWeight && !isNaN(classWeight)) { return classWeight; }
 2551|       |  var classList = __mdmdview_get_class_list(el);
 2552|       |  for (var i = 0; i < classList.length; i++) {
 2553|       |    var cls = classList[i];
 2554|       |    if (cls === 'classTitle' || cls === 'classTitleText' || cls === 'title') {
 2555|       |      return 700;
 2556|       |    }
 2557|       |  }
 2558|       |  return null;
 2559|       |}
 2560|       |function __mdmdview_get_font_weight(el) {
 2561|       |  var direct = __mdmdview_get_font_weight_raw(el);
 2562|       |  if (direct && !isNaN(direct)) { return direct; }
 2563|       |  var current = el;
 2564|       |  var depth = 0;
 2565|       |  while (current && depth < 4) {
 2566|       |    current = current.parentNode;
 2567|       |    if (!current) { break; }
 2568|       |    var parentWeight = __mdmdview_get_font_weight_raw(current);
 2569|       |    if (parentWeight && !isNaN(parentWeight)) { return parentWeight; }
 2570|       |    depth += 1;
 2571|       |  }
 2572|       |  return 400;
 2573|       |}
 2574|       |function __mdmdview_parse_num(value) {
 2575|       |  var num = parseFloat(value);
 2576|       |  return isNaN(num) ? 0 : num;
 2577|       |}
 2578|       |function __mdmdview_parse_length(value, fontSize) {
 2579|       |  if (value === null || value === undefined) { return 0; }
 2580|       |  var raw = String(value).trim();
 2581|       |  if (!raw) { return 0; }
 2582|       |  var num = parseFloat(raw);
 2583|       |  if (isNaN(num)) { return 0; }
 2584|       |  if (raw.indexOf('em') >= 0) {
 2585|       |    return num * (fontSize || 16);
 2586|       |  }
 2587|       |  if (raw.indexOf('ex') >= 0) {
 2588|       |    return num * (fontSize || 16) * 0.5;
 2589|       |  }
 2590|       |  return num;
 2591|       |}
 2592|       |function __mdmdview_transform_point(el, x, y) {
 2593|       |  var box = __mdmdview_apply_transform(el, { x: x, y: y, width: 0, height: 0 });
 2594|       |  return { x: box.x, y: box.y };
 2595|       |}
 2596|       |function __mdmdview_path_points(el) {
 2597|       |  var d = el && el.getAttribute ? el.getAttribute('d') : null;
 2598|       |  if (!d) { return []; }
 2599|       |  var nums = String(d).match(/-?\d*\.?\d+(?:e[-+]?\d+)?/ig);
 2600|       |  if (!nums || nums.length < 2) { return []; }
 2601|       |  var points = [];
 2602|       |  for (var i = 0; i + 1 < nums.length; i += 2) {
 2603|       |    var x = __mdmdview_parse_num(nums[i]);
 2604|       |    var y = __mdmdview_parse_num(nums[i + 1]);
 2605|       |    points.push(__mdmdview_transform_point(el, x, y));
 2606|       |  }
 2607|       |  return points;
 2608|       |}
 2609|       |function __mdmdview_path_total_length(el) {
 2610|       |  var points = __mdmdview_path_points(el);
 2611|       |  if (points.length < 2) { return 0; }
 2612|       |  var total = 0;
 2613|       |  for (var i = 1; i < points.length; i++) {
 2614|       |    var dx = points[i].x - points[i - 1].x;
 2615|       |    var dy = points[i].y - points[i - 1].y;
 2616|       |    total += Math.sqrt(dx * dx + dy * dy);
 2617|       |  }
 2618|       |  return total;
 2619|       |}
 2620|       |function __mdmdview_path_point_at_length(el, length) {
 2621|       |  var points = __mdmdview_path_points(el);
 2622|       |  if (!points.length) { return { x: 0, y: 0 }; }
 2623|       |  if (points.length === 1) { return points[0]; }
 2624|       |  var remaining = Math.max(0, __mdmdview_parse_num(length));
 2625|       |  for (var i = 1; i < points.length; i++) {
 2626|       |    var p0 = points[i - 1];
 2627|       |    var p1 = points[i];
 2628|       |    var dx = p1.x - p0.x;
 2629|       |    var dy = p1.y - p0.y;
 2630|       |    var seg = Math.sqrt(dx * dx + dy * dy);
 2631|       |    if (seg <= 0) { continue; }
 2632|       |    if (remaining <= seg) {
 2633|       |      var t = remaining / seg;
 2634|       |      return { x: p0.x + dx * t, y: p0.y + dy * t };
 2635|       |    }
 2636|       |    remaining -= seg;
 2637|       |  }
 2638|       |  return points[points.length - 1];
 2639|       |}
 2640|       |function __mdmdview_text_metrics(el) {
 2641|       |  var size = __mdmdview_get_font_size(el);
 2642|       |  var weight = __mdmdview_get_font_weight(el);
 2643|       |  if (!el || !el.children || !el.children.length) {
 2644|       |    var raw = el ? __mdmdview_collect_text(el) : '';
 2645|       |    return __mdmdview_measure_text(raw, size, weight);
 2646|       |  }
 2647|       |  var max_w = 0;
 2648|       |  var max_h = 0;
 2649|       |  var lines = 0;
 2650|       |  for (var i = 0; i < el.children.length; i++) {
 2651|       |    var child = el.children[i];
 2652|       |    var tag = (child.tagName || '').toLowerCase();
 2653|       |    if (tag !== 'tspan') { continue; }
 2654|       |    var text = __mdmdview_collect_text(child);
 2655|       |    if (!text || !String(text).trim()) { continue; }
 2656|       |    var child_weight = __mdmdview_get_font_weight(child);
 2657|       |    var m = __mdmdview_measure_text(text, size, child_weight);
 2658|       |    if (m.width > max_w) { max_w = m.width; }
 2659|       |    if (m.height > max_h) { max_h = m.height; }
 2660|       |    lines += 1;
 2661|       |  }
 2662|       |  if (!lines) {
 2663|       |    var fallback = __mdmdview_collect_text(el);
 2664|       |    return __mdmdview_measure_text(fallback, size, weight);
 2665|       |  }
 2666|       |  var line_height = max_h > 0 ? max_h : size * 1.2;
 2667|       |  return { width: max_w, height: lines * line_height };
 2668|       |}
 2669|       |function __mdmdview_apply_matrix(bbox, a, b, c, d, e, f) {
 2670|       |  if (!bbox) { return bbox; }
 2671|       |  var x = bbox.x;
 2672|       |  var y = bbox.y;
 2673|       |  var w = bbox.width;
 2674|       |  var h = bbox.height;
 2675|       |  var pts = [
 2676|       |    [x, y],
 2677|       |    [x + w, y],
 2678|       |    [x, y + h],
 2679|       |    [x + w, y + h]
 2680|       |  ];
 2681|       |  var min_x = Infinity;
 2682|       |  var min_y = Infinity;
 2683|       |  var max_x = -Infinity;
 2684|       |  var max_y = -Infinity;
 2685|       |  for (var i = 0; i < pts.length; i++) {
 2686|       |    var px = pts[i][0];
 2687|       |    var py = pts[i][1];
 2688|       |    var nx = a * px + c * py + e;
 2689|       |    var ny = b * px + d * py + f;
 2690|       |    if (nx < min_x) { min_x = nx; }
 2691|       |    if (ny < min_y) { min_y = ny; }
 2692|       |    if (nx > max_x) { max_x = nx; }
 2693|       |    if (ny > max_y) { max_y = ny; }
 2694|       |  }
 2695|       |  if (!isFinite(min_x) || !isFinite(min_y) || !isFinite(max_x) || !isFinite(max_y)) {
 2696|       |    return bbox;
 2697|       |  }
 2698|       |  return { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y };
 2699|       |}
 2700|       |function __mdmdview_apply_transform(el, bbox) {
 2701|       |  if (!el || !bbox) { return bbox; }
 2702|       |  var transform = el.getAttribute ? el.getAttribute('transform') : null;
 2703|       |  if (!transform) { return bbox; }
 2704|       |  var current = bbox;
 2705|       |  var re = /([a-zA-Z]+)\(([^)]+)\)/g;
 2706|       |  var match = null;
 2707|       |  while ((match = re.exec(String(transform))) !== null) {
 2708|       |    var name = match[1].toLowerCase();
 2709|       |    var params = match[2].split(/[, ]+/).filter(function(p) { return p.length; });
 2710|       |    var nums = [];
 2711|       |    for (var i = 0; i < params.length; i++) {
 2712|       |      nums.push(__mdmdview_parse_num(params[i]));
 2713|       |    }
 2714|       |    if (name === 'translate') {
 2715|       |      var tx = nums.length ? nums[0] : 0;
 2716|       |      var ty = nums.length > 1 ? nums[1] : 0;
 2717|       |      current = __mdmdview_apply_matrix(current, 1, 0, 0, 1, tx, ty);
 2718|       |    } else if (name === 'scale') {
 2719|       |      var sx = nums.length ? nums[0] : 1;
 2720|       |      var sy = nums.length > 1 ? nums[1] : sx;
 2721|       |      current = __mdmdview_apply_matrix(current, sx, 0, 0, sy, 0, 0);
 2722|       |    } else if (name === 'matrix' && nums.length >= 6) {
 2723|       |      current = __mdmdview_apply_matrix(
 2724|       |        current,
 2725|       |        nums[0],
 2726|       |        nums[1],
 2727|       |        nums[2],
 2728|       |        nums[3],
 2729|       |        nums[4],
 2730|       |        nums[5]
 2731|       |      );
 2732|       |    } else if (name === 'rotate' && nums.length) {
 2733|       |      var angle = nums[0] * Math.PI / 180.0;
 2734|       |      var cos = Math.cos(angle);
 2735|       |      var sin = Math.sin(angle);
 2736|       |      if (nums.length >= 3) {
 2737|       |        var cx = nums[1];
 2738|       |        var cy = nums[2];
 2739|       |        current = __mdmdview_apply_matrix(current, 1, 0, 0, 1, -cx, -cy);
 2740|       |        current = __mdmdview_apply_matrix(current, cos, sin, -sin, cos, 0, 0);
 2741|       |        current = __mdmdview_apply_matrix(current, 1, 0, 0, 1, cx, cy);
 2742|       |      } else {
 2743|       |        current = __mdmdview_apply_matrix(current, cos, sin, -sin, cos, 0, 0);
 2744|       |      }
 2745|       |    } else if (name === 'skewx' && nums.length) {
 2746|       |      var ax = nums[0] * Math.PI / 180.0;
 2747|       |      current = __mdmdview_apply_matrix(current, 1, 0, Math.tan(ax), 1, 0, 0);
 2748|       |    } else if (name === 'skewy' && nums.length) {
 2749|       |      var ay = nums[0] * Math.PI / 180.0;
 2750|       |      current = __mdmdview_apply_matrix(current, 1, Math.tan(ay), 0, 1, 0, 0);
 2751|       |    }
 2752|       |  }
 2753|       |  return current;
 2754|       |}
 2755|       |function __mdmdview_children_bounds(el) {
 2756|       |  if (!el || !el.children || !el.children.length) { return null; }
 2757|       |  var min_x = Infinity;
 2758|       |  var min_y = Infinity;
 2759|       |  var max_x = -Infinity;
 2760|       |  var max_y = -Infinity;
 2761|       |  for (var i = 0; i < el.children.length; i++) {
 2762|       |    var child_box = __mdmdview_bbox(el.children[i]);
 2763|       |    if (!child_box) { continue; }
 2764|       |    if (!isFinite(child_box.width) || !isFinite(child_box.height)) { continue; }
 2765|       |    if (child_box.width <= 0 && child_box.height <= 0) { continue; }
 2766|       |    if (child_box.x < min_x) { min_x = child_box.x; }
 2767|       |    if (child_box.y < min_y) { min_y = child_box.y; }
 2768|       |    if (child_box.x + child_box.width > max_x) { max_x = child_box.x + child_box.width; }
 2769|       |    if (child_box.y + child_box.height > max_y) { max_y = child_box.y + child_box.height; }
 2770|       |  }
 2771|       |  if (isFinite(min_x) && isFinite(min_y) && isFinite(max_x) && isFinite(max_y)) {
 2772|       |    return { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y };
 2773|       |  }
 2774|       |  return null;
 2775|       |}
 2776|       |function __mdmdview_cache_bbox(el, box) {
 2777|       |  if (el && box) {
 2778|       |    el.__mdmdview_bbox_cache = box;
 2779|       |    el.__mdmdview_bbox_rev = window.__mdmdview_bbox_rev || 0;
 2780|       |  }
 2781|       |  return box;
 2782|       |}
 2783|       |function __mdmdview_bbox(el) {
 2784|       |  if (!el) { return { x: 0, y: 0, width: 0, height: 0 }; }
 2785|       |  if (el.__mdmdview_bbox_cache && el.__mdmdview_bbox_rev === (window.__mdmdview_bbox_rev || 0)) {
 2786|       |    return el.__mdmdview_bbox_cache;
 2787|       |  }
 2788|       |  var tag = (el.tagName || '').toLowerCase();
 2789|       |  if (
 2790|       |    tag === 'style'
 2791|       |    || tag === 'defs'
 2792|       |    || tag === 'script'
 2793|       |    || tag === 'title'
 2794|       |    || tag === 'desc'
 2795|       |    || tag === 'metadata'
 2796|       |    || tag === 'marker'
 2797|       |    || tag === 'clippath'
 2798|       |    || tag === 'mask'
 2799|       |    || tag === 'pattern'
 2800|       |    || tag === 'lineargradient'
 2801|       |    || tag === 'radialgradient'
 2802|       |    || tag === 'stop'
 2803|       |  ) {
 2804|       |    return { x: 0, y: 0, width: 0, height: 0 };
 2805|       |  }
 2806|       |  if (tag === '#text') {
 2807|       |    var text = el.textContent || '';
 2808|       |    var size = __mdmdview_get_font_size(el);
 2809|       |    var weight = __mdmdview_get_font_weight(el);
 2810|       |    var m = __mdmdview_measure_text(text, size, weight);
 2811|       |    return __mdmdview_cache_bbox(
 2812|       |      el,
 2813|       |      __mdmdview_apply_transform(el, { x: 0, y: 0, width: m.width, height: m.height })
 2814|       |    );
 2815|       |  }
 2816|       |  if (tag === 'svg') {
 2817|       |    if (el.children && el.children.length) {
 2818|       |      var svg_bounds = __mdmdview_children_bounds(el);
 2819|       |      if (svg_bounds) {
 2820|       |        return __mdmdview_cache_bbox(el, __mdmdview_apply_transform(el, svg_bounds));
 2821|       |      }
 2822|       |    }
 2823|       |  }
 2824|       |  if (tag === 'text' || tag === 'tspan') {
 2825|       |    var metrics = __mdmdview_text_metrics(el);
 2826|       |    var fontSize = __mdmdview_get_font_size(el);
 2827|       |    var tx = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('x') : 0);
 2828|       |    var ty = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('y') : 0);
 2829|       |    var dx = __mdmdview_parse_length(el.getAttribute ? el.getAttribute('dx') : 0, fontSize);
 2830|       |    var dy = __mdmdview_parse_length(el.getAttribute ? el.getAttribute('dy') : 0, fontSize);
 2831|       |    if (tag === 'text' && el.children && el.children.length) {
 2832|       |      var first = el.children[0];
 2833|       |      var firstTag = (first.tagName || '').toLowerCase();
 2834|       |      if (firstTag === 'tspan') {
 2835|       |        if (!dx) { dx = __mdmdview_parse_length(first.getAttribute('dx'), fontSize); }
 2836|       |        if (!dy) { dy = __mdmdview_parse_length(first.getAttribute('dy'), fontSize); }
 2837|       |      }
 2838|       |    }
 2839|       |    tx += dx;
 2840|       |    ty += dy;
 2841|       |    var anchor = el.getAttribute ? el.getAttribute('text-anchor') : null;
 2842|       |    if (!anchor && el.style && el.style.textAnchor) { anchor = el.style.textAnchor; }
 2843|       |    if (anchor === 'middle') {
 2844|       |      tx -= metrics.width * 0.5;
 2845|       |    } else if (anchor === 'end' || anchor === 'right') {
 2846|       |      tx -= metrics.width;
 2847|       |    }
 2848|       |    var baseline = el.getAttribute ? el.getAttribute('dominant-baseline') : null;
 2849|       |    if (!baseline && el.style && el.style.dominantBaseline) { baseline = el.style.dominantBaseline; }
 2850|       |    var y = ty - metrics.height * 0.3;
 2851|       |    if (baseline === 'middle' || baseline === 'central') {
 2852|       |      y = ty - metrics.height * 0.5;
 2853|       |    } else if (baseline === 'hanging') {
 2854|       |      y = ty;
 2855|       |    }
 2856|       |    return __mdmdview_cache_bbox(
 2857|       |      el,
 2858|       |      __mdmdview_apply_transform(el, {
 2859|       |        x: tx,
 2860|       |        y: y,
 2861|       |        width: metrics.width,
 2862|       |        height: metrics.height
 2863|       |      })
 2864|       |    );
 2865|       |  }
 2866|       |  if (tag === 'rect') {
 2867|       |    var rx = __mdmdview_parse_num(el.getAttribute('x'));
 2868|       |    var ry = __mdmdview_parse_num(el.getAttribute('y'));
 2869|       |    var rw = __mdmdview_parse_num(el.getAttribute('width'));
 2870|       |    var rh = __mdmdview_parse_num(el.getAttribute('height'));
 2871|       |    return __mdmdview_cache_bbox(
 2872|       |      el,
 2873|       |      __mdmdview_apply_transform(el, { x: rx, y: ry, width: rw, height: rh })
 2874|       |    );
 2875|       |  }
 2876|       |  if (tag === 'circle') {
 2877|       |    var cx = __mdmdview_parse_num(el.getAttribute('cx'));
 2878|       |    var cy = __mdmdview_parse_num(el.getAttribute('cy'));
 2879|       |    var r = __mdmdview_parse_num(el.getAttribute('r'));
 2880|       |    return __mdmdview_cache_bbox(
 2881|       |      el,
 2882|       |      __mdmdview_apply_transform(el, { x: cx - r, y: cy - r, width: r * 2, height: r * 2 })
 2883|       |    );
 2884|       |  }
 2885|       |  if (tag === 'ellipse') {
 2886|       |    var ecx = __mdmdview_parse_num(el.getAttribute('cx'));
 2887|       |    var ecy = __mdmdview_parse_num(el.getAttribute('cy'));
 2888|       |    var erx = __mdmdview_parse_num(el.getAttribute('rx'));
 2889|       |    var ery = __mdmdview_parse_num(el.getAttribute('ry'));
 2890|       |    return __mdmdview_cache_bbox(
 2891|       |      el,
 2892|       |      __mdmdview_apply_transform(el, { x: ecx - erx, y: ecy - ery, width: erx * 2, height: ery * 2 })
 2893|       |    );
 2894|       |  }
 2895|       |  if (tag === 'line') {
 2896|       |    var x1 = __mdmdview_parse_num(el.getAttribute('x1'));
 2897|       |    var y1 = __mdmdview_parse_num(el.getAttribute('y1'));
 2898|       |    var x2 = __mdmdview_parse_num(el.getAttribute('x2'));
 2899|       |    var y2 = __mdmdview_parse_num(el.getAttribute('y2'));
 2900|       |    var min_x = Math.min(x1, x2);
 2901|       |    var min_y = Math.min(y1, y2);
 2902|       |    var max_x = Math.max(x1, x2);
 2903|       |    var max_y = Math.max(y1, y2);
 2904|       |    return __mdmdview_cache_bbox(
 2905|       |      el,
 2906|       |      __mdmdview_apply_transform(el, { x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y })
 2907|       |    );
 2908|       |  }
 2909|       |  if (tag === 'polygon' || tag === 'polyline') {
 2910|       |    var points = el.getAttribute('points');
 2911|       |    if (points) {
 2912|       |      var parts = String(points).trim().split(/[\s,]+/).filter(function(p) { return p.length; });
 2913|       |      if (parts.length >= 2) {
 2914|       |        var min_px = Infinity;
 2915|       |        var min_py = Infinity;
 2916|       |        var max_px = -Infinity;
 2917|       |        var max_py = -Infinity;
 2918|       |        for (var i = 0; i + 1 < parts.length; i += 2) {
 2919|       |          var px = __mdmdview_parse_num(parts[i]);
 2920|       |          var py = __mdmdview_parse_num(parts[i + 1]);
 2921|       |          if (px < min_px) { min_px = px; }
 2922|       |          if (py < min_py) { min_py = py; }
 2923|       |          if (px > max_px) { max_px = px; }
 2924|       |          if (py > max_py) { max_py = py; }
 2925|       |        }
 2926|       |        if (isFinite(min_px) && isFinite(min_py) && isFinite(max_px) && isFinite(max_py)) {
 2927|       |          return __mdmdview_cache_bbox(
 2928|       |            el,
 2929|       |            __mdmdview_apply_transform(el, {
 2930|       |              x: min_px,
 2931|       |              y: min_py,
 2932|       |              width: max_px - min_px,
 2933|       |              height: max_py - min_py
 2934|       |            })
 2935|       |          );
 2936|       |        }
 2937|       |      }
 2938|       |    }
 2939|       |  }
 2940|       |  if (tag === 'path') {
 2941|       |    var d = el.getAttribute('d');
 2942|       |    if (d) {
 2943|       |      var nums = String(d).match(/-?\d*\.?\d+(?:e[-+]?\d+)?/ig);
 2944|       |      if (nums && nums.length >= 2) {
 2945|       |        var min_px = Infinity;
 2946|       |        var min_py = Infinity;
 2947|       |        var max_px = -Infinity;
 2948|       |        var max_py = -Infinity;
 2949|       |        for (var i = 0; i + 1 < nums.length; i += 2) {
 2950|       |          var px = __mdmdview_parse_num(nums[i]);
 2951|       |          var py = __mdmdview_parse_num(nums[i + 1]);
 2952|       |          if (px < min_px) { min_px = px; }
 2953|       |          if (py < min_py) { min_py = py; }
 2954|       |          if (px > max_px) { max_px = px; }
 2955|       |          if (py > max_py) { max_py = py; }
 2956|       |        }
 2957|       |        if (isFinite(min_px) && isFinite(min_py) && isFinite(max_px) && isFinite(max_py)) {
 2958|       |          return __mdmdview_cache_bbox(
 2959|       |            el,
 2960|       |            __mdmdview_apply_transform(el, { x: min_px, y: min_py, width: max_px - min_px, height: max_py - min_py })
 2961|       |          );
 2962|       |        }
 2963|       |      }
 2964|       |    }
 2965|       |  }
 2966|       |  var font_size = __mdmdview_get_font_size(el);
 2967|       |  var width_attr = el.getAttribute ? el.getAttribute('width') : null;
 2968|       |  var height_attr = el.getAttribute ? el.getAttribute('height') : null;
 2969|       |  var bw = __mdmdview_parse_length(width_attr, font_size);
 2970|       |  var bh = __mdmdview_parse_length(height_attr, font_size);
 2971|       |  if ((!bw || !bh) && el.style) {
 2972|       |    if (!bw && el.style.width) { bw = __mdmdview_parse_length(el.style.width, font_size); }
 2973|       |    if (!bh && el.style.height) { bh = __mdmdview_parse_length(el.style.height, font_size); }
 2974|       |  }
 2975|       |  if ((!bw || !bh) && el.getAttribute) {
 2976|       |    var view_box = el.getAttribute('viewBox');
 2977|       |    if (view_box) {
 2978|       |      var parts = String(view_box).trim().split(/[\s,]+/).filter(function(p) { return p.length; });
 2979|       |      if (parts.length >= 4) {
 2980|       |        var vbw = __mdmdview_parse_num(parts[2]);
 2981|       |        var vbh = __mdmdview_parse_num(parts[3]);
 2982|       |        if (!bw && vbw) { bw = vbw; }
 2983|       |        if (!bh && vbh) { bh = vbh; }
 2984|       |      }
 2985|       |    }
 2986|       |  }
 2987|       |  if (!bw && !bh) {
 2988|       |    var html_tag = tag === 'div' || tag === 'body' || tag === 'html';
 2989|       |    if (html_tag) {
 2990|       |      bw = window.innerWidth || 0;
 2991|       |      bh = window.innerHeight || 0;
 2992|       |    }
 2993|       |  }
 2994|       |  if (bw || bh) {
 2995|       |    var bx = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('x') : 0);
 2996|       |    var by = __mdmdview_parse_num(el.getAttribute ? el.getAttribute('y') : 0);
 2997|       |    return __mdmdview_cache_bbox(
 2998|       |      el,
 2999|       |      __mdmdview_apply_transform(el, { x: bx, y: by, width: bw, height: bh })
 3000|       |    );
 3001|       |  }
 3002|       |  if (el.children && el.children.length) {
 3003|       |    var child_bounds = __mdmdview_children_bounds(el);
 3004|       |    if (child_bounds) {
 3005|       |      return __mdmdview_cache_bbox(el, __mdmdview_apply_transform(el, child_bounds));
 3006|       |    }
 3007|       |  }
 3008|       |  var fallback_text = el.textContent || '';
 3009|       |  var fallback_size = __mdmdview_get_font_size(el);
 3010|       |  var fallback_weight = __mdmdview_get_font_weight(el);
 3011|       |  var fallback = __mdmdview_measure_text(fallback_text, fallback_size, fallback_weight);
 3012|       |  return __mdmdview_cache_bbox(
 3013|       |    el,
 3014|       |    __mdmdview_apply_transform(el, { x: 0, y: 0, width: fallback.width, height: fallback.height })
 3015|       |  );
 3016|       |}
 3017|       |function __mdmdview_escape_text(text) {
 3018|       |  return String(text)
 3019|       |    .replace(/&/g, '&amp;')
 3020|       |    .replace(/</g, '&lt;')
 3021|       |    .replace(/>/g, '&gt;');
 3022|       |}
 3023|       |function __mdmdview_collect_text(node) {
 3024|       |  if (!node) { return ''; }
 3025|       |  if (node.tagName === '#text') { return node.textContent || ''; }
 3026|       |  var out = '';
 3027|       |  if (node.children && node.children.length) {
 3028|       |    for (var i = 0; i < node.children.length; i++) {
 3029|       |      out += __mdmdview_collect_text(node.children[i]);
 3030|       |    }
 3031|       |  }
 3032|       |  if (out && out.length) { return out; }
 3033|       |  return node.textContent || '';
 3034|       |}
 3035|       |function __mdmdview_escape_attr(text) {
 3036|       |  return String(text)
 3037|       |    .replace(/&/g, '&amp;')
 3038|       |    .replace(/"/g, '&quot;');
 3039|       |}
 3040|       |function __mdmdview_style_text(style) {
 3041|       |  if (!style) { return ''; }
 3042|       |  if (typeof style.cssText === 'string' && style.cssText.trim().length) {
 3043|       |    return style.cssText;
 3044|       |  }
 3045|       |  var parts = [];
 3046|       |  for (var key in style) {
 3047|       |    if (!Object.prototype.hasOwnProperty.call(style, key)) { continue; }
 3048|       |    if (key === 'cssText') { continue; }
 3049|       |    var val = style[key];
 3050|       |    if (typeof val === 'function') { continue; }
 3051|       |    if (val === null || val === undefined || val === '') { continue; }
 3052|       |    parts.push(key + ':' + String(val));
 3053|       |  }
 3054|       |  return parts.join(';');
 3055|       |}
 3056|       |function __mdmdview_is_shape_tag(tag) {
 3057|       |  var t = String(tag || '').toLowerCase();
 3058|       |  return t === 'rect'
 3059|       |    || t === 'path'
 3060|       |    || t === 'polygon'
 3061|       |    || t === 'circle'
 3062|       |    || t === 'ellipse'
 3063|       |    || t === 'line'
 3064|       |    || t === 'image';
 3065|       |}
 3066|       |function __mdmdview_group_has_text(node) {
 3067|       |  if (!node || !node.children || !node.children.length) { return false; }
 3068|       |  for (var i = 0; i < node.children.length; i++) {
 3069|       |    var child = node.children[i];
 3070|       |    if (!child) { continue; }
 3071|       |    var tag = String(child.tagName || '').toLowerCase();
 3072|       |    if (tag === 'text' || tag === 'foreignobject') { return true; }
 3073|       |    if (child.children && child.children.length && __mdmdview_group_has_text(child)) {
 3074|       |      return true;
 3075|       |    }
 3076|       |  }
 3077|       |  return false;
 3078|       |}
 3079|       |function __mdmdview_group_has_shape(node) {
 3080|       |  if (!node || !node.children || !node.children.length) { return false; }
 3081|       |  for (var i = 0; i < node.children.length; i++) {
 3082|       |    var child = node.children[i];
 3083|       |    if (!child) { continue; }
 3084|       |    if (__mdmdview_is_shape_tag(child.tagName)) { return true; }
 3085|       |    if (child.children && child.children.length && __mdmdview_group_has_shape(child)) {
 3086|       |      return true;
 3087|       |    }
 3088|       |  }
 3089|       |  return false;
 3090|       |}
 3091|       |function __mdmdview_is_labelish(node) {
 3092|       |  if (!node || !node.tagName) { return false; }
 3093|       |  var tag = String(node.tagName || '').toLowerCase();
 3094|       |  if (tag === 'text' || tag === 'foreignobject') { return true; }
 3095|       |  if (tag === 'g') {
 3096|       |    if (__mdmdview_has_class(node, 'clusters')) { return false; }
 3097|       |    if (__mdmdview_has_class(node, 'label')) { return true; }
 3098|       |    return __mdmdview_group_has_text(node);
 3099|       |  }
 3100|       |  return false;
 3101|       |}
 3102|       |function __mdmdview_order_children(node) {
 3103|       |  if (!node || !node.children || !node.children.length) {
 3104|       |    return node && node.children ? node.children : [];
 3105|       |  }
 3106|       |  var tag = String(node.tagName || '').toLowerCase();
 3107|       |  if (tag !== 'g') { return node.children; }
 3108|       |  if (!__mdmdview_group_has_shape(node)) { return node.children; }
 3109|       |  var has_label = false;
 3110|       |  for (var i = 0; i < node.children.length; i++) {
 3111|       |    if (__mdmdview_is_labelish(node.children[i])) { has_label = true; break; }
 3112|       |  }
 3113|       |  if (!has_label) { return node.children; }
 3114|       |  var before = [];
 3115|       |  var after = [];
 3116|       |  for (var j = 0; j < node.children.length; j++) {
 3117|       |    var child = node.children[j];
 3118|       |    if (__mdmdview_is_labelish(child)) { after.push(child); }
 3119|       |    else { before.push(child); }
 3120|       |  }
 3121|       |  if (!before.length || !after.length) { return node.children; }
 3122|       |  return before.concat(after);
 3123|       |}
 3124|       |function __mdmdview_serialize_attrs(node) {
 3125|       |  var out = '';
 3126|       |  if (!node || !node.attributes) { return out; }
 3127|       |  var has_style = false;
 3128|       |  for (var key in node.attributes) {
 3129|       |    if (!Object.prototype.hasOwnProperty.call(node.attributes, key)) { continue; }
 3130|       |    var val = node.attributes[key];
 3131|       |    if (val === null || val === undefined) { continue; }
 3132|       |    if (key === 'style') { has_style = true; }
 3133|       |    out += ' ' + key + '="' + __mdmdview_escape_attr(val) + '"';
 3134|       |  }
 3135|       |  if (!has_style && node.style) {
 3136|       |    var style_text = __mdmdview_style_text(node.style);
 3137|       |    if (style_text) {
 3138|       |      out += ' style="' + __mdmdview_escape_attr(style_text) + '"';
 3139|       |    }
 3140|       |  }
 3141|       |  return out;
 3142|       |}
 3143|       |function __mdmdview_serialize(node) {
 3144|       |  if (!node) { return ''; }
 3145|       |  if (node.tagName === '#text') {
 3146|       |    return __mdmdview_escape_text(node.textContent || '');
 3147|       |  }
 3148|       |  var tag = node.tagName || '';
 3149|       |  var attrs = __mdmdview_serialize_attrs(node);
 3150|       |  var content = '';
 3151|       |  var lower = String(tag).toLowerCase();
 3152|       |  if (node.children && node.children.length) {
 3153|       |    if (lower === 'style' || lower === 'script') {
 3154|       |      content = __mdmdview_collect_text(node);
 3155|       |    } else {
 3156|       |      var ordered = __mdmdview_order_children(node);
 3157|       |      for (var i = 0; i < ordered.length; i++) {
 3158|       |        content += __mdmdview_serialize(ordered[i]);
 3159|       |      }
 3160|       |    }
 3161|       |  } else if (node.textContent) {
 3162|       |    if (lower === 'style' || lower === 'script') {
 3163|       |      content = node.textContent;
 3164|       |    } else {
 3165|       |      content = __mdmdview_escape_text(node.textContent);
 3166|       |    }
 3167|       |  }
 3168|       |  return '<' + tag + attrs + '>' + content + '</' + tag + '>';
 3169|       |}
 3170|       |function __mdmdview_serialize_children(node) {
 3171|       |  if (!node || !node.children) { return ''; }
 3172|       |  var content = '';
 3173|       |  var ordered = __mdmdview_order_children(node);
 3174|       |  for (var i = 0; i < ordered.length; i++) {
 3175|       |    content += __mdmdview_serialize(ordered[i]);
 3176|       |  }
 3177|       |  return content;
 3178|       |}
 3179|       |function __mdmdview_make_style() {
 3180|       |  var style = { cssText: '' };
 3181|       |  style.setProperty = function(key, value) { style[key] = String(value); };
 3182|       |  style.removeProperty = function(key) { delete style[key]; };
 3183|       |  style.getPropertyValue = function(key) {
 3184|       |    return Object.prototype.hasOwnProperty.call(style, key) ? style[key] : '';
 3185|       |  };
 3186|       |  return style;
 3187|       |}
 3188|       |function __mdmdview_detach(child) {
 3189|       |  if (!child || typeof child !== 'object') { return; }
 3190|       |  var parent = child.parentNode;
 3191|       |  if (!parent || !parent.children) { return; }
 3192|       |  var idx = parent.children.indexOf(child);
 3193|       |  if (idx >= 0) {
 3194|       |    parent.children.splice(idx, 1);
 3195|       |    parent.childNodes = parent.children;
 3196|       |    parent.firstChild = parent.children[0] || null;
 3197|       |  }
 3198|       |  child.parentNode = null;
 3199|       |}
 3200|       |function __mdmdview_parse_font_px(font) {
 3201|       |  if (!font) { return 16; }
 3202|       |  var match = String(font).match(/(\d+(?:\.\d+)?)px/);
 3203|       |  if (match && match[1]) {
 3204|       |    var value = parseFloat(match[1]);
 3205|       |    if (!isNaN(value)) { return value; }
 3206|       |  }
 3207|       |  return 16;
 3208|       |}
 3209|       |function __mdmdview_parse_font_weight(font) {
 3210|       |  if (!font) { return null; }
 3211|       |  var raw = String(font).toLowerCase();
 3212|       |  if (raw.indexOf('bold') >= 0) { return 700; }
 3213|       |  return null;
 3214|       |}
 3215|       |function __mdmdview_make_canvas_context(canvas) {
 3216|       |  var ctx = {
 3217|       |    canvas: canvas,
 3218|       |    font: '',
 3219|       |    lineWidth: 1,
 3220|       |    fillStyle: '#000',
 3221|       |    strokeStyle: '#000',
 3222|       |    textAlign: 'start',
 3223|       |    textBaseline: 'alphabetic',
 3224|       |    save: function() {},
 3225|       |    restore: function() {},
 3226|       |    beginPath: function() {},
 3227|       |    closePath: function() {},
 3228|       |    moveTo: function() {},
 3229|       |    lineTo: function() {},
 3230|       |    arc: function() {},
 3231|       |    rect: function() {},
 3232|       |    fill: function() {},
 3233|       |    stroke: function() {},
 3234|       |    clip: function() {},
 3235|       |    translate: function() {},
 3236|       |    scale: function() {},
 3237|       |    rotate: function() {},
 3238|       |    clearRect: function() {},
 3239|       |    fillRect: function() {},
 3240|       |    strokeRect: function() {},
 3241|       |    drawImage: function() {},
 3242|       |    setLineDash: function() {},
 3243|       |    measureText: function(text) {
 3244|       |      var size = __mdmdview_parse_font_px(ctx.font);
 3245|       |      var weight = __mdmdview_parse_font_weight(ctx.font);
 3246|       |      var measured = __mdmdview_measure_text(text || '', size, weight);
 3247|       |      return { width: measured.width || 0 };
 3248|       |    },
 3249|       |    fillText: function() {},
 3250|       |    strokeText: function() {},
 3251|       |    createLinearGradient: function() { return { addColorStop: function() {} }; },
 3252|       |    createRadialGradient: function() { return { addColorStop: function() {} }; },
 3253|       |    createPattern: function() { return null; }
 3254|       |  };
 3255|       |  return ctx;
 3256|       |}
 3257|       |function __mdmdview_mindmap_get_size(node) {
 3258|       |  var data = node && typeof node.data === 'function' ? node.data() : null;
 3259|       |  var w = data && data.width !== undefined ? Number(data.width) : 80;
 3260|       |  var h = data && data.height !== undefined ? Number(data.height) : 40;
 3261|       |  if (!isFinite(w) || w <= 0) { w = 80; }
 3262|       |  if (!isFinite(h) || h <= 0) { h = 40; }
 3263|       |  return { w: w, h: h };
 3264|       |}
 3265|       |function __mdmdview_rect_intersection(hw, hh, ux, uy) {
 3266|       |  var ax = Math.abs(ux);
 3267|       |  var ay = Math.abs(uy);
 3268|       |  var dx = ax > 1e-6 ? hw / ax : Infinity;
 3269|       |  var dy = ay > 1e-6 ? hh / ay : Infinity;
 3270|       |  var dist = Math.min(dx, dy);
 3271|       |  if (!isFinite(dist) || dist <= 0) { dist = Math.max(hw, hh); }
 3272|       |  return dist;
 3273|       |}
 3274|       |function __mdmdview_mindmap_collect(nodes, edges) {
 3275|       |  var node_map = {};
 3276|       |  var parents = {};
 3277|       |  var children = {};
 3278|       |  var root = null;
 3279|       |  var root_id = null;
 3280|       |  for (var i = 0; i < nodes.length; i++) {
 3281|       |    var node = nodes[i];
 3282|       |    if (!node || typeof node.data !== 'function') { continue; }
 3283|       |    var data = node.data();
 3284|       |    if (!data) { continue; }
 3285|       |    var id = data.id !== undefined ? String(data.id) : null;
 3286|       |    if (id === null) { continue; }
 3287|       |    node_map[id] = node;
 3288|       |  }
 3289|       |  for (var j = 0; j < edges.length; j++) {
 3290|       |    var edge = edges[j];
 3291|       |    if (!edge || typeof edge.data !== 'function') { continue; }
 3292|       |    var ed = edge.data();
 3293|       |    if (!ed) { continue; }
 3294|       |    var source = ed.source !== undefined ? String(ed.source) : null;
 3295|       |    var target = ed.target !== undefined ? String(ed.target) : null;
 3296|       |    if (!source || !target) { continue; }
 3297|       |    if (!children[source]) { children[source] = []; }
 3298|       |    children[source].push(target);
 3299|       |    parents[target] = source;
 3300|       |  }
 3301|       |  for (var key in node_map) {
 3302|       |    if (!Object.prototype.hasOwnProperty.call(node_map, key)) { continue; }
 3303|       |    if (!Object.prototype.hasOwnProperty.call(parents, key)) {
 3304|       |      root = node_map[key];
 3305|       |      root_id = key;
 3306|       |      break;
 3307|       |    }
 3308|       |  }
 3309|       |  if (!root && nodes.length) {
 3310|       |    root = nodes[0];
 3311|       |    if (root && typeof root.data === 'function') {
 3312|       |      var rd = root.data();
 3313|       |      if (rd && rd.id !== undefined) { root_id = String(rd.id); }
 3314|       |    }
 3315|       |  }
 3316|       |  return { node_map: node_map, children: children, parents: parents, root: root, root_id: root_id };
 3317|       |}
 3318|       |function __mdmdview_mindmap_sorted_children(node_id, tree) {
 3319|       |  var kids = tree.children[node_id] || [];
 3320|       |  return kids.slice();
 3321|       |}
 3322|       |function __mdmdview_mindmap_assign_sides(tree) {
 3323|       |  var sides = {};
 3324|       |  var root_id = tree.root_id;
 3325|       |  if (!root_id) { return sides; }
 3326|       |  sides[root_id] = 0;
 3327|       |  function assign(node_id) {
 3328|       |    var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
 3329|       |    for (var i = 0; i < kids.length; i++) {
 3330|       |      var child_id = kids[i];
 3331|       |      var child_node = tree.node_map[child_id];
 3332|       |      var side = sides[node_id];
 3333|       |      if (node_id === root_id) {
 3334|       |        var data = child_node && typeof child_node.data === 'function' ? child_node.data() : null;
 3335|       |        var section = data && data.section !== undefined ? Number(data.section) : i;
 3336|       |        if (!isFinite(section)) { section = i; }
 3337|       |        side = (section % 2 === 0) ? -1 : 1;
 3338|       |      }
 3339|       |      sides[child_id] = side;
 3340|       |      assign(child_id);
 3341|       |    }
 3342|       |  }
 3343|       |  assign(root_id);
 3344|       |  return sides;
 3345|       |}
 3346|       |function __mdmdview_mindmap_subtree_height(node_id, tree, sizes, gap, heights) {
 3347|       |  var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
 3348|       |  if (!kids.length) {
 3349|       |    heights[node_id] = sizes[node_id].h;
 3350|       |    return heights[node_id];
 3351|       |  }
 3352|       |  var total = 0;
 3353|       |  for (var i = 0; i < kids.length; i++) {
 3354|       |    total += __mdmdview_mindmap_subtree_height(kids[i], tree, sizes, gap, heights);
 3355|       |  }
 3356|       |  total += gap * Math.max(0, kids.length - 1);
 3357|       |  var base = sizes[node_id].h;
 3358|       |  heights[node_id] = total > base ? total : base;
 3359|       |  return heights[node_id];
 3360|       |}
 3361|       |function __mdmdview_mindmap_layout(nodes, edges) {
 3362|       |  var tree = __mdmdview_mindmap_collect(nodes, edges);
 3363|       |  if (!tree.root || !tree.root_id) { return; }
 3364|       |  var sizes = {};
 3365|       |  for (var key in tree.node_map) {
 3366|       |    if (!Object.prototype.hasOwnProperty.call(tree.node_map, key)) { continue; }
 3367|       |    sizes[key] = __mdmdview_mindmap_get_size(tree.node_map[key]);
 3368|       |  }
 3369|       |  var sides = __mdmdview_mindmap_assign_sides(tree);
 3370|       |  var pad = 10;
 3371|       |  var root_data = tree.root && typeof tree.root.data === 'function' ? tree.root.data() : null;
 3372|       |  if (root_data && root_data.padding !== undefined) {
 3373|       |    var p = Number(root_data.padding);
 3374|       |    if (isFinite(p) && p > 0) { pad = p; }
 3375|       |  }
 3376|       |  var gap_x = Math.max(24, pad * 2.2);
 3377|       |  var positions = {};
 3378|       |  positions[tree.root_id] = { x: 0, y: 0 };
 3379|       |  var angles = {};
 3380|       |  angles[tree.root_id] = 0;
 3381|       |  var deg = Math.PI / 180;
 3382|       |  var left_start = 245 * deg;
 3383|       |  var left_end = 122 * deg;
 3384|       |  var right_start = 345 * deg;
 3385|       |  var right_end = 353 * deg;
 3386|       |  function assign_even(children, start, end) {
 3387|       |    if (!children.length) { return; }
 3388|       |    if (children.length === 1) {
 3389|       |      angles[children[0]] = (start + end) / 2;
 3390|       |      return;
 3391|       |    }
 3392|       |    var span = end - start;
 3393|       |    var step = span / (children.length - 1);
 3394|       |    for (var i = 0; i < children.length; i++) {
 3395|       |      angles[children[i]] = start + step * i;
 3396|       |    }
 3397|       |  }
 3398|       |  var root_kids = __mdmdview_mindmap_sorted_children(tree.root_id, tree);
 3399|       |  var left = [];
 3400|       |  var right = [];
 3401|       |  for (var rk = 0; rk < root_kids.length; rk++) {
 3402|       |    var kid = root_kids[rk];
 3403|       |    var side = sides[kid] || 1;
 3404|       |    if (side < 0) { left.push(kid); } else { right.push(kid); }
 3405|       |  }
 3406|       |  assign_even(left, left_start, left_end);
 3407|       |  assign_even(right, right_start, right_end);
 3408|       |  function spread_for_depth(depth, parent_angle) {
 3409|       |    var base = 38 * deg;
 3410|       |    var cos = Math.cos(parent_angle || 0);
 3411|       |    var bias = cos < 0 ? 1.4 : 1.0;
 3412|       |    var depth_factor = 1 + Math.max(0, depth - 1) * 0.2;
 3413|       |    return (base * bias) / depth_factor;
 3414|       |  }
 3415|       |  function assign_child_angles(node_id, depth) {
 3416|       |    var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
 3417|       |    if (!kids.length) { return; }
 3418|       |    var parent_angle = angles[node_id] || 0;
 3419|       |    if (kids.length === 1) {
 3420|       |      var sin = Math.sin(parent_angle);
 3421|       |      var cos = Math.cos(parent_angle);
 3422|       |      var offset = 0;
 3423|       |      if (cos < -0.1 && sin < -0.1) { offset = 20 * deg; }
 3424|       |      angles[kids[0]] = parent_angle + offset;
 3425|       |      assign_child_angles(kids[0], depth + 1);
 3426|       |      return;
 3427|       |    }
 3428|       |    var spread = spread_for_depth(depth, parent_angle);
 3429|       |    var upper = 1.3;
 3430|       |    var lower = 0.9;
 3431|       |    var start = parent_angle - spread * upper;
 3432|       |    var end = parent_angle + spread * lower;
 3433|       |    assign_even(kids, start, end);
 3434|       |    for (var i = 0; i < kids.length; i++) {
 3435|       |      assign_child_angles(kids[i], depth + 1);
 3436|       |    }
 3437|       |  }
 3438|       |  for (var a = 0; a < root_kids.length; a++) {
 3439|       |    assign_child_angles(root_kids[a], 1);
 3440|       |  }
 3441|       |  function place_node(node_id, depth) {
 3442|       |    var kids = __mdmdview_mindmap_sorted_children(node_id, tree);
 3443|       |    if (!kids.length) { return; }
 3444|       |    var parent_pos = positions[node_id];
 3445|       |    var parent_size = sizes[node_id];
 3446|       |    var parent_radius = Math.max(parent_size.w, parent_size.h) / 2;
 3447|       |    var parent_angle = angles[node_id] || 0;
 3448|       |    for (var i = 0; i < kids.length; i++) {
 3449|       |      var child = kids[i];
 3450|       |      var angle = angles[child];
 3451|       |      if (angle === undefined) { angle = angles[node_id] || 0; }
 3452|       |      var child_size = sizes[child];
 3453|       |      var child_radius = Math.max(child_size.w, child_size.h) / 2;
 3454|       |      var dist = parent_radius + child_radius + gap_x;
 3455|       |      if (depth > 0) {
 3456|       |        dist *= 1.15;
 3457|       |      }
 3458|       |      var factor = 1;
 3459|       |      if (depth === 0) {
 3460|       |        var cos = Math.cos(angle);
 3461|       |        var sin = Math.sin(angle);
 3462|       |        factor *= 1.1 * (1 + 0.2 * cos + 0.1 * sin);
 3463|       |      } else {
 3464|       |        var diff = angle - parent_angle;
 3465|       |        while (diff > Math.PI) { diff -= Math.PI * 2; }
 3466|       |        while (diff < -Math.PI) { diff += Math.PI * 2; }
 3467|       |        var norm = diff / (Math.PI / 6);
 3468|       |        if (norm > 1) { norm = 1; }
 3469|       |        if (norm < -1) { norm = -1; }
 3470|       |        factor *= 1 + 0.12 * norm;
 3471|       |        factor *= 0.98 + depth * 0.04;
 3472|       |      }
 3473|       |      if (depth > 0) {
 3474|       |        var sin = Math.sin(angle);
 3475|       |        var cos = Math.cos(angle);
 3476|       |        if (sin >= 0) {
 3477|       |          factor *= 1 + 0.15 * sin;
 3478|       |        } else if (cos > 0) {
 3479|       |          factor *= 1 + 0.05 * sin;
 3480|       |        } else {
 3481|       |          factor *= 1 + 0.25 * sin;
 3482|       |        }
 3483|       |        if (sin < -0.2 && cos < 0) {
 3484|       |          factor *= 0.9;
 3485|       |        }
 3486|       |      }
 3487|       |      if (kids.length === 1) {
 3488|       |        factor *= 0.95;
 3489|       |      }
 3490|       |      dist = dist * factor;
 3491|       |      var cx = parent_pos.x + Math.cos(angle) * dist;
 3492|       |      var cy = parent_pos.y + Math.sin(angle) * dist;
 3493|       |      positions[child] = { x: cx, y: cy };
 3494|       |      place_node(child, depth + 1);
 3495|       |    }
 3496|       |  }
 3497|       |  place_node(tree.root_id, 0);
 3498|       |  var min_x = Infinity;
 3499|       |  var min_y = Infinity;
 3500|       |  for (var id in positions) {
 3501|       |    if (!Object.prototype.hasOwnProperty.call(positions, id)) { continue; }
 3502|       |    var pos = positions[id];
 3503|       |    var size = sizes[id];
 3504|       |    var lx = pos.x - size.w / 2;
 3505|       |    var ly = pos.y - size.h / 2;
 3506|       |    if (lx < min_x) { min_x = lx; }
 3507|       |    if (ly < min_y) { min_y = ly; }
 3508|       |  }
 3509|       |  if (!isFinite(min_x)) { min_x = 0; }
 3510|       |  if (!isFinite(min_y)) { min_y = 0; }
 3511|       |  var dx = pad - min_x;
 3512|       |  var dy = pad - min_y;
 3513|       |  for (var nid in positions) {
 3514|       |    if (!Object.prototype.hasOwnProperty.call(positions, nid)) { continue; }
 3515|       |    positions[nid].x += dx;
 3516|       |    positions[nid].y += dy;
 3517|       |  }
 3518|       |  for (var n = 0; n < nodes.length; n++) {
 3519|       |    var node = nodes[n];
 3520|       |    if (!node || typeof node.data !== 'function') { continue; }
 3521|       |    var data = node.data();
 3522|       |    var id = data && data.id !== undefined ? String(data.id) : null;
 3523|       |    if (!id || !positions[id]) { continue; }
 3524|       |    node._position = { x: positions[id].x, y: positions[id].y };
 3525|       |    node.position = function() { return this._position; };
 3526|       |    data.x = positions[id].x;
 3527|       |    data.y = positions[id].y;
 3528|       |  }
 3529|       |  for (var e = 0; e < edges.length; e++) {
 3530|       |    var edge = edges[e];
 3531|       |    if (!edge || typeof edge.data !== 'function') { continue; }
 3532|       |    var ed = edge.data();
 3533|       |    var source = ed && ed.source !== undefined ? String(ed.source) : null;
 3534|       |    var target = ed && ed.target !== undefined ? String(ed.target) : null;
 3535|       |    if (!source || !target) { continue; }
 3536|       |    var s_pos = positions[source];
 3537|       |    var t_pos = positions[target];
 3538|       |    if (!s_pos || !t_pos) { continue; }
 3539|       |    var s_size = sizes[source];
 3540|       |    var t_size = sizes[target];
 3541|       |    var dx = t_pos.x - s_pos.x;
 3542|       |    var dy = t_pos.y - s_pos.y;
 3543|       |    var len = Math.sqrt(dx * dx + dy * dy);
 3544|       |    if (!isFinite(len) || len <= 0.001) { len = 1; }
 3545|       |    var ux = dx / len;
 3546|       |    var uy = dy / len;
 3547|       |    var s_radius = __mdmdview_rect_intersection(s_size.w / 2, s_size.h / 2, ux, uy);
 3548|       |    var t_radius = __mdmdview_rect_intersection(t_size.w / 2, t_size.h / 2, ux, uy);
 3549|       |    var overlap = -2;
 3550|       |    s_radius += overlap;
 3551|       |    t_radius += overlap;
 3552|       |    if (s_radius < 0) { s_radius = 0; }
 3553|       |    if (t_radius < 0) { t_radius = 0; }
 3554|       |    var max_total = len * 0.95;
 3555|       |    if (s_radius + t_radius > max_total) {
 3556|       |      var scale = max_total / (s_radius + t_radius);
 3557|       |      s_radius *= scale;
 3558|       |      t_radius *= scale;
 3559|       |    }
 3560|       |    var sx = s_pos.x + ux * s_radius;
 3561|       |    var sy = s_pos.y + uy * s_radius;
 3562|       |    var ex = t_pos.x - ux * t_radius;
 3563|       |    var ey = t_pos.y - uy * t_radius;
 3564|       |    var mx = (sx + ex) / 2;
 3565|       |    var my = (sy + ey) / 2;
 3566|       |    edge[0] = edge[0] || {};
 3567|       |    edge[0]._private = {
 3568|       |      bodyBounds: true,
 3569|       |      rscratch: {
 3570|       |        startX: sx,
 3571|       |        startY: sy,
 3572|       |        midX: mx,
 3573|       |        midY: my,
 3574|       |        endX: ex,
 3575|       |        endY: ey
 3576|       |      }
 3577|       |    };
 3578|       |  }
 3579|       |}
 3580|       |function __mdmdview_cytoscape_stub(options) {
 3581|       |  var nodes = [];
 3582|       |  var edges = [];
 3583|       |  function add(entry) {
 3584|       |    if (!entry || !entry.group) { return; }
 3585|       |    if (entry.group === 'nodes') {
 3586|       |      var node = {
 3587|       |        _data: entry.data || {},
 3588|       |        _position: entry.position || { x: 0, y: 0 },
 3589|       |        data: function() { return this._data; },
 3590|       |        position: function() { return this._position; }
 3591|       |      };
 3592|       |      nodes.push(node);
 3593|       |    } else if (entry.group === 'edges') {
 3594|       |      var edge = {
 3595|       |        _data: entry.data || {},
 3596|       |        data: function() { return this._data; }
 3597|       |      };
 3598|       |      edge[0] = { _private: { bodyBounds: false, rscratch: {} } };
 3599|       |      edges.push(edge);
 3600|       |    }
 3601|       |  }
 3602|       |  return {
 3603|       |    add: add,
 3604|       |    nodes: function() { return nodes; },
 3605|       |    edges: function() { return edges; },
 3606|       |    layout: function() {
 3607|       |      return { run: function() { __mdmdview_mindmap_layout(nodes, edges); return this; } };
 3608|       |    }
 3609|       |  };
 3610|       |}
 3611|       |function __mdmdview_make_element(tag, ownerDoc, ns) {
 3612|       |  var doc = ownerDoc;
 3613|       |  if (!doc && typeof document !== 'undefined' && document) { doc = document; }
 3614|       |  var parent = null;
 3615|       |  var parent_set = false;
 3616|       |  var node = {
 3617|       |    tagName: tag,
 3618|       |    namespaceURI: ns || null,
 3619|       |    firstChild: null,
 3620|       |    style: __mdmdview_make_style(),
 3621|       |    children: [],
 3622|       |    childNodes: [],
 3623|       |    attributes: {},
 3624|       |    textContent: '',
 3625|       |    setAttribute: function(key, value) {
 3626|       |      var v = String(value);
 3627|       |      this.attributes[key] = v;
 3628|       |      if (key === 'id') { this.id = v; }
 3629|       |      __mdmdview_bump_bbox_rev();
 3630|       |    },
 3631|       |    setAttributeNS: function(ns, key, value) {
 3632|       |      var v = String(value);
 3633|       |      this.attributes[key] = v;
 3634|       |      if (key === 'id') { this.id = v; }
 3635|       |      __mdmdview_bump_bbox_rev();
 3636|       |    },
 3637|       |    attr: function(key, value) {
 3638|       |      if (value === undefined) { return this.getAttribute(key); }
 3639|       |      if (value === null) { this.removeAttribute(key); return this; }
 3640|       |      this.setAttribute(key, value);
 3641|       |      return this;
 3642|       |    },
 3643|       |    getAttribute: function(key) {
 3644|       |      return Object.prototype.hasOwnProperty.call(this.attributes, key)
 3645|       |        ? this.attributes[key]
 3646|       |        : null;
 3647|       |    },
 3648|       |    getAttributeNS: function(ns, key) { return this.getAttribute(key); },
 3649|       |    text: function(value) {
 3650|       |      if (value === undefined) { return this.textContent || ''; }
 3651|       |      this.textContent = value === null ? '' : String(value);
 3652|       |      __mdmdview_bump_bbox_rev();
 3653|       |      return this;
 3654|       |    },
 3655|       |    append: function(tag) {
 3656|       |      var child = __mdmdview_make_element(tag, this.ownerDocument, this.namespaceURI);
 3657|       |      this.appendChild(child);
 3658|       |      return child;
 3659|       |    },
 3660|       |    removeAttribute: function(key) { delete this.attributes[key]; __mdmdview_bump_bbox_rev(); },
 3661|       |    removeAttributeNS: function(ns, key) { delete this.attributes[key]; __mdmdview_bump_bbox_rev(); },
 3662|       |    appendChild: function(child) {
 3663|       |      __mdmdview_detach(child);
 3664|       |      this.children.push(child);
 3665|       |      this.childNodes = this.children;
 3666|       |      this.firstChild = this.children[0] || null;
 3667|       |      if (child && typeof child === 'object') {
 3668|       |        child.parentNode = this;
 3669|       |        if (!child.ownerDocument && this.ownerDocument) { child.ownerDocument = this.ownerDocument; }
 3670|       |      }
 3671|       |      __mdmdview_bump_bbox_rev();
 3672|       |      return child;
 3673|       |    },
 3674|       |    removeChild: function(child) {
 3675|       |      var idx = this.children.indexOf(child);
 3676|       |      if (idx >= 0) {
 3677|       |        this.children.splice(idx, 1);
 3678|       |        this.childNodes = this.children;
 3679|       |      }
 3680|       |      if (child && typeof child === 'object') { child.parentNode = null; }
 3681|       |      this.firstChild = this.children[0] || null;
 3682|       |      __mdmdview_bump_bbox_rev();
 3683|       |      return child;
 3684|       |    },
 3685|       |    hasChildNodes: function() { return this.children.length > 0; },
 3686|       |    insertBefore: function(child, before) {
 3687|       |      __mdmdview_detach(child);
 3688|       |      var idx = this.children.indexOf(before);
 3689|       |      if (idx < 0) { this.children.push(child); }
 3690|       |      else { this.children.splice(idx, 0, child); }
 3691|       |      this.childNodes = this.children;
 3692|       |      this.firstChild = this.children[0] || null;
 3693|       |      if (child && typeof child === 'object') {
 3694|       |        child.parentNode = this;
 3695|       |        if (!child.ownerDocument && this.ownerDocument) { child.ownerDocument = this.ownerDocument; }
 3696|       |      }
 3697|       |      __mdmdview_bump_bbox_rev();
 3698|       |      return child;
 3699|       |    },
 3700|       |    remove: function() { return null; },
 3701|       |    querySelector: function(sel) { return __mdmdview_query_selector(this, sel); },
 3702|       |    querySelectorAll: function(sel) { return __mdmdview_query_selector_all(this, sel); },
 3703|       |    cloneNode: function(deep) {
 3704|       |      var copy = __mdmdview_make_element(this.tagName, this.ownerDocument, this.namespaceURI);
 3705|       |      copy.textContent = this.textContent;
 3706|       |      copy.innerHTML = this.innerHTML;
 3707|       |      for (var key in this.attributes) {
 3708|       |        if (!Object.prototype.hasOwnProperty.call(this.attributes, key)) { continue; }
 3709|       |        copy.attributes[key] = this.attributes[key];
 3710|       |      }
 3711|       |      if (this.style) {
 3712|       |        for (var prop in this.style) {
 3713|       |          if (!Object.prototype.hasOwnProperty.call(this.style, prop)) { continue; }
 3714|       |          if (typeof this.style[prop] === 'function') { continue; }
 3715|       |          copy.style[prop] = this.style[prop];
 3716|       |        }
 3717|       |      }
 3718|       |      if (deep && this.children && this.children.length) {
 3719|       |        for (var i = 0; i < this.children.length; i++) {
 3720|       |          copy.appendChild(this.children[i].cloneNode(true));
 3721|       |        }
 3722|       |      }
 3723|       |      return copy;
 3724|       |    },
 3725|       |    getBBox: function() {
 3726|       |      var box = __mdmdview_bbox(this);
 3727|       |      if (box) {
 3728|       |        box.w = box.width;
 3729|       |        box.h = box.height;
 3730|       |      }
 3731|       |      return box;
 3732|       |    },
 3733|       |    getBoundingClientRect: function() {
 3734|       |      var box = __mdmdview_bbox(this);
 3735|       |      if (box) {
 3736|       |        box.left = box.x;
 3737|       |        box.top = box.y;
 3738|       |        box.right = box.x + box.width;
 3739|       |        box.bottom = box.y + box.height;
 3740|       |        box.w = box.width;
 3741|       |        box.h = box.height;
 3742|       |      }
 3743|       |      return box;
 3744|       |    },
 3745|       |    getComputedTextLength: function() { return __mdmdview_bbox(this).width; },
 3746|       |    getTotalLength: function() { return __mdmdview_path_total_length(this); },
 3747|       |    getPointAtLength: function(len) { return __mdmdview_path_point_at_length(this, len); },
 3748|       |    addEventListener: function() {},
 3749|       |    removeEventListener: function() {},
 3750|       |    dispatchEvent: function() { return false; }
 3751|       |  };
 3752|       |  var lower = String(tag || '').toLowerCase();
 3753|       |  if (lower === 'canvas') {
 3754|       |    node.width = 300;
 3755|       |    node.height = 150;
 3756|       |    node.getContext = function(kind) {
 3757|       |      if (kind && String(kind).toLowerCase() !== '2d') { return null; }
 3758|       |      if (!node.__mdmdview_ctx) {
 3759|       |        node.__mdmdview_ctx = __mdmdview_make_canvas_context(node);
 3760|       |      }
 3761|       |      return node.__mdmdview_ctx;
 3762|       |    };
 3763|       |  }
 3764|       |  var classList = {
 3765|       |    add: function() {
 3766|       |      var list = __mdmdview_get_class_list(node);
 3767|       |      for (var i = 0; i < arguments.length; i++) {
 3768|       |        var cls = String(arguments[i]);
 3769|       |        if (cls && list.indexOf(cls) < 0) { list.push(cls); }
 3770|       |      }
 3771|       |      __mdmdview_set_class_list(node, list);
 3772|       |    },
 3773|       |    remove: function() {
 3774|       |      var list = __mdmdview_get_class_list(node);
 3775|       |      var next = [];
 3776|       |      for (var i = 0; i < list.length; i++) {
 3777|       |        var keep = true;
 3778|       |        for (var j = 0; j < arguments.length; j++) {
 3779|       |          if (list[i] === String(arguments[j])) { keep = false; break; }
 3780|       |        }
 3781|       |        if (keep) { next.push(list[i]); }
 3782|       |      }
 3783|       |      __mdmdview_set_class_list(node, next);
 3784|       |    },
 3785|       |    contains: function(cls) { return __mdmdview_has_class(node, cls); },
 3786|       |    toggle: function(cls, force) {
 3787|       |      var list = __mdmdview_get_class_list(node);
 3788|       |      var name = String(cls);
 3789|       |      var has = list.indexOf(name) >= 0;
 3790|       |      var should_add = force === undefined ? !has : !!force;
 3791|       |      if (should_add && !has) { list.push(name); }
 3792|       |      if (!should_add && has) { list = list.filter(function(item) { return item !== name; }); }
 3793|       |      __mdmdview_set_class_list(node, list);
 3794|       |      return should_add;
 3795|       |    }
 3796|       |  };
 3797|       |  node.classList = classList;
 3798|       |  Object.defineProperty(node, 'innerHTML', {
 3799|       |    get: function() { return __mdmdview_serialize_children(this); },
 3800|       |    set: function(value) {
 3801|       |      if (this.children && this.children.length) {
 3802|       |        for (var i = 0; i < this.children.length; i++) {
 3803|       |          var child = this.children[i];
 3804|       |          if (child && typeof child === 'object') { child.parentNode = null; }
 3805|       |        }
 3806|       |      }
 3807|       |      this.children = [];
 3808|       |      this.childNodes = this.children;
 3809|       |      this.firstChild = null;
 3810|       |      this.textContent = value ? String(value) : '';
 3811|       |      __mdmdview_bump_bbox_rev();
 3812|       |    },
 3813|       |    configurable: true
 3814|       |  });
 3815|       |  Object.defineProperty(node, 'className', {
 3816|       |    get: function() {
 3817|       |      var cls = this.getAttribute('class');
 3818|       |      return cls ? String(cls) : '';
 3819|       |    },
 3820|       |    set: function(value) { this.setAttribute('class', value); },
 3821|       |    configurable: true
 3822|       |  });
 3823|       |  Object.defineProperty(node, 'outerHTML', {
 3824|       |    get: function() { return __mdmdview_serialize(this); },
 3825|       |    configurable: true
 3826|       |  });
 3827|       |  Object.defineProperty(node, 'ownerDocument', {
 3828|       |    get: function() {
 3829|       |      if (doc) { return doc; }
 3830|       |      if (typeof document !== 'undefined') { return document || null; }
 3831|       |      return null;
 3832|       |    },
 3833|       |    set: function(value) { doc = value; },
 3834|       |    configurable: true
 3835|       |  });
 3836|       |  Object.defineProperty(node, 'parentNode', {
 3837|       |    get: function() {
 3838|       |      if (parent_set) { return parent || null; }
 3839|       |      if (typeof document !== 'undefined' && document && document.body) { return document.body; }
 3840|       |      return null;
 3841|       |    },
 3842|       |    set: function(value) { parent = value; parent_set = true; },
 3843|       |    configurable: true
 3844|       |  });
 3845|       |  Object.defineProperty(node, 'nextSibling', {
 3846|       |    get: function() {
 3847|       |      var p = this.parentNode;
 3848|       |      if (!p || !p.children) { return null; }
 3849|       |      var idx = p.children.indexOf(this);
 3850|       |      return idx >= 0 && idx + 1 < p.children.length ? p.children[idx + 1] : null;
 3851|       |    },
 3852|       |    configurable: true
 3853|       |  });
 3854|       |  Object.defineProperty(node, 'previousSibling', {
 3855|       |    get: function() {
 3856|       |      var p = this.parentNode;
 3857|       |      if (!p || !p.children) { return null; }
 3858|       |      var idx = p.children.indexOf(this);
 3859|       |      return idx > 0 ? p.children[idx - 1] : null;
 3860|       |    },
 3861|       |    configurable: true
 3862|       |  });
 3863|       |  Object.defineProperty(node, 'firstElementChild', {
 3864|       |    get: function() {
 3865|       |      return this.children && this.children.length ? this.children[0] : null;
 3866|       |    },
 3867|       |    configurable: true
 3868|       |  });
 3869|       |  return node;
 3870|       |}
 3871|       |function __mdmdview_find_by_id(node, id) {
 3872|       |  if (!node || !id) { return null; }
 3873|       |  if (node.id === id) { return node; }
 3874|       |  if (node.attributes && node.attributes.id === id) { return node; }
 3875|       |  if (!node.children) { return null; }
 3876|       |  for (var i = 0; i < node.children.length; i++) {
 3877|       |    var hit = __mdmdview_find_by_id(node.children[i], id);
 3878|       |    if (hit) { return hit; }
 3879|       |  }
 3880|       |  return null;
 3881|       |}
 3882|       |function __mdmdview_find_by_tag(node, tag, matches) {
 3883|       |  if (!node || !tag) { return; }
 3884|       |  var name = (node.tagName || '').toLowerCase();
 3885|       |  if (name === tag) { matches.push(node); }
 3886|       |  if (!node.children) { return; }
 3887|       |  for (var i = 0; i < node.children.length; i++) {
 3888|       |    __mdmdview_find_by_tag(node.children[i], tag, matches);
 3889|       |  }
 3890|       |}
 3891|       |function __mdmdview_get_class_list(node) {
 3892|       |  if (!node) { return []; }
 3893|       |  var raw = null;
 3894|       |  if (node.getAttribute) { raw = node.getAttribute('class'); }
 3895|       |  if (raw === null || raw === undefined) { raw = node.attributes && node.attributes['class']; }
 3896|       |  if (!raw) { return []; }
 3897|       |  return String(raw).split(/\s+/).filter(function(item) { return item.length > 0; });
 3898|       |}
 3899|       |function __mdmdview_set_class_list(node, list) {
 3900|       |  if (!node) { return; }
 3901|       |  var value = (list || []).filter(function(item) { return item.length > 0; }).join(' ');
 3902|       |  if (node.setAttribute) { node.setAttribute('class', value); }
 3903|       |  else if (node.attributes) { node.attributes['class'] = value; }
 3904|       |}
 3905|       |function __mdmdview_has_class(node, className) {
 3906|       |  if (!node || !className) { return false; }
 3907|       |  var cls = node.attributes && node.attributes['class'];
 3908|       |  if (!cls) { return false; }
 3909|       |  var parts = String(cls).split(/\s+/);
 3910|       |  for (var i = 0; i < parts.length; i++) {
 3911|       |    if (parts[i] === className) { return true; }
 3912|       |  }
 3913|       |  return false;
 3914|       |}
 3915|       |function __mdmdview_find_by_class(node, className, matches) {
 3916|       |  if (!node || !className) { return; }
 3917|       |  if (__mdmdview_has_class(node, className)) { matches.push(node); }
 3918|       |  if (!node.children) { return; }
 3919|       |  for (var i = 0; i < node.children.length; i++) {
 3920|       |    __mdmdview_find_by_class(node.children[i], className, matches);
 3921|       |  }
 3922|       |}
 3923|       |function __mdmdview_get_attr(node, name) {
 3924|       |  if (!node || !name) { return null; }
 3925|       |  if (node.getAttribute) {
 3926|       |    var val = node.getAttribute(name);
 3927|       |    if (val !== null && val !== undefined) { return String(val); }
 3928|       |  }
 3929|       |  if (node.attributes && Object.prototype.hasOwnProperty.call(node.attributes, name)) {
 3930|       |    return String(node.attributes[name]);
 3931|       |  }
 3932|       |  return null;
 3933|       |}
 3934|       |function __mdmdview_parse_attr_selector(raw) {
 3935|       |  var match = raw.match(/^\[\s*([^\]=\s]+)\s*=\s*["']?([^\"'\]]+)["']?\s*\]$/);
 3936|       |  if (!match) { return null; }
 3937|       |  return { name: match[1], value: match[2] };
 3938|       |}
 3939|       |function __mdmdview_find_by_attr(node, name, value, matches) {
 3940|       |  if (!node || !name) { return null; }
 3941|       |  var attr = __mdmdview_get_attr(node, name);
 3942|       |  if (attr !== null && String(attr) === String(value)) {
 3943|       |    if (matches) { matches.push(node); }
 3944|       |    else { return node; }
 3945|       |  }
 3946|       |  if (!node.children) { return matches ? null : null; }
 3947|       |  for (var i = 0; i < node.children.length; i++) {
 3948|       |    var hit = __mdmdview_find_by_attr(node.children[i], name, value, matches);
 3949|       |    if (!matches && hit) { return hit; }
 3950|       |  }
 3951|       |  return matches ? null : null;
 3952|       |}
 3953|       |function __mdmdview_matches_simple(node, raw) {
 3954|       |  if (!node || !raw) { return false; }
 3955|       |  var attr = __mdmdview_parse_attr_selector(raw);
 3956|       |  if (attr) {
 3957|       |    var attrVal = __mdmdview_get_attr(node, attr.name);
 3958|       |    return attrVal !== null && String(attrVal) === String(attr.value);
 3959|       |  }
 3960|       |  if (raw[0] === '#') {
 3961|       |    var id = raw.slice(1);
 3962|       |    return node.id === id || __mdmdview_get_attr(node, 'id') === id;
 3963|       |  }
 3964|       |  if (raw[0] === '.') {
 3965|       |    return __mdmdview_has_class(node, raw.slice(1));
 3966|       |  }
 3967|       |  var hashIdx = raw.indexOf('#');
 3968|       |  if (hashIdx > 0) {
 3969|       |    var tagName = raw.slice(0, hashIdx).toLowerCase();
 3970|       |    var tagId = raw.slice(hashIdx + 1);
 3971|       |    return (node.tagName || '').toLowerCase() === tagName
 3972|       |      && (node.id === tagId || __mdmdview_get_attr(node, 'id') === tagId);
 3973|       |  }
 3974|       |  var dotIdx = raw.indexOf('.');
 3975|       |  if (dotIdx > 0) {
 3976|       |    var tag = raw.slice(0, dotIdx).toLowerCase();
 3977|       |    var cls = raw.slice(dotIdx + 1);
 3978|       |    return (node.tagName || '').toLowerCase() === tag && __mdmdview_has_class(node, cls);
 3979|       |  }
 3980|       |  return (node.tagName || '').toLowerCase() === raw.toLowerCase();
 3981|       |}
 3982|       |function __mdmdview_matches_selector(node, sel) {
 3983|       |  if (!node || !sel) { return false; }
 3984|       |  var raw = String(sel).trim();
 3985|       |  if (!raw) { return false; }
 3986|       |  var parts = raw.split(/\s+/).filter(function(part) { return part.length > 0; });
 3987|       |  if (parts.length <= 1) { return __mdmdview_matches_simple(node, raw); }
 3988|       |  var idx = parts.length - 1;
 3989|       |  var current = node;
 3990|       |  while (current && idx >= 0) {
 3991|       |    if (__mdmdview_matches_simple(current, parts[idx])) {
 3992|       |      idx -= 1;
 3993|       |    }
 3994|       |    current = current.parentNode;
 3995|       |  }
 3996|       |  return idx < 0;
 3997|       |}
 3998|       |function __mdmdview_query_selector(node, sel) {
 3999|       |  if (!sel) { return null; }
 4000|       |  var raw = String(sel).trim();
 4001|       |  if (!raw) { return null; }
 4002|       |  if (node && !node.tagName && node._parent) { node = node._parent; }
 4003|       |  if ((!node || !node.children) && document && document.body) { node = document.body; }
 4004|       |  var chain = raw.split(/\s+/).filter(function(part) { return part.length > 0; });
 4005|       |  if (chain.length > 1) {
 4006|       |    var current = node;
 4007|       |    for (var c = 0; c < chain.length; c++) {
 4008|       |      current = __mdmdview_query_selector(current, chain[c]);
 4009|       |      if (!current) { return null; }
 4010|       |    }
 4011|       |    return current;
 4012|       |  }
 4013|       |  var result = null;
 4014|       |  var attrSel = __mdmdview_parse_attr_selector(raw);
 4015|       |  if (attrSel) {
 4016|       |    result = __mdmdview_find_by_attr(node, attrSel.name, attrSel.value);
 4017|       |  } else if (raw[0] === '#') {
 4018|       |    result = __mdmdview_find_by_id(node, raw.slice(1));
 4019|       |  } else if (raw[0] === '.') {
 4020|       |    var className = raw.slice(1);
 4021|       |    var classMatches = [];
 4022|       |    __mdmdview_find_by_class(node, className, classMatches);
 4023|       |    result = classMatches.length ? classMatches[0] : null;
 4024|       |  } else if (raw.indexOf('#') > 0) {
 4025|       |    var hashParts = raw.split('#');
 4026|       |    var hashTag = hashParts[0].toLowerCase();
 4027|       |    var hashId = hashParts[1];
 4028|       |    var hashMatches = [];
 4029|       |    __mdmdview_find_by_tag(node, hashTag, hashMatches);
 4030|       |    for (var h = 0; h < hashMatches.length; h++) {
 4031|       |      if (hashMatches[h].id === hashId || __mdmdview_get_attr(hashMatches[h], 'id') === hashId) {
 4032|       |        result = hashMatches[h];
 4033|       |        break;
 4034|       |      }
 4035|       |    }
 4036|       |  } else if (raw.indexOf('.') > 0) {
 4037|       |    var pieces = raw.split('.');
 4038|       |    var tagName = pieces[0].toLowerCase();
 4039|       |    var clsName = pieces[1];
 4040|       |    var tagMatches = [];
 4041|       |    __mdmdview_find_by_tag(node, tagName, tagMatches);
 4042|       |    for (var t = 0; t < tagMatches.length; t++) {
 4043|       |      if (__mdmdview_has_class(tagMatches[t], clsName)) {
 4044|       |        result = tagMatches[t];
 4045|       |        break;
 4046|       |      }
 4047|       |    }
 4048|       |  } else {
 4049|       |    var tag = raw.toLowerCase();
 4050|       |    var matches = [];
 4051|       |    __mdmdview_find_by_tag(node, tag, matches);
 4052|       |    result = matches.length ? matches[0] : null;
 4053|       |  }
 4054|       |  return result;
 4055|       |}
 4056|       |function __mdmdview_query_selector_all(node, sel) {
 4057|       |  if (!sel) { return []; }
 4058|       |  var raw = String(sel).trim();
 4059|       |  if (!raw) { return []; }
 4060|       |  if (node && !node.tagName && node._parent) { node = node._parent; }
 4061|       |  if ((!node || !node.children) && document && document.body) { node = document.body; }
 4062|       |  var chain = raw.split(/\s+/).filter(function(part) { return part.length > 0; });
 4063|       |  if (chain.length > 1) {
 4064|       |    var current = node;
 4065|       |    for (var c = 0; c < chain.length; c++) {
 4066|       |      current = __mdmdview_query_selector(current, chain[c]);
 4067|       |      if (!current) { return []; }
 4068|       |    }
 4069|       |    return [current];
 4070|       |  }
 4071|       |  var attrSel = __mdmdview_parse_attr_selector(raw);
 4072|       |  if (attrSel) {
 4073|       |    var attrMatches = [];
 4074|       |    __mdmdview_find_by_attr(node, attrSel.name, attrSel.value, attrMatches);
 4075|       |    return attrMatches;
 4076|       |  }
 4077|       |  if (raw[0] === '#') {
 4078|       |    var hit = __mdmdview_find_by_id(node, raw.slice(1));
 4079|       |    return hit ? [hit] : [];
 4080|       |  }
 4081|       |  if (raw[0] === '.') {
 4082|       |    var className = raw.slice(1);
 4083|       |    var classMatches = [];
 4084|       |    __mdmdview_find_by_class(node, className, classMatches);
 4085|       |    return classMatches;
 4086|       |  }
 4087|       |  if (raw.indexOf('#') > 0) {
 4088|       |    var hashParts = raw.split('#');
 4089|       |    var hashTag = hashParts[0].toLowerCase();
 4090|       |    var hashId = hashParts[1];
 4091|       |    var hashMatches = [];
 4092|       |    __mdmdview_find_by_tag(node, hashTag, hashMatches);
 4093|       |    var hashHits = [];
 4094|       |    for (var h = 0; h < hashMatches.length; h++) {
 4095|       |      if (hashMatches[h].id === hashId || __mdmdview_get_attr(hashMatches[h], 'id') === hashId) {
 4096|       |        hashHits.push(hashMatches[h]);
 4097|       |      }
 4098|       |    }
 4099|       |    return hashHits;
 4100|       |  }
 4101|       |  if (raw.indexOf('.') > 0) {
 4102|       |    var pieces = raw.split('.');
 4103|       |    var tagName = pieces[0].toLowerCase();
 4104|       |    var clsName = pieces[1];
 4105|       |    var tagMatches = [];
 4106|       |    __mdmdview_find_by_tag(node, tagName, tagMatches);
 4107|       |    var hits = [];
 4108|       |    for (var t = 0; t < tagMatches.length; t++) {
 4109|       |      if (__mdmdview_has_class(tagMatches[t], clsName)) {
 4110|       |        hits.push(tagMatches[t]);
 4111|       |      }
 4112|       |    }
 4113|       |    return hits;
 4114|       |  }
 4115|       |  var tag = raw.toLowerCase();
 4116|       |  var matches = [];
 4117|       |  __mdmdview_find_by_tag(node, tag, matches);
 4118|       |  return matches;
 4119|       |}
 4120|       |var document = {
 4121|       |  body: __mdmdview_make_element('body'),
 4122|       |  head: __mdmdview_make_element('head'),
 4123|       |  children: [],
 4124|       |  childNodes: [],
 4125|       |  createElement: function(tag) { return __mdmdview_make_element(tag, document); },
 4126|       |  createElementNS: function(ns, tag) { return __mdmdview_make_element(tag, document, ns); },
 4127|       |  createTextNode: function(text) {
 4128|       |    var node = __mdmdview_make_element('#text', document);
 4129|       |    node.textContent = text || '';
 4130|       |    return node;
 4131|       |  },
 4132|       |  getElementById: function(id) { return __mdmdview_find_by_id(document, id); },
 4133|       |  getElementsByTagName: function(tag) {
 4134|       |    var raw = String(tag || '').trim().toLowerCase();
 4135|       |    if (!raw) { return []; }
 4136|       |    if (raw === 'head') { return document.head ? [document.head] : []; }
 4137|       |    if (raw === 'body') { return document.body ? [document.body] : []; }
 4138|       |    var matches = [];
 4139|       |    __mdmdview_find_by_tag(document, raw, matches);
 4140|       |    return matches;
 4141|       |  },
 4142|       |  querySelector: function(sel) {
 4143|       |    var raw = String(sel || '').trim().toLowerCase();
 4144|       |    var result = raw === 'head'
 4145|       |      ? document.head
 4146|       |      : (raw === 'body' ? document.body : __mdmdview_query_selector(document, sel));
 4147|       |    return result || (document && document.body ? document.body : null);
 4148|       |  },
 4149|       |  querySelectorAll: function(sel) {
 4150|       |    var raw = String(sel || '').trim().toLowerCase();
 4151|       |    var result = raw === 'head'
 4152|       |      ? [document.head]
 4153|       |      : (raw === 'body' ? [document.body] : __mdmdview_query_selector_all(document, sel));
 4154|       |    if (result && result.length) { return result; }
 4155|       |    return document && document.body ? [document.body] : [];
 4156|       |  },
 4157|       |  appendChild: function(child) {
 4158|       |    return document.documentElement
 4159|       |      ? document.documentElement.appendChild(child)
 4160|       |      : document.body.appendChild(child);
 4161|       |  },
 4162|       |  insertBefore: function(child, before) {
 4163|       |    return document.documentElement
 4164|       |      ? document.documentElement.insertBefore(child, before)
 4165|       |      : document.body.insertBefore(child, before);
 4166|       |  },
 4167|       |  removeChild: function(child) {
 4168|       |    return document.documentElement
 4169|       |      ? document.documentElement.removeChild(child)
 4170|       |      : document.body.removeChild(child);
 4171|       |  },
 4172|       |  hasChildNodes: function() {
 4173|       |    return document.documentElement
 4174|       |      ? document.documentElement.hasChildNodes()
 4175|       |      : document.body.hasChildNodes();
 4176|       |  },
 4177|       |  addEventListener: function() {}
 4178|       |};
 4179|       |window.document = document;
 4180|       |document.body.ownerDocument = document;
 4181|       |document.head.ownerDocument = document;
 4182|       |document.documentElement = __mdmdview_make_element('html');
 4183|       |document.documentElement.ownerDocument = document;
 4184|       |document.documentElement.appendChild(document.head);
 4185|       |document.documentElement.appendChild(document.body);
 4186|       |document.documentElement.parentNode = document;
 4187|       |document.children = [document.documentElement];
 4188|       |document.childNodes = document.children;
 4189|       |document.defaultView = window;
 4190|       |document.ownerDocument = document;
 4191|       |document.body.namespaceURI = 'http://www.w3.org/1999/xhtml';
 4192|       |document.head.namespaceURI = 'http://www.w3.org/1999/xhtml';
 4193|       |document.documentElement.namespaceURI = 'http://www.w3.org/1999/xhtml';
 4194|       |document.namespaceURI = document.body.namespaceURI;
 4195|       |window.ownerDocument = document;
 4196|       |window.namespaceURI = document.body.namespaceURI;
 4197|       |function __mdmdview_clear_node(node) {
 4198|       |  if (!node) { return; }
 4199|       |  if (node.children && node.children.length) {
 4200|       |    for (var i = 0; i < node.children.length; i++) {
 4201|       |      var child = node.children[i];
 4202|       |      if (child && typeof child === 'object') { child.parentNode = null; }
 4203|       |    }
 4204|       |  }
 4205|       |  node.children = [];
 4206|       |  node.childNodes = node.children;
 4207|       |  node.firstChild = null;
 4208|       |  node.textContent = '';
 4209|       |}
 4210|       |function __mdmdview_reset_dom() {
 4211|       |  __mdmdview_clear_node(document.head);
 4212|       |  __mdmdview_clear_node(document.body);
 4213|       |  document.documentElement.children = [document.head, document.body];
 4214|       |  document.documentElement.childNodes = document.documentElement.children;
 4215|       |  document.documentElement.firstChild = document.head || null;
 4216|       |  document.head.parentNode = document.documentElement;
 4217|       |  document.body.parentNode = document.documentElement;
 4218|       |  __mdmdview_text_cache = {};
 4219|       |  window.__mdmdview_timer_queue = [];
 4220|       |  window.__mdmdview_timer_map = {};
 4221|       |  window.__mdmdview_now_base = 0;
 4222|       |  window.__mdmdview_bbox_rev = 0;
 4223|       |}
 4224|       |if (!Object.hasOwn) {
 4225|       |  Object.hasOwn = function(obj, prop) {
 4226|       |    return Object.prototype.hasOwnProperty.call(obj, prop);
 4227|       |  };
 4228|       |}
 4229|       |if (!Object.prototype.hasOwnProperty('ownerDocument')) {
 4230|       |  Object.defineProperty(Object.prototype, 'ownerDocument', {
 4231|       |    get: function() { return document || null; },
 4232|       |    set: function(value) {
 4233|       |      Object.defineProperty(this, 'ownerDocument', { value: value, writable: true, configurable: true });
 4234|       |    },
 4235|       |    configurable: true
 4236|       |  });
 4237|       |}
 4238|       |if (!Object.prototype.hasOwnProperty('parentNode')) {
 4239|       |  Object.defineProperty(Object.prototype, 'parentNode', {
 4240|       |    get: function() {
 4241|       |      if (this && this.__mdmdview_parent_set) {
 4242|       |        return this.__mdmdview_parent || null;
 4243|       |      }
 4244|       |      if (typeof document !== 'undefined' && document && document.body) { return document.body; }
 4245|       |      return null;
 4246|       |    },
 4247|       |    set: function(value) {
 4248|       |      this.__mdmdview_parent = value;
 4249|       |      this.__mdmdview_parent_set = true;
 4250|       |    },
 4251|       |    configurable: true
 4252|       |  });
 4253|       |}
 4254|       |if (!Object.prototype.hasOwnProperty('querySelector')) {
 4255|       |  Object.defineProperty(Object.prototype, 'querySelector', {
 4256|       |    value: function(sel) { return __mdmdview_query_selector(this, sel); },
 4257|       |    writable: true,
 4258|       |    configurable: true
 4259|       |  });
 4260|       |}
 4261|       |if (!Object.prototype.hasOwnProperty('querySelectorAll')) {
 4262|       |  Object.defineProperty(Object.prototype, 'querySelectorAll', {
 4263|       |    value: function(sel) { return __mdmdview_query_selector_all(this, sel); },
 4264|       |    writable: true,
 4265|       |    configurable: true
 4266|       |  });
 4267|       |}
 4268|       |if (!Object.prototype.hasOwnProperty('appendChild')) {
 4269|       |  Object.defineProperty(Object.prototype, 'appendChild', {
 4270|       |    value: function(child) {
 4271|       |      if (this && !this.tagName && document && document.body && this !== document.body) {
 4272|       |        return document.body.appendChild(child);
 4273|       |      }
 4274|       |      __mdmdview_detach(child);
 4275|       |      if (!this.children) { this.children = []; }
 4276|       |      this.children.push(child);
 4277|       |      this.childNodes = this.children;
 4278|       |      this.firstChild = this.children[0] || null;
 4279|       |      if (child && typeof child === 'object') {
 4280|       |        child.parentNode = this;
 4281|       |      }
 4282|       |      return child;
 4283|       |    },
 4284|       |    writable: true,
 4285|       |    configurable: true
 4286|       |  });
 4287|       |}
 4288|       |if (!Object.prototype.hasOwnProperty('insertBefore')) {
 4289|       |  Object.defineProperty(Object.prototype, 'insertBefore', {
 4290|       |    value: function(child, before) {
 4291|       |      if (this && !this.tagName && document && document.body && this !== document.body) {
 4292|       |        return document.body.insertBefore(child, before);
 4293|       |      }
 4294|       |      __mdmdview_detach(child);
 4295|       |      if (!this.children) { this.children = []; }
 4296|       |      var idx = this.children.indexOf(before);
 4297|       |      if (idx < 0) { this.children.push(child); }
 4298|       |      else { this.children.splice(idx, 0, child); }
 4299|       |      this.childNodes = this.children;
 4300|       |      this.firstChild = this.children[0] || null;
 4301|       |      if (child && typeof child === 'object') {
 4302|       |        child.parentNode = this;
 4303|       |      }
 4304|       |      return child;
 4305|       |    },
 4306|       |    writable: true,
 4307|       |    configurable: true
 4308|       |  });
 4309|       |}
 4310|       |if (!Object.prototype.hasOwnProperty('removeChild')) {
 4311|       |  Object.defineProperty(Object.prototype, 'removeChild', {
 4312|       |    value: function(child) {
 4313|       |      if (!this.children) { return child; }
 4314|       |      var idx = this.children.indexOf(child);
 4315|       |      if (idx >= 0) { this.children.splice(idx, 1); }
 4316|       |      this.childNodes = this.children;
 4317|       |      this.firstChild = this.children[0] || null;
 4318|       |      return child;
 4319|       |    },
 4320|       |    writable: true,
 4321|       |    configurable: true
 4322|       |  });
 4323|       |}
 4324|       |if (!Object.prototype.hasOwnProperty('matches')) {
 4325|       |  Object.defineProperty(Object.prototype, 'matches', {
 4326|       |    value: function(sel) { return __mdmdview_matches_selector(this, sel); },
 4327|       |    writable: true,
 4328|       |    configurable: true
 4329|       |  });
 4330|       |}
 4331|       |if (!Object.prototype.hasOwnProperty('nextSibling')) {
 4332|       |  Object.defineProperty(Object.prototype, 'nextSibling', {
 4333|       |    get: function() { return null; },
 4334|       |    configurable: true
 4335|       |  });
 4336|       |}
 4337|       |if (!Object.prototype.hasOwnProperty('previousSibling')) {
 4338|       |  Object.defineProperty(Object.prototype, 'previousSibling', {
 4339|       |    get: function() { return null; },
 4340|       |    configurable: true
 4341|       |  });
 4342|       |}
 4343|       |window.getComputedStyle = function(el) {
 4344|       |  return (el && el.style) ? el.style : __mdmdview_make_style();
 4345|       |};
 4346|       |window.__mdmdview_timer_queue = [];
 4347|       |window.__mdmdview_timer_map = {};
 4348|       |window.__mdmdview_next_timer_id = 1;
 4349|       |window.setTimeout = function(fn, ms) {
 4350|       |  var id = window.__mdmdview_next_timer_id++;
 4351|       |  window.__mdmdview_timer_map[id] = { fn: fn, interval: false };
 4352|       |  window.__mdmdview_timer_queue.push(id);
 4353|       |  return id;
 4354|       |};
 4355|       |window.clearTimeout = function(id) {
 4356|       |  if (window.__mdmdview_timer_map) {
 4357|       |    delete window.__mdmdview_timer_map[id];
 4358|       |  }
 4359|       |};
 4360|       |window.setInterval = function(fn, ms) {
 4361|       |  var id = window.__mdmdview_next_timer_id++;
 4362|       |  window.__mdmdview_timer_map[id] = { fn: fn, interval: true };
 4363|       |  window.__mdmdview_timer_queue.push(id);
 4364|       |  return id;
 4365|       |};
 4366|       |window.clearInterval = function(id) { window.clearTimeout(id); };
 4367|       |window.requestAnimationFrame = function(fn) {
 4368|       |  return window.setTimeout(function() { fn(0); }, 16);
 4369|       |};
 4370|       |window.cancelAnimationFrame = function(id) { window.clearTimeout(id); };
 4371|       |window.__mdmdview_run_timers = function(max_ticks) {
 4372|       |  var ticks = 0;
 4373|       |  var queue = window.__mdmdview_timer_queue || [];
 4374|       |  var map = window.__mdmdview_timer_map || {};
 4375|       |  var limit = typeof max_ticks === 'number' && max_ticks > 0 ? max_ticks : 1000;
 4376|       |  while (queue.length && ticks < limit) {
 4377|       |    var id = queue.shift();
 4378|       |    var entry = map[id];
 4379|       |    if (entry && typeof entry.fn === 'function') { entry.fn(); }
 4380|       |    if (entry && entry.interval) {
 4381|       |      queue.push(id);
 4382|       |    } else {
 4383|       |      delete map[id];
 4384|       |    }
 4385|       |    ticks++;
 4386|       |  }
 4387|       |  return queue.length;
 4388|       |};
 4389|       |if (!window.devicePixelRatio) { window.devicePixelRatio = 1; }
 4390|       |if (!window.Image) {
 4391|       |  window.Image = function() {
 4392|       |    this.complete = true;
 4393|       |    this.addEventListener = function() {};
 4394|       |    this.removeEventListener = function() {};
 4395|       |    return this;
 4396|       |  };
 4397|       |}
 4398|       |window.addEventListener = function() {};
 4399|       |window.removeEventListener = function() {};
 4400|       |window.structuredClone = function(value) {
 4401|       |  if (value === null || value === undefined) { return value; }
 4402|       |  if (typeof value !== 'object') { return value; }
 4403|       |  try { return JSON.parse(JSON.stringify(value)); } catch (e) {}
 4404|       |  if (Array.isArray(value)) { return value.slice(); }
 4405|       |  var out = {};
 4406|       |  for (var key in value) {
 4407|       |    if (!Object.prototype.hasOwnProperty.call(value, key)) { continue; }
 4408|       |    out[key] = value[key];
 4409|       |  }
 4410|       |  return out;
 4411|       |};
 4412|       |window.__mdmdview_now_base = 0;
 4413|       |window.performance = { now: function(){
 4414|       |  if (typeof Date !== 'undefined' && typeof Date.now === 'function') { return Date.now(); }
 4415|       |  window.__mdmdview_now_base += 1;
 4416|       |  return window.__mdmdview_now_base;
 4417|       |} };
 4418|       |window.console = {
 4419|       |  log: function(){},
 4420|       |  warn: function(){},
 4421|       |  error: function(){},
 4422|       |  info: function(){},
 4423|       |  debug: function(){},
 4424|       |  trace: function(){}
 4425|       |};
 4426|       |window.fetch = function(){ throw new Error('fetch disabled'); };
 4427|       |window.XMLHttpRequest = function(){ throw new Error('XMLHttpRequest disabled'); };
 4428|       |window.DOMPurify = { sanitize: function(html){ return html; } };
 4429|       |window.getComputedStyle = function(el) {
 4430|       |  var style = (el && el.style) ? el.style : __mdmdview_make_style();
 4431|       |  if (!style.fontSize) { style.fontSize = '16px'; }
 4432|       |  if (!style['font-size']) { style['font-size'] = style.fontSize; }
 4433|       |  if (!style.fontFamily) { style.fontFamily = 'sans-serif'; }
 4434|       |  if (!style['font-family']) { style['font-family'] = style.fontFamily; }
 4435|       |  if (!style.fontWeight) { style.fontWeight = 'normal'; }
 4436|       |  if (!style['font-weight']) { style['font-weight'] = style.fontWeight; }
 4437|       |  if (!style.fontStyle) { style.fontStyle = 'normal'; }
 4438|       |  if (!style['font-style']) { style['font-style'] = style.fontStyle; }
 4439|       |  if (el && el.getAttribute) {
 4440|       |    var attrSize = el.getAttribute('font-size');
 4441|       |    if (attrSize) {
 4442|       |      style.fontSize = String(attrSize);
 4443|       |      style['font-size'] = style.fontSize;
 4444|       |    }
 4445|       |    var attrFamily = el.getAttribute('font-family');
 4446|       |    if (attrFamily) {
 4447|       |      style.fontFamily = String(attrFamily);
 4448|       |      style['font-family'] = style.fontFamily;
 4449|       |    }
 4450|       |    var attrWeight = el.getAttribute('font-weight');
 4451|       |    if (attrWeight) {
 4452|       |      style.fontWeight = String(attrWeight);
 4453|       |      style['font-weight'] = style.fontWeight;
 4454|       |    }
 4455|       |    var attrStyle = el.getAttribute('font-style');
 4456|       |    if (attrStyle) {
 4457|       |      style.fontStyle = String(attrStyle);
 4458|       |      style['font-style'] = style.fontStyle;
 4459|       |    }
 4460|       |  }
 4461|       |  style.getPropertyValue = function(key) {
 4462|       |    if (Object.prototype.hasOwnProperty.call(style, key)) { return style[key]; }
 4463|       |    if (key === 'font-size') { return style.fontSize; }
 4464|       |    if (key === 'font-family') { return style.fontFamily; }
 4465|       |    if (key === 'font-weight') { return style.fontWeight; }
 4466|       |    if (key === 'font-style') { return style.fontStyle; }
 4467|       |    return '';
 4468|       |  };
 4469|       |  return style;
 4470|       |};
 4471|       |window.__mdmdview_viewport_width = 1200;
 4472|       |window.__mdmdview_viewport_height = 900;
 4473|       |Object.defineProperty(window, 'innerWidth', {
 4474|       |  get: function() { return window.__mdmdview_viewport_width || 0; },
 4475|       |  configurable: true
 4476|       |});
 4477|       |Object.defineProperty(window, 'innerHeight', {
 4478|       |  get: function() { return window.__mdmdview_viewport_height || 0; },
 4479|       |  configurable: true
 4480|       |});
 4481|       |if (!Object.prototype.hasOwnProperty('parentElement')) {
 4482|       |  Object.defineProperty(Object.prototype, 'parentElement', {
 4483|       |    get: function() {
 4484|       |      var p = this && this.parentNode ? this.parentNode : null;
 4485|       |      if (p && p.tagName) { return p; }
 4486|       |      return null;
 4487|       |    },
 4488|       |    configurable: true
 4489|       |  });
 4490|       |}
 4491|       |if (!Object.prototype.hasOwnProperty('offsetWidth')) {
 4492|       |  Object.defineProperty(Object.prototype, 'offsetWidth', {
 4493|       |    get: function() {
 4494|       |      if (this && typeof this.getBBox === 'function') {
 4495|       |        var width = this.getBBox().width || 0;
 4496|       |        if (width) { return width; }
 4497|       |      }
 4498|       |      return window.innerWidth || 0;
 4499|       |    },
 4500|       |    configurable: true
 4501|       |  });
 4502|       |}
 4503|       |if (!Object.prototype.hasOwnProperty('offsetHeight')) {
 4504|       |  Object.defineProperty(Object.prototype, 'offsetHeight', {
 4505|       |    get: function() {
 4506|       |      if (this && typeof this.getBBox === 'function') {
 4507|       |        var height = this.getBBox().height || 0;
 4508|       |        if (height) { return height; }
 4509|       |      }
 4510|       |      return window.innerHeight || 0;
 4511|       |    },
 4512|       |    configurable: true
 4513|       |  });
 4514|       |}
 4515|       |if (!Object.prototype.hasOwnProperty('clientWidth')) {
 4516|       |  Object.defineProperty(Object.prototype, 'clientWidth', {
 4517|       |    get: function() { return this.offsetWidth || 0; },
 4518|       |    configurable: true
 4519|       |  });
 4520|       |}
 4521|       |if (!Object.prototype.hasOwnProperty('clientHeight')) {
 4522|       |  Object.defineProperty(Object.prototype, 'clientHeight', {
 4523|       |    get: function() { return this.offsetHeight || 0; },
 4524|       |    configurable: true
 4525|       |  });
 4526|       |}
 4527|       |"#;
 4528|       |
 4529|       |#[cfg(feature = "mermaid-quickjs")]
 4530|       |const MERMAID_INIT_SNIPPET: &str = r##"
 4531|       |if (window.mermaid && mermaid.mermaidAPI) {
 4532|       |  mermaid.mermaidAPI.initialize({startOnLoad: false});
 4533|       |  window.__mdmdview_is_plain_object = function(value) {
 4534|       |    return value && typeof value === 'object' && !Array.isArray(value);
 4535|       |  };
 4536|       |  window.__mdmdview_merge_config = function(baseConfig, overrideConfig) {
 4537|       |    var out = {};
 4538|       |    function assign(target, source) {
 4539|       |      if (!window.__mdmdview_is_plain_object(source)) { return; }
 4540|       |      for (var key in source) {
 4541|       |        if (!Object.prototype.hasOwnProperty.call(source, key)) { continue; }
 4542|       |        var value = source[key];
 4543|       |        if (window.__mdmdview_is_plain_object(value)) {
 4544|       |          if (!window.__mdmdview_is_plain_object(target[key])) { target[key] = {}; }
 4545|       |          assign(target[key], value);
 4546|       |        } else if (Array.isArray(value)) {
 4547|       |          target[key] = value.slice();
 4548|       |        } else {
 4549|       |          target[key] = value;
 4550|       |        }
 4551|       |      }
 4552|       |    }
 4553|       |    assign(out, baseConfig);
 4554|       |    assign(out, overrideConfig);
 4555|       |    return out;
 4556|       |  };
 4557|       |  window.__mdmdview_sanitize_config = function(cfg) {
 4558|       |    if (!window.__mdmdview_is_plain_object(cfg)) { return null; }
 4559|       |    var disallowed = {
 4560|       |      securityLevel: true,
 4561|       |      startOnLoad: true,
 4562|       |      maxTextSize: true,
 4563|       |      deterministicIds: true,
 4564|       |      deterministicIDSeed: true,
 4565|       |      htmlLabels: true,
 4566|       |      themeCSS: true,
 4567|       |      dompurifyConfig: true,
 4568|       |      secure: true
 4569|       |    };
 4570|       |    var out = {};
 4571|       |    for (var key in cfg) {
 4572|       |      if (!Object.prototype.hasOwnProperty.call(cfg, key)) { continue; }
 4573|       |      if (key.indexOf('__') === 0 || key.indexOf('proto') >= 0 || key.indexOf('constructor') >= 0) {
 4574|       |        continue;
 4575|       |      }
 4576|       |      if (disallowed[key]) { continue; }
 4577|       |      var value = cfg[key];
 4578|       |      if (window.__mdmdview_is_plain_object(value)) {
 4579|       |        var nested = window.__mdmdview_sanitize_config(value);
 4580|       |        if (nested && Object.keys(nested).length) { out[key] = nested; }
 4581|       |      } else if (Array.isArray(value)) {
 4582|       |        out[key] = value.slice();
 4583|       |      } else {
 4584|       |        out[key] = value;
 4585|       |      }
 4586|       |    }
 4587|       |    if (out.themeVariables && window.__mdmdview_is_plain_object(out.themeVariables)) {
 4588|       |      for (var tvKey in out.themeVariables) {
 4589|       |        if (!Object.prototype.hasOwnProperty.call(out.themeVariables, tvKey)) { continue; }
 4590|       |        var tvVal = out.themeVariables[tvKey];
 4591|       |        if (typeof tvVal === 'string') {
 4592|       |          if (!tvVal.match(/^[\d "#%(),.;A-Za-z-]+$/)) {
 4593|       |            delete out.themeVariables[tvKey];
 4594|       |          }
 4595|       |        }
 4596|       |      }
 4597|       |    }
 4598|       |    return out;
 4599|       |  };
 4600|       |  window.__mdmdview_extract_init = function(code) {
 4601|       |    if (typeof code !== 'string') { return { code: code, config: null }; }
 4602|       |    var initRe = /%%\{\s*init\s*:\s*([\s\S]*?)\s*\}%%/g;
 4603|       |    var found = null;
 4604|       |    var cleaned = code.replace(initRe, function(match, json) {
 4605|       |      if (found === null) {
 4606|       |        try { found = JSON.parse(json); } catch (e) { found = null; }
 4607|       |      }
 4608|       |      return '';
 4609|       |    });
 4610|       |    return { code: cleaned, config: found };
 4611|       |  };
 4612|       |} else {
 4613|       |  throw new Error('Mermaid not available');
 4614|       |}
 4615|       |"##;
 4616|       |
 4617|       |#[cfg(feature = "mermaid-quickjs")]
 4618|       |const MERMAID_RENDER_WRAPPER: &str = r#"
 4619|       |(function(id, code, siteConfigJson, viewportWidth, viewportHeight){
 4620|       |  if (typeof __mdmdview_reset_dom === 'function') {
 4621|       |    __mdmdview_reset_dom();
 4622|       |  }
 4623|       |  if (typeof viewportWidth === 'number' && viewportWidth > 0) {
 4624|       |    window.__mdmdview_viewport_width = viewportWidth;
 4625|       |  }
 4626|       |  if (typeof viewportHeight === 'number' && viewportHeight > 0) {
 4627|       |    window.__mdmdview_viewport_height = viewportHeight;
 4628|       |  }
 4629|       |  var siteConfig = {};
 4630|       |  if (typeof siteConfigJson === 'string' && siteConfigJson.length > 0) {
 4631|       |    try { siteConfig = JSON.parse(siteConfigJson); } catch (e) { siteConfig = {}; }
 4632|       |  }
 4633|       |  var extracted = window.__mdmdview_extract_init(code);
 4634|       |  var directiveConfig = window.__mdmdview_sanitize_config(extracted.config) || {};
 4635|       |  var merged = window.__mdmdview_merge_config(directiveConfig, siteConfig);
 4636|       |  if (merged && merged.securityLevel === 'strict') {
 4637|       |    merged.htmlLabels = false;
 4638|       |    if (!merged.flowchart) { merged.flowchart = {}; }
 4639|       |    merged.flowchart.htmlLabels = false;
 4640|       |  }
 4641|       |  function __mdmdview_flush_timers() {
 4642|       |    if (typeof __mdmdview_run_timers !== 'function') { return; }
 4643|       |    var remaining = 0;
 4644|       |    var cycles = 0;
 4645|       |    do {
 4646|       |      remaining = __mdmdview_run_timers(1000);
 4647|       |      cycles++;
 4648|       |    } while (remaining > 0 && cycles < 100);
 4649|       |    if (remaining > 0) { throw new Error('Mermaid timer queue did not drain'); }
 4650|       |  }
 4651|       |  function __mdmdview_pump_timers(max_cycles) {
 4652|       |    var cycles = 0;
 4653|       |    function step() {
 4654|       |      if (typeof __mdmdview_run_timers !== 'function') {
 4655|       |        return Promise.resolve();
 4656|       |      }
 4657|       |      var remaining = __mdmdview_run_timers(1000);
 4658|       |      cycles++;
 4659|       |      if (remaining > 0 && cycles < max_cycles) {
 4660|       |        return Promise.resolve().then(step);
 4661|       |      }
 4662|       |      if (remaining > 0) {
 4663|       |        return Promise.reject(new Error('Mermaid timer queue did not drain'));
 4664|       |      }
 4665|       |      return Promise.resolve();
 4666|       |    }
 4667|       |    return step();
 4668|       |  }
 4669|       |  mermaid.mermaidAPI.initialize(merged);
 4670|       |  var renderCode = extracted && extracted.code !== undefined ? extracted.code : code;
 4671|       |  var svgOut = null;
 4672|       |  var renderResult = null;
 4673|       |  try {
 4674|       |    renderResult = mermaid.mermaidAPI.render(id, renderCode, function(svg){ svgOut = svg; });
 4675|       |    __mdmdview_flush_timers();
 4676|       |  } catch (err) {
 4677|       |    throw err;
 4678|       |  }
 4679|       |  if (renderResult && typeof renderResult.then === 'function') {
 4680|       |    var pump = __mdmdview_pump_timers(400);
 4681|       |    return Promise.all([renderResult, pump]).then(function(values){
 4682|       |      __mdmdview_flush_timers();
 4683|       |      var out = values && values.length ? values[0] : null;
 4684|       |      if (typeof out === 'string') { return out; }
 4685|       |      if (out && out.svg) { return out.svg; }
 4686|       |      if (typeof svgOut === 'string' && svgOut.length > 0) { return svgOut; }
 4687|       |      throw new Error('Mermaid render returned empty');
 4688|       |    });
 4689|       |  }
 4690|       |  if (typeof renderResult === 'string') { return renderResult; }
 4691|       |  if (renderResult && renderResult.svg) { return renderResult.svg; }
 4692|       |  if (typeof svgOut === 'string' && svgOut.length > 0) { return svgOut; }
 4693|       |  throw new Error('Mermaid render returned empty');
 4694|       |})
 4695|       |"#;
 4696|       |
 4697|       |#[cfg(test)]
 4698|       |mod tests {
 4699|       |    use super::*;
 4700|       |    use std::collections::HashSet;
 4701|       |    use std::sync::{Arc, Mutex, OnceLock};
 4702|       |    use tempfile::tempdir;
 4703|       |
 4704|     30|    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
 4705|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
 4706|     30|        ENV_LOCK
 4707|     30|            .get_or_init(|| Mutex::new(()))
                                          ^1         ^1
 4708|     30|            .lock()
 4709|     30|            .expect("env lock")
 4710|     30|    }
 4711|       |
 4712|       |    #[cfg(feature = "mermaid-quickjs")]
 4713|      5|    fn test_renderer_with_channels(
 4714|      5|        job_tx: Option<MermaidJobSender>,
 4715|      5|        result_rx: MermaidResultReceiver,
 4716|      5|    ) -> MermaidRenderer {
 4717|      5|        MermaidRenderer {
 4718|      5|            mermaid_textures: RefCell::new(LruCache::new(4)),
 4719|      5|            mermaid_pending: RefCell::new(HashSet::new()),
 4720|      5|            mermaid_frame_pending: Cell::new(false),
 4721|      5|            mermaid_svg_cache: RefCell::new(LruCache::new(4)),
 4722|      5|            mermaid_errors: RefCell::new(LruCache::new(4)),
 4723|      5|            mermaid_texture_errors: RefCell::new(LruCache::new(4)),
 4724|      5|            mermaid_job_tx: job_tx,
 4725|      5|            mermaid_result_rx: result_rx,
 4726|      5|            worker_handles: Vec::new(),
 4727|      5|        }
 4728|      5|    }
 4729|       |
 4730|       |    #[test]
 4731|      1|    fn test_lru_cache_eviction_and_touch() {
 4732|      1|        let mut cache = LruCache::new(2);
 4733|      1|        let key_a = "a".to_string();
 4734|      1|        let key_b = "b".to_string();
 4735|      1|        let key_c = "c".to_string();
 4736|       |
 4737|      1|        cache.insert(key_a.clone(), 1);
 4738|      1|        cache.insert(key_b.clone(), 2);
 4739|      1|        assert_eq!(cache.get(&key_a), Some(1));
 4740|      1|        cache.insert(key_c.clone(), 3);
 4741|      1|        assert!(cache.get(&key_b).is_none());
 4742|      1|        assert_eq!(cache.len(), 2);
 4743|      1|    }
 4744|       |
 4745|       |    #[test]
 4746|      1|    fn test_lru_cache_missing_get_and_empty_order_insert() {
 4747|      1|        let mut cache = LruCache::new(1);
 4748|      1|        assert!(cache.get(&"missing".to_string()).is_none());
 4749|      1|        cache.entries.insert("a".to_string(), 1);
 4750|      1|        cache.order.clear();
 4751|      1|        cache.insert("b".to_string(), 2);
 4752|      1|        assert_eq!(cache.len(), 2);
 4753|      1|    }
 4754|       |
 4755|       |    #[test]
 4756|      1|    fn test_lru_cache_capacity_zero_insert() {
 4757|      1|        let mut cache = LruCache::new(0);
 4758|      1|        cache.insert("a".to_string(), 1);
 4759|      1|        assert_eq!(cache.len(), 1);
 4760|      1|    }
 4761|       |
 4762|       |    #[test]
 4763|      1|    fn test_lru_cache_insert_overwrites_existing_key() {
 4764|      1|        let mut cache = LruCache::new(2);
 4765|      1|        let key = "alpha".to_string();
 4766|      1|        cache.insert(key.clone(), 1);
 4767|      1|        cache.insert(key.clone(), 2);
 4768|      1|        assert_eq!(cache.get(&key), Some(2));
 4769|      1|        assert_eq!(cache.len(), 1);
 4770|      1|    }
 4771|       |
 4772|       |    #[test]
 4773|      1|    fn test_lru_cache_string_string_branches() {
 4774|      1|        let mut cache = LruCache::new(1);
 4775|      1|        assert!(cache.get(&"missing".to_string()).is_none());
 4776|       |
 4777|      1|        cache.insert("a".to_string(), "one".to_string());
 4778|      1|        cache.insert("a".to_string(), "uno".to_string());
 4779|      1|        assert_eq!(cache.get(&"a".to_string()), Some("uno".to_string()));
 4780|       |
 4781|      1|        cache.insert("b".to_string(), "two".to_string());
 4782|      1|        assert!(cache.get(&"a".to_string()).is_none());
 4783|       |
 4784|      1|        cache.entries.insert("c".to_string(), "three".to_string());
 4785|      1|        cache.order.clear();
 4786|      1|        cache.insert("d".to_string(), "four".to_string());
 4787|      1|        assert!(cache.len() >= 1);
 4788|      1|    }
 4789|       |
 4790|       |    #[cfg(feature = "mermaid-quickjs")]
 4791|       |    #[test]
 4792|      1|    fn test_lru_cache_mermaid_type_variants() {
 4793|      1|        let mut string_cache = LruCache::new(2);
 4794|      1|        string_cache.insert(1u64, "one".to_string());
 4795|      1|        string_cache.insert(2u64, "two".to_string());
 4796|      1|        assert_eq!(string_cache.get(&1), Some("one".to_string()));
 4797|      1|        assert!(string_cache.get(&3).is_none());
 4798|      1|        string_cache.insert(1u64, "uno".to_string());
 4799|      1|        string_cache.insert(3u64, "three".to_string());
 4800|       |
 4801|      1|        let ctx = egui::Context::default();
 4802|      1|        let tex = ctx.load_texture(
 4803|       |            "mermaid_cache_test",
 4804|      1|            egui::ColorImage::new([1, 1], Color32::WHITE),
 4805|       |            egui::TextureOptions::LINEAR,
 4806|       |        );
 4807|      1|        let entry = MermaidTextureEntry {
 4808|      1|            texture: tex,
 4809|      1|            size: [1, 1],
 4810|      1|        };
 4811|      1|        let mut texture_cache = LruCache::new(1);
 4812|      1|        texture_cache.insert("a".to_string(), entry.clone());
 4813|      1|        assert!(texture_cache.get(&"a".to_string()).is_some());
 4814|      1|        texture_cache.insert("a".to_string(), entry.clone());
 4815|      1|        texture_cache.insert("b".to_string(), entry);
 4816|      1|    }
 4817|       |
 4818|       |    #[test]
 4819|      1|    fn test_mermaid_texture_key_changes_with_scale_and_bg() {
 4820|      1|        let svg_key = 42;
 4821|      1|        let width_bucket = 320;
 4822|      1|        let scale_a = MermaidRenderer::scale_bucket(1.0);
 4823|      1|        let scale_b = MermaidRenderer::scale_bucket(1.2);
 4824|      1|        let bg_a = Some([255, 0, 0, 255]);
 4825|      1|        let bg_b = Some([0, 0, 0, 255]);
 4826|       |
 4827|      1|        let key_a = MermaidRenderer::texture_key(svg_key, width_bucket, scale_a, bg_a);
 4828|      1|        let key_b = MermaidRenderer::texture_key(svg_key, width_bucket, scale_b, bg_a);
 4829|      1|        let key_c = MermaidRenderer::texture_key(svg_key, width_bucket, scale_a, bg_b);
 4830|       |
 4831|      1|        assert_ne!(key_a, key_b);
 4832|      1|        assert_ne!(key_a, key_c);
 4833|      1|    }
 4834|       |
 4835|       |    #[test]
 4836|      1|    fn test_mermaid_width_bucket_rounds_up() {
 4837|      1|        let step = MermaidRenderer::MERMAID_WIDTH_BUCKET_STEP;
 4838|      1|        assert_eq!(MermaidRenderer::width_bucket(1.0), step);
 4839|      1|        assert_eq!(MermaidRenderer::width_bucket(step as f32 + 0.1), step * 2);
 4840|      1|    }
 4841|       |
 4842|       |    #[test]
 4843|      1|    fn test_mermaid_diagram_kind_skips_comments_and_blank() {
 4844|      1|        let code = "\n%% comment\n  \nsequenceDiagram\nAlice->>Bob: Hi";
 4845|      1|        assert_eq!(
 4846|      1|            MermaidRenderer::mermaid_diagram_kind(code),
 4847|      1|            Some("sequencediagram".to_string())
 4848|       |        );
 4849|      1|    }
 4850|       |
 4851|       |    #[test]
 4852|      1|    fn test_mermaid_diagram_kind_returns_none_for_comments_only() {
 4853|      1|        let code = "%% comment\n   \n%% another";
 4854|      1|        assert!(MermaidRenderer::mermaid_diagram_kind(code).is_none());
 4855|      1|    }
 4856|       |
 4857|       |    #[test]
 4858|      1|    fn test_mermaid_renderer_preference_env() {
 4859|      1|        let _lock = env_lock();
 4860|      1|        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
 4861|      1|        let (default_pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
 4862|      1|        assert!(!explicit);
 4863|      1|        let expected = if cfg!(feature = "mermaid-quickjs") {
 4864|      1|            MermaidRenderPreference::Embedded
 4865|       |        } else {
 4866|      0|            MermaidRenderPreference::Off
 4867|       |        };
 4868|      1|        assert_eq!(default_pref, expected);
 4869|       |
 4870|       |        {
 4871|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 4872|      1|            let (pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
 4873|      1|            assert!(explicit);
 4874|      1|            assert_eq!(pref, MermaidRenderPreference::Embedded);
 4875|       |        }
 4876|       |        {
 4877|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "off");
 4878|      1|            let (pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
 4879|      1|            assert!(explicit);
 4880|      1|            assert_eq!(pref, MermaidRenderPreference::Off);
 4881|       |        }
 4882|       |        {
 4883|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "bogus");
 4884|      1|            let (pref, explicit) = MermaidRenderer::mermaid_renderer_preference();
 4885|      1|            assert!(!explicit);
 4886|      1|            assert_eq!(pref, expected);
 4887|       |        }
 4888|      1|    }
 4889|       |
 4890|       |    #[test]
 4891|      1|    fn test_mermaid_security_level_default_and_env() {
 4892|      1|        let _lock = env_lock();
 4893|      1|        std::env::remove_var("MDMDVIEW_MERMAID_SECURITY");
 4894|      1|        assert_eq!(MermaidRenderer::mermaid_security_level(), "strict");
 4895|       |        {
 4896|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_SECURITY", "loose");
 4897|      1|            assert_eq!(MermaidRenderer::mermaid_security_level(), "loose");
 4898|       |        }
 4899|       |        {
 4900|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_SECURITY", "strict");
 4901|      1|            assert_eq!(MermaidRenderer::mermaid_security_level(), "strict");
 4902|       |        }
 4903|      1|    }
 4904|       |
 4905|       |    #[cfg(feature = "mermaid-quickjs")]
 4906|       |    #[test]
 4907|      1|    fn test_mermaid_worker_count_clamps_env() {
 4908|      1|        let _lock = env_lock();
 4909|       |        {
 4910|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "0");
 4911|      1|            assert_eq!(MermaidRenderer::mermaid_worker_count(), 1);
 4912|       |        }
 4913|       |        {
 4914|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "999");
 4915|      1|            assert_eq!(MermaidRenderer::mermaid_worker_count(), 16);
 4916|       |        }
 4917|       |        {
 4918|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_WORKERS", "nope");
 4919|      1|            let count = MermaidRenderer::mermaid_worker_count();
 4920|      1|            assert!(count >= 1);
 4921|      1|            assert!(count <= MermaidRenderer::MAX_MERMAID_JOBS.max(1));
 4922|       |        }
 4923|      1|    }
 4924|       |
 4925|       |    #[cfg(feature = "mermaid-quickjs")]
 4926|       |    #[test]
 4927|      1|    fn test_mermaid_timeout_ms_env_clamps() {
 4928|      1|        let _lock = env_lock();
 4929|       |        {
 4930|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_TIMEOUT_MS", "50");
 4931|      1|            assert_eq!(MermaidRenderer::mermaid_timeout_ms(), 100);
 4932|       |        }
 4933|       |        {
 4934|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_TIMEOUT_MS", "250");
 4935|      1|            assert_eq!(MermaidRenderer::mermaid_timeout_ms(), 250);
 4936|       |        }
 4937|       |        {
 4938|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_TIMEOUT_MS", "bad");
 4939|      1|            assert_eq!(MermaidRenderer::mermaid_timeout_ms(), 30_000);
 4940|       |        }
 4941|      1|    }
 4942|       |
 4943|       |    #[cfg(feature = "mermaid-quickjs")]
 4944|       |    #[test]
 4945|      1|    fn test_mermaid_theme_values_font_family_trim() {
 4946|      1|        let _lock = env_lock();
 4947|       |        {
 4948|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_FONT_FAMILY", "  ");
 4949|      1|            let theme = MermaidRenderer::mermaid_theme_values();
 4950|      1|            assert!(theme.font_family.is_none());
 4951|       |        }
 4952|       |        {
 4953|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_FONT_FAMILY", "  Test Font  ");
 4954|      1|            let theme = MermaidRenderer::mermaid_theme_values();
 4955|      1|            assert_eq!(theme.font_family.as_deref(), Some("Test Font"));
 4956|       |        }
 4957|      1|    }
 4958|       |
 4959|       |    #[cfg(feature = "mermaid-quickjs")]
 4960|       |    #[test]
 4961|      1|    fn test_mermaid_site_config_json_includes_security_flags() {
 4962|      1|        let _lock = env_lock();
 4963|       |        {
 4964|      1|            std::env::remove_var("MDMDVIEW_MERMAID_SECURITY");
 4965|      1|            let json = MermaidRenderer::mermaid_site_config_json(1);
 4966|      1|            assert!(json.contains("\"securityLevel\":\"strict\""));
 4967|      1|            assert!(json.contains("\"htmlLabels\":false"));
 4968|      1|            assert!(json.contains("\"flowchart\":{\"htmlLabels\":false}"));
 4969|       |        }
 4970|       |        {
 4971|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_SECURITY", "loose");
 4972|      1|            let json = MermaidRenderer::mermaid_site_config_json(2);
 4973|      1|            assert!(json.contains("\"securityLevel\":\"loose\""));
 4974|      1|            assert!(!json.contains("\"flowchart\":{\"htmlLabels\":false}"));
 4975|       |        }
 4976|      1|    }
 4977|       |
 4978|       |    #[cfg(feature = "mermaid-quickjs")]
 4979|       |    #[test]
 4980|      1|    fn test_mermaid_site_config_json_includes_font_family() {
 4981|      1|        let _lock = env_lock();
 4982|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_FONT_FAMILY", "Test Sans");
 4983|      1|        let json = MermaidRenderer::mermaid_site_config_json(3);
 4984|      1|        assert!(json.contains("\"fontFamily\":\"Test Sans\""));
 4985|      1|    }
 4986|       |
 4987|       |    #[cfg(feature = "mermaid-quickjs")]
 4988|       |    #[test]
 4989|      1|    fn test_json_escape_handles_specials() {
 4990|      1|        let input = "quote\" backslash\\ newline\n tab\t carriage\r";
 4991|      1|        let escaped = MermaidRenderer::json_escape(input);
 4992|      1|        assert!(escaped.contains("\\\""));
 4993|      1|        assert!(escaped.contains("\\\\"));
 4994|      1|        assert!(escaped.contains("\\n"));
 4995|      1|        assert!(escaped.contains("\\t"));
 4996|      1|        assert!(escaped.contains("\\r"));
 4997|      1|    }
 4998|       |
 4999|       |    #[cfg(feature = "mermaid-quickjs")]
 5000|       |    #[test]
 5001|      1|    fn test_mermaid_image_href_resolver_blocks_external() {
 5002|      1|        let resolver = MermaidWorker::image_href_resolver();
 5003|      1|        let options = usvg::Options::default();
 5004|      1|        let resolve_string = &resolver.resolve_string;
 5005|       |
 5006|      1|        assert!(resolve_string("http://example.com/img.png", &options).is_none());
 5007|      1|        assert!(resolve_string("file:///tmp/foo.png", &options).is_none());
 5008|      1|    }
 5009|       |
 5010|       |    #[cfg(feature = "mermaid-quickjs")]
 5011|       |    #[test]
 5012|      1|    fn test_mermaid_embed_bytes_present() {
 5013|      1|        assert!(!super::mermaid_embed::MERMAID_JS.is_empty());
 5014|      1|    }
 5015|       |
 5016|       |    #[cfg(feature = "mermaid-quickjs")]
 5017|       |    #[test]
 5018|      1|    fn test_mermaid_quickjs_render_smoke() {
 5019|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5020|      1|        fontdb.load_system_fonts();
 5021|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5022|      1|        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5023|       |
 5024|      1|        let flow = "graph TD; A-->B;";
 5025|      1|        let seq = "sequenceDiagram\nAlice->>Bob: Hello\nBob-->>Alice: Hi";
 5026|      1|        let class = "classDiagram\nClass01 <|-- Class02\nClass01 : +int id\nClass02 : +String name";
 5027|      1|        let er = "erDiagram\nCUSTOMER ||--o{ ORDER : places\nORDER ||--|{ LINE_ITEM : contains\nCUSTOMER {\n  int id\n  string name\n}\nORDER {\n  int id\n  date created\n}\nLINE_ITEM {\n  int id\n  int qty\n}\n";
 5028|      1|        let gantt = "gantt\ntitle Sample Gantt\ndateFormat  YYYY-MM-DD\nsection A\nTask 1 :a1, 2024-01-01, 5d\nTask 2 :after a1, 3d\nsection B\nTask 3 :b1, 2024-01-06, 4d\n";
 5029|      1|        let viewport_width = 1200;
 5030|      1|        let viewport_height = 900;
 5031|       |
 5032|      1|        let flow_svg = worker
 5033|      1|            .render_svg(
 5034|      1|                MermaidRenderer::hash_str(flow),
 5035|      1|                flow,
 5036|      1|                viewport_width,
 5037|      1|                viewport_height,
 5038|       |            )
 5039|      1|            .expect("flowchart render");
 5040|      1|        let seq_svg = worker
 5041|      1|            .render_svg(
 5042|      1|                MermaidRenderer::hash_str(seq),
 5043|      1|                seq,
 5044|      1|                viewport_width,
 5045|      1|                viewport_height,
 5046|       |            )
 5047|      1|            .expect("sequence render");
 5048|      1|        let class_svg = worker
 5049|      1|            .render_svg(
 5050|      1|                MermaidRenderer::hash_str(class),
 5051|      1|                class,
 5052|      1|                viewport_width,
 5053|      1|                viewport_height,
 5054|       |            )
 5055|      1|            .expect("class render");
 5056|      1|        let er_svg = worker
 5057|      1|            .render_svg(
 5058|      1|                MermaidRenderer::hash_str(er),
 5059|      1|                er,
 5060|      1|                viewport_width,
 5061|      1|                viewport_height,
 5062|       |            )
 5063|      1|            .expect("er render");
 5064|      1|        let gantt_svg = worker
 5065|      1|            .render_svg(
 5066|      1|                MermaidRenderer::hash_str(gantt),
 5067|      1|                gantt,
 5068|      1|                viewport_width,
 5069|      1|                viewport_height,
 5070|       |            )
 5071|      1|            .expect("gantt render");
 5072|       |
 5073|      1|        assert!(flow_svg.contains("<svg"));
 5074|      1|        assert!(seq_svg.contains("<svg"));
 5075|      1|        assert!(class_svg.contains("<svg"));
 5076|      1|        assert!(er_svg.contains("<svg"));
 5077|      1|        assert!(gantt_svg.contains("<svg"));
 5078|       |
 5079|      1|        let width_bucket = MermaidRenderer::width_bucket(600.0);
 5080|      1|        let scale_bucket = MermaidRenderer::scale_bucket(1.0);
 5081|      1|        let (rgba, w, h) = worker
 5082|      1|            .rasterize_svg(&flow_svg, width_bucket, scale_bucket, None)
 5083|      1|            .expect("rasterize svg");
 5084|      1|        assert!(!rgba.is_empty());
 5085|      1|        assert_eq!(rgba.len(), (w as usize) * (h as usize) * 4);
 5086|      1|        assert!(w > 0);
 5087|      1|        assert!(h > 0);
 5088|      1|        assert!(w <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5089|      1|        assert!(h <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5090|      1|    }
 5091|       |
 5092|       |    #[cfg(feature = "mermaid-quickjs")]
 5093|       |    #[test]
 5094|      1|    fn test_mermaid_worker_dom_debug_env() {
 5095|      1|        let _lock = env_lock();
 5096|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_DOM_DEBUG", "1");
 5097|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5098|      1|        fontdb.load_system_fonts();
 5099|      1|        let fontdb = Arc::new(fontdb);
 5100|      1|        let worker = MermaidWorker::new(0, fontdb);
 5101|      1|        assert!(worker.is_ok());
 5102|      1|    }
 5103|       |
 5104|       |    #[cfg(feature = "mermaid-quickjs")]
 5105|       |    #[test]
 5106|      1|    fn test_process_job_missing_code_returns_error() {
 5107|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5108|      1|        fontdb.load_system_fonts();
 5109|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5110|      1|        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5111|       |
 5112|      1|        let job = MermaidRequest {
 5113|      1|            svg_key: 1,
 5114|      1|            texture_key: "missing".to_string(),
 5115|      1|            code: None,
 5116|      1|            svg: None,
 5117|      1|            width_bucket: 100,
 5118|      1|            scale_bucket: MermaidRenderer::scale_bucket(1.0),
 5119|      1|            viewport_width: 100,
 5120|      1|            viewport_height: 100,
 5121|      1|            bg: None,
 5122|      1|        };
 5123|       |
 5124|      1|        let result = worker.process_job(job);
 5125|      1|        assert!(result.svg.is_none());
 5126|      1|        assert!(result.rgba.is_none());
 5127|      1|        assert!(result.error.is_some());
 5128|      1|    }
 5129|       |
 5130|       |    #[cfg(feature = "mermaid-quickjs")]
 5131|       |    #[test]
 5132|      1|    fn test_rasterize_svg_invalid_returns_error() {
 5133|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5134|      1|        fontdb.load_system_fonts();
 5135|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5136|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5137|       |
 5138|      1|        let err = worker
 5139|      1|            .rasterize_svg("not svg", 100, MermaidRenderer::scale_bucket(1.0), None)
 5140|      1|            .unwrap_err();
 5141|      1|        assert!(!err.is_empty());
 5142|      1|    }
 5143|       |
 5144|       |    #[cfg(feature = "mermaid-quickjs")]
 5145|       |    #[test]
 5146|      1|    fn test_rasterize_svg_logs_when_env_set() {
 5147|      1|        let _lock = env_lock();
 5148|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_LOG_RASTER", "1");
 5149|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5150|      1|        fontdb.load_system_fonts();
 5151|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5152|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5153|      1|        let svg = r#"<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"></svg>"#;
 5154|      1|        let (data, w, h) = worker
 5155|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5156|      1|            .expect("rasterize svg");
 5157|      1|        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 5158|      1|    }
 5159|       |
 5160|       |    #[cfg(feature = "mermaid-quickjs")]
 5161|       |    #[test]
 5162|      1|    fn test_rasterize_svg_viewbox_filter_rejects_small() {
 5163|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5164|      1|        fontdb.load_system_fonts();
 5165|      1|        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5166|      1|        let svg = r#"<svg width="100" height="100" viewBox="0 0 0 0" xmlns="http://www.w3.org/2000/svg"></svg>"#;
 5167|      1|        let (data, w, h) = worker
 5168|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5169|      1|            .expect("rasterize svg");
 5170|      1|        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 5171|      1|    }
 5172|       |
 5173|       |    #[cfg(feature = "mermaid-quickjs")]
 5174|       |    #[test]
 5175|      1|    fn test_rasterize_svg_oversize_bbox_translates() {
 5176|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5177|      1|        fontdb.load_system_fonts();
 5178|      1|        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5179|      1|        let svg = r#"<svg width="100" height="50" xmlns="http://www.w3.org/2000/svg"><rect x="-60" y="0" width="200" height="50" fill="red"/></svg>"#;
 5180|      1|        let (_data, w, h) = worker
 5181|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5182|      1|            .expect("rasterize svg");
 5183|      1|        assert!(w > 100);
 5184|      1|        assert!(h >= 50);
 5185|      1|    }
 5186|       |
 5187|       |    #[cfg(feature = "mermaid-quickjs")]
 5188|       |    #[test]
 5189|      1|    fn test_rasterize_svg_clamps_large_width() {
 5190|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5191|      1|        fontdb.load_system_fonts();
 5192|      1|        let worker = MermaidWorker::new(0, Arc::new(fontdb)).expect("worker init");
 5193|      1|        let svg = r#"<svg width="4100" height="10" xmlns="http://www.w3.org/2000/svg"><rect width="4100" height="10" fill="red"/></svg>"#;
 5194|      1|        let (_data, w, h) = worker
 5195|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5196|      1|            .expect("rasterize svg");
 5197|      1|        assert!(w <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5198|      1|        assert!(h > 0);
 5199|      1|    }
 5200|       |
 5201|       |    #[cfg(feature = "mermaid-quickjs")]
 5202|       |    #[test]
 5203|      1|    fn test_process_job_svg_input_rasterize_error() {
 5204|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5205|      1|        fontdb.load_system_fonts();
 5206|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5207|      1|        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5208|       |
 5209|      1|        let job = MermaidRequest {
 5210|      1|            svg_key: 2,
 5211|      1|            texture_key: "bad-svg".to_string(),
 5212|      1|            code: Some("graph TD; A-->B;".to_string()),
 5213|      1|            svg: Some("not svg".to_string()),
 5214|      1|            width_bucket: 100,
 5215|      1|            scale_bucket: MermaidRenderer::scale_bucket(1.0),
 5216|      1|            viewport_width: 100,
 5217|      1|            viewport_height: 100,
 5218|      1|            bg: None,
 5219|      1|        };
 5220|       |
 5221|      1|        let result = worker.process_job(job);
 5222|      1|        assert!(result.svg.is_some());
 5223|      1|        assert!(result.rgba.is_none());
 5224|      1|        assert!(result.error.is_some());
 5225|      1|    }
 5226|       |
 5227|       |    #[cfg(feature = "mermaid-quickjs")]
 5228|       |    #[test]
 5229|      1|    fn test_rasterize_svg_adjusts_for_oversized_bbox() {
 5230|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5231|      1|        fontdb.load_system_fonts();
 5232|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5233|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5234|       |
 5235|      1|        let svg = r#"<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
 5236|      1|<rect x="-50" y="-50" width="200" height="200" fill="red"/>
 5237|      1|</svg>"#;
 5238|      1|        let (data, w, h) = worker
 5239|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5240|      1|            .expect("rasterize svg");
 5241|      1|        assert_eq!((w, h), (208, 208));
 5242|      1|        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 5243|      1|    }
 5244|       |
 5245|       |    #[cfg(feature = "mermaid-quickjs")]
 5246|       |    #[test]
 5247|      1|    fn test_rasterize_svg_viewbox_filter_skips_small_dims() {
 5248|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5249|      1|        fontdb.load_system_fonts();
 5250|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5251|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5252|       |
 5253|      1|        let svg = r#"<svg width="10" height="12" viewBox="0 0 0.1 0.1" xmlns="http://www.w3.org/2000/svg">
 5254|      1| <rect width="0.1" height="0.1" fill="red"/>
 5255|      1| </svg>"#;
 5256|      1|        let (_data, w, h) = worker
 5257|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5258|      1|            .expect("rasterize svg");
 5259|      1|        assert_eq!((w, h), (10, 12));
 5260|      1|    }
 5261|       |
 5262|       |    #[cfg(feature = "mermaid-quickjs")]
 5263|       |    #[test]
 5264|      1|    fn test_rasterize_svg_keeps_dimensions_for_small_bbox() {
 5265|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5266|      1|        fontdb.load_system_fonts();
 5267|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5268|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5269|       |
 5270|      1|        let svg = r#"<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
 5271|      1| <rect x="10" y="10" width="20" height="20" fill="red"/>
 5272|      1| </svg>"#;
 5273|      1|        let (_data, w, h) = worker
 5274|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5275|      1|            .expect("rasterize svg");
 5276|      1|        assert_eq!((w, h), (100, 100));
 5277|      1|    }
 5278|       |
 5279|       |    #[cfg(feature = "mermaid-quickjs")]
 5280|       |    #[test]
 5281|      1|    fn test_rasterize_svg_clamps_to_max_side() {
 5282|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5283|      1|        fontdb.load_system_fonts();
 5284|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5285|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5286|       |
 5287|      1|        let svg = r#"<svg width="10000" height="10000" viewBox="0 0 10000 10000" xmlns="http://www.w3.org/2000/svg">
 5288|      1|<rect width="10000" height="10000" fill="blue"/>
 5289|      1|</svg>"#;
 5290|      1|        let (_data, w, h) = worker
 5291|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), None)
 5292|      1|            .expect("rasterize svg");
 5293|      1|        assert!(w <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5294|      1|        assert!(h <= MermaidRenderer::MERMAID_MAX_RENDER_SIDE);
 5295|      1|    }
 5296|       |
 5297|       |    #[cfg(feature = "mermaid-quickjs")]
 5298|       |    #[test]
 5299|      1|    fn test_rasterize_svg_applies_background_fill() {
 5300|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5301|      1|        fontdb.load_system_fonts();
 5302|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5303|      1|        let worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5304|       |
 5305|      1|        let svg = r#"<svg width="4" height="4" xmlns="http://www.w3.org/2000/svg"></svg>"#;
 5306|      1|        let bg = Some([10, 20, 30, 200]);
 5307|      1|        let (data, w, h) = worker
 5308|      1|            .rasterize_svg(svg, 0, MermaidRenderer::scale_bucket(1.0), bg)
 5309|      1|            .expect("rasterize svg");
 5310|      1|        assert_eq!((w, h), (4, 4));
 5311|      1|        assert_eq!(data.len(), (w as usize) * (h as usize) * 4);
 5312|      1|        let alpha = 200.0_f32 / 255.0;
 5313|      1|        let expected_r = (10.0_f32 * alpha).round() as u8;
 5314|      1|        let expected_g = (20.0_f32 * alpha).round() as u8;
 5315|      1|        let expected_b = (30.0_f32 * alpha).round() as u8;
 5316|      1|        assert_eq!(data[0], expected_r);
 5317|      1|        assert_eq!(data[1], expected_g);
 5318|      1|        assert_eq!(data[2], expected_b);
 5319|      1|        assert_eq!(data[3], 200);
 5320|      1|    }
 5321|       |
 5322|       |    #[cfg(feature = "mermaid-quickjs")]
 5323|       |    #[test]
 5324|      1|    fn test_process_job_applies_svg_fixups() {
 5325|      1|        let mut fontdb = usvg::fontdb::Database::new();
 5326|      1|        fontdb.load_system_fonts();
 5327|      1|        let fontdb = std::sync::Arc::new(fontdb);
 5328|      1|        let mut worker = MermaidWorker::new(0, fontdb).expect("worker init");
 5329|       |
 5330|      1|        let svg = r#"<svg width="120" height="120" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
 5331|      1|<switch>
 5332|      1|  <foreignObject><div>Plan</div></foreignObject>
 5333|      1|  <text class="journey-section section-type-0" x="10">Plan</text>
 5334|      1|</switch>
 5335|      1|<g id="state-root_end-0">
 5336|      1|  <circle class="state-end" r="5" width="10" height="10"></circle>
 5337|      1|  <circle class="state-start" r="7" width="14" height="14"></circle>
 5338|      1|</g>
 5339|      1|<rect class="er attributeBoxOdd"></rect>
 5340|      1|</svg>"#;
 5341|       |
 5342|      1|        let job = MermaidRequest {
 5343|      1|            svg_key: 4,
 5344|      1|            texture_key: "fixups".to_string(),
 5345|      1|            code: None,
 5346|      1|            svg: Some(svg.to_string()),
 5347|      1|            width_bucket: 0,
 5348|      1|            scale_bucket: MermaidRenderer::scale_bucket(1.0),
 5349|      1|            viewport_width: 120,
 5350|      1|            viewport_height: 120,
 5351|      1|            bg: None,
 5352|      1|        };
 5353|       |
 5354|      1|        let result = worker.process_job(job);
 5355|      1|        let rendered = result.svg.expect("svg output");
 5356|      1|        assert!(!rendered.contains("<switch"));
 5357|      1|        assert!(rendered.contains("fill:"));
 5358|      1|        assert!(rendered.contains("end-state-inner"));
 5359|      1|        assert!(rendered.contains("attributeBoxOdd"));
 5360|      1|    }
 5361|       |
 5362|       |    #[cfg(feature = "mermaid-quickjs")]
 5363|       |    #[test]
 5364|      1|    fn test_mermaid_dump_helpers_sanitize_labels() {
 5365|      1|        let _lock = env_lock();
 5366|      1|        let dir = tempdir().expect("temp dir");
 5367|      1|        let _guard = EnvGuard::set(
 5368|       |            "MDMDVIEW_MERMAID_DUMP_DIR",
 5369|      1|            dir.path().to_string_lossy().as_ref(),
 5370|       |        );
 5371|      1|        MermaidWorker::maybe_dump_svg(10, Some("ok-label 123"), "<svg></svg>");
 5372|      1|        MermaidWorker::maybe_dump_error(11, Some("::bad label::"), "boom");
 5373|      1|        MermaidWorker::maybe_dump_error(12, Some("good_label"), "ok");
 5374|      1|        MermaidWorker::maybe_dump_svg(13, Some("\nrest"), "<svg></svg>");
 5375|      1|        MermaidWorker::maybe_dump_error(14, Some("abcdefghijklmnopqrstuvwxyz0123456789"), "long");
 5376|      1|        MermaidWorker::maybe_dump_svg(16, Some("abcdefghijklmnopqrstuvwxyz0123456789"), "<svg></svg>");
 5377|      1|        MermaidWorker::maybe_dump_error(15, None, "no code");
 5378|       |
 5379|      1|        let entries: Vec<_> = std::fs::read_dir(dir.path())
 5380|      1|            .expect("read dir")
 5381|      7|            .filter_map(|entry| entry.ok())
                           ^1
 5382|      1|            .collect();
 5383|      1|        assert!(entries.iter().any(|entry| entry.path().extension() == Some("svg".as_ref())));
 5384|      2|        assert!(entries.iter().any(|entry| entry.path().extension() == Some("txt".as_ref())));
                      ^1      ^1             ^1
 5385|      1|    }
 5386|       |
 5387|       |    #[cfg(feature = "mermaid-quickjs")]
 5388|       |    #[test]
 5389|      1|    fn test_mermaid_dump_helpers_empty_dir_env_noop() {
 5390|      1|        let _lock = env_lock();
 5391|      1|        let dir = tempdir().expect("temp dir");
 5392|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_DUMP_DIR", "   ");
 5393|      1|        MermaidWorker::maybe_dump_svg(20, Some("label"), "<svg></svg>");
 5394|      1|        MermaidWorker::maybe_dump_error(21, Some("label"), "err");
 5395|      1|        let entries: Vec<_> = std::fs::read_dir(dir.path())
 5396|      1|            .expect("read dir")
 5397|      1|            .filter_map(|entry| entry.ok())
                                              ^0    ^0
 5398|      1|            .collect();
 5399|      1|        assert!(entries.is_empty());
 5400|      1|    }
 5401|       |
 5402|       |    #[cfg(feature = "mermaid-quickjs")]
 5403|       |    #[test]
 5404|      1|    fn test_mermaid_dump_helpers_invalid_dir_noop() {
 5405|      1|        let _lock = env_lock();
 5406|      1|        let dir = tempdir().expect("temp dir");
 5407|      1|        let file_path = dir.path().join("not_a_dir.txt");
 5408|      1|        std::fs::write(&file_path, "data").expect("write file");
 5409|      1|        let _guard = EnvGuard::set(
 5410|       |            "MDMDVIEW_MERMAID_DUMP_DIR",
 5411|      1|            file_path.to_string_lossy().as_ref(),
 5412|       |        );
 5413|      1|        MermaidWorker::maybe_dump_svg(22, Some("label"), "<svg></svg>");
 5414|      1|        MermaidWorker::maybe_dump_error(23, Some("label"), "err");
 5415|      1|        let entries: Vec<_> = std::fs::read_dir(dir.path())
 5416|      1|            .expect("read dir")
 5417|      1|            .filter_map(|entry| entry.ok())
 5418|      1|            .collect();
 5419|      1|        assert_eq!(entries.len(), 1);
 5420|      1|        assert!(entries[0].path().ends_with("not_a_dir.txt"));
 5421|      1|    }
 5422|       |
 5423|       |    #[cfg(feature = "mermaid-quickjs")]
 5424|       |    #[test]
 5425|      1|    fn test_poll_mermaid_results_handles_variants() {
 5426|      1|        let (result_tx, result_rx) = bounded(10);
 5427|      1|        let renderer = MermaidRenderer {
 5428|      1|            mermaid_textures: RefCell::new(LruCache::new(4)),
 5429|      1|            mermaid_pending: RefCell::new(std::collections::HashSet::new()),
 5430|      1|            mermaid_frame_pending: std::cell::Cell::new(false),
 5431|      1|            mermaid_svg_cache: RefCell::new(LruCache::new(4)),
 5432|      1|            mermaid_errors: RefCell::new(LruCache::new(4)),
 5433|      1|            mermaid_texture_errors: RefCell::new(LruCache::new(4)),
 5434|      1|            mermaid_job_tx: None,
 5435|      1|            mermaid_result_rx: result_rx,
 5436|      1|            worker_handles: Vec::new(),
 5437|      1|        };
 5438|      1|        let ctx = egui::Context::default();
 5439|       |
 5440|      1|        renderer
 5441|      1|            .mermaid_pending
 5442|      1|            .borrow_mut()
 5443|      1|            .insert("k1".to_string());
 5444|      1|        result_tx
 5445|      1|            .send(MermaidResult {
 5446|      1|                svg_key: 1,
 5447|      1|                texture_key: "k1".to_string(),
 5448|      1|                svg: Some("<svg width=\"1\" height=\"1\"></svg>".to_string()),
 5449|      1|                rgba: None,
 5450|      1|                size: None,
 5451|      1|                error: None,
 5452|      1|            })
 5453|      1|            .expect("send svg");
 5454|      1|        assert!(renderer.poll_mermaid_results(&ctx));
 5455|      1|        assert!(renderer.mermaid_svg_cache.borrow_mut().get(&1).is_some());
 5456|       |
 5457|      1|        renderer
 5458|      1|            .mermaid_pending
 5459|      1|            .borrow_mut()
 5460|      1|            .insert("k2".to_string());
 5461|      1|        result_tx
 5462|      1|            .send(MermaidResult {
 5463|      1|                svg_key: 2,
 5464|      1|                texture_key: "k2".to_string(),
 5465|      1|                svg: None,
 5466|      1|                rgba: Some(vec![0, 0, 0, 0]),
 5467|      1|                size: None,
 5468|      1|                error: None,
 5469|      1|            })
 5470|      1|            .expect("send rgba missing size");
 5471|      1|        renderer.poll_mermaid_results(&ctx);
 5472|      1|        assert!(renderer
 5473|      1|            .mermaid_texture_errors
 5474|      1|            .borrow_mut()
 5475|      1|            .get(&"k2".to_string())
 5476|      1|            .is_some());
 5477|       |
 5478|      1|        renderer
 5479|      1|            .mermaid_pending
 5480|      1|            .borrow_mut()
 5481|      1|            .insert("k3".to_string());
 5482|      1|        result_tx
 5483|      1|            .send(MermaidResult {
 5484|      1|                svg_key: 3,
 5485|      1|                texture_key: "k3".to_string(),
 5486|      1|                svg: None,
 5487|      1|                rgba: None,
 5488|      1|                size: None,
 5489|      1|                error: Some("boom".to_string()),
 5490|      1|            })
 5491|      1|            .expect("send error");
 5492|      1|        renderer.poll_mermaid_results(&ctx);
 5493|      1|        assert!(renderer.mermaid_errors.borrow_mut().get(&3).is_some());
 5494|       |
 5495|      1|        renderer
 5496|      1|            .mermaid_pending
 5497|      1|            .borrow_mut()
 5498|      1|            .insert("k4".to_string());
 5499|      1|        result_tx
 5500|      1|            .send(MermaidResult {
 5501|      1|                svg_key: 4,
 5502|      1|                texture_key: "k4".to_string(),
 5503|      1|                svg: Some("<svg width=\"1\" height=\"1\"></svg>".to_string()),
 5504|      1|                rgba: None,
 5505|      1|                size: None,
 5506|      1|                error: Some("oops".to_string()),
 5507|      1|            })
 5508|      1|            .expect("send texture error");
 5509|      1|        renderer.poll_mermaid_results(&ctx);
 5510|      1|        assert!(renderer
 5511|      1|            .mermaid_texture_errors
 5512|      1|            .borrow_mut()
 5513|      1|            .get(&"k4".to_string())
 5514|      1|            .is_some());
 5515|       |
 5516|      1|        renderer
 5517|      1|            .mermaid_pending
 5518|      1|            .borrow_mut()
 5519|      1|            .insert("k5".to_string());
 5520|      1|        result_tx
 5521|      1|            .send(MermaidResult {
 5522|      1|                svg_key: 5,
 5523|      1|                texture_key: "k5".to_string(),
 5524|      1|                svg: None,
 5525|      1|                rgba: Some(vec![255, 255, 255, 255]),
 5526|      1|                size: Some((1, 1)),
 5527|      1|                error: None,
 5528|      1|            })
 5529|      1|            .expect("send rgba with size");
 5530|      1|        renderer.poll_mermaid_results(&ctx);
 5531|      1|        assert!(renderer
 5532|      1|            .mermaid_textures
 5533|      1|            .borrow_mut()
 5534|      1|            .get(&"k5".to_string())
 5535|      1|            .is_some());
 5536|      1|    }
 5537|       |
 5538|       |    #[cfg(feature = "mermaid-quickjs")]
 5539|       |    #[test]
 5540|      1|    fn test_format_js_error_variants() {
 5541|      1|        let rt = rquickjs::Runtime::new().expect("runtime");
 5542|      1|        let ctx = rquickjs::Context::full(&rt).expect("context");
 5543|      1|        ctx.with(|ctx| {
 5544|      1|            let err = ctx.eval::<(), _>("throw new Error('boom')").unwrap_err();
 5545|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5546|      1|            assert!(msg.contains("boom"));
 5547|       |
 5548|      1|            let err = ctx
 5549|      1|                .eval::<(), _>("var e = new Error('match'); e.stack = 'match\\nstack'; throw e;")
 5550|      1|                .unwrap_err();
 5551|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5552|      1|            assert!(msg.contains("match"));
 5553|       |
 5554|      1|            let err = ctx
 5555|      1|                .eval::<(), _>("var e = new Error('note'); e.stack = 'stack only'; throw e;")
 5556|      1|                .unwrap_err();
 5557|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5558|      1|            assert!(!msg.is_empty());
 5559|       |
 5560|      1|            let err = ctx
 5561|      1|                .eval::<(), _>("var e = new Error('blank'); e.stack = ' '; throw e;")
 5562|      1|                .unwrap_err();
 5563|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5564|      1|            assert!(msg.contains("blank"));
 5565|       |
 5566|      1|            let err = ctx
 5567|      1|                .eval::<(), _>("throw ({ stack: 'stack-only-obj' })")
 5568|      1|                .unwrap_err();
 5569|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5570|      1|            assert!(!msg.is_empty());
 5571|       |
 5572|      1|            let err = ctx
 5573|      1|                .eval::<(), _>("throw ({ message: 'message-only-obj' })")
 5574|      1|                .unwrap_err();
 5575|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5576|      1|            assert!(!msg.is_empty());
 5577|       |
 5578|      1|            let err = ctx
 5579|      1|                .eval::<(), _>("var e = new Error(''); e.message = undefined; e.stack = 'stack-only'; throw e;")
 5580|      1|                .unwrap_err();
 5581|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5582|      1|            assert!(msg.contains("stack-only"));
 5583|       |
 5584|      1|            let err = ctx
 5585|      1|                .eval::<(), _>("var e = new Error('solo'); delete e.stack; throw e;")
 5586|      1|                .unwrap_err();
 5587|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5588|      1|            assert!(msg.contains("solo"));
 5589|       |
 5590|      1|            let err = ctx
 5591|      1|                .eval::<(), _>("var e = new Error('solo2'); e.stack = undefined; throw e;")
 5592|      1|                .unwrap_err();
 5593|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5594|      1|            assert!(msg.contains("solo2"));
 5595|       |
 5596|      1|            let err = ctx
 5597|      1|                .eval::<(), _>("var e = new Error('zap'); e.stack = ''; throw e;")
 5598|      1|                .unwrap_err();
 5599|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5600|      1|            assert!(msg.contains("zap"));
 5601|       |
 5602|      1|            let err = ctx.eval::<(), _>("throw 'stringy'").unwrap_err();
 5603|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5604|      1|            assert_eq!(msg, "stringy");
 5605|       |
 5606|      1|            let err = ctx.eval::<(), _>("throw 42").unwrap_err();
 5607|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5608|      1|            assert_eq!(msg, "42");
 5609|       |
 5610|      1|            let err = ctx.eval::<(), _>("throw 3.5").unwrap_err();
 5611|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5612|      1|            assert!(msg.contains("3.5"));
 5613|       |
 5614|      1|            let err = ctx.eval::<(), _>("throw true").unwrap_err();
 5615|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5616|      1|            assert_eq!(msg, "true");
 5617|       |
 5618|      1|            let msg = MermaidWorker::format_js_error(&ctx, rquickjs::Error::Unknown);
 5619|      1|            assert!(!msg.is_empty());
 5620|       |
 5621|      1|            let err = ctx.eval::<(), _>("throw ({})").unwrap_err();
 5622|      1|            let msg = MermaidWorker::format_js_error(&ctx, err);
 5623|      1|            assert!(!msg.is_empty());
 5624|      1|        });
 5625|      1|    }
 5626|       |
 5627|       |    struct EnvGuard {
 5628|       |        key: &'static str,
 5629|       |        original: Option<String>,
 5630|       |    }
 5631|       |
 5632|       |    impl EnvGuard {
 5633|     43|        fn set(key: &'static str, value: &str) -> Self {
 5634|     43|            let original = std::env::var(key).ok();
 5635|     43|            std::env::set_var(key, value);
 5636|     43|            Self { key, original }
 5637|     43|        }
 5638|       |    }
 5639|       |
 5640|       |    impl Drop for EnvGuard {
 5641|     43|        fn drop(&mut self) {
 5642|     43|            if let Some(value) = &self.original {
                                      ^2
  ------------------
  |  Branch (5642:20): [True: 2, False: 41]
  ------------------
 5643|      2|                std::env::set_var(self.key, value);
 5644|     41|            } else {
 5645|     41|                std::env::remove_var(self.key);
 5646|     41|            }
 5647|     43|        }
 5648|       |    }
 5649|       |
 5650|       |    #[test]
 5651|      1|    fn test_parse_hex_color_and_mermaid_bg_fill() {
 5652|      1|        let _lock = env_lock();
 5653|      1|        assert_eq!(
 5654|      1|            MermaidRenderer::parse_hex_color("#ff00ff"),
 5655|       |            Some([255, 0, 255, 255])
 5656|       |        );
 5657|      1|        assert_eq!(
 5658|      1|            MermaidRenderer::parse_hex_color("11223344"),
 5659|       |            Some([17, 34, 51, 68])
 5660|       |        );
 5661|      1|        assert!(MermaidRenderer::parse_hex_color("bad").is_none());
 5662|       |
 5663|       |        {
 5664|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG_COLOR", "#010203");
 5665|      1|            assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([1, 2, 3, 255]));
 5666|       |        }
 5667|       |
 5668|       |        {
 5669|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "transparent");
 5670|      1|            assert_eq!(MermaidRenderer::mermaid_bg_fill(), None);
 5671|       |        }
 5672|       |
 5673|       |        {
 5674|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "dark");
 5675|      1|            assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([20, 20, 20, 255]));
 5676|       |        }
 5677|      1|    }
 5678|       |
 5679|       |    #[test]
 5680|      1|    fn test_env_guard_restores_original_value() {
 5681|      1|        let _lock = env_lock();
 5682|      1|        std::env::set_var("MDMDVIEW_MERMAID_PATCH_DEBUG", "before");
 5683|       |        {
 5684|      1|            let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "after");
 5685|      1|            assert_eq!(
 5686|      1|                std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG")
 5687|      1|                    .ok()
 5688|      1|                    .as_deref(),
 5689|       |                Some("after")
 5690|       |            );
 5691|       |        }
 5692|      1|        assert_eq!(
 5693|      1|            std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG")
 5694|      1|                .ok()
 5695|      1|                .as_deref(),
 5696|       |            Some("before")
 5697|       |        );
 5698|      1|        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
 5699|      1|    }
 5700|       |
 5701|       |    #[test]
 5702|      1|    fn test_mermaid_bg_fill_invalid_color_falls_back() {
 5703|      1|        let _lock = env_lock();
 5704|      1|        let _guard_color = EnvGuard::set("MDMDVIEW_MERMAID_BG_COLOR", "bad");
 5705|      1|        let _guard_mode = EnvGuard::set("MDMDVIEW_MERMAID_BG", "dark");
 5706|      1|        assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([20, 20, 20, 255]));
 5707|      1|    }
 5708|       |
 5709|       |    #[test]
 5710|      1|    fn test_mermaid_bg_fill_invalid_theme_color_uses_default() {
 5711|      1|        let _lock = env_lock();
 5712|      1|        let _guard_mode = EnvGuard::set("MDMDVIEW_MERMAID_BG", "theme");
 5713|      1|        let _guard_bkg = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "bad");
 5714|      1|        assert_eq!(
 5715|      1|            MermaidRenderer::mermaid_bg_fill(),
 5716|       |            Some([255, 248, 219, 255])
 5717|       |        );
 5718|      1|    }
 5719|       |
 5720|       |    #[test]
 5721|      1|    fn test_mermaid_bg_key_and_scale_bucket() {
 5722|      1|        assert_eq!(MermaidRenderer::mermaid_bg_key(None), "none");
 5723|      1|        assert_eq!(
 5724|      1|            MermaidRenderer::mermaid_bg_key(Some([1, 2, 3, 4])),
 5725|       |            "01020304"
 5726|       |        );
 5727|       |
 5728|      1|        let factor = MermaidRenderer::MERMAID_SCALE_BUCKET_FACTOR;
 5729|      1|        assert_eq!(
 5730|      1|            MermaidRenderer::scale_bucket(0.1),
 5731|      1|            (0.5 * factor).round() as u32
 5732|       |        );
 5733|      1|        assert_eq!(
 5734|      1|            MermaidRenderer::scale_bucket(10.0),
 5735|      1|            (4.0 * factor).round() as u32
 5736|       |        );
 5737|      1|    }
 5738|       |
 5739|       |    #[test]
 5740|      1|    fn test_mermaid_hash_str_stable_and_distinct() {
 5741|      1|        let a = MermaidRenderer::hash_str("alpha");
 5742|      1|        let b = MermaidRenderer::hash_str("alpha");
 5743|      1|        let c = MermaidRenderer::hash_str("beta");
 5744|      1|        assert_eq!(a, b);
 5745|      1|        assert_ne!(a, c);
 5746|      1|    }
 5747|       |
 5748|       |    #[test]
 5749|      1|    fn test_mermaid_bg_fill_light_mode() {
 5750|      1|        let _lock = env_lock();
 5751|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG", "light");
 5752|      1|        assert_eq!(
 5753|      1|            MermaidRenderer::mermaid_bg_fill(),
 5754|       |            Some([255, 255, 255, 255])
 5755|       |        );
 5756|      1|    }
 5757|       |
 5758|       |    #[test]
 5759|      1|    fn test_mermaid_bg_fill_color_override() {
 5760|      1|        let _lock = env_lock();
 5761|      1|        std::env::remove_var("MDMDVIEW_MERMAID_BG");
 5762|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_BG_COLOR", "#11223344");
 5763|      1|        assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([17, 34, 51, 68]));
 5764|      1|    }
 5765|       |
 5766|       |    #[test]
 5767|      1|    fn test_mermaid_bg_fill_theme_fallback() {
 5768|      1|        let _lock = env_lock();
 5769|      1|        let _guard_mode = EnvGuard::set("MDMDVIEW_MERMAID_BG", "theme");
 5770|      1|        let _guard_bkg = EnvGuard::set("MDMDVIEW_MERMAID_MAIN_BKG", "#010203");
 5771|      1|        assert_eq!(MermaidRenderer::mermaid_bg_fill(), Some([1, 2, 3, 255]));
 5772|      1|    }
 5773|       |
 5774|       |    #[test]
 5775|      1|    fn test_render_block_off_and_embedded_without_feature() {
 5776|      1|        let _lock = env_lock();
 5777|      1|        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
 5778|      1|        let renderer = MermaidRenderer::new();
 5779|      1|        let ctx = egui::Context::default();
 5780|      1|        let input = egui::RawInput {
 5781|      1|            screen_rect: Some(egui::Rect::from_min_size(
 5782|      1|                egui::pos2(0.0, 0.0),
 5783|      1|                egui::vec2(800.0, 600.0),
 5784|      1|            )),
 5785|      1|            ..Default::default()
 5786|      1|        };
 5787|       |
 5788|      1|        let mut rendered = true;
 5789|      1|        let _ = ctx.run(input.clone(), |ctx| {
 5790|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 5791|      1|                rendered = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 5792|      1|            });
 5793|      1|        });
 5794|      1|        assert!(rendered);
 5795|       |
 5796|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "off");
 5797|      1|        let renderer = MermaidRenderer::new();
 5798|      1|        let mut rendered_off = true;
 5799|      1|        let _ = ctx.run(input.clone(), |ctx| {
 5800|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 5801|      1|                rendered_off = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 5802|      1|            });
 5803|      1|        });
 5804|      1|        assert!(rendered_off);
 5805|       |
 5806|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 5807|      1|        let renderer = MermaidRenderer::new();
 5808|      1|        let mut rendered_embedded = true;
 5809|      1|        let _ = ctx.run(input, |ctx| {
 5810|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 5811|      1|                rendered_embedded = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 5812|      1|            });
 5813|      1|        });
 5814|      1|        assert!(rendered_embedded);
 5815|      1|    }
 5816|       |
 5817|       |    #[cfg(feature = "mermaid-quickjs")]
 5818|       |    #[test]
 5819|      1|    fn test_render_block_width_fallback_for_small_ui() {
 5820|      1|        let _lock = env_lock();
 5821|      1|        std::env::remove_var("MDMDVIEW_MERMAID_RENDERER");
 5822|      1|        let renderer = MermaidRenderer::new();
 5823|      1|        let ctx = egui::Context::default();
 5824|      1|        let input = egui::RawInput {
 5825|      1|            screen_rect: Some(egui::Rect::from_min_size(
 5826|      1|                egui::pos2(0.0, 0.0),
 5827|      1|                egui::vec2(800.0, 600.0),
 5828|      1|            )),
 5829|      1|            ..Default::default()
 5830|      1|        };
 5831|       |
 5832|      1|        let mut rendered = true;
 5833|      1|        let _ = ctx.run(input, |ctx| {
 5834|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 5835|      1|                ui.allocate_ui_with_layout(
 5836|      1|                    egui::vec2(20.0, 200.0),
 5837|      1|                    egui::Layout::top_down(egui::Align::Min),
 5838|      1|                    |ui| {
 5839|      1|                        rendered = renderer.render_block(ui, "%% comment", 1.0, 14.0);
 5840|      1|                    },
 5841|       |                );
 5842|      1|            });
 5843|      1|        });
 5844|      1|        assert!(rendered);
 5845|      1|    }
 5846|       |
 5847|       |    #[cfg(feature = "mermaid-quickjs")]
 5848|       |    #[test]
 5849|      1|    fn test_render_block_uses_cached_texture_scales() {
 5850|      1|        let _lock = env_lock();
 5851|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 5852|      1|        let (_result_tx, result_rx) = bounded(1);
 5853|      1|        let renderer = test_renderer_with_channels(None, result_rx);
 5854|      1|        let ctx = egui::Context::default();
 5855|      1|        let input = egui::RawInput {
 5856|      1|            screen_rect: Some(egui::Rect::from_min_size(
 5857|      1|                egui::pos2(0.0, 0.0),
 5858|      1|                egui::vec2(240.0, 160.0),
 5859|      1|            )),
 5860|      1|            ..Default::default()
 5861|      1|        };
 5862|      1|        let code = "graph TD; A-->B;";
 5863|      1|        let mut rendered_large = false;
 5864|      1|        let mut rendered_small = false;
 5865|       |
 5866|      1|        let _ = ctx.run(input, |ctx| {
 5867|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 5868|      1|                let image = egui::ColorImage::new([2, 2], Color32::WHITE);
 5869|      1|                let texture =
 5870|      1|                    ui.ctx()
 5871|      1|                        .load_texture("mermaid-test", image, egui::TextureOptions::default());
 5872|      1|                let svg_key = MermaidRenderer::hash_str(code);
 5873|      2|                let make_key = |ui: &egui::Ui| {
                                  ^1
 5874|      2|                    let width_bucket = MermaidRenderer::width_bucket(ui.available_width());
 5875|      2|                    let scale_bucket = MermaidRenderer::scale_bucket(1.0);
 5876|      2|                    let bg = MermaidRenderer::mermaid_bg_fill();
 5877|      2|                    MermaidRenderer::texture_key(svg_key, width_bucket, scale_bucket, bg)
 5878|      2|                };
 5879|       |
 5880|      1|                let texture_key = make_key(ui);
 5881|      1|                renderer.mermaid_textures.borrow_mut().insert(
 5882|      1|                    texture_key.clone(),
 5883|      1|                    MermaidTextureEntry {
 5884|      1|                        texture: texture.clone(),
 5885|      1|                        size: [400, 200],
 5886|      1|                    },
 5887|      1|                );
 5888|      1|                rendered_large = renderer.render_block(ui, code, 1.0, 14.0);
 5889|       |
 5890|      1|                let texture_key = make_key(ui);
 5891|      1|                renderer.mermaid_textures.borrow_mut().insert(
 5892|      1|                    texture_key,
 5893|      1|                    MermaidTextureEntry {
 5894|      1|                        texture,
 5895|      1|                        size: [20, 10],
 5896|      1|                    },
 5897|      1|                );
 5898|      1|                rendered_small = renderer.render_block(ui, code, 1.0, 14.0);
 5899|      1|            });
 5900|      1|        });
 5901|       |
 5902|      1|        assert!(rendered_large);
 5903|      1|        assert!(rendered_small);
 5904|      1|    }
 5905|       |
 5906|       |    #[cfg(feature = "mermaid-quickjs")]
 5907|       |    #[test]
 5908|      1|    fn test_render_block_reports_cached_error() {
 5909|      1|        let _lock = env_lock();
 5910|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 5911|      1|        let (_result_tx, result_rx) = bounded(1);
 5912|      1|        let renderer = test_renderer_with_channels(None, result_rx);
 5913|      1|        let code = "graph TD; A-->B;";
 5914|      1|        let svg_key = MermaidRenderer::hash_str(code);
 5915|      1|        renderer
 5916|      1|            .mermaid_errors
 5917|      1|            .borrow_mut()
 5918|      1|            .insert(svg_key, "boom".to_string());
 5919|      1|        let ctx = egui::Context::default();
 5920|      1|        let input = egui::RawInput {
 5921|      1|            screen_rect: Some(egui::Rect::from_min_size(
 5922|      1|                egui::pos2(0.0, 0.0),
 5923|      1|                egui::vec2(240.0, 160.0),
 5924|      1|            )),
 5925|      1|            ..Default::default()
 5926|      1|        };
 5927|      1|        let mut rendered = false;
 5928|      1|        let _ = ctx.run(input, |ctx| {
 5929|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 5930|      1|                rendered = renderer.render_block(ui, code, 1.0, 14.0);
 5931|      1|            });
 5932|      1|        });
 5933|      1|        assert!(rendered);
 5934|      1|    }
 5935|       |
 5936|       |    #[cfg(feature = "mermaid-quickjs")]
 5937|       |    #[test]
 5938|      1|    fn test_render_block_queue_full_sets_waiting() {
 5939|      1|        let _lock = env_lock();
 5940|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 5941|      1|        let (job_tx, job_rx) = bounded(1);
 5942|      1|        let (_result_tx, result_rx) = bounded(1);
 5943|      1|        let renderer = test_renderer_with_channels(Some(job_tx.clone()), result_rx);
 5944|      1|        let request = MermaidRequest {
 5945|      1|            svg_key: 1,
 5946|      1|            texture_key: "full".to_string(),
 5947|      1|            code: Some("graph TD; A-->B;".to_string()),
 5948|      1|            svg: None,
 5949|      1|            width_bucket: 32,
 5950|      1|            scale_bucket: MermaidRenderer::scale_bucket(1.0),
 5951|      1|            viewport_width: 120,
 5952|      1|            viewport_height: 120,
 5953|      1|            bg: MermaidRenderer::mermaid_bg_fill(),
 5954|      1|        };
 5955|      1|        job_tx.send(request).expect("fill queue");
 5956|       |
 5957|      1|        let ctx = egui::Context::default();
 5958|      1|        let input = egui::RawInput {
 5959|      1|            screen_rect: Some(egui::Rect::from_min_size(
 5960|      1|                egui::pos2(0.0, 0.0),
 5961|      1|                egui::vec2(240.0, 160.0),
 5962|      1|            )),
 5963|      1|            ..Default::default()
 5964|      1|        };
 5965|      1|        let mut rendered = false;
 5966|      1|        let _ = ctx.run(input, |ctx| {
 5967|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 5968|      1|                rendered = renderer.render_block(ui, "graph TD; A-->B;", 1.0, 14.0);
 5969|      1|            });
 5970|      1|        });
 5971|      1|        assert!(rendered);
 5972|      1|        assert!(renderer.mermaid_frame_pending.get());
 5973|      1|        drop(job_rx);
 5974|      1|    }
 5975|       |
 5976|       |    #[cfg(feature = "mermaid-quickjs")]
 5977|       |    #[test]
 5978|      1|    fn test_render_block_disconnected_queue_sets_error() {
 5979|      1|        let _lock = env_lock();
 5980|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 5981|      1|        let (_result_tx, result_rx) = bounded(1);
 5982|      1|        let renderer = test_renderer_with_channels(None, result_rx);
 5983|      1|        let ctx = egui::Context::default();
 5984|      1|        let input = egui::RawInput {
 5985|      1|            screen_rect: Some(egui::Rect::from_min_size(
 5986|      1|                egui::pos2(0.0, 0.0),
 5987|      1|                egui::vec2(240.0, 160.0),
 5988|      1|            )),
 5989|      1|            ..Default::default()
 5990|      1|        };
 5991|      1|        let code = "graph TD; A-->B;";
 5992|      1|        let mut rendered = false;
 5993|      1|        let _ = ctx.run(input, |ctx| {
 5994|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 5995|      1|                rendered = renderer.render_block(ui, code, 1.0, 14.0);
 5996|      1|            });
 5997|      1|        });
 5998|      1|        assert!(rendered);
 5999|      1|        let svg_key = MermaidRenderer::hash_str(code);
 6000|      1|        assert!(renderer.mermaid_errors.borrow_mut().get(&svg_key).is_some());
 6001|      1|    }
 6002|       |
 6003|       |    #[cfg(feature = "mermaid-quickjs")]
 6004|       |    #[test]
 6005|      1|    fn test_render_block_pending_and_width_fallback() {
 6006|      1|        let _lock = env_lock();
 6007|      1|        let _guard_renderer = EnvGuard::set("MDMDVIEW_MERMAID_RENDERER", "embedded");
 6008|      1|        let _guard_log = EnvGuard::set("MDMDVIEW_MERMAID_LOG_WIDTH", "1");
 6009|      1|        let (job_tx, job_rx) = bounded(2);
 6010|      1|        let (result_tx, result_rx) = bounded(2);
 6011|      1|        let renderer = test_renderer_with_channels(Some(job_tx), result_rx);
 6012|      1|        result_tx
 6013|      1|            .send(MermaidResult {
 6014|      1|                svg_key: 99,
 6015|      1|                texture_key: "other".to_string(),
 6016|      1|                svg: Some("<svg width=\"1\" height=\"1\"></svg>".to_string()),
 6017|      1|                rgba: None,
 6018|      1|                size: None,
 6019|      1|                error: None,
 6020|      1|            })
 6021|      1|            .expect("send svg");
 6022|       |
 6023|      1|        let ctx = egui::Context::default();
 6024|      1|        let input = egui::RawInput {
 6025|      1|            screen_rect: Some(egui::Rect::from_min_size(
 6026|      1|                egui::pos2(0.0, 0.0),
 6027|      1|                egui::vec2(200.0, 120.0),
 6028|      1|            )),
 6029|      1|            ..Default::default()
 6030|      1|        };
 6031|      1|        let code = "timeline\n  title Demo";
 6032|      1|        let mut rendered_first = false;
 6033|      1|        let mut rendered_second = false;
 6034|      1|        let _ = ctx.run(input, |ctx| {
 6035|      1|            egui::CentralPanel::default().show(ctx, |ui| {
 6036|      1|                let rect =
 6037|      1|                    egui::Rect::from_min_size(egui::pos2(0.0, 0.0), egui::vec2(10.0, 80.0));
 6038|      1|                ui.allocate_ui_at_rect(rect, |ui| {
 6039|      1|                    rendered_first = renderer.render_block(ui, code, 1.0, 14.0);
 6040|      1|                    rendered_second = renderer.render_block(ui, code, 1.0, 14.0);
 6041|      1|                });
 6042|      1|            });
 6043|      1|        });
 6044|      1|        assert!(rendered_first);
 6045|      1|        assert!(rendered_second);
 6046|      1|        drop(job_rx);
 6047|      1|    }
 6048|       |
 6049|       |    #[test]
 6050|      1|    fn test_mermaid_cache_insert_existing_key_and_empty_order() {
 6051|      1|        let mut cache = LruCache::new(1);
 6052|      1|        cache.insert(1u8, "one".to_string());
 6053|      1|        cache.insert(1u8, "uno".to_string());
 6054|      1|        assert_eq!(cache.get(&1), Some("uno".to_string()));
 6055|       |
 6056|      1|        cache.entries.clear();
 6057|      1|        cache.entries.insert(2u8, "two".to_string());
 6058|      1|        cache.order.clear();
 6059|      1|        cache.insert(3u8, "three".to_string());
 6060|      1|        assert_eq!(cache.len(), 2);
 6061|      1|    }
 6062|       |
 6063|       |    #[test]
 6064|      1|    fn test_mermaid_has_pending_default_false() {
 6065|      1|        let renderer = MermaidRenderer::new();
 6066|      1|        assert!(!renderer.has_pending());
 6067|      1|    }
 6068|       |
 6069|       |    #[cfg(feature = "mermaid-quickjs")]
 6070|       |    #[test]
 6071|      1|    fn test_mermaid_has_pending_true_for_frame_or_queue() {
 6072|      1|        let renderer = MermaidRenderer::new();
 6073|      1|        renderer.mermaid_frame_pending.set(true);
 6074|      1|        assert!(renderer.has_pending());
 6075|      1|        renderer.mermaid_frame_pending.set(false);
 6076|      1|        renderer
 6077|      1|            .mermaid_pending
 6078|      1|            .borrow_mut()
 6079|      1|            .insert("pending".to_string());
 6080|      1|        assert!(renderer.has_pending());
 6081|      1|    }
 6082|       |
 6083|       |    #[cfg(feature = "mermaid-quickjs")]
 6084|       |    #[test]
 6085|      1|    fn test_fix_journey_section_text_fill_adds_fill() {
 6086|      1|        let input = r#"<svg><text class="journey-section section-type-0" x="0">Plan</text></svg>"#;
 6087|      1|        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
 6088|      1|            .expect("journey text updated");
 6089|      1|        assert!(output.contains("class=\"journey-section section-type-0\""));
 6090|      1|        assert!(output.contains("fill:#112233"));
 6091|      1|    }
 6092|       |
 6093|       |    #[cfg(feature = "mermaid-quickjs")]
 6094|       |    #[test]
 6095|      1|    fn test_fix_journey_section_text_overwrites_fill_in_style() {
 6096|      1|        let input = r#"<svg><text class="journey-section" style="fill:#000000;stroke:#fff" x="0">Plan</text></svg>"#;
 6097|      1|        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
 6098|      1|            .expect("journey text updated");
 6099|      1|        assert!(output.contains("fill:#112233"));
 6100|      1|        assert!(!output.contains("fill:#000000"));
 6101|      1|    }
 6102|       |
 6103|       |    #[cfg(feature = "mermaid-quickjs")]
 6104|       |    #[test]
 6105|      1|    fn test_fix_journey_section_text_skips_empty_style_parts() {
 6106|      1|        let input = r#"<svg><text class="journey-section" style="fill:#000000;;stroke:#fff" x="0">Plan</text></svg>"#;
 6107|      1|        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
 6108|      1|            .expect("journey text updated");
 6109|      1|        assert!(output.contains("fill:#112233"));
 6110|      1|        assert!(output.contains("stroke:#fff"));
 6111|      1|    }
 6112|       |
 6113|       |    #[cfg(feature = "mermaid-quickjs")]
 6114|       |    #[test]
 6115|      1|    fn test_fix_journey_section_text_noop_without_marker() {
 6116|      1|        let input = r#"<svg><text class="label" x="0">Plan</text></svg>"#;
 6117|      1|        assert!(MermaidWorker::fix_journey_section_text(input, "#112233").is_none());
 6118|      1|    }
 6119|       |
 6120|       |    #[cfg(feature = "mermaid-quickjs")]
 6121|       |    #[test]
 6122|      1|    fn test_fix_journey_section_text_handles_non_section_tag() {
 6123|      1|        let input = r#"<svg><text class="label">A</text><text class="journey-section" style="fill:#000">B</text></svg>"#;
 6124|      1|        let output = MermaidWorker::fix_journey_section_text(input, "#112233")
 6125|      1|            .expect("journey text updated");
 6126|      1|        assert!(output.contains("class=\"label\""));
 6127|      1|        assert!(output.contains("fill:#112233"));
 6128|      1|    }
 6129|       |
 6130|       |    #[cfg(feature = "mermaid-quickjs")]
 6131|       |    #[test]
 6132|      1|    fn test_fix_journey_section_text_style_missing_quote_returns_none() {
 6133|      1|        let input = r#"<svg><text class="journey-section" style="fill:#000>Plan</text></svg>"#;
 6134|      1|        assert!(MermaidWorker::fix_journey_section_text(input, "#112233").is_none());
 6135|      1|    }
 6136|       |
 6137|       |    #[cfg(feature = "mermaid-quickjs")]
 6138|       |    #[test]
 6139|      1|    fn test_fix_state_end_circles_swaps_radii() {
 6140|      1|        let input = r#"<svg><g id="state-root_end-0"><circle class="state-end" r="5" width="10" height="10"></circle><circle class="state-start" r="7" width="14" height="14"></circle></g></svg>"#;
 6141|      1|        let output =
 6142|      1|            MermaidWorker::fix_state_end_circles(input).expect("state end circles updated");
 6143|      1|        assert!(output.contains("class=\"state-end\" r=\"7\""));
 6144|      1|        assert!(output.contains("class=\"end-state-inner\" r=\"5\""));
 6145|      1|        assert!(output.contains("class=\"state-end\" r=\"7\" width=\"14\" height=\"14\""));
 6146|      1|        assert!(output.contains("class=\"end-state-inner\" r=\"5\" width=\"10\" height=\"10\""));
 6147|      1|    }
 6148|       |
 6149|       |    #[cfg(feature = "mermaid-quickjs")]
 6150|       |    #[test]
 6151|      1|    fn test_fix_state_end_circles_swaps_radii_when_start_first() {
 6152|      1|        let input = r#"<svg><g id="state-root_end-0"><circle class="state-start" r="7" width="14" height="14"></circle><circle class="state-end" r="5" width="10" height="10"></circle></g></svg>"#;
 6153|      1|        let output =
 6154|      1|            MermaidWorker::fix_state_end_circles(input).expect("state end circles updated");
 6155|      1|        assert!(output.contains("end-state-inner"));
 6156|      1|        assert!(output.contains("class=\"state-end\" r=\"7\""));
 6157|      1|    }
 6158|       |
 6159|       |    #[cfg(feature = "mermaid-quickjs")]
 6160|       |    #[test]
 6161|      1|    fn test_fix_state_end_circles_noop_without_marker() {
 6162|      1|        let input = r#"<svg><g><circle class="state-start" r="7"></circle></g></svg>"#;
 6163|      1|        assert!(MermaidWorker::fix_state_end_circles(input).is_none());
 6164|      1|    }
 6165|       |
 6166|       |    #[cfg(feature = "mermaid-quickjs")]
 6167|       |    #[test]
 6168|      1|    fn test_fix_state_end_circles_noop_when_radii_ordered() {
 6169|      1|        let input = r#"<svg><g id="state-root_end-0"><circle class="state-end" r="7"></circle><circle class="state-start" r="5"></circle></g></svg>"#;
 6170|      1|        assert!(MermaidWorker::fix_state_end_circles(input).is_none());
 6171|      1|    }
 6172|       |
 6173|       |    #[cfg(feature = "mermaid-quickjs")]
 6174|       |    #[test]
 6175|      1|    fn test_fix_state_end_circles_skips_non_end_group() {
 6176|      1|        let input = r#"<svg><g id="state-root-0"><circle class="state-end" r="5"></circle></g><g id="state-root_end-0"><circle class="state-end" r="5" width="10" height="10"></circle><circle class="state-start" r="7" width="14" height="14"></circle></g></svg>"#;
 6177|      1|        let output =
 6178|      1|            MermaidWorker::fix_state_end_circles(input).expect("state end circles updated");
 6179|      1|        assert!(output.contains("state-root-0"));
 6180|      1|        assert!(output.contains("end-state-inner"));
 6181|      1|    }
 6182|       |
 6183|       |    #[cfg(feature = "mermaid-quickjs")]
 6184|       |    #[test]
 6185|      1|    fn test_mindmap_edge_trim_uses_min_radius() {
 6186|      1|        let dx_idx = MERMAID_DOM_SHIM
 6187|      1|            .find("var dx = t_pos.x - s_pos.x")
 6188|      1|            .expect("mindmap dx computed");
 6189|      1|        let radius_idx = MERMAID_DOM_SHIM
 6190|      1|            .find("var s_radius = __mdmdview_rect_intersection")
 6191|      1|            .expect("mindmap radius computed");
 6192|      1|        assert!(dx_idx < radius_idx);
 6193|      1|    }
 6194|       |
 6195|       |    #[cfg(feature = "mermaid-quickjs")]
 6196|       |    #[test]
 6197|      1|    fn test_mindmap_edge_overlap_padding_present() {
 6198|      1|        assert!(MERMAID_DOM_SHIM.contains("var overlap = -2"));
 6199|      1|        assert!(MERMAID_DOM_SHIM.contains("var max_total = len * 0.95"));
 6200|      1|    }
 6201|       |
 6202|       |    #[cfg(feature = "mermaid-quickjs")]
 6203|       |    #[test]
 6204|      1|    fn test_flatten_svg_switches_removes_foreignobject() {
 6205|      1|        let input = r#"<svg><switch><foreignObject><div>Plan</div></foreignObject><text>Plan</text></switch></svg>"#;
 6206|      1|        let output =
 6207|      1|            MermaidWorker::flatten_svg_switches(input).expect("switch flattened");
 6208|      1|        assert!(!output.contains("<switch"));
 6209|      1|        assert!(!output.contains("foreignObject"));
 6210|      1|        assert!(output.contains("<text>Plan</text>"));
 6211|      1|    }
 6212|       |
 6213|       |    #[cfg(feature = "mermaid-quickjs")]
 6214|       |    #[test]
 6215|      1|    fn test_mermaid_dom_shim_clusters_not_labelish() {
 6216|      1|        assert!(MERMAID_DOM_SHIM.contains("has_class(node, 'clusters')"));
 6217|      1|    }
 6218|       |
 6219|       |    #[cfg(feature = "mermaid-quickjs")]
 6220|       |    #[test]
 6221|      1|    fn test_fix_er_attribute_fills_inlines_colors() {
 6222|      1|        let input = r#"<svg><rect class="er attributeBoxOdd"></rect><rect class="er attributeBoxEven"></rect></svg>"#;
 6223|      1|        let output =
 6224|      1|            MermaidWorker::fix_er_attribute_fills(input).expect("er fills updated");
 6225|      1|        assert!(output.contains("attributeBoxOdd\" fill=\"#ffffff\""));
 6226|      1|        assert!(output.contains("attributeBoxEven\" fill=\"#f2f2f2\""));
 6227|      1|    }
 6228|       |
 6229|       |    #[cfg(feature = "mermaid-quickjs")]
 6230|       |    #[test]
 6231|      1|    fn test_fix_er_attribute_fills_noop_without_markers() {
 6232|      1|        let input = r#"<svg><rect class="er"></rect></svg>"#;
 6233|      1|        assert!(MermaidWorker::fix_er_attribute_fills(input).is_none());
 6234|      1|    }
 6235|       |
 6236|       |    #[cfg(feature = "mermaid-quickjs")]
 6237|       |    #[test]
 6238|      1|    fn test_fix_er_attribute_fills_noop_when_fill_matches() {
 6239|      1|        let input = r##"<svg><rect class="er attributeBoxOdd" fill="#ffffff"></rect></svg>"##;
 6240|      1|        assert!(MermaidWorker::fix_er_attribute_fills(input).is_none());
 6241|      1|    }
 6242|       |
 6243|       |    #[cfg(feature = "mermaid-quickjs")]
 6244|       |    #[test]
 6245|      1|    fn test_flatten_svg_switches_noop_without_switch() {
 6246|      1|        let input = r#"<svg><text>Plan</text></svg>"#;
 6247|      1|        assert!(MermaidWorker::flatten_svg_switches(input).is_none());
 6248|      1|    }
 6249|       |
 6250|       |    #[cfg(feature = "mermaid-quickjs")]
 6251|       |    #[test]
 6252|      1|    fn test_flatten_svg_switches_handles_missing_close() {
 6253|      1|        let input = r#"<svg><switch><text>Plan</text></svg>"#;
 6254|      1|        assert!(MermaidWorker::flatten_svg_switches(input).is_none());
 6255|      1|    }
 6256|       |
 6257|       |    #[cfg(feature = "mermaid-quickjs")]
 6258|       |    #[test]
 6259|      1|    fn test_flatten_svg_switches_missing_foreign_object_close() {
 6260|      1|        let input =
 6261|      1|            r#"<svg><switch><foreignObject><div>Plan</div></switch><text>After</text></svg>"#;
 6262|      1|        let output = MermaidWorker::flatten_svg_switches(input).expect("switch flattened");
 6263|      1|        assert!(output.contains("<text>After</text>"));
 6264|      1|    }
 6265|       |
 6266|       |    #[cfg(feature = "mermaid-quickjs")]
 6267|       |    #[test]
 6268|      1|    fn test_patch_mermaid_js_applies_expected_replacements() {
 6269|      1|        let js = concat!(
 6270|       |            "var hD=wRe();",
 6271|       |            "FY.prototype={constructor:FY,appendChild:function(i){return this._parent.insertBefore(i,this._next)},insertBefore:function(i,s){return this._parent.insertBefore(i,s)},querySelector:function(i){return this._parent.querySelector(i)},querySelectorAll:function(i){return this._parent.querySelectorAll(i)}};",
 6272|       |            "function FY(i,s){this.ownerDocument=i.ownerDocument,this.namespaceURI=i.namespaceURI,this._next=null,this._parent=i,this.__data__=s}",
 6273|       |            "u.text().split(/(\\s+|<br>)/).reverse()",
 6274|       |            "p=fWe({container:document.getElementById(\"cy\"),style:[{selector:\"edge\",style:{\"curve-style\":\"bezier\"}}]});",
 6275|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run(),p.ready(v=>{Xe.info(\"Ready\",v),u(p)})",
 6276|       |            "const se=_.node().getBBox();"
 6277|       |        );
 6278|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 6279|      1|        assert!(output.contains("sanitize:function"));
 6280|      1|        assert!(output.contains("document.body"));
 6281|      1|        assert!(output.contains("String(typeof u.text"));
 6282|      1|        assert!(output.contains("__mdmdview_cytoscape_stub"));
 6283|      1|        assert!(output.contains("breadthfirst"));
 6284|      1|        assert!(output.contains("se.width=Math.max"));
 6285|      1|    }
 6286|       |
 6287|       |    #[cfg(feature = "mermaid-quickjs")]
 6288|       |    #[test]
 6289|      1|    fn test_patch_mermaid_js_applies_mindmap_layout_fallback() {
 6290|      1|        let js = "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 6291|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 6292|      1|        assert!(output.contains("breadthfirst"));
 6293|      1|    }
 6294|       |
 6295|       |    #[cfg(feature = "mermaid-quickjs")]
 6296|       |    #[test]
 6297|      1|    fn test_patch_mermaid_js_debug_paths_without_targets() {
 6298|      1|        let _lock = env_lock();
 6299|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
 6300|      1|        let js = "console.log('no targets here');";
 6301|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 6302|      1|        assert_eq!(output, js);
 6303|      1|    }
 6304|       |
 6305|       |    #[cfg(feature = "mermaid-quickjs")]
 6306|       |    #[test]
 6307|      1|    fn test_patch_mermaid_js_debug_false_branch() {
 6308|      1|        let _lock = env_lock();
 6309|      1|        let previous = std::env::var("MDMDVIEW_MERMAID_PATCH_DEBUG").ok();
 6310|      1|        std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
 6311|      1|        let js = "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 6312|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 6313|      1|        assert!(output.contains("breadthfirst"));
 6314|      1|        if let Some(value) = previous {
                                  ^0
  ------------------
  |  Branch (6314:16): [True: 0, False: 1]
  ------------------
 6315|      0|            std::env::set_var("MDMDVIEW_MERMAID_PATCH_DEBUG", value);
 6316|      1|        } else {
 6317|      1|            std::env::remove_var("MDMDVIEW_MERMAID_PATCH_DEBUG");
 6318|      1|        }
 6319|      1|    }
 6320|       |
 6321|       |    #[cfg(feature = "mermaid-quickjs")]
 6322|       |    #[test]
 6323|      1|    fn test_patch_mermaid_js_debug_paths_with_targets() {
 6324|      1|        let _lock = env_lock();
 6325|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
 6326|      1|        let js = concat!(
 6327|       |            "var hD=wRe();",
 6328|       |            "FY.prototype={constructor:FY,appendChild:function(i){return this._parent.insertBefore(i,this._next)},insertBefore:function(i,s){return this._parent.insertBefore(i,s)},querySelector:function(i){return this._parent.querySelector(i)},querySelectorAll:function(i){return this._parent.querySelectorAll(i)}};",
 6329|       |            "function FY(i,s){this.ownerDocument=i.ownerDocument,this.namespaceURI=i.namespaceURI,this._next=null,this._parent=i,this.__data__=s}",
 6330|       |            "u.text().split(/(\\s+|<br>)/).reverse()",
 6331|       |            "p=fWe({container:document.getElementById(\"cy\"),style:[{selector:\"edge\",style:{\"curve-style\":\"bezier\"}}]});",
 6332|       |            "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run(),p.ready(v=>{Xe.info(\"Ready\",v),u(p)})",
 6333|       |            "const se=_.node().getBBox();"
 6334|       |        );
 6335|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 6336|      1|        assert!(output.contains("sanitize:function"));
 6337|      1|        assert!(output.contains("__mdmdview_cytoscape_stub"));
 6338|      1|    }
 6339|       |
 6340|       |    #[cfg(feature = "mermaid-quickjs")]
 6341|       |    #[test]
 6342|      1|    fn test_patch_mermaid_js_debug_paths_with_layout_only() {
 6343|      1|        let _lock = env_lock();
 6344|      1|        let _guard = EnvGuard::set("MDMDVIEW_MERMAID_PATCH_DEBUG", "1");
 6345|      1|        let js = "p.layout({name:\"cose-bilkent\",quality:\"proof\",styleEnabled:!1,animate:!1}).run()";
 6346|      1|        let output = MermaidWorker::patch_mermaid_js(js);
 6347|      1|        assert!(output.contains("breadthfirst"));
 6348|      1|    }
 6349|       |
 6350|       |    #[cfg(feature = "mermaid-quickjs")]
 6351|       |    #[test]
 6352|      1|    fn test_normalize_svg_size_inserts_dimensions() {
 6353|      1|        let svg = r#"<svg viewBox="0 0 200 100" width="100%" height="100%"></svg>"#;
 6354|      1|        let output = MermaidWorker::normalize_svg_size(svg);
 6355|      1|        assert!(output.contains("width=\"200\""));
 6356|      1|        assert!(output.contains("height=\"100\""));
 6357|      1|    }
 6358|       |
 6359|       |    #[cfg(feature = "mermaid-quickjs")]
 6360|       |    #[test]
 6361|      1|    fn test_normalize_svg_size_inserts_missing_dimension() {
 6362|      1|        let svg = r#"<svg viewBox="0 0 320 240" height="100%"></svg>"#;
 6363|      1|        let output = MermaidWorker::normalize_svg_size(svg);
 6364|      1|        assert!(output.contains("width=\"320\""));
 6365|      1|        assert!(output.contains("height=\"240\""));
 6366|      1|    }
 6367|       |
 6368|       |    #[cfg(feature = "mermaid-quickjs")]
 6369|       |    #[test]
 6370|      1|    fn test_normalize_svg_size_skips_fixed_dimensions() {
 6371|      1|        let svg = r#"<svg viewBox="0 0 200 100" width="200" height="100"></svg>"#;
 6372|      1|        assert_eq!(MermaidWorker::normalize_svg_size(svg), svg);
 6373|      1|    }
 6374|       |
 6375|       |    #[cfg(feature = "mermaid-quickjs")]
 6376|       |    #[test]
 6377|      1|    fn test_normalize_svg_size_no_viewbox_no_change() {
 6378|      1|        let svg = r#"<svg width="100%" height="100%"></svg>"#;
 6379|      1|        assert_eq!(MermaidWorker::normalize_svg_size(svg), svg);
 6380|      1|    }
 6381|       |
 6382|       |    #[cfg(feature = "mermaid-quickjs")]
 6383|       |    #[test]
 6384|      1|    fn test_replace_and_upsert_attr_paths() {
 6385|      1|        let tag = r#"<svg width="10" height="20">"#;
 6386|      1|        let replaced = MermaidWorker::replace_attr(tag, "width", "99");
 6387|      1|        assert!(replaced.contains("width=\"99\""));
 6388|      1|        let unchanged = MermaidWorker::replace_attr(tag, "viewBox", "0 0 1 1");
 6389|      1|        assert_eq!(unchanged, tag);
 6390|      1|        let upsert_existing = MermaidWorker::upsert_attr(tag, "height", "42");
 6391|      1|        assert!(upsert_existing.contains("height=\"42\""));
 6392|      1|        let upsert_new = MermaidWorker::upsert_attr(tag, "viewBox", "0 0 1 1");
 6393|      1|        assert!(upsert_new.contains("viewBox=\"0 0 1 1\""));
 6394|      1|    }
 6395|       |
 6396|       |    #[cfg(feature = "mermaid-quickjs")]
 6397|       |    #[test]
 6398|      1|    fn test_strip_svg_attr_and_insert_svg_attr() {
 6399|      1|        let svg = r#"<svg width="10" height="20"></svg>"#;
 6400|      1|        let stripped = MermaidWorker::strip_svg_attr(svg, "width").expect("width removed");
 6401|      1|        assert!(!stripped.contains("width=\"10\""));
 6402|      1|        assert!(MermaidWorker::strip_svg_attr(svg, "viewBox").is_none());
 6403|      1|        let inserted = MermaidWorker::insert_svg_attr("<svg></svg>", "viewBox", "0 0 1 1");
 6404|      1|        assert!(inserted.contains("viewBox=\"0 0 1 1\""));
 6405|      1|    }
 6406|       |
 6407|       |    #[cfg(feature = "mermaid-quickjs")]
 6408|       |    #[test]
 6409|      1|    fn test_remove_svg_attr_trims_double_space() {
 6410|      1|        let tag = r#"<svg width="10"  height="20">"#;
 6411|      1|        let stripped = MermaidWorker::remove_svg_attr(tag, "width");
 6412|      1|        assert!(!stripped.contains("width=\"10\""));
 6413|      1|        assert!(stripped.contains("height=\"20\""));
 6414|      1|        assert!(stripped.starts_with("<svg"));
 6415|      1|    }
 6416|       |
 6417|       |    #[cfg(feature = "mermaid-quickjs")]
 6418|       |    #[test]
 6419|      1|    fn test_remove_svg_attr_noop_when_missing_or_unclosed() {
 6420|      1|        let tag = r#"<svg height="20">"#;
 6421|      1|        assert_eq!(MermaidWorker::remove_svg_attr(tag, "width"), tag);
 6422|      1|        let unclosed = r#"<svg width="10 height=20>"#;
 6423|      1|        assert_eq!(MermaidWorker::remove_svg_attr(unclosed, "width"), unclosed);
 6424|      1|    }
 6425|       |
 6426|       |    #[cfg(feature = "mermaid-quickjs")]
 6427|       |    #[test]
 6428|      1|    fn test_remove_svg_attr_preserves_spacing_without_double_space() {
 6429|      1|        let tag = r#"<svg width="10"height="20">"#;
 6430|      1|        assert_eq!(MermaidWorker::remove_svg_attr(tag, "width"), "<svg height=\"20\">");
 6431|      1|    }
 6432|       |
 6433|       |    #[cfg(feature = "mermaid-quickjs")]
 6434|       |    #[test]
 6435|      1|    fn test_parse_viewbox_dims_and_format_dim() {
 6436|      1|        assert_eq!(MermaidWorker::parse_viewbox_dims("0 0 100 200"), Some((100.0, 200.0)));
 6437|      1|        assert_eq!(
 6438|      1|            MermaidWorker::parse_viewbox_dims("0,0,100,200"),
 6439|       |            Some((100.0, 200.0))
 6440|       |        );
 6441|      1|        assert!(MermaidWorker::parse_viewbox_dims("0,0,100,0").is_none());
 6442|      1|        assert!(MermaidWorker::parse_viewbox_dims("0 0 -1 2").is_none());
 6443|      1|        assert!(MermaidWorker::parse_viewbox_dims("0 0 NaN 2").is_none());
 6444|      1|        assert!(MermaidWorker::parse_viewbox_dims("bad").is_none());
 6445|      1|        assert_eq!(MermaidWorker::format_dim(10.0), "10");
 6446|      1|        assert_eq!(MermaidWorker::format_dim(10.5), "10.5");
 6447|      1|        assert_eq!(MermaidWorker::format_dim(0.0), "0");
 6448|      1|        assert_eq!(MermaidWorker::format_dim(10.123), "10.123");
 6449|      1|    }
 6450|       |
 6451|       |    #[cfg(feature = "mermaid-quickjs")]
 6452|       |    #[test]
 6453|      1|    fn test_text_measurer_fallback_for_missing_fonts() {
 6454|      1|        let fontdb = Arc::new(usvg::fontdb::Database::new());
 6455|      1|        let measurer = TextMeasurer::new(Arc::clone(&fontdb));
 6456|      1|        let (width, height) = measurer.measure_text("abc", -1.0, Some(700.0));
 6457|      1|        assert!(width > 0.0);
 6458|      1|        assert!(height > 0.0);
 6459|      1|    }
 6460|       |
 6461|       |    #[cfg(feature = "mermaid-quickjs")]
 6462|       |    #[test]
 6463|      1|    fn test_text_measurer_non_finite_font_size_uses_default() {
 6464|      1|        let mut fontdb = usvg::fontdb::Database::new();
 6465|      1|        fontdb.load_system_fonts();
 6466|      1|        let measurer = TextMeasurer::new(Arc::new(fontdb));
 6467|      1|        let (width, height) = measurer.measure_text("abc", f32::NAN, None);
 6468|      1|        assert!(width > 0.0);
 6469|      1|        assert!(height > 0.0);
 6470|      1|    }
 6471|       |
 6472|       |    #[cfg(feature = "mermaid-quickjs")]
 6473|       |    #[test]
 6474|      1|    fn test_text_measurer_missing_glyph_uses_fallback_advance() {
 6475|      1|        let mut fontdb = usvg::fontdb::Database::new();
 6476|      1|        fontdb.load_system_fonts();
 6477|      1|        let measurer = TextMeasurer::new(Arc::new(fontdb));
 6478|      1|        let (width, height) = measurer.measure_text("\u{10FFFF}", 16.0, None);
 6479|      1|        assert!(width > 0.0);
 6480|      1|        assert!(height > 0.0);
 6481|      1|    }
 6482|       |
 6483|       |    #[cfg(feature = "mermaid-quickjs")]
 6484|       |    #[test]
 6485|      1|    fn test_text_measurer_bold_adjusts_when_faces_match() {
 6486|      1|        let mut fontdb = usvg::fontdb::Database::new();
 6487|      1|        fontdb.load_system_fonts();
 6488|      1|        let fontdb = Arc::new(fontdb);
 6489|      1|        let face_id = fontdb.query(&usvg::fontdb::Query {
 6490|      1|            families: &[usvg::fontdb::Family::SansSerif],
 6491|      1|            ..Default::default()
 6492|      1|        });
 6493|      1|        let measurer = TextMeasurer {
 6494|      1|            fontdb: Arc::clone(&fontdb),
 6495|      1|            face_id,
 6496|      1|            bold_face_id: face_id,
 6497|      1|        };
 6498|      1|        let (width, height) = measurer.measure_text("Test", 16.0, Some(700.0));
 6499|      1|        assert!(width > 0.0);
 6500|      1|        assert!(height > 0.0);
 6501|      1|    }
 6502|       |
 6503|       |    #[cfg(feature = "mermaid-quickjs")]
 6504|       |    #[test]
 6505|      1|    fn test_text_measurer_empty_text_returns_zero() {
 6506|      1|        let mut fontdb = usvg::fontdb::Database::new();
 6507|      1|        fontdb.load_system_fonts();
 6508|      1|        let measurer = TextMeasurer::new(Arc::new(fontdb));
 6509|      1|        let (width, height) = measurer.measure_text("", 16.0, None);
 6510|      1|        assert_eq!(width, 0.0);
 6511|      1|        assert_eq!(height, 0.0);
 6512|      1|    }
 6513|       |
 6514|       |    #[cfg(feature = "mermaid-quickjs")]
 6515|       |    #[test]
 6516|      1|    fn test_text_measurer_kerning_adjusts_width_when_available() {
 6517|      1|        let mut fontdb = usvg::fontdb::Database::new();
 6518|      1|        fontdb.load_system_fonts();
 6519|      1|        let fontdb = Arc::new(fontdb);
 6520|      1|        let measurer = TextMeasurer::new(Arc::clone(&fontdb));
 6521|      1|        let face_id = match measurer.face_id {
 6522|      1|            Some(id) => id,
 6523|      0|            None => return,
 6524|       |        };
 6525|      1|        let has_kern = fontdb
 6526|      1|            .with_face_data(face_id, |data, index| {
 6527|      1|                let face = ttf_parser::Face::parse(data, index).ok()?;
                                                                                  ^0
 6528|      1|                let kern = face.tables().kern?;
                                                           ^0
 6529|      1|                let left = face.glyph_index('A')?;
                                                              ^0
 6530|      1|                let right = face.glyph_index('V')?;
                                                               ^0
 6531|      1|                for table in kern.subtables.into_iter() {
 6532|      1|                    if !table.horizontal
  ------------------
  |  Branch (6532:24): [True: 0, False: 1]
  ------------------
 6533|      1|                        || table.has_cross_stream
  ------------------
  |  Branch (6533:28): [True: 0, False: 1]
  ------------------
 6534|      1|                        || table.variable
  ------------------
  |  Branch (6534:28): [True: 0, False: 1]
  ------------------
 6535|      1|                        || table.has_state_machine
  ------------------
  |  Branch (6535:28): [True: 0, False: 1]
  ------------------
 6536|       |                    {
 6537|      0|                        continue;
 6538|      1|                    }
 6539|      1|                    if let Some(value) = table.glyphs_kerning(left, right) {
  ------------------
  |  Branch (6539:28): [True: 1, False: 0]
  ------------------
 6540|      1|                        if value != 0 {
  ------------------
  |  Branch (6540:28): [True: 1, False: 0]
  ------------------
 6541|      1|                            return Some(true);
 6542|      0|                        }
 6543|      0|                    }
 6544|       |                }
 6545|      0|                Some(false)
 6546|      1|            })
 6547|      1|            .flatten()
 6548|      1|            .unwrap_or(false);
 6549|      1|        if !has_kern {
  ------------------
  |  Branch (6549:12): [True: 0, False: 1]
  ------------------
 6550|      0|            return;
 6551|      1|        }
 6552|      1|        let (w_av, _) = measurer.measure_text("AV", 16.0, None);
 6553|      1|        let (w_a, _) = measurer.measure_text("A", 16.0, None);
 6554|      1|        let (w_v, _) = measurer.measure_text("V", 16.0, None);
 6555|      1|        assert!(w_av < w_a + w_v);
 6556|      1|    }
 6557|       |
 6558|       |    #[cfg(feature = "mermaid-quickjs")]
 6559|       |    #[test]
 6560|      1|    fn test_scale_adjustment_for_svg_defaults() {
 6561|      1|        assert_eq!(MermaidWorker::scale_adjustment_for_svg("<svg></svg>"), 1.0);
 6562|      1|        assert_eq!(
 6563|      1|            MermaidWorker::scale_adjustment_for_svg("<svg aria-roledescription=\"er\"></svg>"),
 6564|       |            0.94
 6565|       |        );
 6566|      1|        assert_eq!(
 6567|      1|            MermaidWorker::scale_adjustment_for_svg("<svg aria-roledescription='er'></svg>"),
 6568|       |            0.94
 6569|       |        );
 6570|      1|    }
 6571|       |}

C:\language\mdmdview\src\sample_files.rs:
    1|       |//! Sample markdown files embedded in the application
    2|       |//!
    3|       |//! These files demonstrate the markdown viewer capabilities and provide
    4|       |//! usage instructions. They are built into the executable for easy access.
    5|       |
    6|       |/// Represents a sample markdown file with metadata
    7|       |#[derive(Debug, Clone)]
    8|       |pub struct SampleFile {
    9|       |    pub name: &'static str,
   10|       |    pub title: &'static str,
   11|       |    pub content: &'static str,
   12|       |}
   13|       |
   14|       |/// Collection of all embedded sample files
   15|       |pub const SAMPLE_FILES: &[SampleFile] = &[
   16|       |    SampleFile {
   17|       |        name: "welcome.md",
   18|       |        title: "Welcome to MarkdownView",
   19|       |        content: WELCOME_CONTENT,
   20|       |    },
   21|       |    SampleFile {
   22|       |        name: "formatting.md",
   23|       |        title: "Formatting Examples",
   24|       |        content: FORMATTING_CONTENT,
   25|       |    },
   26|       |    SampleFile {
   27|       |        name: "code.md",
   28|       |        title: "Code Examples",
   29|       |        content: CODE_CONTENT,
   30|       |    },
   31|       |    SampleFile {
   32|       |        name: "usage.md",
   33|       |        title: "Usage Instructions",
   34|       |        content: USAGE_CONTENT,
   35|       |    },
   36|       |    SampleFile {
   37|       |        name: "search.md",
   38|       |        title: "Search Tips & Examples",
   39|       |        content: SEARCH_GUIDE_CONTENT,
   40|       |    },
   41|       |    SampleFile {
   42|       |        name: "images.md",
   43|       |        title: "Inline Images & Diagrams",
   44|       |        content: IMAGES_CONTENT,
   45|       |    },
   46|       |];
   47|       |
   48|       |/// Welcome content with basic introduction
   49|       |const WELCOME_CONTENT: &str = r#"# Welcome to MarkdownView
   50|       |
   51|       |A simple, fast markdown viewer for Windows built with Rust and egui.
   52|       |
   53|       |## Features
   54|       |
   55|       |- **Pure Rust Implementation** - Single executable, no dependencies
   56|       |- **Fast Rendering** - Efficient markdown parsing with pulldown-cmark
   57|       |- **Syntax Highlighting** - Code blocks with proper syntax coloring
   58|       |- **Native File Dialogs** - Seamless Windows integration
   59|       |- **Embedded Examples** - Built-in sample files to explore
   60|       |
   61|       |## Quick Start
   62|       |
   63|       |1. **Open a File**: Use `File  Open` or `Ctrl+O` to load a markdown file
   64|       |2. **Browse Samples**: Use `File  Samples` to explore built-in examples
   65|       |3. **Navigate**: Scroll to read through documents
   66|       |
   67|       |Enjoy reading your markdown files with this lightweight, efficient viewer!
   68|       |
   69|       |---
   70|       |
   71|       |*Built with  using Rust, egui, and pulldown-cmark*
   72|       |"#;
   73|       |
   74|       |const FORMATTING_CONTENT: &str = r#"# Markdown Formatting Guide
   75|       |
   76|       |This document demonstrates the various formatting options supported by MarkdownView.
   77|       |
   78|       |## Table of Contents
   79|       |
   80|       |- [Text Formatting](#text-formatting)
   81|       |- [Headers](#headers)
   82|       |- [Lists](#lists)
   83|       |- [Links and Images](#links-and-images)
   84|       |- [Emojis](#emojis)
   85|       |- [Blockquotes](#blockquotes)
   86|       |- [Horizontal Rules](#horizontal-rules)
   87|       |- [Tables](#tables)
   88|       |
   89|       |Quick jump: [Go to Lists](#lists) | [Go to Tables](#tables)
   90|       |
   91|       |## Text Formatting
   92|       |
   93|       |**Bold text** and *italic text* are supported, as well as ***bold italic***.
   94|       |
   95|       |You can also use `inline code` and ~~strikethrough~~ text.
   96|       |
   97|       |## Headers
   98|       |
   99|       |# Header 1
  100|       |## Header 2  
  101|       |### Header 3
  102|       |#### Header 4
  103|       |##### Header 5
  104|       |###### Header 6
  105|       |
  106|       |## Lists
  107|       |
  108|       |### Unordered Lists
  109|       |
  110|       |- First item
  111|       |- Second item
  112|       |  - Nested item
  113|       |  - Another nested item
  114|       |- Third item
  115|       |- Inline code in bullets works: use `--help` or `cargo run`
  116|       |- Styled + emoji in bullets: **:rocket:** launch, *:tada:* celebration, and ~~:fire:~~ warning
  117|       |- Tight list check: this item has :rocket: and `code` without blank lines between items
  118|       |
  119|       |### Ordered Lists
  120|       |
  121|       |1. First item
  122|       |2. Second item
  123|       |   1. Nested numbered item
  124|       |   2. Another nested item
  125|       |3. Third item
  126|       |
  127|       |## Links and Images
  128|       |
  129|       |[Visit Rust's website](https://rust-lang.org)
  130|       |
  131|       |Internal anchors let you jump within this document:
  132|       |- [Jump to Headers](#headers)
  133|       |- [Jump to Tables](#tables)
  134|       |- [Back to top](#markdown-formatting-guide)
  135|       |
  136|       |Links are clickable and will open in your default browser.
  137|       |
  138|       |## Emojis
  139|       |
  140|       |Unicode emojis render as normal text if your font supports them.
  141|       |Examples: Thanks!   Status:   Ship it 
  142|       |
  143|       |Shortcodes like `:rocket:` and `:tada:` are expanded to emoji images in normal text, headers, and list items.
  144|       |
  145|       |## Blockquotes
  146|       |
  147|       |> This is a blockquote.
  148|       |> It can span multiple lines.
  149|       |> 
  150|       |> > Nested blockquotes are also supported.
  151|       |
  152|       |## Horizontal Rules
  153|       |
  154|       |---
  155|       |
  156|       |## Tables
  157|       |
  158|       || Feature | Supported | Notes |
  159|       ||---------|-----------|-------|
  160|       || Headers | Yes | All levels 1-6 |
  161|       || Lists | Yes | Ordered and unordered |
  162|       || Code blocks | Yes | With syntax highlighting |
  163|       || Tables | Yes | Basic table support |
  164|       || Links | Yes | Opens in browser; internal anchors scroll in document |
  165|       |
  166|       |---
  167|       |
  168|       |*This covers most of the formatting features available in MarkdownView.*  
  169|       |[Back to top](#markdown-formatting-guide)
  170|       |"#;
  171|       |
  172|       |/// Code examples with syntax highlighting
  173|       |const SEARCH_GUIDE_CONTENT: &str = concat!(
  174|       |    "# Search Tips & Examples\n\n",
  175|       |    "MarkdownView's search panel is accent-aware and case-insensitive. A single query matches multiple spellings automatically.\n\n",
  176|       |    "## Accent Folding\n\n",
  177|       |    "- Typing `resume` highlights `r\u{00e9}sum\u{00e9}`, `RESUME`, and `re\u{0301}sume` (precomposed vs. combining accent).\n",
  178|       |    "- `istanbul` matches both `\u{0130}stanbul` (Turkish dotted capital I) and `ISTANBUL`.\n",
  179|       |    "- `sao` finds `S\u{00e3}o`, `SAO`, and `Sao` regardless of combining marks.\n",
  180|       |    "- `nino` finds `Ni\u{00f1}o`, `NINO`, and `nin\u{0303}o`.\n\n",
  181|       |    "Try opening this sample, pressing `Ctrl+F`, and searching for the words below:\n\n",
  182|       |    "| Query | Matches in this document |\n",
  183|       |    "|-------|-------------------------|\n",
  184|       |    "| `resume` | r\u{00e9}sum\u{00e9}, RESUME, re\u{0301}sume |\n",
  185|       |    "| `istanbul` | \u{0130}stanbul, ISTANBUL |\n",
  186|       |    "| `sao` | S\u{00e3}o, SAO, Sao |\n",
  187|       |    "| `nino` | Ni\u{00f1}o, NINO, nin\u{0303}o |\n\n",
  188|       |    "> Tip: Use `Enter` / `Shift+Enter` to cycle through matches. The highlight respects grapheme clusters, so emoji and combined characters stay intact.\n\n",
  189|       |);
  190|       |const IMAGES_CONTENT: &str = r#"# Inline Images & Diagrams
  191|       |
  192|       |This sample demonstrates inline images and Mermaid code blocks.
  193|       |
  194|       |## PNG Image
  195|       |
  196|       |Below is a PNG image using an embedded emoji asset.
  197|       |
  198|       |![Smiley PNG](assets/emoji/1f600.png "PNG emoji sample")
  199|       |
  200|       |## SVG Image
  201|       |
  202|       |An SVG logo rendered via resvg/tiny-skia.
  203|       |
  204|       |![SVG Logo](assets/samples/logo.svg "SVG sample logo")
  205|       |
  206|       |## WEBP Image
  207|       |
  208|       |A small WEBP sample is bundled for testing.
  209|       |
  210|       |![WEBP Sample](assets/samples/webp_sample.webp "WEBP sample")
  211|       |
  212|       |## Mermaid Diagram (embedded)
  213|       |
  214|       |Mermaid code blocks are rendered as diagrams by default.
  215|       |Build with `--no-default-features` or set `MDMDVIEW_MERMAID_RENDERER=off` to show the source instead.
  216|       |
  217|       |```mermaid
  218|       |graph TD;
  219|       |    A[Start] --> B{Is SVG supported?};
  220|       |    B -- Yes --> C[Rasterize via resvg];
  221|       |    B -- No  --> D[Show placeholder];
  222|       |    C --> E[Display egui texture];
  223|       |    D --> E;
  224|       |```
  225|       |
  226|       |## Notes
  227|       |
  228|       |- The WEBP sample is at `assets/samples/webp_sample.webp`. See `examples/webp_test.md` for a standalone test file.
  229|       |
  230|       |"#;
  231|       |
  232|       |const CODE_CONTENT: &str = r#"# Code Examples
  233|       |
  234|       |MarkdownView supports syntax highlighting for many programming languages.
  235|       |
  236|       |## Rust Code
  237|       |
  238|       |```rust
  239|       |fn main() {
  240|       |    println!("Hello, world!");
  241|       |    
  242|       |    let mut vector = vec![1, 2, 3, 4, 5];
  243|       |    vector.iter()
  244|       |        .filter(|&x| x % 2 == 0)
  245|       |        .for_each(|x| println!("Even number: {}", x));
  246|       |}
  247|       |
  248|       |// Struct definition with lifetimes
  249|       |struct Config<'a> {
  250|       |    name: &'a str,
  251|       |    version: u32,
  252|       |}
  253|       |
  254|       |impl<'a> Config<'a> {
  255|       |    fn new(name: &'a str) -> Self {
  256|       |        Config { name, version: 1 }
  257|       |    }
  258|       |}
  259|       |```
  260|       |
  261|       |## Python Code
  262|       |
  263|       |```python
  264|       |def fibonacci(n):
  265|       |    """Generate fibonacci sequence up to n"""
  266|       |    if n <= 0:
  267|       |        return []
  268|       |    elif n == 1:
  269|       |        return [0]
  270|       |    
  271|       |    sequence = [0, 1]
  272|       |    while len(sequence) < n:
  273|       |        sequence.append(sequence[-1] + sequence[-2])
  274|       |    
  275|       |    return sequence
  276|       |
  277|       |# List comprehension example
  278|       |squares = [x**2 for x in range(10) if x % 2 == 0]
  279|       |print(f"Even squares: {squares}")
  280|       |```
  281|       |
  282|       |## JavaScript Code
  283|       |
  284|       |```javascript
  285|       |// Modern JavaScript with async/await
  286|       |async function fetchUserData(userId) {
  287|       |    try {
  288|       |        const response = await fetch(`/api/users/${userId}`);
  289|       |        const userData = await response.json();
  290|       |        
  291|       |        return {
  292|       |            ...userData,
  293|       |            lastUpdated: new Date().toISOString()
  294|       |        };
  295|       |    } catch (error) {
  296|       |        console.error('Failed to fetch user data:', error);
  297|       |        throw error;
  298|       |    }
  299|       |}
  300|       |
  301|       |// Arrow functions and destructuring
  302|       |const processData = ({ name, age, email }) => ({
  303|       |    displayName: name.toUpperCase(),
  304|       |    isAdult: age >= 18,
  305|       |    emailDomain: email.split('@')[1]
  306|       |});
  307|       |```
  308|       |
  309|       |## SQL Code
  310|       |
  311|       |```sql
  312|       |-- Complex query with joins and aggregation
  313|       |SELECT 
  314|       |    u.username,
  315|       |    u.email,
  316|       |    COUNT(o.id) as total_orders,
  317|       |    SUM(oi.price * oi.quantity) as total_spent
  318|       |FROM users u
  319|       |LEFT JOIN orders o ON u.id = o.user_id
  320|       |LEFT JOIN order_items oi ON o.id = oi.order_id
  321|       |WHERE u.created_at >= '2023-01-01'
  322|       |GROUP BY u.id, u.username, u.email
  323|       |HAVING COUNT(o.id) > 5
  324|       |ORDER BY total_spent DESC
  325|       |LIMIT 20;
  326|       |```
  327|       |
  328|       |## Inline Code
  329|       |
  330|       |You can also use `inline code` within paragraphs, like `let x = 42;` or `print("hello")`.
  331|       |
  332|       |---
  333|       |
  334|       |*Syntax highlighting is powered by the syntect library, supporting dozens of languages.*
  335|       |"#;
  336|       |
  337|       |/// Usage instructions and tips
  338|       |const USAGE_CONTENT: &str = r#"# Usage Instructions
  339|       |
  340|       |## Opening Files
  341|       |
  342|       |### File Menu
  343|       |- Use `File  Open` from the menu bar
  344|       |- Keyboard shortcut: `Ctrl+O`
  345|       |- Select any `.md` or `.markdown` file from your system
  346|       |
  347|       |### Drag and Drop
  348|       |- Drag markdown files directly into the application window
  349|       |- Multiple files can be opened in sequence
  350|       |
  351|       |## Viewing Sample Files
  352|       |
  353|       |### Built-in Examples
  354|       |- Use `File  Samples` to browse embedded examples
  355|       |- These files demonstrate various markdown features
  356|       |- Perfect for testing and learning
  357|       |
  358|       |### Sample File List
  359|       |- **welcome.md** - Introduction and overview
  360|       |- **formatting.md** - Text formatting examples  
  361|       |- **code.md** - Syntax highlighting examples
  362|       |- **usage.md** - This usage guide
  363|       |
  364|       |## Navigation
  365|       |
  366|       |### Scrolling
  367|       |- Use mouse wheel or trackpad to scroll
  368|       |- Keyboard arrows for line-by-line navigation
  369|       |- Page Up/Page Down for faster scrolling
  370|       |
  371|       |### Window Controls
  372|       |- Resize the window as needed
  373|       |- Content automatically reflows
  374|       |- Minimum window size is enforced
  375|       |
  376|       |## Keyboard Shortcuts
  377|       |
  378|       || Shortcut | Action |
  379|       ||----------|--------|
  380|       || `Ctrl+O` | Open file |
  381|       || `Ctrl+W` | Close current file |
  382|       || `F5` | Reload current file |
  383|       || `Ctrl+Q` | Quit application |
  384|       || `F11` | Toggle fullscreen |
  385|       || `Ctrl++` | Zoom in (increase font size) |
  386|       || `Ctrl+-` | Zoom out (decrease font size) |
  387|       || `Ctrl` + Mouse Wheel | Zoom in/out |
  388|       || `Ctrl+0` | Reset zoom to default size |
  389|       || `Home` | Go to top of document |
  390|       || `End` | Go to bottom of document |
  391|       || `Page Up` | Scroll up one page |
  392|       || `Page Down` | Scroll down one page |
  393|       |
  394|       |## File Associations
  395|       |
  396|       |### Windows Integration
  397|       |To make MarkdownView the default for `.md` files:
  398|       |
  399|       |1. Right-click any `.md` file
  400|       |2. Select "Open with  Choose another app"
  401|       |3. Browse to the MarkdownView executable
  402|       |4. Check "Always use this app"
  403|       |
  404|       |### Supported Extensions
  405|       |- `.md` - Standard markdown files
  406|       |- `.markdown` - Alternative markdown extension
  407|       |- `.mdown` - Another common variation
  408|       |- `.mkd` - Short markdown extension
  409|       |
  410|       |## Performance
  411|       |
  412|       |### Large Files
  413|       |- Files up to several MB render efficiently
  414|       |- Very large files (>10MB) may take a moment to parse
  415|       |- Consider breaking up extremely large documents
  416|       |
  417|       |### Memory Usage
  418|       |- Minimal memory footprint
  419|       |- Parsed content is cached for fast scrolling
  420|       |- No memory leaks during normal operation
  421|       |
  422|       |## Troubleshooting
  423|       |
  424|       |### Common Issues
  425|       |
  426|       |**File won't open**
  427|       |- Check file extension is `.md` or `.markdown`
  428|       |- Ensure file isn't locked by another application
  429|       |- Verify file contains valid UTF-8 text
  430|       |
  431|       |**Display issues**
  432|       |- Try resizing the window
  433|       |- Restart the application
  434|       |- Check if file contains very long lines
  435|       |
  436|       |**Performance problems**
  437|       |- Close and reopen large files
  438|       |- Ensure adequate system memory
  439|       |- Consider breaking up large documents
  440|       |
  441|       |### Getting Help
  442|       |
  443|       |For bugs or feature requests:
  444|       |1. Check the application works with sample files
  445|       |2. Try reproducing with a minimal markdown file
  446|       |3. Note your Windows version and system specs
  447|       |
  448|       |---
  449|       |
  450|       |*Thank you for using MarkdownView! We hope it serves your markdown reading needs well.*
  451|       |"#;
  452|       |
  453|       |#[cfg(test)]
  454|       |mod tests {
  455|       |    use super::*;
  456|       |
  457|       |    #[test]
  458|      1|    fn test_sample_files_exist() {
  459|      1|        assert_eq!(SAMPLE_FILES.len(), 6);
  460|       |
  461|      1|        let names: Vec<&str> = SAMPLE_FILES.iter().map(|f| f.name).collect();
  462|      1|        assert!(names.contains(&"welcome.md"));
  463|      1|        assert!(names.contains(&"formatting.md"));
  464|      1|        assert!(names.contains(&"code.md"));
  465|      1|        assert!(names.contains(&"usage.md"));
  466|      1|        assert!(names.contains(&"search.md"));
  467|      1|        assert!(names.contains(&"images.md"));
  468|      1|    }
  469|       |
  470|       |    #[test]
  471|      1|    fn test_sample_files_content_not_empty() {
  472|      7|        for file in SAMPLE_FILES {
                          ^6
  473|      6|            assert!(!file.content.is_empty());
  474|      6|            assert!(!file.title.is_empty());
  475|      6|            assert!(!file.name.is_empty());
  476|       |        }
  477|      1|    }
  478|       |
  479|       |    #[test]
  480|      1|    fn test_sample_files_are_valid_markdown() {
  481|       |        use pulldown_cmark::{Options, Parser};
  482|       |
  483|      7|        for file in SAMPLE_FILES {
                          ^6
  484|      6|            let parser = Parser::new_ext(file.content, Options::all());
  485|      6|            let events: Vec<_> = parser.collect();
  486|      6|            assert!(!events.is_empty());
  487|       |        }
  488|      1|    }
  489|       |
  490|       |    #[test]
  491|      1|    fn test_welcome_content_structure() {
  492|      1|        assert!(WELCOME_CONTENT.contains("# Welcome"));
  493|      1|        assert!(WELCOME_CONTENT.contains("## Features"));
  494|      1|        assert!(WELCOME_CONTENT.contains("## Quick Start"));
  495|      1|    }
  496|       |
  497|       |    #[test]
  498|      1|    fn test_formatting_content_examples() {
  499|      1|        assert!(FORMATTING_CONTENT.contains("**Bold text**"));
  500|      1|        assert!(FORMATTING_CONTENT.contains("*italic text*"));
  501|      1|        assert!(FORMATTING_CONTENT.contains("`inline code`"));
  502|      1|        assert!(FORMATTING_CONTENT.contains("| Feature | Supported |"));
  503|      1|    }
  504|       |
  505|       |    #[test]
  506|      1|    fn test_code_content_languages() {
  507|      1|        assert!(CODE_CONTENT.contains("```rust"));
  508|      1|        assert!(CODE_CONTENT.contains("```python"));
  509|      1|        assert!(CODE_CONTENT.contains("```javascript"));
  510|      1|        assert!(CODE_CONTENT.contains("```sql"));
  511|      1|    }
  512|       |
  513|       |    #[test]
  514|      1|    fn test_usage_content_sections() {
  515|      1|        assert!(USAGE_CONTENT.contains("## Opening Files"));
  516|      1|        assert!(USAGE_CONTENT.contains("## Keyboard Shortcuts"));
  517|      1|        assert!(USAGE_CONTENT.contains("## Troubleshooting"));
  518|      1|    }
  519|       |
  520|       |    #[test]
  521|      1|    fn test_search_guide_examples_present() {
  522|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("rsum"));
  523|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("stanbul"));
  524|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("So"));
  525|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("Nio"));
  526|      1|        assert!(SEARCH_GUIDE_CONTENT.contains("Ctrl+F"));
  527|      1|    }
  528|       |
  529|       |    #[test]
  530|      1|    fn test_images_content_mentions_samples() {
  531|      1|        assert!(IMAGES_CONTENT.contains("Inline Images"));
  532|      1|        assert!(IMAGES_CONTENT.contains("WEBP Sample"));
  533|      1|        assert!(IMAGES_CONTENT.contains("```mermaid"));
  534|      1|    }
  535|       |}

C:\language\mdmdview\src\table_support\column_spec.rs:
    1|       |use std::cmp::max;
    2|       |use std::hash::{Hash, Hasher};
    3|       |
    4|       |use egui_extras::Column;
    5|       |use unicode_segmentation::UnicodeSegmentation;
    6|       |use unicode_width::UnicodeWidthStr;
    7|       |
    8|       |use crate::markdown_renderer::InlineSpan;
    9|       |
   10|       |const MAX_REMAINDER_COLUMNS: usize = 2;
   11|       |
   12|    120|fn normalize_body_font_px(body: f32) -> f32 {
   13|    120|    if body.is_finite() && body > 4.0 {
                                         ^119
  ------------------
  |  Branch (13:8): [True: 119, False: 1]
  |  Branch (13:28): [True: 117, False: 2]
  ------------------
   14|    117|        body
   15|       |    } else {
   16|      3|        14.0
   17|       |    }
   18|    120|}
   19|       |
   20|    116|fn px(body_px: f32, factor: f32) -> f32 {
   21|    116|    normalize_body_font_px(body_px) * factor
   22|    116|}
   23|       |
   24|       |#[derive(Debug, Clone, PartialEq)]
   25|       |pub enum ColumnPolicy {
   26|       |    Auto,
   27|       |    Fixed {
   28|       |        width: f32,
   29|       |        clip: bool,
   30|       |    },
   31|       |    Remainder {
   32|       |        clip: bool,
   33|       |    },
   34|       |    Resizable {
   35|       |        min: f32,
   36|       |        preferred: f32,
   37|       |        clip: bool,
   38|       |    },
   39|       |}
   40|       |
   41|       |impl ColumnPolicy {
   42|     24|    pub fn to_column(&self) -> Column {
   43|     24|        match self {
   44|      2|            ColumnPolicy::Auto => Column::auto(),
   45|      6|            ColumnPolicy::Fixed { width, clip } => {
   46|      6|                let mut col = Column::exact(*width);
   47|      6|                if *clip {
  ------------------
  |  Branch (47:20): [True: 5, False: 1]
  ------------------
   48|      5|                    col = col.clip(true);
   49|      5|                }
                              ^1
   50|      6|                col
   51|       |            }
   52|      5|            ColumnPolicy::Remainder { clip } => {
   53|      5|                let mut col = Column::remainder();
   54|      5|                if *clip {
  ------------------
  |  Branch (54:20): [True: 1, False: 4]
  ------------------
   55|      1|                    col = col.clip(true);
   56|      4|                }
   57|      5|                col
   58|       |            }
   59|       |            ColumnPolicy::Resizable {
   60|     11|                min,
   61|     11|                preferred,
   62|     11|                clip,
   63|       |            } => {
   64|     11|                let mut col = Column::initial(*preferred).at_least(*min).resizable(true);
   65|     11|                if *clip {
  ------------------
  |  Branch (65:20): [True: 2, False: 9]
  ------------------
   66|      2|                    col = col.clip(true);
   67|      9|                }
   68|     11|                col
   69|       |            }
   70|       |        }
   71|     24|    }
   72|       |}
   73|       |
   74|       |impl Hash for ColumnPolicy {
   75|      4|    fn hash<H: Hasher>(&self, state: &mut H) {
   76|      4|        std::mem::discriminant(self).hash(state);
   77|      4|        match self {
   78|      1|            ColumnPolicy::Auto => {}
   79|      1|            ColumnPolicy::Fixed { width, clip } => {
   80|      1|                width.to_bits().hash(state);
   81|      1|                clip.hash(state);
   82|      1|            }
   83|      1|            ColumnPolicy::Remainder { clip } => {
   84|      1|                clip.hash(state);
   85|      1|            }
   86|       |            ColumnPolicy::Resizable {
   87|      1|                min,
   88|      1|                preferred,
   89|      1|                clip,
   90|      1|            } => {
   91|      1|                min.to_bits().hash(state);
   92|      1|                preferred.to_bits().hash(state);
   93|      1|                clip.hash(state);
   94|      1|            }
   95|       |        }
   96|      4|    }
   97|       |}
   98|       |
   99|       |#[derive(Debug, Clone)]
  100|       |pub struct ColumnSpec {
  101|       |    pub index: usize,
  102|       |    pub ident: String,
  103|       |    pub policy: ColumnPolicy,
  104|       |    pub tooltip: Option<String>,
  105|       |    pub policy_hash: u64,
  106|       |}
  107|       |
  108|       |impl ColumnSpec {
  109|     86|    pub fn new(
  110|     86|        index: usize,
  111|     86|        ident: impl Into<String>,
  112|     86|        policy: ColumnPolicy,
  113|     86|        tooltip: Option<String>,
  114|     86|    ) -> Self {
  115|     86|        let ident = ident.into();
  116|     86|        let policy_hash = calculate_policy_hash(index, &ident, &policy);
  117|     86|        Self {
  118|     86|            index,
  119|     86|            ident,
  120|     86|            policy,
  121|     86|            tooltip,
  122|     86|            policy_hash,
  123|     86|        }
  124|     86|    }
  125|       |
  126|     16|    pub fn as_column(&self) -> Column {
  127|     16|        self.policy.to_column()
  128|     16|    }
  129|       |
  130|     26|    pub fn set_policy(&mut self, policy: ColumnPolicy) {
  131|     26|        self.policy = policy;
  132|     26|        self.policy_hash = calculate_policy_hash(self.index, &self.ident, &self.policy);
  133|     26|    }
  134|       |
  135|      5|    pub fn apply_preferred_width(&mut self, width: f32) {
  136|       |        if let ColumnPolicy::Resizable {
  ------------------
  |  Branch (136:16): [True: 4, False: 1]
  ------------------
  137|      4|            min,
  138|      4|            ref mut preferred,
  139|       |            ..
  140|      5|        } = self.policy
  141|      4|        {
  142|      4|            let clamped = width.max(min);
  143|      4|            *preferred = clamped;
  144|      4|            self.policy_hash = calculate_policy_hash(self.index, &self.ident, &self.policy);
  145|      4|        }
                      ^1
  146|      5|    }
  147|       |}
  148|       |
  149|       |#[derive(Debug, Clone, Copy, Default)]
  150|       |pub struct RichContentFlags {
  151|       |    pub has_link: bool,
  152|       |    pub has_image: bool,
  153|       |    pub has_emoji_like: bool,
  154|       |}
  155|       |
  156|       |#[derive(Debug, Clone, Default)]
  157|       |pub struct ColumnStat {
  158|       |    pub max_graphemes: usize,
  159|       |    pub longest_word: usize,
  160|       |    pub rich_content: RichContentFlags,
  161|       |}
  162|       |
  163|       |pub struct TableColumnContext<'a> {
  164|       |    pub headers: &'a [Vec<InlineSpan>],
  165|       |    pub rows: &'a [Vec<Vec<InlineSpan>>],
  166|       |    pub stats: &'a [ColumnStat],
  167|       |    pub body_font_px: f32,
  168|       |    pub table_id: u64,
  169|       |}
  170|       |
  171|       |impl<'a> TableColumnContext<'a> {
  172|     27|    pub fn new(
  173|     27|        headers: &'a [Vec<InlineSpan>],
  174|     27|        rows: &'a [Vec<Vec<InlineSpan>>],
  175|     27|        stats: &'a [ColumnStat],
  176|     27|        body_font_px: f32,
  177|     27|        table_id: u64,
  178|     27|    ) -> Self {
  179|     27|        Self {
  180|     27|            headers,
  181|     27|            rows,
  182|     27|            stats,
  183|     27|            body_font_px,
  184|     27|            table_id,
  185|     27|        }
  186|     27|    }
  187|       |
  188|     99|    pub fn column_stat(&self, idx: usize) -> Option<&ColumnStat> {
  189|     99|        self.stats.get(idx)
  190|     99|    }
  191|       |}
  192|       |
  193|    116|fn calculate_policy_hash(index: usize, ident: &str, policy: &ColumnPolicy) -> u64 {
  194|    116|    let mut hasher = std::collections::hash_map::DefaultHasher::new();
  195|    116|    index.hash(&mut hasher);
  196|    116|    ident.hash(&mut hasher);
  197|    116|    std::mem::discriminant(policy).hash(&mut hasher);
  198|    116|    match policy {
  199|      4|        ColumnPolicy::Auto => {}
  200|     24|        ColumnPolicy::Fixed { width, clip } => {
  201|     24|            width.to_bits().hash(&mut hasher);
  202|     24|            clip.hash(&mut hasher);
  203|     24|        }
  204|     29|        ColumnPolicy::Remainder { clip } => {
  205|     29|            clip.hash(&mut hasher);
  206|     29|        }
  207|     59|        ColumnPolicy::Resizable { min, clip, .. } => {
  208|     59|            min.to_bits().hash(&mut hasher);
  209|     59|            clip.hash(&mut hasher);
  210|     59|        }
  211|       |    }
  212|    116|    hasher.finish()
  213|    116|}
  214|       |
  215|     27|pub fn derive_column_specs(ctx: &TableColumnContext) -> Vec<ColumnSpec> {
  216|     27|    let mut remainder_assigned = 0usize;
  217|     27|    let mut fallback_idx: Option<usize> = None;
  218|     27|    let mut fallback_score: usize = 0;
  219|     27|    let column_count = ctx
  220|     27|        .stats
  221|     27|        .len()
  222|     27|        .max(ctx.headers.len())
  223|     31|        .max(ctx.rows.iter().map(|r| r.len()).max().unwrap_or(0));
                       ^27 ^27      ^27    ^27              ^27   ^27
  224|       |
  225|     27|    let mut scored_indices: Vec<(usize, usize)> = Vec::with_capacity(column_count);
  226|       |
  227|     27|    let mut specs: Vec<ColumnSpec> = (0..column_count)
  228|     74|        .map(|idx| {
                       ^27
  229|     74|            let spans = ctx.headers.get(idx).map(|v| v.as_slice()).unwrap_or(&[]);
                                                                   ^71^71
  230|     74|            let label = header_text(spans);
  231|     74|            let stat = ctx.column_stat(idx);
  232|       |
  233|     74|            let candidate_score = stat
  234|     74|                .map(|s| {
  235|     74|                    let mut score = s.max_graphemes + s.longest_word * 2;
  236|     74|                    if s.rich_content.has_image {
  ------------------
  |  Branch (236:24): [True: 2, False: 72]
  ------------------
  237|      2|                        score += 50;
  238|     72|                    }
  239|     74|                    if s.rich_content.has_link {
  ------------------
  |  Branch (239:24): [True: 4, False: 70]
  ------------------
  240|      4|                        score += 25;
  241|     70|                    }
  242|     74|                    score
  243|     74|                })
  244|     74|                .unwrap_or_else(|| label.len());
                                                 ^0    ^0
  245|     74|            if candidate_score > fallback_score {
  ------------------
  |  Branch (245:16): [True: 39, False: 35]
  ------------------
  246|     39|                fallback_score = candidate_score;
  247|     39|                fallback_idx = Some(idx);
  248|     39|            }
                          ^35
  249|     74|            scored_indices.push((idx, candidate_score));
  250|       |
  251|     74|            let policy =
  252|     74|                classify_column(&label, idx, &mut remainder_assigned, stat, ctx.body_font_px);
  253|     74|            let tooltip = column_tooltip(&label, &policy);
  254|     74|            ColumnSpec::new(idx, label, policy, tooltip)
  255|     74|        })
  256|     27|        .collect();
  257|       |
  258|       |    // Ensure at least one remainder if none assigned and available
  259|     27|    if remainder_assigned == 0 {
  ------------------
  |  Branch (259:8): [True: 18, False: 9]
  ------------------
  260|     18|        let mut candidate = fallback_idx;
  261|     18|        if let Some(idx) = candidate {
                                  ^17
  ------------------
  |  Branch (261:16): [True: 17, False: 1]
  ------------------
  262|     17|            if matches!(specs[idx].policy, ColumnPolicy::Fixed { .. }) {
                             ^5
  263|     12|                candidate = None;
  264|     12|            }
                          ^5
  265|      1|        }
  266|     18|        let has_non_fixed_other = specs
  267|     18|            .iter()
  268|     18|            .enumerate()
  269|     32|            .any(|(idx, spec)| idx != 0 && !matches!(spec.policy, ColumnPolicy::Fixed { .. }));
                           ^18                            ^14      ^15
  ------------------
  |  Branch (269:32): [True: 15, False: 17]
  ------------------
  270|     18|        if has_non_fixed_other && (candidate.is_none() || candidate == Some(0)) {
                                                 ^14       ^14          ^5
  ------------------
  |  Branch (270:12): [True: 14, False: 4]
  |  Branch (270:36): [True: 9, False: 5]
  |  Branch (270:59): [True: 3, False: 2]
  ------------------
  271|     12|            candidate = scored_indices
  272|     12|                .iter()
  273|     39|                .filter(|(idx, _)| *idx != 0)
                               ^12
  274|     27|                .filter(|(idx, _)| !matches!(specs[*idx].policy, ColumnPolicy::Fixed { .. }))
                               ^12
  275|     12|                .max_by_key(|(_, score)| *score)
  276|     12|                .map(|(idx, _)| *idx);
  277|      6|        }
  278|     18|        if candidate.is_none() {
  ------------------
  |  Branch (278:12): [True: 4, False: 14]
  ------------------
  279|      4|            candidate = specs
  280|      4|                .iter()
  281|      4|                .enumerate()
  282|      4|                .find(|(_, spec)| !matches!(spec.policy, ColumnPolicy::Fixed { .. }))
                                                 ^0
  283|      4|                .map(|(idx, _)| idx);
  284|     14|        }
  285|     18|        if let Some(idx) = candidate {
                                  ^14
  ------------------
  |  Branch (285:16): [True: 14, False: 4]
  ------------------
  286|     14|            let spec = &mut specs[idx];
  287|     14|            spec.set_policy(ColumnPolicy::Remainder { clip: false });
  288|     14|            remainder_assigned += 1;
  289|     14|        }
                      ^4
  290|      9|    }
  291|       |
  292|       |    // Promote additional wide columns to remainder up to the cap
  293|     68|    scored_indices.sort_by(|a, b| b.1.cmp(&a.1));
                  ^27            ^27
  294|     90|    for (idx, _) in scored_indices {
                       ^66
  295|     66|        if remainder_assigned >= MAX_REMAINDER_COLUMNS {
  ------------------
  |  Branch (295:12): [True: 3, False: 63]
  ------------------
  296|      3|            break;
  297|     63|        }
  298|     63|        let spec = &mut specs[idx];
  299|     63|        if matches!(spec.policy, ColumnPolicy::Resizable { .. })
                         ^38
  300|     25|            && column_needs_remainder(ctx.column_stat(idx))
  ------------------
  |  Branch (300:16): [True: 1, False: 24]
  ------------------
  301|      1|        {
  302|      1|            spec.set_policy(ColumnPolicy::Remainder { clip: false });
  303|      1|            remainder_assigned += 1;
  304|     62|        }
  305|       |    }
  306|       |
  307|     27|    specs
  308|     27|}
  309|       |
  310|     80|fn header_text(spans: &[InlineSpan]) -> String {
  311|     80|    let mut text = String::new();
  312|    162|    for span in spans {
                      ^82
  313|     82|        match span {
  314|     74|            InlineSpan::Text(t)
  315|      1|            | InlineSpan::Strong(t)
  316|      1|            | InlineSpan::Emphasis(t)
  317|      1|            | InlineSpan::Strikethrough(t)
  318|      1|            | InlineSpan::Code(t) => {
  319|     78|                if !text.is_empty() {
  ------------------
  |  Branch (319:20): [True: 4, False: 74]
  ------------------
  320|      4|                    text.push(' ');
  321|     74|                }
  322|     78|                text.push_str(t.trim());
  323|       |            }
  324|      2|            InlineSpan::Link { text: t, .. } => {
  325|      2|                if !text.is_empty() {
  ------------------
  |  Branch (325:20): [True: 1, False: 1]
  ------------------
  326|      1|                    text.push(' ');
  327|      1|                }
  328|      2|                text.push_str(t.trim());
  329|       |            }
  330|      2|            InlineSpan::Image { alt, .. } => {
  331|      2|                if !text.is_empty() {
  ------------------
  |  Branch (331:20): [True: 1, False: 1]
  ------------------
  332|      1|                    text.push(' ');
  333|      1|                }
  334|      2|                text.push_str(alt.trim());
  335|       |            }
  336|       |        }
  337|       |    }
  338|     80|    if text.trim().is_empty() {
  ------------------
  |  Branch (338:8): [True: 5, False: 75]
  ------------------
  339|      5|        "Column".to_string()
  340|       |    } else {
  341|     75|        text.trim().to_string()
  342|       |    }
  343|     80|}
  344|       |
  345|     79|fn classify_column(
  346|     79|    label: &str,
  347|     79|    index: usize,
  348|     79|    remainder_assigned: &mut usize,
  349|     79|    stat: Option<&ColumnStat>,
  350|     79|    body_font_px: f32,
  351|     79|) -> ColumnPolicy {
  352|     79|    let lower = label.to_ascii_lowercase();
  353|     79|    if matches_any(&lower, &["version", "rev", "#", "id"]) {
  ------------------
  |  Branch (353:8): [True: 6, False: 73]
  ------------------
  354|      6|        return ColumnPolicy::Fixed {
  355|      6|            width: px(body_font_px, 5.8).clamp(80.0, 160.0),
  356|      6|            clip: true,
  357|      6|        };
  358|     73|    }
  359|     73|    if matches_any(&lower, &["date", "time", "timestamp"]) {
  ------------------
  |  Branch (359:8): [True: 1, False: 72]
  ------------------
  360|      1|        return ColumnPolicy::Fixed {
  361|      1|            width: px(body_font_px, 8.5).clamp(110.0, 200.0),
  362|      1|            clip: false,
  363|      1|        };
  364|     72|    }
  365|     72|    if matches_any(&lower, &["author", "owner", "assignee", "user"]) {
  ------------------
  |  Branch (365:8): [True: 4, False: 68]
  ------------------
  366|      4|        return ColumnPolicy::Resizable {
  367|      4|            min: px(body_font_px, 7.5),
  368|      4|            preferred: px(body_font_px, 10.0),
  369|      4|            clip: false,
  370|      4|        };
  371|     68|    }
  372|     68|    if matches_any(&lower, &["status", "state"]) {
  ------------------
  |  Branch (372:8): [True: 1, False: 67]
  ------------------
  373|      1|        return ColumnPolicy::Fixed {
  374|      1|            width: px(body_font_px, 7.0).clamp(90.0, 180.0),
  375|      1|            clip: true,
  376|      1|        };
  377|     67|    }
  378|     67|    if matches_any(
  ------------------
  |  Branch (378:8): [True: 14, False: 53]
  ------------------
  379|     67|        &lower,
  380|     67|        &["notes", "changes", "description", "details", "summary"],
  381|       |    ) {
  382|     14|        return ColumnPolicy::Resizable {
  383|     14|            min: px(body_font_px, 10.5),
  384|     14|            preferred: px(body_font_px, 14.5),
  385|     14|            clip: false,
  386|     14|        };
  387|     53|    }
  388|     53|    if matches_any(
  ------------------
  |  Branch (388:8): [True: 6, False: 47]
  ------------------
  389|     53|        &lower,
  390|     53|        &["example", "examples", "sample", "use case", "use cases"],
  391|       |    ) {
  392|      6|        *remainder_assigned += 1;
  393|      6|        return ColumnPolicy::Remainder { clip: false };
  394|     47|    }
  395|     47|    if index == 0 {
  ------------------
  |  Branch (395:8): [True: 17, False: 30]
  ------------------
  396|       |        // First column typically identifiers; keep fixed only for short labels.
  397|     17|        if stat
  ------------------
  |  Branch (397:12): [True: 13, False: 4]
  ------------------
  398|     17|            .map(|s| s.max_graphemes <= 18 && s.longest_word <= 12)
                                                            ^14
  ------------------
  |  Branch (398:22): [True: 14, False: 3]
  ------------------
  399|     17|            .unwrap_or_else(|| label.len() <= 12)
                                             ^0    ^0
  400|       |        {
  401|     13|            return ColumnPolicy::Fixed {
  402|     13|                width: px(body_font_px, 7.0).clamp(80.0, 180.0),
  403|     13|                clip: true,
  404|     13|            };
  405|      4|        }
  406|     30|    }
  407|     34|    if *remainder_assigned < MAX_REMAINDER_COLUMNS && column_needs_remainder(stat) {
                                                                    ^33                    ^33
  ------------------
  |  Branch (407:8): [True: 33, False: 1]
  |  Branch (407:55): [True: 5, False: 28]
  ------------------
  408|      5|        *remainder_assigned += 1;
  409|      5|        return ColumnPolicy::Remainder { clip: false };
  410|     29|    }
  411|     29|    ColumnPolicy::Resizable {
  412|     29|        min: px(body_font_px, 7.0),
  413|     29|        preferred: px(body_font_px, 9.5),
  414|     29|        clip: false,
  415|     29|    }
  416|     79|}
  417|       |
  418|     61|fn column_needs_remainder(stat: Option<&ColumnStat>) -> bool {
  419|     61|    if let Some(stat) = stat {
                              ^60
  ------------------
  |  Branch (419:12): [True: 60, False: 1]
  ------------------
  420|     60|        stat.rich_content.has_image
  ------------------
  |  Branch (420:9): [True: 1, False: 59]
  ------------------
  421|     59|            || stat.longest_word > 18
  ------------------
  |  Branch (421:16): [True: 1, False: 58]
  ------------------
  422|     58|            || stat.max_graphemes > 60
  ------------------
  |  Branch (422:16): [True: 2, False: 56]
  ------------------
  423|     56|            || stat.rich_content.has_link
  424|       |    } else {
  425|      1|        false
  426|       |    }
  427|     61|}
  428|       |
  429|    412|fn matches_any(label: &str, needles: &[&str]) -> bool {
  430|  1.47k|    needles.iter().any(|needle| label.contains(needle))
                  ^412           ^412
  431|    412|}
  432|       |
  433|     80|fn column_tooltip(label: &str, policy: &ColumnPolicy) -> Option<String> {
  434|     80|    let description = match policy {
  435|      1|        ColumnPolicy::Auto => "Auto-sized column".to_string(),
  436|     21|        ColumnPolicy::Fixed { width, clip } => format!(
  437|     21|            "Fixed width {:.0}px{}",
  438|       |            width,
  439|     21|            if *clip { " (clipped)" } else { "" }
                                     ^20                   ^1
  ------------------
  |  Branch (439:16): [True: 20, False: 1]
  ------------------
  440|       |        ),
  441|     13|        ColumnPolicy::Remainder { clip } => format!(
  442|     13|            "Shared remainder width{}",
  443|     13|            if *clip { " (clipped)" } else { "" }
                                     ^1                    ^12
  ------------------
  |  Branch (443:16): [True: 1, False: 12]
  ------------------
  444|       |        ),
  445|       |        ColumnPolicy::Resizable {
  446|     45|            min,
  447|     45|            preferred,
  448|     45|            clip,
  449|     45|        } => format!(
  450|     45|            "Resizable (min {:.0}px, start {:.0}px{})",
  451|       |            min,
  452|       |            preferred,
  453|     45|            if *clip { ", clipped" } else { "" }
                                     ^1                   ^44
  ------------------
  |  Branch (453:16): [True: 1, False: 44]
  ------------------
  454|       |        ),
  455|       |    };
  456|     80|    Some(format!("{label}: {description}"))
  457|     80|}
  458|       |
  459|     27|pub fn compute_column_stats(
  460|     27|    headers: &[Vec<InlineSpan>],
  461|     27|    rows: &[Vec<Vec<InlineSpan>>],
  462|     27|    max_samples: usize,
  463|     27|) -> Vec<ColumnStat> {
  464|     27|    let column_count = max(
  465|     27|        headers.len(),
  466|     31|        rows.iter().map(|row| row.len()).max().unwrap_or(0),
                      ^27  ^27    ^27                  ^27   ^27
  467|       |    );
  468|     27|    if column_count == 0 {
  ------------------
  |  Branch (468:8): [True: 1, False: 26]
  ------------------
  469|      1|        return Vec::new();
  470|     26|    }
  471|       |
  472|     26|    let mut stats = vec![ColumnStat::default(); column_count];
  473|       |
  474|     64|    for (idx, header) in headers.iter().enumerate() {
                                       ^26     ^26    ^26
  475|     64|        accumulate_stats_for_cell(header, &mut stats[idx]);
  476|     64|    }
  477|       |
  478|     26|    let mut sampled_rows = 0;
  479|     30|    for row in rows.iter() {
                             ^26  ^26
  480|     76|        for (idx, cell) in row.iter().enumerate().take(column_count) {
                                         ^30        ^30         ^30  ^30
  481|     76|            accumulate_stats_for_cell(cell, &mut stats[idx]);
  482|     76|        }
  483|     30|        sampled_rows += 1;
  484|     30|        if sampled_rows >= max_samples {
  ------------------
  |  Branch (484:12): [True: 1, False: 29]
  ------------------
  485|      1|            break;
  486|     29|        }
  487|       |    }
  488|       |
  489|     26|    stats
  490|     27|}
  491|       |
  492|    145|fn accumulate_stats_for_cell(spans: &[InlineSpan], stat: &mut ColumnStat) {
  493|    145|    if stat.rich_content.has_image {
  ------------------
  |  Branch (493:8): [True: 1, False: 144]
  ------------------
  494|      1|        // rich-content flags persist; skip repeated scans for pure images.
  495|    144|    }
  496|    145|    let mut has_link = stat.rich_content.has_link;
  497|    145|    let mut has_image = stat.rich_content.has_image;
  498|    145|    let mut has_emoji_like = stat.rich_content.has_emoji_like;
  499|       |
  500|    304|    for span in spans {
                      ^159
  501|    159|        match span {
  502|      3|            InlineSpan::Link { .. } => has_link = true,
  503|      2|            InlineSpan::Image { .. } => has_image = true,
  504|    154|            _ => {}
  505|       |        }
  506|       |    }
  507|       |
  508|    145|    let text = spans_to_text(spans);
  509|    145|    if !text.is_empty() {
  ------------------
  |  Branch (509:8): [True: 144, False: 1]
  ------------------
  510|    144|        let graphemes = text.graphemes(true).count();
  511|    144|        let display_width = UnicodeWidthStr::width(text.as_str());
  512|    144|        stat.max_graphemes = stat.max_graphemes.max(display_width.max(graphemes));
  513|       |
  514|    222|        for word in text.split_whitespace() {
                                  ^144 ^144
  515|    222|            let word_len = UnicodeWidthStr::width(word).max(word.graphemes(true).count());
  516|    222|            stat.longest_word = stat.longest_word.max(word_len);
  517|    222|        }
  518|       |
  519|    144|        if !has_emoji_like {
  ------------------
  |  Branch (519:12): [True: 143, False: 1]
  ------------------
  520|  1.13k|            has_emoji_like = text.chars().any(|c| matches!(c as u32, 0x1F300..=0x1FAFF));
                                           ^143         ^143                       ^2
  521|      1|        }
  522|      1|    }
  523|       |
  524|    145|    stat.rich_content = RichContentFlags {
  525|    145|        has_link,
  526|    145|        has_image,
  527|    145|        has_emoji_like,
  528|    145|    };
  529|    145|}
  530|       |
  531|    146|fn spans_to_text(spans: &[InlineSpan]) -> String {
  532|    146|    let mut text = String::new();
  533|    312|    for span in spans {
                      ^166
  534|    166|        match span {
  535|    152|            InlineSpan::Text(t)
  536|      1|            | InlineSpan::Code(t)
  537|      4|            | InlineSpan::Strong(t)
  538|      1|            | InlineSpan::Emphasis(t)
  539|      1|            | InlineSpan::Strikethrough(t) => {
  540|    159|                if !text.is_empty() {
  ------------------
  |  Branch (540:20): [True: 19, False: 140]
  ------------------
  541|     19|                    text.push(' ');
  542|    140|                }
  543|    159|                text.push_str(t);
  544|       |            }
  545|      4|            InlineSpan::Link { text: t, .. } => {
  546|      4|                if !text.is_empty() {
  ------------------
  |  Branch (546:20): [True: 1, False: 3]
  ------------------
  547|      1|                    text.push(' ');
  548|      3|                }
  549|      4|                text.push_str(t);
  550|       |            }
  551|      3|            InlineSpan::Image { alt, .. } => {
  552|      3|                if !text.is_empty() {
  ------------------
  |  Branch (552:20): [True: 1, False: 2]
  ------------------
  553|      1|                    text.push(' ');
  554|      2|                }
  555|      3|                text.push_str(alt);
  556|       |            }
  557|       |        }
  558|       |    }
  559|    146|    text.trim().to_string()
  560|    146|}
  561|       |
  562|       |#[cfg(test)]
  563|       |mod tests {
  564|       |    use super::*;
  565|       |
  566|     39|    fn span(text: &str) -> InlineSpan {
  567|     39|        InlineSpan::Text(text.to_string())
  568|     39|    }
  569|       |
  570|       |    #[test]
  571|      1|    fn classify_version_column() {
  572|      1|        let headers = vec![vec![span("Version")], vec![span("Changes")]];
  573|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  574|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  575|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  576|      1|        let specs = derive_column_specs(&ctx);
  577|      1|        assert!(matches!(specs[0].policy, ColumnPolicy::Fixed { .. }));
                              ^0
  578|      1|        assert!(matches!(specs[1].policy, ColumnPolicy::Remainder { .. }));
                              ^0
  579|      1|    }
  580|       |
  581|       |    #[test]
  582|      1|    fn classify_author_column() {
  583|      1|        let headers = vec![vec![span("Author")], vec![span("Examples")]];
  584|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  585|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  586|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  587|      1|        let specs = derive_column_specs(&ctx);
  588|      1|        assert!(matches!(specs[0].policy, ColumnPolicy::Resizable { .. }));
                              ^0
  589|      1|        assert!(matches!(specs[1].policy, ColumnPolicy::Remainder { .. }));
                              ^0
  590|      1|    }
  591|       |
  592|       |    #[test]
  593|      1|    fn classify_examples_column() {
  594|      1|        let headers = vec![
  595|      1|            vec![span("Element")],
  596|      1|            vec![span("Symbol")],
  597|      1|            vec![span("Description")],
  598|      1|            vec![span("Examples")],
  599|       |        ];
  600|      1|        assert_eq!(header_text(&headers[3]), "Examples");
  601|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  602|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  603|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  604|      1|        let specs = derive_column_specs(&ctx);
  605|      1|        assert!(matches!(specs[3].policy, ColumnPolicy::Remainder { .. }));
                              ^0
  606|      1|        assert!(matches!(specs[2].policy, ColumnPolicy::Resizable { .. }));
                              ^0
  607|      1|    }
  608|       |
  609|       |    #[test]
  610|      1|    fn compute_stats_counts_text() {
  611|      1|        let headers = vec![vec![span("Head")]];
  612|      1|        let rows = vec![vec![vec![span("Emoji  test")]]];
  613|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  614|      1|        assert_eq!(stats.len(), 1);
  615|      1|        assert!(stats[0].max_graphemes >= 4);
  616|      1|        assert!(stats[0].longest_word >= 5);
  617|      1|        assert!(stats[0].rich_content.has_emoji_like);
  618|      1|    }
  619|       |
  620|       |    #[test]
  621|      1|    fn fallback_assigns_remainder_based_on_stats() {
  622|      1|        let headers = vec![vec![span("Foo")], vec![span("Bar")]];
  623|      1|        let rows = vec![vec![
  624|      1|            vec![span("Short")],
  625|      1|            vec![span(
  626|      1|                "This column contains a very long sentence that should force remainder selection.",
  627|       |            )],
  628|       |        ]];
  629|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  630|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  631|      1|        let specs = derive_column_specs(&ctx);
  632|      1|        assert!(matches!(specs[1].policy, ColumnPolicy::Remainder { .. }));
                              ^0
  633|      1|    }
  634|       |
  635|       |    #[test]
  636|      1|    fn fallback_avoids_first_column_when_possible() {
  637|      1|        let headers = vec![
  638|      1|            vec![span("Center")],
  639|      1|            vec![span("Left")],
  640|      1|            vec![span("Right")],
  641|       |        ];
  642|      1|        let rows = vec![vec![
  643|      1|            vec![span("Centered label with enough words to raise score")],
  644|      1|            vec![span("L1")],
  645|      1|            vec![span("R1")],
  646|       |        ]];
  647|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  648|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  649|      1|        let specs = derive_column_specs(&ctx);
  650|      1|        assert!(!matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
  651|      1|        assert!(specs[1..]
  652|      1|            .iter()
  653|      2|            .any(|spec| matches!(spec.policy, ColumnPolicy::Remainder { .. })));
                           ^1
  654|      1|    }
  655|       |
  656|       |    #[test]
  657|      1|    fn fallback_skips_fixed_candidate_for_remainder() {
  658|      1|        let headers = vec![
  659|      1|            vec![span("Version")],
  660|      1|            vec![span("Notes")],
  661|      1|            vec![span("Owner")],
  662|       |        ];
  663|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  664|      1|        let stats = vec![
  665|      1|            ColumnStat {
  666|      1|                max_graphemes: 50,
  667|      1|                longest_word: 10,
  668|      1|                rich_content: RichContentFlags {
  669|      1|                    has_link: false,
  670|      1|                    has_image: false,
  671|      1|                    has_emoji_like: false,
  672|      1|                },
  673|      1|            },
  674|      1|            ColumnStat {
  675|      1|                max_graphemes: 5,
  676|      1|                longest_word: 5,
  677|      1|                rich_content: RichContentFlags {
  678|      1|                    has_link: false,
  679|      1|                    has_image: false,
  680|      1|                    has_emoji_like: false,
  681|      1|                },
  682|      1|            },
  683|      1|            ColumnStat {
  684|      1|                max_graphemes: 4,
  685|      1|                longest_word: 4,
  686|      1|                rich_content: RichContentFlags {
  687|      1|                    has_link: false,
  688|      1|                    has_image: false,
  689|      1|                    has_emoji_like: false,
  690|      1|                },
  691|      1|            },
  692|       |        ];
  693|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  694|      1|        let specs = derive_column_specs(&ctx);
  695|      1|        assert!(matches!(specs[0].policy, ColumnPolicy::Fixed { .. }));
                              ^0
  696|      1|        assert!(specs[1..]
  697|      1|            .iter()
  698|      1|            .any(|spec| matches!(spec.policy, ColumnPolicy::Remainder { .. })));
  699|      1|    }
  700|       |
  701|       |    #[test]
  702|      1|    fn examples_header_prefers_remainder() {
  703|      1|        let headers = vec![vec![span("Examples")], vec![span("Description")]];
  704|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
  705|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  706|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 16.0, 0);
  707|      1|        let specs = derive_column_specs(&ctx);
  708|      1|        assert!(matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
                              ^0
  709|      1|        assert!(matches!(specs[1].policy, ColumnPolicy::Resizable { .. }));
                              ^0
  710|      1|    }
  711|       |
  712|       |    #[test]
  713|      1|    fn multiple_remainder_columns_allowed() {
  714|      1|        let headers = vec![
  715|      1|            vec![span("Summary")],
  716|      1|            vec![span("Details")],
  717|      1|            vec![span("Examples")],
  718|       |        ];
  719|      1|        let rows = vec![vec![
  720|      1|            vec![span("short")],
  721|      1|            vec![span(
  722|      1|                "Long content that should trigger a remainder column due to its width and words.",
  723|       |            )],
  724|      1|            vec![span(
  725|      1|                "Another large column with links https://example.com and more text.",
  726|       |            )],
  727|       |        ]];
  728|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  729|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  730|      1|        let specs = derive_column_specs(&ctx);
  731|      1|        let remainder_count = specs
  732|      1|            .iter()
  733|      3|            .filter(|s| matches!(s.policy, ColumnPolicy::Remainder { .. }))
                           ^1
  734|      1|            .count();
  735|      1|        assert!(remainder_count >= 2);
  736|      1|    }
  737|       |
  738|       |    #[test]
  739|      1|    fn cjk_widths_increase_stat_estimates() {
  740|      1|        let headers = vec![vec![span("")], vec![span("Column")]];
  741|      1|        let rows = vec![vec![vec![span("")], vec![span("short")]]];
  742|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  743|      1|        assert!(stats[0].max_graphemes > stats[1].max_graphemes);
  744|      1|    }
  745|       |
  746|       |    #[test]
  747|      1|    fn test_header_text_and_spans_to_text_variants() {
  748|      1|        let spans = vec![
  749|      1|            InlineSpan::Text(" Alpha ".to_string()),
  750|      1|            InlineSpan::Strong("Beta".to_string()),
  751|      1|            InlineSpan::Emphasis("Gamma".to_string()),
  752|      1|            InlineSpan::Strikethrough("Delta".to_string()),
  753|      1|            InlineSpan::Code("Epsilon".to_string()),
  754|      1|            InlineSpan::Link {
  755|      1|                text: "Zeta".to_string(),
  756|      1|                url: "https://example.invalid".to_string(),
  757|      1|            },
  758|      1|            InlineSpan::Image {
  759|      1|                src: "img.png".to_string(),
  760|      1|                alt: "Eta".to_string(),
  761|      1|                title: None,
  762|      1|            },
  763|       |        ];
  764|       |
  765|      1|        let header = header_text(&spans);
  766|      1|        assert!(header.contains("Alpha"));
  767|      1|        assert!(header.contains("Beta"));
  768|      1|        assert!(header.contains("Zeta"));
  769|      1|        assert!(header.contains("Eta"));
  770|       |
  771|      1|        let text = spans_to_text(&spans);
  772|      1|        assert!(text.contains("Alpha"));
  773|      1|        assert!(text.contains("Zeta"));
  774|      1|        assert!(text.contains("Eta"));
  775|       |
  776|      1|        assert_eq!(header_text(&[]), "Column");
  777|      1|        assert_eq!(
  778|      1|            header_text(&[InlineSpan::Text("   ".to_string())]),
  779|       |            "Column"
  780|       |        );
  781|      1|    }
  782|       |
  783|       |    #[test]
  784|      1|    fn test_column_policy_to_column_and_tooltip() {
  785|      1|        let policies = vec![
  786|      1|            ColumnPolicy::Auto,
  787|      1|            ColumnPolicy::Fixed {
  788|      1|                width: 120.0,
  789|      1|                clip: true,
  790|      1|            },
  791|      1|            ColumnPolicy::Remainder { clip: false },
  792|      1|            ColumnPolicy::Resizable {
  793|      1|                min: 50.0,
  794|      1|                preferred: 140.0,
  795|      1|                clip: true,
  796|      1|            },
  797|       |        ];
  798|       |
  799|      5|        for policy in policies {
                          ^4
  800|      4|            let _col = policy.to_column();
  801|      4|            let tooltip = column_tooltip("Header", &policy).expect("tooltip");
  802|      4|            assert!(tooltip.contains("Header"));
  803|       |        }
  804|      1|    }
  805|       |
  806|       |    #[test]
  807|      1|    fn test_apply_preferred_width_clamps_and_hash_stable_for_resizable() {
  808|      1|        let mut spec = ColumnSpec::new(
  809|       |            0,
  810|       |            "body",
  811|      1|            ColumnPolicy::Resizable {
  812|      1|                min: 50.0,
  813|      1|                preferred: 120.0,
  814|      1|                clip: false,
  815|      1|            },
  816|      1|            None,
  817|       |        );
  818|      1|        let original_hash = spec.policy_hash;
  819|      1|        spec.apply_preferred_width(10.0);
  820|      1|        assert!(matches!(spec.policy, ColumnPolicy::Resizable { .. }));
                              ^0
  821|      1|        assert_eq!(spec.policy_hash, original_hash);
  822|       |
  823|      1|        let mut fixed = ColumnSpec::new(
  824|       |            1,
  825|       |            "fixed",
  826|      1|            ColumnPolicy::Fixed {
  827|      1|                width: 40.0,
  828|      1|                clip: false,
  829|      1|            },
  830|      1|            None,
  831|       |        );
  832|      1|        let fixed_hash = fixed.policy_hash;
  833|      1|        fixed.apply_preferred_width(100.0);
  834|      1|        assert_eq!(fixed.policy_hash, fixed_hash);
  835|      1|    }
  836|       |
  837|       |    #[test]
  838|      1|    fn test_column_spec_hash_includes_index() {
  839|      1|        let policy = ColumnPolicy::Resizable {
  840|      1|            min: 40.0,
  841|      1|            preferred: 120.0,
  842|      1|            clip: false,
  843|      1|        };
  844|      1|        let first = ColumnSpec::new(0, "Header", policy.clone(), None);
  845|      1|        let second = ColumnSpec::new(1, "Header", policy, None);
  846|      1|        assert_ne!(first.policy_hash, second.policy_hash);
  847|      1|    }
  848|       |
  849|       |    #[test]
  850|      1|    fn test_compute_column_stats_empty() {
  851|      1|        let stats = compute_column_stats(&[], &[], 10);
  852|      1|        assert!(stats.is_empty());
  853|      1|    }
  854|       |
  855|       |    #[test]
  856|      1|    fn test_classify_date_status_notes_columns() {
  857|      1|        let mut remainder = 0usize;
  858|      1|        let date_policy = classify_column("Date", 0, &mut remainder, None, 14.0);
  859|      1|        let status_policy = classify_column("Status", 1, &mut remainder, None, 14.0);
  860|      1|        let notes_policy = classify_column("Notes", 2, &mut remainder, None, 14.0);
  861|       |
  862|      1|        assert!(matches!(date_policy, ColumnPolicy::Fixed { .. }));
                              ^0
  863|      1|        assert!(matches!(status_policy, ColumnPolicy::Fixed { .. }));
                              ^0
  864|      1|        assert!(matches!(notes_policy, ColumnPolicy::Resizable { .. }));
                              ^0
  865|      1|    }
  866|       |
  867|       |    #[test]
  868|      1|    fn test_derive_column_specs_remainder_for_rich_content() {
  869|      1|        let headers = vec![vec![span("Body")]];
  870|      1|        let rows = vec![vec![vec![InlineSpan::Link {
  871|      1|            text: "verylonglinkword".to_string(),
  872|      1|            url: "https://example.invalid".to_string(),
  873|      1|        }]]];
  874|      1|        let stats = compute_column_stats(&headers, &rows, 32);
  875|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
  876|      1|        let specs = derive_column_specs(&ctx);
  877|       |
  878|      1|        assert!(matches!(specs[0].policy, ColumnPolicy::Remainder { .. }));
                              ^0
  879|      1|    }
  880|       |
  881|       |    #[test]
  882|      1|    fn test_normalize_body_font_px_defaults_for_invalid_values() {
  883|      1|        assert_eq!(normalize_body_font_px(f32::NAN), 14.0);
  884|      1|        assert_eq!(normalize_body_font_px(-10.0), 14.0);
  885|      1|        assert_eq!(normalize_body_font_px(0.0), 14.0);
  886|      1|        assert_eq!(normalize_body_font_px(12.0), 12.0);
  887|      1|        assert_eq!(px(10.0, 2.0), 20.0);
  888|      1|    }
  889|       |
  890|       |    #[test]
  891|      1|    fn test_column_policy_tooltip_variants_for_clip_flags() {
  892|      1|        let fixed = ColumnPolicy::Fixed {
  893|      1|            width: 120.0,
  894|      1|            clip: false,
  895|      1|        };
  896|      1|        let remainder = ColumnPolicy::Remainder { clip: true };
  897|       |
  898|      1|        let fixed_tooltip = column_tooltip("Fixed", &fixed).expect("tooltip");
  899|      1|        assert!(!fixed_tooltip.contains("clipped"));
  900|       |
  901|      1|        let remainder_tooltip = column_tooltip("Remainder", &remainder).expect("tooltip");
  902|      1|        assert!(remainder_tooltip.contains("clipped"));
  903|      1|    }
  904|       |
  905|       |    #[test]
  906|      1|    fn test_set_policy_updates_hash() {
  907|      1|        let mut spec = ColumnSpec::new(0, "col", ColumnPolicy::Auto, None);
  908|      1|        let original = spec.policy_hash;
  909|      1|        spec.set_policy(ColumnPolicy::Fixed {
  910|      1|            width: 100.0,
  911|      1|            clip: true,
  912|      1|        });
  913|      1|        assert_ne!(spec.policy_hash, original);
  914|      1|    }
  915|       |
  916|       |    #[test]
  917|      1|    fn test_apply_preferred_width_updates_preferred_value() {
  918|      1|        let mut spec = ColumnSpec::new(
  919|       |            0,
  920|       |            "body",
  921|      1|            ColumnPolicy::Resizable {
  922|      1|                min: 50.0,
  923|      1|                preferred: 120.0,
  924|      1|                clip: false,
  925|      1|            },
  926|      1|            None,
  927|       |        );
  928|      1|        spec.apply_preferred_width(180.0);
  929|      1|        assert!(matches!(spec.policy, ColumnPolicy::Resizable { .. }));
                              ^0
  930|      1|    }
  931|       |
  932|       |    #[test]
  933|      1|    fn test_column_policy_hash_variants() {
  934|      1|        let policies = [
  935|      1|            ColumnPolicy::Auto,
  936|      1|            ColumnPolicy::Fixed {
  937|      1|                width: 120.0,
  938|      1|                clip: true,
  939|      1|            },
  940|      1|            ColumnPolicy::Remainder { clip: true },
  941|      1|            ColumnPolicy::Resizable {
  942|      1|                min: 40.0,
  943|      1|                preferred: 120.0,
  944|      1|                clip: true,
  945|      1|            },
  946|      1|        ];
  947|      5|        for policy in policies {
                          ^4
  948|      4|            let mut hasher = std::collections::hash_map::DefaultHasher::new();
  949|      4|            policy.hash(&mut hasher);
  950|      4|            let _ = hasher.finish();
  951|      4|        }
  952|      1|    }
  953|       |
  954|       |    #[test]
  955|      1|    fn test_column_policy_to_column_clipped_variants() {
  956|      1|        let fixed = ColumnPolicy::Fixed {
  957|      1|            width: 120.0,
  958|      1|            clip: true,
  959|      1|        };
  960|      1|        let fixed_unclipped = ColumnPolicy::Fixed {
  961|      1|            width: 120.0,
  962|      1|            clip: false,
  963|      1|        };
  964|      1|        let remainder = ColumnPolicy::Remainder { clip: true };
  965|      1|        let resizable = ColumnPolicy::Resizable {
  966|      1|            min: 40.0,
  967|      1|            preferred: 120.0,
  968|      1|            clip: true,
  969|      1|        };
  970|      1|        let _ = fixed.to_column();
  971|      1|        let _ = fixed_unclipped.to_column();
  972|      1|        let _ = remainder.to_column();
  973|      1|        let _ = resizable.to_column();
  974|      1|    }
  975|       |
  976|       |    #[test]
  977|      1|    fn test_column_needs_remainder_none_is_false() {
  978|      1|        assert!(!column_needs_remainder(None));
  979|      1|    }
  980|       |
  981|       |    #[test]
  982|      1|    fn test_accumulate_stats_for_cell_tracks_images() {
  983|      1|        let spans = vec![InlineSpan::Image {
  984|      1|            src: "img.png".to_string(),
  985|      1|            alt: "Alt".to_string(),
  986|      1|            title: None,
  987|      1|        }];
  988|      1|        let mut stat = ColumnStat::default();
  989|      1|        accumulate_stats_for_cell(&spans, &mut stat);
  990|      1|        assert!(stat.rich_content.has_image);
  991|      1|    }
  992|       |
  993|       |    #[test]
  994|      1|    fn test_accumulate_stats_detects_emoji_like_text() {
  995|      1|        let emoji = char::from_u32(0x1F600).expect("emoji");
  996|      1|        let spans = vec![InlineSpan::Text(format!("Hello {emoji}"))];
  997|      1|        let mut stat = ColumnStat::default();
  998|      1|        accumulate_stats_for_cell(&spans, &mut stat);
  999|      1|        assert!(stat.rich_content.has_emoji_like);
 1000|      1|    }
 1001|       |
 1002|       |    #[test]
 1003|      1|    fn test_remainder_cap_forces_resizable() {
 1004|      1|        let mut remainder = MAX_REMAINDER_COLUMNS;
 1005|      1|        let stat = ColumnStat {
 1006|      1|            max_graphemes: 80,
 1007|      1|            longest_word: 40,
 1008|      1|            rich_content: RichContentFlags {
 1009|      1|                has_link: true,
 1010|      1|                has_image: false,
 1011|      1|                has_emoji_like: false,
 1012|      1|            },
 1013|      1|        };
 1014|      1|        let policy = classify_column("Notes", 2, &mut remainder, Some(&stat), 14.0);
 1015|      1|        assert!(matches!(policy, ColumnPolicy::Resizable { .. }));
                              ^0
 1016|      1|    }
 1017|       |
 1018|       |    #[test]
 1019|      1|    fn test_compute_column_stats_respects_max_samples() {
 1020|      1|        let headers = vec![vec![span("Header")]];
 1021|      1|        let rows = vec![
 1022|      1|            vec![vec![span("short")]],
 1023|      1|            vec![vec![span("this_is_a_much_longer_token")]],
 1024|       |        ];
 1025|      1|        let stats = compute_column_stats(&headers, &rows, 1);
 1026|      1|        assert_eq!(stats.len(), 1);
 1027|      1|        assert!(stats[0].longest_word < 20, "should ignore second row");
                                                          ^0
 1028|      1|    }
 1029|       |
 1030|       |    #[test]
 1031|      1|    fn test_accumulate_stats_preserves_existing_flags() {
 1032|      1|        let mut stat = ColumnStat {
 1033|      1|            max_graphemes: 0,
 1034|      1|            longest_word: 0,
 1035|      1|            rich_content: RichContentFlags {
 1036|      1|                has_link: false,
 1037|      1|                has_image: true,
 1038|      1|                has_emoji_like: false,
 1039|      1|            },
 1040|      1|        };
 1041|      1|        accumulate_stats_for_cell(&[InlineSpan::Text("plain".to_string())], &mut stat);
 1042|      1|        assert!(stat.rich_content.has_image);
 1043|      1|        assert!(!stat.rich_content.has_link);
 1044|      1|    }
 1045|       |
 1046|       |    #[test]
 1047|      1|    fn test_derive_column_specs_empty_context_returns_empty() {
 1048|      1|        let headers: Vec<Vec<InlineSpan>> = Vec::new();
 1049|      1|        let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();
 1050|      1|        let stats: Vec<ColumnStat> = Vec::new();
 1051|      1|        let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
 1052|      1|        let specs = derive_column_specs(&ctx);
 1053|      1|        assert!(specs.is_empty());
 1054|      1|    }
 1055|       |
 1056|       |    #[test]
 1057|      1|    fn test_header_text_link_and_image_first() {
 1058|      1|        let spans = vec![InlineSpan::Link {
 1059|      1|            text: "Docs".to_string(),
 1060|      1|            url: "https://example.com".to_string(),
 1061|      1|        }];
 1062|      1|        assert_eq!(header_text(&spans), "Docs");
 1063|      1|        let spans = vec![InlineSpan::Image {
 1064|      1|            src: "img.png".to_string(),
 1065|      1|            alt: "Diagram".to_string(),
 1066|      1|            title: None,
 1067|      1|        }];
 1068|      1|        assert_eq!(header_text(&spans), "Diagram");
 1069|      1|    }
 1070|       |
 1071|       |    #[test]
 1072|      1|    fn test_column_needs_remainder_true_for_long_words() {
 1073|      1|        let stat = ColumnStat {
 1074|      1|            max_graphemes: 10,
 1075|      1|            longest_word: 24,
 1076|      1|            rich_content: RichContentFlags {
 1077|      1|                has_link: false,
 1078|      1|                has_image: false,
 1079|      1|                has_emoji_like: false,
 1080|      1|            },
 1081|      1|        };
 1082|      1|        assert!(column_needs_remainder(Some(&stat)));
 1083|      1|    }
 1084|       |
 1085|       |    #[test]
 1086|      1|    fn test_column_needs_remainder_true_for_images() {
 1087|      1|        let stat = ColumnStat {
 1088|      1|            max_graphemes: 5,
 1089|      1|            longest_word: 5,
 1090|      1|            rich_content: RichContentFlags {
 1091|      1|                has_link: false,
 1092|      1|                has_image: true,
 1093|      1|                has_emoji_like: false,
 1094|      1|            },
 1095|      1|        };
 1096|      1|        assert!(column_needs_remainder(Some(&stat)));
 1097|      1|    }
 1098|       |
 1099|       |    #[test]
 1100|      1|    fn test_classify_column_skips_remainder_when_limit_reached() {
 1101|      1|        let mut remainder_assigned = MAX_REMAINDER_COLUMNS;
 1102|      1|        let stat = ColumnStat {
 1103|      1|            max_graphemes: 2,
 1104|      1|            longest_word: 2,
 1105|      1|            rich_content: RichContentFlags {
 1106|      1|                has_link: false,
 1107|      1|                has_image: true,
 1108|      1|                has_emoji_like: false,
 1109|      1|            },
 1110|      1|        };
 1111|      1|        let policy = classify_column("misc", 1, &mut remainder_assigned, Some(&stat), 14.0);
 1112|      1|        assert!(matches!(policy, ColumnPolicy::Resizable { .. }));
                              ^0
 1113|      1|    }
 1114|       |
 1115|       |    #[test]
 1116|      1|    fn test_accumulate_stats_empty_text_and_existing_emoji_flag() {
 1117|      1|        let mut stat = ColumnStat {
 1118|      1|            max_graphemes: 0,
 1119|      1|            longest_word: 0,
 1120|      1|            rich_content: RichContentFlags {
 1121|      1|                has_link: false,
 1122|      1|                has_image: false,
 1123|      1|                has_emoji_like: true,
 1124|      1|            },
 1125|      1|        };
 1126|      1|        accumulate_stats_for_cell(&[InlineSpan::Text("Hello".to_string())], &mut stat);
 1127|      1|        assert!(stat.rich_content.has_emoji_like);
 1128|       |
 1129|      1|        let mut empty_stat = ColumnStat::default();
 1130|      1|        accumulate_stats_for_cell(&[], &mut empty_stat);
 1131|      1|        assert_eq!(empty_stat.max_graphemes, 0);
 1132|      1|    }
 1133|       |}

C:\language\mdmdview\src\table_support\metrics.rs:
    1|       |use std::collections::HashMap;
    2|       |
    3|       |#[allow(dead_code)]
    4|       |#[derive(Debug, Default, Clone)]
    5|       |pub struct RowMetrics {
    6|       |    pub max_height: f32,
    7|       |    pub dirty: bool,
    8|       |}
    9|       |
   10|       |#[allow(dead_code)]
   11|       |#[derive(Debug, Default, Clone)]
   12|       |pub struct TableMetricEntry {
   13|       |    pub rows: Vec<RowMetrics>,
   14|       |    pub rendered_rows: usize,
   15|       |    pub total_rows: usize,
   16|       |    pub header_height: f32,
   17|       |    pub resolved_widths: Vec<f32>,
   18|       |    pub last_width_frame: u64,
   19|       |    pub last_discard_frame: Option<u64>,
   20|       |    pub persisted_column_widths: HashMap<u64, f32>,
   21|       |    pub pending_user_resize: Option<PendingResize>,
   22|       |    /// Font size when widths were last persisted. Used to invalidate
   23|       |    /// persisted widths when zoom level changes.
   24|       |    pub persisted_font_size: Option<f32>,
   25|       |}
   26|       |
   27|       |#[derive(Debug, Clone, Copy)]
   28|       |pub struct PendingResize {
   29|       |    pub column_hash: u64,
   30|       |    pub width: f32,
   31|       |}
   32|       |
   33|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   34|       |pub enum WidthChange {
   35|       |    None,
   36|       |    Small,
   37|       |    Large,
   38|       |}
   39|       |
   40|       |const WIDTH_EPSILON: f32 = 0.15;
   41|       |const WIDTH_LARGE_DELTA: f32 = 0.75;
   42|       |
   43|       |impl TableMetricEntry {
   44|     25|    pub fn ensure_row(&mut self, index: usize) -> &mut RowMetrics {
   45|     25|        if index >= self.rows.len() {
  ------------------
  |  Branch (45:12): [True: 24, False: 1]
  ------------------
   46|     24|            self.rows.resize_with(index + 1, RowMetrics::default);
   47|     24|        }
                      ^1
   48|     25|        &mut self.rows[index]
   49|     25|    }
   50|       |
   51|     27|    pub fn row(&self, index: usize) -> Option<&RowMetrics> {
   52|     27|        self.rows.get(index)
   53|     27|    }
   54|       |
   55|     19|    pub fn begin_pass(&mut self, total_rows: usize) {
   56|     19|        self.total_rows = total_rows;
   57|     19|        self.rendered_rows = 0;
   58|     19|    }
   59|       |
   60|     29|    pub fn note_row_rendered(&mut self) {
   61|     29|        self.rendered_rows += 1;
   62|     29|    }
   63|       |
   64|     86|    pub fn persisted_width(&self, key: u64) -> Option<f32> {
   65|     86|        self.persisted_column_widths.get(&key).copied()
   66|     86|    }
   67|       |
   68|     24|    pub fn set_persisted_width(&mut self, key: u64, width: f32) {
   69|     24|        self.persisted_column_widths.insert(key, width);
   70|     24|    }
   71|       |
   72|      1|    pub fn remove_persisted_width(&mut self, key: u64) {
   73|      1|        self.persisted_column_widths.remove(&key);
   74|      1|    }
   75|       |
   76|     22|    pub fn update_widths(&mut self, widths: &[f32], frame_id: u64) -> WidthChange {
   77|     22|        if widths.is_empty() {
  ------------------
  |  Branch (77:12): [True: 1, False: 21]
  ------------------
   78|      1|            self.resolved_widths.clear();
   79|      1|            self.last_width_frame = frame_id;
   80|      1|            return WidthChange::None;
   81|     21|        }
   82|       |
   83|     21|        let first_update = self.resolved_widths.is_empty();
   84|     21|        let mut change = WidthChange::None;
   85|     21|        if !first_update && self.resolved_widths.len() != widths.len() {
                                          ^4                   ^4
  ------------------
  |  Branch (85:12): [True: 4, False: 17]
  |  Branch (85:29): [True: 1, False: 3]
  ------------------
   86|      1|            change = WidthChange::Large;
   87|      1|        } else {
   88|     20|            for (old, new) in self.resolved_widths.iter().zip(widths.iter()) {
                               ^8   ^8
   89|      8|                let delta = (old - new).abs();
   90|      8|                if delta > WIDTH_LARGE_DELTA {
  ------------------
  |  Branch (90:20): [True: 1, False: 7]
  ------------------
   91|      1|                    change = WidthChange::Large;
   92|      1|                    break;
   93|      7|                }
   94|      7|                if delta > WIDTH_EPSILON {
  ------------------
  |  Branch (94:20): [True: 2, False: 5]
  ------------------
   95|      2|                    change = WidthChange::Small;
   96|      5|                }
   97|       |            }
   98|       |        }
   99|       |
  100|     21|        self.resolved_widths.clear();
  101|     21|        self.resolved_widths.extend_from_slice(widths);
  102|     21|        self.last_width_frame = frame_id;
  103|       |
  104|     21|        change
  105|     22|    }
  106|       |
  107|     19|    pub fn header_height(&self) -> Option<f32> {
  108|     19|        if self.header_height > 0.0 {
  ------------------
  |  Branch (108:12): [True: 3, False: 16]
  ------------------
  109|      3|            Some(self.header_height)
  110|       |        } else {
  111|     16|            None
  112|       |        }
  113|     19|    }
  114|       |
  115|     19|    pub fn update_header_height(&mut self, height: f32) -> bool {
  116|     19|        let clamped = height.max(0.0);
  117|     19|        if (self.header_height - clamped).abs() > 0.5 {
  ------------------
  |  Branch (117:12): [True: 17, False: 2]
  ------------------
  118|     17|            self.header_height = clamped;
  119|     17|            true
  120|       |        } else {
  121|      2|            false
  122|       |        }
  123|     19|    }
  124|       |
  125|     18|    pub fn current_widths(&self) -> &[f32] {
  126|     18|        &self.resolved_widths
  127|     18|    }
  128|       |
  129|       |    /// Check if font size has changed since widths were last persisted.
  130|       |    /// If so, clear all persisted widths and update the stored font size.
  131|       |    /// Returns true if widths were cleared.
  132|     25|    pub fn check_font_size_change(&mut self, current_font_size: f32) -> bool {
  133|       |        const FONT_SIZE_EPSILON: f32 = 0.5;
  134|     25|        if let Some(stored_font) = self.persisted_font_size {
                                  ^5
  ------------------
  |  Branch (134:16): [True: 5, False: 20]
  ------------------
  135|      5|            if (stored_font - current_font_size).abs() > FONT_SIZE_EPSILON {
  ------------------
  |  Branch (135:16): [True: 2, False: 3]
  ------------------
  136|      2|                self.persisted_column_widths.clear();
  137|      2|                self.persisted_font_size = Some(current_font_size);
  138|      2|                return true;
  139|      3|            }
  140|     20|        } else {
  141|     20|            self.persisted_font_size = Some(current_font_size);
  142|     20|        }
  143|     23|        false
  144|     25|    }
  145|       |}
  146|       |
  147|       |#[allow(dead_code)]
  148|       |#[derive(Debug, Default, Clone)]
  149|       |pub struct TableMetrics {
  150|       |    tables: HashMap<u64, TableMetricEntry>,
  151|       |}
  152|       |
  153|       |impl TableMetrics {
  154|    140|    pub fn entry_mut(&mut self, table_id: u64) -> &mut TableMetricEntry {
  155|    140|        self.tables.entry(table_id).or_default()
  156|    140|    }
  157|       |
  158|     82|    pub fn entry(&self, table_id: u64) -> Option<&TableMetricEntry> {
  159|     82|        self.tables.get(&table_id)
  160|     82|    }
  161|       |
  162|      3|    pub fn totals(&self) -> (usize, usize) {
  163|      3|        self.tables
  164|      3|            .values()
  165|      4|            .fold((0, 0), |(rendered, total), entry| {
                           ^3   ^3
  166|      4|                (rendered + entry.rendered_rows, total + entry.total_rows)
  167|      4|            })
  168|      3|    }
  169|       |
  170|    201|    pub fn clear(&mut self) {
  171|    201|        self.tables.clear();
  172|    201|    }
  173|       |}
  174|       |
  175|       |#[allow(dead_code)]
  176|       |#[derive(Debug, Default, Clone)]
  177|       |pub struct CacheStats {
  178|       |    pub hits: u64,
  179|       |    pub misses: u64,
  180|       |}
  181|       |
  182|       |impl CacheStats {
  183|      2|    pub fn record_hit(&mut self) {
  184|      2|        self.hits += 1;
  185|      2|    }
  186|       |
  187|      1|    pub fn record_miss(&mut self) {
  188|      1|        self.misses += 1;
  189|      1|    }
  190|       |}
  191|       |
  192|       |#[cfg(test)]
  193|       |mod tests {
  194|       |    use super::*;
  195|       |
  196|       |    #[test]
  197|      1|    fn update_widths_detects_large_change() {
  198|      1|        let mut entry = TableMetricEntry::default();
  199|      1|        assert_eq!(entry.update_widths(&[100.0, 120.0], 1), WidthChange::None);
  200|      1|        assert_eq!(entry.update_widths(&[100.2, 120.6], 2), WidthChange::Small);
  201|      1|        assert_eq!(entry.update_widths(&[140.0, 120.6], 3), WidthChange::Large);
  202|      1|    }
  203|       |
  204|       |    #[test]
  205|      1|    fn font_size_change_clears_persisted_widths() {
  206|      1|        let mut entry = TableMetricEntry::default();
  207|       |
  208|       |        // Set some persisted widths at font size 14.0
  209|      1|        entry.set_persisted_width(1, 100.0);
  210|      1|        entry.set_persisted_width(2, 150.0);
  211|      1|        assert!(!entry.check_font_size_change(14.0)); // First call sets baseline
  212|      1|        assert_eq!(entry.persisted_width(1), Some(100.0));
  213|      1|        assert_eq!(entry.persisted_width(2), Some(150.0));
  214|       |
  215|       |        // Small font size change (within epsilon) should NOT clear
  216|      1|        assert!(!entry.check_font_size_change(14.3));
  217|      1|        assert_eq!(entry.persisted_width(1), Some(100.0));
  218|       |
  219|       |        // Large font size change should clear all persisted widths
  220|      1|        assert!(entry.check_font_size_change(16.0));
  221|      1|        assert_eq!(entry.persisted_width(1), None);
  222|      1|        assert_eq!(entry.persisted_width(2), None);
  223|      1|        assert_eq!(entry.persisted_font_size, Some(16.0));
  224|      1|    }
  225|       |
  226|       |    #[test]
  227|      1|    fn row_management_tracks_rows_and_rendered_counts() {
  228|      1|        let mut entry = TableMetricEntry::default();
  229|      1|        entry.begin_pass(3);
  230|      1|        assert_eq!(entry.total_rows, 3);
  231|      1|        assert_eq!(entry.rendered_rows, 0);
  232|       |
  233|      1|        let row = entry.ensure_row(2);
  234|      1|        row.max_height = 12.0;
  235|      1|        row.dirty = true;
  236|       |
  237|      1|        assert_eq!(entry.row(2).map(|r| r.max_height), Some(12.0));
  238|      1|        assert_eq!(entry.row(2).map(|r| r.dirty), Some(true));
  239|      1|        assert!(entry.row(5).is_none());
  240|       |
  241|      1|        entry.note_row_rendered();
  242|      1|        entry.note_row_rendered();
  243|      1|        assert_eq!(entry.rendered_rows, 2);
  244|      1|    }
  245|       |
  246|       |    #[test]
  247|      1|    fn persisted_widths_can_be_added_and_removed() {
  248|      1|        let mut entry = TableMetricEntry::default();
  249|      1|        assert!(entry.persisted_width(10).is_none());
  250|      1|        entry.set_persisted_width(10, 123.0);
  251|      1|        assert_eq!(entry.persisted_width(10), Some(123.0));
  252|      1|        entry.remove_persisted_width(10);
  253|      1|        assert!(entry.persisted_width(10).is_none());
  254|      1|    }
  255|       |
  256|       |    #[test]
  257|      1|    fn update_widths_handles_empty_and_length_change() {
  258|      1|        let mut entry = TableMetricEntry::default();
  259|      1|        assert_eq!(entry.update_widths(&[], 1), WidthChange::None);
  260|      1|        assert!(entry.current_widths().is_empty());
  261|       |
  262|      1|        assert_eq!(entry.update_widths(&[50.0, 60.0], 2), WidthChange::None);
  263|      1|        assert_eq!(entry.update_widths(&[50.0], 3), WidthChange::Large);
  264|      1|    }
  265|       |
  266|       |    #[test]
  267|      1|    fn header_height_updates_when_changed() {
  268|      1|        let mut entry = TableMetricEntry::default();
  269|      1|        assert!(entry.header_height().is_none());
  270|      1|        assert!(entry.update_header_height(24.0));
  271|      1|        assert_eq!(entry.header_height(), Some(24.0));
  272|      1|        assert!(!entry.update_header_height(24.2));
  273|      1|        assert!(entry.update_header_height(30.0));
  274|      1|        assert_eq!(entry.header_height(), Some(30.0));
  275|      1|    }
  276|       |
  277|       |    #[test]
  278|      1|    fn table_metrics_totals_and_clear() {
  279|      1|        let mut metrics = TableMetrics::default();
  280|      1|        metrics.entry_mut(1).begin_pass(2);
  281|      1|        metrics.entry_mut(1).note_row_rendered();
  282|      1|        metrics.entry_mut(2).begin_pass(3);
  283|      1|        metrics.entry_mut(2).note_row_rendered();
  284|      1|        metrics.entry_mut(2).note_row_rendered();
  285|       |
  286|      1|        assert_eq!(metrics.totals(), (3, 5));
  287|      1|        metrics.clear();
  288|      1|        assert!(metrics.entry(1).is_none());
  289|      1|    }
  290|       |
  291|       |    #[test]
  292|      1|    fn cache_stats_counts_hits_and_misses() {
  293|      1|        let mut stats = CacheStats::default();
  294|      1|        stats.record_hit();
  295|      1|        stats.record_hit();
  296|      1|        stats.record_miss();
  297|      1|        assert_eq!(stats.hits, 2);
  298|      1|        assert_eq!(stats.misses, 1);
  299|      1|    }
  300|       |}

C:\language\mdmdview\src\window_state.rs:
    1|       |use std::fs;
    2|       |use std::io::{Read, Write};
    3|       |use std::path::PathBuf;
    4|       |
    5|       |#[derive(Debug, Clone, Copy)]
    6|       |pub struct WindowState {
    7|       |    pub pos: [f32; 2],
    8|       |    pub size: [f32; 2],
    9|       |    pub maximized: bool,
   10|       |}
   11|       |
   12|     16|fn config_dir() -> Option<PathBuf> {
   13|       |    // Crossplatform config dir without extra deps
   14|       |    #[cfg(target_os = "windows")]
   15|       |    {
   16|     16|        if let Ok(appdata) = std::env::var("APPDATA") {
                                ^11
  ------------------
  |  Branch (16:16): [True: 11, False: 5]
  ------------------
   17|     11|            let mut p = PathBuf::from(appdata);
   18|     11|            p.push("MarkdownView");
   19|     11|            return Some(p);
   20|      5|        }
   21|       |    }
   22|       |
   23|       |    #[cfg(target_os = "macos")]
   24|       |    {
   25|       |        if let Ok(home) = std::env::var("HOME") {
   26|       |            let mut p = PathBuf::from(home);
   27|       |            p.push("Library/Application Support/MarkdownView");
   28|       |            return Some(p);
   29|       |        }
   30|       |    }
   31|       |
   32|       |    // Linux / others: XDG or ~/.config
   33|      5|    if let Ok(xdg) = std::env::var("XDG_CONFIG_HOME") {
                            ^1
  ------------------
  |  Branch (33:12): [True: 1, False: 4]
  ------------------
   34|      1|        let mut p = PathBuf::from(xdg);
   35|      1|        p.push("mdmdview");
   36|      1|        return Some(p);
   37|      4|    }
   38|      4|    if let Ok(home) = std::env::var("HOME") {
                            ^1
  ------------------
  |  Branch (38:12): [True: 1, False: 3]
  ------------------
   39|      1|        let mut p = PathBuf::from(home);
   40|      1|        p.push(".config/mdmdview");
   41|      1|        return Some(p);
   42|      3|    }
   43|      3|    None
   44|     16|}
   45|       |
   46|      6|fn state_path() -> Option<PathBuf> {
   47|      6|    config_dir().map(|mut dir| {
                                             ^5
   48|      5|        dir.push("window_state.txt");
   49|      5|        dir
   50|      5|    })
   51|      6|}
   52|       |
   53|      7|pub fn load_window_state() -> Option<WindowState> {
   54|       |    #[cfg(windows)]
   55|       |    {
   56|      7|        if let Some(ws) = load_window_state_registry() {
                                  ^1
  ------------------
  |  Branch (56:16): [True: 1, False: 6]
  ------------------
   57|      1|            return Some(ws);
   58|      6|        }
   59|       |    }
   60|      6|    let path = state_path()?;
                      ^5                 ^1
   61|      5|    let mut f = fs::File::open(path).ok()?;
                      ^4                               ^1
   62|      4|    let mut s = String::new();
   63|      4|    f.read_to_string(&mut s).ok()?;
                                               ^0
   64|       |    // expected format: "x y w h max"
   65|      4|    let parts: Vec<&str> = s.split_whitespace().collect();
   66|      4|    if parts.len() < 5 {
  ------------------
  |  Branch (66:8): [True: 1, False: 3]
  ------------------
   67|      1|        return None;
   68|      3|    }
   69|      3|    let x = parts[0].parse::<f32>().ok()?;
                      ^2                              ^1
   70|      2|    let y = parts[1].parse::<f32>().ok()?;
                                                      ^0
   71|      2|    let w = parts[2].parse::<f32>().ok()?;
                                                      ^0
   72|      2|    let h = parts[3].parse::<f32>().ok()?;
                                                      ^0
   73|      2|    let max = matches!(parts[4], "1" | "true" | "True");
                            ^1                                ^1
   74|      2|    Some(WindowState {
   75|      2|        pos: [x, y],
   76|      2|        size: [w, h],
   77|      2|        maximized: max,
   78|      2|    })
   79|      7|}
   80|       |
   81|      7|pub fn save_window_state(state: &WindowState) -> std::io::Result<()> {
   82|       |    #[cfg(windows)]
   83|       |    {
   84|      7|        if let Err(e) = save_window_state_registry(state) {
                                 ^1
  ------------------
  |  Branch (84:16): [True: 1, False: 6]
  ------------------
   85|      1|            eprintln!("Failed to write window state to registry: {e}");
   86|      6|        }
   87|       |    }
   88|      7|    if let Some(mut dir) = config_dir() {
                              ^6
  ------------------
  |  Branch (88:12): [True: 6, False: 1]
  ------------------
   89|      6|        if !dir.exists() {
  ------------------
  |  Branch (89:12): [True: 5, False: 1]
  ------------------
   90|      5|            fs::create_dir_all(&dir)?;
                                                  ^0
   91|      1|        }
   92|      6|        dir.push("window_state.txt");
   93|      6|        let mut f = fs::File::create(&dir)?;
                                                        ^0
   94|       |        // simple whitespace separated format
   95|      6|        writeln!(
   96|      6|            f,
   97|      6|            "{} {} {} {} {}",
   98|      6|            state.pos[0], state.pos[1], state.size[0], state.size[1], state.maximized as u8
   99|      0|        )?;
  100|      1|    }
  101|      7|    Ok(())
  102|      7|}
  103|       |
  104|      5|pub fn sanitize_window_state(ws: WindowState) -> Option<WindowState> {
  105|       |    // Basic sanity: finite values
  106|      5|    if !ws.pos[0].is_finite()
  ------------------
  |  Branch (106:8): [True: 1, False: 4]
  ------------------
  107|      4|        || !ws.pos[1].is_finite()
  ------------------
  |  Branch (107:12): [True: 1, False: 3]
  ------------------
  108|      3|        || !ws.size[0].is_finite()
  ------------------
  |  Branch (108:12): [True: 1, False: 2]
  ------------------
  109|      2|        || !ws.size[1].is_finite()
  ------------------
  |  Branch (109:12): [True: 1, False: 1]
  ------------------
  110|       |    {
  111|      4|        return None;
  112|      1|    }
  113|       |
  114|       |    // Clamp to reasonable ranges
  115|      1|    let min_w = 600.0f32;
  116|      1|    let min_h = 400.0f32;
  117|      1|    let max_w = 10000.0f32;
  118|      1|    let max_h = 10000.0f32;
  119|      1|    let max_pos = 20000.0f32; // avoid absurdly large coordinates
  120|       |
  121|      1|    let w = ws.size[0].clamp(min_w, max_w);
  122|      1|    let h = ws.size[1].clamp(min_h, max_h);
  123|      1|    let x = ws.pos[0].max(0.0).min(max_pos);
  124|      1|    let y = ws.pos[1].max(0.0).min(max_pos);
  125|       |
  126|      1|    Some(WindowState {
  127|      1|        pos: [x, y],
  128|      1|        size: [w, h],
  129|      1|        maximized: ws.maximized,
  130|      1|    })
  131|      5|}
  132|       |
  133|       |#[cfg(all(windows, not(test)))]
  134|       |fn load_window_state_registry() -> Option<WindowState> {
  135|       |    use winreg::enums::HKEY_CURRENT_USER;
  136|       |    use winreg::RegKey;
  137|       |    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  138|       |    let key = hkcu.open_subkey("Software\\MarkdownView").ok()?;
  139|       |    let x: u32 = key.get_value("PosX").ok()?;
  140|       |    let y: u32 = key.get_value("PosY").ok()?;
  141|       |    let w: u32 = key.get_value("Width").ok()?;
  142|       |    let h: u32 = key.get_value("Height").ok()?;
  143|       |    let maximized: u32 = key.get_value("Maximized").unwrap_or(0);
  144|       |    Some(WindowState {
  145|       |        pos: [x as f32, y as f32],
  146|       |        size: [w as f32, h as f32],
  147|       |        maximized: maximized != 0,
  148|       |    })
  149|       |}
  150|       |
  151|       |#[cfg(all(windows, not(test)))]
  152|       |fn save_window_state_registry(state: &WindowState) -> std::io::Result<()> {
  153|       |    use winreg::enums::{HKEY_CURRENT_USER, KEY_READ, KEY_WRITE};
  154|       |    use winreg::RegKey;
  155|       |    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
  156|       |    let (key, _disp) =
  157|       |        hkcu.create_subkey_with_flags("Software\\MarkdownView", KEY_READ | KEY_WRITE)?;
  158|       |    let to_u32 = |v: f32| -> u32 {
  159|       |        if v.is_finite() {
  160|       |            v.max(0.0).min(u32::MAX as f32).round() as u32
  161|       |        } else {
  162|       |            0
  163|       |        }
  164|       |    };
  165|       |    key.set_value("PosX", &to_u32(state.pos[0]))?;
  166|       |    key.set_value("PosY", &to_u32(state.pos[1]))?;
  167|       |    key.set_value("Width", &to_u32(state.size[0]))?;
  168|       |    key.set_value("Height", &to_u32(state.size[1]))?;
  169|       |    key.set_value("Maximized", &(state.maximized as u32))?;
  170|       |    Ok(())
  171|       |}
  172|       |
  173|       |#[cfg(all(windows, test))]
  174|       |thread_local! {
  175|       |    static FORCED_REGISTRY_LOAD: std::cell::RefCell<Option<WindowState>> =
  176|       |        const { std::cell::RefCell::new(None) };
  177|       |    static FORCED_REGISTRY_SAVE_ERROR: std::cell::RefCell<bool> =
  178|       |        const { std::cell::RefCell::new(false) };
  179|       |}
  180|       |
  181|       |#[cfg(all(windows, test))]
  182|      7|fn take_forced_registry_load() -> Option<WindowState> {
  183|      7|    FORCED_REGISTRY_LOAD.with(|slot| slot.borrow_mut().take())
  184|      7|}
  185|       |
  186|       |#[cfg(all(windows, test))]
  187|      7|fn take_forced_registry_save_error() -> bool {
  188|      7|    FORCED_REGISTRY_SAVE_ERROR.with(|flag| flag.replace(false))
  189|      7|}
  190|       |
  191|       |#[cfg(all(windows, test))]
  192|      1|fn force_registry_load_once(state: WindowState) {
  193|      1|    FORCED_REGISTRY_LOAD.with(|slot| {
  194|      1|        *slot.borrow_mut() = Some(state);
  195|      1|    });
  196|      1|}
  197|       |
  198|       |#[cfg(all(windows, test))]
  199|      1|fn force_registry_save_error_once() {
  200|      1|    FORCED_REGISTRY_SAVE_ERROR.with(|flag| {
  201|      1|        *flag.borrow_mut() = true;
  202|      1|    });
  203|      1|}
  204|       |
  205|       |#[cfg(all(windows, test))]
  206|      7|fn load_window_state_registry() -> Option<WindowState> {
  207|      7|    take_forced_registry_load()
  208|      7|}
  209|       |
  210|       |#[cfg(all(windows, test))]
  211|      7|fn save_window_state_registry(_state: &WindowState) -> std::io::Result<()> {
  212|      7|    if take_forced_registry_save_error() {
  ------------------
  |  Branch (212:8): [True: 1, False: 6]
  ------------------
  213|      1|        return Err(std::io::Error::other("forced registry error"));
  214|      6|    }
  215|      6|    Ok(())
  216|      7|}
  217|       |
  218|       |#[cfg(test)]
  219|       |mod tests {
  220|       |    use super::*;
  221|       |    use std::sync::{Mutex, OnceLock};
  222|       |    use tempfile::TempDir;
  223|       |
  224|     12|    fn env_lock() -> std::sync::MutexGuard<'static, ()> {
  225|       |        static ENV_LOCK: OnceLock<Mutex<()>> = OnceLock::new();
  226|     12|        ENV_LOCK
  227|     12|            .get_or_init(|| Mutex::new(()))
                                          ^1         ^1
  228|     12|            .lock()
  229|     12|            .expect("env lock")
  230|     12|    }
  231|       |
  232|       |    struct EnvGuard {
  233|       |        key: &'static str,
  234|       |        original: Option<String>,
  235|       |    }
  236|       |
  237|       |    impl EnvGuard {
  238|     11|        fn set(key: &'static str, value: &str) -> Self {
  239|     11|            let original = std::env::var(key).ok();
  240|     11|            std::env::set_var(key, value);
  241|     11|            Self { key, original }
  242|     11|        }
  243|       |
  244|      7|        fn unset(key: &'static str) -> Self {
  245|      7|            let original = std::env::var(key).ok();
  246|      7|            std::env::remove_var(key);
  247|      7|            Self { key, original }
  248|      7|        }
  249|       |    }
  250|       |
  251|       |    impl Drop for EnvGuard {
  252|     18|        fn drop(&mut self) {
  253|     18|            if let Some(value) = &self.original {
                                      ^12
  ------------------
  |  Branch (253:20): [True: 12, False: 6]
  ------------------
  254|     12|                std::env::set_var(self.key, value);
  255|     12|            } else {
  256|      6|                std::env::remove_var(self.key);
  257|      6|            }
  258|     18|        }
  259|       |    }
  260|       |
  261|       |    #[test]
  262|      1|    fn test_sanitize_window_state_clamps_and_rejects_invalid() {
  263|      1|        let invalid = WindowState {
  264|      1|            pos: [f32::NAN, 10.0],
  265|      1|            size: [800.0, 600.0],
  266|      1|            maximized: false,
  267|      1|        };
  268|      1|        assert!(sanitize_window_state(invalid).is_none());
  269|       |
  270|      1|        let input = WindowState {
  271|      1|            pos: [-50.0, 25000.0],
  272|      1|            size: [100.0, 200.0],
  273|      1|            maximized: true,
  274|      1|        };
  275|      1|        let sanitized = sanitize_window_state(input).expect("expected sanitized state");
  276|      1|        assert_eq!(sanitized.pos[0], 0.0);
  277|      1|        assert_eq!(sanitized.pos[1], 20000.0);
  278|      1|        assert_eq!(sanitized.size[0], 600.0);
  279|      1|        assert_eq!(sanitized.size[1], 400.0);
  280|      1|        assert!(sanitized.maximized);
  281|      1|    }
  282|       |
  283|       |    #[test]
  284|      1|    fn test_sanitize_window_state_rejects_non_finite_components() {
  285|      1|        let invalid_y = WindowState {
  286|      1|            pos: [10.0, f32::NAN],
  287|      1|            size: [800.0, 600.0],
  288|      1|            maximized: false,
  289|      1|        };
  290|      1|        assert!(sanitize_window_state(invalid_y).is_none());
  291|       |
  292|      1|        let invalid_w = WindowState {
  293|      1|            pos: [10.0, 20.0],
  294|      1|            size: [f32::NAN, 600.0],
  295|      1|            maximized: false,
  296|      1|        };
  297|      1|        assert!(sanitize_window_state(invalid_w).is_none());
  298|       |
  299|      1|        let invalid_h = WindowState {
  300|      1|            pos: [10.0, 20.0],
  301|      1|            size: [800.0, f32::NAN],
  302|      1|            maximized: false,
  303|      1|        };
  304|      1|        assert!(sanitize_window_state(invalid_h).is_none());
  305|      1|    }
  306|       |
  307|       |    #[test]
  308|      1|    fn test_save_and_load_window_state_from_file() {
  309|      1|        let _lock = env_lock();
  310|      1|        let temp = TempDir::new().expect("temp dir");
  311|      1|        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  312|       |
  313|      1|        let state = WindowState {
  314|      1|            pos: [120.0, 80.0],
  315|      1|            size: [1024.0, 768.0],
  316|      1|            maximized: false,
  317|      1|        };
  318|      1|        save_window_state(&state).expect("save");
  319|       |
  320|      1|        let loaded = load_window_state().expect("load");
  321|      1|        assert_eq!(loaded.pos, state.pos);
  322|      1|        assert_eq!(loaded.size, state.size);
  323|      1|        assert_eq!(loaded.maximized, state.maximized);
  324|      1|    }
  325|       |
  326|       |    #[test]
  327|      1|    fn test_save_window_state_creates_dir_and_writes_file() {
  328|      1|        let _lock = env_lock();
  329|      1|        let temp = TempDir::new().expect("temp dir");
  330|      1|        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  331|       |
  332|      1|        let config_dir = temp.path().join("MarkdownView");
  333|      1|        let _ = fs::remove_dir_all(&config_dir);
  334|       |
  335|      1|        let state = WindowState {
  336|      1|            pos: [10.0, 20.0],
  337|      1|            size: [800.0, 600.0],
  338|      1|            maximized: true,
  339|      1|        };
  340|      1|        save_window_state(&state).expect("save");
  341|       |
  342|      1|        let path = config_dir.join("window_state.txt");
  343|      1|        let contents = fs::read_to_string(&path).expect("read");
  344|      1|        let mut parts = contents.split_whitespace();
  345|      1|        let pos_x: f32 = parts.next().expect("pos x").parse().expect("parse pos x");
  346|      1|        let pos_y: f32 = parts.next().expect("pos y").parse().expect("parse pos y");
  347|      1|        let size_x: f32 = parts.next().expect("size x").parse().expect("parse size x");
  348|      1|        let size_y: f32 = parts.next().expect("size y").parse().expect("parse size y");
  349|      1|        let max_flag = parts.next().expect("max flag");
  350|      1|        assert_eq!(pos_x, state.pos[0]);
  351|      1|        assert_eq!(pos_y, state.pos[1]);
  352|      1|        assert_eq!(size_x, state.size[0]);
  353|      1|        assert_eq!(size_y, state.size[1]);
  354|      1|        assert_eq!(max_flag, "1");
  355|      1|    }
  356|       |
  357|       |    #[test]
  358|      1|    fn test_save_window_state_when_dir_exists() {
  359|      1|        let _lock = env_lock();
  360|      1|        let temp = TempDir::new().expect("temp dir");
  361|      1|        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  362|      1|        let config_dir = temp.path().join("MarkdownView");
  363|      1|        fs::create_dir_all(&config_dir).expect("create config dir");
  364|       |
  365|      1|        let state = WindowState {
  366|      1|            pos: [5.0, 6.0],
  367|      1|            size: [700.0, 500.0],
  368|      1|            maximized: false,
  369|      1|        };
  370|      1|        save_window_state(&state).expect("save");
  371|      1|        let path = config_dir.join("window_state.txt");
  372|      1|        assert!(path.exists());
  373|      1|    }
  374|       |
  375|       |    #[test]
  376|      1|    fn test_load_window_state_prefers_registry_when_forced() {
  377|      1|        let _lock = env_lock();
  378|      1|        let temp = TempDir::new().expect("temp dir");
  379|      1|        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  380|       |
  381|      1|        let state = WindowState {
  382|      1|            pos: [42.0, 24.0],
  383|      1|            size: [800.0, 600.0],
  384|      1|            maximized: true,
  385|      1|        };
  386|      1|        force_registry_load_once(state);
  387|       |
  388|      1|        let loaded = load_window_state().expect("load");
  389|      1|        assert_eq!(loaded.pos, state.pos);
  390|      1|        assert_eq!(loaded.size, state.size);
  391|      1|        assert_eq!(loaded.maximized, state.maximized);
  392|      1|    }
  393|       |
  394|       |    #[test]
  395|      1|    fn test_save_window_state_registry_error_still_writes_file() {
  396|      1|        let _lock = env_lock();
  397|      1|        let temp = TempDir::new().expect("temp dir");
  398|      1|        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  399|      1|        force_registry_save_error_once();
  400|       |
  401|      1|        let state = WindowState {
  402|      1|            pos: [10.0, 20.0],
  403|      1|            size: [1024.0, 768.0],
  404|      1|            maximized: false,
  405|      1|        };
  406|      1|        save_window_state(&state).expect("save");
  407|       |
  408|      1|        let path = temp.path().join("MarkdownView").join("window_state.txt");
  409|      1|        assert!(path.exists());
  410|      1|    }
  411|       |
  412|       |    #[test]
  413|      1|    fn test_load_window_state_rejects_bad_file() {
  414|      1|        let _lock = env_lock();
  415|      1|        let temp = TempDir::new().expect("temp dir");
  416|      1|        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  417|       |
  418|      1|        let mut config = temp.path().join("MarkdownView");
  419|      1|        std::fs::create_dir_all(&config).expect("create config dir");
  420|      1|        config.push("window_state.txt");
  421|      1|        std::fs::write(&config, "10 20 30").expect("write bad data");
  422|       |
  423|      1|        assert!(load_window_state().is_none());
  424|      1|    }
  425|       |
  426|       |    #[test]
  427|      1|    fn test_load_window_state_rejects_invalid_numbers() {
  428|      1|        let _lock = env_lock();
  429|      1|        let temp = TempDir::new().expect("temp dir");
  430|      1|        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  431|       |
  432|      1|        let mut config = temp.path().join("MarkdownView");
  433|      1|        std::fs::create_dir_all(&config).expect("create config dir");
  434|      1|        config.push("window_state.txt");
  435|      1|        std::fs::write(&config, "x y 10 20 true").expect("write bad data");
  436|       |
  437|      1|        assert!(load_window_state().is_none());
  438|      1|    }
  439|       |
  440|       |    #[test]
  441|      1|    fn test_load_window_state_parses_maximized_true() {
  442|      1|        let _lock = env_lock();
  443|      1|        let temp = TempDir::new().expect("temp dir");
  444|      1|        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  445|       |
  446|      1|        let mut config = temp.path().join("MarkdownView");
  447|      1|        std::fs::create_dir_all(&config).expect("create config dir");
  448|      1|        config.push("window_state.txt");
  449|      1|        std::fs::write(&config, "10 20 300 400 true").expect("write data");
  450|       |
  451|      1|        let loaded = load_window_state().expect("load");
  452|      1|        assert!(loaded.maximized);
  453|      1|    }
  454|       |
  455|       |    #[test]
  456|      1|    fn test_load_window_state_returns_none_when_missing() {
  457|      1|        let _lock = env_lock();
  458|      1|        let temp = TempDir::new().expect("temp dir");
  459|      1|        let _guard = EnvGuard::set("APPDATA", temp.path().to_string_lossy().as_ref());
  460|       |
  461|      1|        assert!(load_window_state().is_none());
  462|      1|    }
  463|       |
  464|       |    #[test]
  465|      1|    fn test_config_dir_falls_back_to_xdg() {
  466|      1|        let _lock = env_lock();
  467|      1|        let temp = TempDir::new().expect("temp dir");
  468|      1|        let _guard_appdata = EnvGuard::unset("APPDATA");
  469|      1|        let _guard_home = EnvGuard::unset("HOME");
  470|      1|        let _guard_xdg = EnvGuard::set("XDG_CONFIG_HOME", temp.path().to_string_lossy().as_ref());
  471|       |
  472|      1|        let dir = config_dir().expect("config dir");
  473|      1|        assert!(dir.starts_with(temp.path()));
  474|      1|        assert!(dir.ends_with("mdmdview"));
  475|      1|    }
  476|       |
  477|       |    #[test]
  478|      1|    fn test_config_dir_falls_back_to_home() {
  479|      1|        let _lock = env_lock();
  480|      1|        let temp = TempDir::new().expect("temp dir");
  481|      1|        let _guard_appdata = EnvGuard::unset("APPDATA");
  482|      1|        let _guard_xdg = EnvGuard::unset("XDG_CONFIG_HOME");
  483|      1|        let _guard_home = EnvGuard::set("HOME", temp.path().to_string_lossy().as_ref());
  484|       |
  485|      1|        let dir = config_dir().expect("config dir");
  486|      1|        assert!(dir.starts_with(temp.path()));
  487|      1|        assert!(dir.ends_with(std::path::Path::new(".config").join("mdmdview")));
  488|      1|    }
  489|       |
  490|       |    #[test]
  491|      1|    fn test_config_dir_none_without_env() {
  492|      1|        let _lock = env_lock();
  493|      1|        let _guard_appdata = EnvGuard::unset("APPDATA");
  494|      1|        let _guard_xdg = EnvGuard::unset("XDG_CONFIG_HOME");
  495|      1|        let _guard_home = EnvGuard::unset("HOME");
  496|       |
  497|      1|        assert!(config_dir().is_none());
  498|      1|        let state = WindowState {
  499|      1|            pos: [1.0, 2.0],
  500|      1|            size: [800.0, 600.0],
  501|      1|            maximized: false,
  502|      1|        };
  503|      1|        save_window_state(&state).expect("save ok");
  504|      1|        assert!(load_window_state().is_none());
  505|      1|    }
  506|       |}

c:\language\mdmdview\target\llvm-cov-target\debug\build\glutin_egl_sys-539297a1ef0c280c\out\egl_bindings.rs:
    1|       |
    2|       |        mod __gl_imports {
    3|       |            pub use std::mem;
    4|       |            pub use std::marker::Send;
    5|       |            pub use std::os::raw;
    6|       |        }
    7|       |    
    8|       |
    9|       |        pub mod types {
   10|       |            #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)]
   11|       |    
   12|       |// platform-specific aliases are unknown
   13|       |// IMPORTANT: these are alises to the same level of the bindings
   14|       |// the values must be defined by the user
   15|       |#[allow(dead_code)]
   16|       |pub type khronos_utime_nanoseconds_t = super::khronos_utime_nanoseconds_t;
   17|       |#[allow(dead_code)]
   18|       |pub type khronos_uint64_t = super::khronos_uint64_t;
   19|       |#[allow(dead_code)]
   20|       |pub type khronos_ssize_t = super::khronos_ssize_t;
   21|       |pub type EGLNativeDisplayType = super::EGLNativeDisplayType;
   22|       |#[allow(dead_code)]
   23|       |pub type EGLNativePixmapType = super::EGLNativePixmapType;
   24|       |#[allow(dead_code)]
   25|       |pub type EGLNativeWindowType = super::EGLNativeWindowType;
   26|       |pub type EGLint = super::EGLint;
   27|       |#[allow(dead_code)]
   28|       |pub type NativeDisplayType = super::NativeDisplayType;
   29|       |#[allow(dead_code)]
   30|       |pub type NativePixmapType = super::NativePixmapType;
   31|       |#[allow(dead_code)]
   32|       |pub type NativeWindowType = super::NativeWindowType;
   33|       |
   34|       |// EGL alises
   35|       |pub type Bool = EGLBoolean; // TODO: not sure
   36|       |pub type EGLBoolean = super::__gl_imports::raw::c_uint;
   37|       |pub type EGLenum = super::__gl_imports::raw::c_uint;
   38|       |pub type EGLAttribKHR = isize;
   39|       |pub type EGLAttrib = isize;
   40|       |pub type EGLConfig = *const super::__gl_imports::raw::c_void;
   41|       |pub type EGLContext = *const super::__gl_imports::raw::c_void;
   42|       |pub type EGLDeviceEXT = *const super::__gl_imports::raw::c_void;
   43|       |pub type EGLDisplay = *const super::__gl_imports::raw::c_void;
   44|       |pub type EGLSurface = *const super::__gl_imports::raw::c_void;
   45|       |pub type EGLClientBuffer = *const super::__gl_imports::raw::c_void;
   46|       |pub enum __eglMustCastToProperFunctionPointerType_fn {}
   47|       |pub type __eglMustCastToProperFunctionPointerType =
   48|       |    *mut __eglMustCastToProperFunctionPointerType_fn;
   49|       |pub type EGLImageKHR = *const super::__gl_imports::raw::c_void;
   50|       |pub type EGLImage = *const super::__gl_imports::raw::c_void;
   51|       |pub type EGLOutputLayerEXT = *const super::__gl_imports::raw::c_void;
   52|       |pub type EGLOutputPortEXT = *const super::__gl_imports::raw::c_void;
   53|       |pub type EGLSyncKHR = *const super::__gl_imports::raw::c_void;
   54|       |pub type EGLSync = *const super::__gl_imports::raw::c_void;
   55|       |pub type EGLTimeKHR = khronos_utime_nanoseconds_t;
   56|       |pub type EGLTime = khronos_utime_nanoseconds_t;
   57|       |pub type EGLSyncNV = *const super::__gl_imports::raw::c_void;
   58|       |pub type EGLTimeNV = khronos_utime_nanoseconds_t;
   59|       |pub type EGLuint64NV = khronos_utime_nanoseconds_t;
   60|       |pub type EGLStreamKHR = *const super::__gl_imports::raw::c_void;
   61|       |pub type EGLuint64KHR = khronos_uint64_t;
   62|       |pub type EGLNativeFileDescriptorKHR = super::__gl_imports::raw::c_int;
   63|       |pub type EGLsizeiANDROID = khronos_ssize_t;
   64|       |pub type EGLSetBlobFuncANDROID = extern "system" fn(*const super::__gl_imports::raw::c_void,
   65|       |                                                    EGLsizeiANDROID,
   66|       |                                                    *const super::__gl_imports::raw::c_void,
   67|       |                                                    EGLsizeiANDROID)
   68|       |                                                    -> ();
   69|       |pub type EGLGetBlobFuncANDROID = extern "system" fn(*const super::__gl_imports::raw::c_void,
   70|       |                                                    EGLsizeiANDROID,
   71|       |                                                    *mut super::__gl_imports::raw::c_void,
   72|       |                                                    EGLsizeiANDROID)
   73|       |                                                    -> EGLsizeiANDROID;
   74|       |
   75|       |#[repr(C)]
   76|       |pub struct EGLClientPixmapHI {
   77|       |    pData: *const super::__gl_imports::raw::c_void,
   78|       |    iWidth: EGLint,
   79|       |    iHeight: EGLint,
   80|       |    iStride: EGLint,
   81|       |}
   82|       |
   83|       |}
   84|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT: types::EGLenum = 0x3088;
   85|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT_NONPRE: types::EGLenum = 0x308B;
   86|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_FORMAT_PRE: types::EGLenum = 0x308C;
   87|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_MASK_SIZE: types::EGLenum = 0x303E;
   88|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_SIZE: types::EGLenum = 0x3021;
   89|       |#[allow(dead_code, non_upper_case_globals)] pub const BACK_BUFFER: types::EGLenum = 0x3084;
   90|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_ACCESS: types::EGLenum = 0x3002;
   91|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_ALLOC: types::EGLenum = 0x3003;
   92|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_ATTRIBUTE: types::EGLenum = 0x3004;
   93|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_CONFIG: types::EGLenum = 0x3005;
   94|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_CONTEXT: types::EGLenum = 0x3006;
   95|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_CURRENT_SURFACE: types::EGLenum = 0x3007;
   96|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_DEVICE_EXT: types::EGLenum = 0x322B;
   97|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_DISPLAY: types::EGLenum = 0x3008;
   98|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_MATCH: types::EGLenum = 0x3009;
   99|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_NATIVE_PIXMAP: types::EGLenum = 0x300A;
  100|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_NATIVE_WINDOW: types::EGLenum = 0x300B;
  101|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_PARAMETER: types::EGLenum = 0x300C;
  102|       |#[allow(dead_code, non_upper_case_globals)] pub const BAD_SURFACE: types::EGLenum = 0x300D;
  103|       |#[allow(dead_code, non_upper_case_globals)] pub const BIND_TO_TEXTURE_RGB: types::EGLenum = 0x3039;
  104|       |#[allow(dead_code, non_upper_case_globals)] pub const BIND_TO_TEXTURE_RGBA: types::EGLenum = 0x303A;
  105|       |#[allow(dead_code, non_upper_case_globals)] pub const BLUE_SIZE: types::EGLenum = 0x3022;
  106|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_AGE_EXT: types::EGLenum = 0x313D;
  107|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_DESTROYED: types::EGLenum = 0x3095;
  108|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_PRESERVED: types::EGLenum = 0x3094;
  109|       |#[allow(dead_code, non_upper_case_globals)] pub const BUFFER_SIZE: types::EGLenum = 0x3020;
  110|       |#[allow(dead_code, non_upper_case_globals)] pub const CLIENT_APIS: types::EGLenum = 0x308D;
  111|       |#[allow(dead_code, non_upper_case_globals)] pub const CL_EVENT_HANDLE: types::EGLenum = 0x309C;
  112|       |#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE: types::EGLenum = 0x3087;
  113|       |#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE_LINEAR: types::EGLenum = 0x308A;
  114|       |#[allow(dead_code, non_upper_case_globals)] pub const COLORSPACE_sRGB: types::EGLenum = 0x3089;
  115|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_BUFFER_TYPE: types::EGLenum = 0x303F;
  116|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_EXT: types::EGLenum = 0x3339;
  117|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_FIXED_EXT: types::EGLenum = 0x333A;
  118|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_COMPONENT_TYPE_FLOAT_EXT: types::EGLenum = 0x333B;
  119|       |#[allow(dead_code, non_upper_case_globals)] pub const CONDITION_SATISFIED: types::EGLenum = 0x30F6;
  120|       |#[allow(dead_code, non_upper_case_globals)] pub const CONFIG_CAVEAT: types::EGLenum = 0x3027;
  121|       |#[allow(dead_code, non_upper_case_globals)] pub const CONFIG_ID: types::EGLenum = 0x3028;
  122|       |#[allow(dead_code, non_upper_case_globals)] pub const CONFORMANT: types::EGLenum = 0x3042;
  123|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CLIENT_TYPE: types::EGLenum = 0x3097;
  124|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CLIENT_VERSION: types::EGLenum = 0x3098;
  125|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FLAGS_KHR: types::EGLenum = 0x30FC;
  126|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_LOST: types::EGLenum = 0x300E;
  127|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION: types::EGLenum = 0x3098;
  128|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION_KHR: types::EGLenum = 0x3098;
  129|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION: types::EGLenum = 0x30FB;
  130|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION_KHR: types::EGLenum = 0x30FB;
  131|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT: types::EGLenum = 0x00000002;
  132|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT_KHR: types::EGLenum = 0x00000002;
  133|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_CORE_PROFILE_BIT: types::EGLenum = 0x00000001;
  134|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR: types::EGLenum = 0x00000001;
  135|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_DEBUG: types::EGLenum = 0x31B0;
  136|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_DEBUG_BIT_KHR: types::EGLenum = 0x00000001;
  137|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_FORWARD_COMPATIBLE: types::EGLenum = 0x31B1;
  138|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR: types::EGLenum = 0x00000002;
  139|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_NO_ERROR_KHR: types::EGLenum = 0x31B3;
  140|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_PROFILE_MASK: types::EGLenum = 0x30FD;
  141|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_PROFILE_MASK_KHR: types::EGLenum = 0x30FD;
  142|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY: types::EGLenum = 0x31BD;
  143|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_EXT: types::EGLenum = 0x3138;
  144|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY_KHR: types::EGLenum = 0x31BD;
  145|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS: types::EGLenum = 0x31B2;
  146|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR: types::EGLenum = 0x00000004;
  147|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_ROBUST_ACCESS_EXT: types::EGLenum = 0x30BF;
  148|       |#[allow(dead_code, non_upper_case_globals)] pub const CORE_NATIVE_ENGINE: types::EGLenum = 0x305B;
  149|       |#[allow(dead_code, non_upper_case_globals)] pub const DEFAULT_DISPLAY: types::EGLNativeDisplayType = 0 as types::EGLNativeDisplayType;
  150|       |#[allow(dead_code, non_upper_case_globals)] pub const DEPTH_SIZE: types::EGLenum = 0x3025;
  151|       |#[allow(dead_code, non_upper_case_globals)] pub const DEVICE_EXT: types::EGLenum = 0x322C;
  152|       |#[allow(dead_code, non_upper_case_globals)] pub const DISPLAY_SCALING: types::EGLenum = 10000;
  153|       |#[allow(dead_code, non_upper_case_globals)] pub const DONT_CARE: types::EGLint = -1 as types::EGLint;
  154|       |#[allow(dead_code, non_upper_case_globals)] pub const DRAW: types::EGLenum = 0x3059;
  155|       |#[allow(dead_code, non_upper_case_globals)] pub const DRM_DEVICE_FILE_EXT: types::EGLenum = 0x3233;
  156|       |#[allow(dead_code, non_upper_case_globals)] pub const DRM_MASTER_FD_EXT: types::EGLenum = 0x333C;
  157|       |#[allow(dead_code, non_upper_case_globals)] pub const EXTENSIONS: types::EGLenum = 0x3055;
  158|       |#[allow(dead_code, non_upper_case_globals)] pub const FALSE: types::EGLBoolean = 0;
  159|       |#[allow(dead_code, non_upper_case_globals)] pub const FOREVER: types::EGLuint64KHR = 0xFFFFFFFFFFFFFFFF;
  160|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE: types::EGLenum = 0x309D;
  161|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE_LINEAR: types::EGLenum = 0x308A;
  162|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_COLORSPACE_SRGB: types::EGLenum = 0x3089;
  163|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_RENDERBUFFER: types::EGLenum = 0x30B9;
  164|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_2D: types::EGLenum = 0x30B1;
  165|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_3D: types::EGLenum = 0x30B2;
  166|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_X: types::EGLenum = 0x30B4;
  167|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: types::EGLenum = 0x30B6;
  168|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: types::EGLenum = 0x30B8;
  169|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_X: types::EGLenum = 0x30B3;
  170|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Y: types::EGLenum = 0x30B5;
  171|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_CUBE_MAP_POSITIVE_Z: types::EGLenum = 0x30B7;
  172|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_LEVEL: types::EGLenum = 0x30BC;
  173|       |#[allow(dead_code, non_upper_case_globals)] pub const GL_TEXTURE_ZOFFSET: types::EGLenum = 0x30BD;
  174|       |#[allow(dead_code, non_upper_case_globals)] pub const GREEN_SIZE: types::EGLenum = 0x3023;
  175|       |#[allow(dead_code, non_upper_case_globals)] pub const HEIGHT: types::EGLenum = 0x3056;
  176|       |#[allow(dead_code, non_upper_case_globals)] pub const HORIZONTAL_RESOLUTION: types::EGLenum = 0x3090;
  177|       |#[allow(dead_code, non_upper_case_globals)] pub const IMAGE_PRESERVED: types::EGLenum = 0x30D2;
  178|       |#[allow(dead_code, non_upper_case_globals)] pub const LARGEST_PBUFFER: types::EGLenum = 0x3058;
  179|       |#[allow(dead_code, non_upper_case_globals)] pub const LEVEL: types::EGLenum = 0x3029;
  180|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET: types::EGLenum = 0x31BF;
  181|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_EXT: types::EGLenum = 0x31BF;
  182|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_KHR: types::EGLenum = 0x31BF;
  183|       |#[allow(dead_code, non_upper_case_globals)] pub const LUMINANCE_BUFFER: types::EGLenum = 0x308F;
  184|       |#[allow(dead_code, non_upper_case_globals)] pub const LUMINANCE_SIZE: types::EGLenum = 0x303D;
  185|       |#[allow(dead_code, non_upper_case_globals)] pub const MATCH_NATIVE_PIXMAP: types::EGLenum = 0x3041;
  186|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_HEIGHT: types::EGLenum = 0x302A;
  187|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_PIXELS: types::EGLenum = 0x302B;
  188|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_PBUFFER_WIDTH: types::EGLenum = 0x302C;
  189|       |#[allow(dead_code, non_upper_case_globals)] pub const MAX_SWAP_INTERVAL: types::EGLenum = 0x303C;
  190|       |#[allow(dead_code, non_upper_case_globals)] pub const MIN_SWAP_INTERVAL: types::EGLenum = 0x303B;
  191|       |#[allow(dead_code, non_upper_case_globals)] pub const MIPMAP_LEVEL: types::EGLenum = 0x3083;
  192|       |#[allow(dead_code, non_upper_case_globals)] pub const MIPMAP_TEXTURE: types::EGLenum = 0x3082;
  193|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE: types::EGLenum = 0x3099;
  194|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_BOX: types::EGLenum = 0x309B;
  195|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_BOX_BIT: types::EGLenum = 0x0200;
  196|       |#[allow(dead_code, non_upper_case_globals)] pub const MULTISAMPLE_RESOLVE_DEFAULT: types::EGLenum = 0x309A;
  197|       |#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_RENDERABLE: types::EGLenum = 0x302D;
  198|       |#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_VISUAL_ID: types::EGLenum = 0x302E;
  199|       |#[allow(dead_code, non_upper_case_globals)] pub const NATIVE_VISUAL_TYPE: types::EGLenum = 0x302F;
  200|       |#[allow(dead_code, non_upper_case_globals)] pub const NONE: types::EGLenum = 0x3038;
  201|       |#[allow(dead_code, non_upper_case_globals)] pub const NON_CONFORMANT_CONFIG: types::EGLenum = 0x3051;
  202|       |#[allow(dead_code, non_upper_case_globals)] pub const NOT_INITIALIZED: types::EGLenum = 0x3001;
  203|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_CONTEXT: types::EGLContext = 0 as types::EGLContext;
  204|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_DEVICE_EXT: types::EGLDeviceEXT = 0 as types::EGLDeviceEXT;
  205|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_DISPLAY: types::EGLDisplay = 0 as types::EGLDisplay;
  206|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_IMAGE: types::EGLImage = 0 as types::EGLImage;
  207|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_NATIVE_FENCE_FD_ANDROID: types::EGLint = -1;
  208|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION: types::EGLenum = 0x31BE;
  209|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_EXT: types::EGLenum = 0x31BE;
  210|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_KHR: types::EGLenum = 0x31BE;
  211|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_SURFACE: types::EGLSurface = 0 as types::EGLSurface;
  212|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_SYNC: types::EGLSync = 0 as types::EGLSync;
  213|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_TEXTURE: types::EGLenum = 0x305C;
  214|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_API: types::EGLenum = 0x30A2;
  215|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_BIT: types::EGLenum = 0x0008;
  216|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES2_BIT: types::EGLenum = 0x0004;
  217|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES3_BIT: types::EGLenum = 0x00000040;
  218|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES3_BIT_KHR: types::EGLenum = 0x00000040;
  219|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES_API: types::EGLenum = 0x30A0;
  220|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENGL_ES_BIT: types::EGLenum = 0x0001;
  221|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_API: types::EGLenum = 0x30A1;
  222|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_BIT: types::EGLenum = 0x0002;
  223|       |#[allow(dead_code, non_upper_case_globals)] pub const OPENVG_IMAGE: types::EGLenum = 0x3096;
  224|       |#[allow(dead_code, non_upper_case_globals)] pub const PBUFFER_BIT: types::EGLenum = 0x0001;
  225|       |#[allow(dead_code, non_upper_case_globals)] pub const PIXEL_ASPECT_RATIO: types::EGLenum = 0x3092;
  226|       |#[allow(dead_code, non_upper_case_globals)] pub const PIXMAP_BIT: types::EGLenum = 0x0002;
  227|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_ANDROID_KHR: types::EGLenum = 0x3141;
  228|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_DEVICE_EXT: types::EGLenum = 0x313F;
  229|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_GBM_KHR: types::EGLenum = 0x31D7;
  230|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_GBM_MESA: types::EGLenum = 0x31D7;
  231|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_WAYLAND_EXT: types::EGLenum = 0x31D8;
  232|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_WAYLAND_KHR: types::EGLenum = 0x31D8;
  233|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_EXT: types::EGLenum = 0x31D5;
  234|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_KHR: types::EGLenum = 0x31D5;
  235|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_SCREEN_EXT: types::EGLenum = 0x31D6;
  236|       |#[allow(dead_code, non_upper_case_globals)] pub const PLATFORM_X11_SCREEN_KHR: types::EGLenum = 0x31D6;
  237|       |#[allow(dead_code, non_upper_case_globals)] pub const READ: types::EGLenum = 0x305A;
  238|       |#[allow(dead_code, non_upper_case_globals)] pub const RED_SIZE: types::EGLenum = 0x3024;
  239|       |#[allow(dead_code, non_upper_case_globals)] pub const RENDERABLE_TYPE: types::EGLenum = 0x3040;
  240|       |#[allow(dead_code, non_upper_case_globals)] pub const RENDER_BUFFER: types::EGLenum = 0x3086;
  241|       |#[allow(dead_code, non_upper_case_globals)] pub const RGB_BUFFER: types::EGLenum = 0x308E;
  242|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLES: types::EGLenum = 0x3031;
  243|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLE_BUFFERS: types::EGLenum = 0x3032;
  244|       |#[allow(dead_code, non_upper_case_globals)] pub const SIGNALED: types::EGLenum = 0x30F2;
  245|       |#[allow(dead_code, non_upper_case_globals)] pub const SINGLE_BUFFER: types::EGLenum = 0x3085;
  246|       |#[allow(dead_code, non_upper_case_globals)] pub const SLOW_CONFIG: types::EGLenum = 0x3050;
  247|       |#[allow(dead_code, non_upper_case_globals)] pub const STENCIL_SIZE: types::EGLenum = 0x3026;
  248|       |#[allow(dead_code, non_upper_case_globals)] pub const SUCCESS: types::EGLenum = 0x3000;
  249|       |#[allow(dead_code, non_upper_case_globals)] pub const SURFACE_TYPE: types::EGLenum = 0x3033;
  250|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_BEHAVIOR: types::EGLenum = 0x3093;
  251|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_BEHAVIOR_PRESERVED_BIT: types::EGLenum = 0x0400;
  252|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CL_EVENT: types::EGLenum = 0x30FE;
  253|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CL_EVENT_COMPLETE: types::EGLenum = 0x30FF;
  254|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CONDITION: types::EGLenum = 0x30F8;
  255|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_CONDITION_KHR: types::EGLenum = 0x30F8;
  256|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FENCE: types::EGLenum = 0x30F9;
  257|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FENCE_KHR: types::EGLenum = 0x30F9;
  258|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_FLUSH_COMMANDS_BIT: types::EGLenum = 0x0001;
  259|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_ANDROID: types::EGLenum = 0x3144;
  260|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_FD_ANDROID: types::EGLenum = 0x3145;
  261|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_NATIVE_FENCE_SIGNALED_ANDROID: types::EGLenum = 0x3146;
  262|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_PRIOR_COMMANDS_COMPLETE: types::EGLenum = 0x30F0;
  263|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_PRIOR_COMMANDS_COMPLETE_KHR: types::EGLenum = 0x30F0;
  264|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_STATUS: types::EGLenum = 0x30F1;
  265|       |#[allow(dead_code, non_upper_case_globals)] pub const SYNC_TYPE: types::EGLenum = 0x30F7;
  266|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_2D: types::EGLenum = 0x305F;
  267|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_FORMAT: types::EGLenum = 0x3080;
  268|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_RGB: types::EGLenum = 0x305D;
  269|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_RGBA: types::EGLenum = 0x305E;
  270|       |#[allow(dead_code, non_upper_case_globals)] pub const TEXTURE_TARGET: types::EGLenum = 0x3081;
  271|       |#[allow(dead_code, non_upper_case_globals)] pub const TIMEOUT_EXPIRED: types::EGLenum = 0x30F5;
  272|       |#[allow(dead_code, non_upper_case_globals)] pub const TRACK_REFERENCES_KHR: types::EGLenum = 0x3352;
  273|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_BLUE_VALUE: types::EGLenum = 0x3035;
  274|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_GREEN_VALUE: types::EGLenum = 0x3036;
  275|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RED_VALUE: types::EGLenum = 0x3037;
  276|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RGB: types::EGLenum = 0x3052;
  277|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_TYPE: types::EGLenum = 0x3034;
  278|       |#[allow(dead_code, non_upper_case_globals)] pub const TRUE: types::EGLBoolean = 1;
  279|       |#[allow(dead_code, non_upper_case_globals)] pub const UNKNOWN: types::EGLint = -1 as types::EGLint;
  280|       |#[allow(dead_code, non_upper_case_globals)] pub const UNSIGNALED: types::EGLenum = 0x30F3;
  281|       |#[allow(dead_code, non_upper_case_globals)] pub const VENDOR: types::EGLenum = 0x3053;
  282|       |#[allow(dead_code, non_upper_case_globals)] pub const VERSION: types::EGLenum = 0x3054;
  283|       |#[allow(dead_code, non_upper_case_globals)] pub const VERTICAL_RESOLUTION: types::EGLenum = 0x3091;
  284|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT: types::EGLenum = 0x3088;
  285|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_NONPRE: types::EGLenum = 0x308B;
  286|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_PRE: types::EGLenum = 0x308C;
  287|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_ALPHA_FORMAT_PRE_BIT: types::EGLenum = 0x0040;
  288|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE: types::EGLenum = 0x3087;
  289|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_LINEAR: types::EGLenum = 0x308A;
  290|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_LINEAR_BIT: types::EGLenum = 0x0020;
  291|       |#[allow(dead_code, non_upper_case_globals)] pub const VG_COLORSPACE_sRGB: types::EGLenum = 0x3089;
  292|       |#[allow(dead_code, non_upper_case_globals)] pub const WIDTH: types::EGLenum = 0x3057;
  293|       |#[allow(dead_code, non_upper_case_globals)] pub const WINDOW_BIT: types::EGLenum = 0x0004;
  294|       |
  295|       |        #[allow(dead_code, missing_copy_implementations)]
  296|       |        #[derive(Clone)]
  297|       |        pub struct FnPtr {
  298|       |            /// The function pointer that will be used when calling the function.
  299|       |            f: *const __gl_imports::raw::c_void,
  300|       |            /// True if the pointer points to a real function, false if points to a `panic!` fn.
  301|       |            is_loaded: bool,
  302|       |        }
  303|       |
  304|       |        impl FnPtr {
  305|       |            /// Creates a `FnPtr` from a load attempt.
  306|      0|            fn new(ptr: *const __gl_imports::raw::c_void) -> FnPtr {
  307|      0|                if ptr.is_null() {
  ------------------
  |  Branch (307:20): [True: 0, False: 0]
  ------------------
  308|      0|                    FnPtr {
  309|      0|                        f: missing_fn_panic as *const __gl_imports::raw::c_void,
  310|      0|                        is_loaded: false
  311|      0|                    }
  312|       |                } else {
  313|      0|                    FnPtr { f: ptr, is_loaded: true }
  314|       |                }
  315|      0|            }
  316|       |
  317|       |            /// Returns `true` if the function has been successfully loaded.
  318|       |            ///
  319|       |            /// If it returns `false`, calling the corresponding function will fail.
  320|       |            #[inline]
  321|       |            #[allow(dead_code)]
  322|      0|            pub fn is_loaded(&self) -> bool {
  323|      0|                self.is_loaded
  324|      0|            }
  325|       |        }
  326|       |    
  327|       |#[inline(never)]
  328|      0|        fn missing_fn_panic() -> ! {
  329|      0|            panic!("egl function was not loaded")
  330|       |        }
  331|       |
  332|       |        #[allow(non_camel_case_types, non_snake_case, dead_code)]
  333|       |        #[derive(Clone)]
  334|       |        pub struct Egl {
  335|       |pub BindAPI: FnPtr,
  336|       |pub BindTexImage: FnPtr,
  337|       |pub ChooseConfig: FnPtr,
  338|       |/// Fallbacks: ClientWaitSyncKHR
  339|       |pub ClientWaitSync: FnPtr,
  340|       |pub ClientWaitSyncKHR: FnPtr,
  341|       |pub CopyBuffers: FnPtr,
  342|       |pub CreateContext: FnPtr,
  343|       |pub CreateImage: FnPtr,
  344|       |pub CreatePbufferFromClientBuffer: FnPtr,
  345|       |pub CreatePbufferSurface: FnPtr,
  346|       |pub CreatePixmapSurface: FnPtr,
  347|       |pub CreatePlatformPixmapSurface: FnPtr,
  348|       |pub CreatePlatformPixmapSurfaceEXT: FnPtr,
  349|       |pub CreatePlatformWindowSurface: FnPtr,
  350|       |pub CreatePlatformWindowSurfaceEXT: FnPtr,
  351|       |/// Fallbacks: CreateSync64KHR
  352|       |pub CreateSync: FnPtr,
  353|       |pub CreateSyncKHR: FnPtr,
  354|       |pub CreateWindowSurface: FnPtr,
  355|       |pub DestroyContext: FnPtr,
  356|       |/// Fallbacks: DestroyImageKHR
  357|       |pub DestroyImage: FnPtr,
  358|       |pub DestroySurface: FnPtr,
  359|       |/// Fallbacks: DestroySyncKHR
  360|       |pub DestroySync: FnPtr,
  361|       |pub DestroySyncKHR: FnPtr,
  362|       |pub DupNativeFenceFDANDROID: FnPtr,
  363|       |pub GetConfigAttrib: FnPtr,
  364|       |pub GetConfigs: FnPtr,
  365|       |pub GetCurrentContext: FnPtr,
  366|       |pub GetCurrentDisplay: FnPtr,
  367|       |pub GetCurrentSurface: FnPtr,
  368|       |pub GetDisplay: FnPtr,
  369|       |pub GetError: FnPtr,
  370|       |pub GetPlatformDisplay: FnPtr,
  371|       |pub GetPlatformDisplayEXT: FnPtr,
  372|       |pub GetProcAddress: FnPtr,
  373|       |pub GetSyncAttrib: FnPtr,
  374|       |pub GetSyncAttribKHR: FnPtr,
  375|       |pub Initialize: FnPtr,
  376|       |pub MakeCurrent: FnPtr,
  377|       |pub QueryAPI: FnPtr,
  378|       |pub QueryContext: FnPtr,
  379|       |pub QueryDeviceAttribEXT: FnPtr,
  380|       |pub QueryDeviceStringEXT: FnPtr,
  381|       |pub QueryDevicesEXT: FnPtr,
  382|       |pub QueryDisplayAttribEXT: FnPtr,
  383|       |/// Fallbacks: QueryDisplayAttribEXT, QueryDisplayAttribNV
  384|       |pub QueryDisplayAttribKHR: FnPtr,
  385|       |pub QueryString: FnPtr,
  386|       |pub QuerySurface: FnPtr,
  387|       |pub ReleaseTexImage: FnPtr,
  388|       |pub ReleaseThread: FnPtr,
  389|       |pub SurfaceAttrib: FnPtr,
  390|       |pub SwapBuffers: FnPtr,
  391|       |pub SwapBuffersWithDamageEXT: FnPtr,
  392|       |pub SwapBuffersWithDamageKHR: FnPtr,
  393|       |pub SwapInterval: FnPtr,
  394|       |pub Terminate: FnPtr,
  395|       |pub WaitClient: FnPtr,
  396|       |pub WaitGL: FnPtr,
  397|       |pub WaitNative: FnPtr,
  398|       |pub WaitSync: FnPtr,
  399|       |pub WaitSyncKHR: FnPtr,
  400|       |_priv: ()
  401|       |}
  402|       |impl Egl {
  403|       |            /// Load each OpenGL symbol using a custom load function. This allows for the
  404|       |            /// use of functions like `glfwGetProcAddress` or `SDL_GL_GetProcAddress`.
  405|       |            ///
  406|       |            /// ~~~ignore
  407|       |            /// let gl = Gl::load_with(|s| glfw.get_proc_address(s));
  408|       |            /// ~~~
  409|       |            #[allow(dead_code, unused_variables)]
  410|      0|            pub fn load_with<F>(mut loadfn: F) -> Egl where F: FnMut(&'static str) -> *const __gl_imports::raw::c_void {
  411|       |                #[inline(never)]
  412|      0|                fn do_metaloadfn(loadfn: &mut dyn FnMut(&'static str) -> *const __gl_imports::raw::c_void,
  413|      0|                                 symbol: &'static str,
  414|      0|                                 symbols: &[&'static str])
  415|      0|                                 -> *const __gl_imports::raw::c_void {
  416|      0|                    let mut ptr = loadfn(symbol);
  417|      0|                    if ptr.is_null() {
  ------------------
  |  Branch (417:24): [True: 0, False: 0]
  ------------------
  418|      0|                        for &sym in symbols {
  419|      0|                            ptr = loadfn(sym);
  420|      0|                            if !ptr.is_null() { break; }
  ------------------
  |  Branch (420:32): [True: 0, False: 0]
  ------------------
  421|       |                        }
  422|      0|                    }
  423|      0|                    ptr
  424|      0|                }
  425|      0|                let mut metaloadfn = |symbol: &'static str, symbols: &[&'static str]| {
  426|      0|                    do_metaloadfn(&mut loadfn, symbol, symbols)
  427|      0|                };
  428|      0|                Egl {
  429|      0|BindAPI: FnPtr::new(metaloadfn("eglBindAPI", &[])),
  430|      0|BindTexImage: FnPtr::new(metaloadfn("eglBindTexImage", &[])),
  431|      0|ChooseConfig: FnPtr::new(metaloadfn("eglChooseConfig", &[])),
  432|      0|ClientWaitSync: FnPtr::new(metaloadfn("eglClientWaitSync", &["eglClientWaitSyncKHR"])),
  433|      0|ClientWaitSyncKHR: FnPtr::new(metaloadfn("eglClientWaitSyncKHR", &[])),
  434|      0|CopyBuffers: FnPtr::new(metaloadfn("eglCopyBuffers", &[])),
  435|      0|CreateContext: FnPtr::new(metaloadfn("eglCreateContext", &[])),
  436|      0|CreateImage: FnPtr::new(metaloadfn("eglCreateImage", &[])),
  437|      0|CreatePbufferFromClientBuffer: FnPtr::new(metaloadfn("eglCreatePbufferFromClientBuffer", &[])),
  438|      0|CreatePbufferSurface: FnPtr::new(metaloadfn("eglCreatePbufferSurface", &[])),
  439|      0|CreatePixmapSurface: FnPtr::new(metaloadfn("eglCreatePixmapSurface", &[])),
  440|      0|CreatePlatformPixmapSurface: FnPtr::new(metaloadfn("eglCreatePlatformPixmapSurface", &[])),
  441|      0|CreatePlatformPixmapSurfaceEXT: FnPtr::new(metaloadfn("eglCreatePlatformPixmapSurfaceEXT", &[])),
  442|      0|CreatePlatformWindowSurface: FnPtr::new(metaloadfn("eglCreatePlatformWindowSurface", &[])),
  443|      0|CreatePlatformWindowSurfaceEXT: FnPtr::new(metaloadfn("eglCreatePlatformWindowSurfaceEXT", &[])),
  444|      0|CreateSync: FnPtr::new(metaloadfn("eglCreateSync", &["eglCreateSync64KHR"])),
  445|      0|CreateSyncKHR: FnPtr::new(metaloadfn("eglCreateSyncKHR", &[])),
  446|      0|CreateWindowSurface: FnPtr::new(metaloadfn("eglCreateWindowSurface", &[])),
  447|      0|DestroyContext: FnPtr::new(metaloadfn("eglDestroyContext", &[])),
  448|      0|DestroyImage: FnPtr::new(metaloadfn("eglDestroyImage", &["eglDestroyImageKHR"])),
  449|      0|DestroySurface: FnPtr::new(metaloadfn("eglDestroySurface", &[])),
  450|      0|DestroySync: FnPtr::new(metaloadfn("eglDestroySync", &["eglDestroySyncKHR"])),
  451|      0|DestroySyncKHR: FnPtr::new(metaloadfn("eglDestroySyncKHR", &[])),
  452|      0|DupNativeFenceFDANDROID: FnPtr::new(metaloadfn("eglDupNativeFenceFDANDROID", &[])),
  453|      0|GetConfigAttrib: FnPtr::new(metaloadfn("eglGetConfigAttrib", &[])),
  454|      0|GetConfigs: FnPtr::new(metaloadfn("eglGetConfigs", &[])),
  455|      0|GetCurrentContext: FnPtr::new(metaloadfn("eglGetCurrentContext", &[])),
  456|      0|GetCurrentDisplay: FnPtr::new(metaloadfn("eglGetCurrentDisplay", &[])),
  457|      0|GetCurrentSurface: FnPtr::new(metaloadfn("eglGetCurrentSurface", &[])),
  458|      0|GetDisplay: FnPtr::new(metaloadfn("eglGetDisplay", &[])),
  459|      0|GetError: FnPtr::new(metaloadfn("eglGetError", &[])),
  460|      0|GetPlatformDisplay: FnPtr::new(metaloadfn("eglGetPlatformDisplay", &[])),
  461|      0|GetPlatformDisplayEXT: FnPtr::new(metaloadfn("eglGetPlatformDisplayEXT", &[])),
  462|      0|GetProcAddress: FnPtr::new(metaloadfn("eglGetProcAddress", &[])),
  463|      0|GetSyncAttrib: FnPtr::new(metaloadfn("eglGetSyncAttrib", &[])),
  464|      0|GetSyncAttribKHR: FnPtr::new(metaloadfn("eglGetSyncAttribKHR", &[])),
  465|      0|Initialize: FnPtr::new(metaloadfn("eglInitialize", &[])),
  466|      0|MakeCurrent: FnPtr::new(metaloadfn("eglMakeCurrent", &[])),
  467|      0|QueryAPI: FnPtr::new(metaloadfn("eglQueryAPI", &[])),
  468|      0|QueryContext: FnPtr::new(metaloadfn("eglQueryContext", &[])),
  469|      0|QueryDeviceAttribEXT: FnPtr::new(metaloadfn("eglQueryDeviceAttribEXT", &[])),
  470|      0|QueryDeviceStringEXT: FnPtr::new(metaloadfn("eglQueryDeviceStringEXT", &[])),
  471|      0|QueryDevicesEXT: FnPtr::new(metaloadfn("eglQueryDevicesEXT", &[])),
  472|      0|QueryDisplayAttribEXT: FnPtr::new(metaloadfn("eglQueryDisplayAttribEXT", &[])),
  473|      0|QueryDisplayAttribKHR: FnPtr::new(metaloadfn("eglQueryDisplayAttribKHR", &["eglQueryDisplayAttribEXT", "eglQueryDisplayAttribNV"])),
  474|      0|QueryString: FnPtr::new(metaloadfn("eglQueryString", &[])),
  475|      0|QuerySurface: FnPtr::new(metaloadfn("eglQuerySurface", &[])),
  476|      0|ReleaseTexImage: FnPtr::new(metaloadfn("eglReleaseTexImage", &[])),
  477|      0|ReleaseThread: FnPtr::new(metaloadfn("eglReleaseThread", &[])),
  478|      0|SurfaceAttrib: FnPtr::new(metaloadfn("eglSurfaceAttrib", &[])),
  479|      0|SwapBuffers: FnPtr::new(metaloadfn("eglSwapBuffers", &[])),
  480|      0|SwapBuffersWithDamageEXT: FnPtr::new(metaloadfn("eglSwapBuffersWithDamageEXT", &[])),
  481|      0|SwapBuffersWithDamageKHR: FnPtr::new(metaloadfn("eglSwapBuffersWithDamageKHR", &[])),
  482|      0|SwapInterval: FnPtr::new(metaloadfn("eglSwapInterval", &[])),
  483|      0|Terminate: FnPtr::new(metaloadfn("eglTerminate", &[])),
  484|      0|WaitClient: FnPtr::new(metaloadfn("eglWaitClient", &[])),
  485|      0|WaitGL: FnPtr::new(metaloadfn("eglWaitGL", &[])),
  486|      0|WaitNative: FnPtr::new(metaloadfn("eglWaitNative", &[])),
  487|      0|WaitSync: FnPtr::new(metaloadfn("eglWaitSync", &[])),
  488|      0|WaitSyncKHR: FnPtr::new(metaloadfn("eglWaitSyncKHR", &[])),
  489|      0|_priv: ()
  490|      0|}
  491|      0|        }
  492|       |#[allow(non_snake_case, unused_variables, dead_code)]
  493|      0|            #[inline] pub unsafe fn BindAPI(&self, api: types::EGLenum) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLenum) -> types::EGLBoolean>(self.BindAPI.f)(api) }
  494|       |#[allow(non_snake_case, unused_variables, dead_code)]
  495|      0|            #[inline] pub unsafe fn BindTexImage(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, buffer: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint) -> types::EGLBoolean>(self.BindTexImage.f)(dpy, surface, buffer) }
  496|       |#[allow(non_snake_case, unused_variables, dead_code)]
  497|      0|            #[inline] pub unsafe fn ChooseConfig(&self, dpy: types::EGLDisplay, attrib_list: *const types::EGLint, configs: *mut types::EGLConfig, config_size: types::EGLint, num_config: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, *const types::EGLint, *mut types::EGLConfig, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.ChooseConfig.f)(dpy, attrib_list, configs, config_size, num_config) }
  498|       |#[allow(non_snake_case, unused_variables, dead_code)]
  499|      0|            #[inline] pub unsafe fn ClientWaitSync(&self, dpy: types::EGLDisplay, sync: types::EGLSync, flags: types::EGLint, timeout: types::EGLTime) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync, types::EGLint, types::EGLTime) -> types::EGLint>(self.ClientWaitSync.f)(dpy, sync, flags, timeout) }
  500|       |#[allow(non_snake_case, unused_variables, dead_code)]
  501|      0|            #[inline] pub unsafe fn ClientWaitSyncKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, flags: types::EGLint, timeout: types::EGLTimeKHR) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint, types::EGLTimeKHR) -> types::EGLint>(self.ClientWaitSyncKHR.f)(dpy, sync, flags, timeout) }
  502|       |#[allow(non_snake_case, unused_variables, dead_code)]
  503|      0|            #[inline] pub unsafe fn CopyBuffers(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, target: types::EGLNativePixmapType) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLNativePixmapType) -> types::EGLBoolean>(self.CopyBuffers.f)(dpy, surface, target) }
  504|       |#[allow(non_snake_case, unused_variables, dead_code)]
  505|      0|            #[inline] pub unsafe fn CreateContext(&self, dpy: types::EGLDisplay, config: types::EGLConfig, share_context: types::EGLContext, attrib_list: *const types::EGLint) -> types::EGLContext { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLContext, *const types::EGLint) -> types::EGLContext>(self.CreateContext.f)(dpy, config, share_context, attrib_list) }
  506|       |#[allow(non_snake_case, unused_variables, dead_code)]
  507|      0|            #[inline] pub unsafe fn CreateImage(&self, dpy: types::EGLDisplay, ctx: types::EGLContext, target: types::EGLenum, buffer: types::EGLClientBuffer, attrib_list: *const types::EGLAttrib) -> types::EGLImage { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLContext, types::EGLenum, types::EGLClientBuffer, *const types::EGLAttrib) -> types::EGLImage>(self.CreateImage.f)(dpy, ctx, target, buffer, attrib_list) }
  508|       |#[allow(non_snake_case, unused_variables, dead_code)]
  509|      0|            #[inline] pub unsafe fn CreatePbufferFromClientBuffer(&self, dpy: types::EGLDisplay, buftype: types::EGLenum, buffer: types::EGLClientBuffer, config: types::EGLConfig, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLenum, types::EGLClientBuffer, types::EGLConfig, *const types::EGLint) -> types::EGLSurface>(self.CreatePbufferFromClientBuffer.f)(dpy, buftype, buffer, config, attrib_list) }
  510|       |#[allow(non_snake_case, unused_variables, dead_code)]
  511|      0|            #[inline] pub unsafe fn CreatePbufferSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *const types::EGLint) -> types::EGLSurface>(self.CreatePbufferSurface.f)(dpy, config, attrib_list) }
  512|       |#[allow(non_snake_case, unused_variables, dead_code)]
  513|      0|            #[inline] pub unsafe fn CreatePixmapSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, pixmap: types::EGLNativePixmapType, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLNativePixmapType, *const types::EGLint) -> types::EGLSurface>(self.CreatePixmapSurface.f)(dpy, config, pixmap, attrib_list) }
  514|       |#[allow(non_snake_case, unused_variables, dead_code)]
  515|      0|            #[inline] pub unsafe fn CreatePlatformPixmapSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_pixmap: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -> types::EGLSurface>(self.CreatePlatformPixmapSurface.f)(dpy, config, native_pixmap, attrib_list) }
  516|       |#[allow(non_snake_case, unused_variables, dead_code)]
  517|      0|            #[inline] pub unsafe fn CreatePlatformPixmapSurfaceEXT(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_pixmap: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLint) -> types::EGLSurface>(self.CreatePlatformPixmapSurfaceEXT.f)(dpy, config, native_pixmap, attrib_list) }
  518|       |#[allow(non_snake_case, unused_variables, dead_code)]
  519|      0|            #[inline] pub unsafe fn CreatePlatformWindowSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_window: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -> types::EGLSurface>(self.CreatePlatformWindowSurface.f)(dpy, config, native_window, attrib_list) }
  520|       |#[allow(non_snake_case, unused_variables, dead_code)]
  521|      0|            #[inline] pub unsafe fn CreatePlatformWindowSurfaceEXT(&self, dpy: types::EGLDisplay, config: types::EGLConfig, native_window: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, *mut __gl_imports::raw::c_void, *const types::EGLint) -> types::EGLSurface>(self.CreatePlatformWindowSurfaceEXT.f)(dpy, config, native_window, attrib_list) }
  522|       |#[allow(non_snake_case, unused_variables, dead_code)]
  523|      0|            #[inline] pub unsafe fn CreateSync(&self, dpy: types::EGLDisplay, type_: types::EGLenum, attrib_list: *const types::EGLAttrib) -> types::EGLSync { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLenum, *const types::EGLAttrib) -> types::EGLSync>(self.CreateSync.f)(dpy, type_, attrib_list) }
  524|       |#[allow(non_snake_case, unused_variables, dead_code)]
  525|      0|            #[inline] pub unsafe fn CreateSyncKHR(&self, dpy: types::EGLDisplay, type_: types::EGLenum, attrib_list: *const types::EGLint) -> types::EGLSyncKHR { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLenum, *const types::EGLint) -> types::EGLSyncKHR>(self.CreateSyncKHR.f)(dpy, type_, attrib_list) }
  526|       |#[allow(non_snake_case, unused_variables, dead_code)]
  527|      0|            #[inline] pub unsafe fn CreateWindowSurface(&self, dpy: types::EGLDisplay, config: types::EGLConfig, win: types::EGLNativeWindowType, attrib_list: *const types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLNativeWindowType, *const types::EGLint) -> types::EGLSurface>(self.CreateWindowSurface.f)(dpy, config, win, attrib_list) }
  528|       |#[allow(non_snake_case, unused_variables, dead_code)]
  529|      0|            #[inline] pub unsafe fn DestroyContext(&self, dpy: types::EGLDisplay, ctx: types::EGLContext) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLContext) -> types::EGLBoolean>(self.DestroyContext.f)(dpy, ctx) }
  530|       |#[allow(non_snake_case, unused_variables, dead_code)]
  531|      0|            #[inline] pub unsafe fn DestroyImage(&self, dpy: types::EGLDisplay, image: types::EGLImage) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLImage) -> types::EGLBoolean>(self.DestroyImage.f)(dpy, image) }
  532|       |#[allow(non_snake_case, unused_variables, dead_code)]
  533|      0|            #[inline] pub unsafe fn DestroySurface(&self, dpy: types::EGLDisplay, surface: types::EGLSurface) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface) -> types::EGLBoolean>(self.DestroySurface.f)(dpy, surface) }
  534|       |#[allow(non_snake_case, unused_variables, dead_code)]
  535|      0|            #[inline] pub unsafe fn DestroySync(&self, dpy: types::EGLDisplay, sync: types::EGLSync) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync) -> types::EGLBoolean>(self.DestroySync.f)(dpy, sync) }
  536|       |#[allow(non_snake_case, unused_variables, dead_code)]
  537|      0|            #[inline] pub unsafe fn DestroySyncKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR) -> types::EGLBoolean>(self.DestroySyncKHR.f)(dpy, sync) }
  538|       |#[allow(non_snake_case, unused_variables, dead_code)]
  539|      0|            #[inline] pub unsafe fn DupNativeFenceFDANDROID(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR) -> types::EGLint>(self.DupNativeFenceFDANDROID.f)(dpy, sync) }
  540|       |#[allow(non_snake_case, unused_variables, dead_code)]
  541|      0|            #[inline] pub unsafe fn GetConfigAttrib(&self, dpy: types::EGLDisplay, config: types::EGLConfig, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLConfig, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.GetConfigAttrib.f)(dpy, config, attribute, value) }
  542|       |#[allow(non_snake_case, unused_variables, dead_code)]
  543|      0|            #[inline] pub unsafe fn GetConfigs(&self, dpy: types::EGLDisplay, configs: *mut types::EGLConfig, config_size: types::EGLint, num_config: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, *mut types::EGLConfig, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.GetConfigs.f)(dpy, configs, config_size, num_config) }
  544|       |#[allow(non_snake_case, unused_variables, dead_code)]
  545|      0|            #[inline] pub unsafe fn GetCurrentContext(&self, ) -> types::EGLContext { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLContext>(self.GetCurrentContext.f)() }
  546|       |#[allow(non_snake_case, unused_variables, dead_code)]
  547|      0|            #[inline] pub unsafe fn GetCurrentDisplay(&self, ) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLDisplay>(self.GetCurrentDisplay.f)() }
  548|       |#[allow(non_snake_case, unused_variables, dead_code)]
  549|      0|            #[inline] pub unsafe fn GetCurrentSurface(&self, readdraw: types::EGLint) -> types::EGLSurface { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLint) -> types::EGLSurface>(self.GetCurrentSurface.f)(readdraw) }
  550|       |#[allow(non_snake_case, unused_variables, dead_code)]
  551|      0|            #[inline] pub unsafe fn GetDisplay(&self, display_id: types::EGLNativeDisplayType) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLNativeDisplayType) -> types::EGLDisplay>(self.GetDisplay.f)(display_id) }
  552|       |#[allow(non_snake_case, unused_variables, dead_code)]
  553|      0|            #[inline] pub unsafe fn GetError(&self, ) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLint>(self.GetError.f)() }
  554|       |#[allow(non_snake_case, unused_variables, dead_code)]
  555|      0|            #[inline] pub unsafe fn GetPlatformDisplay(&self, platform: types::EGLenum, native_display: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLAttrib) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLenum, *mut __gl_imports::raw::c_void, *const types::EGLAttrib) -> types::EGLDisplay>(self.GetPlatformDisplay.f)(platform, native_display, attrib_list) }
  556|       |#[allow(non_snake_case, unused_variables, dead_code)]
  557|      0|            #[inline] pub unsafe fn GetPlatformDisplayEXT(&self, platform: types::EGLenum, native_display: *mut __gl_imports::raw::c_void, attrib_list: *const types::EGLint) -> types::EGLDisplay { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLenum, *mut __gl_imports::raw::c_void, *const types::EGLint) -> types::EGLDisplay>(self.GetPlatformDisplayEXT.f)(platform, native_display, attrib_list) }
  558|       |#[allow(non_snake_case, unused_variables, dead_code)]
  559|      0|            #[inline] pub unsafe fn GetProcAddress(&self, procname: *const __gl_imports::raw::c_char) -> types::__eglMustCastToProperFunctionPointerType { __gl_imports::mem::transmute::<_, extern "system" fn(*const __gl_imports::raw::c_char) -> types::__eglMustCastToProperFunctionPointerType>(self.GetProcAddress.f)(procname) }
  560|       |#[allow(non_snake_case, unused_variables, dead_code)]
  561|      0|            #[inline] pub unsafe fn GetSyncAttrib(&self, dpy: types::EGLDisplay, sync: types::EGLSync, attribute: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.GetSyncAttrib.f)(dpy, sync, attribute, value) }
  562|       |#[allow(non_snake_case, unused_variables, dead_code)]
  563|      0|            #[inline] pub unsafe fn GetSyncAttribKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.GetSyncAttribKHR.f)(dpy, sync, attribute, value) }
  564|       |#[allow(non_snake_case, unused_variables, dead_code)]
  565|      0|            #[inline] pub unsafe fn Initialize(&self, dpy: types::EGLDisplay, major: *mut types::EGLint, minor: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, *mut types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.Initialize.f)(dpy, major, minor) }
  566|       |#[allow(non_snake_case, unused_variables, dead_code)]
  567|      0|            #[inline] pub unsafe fn MakeCurrent(&self, dpy: types::EGLDisplay, draw: types::EGLSurface, read: types::EGLSurface, ctx: types::EGLContext) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLSurface, types::EGLContext) -> types::EGLBoolean>(self.MakeCurrent.f)(dpy, draw, read, ctx) }
  568|       |#[allow(non_snake_case, unused_variables, dead_code)]
  569|      0|            #[inline] pub unsafe fn QueryAPI(&self, ) -> types::EGLenum { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLenum>(self.QueryAPI.f)() }
  570|       |#[allow(non_snake_case, unused_variables, dead_code)]
  571|      0|            #[inline] pub unsafe fn QueryContext(&self, dpy: types::EGLDisplay, ctx: types::EGLContext, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLContext, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.QueryContext.f)(dpy, ctx, attribute, value) }
  572|       |#[allow(non_snake_case, unused_variables, dead_code)]
  573|      0|            #[inline] pub unsafe fn QueryDeviceAttribEXT(&self, device: types::EGLDeviceEXT, attribute: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDeviceEXT, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.QueryDeviceAttribEXT.f)(device, attribute, value) }
  574|       |#[allow(non_snake_case, unused_variables, dead_code)]
  575|      0|            #[inline] pub unsafe fn QueryDeviceStringEXT(&self, device: types::EGLDeviceEXT, name: types::EGLint) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDeviceEXT, types::EGLint) -> *const __gl_imports::raw::c_char>(self.QueryDeviceStringEXT.f)(device, name) }
  576|       |#[allow(non_snake_case, unused_variables, dead_code)]
  577|      0|            #[inline] pub unsafe fn QueryDevicesEXT(&self, max_devices: types::EGLint, devices: *mut types::EGLDeviceEXT, num_devices: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLint, *mut types::EGLDeviceEXT, *mut types::EGLint) -> types::EGLBoolean>(self.QueryDevicesEXT.f)(max_devices, devices, num_devices) }
  578|       |#[allow(non_snake_case, unused_variables, dead_code)]
  579|      0|            #[inline] pub unsafe fn QueryDisplayAttribEXT(&self, dpy: types::EGLDisplay, attribute: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.QueryDisplayAttribEXT.f)(dpy, attribute, value) }
  580|       |#[allow(non_snake_case, unused_variables, dead_code)]
  581|      0|            #[inline] pub unsafe fn QueryDisplayAttribKHR(&self, dpy: types::EGLDisplay, name: types::EGLint, value: *mut types::EGLAttrib) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint, *mut types::EGLAttrib) -> types::EGLBoolean>(self.QueryDisplayAttribKHR.f)(dpy, name, value) }
  582|       |#[allow(non_snake_case, unused_variables, dead_code)]
  583|      0|            #[inline] pub unsafe fn QueryString(&self, dpy: types::EGLDisplay, name: types::EGLint) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint) -> *const __gl_imports::raw::c_char>(self.QueryString.f)(dpy, name) }
  584|       |#[allow(non_snake_case, unused_variables, dead_code)]
  585|      0|            #[inline] pub unsafe fn QuerySurface(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, attribute: types::EGLint, value: *mut types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint, *mut types::EGLint) -> types::EGLBoolean>(self.QuerySurface.f)(dpy, surface, attribute, value) }
  586|       |#[allow(non_snake_case, unused_variables, dead_code)]
  587|      0|            #[inline] pub unsafe fn ReleaseTexImage(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, buffer: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint) -> types::EGLBoolean>(self.ReleaseTexImage.f)(dpy, surface, buffer) }
  588|       |#[allow(non_snake_case, unused_variables, dead_code)]
  589|      0|            #[inline] pub unsafe fn ReleaseThread(&self, ) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLBoolean>(self.ReleaseThread.f)() }
  590|       |#[allow(non_snake_case, unused_variables, dead_code)]
  591|      0|            #[inline] pub unsafe fn SurfaceAttrib(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, attribute: types::EGLint, value: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, types::EGLint, types::EGLint) -> types::EGLBoolean>(self.SurfaceAttrib.f)(dpy, surface, attribute, value) }
  592|       |#[allow(non_snake_case, unused_variables, dead_code)]
  593|      0|            #[inline] pub unsafe fn SwapBuffers(&self, dpy: types::EGLDisplay, surface: types::EGLSurface) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface) -> types::EGLBoolean>(self.SwapBuffers.f)(dpy, surface) }
  594|       |#[allow(non_snake_case, unused_variables, dead_code)]
  595|      0|            #[inline] pub unsafe fn SwapBuffersWithDamageEXT(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, rects: *mut types::EGLint, n_rects: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, *mut types::EGLint, types::EGLint) -> types::EGLBoolean>(self.SwapBuffersWithDamageEXT.f)(dpy, surface, rects, n_rects) }
  596|       |#[allow(non_snake_case, unused_variables, dead_code)]
  597|      0|            #[inline] pub unsafe fn SwapBuffersWithDamageKHR(&self, dpy: types::EGLDisplay, surface: types::EGLSurface, rects: *mut types::EGLint, n_rects: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSurface, *mut types::EGLint, types::EGLint) -> types::EGLBoolean>(self.SwapBuffersWithDamageKHR.f)(dpy, surface, rects, n_rects) }
  598|       |#[allow(non_snake_case, unused_variables, dead_code)]
  599|      0|            #[inline] pub unsafe fn SwapInterval(&self, dpy: types::EGLDisplay, interval: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLint) -> types::EGLBoolean>(self.SwapInterval.f)(dpy, interval) }
  600|       |#[allow(non_snake_case, unused_variables, dead_code)]
  601|      0|            #[inline] pub unsafe fn Terminate(&self, dpy: types::EGLDisplay) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay) -> types::EGLBoolean>(self.Terminate.f)(dpy) }
  602|       |#[allow(non_snake_case, unused_variables, dead_code)]
  603|      0|            #[inline] pub unsafe fn WaitClient(&self, ) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLBoolean>(self.WaitClient.f)() }
  604|       |#[allow(non_snake_case, unused_variables, dead_code)]
  605|      0|            #[inline] pub unsafe fn WaitGL(&self, ) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::EGLBoolean>(self.WaitGL.f)() }
  606|       |#[allow(non_snake_case, unused_variables, dead_code)]
  607|      0|            #[inline] pub unsafe fn WaitNative(&self, engine: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLint) -> types::EGLBoolean>(self.WaitNative.f)(engine) }
  608|       |#[allow(non_snake_case, unused_variables, dead_code)]
  609|      0|            #[inline] pub unsafe fn WaitSync(&self, dpy: types::EGLDisplay, sync: types::EGLSync, flags: types::EGLint) -> types::EGLBoolean { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSync, types::EGLint) -> types::EGLBoolean>(self.WaitSync.f)(dpy, sync, flags) }
  610|       |#[allow(non_snake_case, unused_variables, dead_code)]
  611|      0|            #[inline] pub unsafe fn WaitSyncKHR(&self, dpy: types::EGLDisplay, sync: types::EGLSyncKHR, flags: types::EGLint) -> types::EGLint { __gl_imports::mem::transmute::<_, extern "system" fn(types::EGLDisplay, types::EGLSyncKHR, types::EGLint) -> types::EGLint>(self.WaitSyncKHR.f)(dpy, sync, flags) }
  612|       |}
  613|       |
  614|       |        unsafe impl __gl_imports::Send for Egl {}

c:\language\mdmdview\target\llvm-cov-target\debug\build\glutin_wgl_sys-40d142050ed41546\out\wgl_extra_bindings.rs:
    1|       |
    2|       |        mod __gl_imports {
    3|       |            pub use std::mem;
    4|       |            pub use std::marker::Send;
    5|       |            pub use std::os::raw;
    6|       |        }
    7|       |    
    8|       |
    9|       |        pub mod types {
   10|       |            #![allow(non_camel_case_types, non_snake_case, dead_code, missing_copy_implementations)]
   11|       |    
   12|       |// Common types from OpenGL 1.1
   13|       |pub type GLenum = super::__gl_imports::raw::c_uint;
   14|       |pub type GLboolean = super::__gl_imports::raw::c_uchar;
   15|       |pub type GLbitfield = super::__gl_imports::raw::c_uint;
   16|       |pub type GLvoid = super::__gl_imports::raw::c_void;
   17|       |pub type GLbyte = super::__gl_imports::raw::c_char;
   18|       |pub type GLshort = super::__gl_imports::raw::c_short;
   19|       |pub type GLint = super::__gl_imports::raw::c_int;
   20|       |pub type GLclampx = super::__gl_imports::raw::c_int;
   21|       |pub type GLubyte = super::__gl_imports::raw::c_uchar;
   22|       |pub type GLushort = super::__gl_imports::raw::c_ushort;
   23|       |pub type GLuint = super::__gl_imports::raw::c_uint;
   24|       |pub type GLsizei = super::__gl_imports::raw::c_int;
   25|       |pub type GLfloat = super::__gl_imports::raw::c_float;
   26|       |pub type GLclampf = super::__gl_imports::raw::c_float;
   27|       |pub type GLdouble = super::__gl_imports::raw::c_double;
   28|       |pub type GLclampd = super::__gl_imports::raw::c_double;
   29|       |pub type GLeglImageOES = *const super::__gl_imports::raw::c_void;
   30|       |pub type GLchar = super::__gl_imports::raw::c_char;
   31|       |pub type GLcharARB = super::__gl_imports::raw::c_char;
   32|       |
   33|       |#[cfg(target_os = "macos")]
   34|       |pub type GLhandleARB = *const super::__gl_imports::raw::c_void;
   35|       |#[cfg(not(target_os = "macos"))]
   36|       |pub type GLhandleARB = super::__gl_imports::raw::c_uint;
   37|       |
   38|       |pub type GLhalfARB = super::__gl_imports::raw::c_ushort;
   39|       |pub type GLhalf = super::__gl_imports::raw::c_ushort;
   40|       |
   41|       |// Must be 32 bits
   42|       |pub type GLfixed = GLint;
   43|       |
   44|       |pub type GLintptr = isize;
   45|       |pub type GLsizeiptr = isize;
   46|       |pub type GLint64 = i64;
   47|       |pub type GLuint64 = u64;
   48|       |pub type GLintptrARB = isize;
   49|       |pub type GLsizeiptrARB = isize;
   50|       |pub type GLint64EXT = i64;
   51|       |pub type GLuint64EXT = u64;
   52|       |
   53|       |pub enum __GLsync {}
   54|       |pub type GLsync = *const __GLsync;
   55|       |
   56|       |// compatible with OpenCL cl_context
   57|       |pub enum _cl_context {}
   58|       |pub enum _cl_event {}
   59|       |
   60|       |pub type GLDEBUGPROC = Option<extern "system" fn(source: GLenum,
   61|       |                                                 gltype: GLenum,
   62|       |                                                 id: GLuint,
   63|       |                                                 severity: GLenum,
   64|       |                                                 length: GLsizei,
   65|       |                                                 message: *const GLchar,
   66|       |                                                 userParam: *mut super::__gl_imports::raw::c_void)>;
   67|       |pub type GLDEBUGPROCARB = Option<extern "system" fn(source: GLenum,
   68|       |                                                    gltype: GLenum,
   69|       |                                                    id: GLuint,
   70|       |                                                    severity: GLenum,
   71|       |                                                    length: GLsizei,
   72|       |                                                    message: *const GLchar,
   73|       |                                                    userParam: *mut super::__gl_imports::raw::c_void)>;
   74|       |pub type GLDEBUGPROCKHR = Option<extern "system" fn(source: GLenum,
   75|       |                                                    gltype: GLenum,
   76|       |                                                    id: GLuint,
   77|       |                                                    severity: GLenum,
   78|       |                                                    length: GLsizei,
   79|       |                                                    message: *const GLchar,
   80|       |                                                    userParam: *mut super::__gl_imports::raw::c_void)>;
   81|       |
   82|       |// GLES 1 types
   83|       |// "pub type GLclampx = i32;",
   84|       |
   85|       |// GLES 1/2 types (tagged for GLES 1)
   86|       |// "pub type GLbyte = i8;",
   87|       |// "pub type GLubyte = u8;",
   88|       |// "pub type GLfloat = GLfloat;",
   89|       |// "pub type GLclampf = GLfloat;",
   90|       |// "pub type GLfixed = i32;",
   91|       |// "pub type GLint64 = i64;",
   92|       |// "pub type GLuint64 = u64;",
   93|       |// "pub type GLintptr = intptr_t;",
   94|       |// "pub type GLsizeiptr = ssize_t;",
   95|       |
   96|       |// GLES 1/2 types (tagged for GLES 2 - attribute syntax is limited)
   97|       |// "pub type GLbyte = i8;",
   98|       |// "pub type GLubyte = u8;",
   99|       |// "pub type GLfloat = GLfloat;",
  100|       |// "pub type GLclampf = GLfloat;",
  101|       |// "pub type GLfixed = i32;",
  102|       |// "pub type GLint64 = i64;",
  103|       |// "pub type GLuint64 = u64;",
  104|       |// "pub type GLint64EXT = i64;",
  105|       |// "pub type GLuint64EXT = u64;",
  106|       |// "pub type GLintptr = intptr_t;",
  107|       |// "pub type GLsizeiptr = ssize_t;",
  108|       |
  109|       |// GLES 2 types (none currently)
  110|       |
  111|       |// Vendor extension types
  112|       |pub type GLDEBUGPROCAMD = Option<extern "system" fn(id: GLuint,
  113|       |                                                    category: GLenum,
  114|       |                                                    severity: GLenum,
  115|       |                                                    length: GLsizei,
  116|       |                                                    message: *const GLchar,
  117|       |                                                    userParam: *mut super::__gl_imports::raw::c_void)>;
  118|       |pub type GLhalfNV = super::__gl_imports::raw::c_ushort;
  119|       |pub type GLvdpauSurfaceNV = GLintptr;
  120|       |
  121|       |// From WinNT.h
  122|       |
  123|       |pub type CHAR = super::__gl_imports::raw::c_char;
  124|       |pub type HANDLE = PVOID;
  125|       |pub type LONG = super::__gl_imports::raw::c_long;
  126|       |pub type LPCSTR = *const super::__gl_imports::raw::c_char;
  127|       |pub type VOID = ();
  128|       |// #define DECLARE_HANDLE(name) struct name##__{int unused;}; typedef struct name##__ *name
  129|       |pub type HPBUFFERARB = *const super::__gl_imports::raw::c_void;
  130|       |pub type HPBUFFEREXT = *const super::__gl_imports::raw::c_void;
  131|       |pub type HVIDEOOUTPUTDEVICENV = *const super::__gl_imports::raw::c_void;
  132|       |pub type HPVIDEODEV = *const super::__gl_imports::raw::c_void;
  133|       |pub type HPGPUNV = *const super::__gl_imports::raw::c_void;
  134|       |pub type HGPUNV = *const super::__gl_imports::raw::c_void;
  135|       |pub type HVIDEOINPUTDEVICENV = *const super::__gl_imports::raw::c_void;
  136|       |
  137|       |// From Windef.h
  138|       |
  139|       |pub type BOOL = super::__gl_imports::raw::c_int;
  140|       |pub type BYTE = super::__gl_imports::raw::c_uchar;
  141|       |pub type COLORREF = DWORD;
  142|       |pub type FLOAT = super::__gl_imports::raw::c_float;
  143|       |pub type HDC = HANDLE;
  144|       |pub type HENHMETAFILE = HANDLE;
  145|       |pub type HGLRC = *const super::__gl_imports::raw::c_void;
  146|       |pub type INT = super::__gl_imports::raw::c_int;
  147|       |pub type PVOID = *const super::__gl_imports::raw::c_void;
  148|       |pub type LPVOID = *const super::__gl_imports::raw::c_void;
  149|       |pub enum __PROC_fn {}
  150|       |pub type PROC = *mut __PROC_fn;
  151|       |
  152|       |#[repr(C)]
  153|       |pub struct RECT {
  154|       |    left: LONG,
  155|       |    top: LONG,
  156|       |    right: LONG,
  157|       |    bottom: LONG,
  158|       |}
  159|       |
  160|       |pub type UINT = super::__gl_imports::raw::c_uint;
  161|       |pub type USHORT = super::__gl_imports::raw::c_ushort;
  162|       |pub type WORD = super::__gl_imports::raw::c_ushort;
  163|       |
  164|       |// From BaseTsd.h
  165|       |
  166|       |pub type INT32 = i32;
  167|       |pub type INT64 = i64;
  168|       |
  169|       |// From IntSafe.h
  170|       |
  171|       |pub type DWORD = super::__gl_imports::raw::c_ulong;
  172|       |
  173|       |// From Wingdi.h
  174|       |
  175|       |#[repr(C)]
  176|       |pub struct POINTFLOAT {
  177|       |    pub x: FLOAT,
  178|       |    pub y: FLOAT,
  179|       |}
  180|       |
  181|       |#[repr(C)]
  182|       |pub struct GLYPHMETRICSFLOAT {
  183|       |    pub gmfBlackBoxX: FLOAT,
  184|       |    pub gmfBlackBoxY: FLOAT,
  185|       |    pub gmfptGlyphOrigin: POINTFLOAT,
  186|       |    pub gmfCellIncX: FLOAT,
  187|       |    pub gmfCellIncY: FLOAT,
  188|       |}
  189|       |pub type LPGLYPHMETRICSFLOAT = *const GLYPHMETRICSFLOAT;
  190|       |
  191|       |#[repr(C)]
  192|       |pub struct LAYERPLANEDESCRIPTOR {
  193|       |    pub nSize: WORD,
  194|       |    pub nVersion: WORD,
  195|       |    pub dwFlags: DWORD,
  196|       |    pub iPixelType: BYTE,
  197|       |    pub cColorBits: BYTE,
  198|       |    pub cRedBits: BYTE,
  199|       |    pub cRedShift: BYTE,
  200|       |    pub cGreenBits: BYTE,
  201|       |    pub cGreenShift: BYTE,
  202|       |    pub cBlueBits: BYTE,
  203|       |    pub cBlueShift: BYTE,
  204|       |    pub cAlphaBits: BYTE,
  205|       |    pub cAlphaShift: BYTE,
  206|       |    pub cAccumBits: BYTE,
  207|       |    pub cAccumRedBits: BYTE,
  208|       |    pub cAccumGreenBits: BYTE,
  209|       |    pub cAccumBlueBits: BYTE,
  210|       |    pub cAccumAlphaBits: BYTE,
  211|       |    pub cDepthBits: BYTE,
  212|       |    pub cStencilBits: BYTE,
  213|       |    pub cAuxBuffers: BYTE,
  214|       |    pub iLayerType: BYTE,
  215|       |    pub bReserved: BYTE,
  216|       |    pub crTransparent: COLORREF,
  217|       |}
  218|       |
  219|       |#[repr(C)]
  220|       |pub struct PIXELFORMATDESCRIPTOR {
  221|       |    pub nSize: WORD,
  222|       |    pub nVersion: WORD,
  223|       |    pub dwFlags: DWORD,
  224|       |    pub iPixelType: BYTE,
  225|       |    pub cColorBits: BYTE,
  226|       |    pub cRedBits: BYTE,
  227|       |    pub cRedShift: BYTE,
  228|       |    pub cGreenBits: BYTE,
  229|       |    pub cGreenShift: BYTE,
  230|       |    pub cBlueBits: BYTE,
  231|       |    pub cBlueShift: BYTE,
  232|       |    pub cAlphaBits: BYTE,
  233|       |    pub cAlphaShift: BYTE,
  234|       |    pub cAccumBits: BYTE,
  235|       |    pub cAccumRedBits: BYTE,
  236|       |    pub cAccumGreenBits: BYTE,
  237|       |    pub cAccumBlueBits: BYTE,
  238|       |    pub cAccumAlphaBits: BYTE,
  239|       |    pub cDepthBits: BYTE,
  240|       |    pub cStencilBits: BYTE,
  241|       |    pub cAuxBuffers: BYTE,
  242|       |    pub iLayerType: BYTE,
  243|       |    pub bReserved: BYTE,
  244|       |    pub dwLayerMask: DWORD,
  245|       |    pub dwVisibleMask: DWORD,
  246|       |    pub dwDamageMask: DWORD,
  247|       |}
  248|       |
  249|       |#[repr(C)]
  250|       |pub struct _GPU_DEVICE {
  251|       |    cb: DWORD,
  252|       |    DeviceName: [CHAR; 32],
  253|       |    DeviceString: [CHAR; 128],
  254|       |    Flags: DWORD,
  255|       |    rcVirtualScreen: RECT,
  256|       |}
  257|       |
  258|       |pub struct GPU_DEVICE(_GPU_DEVICE);
  259|       |pub struct PGPU_DEVICE(*const _GPU_DEVICE);
  260|       |
  261|       |}
  262|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCELERATION_ARB: types::GLenum = 0x2003;
  263|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_ALPHA_BITS_ARB: types::GLenum = 0x2021;
  264|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_BITS_ARB: types::GLenum = 0x201D;
  265|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_BLUE_BITS_ARB: types::GLenum = 0x2020;
  266|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_GREEN_BITS_ARB: types::GLenum = 0x201F;
  267|       |#[allow(dead_code, non_upper_case_globals)] pub const ACCUM_RED_BITS_ARB: types::GLenum = 0x201E;
  268|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_BITS_ARB: types::GLenum = 0x201B;
  269|       |#[allow(dead_code, non_upper_case_globals)] pub const ALPHA_SHIFT_ARB: types::GLenum = 0x201C;
  270|       |#[allow(dead_code, non_upper_case_globals)] pub const AUX_BUFFERS_ARB: types::GLenum = 0x2024;
  271|       |#[allow(dead_code, non_upper_case_globals)] pub const BLUE_BITS_ARB: types::GLenum = 0x2019;
  272|       |#[allow(dead_code, non_upper_case_globals)] pub const BLUE_SHIFT_ARB: types::GLenum = 0x201A;
  273|       |#[allow(dead_code, non_upper_case_globals)] pub const COLOR_BITS_ARB: types::GLenum = 0x2014;
  274|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB: types::GLenum = 0x00000002;
  275|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_CORE_PROFILE_BIT_ARB: types::GLenum = 0x00000001;
  276|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_DEBUG_BIT_ARB: types::GLenum = 0x00000001;
  277|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_ES2_PROFILE_BIT_EXT: types::GLenum = 0x00000004;
  278|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FLAGS_ARB: types::GLenum = 0x2094;
  279|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_FORWARD_COMPATIBLE_BIT_ARB: types::GLenum = 0x00000002;
  280|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_LAYER_PLANE_ARB: types::GLenum = 0x2093;
  281|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MAJOR_VERSION_ARB: types::GLenum = 0x2091;
  282|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_MINOR_VERSION_ARB: types::GLenum = 0x2092;
  283|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_OPENGL_NO_ERROR_ARB: types::GLenum = 0x31B3;
  284|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_PROFILE_MASK_ARB: types::GLenum = 0x9126;
  285|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_ARB: types::GLenum = 0x2097;
  286|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_FLUSH_ARB: types::GLenum = 0x2098;
  287|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RELEASE_BEHAVIOR_NONE_ARB: types::GLenum = 0;
  288|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB: types::GLenum = 0x8256;
  289|       |#[allow(dead_code, non_upper_case_globals)] pub const CONTEXT_ROBUST_ACCESS_BIT_ARB: types::GLenum = 0x00000004;
  290|       |#[allow(dead_code, non_upper_case_globals)] pub const DEPTH_BITS_ARB: types::GLenum = 0x2022;
  291|       |#[allow(dead_code, non_upper_case_globals)] pub const DOUBLE_BUFFER_ARB: types::GLenum = 0x2011;
  292|       |#[allow(dead_code, non_upper_case_globals)] pub const DRAW_TO_BITMAP_ARB: types::GLenum = 0x2002;
  293|       |#[allow(dead_code, non_upper_case_globals)] pub const DRAW_TO_WINDOW_ARB: types::GLenum = 0x2001;
  294|       |#[allow(dead_code, non_upper_case_globals)] pub const FONT_LINES: types::GLenum = 0;
  295|       |#[allow(dead_code, non_upper_case_globals)] pub const FONT_POLYGONS: types::GLenum = 1;
  296|       |#[allow(dead_code, non_upper_case_globals)] pub const FRAMEBUFFER_SRGB_CAPABLE_ARB: types::GLenum = 0x20A9;
  297|       |#[allow(dead_code, non_upper_case_globals)] pub const FRAMEBUFFER_SRGB_CAPABLE_EXT: types::GLenum = 0x20A9;
  298|       |#[allow(dead_code, non_upper_case_globals)] pub const FULL_ACCELERATION_ARB: types::GLenum = 0x2027;
  299|       |#[allow(dead_code, non_upper_case_globals)] pub const GENERIC_ACCELERATION_ARB: types::GLenum = 0x2026;
  300|       |#[allow(dead_code, non_upper_case_globals)] pub const GREEN_BITS_ARB: types::GLenum = 0x2017;
  301|       |#[allow(dead_code, non_upper_case_globals)] pub const GREEN_SHIFT_ARB: types::GLenum = 0x2018;
  302|       |#[allow(dead_code, non_upper_case_globals)] pub const LOSE_CONTEXT_ON_RESET_ARB: types::GLenum = 0x8252;
  303|       |#[allow(dead_code, non_upper_case_globals)] pub const NEED_PALETTE_ARB: types::GLenum = 0x2004;
  304|       |#[allow(dead_code, non_upper_case_globals)] pub const NEED_SYSTEM_PALETTE_ARB: types::GLenum = 0x2005;
  305|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_ACCELERATION_ARB: types::GLenum = 0x2025;
  306|       |#[allow(dead_code, non_upper_case_globals)] pub const NO_RESET_NOTIFICATION_ARB: types::GLenum = 0x8261;
  307|       |#[allow(dead_code, non_upper_case_globals)] pub const NUMBER_OVERLAYS_ARB: types::GLenum = 0x2008;
  308|       |#[allow(dead_code, non_upper_case_globals)] pub const NUMBER_PIXEL_FORMATS_ARB: types::GLenum = 0x2000;
  309|       |#[allow(dead_code, non_upper_case_globals)] pub const NUMBER_UNDERLAYS_ARB: types::GLenum = 0x2009;
  310|       |#[allow(dead_code, non_upper_case_globals)] pub const PIXEL_TYPE_ARB: types::GLenum = 0x2013;
  311|       |#[allow(dead_code, non_upper_case_globals)] pub const RED_BITS_ARB: types::GLenum = 0x2015;
  312|       |#[allow(dead_code, non_upper_case_globals)] pub const RED_SHIFT_ARB: types::GLenum = 0x2016;
  313|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLES_ARB: types::GLenum = 0x2042;
  314|       |#[allow(dead_code, non_upper_case_globals)] pub const SAMPLE_BUFFERS_ARB: types::GLenum = 0x2041;
  315|       |#[allow(dead_code, non_upper_case_globals)] pub const SHARE_ACCUM_ARB: types::GLenum = 0x200E;
  316|       |#[allow(dead_code, non_upper_case_globals)] pub const SHARE_DEPTH_ARB: types::GLenum = 0x200C;
  317|       |#[allow(dead_code, non_upper_case_globals)] pub const SHARE_STENCIL_ARB: types::GLenum = 0x200D;
  318|       |#[allow(dead_code, non_upper_case_globals)] pub const STENCIL_BITS_ARB: types::GLenum = 0x2023;
  319|       |#[allow(dead_code, non_upper_case_globals)] pub const STEREO_ARB: types::GLenum = 0x2012;
  320|       |#[allow(dead_code, non_upper_case_globals)] pub const SUPPORT_GDI_ARB: types::GLenum = 0x200F;
  321|       |#[allow(dead_code, non_upper_case_globals)] pub const SUPPORT_OPENGL_ARB: types::GLenum = 0x2010;
  322|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_COPY_ARB: types::GLenum = 0x2029;
  323|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_EXCHANGE_ARB: types::GLenum = 0x2028;
  324|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_LAYER_BUFFERS_ARB: types::GLenum = 0x2006;
  325|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_MAIN_PLANE: types::GLenum = 0x00000001;
  326|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_METHOD_ARB: types::GLenum = 0x2007;
  327|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY1: types::GLenum = 0x00000002;
  328|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY10: types::GLenum = 0x00000400;
  329|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY11: types::GLenum = 0x00000800;
  330|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY12: types::GLenum = 0x00001000;
  331|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY13: types::GLenum = 0x00002000;
  332|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY14: types::GLenum = 0x00004000;
  333|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY15: types::GLenum = 0x00008000;
  334|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY2: types::GLenum = 0x00000004;
  335|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY3: types::GLenum = 0x00000008;
  336|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY4: types::GLenum = 0x00000010;
  337|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY5: types::GLenum = 0x00000020;
  338|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY6: types::GLenum = 0x00000040;
  339|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY7: types::GLenum = 0x00000080;
  340|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY8: types::GLenum = 0x00000100;
  341|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_OVERLAY9: types::GLenum = 0x00000200;
  342|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDEFINED_ARB: types::GLenum = 0x202A;
  343|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY1: types::GLenum = 0x00010000;
  344|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY10: types::GLenum = 0x02000000;
  345|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY11: types::GLenum = 0x04000000;
  346|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY12: types::GLenum = 0x08000000;
  347|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY13: types::GLenum = 0x10000000;
  348|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY14: types::GLenum = 0x20000000;
  349|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY15: types::GLenum = 0x40000000;
  350|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY2: types::GLenum = 0x00020000;
  351|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY3: types::GLenum = 0x00040000;
  352|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY4: types::GLenum = 0x00080000;
  353|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY5: types::GLenum = 0x00100000;
  354|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY6: types::GLenum = 0x00200000;
  355|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY7: types::GLenum = 0x00400000;
  356|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY8: types::GLenum = 0x00800000;
  357|       |#[allow(dead_code, non_upper_case_globals)] pub const SWAP_UNDERLAY9: types::GLenum = 0x01000000;
  358|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_ALPHA_VALUE_ARB: types::GLenum = 0x203A;
  359|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_ARB: types::GLenum = 0x200A;
  360|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_BLUE_VALUE_ARB: types::GLenum = 0x2039;
  361|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_GREEN_VALUE_ARB: types::GLenum = 0x2038;
  362|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_INDEX_VALUE_ARB: types::GLenum = 0x203B;
  363|       |#[allow(dead_code, non_upper_case_globals)] pub const TRANSPARENT_RED_VALUE_ARB: types::GLenum = 0x2037;
  364|       |#[allow(dead_code, non_upper_case_globals)] pub const TYPE_COLORINDEX_ARB: types::GLenum = 0x202C;
  365|       |#[allow(dead_code, non_upper_case_globals)] pub const TYPE_RGBA_ARB: types::GLenum = 0x202B;
  366|       |#[allow(dead_code, non_upper_case_globals)] pub const TYPE_RGBA_FLOAT_ARB: types::GLenum = 0x21A0;
  367|       |
  368|       |        #[allow(dead_code, missing_copy_implementations)]
  369|       |        #[derive(Clone)]
  370|       |        pub struct FnPtr {
  371|       |            /// The function pointer that will be used when calling the function.
  372|       |            f: *const __gl_imports::raw::c_void,
  373|       |            /// True if the pointer points to a real function, false if points to a `panic!` fn.
  374|       |            is_loaded: bool,
  375|       |        }
  376|       |
  377|       |        impl FnPtr {
  378|       |            /// Creates a `FnPtr` from a load attempt.
  379|      0|            fn new(ptr: *const __gl_imports::raw::c_void) -> FnPtr {
  380|      0|                if ptr.is_null() {
  ------------------
  |  Branch (380:20): [True: 0, False: 0]
  ------------------
  381|      0|                    FnPtr {
  382|      0|                        f: missing_fn_panic as *const __gl_imports::raw::c_void,
  383|      0|                        is_loaded: false
  384|      0|                    }
  385|       |                } else {
  386|      0|                    FnPtr { f: ptr, is_loaded: true }
  387|       |                }
  388|      0|            }
  389|       |
  390|       |            /// Returns `true` if the function has been successfully loaded.
  391|       |            ///
  392|       |            /// If it returns `false`, calling the corresponding function will fail.
  393|       |            #[inline]
  394|       |            #[allow(dead_code)]
  395|      0|            pub fn is_loaded(&self) -> bool {
  396|      0|                self.is_loaded
  397|      0|            }
  398|       |        }
  399|       |    
  400|       |#[inline(never)]
  401|      0|        fn missing_fn_panic() -> ! {
  402|      0|            panic!("wgl function was not loaded")
  403|       |        }
  404|       |
  405|       |        #[allow(non_camel_case_types, non_snake_case, dead_code)]
  406|       |        #[derive(Clone)]
  407|       |        pub struct Wgl {
  408|       |pub ChoosePixelFormatARB: FnPtr,
  409|       |pub CopyContext: FnPtr,
  410|       |pub CreateContext: FnPtr,
  411|       |pub CreateContextAttribsARB: FnPtr,
  412|       |pub CreateLayerContext: FnPtr,
  413|       |pub DeleteContext: FnPtr,
  414|       |pub DescribeLayerPlane: FnPtr,
  415|       |pub GetCurrentContext: FnPtr,
  416|       |pub GetCurrentDC: FnPtr,
  417|       |pub GetExtensionsStringARB: FnPtr,
  418|       |pub GetExtensionsStringEXT: FnPtr,
  419|       |pub GetLayerPaletteEntries: FnPtr,
  420|       |pub GetPixelFormatAttribfvARB: FnPtr,
  421|       |pub GetPixelFormatAttribivARB: FnPtr,
  422|       |pub GetProcAddress: FnPtr,
  423|       |pub GetSwapIntervalEXT: FnPtr,
  424|       |pub MakeCurrent: FnPtr,
  425|       |pub RealizeLayerPalette: FnPtr,
  426|       |pub SetLayerPaletteEntries: FnPtr,
  427|       |pub ShareLists: FnPtr,
  428|       |pub SwapIntervalEXT: FnPtr,
  429|       |pub SwapLayerBuffers: FnPtr,
  430|       |pub UseFontBitmaps: FnPtr,
  431|       |pub UseFontBitmapsA: FnPtr,
  432|       |pub UseFontBitmapsW: FnPtr,
  433|       |pub UseFontOutlines: FnPtr,
  434|       |pub UseFontOutlinesA: FnPtr,
  435|       |pub UseFontOutlinesW: FnPtr,
  436|       |_priv: ()
  437|       |}
  438|       |impl Wgl {
  439|       |            /// Load each OpenGL symbol using a custom load function. This allows for the
  440|       |            /// use of functions like `glfwGetProcAddress` or `SDL_GL_GetProcAddress`.
  441|       |            ///
  442|       |            /// ~~~ignore
  443|       |            /// let gl = Gl::load_with(|s| glfw.get_proc_address(s));
  444|       |            /// ~~~
  445|       |            #[allow(dead_code, unused_variables)]
  446|      0|            pub fn load_with<F>(mut loadfn: F) -> Wgl where F: FnMut(&'static str) -> *const __gl_imports::raw::c_void {
  447|       |                #[inline(never)]
  448|      0|                fn do_metaloadfn(loadfn: &mut dyn FnMut(&'static str) -> *const __gl_imports::raw::c_void,
  449|      0|                                 symbol: &'static str,
  450|      0|                                 symbols: &[&'static str])
  451|      0|                                 -> *const __gl_imports::raw::c_void {
  452|      0|                    let mut ptr = loadfn(symbol);
  453|      0|                    if ptr.is_null() {
  ------------------
  |  Branch (453:24): [True: 0, False: 0]
  ------------------
  454|      0|                        for &sym in symbols {
  455|      0|                            ptr = loadfn(sym);
  456|      0|                            if !ptr.is_null() { break; }
  ------------------
  |  Branch (456:32): [True: 0, False: 0]
  ------------------
  457|       |                        }
  458|      0|                    }
  459|      0|                    ptr
  460|      0|                }
  461|      0|                let mut metaloadfn = |symbol: &'static str, symbols: &[&'static str]| {
  462|      0|                    do_metaloadfn(&mut loadfn, symbol, symbols)
  463|      0|                };
  464|      0|                Wgl {
  465|      0|ChoosePixelFormatARB: FnPtr::new(metaloadfn("wglChoosePixelFormatARB", &[])),
  466|      0|CopyContext: FnPtr::new(metaloadfn("wglCopyContext", &[])),
  467|      0|CreateContext: FnPtr::new(metaloadfn("wglCreateContext", &[])),
  468|      0|CreateContextAttribsARB: FnPtr::new(metaloadfn("wglCreateContextAttribsARB", &[])),
  469|      0|CreateLayerContext: FnPtr::new(metaloadfn("wglCreateLayerContext", &[])),
  470|      0|DeleteContext: FnPtr::new(metaloadfn("wglDeleteContext", &[])),
  471|      0|DescribeLayerPlane: FnPtr::new(metaloadfn("wglDescribeLayerPlane", &[])),
  472|      0|GetCurrentContext: FnPtr::new(metaloadfn("wglGetCurrentContext", &[])),
  473|      0|GetCurrentDC: FnPtr::new(metaloadfn("wglGetCurrentDC", &[])),
  474|      0|GetExtensionsStringARB: FnPtr::new(metaloadfn("wglGetExtensionsStringARB", &[])),
  475|      0|GetExtensionsStringEXT: FnPtr::new(metaloadfn("wglGetExtensionsStringEXT", &[])),
  476|      0|GetLayerPaletteEntries: FnPtr::new(metaloadfn("wglGetLayerPaletteEntries", &[])),
  477|      0|GetPixelFormatAttribfvARB: FnPtr::new(metaloadfn("wglGetPixelFormatAttribfvARB", &[])),
  478|      0|GetPixelFormatAttribivARB: FnPtr::new(metaloadfn("wglGetPixelFormatAttribivARB", &[])),
  479|      0|GetProcAddress: FnPtr::new(metaloadfn("wglGetProcAddress", &[])),
  480|      0|GetSwapIntervalEXT: FnPtr::new(metaloadfn("wglGetSwapIntervalEXT", &[])),
  481|      0|MakeCurrent: FnPtr::new(metaloadfn("wglMakeCurrent", &[])),
  482|      0|RealizeLayerPalette: FnPtr::new(metaloadfn("wglRealizeLayerPalette", &[])),
  483|      0|SetLayerPaletteEntries: FnPtr::new(metaloadfn("wglSetLayerPaletteEntries", &[])),
  484|      0|ShareLists: FnPtr::new(metaloadfn("wglShareLists", &[])),
  485|      0|SwapIntervalEXT: FnPtr::new(metaloadfn("wglSwapIntervalEXT", &[])),
  486|      0|SwapLayerBuffers: FnPtr::new(metaloadfn("wglSwapLayerBuffers", &[])),
  487|      0|UseFontBitmaps: FnPtr::new(metaloadfn("wglUseFontBitmaps", &[])),
  488|      0|UseFontBitmapsA: FnPtr::new(metaloadfn("wglUseFontBitmapsA", &[])),
  489|      0|UseFontBitmapsW: FnPtr::new(metaloadfn("wglUseFontBitmapsW", &[])),
  490|      0|UseFontOutlines: FnPtr::new(metaloadfn("wglUseFontOutlines", &[])),
  491|      0|UseFontOutlinesA: FnPtr::new(metaloadfn("wglUseFontOutlinesA", &[])),
  492|      0|UseFontOutlinesW: FnPtr::new(metaloadfn("wglUseFontOutlinesW", &[])),
  493|      0|_priv: ()
  494|      0|}
  495|      0|        }
  496|       |#[allow(non_snake_case, unused_variables, dead_code)]
  497|      0|            #[inline] pub unsafe fn ChoosePixelFormatARB(&self, hdc: types::HDC, piAttribIList: *const __gl_imports::raw::c_int, pfAttribFList: *const types::FLOAT, nMaxFormats: types::UINT, piFormats: *mut __gl_imports::raw::c_int, nNumFormats: *mut types::UINT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, *const __gl_imports::raw::c_int, *const types::FLOAT, types::UINT, *mut __gl_imports::raw::c_int, *mut types::UINT) -> types::BOOL>(self.ChoosePixelFormatARB.f)(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats) }
  498|       |#[allow(non_snake_case, unused_variables, dead_code)]
  499|      0|            #[inline] pub unsafe fn CopyContext(&self, hglrcSrc: types::HGLRC, hglrcDst: types::HGLRC, mask: types::UINT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HGLRC, types::HGLRC, types::UINT) -> types::BOOL>(self.CopyContext.f)(hglrcSrc, hglrcDst, mask) }
  500|       |#[allow(non_snake_case, unused_variables, dead_code)]
  501|      0|            #[inline] pub unsafe fn CreateContext(&self, hDc: types::HDC) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC) -> types::HGLRC>(self.CreateContext.f)(hDc) }
  502|       |#[allow(non_snake_case, unused_variables, dead_code)]
  503|      0|            #[inline] pub unsafe fn CreateContextAttribsARB(&self, hDC: types::HDC, hShareContext: types::HGLRC, attribList: *const __gl_imports::raw::c_int) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::HGLRC, *const __gl_imports::raw::c_int) -> types::HGLRC>(self.CreateContextAttribsARB.f)(hDC, hShareContext, attribList) }
  504|       |#[allow(non_snake_case, unused_variables, dead_code)]
  505|      0|            #[inline] pub unsafe fn CreateLayerContext(&self, hDc: types::HDC, level: __gl_imports::raw::c_int) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int) -> types::HGLRC>(self.CreateLayerContext.f)(hDc, level) }
  506|       |#[allow(non_snake_case, unused_variables, dead_code)]
  507|      0|            #[inline] pub unsafe fn DeleteContext(&self, oldContext: types::HGLRC) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HGLRC) -> types::BOOL>(self.DeleteContext.f)(oldContext) }
  508|       |#[allow(non_snake_case, unused_variables, dead_code)]
  509|      0|            #[inline] pub unsafe fn DescribeLayerPlane(&self, hDc: types::HDC, pixelFormat: __gl_imports::raw::c_int, layerPlane: __gl_imports::raw::c_int, nBytes: types::UINT, plpd: *const types::LAYERPLANEDESCRIPTOR) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, types::UINT, *const types::LAYERPLANEDESCRIPTOR) -> types::BOOL>(self.DescribeLayerPlane.f)(hDc, pixelFormat, layerPlane, nBytes, plpd) }
  510|       |#[allow(non_snake_case, unused_variables, dead_code)]
  511|      0|            #[inline] pub unsafe fn GetCurrentContext(&self, ) -> types::HGLRC { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::HGLRC>(self.GetCurrentContext.f)() }
  512|       |#[allow(non_snake_case, unused_variables, dead_code)]
  513|      0|            #[inline] pub unsafe fn GetCurrentDC(&self, ) -> types::HDC { __gl_imports::mem::transmute::<_, extern "system" fn() -> types::HDC>(self.GetCurrentDC.f)() }
  514|       |#[allow(non_snake_case, unused_variables, dead_code)]
  515|      0|            #[inline] pub unsafe fn GetExtensionsStringARB(&self, hdc: types::HDC) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC) -> *const __gl_imports::raw::c_char>(self.GetExtensionsStringARB.f)(hdc) }
  516|       |#[allow(non_snake_case, unused_variables, dead_code)]
  517|      0|            #[inline] pub unsafe fn GetExtensionsStringEXT(&self, ) -> *const __gl_imports::raw::c_char { __gl_imports::mem::transmute::<_, extern "system" fn() -> *const __gl_imports::raw::c_char>(self.GetExtensionsStringEXT.f)() }
  518|       |#[allow(non_snake_case, unused_variables, dead_code)]
  519|      0|            #[inline] pub unsafe fn GetLayerPaletteEntries(&self, hdc: types::HDC, iLayerPlane: __gl_imports::raw::c_int, iStart: __gl_imports::raw::c_int, cEntries: __gl_imports::raw::c_int, pcr: *const types::COLORREF) -> __gl_imports::raw::c_int { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, __gl_imports::raw::c_int, *const types::COLORREF) -> __gl_imports::raw::c_int>(self.GetLayerPaletteEntries.f)(hdc, iLayerPlane, iStart, cEntries, pcr) }
  520|       |#[allow(non_snake_case, unused_variables, dead_code)]
  521|      0|            #[inline] pub unsafe fn GetPixelFormatAttribfvARB(&self, hdc: types::HDC, iPixelFormat: __gl_imports::raw::c_int, iLayerPlane: __gl_imports::raw::c_int, nAttributes: types::UINT, piAttributes: *const __gl_imports::raw::c_int, pfValues: *mut types::FLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, types::UINT, *const __gl_imports::raw::c_int, *mut types::FLOAT) -> types::BOOL>(self.GetPixelFormatAttribfvARB.f)(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues) }
  522|       |#[allow(non_snake_case, unused_variables, dead_code)]
  523|      0|            #[inline] pub unsafe fn GetPixelFormatAttribivARB(&self, hdc: types::HDC, iPixelFormat: __gl_imports::raw::c_int, iLayerPlane: __gl_imports::raw::c_int, nAttributes: types::UINT, piAttributes: *const __gl_imports::raw::c_int, piValues: *mut __gl_imports::raw::c_int) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, types::UINT, *const __gl_imports::raw::c_int, *mut __gl_imports::raw::c_int) -> types::BOOL>(self.GetPixelFormatAttribivARB.f)(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues) }
  524|       |#[allow(non_snake_case, unused_variables, dead_code)]
  525|      0|            #[inline] pub unsafe fn GetProcAddress(&self, lpszProc: types::LPCSTR) -> types::PROC { __gl_imports::mem::transmute::<_, extern "system" fn(types::LPCSTR) -> types::PROC>(self.GetProcAddress.f)(lpszProc) }
  526|       |#[allow(non_snake_case, unused_variables, dead_code)]
  527|      0|            #[inline] pub unsafe fn GetSwapIntervalEXT(&self, ) -> __gl_imports::raw::c_int { __gl_imports::mem::transmute::<_, extern "system" fn() -> __gl_imports::raw::c_int>(self.GetSwapIntervalEXT.f)() }
  528|       |#[allow(non_snake_case, unused_variables, dead_code)]
  529|      0|            #[inline] pub unsafe fn MakeCurrent(&self, hDc: types::HDC, newContext: types::HGLRC) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::HGLRC) -> types::BOOL>(self.MakeCurrent.f)(hDc, newContext) }
  530|       |#[allow(non_snake_case, unused_variables, dead_code)]
  531|      0|            #[inline] pub unsafe fn RealizeLayerPalette(&self, hdc: types::HDC, iLayerPlane: __gl_imports::raw::c_int, bRealize: types::BOOL) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, types::BOOL) -> types::BOOL>(self.RealizeLayerPalette.f)(hdc, iLayerPlane, bRealize) }
  532|       |#[allow(non_snake_case, unused_variables, dead_code)]
  533|      0|            #[inline] pub unsafe fn SetLayerPaletteEntries(&self, hdc: types::HDC, iLayerPlane: __gl_imports::raw::c_int, iStart: __gl_imports::raw::c_int, cEntries: __gl_imports::raw::c_int, pcr: *const types::COLORREF) -> __gl_imports::raw::c_int { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, __gl_imports::raw::c_int, __gl_imports::raw::c_int, __gl_imports::raw::c_int, *const types::COLORREF) -> __gl_imports::raw::c_int>(self.SetLayerPaletteEntries.f)(hdc, iLayerPlane, iStart, cEntries, pcr) }
  534|       |#[allow(non_snake_case, unused_variables, dead_code)]
  535|      0|            #[inline] pub unsafe fn ShareLists(&self, hrcSrvShare: types::HGLRC, hrcSrvSource: types::HGLRC) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HGLRC, types::HGLRC) -> types::BOOL>(self.ShareLists.f)(hrcSrvShare, hrcSrvSource) }
  536|       |#[allow(non_snake_case, unused_variables, dead_code)]
  537|      0|            #[inline] pub unsafe fn SwapIntervalEXT(&self, interval: __gl_imports::raw::c_int) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(__gl_imports::raw::c_int) -> types::BOOL>(self.SwapIntervalEXT.f)(interval) }
  538|       |#[allow(non_snake_case, unused_variables, dead_code)]
  539|      0|            #[inline] pub unsafe fn SwapLayerBuffers(&self, hdc: types::HDC, fuFlags: types::UINT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::UINT) -> types::BOOL>(self.SwapLayerBuffers.f)(hdc, fuFlags) }
  540|       |#[allow(non_snake_case, unused_variables, dead_code)]
  541|      0|            #[inline] pub unsafe fn UseFontBitmaps(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD) -> types::BOOL>(self.UseFontBitmaps.f)(hDC, first, count, listBase) }
  542|       |#[allow(non_snake_case, unused_variables, dead_code)]
  543|      0|            #[inline] pub unsafe fn UseFontBitmapsA(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD) -> types::BOOL>(self.UseFontBitmapsA.f)(hDC, first, count, listBase) }
  544|       |#[allow(non_snake_case, unused_variables, dead_code)]
  545|      0|            #[inline] pub unsafe fn UseFontBitmapsW(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD) -> types::BOOL>(self.UseFontBitmapsW.f)(hDC, first, count, listBase) }
  546|       |#[allow(non_snake_case, unused_variables, dead_code)]
  547|      0|            #[inline] pub unsafe fn UseFontOutlines(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD, deviation: types::FLOAT, extrusion: types::FLOAT, format: __gl_imports::raw::c_int, lpgmf: types::LPGLYPHMETRICSFLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD, types::FLOAT, types::FLOAT, __gl_imports::raw::c_int, types::LPGLYPHMETRICSFLOAT) -> types::BOOL>(self.UseFontOutlines.f)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf) }
  548|       |#[allow(non_snake_case, unused_variables, dead_code)]
  549|      0|            #[inline] pub unsafe fn UseFontOutlinesA(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD, deviation: types::FLOAT, extrusion: types::FLOAT, format: __gl_imports::raw::c_int, lpgmf: types::LPGLYPHMETRICSFLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD, types::FLOAT, types::FLOAT, __gl_imports::raw::c_int, types::LPGLYPHMETRICSFLOAT) -> types::BOOL>(self.UseFontOutlinesA.f)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf) }
  550|       |#[allow(non_snake_case, unused_variables, dead_code)]
  551|      0|            #[inline] pub unsafe fn UseFontOutlinesW(&self, hDC: types::HDC, first: types::DWORD, count: types::DWORD, listBase: types::DWORD, deviation: types::FLOAT, extrusion: types::FLOAT, format: __gl_imports::raw::c_int, lpgmf: types::LPGLYPHMETRICSFLOAT) -> types::BOOL { __gl_imports::mem::transmute::<_, extern "system" fn(types::HDC, types::DWORD, types::DWORD, types::DWORD, types::FLOAT, types::FLOAT, __gl_imports::raw::c_int, types::LPGLYPHMETRICSFLOAT) -> types::BOOL>(self.UseFontOutlinesW.f)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf) }
  552|       |}
  553|       |
  554|       |        unsafe impl __gl_imports::Send for Wgl {}
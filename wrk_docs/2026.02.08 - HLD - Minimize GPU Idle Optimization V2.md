# HLD: Minimize GPU Idle Optimization (V2)

**Date:** 2026-02-08
**Status:** Draft
**Author:** Claude (pair with Arthur)
**Revision:** V2 — addresses critical flaws in V1

## Changes from V1

| # | V1 Issue | V2 Fix |
|---|----------|--------|
| 1 | Idle timeout in `update_impl()` never fires when minimized (eframe skips repaints) | Removed idle timeout; use direct minimize detection instead |
| 2 | Idle timeout releases textures on visible-but-idle windows → flash on return | Removed; only release when minimized (Arthur: "no flashing on visible windows") |
| 3 | `request_repaint_after()` discarded when minimized — deferred work can't execute | No longer relies on deferred work while minimized |
| 4 | Configurable timeout via env variable | Removed per Arthur's preference ("avoid env variable") |
| 5 | 60s timeout | Moot — no timeout mechanism |

## Problem Statement

When mdmdview is minimized with a complex document loaded (e.g., `test_stress.md`), Windows
Task Manager reports **2.6% GPU utilization** despite zero CPU usage and zero frame rendering.
Arthur's other egui apps show **0.1% GPU** when minimized.

## Root Cause

The GPU overhead comes from OpenGL driver housekeeping on live texture objects plus GPU P-state
elevation. With `test_stress.md` fully scrolled, mdmdview holds ~30 GPU textures totaling ~37.5 MB:

| Category              | Count  | VRAM       | Notes                          |
|-----------------------|--------|------------|--------------------------------|
| Mermaid diagrams      | 8      | 34.4 MB    | 4.3 MB each (1200x900 RGBA8)  |
| Emoji textures        | ~20    | 320 KB     | 16 KB each (64x64 RGBA8)      |
| Font atlas            | 1      | 2.5 MB     | egui-managed, cannot release   |
| egui UI chrome        | 1      | 150 KB     | egui-managed, cannot release   |
| **Total**             | **~30**| **~37.5 MB** |                             |

A simple egui app has ~3 textures totaling ~2 MB, explaining the 0.1% baseline.

## Proposed Solution

Release application-managed GPU textures when the window is minimized. On restore, textures
rebuild lazily through the existing rendering pipeline.

### Design Principle: Minimize Detection Only

V1 proposed an idle timeout as the primary mechanism, with minimize detection as backup. This was
fundamentally flawed because **eframe 0.27 discards all repaint requests while minimized** — the
idle timeout code in `update_impl()` never executes.

V2 inverts the approach: **minimize detection is the sole trigger**. This works because:

1. The minimize event itself triggers at least one `RedrawRequested` (platform event)
2. eframe processes this event and calls `update()` with `viewport().minimized == Some(true)`
3. We detect the transition and release textures immediately
4. After this frame, eframe discards all repaint requests (the minimize check in `run.rs:185-206`)
5. On restore, the platform triggers another `RedrawRequested`, and `update()` runs again

We explicitly do **not** release textures on visible-but-idle windows, per Arthur's requirement
of no visual flashing on visible windows.

### What to Release

| Cache                  | Owner                | Release?  | Rebuild Cost                  |
|------------------------|----------------------|-----------|-------------------------------|
| `mermaid_textures`     | `MermaidRenderer`    | **Yes**   | Fast: rasterize from SVG cache (~10-50ms/diagram) |
| `emoji_textures`       | `MarkdownRenderer`   | **Yes**   | Fast: decode embedded PNGs (~1ms/emoji) |
| `image_textures`       | `MarkdownRenderer`   | **Yes**   | Medium: re-decode from disk/cache |
| `mermaid_svg_cache`    | `MermaidRenderer`    | No        | Retain — needed for fast texture rebuild |
| `mermaid_errors`       | `MermaidRenderer`    | No        | Retain — prevents retry storms |
| Font atlas             | egui                 | No        | Framework-managed, no API to release |

## Detailed Design

### 1. State Tracking in `MarkdownViewerApp`

Add a single field to detect minimize/restore **transitions**:

```rust
// In MarkdownViewerApp struct (app.rs)
/// Tracks whether GPU textures have been released (e.g., due to minimize).
gpu_textures_released: bool,
```

Initialize to `false` in the constructor. No `was_minimized` field needed — we track the
release state directly, which is more robust.

### 2. Minimize/Restore Detection in `update_impl()`

At the top of `update_impl()`, after the startup frame logic, detect state transitions:

```rust
// Detect minimize → release GPU textures
let is_minimized = ctx.input(|i| {
    i.viewport().minimized.unwrap_or(false)
});

if is_minimized && !self.gpu_textures_released && self.screenshot.is_none() {
    // Window just became minimized — release textures to reduce GPU idle usage
    self.renderer.release_gpu_textures();
    self.gpu_textures_released = true;
}

if !is_minimized && self.gpu_textures_released {
    // Window restored — textures rebuild lazily on next render
    self.gpu_textures_released = false;
    ctx.request_repaint(); // Ensure a full re-render happens
}
```

**Why `gpu_textures_released` instead of `was_minimized`?**

Using `gpu_textures_released` is more robust because it tracks the actual state we care about
(whether textures need rebuilding), not a proxy for it. If textures are released for any reason,
the restore path always fires. If the minimize transition frame is missed (theoretically
shouldn't happen), the flag stays `false` and no harm is done — we just don't release textures,
which is the conservative behavior.

### 3. `TextureCache::clear()` on `MermaidRenderer`

The existing `TextureCache` struct (mermaid_renderer.rs, lines 470-556) lacks a `clear()` method.
Add one:

```rust
// In TextureCache (mermaid_renderer.rs)
fn clear(&mut self) {
    self.entries.clear();
    self.order.clear();
    self.current_bytes = 0;
}
```

### 4. `ImageCache::clear()` on `MarkdownRenderer`

The existing `ImageCache` struct (markdown_renderer.rs, lines 448-527) lacks a `clear()` method.
Add one:

```rust
// In ImageCache (markdown_renderer.rs)
fn clear(&mut self) {
    self.entries.clear();
    self.order.clear();
    self.total_bytes = 0;
}
```

### 5. `MermaidRenderer::release_gpu_textures()`

Add a public method to clear the texture cache only (preserving SVG cache):

```rust
// In MermaidRenderer (mermaid_renderer.rs)

/// Release GPU textures to reduce idle GPU usage.
/// SVG cache is retained so diagrams can be quickly re-rasterized on restore.
pub(crate) fn release_gpu_textures(&self) {
    #[cfg(feature = "mermaid-quickjs")]
    {
        self.mermaid_textures.borrow_mut().clear();
        // Note: mermaid_svg_cache intentionally retained
        // Note: mermaid_errors intentionally retained
        // Note: mermaid_texture_errors intentionally retained
    }
}
```

### 6. `MarkdownRenderer::release_gpu_textures()`

Add a public method that releases all application-managed textures:

```rust
// In MarkdownRenderer (markdown_renderer.rs)

/// Release GPU textures to reduce idle GPU usage (e.g., when minimized).
/// Textures rebuild lazily on next render. SVG/error caches are retained
/// so rebuilds are fast.
pub fn release_gpu_textures(&self) {
    self.emoji_textures.borrow_mut().clear();
    self.image_textures.borrow_mut().clear();
    self.mermaid.release_gpu_textures();
}
```

### 7. Texture Rebuild on Restore

**No special rebuild logic needed.** The existing lazy-loading pipeline handles everything:

- **Mermaid diagrams**: `render_block()` checks `mermaid_textures` cache → miss → checks
  `mermaid_svg_cache` (still populated) → rasterizes SVG → uploads texture. Cost: ~10-50ms/diagram.

- **Emoji textures**: emoji rendering checks `emoji_textures` cache → miss → decodes
  embedded PNG → uploads texture. Cost: ~1ms/emoji.

- **Image textures**: image rendering checks `image_textures` cache → miss → enqueues async
  load → uploads on completion. Cost: varies, async so non-blocking.

The only user-visible effect is a brief placeholder flash on the first frame after restore.
With 8 mermaid diagrams, this settles within 3-5 frames (~100-200ms).

## Edge Cases

### Platform Doesn't Report Minimize State

If `viewport().minimized` returns `None` (unsupported platform), `unwrap_or(false)` means
we never release textures. This is the conservative fallback — no change in behavior from today.

### Minimize During Mermaid Rendering

If the user minimizes while mermaid diagrams are still rendering:
- Worker threads continue (CPU-only, not GPU)
- Results queue in the bounded channel
- `release_gpu_textures()` fires on the minimize transition frame
- On restore, `poll_mermaid_results()` drains the queue and creates textures

No race condition: the channel is drained before texture lookup, so any textures created from
poll results are immediately available.

### Minimize During Screenshot Capture

`self.screenshot.is_some()` guard prevents releasing textures during screenshot capture.
Screenshots need all textures present for correct rendering.

### Rapid Minimize/Restore Cycling

If the user rapidly Alt-Tabs:
- Minimize frame: textures released (~instant, just drops TextureHandle references)
- Restore frame: textures rebuild lazily (10-50ms per mermaid diagram)
- Worst case: 200-500ms of rebuild per cycle for test_stress.md
- In practice, rapid cycling is rare and the brief rebuild is acceptable

### File Switch While Minimized

If the user opens a new file via CLI argument or file association while minimized:
- The new file load triggers a full re-parse, which clears document-specific caches anyway
- `gpu_textures_released` stays `true` until the window is restored
- On restore, the new document renders fresh — no stale texture issue

### No Document Loaded

If no document is loaded, there are no application textures to release.
The `clear()` methods are safe to call on empty caches (no-ops).

## Expected Impact

### GPU Usage When Minimized

| Scenario                          | Before  | After   |
|-----------------------------------|---------|---------|
| test_stress.md, minimized         | 2.6%    | ~0.1%   |
| Simple document, minimized        | ~0.5%   | ~0.1%   |
| No document, minimized            | ~0.1%   | ~0.1%   |

### Restore Latency

| Content Type        | Rebuild Time  | Frames to Settle |
|---------------------|---------------|------------------|
| Mermaid diagrams    | 10-50ms each  | 2-5 frames       |
| Emoji               | ~1ms each     | 1 frame          |
| Images (from disk)  | 5-50ms each   | 2-3 frames       |
| Total (test_stress) | ~200-500ms    | 3-5 frames       |

### No Impact on Visible Windows

- No texture release on visible-but-idle windows
- No timeout mechanism — only minimize triggers release
- No visual flash during normal usage

## Implementation Order

1. Add `TextureCache::clear()` to mermaid_renderer.rs
2. Add `ImageCache::clear()` to markdown_renderer.rs
3. Add `MermaidRenderer::release_gpu_textures()`
4. Add `MarkdownRenderer::release_gpu_textures()`
5. Add `gpu_textures_released` field to `MarkdownViewerApp`
6. Add minimize/restore detection in `update_impl()`
7. Write unit tests for `clear()` methods
8. Write unit tests for `release_gpu_textures()` methods
9. Manual verification: load test_stress.md, minimize, check GPU%

## Testing Strategy

### Unit Tests

- `TextureCache::clear()` zeroes `current_bytes` and empties entries/order
- `ImageCache::clear()` zeroes `total_bytes` and empties entries/order
- `MermaidRenderer::release_gpu_textures()` clears texture cache but retains SVG cache
- `MarkdownRenderer::release_gpu_textures()` clears emoji + image + mermaid textures

### Manual Verification

1. Build release: `cargo build --release`
2. Open `test_stress.md`, scroll to bottom (trigger all mermaid renders)
3. Wait 10 seconds for everything to settle
4. Note GPU% in Task Manager (expected: ~2.6%)
5. Minimize window
6. Wait 5 seconds
7. Check GPU% (expected: ~0.1%)
8. Restore window — verify diagrams re-render within ~500ms
9. Check GPU% returns to normal rendering level

## Alternatives Considered

### A. Idle Timeout (V1 Primary Mechanism)

Track time since last interaction; release after 30s. **Rejected** because:
- `update()` effectively stops being called when minimized (repaints discarded)
- The timeout check in `update_impl()` never fires
- `request_repaint_after()` is also discarded when minimized
- Would require OS-level timer (platform-specific) to work around this — excessive complexity

### B. Focus-Loss Timeout

Release textures 30s after window loses focus (but remains visible). **Rejected** because:
- Arthur: "no flashing on visible windows"
- Unfocused-but-visible windows still show content — flash on re-focus is undesirable
- Focus loss doesn't imply the user isn't looking at the window

### C. Switch to wgpu Backend

Would achieve near-zero idle GPU through modern API idle management. **Rejected** because:
- Major architectural change
- wgpu has its own issues (buffer GC starvation when minimized — egui #7434)
- Disproportionate effort for ~2.5% GPU reduction

### D. Deactivate OpenGL Context

Call `glutin::make_not_current()` when minimized. **Rejected** because:
- Not accessible through eframe's abstraction layer
- Would require rebuilding ALL state including framework textures
- Risk of GL errors

## References

- [GPUs in the Task Manager — DirectX Developer Blog](https://devblogs.microsoft.com/directx/gpus-in-the-task-manager/)
- [egui Issue #3982: Windows: High CPU Usage when minimized](https://github.com/emilk/egui/issues/3982)
- [egui Issue #3321: Graphical glitches after minimized](https://github.com/emilk/egui/issues/3321)
- [Khronos Forums: High GPU usage drawing nothing](https://community.khronos.org/t/high-gpu-usage-even-when-drawing-nothing-on-the-window-and-even-with-framerate-limiting/108031)

# High-Level Design: Table Column and Border Fixes (Revision 3)

**Date:** 2025.11.14
**Author:** Claude
**Status:** Draft - Revision 3
**Branch:** feat/table-column-fixes

**Revision History:**
- **Rev 1:** Initial design with incorrect root cause analysis
- **Rev 2:** Added Phase 0 debug plan, identified image measurement bug
- **Rev 3:** **CRITICAL CORRECTION** - Discovered existing work, corrected analysis, focused on actual remaining issues

---

## 0. Critical Discovery: Existing Work on Feature Branch

### 0.1 What Was Discovered

After deeper code analysis, **discovered that extensive work has already been completed** on branch `feat/table-column-fixes`:

**COMPLETED (per journal 2025.11.14):**
- ✅ Column stats collection (`compute_column_stats`)
- ✅ `TableColumnContext` and context-aware `derive_column_specs`
- ✅ DPI-aware column sizing with `px()` helper
- ✅ Content-based fallback remainder selection
- ✅ Per-table `TableMetrics` with width/height tracking
- ✅ Column width persistence plumbing
- ✅ Cell dividers **implemented but rolled back** due to scroll issues (19:30 ET entry)

**NOT COMPLETED:**
- ❌ Padding column Remainder bug **NOT FIXED** (still uses `Remainder` policy)
- ❌ Cell dividers **REMOVED** from code after scroll issues discovered
- ❌ Root cause of scroll issues **NOT DOCUMENTED**
- ❌ Column width bugs **NOT VERIFIED** as fixed by existing work

### 0.2 Critical Errors in Rev 1 & Rev 2

**REV 1 & 2 MAJOR ERRORS:**

1. **WRONG CODE PATH ANALYZED**
   - Rev 2 identified image measurement bug in `measure_inline_spans`
   - But this function is ONLY used in **legacy path** (lines 3241-3263)
   - Active path is TableBuilder (line 3225: `if self.table_wrap_overhaul_enabled`)
   - `table_wrap_overhaul_enabled` defaults to `true` (app.rs:298)
   - **Image measurement bug does NOT affect active code!**

2. **MISSED EXISTING WORK**
   - Did not check for feature branches or work-in-progress
   - Designed solutions for problems already partially solved
   - Did not review journals or existing HLD/Plan docs

3. **INCOMPLETE ANALYSIS**
   - Did not verify which rendering path is actually active
   - Did not check git status or uncommitted changes
   - Made assumptions without testing

**LESSON:** Always check current branch, uncommitted work, and journals before designing!

---

## 1. Corrected Problem Statement

### 1.1 Actual Current State (feat/table-column-fixes branch)

**Modified Files (uncommitted):**
```
M src/markdown_renderer.rs
M src/table_support/column_spec.rs
M src/table_support/metrics.rs
M src/table_support/mod.rs
```

**Column Sizing:** Substantial improvements implemented:
- Context-aware column classification
- DPI-aware widths using `px()` helper
- Content stats (max_graphemes, longest_word, has_image/link flags)
- Smart fallback remainder selection

**Cell Dividers:** Were implemented, then **rolled back**:
- Journal 19:05 ET: "Persisted resizable column widths automatically"
- Journal 19:30 ET: "Rolled back experimental divider rendering + env flag after discovering scroll issues; restored original drawing while retaining column sizing/persistence plumbing"
- **Scroll issues NOT documented** - need to investigate

### 1.2 Remaining Issues

**ISSUE #1: Padding Column Bug (CONFIRMED UNFIXED)**

Location: `src/markdown_renderer.rs:3332-3339`

Current code (from diff analysis):
```rust
let row_max = rows.iter().map(|r| r.len()).max().unwrap_or(0);
let target_cols = column_specs.len().max(row_max).max(1);
while column_specs.len() < target_cols {
    column_specs.push(ColumnSpec::new(
        format!("Column {}", column_specs.len() + 1),
        ColumnPolicy::Remainder { clip: false },  // ❌ BUG STILL EXISTS
    ));
}
```

**Impact:** For ragged tables, creates multiple Remainder columns
**Severity:** HIGH for ragged tables, LOW for equal-column tables (like threat-model)
**Status:** **NOT FIXED** in current uncommitted work

**ISSUE #2: Cell Dividers Rolled Back**

**What Happened:**
- Dividers were implemented
- Caused "scroll issues" (nature undocumented)
- Completely removed from code

**Missing Information:**
- What were the specific scroll issues?
- Was it a TableBuilder bug or implementation bug?
- What approach was used?
- Can it be fixed or does it need different approach?

**Status:** Dividers **DO NOT EXIST** in current code

**ISSUE #3: Column Width Bug - Verification Needed**

**Reported:** Examples column too narrow, Description too wide

**Question:** Does the existing column sizing work fix this?

**Evidence Needed:**
- Visual comparison before/after
- Actual column spec assignments for threat-model table
- Verification that Examples gets Remainder policy
- Confirmation that widths are correct

**Status:** **UNVERIFIED** - needs testing

---

## 2. Corrected Root Cause Analysis

### 2.1 TableBuilder Path (Active Code Path)

**Flow:**
```
render_table (line 3215)
  if table_wrap_overhaul_enabled (line 3225) ← DEFAULT TRUE
    → render_table_tablebuilder (line 3318)
      → compute_column_stats (column_spec.rs:378)
        → accumulate_stats_for_cell (column_spec.rs:411)
          → Counts graphemes, longest_word, flags
          → For images: uses ALT TEXT, not pixel width
      → derive_column_specs (column_spec.rs:190)
        → classify_column (column_spec.rs:270)
          → Pattern matching on header text
          → Content stats influence (has_image, longest_word, etc.)
          → Returns ColumnPolicy (Fixed/Resizable/Remainder/Auto)
      → TableBuilder with Column::auto(), Column::remainder(), etc.
        → egui handles actual layout
```

**KEY INSIGHT:** Width calculation is NOT pixel-based in TableBuilder path:
- Uses grapheme counts and content flags
- Relies on egui's Column policies for actual layout
- No `measure_inline_spans` call in this path

### 2.2 Why Rev 2's "Image Bug" Analysis Was Wrong

`measure_inline_spans` (line 2074) contains:
```rust
InlineSpan::Image { .. } => {
    width += ui.available_width();  // Rev 2 identified this as bug
}
```

**But this is ONLY called in legacy path:**
- Line 3243: `self.measure_inline_spans(ui, h)` (legacy path)
- Line 3256: `self.measure_inline_spans(ui, cell)` (legacy path)
- **NOT called** in TableBuilder path at all!

**TableBuilder path uses:**
- `accumulate_stats_for_cell` which extracts image ALT TEXT
- Grapheme counting, not pixel measurement
- Content flags (has_image) for policy hints

**Conclusion:** Image measurement bug exists but is **IRRELEVANT** to active code path.

### 2.3 Actual Bugs in Active Path

**BUG #1: Padding Column Policy**
- Creates multiple Remainder columns for ragged tables
- Each padding column gets `ColumnPolicy::Remainder { clip: false }`
- Violates "single remainder" design
- Causes remainder columns to compete for space

**BUG #2: Dividers Missing**
- Were implemented, had scroll issues, removed entirely
- Current code has NO cell dividers
- Only striped row backgrounds exist

**UNKNOWN: Column Width Bug**
- May be fixed by existing column sizing work
- May be related to padding column bug
- May be separate egui TableBuilder bug
- **Needs testing to verify**

---

## 3. Recommended Solutions

### 3.1 Fix Padding Column Bug (HIGH PRIORITY)

**Current Code:**
```rust
while column_specs.len() < target_cols {
    column_specs.push(ColumnSpec::new(
        format!("Column {}", column_specs.len() + 1),
        ColumnPolicy::Remainder { clip: false },  // ❌ BUG
    ));
}
```

**Fixed Code:**
```rust
while column_specs.len() < target_cols {
    let padding_idx = column_specs.len();
    column_specs.push(ColumnSpec::new(
        format!("Padding {}", padding_idx + 1),
        ColumnPolicy::Auto,  // ✅ FIX: Use Auto instead of Remainder
        Some(format!("Auto-generated column {}", padding_idx)),
    ));
}

// Add debug assertion to verify single remainder
#[cfg(debug_assertions)]
{
    let remainder_count = column_specs
        .iter()
        .filter(|s| matches!(s.policy, ColumnPolicy::Remainder { .. }))
        .count();
    if remainder_count != 1 {
        eprintln!(
            "⚠️  Table {} has {} remainder columns (expected 1)",
            table_id, remainder_count
        );
    }
}
```

**Rationale:**
- `Auto` policy lets egui size based on content
- Doesn't compete with intended Remainder column
- Handles ragged tables gracefully
- Debug assertion catches regressions

**Testing:**
```rust
#[test]
fn padding_columns_use_auto_policy() {
    let headers = vec![vec![span("A")], vec![span("B")]];
    let rows = vec![vec![
        vec![span("1")],
        vec![span("2")],
        vec![span("3")],  // Extra cell
    ]];

    let stats = compute_column_stats(&headers, &rows, 32);
    let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
    let specs = derive_column_specs(&ctx);

    // Should have 3 specs total
    assert_eq!(specs.len(), 3);

    // Exactly one should be Remainder
    let remainder_count = specs
        .iter()
        .filter(|s| matches!(s.policy, ColumnPolicy::Remainder { .. }))
        .count();
    assert_eq!(remainder_count, 1, "Should have exactly one remainder column");

    // Last one (padding) should be Auto
    assert!(matches!(specs[2].policy, ColumnPolicy::Auto));
}
```

**Effort:** 1-2 hours (simple fix, needs testing)

### 3.2 Investigate and Fix Divider Scroll Issues (MEDIUM PRIORITY)

**Step 1: Document What Went Wrong**

Need to understand why dividers were rolled back:
- What was the visual manifestation of "scroll issues"?
- Did dividers not scroll with content?
- Were dividers painted at wrong positions during scroll?
- Was there a performance issue?
- Was it egui repaint/layout issue?

**Step 2: Review Rolled-Back Code**

```bash
# Check git history for the divider code before rollback
git log --all --source --full-history -S "paint_table_dividers" -- "*.rs"
git show <commit> -- src/markdown_renderer.rs
```

**Step 3: Identify Root Cause**

Likely causes:
1. **Painter layer issue:** Dividers painted on wrong layer, didn't scroll
2. **Clip rect issue:** Dividers not clipped to scrollable area
3. **Coordinate system issue:** Used wrong rect for positioning
4. **Repaint timing:** Dividers painted before final layout settled

**Step 4: Implement Better Approach**

Based on root cause, choose approach:

**Approach A: Fix Original Implementation**
- If issue was simple (wrong clip rect, wrong layer), just fix it
- Add proper clipping to scroll area
- Use correct painter layer

**Approach B: egui::Separator Between Cells**
- Instead of post-render painting, add separator widgets
- More "egui native" approach
- Might avoid scroll issues

**Approach C: Custom TableBuilder Extension**
- Extend TableBuilder with divider support
- Would require forking egui_extras or contributing upstream

**Approach D: Accept Limitation**
- Document that cell dividers unavailable due to egui limitations
- Rely on striped rows for visual separation
- Wait for egui native support

**Recommended:** Start with Approach A (fix original), fallback to Approach D if unfixable

**Effort:** 4-8 hours (depends on root cause complexity)

### 3.3 Verify Column Width Fix (HIGH PRIORITY)

**Action Required:** Test whether existing column sizing work fixes reported bug

**Test Plan:**

1. **Build current branch:**
   ```bash
   cargo build --release
   ```

2. **Run with threat-model table:**
   ```bash
   cargo run --release -- examples/regressions/table-threat-model.md
   ```

3. **Visual inspection:**
   - Is Examples column widest?
   - Is Description column moderate width?
   - Do columns look balanced?

4. **Debug output** (add temporary logging):
   ```rust
   // In render_table_tablebuilder after derive_column_specs
   eprintln!("Table {} column specs:", table_id);
   for (i, spec) in column_specs.iter().enumerate() {
       let header = headers.get(i).map(|h| header_text(h)).unwrap_or_default();
       eprintln!("  [{}] {}: {:?}", i, header, spec.policy);
   }
   ```

5. **Expected output for threat-model table:**
   ```
   [0] Element: Fixed { width: ~90-200, clip: true }
   [1] Symbol: Resizable { min: ~105, preferred: ~140 } or Auto
   [2] Description: Resizable { min: ~147, preferred: ~203 }
   [3] Examples: Remainder { clip: false }
   ```

6. **If correct:** Column sizing work DOES fix the bug ✅
7. **If incorrect:** Need additional fixes ❌

**Effort:** 1-2 hours

---

## 4. Revised Implementation Plan

### 4.1 Phase 1: Verify Current State (PRIORITY 1)

**Duration:** 2-3 hours

**Tasks:**
1. Build and run current branch with threat-model table
2. Add debug logging to show column spec assignments
3. Capture screenshots of current rendering
4. Document visual bugs (if any remain)
5. Verify which issues are already fixed

**Deliverables:**
- Screenshots showing current state
- Debug output showing column policies
- List of remaining vs. fixed issues

### 4.2 Phase 2: Fix Padding Column Bug (PRIORITY 1)

**Duration:** 1-2 hours

**Tasks:**
1. Change `Remainder` to `Auto` in padding loop
2. Add debug assertion for single remainder column
3. Write unit test for ragged tables
4. Test with threat-model table (no change expected)
5. Test with ragged table (should show improvement)

**Deliverables:**
- Fixed code committed
- Unit test passing
- Visual confirmation of fix

### 4.3 Phase 3: Investigate Divider Rollback (PRIORITY 2)

**Duration:** 3-4 hours

**Tasks:**
1. Search git history for rolled-back divider code
2. Review journal entry for scroll issue details
3. Identify root cause of scroll issues
4. Document findings
5. Decide on approach (fix, alternative, or defer)

**Deliverables:**
- Root cause analysis document
- Recommendation for path forward
- If fixable: implementation plan

### 4.4 Phase 4: Re-implement or Document Dividers (PRIORITY 3)

**Duration:** 4-8 hours (if re-implementing)

**Option A: Fix and Re-implement**
- Fix identified scroll issue
- Re-implement dividers with fix
- Test thoroughly with scrolling
- Add regression test

**Option B: Document Limitation**
- Document why dividers unavailable
- Update user-facing docs
- File issue for future work
- Consider alternatives (thicker stripes, etc.)

**Deliverables:**
- Working dividers OR documented limitation
- Updated docs
- Tests (if implemented)

### 4.5 Phase 5: Testing and Validation (PRIORITY 1)

**Duration:** 4-6 hours

**Tasks:**
1. Comprehensive visual testing
2. Test at multiple DPI settings (100%, 125%, 150%)
3. Test window resizing
4. Test scrolling (if dividers implemented)
5. Test legacy path still works
6. Performance testing

**Deliverables:**
- Test report
- Screenshots at various DPI
- Performance numbers
- Regression test suite

### 4.6 Phase 6: Commit and PR (PRIORITY 1)

**Duration:** 2-3 hours

**Tasks:**
1. Review all changes
2. Run `cargo fmt`, `cargo clippy`
3. Ensure all tests pass
4. Write comprehensive commit messages
5. Create PR with before/after screenshots
6. Update QA docs

**Deliverables:**
- Clean commits
- PR ready for review
- Documentation updated

---

## 5. Testing Strategy (Revised)

### 5.1 Unit Tests

**Test 1: Padding Column Policy**
```rust
#[test]
fn padding_uses_auto_not_remainder() {
    // Ragged table: 2 headers, row with 4 cells
    let headers = vec![vec![span("A")], vec![span("B")]];
    let rows = vec![vec![
        vec![span("1")],
        vec![span("2")],
        vec![span("3")],
        vec![span("4")],
    ]];

    let stats = compute_column_stats(&headers, &rows, 32);
    let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
    let specs = derive_column_specs(&ctx);

    assert_eq!(specs.len(), 4);

    let remainder_count = specs
        .iter()
        .filter(|s| matches!(s.policy, ColumnPolicy::Remainder { .. }))
        .count();

    assert_eq!(remainder_count, 1, "Exactly one remainder column");

    // Verify padding columns are Auto
    assert!(matches!(specs[2].policy, ColumnPolicy::Auto));
    assert!(matches!(specs[3].policy, ColumnPolicy::Auto));
}
```

**Test 2: Threat-Model Column Assignment**
```rust
#[test]
fn threat_model_column_policies() {
    let headers = vec![
        vec![span("Element")],
        vec![span("Symbol")],
        vec![span("Description")],
        vec![span("Examples")],
    ];
    let rows: Vec<Vec<Vec<InlineSpan>>> = Vec::new();

    let stats = compute_column_stats(&headers, &rows, 32);
    let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
    let specs = derive_column_specs(&ctx);

    assert_eq!(specs.len(), 4);

    // Element: should be Fixed (first column default)
    assert!(matches!(specs[0].policy, ColumnPolicy::Fixed { .. }));

    // Description: should be Resizable (matches pattern)
    assert!(matches!(specs[2].policy, ColumnPolicy::Resizable { .. }));

    // Examples: should be Remainder (matches pattern)
    assert!(matches!(specs[3].policy, ColumnPolicy::Remainder { .. }));
}
```

### 5.2 Visual Regression Tests

**Test Tables:**

1. **Simple equal-column table:**
   ```markdown
   | A | B | C |
   |---|---|---|
   | 1 | 2 | 3 |
   ```

2. **Threat-model table** (existing file)

3. **Ragged table:**
   ```markdown
   | A | B |
   |---|---|
   | 1 | 2 | 3 | 4 |
   | x | y |
   ```

4. **Image-heavy table:**
   ```markdown
   | Icon | Name | Description |
   |------|------|-------------|
   | ![](a.png) | Item 1 | First |
   | ![](b.png) | Item 2 | Second |
   ```

5. **Wide content table:**
   ```markdown
   | Short | Very long description that should wrap or expand the column |
   |-------|-------------------------------------------------------------|
   | A     | This column contains a lot of text... |
   ```

**Test Procedure:**
1. Capture screenshot at 100% DPI
2. Capture screenshot at 125% DPI
3. Capture screenshot at 150% DPI
4. Capture screenshot with narrow window
5. Capture screenshot with wide window
6. Compare before/after for each scenario

### 5.3 Performance Tests

**Benchmark 1: Column Stats Collection**
```rust
#[bench]
fn bench_compute_column_stats_large_table(b: &mut Bencher) {
    let headers = vec![/* 10 columns */];
    let rows = vec![/* 1000 rows with 10 cells each */];

    b.iter(|| {
        compute_column_stats(&headers, &rows, 128)
    });

    // Target: < 5ms
}
```

**Benchmark 2: Table Rendering**
```rust
#[bench]
fn bench_render_large_table(b: &mut Bencher) {
    // Render 10x100 table with current implementation
    // Compare with baseline

    // Target: < 5% regression
}
```

---

## 6. Success Criteria (Revised)

### 6.1 Must-Have (Release Blockers)

- [ ] Padding column bug fixed and tested
- [ ] Threat-model table renders correctly (Examples widest)
- [ ] No regressions in existing tables
- [ ] All unit tests pass
- [ ] `cargo clippy` clean
- [ ] Performance within 5% of baseline

### 6.2 Should-Have (Important)

- [ ] Divider scroll issue root cause documented
- [ ] Decision made on divider implementation (fix, defer, or alternative)
- [ ] Visual regression tests created
- [ ] DPI testing completed (100%, 125%, 150%)
- [ ] Documentation updated

### 6.3 Nice-to-Have (Future Work)

- [ ] Cell dividers working without scroll issues
- [ ] Column resize persistence verified working
- [ ] GFM alignment support
- [ ] Legacy path deprecated

---

## 7. Key Learnings and Process Improvements

### 7.1 What Went Wrong in Rev 1 & 2

1. **Did not check current branch** - Missed that work was in progress
2. **Did not review journals** - Existing HLD/Plan/Journal documented work
3. **Did not trace code flow** - Analyzed wrong code path
4. **Made assumptions** - Assumed bug locations without verification
5. **Jumped to solutions** - Designed fixes before understanding problem

### 7.2 Correct Process for Future

**ALWAYS START WITH:**
1. `git branch --show-current` - What branch am I on?
2. `git status` - What's uncommitted?
3. `git log --oneline -20` - Recent commits?
4. Check `wrk_journals/*.md` - What work was done?
5. Check `wrk_docs/*.md` - Existing designs/plans?
6. **THEN** analyze code
7. **THEN** identify issues
8. **THEN** design solutions

### 7.3 Verification Steps

**Before claiming root cause:**
1. Trace actual execution flow
2. Add debug logging
3. Run the code
4. Observe the bug
5. Verify the suspected code path is actually executed

**Before proposing solution:**
1. Verify problem still exists
2. Verify proposed solution addresses actual issue
3. Consider existing work
4. Check for prior attempts (like divider rollback)

---

## 8. Recommendations

### 8.1 Immediate Actions (Next 2-4 hours)

1. **Fix padding column bug** - Simple, low-risk, clear fix
2. **Verify column width bug is fixed** - Test current implementation
3. **Document current state** - Capture screenshots, debug output

### 8.2 Short-Term (Next 1-2 days)

1. **Investigate divider rollback** - Understand what went wrong
2. **Decide divider approach** - Fix, alternative, or defer?
3. **Complete testing** - Visual regression, DPI, performance

### 8.3 Long-Term (Future)

1. **GFM alignment support** - If dividers working
2. **Legacy path deprecation** - Reduce maintenance burden
3. **Upstream contribution** - If egui changes needed

---

## 9. Open Questions

**Q1:** What were the specific "scroll issues" that caused divider rollback?
- **Action:** Review git history, test rolled-back code
- **Owner:** Developer
- **Priority:** High

**Q2:** Does existing column sizing work fix the reported width bug?
- **Action:** Build and test current branch
- **Owner:** Developer
- **Priority:** Critical

**Q3:** Should we invest in fixing dividers or defer to future?
- **Action:** Decide after understanding scroll issue root cause
- **Owner:** Tech lead
- **Priority:** Medium

**Q4:** Are there other bugs not captured in original report?
- **Action:** Comprehensive testing of current implementation
- **Owner:** QA
- **Priority:** High

---

## 10. Appendix

### 10.1 Code Locations (Correct)

| Component | File | Lines | Path |
|-----------|------|-------|------|
| **Main render** | `src/markdown_renderer.rs` | 3215-3229 | Dispatcher |
| **TableBuilder render** | `src/markdown_renderer.rs` | 3318-3382 | Active path |
| **Legacy render** | `src/markdown_renderer.rs` | 3231-3316 | Fallback path |
| **Padding bug** | `src/markdown_renderer.rs` | 3332-3339 | NEEDS FIX |
| **Column classification** | `src/table_support/column_spec.rs` | 270-335 | Policy logic |
| **Column stats** | `src/table_support/column_spec.rs` | 378-447 | Content analysis |
| **Image measurement** | `src/markdown_renderer.rs` | 2102-2106 | Legacy only |

### 10.2 Feature Flags

| Flag | Default | Purpose |
|------|---------|---------|
| `table_wrap_overhaul_enabled` | `true` | Enable TableBuilder path |
| `MDMDVIEW_DISABLE_TABLE_DIVIDERS` | unset | Was for dividers (rolled back) |

### 10.3 Related Documents

- **Journal:** `wrk_journals/2025.11.14 - JRN - Table Column Fixes.md`
- **Original HLD:** `wrk_docs/2025.11.14 - HLD - Table Column Fixes.md`
- **Plan:** `wrk_docs/2025.11.14 - PLN - Table Column Fixes.md`
- **QA Doc:** `docs/QA-table-wrap.md`
- **Test File:** `examples/regressions/table-threat-model.md`

---

**End of High-Level Design (Revision 3)**

**Summary of Key Changes from Rev 2:**
1. Acknowledged existing work on feature branch
2. Corrected code path analysis (TableBuilder, not legacy)
3. Identified image measurement bug as irrelevant to active path
4. Focused on actual remaining issues (padding bug, rolled-back dividers)
5. Added verification steps before assuming fixes needed
6. Documented learnings and process improvements
7. Reduced scope to fixing/completing existing work vs. redesigning

**Next Steps:**
1. Review this HLD with stakeholders
2. Execute Phase 1: Verify current state
3. Execute Phase 2: Fix padding bug
4. Decide on divider approach based on investigation

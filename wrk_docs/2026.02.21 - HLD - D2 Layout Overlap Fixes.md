# HLD — D2 Layout Overlap Fixes

**Date:** 2026-02-21
**Author:** Claude Opus 4.6 + Arthur
**Status:** Draft
**Crate:** `mdmdview-d2` (`crates/d2/`)

---

## 1. Problem Statement

Three classes of visual overlap are observed in rendered D2 diagrams:

| # | Symptom | Severity | Example |
|---|---------|----------|---------|
| A | Nodes inside sibling containers overlap in absolute coordinates | **Critical** | Backend/Frontend children pile on top of each other |
| B | Edge labels render on top of nodes instead of in the gap between ranks | High | "fetch", "enqueue jobs", "CRUD" obscure node labels |
| C | Adjacent containers crowd each other; padding insufficient for dense graphs | Medium | Services/Data Layer containers overlap at boundaries |

All three are **layout-phase** bugs, not rendering bugs. The SVG renderer faithfully draws what the layout produces.

---

## 2. Root Cause Analysis

### 2A. Container Descendant Stranding (Critical)

**Location:** `layout.rs:90-122` (`layout_recursive`) + `layout_sugiyama.rs:720-787` (`assign_coordinates`)

**Mechanism:**

The recursive layout processes containers bottom-up:

```
layout_recursive(Platform):
  1. layout_recursive(Frontend)
       → Sugiyama positions {app, cdn} at absolute coords
       → fit_container(Frontend) wraps them: Frontend.box_ = (-30, -12, 120, 120)
  2. layout_recursive(Backend)
       → Sugiyama positions {api, svc} at absolute coords
       → fit_container(Backend) wraps them: Backend.box_ = (-30, -12, 160, 192)
  3. layout_sugiyama::layout_children(Platform)
       → Treats Frontend and Backend as opaque nodes with sizes from fit_container
       → assign_coordinates OVERWRITES Frontend.box_ to (50, 0, ...) and Backend.box_ to (50, 252, ...)
  4. fit_container(Platform)
       → Reads children's NEW positions... but grandchildren are STRANDED at old positions
```

**The bug:** In step 3, `assign_coordinates` overwrites each container's `box_.x` and `box_.y` with new layout positions. But descendants (grandchildren, great-grandchildren, etc.) inside those containers **are not shifted by the same delta**. They remain at their absolute positions from step 1/2, which no longer correspond to the container's new location.

**Concrete example:** After step 2, `api` (API Gateway) is at absolute position (0, 24). After step 3, Backend's box moves from (-30, -12) to (50, 252). The delta is (+80, +264). But `api` is still at (0, 24) instead of (80, 288). When rendered, `api` appears near the origin instead of inside Backend.

**Why it's intermittent:** For the root container, `layout_recursive` is called once and its direct children are non-containers (or the containers happen to be positioned near the origin by Sugiyama's centering). For nested containers (like the Platform example), the bug is always present.

### 2B. Edge Label Placement at Bézier Midpoint

**Location:** `edge_routing.rs:119-121`

```rust
let mid = bezier_midpoint(&route);
let label_pos = Some(Point::new(mid.x, mid.y - 10.0));
```

The label is placed at the Bézier curve's parametric midpoint (t=0.5) with a hardcoded 10px upward offset. Problems:

1. **The Bézier midpoint often falls on or near a node.** For edges between vertically adjacent ranks, the midpoint is roughly halfway between the source and destination. With `NODE_SPACING_V = 60.0` and typical node heights of 36-50px, the gap between adjacent node edges is only ~10-24px. The midpoint of the edge (which runs through this gap) is right in the middle — but a label is ~20px tall, so it overlaps both nodes.

2. **No collision detection.** The label placement has zero awareness of node bounding boxes. Even the 10px offset is a fixed constant that doesn't adapt to the diagram geometry.

3. **No space reservation.** Unlike proper Sugiyama implementations that insert virtual label nodes to widen rank gaps, our layout allocates no extra vertical space for labels.

### 2C. Insufficient Container Spacing

**Location:** `layout_sugiyama.rs:20-23` (spacing constants) + `layout.rs:24-26` (container padding)

```rust
const NODE_SPACING_H: f64 = 40.0;   // Between nodes in same rank
const NODE_SPACING_V: f64 = 60.0;   // Between ranks
const CONTAINER_PADDING: f64 = 30.0; // Inside container border
```

When containers are treated as nodes in their parent's Sugiyama layout, they use the same `NODE_SPACING_H = 40` as leaf nodes. But containers are typically 3-10x larger than leaf nodes. The 40px gap that works between two 60px-wide rectangles is visually cramped between two 300px-wide containers.

Additionally, `fit_containers` is called at the end (`layout.rs:47`) and re-computes container sizes — but this second pass can only shrink or maintain sizes (it reads children's current positions). It cannot push sibling containers apart if they now overlap.

---

## 3. Proposed Solutions

### Fix A: Propagate Position Deltas to Descendants

**Strategy:** After `assign_coordinates` repositions container nodes, compute the positional delta for each container and shift its entire descendant subtree.

**File:** `layout.rs`

**Change to `layout_recursive`:**

```rust
fn layout_recursive(
    graph: &mut D2Graph,
    container: NodeIndex,
    parent_direction: Direction,
) -> Result<(), LayoutError> {
    let children: Vec<NodeIndex> = graph.graph[container].children.clone();
    if children.is_empty() {
        return Ok(());
    }

    let direction = graph.graph[container]
        .direction
        .unwrap_or(parent_direction);

    // Recurse into child containers (bottom-up)
    for &child in &children {
        if graph.graph[child].is_container {
            layout_recursive(graph, child, direction)?;
        }
    }

    // ---- NEW: Snapshot container positions before Sugiyama ----
    let old_positions: Vec<(NodeIndex, Option<Rect>)> = children
        .iter()
        .filter(|&&c| graph.graph[c].is_container)
        .map(|&c| (c, graph.graph[c].box_))
        .collect();

    // Sugiyama positions direct children (overwrites container box_ positions)
    layout_sugiyama::layout_children(graph, container, direction)?;

    // ---- NEW: Propagate delta to descendants of repositioned containers ----
    for (child, old_box) in &old_positions {
        if let (Some(old), Some(new)) = (old_box, graph.graph[*child].box_) {
            let dx = new.x - old.x;
            let dy = new.y - old.y;
            if dx.abs() > 0.01 || dy.abs() > 0.01 {
                let grandchildren = graph.graph[*child].children.clone();
                offset_subtree(graph, &grandchildren, dx, dy);
            }
        }
    }

    // Size the container to fit its (now correctly positioned) children
    if container != graph.root {
        fit_container(graph, container);
    }

    Ok(())
}
```

**Why this works:** `offset_subtree` already exists (used by `fit_container` for label height offsets at line 176). It recursively shifts all descendants by (dx, dy). By calling it after Sugiyama repositions the container, all grandchildren, great-grandchildren, etc. move in lockstep with their container.

**Edge case:** If a container has `box_ = None` before Sugiyama (no children → never fitted), `old_box` is `None` and the delta computation is skipped. This is correct — empty containers have no descendants to shift.

### Fix B: Edge Label Collision Avoidance

This fix has two parts: **allocate space** and **position labels intelligently**.

#### B1. Reserve Space for Labeled Edges in Rank Gaps

**File:** `layout_sugiyama.rs`, function `assign_coordinates`

**Strategy:** When computing `rank_offset` (the vertical distance between ranks), check if any edge between these two ranks has a label. If so, add extra space to accommodate the label.

```rust
fn assign_coordinates(
    graph: &mut D2Graph,
    ordered_ranks: &[Vec<NodeIndex>],
    edges_with_labels: &[(NodeIndex, NodeIndex, bool)],  // NEW param: (src, dst, has_label)
    direction: Direction,
) {
    // ... existing setup ...

    // Build a lookup: for each pair of adjacent ranks, does any edge have a label?
    let node_to_rank: HashMap<NodeIndex, usize> = /* build from ordered_ranks */;

    let mut rank_offset = 0.0;
    let mut rank_offsets: Vec<f64> = Vec::new();

    for (rank_idx, rank_nodes) in ordered_ranks.iter().enumerate() {
        rank_offsets.push(rank_offset);

        let max_size = rank_nodes
            .iter()
            .filter_map(|&node| graph.graph[node].box_)
            .map(|rect| if is_horizontal { rect.width } else { rect.height })
            .fold(0.0f64, f64::max);

        // NEW: Check if any labeled edge spans this rank gap → next rank
        let has_label_in_gap = edges_with_labels.iter().any(|(src, dst, has_label)| {
            if !has_label { return false; }
            let sr = node_to_rank.get(src).copied();
            let dr = node_to_rank.get(dst).copied();
            matches!((sr, dr), (Some(s), Some(d)) if s == rank_idx && d == rank_idx + 1)
                || matches!((sr, dr), (Some(s), Some(d)) if d == rank_idx && s == rank_idx + 1)
        });

        let label_extra = if has_label_in_gap { EDGE_LABEL_SPACING } else { 0.0 };

        rank_offset += max_size + NODE_SPACING_V + label_extra;
    }

    // ... rest unchanged ...
}
```

**New constant:**

```rust
/// Extra vertical space between ranks when a labeled edge spans the gap.
/// Accommodates a single line of label text (~20px) plus padding.
const EDGE_LABEL_SPACING: f64 = 28.0;
```

This requires threading label information from `layout_component` into `assign_coordinates`. The cleanest approach: `layout_component` already has access to `edges` (which are `EdgeIndex` values). It can check `graph.graph[eidx].label.is_some()` for each edge and pass this information down.

#### B2. Position Labels in the Rank Gap Center

**File:** `edge_routing.rs`, function `route_all_edges`

**Strategy:** Instead of placing labels at the Bézier parametric midpoint, place them at the geometric midpoint of the straight line between the two **clipped** edge endpoints (which sit on the shape boundaries). This naturally positions the label in the gap between nodes.

```rust
// BEFORE:
let mid = bezier_midpoint(&route);
let label_pos = Some(Point::new(mid.x, mid.y - 10.0));

// AFTER:
let label_pos = if graph.graph[eidx].label.is_some() {
    // Place label at geometric center of the gap between shape edges
    let gap_mid = Point::new(
        (start.x + end.x) / 2.0,
        (start.y + end.y) / 2.0,
    );
    Some(gap_mid)
} else {
    None
};
```

**Why geometric midpoint?** The clipped `start` point sits on the source shape's boundary, and `end` sits on the destination shape's boundary. The midpoint of the straight line between them is always in the gap between nodes — exactly where we want the label.

The Bézier parametric midpoint can differ significantly from the geometric midpoint for curved edges, especially for edges with large horizontal displacement.

#### B3. (Optional, V2) Collision Nudging

After initial label placement, check if the label's bounding box overlaps any node's bounding box. If so, nudge the label perpendicular to the edge direction. This handles corner cases like diagonal edges where even the geometric midpoint falls on a node.

Deferred to V2 because fixes B1+B2 address >90% of cases.

### Fix C: Adaptive Container Spacing

**File:** `layout_sugiyama.rs`, function `assign_coordinates`

**Strategy:** Use a per-rank-pair spacing value instead of the global `NODE_SPACING_H` / `NODE_SPACING_V`. For containers, scale spacing proportionally.

```rust
// In assign_coordinates, when computing cross-rank spacing:
let node_spacing = if rank_nodes.iter().any(|&n| graph.graph[n].is_container) {
    NODE_SPACING_H.max(CONTAINER_SPACING_MIN)
} else {
    NODE_SPACING_H
};
```

**New constant:**

```rust
/// Minimum spacing between container nodes in the same rank (pixels).
/// Containers are visually larger and benefit from more breathing room.
const CONTAINER_SPACING_MIN: f64 = 60.0;
```

Similarly for inter-rank (vertical) spacing:

```rust
let rank_spacing = if /* either rank contains a container */ {
    NODE_SPACING_V.max(CONTAINER_RANK_SPACING_MIN)
} else {
    NODE_SPACING_V
};
```

**New constant:**

```rust
/// Minimum vertical spacing between ranks that contain containers.
const CONTAINER_RANK_SPACING_MIN: f64 = 80.0;
```

This is deliberately conservative — it doesn't try to compute the "perfect" spacing, just ensures containers get more room than leaf nodes. A future Brandes-Kopf coordinate assignment phase would handle this more elegantly.

---

## 4. Implementation Plan

### Phase 1: Container Descendant Fix (Fix A) — Critical

**Files modified:** `layout.rs`

1. In `layout_recursive`, snapshot container children's positions before calling `layout_sugiyama::layout_children`.
2. After Sugiyama returns, compute deltas and call `offset_subtree` for each moved container.
3. The rest of the function (`fit_container`) remains unchanged.

**Tests:**
- `test_container_children_absolute_positions`: Parse `"a: { x\n y\n }\nb: { p\n q\n }\na.x -> b.p"`, verify x/y of children are within their parent container bounds.
- `test_nested_container_no_overlap`: Parse the Platform/Frontend/Backend example from the stress test, verify no two leaf nodes have overlapping bounding boxes.
- `test_container_delta_propagation`: Two-level nesting, verify grandchildren shift correctly.

**Risk:** Low. The `offset_subtree` function is already battle-tested (used for label height offsets). The only new logic is the delta computation, which is trivial arithmetic.

### Phase 2: Edge Label Space Reservation (Fix B1) — High priority

**Files modified:** `layout_sugiyama.rs`, `layout.rs` (minor wiring)

1. Add `EDGE_LABEL_SPACING` constant.
2. Modify `layout_component` to pass edge label information to `assign_coordinates`.
3. In `assign_coordinates`, compute per-rank-gap spacing that accounts for labels.

**Approach to threading label info:** The simplest approach is to have `layout_component` (which already has `edges: &[(NodeIndex, NodeIndex, EdgeIndex)]`) build a set of labeled rank-pairs and pass it into `assign_coordinates`. Alternatively, pass the graph reference and let `assign_coordinates` query labels directly.

The cleanest refactor: change `assign_coordinates` to also take a reference to the graph's edge data so it can check labels itself. This avoids adding a new parameter type.

```rust
fn assign_coordinates(
    graph: &D2Graph,           // NEW: read-only for label queries
    positions: &mut D2Graph,   // write positions (same graph, but clarifies intent)
    ordered_ranks: &[Vec<NodeIndex>],
    edges: &[(NodeIndex, NodeIndex, EdgeIndex)],  // already available in layout_component
    direction: Direction,
)
```

Actually, since `graph` is `&mut D2Graph` (we write positions), we can just accept the edges slice and check labels from the same mutable reference:

```rust
fn assign_coordinates(
    graph: &mut D2Graph,
    ordered_ranks: &[Vec<NodeIndex>],
    edges: &[(NodeIndex, NodeIndex, EdgeIndex)],  // NEW param
    direction: Direction,
)
```

**Tests:**
- `test_labeled_edge_gap`: Parse `"a -> b: hello"`, verify the vertical gap between a's bottom edge and b's top edge is >= `EDGE_LABEL_SPACING`.
- `test_unlabeled_edge_no_extra_gap`: Parse `"a -> b"`, verify the gap equals exactly `NODE_SPACING_V` (no extra space wasted).

### Phase 3: Smart Label Positioning (Fix B2) — High priority

**Files modified:** `edge_routing.rs`

1. Replace Bézier midpoint with geometric midpoint of clipped endpoints.
2. Remove the hardcoded `-10.0` vertical offset.

**Tests:**
- `test_label_in_gap_between_nodes`: Parse `"a -> b: label"`, run full layout + routing, verify label_position is between a's bottom edge and b's top edge (not overlapping either).
- `test_horizontal_label_in_gap`: Parse `"direction: right\na -> b: label"`, verify label is between a's right edge and b's left edge.

### Phase 4: Adaptive Container Spacing (Fix C) — Medium priority

**Files modified:** `layout_sugiyama.rs`

1. Add `CONTAINER_SPACING_MIN` and `CONTAINER_RANK_SPACING_MIN` constants.
2. In `assign_coordinates`, use container-aware spacing when containers are present in a rank.

**Tests:**
- `test_container_spacing_wider_than_leaf`: Parse two containers side-by-side, verify horizontal gap is >= `CONTAINER_SPACING_MIN`.
- `test_leaf_spacing_unchanged`: Parse leaf-only diagrams, verify spacing is exactly `NODE_SPACING_H`.

---

## 5. Files Changed Summary

| File | Change | Phase |
|------|--------|-------|
| `crates/d2/src/layout.rs` | Delta propagation in `layout_recursive` | 1 |
| `crates/d2/src/layout_sugiyama.rs` | New constants, label-aware rank spacing, container spacing | 2, 4 |
| `crates/d2/src/edge_routing.rs` | Geometric midpoint label placement | 3 |

No changes to: `parser.rs`, `compiler.rs`, `graph.rs`, `shapes.rs`, `svg_render.rs`, `text.rs`.

---

## 6. Design Decisions and Trade-offs

### Why not insert virtual label nodes? (Rejected for V1)

The "textbook" Sugiyama approach inserts virtual nodes for edge labels, which gives them first-class participation in crossing reduction and coordinate assignment. This produces optimal results but requires:
- Modifying the graph (adding/removing virtual nodes)
- Special handling during crossing reduction (virtual nodes should be transparent)
- Complex coordinate assignment to align virtual nodes with their edges

For V1, the simpler approach of reserving extra rank-gap space + geometric midpoint placement achieves 90% of the visual quality at 10% of the complexity. Virtual label nodes are a V2 feature if needed.

### Why not a full Brandes-Kopf coordinate assignment? (Deferred to V2)

The current "center each rank independently" approach causes misalignment between connected nodes across ranks. Brandes-Kopf computes a balanced median alignment that minimizes total edge length. However:
- It's a significant implementation effort (~200-300 lines)
- It requires the virtual-node infrastructure to work correctly with long edges
- The current approach works well for simple/medium diagrams
- The overlap fixes in this HLD are orthogonal to Brandes-Kopf and will compound with it when added later

### Why per-rank-pair spacing instead of a single enlarged constant?

Doubling `NODE_SPACING_V` globally would fix label overlap but waste space on edges without labels. The per-rank-pair approach adds space only where needed, keeping compact diagrams compact.

### Why geometric midpoint instead of Bézier midpoint for labels?

For our edge routing, the Bézier control points push the curve's parametric midpoint toward the source or destination node (because control points are 40% along the axis). The geometric midpoint of the clipped endpoints is always in the visual gap between shapes, which is where human readers expect to see the label.

---

## 7. Verification Strategy

### Manual Verification

After implementation, re-render the three diagrams from the bug screenshots:

1. **Container nesting** (`test_stress.md` "Container Nesting" section): Verify Frontend and Backend children don't overlap.
2. **Styled elements** (`test_stress.md` "Styled Elements"): Verify "retry" label is between the green and red boxes.
3. **Architecture** (`test_stress.md` "Architecture"): Verify labels ("HTTPS", "verify", "route", "sessions", "CRUD") sit in gaps between nodes.

### Automated Tests

| Test | Phase | What it validates |
|------|-------|-------------------|
| `test_container_children_absolute_positions` | 1 | Children stay inside parent bounds |
| `test_nested_container_no_overlap` | 1 | Leaf nodes in sibling containers don't overlap |
| `test_container_delta_propagation` | 1 | 2-level nesting shifts grandchildren correctly |
| `test_labeled_edge_gap` | 2 | Extra space allocated between ranks with labeled edges |
| `test_unlabeled_edge_no_extra_gap` | 2 | No wasted space for unlabeled edges |
| `test_label_in_gap_between_nodes` | 3 | Label position is between node boundaries |
| `test_horizontal_label_in_gap` | 3 | Same check for direction: right |
| `test_container_spacing_wider_than_leaf` | 4 | Containers get more breathing room |

### Non-Overlap Invariant Test

Add a general-purpose "no leaf overlap" test that can be applied to any D2 source:

```rust
fn assert_no_leaf_overlap(graph: &D2Graph) {
    let leaves: Vec<(NodeIndex, Rect)> = graph.objects.iter()
        .filter(|&&idx| idx != graph.root && !graph.graph[idx].is_container)
        .filter_map(|&idx| graph.graph[idx].box_.map(|r| (idx, r)))
        .collect();

    for i in 0..leaves.len() {
        for j in (i + 1)..leaves.len() {
            let (a_idx, a) = leaves[i];
            let (b_idx, b) = leaves[j];
            let overlap_x = a.x < b.x + b.width && b.x < a.x + a.width;
            let overlap_y = a.y < b.y + b.height && b.y < a.y + a.height;
            assert!(
                !(overlap_x && overlap_y),
                "leaf nodes '{}' and '{}' overlap: {:?} vs {:?}",
                graph.graph[a_idx].id, graph.graph[b_idx].id, a, b,
            );
        }
    }
}
```

Apply this to the stress-test diagrams and to a suite of representative D2 inputs.

---

## 8. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Fix A changes positions of all container layouts, breaking existing e2e tests | High | Low | Expected — update snapshot assertions. The old positions were wrong. |
| Extra label spacing makes small diagrams look too spread out | Low | Low | Only adds space when labeled edges exist in that rank gap |
| Container spacing increase makes compact diagrams wider than necessary | Medium | Low | Conservative increase (60px vs 40px); only for ranks with containers |
| `offset_subtree` called multiple times for deep nesting (performance) | Low | Negligible | Already O(n) per call; total work is O(n) across all levels |
| Edge label position changes produce different-but-still-bad overlaps | Low | Medium | Geometric midpoint is strictly better than Bézier midpoint for this use case. V2 collision nudging can handle remaining cases. |

---

## 9. Future Work (V2+)

These are explicitly out of scope for this HLD but worth tracking:

1. **Brandes-Kopf coordinate assignment** — Align nodes with connected parents for cleaner edge routing and more compact layouts.
2. **Virtual label nodes** — Insert label placeholders into the rank structure for first-class label layout.
3. **Edge label collision detection and nudging** — Post-layout pass that shifts labels away from overlapping nodes.
4. **Orthogonal edge routing** — Route edges along horizontal/vertical segments instead of Bézier curves, which gives cleaner routing around containers.
5. **Container-aware edge routing** — Clip edges at container boundaries when edges cross between containers.
6. **Dynamic spacing based on node size** — Instead of fixed constants, compute spacing as a function of the largest nodes in adjacent ranks.

---

## 10. Implementation Order

```
Phase 1 (Fix A) ──→ Phase 2 (Fix B1) ──→ Phase 3 (Fix B2) ──→ Phase 4 (Fix C)
   Critical             High                  High                 Medium
   ~30 lines            ~40 lines             ~10 lines            ~20 lines
```

Phases 2 and 3 can be combined into a single commit since they both address edge labels.
Phases 1 and 2+3 are independent and could be parallelized, but Phase 1 should land first because it changes container positions which affects all downstream geometry (including edge routing and label placement).

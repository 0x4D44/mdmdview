# HLD — D2 Orthogonal Edge Routing (V2)

**Date:** 2026-02-21
**Author:** Claude Opus 4.6 + Arthur
**Status:** Draft
**Crate:** `mdmdview-d2` (`crates/d2/`)
**Revision:** V2 — polish pass; fixes editorial issues, LCA edge cases, and label placement from V1

---

## Changelog from V1

| # | Issue in V1 | Fix in V2 |
|---|-------------|-----------|
| 1 | §3.7 had thinking-out-loud prose ("Wait — this is just a normal three-segment route...") | Rewritten as clean specification with concrete geometry. |
| 2 | §3.3 didn't address long-span edges sharing gaps with shorter edges | Added explicit note: long-span edges reserve channel positions in ALL intermediate gaps they pass through, coordinated with shorter edges in those gaps. |
| 3 | Label placement for cross-container edges could put labels inside container bounds | Added "gap-only" label rule: for cross-container edges, labels are placed on the portion of the exit/enter segment that lies outside all container boundaries (i.e., in the open gap). |
| 4 | Problem statement said "unchanged from V0, see original" — not self-contained | Inlined the full problem statement and example. |
| 5 | `child_ancestor_of` infinite loop when `node == ancestor` | Added guard clause: if `node == ancestor`, return `node` (handles container-to-descendant edges). |
| 6 | Edge between container and its own descendant was unhandled | Added §3.2.1 covering this case: when one endpoint IS the LCA, the other endpoint's child-ancestor is used directly and the channel is placed within the container's internal layout. |

---

## 1. Problem Statement

The current edge routing (`edge_routing.rs`) produces diagonal Bézier curves between node centers. For diagrams with multiple cross-container edges this creates visual chaos:

```d2
direction: right

lb: Load Balancer {shape: cloud}
services: Services {
  gw: API Gateway
  auth: Auth Service
  orders: Order Service
  notify: Notification Service
  gw -> auth: verify token
  gw -> orders: route request
  orders -> notify: order placed
}
data: Data Layer {
  pg: PostgreSQL {shape: cylinder}
  redis: Redis {shape: cylinder}
  s3: Object Store {shape: cylinder}
}
lb -> services.gw: HTTPS
services.auth -> data.redis: sessions
services.orders -> data.pg: CRUD
services.notify -> data.s3: templates
```

**Observed defects:**

| # | Symptom | Root Cause |
|---|---------|------------|
| 1 | Cross-container edges (auth→redis, orders→pg, notify→s3) form a tangled diagonal bundle | Center-to-center Bézier routing: all edges fan through the same gap area at different angles |
| 2 | Edge labels ("CRUD", "sessions", "templates") pile up on top of each other | Labels placed at geometric midpoint of diagonal paths that converge in the same area |
| 3 | Edges cross unnecessarily | No awareness of other edges; only parallel edges (same src/dst pair) are offset |
| 4 | Arrows enter/exit nodes at arbitrary angles | Shape clipping from center creates angled attachment points |

**Goal:** Edges should follow horizontal and vertical paths with clean right-angle turns — the standard look for architecture diagrams and the style used by the official D2 renderer.

---

## 2. Key Architectural Insight: Hierarchical Routing

The Sugiyama layout runs **per-container**: root lays out {lb, services, data}, Services lays out {gw, auth, orders, notify}, Data Layer lays out {pg, redis, s3}. Each container has its own direction and rank structure.

Cross-container edges (e.g., `services.auth -> data.redis`) have their actual endpoints at leaf nodes deep in the hierarchy, but at the root level they're abstracted as edges between container children (`services -> data`).

**The router must work with the hierarchy:**

1. For edge (src, dst), find their **Lowest Common Ancestor (LCA)** container
2. Find the **child-of-LCA ancestor** of src (`src_anc`) and dst (`dst_anc`)
3. Read the **effective direction** of the LCA container
4. Compute the **channel position** in the gap between `src_anc` and `dst_anc`
5. Route from the actual leaf node position through the channel to the destination

**Example trace for `auth -> redis`:**

```
auth's parent chain: auth → Services → root
redis's parent chain: redis → Data Layer → root
LCA = root
src_anc = Services (direct child of root containing auth)
dst_anc = Data Layer (direct child of root containing redis)
direction = right (root's effective direction)
gap_start = Services.right()    ≈ 600
gap_end   = Data Layer.x        ≈ 700
channel_x = (600 + 700) / 2     = 650
Route: auth.right_edge →(horizontal)→ 650 →(vertical)→ redis.y →(horizontal)→ redis.left_edge
```

For **intra-container edges** (e.g., `gw -> auth` within Services):

```
LCA = Services
src_anc = gw (direct child of Services)
dst_anc = auth (direct child of Services)
direction = right (Services' effective direction)
channel_x = (gw.right() + auth.x) / 2.0
Route: gw.right_edge →(horizontal)→ channel_x →(vertical)→ auth.y →(horizontal)→ auth.left_edge
```

---

## 3. Design

### 3.1 Route Shape: Three-Segment Orthogonal Path

The primary routing pattern is a **three-segment path**:

```
direction: right                    direction: down

  ┌─────┐                            ┌─────┐
  │ src ├──── exit ─┐                │ src │
  └─────┘           │ channel        └──┬──┘
                    │ (vertical)        │ exit
  ┌─────┐           │                   │ (vertical)
  │ dst ◄──── enter─┘            ┌──────┤ channel (horizontal)
  └─────┘                        │      │
                              ┌──▼──┐
                              │ dst │
                              └─────┘
```

**Segment definitions for `direction: right`:**

| Segment | Axis | From | To |
|---------|------|------|----|
| Exit | Horizontal (+X) | Source port (shape right edge) | Channel X |
| Channel | Vertical (±Y) | Source port Y → Destination port Y | At channel X |
| Enter | Horizontal (+X) | Channel X | Destination port (shape left edge) |

**Degenerate cases:**

- **Same cross-position** (same Y for direction=right): Channel segment has zero length → two-point straight horizontal line.
- **Same-rank edges** (src and dst at same primary position): Requires jog routing (see §3.7).
- **Backward edges** (dst is behind src in layout direction): Reversed port sides (see §3.8).

### 3.2 LCA Resolution and Channel Position

The router computes channel positions on-the-fly from the graph hierarchy and final node positions. No stored rank metadata needed.

```rust
/// Find the Lowest Common Ancestor container of two nodes.
fn find_lca(graph: &D2Graph, a: NodeIndex, b: NodeIndex) -> NodeIndex {
    let ancestors_a: HashSet<NodeIndex> = ancestor_chain(graph, a);
    let mut current = b;
    loop {
        if ancestors_a.contains(&current) {
            return current;
        }
        match graph.graph[current].parent {
            Some(p) => current = p,
            None => return graph.root,
        }
    }
}

/// Collect the full ancestor chain (inclusive) from node to root.
fn ancestor_chain(graph: &D2Graph, node: NodeIndex) -> HashSet<NodeIndex> {
    let mut chain = HashSet::new();
    let mut current = node;
    loop {
        chain.insert(current);
        match graph.graph[current].parent {
            Some(p) => current = p,
            None => break,
        }
    }
    chain
}

/// Find the direct child of `ancestor` that contains `node`.
/// Returns `node` itself if `node == ancestor` (container-to-descendant edge).
fn child_ancestor_of(
    graph: &D2Graph,
    node: NodeIndex,
    ancestor: NodeIndex,
) -> NodeIndex {
    if node == ancestor {
        return node; // Guard: node IS the ancestor
    }
    let mut current = node;
    loop {
        match graph.graph[current].parent {
            Some(p) if p == ancestor => return current,
            Some(p) => current = p,
            None => return node, // shouldn't happen in well-formed graph
        }
    }
}
```

**Channel position for direction=right:**

```rust
let lca = find_lca(graph, src, dst);
let src_anc = child_ancestor_of(graph, src, lca);
let dst_anc = child_ancestor_of(graph, dst, lca);
let direction = effective_direction(graph, lca);

let src_anc_rect = graph.graph[src_anc].box_.unwrap();
let dst_anc_rect = graph.graph[dst_anc].box_.unwrap();

// Gap between ancestors in the primary axis
let (gap_start, gap_end) = match direction {
    Direction::Right => (src_anc_rect.right(), dst_anc_rect.x),
    Direction::Left  => (dst_anc_rect.right(), src_anc_rect.x),
    Direction::Down  => (src_anc_rect.bottom(), dst_anc_rect.y),
    Direction::Up    => (dst_anc_rect.bottom(), src_anc_rect.y),
};
let channel_pos = (gap_start + gap_end) / 2.0;
```

**Effective direction:**

```rust
fn effective_direction(graph: &D2Graph, container: NodeIndex) -> Direction {
    let mut node = container;
    loop {
        if let Some(dir) = graph.graph[node].direction {
            return dir;
        }
        match graph.graph[node].parent {
            Some(p) => node = p,
            None => return graph.direction,
        }
    }
}
```

#### 3.2.1 Container-to-Descendant Edges

When one endpoint IS the LCA container (e.g., `services -> services.auth`):

- `find_lca(services, auth)` returns `services`
- `child_ancestor_of(services, services)` returns `services` (guard clause)
- `child_ancestor_of(auth, services)` returns `auth`

The "gap" is between the container itself and its direct child. Since the container's `box_` encloses all children, there's no meaningful gap in the primary axis. In this case, fall back to a direct orthogonal route using the container's internal layout direction:

```rust
if src_anc == lca || dst_anc == lca {
    // One endpoint is the container itself.
    // Route directly between the two nodes using a simple L-shaped path.
    let src_rect = graph.graph[src].box_.unwrap();
    let dst_rect = graph.graph[dst].box_.unwrap();
    // channel_pos = midpoint between the two nodes' primary extents
    match direction {
        Direction::Right => {
            channel_pos = (src_rect.right() + dst_rect.x) / 2.0;
        }
        // ... other directions analogous
    }
}
```

### 3.3 Channel Allocation: Preventing Edge Overlap

When multiple edges cross the same inter-ancestor gap, their channel segments must be spaced apart.

**Algorithm:**

1. **Group edges by gap.** Two edges share a gap if they have the same LCA AND the same `{src_anc, dst_anc}` pair (order-independent). This groups all parallel edges between the same pair of child-ancestors.

2. **Long-span edges and shared gaps.** An edge from rank 0 to rank 3 (src_anc=A, dst_anc=D) has a channel segment that passes through intermediate gaps (A-B, B-C, C-D). In those intermediate gaps, shorter edges (e.g., B→C) may also have channel segments. **For V1, long-span edges are allocated independently from shorter edges in shared intermediate gaps.** This means their vertical channel segments may share the same cross-axis position as shorter edges' channels. This is a known limitation — acceptable because:
   - Long-span edges are uncommon in typical Sugiyama layouts
   - Even when overlap occurs, the orthogonal paths are far more readable than the current diagonal Bézier mess
   - A future iteration can add per-gap coordination for overlapping spans

3. **Sort edges within each gap by source cross-position.** For direction=right, sort by source node's center Y (ascending). This ensures vertical channel segments are ordered consistently from the source side, minimizing crossings.

4. **Assign channel primary-axis offsets.** Spread edges symmetrically around the gap midpoint:

```rust
let n = edges_in_gap.len();
let total_spread = (n - 1) as f64 * CHANNEL_SPACING;
for (i, edge) in edges_in_gap.iter().enumerate() {
    edge.channel_pos = gap_midpoint - total_spread / 2.0 + i as f64 * CHANNEL_SPACING;
}
```

**Clamping:** If `total_spread > gap_width - 2 * MIN_STUB_LENGTH`, reduce `CHANNEL_SPACING` proportionally so all channels fit within the gap with visible stub segments on each side.

### 3.4 Port Selection: Where Edges Attach to Shapes

**Rectangular shapes** (rectangle, square, cylinder, code, and fallback shapes): Place ports directly on the bounding box edge at the desired cross-axis position.

**Non-rectangular shapes** (cloud, diamond, hexagon, oval, person, document, parallelogram): Use `clip_to_shape()` from the node center toward a target point on the desired exit side. This produces a port on the actual shape boundary. The clipped point may be slightly off the desired cross-axis position — this produces a small diagonal at the shape boundary, which is acceptable.

```rust
fn compute_port(
    shape: ShapeType,
    rect: &Rect,
    direction: Direction,
    port_cross: f64, // cross-axis position for the port
) -> Point {
    match shape {
        ShapeType::Rectangle | ShapeType::Square | ShapeType::Cylinder
        | ShapeType::Code | ShapeType::Package | ShapeType::Queue
        | ShapeType::Page | ShapeType::Step | ShapeType::StoredData => {
            // Place directly on bounding box edge
            match direction {
                Direction::Right => Point::new(rect.right(), port_cross),
                Direction::Left  => Point::new(rect.x, port_cross),
                Direction::Down  => Point::new(port_cross, rect.bottom()),
                Direction::Up    => Point::new(port_cross, rect.y),
            }
        }
        _ => {
            // Clip from center toward the exit side at the desired cross position
            let target = match direction {
                Direction::Right => Point::new(rect.right() + 100.0, port_cross),
                Direction::Left  => Point::new(rect.x - 100.0, port_cross),
                Direction::Down  => Point::new(port_cross, rect.bottom() + 100.0),
                Direction::Up    => Point::new(port_cross, rect.y - 100.0),
            };
            clip_to_shape(shape, rect, rect.center(), target)
        }
    }
}
```

**Port ordering and distribution:**

When a node has N outgoing edges in the same direction, sort them by destination cross-position before assigning port indices. This ensures the topmost edge exits at the topmost port, minimizing crossings.

```rust
// For direction=right: sort outgoing edges by destination center Y
outgoing_edges.sort_by(|a, b| {
    let a_y = graph.graph[a.dst].box_.unwrap().center().y;
    let b_y = graph.graph[b.dst].box_.unwrap().center().y;
    a_y.partial_cmp(&b_y).unwrap()
});

// Distribute port positions evenly along the exit edge
let edge_length = src_rect.height; // cross-axis dimension for direction=right
let step = edge_length / (outgoing_edges.len() as f64 + 1.0);
for (i, edge) in outgoing_edges.iter().enumerate() {
    let port_cross = src_rect.y + step * (i as f64 + 1.0);
    edge.src_port = compute_port(src_shape, &src_rect, direction, port_cross);
}
```

Same logic applies to destination entry ports: sort incoming edges by source cross-position, distribute entry ports evenly along the entry edge.

**Fallback:** If the node is too small for all ports (step < 4.0px), use the node's center cross-position for all edges.

### 3.5 Rounded Corners

Replace sharp right-angle bends with small-radius quadratic Bézier arcs at each internal waypoint.

**At each bend point B** (where segments A→B and B→C meet):

```
r = min(BEND_RADIUS, |AB|/2, |BC|/2)

arc_start = B + r * normalize(A - B)   // r pixels before bend, on incoming segment
arc_end   = B + r * normalize(C - B)   // r pixels after bend, on outgoing segment

SVG: ... L arc_start Q B arc_end ...
```

**Corner radius:** `BEND_RADIUS = 5.0` pixels.

**Full SVG path construction:**

```rust
fn polyline_with_rounded_corners(points: &[Point], radius: f64) -> String {
    if points.len() < 2 {
        return String::new();
    }
    let mut path = format!("M {} {}", c(points[0].x), c(points[0].y));

    if points.len() == 2 {
        path.push_str(&format!(" L {} {}", c(points[1].x), c(points[1].y)));
        return path;
    }

    for i in 1..points.len() - 1 {
        let prev = points[i - 1];
        let curr = points[i];
        let next = points[i + 1];

        let dx1 = prev.x - curr.x;
        let dy1 = prev.y - curr.y;
        let len1 = (dx1 * dx1 + dy1 * dy1).sqrt();

        let dx2 = next.x - curr.x;
        let dy2 = next.y - curr.y;
        let len2 = (dx2 * dx2 + dy2 * dy2).sqrt();

        if len1 < 1e-6 || len2 < 1e-6 {
            // Degenerate segment — emit line to curr
            path.push_str(&format!(" L {} {}", c(curr.x), c(curr.y)));
            continue;
        }

        let r = radius.min(len1 / 2.0).min(len2 / 2.0);

        let arc_start_x = curr.x + dx1 / len1 * r;
        let arc_start_y = curr.y + dy1 / len1 * r;
        let arc_end_x = curr.x + dx2 / len2 * r;
        let arc_end_y = curr.y + dy2 / len2 * r;

        path.push_str(&format!(
            " L {} {} Q {} {} {} {}",
            c(arc_start_x), c(arc_start_y),
            c(curr.x), c(curr.y),
            c(arc_end_x), c(arc_end_y),
        ));
    }

    let last = points.last().unwrap();
    path.push_str(&format!(" L {} {}", c(last.x), c(last.y)));
    path
}

/// Round to 2 decimal places (reuse existing svg_render helper).
fn c(v: f64) -> f64 { (v * 100.0).round() / 100.0 }
```

### 3.6 Route Data Format

Add `RouteType` to distinguish Bézier and orthogonal path interpretation:

```rust
// In graph.rs

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum RouteType {
    /// Cubic Bézier: [start, ctrl1, ctrl2, end, ctrl1, ctrl2, end, ...]
    Bezier,
    /// Orthogonal polyline: [p0, p1, p2, ...] with line segments
    /// and automatic rounded corners at bend points.
    Orthogonal,
}

impl Default for RouteType {
    fn default() -> Self { RouteType::Bezier }
}

// In D2EdgeData — add field:
pub route_type: RouteType,
```

The SVG renderer checks `route_type`:
- `Bezier` → existing `M ... C ...` logic (unchanged)
- `Orthogonal` → `polyline_with_rounded_corners()` from §3.5

### 3.7 Same-Rank Edges (Jog Routing)

When src and dst are at the same primary-axis position (same rank), there is no inter-rank gap for a channel segment. The route jogs outward beyond both nodes.

**Geometry for direction=right:**

```
                   jog_x
  ┌─────┐           │
  │ src ├───────────┤          exit (horizontal, rightward)
  └─────┘           │
                    │ channel   (vertical, toward dst)
  ┌─────┐           │
  │ dst ◄───────────┘          enter (horizontal, leftward to dst)
  └─────┘
```

```rust
let jog_primary = src_rect.right().max(dst_rect.right()) + SAME_RANK_JOG;
let route = vec![
    src_port,                                           // shape right edge
    Point::new(jog_primary, src_port.y),                // horizontal to jog
    Point::new(jog_primary, dst_port.y),                // vertical to dst level
    dst_port,                                           // horizontal back to dst (entering from right!)
];
```

**Note:** The destination port is on the RIGHT side (not the left as in normal forward routing), because the jog goes rightward past both nodes. The enter segment goes leftward from the jog back into the destination shape.

**For direction=down (same-rank → same Y):**

```rust
let jog_primary = src_rect.bottom().max(dst_rect.bottom()) + SAME_RANK_JOG;
// Route: src bottom → vertical to jog_y → horizontal to dst_x → vertical back up to dst
```

**Detection:** Same-rank when `|src_anc primary center - dst_anc primary center| < threshold` or when `src_anc == dst_anc` and nodes are siblings in the same container rank.

### 3.8 Backward Edges

When src is further along the primary axis than dst (the edge goes "against" the layout direction).

**Detection:**

```rust
let forward = match direction {
    Direction::Right => src_anc_rect.center().x < dst_anc_rect.center().x,
    Direction::Left  => src_anc_rect.center().x > dst_anc_rect.center().x,
    Direction::Down  => src_anc_rect.center().y < dst_anc_rect.center().y,
    Direction::Up    => src_anc_rect.center().y > dst_anc_rect.center().y,
};
```

**When backward (`!forward`):**

- Exit from the OPPOSITE side of src (left for direction=right)
- Enter from the OPPOSITE side of dst (right for direction=right)
- Channel position: midpoint of gap in the reverse direction

```rust
let (gap_start, gap_end) = match direction {
    Direction::Right => (dst_anc_rect.right(), src_anc_rect.x), // reversed
    // ... other directions analogous
};
```

### 3.9 Label Placement

Labels are placed on **exit or enter segments**, preferring segments that lie in the open gap between containers (not inside a container's bounding box).

**Algorithm:**

1. Identify exit segment (route[0]→route[1]) and enter segment (route[N-2]→route[N-1])
2. Compute label text width: `label.chars().count() * char_width` (approximate, `char_width ≈ font_size * 0.55`)
3. **For cross-container edges:** Compute the portion of each segment that lies outside all ancestor container boundaries. Prefer the segment with the longest "in-gap" portion.
4. **For intra-container edges:** Prefer exit segment (it's in the inter-rank gap within the container).
5. **Fallback:** If no segment has room, use the longest segment midpoint.

**Simplified implementation (good enough for V1):** Place the label at the midpoint of the enter segment (the last horizontal segment for direction=right). The enter segment originates at the channel position (in the gap) and ends at the destination shape. For cross-container edges, the enter segment's midpoint is typically between the gap and the destination container boundary — usually not overlapping internal nodes.

**Offset:** Shift label perpendicular to the segment by `LABEL_OFFSET` (10px). For horizontal segments: shift Y upward (-Y). For vertical segments: shift X leftward (-X).

### 3.10 Arrowhead Alignment

The existing `arrowhead_polygon()` function computes direction from the last two route points. For orthogonal routes, the last segment is axis-aligned, so the arrowhead points in the correct cardinal direction. No changes needed.

Note: The rounded corners in the SVG path only affect internal bend points. The first and last points of the route (where arrowheads attach) are unaffected by rounding.

### 3.11 SVG Renderer Changes

`svg_render.rs::render_edges()` adds a branch for orthogonal routes:

```rust
let path_str = match edge.route_type {
    RouteType::Bezier => build_bezier_path(&edge.route),  // existing logic
    RouteType::Orthogonal => polyline_with_rounded_corners(&edge.route, BEND_RADIUS),
};
```

### 3.12 Interaction with Existing Features

| Feature | Impact |
|---------|--------|
| **Self-loops** | Unchanged. Keep `RouteType::Bezier` and existing `self_loop_route()`. |
| **Parallel edges** | Sorted and allocated separate channel positions via §3.3. |
| **Animated/dashed edges** | `stroke-dasharray` works identically on polyline paths. |
| **Back-edges** | §3.8 handles reversed port sides. |
| **Shape clipping** | Replaced by `compute_port()` (§3.4) for orthogonal routes. `clip_to_shape` retained for non-rectangular shapes and Bézier fallback. |
| **Direction overrides** | `effective_direction()` (§3.2) reads per-container direction from the LCA. |
| **ViewBox** | `compute_viewbox` already includes all route points. No change needed. |

---

## 4. Implementation Plan

### Phase 1: Data Model (Small)

**Files:** `graph.rs`

1. Add `RouteType` enum (default: `Bezier`)
2. Add `route_type: RouteType` field to `D2EdgeData`

**Tests:** Existing tests compile and pass (default `Bezier` preserves old behavior).

### Phase 2: Hierarchy Utilities (Small)

**Files:** `edge_routing.rs`

1. `find_lca(graph, src, dst) -> NodeIndex`
2. `ancestor_chain(graph, node) -> HashSet<NodeIndex>`
3. `child_ancestor_of(graph, node, ancestor) -> NodeIndex` (with guard for `node == ancestor`)
4. `effective_direction(graph, container) -> Direction`

**Tests:**
- `find_lca` returns root for nodes in different top-level containers
- `find_lca` returns the container for sibling nodes
- `child_ancestor_of` returns correct intermediate ancestor
- `child_ancestor_of(node, node)` returns `node` (guard clause)
- `effective_direction` inherits from parent when no override

### Phase 3: Orthogonal Router (Core)

**Files:** `edge_routing.rs`

1. Add `route_orthogonal_edges(graph)` entry point
2. For each non-self-loop edge:
   a. LCA + child-ancestor lookup
   b. Forward/backward/same-rank detection
   c. Channel position from ancestor bounding boxes
3. Channel allocation: group by gap, sort by source cross-position, assign offsets with clamping
4. Port selection: sort-by-destination ordering, even distribution, shape-aware placement
5. Three-segment path generation (forward), reversed path (backward), jog path (same-rank)
6. Set `route_type = Orthogonal`
7. Update `route_all_edges()` to call orthogonal router for non-self-loop edges

**Tests:**
- `a -> b` direction=right: straight horizontal line (2 points)
- `a -> b` direction=down: straight vertical line
- Cross-rank with Y offset: 4-point route (exit, bend, bend, enter)
- Same-rank: 4-point jog route
- Multiple edges same gap: channel positions spread apart
- Cross-container: channel between container boundaries
- Backward edge: reversed port sides
- Self-loop: still Bézier
- Container-to-descendant: direct L-shaped route

### Phase 4: SVG Rendering (Small)

**Files:** `svg_render.rs`

1. Add `polyline_with_rounded_corners()` function
2. Add `RouteType::Orthogonal` branch in `render_edges()` path construction

**Tests:**
- SVG for orthogonal edge contains `L` and `Q` commands (not `C`)
- Arrowheads point in correct cardinal direction
- Rounded corners don't overshoot (r clamped)

### Phase 5: Label Placement (Small)

**Files:** `edge_routing.rs`

1. Implement enter-segment-preferring label placement (§3.9)
2. Perpendicular offset

**Tests:**
- Label on horizontal segment, offset above the line
- Label not overlapping source or destination nodes
- Multiple edges in same gap have labels at different Y positions

---

## 5. Constants

```rust
/// Spacing between parallel channel segments in the same inter-ancestor gap.
const CHANNEL_SPACING: f64 = 12.0;

/// Minimum length for exit/enter stub segments.
const MIN_STUB_LENGTH: f64 = 15.0;

/// Radius for rounded corners at orthogonal bends.
const BEND_RADIUS: f64 = 5.0;

/// Perpendicular offset for edge labels from the path segment.
const LABEL_OFFSET: f64 = 10.0;

/// Distance beyond nodes for same-rank jog routing.
const SAME_RANK_JOG: f64 = 30.0;
```

---

## 6. Edge Cases

### 6.1 Long-Span Edges (Skipping Ranks)

An edge from rank 0 to rank 3 has its channel in the gap between src_anc and dst_anc. The vertical channel segment passes through intermediate gaps where shorter edges may also have channels. For V1, long-span and short-span edges in the same intermediate gap are NOT coordinated — their channel segments may overlap. This is acceptable for now (see §3.3 item 2).

### 6.2 Container Boundary Crossing

Cross-container edges route from leaf node positions through container borders to the inter-container gap. The container boundary is not explicitly modeled in the route. This matches the official D2 renderer.

### 6.3 All Four Directions

Direction handling uses explicit match arms consistent with `assign_coordinates`:

| Direction | Exit side | Enter side | Primary axis | Cross axis |
|-----------|-----------|------------|-------------|------------|
| Right | right | left | +X | Y |
| Left | left | right | -X | Y |
| Down | bottom | top | +Y | X |
| Up | top | bottom | -Y | X |

### 6.4 Nodes with Many Edges

Port distribution (§3.4) spaces ports evenly. If node cross-axis dimension / (N+1) < 4px, fall back to center port for all edges.

### 6.5 Degenerate Same-Cross-Position

When source and destination have the same cross-position, the channel segment has zero length. Route degenerates to a straight line: `[src_port, dst_port]`.

### 6.6 Container-to-Descendant Edges

When one endpoint is a container and the other is inside it (§3.2.1), the route uses the container's internal layout direction with a direct L-shaped path.

---

## 7. Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| LCA computation is O(depth²) per edge | Tree depth typically ≤ 5. Cache if profiling shows issues. |
| Straight line looks good for 2-node diagrams | Degenerate case detection (§6.5) produces a straight line. |
| Channel spread exceeds gap width | Clamp CHANNEL_SPACING (§3.3). |
| Rounded corners overshoot on short segments | r clamped to min(segment_length / 2). |
| Non-rectangular shape ports slightly off-axis | Acceptable small diagonal at shape boundary. |
| Existing edge label tests break | Expected: update test assertions for new label positions. |
| Long-span edge channels overlap with shorter edges | Known V1 limitation (§6.1). Upgrade to per-gap coordination later. |

---

## 8. What This HLD Does NOT Address

- **Edge-node avoidance**: Long-span edges may visually pass through intermediate nodes. Requires obstacle-aware routing (visibility graph or A*). Deferred.
- **Edge crossing minimization in routing phase**: Sugiyama crossing reduction handles node ordering; routing may still produce crossings. Deferred.
- **Container descendant stranding** (Overlap Fixes V3 HLD bug A): Layout bug, not routing. Fix independently.
- **Curved orthogonal edges**: This HLD uses polyline + rounded corners.
- **Mixed-direction containers**: When a child container overrides direction, cross-container edges use the LCA's direction for the entire route. Transitioning between axis orientations at container boundaries is deferred.

# PLN - Built-in Mermaid Rendering Implementation Plan

Date: 2025.12.25
Based on: wrk_docs/2025.12.25 - HLD - Built-in Mermaid Rendering.md

## Overview
This plan delivers offline Mermaid rendering in staged, testable steps, keeping the UI non-blocking and preserving existing behavior until the embedded path is verified.

## Stage 0 - Preflight and assets
Goal: lock down inputs, licensing, and build wiring before code churn.
- Select the embedded Mermaid version and add `mermaid.min.js` under `assets/vendor`.
- Verify build or runtime loading path for the JS asset and any license file requirements.
- Audit `Cargo.toml` features and dependencies for QuickJS/resvg/usvg alignment.
Deliverables:
- Mermaid asset present and loadable in a minimal harness.
- Features compile cleanly with current defaults.
Exit criteria:
- `cargo build` succeeds with assets in place.

## Stage 1 - Foundation, worker pool, and refactor
Goal: isolate Mermaid logic and add scaffolding for the new service without changing behavior.
- Create `src/mermaid_renderer.rs` with `MermaidRenderService` skeleton, request/result types, and caches.
- Add bounded queue, worker lifecycle hooks, and clean shutdown for background threads.
- Add config structs and hashing utilities for cache keys (code hash + width bucket + scale bucket).
Deliverables:
- New module and wiring in `src/markdown_renderer.rs` compile with no behavior change.
- Unit tests for hash/key stability, width/scale bucket logic, and queue backpressure.
Exit criteria:
- `cargo test` passes, no UI regressions observed in manual run.

## Stage 2 - Embedded renderer execution (QuickJS + DOM shim)
Goal: render Mermaid to SVG in-process with QuickJS on worker threads.
- Embed Mermaid JS asset loading and per-worker runtime initialization.
- Implement DOM shim stubs with required APIs and deterministic text measurement heuristic.
- Define a measurement interface that can be upgraded later with Rust-backed text metrics.
- Add Promise handling with time and memory limits per render.
- Disable fetch/XHR; stub DOMPurify; set strict security defaults.
Deliverables:
- Worker can render basic diagrams to non-empty SVG.
- Unit tests for promise handling, DOM shim smoke tests, and basic flowchart render.
Exit criteria:
- Rendering works offline for basic Mermaid examples with no UI thread blocking.

## Stage 3 - Rasterization, caching, and resource isolation
Goal: produce RGBA off UI thread and integrate caching with strict resource handling.
- Rasterize SVG to RGBA in worker using resvg/usvg; return size and buffer.
- Reuse a shared fontdb across workers to avoid repeated font scans.
- Deny external resources in the SVG resolver (no http/https, no file paths).
- Add SVG cache and texture cache keyed by hash + width/scale bucket + background mode.
- Add scale bucket invalidation on zoom changes and failed-hash cache.
- Add LRU limits for SVG and texture caches.
Deliverables:
- End-to-end render produces cached textures and displays in egui.
- Tests for cache hits/misses, zoom invalidation, and blocked external image hrefs.
Exit criteria:
- Repeated renders reuse cached textures; zoom changes re-render at new scale.

## Stage 4 - Configuration merging, security enforcement, and selection
Goal: align config merging, theme variables, and renderer selection.
- Implement mermaidAPI.initialize config merge with sanitized overrides and deterministic ID seed.
- Prefer site config over %%{init}%% directives; sanitize or drop unsafe directive keys.
- Enforce strict securityLevel by default; clamp maxTextSize; disable htmlLabels in strict mode.
Deliverables:
- Config tests cover override precedence and unsafe key rejection.
- Tests verify renderer selection and security defaults.
Exit criteria:
- All renders are offline and deterministic with safe defaults.

## Stage 5 - UI integration, fallback behavior, and docs
Goal: finalize UI behavior, errors, and documentation updates.
- Integrate placeholder UI, error display, and fallback to source code block.
- Ensure UI requests repaint on completion and remains responsive.
Deliverables:
- Manual tests confirm toggles and fallback behavior work.
Exit criteria:

## Stage 6 - Validation and polish
Goal: lock down quality and release readiness.
- Expand tests with multiple diagram types (sequence, class, state).
- Add negative tests for disabled fetch/XHR and timeout handling.
- Add sample Mermaid in `src/sample_files.rs` if needed.
- Run `cargo fmt`, `cargo clippy --all-targets -- -D warnings`, and `cargo test`.
Deliverables:
- All checks clean; README updated for user-visible changes.
Exit criteria:
- CI-equivalent checks pass and release build succeeds.

## Dependencies and notes
- Requires mermaid.min.js asset in `assets/vendor` and QuickJS integration.
- Uses resvg/usvg for rasterization; ensure feature flags match existing dependencies.
- No network calls at any stage; keep strict security defaults.

# HLD — D2 Edge Label Placement Fix V3

Date: 2026.02.22
Revision: V3 — final review pass

## Change Log

- **Original → V1:** Seven issues found in original design. Two critical: wrong perpendicular offset dimension for vertical segments, font_size plumbing error. Five moderate/minor.
- **V1 → V2:** Six additional issues found. Three moderate: `?` operator causing premature abort in nudge search, container nodes producing false positives, borrow checker conflict. Three minor: constant duplication, naming mismatch, label-vs-label limitation documented.
- **V2 → V3:** One minor issue found: `Rect::min_separation` returns `max` instead of `min` when both axes are separated, distorting the clearance metric for nudge fallback. Also tightened the function name consistency (method on `Rect`, not free function). Final review found no remaining issues.

## Scope

This design addresses **bug 1 only**: edge labels overlapping node boxes. It does **not** address bug 2 (edges routing through intermediate nodes), which is a separate edge-routing problem requiring a different fix.

## Problem Statement

Edge labels in our D2 renderer frequently overlap node boxes. Two root causes:

1. **Label position is computed from the enter segment only.** The current `compute_label_position()` (edge_routing.rs:716–744) uses the midpoint of the *last segment before the destination*, with a fixed 10px perpendicular offset. For multi-segment routes, the enter segment is typically short (the stub from the channel into the destination port), so the label lands on top of or inside the destination node.

2. **Label dimensions are not considered during placement.** The routing code emits a bare `Point` for the label center, never checking whether the label's bounding box intersects any node. The SVG renderer estimates label size at render time (svg_render.rs:623–625) but by then it's too late to move anything.

### Visual evidence

**Screenshot 1** (horizontal architecture): Labels "HTTPS", "verify", "sessions", "route", "CRUD" all overlap their destination boxes.

**Screenshot 2** (vertical platform): The "route" label between API Gateway and Service overlaps the API Gateway box.

### How D2 official handles this

D2's Dagre layout places labels at a **percentage along the total route** (default 50% = midpoint). The `lib/label` package walks the polyline to the target percentage of total arc length, then offsets perpendicular. Labels end up in the inter-rank gap where there is space.

## All Issues Found Across Reviews

| # | Severity | Issue | Resolution |
|---|----------|-------|------------|
| 1 | Critical | Wrong dimension for perpendicular offset on vertical segments | Use `label_width` for vertical, `label_height` for horizontal |
| 2 | Critical | `font_size` not available via `RenderOptions` | Pass `font_size` + `font_family` from `layout()` directly |
| 3 | Moderate | Self-loop labels missing `label_width`/`label_height` | Measure and store in self-loop branch |
| 4 | Moderate | Nudge algorithm underspecified | Center-out candidate search with 9 percentages |
| 5 | Moderate | Endpoint nodes unconditionally excluded from nudge | Check all leaf nodes; skip nudge for 2-point routes |
| 6 | Minor | `rects_intersect` utility not defined | Add `Rect::intersects` to `geo.rs` |
| 7 | Minor | Measurement height mismatch (1.4× vs 1.2×) | Both now use stored dims from `measure_and_wrap_label` |
| 8 | Moderate | `?` in nudge search causes premature abort | Use `match`/`continue` |
| 9 | Moderate | Container nodes produce false positives in nudge | Skip containers (check leaf nodes only) |
| 10 | Moderate | Borrow checker: can't iterate edges and mutate | Clone edge indices before iterating |
| 11 | Minor | Halo padding constant duplicated across files | Shared `LABEL_HALO_PADDING` constant |
| 12 | Minor | `min_separation` function name mismatch | Method on `Rect`: `rect.min_separation(other)` |
| 13 | Minor | `min_separation` returns `max` when both axes separated | Three-branch logic: both-sep, one-sep, both-overlap |

## Design

### Change 1: Percentage-along-route placement

Replace the enter-segment heuristic with **percentage-of-total-arc-length**.

```rust
/// Padding between label edge and route line (pixels).
const LABEL_PADDING: f64 = 4.0;

/// Compute label position at a percentage along total route arc length.
/// Returns the label center point, offset perpendicular to the segment.
fn compute_label_position(
    route: &[Point],
    percentage: f64,
    label_width: f64,
    label_height: f64,
) -> Option<Point> {
    if route.len() < 2 {
        return None;
    }

    // 1. Compute segment lengths and total.
    let mut seg_lengths: Vec<f64> = Vec::with_capacity(route.len() - 1);
    let mut total = 0.0;
    for i in 0..route.len() - 1 {
        let len = route[i].distance_to(&route[i + 1]);
        seg_lengths.push(len);
        total += len;
    }

    if total < 1e-6 {
        return Some(route[0]);
    }

    // 2. Walk to target distance.
    let target = total * percentage.clamp(0.0, 1.0);
    let mut accumulated = 0.0;

    for (i, &seg_len) in seg_lengths.iter().enumerate() {
        if accumulated + seg_len >= target || i == seg_lengths.len() - 1 {
            let t = if seg_len > 1e-6 {
                (target - accumulated) / seg_len
            } else {
                0.5
            };
            let a = route[i];
            let b = route[i + 1];
            let px = a.x + (b.x - a.x) * t;
            let py = a.y + (b.y - a.y) * t;

            // 3. Axis-aware perpendicular offset.
            let dx = b.x - a.x;
            let dy = b.y - a.y;

            return if dx.abs() > dy.abs() {
                // Horizontal segment → offset upward by half label height
                let offset = (label_height / 2.0) + LABEL_PADDING;
                Some(Point::new(px, py - offset))
            } else {
                // Vertical segment → offset leftward by half label width
                let offset = (label_width / 2.0) + LABEL_PADDING;
                Some(Point::new(px - offset, py))
            };
        }
        accumulated += seg_len;
    }

    None
}
```

**Default percentage: 0.5.** For a 4-point route (port → bend → bend → port), 50% lands on the channel segment — the inter-rank gap where no nodes live. For 2-point routes, 50% is equidistant from both nodes.

### Change 2: Label bounding box stored on edge data

Add to `D2EdgeData` in `graph.rs`:

```rust
pub label_width: f64,     // estimated label width (pixels), 0.0 if unlabeled
pub label_height: f64,    // estimated label height (pixels), 0.0 if unlabeled
```

Initialize to `0.0` at the construction site in `compiler.rs` (line 295).

Compute during routing using per-edge font size:

```rust
let fs = graph.graph[eidx].style.font_size.unwrap_or(default_font_size);
let m = crate::text::measure_and_wrap_label(label_text, fs, font_family);
```

`measure_and_wrap_label` uses `CHAR_WIDTH_FACTOR = 0.55` and `LINE_HEIGHT_FACTOR = 1.4` (ignores `font_family` — the `_font_family` parameter is unused). The SVG renderer will use the stored dimensions instead of re-estimating, ensuring consistency.

### Change 3: Post-placement overlap nudge

After all labels are positioned, a nudge pass fixes remaining overlaps.

```rust
/// Padding around label text for the background halo (pixels).
/// Shared between edge_routing (nudge) and svg_render (halo rect).
pub(crate) const LABEL_HALO_PADDING: f64 = 3.0;

fn nudge_overlapping_labels(graph: &mut D2Graph) {
    // Collect leaf node rects only (containers produce false positives).
    let node_rects: Vec<(NodeIndex, Rect)> = graph.objects.iter()
        .filter(|&&idx| idx != graph.root)
        .filter(|&&idx| !graph.graph[idx].is_container)
        .filter_map(|&idx| graph.graph[idx].box_.map(|r| (idx, r)))
        .collect();

    // Clone to avoid borrow conflict with mutation below.
    let edge_indices: Vec<EdgeIndex> = graph.edges.clone();

    for &eidx in &edge_indices {
        let pos = match graph.graph[eidx].label_position {
            Some(p) => p,
            None => continue,
        };
        let lw = graph.graph[eidx].label_width;
        let lh = graph.graph[eidx].label_height;
        if lw < 1.0 || lh < 1.0 { continue; }

        let route = graph.graph[eidx].route.clone();

        // 2-point routes have nowhere to slide — skip.
        if route.len() <= 2 { continue; }

        let label_rect = Rect::new(
            pos.x - lw / 2.0 - LABEL_HALO_PADDING,
            pos.y - lh / 2.0 - LABEL_HALO_PADDING,
            lw + LABEL_HALO_PADDING * 2.0,
            lh + LABEL_HALO_PADDING * 2.0,
        );

        let has_overlap = node_rects.iter().any(|(_, nr)| label_rect.intersects(nr));
        if !has_overlap { continue; }

        if let Some(new_pos) = find_best_label_position(&route, lw, lh, &node_rects) {
            graph.graph[eidx].label_position = Some(new_pos);
        }
    }
}

fn find_best_label_position(
    route: &[Point],
    label_width: f64,
    label_height: f64,
    node_rects: &[(NodeIndex, Rect)],
) -> Option<Point> {
    // Center-out search: prefer positions near route midpoint.
    let candidates = [0.5, 0.4, 0.6, 0.3, 0.7, 0.2, 0.8, 0.15, 0.85];

    let mut best_pos: Option<Point> = None;
    let mut best_clearance: f64 = f64::NEG_INFINITY;

    for &pct in &candidates {
        let pos = match compute_label_position(route, pct, label_width, label_height) {
            Some(p) => p,
            None => continue, // skip failed candidate, try next
        };

        let lr = Rect::new(
            pos.x - label_width / 2.0 - LABEL_HALO_PADDING,
            pos.y - label_height / 2.0 - LABEL_HALO_PADDING,
            label_width + LABEL_HALO_PADDING * 2.0,
            label_height + LABEL_HALO_PADDING * 2.0,
        );

        let overlaps = node_rects.iter().any(|(_, nr)| lr.intersects(nr));
        if !overlaps {
            return Some(pos); // First non-overlapping position wins
        }

        // Track clearance for fallback (choose the least-bad position).
        let min_clearance = node_rects.iter()
            .map(|(_, nr)| lr.min_separation(nr))
            .fold(f64::INFINITY, f64::min);
        if min_clearance > best_clearance {
            best_clearance = min_clearance;
            best_pos = Some(pos);
        }
    }

    best_pos
}
```

**Design rationale:**
- Center-out search (0.5, 0.4, 0.6, ...) prefers positions near the route midpoint.
- 9 fixed candidates avoids continuous sliding and segment boundary complexity.
- `match`/`continue` instead of `?` — one bad candidate doesn't abort the search.
- If no candidate is overlap-free, returns the one with maximum clearance (graceful degradation).
- Leaf nodes only — containers excluded to avoid false positives.
- Edge indices cloned before iteration (borrow checker).
- 2-point routes skipped (no alternative positions exist).

### Change 4: Perpendicular offset scales with label dimensions (axis-aware)

Integrated into `compute_label_position`. Replace `LABEL_OFFSET = 10.0` with:
- Horizontal segment: `(label_height / 2) + LABEL_PADDING` → vertical clearance
- Vertical segment: `(label_width / 2) + LABEL_PADDING` → horizontal clearance

## Detailed File Changes

### `crates/d2/src/geo.rs`

Add `intersects` and `min_separation` to `Rect`:

```rust
impl Rect {
    /// Test whether two rectangles overlap (strict intersection, not touching).
    pub fn intersects(&self, other: &Rect) -> bool {
        self.x < other.right()
            && self.right() > other.x
            && self.y < other.bottom()
            && self.bottom() > other.y
    }

    /// Minimum axis-aligned separation between two rects.
    /// Returns positive when separated, negative when overlapping.
    /// Used by the nudge pass to compare candidate label positions.
    pub fn min_separation(&self, other: &Rect) -> f64 {
        let sep_x = if self.right() <= other.x {
            other.x - self.right()
        } else if other.right() <= self.x {
            self.x - other.right()
        } else {
            -(self.right().min(other.right()) - self.x.max(other.x))
        };

        let sep_y = if self.bottom() <= other.y {
            other.y - self.bottom()
        } else if other.bottom() <= self.y {
            self.y - other.bottom()
        } else {
            -(self.bottom().min(other.bottom()) - self.y.max(other.y))
        };

        if sep_x >= 0.0 && sep_y >= 0.0 {
            // Separated on both axes: return the tightest gap.
            sep_x.min(sep_y)
        } else if sep_x >= 0.0 || sep_y >= 0.0 {
            // Separated on one axis only (no intersection): return the positive gap.
            sep_x.max(sep_y)
        } else {
            // Overlapping on both axes: return the least-negative (closest to separating).
            sep_x.max(sep_y)
        }
    }
}
```

### `crates/d2/src/graph.rs`

Add two fields to `D2EdgeData`:

```rust
pub struct D2EdgeData {
    pub label: Option<String>,
    pub src_arrow: ArrowheadType,
    pub dst_arrow: ArrowheadType,
    pub style: Style,
    pub route_type: RouteType,
    pub route: Vec<Point>,
    pub label_position: Option<Point>,
    pub label_width: f64,     // NEW
    pub label_height: f64,    // NEW
}
```

### `crates/d2/src/compiler.rs`

Update construction site (~line 295):

```rust
let edge_data = D2EdgeData {
    label,
    src_arrow,
    dst_arrow,
    style: Style::default(),
    route_type: RouteType::Bezier,
    route: Vec::new(),
    label_position: None,
    label_width: 0.0,     // NEW
    label_height: 0.0,    // NEW
};
```

### `crates/d2/src/edge_routing.rs`

1. **Constants:**
   - Remove `LABEL_OFFSET`
   - Add `LABEL_PADDING: f64 = 4.0` (private)
   - Add `pub(crate) LABEL_HALO_PADDING: f64 = 3.0`

2. **`route_all_edges` signature and self-loop handling:**

```rust
pub fn route_all_edges(graph: &mut D2Graph, font_size: f64, font_family: &str) {
    let edge_indices: Vec<EdgeIndex> = graph.edges.clone();
    let mut non_self_loops: Vec<EdgeIndex> = Vec::new();

    for &eidx in &edge_indices {
        let (src_idx, dst_idx) = match graph.graph.edge_endpoints(eidx) {
            Some(endpoints) => endpoints,
            None => continue,
        };

        if src_idx == dst_idx {
            // Self-loop: Bézier route (unchanged)
            let src_rect = match graph.graph[src_idx].box_ {
                Some(r) => r,
                None => continue,
            };
            let src_center = src_rect.center();
            let route = self_loop_route(&src_rect);
            let label_pos = Some(Point::new(
                src_center.x + src_rect.width * 0.6,
                src_center.y - src_rect.height * 0.6,
            ));
            graph.graph[eidx].route = route;
            graph.graph[eidx].label_position = label_pos;

            // NEW: measure and store label dimensions
            if let Some(ref label_text) = graph.graph[eidx].label {
                let fs = graph.graph[eidx].style.font_size.unwrap_or(font_size);
                let m = crate::text::measure_and_wrap_label(label_text, fs, font_family);
                graph.graph[eidx].label_width = m.width;
                graph.graph[eidx].label_height = m.height;
            }
        } else {
            non_self_loops.push(eidx);
        }
    }

    route_orthogonal_edges(graph, &non_self_loops, font_size, font_family);
    nudge_overlapping_labels(graph);
}
```

3. **`route_orthogonal_edges`** — add font params, update label placement:

```rust
fn route_orthogonal_edges(
    graph: &mut D2Graph,
    edge_indices: &[EdgeIndex],
    font_size: f64,
    font_family: &str,
) {
    // ... existing Pass 1 (classify), Pass 2 (allocate channels/ports) ...

    // Pass 3: Build routes and compute labels
    for ec in &classified {
        let src_rect = graph.graph[ec.src].box_.unwrap();
        let dst_rect = graph.graph[ec.dst].box_.unwrap();
        let route = build_route(ec, &src_rect, &dst_rect);

        let (label_pos, label_w, label_h) =
            if let Some(ref text) = graph.graph[ec.edge_idx].label {
                let fs = graph.graph[ec.edge_idx].style.font_size.unwrap_or(font_size);
                let m = crate::text::measure_and_wrap_label(text, fs, font_family);
                let pos = compute_label_position(&route, 0.5, m.width, m.height);
                (pos, m.width, m.height)
            } else {
                (None, 0.0, 0.0)
            };

        graph.graph[ec.edge_idx].route = route;
        graph.graph[ec.edge_idx].route_type = RouteType::Orthogonal;
        graph.graph[ec.edge_idx].label_position = label_pos;
        graph.graph[ec.edge_idx].label_width = label_w;
        graph.graph[ec.edge_idx].label_height = label_h;
    }
}
```

4. **Replace `compute_label_position`** (see Change 1).

5. **Add `nudge_overlapping_labels` and `find_best_label_position`** (see Change 3).

### `crates/d2/src/svg_render.rs`

```rust
use crate::edge_routing::LABEL_HALO_PADDING;

// In edge label rendering (~line 622), replace:
//   let char_width = font_size * 0.55;
//   let label_width = label.chars().count() as f64 * char_width;
//   let label_height = font_size * 1.2;
//   let pad = 3.0;
// With:
let label_width = if edge.label_width > 0.0 {
    edge.label_width
} else {
    label.chars().count() as f64 * font_size * 0.55
};
let label_height = if edge.label_height > 0.0 {
    edge.label_height
} else {
    font_size * 1.2
};
let pad = LABEL_HALO_PADDING;
```

### `crates/d2/src/layout.rs`

```rust
// Line 53 — before:
edge_routing::route_all_edges(graph);

// After:
edge_routing::route_all_edges(graph, font_size, font_family);
```

Both variables are already in scope in `layout()`.

## Test Plan

### Existing tests to update

Structural invariants hold; specific coordinate values may shift:

- `test_label_between_nodes` — y between a.bottom and b.top ✓
- `test_label_between_nodes_horizontal` — x between a.right and b.left ✓
- `test_ortho_label_horizontal` — offset direction unchanged, magnitude increases
- `test_ortho_label_vertical` — offset direction unchanged, magnitude changes
- `test_ortho_labels_spread` — distance invariant holds

### New tests

| Test | What it verifies |
|------|-----------------|
| `test_rect_intersects` | `Rect::intersects`: overlapping, touching, separated, nested |
| `test_rect_min_separation` | `Rect::min_separation`: positive, zero, negative |
| `test_label_at_route_midpoint` | 4-point route: label at 50% arc length, not enter segment |
| `test_label_offset_horizontal` | Horizontal segment: offset ≥ `label_height / 2` |
| `test_label_offset_vertical` | Vertical segment: offset ≥ `label_width / 2` |
| `test_label_no_node_overlap` | Architecture diagram: no label overlaps any leaf node |
| `test_label_dimensions_stored` | All labeled edges: `label_width > 0`, `label_height > 0` |
| `test_self_loop_label_dimensions` | Self-loop: dimensions stored |
| `test_nudge_finds_clear_position` | Tight layout: nudge finds non-overlapping position |
| `test_parallel_labels_no_overlap` | Two labeled edges in same gap: labels don't overlap each other |

## Known Limitations

1. **Label-vs-label overlap:** Not detected. Mitigated by channel spreading (parallel edges get different routes). Follow-up if conformance tests surface real cases.

2. **Container title overlap:** Labels inside containers could overlap container title text. Requires container title dimension tracking (out of scope).

3. **2-point route tight gaps:** If gap is too small for the label, no nudge is possible. Fix requires increased inter-node spacing (layout concern, separate design).

## Risk Assessment

**Low risk.** Changes confined to `label_position`, `label_width`, `label_height` on `D2EdgeData`. Node positions, edge waypoints, SVG structure unaffected.

**Performance:** Arc-length walk O(P) per edge (P=2–4 typical). Nudge O(E × 9 × N) for overlapping edges only. Negligible < 1000 elements.

## Implementation Order

1. `geo.rs`: Add `Rect::intersects` + `Rect::min_separation` + unit tests
2. `graph.rs`: Add `label_width` / `label_height` fields
3. `compiler.rs`: Initialize new fields to `0.0`
4. `edge_routing.rs`: Replace constants (`LABEL_OFFSET` → `LABEL_PADDING` + `LABEL_HALO_PADDING`)
5. `layout.rs` + `edge_routing.rs`: Change `route_all_edges` signature, thread font params
6. `edge_routing.rs`: Replace `compute_label_position` with arc-length version **(primary fix)**
7. `edge_routing.rs`: Update self-loop handling to store label dimensions
8. `svg_render.rs`: Use stored dimensions + shared halo constant
9. `edge_routing.rs`: Add `nudge_overlapping_labels` + `find_best_label_position`
10. Update existing tests, add new tests
11. Visual verification against screenshot scenarios

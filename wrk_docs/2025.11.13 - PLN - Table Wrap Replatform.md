# Implementation Plan - Table Wrap Replatform (Revised)

**Date:** 2025-11-13  
**Author:** Codex (autogen)  
**Source HLD:** wrk_docs/2025.11.13 - HLD - Table Wrap Replatform.md

---

## Stage 0 – Preparatory Work (1 day)
- [ ] Confirm flag plumbing (--table-wrap, --no-table-wrap, View menu toggle) routes code through a single branch so we can swap the renderer cleanly.
- [ ] Introduce helper modules (e.g., column_spec.rs, 	able_metrics.rs) so column policies and row metrics live outside markdown_renderer.rs.
- [ ] Add structs for telemetry/caching (TableLayoutCache, RowMetrics, CacheStats).
- [ ] Ensure egui_extras is imported everywhere we need TableBuilder (update Cargo features if necessary).

Exit criteria: new scaffolding compiles, existing tests remain green, no behavior change yet.

---

## Stage 1 – Column Policy & Spec Layer (1–2 days)
1. Implement ColumnPolicy + ColumnSpec { column: Column, ident: String, policy_hash: u64, tooltip: Option<String> }.
2. Write n derive_column_specs(headers: &[Vec<InlineSpan>]) -> Vec<ColumnSpec>:
   - Classify columns (numeric/date/text) using header heuristics.
   - Map to default Column descriptors (exact, initial, emainder, esizable).
   - Attach tooltips describing wrap/clip status for QA help.
3. Unit tests:
   - Header classification (e.g., ["Version", "Changes"] → expected policies).
   - Policy hash stability/uniqueness.
4. Document extension points for future CLI/config overrides.

Exit criteria: derive_column_specs unit tests pass; renderer still uses legacy grid.

---

## Stage 2 – TableBuilder Skeleton (2 days)
1. Behind 	able_wrap_overhaul_enabled, replace the egui::Grid rendering with TableBuilder scaffolding: TableBuilder::new(ui).striped(true)....
2. Call 	able.column(spec.column.clone()) once per column.
3. Implement header builder using 	able.header(HEADER_HEIGHT, |mut header| { header.col(|ui| render_cell(None, ci, header_spans)) }).
4. Implement body builder stub: 	able.body(|mut body| body.rows(row_count, |mut row| { row.row(fallback_height, |mut row_ui| row_ui.col(|ui| legacy_cell_render(...))) })). Keep legacy cell renderer temporarily to isolate layout regressions.
5. Introduce RowMetrics vector with fallback heights.
6. Ensure --no-table-wrap toggles the legacy grid (for QA fallback).

Checks:
- Manual regression screenshot verifying headers/body render via TableBuilder even though wrapping logic is still legacy.
- cargo test remains green.

Exit criteria: TableBuilder scaffolding in place; wrapping still handled by old code but controlled via flag.

---

## Stage 3 – Cell Rendering & Cache Integration (2–3 days)
1. Update ender_table_cell to assume TableBuilder-provided widths (ui.max_rect().width()), removing set_width hacks.
2. Extend CellLayoutCache keys with policy_hash, rounded width_px, and row index; include is_header flag.
3. On cache miss: build LayoutJob, compute galley_height, update RowMetrics[row].max_height. Store job + metrics.
4. On hit: reuse job/height without re-layout.
5. Respect clipped columns via Column::clip(true); apply extra clipping only for oversized inline widgets (images/emojis).
6. Update status telemetry (hits/misses + new “rows rendered vs total” counter).

Tests:
- Unit tests covering cache invalidation when column width/policy changes or highlight toggles.
- Manual QA on regression doc at multiple widths; confirm text wraps/links/highlights render correctly.

Exit criteria: TableBuilder cells use LayoutJobs exclusively, cache is keyed correctly, QA sample passes visual inspection.

---

## Stage 4 – Row Virtualization & Height Accuracy (2 days)
1. Implement row height tracking: whenever any cell in row i re-layouts, recompute RowMetrics[i].max_height and mark dirty.
2. Update TableBuilder body to fetch ow.index(), read the latest height (fallback to body font line height + padding if stale), and call ow.row(height, |mut row_ui| ...) to render only visible rows.
3. Add instrumentation counters (ows_rendered, ows_total, cache stats) for QA.
4. Validate with large synthetic markdown (>= 500 rows) to ensure virtualization behaves.

Tests:
- Headless benchmark confirming only visible rows trigger ender_cell (use instrumentation to assert rendered rows ≈ viewport rows).
- Manual QA: scroll large doc, verify smoothness + accurate telemetry.

Exit criteria: virtualization working, row heights stable during scroll, large docs performant.

---

## Stage 5 – Polish & Cleanup (1 day)
1. Confirm --no-table-wrap still forces the legacy grid; log a deprecation warning to encourage QA to stay on TableBuilder.
2. Update README/QA docs with TableBuilder guidance (column resizing, virtualization) and capture before/after screenshots.
3. Decide on schedule to remove legacy grid; file follow-up ticket if not removed immediately.
4. Optional: add MDMDVIEW_TABLE_WRAP_TAFFY=1 debug fallback.

Exit criteria: documentation/tests updated; feature ready for release candidate.

---

## Testing & Validation Summary
- **Unit:** derive_column_specs, cache invalidation logic, row metrics math.
- **Integration:** headless renders verifying wrapping, column resizing, virtualization metrics.
- **Manual:** regression table (narrow/wide), large dataset, light/dark themes, CLI toggles, column resizing if enabled.

---

## Rollout Checklist
1. Merge TableBuilder path behind existing flag; keep --no-table-wrap fallback until QA sign-off.
2. Run full regression suite + cargo clippy --all-targets -- -D warnings before default-on release.
3. Collect QA artifacts (screenshots, cache metrics, large-doc perf) and update release notes.
4. After burn-in, remove legacy grid path and retire fallback flag.

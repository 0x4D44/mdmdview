# Implementation Plan — Table Column Stabilization & Divider Alignment (Revised)

**Plan Date:** 2025-11-14  
**Linked HLD:** `wrk_docs/2025.11.14 - HLD - Table Column Fixes.md`

## Stage 0 – Preparation & Baseline
**Purpose:** ensure tracking, measurement, and branching are in place before touching code.

- [ ] File tracking issue referencing the HLD, screenshot, and regression markdown.
- [ ] Capture BEFORE screenshots + column width measurements (100% & 125% DPI) for the threat-model table.
- [ ] Create feature branch `feat/table-column-fixes` and enable `table_wrap_overhaul` for local testing.
- **Exit criteria:** issue + branch exist, baseline artifacts stored under `/wrk_docs/baselines/2025-11-14/` (screenshots + notes).

## Stage 1 – Column Context & Stats Plumbing
**Goal:** feed `derive_column_specs` with context (font scale, table id, sampled stats).

Tasks:
1. Introduce `TableColumnContext { headers, rows, body_font_px, table_id }`.
2. Implement `compute_column_stats(rows, max_samples=128)` returning per-column metrics (max text width in ems, longest unbroken word, emoji/image flags).
3. Cache stats per `table_id` + `content_hash`; invalidate when markdown changes.
4. Update `derive_column_specs` signature + call sites (renderer tests, docs) and adjust unit tests.
5. Micro-benchmark stats collection; capture numbers in issue comment.

Dependencies: Stage 0.

Exit Criteria:
- `cargo test column_spec` green with new signature.
- Stats cache proves <1 ms overhead on sample tables (document measurement).

## Stage 2 – Heuristic Rewrite & DPI Scaling
**Goal:** apply semantic + statistical rules, include user-resize persistence, remove magic pixel constants.

Tasks:
1. Add helper `fn px(body_px: f32, factor: f32) -> f32` and replace fixed widths.
2. Encode rule order per HLD: metadata fixed, description resizable, examples remainder, fallback to widest column.
3. Introduce `persisted_column_widths: HashMap<u64, f32>` inside metrics; seed `Column::initial()`/`at_least()` with stored values and update map when egui reports drag resizes.
4. Extend tooltips to display semantic rule + computed px width.
5. Update/expand unit tests covering: remainder assignment, stats override, DPI scaling, persistence serialization.

Dependencies: Stage 1 (context/stats available).

Exit Criteria:
- `cargo test column_spec` + new persistence tests pass.
- Manual verification (threat-model markdown) shows Examples column wider than Description at both 100% and 125% DPI with table wrap enabled.

## Stage 3 – Metrics Refactor & Table Identity
**Goal:** store per-table metrics (rows + widths) and isolate data between files.

Tasks:
1. Define `TableMetrics` struct: `{ rows: Vec<RowMetric>, resolved_widths: Vec<f32>, last_width_frame: u64, last_discard_frame: Option<u64>, persisted_column_widths: HashMap<u64, f32> }`.
2. Maintain `HashMap<table_id, TableMetrics>`; compute `table_id = hash(headers, row_count, file_path?)` each render.
3. Update row-height code to read/write through the per-table entry.
4. Ensure `clear_table_layout_cache`, font changes, or toggling table wrap resets the table map.
5. Add unit tests for `update_widths`, discard throttling, and persistence map behavior.

Dependencies: Stage 1 (table context) and Stage 2 (persistence).

Exit Criteria:
- Metrics tests pass.
- Switching between two markdown docs preserves independent column widths (manual check recorded in issue).

## Stage 4 – Renderer Updates (Widths, Dividers, Jitter Control)
**Goal:** integrate widths into the renderer, adjust spacing, paint stable dividers, and handle request/discard.

Tasks:
1. After `body.heterogeneous_rows`, call `let widths = body.widths().to_vec();` and pass to `TableMetrics::update_widths`. Store last stable widths for display.
2. Apply spacing tweaks: `table.cell_padding = Vec2::splat(6.0)`, `ui.spacing_mut().item_spacing = vec2(4.0, 2.0)` before rendering cells.
3. Implement `paint_table_dividers(body_ui, widths, visuals, clip_rect)` to draw interior lines + outer border using visuals-derived stroke.
4. Handle `WidthChange::Large` by calling `ctx.request_discard("table-width-settle")` with guard against duplicate same-frame requests; reuse previous widths while waiting.
5. Honor `
6. Add automated check (integration test or debug flag) to confirm `resolved_widths` vector length equals column count.

Dependencies: Stage 2 & 3.

Exit Criteria:
- Manual run on regression markdown shows aligned dividers while resizing/scrolling.
- Env flag disables dividers without affecting column widths.
- Integration test verifying `resolved_widths[examples] >= resolved_widths[description]` passes.

## Stage 5 – QA, Docs, and Release Prep
**Goal:** document the feature, add regression artifacts, and ensure CI cleanliness.

Tasks:
1. Add markdown sample replicating threat-model table (`examples/regressions/table-threat-model.md`).
2. Update `docs/QA-table-wrap.md`, README advanced features, and release notes draft with divider + DPI-aware sizing details and env flag instructions.
3. Produce manual QA checklist (DPI variations, window resize, table wrap toggle, env flag) and store in repo.
4. Run `cargo fmt`, `cargo clippy --all-targets -D warnings`, `cargo test`; attach logs to PR.
5. Capture AFTER screenshots (same angles as Stage 0) and include in PR summary.

Dependencies: Stages 1–4 complete.

Exit Criteria:
- Docs reviewed/approved; QA checklist signed.
- CI + lint/test suite green.
- PR includes before/after evidence.

## Stage 6 – Rollout & Monitoring
**Goal:** deliver feature safely and watch for regressions.

Tasks:
1. Merge feature branch once code review completes.
2. Publish release-note entry under “Table Rendering” with screenshot + env flag mention.
3. Monitor issue tracker for two weeks; if regressions arise, instruct affected users to set `
4. Close tracking issue once monitoring window passes without new bugs.

Dependencies: Stage 5.

Exit Criteria:
- Merge completed; release notes updated.
- Monitoring log shows no unresolved regressions after two weeks.


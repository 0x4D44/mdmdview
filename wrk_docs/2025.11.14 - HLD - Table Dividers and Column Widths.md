# HLD — Table Divider Alignment & Column Width Corrections

**Date:** 2025-11-14  
**Owner:** Codex  
**Related Artifacts:** README.md, docs/QA-table-wrap.md, examples/regressions/table-threat-model.md

## 1. Summary
User feedback (see screenshot 2025-11-14 121230.png) shows the overhauled table renderer still produces misaligned vertical dividers and assigns the widest width to the wrong column (Description instead of Examples). This document proposes deterministic divider rendering and smarter column-sizing heuristics inspired by open-source egui table implementations (e.g., rerun-io/egui_table, lovasoa/egui-selectable-table).

## 2. Problem Statement
1. **Dividers overlay text or vanish.** We currently rely on alternating row backgrounds provided by `TableBuilder`. When column widths fluctuate from wrapping or DPI rounding, the only visible “divider” is the stripe edge, which often appears in the wrong column or runs through text.
2. **Column widths skewed.** `derive_column_specs` marks Description/Summary as the first `Remainder` column, so it absorbs leftover width. Examples columns fall back to a resizable policy capped at ~200 px, yielding the opposite of the expected layout in threat-model tables.

## 3. Goals & Non-goals
- **Goals**
  - Paint stable, theme-aware divider lines after `TableBuilder` resolves the actual column widths so they never overlap glyphs.
  - Update column heuristics to favor Examples (or data-heavy columns) for the remainder width, with DPI-aware defaults and content-based overrides.
  - Persist user-driven column resizes via `TableMetrics` so manual adjustments survive rerenders.
- **Non-goals**
  - No sticky headers or horizontal scrolling changes.
  - No new runtime toggles beyond the existing View > Table Wrap switch.

## 4. Current State Analysis
| Area | Current Behavior | Issue |
|------|------------------|-------|
| Divider rendering | No explicit dividers; only row striping from egui. | Striped edge can appear mid-cell or only once per table, giving the “single line” bug. |
| Column heuristics | Description/Summary becomes `Remainder`; Examples becomes resizable `~200 px`. | Wide text ends up in Description while Examples stays cramped. |
| DPI handling | Fixed pixel widths (120/150/200). | At 125% DPI Description rounds up, Examples rounds down: off-by-one behavior. |
| User resizes | Not persisted; every render reverts to heuristics. | Manual adjustments vanish on scroll or reopen. |
| Metrics | `TableMetrics` only tracks row heights, not column widths/table IDs. | No place to store resolved widths or per-table state. |

## 5. Proposed Design
### 5.1 Data & Context Plumbing
- Introduce `TableColumnContext { headers, rows, stats, body_font_px, table_id }`.
- Implement `compute_column_stats(rows, max_samples=128)` capturing grapheme counts, longest word, and rich-content flags per column. Cache stats per table (table ID derived from header hashes + row count) with a content hash to avoid rescans unless the table changes.
- Extend `TableMetrics` to store `resolved_widths: Vec<f32>`, `persisted_column_widths: HashMap<u64, f32>`, `last_width_frame`, and `last_discard_frame` so width changes can be detected per table.

### 5.2 Column Heuristic Rewrite
1. **Semantic priority**
   - Headers containing “examples/sample/use case” ⇒ `ColumnPolicy::Remainder { clip: false }`.
   - Headers containing “description/details/summary/notes” ⇒ `ColumnPolicy::Resizable { min = 12 × body_font, preferred = 18 × body_font }`.
   - Metadata columns (“id/version/status/date/author”) keep fixed/resizable hints but widths scale with `body_font_px`.
2. **Content-aware fallback**
   - If no header claims remainder, choose the column with the highest `max_graphemes + 2 × longest_word` from stats and assign remainder (skipping fixed columns).
3. **User resize persistence**
   - When `TableBuilder` reports new resolved widths, compare resizable columns against their persisted widths with an epsilon (≈0.5 px). If delta > ε, store the new width; seed future renders via `Column::initial()`.

### 5.3 Divider Rendering
1. **Capture widths** — After `body.heterogeneous_rows` finishes, call `let widths = body.widths().to_vec();` and store them in `TableMetrics::resolved_widths` via `update_widths(table_id)` to detect large shifts.
2. **Spacing** — Before rendering cells, set `ui.spacing_mut().item_spacing.x = 6.0` to guarantee glyph padding away from dividers.
3. **Overlay painting** — After rows are done, compute cumulative x-positions over `body.max_rect()`. Paint dividers via `painter.vline(x.round() + 0.5, rect.y_range(), separator_stroke)` and draw an outer border using `ui.visuals().window_stroke()`. Clip to `body.clip_rect()` so lines don’t leak into scrollbars.
4. **Jitter control** — If `update_widths` reports a “large” change (>0.75 px), call `ui.ctx().request_repaint()` once per frame to settle widths before painting.

### 5.4 Metrics & APIs
- `TableMetricEntry` gains methods `update_widths(&mut self, widths, frame_id) -> WidthChange`, `persisted_width(&self, hash)`, and `set_persisted_width(hash, width)`.
- `TableMetrics` now exposes `entry_mut(table_id)` / `entry(table_id)` and `totals()` for stats UI.
- Clearing the table layout cache wipes both layout and metrics maps so new documents start fresh.

### 5.5 QA & Tooling
- Regression sample: `examples/regressions/table-threat-model.md` reproduces the threat-model table from the screenshot.
- README “Column-Aware Tables” bullet points users to that sample.
- QA checklist (docs/QA-table-wrap.md) includes DPI sweeps, manual resize persistence, and screenshot capture steps.

## 6. Implementation Plan (High Level)
1. **Context + Metrics plumbing** (Stage 1/3): add column stats cache, table IDs, and per-table metrics data structures.
2. **Heuristic rewrite** (Stage 2): update `derive_column_specs` to consume `TableColumnContext`, apply new semantic rules, and use stats for fallback remainder selection.
3. **Renderer updates** (Stage 4): integrate stats context, capture `body.widths()`, update metrics, persist user resizes, and paint dividers.
4. **Docs & regression** (Stage 5): document the new sample, QA steps, and update README.

## 7. Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|------------|
| Divider overlay conflicts with user themes | Low | Use colors from `ui.visuals()` so dark/light modes stay consistent. |
| Width-change repaint loop | Medium | Only request repaint when delta > 0.75 px and throttle via `last_discard_frame`. |
| Stats collection overhead on huge tables | Low | Sample at most 128 rows; cache by content hash to avoid rescans. |
| Persisted widths drift after font/DPI changes | Medium | Clamp persisted widths to `>= min`, and reset metrics when font DPI changes or cache cleared. |

## 8. Testing Strategy
- **Unit tests:** `column_spec` (Examples remainder, stats fallback, DPI scaling), `table_support::metrics` (width-change thresholds, persistence map), renderer tests ensuring width order is correct via `TableMetrics`.
- **Manual QA:** Follow the new checklist with `examples/regressions/table-threat-model.md` at 100/125/150% DPI, verifying dividers and column sizing. Capture screenshots for release notes.
- **Performance:** Scroll through large tables and monitor the cache tooltip; ensure dividers don’t cause noticeable frame drops.

## 9. Rollout
1. Land code + tests on `feat/table-column-fixes`.
2. Update docs/README/regression sample in the same PR.
3. Capture before/after screenshots for the release notes.
4. Monitor feedback post-release; if users report GPU issues, consider an env flag to disable dividers (but default on).

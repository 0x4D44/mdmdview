# HLD: D2 Edge Label Placement Overhaul (V4)

**Date:** 2026-02-22
**Status:** Draft
**Scope:** `crates/d2/src/edge_routing.rs`, `crates/d2/src/svg_render.rs`
**Supersedes:** V1, V2, V3 (same date)

## Changes from V3

| # | Issue in V3 | Resolution in V4 |
|---|-------------|-------------------|
| 1 | "SQL queries" near-edge gap shown as -3px — actual is -2.5px (width=84.7, gap=40-42.35=-2.35) | Corrected table values using exact widths |
| 2 | "This is a very long label" shown as 26 chars — actual count is 25 | Corrected char count; marked row as illustrative (not a real fixture label) |
| 3 | `label_overshoot` takes `&Option<Rect>` — not idiomatic Rust | Changed to take `&Rect` directly; `node_bounds` is always `Some` at the call site since the `node_rects.is_empty()` early return already fired |
| 4 | `label_overshoot` duplicates the padded-rect computation from `label_bounding_rect` | Refactored to call `label_bounding_rect` and use its output |
| 5 | Fix C cliff behavior (1px width increase → 40px position jump) undocumented in Risks | Added explicit risk entry with worked example |
| 6 | Conformance analysis only covers 3 specific fixtures — fixture 053 (wide-fanout-labels) and 033 (parallel-labeled-edges) not analyzed | Added analysis for all labeled fixtures |
| 7 | No mention that `node_rects` passed to `compute_label_position` includes edge endpoints | Added clarifying note in Section 4.2.3 |
| 8 | Fix C may cause nudge to activate more often for wide labels near nodes — not discussed | Added to Risks section |

## 1. Problem Statement

Edge labels in D2 diagrams are frequently cut off or overlap diagram elements. Observed in a vertical 4-node chain (`client -> api -> cache -> db`) with labels on each edge:

| Symptom | Root Cause |
|---------|------------|
| Labels cut off at left edge of viewport | ViewBox doesn't include label bounding rects |
| All labels pushed to the same side | `label_position_at` always offsets left (vertical) or up (horizontal) |
| Wide labels overlap the edge line | `MAX_LABEL_OFFSET` cap pulls label center back toward line |

Screenshot evidence: every label ("REST/JSON", "get/set", "SQL queries", "cache miss") is pushed left and clipped.

## 2. Root Cause Analysis

### 2.1 ViewBox ignores labels (the clipping bug)

`compute_viewbox()` in `svg_render.rs:185-234` computes bounds from:
- Node bounding rects (including shadow/3D extras)
- Edge route control points

It does **not** include edge label bounding rects. A label whose halo extends beyond the leftmost node is clipped by the SVG viewport.

### 2.2 Unidirectional offset bias

`label_position_at()` in `edge_routing.rs:889-934` always applies the perpendicular offset in a fixed direction:

```
Horizontal segment → offset UP    (py - offset)
Vertical segment   → offset LEFT  (px - offset)
```

In a vertical layout where every edge is vertical, every label is pushed left. The candidate loop in `compute_label_position()` tries 9 percentage positions along the route but always uses the same perpendicular side.

### 2.3 MAX_LABEL_OFFSET cap causes line overlap

The offset formula is (using the cross-axis dimension — `label_height` for horizontal segments, `label_width` for vertical):
```
offset = min(label_dim/2 + LABEL_PADDING, MAX_LABEL_OFFSET)
       = min(label_dim/2 + 4, 40)
```

The label's nearest edge to the route line is at `offset - label_dim/2` pixels. When offset is capped at 40, this becomes `40 - label_dim/2`:

| Label text | Chars | Width (px) | Natural offset | Capped offset | Near-edge gap | Result |
|-----------|-------|-----------|----------------|--------------|---------------|--------|
| get/set | 7 | 53.9 | 31.0 | 31.0 | +4.0px | Clean |
| REST/JSON | 9 | 69.3 | 38.7 | 38.7 | +4.0px | Clean |
| cache miss | 10 | 77.0 | 42.5 | 40.0 (capped) | +1.5px | Barely clear |
| SQL queries | 11 | 84.7 | 46.4 | 40.0 (capped) | −2.4px | Overlaps line |
| *(illustrative)* long text | 25 | ~185 (wrapped) | 96.5 | 40.0 (capped) | −52.5px | Major overlap |

*(Width at default font_size=14px: char_width = 0.55 × 14 = 7.7px/char. Natural offset = width/2 + 4. Gap = capped_offset − width/2.)*

Removing the cap entirely would cause labels wider than 92px to violate the conformance `label_near_edge` threshold (50px max distance from label center to edge): offset = dim/2 + 4 > 50 → dim > 92.

## 3. Proposed Design

Three coordinated fixes, ordered by impact:

### Fix A: Expand ViewBox to include label bounds

**Impact:** High — directly eliminates clipping.
**Complexity:** Trivial (~15 lines).

After computing bounds from nodes and routes, also include each edge label's full bounding rect (with halo padding).

**Where:** `svg_render.rs`, `compute_viewbox()`

**Logic:**
```
for each edge with label_position:
    label_rect = Rect(
        pos.x - label_width/2 - LABEL_HALO_PADDING,
        pos.y - label_height/2 - LABEL_HALO_PADDING,
        label_width + 2 * LABEL_HALO_PADDING,
        label_height + 2 * LABEL_HALO_PADDING
    )
    expand min_x, min_y, max_x, max_y to contain label_rect
```

**Effect:** Labels are never clipped, regardless of placement. The diagram grows to accommodate them. This matches D2, Mermaid, and Graphviz behavior.

**Risk:** A very wide label makes the diagram wider. This is correct — the user chose a wide label, the diagram should show it. The existing 20px padding still applies on top.

### Fix B: Bidirectional perpendicular offset

**Impact:** Medium — distributes labels to the better side when layout is asymmetric.
**Complexity:** Moderate (~40 lines changed).

For each candidate position along the route, evaluate BOTH perpendicular directions (left+right or up+down). Pick using two-phase scoring:

1. **Primary: clearance from nodes** — strictly better clearance wins (existing metric)
2. **Secondary: overshoot beyond node bounding box** — when clearance is equal, prefer the side where the label's full bounding rect extends less beyond the bounding box of all nodes
3. **Tertiary: default to side=-1** (left/up) — deterministic fallback for perfectly symmetric layouts

**Approach:** Add a `side: f64` parameter to `label_position_at` (+1.0 or -1.0).

**Critical structural detail:** The early-exit check in the candidate loop is OUTSIDE the inner sides loop. This ensures both sides are always evaluated at each percentage before deciding to stop. This is a behavioral improvement over the current code, which exits as soon as any single candidate has good clearance.

**Honest limitation:** For a perfectly symmetric vertical chain (all nodes centered at the same x), both sides have equal clearance AND equal overshoot. The default side=-1 (left/up) wins consistently. All labels go left. This is acceptable because:
- Fix A ensures they're not clipped
- The layout is consistent and predictable
- Alternation would require arbitrary heuristics (edge-index parity, etc.) with no principled basis

**Where it helps:** Asymmetric layouts — where one side has nearby nodes and the other doesn't, or where the edge is off-center relative to the node bounding box. The better side is chosen automatically.

### Fix C: On-edge fallback for very wide labels

**Impact:** Low — affects labels wider than ~72px at default font size.
**Complexity:** Trivial (~6 lines changed).

When a label is so wide that the perpendicular offset would cause the label to straddle the route line, place it centered directly on the edge (offset = 0). The halo background covers the line underneath.

**Threshold derivation:**

The label's nearest edge overlaps the route line when `natural_offset > MAX_LABEL_OFFSET`:
```
natural_offset = dim/2 + LABEL_PADDING = dim/2 + 4
trigger: natural_offset > MAX_LABEL_OFFSET = 40
→ dim/2 + 4 > 40
→ dim > 72px
```

At default font_size=14px (7.7px/char), this is ~9.4 characters. From the problem diagram:
- "get/set" (53.9px) → offset (clears line)
- "REST/JSON" (69.3px) → offset (clears line)
- "cache miss" (77.0px) → **centered on edge** (natural_offset=42.5 > 40)
- "SQL queries" (84.7px) → **centered on edge** (natural_offset=46.4 > 40)

**Why binary (natural vs. zero) instead of smooth clamp:**

The smooth clamp (`min(natural, MAX_LABEL_OFFSET)`) produces three visual states:
1. **Natural offset** (narrow labels): label fully clears the line. Clean.
2. **Clamped offset** (medium labels): label partially overlaps the line. Ugly — the halo covers part of the line asymmetrically.
3. **On-edge** (wide labels): label centered on line. Clean — halo provides symmetric visual break.

The clamp produces state (2), which is the worst. The binary choice skips from (1) to (3), giving two clean visual states.

**Implementation:** This replaces the existing `.min(MAX_LABEL_OFFSET)` clamp — the `.min()` call is removed entirely and replaced with:
```rust
let natural_offset = (label_dim / 2.0) + LABEL_PADDING;
let offset = if natural_offset > MAX_LABEL_OFFSET { 0.0 } else { natural_offset };
```

**Conformance:** With offset = 0, label center is on the edge → distance ≈ 0, trivially under the 50px `label_near_edge` threshold.

## 4. Implementation Details

### 4.1 compute_viewbox expansion (Fix A)

**File:** `crates/d2/src/svg_render.rs`

`LABEL_HALO_PADDING` is already imported at line 15. Insert after the existing "edge route control points" loop (after line 229), before the empty-diagram check:

```rust
// Include edge label bounding rects
for &eidx in &graph.edges {
    let edge = &graph.graph[eidx];
    if let Some(pos) = edge.label_position {
        if edge.label_width > 0.0 && edge.label_height > 0.0 {
            let pad = LABEL_HALO_PADDING;
            let lx = pos.x - edge.label_width / 2.0 - pad;
            let ly = pos.y - edge.label_height / 2.0 - pad;
            let lr = lx + edge.label_width + pad * 2.0;
            let lb = ly + edge.label_height + pad * 2.0;
            min_x = min_x.min(lx);
            min_y = min_y.min(ly);
            max_x = max_x.max(lr);
            max_y = max_y.max(lb);
        }
    }
}
```

No new types, no structural changes. The existing 20px padding wraps the expanded bounds.

### 4.2 Bidirectional offset (Fix B)

**File:** `crates/d2/src/edge_routing.rs`

#### 4.2.1 Modify `label_position_at` signature

Add `side: f64` parameter. Update the offset application:

```rust
fn label_position_at(
    route: &[Point],
    seg_lengths: &[f64],
    total_length: f64,
    percentage: f64,
    label_width: f64,
    label_height: f64,
    side: f64,
) -> Option<Point> {
    // ... existing interpolation logic unchanged ...

    return if dx.abs() > dy.abs() {
        let offset = /* see 4.3 */;
        Some(Point::new(px, py + side * offset))   // side=-1 → up, +1 → down
    } else {
        let offset = /* see 4.3 */;
        Some(Point::new(px + side * offset, py))   // side=-1 → left, +1 → right
    };
}
```

#### 4.2.2 New helper: `label_overshoot`

Computes how many total pixels the label's bounding rect extends beyond the bounding box of all nodes. Lower is better.

```rust
fn label_overshoot(
    pos: Point,
    label_width: f64,
    label_height: f64,
    node_bounds: &Rect,
) -> f64 {
    let lr = label_bounding_rect(pos, label_width, label_height);

    (node_bounds.x - lr.x).max(0.0)                 // left overshoot
        + (lr.right() - node_bounds.right()).max(0.0) // right overshoot
        + (node_bounds.y - lr.y).max(0.0)             // top overshoot
        + (lr.bottom() - node_bounds.bottom()).max(0.0) // bottom overshoot
}
```

**Design note:** Reuses `label_bounding_rect` (which already includes `LABEL_HALO_PADDING`) rather than duplicating the padded-rect computation inline.

#### 4.2.3 Modify `compute_label_position` candidate loop

**Important context:** `node_rects` comes from `collect_node_rects_indexed()` which collects ALL non-container, non-root node rects — including the current edge's source and destination nodes. This is intentional: we want labels to avoid overlapping any node, including endpoints. The nudge-only-non-endpoint behavior in some tests is a weaker assertion than what the placement algorithm guarantees.

```rust
fn compute_label_position(
    route: &[Point],
    percentage: f64,
    label_width: f64,
    label_height: f64,
    node_rects: &[Rect],
) -> Option<Point> {
    // ... existing seg_lengths / total computation ...

    // Fast path: no nodes to dodge
    if node_rects.is_empty() {
        return label_position_at(route, &seg_lengths, total, percentage,
                                 label_width, label_height, -1.0);
    }

    // Compute bounding box of all node rects for overshoot tie-breaking.
    // node_rects is guaranteed non-empty here (is_empty returned early above).
    let node_bounds = {
        let min_x = node_rects.iter().map(|r| r.x).fold(f64::INFINITY, f64::min);
        let min_y = node_rects.iter().map(|r| r.y).fold(f64::INFINITY, f64::min);
        let max_x = node_rects.iter().map(|r| r.right()).fold(f64::NEG_INFINITY, f64::max);
        let max_y = node_rects.iter().map(|r| r.bottom()).fold(f64::NEG_INFINITY, f64::max);
        Rect::new(min_x, min_y, max_x - min_x, max_y - min_y)
    };

    const CANDIDATES: [f64; 9] = [0.5, 0.35, 0.65, 0.2, 0.8, 0.15, 0.85, 0.4, 0.6];
    const SIDES: [f64; 2] = [-1.0, 1.0];

    let mut best_pos: Option<Point> = None;
    let mut best_clearance = f64::NEG_INFINITY;
    let mut best_overshoot = f64::INFINITY;

    for &pct in &CANDIDATES {
        // Evaluate BOTH sides at this percentage before considering early exit
        for &side in &SIDES {
            if let Some(pos) = label_position_at(
                route, &seg_lengths, total, pct,
                label_width, label_height, side,
            ) {
                let lr = label_bounding_rect(pos, label_width, label_height);
                let clearance = label_clearance(&lr, node_rects);
                let overshoot = label_overshoot(pos, label_width, label_height, &node_bounds);

                // Phase 1: strictly better clearance always wins
                let dominated = if clearance > best_clearance {
                    false
                } else if clearance < best_clearance {
                    true
                } else {
                    // Phase 2: equal clearance → less overshoot wins
                    // Phase 3 (implicit): equal overshoot → first candidate kept (>=)
                    overshoot >= best_overshoot
                };

                if !dominated {
                    best_clearance = clearance;
                    best_overshoot = overshoot;
                    best_pos = Some(pos);
                }
            }
        }

        // Early exit AFTER evaluating both sides at this percentage
        if best_clearance > LABEL_PADDING {
            break;
        }
    }

    // If best position still overlaps a node, nudge it away.
    if best_clearance < 0.0 {
        if let Some(pos) = best_pos {
            best_pos = Some(nudge_away_from_nodes(pos, label_width, label_height, node_rects));
        }
    }

    best_pos
}
```

**Note on floating-point equality:** The strict inequalities `clearance > best_clearance` / `clearance < best_clearance` handle the common case. When clearances are within floating-point epsilon, the `else` branch triggers and overshoot breaks the tie. Two candidates at opposite sides of the same route point have clearances computed via identical `min_separation` operations on symmetric geometry — they produce bitwise-equal floats, so the `else` branch fires correctly.

### 4.3 On-edge fallback (Fix C)

**File:** `crates/d2/src/edge_routing.rs`, inside `label_position_at()`

Replace the existing `.min(MAX_LABEL_OFFSET)` clamp in both branches:

```rust
// BEFORE (current code):
let offset = ((label_height / 2.0) + LABEL_PADDING).min(MAX_LABEL_OFFSET);

// AFTER (Fix C — binary choice replaces smooth clamp):
let natural_offset = (label_height / 2.0) + LABEL_PADDING;
let offset = if natural_offset > MAX_LABEL_OFFSET { 0.0 } else { natural_offset };
```

Same change for vertical segments with `label_width`.

When `offset = 0`, both sides produce the same position `(px, py)`. The candidate loop evaluates both, finds identical clearance and overshoot, keeps the first (side=-1). No wasted updates.

## 5. Interaction Between Fixes

The three fixes are independent and composable:

| Fix | Alone | With others |
|-----|-------|-------------|
| A (viewBox) | Labels never clipped, but still all on one side | Correct bounds for any placement strategy |
| B (bidirectional) | Labels distributed better for asymmetric layouts, but wide ones still clipped | Combined with A, fully solves the problem |
| C (on-edge) | Wide labels centered cleanly, but still clipped | Combined with A+B, clean placement at all widths |

**Recommended order:** A → B+C.

Fix A alone resolves the most critical issue (clipping) and can ship independently. Fixes B and C should ship together — both modify `label_position_at` (B adds the `side` parameter, C changes the offset formula).

**Fix C + nudge interaction:** When Fix C centers a wide label on the edge (offset=0), the label's bounding rect extends `label_dim/2 + LABEL_HALO_PADDING` in each direction from the edge line. If a node is within this distance of the edge, the label overlaps and the nudge mechanism activates — pushing the label away from the nearest overlapping node. This is correct behavior: the nudge is the existing safety net. However, Fix C will cause the nudge to activate more frequently for wide labels on edges that pass near nodes. This is acceptable because the nudge produces valid placements and the current capped offset (40px) already causes overlap for wide labels (that's the bug Fix C is addressing).

## 6. Existing Call Sites Affected

### `label_position_at` callers (2 sites, both in `compute_label_position`):

1. Fast path (no nodes) — pass `side = -1.0`
2. Candidate loop — pass both `side = -1.0` and `side = 1.0`

### `compute_viewbox` callers (1 site):

1. `render()` in `svg_render.rs` — no signature change, automatically gets expanded bounds

### Constants:

| Constant | Current | After |
|----------|---------|-------|
| `MAX_LABEL_OFFSET` | 40.0 | Kept. Meaning changes: threshold for binary offset/on-edge choice (was smooth clamp limit). |
| `LABEL_HALO_PADDING` | 3.0 | No change; used in viewBox expansion and overshoot calculation. |
| ViewBox `padding` | 20.0 | No change. |

## 7. Test Plan

### 7.1 New unit tests

| Test | Validates |
|------|-----------|
| `test_viewbox_includes_labels` | Parse SVG output, verify viewBox contains all edge label bounding rects |
| `test_label_not_clipped` | For the 4-node chain, verify no label rect extends beyond viewBox |
| `test_label_side_asymmetric` | Layout where one side has a node — verify the label goes to the other side |
| `test_wide_label_on_edge` | Label with 11+ chars → width > 72px → offset is 0 (centered on edge) |
| `test_overshoot_prefers_inward` | Edge near left boundary of diagram → label placed to the right (less overshoot) |

### 7.2 Existing tests — impact analysis

| Test | Expected Impact |
|------|-----------------|
| `test_label_offset_vertical` | **No change.** Simple `a -> b: hello` (5 chars, 38.5px). Natural offset = 23.3 < 40, so Fix C doesn't trigger. `node_rects` contains both endpoint nodes (a, b) — fast path is NOT taken. Candidate loop evaluates pct=0.5 with both sides. Both sides have equal clearance (midpoint is symmetric between a and b) and equal overshoot. Default side=-1 (left) wins. Existing assertions (`label_pos.x < line_x`, `offset >= label_width/2`) pass. |
| `test_label_offset_horizontal` | **No change.** Same reasoning — both sides equal, default side=-1 (up) wins. Assertions (`label_pos.y < line_y`, `offset >= label_height/2`) pass. |
| `test_ortho_label_vertical` | **No change.** Default side wins for simple layout. |
| `test_ortho_label_horizontal` | **No change.** Default side wins for simple layout. |
| `test_label_no_node_overlap` | **No change.** Clearance logic unchanged; overshoot is secondary. |
| `test_nudge_finds_clear_position` | **Possible improvement.** Bidirectional may find a clear position without nudging. Test checks "no overlap" — still holds. |
| All other edge_routing tests | **No change.** Don't test label direction. |

**Key insight:** For all simple test diagrams (`a -> b: hello`), label width is 38.5px (5 chars × 7.7). Natural offset = 23.3 < 40, so Fix C doesn't trigger. For the bidirectional evaluation, both sides have equal clearance against the two endpoint nodes. Both sides have equal overshoot (node bounding box is symmetric around the edge). The first candidate (side=-1, left/up) wins via the `>=` tie-breaker. This matches current behavior exactly. No assertions break.

### 7.3 Conformance suite

All 24 fixtures must pass with 0 violations. Fixture-by-fixture analysis:

**Fix C affected (wide labels → on-edge):**

| Fixture | Label widths (px) | Impact |
|---------|-------------------|--------|
| 010 (labeled-edge) | "hello" = 38.5 | No change. Below 72px threshold. |
| 011 (multi-labeled) | "foo"=23.1, "bar"=23.1, "baz"=23.1 | No change. All below threshold. Fix B: layout is asymmetric (triangle), labels may distribute to both sides. Clearance-first scoring ensures no violations. |
| 012 (long label) | "This is a very long edge label" wraps → longest line ~185px | Fix C triggers. Label center moves from 40px offset to 0px (on-edge). Passes `label_near_edge` by wider margin. |
| 013 (label-horizontal) | "label" = 38.5 | No change. Below 72px threshold. |
| 030 (architecture-labels) | "HTTPS"=38.5, "verify"=46.2, "sessions"=61.6, "route"=38.5, "CRUD"=30.8 | No change. All below 72px threshold. |
| 032 (label-near-box) | "overlapping label"=130.9, "another label"=100.1, "direct"=46.2 | Fix C: first two labels centered on edge. Third stays offset. Clearance check + nudge handles nearby nodes. |
| 033 (parallel-labeled) | "first"=38.5, "second"=46.2, "third"=38.5 | No change. All below threshold. Fix B may distribute labels to both sides of parallel edges. |
| 053 (wide-fanout) | "link1"–"link5" = 38.5 each | No change. Below threshold. Fix B: fan-out is asymmetric, labels may pick better sides per spoke. |

**Fix A affected (viewBox expansion):**

All fixtures benefit. ViewBox now includes label bounding rects, so labels are never clipped. The conformance invariant checks parse SVG geometry (not viewport), so the viewBox change doesn't affect invariant results — it only improves visual output.

**Fix B affected (bidirectional):**

Asymmetric layouts (011, 032, 033, 053) may see labels move to the other side of their edge. The new side is always the one with better clearance or less overshoot. No invariant can be violated by moving a label to a position with equal-or-better clearance.

### 7.4 Visual verification

Render the failing diagram before and after. Verify:
- No labels cut off at any edge
- Wide labels ("SQL queries", "cache miss") visually clean — centered on edge with halo
- Narrow labels ("get/set", "REST/JSON") still offset from edge with gap

## 8. Design Properties

### 8.1 Monotonic improvement guarantee

Bidirectional evaluation (9 positions × 2 sides = 18 candidates) searches a strict superset of the current search space (9 positions × 1 side). The optimal candidate from the larger space has clearance ≥ the optimal from the smaller space. It is mathematically impossible for Fix B to produce a worse label placement than the current algorithm.

### 8.2 Direction-independence

The perpendicular offset depends on segment orientation (`dx.abs()` vs `dy.abs()`), not the `Direction` enum (`Up`, `Down`, `Left`, `Right`). All four layout directions are handled correctly without special-casing. Edge traversal direction (forward vs backward) is also irrelevant — only the segment's dx/dy determines whether the label is offset horizontally or vertically.

### 8.3 Self-loop label viewBox bonus

Fix A's loop iterates ALL `graph.edges`, including self-loops. Self-loop labels have `label_position`, `label_width`, and `label_height` set (lines 90-102 in `route_all_edges`). So Fix A implicitly prevents self-loop label clipping — a free improvement beyond the stated goal.

### 8.4 Fix C threshold applies symmetrically to both axes

The design's worked examples focus on label width (vertical segments), but Fix C equally applies to label height on horizontal segments. A label taller than 72px (~3.7 lines at font_size=14) on a horizontal segment triggers on-edge placement. The threshold derivation in Section 3 uses generic "dim" notation, covering both axes.

## 9. Pre-Existing Limitations (Unchanged)

### 9.1 L-shape corner interpolation

When `label_position_at` interpolates at exactly 50% of a 2-segment L-shaped route, the `>=` boundary condition (line 905) causes `t=1.0` — landing at the corner point. The label inherits the incoming segment's direction vector, so the offset is perpendicular to the incoming leg but parallel to the outgoing leg. The halo partially overlaps the outgoing segment visually.

**Scope:** Only affects tight-gap container-descendant edges (`build_container_route`, 2 call sites at lines 738 and 755). Standard 3-segment and detour routes place 50% on the middle segment, away from corners.

**Mitigation:** The candidate loop tries 9 percentages. For an equal-length L-shape, pct=0.5 hits the corner, but pct=0.35 and pct=0.65 land safely within individual segments. If the corner position has good clearance (likely — no nearby nodes at the elbow), the early exit accepts it. The visual overlap is covered by the halo. This is a cosmetic imperfection, not a correctness issue.

**Not addressed by this design.** Neither Fix B nor Fix C changes the interpolation logic or the `>=` boundary condition. The issue is pre-existing and unchanged.

## 10. Risks and Mitigations

| Risk | Likelihood | Mitigation |
|------|-----------|------------|
| ViewBox expansion makes diagram wider for long labels | Low | Correct behavior. Labels should be visible. |
| On-edge placement (Fix C) hides route line under halo | By design | Halo is opacity=0.85, matches background. Standard practice in D2/Mermaid/Graphviz. |
| Overshoot tie-breaker ineffective for perfectly symmetric layouts | By design | Acknowledged limitation. Labels go left/up consistently. Fix A ensures visibility. |
| Fix C cliff behavior: 1px width increase at threshold causes 40px position jump | Acceptable | A label at 72px has natural_offset=40.0 (stays offset); at 73px, natural_offset=40.5 → centered on-edge (offset=0). The cliff is inherent to the binary choice. The alternative (smooth clamp) produces the ugly "partial overlap" state that Fix C exists to eliminate. Tuning MAX_LABEL_OFFSET shifts the cliff but doesn't remove it. In practice, the cliff is not user-visible because label widths are discrete (character-based) and the transition zone (~9.3–9.4 chars) is narrow. |
| Fix C increases nudge activation for wide labels near nodes | Low | When offset=0 places a wide label overlapping a nearby node, the nudge mechanism pushes it clear. This is the same nudge that handles all other overlap cases. The result is valid but the label position is determined by nudge heuristics (push away from nearest node center) rather than the controlled perpendicular offset. |
| Bidirectional offset changes visual regression baselines | Moderate | Only affects asymmetric layouts. New positions are better. Update baselines. |
| Performance: 18 candidates instead of 9 | Negligible | ~N rect comparisons per candidate. Sub-microsecond for real diagrams. |

## 9. Files Modified

| File | Change | Lines |
|------|--------|-------|
| `crates/d2/src/svg_render.rs` | `compute_viewbox`: add label bounds expansion | ~15 |
| `crates/d2/src/edge_routing.rs` | `label_position_at`: add `side` param, replace `.min()` with binary fallback | ~10 |
| `crates/d2/src/edge_routing.rs` | `compute_label_position`: bidirectional candidates + overshoot scoring | ~30 |
| `crates/d2/src/edge_routing.rs` | New helper: `label_overshoot` | ~10 |
| `crates/d2/src/edge_routing.rs` | New tests (5) + existing tests unchanged | ~50 |
| **Total** | | **~115 lines** |

## 10. Out of Scope

- **Label-vs-label overlap detection**: Two labels on parallel edges may overlap each other. Mitigated by channel spreading. Full collision resolution would require a constraint solver.
- **Label alternation for symmetric layouts**: No principled heuristic exists. Default left/up is consistent and predictable.
- **Multi-line label wrapping at viewport boundary**: Labels wider than `MAX_LABEL_WIDTH` (200px) already wrap. Viewport-aware wrapping is a separate feature.
- **Curved edge labels**: Self-loop labels use hardcoded positioning. Separate concern.
- **Tuning MAX_LABEL_OFFSET**: Current value (40) sets the on-edge threshold at 72px label width. Could be increased to 45 (threshold 82px) or 48 (threshold 88px) if post-implementation testing shows the threshold is too aggressive. This is a single-constant change.

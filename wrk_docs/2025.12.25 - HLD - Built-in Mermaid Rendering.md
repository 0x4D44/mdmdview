# HLD - Built-in Mermaid Rendering

Date: 2025.12.25
Status: Draft

## Summary

## Problem statement
- A built-in renderer should produce diagrams locally without external calls and keep egui update() non-blocking.

## Goals
- Render Mermaid code blocks locally without any network dependency.
- Keep UI responsive by performing rendering off the UI thread.
- Support the Mermaid syntax set shipped in the embedded Mermaid JS bundle.
- Preserve existing markdown rendering flow and cached image reuse.
- Provide clear errors and a source fallback when rendering fails.

## Non-goals
- Re-implement Mermaid parsing or layout in Rust.
- Provide interactive SVG behaviors inside the egui view (links, callbacks).
- Dynamically download icon packs or external assets.
- Support diagrams that require external Mermaid modules unless we explicitly bundle them.

## Constraints and guidelines
- No network calls for rendering.
- UI update() must remain non-blocking.
- Default to ASCII content in repository files.
- Avoid unwrap/expect outside tests.

## Current behavior (baseline)
- Mermaid blocks are detected in src/markdown_renderer.rs and sent to render_mermaid_block().
- If the optional mermaid-quickjs feature is enabled, the renderer tries QuickJS and embedded mermaid.min.js.

## Proposed design

### Architecture overview
Introduce a dedicated MermaidRenderService that owns:
- A bounded job queue and worker threads.
- A QuickJS runtime per worker with Mermaid JS and a DOM shim preloaded.
- SVG and texture caches keyed by code hash, width bucket, scale bucket, and background mode.

UI thread flow:
1. MarkdownRenderer sees a ```mermaid block and computes a hash.
2. If a cached texture exists for the width+scale bucket, draw it.
3. If no cached texture exists, enqueue a render job and show a placeholder.
4. Poll job results each frame; on completion, upload the pre-rasterized RGBA buffer and cache texture metadata.
5. On failure, show a diagnostic frame and fall back to code block rendering.

### Mermaid renderer module
Create src/mermaid_renderer.rs and move Mermaid-specific logic out of markdown_renderer.rs.
Key types:
- MermaidRenderService
  - enqueue_render(code: &str, width_bucket: u32, scale_bucket: u32) -> RenderState
  - poll_results() -> Vec<RenderResult>
- MermaidRenderRequest { code_hash, code, width_bucket, scale_bucket, options }
- MermaidRenderResult { code_hash, svg: Option<String>, rgba: Option<Vec<u8>>, size: (u32, u32), width_bucket, scale_bucket, error: Option<String> }

Notes:
- Workers produce SVG and rasterize to RGBA off the UI thread. UI thread only uploads textures.
- SVG is cached for re-rasterization when scale or background mode changes.

MarkdownRenderer will:
- Hold a MermaidRenderService instance.
- Provide a thin render_mermaid_block wrapper to integrate with egui.

### QuickJS execution model
- Each worker thread owns a QuickJS Runtime and Context and is reused for multiple jobs.
- Mermaid JS is evaluated once per worker on startup.
- A DOM shim is loaded before Mermaid to satisfy mermaidAPI.render() calls.
- Rendering uses mermaid.mermaidAPI.render() and handles async Promises by driving the QuickJS job queue until resolution or timeout.
- Apply runtime limits (time and memory) to prevent long-running or unbounded scripts.

### DOM shim requirements
Mermaid uses a subset of DOM APIs. The shim must provide:
- window and document with createElement, createElementNS, body, querySelector, getElementById.
- Basic SVG element stubs with setAttribute, getAttribute, appendChild, textContent, and style.
- getBBox, getComputedTextLength, and getBoundingClientRect for text measurement.
- window.getComputedStyle for basic font lookup.

Design choice: start with a deterministic JS-only measurement heuristic, then optionally upgrade.
- Heuristic: width = char_count * font_size * factor (default factor 0.6), height = font_size * 1.2.
- Cache measurement results per font family/size/text in the worker.
- Phase 2 (optional): provide a Rust-backed text measurement hook using fontdb and rustybuzz to improve layout fidelity.

### Render configuration
- Initialize Mermaid with safe defaults via mermaid.mermaidAPI.initialize():
  - startOnLoad: false
  - securityLevel: strict
  - deterministicIds: true
  - deterministicIDSeed: code hash (per diagram)
  - maxTextSize: set to a reasonable limit
- Allow frontmatter and directives in the mermaid source, but sanitize or override unsafe keys:
  - Always force securityLevel to strict unless a local env var explicitly allows it.
  - Ignore or clamp maxTextSize if user tries to set it too high.
  - Optionally force htmlLabels to false in strict mode.
- Reuse existing MDMDVIEW_MERMAID_* env vars to set theme variables.
- For built-in rendering, prefer site config over injecting %%{init}%% text.

### Caching strategy
- Key SVG cache by hash(code + normalized config overrides).
- Key texture cache by hash + width_bucket + scale_bucket + background mode.
- Invalidate or re-render when UI scale changes (scale_bucket changes).
- Keep per-renderer LRU limits (configurable) to avoid unbounded memory growth.
- Keep a small failed-hash set to avoid retrying known-bad code until it changes.

### Background and scale
- Use existing MDMDVIEW_MERMAID_BG or MDMDVIEW_MERMAID_BG_COLOR to pick a raster background.
- Use existing ui scale logic, but bucket on scale to avoid blurry results after zoom changes.

### Diagram support and bundles
- Use the full Mermaid JS bundle (assets/vendor/mermaid.min.js) so common diagrams work offline.
- Zenuml and other external diagrams remain unsupported unless we explicitly bundle them.
- Icon packs are not fetched at runtime. If needed, we can add local icon pack JSON files under assets/vendor and register them during initialization.

### Security and privacy
- Disable network-related JS APIs (fetch, XMLHttpRequest) in the QuickJS context.
- Provide a no-op DOMPurify stub (or ensure Mermaid strict mode does not require DOMPurify) to avoid runtime errors.
- Ensure resvg/usvg rejects external resources:
  - No file system resolution (resources_dir unset).
  - Custom image href resolver that denies http/https and file paths.
- Force securityLevel strict unless explicitly overridden by a local opt-in setting.

### Failure behavior
- Rendering failures show a small diagnostic block with a message and error string.
- The code block is displayed as a fallback to guarantee visibility.
- Errors are cached per hash to avoid repeated expensive attempts.

## Configuration and feature flags

### Cargo features
- mermaid-quickjs (existing): enable QuickJS and embedded Mermaid rendering.
- If we introduce mermaid-embedded, make it an alias of mermaid-quickjs to avoid breaking existing builds.

### Environment variables
- MDMDVIEW_MERMAID_THEME and MDMDVIEW_MERMAID_* theme variables remain supported.
- MDMDVIEW_MERMAID_SECURITY: strict | loose (default: strict).
- MDMDVIEW_MERMAID_WORKERS: override worker count (default: min(4, num_cpus)). 
- MDMDVIEW_MERMAID_TIMEOUT_MS: per-render timeout before abort.

## UI integration details
- render_mermaid_block() remains the entry point from render_code_block().
- The function becomes a thin wrapper that uses MermaidRenderService.
- Placeholder UI matches existing dark frame style.
- When a render completes, the UI requests repaint.

## Data flow (text)
1. MarkdownRenderer detects mermaid fenced block.
2. Compute hash and width bucket.
3. Check texture cache.
4. If cache miss, enqueue a worker job.
5. Worker renders SVG via QuickJS and returns result.
6. UI thread rasterizes SVG to ColorImage using resvg.
7. Store texture and draw.

## Performance considerations
- Rendering and rasterization both move off the UI thread.
- UI thread only uploads textures and caches handles.
- Limit in-flight jobs and apply memory limits in QuickJS.
- Use timeouts or QuickJS interrupt hooks to prevent long-running renders.
- Reuse fontdb across worker jobs to avoid repeated system font scans.

## Compatibility notes
- Mermaid features that rely on external JS modules (zenuml) will not render unless bundled.
- Interactive links and callbacks are not supported because we render to images.
- Image nodes that reference remote URLs are blocked; they will render as empty or be omitted.

## Testing plan
- Unit tests for:
  - Hashing and cache key stability.
  - Config merging and forced security overrides.
  - DOM shim text measurement results (smoke test).
  - QuickJS promise handling (render returns non-empty SVG).
- Renderer tests:
  - Basic flowchart, sequence, class diagram render to non-empty SVG.
  - Invalid mermaid input returns a handled error and falls back to source.
  - Large input exceeds maxTextSize and is rejected with a friendly message.
- Integration tests:
  - Render mermaid sample from src/sample_files.rs and verify a texture is produced.
  - Ensure no network calls are made during rendering.
  - Verify external image references are blocked.

## Rollout plan
2. Enable mermaid-embedded by default and set renderer default to embedded.
4. Update README and sample files to describe built-in rendering.

## Open questions
- Which Mermaid version should be vendored and how often to update it?
- Do we need to support a local icon pack workflow for flowchart/mindmap icons?
- Should we expose a UI toggle for Mermaid securityLevel or renderer selection?
- Do we need a disk cache to persist renders across app restarts?
- Do we need to support high-DPI re-rendering at multiple scale buckets to avoid blur?

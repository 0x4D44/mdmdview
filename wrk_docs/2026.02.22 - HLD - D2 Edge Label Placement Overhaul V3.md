# HLD: D2 Edge Label Placement Overhaul (V3)

**Date:** 2026-02-22
**Status:** Draft
**Scope:** `crates/d2/src/edge_routing.rs`, `crates/d2/src/svg_render.rs`
**Supersedes:** V1, V2 (same date)

## Changes from V2

| # | Issue in V2 | Resolution in V3 |
|---|-------------|-------------------|
| 1 | Fix C threshold stated as `dim > 80px` — math error: `dim/2 + 4 > 40` → `dim > 72px` | Corrected threshold to 72px with worked examples |
| 2 | Fix A code uses `crate::edge_routing::LABEL_HALO_PADDING` but svg_render.rs already imports it at line 15 | Corrected: just use `LABEL_HALO_PADDING` directly |
| 3 | Section 9 says "Remove `closer_to_center`" but this was never implemented — V1 proposal only | Removed misleading line |
| 4 | Unclear that Fix C replaces the existing `.min(MAX_LABEL_OFFSET)` clamp, not supplements it | Made explicit: `.min()` is removed and replaced by the binary choice |
| 5 | No concrete worked examples for label width thresholds | Added table showing which labels from the problem diagram hit each threshold |

## 1. Problem Statement

Edge labels in D2 diagrams are frequently cut off or overlap diagram elements. Observed in a vertical 4-node chain (`client -> api -> cache -> db`) with labels on each edge:

| Symptom | Root Cause |
|---------|------------|
| Labels cut off at left edge of viewport | ViewBox doesn't include label bounding rects |
| All labels pushed to the same side | `label_position_at` always offsets left (vertical) or up (horizontal) |
| Wide labels overlap the edge line | `MAX_LABEL_OFFSET` cap pulls label center back toward line |

Screenshot evidence: every label ("REST/JSON", "get/set", "SQL queries", "cache miss") is pushed left and clipped.

## 2. Root Cause Analysis

### 2.1 ViewBox ignores labels (the clipping bug)

`compute_viewbox()` in `svg_render.rs:185-234` computes bounds from:
- Node bounding rects (including shadow/3D extras)
- Edge route control points

It does **not** include edge label bounding rects. A label whose halo extends beyond the leftmost node is clipped by the SVG viewport.

### 2.2 Unidirectional offset bias

`label_position_at()` in `edge_routing.rs:889-934` always applies the perpendicular offset in a fixed direction:

```
Horizontal segment → offset UP    (py - offset)
Vertical segment   → offset LEFT  (px - offset)
```

In a vertical layout where every edge is vertical, every label is pushed left. The candidate loop in `compute_label_position()` tries 9 percentage positions along the route but always uses the same perpendicular side.

### 2.3 MAX_LABEL_OFFSET cap causes line overlap

The offset formula is:
```
offset = min(label_width/2 + LABEL_PADDING, MAX_LABEL_OFFSET)
       = min(label_width/2 + 4, 40)
```

The label's nearest edge to the route line is at `offset - label_width/2` pixels. When offset is capped at 40, this becomes `40 - label_width/2`:

| Label text | Chars | Width (px) | Natural offset | Capped offset | Near-edge gap | Result |
|-----------|-------|-----------|----------------|--------------|---------------|--------|
| get/set | 7 | 54 | 31 | 31 | +4px | Clean |
| REST/JSON | 9 | 69 | 39 | 39 | +4px | Clean |
| SQL queries | 11 | 85 | 46 | 40 (capped) | -3px | Overlaps line |
| cache miss | 10 | 77 | 43 | 40 (capped) | +2px | Barely clear |
| "This is a very long label" | 26 | 200 (wrapped) | 104 | 40 (capped) | -60px | Major overlap |

*(Width at default font_size=14px: char_width = 0.55 × 14 = 7.7px/char)*

Removing the cap entirely would cause labels wider than 92px to violate the conformance `label_near_edge` threshold (50px max distance from label center to edge).

## 3. Proposed Design

Three coordinated fixes, ordered by impact:

### Fix A: Expand ViewBox to include label bounds

**Impact:** High — directly eliminates clipping.
**Complexity:** Trivial (~15 lines).

After computing bounds from nodes and routes, also include each edge label's full bounding rect (with halo padding).

**Where:** `svg_render.rs`, `compute_viewbox()`

**Logic:**
```
for each edge with label_position:
    label_rect = Rect(
        pos.x - label_width/2 - LABEL_HALO_PADDING,
        pos.y - label_height/2 - LABEL_HALO_PADDING,
        label_width + 2 * LABEL_HALO_PADDING,
        label_height + 2 * LABEL_HALO_PADDING
    )
    expand min_x, min_y, max_x, max_y to contain label_rect
```

**Effect:** Labels are never clipped, regardless of placement. The diagram grows to accommodate them. This matches D2, Mermaid, and Graphviz behavior.

**Risk:** A very wide label makes the diagram wider. This is correct — the user chose a wide label, the diagram should show it. The existing 20px padding still applies on top.

### Fix B: Bidirectional perpendicular offset

**Impact:** Medium — distributes labels to the better side when layout is asymmetric.
**Complexity:** Moderate (~40 lines changed).

For each candidate position along the route, evaluate BOTH perpendicular directions (left+right or up+down). Pick using two-phase scoring:

1. **Primary: clearance from nodes** — strictly better clearance wins (existing metric)
2. **Secondary: overshoot beyond node bounding box** — when clearance is equal, prefer the side where the label's full bounding rect extends less beyond the bounding box of all nodes
3. **Tertiary: default to side=-1** (left/up) — deterministic fallback for perfectly symmetric layouts

**Approach:** Add a `side: f64` parameter to `label_position_at` (+1.0 or -1.0).

**Critical structural detail:** The early-exit check in the candidate loop is OUTSIDE the inner sides loop. This ensures both sides are always evaluated at each percentage before deciding to stop.

**Honest limitation:** For a perfectly symmetric vertical chain (all nodes centered at the same x), both sides have equal clearance AND equal overshoot. The default side=-1 (left/up) wins consistently. All labels go left. This is acceptable because:
- Fix A ensures they're not clipped
- The layout is consistent and predictable
- Alternation would require arbitrary heuristics (edge-index parity, etc.) with no principled basis

**Where it helps:** Asymmetric layouts — where one side has nearby nodes and the other doesn't, or where the edge is off-center relative to the node bounding box. The better side is chosen automatically.

### Fix C: On-edge fallback for very wide labels

**Impact:** Low — affects labels wider than ~72px at default font size.
**Complexity:** Trivial (~6 lines changed).

When a label is so wide that the perpendicular offset would cause the label to straddle the route line, place it centered directly on the edge (offset = 0). The halo background covers the line underneath.

**Threshold derivation:**

The label's nearest edge overlaps the route line when `MAX_LABEL_OFFSET < label_dim/2`:
```
natural_offset = dim/2 + LABEL_PADDING = dim/2 + 4
trigger: natural_offset > MAX_LABEL_OFFSET = 40
→ dim/2 + 4 > 40
→ dim > 72px
```

At default font_size=14px (7.7px/char), this is ~9.4 characters. From the problem diagram:
- "get/set" (54px) → offset (clears line)
- "REST/JSON" (69px) → offset (clears line)
- "cache miss" (77px) → **centered on edge** (would barely clear with natural offset, but 77 > 72 triggers on-edge)
- "SQL queries" (85px) → **centered on edge**

**Why binary (natural vs. zero) instead of smooth clamp:**

The smooth clamp (`min(natural, MAX_LABEL_OFFSET)`) produces three visual states:
1. **Natural offset** (narrow labels): label fully clears the line. Clean.
2. **Clamped offset** (medium labels): label partially overlaps the line. Ugly — the halo covers part of the line asymmetrically.
3. **On-edge** (wide labels): label centered on line. Clean — halo provides symmetric visual break.

The clamp produces state (2), which is the worst. The binary choice skips from (1) to (3), giving two clean visual states.

**Implementation:** This replaces the existing `.min(MAX_LABEL_OFFSET)` clamp — the `.min()` call is removed entirely and replaced with:
```rust
let natural_offset = (label_dim / 2.0) + LABEL_PADDING;
let offset = if natural_offset > MAX_LABEL_OFFSET { 0.0 } else { natural_offset };
```

**Conformance:** With offset = 0, label center is on the edge → distance ≈ 0, trivially under the 50px `label_near_edge` threshold.

## 4. Implementation Details

### 4.1 compute_viewbox expansion (Fix A)

**File:** `crates/d2/src/svg_render.rs`

`LABEL_HALO_PADDING` is already imported at line 15. Insert after the existing "edge route control points" loop (after line 229), before the empty-diagram check:

```rust
// Include edge label bounding rects
for &eidx in &graph.edges {
    let edge = &graph.graph[eidx];
    if let Some(pos) = edge.label_position {
        if edge.label_width > 0.0 && edge.label_height > 0.0 {
            let pad = LABEL_HALO_PADDING;
            let lx = pos.x - edge.label_width / 2.0 - pad;
            let ly = pos.y - edge.label_height / 2.0 - pad;
            let lr = lx + edge.label_width + pad * 2.0;
            let lb = ly + edge.label_height + pad * 2.0;
            min_x = min_x.min(lx);
            min_y = min_y.min(ly);
            max_x = max_x.max(lr);
            max_y = max_y.max(lb);
        }
    }
}
```

No new types, no structural changes. The existing 20px padding wraps the expanded bounds.

### 4.2 Bidirectional offset (Fix B)

**File:** `crates/d2/src/edge_routing.rs`

#### 4.2.1 Modify `label_position_at` signature

Add `side: f64` parameter. Update the offset application:

```rust
fn label_position_at(
    route: &[Point],
    seg_lengths: &[f64],
    total_length: f64,
    percentage: f64,
    label_width: f64,
    label_height: f64,
    side: f64,
) -> Option<Point> {
    // ... existing interpolation logic unchanged ...

    return if dx.abs() > dy.abs() {
        let offset = /* see 4.3 */;
        Some(Point::new(px, py + side * offset))   // side=-1 → up, +1 → down
    } else {
        let offset = /* see 4.3 */;
        Some(Point::new(px + side * offset, py))   // side=-1 → left, +1 → right
    };
}
```

#### 4.2.2 New helper: `label_overshoot`

Computes how many total pixels the label's bounding rect extends beyond the bounding box of all nodes. Lower is better.

```rust
fn label_overshoot(
    pos: Point,
    label_width: f64,
    label_height: f64,
    node_bounds: &Option<Rect>,
) -> f64 {
    let bounds = match node_bounds {
        Some(b) => b,
        None => return 0.0,
    };
    let pad = LABEL_HALO_PADDING;
    let lx = pos.x - label_width / 2.0 - pad;
    let ly = pos.y - label_height / 2.0 - pad;
    let lr = pos.x + label_width / 2.0 + pad;
    let lb = pos.y + label_height / 2.0 + pad;

    (bounds.x - lx).max(0.0)            // left overshoot
        + (lr - bounds.right()).max(0.0) // right overshoot
        + (bounds.y - ly).max(0.0)       // top overshoot
        + (lb - bounds.bottom()).max(0.0) // bottom overshoot
}
```

#### 4.2.3 Modify `compute_label_position` candidate loop

```rust
fn compute_label_position(
    route: &[Point],
    percentage: f64,
    label_width: f64,
    label_height: f64,
    node_rects: &[Rect],
) -> Option<Point> {
    // ... existing seg_lengths / total computation ...

    // Fast path: no nodes to dodge
    if node_rects.is_empty() {
        return label_position_at(route, &seg_lengths, total, percentage,
                                 label_width, label_height, -1.0);
    }

    // Compute bounding box of all node rects for overshoot tie-breaking
    let node_bounds = {
        let min_x = node_rects.iter().map(|r| r.x).fold(f64::INFINITY, f64::min);
        let min_y = node_rects.iter().map(|r| r.y).fold(f64::INFINITY, f64::min);
        let max_x = node_rects.iter().map(|r| r.right()).fold(f64::NEG_INFINITY, f64::max);
        let max_y = node_rects.iter().map(|r| r.bottom()).fold(f64::NEG_INFINITY, f64::max);
        Some(Rect::new(min_x, min_y, max_x - min_x, max_y - min_y))
    };

    const CANDIDATES: [f64; 9] = [0.5, 0.35, 0.65, 0.2, 0.8, 0.15, 0.85, 0.4, 0.6];
    const SIDES: [f64; 2] = [-1.0, 1.0];

    let mut best_pos: Option<Point> = None;
    let mut best_clearance = f64::NEG_INFINITY;
    let mut best_overshoot = f64::INFINITY;

    for &pct in &CANDIDATES {
        // Evaluate BOTH sides at this percentage before considering early exit
        for &side in &SIDES {
            if let Some(pos) = label_position_at(
                route, &seg_lengths, total, pct,
                label_width, label_height, side,
            ) {
                let lr = label_bounding_rect(pos, label_width, label_height);
                let clearance = label_clearance(&lr, node_rects);
                let overshoot = label_overshoot(pos, label_width, label_height, &node_bounds);

                // Phase 1: strictly better clearance always wins
                let dominated = if clearance > best_clearance {
                    false
                } else if clearance < best_clearance {
                    true
                } else {
                    // Phase 2: equal clearance → less overshoot wins
                    // Phase 3 (implicit): equal overshoot → first candidate kept (>=)
                    overshoot >= best_overshoot
                };

                if !dominated {
                    best_clearance = clearance;
                    best_overshoot = overshoot;
                    best_pos = Some(pos);
                }
            }
        }

        // Early exit AFTER evaluating both sides at this percentage
        if best_clearance > LABEL_PADDING {
            break;
        }
    }

    // If best position still overlaps a node, nudge it away.
    if best_clearance < 0.0 {
        if let Some(pos) = best_pos {
            best_pos = Some(nudge_away_from_nodes(pos, label_width, label_height, node_rects));
        }
    }

    best_pos
}
```

**Note on floating-point equality:** The strict inequalities `clearance > best_clearance` / `clearance < best_clearance` handle the common case. When clearances are within floating-point epsilon, the `else` branch triggers and overshoot breaks the tie. Two candidates at opposite sides of the same route point have clearances computed via identical `min_separation` operations on symmetric geometry — they produce bitwise-equal floats, so the `else` branch fires correctly.

### 4.3 On-edge fallback (Fix C)

**File:** `crates/d2/src/edge_routing.rs`, inside `label_position_at()`

Replace the existing `.min(MAX_LABEL_OFFSET)` clamp in both branches:

```rust
// BEFORE (current code):
let offset = ((label_height / 2.0) + LABEL_PADDING).min(MAX_LABEL_OFFSET);

// AFTER (Fix C — binary choice replaces smooth clamp):
let natural_offset = (label_height / 2.0) + LABEL_PADDING;
let offset = if natural_offset > MAX_LABEL_OFFSET { 0.0 } else { natural_offset };
```

Same change for vertical segments with `label_width`.

When `offset = 0`, both sides produce the same position `(px, py)`. The candidate loop evaluates both, finds identical clearance and overshoot, keeps the first (side=-1). No wasted updates.

## 5. Interaction Between Fixes

The three fixes are independent and composable:

| Fix | Alone | With others |
|-----|-------|-------------|
| A (viewBox) | Labels never clipped, but still all on one side | Correct bounds for any placement strategy |
| B (bidirectional) | Labels distributed better for asymmetric layouts, but wide ones still clipped | Combined with A, fully solves the problem |
| C (on-edge) | Wide labels centered cleanly, but still clipped | Combined with A+B, clean placement at all widths |

**Recommended order:** A → B+C.

Fix A alone resolves the most critical issue (clipping) and can ship independently. Fixes B and C should ship together — both modify `label_position_at` (B adds the `side` parameter, C changes the offset formula).

## 6. Existing Call Sites Affected

### `label_position_at` callers (2 sites, both in `compute_label_position`):

1. Fast path (no nodes) — pass `side = -1.0`
2. Candidate loop — pass both `side = -1.0` and `side = 1.0`

### `compute_viewbox` callers (1 site):

1. `render()` in `svg_render.rs` — no signature change, automatically gets expanded bounds

### Constants:

| Constant | Current | After |
|----------|---------|-------|
| `MAX_LABEL_OFFSET` | 40.0 | Kept. Meaning changes: threshold for binary offset/on-edge choice (was smooth clamp limit). |
| `LABEL_HALO_PADDING` | 3.0 | No change; used in viewBox expansion and overshoot calculation. |
| ViewBox `padding` | 20.0 | No change. |

## 7. Test Plan

### 7.1 New unit tests

| Test | Validates |
|------|-----------|
| `test_viewbox_includes_labels` | Parse SVG output, verify viewBox contains all edge label bounding rects |
| `test_label_not_clipped` | For the 4-node chain, verify no label rect extends beyond viewBox |
| `test_label_side_asymmetric` | Layout where one side has a node — verify the label goes to the other side |
| `test_wide_label_on_edge` | Label with 11+ chars → width > 72px → offset is 0 (centered on edge) |
| `test_overshoot_prefers_inward` | Edge near left boundary of diagram → label placed to the right (less overshoot) |

### 7.2 Existing tests — impact analysis

| Test | Expected Impact |
|------|-----------------|
| `test_label_offset_vertical` | **No change.** Simple `a -> b: hello` (5 chars, ~39px). Offset = 23 < 40. Both sides equal clearance/overshoot. Default side=-1 (left) wins. Existing assertion passes. |
| `test_label_offset_horizontal` | **No change.** Same reasoning. Default side=-1 (up) wins. |
| `test_ortho_label_vertical` | **No change.** Default side wins for simple layout. |
| `test_ortho_label_horizontal` | **No change.** Default side wins for simple layout. |
| `test_label_no_node_overlap` | **No change.** Clearance logic unchanged; overshoot is secondary. |
| `test_nudge_finds_clear_position` | **Possible improvement.** Bidirectional may find a clear position without nudging. Test checks "no overlap" — still holds. |
| All other edge_routing tests | **No change.** Don't test label direction. |

**Key insight:** For all simple test diagrams (`a -> b: hello`), both sides of the edge have equal clearance (label is in the gap between two symmetric endpoints). Both sides have equal overshoot (node bounding box is symmetric). The first candidate (side=-1, left/up) wins. This matches current behavior exactly. No assertions break.

### 7.3 Conformance suite

All 24 fixtures must pass with 0 violations. Fixture-specific analysis:

| Fixture | Fix | Impact |
|---------|-----|--------|
| 012 (long label) | C | Label center moves from 40px offset to 0px (on-edge). Distance to edge changes from ~40px to ~0px. Passes `label_near_edge` (≤50px) by wider margin. |
| 032 (label near box) | C | Wide label centered on edge instead of partially overlapping. Clearance from nearby box unchanged or improved. |
| 011 (multi-labeled) | B | Labels may distribute to both sides if layout is asymmetric. No violation possible — offset magnitude unchanged. |
| All others | A | ViewBox expansion doesn't affect invariant checks (they parse SVG geometry, not viewport). |

### 7.4 Visual verification

Render the failing diagram before and after. Verify:
- No labels cut off at any edge
- Wide labels ("SQL queries", "cache miss") visually clean — centered on edge with halo
- Narrow labels ("get/set", "REST/JSON") still offset from edge with gap

## 8. Risks and Mitigations

| Risk | Likelihood | Mitigation |
|------|-----------|------------|
| ViewBox expansion makes diagram wider for long labels | Low | Correct behavior. Labels should be visible. |
| On-edge placement (Fix C) hides route line under halo | By design | Halo is opacity=0.85, matches background. Standard practice in D2/Mermaid/Graphviz. |
| Overshoot tie-breaker ineffective for perfectly symmetric layouts | By design | Acknowledged limitation. Labels go left/up consistently. Fix A ensures visibility. |
| Fix C threshold (72px) feels low — "cache miss" (77px) gets centered | Acceptable | 77px label with 4px gap barely clears the line. Centering looks cleaner than a 2px gap. The threshold could be tuned (increase MAX_LABEL_OFFSET to 45 → threshold 82px) if needed post-implementation. |
| Bidirectional offset changes visual regression baselines | Moderate | Only affects asymmetric layouts. New positions are better. Update baselines. |
| Performance: 18 candidates instead of 9 | Negligible | ~N rect comparisons per candidate. Sub-microsecond for real diagrams. |

## 9. Files Modified

| File | Change | Lines |
|------|--------|-------|
| `crates/d2/src/svg_render.rs` | `compute_viewbox`: add label bounds expansion | ~15 |
| `crates/d2/src/edge_routing.rs` | `label_position_at`: add `side` param, replace `.min()` with binary fallback | ~10 |
| `crates/d2/src/edge_routing.rs` | `compute_label_position`: bidirectional candidates + overshoot scoring | ~30 |
| `crates/d2/src/edge_routing.rs` | New helper: `label_overshoot` | ~15 |
| `crates/d2/src/edge_routing.rs` | New tests (5) + existing tests unchanged | ~50 |
| **Total** | | **~120 lines** |

## 10. Out of Scope

- **Label-vs-label overlap detection**: Two labels on parallel edges may overlap each other. Mitigated by channel spreading. Full collision resolution would require a constraint solver.
- **Label alternation for symmetric layouts**: No principled heuristic exists. Default left/up is consistent and predictable.
- **Multi-line label wrapping at viewport boundary**: Labels wider than `MAX_LABEL_WIDTH` (200px) already wrap. Viewport-aware wrapping is a separate feature.
- **Curved edge labels**: Self-loop labels use hardcoded positioning. Separate concern.
- **Tuning MAX_LABEL_OFFSET**: Current value (40) sets the on-edge threshold at 72px label width. Could be increased to 45 (threshold 82px) or 48 (threshold 88px) if post-implementation testing shows the threshold is too aggressive. This is a single-constant change.

# HLD: D2 Diagram Rendering in Rust

**Date**: 2026-02-15
**Status**: Draft
**Author**: Claude (with Arthur)
**Version**: 6

## Revision History

| Version | Date | Changes |
|---------|------|---------|
| V1 | 2026-02-15 | Initial design |
| V2 | 2026-02-15 | Review pass 1: 24 issues addressed (see §11) |
| V3 | 2026-02-15 | Review pass 2: 12 further issues addressed (see §12) |
| V4 | 2026-02-15 | Review pass 3: 4 final issues addressed (see §13) |
| V5 | 2026-02-15 | Feasibility validation: rust-sugiyama dropped, own Sugiyama, polygon arrowheads, parser complexity (see §14) |
| V6 | 2026-02-15 | Review pass 5: SVG z-ordering, root object, warning propagation, style rendering gaps (see §15) |

## 1. Goal

Add native D2 diagram rendering to mdmdview as an embedded Rust implementation — no external binaries, no WASM blobs, single-binary distribution preserved. D2 code blocks in markdown (` ```d2 `) are parsed, laid out, and rendered to textures inline, matching the existing Mermaid and Pikchr pipelines.

## 2. Background and Motivation

mdmdview already renders two diagram languages:
- **Pikchr**: C library compiled at build time, manual positioning, tiny footprint
- **Mermaid**: JavaScript executed via embedded QuickJS, broad ecosystem

D2 fills a gap: **automatic layout of software architecture diagrams** with a clean, modern syntax. Its killer feature over Pikchr (manual positioning) and Mermaid (often ugly defaults) is that it produces professional hierarchical layouts automatically.

The reference D2 implementation is written in Go (~2M bytes of source, ~50-80K lines). No Rust port exists. A full reimplementation is infeasible; instead, we implement a **useful subset** using a hybrid approach:
- LLM-assisted translation where Go→Rust maps cleanly (parser)
- Design extraction and idiomatic Rust reimplementation where it doesn't (graph IR, layout)
- Differential testing against the Go `d2` CLI as the correctness oracle

## 3. Scope

### 3.1 In Scope (v1 Subset)

The v1 subset targets **~80% of real-world D2 usage** — architecture diagrams, flow charts, simple hierarchies. Features are classified by the D2 language specification:

#### Core Syntax (Must Have)
| Feature | D2 Syntax | Notes |
|---------|-----------|-------|
| Shape declarations | `server` | Default shape is rectangle |
| Explicit labels | `server: "My Server"` | Colon-separated |
| Connections | `a -> b`, `a -- b`, `a <-> b`, `a <- b` | All four arrow types |
| Connection labels | `a -> b: "sends data"` | Label on edge |
| Connection chaining | `a -> b -> c -> d` | Multiple edges in one statement |
| Containers | `group: { a; b }` or `group.a`, `group.b` | Nested shapes |
| Container labels | `group: "My Group" { ... }` | |
| Shape types | `x.shape: circle` | ~20 types (see §3.1.1) |
| Comments | `# line comment` | Single-line only for v1 |
| Semicolons | `a; b; c` | Statement separator |
| Quoted strings | `'literal'`, `"interpolatable"` | Both quote styles |

#### Shape Types (v1)
| Shape | Priority | Notes |
|-------|----------|-------|
| `rectangle` | Must have | Default |
| `square` | Must have | 1:1 aspect ratio |
| `circle` | Must have | |
| `oval` | Must have | |
| `diamond` | Must have | Decision nodes |
| `hexagon` | Must have | |
| `cylinder` | Must have | Database icon |
| `cloud` | Must have | External service |
| `person` | Nice to have | Stick figure |
| `package` | Nice to have | UML package |
| `queue` | Nice to have | Message queue |
| `page` | Nice to have | Document |
| `parallelogram` | Nice to have | I/O |
| `document` | Nice to have | |
| `step` | Nice to have | Process step |
| `callout` | Nice to have | |
| `stored_data` | Nice to have | |
| `text` | Must have | Label-only, no border |
| `code` | Nice to have | Monospace text block |

#### Styles (Must Have)
| Property | D2 Syntax | Notes |
|----------|-----------|-------|
| Fill color | `x.style.fill: "#ff0000"` | Hex colors |
| Stroke color | `x.style.stroke: blue` | Named + hex |
| Stroke width | `x.style.stroke-width: 3` | Pixels |
| Font size | `x.style.font-size: 16` | |
| Font color | `x.style.font-color: white` | |
| Bold/italic | `x.style.bold: true` | |
| Border radius | `x.style.border-radius: 8` | Rounded corners |
| Opacity | `x.style.opacity: 0.5` | |
| Multiple instances | `x.style.multiple: true` | Stacked shape effect (see §4.4 Phase 5 notes) |
| Shadow | `x.style.shadow: true` | Drop shadow (see §4.4 Phase 5 notes) |
| 3D effect | `x.style.3d: true` | Raised appearance (see §4.4 Phase 5 notes) |
| Stroke dash | `x.style.stroke-dash: 5` | Dashed lines |
| Double border | `x.style.double-border: true` | Double outline |
| Underline | `x.style.underline: true` | Text underline |

#### Connection Styles
| Feature | D2 Syntax | Notes |
|---------|-----------|-------|
| Arrowhead types | `x -> y: { source-arrowhead: ... }` | See Arrowhead Types below |
| Animated edges | `(x -> y).style.animated: true` | Rendered as dashed stroke in static output (see §3.3) |
| Edge stroke | `(x -> y).style.stroke: red` | |
| Edge references | `(x -> y)[0].style.stroke: red` | Index-based |

#### Arrowhead Types (v1)
`arrow` (default), `triangle`, `diamond`, `filled-diamond`, `circle`, `filled-circle`, `cf-one`, `cf-many`, `cf-one-required`, `cf-many-required`, `none`

Each arrowhead type requires its own polygon generator in `arrowhead_polygon()`:
- **arrow/triangle**: Simple filled triangle (default)
- **diamond/filled-diamond**: Rotated square (4 vertices)
- **circle/filled-circle**: Approximated with SVG `<circle>` element at endpoint
- **cf-\***: Crow's foot notation — line forks into 2-3 tines near the endpoint. Rendered as short line segments (not a single polygon). These are ER diagram notation and have distinct visual forms per type.

#### Layout Directives
| Feature | D2 Syntax | Notes |
|---------|-----------|-------|
| Direction | `direction: right` | `up`, `down`, `left`, `right` — applies at graph or container level |
| Width/height | `x.width: 200` | Explicit dimensions |

**Note**: The `near` keyword (`x.near: y`) is **deferred to v1.1** — it requires constraint-aware layout positioning that our Sugiyama implementation does not support, and implementing constraint-based placement is a significant effort orthogonal to the core pipeline.

#### Reserved Keywords (v1)
The parser recognizes all D2 reserved keywords but only the v1 subset is semantically processed by the compiler. Unrecognized keywords produce a warning ("not yet supported") rather than being silently parsed as regular identifiers:

**Processed in v1**: `label`, `shape`, `style`, `width`, `height`, `direction`, `source-arrowhead`, `target-arrowhead`

**Parsed but layout-deferred**: `near` — recognized by the parser (no error), stored on the object, but has no layout effect in v1. Layout constraint implementation deferred to v1.1.

**Recognized but deferred**: `icon`, `tooltip`, `link`, `class`, `classes`, `vars`, `constraint`, `grid-rows`, `grid-columns`, `grid-gap`, `vertical-gap`, `horizontal-gap`, `top`, `left`

### 3.1.1 Explicitly Out of Scope (v1)

These features are deferred to future versions:

| Feature | Reason |
|---------|--------|
| Variables (`vars: { ... }`, `${var}`) | Adds compiler complexity |
| Globs (`*.style.fill: red`, `**`) | Pattern matching engine needed |
| Imports (`@filename`) | File resolution, cycle detection |
| Layers, scenarios, steps | Board composition system |
| Sequence diagrams (`shape: sequence_diagram`) | Entirely different layout algorithm |
| Grid diagrams (`grid-rows`, `grid-columns`) | Separate layout system |
| SQL tables (`shape: sql_table`) | Custom rendering |
| UML classes (`shape: class`) | Custom rendering with fields/methods |
| Block strings (`\|...\|`) | Parser complexity |
| Markdown in labels | Recursive rendering |
| LaTeX in labels | External dependency |
| Icons (`icon: ...`) | URL/asset resolution |
| Tooltips, links | Interactive features (SVG-only in D2) |
| Filters (`&shape`, `!&shape`) | IR complexity |
| Null/deletion (`x: null`) | Map merging semantics |
| Spread operator (`...@file`) | Import-dependent |
| Themes | Styling system |
| Multiple boards | Composition system |
| Near (layout constraint) | Constraint-based positioning (see §3.1 note) |

### 3.2 Integration with mdmdview

D2 renders identically to Mermaid and Pikchr:
1. Markdown parser encounters ` ```d2 ` code block
2. D2 source text extracted
3. `mdmdview_d2::render_d2_to_svg(source, &options)` called across crate boundary → returns SVG string
4. SVG rasterized via `usvg`/`resvg` (existing infrastructure, in main crate)
5. Raster image cached as egui texture (existing `LruCache`, in main crate)
6. Displayed inline in rendered markdown view

The crate boundary is clean: the D2 crate knows nothing about egui, textures, or caching. It takes a `&str` plus rendering options and returns an SVG `String`. All UI integration stays in the main crate's `markdown_renderer.rs`.

**Cache key**: The main crate's existing `LruCache` caches rasterized textures keyed by `hash(source_text, dark_mode, font_family)`. This means changing dark mode or font invalidates the cached texture and triggers re-render. Zoom level is not part of the cache key — zoom is handled by scaling the texture during display, not by re-rendering the SVG.

**Error display**: When D2 parsing/compilation fails, the error message is displayed inline in a styled error box (red border, monospace text), matching mdmdview's existing Pikchr/Mermaid error display pattern. Non-fatal warnings (e.g., "feature not yet supported") are collected and returned alongside the SVG for optional display.

### 3.3 Static Rendering Limitations

Since mdmdview rasterizes SVG to a PNG texture via resvg, some D2 features that rely on SVG animation or interactivity are rendered as static approximations:

| D2 Feature | Static Rendering |
|------------|-----------------|
| `animated: true` edges | Rendered as dashed stroke (no animation) |
| `tooltip: "..."` | Ignored (no hover in raster) |
| `link: "..."` | Ignored (no click in raster) |

This is explicitly acceptable — mdmdview is a document viewer, not an interactive diagram tool.

## 4. Architecture

### 4.1 High-Level Pipeline

```
D2 source text (from markdown code block)
    │
    ▼
┌─────────────────────────────────┐
│  Phase 1: PARSER                │
│  d2_parser::parse()             │
│  Input: &str                    │
│  Output: D2Ast (syntax tree)    │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  Phase 2: COMPILER              │
│  d2_compiler::compile()         │
│  Input: D2Ast                   │
│  Output: D2Graph                │
│  - Resolves reserved keywords   │
│  - Builds object hierarchy      │
│  - Creates edge objects         │
│  - Validates styles             │
│  - Sets default shapes/styles   │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  Phase 3: TEXT MEASUREMENT      │
│  Compute node dimensions from   │
│  label text + shape type +      │
│  padding + user overrides       │
│  Includes label wrapping for    │
│  long text (max ~200px default) │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  Phase 4: LAYOUT                │
│  d2_layout::layout()            │
│  Input: D2Graph with dimensions │
│  Output: Positioned graph       │
│  4a. Container-recursive        │
│      Sugiyama node positioning  │
│  4c. Container fitting          │
│  4d. Post-layout adjustments    │
│  4b. Edge routing (last!)       │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  Phase 5: SVG RENDERING         │
│  d2_svg::render()               │
│  Input: Positioned D2Graph      │
│  Output: SVG string             │
│  - Shape drawing                │
│  - Edge paths (cubic Bézier)    │
│  - Labels (with line wrapping)  │
│  - Arrowheads (polygon)         │
│  - Edge label halos             │
│  - Container backgrounds        │
│  - Theme colors (dark/light)    │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  Existing mdmdview pipeline     │
│  usvg parse → resvg render →   │
│  egui texture                   │
└─────────────────────────────────┘
```

### 4.2 Workspace and Crate Structure

D2 lives in a **separate crate** within a Cargo workspace. This provides:
- **Isolation**: D2 changes don't recompile all of mdmdview
- **Fast test cycles**: `cargo test -p mdmdview-d2` runs in seconds, not 8 minutes
- **Clean API boundary**: mdmdview calls one function across the crate boundary
- **Easy to discard**: Remove the workspace member if the experiment fails
- **Dependency isolation**: `petgraph` and `thiserror` only pulled in when the `d2` feature is enabled

Existing Pikchr and Mermaid renderers stay as modules in the main crate — they're small, stable, and coupled to mdmdview's texture/caching internals. D2 is different: large, experimental, with its own dependency tree.

```
mdmdview/                           # workspace root
├── Cargo.toml                      # [workspace] members = [".", "crates/d2"]
├── src/                            # existing mdmdview code (unchanged)
│   ├── main.rs
│   ├── app.rs
│   ├── markdown_renderer.rs        # calls mdmdview_d2::render_d2_to_svg()
│   ├── pikchr_renderer.rs          # stays here — small, stable
│   └── ...
└── crates/
    └── d2/                         # new crate: mdmdview-d2
        ├── Cargo.toml              # [dependencies] petgraph, thiserror
        └── src/
            ├── lib.rs              # Public API (see §4.2.1)
            ├── ast.rs              # AST node types
            ├── parser.rs           # Recursive-descent parser
            ├── compiler.rs         # AST → D2Graph compilation
            ├── graph.rs            # D2Graph, D2Object, D2Edge, Style
            ├── layout.rs           # Sugiyama layout orchestration
            ├── layout_sugiyama.rs  # Sugiyama algorithm implementation
            ├── edge_routing.rs     # Edge path computation and curve generation
            ├── svg_render.rs       # SVG output generation
            ├── shapes.rs           # Shape definitions and path generators
            ├── geo.rs              # Geometry primitives (Point, Rect, etc.)
            ├── text.rs             # Text measurement and wrapping
            ├── theme.rs            # Default colors and dark/light themes
            └── keywords.rs         # Reserved keyword definitions
```

#### 4.2.1 Crate Public API

The `mdmdview-d2` crate exposes a minimal public interface:

```rust
// crates/d2/src/lib.rs

/// Rendering options passed from the host application.
pub struct RenderOptions {
    /// Dark mode (true) or light mode (false). Default: true (matches mdmdview).
    pub dark_mode: bool,
    /// Font family for labels. Default: "Arial, Helvetica, sans-serif".
    pub font_family: String,
}

impl Default for RenderOptions {
    fn default() -> Self {
        Self {
            dark_mode: true,
            font_family: "Arial, Helvetica, sans-serif".into(),
        }
    }
}

/// Result of rendering, including the SVG and any non-fatal warnings.
pub struct RenderResult {
    pub svg: String,
    pub warnings: Vec<D2Warning>,
}

/// Full pipeline: D2 source text → SVG string.
/// This is the primary entry point for mdmdview integration.
pub fn render_d2_to_svg(source: &str, options: &RenderOptions) -> Result<RenderResult, D2Error>;

/// Individual pipeline phases, exposed for testing and debugging.
pub fn parse(source: &str) -> ParseResult;
pub fn compile(ast: &D2Map) -> Result<D2Graph, CompileError>;
/// Layout modifies graph in-place: sets node positions, edge routes,
/// and may append to graph.warnings (e.g., disconnected components, degenerate dimensions).
pub fn layout(graph: &mut D2Graph, options: &RenderOptions) -> Result<(), LayoutError>;
pub fn render_svg(graph: &D2Graph, options: &RenderOptions) -> String;
```

**Note on parse API**: `parse()` returns a `ParseResult` (always contains the AST, plus any errors) rather than `Result<D2Map, ParseError>`. This matches D2's behavior: the parser continues after errors and returns a partial AST alongside diagnostics. The caller decides whether to proceed with a partial AST or bail.

**Error handling in `render_d2_to_svg()`**: If `parse()` returns any errors, `render_d2_to_svg()` immediately returns `Err(D2Error::Parse(errors))`. The partial AST is not compiled. The partial AST exists for future tooling use (LSP, editor integration) via the individual `parse()` function, not for the rendering pipeline.

```rust
pub struct ParseResult {
    pub ast: D2Map,
    pub errors: Vec<ParseError>,
}
```

**Error type hierarchy** (using `thiserror`):

```rust
/// Top-level error from render_d2_to_svg()
#[derive(Debug, thiserror::Error)]
pub enum D2Error {
    #[error("parse errors: {0:?}")]
    Parse(Vec<ParseError>),
    #[error("compile error: {0}")]
    Compile(#[from] CompileError),
    #[error("layout error: {0}")]
    Layout(#[from] LayoutError),
}

/// A single parse diagnostic (position + message)
#[derive(Debug, thiserror::Error)]
#[error("{range}: {message}")]
pub struct ParseError {
    pub message: String,
    pub range: Range,
}

/// Compilation failure
#[derive(Debug, thiserror::Error)]
#[error("{message}")]
pub struct CompileError {
    pub message: String,
    pub range: Option<Range>,
}

/// Layout failure (e.g., cycle detection failure, dimension errors)
#[derive(Debug, thiserror::Error)]
#[error("layout: {0}")]
pub struct LayoutError(pub String);

/// Non-fatal warning (e.g., "feature not yet supported")
#[derive(Debug)]
pub struct D2Warning {
    pub message: String,
    pub range: Option<Range>,
}
```

#### 4.2.2 Workspace Cargo.toml Configuration

Root `Cargo.toml`:
```toml
[workspace]
members = [".", "crates/d2"]

# Shared settings for all workspace members
[workspace.package]
edition = "2021"
```

Main crate `Cargo.toml` (additions):
```toml
[features]
default = ["mermaid-embedded", "pikchr", "d2"]  # d2 is default-enabled
d2 = ["dep:mdmdview-d2"]

[dependencies]
mdmdview-d2 = { path = "crates/d2", optional = true }
```

D2 crate `crates/d2/Cargo.toml`:
```toml
[package]
name = "mdmdview-d2"
version = "0.1.0"
edition.workspace = true

[dependencies]
petgraph = "0.8"
thiserror = "2"
```

**Note**: We use `thiserror` (not `anyhow`) because this is a library crate. `thiserror` derives structured error types that callers can match on. `anyhow` erases error types, which is fine for applications but wrong for libraries.

### 4.3 Key Data Structures

#### 4.3.1 AST (Phase 1 Output)

Mirrors D2's Go AST closely, adapted for Rust idioms:

```rust
/// Top-level map containing all declarations
pub struct D2Map {
    pub nodes: Vec<MapNode>,
    pub range: Range,
}

/// A node within a map
pub enum MapNode {
    Comment(Comment),
    Key(Key),
}

/// A key declaration (shape, edge, or property assignment)
pub struct Key {
    pub key: KeyPath,           // dotted path: "a.b.c"
    pub edges: Vec<Edge>,       // connection chain
    pub edge_index: Option<usize>,      // (a -> b)[0] — D2 syntax index, not petgraph
    pub edge_key: Option<KeyPath>,      // property on edge reference
    pub primary: Option<ScalarValue>,   // label value
    pub value: Option<Value>,           // map, array, or scalar
    pub range: Range,
}

/// A string value with source position tracking
pub struct StringValue {
    pub value: String,
    pub raw: String,            // original source text (before unquoting)
    pub range: Range,
}

/// A comment line
pub struct Comment {
    pub value: String,
    pub range: Range,
}

/// Dotted key path: "server.style.fill"
pub struct KeyPath {
    pub segments: Vec<StringValue>,
}

/// An edge between two keys
pub struct Edge {
    pub src: KeyPath,
    pub dst: KeyPath,
    pub src_arrow: bool,    // <-
    pub dst_arrow: bool,    // ->
    pub range: Range,
}

/// Values that can appear on the right side of ':'
pub enum Value {
    Scalar(ScalarValue),
    Map(D2Map),
    Array(Vec<Value>),
}

pub enum ScalarValue {
    Unquoted(String),
    SingleQuoted(String),
    DoubleQuoted(String),
    Number(f64),
    Boolean(bool),
    // No Null variant — null deletion is out of scope for v1.
    // The parser recognizes `null` and emits a "not yet supported" warning.
}

/// Source position tracking
pub struct Range {
    pub start: Position,
    pub end: Position,
}

pub struct Position {
    pub line: usize,    // 0-indexed
    pub column: usize,  // 0-indexed, byte offset
}
```

#### 4.3.2 Graph IR (Phase 2 Output)

Index-based arena design using petgraph as the backbone:

```rust
use petgraph::stable_graph::{StableDiGraph, NodeIndex, EdgeIndex};

/// The complete diagram graph
pub struct D2Graph {
    /// petgraph backing store — nodes are D2Object, edges are D2EdgeData
    pub graph: StableDiGraph<D2Object, D2EdgeData>,

    /// Root object (implicit top-level container).
    /// The root is special: it has no shape, no label, no border.
    /// It exists only as the parent of top-level objects.
    /// Its `box_` is set to the bounding box of all children after layout.
    /// The SVG renderer must NOT draw a shape or label for the root —
    /// only its `box_` contributes to the viewBox computation.
    pub root: NodeIndex,

    /// All objects in declaration order (preserved for deterministic iteration).
    /// petgraph's node_indices() order may differ from source order.
    pub objects: Vec<NodeIndex>,

    /// All edges in declaration order (preserved for deterministic rendering).
    pub edges: Vec<EdgeIndex>,

    /// Top-level layout direction (default: Down).
    /// Per-container overrides stored on D2Object.direction.
    pub direction: Direction,

    /// Non-fatal warnings accumulated during compilation.
    /// Includes "feature not yet supported" for deferred keywords.
    /// Extracted into RenderResult.warnings by render_d2_to_svg().
    pub warnings: Vec<D2Warning>,
}

/// A shape/container in the diagram
pub struct D2Object {
    pub id: String,                 // fully qualified: "group.server"
    pub label: String,              // display text
    pub shape: ShapeType,           // rectangle, circle, etc.
    pub style: Style,               // visual properties

    // Hierarchy
    pub parent: Option<NodeIndex>,
    pub children: Vec<NodeIndex>,

    // Per-container direction override (None = inherit from parent/graph)
    pub direction: Option<Direction>,

    // Geometry (populated during layout, using top-left coordinate convention)
    pub box_: Option<Rect>,         // position + size after layout
    pub label_dimensions: Option<(f64, f64)>,  // measured text size (pre-layout)
    pub label_lines: Vec<String>,   // label text after wrapping (pre-layout)

    /// Whether this object is a container (has children).
    /// Affects label positioning:
    /// - Non-containers: label centered on shape
    /// - Containers: label top-left aligned inside container (padded from top-left corner)
    pub is_container: bool,
}

/// An edge/connection.
/// Source and target nodes are stored by petgraph on the edge itself
/// (accessible via graph.edge_endpoints(idx)). We don't duplicate them here.
pub struct D2EdgeData {
    pub label: Option<String>,
    pub src_arrow: ArrowheadType,
    pub dst_arrow: ArrowheadType,
    pub style: Style,

    // Geometry (populated during layout/routing)
    /// Cubic Bézier control points for the edge path.
    /// Format: [start, ctrl1, ctrl2, end, ctrl1, ctrl2, end, ...]
    /// The first point is the clipped start on the source shape.
    /// Each subsequent group of 3 points defines one cubic Bézier segment.
    pub route: Vec<Point>,
    /// Position for the edge label (midpoint of the path, offset to avoid overlap)
    pub label_position: Option<Point>,
}

pub enum ShapeType {
    Rectangle, Square, Circle, Oval, Diamond, Hexagon,
    Cylinder, Cloud, Person, Package, Queue, Page,
    Parallelogram, Document, Step, Callout, StoredData,
    Text, Code,
}

pub struct Style {
    pub fill: Option<Color>,
    pub stroke: Option<Color>,
    pub stroke_width: Option<f64>,
    pub stroke_dash: Option<f64>,
    pub font_size: Option<f64>,
    pub font_color: Option<Color>,
    pub bold: bool,
    pub italic: bool,
    pub underline: bool,
    pub border_radius: Option<f64>,
    pub opacity: Option<f64>,
    pub shadow: bool,
    pub three_d: bool,
    pub multiple: bool,
    pub animated: bool,         // Rendered as dashed in static output
    pub double_border: bool,
}

pub enum Direction {
    Down,   // TB - default
    Up,     // BT
    Right,  // LR
    Left,   // RL
}

pub enum ArrowheadType {
    Arrow,          // default ->
    Triangle,
    Diamond,
    FilledDiamond,
    Circle,
    FilledCircle,
    CfOne,
    CfMany,
    CfOneRequired,
    CfManyRequired,
    None,
}

/// Color representation.
/// Named colors are resolved to RGB during compilation using the SVG named
/// color table (148 colors: https://www.w3.org/TR/css-color-3/#svg-color).
pub enum Color {
    Hex(u8, u8, u8),           // #rrggbb
    HexAlpha(u8, u8, u8, u8), // #rrggbbaa
}
```

**Design note**: `Color::Named` was removed in V2. Named colors (e.g., `"red"`, `"blue"`) are resolved to `Color::Hex` during compilation, not stored as strings. This avoids pushing color resolution into the SVG renderer and keeps the color representation uniform throughout the pipeline. The compiler uses a lookup table of SVG/CSS named colors.

#### 4.3.3 Geometry Primitives

```rust
/// All coordinates use top-left origin convention:
/// - x increases rightward
/// - y increases downward
/// - Rect.x/y is the top-left corner of the rectangle
///
/// This matches SVG's coordinate system, so no conversion is needed
/// when generating SVG output.

#[derive(Clone, Copy, Debug)]
pub struct Point {
    pub x: f64,
    pub y: f64,
}

#[derive(Clone, Copy, Debug)]
pub struct Rect {
    pub x: f64,      // top-left x
    pub y: f64,      // top-left y
    pub width: f64,
    pub height: f64,
}

impl Rect {
    pub fn center(&self) -> Point {
        Point { x: self.x + self.width / 2.0, y: self.y + self.height / 2.0 }
    }
}
```

#### 4.3.4 Theme and Default Styles

```rust
pub struct Theme {
    /// Default node fill
    pub node_fill: Color,
    /// Default node stroke
    pub node_stroke: Color,
    /// Default node label color
    pub font_color: Color,
    /// Default edge stroke
    pub edge_color: Color,
    /// Default container fill (slightly different from node)
    pub container_fill: Color,
    /// Background color for the diagram
    pub background: Color,
    /// Default font size in pixels
    pub font_size: f64,
    /// Default stroke width
    pub stroke_width: f64,
}

impl Theme {
    pub fn dark() -> Self {
        Self {
            node_fill: Color::Hex(0x2A, 0x2A, 0x2A),       // dark gray
            node_stroke: Color::Hex(0x88, 0x88, 0x88),      // medium gray
            font_color: Color::Hex(0xE0, 0xE0, 0xE0),       // light gray
            edge_color: Color::Hex(0x88, 0x88, 0x88),        // medium gray
            container_fill: Color::Hex(0x1A, 0x1A, 0x1A),    // darker gray
            background: Color::Hex(0x00, 0x00, 0x00),         // black (matches mdmdview)
            font_size: 14.0,
            stroke_width: 2.0,
        }
    }

    pub fn light() -> Self {
        Self {
            node_fill: Color::Hex(0xFF, 0xFF, 0xFF),         // white
            node_stroke: Color::Hex(0x33, 0x33, 0x33),       // dark gray
            font_color: Color::Hex(0x17, 0x17, 0x17),        // near black
            edge_color: Color::Hex(0x33, 0x33, 0x33),         // dark gray
            container_fill: Color::Hex(0xF5, 0xF5, 0xF5),     // light gray
            background: Color::Hex(0xFF, 0xFF, 0xFF),          // white
            font_size: 14.0,
            stroke_width: 2.0,
        }
    }
}
```

### 4.4 Phase Details

#### Phase 1: Parser

**Approach**: Hand-written recursive descent parser in Rust, closely following the structure of D2's Go parser (`d2parser/parse.go`, 1,891 lines).

**Why not a parser generator?** D2's syntax is context-sensitive (unquoted strings behave differently in keys vs values, edge operators are multi-character, and the parser needs multi-error recovery for editor tooling). The Go implementation is hand-written for the same reasons.

**Unquoted string complexity**: D2 allows unquoted strings that contain spaces. For example, `My Server -> Your Server` is valid D2: both `My Server` and `Your Server` are node identifiers. The parser terminates an unquoted string when it encounters a **reserved character sequence** (`->`, `--`, `<-`, `<->`, `:`, `.`, `{`, `}`, `;`, `#`, `\n`), not at whitespace boundaries. This makes the tokenizer significantly more context-dependent than typical languages and is a key reason the Go parser is 1,891 lines. The Rust parser will need the same approach: scan forward accumulating characters until a reserved sequence is found, then trim trailing whitespace from the accumulated string.

**Translation strategy**: The Go parser is the most amenable to LLM-assisted translation. It's mostly pure functions operating on a reader/lookahead buffer. Key mappings:
- Go `io.RuneReader` → Rust `std::str::Chars` with a peekable buffer
- Go `parser` struct → Rust `Parser` struct with identical fields
- Go slice of errors → Rust `Vec<ParseError>`
- Go `d2ast.MapNodeBox` (tagged union via struct) → Rust `enum MapNode`

**Error handling**: The parser collects multiple errors and continues, returning a partial AST. This matches D2 behavior and supports future LSP integration. The return type is `ParseResult` (always contains AST + errors), not `Result<D2Map, ParseError>`. See §4.2.1.

**Entry point**:
```rust
pub fn parse(source: &str) -> ParseResult {
    let mut parser = Parser::new(source);
    let map = parser.parse_map(true); // true = file-level map
    ParseResult {
        ast: map,
        errors: parser.errors,
    }
}
```

#### Phase 2: Compiler

**Approach**: Reimplement from D2's Go design, idiomatic Rust.

The compiler walks the AST and builds the `D2Graph`:
1. **Collect declarations**: Walk all `Key` nodes, build object/edge lists
2. **Resolve hierarchy**: Dotted keys like `group.server` create parent-child relationships
3. **Apply reserved keywords**: `shape`, `label`, `style.*`, `direction`, `width`, `height`
4. **Resolve named colors**: Convert string color identifiers (parsed as `ScalarValue::Unquoted`, e.g., `"red"`) to `Color::Hex` via lookup table during style processing
5. **Validate**: Check shape types, style values, connection endpoints
6. **Set defaults**: Rectangle shape, `Style` fields left as `None`/`false` where not explicitly set. Theme-based defaults (fill color, stroke, font color) are resolved later during SVG rendering using `Theme::dark()` or `Theme::light()` based on `RenderOptions.dark_mode`. This keeps compilation theme-independent.
7. **Collect warnings**: Emit "not yet supported" for recognized but deferred keywords

**Label text is plain text in v1**: Labels like `"**bold**"` are rendered as literal characters, not interpreted as markdown or rich text. Markdown-in-labels and LaTeX-in-labels are out of scope (see §3.1.1).

Since v1 excludes variables, globs, imports, and layers, this compiler is significantly simpler than D2's full `d2ir` + `d2compiler` two-phase pipeline. We collapse both into a single pass.

#### Phase 3: Text Measurement

Before layout, each node needs pixel dimensions computed from its label text.

**Approach**: Heuristic measurement using average character widths for proportional fonts, with label wrapping for long text. This doesn't need to be pixel-perfect — the layout just needs reasonable width/height estimates. The final text rendering is done by resvg with real font metrics.

```rust
/// Maximum label width before wrapping (pixels at default font size)
const MAX_LABEL_WIDTH: f64 = 200.0;

/// Measure and wrap a label, returning wrapped lines and total dimensions.
fn measure_and_wrap_label(
    text: &str,
    font_size: f64,
    font_family: &str,
) -> (Vec<String>, f64, f64) {
    // Average character width for proportional fonts (empirical)
    // Arial at 14px: average ~7.5px per character
    let avg_char_width = font_size * 0.55;
    let line_height = font_size * 1.4;
    let max_width = MAX_LABEL_WIDTH * (font_size / 14.0);

    // Word-wrap into lines
    let mut lines = Vec::new();
    let mut current_line = String::new();
    let mut current_width = 0.0;

    for word in text.split_whitespace() {
        let word_width = word.chars().count() as f64 * avg_char_width;
        if current_width + word_width > max_width && !current_line.is_empty() {
            lines.push(current_line.clone());
            current_line.clear();
            current_width = 0.0;
        }
        if !current_line.is_empty() {
            current_line.push(' ');
            current_width += avg_char_width;
        }
        current_line.push_str(word);
        current_width += word_width;
    }
    if !current_line.is_empty() {
        lines.push(current_line);
    }

    let width = lines.iter()
        .map(|l| l.chars().count() as f64 * avg_char_width)
        .fold(0.0f64, f64::max);
    let height = lines.len() as f64 * line_height;

    (lines, width, height)
}
```

Node dimensions = label dimensions + shape padding + user overrides (`width`/`height`).

**Shape padding**: Different shapes need different padding to accommodate their geometry:
| Shape | Horizontal Padding | Vertical Padding | Rationale |
|-------|-------------------|-----------------|-----------|
| Rectangle/Square | 20px | 12px | Standard box padding |
| Circle/Oval | 30px | 20px | Inscribed text needs more room |
| Diamond | 40px | 30px | Diagonal edges waste more space |
| Hexagon | 25px | 15px | Slightly more than rectangle |
| Cylinder | 20px | 20px | Extra top/bottom for 3D cap |
| Text | 0px | 0px | No border, no padding |
| All other shapes | 20px | 12px | Default to rectangle padding |

All `ShapeType` variants not explicitly listed (Person, Package, Queue, Page, Parallelogram, Document, Step, Callout, StoredData, Code) use the default rectangle padding. These values are initial estimates; they'll be tuned during differential testing against the Go implementation.

**Text measurement is invoked by `layout()`**: Since text measurement depends on `font_family` from `RenderOptions`, the `layout()` function accepts `&RenderOptions` and performs text measurement internally before running the Sugiyama algorithm.

#### Phase 4: Layout

**This is the hardest phase.** The design follows four sub-phases, executed in this order:

1. **4a**: Node positioning (Sugiyama) — recursive, bottom-up
2. **4c**: Container fitting — refine container bounds after positioning
3. **4d**: Post-layout adjustments — normalize spacing
4. **4b**: Edge routing — **last**, after all positions are finalized

This ordering is critical: edges must be routed after all node/container positions are final, otherwise position adjustments would invalidate edge paths.

##### 4a. Container-Recursive Sugiyama Node Positioning

**Approach**: Own Sugiyama implementation built on petgraph, using D2's Go dagre wrapper as the design specification.

**Why not rust-sugiyama?** Validation revealed three blocking issues:
1. Its API does **not** accept node dimensions — all nodes are treated as points, causing overlap with variable-sized nodes
2. The `from_graph` API has a **known infinite loop bug** (issue #25, Jan 2026)
3. It has no concept of compound graphs (containers), which we need for D2

Our implementation uses petgraph's `StableDiGraph` as the graph backbone and implements the four classic Sugiyama phases with full node-size awareness:

**Phase 4a-i: Cycle Removal**
- Use petgraph's `greedy_feedback_arc_set()` to identify back-edges (available since petgraph 0.6; verify API path in 0.8 — fallback: simple DFS-based back-edge detection, ~30 lines)
- Temporarily reverse back-edges to make the graph acyclic
- After layout, restore original edge directions (visual arrow direction is preserved via `D2EdgeData.src_arrow`/`dst_arrow`)

**Phase 4a-ii: Rank Assignment**
- **v1**: Longest-path ranking (~50 lines, simple DFS). Assigns each node to a layer based on its longest incoming path. Produces correct but not always optimal layouts.
- **Future**: Network simplex ranking (minimizes total edge length). More complex (~300 lines) but produces tighter layouts. Upgrade when visual quality demands it.
- User-specified `width`/`height` constraints are applied after ranking.

**Phase 4a-iii: Crossing Reduction**
- Barycenter heuristic: for each layer, sort nodes by the average position of their neighbors in the adjacent layer
- Iterative sweeps: alternate downward and upward passes, 12-24 iterations (matching dagre's default)
- Track crossing count; keep the ordering that produces the fewest crossings

**Phase 4a-iv: Coordinate Assignment (Node-Size-Aware)**
- Brandes-Köpf algorithm with node-size awareness:
  - Four alignment passes (upper-left, upper-right, lower-left, lower-right)
  - Each pass computes x-coordinates respecting actual node widths + spacing
  - Final position = median of the four alignments (reduces bias)
- Y-coordinates (or X for horizontal layouts) assigned by rank, with uniform rank spacing adjusted for the tallest node in each rank
- Minimum node spacing: configurable, default 40px horizontal, 60px vertical

**Container handling (recursive layout)**:

D2 handles containers by recursively laying out each container's children as a sub-graph:

1. **Bottom-up traversal**: Start from leaf containers (containers with no child containers)
2. **Lay out children**: Run Sugiyama on the container's direct children (treating each child container as an opaque node with its already-computed dimensions)
3. **Size the container**: Container dimensions = bounding box of positioned children + padding + label area
4. **Repeat upward**: The sized container becomes a node in its parent's layout

**Cross-container edges**: Edges that cross container boundaries are handled in two stages:
- **During layout**: Cross-container edges contribute to the rank assignment and ordering at the *lowest common ancestor* (LCA) container's level. The LCA is found by walking `D2Object.parent` pointers from both endpoints until they meet. Each endpoint is represented by its ancestor container at the LCA's child level.
- **During routing (Phase 4b)**: The actual edge path is computed after all node positions are finalized, routing through container boundaries.

This matches D2's own architecture. The key insight is that cross-container edges affect *ordering* (which container appears left/right) but the detailed routing is deferred.

**Per-container direction**: Each container can override `direction`. When laying out a container's children, we use that container's direction (falling back to the parent's, ultimately to the graph-level default). This means a top-level `direction: right` graph can contain a sub-container with `direction: down`.

**Disconnected components**: When a container (or the root graph) has multiple disconnected sub-graphs, each component is laid out independently, then arranged side-by-side (horizontal stacking for top-down layouts, vertical stacking for left-right layouts) with a gap between components. Default gap: 60px (matching dagre's `ranksep` default). This is a constant in `layout.rs`, not a user-facing option.

##### 4b. Edge Routing (Shape-Aware)

**No existing Rust crate provides edge routing for hierarchical layouts.** Neither `dagre-rs`, `rust-sugiyama`, nor `layout-rs` (adequately) return edge paths. This matches D2's own architecture: even with full dagre.js, D2 writes ~200 lines of custom edge routing.

We implement edge routing from the D2 Go source as design specification:

1. **Straight waypoints**: Connect source center → destination center via rank-aligned waypoints
2. **Shape-aware clipping**: Clip edge endpoints to shape boundaries using shape-specific intersection:
   - **Rectangle/Square**: Line-rectangle intersection (4 edge tests)
   - **Circle/Oval**: Line-ellipse intersection (parametric equation)
   - **Diamond**: Line intersection with 4 diagonal edges
   - **Hexagon**: Line intersection with 6 edges
   - **Other shapes**: Fall back to bounding-box rectangle intersection
3. **Curve generation**: Convert waypoints to cubic Bézier curves:
   - First segment: control point at 80% along vector
   - Intermediate: control points at 20%, 50%, 80% positions
   - Produces smooth SVG `C` (curveto) commands
4. **Minimum segment length**: Extend short segments to prevent arrowhead rendering artifacts

```rust
/// Route an edge between two shapes, returning Bézier control points.
fn route_edge(
    src_shape: ShapeType,
    src_rect: &Rect,
    dst_shape: ShapeType,
    dst_rect: &Rect,
    waypoints: &[Point],
) -> Vec<Point> {
    let clipped_start = clip_to_shape(src_shape, src_rect, waypoints[0], waypoints[1]);
    let clipped_end = clip_to_shape(dst_shape, dst_rect, *waypoints.last().unwrap(),
                                     waypoints[waypoints.len() - 2]);
    // ... generate Bézier control points ...
    todo!()
}

/// Clip a line segment to a shape boundary.
fn clip_to_shape(shape: ShapeType, rect: &Rect, from: Point, toward: Point) -> Point {
    match shape {
        ShapeType::Circle | ShapeType::Oval => clip_to_ellipse(rect, from, toward),
        ShapeType::Diamond => clip_to_diamond(rect, from, toward),
        ShapeType::Hexagon => clip_to_hexagon(rect, from, toward),
        _ => clip_to_rect(rect, from, toward),  // rectangle fallback
    }
}
```

**Self-edges** (`a -> a`): Rendered as a loop arc — a cubic Bézier that exits the shape at the top, arcs outward, and re-enters at the right (adjustable by layout direction). The loop size is proportional to the node dimensions.

**Parallel edges** (`a -> b` appearing multiple times): Supported via petgraph's `StableDiGraph`, which allows multiple edges between the same pair. During routing, parallel edges are offset from each other to prevent overlap (spacing them evenly around the center line).

**Empty diagrams**: If the D2 source is empty or contains only comments, `render_d2_to_svg()` returns a minimal SVG with just the background color and no elements. This avoids special-casing in the caller.

##### 4c. Container Fitting

After layout, containers are fitted to their children:
1. Compute bounding box of all children
2. Add padding for container label (top) and margins (all sides)
3. Ensure label doesn't overlap child shapes (offset children downward if needed)
4. Adjust container bounds

##### 4d. Post-Layout Adjustments

Following D2's Go implementation, three adjustment passes refine the layout:
1. **`adjust_rank_spacing()`**: Normalize vertical (or horizontal) gaps between ranks
2. **`adjust_cross_rank_spacing()`**: Normalize gaps perpendicular to the layout direction
3. **`fit_container_padding()`**: Ensure container padding is consistent after position adjustments

#### Phase 5: SVG Rendering

Generate SVG strings from positioned graph. The SVG uses a computed viewBox based on the bounding box of all elements plus padding:

```rust
fn compute_viewbox(graph: &D2Graph) -> (f64, f64, f64, f64) {
    let padding = 20.0;
    let mut min_x = f64::INFINITY;
    let mut min_y = f64::INFINITY;
    let mut max_x = f64::NEG_INFINITY;
    let mut max_y = f64::NEG_INFINITY;

    // Include all node bounding boxes
    for idx in &graph.objects {
        if let Some(rect) = &graph.graph[*idx].box_ {
            min_x = min_x.min(rect.x);
            min_y = min_y.min(rect.y);
            max_x = max_x.max(rect.x + rect.width);
            max_y = max_y.max(rect.y + rect.height);
        }
    }

    // Include all edge route control points (self-loops and curved
    // edges may extend beyond node bounding boxes)
    for idx in &graph.edges {
        let edge = &graph.graph[*idx];
        for pt in &edge.route {
            min_x = min_x.min(pt.x);
            min_y = min_y.min(pt.y);
            max_x = max_x.max(pt.x);
            max_y = max_y.max(pt.y);
        }
    }

    (min_x - padding, min_y - padding,
     (max_x - min_x) + 2.0 * padding,
     (max_y - min_y) + 2.0 * padding)
}
```

SVG structure:

The SVG z-ordering follows D2's Go implementation (`lib/svg/svg.go`). Later elements are drawn on top. The order is:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="{x} {y} {w} {h}">
  <!-- Layer 1: Background -->
  <rect x="{x}" y="{y}" width="{w}" height="{h}" fill="{bg}" />

  <!-- Layer 2: Container fills (outermost first, for nested containers) -->
  <rect x="{x}" y="{y}" width="{w}" height="{h}" rx="{r}"
        fill="{fill}" stroke="{stroke}" stroke-width="{sw}" />

  <!-- Layer 3: Shape fills + strokes (nodes drawn on top of container fills) -->
  <rect ... />     <!-- rectangle -->
  <ellipse ... />  <!-- circle/oval -->
  <polygon ... />  <!-- diamond/hexagon -->

  <!-- Layer 4: Edges + arrowheads (on top of shapes — endpoints are clipped
       to shape boundaries, so no overlap with shape interiors) -->
  <path d="M {x0} {y0} C {cx1} {cy1} {cx2} {cy2} {x1} {y1}"
        stroke="{color}" fill="none" stroke-width="{sw}" />
  <polygon points="{tip_x},{tip_y} {left_x},{left_y} {right_x},{right_y}"
           fill="{color}" />

  <!-- Layer 5: All labels (topmost — always readable) -->
  <!-- Container labels (top-left aligned inside container) -->
  <text x="{container_x + pad}" y="{container_y + pad + font_size}"
        font-family="{font}" font-size="{fs}" fill="{color}"
        dominant-baseline="auto">{container_label}</text>
  <!-- Edge labels with background halo for readability -->
  <!-- bg_color = theme.background (black in dark mode, white in light mode) -->
  <rect x="{lbl_x - pad}" y="{lbl_y - pad}" width="{lbl_w + 2*pad}" height="{lbl_h + 2*pad}"
        fill="{bg_color}" opacity="0.85" rx="2" />
  <text x="{label_x}" y="{label_y}" font-family="{font}" font-size="{fs}"
        fill="{color}" text-anchor="middle" dominant-baseline="central"
        >{edge_label}</text>
  <!-- Node labels (centered on shape) -->
  <text x="{cx}" y="{cy}" font-family="{font}" font-size="{fs}"
        fill="{color}" text-anchor="middle" dominant-baseline="central">
    <tspan x="{cx}" dy="0">{line1}</tspan>
    <tspan x="{cx}" dy="{line_height}">{line2}</tspan>
  </text>
</svg>
```

**Arrowheads**: Rendered as explicit `<polygon>` triangles at edge endpoints, **not** SVG `<marker>` elements. This avoids resvg compatibility issues with `orient=auto-start-reverse` (which has limited support). The arrowhead polygon is computed during SVG generation from the edge's terminal control points:

```rust
/// Compute arrowhead triangle at the endpoint of an edge.
/// `tip` is the point where the edge meets the shape.
/// `from` is the previous control point (gives direction).
/// Returns three polygon vertices: (tip, left, right).
fn arrowhead_polygon(tip: Point, from: Point, size: f64) -> (Point, Point, Point) {
    let dx = tip.x - from.x;
    let dy = tip.y - from.y;
    let len = (dx * dx + dy * dy).sqrt();
    if len < 1e-6 {
        // Degenerate: tip ≈ from. Default to pointing downward.
        return (tip,
                Point { x: tip.x - size * 0.4, y: tip.y - size },
                Point { x: tip.x + size * 0.4, y: tip.y - size });
    }
    let ux = dx / len;  // unit vector along edge
    let uy = dy / len;
    let base_x = tip.x - ux * size;
    let base_y = tip.y - uy * size;
    let half_width = size * 0.4;
    let left = Point { x: base_x - uy * half_width, y: base_y + ux * half_width };
    let right = Point { x: base_x + uy * half_width, y: base_y - ux * half_width };
    (tip, left, right)
}
```

This matches mdmdview's existing Pikchr renderer, which uses explicit `<polygon>` arrowheads and renders correctly with resvg.

**Multi-line labels**: Long labels wrapped during Phase 3 are rendered using SVG `<tspan>` elements within a `<text>` parent. Each line gets its own `<tspan>` with a `dy` offset equal to the line height.

**Font specification**: SVG `<text>` elements use `font-family` from `RenderOptions`. The same font family is used for text measurement heuristics in Phase 3. Since resvg resolves fonts from the system, measurements won't be pixel-perfect, but will be close enough for layout purposes.

**Root object guard**: The SVG renderer iterates `graph.objects` to draw shapes and labels. The `graph.root` index MUST be skipped — root has no visual representation (see §4.3.2). Without this guard, root would render as an unexpected rectangle at the origin.

Shape-specific SVG generators are needed for each `ShapeType`. Prioritize rectangle, circle, diamond, cylinder as they cover most usage.

**Special style rendering**: Three styles require non-trivial SVG techniques:

| Style | SVG Rendering | Complexity |
|-------|--------------|------------|
| `shadow: true` | Duplicate shape offset by (3px, 3px) with `opacity="0.3"` drawn behind the main shape. Simple and resvg-compatible. No SVG filters needed. | Low |
| `3d: true` | Extra parallelogram face on bottom-right of shape (like an extruded rectangle). Fill with slightly darker shade of the shape's fill color. Straightforward for rectangles and cylinders; approximated for curves. | Medium |
| `multiple: true` | Draw 2 offset copies of the shape behind the main one (offsets: +4px,+4px and +8px,+8px) with the same fill/stroke. Creates a "stacked cards" visual. | Low |

These are handled during SVG generation (Phase 5), not layout (Phase 4). They don't affect node dimensions — the shadow/3D/multiple copies are decorative and extend beyond the layout bounding box. The `compute_viewbox()` function should include a small extra margin when these styles are present.

## 5. Implementation Strategy

### 5.1 Translation and Reimplementation Mix

| Component | Approach | Rationale |
|-----------|----------|-----------|
| **Parser** | LLM-assisted translation from Go | Most mechanical, maps cleanly |
| **AST types** | LLM-assisted translation | Direct type mapping |
| **Keywords** | Direct translation | Constants and enums |
| **Compiler** | Reimplementation from Go design | Ownership model differs, simpler for v1 subset |
| **Graph types** | Reimplementation (index-based) | Arena allocation decision drives design |
| **Layout (Sugiyama)** | Own implementation on petgraph | No existing Rust crate handles node-sized compound graphs (see §4.4 Phase 4a) |
| **Edge routing** | Reimplementation from Go design | No existing Rust solution |
| **SVG renderer** | Written from scratch | Simple string building, mdmdview-specific |
| **Shape paths** | Written from scratch | SVG path generation per shape |
| **Arrowheads** | Written from scratch (polygon) | Explicit `<polygon>` triangles, matches Pikchr approach |
| **Text measurement** | Written from scratch | Simple heuristic, no Go equivalent needed |
| **Theme/colors** | Written from scratch | mdmdview-specific dark/light themes |

### 5.2 Phased Delivery

**Phase 1: Parser + AST** (~3-4 days)
- Implement all AST types
- Hand-written recursive descent parser
- Parse all v1 syntax features
- Unit tests against D2's test corpus (35 parser fixtures)
- Validate: parse → serialize → compare with D2 Go output

**Phase 2: Compiler + Graph** (~3-4 days)
- Implement D2Graph with petgraph backbone
- Single-pass AST → Graph compilation
- Reserved keyword handling
- Style validation and named color resolution
- Theme defaults
- Unit tests for compilation

**Phase 3: Layout** (~5-7 days)
- Implement own Sugiyama algorithm on petgraph (cycle removal, ranking, crossing reduction, coordinate assignment)
- Node-size-aware coordinate assignment (Brandes-Köpf)
- Implement container recursive layout (bottom-up)
- Implement shape-aware edge routing with curve generation
- Text measurement and wrapping heuristics
- This is the riskiest phase — budget extra time

**Phase 4: SVG Rendering** (~2-3 days)
- Shape-specific SVG generators
- Edge path rendering (Bézier curves)
- Arrowhead polygon generation
- Multi-line label placement with `<tspan>`
- Container backgrounds
- Style application (colors, dashes, opacity, etc.)
- Dark/light theme application

**Phase 5: Integration + Polish** (~2-3 days)
- Set up workspace: root `Cargo.toml` with `[workspace]`, move nothing — main crate stays in place
- Create `crates/d2/` with its own `Cargo.toml`
- Add `d2` feature flag to main crate (default-enabled like `mermaid-embedded` and `pikchr`)
- Wire `markdown_renderer.rs` to call `mdmdview_d2::render_d2_to_svg()` behind `#[cfg(feature = "d2")]`
- LRU texture caching (reuse existing `LruCache` in main crate)
- Dark mode: pass `RenderOptions { dark_mode: true, .. }` from mdmdview
- Zoom scaling
- Error display: show D2Error in styled error box (matching Pikchr/Mermaid pattern)
- Warning display: optionally show non-fatal warnings

### 5.3 Estimated Total: ~2-3 weeks

## 6. Testing Strategy

### 6.1 Differential Testing (Primary Oracle)

The Go `d2` CLI is the correctness oracle. For every test case:

```
                    ┌──────────┐
  test.d2 ───────►  │ d2 (Go)  │ ───► expected.svg
                    └──────────┘
                    ┌──────────┐
  test.d2 ───────►  │ Rust impl│ ───► actual.svg
                    └──────────┘
                         │
                    ┌──────────┐
                    │ Compare  │
                    └──────────┘
```

**Comparison method**: Rasterize both SVGs via `resvg` → PNG, then pixel-diff with tolerance. We already have the `resvg` pipeline.

Exact pixel matching is too strict (floating-point differences in positions, different SVG attribute ordering). Instead:
- Rasterize at fixed resolution (e.g., 2x scale)
- Compare pixel-by-pixel with tolerance (e.g., allow RGB diff ≤ 5 per channel)
- Report percentage of differing pixels
- Threshold: <2% pixel difference = PASS

**Dev dependency setup**: Differential tests require the Go `d2` CLI:
```bash
# Install Go (if not present)
# https://go.dev/dl/

# Install d2 CLI
go install oss.terrastruct.com/d2@latest

# Verify
d2 --version
```

Differential tests are gated behind a `#[cfg(feature = "diff-tests")]` flag so they don't run in normal CI (which may not have Go installed). Golden files generated from differential tests are checked into the repo for regression testing without Go.

### 6.2 Unit Tests

Each phase gets dedicated unit tests:

- **Parser**: Parse D2 snippets → assert AST structure. Harvest fixtures from D2's `testdata/d2parser/TestParse/` (35 golden files)
- **Compiler**: Compile AST → assert graph topology, object attributes, edge connections
- **Layout**: Fixed-input graphs → assert node positions within tolerance
- **SVG**: Render positioned graphs → validate SVG structure (well-formed XML, correct elements)

### 6.3 Test Corpus

Sources for test inputs:
1. **D2's own test fixtures**: `testdata/d2parser/`, `testdata/d2compiler/` (238 fixtures), `e2etests/stable/` (100+ visual regression tests)
2. **D2 documentation examples**: Extracted from d2lang.com tour pages
3. **Real-world D2 files**: Architecture diagrams from open-source projects
4. **Fuzzing**: Property-based tests for parser robustness

### 6.4 Regression Suite

Once the initial implementation passes differential tests, the expected SVGs become golden files for regression testing (no Go CLI dependency needed for CI).

## 7. Dependencies

### mdmdview-d2 Crate Dependencies

| Crate | Version | Purpose | Size Impact |
|-------|---------|---------|-------------|
| `petgraph` | 0.8.x | Graph data structure backbone (StableDiGraph, algorithms) | Small (pure Rust) |
| `thiserror` | 2.x | Structured error types for library | Tiny (proc-macro) |

These dependencies are **isolated to the D2 crate**. When the `d2` feature is disabled, they are not compiled or linked into the mdmdview binary.

**Note**: `rust-sugiyama` was evaluated and rejected — see §4.4 Phase 4a for rationale. The Sugiyama algorithm is implemented directly on petgraph.

### Main Crate Additions

| Crate | Version | Purpose |
|-------|---------|---------|
| `mdmdview-d2` | 0.1.0 (path) | D2 rendering (optional, behind `d2` feature flag) |

### Existing Dependencies (Reused by Main Crate)

| Crate | Purpose |
|-------|---------|
| `usvg` / `resvg` / `tiny-skia` | SVG → raster (already used for Pikchr, Mermaid) |

### No New Large Dependencies

No JS runtime, no WASM, no C libraries. The D2 crate is pure Rust. Total new dependency footprint is minimal — `petgraph` + `thiserror` are small, well-maintained crates.

## 8. Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Own Sugiyama implementation has bugs or produces poor layouts | Medium | High | Use D2's Go dagre wrapper + dagre.js wiki as design spec; differential test heavily against Go CLI output |
| Brandes-Köpf coordinate assignment is complex to implement correctly | Medium | Medium | Start with simple left-aligned placement; upgrade to Brandes-Köpf iteratively. Simpler fallback produces acceptable (if not optimal) results |
| Layout output differs significantly from D2 Go | High | Medium | Accept "close enough" rather than pixel-perfect; focus on correct topology |
| Parser edge cases in D2 syntax (especially unquoted strings with spaces) | Medium | Medium | Harvest D2's parser test fixtures (35+ cases); add targeted tests for space-containing identifiers and edge operator ambiguity |
| Edge routing produces ugly results | Medium | Medium | D2's own edge routing is well-documented in Go source; iterate with visual comparison |
| Performance on large diagrams | Low | Low | Most D2 diagrams are <100 nodes; layout is O(V²) at worst |
| Text measurement inaccuracy causes overlapping nodes | Medium | Medium | Conservative padding; tune heuristic against visual comparison with Go output |
| Font rendering differences between measurement and resvg | Medium | Low | Use same font family string; accept minor misalignment |
| Cross-container edge routing produces wrong paths | Medium | High | Simplify: route through container boundaries with waypoints at boundary crossings |
| Scope creep — temptation to add features beyond v1 subset | Medium | Medium | Strict v1 feature boundary; out-of-scope features emit warnings, not errors |

## 9. Future Expansion (Post-v1)

Rough priority order for features to add after v1 ships:

1. **Near constraint** (`near: ...`) — deferred from v1, popular layout directive
2. **Variables and substitution** (`vars: { }`, `${var}`) — most requested advanced feature
3. **Classes** (`classes: { }`) — style reuse, common in large diagrams
4. **Icons** (`icon: ...`) — visual richness
5. **Sequence diagrams** — separate layout algorithm, high value
6. **Grid diagrams** — separate layout algorithm
7. **Imports** (`@file`) — composition
8. **Globs** (`*.style.fill: red`) — bulk styling
9. **Layers/scenarios/steps** — board composition
10. **SQL tables / UML classes** — specialized shapes
11. **Block strings** — multi-line text
12. **Themes** — color scheme system

Each expansion can be tested differentially against the Go CLI, using the same oracle approach.

## 10. References

- [D2 GitHub Repository](https://github.com/terrastruct/d2) — Go source code
- [D2 Documentation](https://d2lang.com/) — Language tour and reference
- [D2 Cheat Sheet](https://terrastruct-site-assets.s3.us-west-1.amazonaws.com/documents/d2_cheat_sheet.pdf)
- [D2 DeepWiki Architecture](https://deepwiki.com/terrastruct/d2) — Architecture analysis
- [dagre-rs](https://github.com/TangleGuard/dagre-rs) — Rust dagre (reference only; too incomplete)
- [layout-rs](https://github.com/nadavrot/layout) — Rust graph layout + SVG (reference)
- [rust-sugiyama](https://crates.io/crates/rust-sugiyama) — Evaluated and rejected (no node dimensions, infinite loop bug, no compound graphs)
- [petgraph](https://docs.rs/petgraph/) — Graph data structure library
- [Oxidizer Paper](https://arxiv.org/html/2412.08035) — LLM-based Go→Rust translation
- [dagre.js Wiki](https://github.com/dagrejs/dagre/wiki) — Original dagre algorithm documentation
- [Sugiyama Algorithm](https://en.wikipedia.org/wiki/Layered_graph_drawing) — Layered graph drawing theory
- [SVG Named Colors](https://www.w3.org/TR/css-color-3/#svg-color) — CSS/SVG color name specification

## 11. V2 Review Changes

Issues identified and resolved in this revision:

### Critical (6)
1. **`Attributes` struct undefined** → Removed `attributes` field from `D2Object`. Icon/tooltip/link are out of v1 scope; no separate struct needed.
2. **Container + cross-container edges under-specified** → Added detailed recursive layout algorithm (§4.4.4a) explaining bottom-up traversal, cross-container edge handling at LCA level, and two-stage routing.
3. **`anyhow` as library dependency** → Replaced with `thiserror` throughout. Library crates should expose typed errors, not erased `anyhow::Error`.
4. **Dark mode strategy missing** → Added `RenderOptions` with `dark_mode` flag, `Theme` struct with `dark()`/`light()` presets (§4.3.4), theme application in SVG renderer.
5. **Per-container `direction` not stored** → Added `direction: Option<Direction>` to `D2Object`. Layout uses container's direction with fallback to parent/graph-level default.
6. **Edge routing not shape-aware** → Redesigned `route_edge()` and `clip_to_shape()` to accept `ShapeType` with per-shape intersection logic (§4.4.4b).

### Important (10)
7. **`near` keyword layout-impossible** → Moved to "deferred to v1.1" with explicit rationale. Added to future expansion list as priority 1.
8. **Animated edges contradicts static rendering** → Added §3.3 "Static Rendering Limitations" explaining animated→dashed fallback.
9. **`ScalarValue::Null` inconsistency** → Removed `Null` variant from enum. Parser recognizes `null` keyword and emits warning.
10. **Redundant `src`/`dst` on `D2EdgeData`** → Removed. Source/target accessible via `graph.edge_endpoints(idx)`.
11. **`ParseError` API loses partial AST** → Redesigned as `ParseResult { ast, errors }` — always returns AST.
12. **Missing arrowhead types** → Added `filled-diamond` and `filled-circle` to §3.1 arrowhead list and enum.
13. **Label wrapping missing** → Added `measure_and_wrap_label()` with word-wrapping logic and `MAX_LABEL_WIDTH` (§4.4 Phase 3). Added `label_lines` field on `D2Object`.
14. **SVG `<text>` can't do multi-line** → SVG template updated to use `<tspan>` elements for wrapped labels (§4.4 Phase 5).
15. **Error display undefined** → Added to §3.2: errors shown in styled error box matching Pikchr/Mermaid pattern; warnings returned in `RenderResult`.
16. **Font family unspecified** → Added `font_family` to `RenderOptions` (default: "Arial, Helvetica, sans-serif"), used in both measurement and SVG output.

### Minor (8)
17. **`double_border`/`underline` in struct but not scope** → Added both to §3.1 Styles table.
18. **Named color mapping undefined** → Colors resolved to hex during compilation. Added note referencing W3C SVG color spec (148 colors). Removed `Color::Named` variant.
19. **Coordinate convention unclear** → Added documentation on `Rect` and `geo.rs` module: top-left origin, matching SVG coordinate system.
20. **SVG viewBox sizing missing** → Added `compute_viewbox()` function computing bounding box + padding (§4.4 Phase 5).
21. **Non-fatal warning return path** → Added `D2Warning` and `RenderResult { svg, warnings }` to public API.
22. **Reserved keywords mixed v1/future** → Split into "Processed in v1" and "Recognized but deferred" lists.
23. **`objects`/`edges` vecs purpose undocumented** → Added comments explaining they preserve declaration order for deterministic iteration.
24. **Go `d2` CLI dev dependency** → Added setup instructions and `#[cfg(feature = "diff-tests")]` gating (§6.1).

## 12. V3 Review Changes

Issues identified and resolved in this revision:

### Critical (2)
25. **AST `Key.edge_index` used petgraph's `EdgeIndex`** → Changed to `Option<usize>`. The AST must have zero dependency on petgraph; `(a -> b)[0]` is a D2 syntax-level numeric index.
26. **`layout()` needs font info for text measurement** → Added `&RenderOptions` parameter to `layout()`. Text measurement (Phase 3) now happens inside `layout()` since it needs `font_family` to estimate character widths.

### Important (7)
27. **`StringValue` type undefined** → Added struct definition with `value`, `raw`, and `range` fields.
28. **`Comment` type undefined** → Added struct definition with `value` and `range` fields.
29. **Error types unspecified** → Added complete error hierarchy: `D2Error` (top-level enum), `ParseError` (diagnostic with position), `CompileError`, `LayoutError`, `D2Warning`. All use `thiserror` derives.
30. **`d2` feature not in `default` list** → Added `d2` to the `default` features array in the main crate Cargo.toml, matching the stated intent ("default-enabled like mermaid-embedded and pikchr").
31. **SVG `<defs>` placed after referencing elements** → Moved `<defs>` (arrowhead markers) to top of SVG body, before container/edge/shape elements.
32. **`compute_viewbox` used `f64::MIN` for max tracking** → Fixed to use `f64::INFINITY` / `f64::NEG_INFINITY`. `f64::MIN` is the smallest *positive* float (~2.2e-308), which would fail for negative coordinates.

### Minor (3)
33. **Shape padding values undefined** → Added padding table per shape type (§4.4 Phase 3). Values are initial estimates to be tuned during differential testing.
34. **Self-edges not addressed** → Added self-edge rendering as loop arc (§4.4.4b).
35. **Parallel edges not addressed** → Added parallel edge offset strategy (§4.4.4b).
36. **Empty diagram handling undefined** → Returns minimal SVG with background only (§4.4.4b).

## 13. V4 Review Changes

Issues identified and resolved in this revision:

### Important (1)
37. **Edge label positioning missing** → Added `label_position: Option<Point>` to `D2EdgeData`, computed during edge routing (midpoint of path, offset perpendicular to avoid overlap). Added edge label `<text>` element to SVG template.

### Minor (3)
38. **Container label not shown in SVG template** → Added container label `<text>` element alongside container `<rect>` in SVG template.
39. **`D2EdgeData.route` described as "waypoints"** → Clarified as cubic Bézier control points with explicit format: `[start, ctrl1, ctrl2, end, ctrl1, ctrl2, end, ...]`.
40. **Container fitting mentioned "icon overlap"** → Corrected to "label/child shape overlap" since icons are out of v1 scope.
41. **Compiler step 4 referenced non-existent `Color::Named` variant** → Reworded to describe converting `ScalarValue::Unquoted` string identifiers to `Color::Hex` via lookup table. `Color::Named` was removed in V2 but compiler description wasn't updated.
42. **`near` keyword classification ambiguous** → Split into three categories: "Processed in v1", "Parsed but layout-deferred" (for `near`), and "Recognized but deferred". Clarifies that `near` is parsed without error but has no layout effect until v1.1.
43. **Shape padding table coverage unclear** → Added explicit note that all unlisted ShapeType variants (Person, Package, Queue, etc.) use the default rectangle padding.

## 14. V5 Review Changes

Issues identified and resolved in this revision (based on feasibility validation research):

### Critical (2)
44. **`rust-sugiyama` API cannot handle node dimensions** → Dropped `rust-sugiyama` entirely. Replaced with own Sugiyama implementation on petgraph with full node-size awareness (Brandes-Köpf coordinate assignment). Updated Phase 4a, dependencies, Cargo.toml, implementation strategy, and risks. See §4.4 Phase 4a for detailed algorithm design.
45. **SVG `<marker>` arrowheads have limited resvg support** → Replaced with explicit `<polygon>` arrowhead triangles computed at edge endpoints. Added `arrowhead_polygon()` function. This matches mdmdview's existing Pikchr renderer approach. Updated SVG template, Phase 5 description, and implementation strategy.

### Important (5)
46. **Parser complexity for unquoted strings with spaces underestimated** → Added detailed parser note explaining that D2 unquoted strings can contain spaces (`My Server -> Your Server`), terminated by reserved character sequences, not whitespace. Updated parser risk assessment.
47. **Cache key unspecified** → Added cache key specification to §3.2: `hash(source_text, dark_mode, font_family)`. Zoom handled at display time, not render time.
48. **Edge labels unreadable when crossing edges** → Added background halo (semi-transparent `<rect>` behind edge label text) to SVG template for readability.
49. **Implementation strategy table stale** → Updated Layout row to "Own implementation on petgraph". Added Arrowheads row. Removed reference to `rust-sugiyama`.
50. **Risks table referenced dropped dependency** → Replaced `rust-sugiyama` risks with own-implementation risks (Sugiyama bugs, Brandes-Köpf complexity). Added scope creep risk.

### Minor (3)
51. **Dependencies section listed `rust-sugiyama`** → Removed from all dependency tables and Cargo.toml snippets. Added note explaining the rejection.
52. **References listed `rust-sugiyama` as active dependency** → Moved to "evaluated and rejected" with rationale.
53. **V3 review §31 now stale** → V3 noted "`<defs>` moved to top of SVG body". V5 removes `<defs>` entirely since polygon arrowheads don't need marker definitions. The SVG template no longer uses `<defs>` at all.

### V5 Self-Review (additional fixes after initial V5 updates)

54. **Phase ordering wrong: edges routed before positions finalized** (Critical) → Reordered Phase 4 sub-phases: 4a (positioning) → 4c (container fitting) → 4d (adjustments) → 4b (edge routing last). Edges must be routed after all positions are final.
55. **LCA for cross-container edges undefined** (Important) → Added specification: "walk `D2Object.parent` pointers from both endpoints until they meet".
56. **Edge label halo `{bg}` color ambiguous** (Important) → Clarified as `theme.background` color (black in dark mode, white in light mode).
57. **Crow's foot arrowhead rendering unspecified** (Important) → Added per-type polygon/element descriptions for all ArrowheadType variants (triangle, diamond, circle, crow's foot tines).
58. **Labels with markdown formatting ambiguous** (Important) → Added explicit note: labels are plain text in v1, markdown/rich text in labels is out of scope.
59. **`greedy_feedback_arc_set()` petgraph version uncertainty** (Minor) → Added fallback note: verify API path in petgraph 0.8, with DFS-based alternative (~30 lines).
60. **`near` keyword note still referenced `rust-sugiyama`** (Minor) → Updated to "our Sugiyama implementation".

## 15. V6 Review Changes

Issues identified and resolved in this revision:

### Critical (1)
61. **SVG z-ordering wrong: shapes rendered above edges** → Edges must be ON TOP of shapes (matching D2's Go `lib/svg/svg.go`). Otherwise shape fills cover edge endpoints. Fixed layer order: (1) background, (2) container fills, (3) shape fills+strokes, (4) edges+arrowheads, (5) all labels. Also separated container labels (top-left aligned) from node labels (center aligned) in the template.

### Important (6)
62. **Root object properties unspecified** → Root is special: no shape, no label, no border. Its `box_` is the bounding box of all children. SVG renderer must skip drawing it. Added documentation on `D2Graph.root`.
63. **Warning propagation gap in `compile()` API** → `compile()` returns `Result<D2Graph, CompileError>` but warnings are generated during compilation (step 7). Added `warnings: Vec<D2Warning>` field to `D2Graph`. Warnings accumulate during compilation and are extracted into `RenderResult.warnings` by `render_d2_to_svg()`.
64. **`arrowhead_polygon()` division by zero** → Zero-length direction vector (tip ≈ from) causes NaN. Added guard: if `len < 1e-6`, return a default downward-pointing arrowhead.
65. **Shadow, 3D, multiple style rendering unspecified** → Listed as "Must Have" styles but had no SVG rendering description. Added rendering table: shadow = offset duplicate at 30% opacity; 3D = extra parallelogram face; multiple = 2 offset copies. All are decorative (don't affect layout dimensions). Added note about extra viewBox margin.
66. **Container vs node label positioning undifferentiated** → Node labels are centered on shape. Container labels are top-left aligned inside the container. Added `is_container: bool` field to `D2Object`. SVG renderer uses this to select positioning strategy.
67. **`render_d2_to_svg()` parse error threshold unspecified** → Clarified: any parse errors → immediate `D2Error::Parse`. Partial AST is not compiled. The partial AST exists for future tooling use (LSP) via the individual `parse()` function.

### Minor (3)
68. **Dangling cross-reference §3.1.2** → Connection Styles table referenced "See §3.1.2" but that section number doesn't exist. Fixed to "See Arrowhead Types below".
69. **Compiler step 6 "default theme colors" but compile() has no theme** → `compile()` doesn't take `RenderOptions`, so it can't set theme-based defaults. Clarified: Style fields left as `None`, theme defaults resolved during SVG rendering based on `dark_mode`. Keeps compilation theme-independent.
70. **`compute_viewbox()` only considered node boxes, not edge routes** → Self-loops and curved edges may extend beyond node bounding boxes. Added iteration over `graph.edges` route control points to include them in viewBox bounds.
71. **`layout()` warning propagation implicit** → `layout()` takes `&mut D2Graph` and can append to `graph.warnings`, but this was undocumented. Added doc comment on `layout()` API specifying that it may mutate warnings.
72. **Root object not excluded from SVG shape iteration** → SVG renderer iterates `graph.objects` to draw shapes. Root must be skipped (no visual representation). Added explicit "Root object guard" note to Phase 5 description.
73. **Disconnected component gap value unspecified** → Layout says "configurable gap" but never gives a default. Set default to 60px (matching dagre's `ranksep` default), constant in `layout.rs`.

# HLD: D2 Edge Label Placement Overhaul (V2)

**Date:** 2026-02-22
**Status:** Draft
**Scope:** `crates/d2/src/edge_routing.rs`, `crates/d2/src/svg_render.rs`
**Supersedes:** V1 (same date)

## Changes from V1

| # | Issue in V1 | Resolution in V2 |
|---|-------------|-------------------|
| 1 | Early-exit `break 'search` inside inner SIDES loop exits after testing only side=-1 — side=+1 never evaluated when clearance is already good | Restructured: evaluate BOTH sides at each percentage, then check early-exit AFTER the inner loop |
| 2 | `closer_to_center` tie-breaker uses centroid distance — ineffective for symmetric/centered layouts (both sides equidistant) | Replaced with **overshoot** metric: how much the label rect extends beyond the node bounding box. Concrete, measurable, and effective for asymmetric layouts |
| 3 | Claim that labels "naturally alternate" in a centered chain is false — centroid distance is symmetric, no alternation occurs | Corrected: acknowledged that symmetric layouts produce consistent left/up placement. This is acceptable with viewBox expansion. Alternation is a non-goal. |
| 4 | `dominated` check uses floating-point equality (`clearance == best_clearance`) — fragile | Replaced with explicit two-phase comparison: (1) strictly better clearance wins, (2) equal clearance → lower overshoot wins, (3) all else equal → first candidate (side=-1) wins |
| 5 | Test plan claims 4 existing tests need direction changes | Corrected: for simple a→b diagrams the default side=-1 wins every time; existing tests pass unchanged. Tests are direction-agnostic only if needed for robustness. |
| 6 | Fix C binary jump (natural offset or 0) not well justified vs. smooth clamp | Added analysis: smooth clamp produces ugly partial overlap; binary choice gives two clean visual states (offset or centered). Justified. |

## 1. Problem Statement

Edge labels in D2 diagrams are frequently cut off or overlap diagram elements. Observed in a vertical 4-node chain (`client -> api -> cache -> db`) with labels on each edge:

| Symptom | Root Cause |
|---------|------------|
| Labels cut off at left edge of viewport | ViewBox doesn't include label bounding rects |
| All labels pushed to the same side | `label_position_at` always offsets left (vertical) or up (horizontal) |
| Wide labels overlap the edge line | `MAX_LABEL_OFFSET` cap pulls label center back toward line |

Screenshot evidence: every label ("REST/JSON", "get/set", "SQL queries", "cache miss") is pushed left and clipped.

## 2. Root Cause Analysis

### 2.1 ViewBox ignores labels (the clipping bug)

`compute_viewbox()` in `svg_render.rs:185-234` computes bounds from:
- Node bounding rects (including shadow/3D extras)
- Edge route control points

It does **not** include edge label bounding rects. A label whose halo extends beyond the leftmost node simply gets clipped by the SVG viewport.

### 2.2 Unidirectional offset bias

`label_position_at()` in `edge_routing.rs:889-934` always applies the perpendicular offset in a fixed direction:

```
Horizontal segment → offset UP    (py - offset)
Vertical segment   → offset LEFT  (px - offset)
```

In a vertical layout where every edge is vertical, every label is pushed left. The candidate loop in `compute_label_position()` tries 9 percentage positions along the route but always uses the same perpendicular side — it never evaluates the opposite direction.

### 2.3 MAX_LABEL_OFFSET cap causes line overlap

The offset formula is:
```
offset = min(label_width/2 + LABEL_PADDING, MAX_LABEL_OFFSET)
       = min(label_width/2 + 4, 40)
```

| Label width | Offset | Nearest label edge to line | Result |
|------------|--------|---------------------------|--------|
| ≤ 72px | label_width/2 + 4 | 4px gap | Clean |
| 80px | 40 (capped) | 0px | Touches line |
| 100px | 40 (capped) | -10px | Overlaps 10px |
| 200px | 40 (capped) | -60px | Overlaps 60px |

The overlap worsens linearly with label width beyond 80px. The halo covers the line, but the visual result is messy — half the label is on one side of the line, half on the other.

Removing the cap entirely would cause labels wider than 92px to violate the conformance `label_near_edge` threshold (label center > 50px from edge).

## 3. Proposed Design

Three coordinated fixes, ordered by impact:

### Fix A: Expand ViewBox to include label bounds

**Impact:** High — directly eliminates clipping.
**Complexity:** Trivial (~15 lines).

After computing bounds from nodes and routes, also include each edge label's full bounding rect (with halo padding).

**Where:** `svg_render.rs`, `compute_viewbox()`

**Logic:**
```
for each edge with label_position:
    label_rect = Rect(
        pos.x - label_width/2 - LABEL_HALO_PADDING,
        pos.y - label_height/2 - LABEL_HALO_PADDING,
        label_width + 2 * LABEL_HALO_PADDING,
        label_height + 2 * LABEL_HALO_PADDING
    )
    expand min_x, min_y, max_x, max_y to contain label_rect
```

**Effect:** Labels are never clipped, regardless of placement. The diagram grows to accommodate them. This matches D2, Mermaid, and Graphviz behavior.

**Risk:** A very wide label makes the diagram wider. This is correct — the user chose a wide label, the diagram should show it. The existing 20px padding still applies on top.

### Fix B: Bidirectional perpendicular offset

**Impact:** Medium — distributes labels to the better side when layout is asymmetric.
**Complexity:** Moderate (~40 lines changed).

For each candidate position along the route, evaluate BOTH perpendicular directions (left+right or up+down). Pick using a two-phase scoring:

1. **Primary: clearance from nodes** — strictly better clearance wins (existing metric)
2. **Secondary: overshoot beyond node bounding box** — when clearance is equal, prefer the side where the label's full bounding rect extends less beyond the bounding box of all nodes
3. **Tertiary: default to side=-1** (left/up) — deterministic fallback for perfectly symmetric layouts

**Approach:** Add a `side: f64` parameter to `label_position_at` (+1.0 or -1.0):

```rust
fn label_position_at(
    route, seg_lengths, total_length, percentage,
    label_width, label_height,
    side: f64,          // +1.0 = right/down, -1.0 = left/up
) -> Option<Point>
```

In `compute_label_position`, evaluate both sides at each percentage:

```rust
for &pct in &CANDIDATES {
    // Evaluate BOTH sides at this percentage
    for &side in &[-1.0_f64, 1.0] {
        let pos = label_position_at(..., side);
        let clearance = label_clearance(&label_bounding_rect(pos, ...), node_rects);
        let overshoot = label_overshoot(pos, label_width, label_height, &node_bounds);

        // Phase 1: strictly better clearance always wins
        if clearance > best_clearance {
            update best;
        }
        // Phase 2: equal clearance, less overshoot wins
        else if clearance == best_clearance && overshoot < best_overshoot {
            update best;
        }
        // Phase 3: all equal, first candidate (side=-1) already stored → skip
    }

    // Early exit AFTER evaluating both sides at this percentage
    if best_clearance > LABEL_PADDING {
        break;
    }
}
```

**Critical structural detail:** The early-exit check is OUTSIDE the inner `SIDES` loop. This ensures both sides are always evaluated before deciding to stop. V1 had this wrong — the break was inside the inner loop, causing side=+1 to be skipped when side=-1 already had good clearance.

**Honest limitation:** For a perfectly symmetric vertical chain (all nodes centered at the same x), both sides have equal clearance AND equal overshoot. The default side=-1 (left/up) wins consistently. All labels go left. This is acceptable because:
- Fix A ensures they're not clipped
- The layout is consistent and predictable
- Alternation would require arbitrary heuristics (edge-index parity, etc.) with no principled basis

**Where it helps:** Asymmetric layouts — where one side has nearby nodes and the other doesn't, or where the edge is off-center relative to the node bounding box. The better side is chosen automatically.

### Fix C: On-edge fallback for very wide labels

**Impact:** Low — affects only labels wider than ~80px.
**Complexity:** Trivial (~6 lines changed).

When a label is so wide that the perpendicular offset would cause the label to straddle the route line, place it centered directly on the edge (offset = 0). The halo background covers the line underneath.

**Threshold analysis:**

The label's nearest edge overlaps the route line when `MAX_LABEL_OFFSET < label_dim/2`:
- For vertical segments: `label_width > 2 * MAX_LABEL_OFFSET = 80px`
- For horizontal segments: `label_height > 80px` (rare — requires ~4 wrapped lines)

**Why binary (natural vs. zero) instead of smooth clamp:**

The smooth clamp (`min(natural, MAX_LABEL_OFFSET)`) produces three visual states:
1. **Natural offset** (narrow labels): label fully clears the line. Clean.
2. **Clamped offset** (medium labels): label partially overlaps the line. Ugly — half the label is on each side, the halo covers part of the line but not cleanly.
3. **On-edge** (wide labels): label centered on line. Clean — halo provides clear visual break.

The clamp produces state (2), which is the worst of all three. The binary choice skips directly from (1) to (3), giving two clean visual states. No messy in-between.

**Logic:**
```rust
let natural_offset = (label_dim / 2.0) + LABEL_PADDING;
let offset = if natural_offset > MAX_LABEL_OFFSET {
    0.0  // center on edge, halo covers line
} else {
    natural_offset  // full clearance from line
};
```

**Conformance:** With offset = 0, label center is on the edge → distance ≈ 0, trivially under the 50px `label_near_edge` threshold.

## 4. Implementation Details

### 4.1 compute_viewbox expansion (Fix A)

**File:** `crates/d2/src/svg_render.rs`

Insert after the existing "edge route control points" loop (after line 229), before the empty-diagram check:

```rust
// Include edge label bounding rects
for &eidx in &graph.edges {
    let edge = &graph.graph[eidx];
    if let Some(pos) = edge.label_position {
        if edge.label_width > 0.0 && edge.label_height > 0.0 {
            let pad = crate::edge_routing::LABEL_HALO_PADDING;
            let lx = pos.x - edge.label_width / 2.0 - pad;
            let ly = pos.y - edge.label_height / 2.0 - pad;
            let lr = lx + edge.label_width + pad * 2.0;
            let lb = ly + edge.label_height + pad * 2.0;
            min_x = min_x.min(lx);
            min_y = min_y.min(ly);
            max_x = max_x.max(lr);
            max_y = max_y.max(lb);
        }
    }
}
```

No new types, no structural changes. The existing 20px padding wraps the expanded bounds.

### 4.2 Bidirectional offset (Fix B)

**File:** `crates/d2/src/edge_routing.rs`

#### 4.2.1 Modify `label_position_at` signature

Add `side: f64` parameter. Update the offset application:

```rust
fn label_position_at(
    route: &[Point],
    seg_lengths: &[f64],
    total_length: f64,
    percentage: f64,
    label_width: f64,
    label_height: f64,
    side: f64,
) -> Option<Point> {
    // ... existing interpolation logic unchanged ...

    return if dx.abs() > dy.abs() {
        let offset = /* see Fix C */;
        Some(Point::new(px, py + side * offset))   // side=-1 → up, +1 → down
    } else {
        let offset = /* see Fix C */;
        Some(Point::new(px + side * offset, py))   // side=-1 → left, +1 → right
    };
}
```

#### 4.2.2 New helper: `label_overshoot`

Computes how many total pixels the label's bounding rect extends beyond the bounding box of all nodes. Lower is better.

```rust
fn label_overshoot(
    pos: Point,
    label_width: f64,
    label_height: f64,
    node_bounds: &Option<Rect>,
) -> f64 {
    let bounds = match node_bounds {
        Some(b) => b,
        None => return 0.0,
    };
    let pad = LABEL_HALO_PADDING;
    let lx = pos.x - label_width / 2.0 - pad;
    let ly = pos.y - label_height / 2.0 - pad;
    let lr = pos.x + label_width / 2.0 + pad;
    let lb = pos.y + label_height / 2.0 + pad;

    (bounds.x - lx).max(0.0)            // left overshoot
        + (lr - bounds.right()).max(0.0) // right overshoot
        + (bounds.y - ly).max(0.0)       // top overshoot
        + (lb - bounds.bottom()).max(0.0) // bottom overshoot
}
```

#### 4.2.3 Modify `compute_label_position` candidate loop

```rust
fn compute_label_position(
    route: &[Point],
    percentage: f64,
    label_width: f64,
    label_height: f64,
    node_rects: &[Rect],
) -> Option<Point> {
    // ... existing seg_lengths / total computation ...

    // Fast path: no nodes to dodge
    if node_rects.is_empty() {
        return label_position_at(route, &seg_lengths, total, percentage,
                                 label_width, label_height, -1.0);
    }

    // Compute bounding box of all node rects for overshoot tie-breaking
    let node_bounds = {
        let min_x = node_rects.iter().map(|r| r.x).fold(f64::INFINITY, f64::min);
        let min_y = node_rects.iter().map(|r| r.y).fold(f64::INFINITY, f64::min);
        let max_x = node_rects.iter().map(|r| r.right()).fold(f64::NEG_INFINITY, f64::max);
        let max_y = node_rects.iter().map(|r| r.bottom()).fold(f64::NEG_INFINITY, f64::max);
        Some(Rect::new(min_x, min_y, max_x - min_x, max_y - min_y))
    };

    const CANDIDATES: [f64; 9] = [0.5, 0.35, 0.65, 0.2, 0.8, 0.15, 0.85, 0.4, 0.6];
    const SIDES: [f64; 2] = [-1.0, 1.0];

    let mut best_pos: Option<Point> = None;
    let mut best_clearance = f64::NEG_INFINITY;
    let mut best_overshoot = f64::INFINITY;

    for &pct in &CANDIDATES {
        // Evaluate BOTH sides at this percentage before considering early exit
        for &side in &SIDES {
            if let Some(pos) = label_position_at(
                route, &seg_lengths, total, pct,
                label_width, label_height, side,
            ) {
                let lr = label_bounding_rect(pos, label_width, label_height);
                let clearance = label_clearance(&lr, node_rects);
                let overshoot = label_overshoot(pos, label_width, label_height, &node_bounds);

                // Phase 1: strictly better clearance always wins
                let dominated = if clearance > best_clearance {
                    false
                } else if clearance < best_clearance {
                    true
                } else {
                    // Phase 2: equal clearance → less overshoot wins
                    overshoot >= best_overshoot
                    // Phase 3 (implicit): all equal → first candidate kept
                };

                if !dominated {
                    best_clearance = clearance;
                    best_overshoot = overshoot;
                    best_pos = Some(pos);
                }
            }
        }

        // Early exit AFTER evaluating both sides
        if best_clearance > LABEL_PADDING {
            break;
        }
    }

    // If best position still overlaps a node, nudge it away.
    if best_clearance < 0.0 {
        if let Some(pos) = best_pos {
            best_pos = Some(nudge_away_from_nodes(pos, label_width, label_height, node_rects));
        }
    }

    best_pos
}
```

**Note on floating-point equality:** The `clearance < best_clearance` / `clearance > best_clearance` comparisons use strict inequality. When clearances are within floating-point epsilon of each other, the `else` branch triggers, which compares overshoot. This is robust — two candidates with nearly-equal clearance are disambiguated by overshoot rather than by arbitrary floating-point ordering.

### 4.3 On-edge fallback (Fix C)

**File:** `crates/d2/src/edge_routing.rs`, inside `label_position_at()`

Replace the offset computation in both branches:

```rust
return if dx.abs() > dy.abs() {
    // Horizontal segment
    let natural_offset = (label_height / 2.0) + LABEL_PADDING;
    let offset = if natural_offset > MAX_LABEL_OFFSET { 0.0 } else { natural_offset };
    Some(Point::new(px, py + side * offset))
} else {
    // Vertical segment
    let natural_offset = (label_width / 2.0) + LABEL_PADDING;
    let offset = if natural_offset > MAX_LABEL_OFFSET { 0.0 } else { natural_offset };
    Some(Point::new(px + side * offset, py))
};
```

When `offset = 0`, both sides produce the same position. The candidate loop evaluates both, finds them identical, and keeps the first (side=-1). No wasted work — the second evaluation is a no-op that doesn't update best.

## 5. Interaction Between Fixes

The three fixes are independent and composable:

| Fix | Alone | With others |
|-----|-------|-------------|
| A (viewBox) | Labels never clipped, but still all on one side | Correct bounds for any placement strategy |
| B (bidirectional) | Labels distributed better for asymmetric layouts, but wide ones still clipped | Combined with A, fully solves the problem |
| C (on-edge) | Wide labels centered cleanly, but still clipped | Combined with A+B, clean placement at all widths |

**Recommended order:** A → B → C.

Fix A alone resolves the most critical issue (clipping). It can ship independently. Fixes B and C are refinements that should ship together (B changes the `label_position_at` signature, C changes the offset logic in the same function).

## 6. Existing Call Sites Affected

### `label_position_at` callers (2 sites, both in `compute_label_position`):

1. Fast path (no nodes) — pass `side = -1.0`
2. Candidate loop — pass both `side = -1.0` and `side = 1.0`

### `compute_viewbox` callers (1 site):

1. `render()` in `svg_render.rs` — no signature change, automatically gets expanded bounds

### Constants:

| Constant | Current | After |
|----------|---------|-------|
| `MAX_LABEL_OFFSET` | 40.0 | Kept unchanged. Acts as threshold between offset and on-edge placement. |
| `LABEL_HALO_PADDING` | 3.0 | No change; used in viewBox expansion and overshoot calculation. |
| ViewBox `padding` | 20.0 | No change. |

## 7. Test Plan

### 7.1 New unit tests

| Test | Validates |
|------|-----------|
| `test_viewbox_includes_labels` | Parse SVG output, verify viewBox contains all edge label bounding rects |
| `test_label_not_clipped` | For the problematic 4-node chain, verify no label rect extends beyond viewBox |
| `test_label_side_asymmetric` | Layout where one side has a node — verify the label goes to the other side |
| `test_wide_label_on_edge` | Label wider than 80px → offset is 0 (centered on edge) |
| `test_overshoot_prefers_inward` | Edge near left boundary of diagram → label placed to the right (less overshoot) |

### 7.2 Existing tests — impact analysis

| Test | Expected Impact |
|------|-----------------|
| `test_label_offset_vertical` | **No change.** Simple a→b, both sides have equal clearance/overshoot. Default side=-1 (left) wins. Existing assertion (`label.x < line.x`) passes. |
| `test_label_offset_horizontal` | **No change.** Same reasoning. Default side=-1 (up) wins. |
| `test_ortho_label_vertical` | **No change.** Default side wins for simple layout. |
| `test_ortho_label_horizontal` | **No change.** Default side wins for simple layout. |
| `test_label_no_node_overlap` | **No change.** Clearance logic is unchanged; overshoot is secondary. |
| `test_nudge_finds_clear_position` | **Possible improvement.** Bidirectional may find a clear position without nudging. Test checks "no overlap" which still holds. |
| All other edge_routing tests | **No change.** Don't test label direction. |

**Key insight from V1 correction:** For all simple test diagrams (`a -> b: hello`), both sides of the edge have equal clearance from nodes (the label is between the two endpoints, equidistant from both). Both sides also have equal overshoot (symmetric layout). The first evaluated side (side=-1, left/up) wins. This matches the current behavior exactly. No test assertions break.

Tests would only need updating if we explicitly assert a label goes RIGHT in an asymmetric layout — those are new tests, not modifications.

### 7.3 Conformance suite

All 24 fixtures must pass with 0 violations.

- `label_near_edge` (50px threshold): Fix C keeps wide labels at offset=0 (on-edge). Fix B may place labels on the right side — the offset magnitude is unchanged (same distance from edge). Both pass.
- `edge_not_through_node`: Unaffected (routing, not labeling).
- `label_not_overlapping_node`: Clearance-based selection is unchanged/improved.
- `nodes_not_overlapping`: Unaffected.

### 7.4 Visual verification

Render the failing diagram (`client -> api -> cache -> db` with labels) before and after. Verify:
- No labels cut off at any edge
- Wide labels visually clean (centered on edge with halo, or offset with clearance)

## 8. Risks and Mitigations

| Risk | Likelihood | Mitigation |
|------|-----------|------------|
| ViewBox expansion makes diagram unexpectedly wide for very long labels | Low | Correct behavior. The user chose a long label; the diagram should show it. If too wide, use shorter text or rely on text wrapping (`MAX_LABEL_WIDTH = 200px`). |
| On-edge placement (Fix C) hides route line under halo | By design | Halo has opacity=0.85 and matches background. This is standard in D2/Mermaid/Graphviz. Line remains visible at halo edges. |
| Overshoot tie-breaker doesn't help for perfectly symmetric layouts | By design | Acknowledged limitation. Symmetric layouts get consistent left/up placement. Fix A ensures visibility. No worse than current behavior. |
| Bidirectional offset changes visual regression baselines | Moderate | Only affects asymmetric layouts where the old left-biased placement was suboptimal. New positions are objectively better. Update baselines. |
| Performance: 18 candidates instead of 9 | Negligible | Each candidate is ~N rect comparisons where N = node count. For 100-node diagrams, ~1800 comparisons total. Sub-microsecond. |

## 9. Files Modified

| File | Change | Lines |
|------|--------|-------|
| `crates/d2/src/svg_render.rs` | `compute_viewbox`: add label bounds expansion | ~15 |
| `crates/d2/src/edge_routing.rs` | `label_position_at`: add `side` param + on-edge fallback | ~10 |
| `crates/d2/src/edge_routing.rs` | `compute_label_position`: bidirectional candidates + overshoot scoring | ~30 |
| `crates/d2/src/edge_routing.rs` | New helper: `label_overshoot` | ~15 |
| `crates/d2/src/edge_routing.rs` | Remove `closer_to_center` (V1 artifact, not needed) | — |
| `crates/d2/src/edge_routing.rs` | New tests (5) + existing tests unchanged | ~50 |
| **Total** | | **~120 lines** |

## 10. Out of Scope

- **Label-vs-label overlap detection**: Two labels on parallel edges may still overlap each other. Mitigated by channel spreading. Full collision resolution would require a constraint solver — not justified by current failure rate.
- **Label alternation for symmetric layouts**: Deliberately placing labels on alternating sides (even=left, odd=right) for pure aesthetics. No principled heuristic exists; the default left/up is consistent and predictable.
- **Multi-line label wrapping at viewport boundary**: Labels wider than `MAX_LABEL_WIDTH` (200px) are already wrapped by `measure_and_wrap_label`. Viewport-aware wrapping would be a separate feature.
- **Curved edge labels**: Self-loop edges use Bézier routing with hardcoded label position. Not addressed here.
- **Node label overflow**: Node labels are rendered inside their bounding rects and cannot extend beyond them. Not a concern.

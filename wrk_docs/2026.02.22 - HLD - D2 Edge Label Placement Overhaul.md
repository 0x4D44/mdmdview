# HLD: D2 Edge Label Placement Overhaul

**Date:** 2026-02-22
**Status:** Draft
**Scope:** `crates/d2/src/edge_routing.rs`, `crates/d2/src/svg_render.rs`

## 1. Problem Statement

Edge labels in D2 diagrams are frequently cut off or overlap diagram elements. Observed in a vertical 4-node chain (`client -> api -> cache -> db`) with labels on each edge:

| Symptom | Root Cause |
|---------|------------|
| Labels cut off at left edge of viewport | ViewBox doesn't include label bounding rects |
| All labels pushed to the same side | `label_position_at` always offsets left (vertical) or up (horizontal) |
| Wide labels overlap the edge line | `MAX_LABEL_OFFSET` cap pulls label center back toward line |

Screenshot evidence: every label ("REST/JSON", "get/set", "SQL queries", "cache miss") is pushed left and clipped.

## 2. Root Cause Analysis

### 2.1 ViewBox ignores labels (the clipping bug)

`compute_viewbox()` in `svg_render.rs:177-229` computes bounds from:
- Node bounding rects (including shadow/3D extras)
- Edge route control points

It does **not** include edge label bounding rects. A label whose halo extends beyond the leftmost node simply gets clipped by the SVG viewport.

### 2.2 Unidirectional offset bias

`label_position_at()` in `edge_routing.rs` always applies the perpendicular offset in a fixed direction:

```
Horizontal segment → offset UP    (py - offset)
Vertical segment   → offset LEFT  (px - offset)
```

In a vertical layout where every edge is vertical, every label is pushed left. No alternative direction is ever evaluated. The candidate evaluation in `compute_label_position()` tries 9 percentage positions along the route but always uses the same perpendicular side.

### 2.3 MAX_LABEL_OFFSET cap causes line overlap

The offset formula is:
```
offset = min(label_width/2 + LABEL_PADDING, MAX_LABEL_OFFSET)
       = min(label_width/2 + 4, 40)
```

For label_width ≤ 72px, offset = label_width/2 + 4, so the nearest label edge is 4px from the route line. Fine.

For label_width > 72px, offset is capped at 40px. The nearest label edge is then at `40 - label_width/2` from the line. For a 100px-wide label, the label overlaps the line by 10px. The halo covers the line, but the visual result is messy.

Meanwhile, removing the cap entirely would cause labels wider than 92px to violate the conformance `label_near_edge` threshold (label center > 50px from edge).

## 3. Proposed Design

Three coordinated fixes, ordered by impact:

### Fix A: Expand ViewBox to include label bounds (high impact, simple)

**What:** After computing bounds from nodes and routes, also include each edge label's full bounding rect (with halo padding).

**Where:** `svg_render.rs`, `compute_viewbox()`

**Logic:**
```
for each edge with label_position:
    label_rect = Rect(
        pos.x - label_width/2 - LABEL_HALO_PADDING,
        pos.y - label_height/2 - LABEL_HALO_PADDING,
        label_width + 2 * LABEL_HALO_PADDING,
        label_height + 2 * LABEL_HALO_PADDING
    )
    expand min_x, min_y, max_x, max_y to contain label_rect
```

**Effect:** Labels are never clipped, regardless of where they're placed. The diagram grows to accommodate them. This matches how D2, Mermaid, and Graphviz all behave.

**Risk:** Minimal. The existing 20px padding still applies on top of the expanded bounds. A very wide label could make the diagram wider than expected, but that's the correct behavior — you chose a wide label, the diagram should show it.

### Fix B: Bidirectional perpendicular offset (aesthetic improvement)

**What:** For each candidate position along the route, evaluate BOTH perpendicular directions (left+right or up+down) and pick the side with better clearance.

**Where:** `edge_routing.rs`, `label_position_at()` and `compute_label_position()`

**Approach:**

Add a `side: f64` parameter to `label_position_at` (+1.0 or -1.0):

```rust
fn label_position_at(
    route: &[Point],
    seg_lengths: &[f64],
    total_length: f64,
    percentage: f64,
    label_width: f64,
    label_height: f64,
    side: f64,          // +1.0 = right/down, -1.0 = left/up
) -> Option<Point> {
    // ... existing interpolation logic ...

    if dx.abs() > dy.abs() {
        // Horizontal segment: offset perpendicular (up or down)
        let offset = ((label_height / 2.0) + LABEL_PADDING).min(MAX_LABEL_OFFSET);
        Some(Point::new(px, py + side * offset))
    } else {
        // Vertical segment: offset perpendicular (left or right)
        let offset = ((label_width / 2.0) + LABEL_PADDING).min(MAX_LABEL_OFFSET);
        Some(Point::new(px + side * offset, py))
    }
}
```

In `compute_label_position`, double the candidate space:

```rust
const SIDES: [f64; 2] = [-1.0, 1.0];  // left/up first, then right/down

for &pct in &CANDIDATES {
    for &side in &SIDES {
        if let Some(pos) = label_position_at(..., side) {
            let lr = label_bounding_rect(pos, label_width, label_height);
            let clearance = label_clearance(&lr, node_rects);
            if clearance > best_clearance {
                best_clearance = clearance;
                best_pos = Some(pos);
                if clearance > LABEL_PADDING {
                    break 'outer;  // need labeled break
                }
            }
        }
    }
}
```

This doubles the candidate count from 9 to 18. Each evaluation is a handful of rect comparisons — negligible cost.

**Scoring tie-breaker:** When both sides have equal clearance (common in simple chains with no nearby nodes), prefer the side where the label stays closer to the diagram's horizontal center. Compute this from the node bounding box:

```rust
let diagram_center_x = (all_nodes_min_x + all_nodes_max_x) / 2.0;
// Break ties: prefer side closer to center
if clearance == best_clearance {
    let new_dist = (pos.x - diagram_center_x).abs();
    let old_dist = (best_pos.unwrap().x - diagram_center_x).abs();
    if new_dist < old_dist {
        best_pos = Some(pos);
    }
}
```

For a vertical chain of nodes, this naturally alternates labels left and right (or more precisely, puts them on whichever side keeps them closer to center), distributing them evenly rather than stacking them all on one side.

**Effect:** Labels distribute to the side with more room. In a vertical chain, some labels go left, some go right. No more uniform left-drift.

### Fix C: On-edge fallback for very wide labels

**What:** When a label is so wide that the capped offset would cause overlap with the route line, place the label centered directly on the edge (offset = 0). The halo background covers the line underneath, providing clean visual separation.

**Where:** `edge_routing.rs`, inside `label_position_at()`

**Threshold:** The label's nearest edge overlaps the route line when:
```
offset < label_width / 2   (for vertical segments)
offset < label_height / 2  (for horizontal segments)
```

Since `offset = min(dim/2 + LABEL_PADDING, MAX_LABEL_OFFSET)`, overlap happens when `MAX_LABEL_OFFSET < dim/2`, i.e., `dim > 2 * MAX_LABEL_OFFSET = 80px`.

**Logic:**
```rust
// Vertical segment example:
let natural_offset = (label_width / 2.0) + LABEL_PADDING;
let offset = if natural_offset > MAX_LABEL_OFFSET {
    // Label too wide — center on edge, halo covers the line
    0.0
} else {
    natural_offset
};
Some(Point::new(px + side * offset, py))
```

**Effect:** Very wide labels ("This is a very long edge label") sit centered on the edge with a clean halo background, rather than being awkwardly half-offset. Narrow labels still get the offset.

**Conformance:** `label_near_edge` measures distance from label center to edge. With offset = 0, distance ≈ 0, which trivially passes the 50px threshold.

**Trade-off:** The `MAX_LABEL_OFFSET` constant becomes irrelevant for wide labels. It only constrains medium-width labels (width 72-80px). Consider whether `MAX_LABEL_OFFSET` is still needed at all, or whether the on-edge fallback should apply more broadly.

## 4. Implementation Details

### 4.1 compute_viewbox expansion (Fix A)

**File:** `crates/d2/src/svg_render.rs`

Modify `compute_viewbox()` — after the existing edge route loop, add:

```rust
// Include edge label bounding rects
for &eidx in &graph.edges {
    let edge = &graph.graph[eidx];
    if let Some(pos) = edge.label_position {
        if edge.label_width > 0.0 && edge.label_height > 0.0 {
            let pad = crate::edge_routing::LABEL_HALO_PADDING;
            let lx = pos.x - edge.label_width / 2.0 - pad;
            let ly = pos.y - edge.label_height / 2.0 - pad;
            let lr = lx + edge.label_width + pad * 2.0;
            let lb = ly + edge.label_height + pad * 2.0;
            min_x = min_x.min(lx);
            min_y = min_y.min(ly);
            max_x = max_x.max(lr);
            max_y = max_y.max(lb);
        }
    }
}
```

Insert this block between the existing "edge route control points" loop and the final padding calculation. No new types, no structural changes.

### 4.2 Bidirectional offset (Fix B)

**File:** `crates/d2/src/edge_routing.rs`

#### 4.2.1 Modify `label_position_at` signature

Add `side: f64` parameter. Update the offset application:

```rust
// Before (always negative):
Some(Point::new(px, py - offset))
Some(Point::new(px - offset, py))

// After (sign-controlled):
Some(Point::new(px, py + side * offset))    // side=-1 → up, side=+1 → down
Some(Point::new(px + side * offset, py))    // side=-1 → left, side=+1 → right
```

#### 4.2.2 Modify `compute_label_position` candidate loop

Add diagram center computation and double the candidate space:

```rust
fn compute_label_position(
    route: &[Point],
    percentage: f64,
    label_width: f64,
    label_height: f64,
    node_rects: &[Rect],
) -> Option<Point> {
    // ... existing seg_lengths / total computation ...

    // Compute diagram center from node rects for tie-breaking
    let diagram_center = if node_rects.is_empty() {
        None
    } else {
        let cx = node_rects.iter().map(|r| r.x + r.width / 2.0).sum::<f64>()
            / node_rects.len() as f64;
        let cy = node_rects.iter().map(|r| r.y + r.height / 2.0).sum::<f64>()
            / node_rects.len() as f64;
        Some(Point::new(cx, cy))
    };

    // Fast path: no nodes to dodge
    if node_rects.is_empty() {
        // Default to side=-1.0 (left/up) for backwards compatibility
        return label_position_at(route, &seg_lengths, total, percentage,
                                 label_width, label_height, -1.0);
    }

    const CANDIDATES: [f64; 9] = [0.5, 0.35, 0.65, 0.2, 0.8, 0.15, 0.85, 0.4, 0.6];
    const SIDES: [f64; 2] = [-1.0, 1.0];

    let mut best_pos: Option<Point> = None;
    let mut best_clearance = f64::NEG_INFINITY;

    'search: for &pct in &CANDIDATES {
        for &side in &SIDES {
            if let Some(pos) = label_position_at(
                route, &seg_lengths, total, pct,
                label_width, label_height, side
            ) {
                let lr = label_bounding_rect(pos, label_width, label_height);
                let clearance = label_clearance(&lr, node_rects);

                let dominated = clearance < best_clearance
                    || (clearance == best_clearance && !closer_to_center(
                        pos, best_pos, diagram_center));

                if !dominated {
                    best_clearance = clearance;
                    best_pos = Some(pos);
                    if clearance > LABEL_PADDING {
                        break 'search;
                    }
                }
            }
        }
    }

    // ... existing nudge logic ...
}
```

#### 4.2.3 New helper: `closer_to_center`

```rust
/// Returns true if `candidate` is closer to `center` than `current`.
fn closer_to_center(
    candidate: Point,
    current: Option<Point>,
    center: Option<Point>,
) -> bool {
    match (current, center) {
        (Some(cur), Some(c)) => {
            let d_new = (candidate.x - c.x).powi(2) + (candidate.y - c.y).powi(2);
            let d_old = (cur.x - c.x).powi(2) + (cur.y - c.y).powi(2);
            d_new < d_old
        }
        _ => true, // no current best or no center → accept candidate
    }
}
```

### 4.3 On-edge fallback (Fix C)

**File:** `crates/d2/src/edge_routing.rs`, inside `label_position_at()`

Replace the offset computation:

```rust
// Horizontal segment:
let natural_offset = (label_height / 2.0) + LABEL_PADDING;
let offset = if natural_offset > MAX_LABEL_OFFSET {
    0.0  // too tall — center on edge
} else {
    natural_offset
};
Some(Point::new(px, py + side * offset))

// Vertical segment:
let natural_offset = (label_width / 2.0) + LABEL_PADDING;
let offset = if natural_offset > MAX_LABEL_OFFSET {
    0.0  // too wide — center on edge
} else {
    natural_offset
};
Some(Point::new(px + side * offset, py))
```

This replaces the `.min(MAX_LABEL_OFFSET)` clamp with a binary choice: either use the full natural offset (label clears the line) or zero (label sits on the line with halo coverage). No in-between.

## 5. Interaction Between Fixes

The three fixes are independent and composable:

| Fix | Alone | With others |
|-----|-------|-------------|
| A (viewBox) | Labels no longer clipped, but still all on one side | Correct bounds for any placement strategy |
| B (bidirectional) | Labels distributed better, but wide ones still clipped | Combined with A, fully solves the problem |
| C (on-edge) | Wide labels centered on line, still clipped | Combined with A+B, clean placement at all widths |

**Recommended order:** A → B → C. Fix A alone resolves the most critical issue (clipping). Fix B resolves the aesthetic clustering. Fix C is a polish step for edge cases with very wide labels.

## 6. Existing Call Sites Affected

### `label_position_at` callers:

1. `compute_label_position` — primary caller, updated in Fix B
2. Fast path in `compute_label_position` (no nodes to dodge) — pass `side = -1.0`

### `compute_viewbox` callers:

1. `render()` in `svg_render.rs` — no signature change, automatically gets expanded bounds

### Constants affected:

| Constant | Current | After |
|----------|---------|-------|
| `MAX_LABEL_OFFSET` | 40.0 | Kept, but only active for medium labels (Fix C) |
| `LABEL_HALO_PADDING` | 3.0 | No change; used in viewBox expansion |
| ViewBox `padding` | 20.0 | No change |

## 7. Test Plan

### 7.1 New unit tests

| Test | Validates |
|------|-----------|
| `test_viewbox_includes_labels` | SVG viewBox contains all label bounding rects |
| `test_label_side_selection_vertical` | Vertical chain: labels don't all go left |
| `test_label_side_selection_horizontal` | Horizontal chain: labels don't all go up |
| `test_wide_label_on_edge` | Label wider than 80px is centered on edge (offset=0) |
| `test_label_not_clipped` | Parse SVG viewBox, verify all label rects are inside |

### 7.2 Existing tests to update

| Test | Expected change |
|------|-----------------|
| `test_label_offset_vertical` | Label may now be RIGHT of line (side=+1) instead of always left. Relax assertion to check offset magnitude, not direction. |
| `test_label_offset_horizontal` | Label may now be BELOW line. Same relaxation. |
| `test_ortho_label_vertical` | May need direction-agnostic assertion |
| `test_ortho_label_horizontal` | May need direction-agnostic assertion |

The assertions change from "label.x < line.x" to "abs(label.x - line.x) >= label_width/2", checking offset magnitude rather than fixed direction.

### 7.3 Conformance suite

All 24 fixtures must pass with 0 violations. The `label_near_edge` invariant (50px threshold) is the binding constraint — Fix C ensures compliance for wide labels by centering them on the edge.

### 7.4 Visual verification

Render the failing diagram (`client -> api -> cache -> db` with labels) before and after. Verify:
- No labels cut off at any edge
- Labels distributed on both sides of the vertical edge chain
- Wide labels visually clean (centered on edge with halo)

## 8. Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| Bidirectional offset changes label positions, breaking visual regression baselines | Visual regression tests should be updated. The new positions are objectively better. |
| On-edge placement (Fix C) hides the route line under the halo | Halo is semi-transparent (opacity=0.85) and matches background — this is standard practice in D2/Mermaid/Graphviz. The line remains visible at halo edges. |
| ViewBox expansion makes diagram larger than expected | Correct behavior — the diagram should be as large as its content. The 20px padding still applies. |
| `closer_to_center` tie-breaker uses node centroid, not geometric center | Good enough. Centroid naturally tracks where the visual "center of mass" is. |
| Existing tests assert fixed label direction | Relax to direction-agnostic assertions. The old direction was arbitrary, not intentional. |

## 9. Files Modified

| File | Change |
|------|--------|
| `crates/d2/src/svg_render.rs` | `compute_viewbox`: add label bounds expansion |
| `crates/d2/src/edge_routing.rs` | `label_position_at`: add `side` param + on-edge fallback |
| `crates/d2/src/edge_routing.rs` | `compute_label_position`: bidirectional candidates + center tie-break |
| `crates/d2/src/edge_routing.rs` | New helper: `closer_to_center` |
| `crates/d2/src/edge_routing.rs` | Tests: new + updated assertions |

## 10. Out of Scope

- **Label-vs-label overlap detection**: Two labels on parallel edges may still overlap each other. Mitigated by channel spreading. Full collision resolution would require a constraint solver — not justified by current failure rate.
- **Multi-line label wrapping at viewport boundary**: If a label is wider than the diagram, it should ideally wrap. Current text wrapping is only based on `MAX_LABEL_WIDTH` (200px). A viewport-aware wrapping pass would be a separate feature.
- **Curved edge labels**: Self-loop edges use Bézier routing. Label placement for those is a separate algorithm (currently hardcoded position). Not addressed here.

# High-Level Design - Markdown Table Wrapping Overhaul

**Date:** 2025-11-10  
**Author:** Codex (autogen)  
**Status:** Draft for review  
**Related Issue:** Markdown tables overflow/overwrite adjacent columns

---

## 0. Design Review Summary

The first draft captured the right architectural direction (single `LayoutJob` per cell) but left several gaps:

1. **Highlight/Search handling** - The renderer currently supports `highlight_phrase`; the draft did not describe how highlighting propagates into the new layout jobs.
2. **Inline widgets (emoji, images, code backgrounds)** - We need an explicit plan for spans that are not plain text so that wraps remain correct when widgets appear mid-cell.
3. **Reuse/Caching** - Without caching, we would rebuild every layout job every frame even when nothing changes. The design needs guidance on memoizing per-cell galleys.
4. **Testing hooks** - Existing tests only cover parser logic. We should document how to verify the new layout builder in isolation.

This revision addresses those items and tightens the implementation plan.

---

## 1. Background & Problem Statement

Tables are rendered by iterating over each `InlineSpan` in a cell and emitting separate `Label`s inside `ui.horizontal_wrapped`. Although we compute per-column widths, the text keeps painting horizontally because:

1. Child `Ui`s inherit an unconstrained `max_rect`, so labels assume infinite width.
2. egui only allows one "shrinkable"/wrappable text atom per widget (`AtomKind::Text`). After the first span, additional labels ignore wrapping and overrun the next column.
3. Emoji/images insert additional widgets that reset width constraints.

Symptoms: long strings (e.g., "comprehensive summary") visually overwrite adjacent columns despite width calculations.

---

## 2. Goals

1. **Preserve column integrity** - Text stays inside its computed column, wrapping vertically when needed.
2. **Retain Markdown fidelity** - Bold/italic/links/code/emoji render exactly as before.
3. **Respect dynamic widths** - Column widths derived from measurement (and eventually user resizing) must directly drive text wrapping.
4. **Remain performant** - Avoid per-frame heap churn; reuse layout buffers and galleys whenever possible.
5. **Maintain UX features** - Highlight/search, context menus, and copy shortcuts continue to work.

---

## 3. Non-Goals

- Replacing egui with another UI toolkit.
- Implementing column resizing UI (possible follow-up once wrapping works).
- Refactoring non-table Markdown rendering code paths.

---

## 4. References & Prior Art

| Source | Key Takeaway |
| --- | --- |
| `egui_extras::TableBuilder` docs | Heterogeneous row heights rely on cell text wrapping; exposes `TableBody::widths()` for per-column feedback. |
| `egui-selectable-table` crate | Uses one widget per cell hooked into `TableBuilder`, proving the pattern in production. |
| `egui-data-table` crate | Same approach for editable grids; cells feed a single `WidgetText` with controlled wrapping. |
| `AtomKind::Text` docs | Only the first atom in a widget is shrinkable unless `atom_max_width` is set manually; motivates the single-`LayoutJob` design. |

---

## 5. Proposed Architecture

### 5.1 Column Width Pipeline (unchanged foundation)

1. **Measure natural widths** via `measure_inline_spans` (headers + rows).
2. **Resolve against viewport** with the existing solver (min floor, wrap cap, proportional shrinking).
3. **(Future)** When we adopt `egui_extras::TableBuilder`, capture actual widths via `TableBody::widths()` to feed back into wraps.

### 5.2 Cell Fragment Model

Introduce an intermediate representation before rendering:

```rust
enum CellFragment<'a> {
    Text(&'a [InlineSpan]),     // contiguous spans convertible to one LayoutJob
    Emoji(&'a str),             // grapheme rendered as Image widget
    Image(&'a InlineSpan),      // existing image span
}
```

Algorithm per cell:

* Iterate spans, grouping contiguous text-like spans (`Text`, `Strong`, `Emphasis`, `Strikethrough`, `Link`, `Code`) until we hit an emoji/image span.
* When encountering emoji/image, flush the current text fragment, push the widget fragment, and continue.

This guarantees we emit at most one text widget between non-text atoms, keeping the "one shrinkable atom" rule intact.

### 5.3 Layout Job Builder

Add `build_layout_job(&self, spans: &[InlineSpan], wrap_width: f32, strong_override: bool) -> LayoutJob`.

Responsibilities:

1. **Section construction** - Convert spans into `LayoutSection`s with the correct font, size, color, italics, strike, etc.
2. **Inline code** - Encode code spans via monospace font plus background color (emulated using `LayoutSection.extra_bg_color`).
3. **Links** - Apply color overrides and store metadata for click handling (wrap the final `Response`).
4. **Highlight phrase support** - Reuse `highlight_phrase` logic by splitting text fragments inside the job to insert sections with background colors when matches occur. This mirrors what `render_text_segment_with_optional_highlight` currently does.
5. **Wrapping** - Set `job.wrap.max_width = wrap_width` and `job.wrap_mode = TextWrapMode::Wrap`. Optionally expose `break_anywhere` for extremely narrow columns.
6. **Context menu integration** - After `ui.label(job)`, attach the same context menu (copy text) we currently use.

### 5.4 Inline Widgets (Emoji & Images)

* **Emoji** - Continue rendering via `Image` widgets, but surround them with `ui.allocate_space(Vec2::new(emoji_width, job_height))` to keep them inside the column width. Because text fragments are flushed before and after, the width constraint persists.
* **Images** - For inline markdown images, clamp `.max_width(col_width)` so they never exceed the column.

### 5.5 Table Rendering Flow

For each column:

1. `ui.allocate_ui_with_layout(Vec2::new(col_width, f32::INFINITY), Layout::top_down(Align::LEFT))`.
2. Inside the child `Ui`, call both `set_width(col_width)` and `set_max_width(col_width)` so nested widgets inherit the constraint.
3. For each fragment produced in Sec 5.2:
   - Text fragment -> build layout job -> render -> attach context menu, highlight, link handling.
   - Emoji/Image fragment -> render widget with width clamp.
4. If any fragment produces multiple galley rows, optionally attach `response.on_hover_text_full(cell_plain_text)` to hint at wrapped content.

Headers run through the same pipeline with `strong_override = true`.

### 5.6 Caching & Reuse

To avoid rebuilding jobs every frame:

* Cache per-cell layout inputs keyed by `(row_index, column_index, content_hash, wrap_width, font_scale)`.
* Store `Arc<Galley>` or raw `LayoutJob` inside a small LRU; invalidate cache when:
  - content changes (file reload, edits),
  - zoom level changes,
  - column widths change (window resize, viewport width shift).
* Emoji/image lookups already use caches (`emoji_textures`); reuse that.

### 5.7 Highlight/Search + Selection

* `build_layout_job` will query `self.highlight_phrase` and split text accordingly, ensuring the resulting galley visually highlights matches.
* Because there is a single `label` per fragment, selection/copy still works; the context menu will copy the plain text of the fragment (extracted via `InlineSpan::text_only` helper).

---

## 6. Implementation Plan

1. **Fragment builder** - Utility that converts `[InlineSpan]` -> `Vec<CellFragment>`.
2. **Layout job builder** - Implement Sec 5.3, including highlight support and inline code styling.
3. **Caching layer** - Add a struct (e.g., `CellLayoutCache`) on `MarkdownRenderer` to memoize `LayoutJob`s/`Galley`s keyed by content hash + width.
4. **Table renderer refactor** - Replace `horizontal_wrapped` loops with fragment iteration; clamp widths per Sec 5.5.
5. **Context menus & link handling** - Wrap each label's `Response` to restore copy + link click behavior.
6. **Unit tests**
   - `test_layout_job_wraps_within_width` - ensures galleys respect supplied width.
   - `test_table_cell_fragments_split_on_emoji`.
   - Regression test with the user's table verifying plain-text export keeps columns distinct.
7. **Manual verification** - Example markdown containing wide text, inline images, emoji, and highlights.

---

## 7. Testing Strategy

| Layer | Test | Purpose |
| --- | --- | --- |
| Unit | `build_layout_job` width + highlight tests | Ensures wrapping and styling survive refactor. |
| Unit | Fragment splitter tests | Confirms emoji/images create separate fragments. |
| Integration | Table render smoke test (headless) | Renders to an off-screen context and reads galley widths. |
| Manual | Run sample markdowns + user table | Visual confirmation at different zooms and window sizes. |

Optional future: screenshot-based golden tests once we have infrastructure.

---

## 8. Risks & Mitigations

| Risk | Impact | Mitigation |
| --- | --- | --- |
| Cache invalidation mistakes leave stale galleys | Wrong text or widths | Include width + font scale in cache key; expose `clear_cache()` when zoom/content changes. |
| Layout job builder duplicates logic from existing text renderer | Divergent styling | Extract shared helpers (e.g., `fn apply_inline_style(section, InlineStyle)`) or run the layout builder through the same style structs. |
| Inline images taller than text break row height | Visual jitter | Clamp image width and add `ui.add_space` to ensure row height grows instead of overflowing. |
| Accessibility regression (keyboard focus) | Harder to navigate | Keep focus/hover handling identical by wrapping label responses and forwarding `Sense::click` for links. |

---

## 9. Open Questions & Follow-Ups

1. **Migration to `egui_extras::TableBuilder`** - Once wrap issues are solved, adopting `TableBuilder` would give us column resizing and scrolling optimizations for free.
2. **Tooltip heuristics** - Do we show full cell content on hover only when it wraps, or always?
3. **Localization** - Should highlight/search remain case-insensitive once text passes through `LayoutJob`? (Likely yes; reuse current normalization.)

---

With these clarifications, the design now specifies how to handle highlighting, emoji/images, caching, and testing, setting the stage for implementation without relying on trial-and-error tweaks.

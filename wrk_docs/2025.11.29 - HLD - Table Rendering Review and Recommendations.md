# HLD - Table Rendering Review and Recommendations

**Date:** 2025-11-29
**Author:** Claude
**Branch:** feat/table-dividers
**Status:** Design Review
**Related Files:** `src/markdown_renderer.rs`, `src/table_support/`

---

## 1. Executive Summary

This document provides a comprehensive review of the table rendering implementation in the `feat/table-dividers` branch. The implementation has evolved through multiple iterations (Nov 10-28, 2025) and addresses several key issues including column width calculation, divider alignment, and row height virtualization.

**Overall Assessment:** The design is fundamentally sound with the Nov 28 bug fix correctly addressing the root cause of divider misalignment. However, several issues and opportunities for improvement remain.

---

## 2. Current State Analysis

### 2.1 What's Working Well

| Feature | Implementation | Status |
|---------|---------------|--------|
| Column width capture | Uses `body.widths()` instead of `ui.min_rect()` | ✅ Correct |
| Divider painting | Uses captured widths with pixel-boundary rounding | ✅ Correct |
| Row virtualization | `heterogeneous_rows()` with height hints | ✅ Working |
| Column policies | Semantic heuristics + content stats | ✅ Good |
| Width persistence | Per-column hash with delta threshold | ✅ Working |
| Unicode support | `unicode-width` for CJK text | ✅ Implemented |
| Multiple remainder columns | Cap at 2, score-based promotion | ✅ Implemented |

### 2.2 Test Coverage

- 87 tests passing
- Unit tests for column classification, width change detection, CJK handling
- Integration tests for table ID uniqueness, cell parsing

---

## 3. Identified Issues

### 3.1 Critical Issues

#### Issue 1: Table Rect Calculation Uses Cell min_rect Instead of Allocated Space

**Location:** `render_table_tablebuilder()` lines 3386, 3416

**Problem:** The `table_rect` is built by unioning each cell's `ui.min_rect()`. However, `min_rect()` returns the bounding box of *rendered content*, which may be smaller than the *allocated column width*. This could cause:
- Border drawn inside the rightmost column boundary
- Dividers extending beyond the outer border

**Current Code:**
```rust
header.col(|ui| {
    // ...
    Self::extend_table_rect(&mut table_rect, ui.min_rect());  // Content rect, not column rect
});
```

**Evidence:** The HLD from Nov 28 acknowledges this: "The `table_rect` should encompass the entire table. Currently it's built by extending with each cell's `min_rect()`. This is acceptable because we're union-ing all rects, but we should verify it includes padding."

**Risk Level:** Medium - May cause visual artifacts at table edges.

---

#### Issue 2: Clip Rect Captured from First Cell May Not Cover Full Table

**Location:** `render_table_tablebuilder()` lines 3387-3391, 3417-3421

**Problem:** The `clip_rect` is captured from the first rendered cell and never updated. If the table scrolls or the first cell has an unusual clip region, dividers could be clipped incorrectly.

**Current Code:**
```rust
if clip_rect.is_none() {
    clip_rect = Some(ui.clip_rect());
    // ...
}
```

**Risk Level:** Low - Usually works because cells share the same scroll region.

---

#### Issue 3: No Horizontal Divider Between Header and Body

**Location:** `paint_table_dividers()` lines 3549-3576

**Problem:** Only vertical dividers and an outer border are painted. There is no horizontal line separating the header row from the body rows. Most table renderers draw this line for visual clarity.

**Current Code:**
```rust
// Draw vertical dividers between columns
for width in widths.iter().take(widths.len().saturating_sub(1)) {
    x += *width;
    painter.vline(x_pos, rect.y_range(), separator_stroke);
}
// Draw outer border
painter.rect_stroke(rect, 0.0, border_stroke);
// No header separator!
```

**Risk Level:** Low - Cosmetic issue, but common user expectation.

---

### 3.2 Moderate Issues

#### Issue 4: Header Height Estimation Runs Twice

**Location:** `render_table_tablebuilder()` lines 3338-3353

**Problem:** Header heights are pre-measured by rendering into throwaway UIs, then the header is rendered again in the actual TableBuilder. This is correct but wasteful - the header is effectively rendered twice.

**Design Note:** The Nov 20 HLD proposed measuring headers once and caching, but the current implementation re-renders. This is acceptable for correctness but has a minor performance cost.

**Risk Level:** Low - Performance overhead is small for typical headers.

---

#### Issue 5: Empty Table Metrics Not Cleaned Up

**Location:** `src/table_support/metrics.rs`

**Problem:** `TableMetrics` stores per-table entries indefinitely. If a document changes and tables are removed, stale entries remain in memory.

**Current Mitigation:** Calling `clear()` wipes all metrics, but there's no per-table cleanup when navigating between documents.

**Risk Level:** Low - Memory overhead is minimal for typical usage.

---

#### Issue 6: Column Stat Sampling Limit May Miss Long Tables

**Location:** `column_spec.rs` line 10: `const MAX_REMAINDER_COLUMNS: usize = 2`

**Problem:** Column stats sample only the first 128 rows (`COLUMN_STATS_SAMPLE_ROWS`). For tables where content varies significantly after row 128, column policies may be suboptimal.

**Risk Level:** Low - 128 rows is a reasonable sample for most use cases.

---

### 3.3 Minor Issues / Opportunities

#### Issue 7: Persisted Widths Not Invalidated on Font Size Change

**Location:** `persist_resizable_widths()`, `apply_persisted_widths()`

**Problem:** If the user changes zoom level, persisted column widths from the previous font size are still applied. This could cause columns to be too narrow or wide after zooming.

**Design Note:** The Nov 20 HLD flagged this as an open question: "Should persisted widths survive font size changes?"

**Risk Level:** Low - Users can manually resize or clear cache.

---

#### Issue 8: Width Change Repaint May Loop Briefly

**Location:** `handle_width_change()` lines 3531-3541

**Problem:** When a "Large" width change is detected, a repaint is requested. This could theoretically cause a brief repaint loop if widths continue to change.

**Current Mitigation:** The `last_discard_frame` check prevents multiple repaints per frame.

**Risk Level:** Very Low - Current mitigation is effective.

---

## 4. Recommended Fixes

### 4.1 High Priority

#### Fix 1: Calculate Table Rect from Column Widths + Body Max Rect

Replace the current `extend_table_rect` approach with a calculation based on known column widths and the body's actual bounds.

**Proposed Change:**
```rust
.body(|body| {
    *column_widths.borrow_mut() = body.widths().to_vec();

    // Capture the body's max_rect for accurate table bounds
    let body_rect = body.max_rect();

    body.heterogeneous_rows(/* ... */);

    // Use body_rect for table boundary instead of union of min_rects
});
```

**Note:** `body.max_rect()` returns the screen-space region occupied by the table body. Combined with the header height, this gives an accurate table rect.

**Complexity:** Low
**Risk:** Low

---

#### Fix 2: Add Horizontal Header Separator

Add a horizontal line between the header and body rows.

**Proposed Change to `paint_table_dividers()`:**
```rust
fn paint_table_dividers(
    &self,
    painter: &Painter,
    visuals: &Visuals,
    rect: egui::Rect,
    clip_rect: egui::Rect,
    widths: &[f32],
    header_height: f32,  // NEW PARAMETER
) {
    // ... existing vertical dividers ...

    // Draw horizontal separator below header
    let header_y = rect.top() + header_height;
    if header_y > rect.top() && header_y < rect.bottom() {
        painter.hline(rect.x_range(), header_y.round() + 0.5, separator_stroke);
    }

    // ... existing outer border ...
}
```

**Complexity:** Low
**Risk:** Very Low

---

### 4.2 Medium Priority

#### Fix 3: Invalidate Persisted Widths on Zoom Change

Track the font size when widths are persisted. If font size changes, clear persisted widths for affected tables.

**Proposed Change to `TableMetricEntry`:**
```rust
pub struct TableMetricEntry {
    // ... existing fields ...
    pub last_font_size: f32,  // NEW FIELD
}

// In persist_resizable_widths():
if (entry.last_font_size - body_font_px).abs() > 0.5 {
    entry.persisted_column_widths.clear();
    entry.last_font_size = body_font_px;
}
```

**Complexity:** Low
**Risk:** Low

---

#### Fix 4: Use Body Clip Rect Instead of First Cell

Capture the clip rect from the body context rather than the first cell.

**Proposed Change:**
```rust
.body(|body| {
    // Capture clip rect from body context
    let body_clip = body.max_rect();  // or use the scroll area's clip

    // ... rest of body rendering ...
});
```

**Note:** This requires investigation into whether `body.max_rect()` provides the appropriate clip region or if the scroll area's clip is needed.

**Complexity:** Medium
**Risk:** Low

---

### 4.3 Low Priority / Future Enhancements

#### Enhancement 1: Cache Header Height Measurement

Avoid re-measuring headers by caching the computed header height per table ID.

**Complexity:** Medium
**Risk:** Low

---

#### Enhancement 2: Clean Up Stale Table Metrics

When loading a new document, compare table IDs and remove entries that no longer exist.

**Complexity:** Medium
**Risk:** Low

---

#### Enhancement 3: Horizontal Row Dividers (Optional)

Some users may want horizontal dividers between all rows, not just below the header. This could be a preference.

**Complexity:** Low
**Risk:** Very Low (if made optional)

---

## 5. Implementation Order

| Priority | Fix | Effort | Impact |
|----------|-----|--------|--------|
| 1 | Header separator line | Low | High - Visual polish |
| 2 | Table rect from body.max_rect() | Low | Medium - Correctness |
| 3 | Zoom invalidates persisted widths | Low | Medium - UX |
| 4 | Clip rect from body | Medium | Low - Edge cases |
| 5 | Cache header measurement | Medium | Low - Performance |
| 6 | Clean stale metrics | Medium | Low - Memory |

---

## 6. Design Validation

### 6.1 Confirmed Correct

The following aspects of the Nov 28 HLD have been validated as correctly implemented:

1. **Width Capture Bug Fix:** `body.widths()` is correctly used instead of `ui.min_rect().width()`. This is implemented at line 3399.

2. **RefCell Pattern:** The `RefCell<Vec<f32>>` pattern is correctly used to capture widths from the body closure and use them after the closure completes.

3. **Width Change Detection:** The `WidthChange` enum with `None`/`Small`/`Large` thresholds is correctly implemented in `metrics.rs`.

4. **Divider Pixel Rounding:** The `(x.round() + 0.5)` pattern is correctly applied for crisp 1-pixel lines.

### 6.2 HLD Discrepancies

| HLD Statement | Actual Implementation | Status |
|---------------|----------------------|--------|
| "Use `body.max_rect()` as fallback for table rect" | Not implemented - uses union of min_rects | Gap |
| "Add test for width capture correctness" | No specific test exists | Gap |
| "Document the fix with inline comments" | Comments exist at lines 3365-3368, 3384-3385, 3397-3398, 3543-3548 | ✅ Done |

---

## 7. Test Recommendations

### 7.1 Missing Tests

1. **Table rect bounds match column widths:** Verify that `table_rect.width()` equals `sum(column_widths)`.

2. **Header separator position:** Verify that the header separator (once added) is at the correct y-position.

3. **Zoom font size change:** Verify that persisted widths are cleared when font size changes (once implemented).

4. **Empty table handling:** Verify that tables with no rows render correctly.

### 7.2 Regression Test Files

The existing test files are adequate:
- `examples/regressions/table-wrap.md` - Multi-column wrapping
- `examples/regressions/table-threat-model.md` - Wide Examples column
- `examples/table_test.md` - General table rendering

---

## 8. Conclusion

The `feat/table-dividers` branch represents a solid implementation of the table rendering overhaul. The core bug fix (using `body.widths()` instead of `ui.min_rect()`) is correctly implemented and well-documented.

**Recommended Next Steps:**

1. **Implement Fix 1 (Header separator)** - High visual impact, low effort
2. **Implement Fix 2 (Table rect calculation)** - Correctness improvement
3. **Merge to master** after fixes 1-2 are complete
4. **Address remaining items** in subsequent iterations

The design is mature and ready for final polish before merging.

---

## 9. References

- `wrk_docs/2025.11.28 - HLD - Table Rendering Bug Fixes.md`
- `wrk_docs/2025.11.28 - PLN - Table Rendering Bug Fixes.md`
- `wrk_docs/2025.11.20 - HLD - table-formatting-improvements.md`
- `wrk_docs/2025.11.14 - HLD - Table Dividers and Column Widths.md`
- `docs/QA-table-wrap.md`
- [egui_extras TableBody Documentation](https://docs.rs/egui_extras/latest/egui_extras/struct.TableBody.html)

---

## Appendix A: Code Locations Quick Reference

| Component | File | Lines |
|-----------|------|-------|
| Table ID computation | `markdown_renderer.rs` | 2912-2948 |
| Column stats cache | `markdown_renderer.rs` | 2950-2976 |
| Table rect extension | `markdown_renderer.rs` | 3293-3306 |
| TableBuilder rendering | `markdown_renderer.rs` | 3308-3453 |
| Divider painting | `markdown_renderer.rs` | 3543-3576 |
| Column policies | `table_support/column_spec.rs` | 24-96 |
| Column classification | `table_support/column_spec.rs` | 313-384 |
| Metrics tracking | `table_support/metrics.rs` | 1-165 |

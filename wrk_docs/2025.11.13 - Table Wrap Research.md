# Table Wrap Research Report

**Date:** 2025-11-13

## 1. Overview
We surveyed widely used egui-based table/markdown components to understand their wrapping strategies, column sizing policies, and performance trade-offs. Sources include official egui_extras docs, specialized table crates (egui_data_table, egui_selectable_table, egui_table), layout utilities (egui_taffy), and markdown viewers like egui_commonmark. Key findings are below.

## 2. Canonical Patterns in Open-Source Egui Tables

### 2.1 TableBuilder as the default scaffold
egui_extras::TableBuilder is the de facto foundation for high-quality tables. It exposes per-column sizing (auto/remainder/exact), resizability toggles, and ties into virtualization-friendly row builders. Projects such as egui_data_table and egui_selectable_table lean on these APIs for predictable wrapping and resizing.citeturn2search0turn5search2turn3search7

Implications:
- Adopt TableBuilder instead of custom grids. It already handles scrollable bodies, headers, and coordinates with TableBody::rows/heterogeneous_rows to avoid re-rendering hidden content.
- Use TableBody::widths() feedback loop if cell content depends on the final column width (critical for wrapped markdown).citeturn4search0

### 2.2 Column definitions enforce wrapping budgets
Open-source tables declare columns using egui_extras::Column, combining automatic sizing with guards like .at_least() and .clip(true) to prevent runaway columns. This is how egui_selectable_table and egui_data_table keep text constrained without manual measurement.citeturn4search2turn3search7turn5search2

Implications:
- Mirror this by driving our width solver from actual Column descriptors rather than bespoke heuristics.
- Leverage .clip(true) when a column must stay narrow and rely on tooltips for overflow; otherwise keep clipping off so TableBuilder grows the column.

### 2.3 Heterogeneous row heights for wrapped text
TableBody::heterogeneous_rows is the documented method for allowing each row to consume as much vertical space as its wrapped text requires while still benefiting from virtualization.citeturn4search0

Implications:
- Precompute row heights (based on final galley row count) and feed them into heterogeneous_rows. This is how egui_table achieves stable scrolling with multi-line cells.citeturn1search10

### 2.4 Text layout expectations in egui
Wrapping control happens at the LayoutJob/TextWrapping level, not by stacking multiple labels. TextWrapMode and AtomKind specify that exactly one shrinkable text atom per widget is permitted; additional atoms must set explicit widths or get collapsed.citeturn0search0turn0search1turn1search7

Implications:
- Build a single LayoutJob per cell with TextWrapping { max_width, break_anywhere } matching the computed column width. Avoid mixing Label widgets for different spans.

### 2.5 Using higher-level layout engines when needed
egui_taffy demonstrates how alternative layout back-ends (taffy) can enforce minimum widths and wrap policies reliably, recommending explicit width constraints or wrap mode overrides when egui defaults misbehave.citeturn0search4

Implications:
- If TableBuilder proves insufficient, embedding a taffy-based container (or even StripBuilder/GridBuilder) around the table region is a known escape hatch.

## 3. Markdown-Specific Observations
egui_commonmark already renders CommonMark tables on top of egui, so it is an existence proof that the pattern works. While its docs do not spell out the implementation, its feature list confirms table support—suggesting we could study its source for concrete techniques (e.g., whether it uses TableBuilder or a grid fallback).citeturn3search3

## 4. Gap Analysis vs. mdmdview
1. **Custom grid vs. TableBuilder:** mdmdview still hand-rolls a grid, re-implementing width resolution and rendering. This diverges from the community baseline and forfeits built-in virtualization.
2. **Width feedback loop:** We measure spans up-front but never reconcile with actual UI geometry. TableBuilder users rely on TableBody::widths() to know the true width after layout.
3. **Row virtualization:** We render every row every frame; open-source data tables use ows/heterogeneous_rows to render only visible portions.
4. **Single-atom text widgets:** Our renderer still stitches multiple Labels per span. That clashes with egui’s “one shrinkable atom” rule documented under AtomKind, explaining the wrapping glitches.
5. **Column descriptors:** Without Column::clip/at_least/resizable, we manually clamp widths and risk inconsistencies between headers/body.

## 5. Recommendations
1. **Re-platform on TableBuilder:** Replace the bespoke grid with TableBuilder::new(ui).columns(...) so we inherit scrolling, headers, and column resizing for free.
2. **Define column policies explicitly:** For each markdown column, declare whether it’s uto(), initial(width).resizable(true), or emainder().clip(true); this standardizes wrap behavior.
3. **Adopt heterogeneous row virtualization:** After building each cell LayoutJob, record galley.rows to derive the row height fed into heterogeneous_rows. This matches egui_table guidance and keeps performance predictable.
4. **Use one LayoutJob per cell:** Respect TextWrapping and TextWrapMode::Wrap; ensure only one shrinkable text atom exists (links/emojis become sections inside the same job).
5. **Study egui_commonmark/egui_data_table:** Audit their code paths to understand how they map markdown spans into TableBuilder-driven cells; we can likely port their approach instead of maintaining a divergent renderer.
6. **Consider taffy-backed layout as fallback:** If TableBuilder still cannot meet requirements (e.g., we need CSS-like flex), egui_taffy provides a known-good path for precise wrapping.

Adopting these patterns aligns mdmdview with how the egui ecosystem already solves wrapped tables, reducing maintenance burden and improving fidelity with minimal bespoke logic.

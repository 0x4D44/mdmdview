# High-Level Design - Table Wrap Replatform (Revised)

**Date:** 2025-11-13  
**Author:** Codex (autogen)  
**Related Artifacts:** wrk_docs/2025.11.13 - Table Wrap Research.md

---

## 0. Problem Statement & Goals
The current table renderer hand-builds an egui::Grid, measures spans manually, and paints per-cell LayoutJobs outside egui’s table infrastructure. Despite recent fixes it still suffers from inconsistent wrapping, multiple-label artifacts (violating egui’s one shrinkable atom rule), and high per-frame costs. The egui ecosystem already converged on egui_extras::TableBuilder (and, when necessary, egui_taffy) for virtualized, wrap-aware tables. Replatforming on that canonical path delivers:
1. Predictable wrapping tied to actual column widths.
2. Built-in virtualization / heterogeneous row heights via TableBody APIs.
3. Declarative column policies (auto/resizable/clip) consistent with user expectations.
4. Simpler, community-aligned code, easing maintenance.

---

## 1. Requirements
| ID | Requirement | Notes |
| --- | --- | --- |
| R1 | Render markdown tables using egui_extras::TableBuilder for both headers and body | Enables column descriptors + virtualization |
| R2 | Each cell emits a single LayoutJob whose TextWrapping.max_width matches the resolved column width | Avoids multi-label overflow issues |
| R3 | Support heterogeneous row heights so multi-line cells expand vertically without distorting scroll metrics | Use TableBody::rows(|row| row.row(height, …)) with per-row heights |
| R4 | Columns have explicit policies (auto, fixed, remainder, clip, resizable) mirroring egui_data_table | Allows future persistence/resizing |
| R5 | Keep the runtime toggle (--table-wrap, --no-table-wrap, View menu) but default to the overhaul | Already true; legacy path remains fallback |
| R6 | Maintain layout cache/metrics, keyed by (row?, column, resolved width px, strong flag, highlight hash, content hash) | Cache must reflect real column widths |
| R7 | Provide optional fallbacks (legacy grid / taffy) behind debug flags, but TableBuilder path is the default | For troubleshooting only |
| R8 | Preserve existing UX (link clicks, selection, drag/drop) | LayoutJob metadata still drives interactions |

---

## 2. Architecture Overview
`
MarkdownRenderer::render_table()
    ├─ derive_column_specs(&headers) -> Vec<ColumnSpec>
    ├─ build TableBuilder with per-column definitions
    │     ├─ header(|mut header| header.col(|ui| render_cell(None, col)))
    │     └─ body(|mut body| body.rows(row_count, |row| row.row(height, |mut row| render_cell(Some(idx), col))))
    └─ CellLayoutCache keyed by (row?, col, column_width_px, is_header, highlight_hash, content_hash)
`

Key pieces:
1. **ColumnSpec** – derived from header semantics (text vs numeric) + default heuristics. Wraps egui_extras::Column plus metadata (resizable?, clipped?).
2. **TableBuilder integration** – replace egui::Grid with TableBuilder, using column(Column::...) calls for each column. Enables horizontal scrolling/resizing and built-in striping.
3. **Layout pipeline** – fragment + layout-job builder remain, but they now receive the actual column width from the TableBuilder-provided Ui (ui.max_rect().width() inside each cell).
4. **Cache** – keyed by row/column IDs and width. Heights (galley.size().y + padding) are stored alongside jobs for virtualization.
5. **Virtualization** – ody.rows(row_count, |mut row| { let h = row_heights[row.index()]; row.row(h, |mut row| { ... }); }) renders only visible rows.

---

## 3. Detailed Design
### 3.1 Column Policy Resolution
- Define ColumnPolicy enum (Auto, Fixed { width }, Remainder, Resizable { min, preferred, clip }).
- Map header content → policies:
  - Numeric/short text (Version, Date) → Column::exact(width).clip(true).
  - Long text (Changes, Notes) → Column::remainder().clip(false) so wrapping drives width.
  - Author/metadata → Column::initial(140.0).resizable(true).at_least(100.0).
- Implement n column_specs(headers: &[Vec<InlineSpan>]) -> Vec<ColumnSpec> returning both the Column handles and derived metadata (tooltip labels, default widths). Allow future CLI/config overrides per column.

### 3.2 TableBuilder Flow (corrected)
`ust
let mut table = TableBuilder::new(ui)
    .striped(true)
    .column(Column::exact(80.0).clip(true))
    .column(Column::exact(120.0))
    .column(Column::remainder())
    .column(Column::auto().resizable(true));

table
    .header(HEADER_HEIGHT, |mut header| {
        for (ci, column) in headers.iter().enumerate() {
            header.col(|ui| render_cell(ui, None, ci, column));
        }
    })
    .body(|mut body| {
        body.rows(row_count, |mut row| {
            let idx = row.index();
            let height = row_metrics[idx].height;
            row.row(height, |mut row_ui| {
                for (ci, cell_spans) in rows[idx].iter().enumerate() {
                    row_ui.col(|ui| render_cell(ui, Some(idx), ci, cell_spans));
                }
            });
        });
    });
`
- We add one column(...) call per column; there is no .columns(...) helper in the API (earlier draft incorrectly implied one bulk call).
- Row virtualization happens because ow.row(height, …) is only invoked for rows the TableBuilder decides to display (when the table sits inside a scroll region). Using ow.index() avoids precomputing heights for off-screen rows.
- ow_metrics[idx] is populated lazily: the cache stores the most recent galley height per row/column; the row height is max(cell_heights_in_row) + vertical_padding.

### 3.3 Cell Rendering & Layout
- ender_cell(ui, row_idx, col_idx, spans) obtains the column width from ui.max_rect().width() (TableBuilder clips each cell to the column’s width). This replaces the previous manual width solver.
- Cache key fields:
  - ow_idx: Option<usize> (None for header)
  - col_idx: usize
  - width_px: f32 (rounded to e.g. 0.25 px to avoid thrash)
  - strong_flag (header styling)
  - highlight_hash, content_hash
  - policy_tag (hash of ColumnPolicy variant) to ensure toggling clip/resizable invalidates cache
- Cache entry stores LayoutJobBuild + galley_height. On miss we build the job, store height, and update row_metrics.
- For clipped columns we rely on TableBuilder’s column.clip(true); any additional clipping is handled via ui.clip_rect_intersect only when child widgets (images) exceed width.

### 3.4 Row Virtualization & Metrics
- Maintain RowMetrics vector per table (resized lazily). Each entry tracks max_cell_height, dirty flag, and optional instrumentation (cache hits).
- When TableBuilder requests row i, we ensure RowMetrics[i] exists; if any cell in that row re-layouts (cache miss or width change), update max_cell_height.
- ow.row(height, |row_ui| …) uses the latest max_cell_height (default fallback = font line height + padding). This matches egui_selectable_table / egui_table patterns.
- Large tables: TableBuilder already places the body in a scroll region so only visible rows run ender_cell. No extra threshold logic is required beyond ensuring we wrap the table in ScrollArea (TableBuilder does this automatically when .auto_scroll(true) is set; default is true).

### 3.5 Integration Points
- Feature flag remains for now; --no-table-wrap flips back to the legacy grid until QA signs off. Once stable we delete the grid path and repurpose the flag as a debug fallback.
- Cache flush triggers: file load, highlight change, zoom change, theme change, column resize, toggle on/off.
- Status bar telemetry continues to report hits/misses; extend to include endered_rows / total_rows so QA can confirm virtualization.

### 3.6 Optional Taffy Fallback
- Provide hidden flag MDMDVIEW_TABLE_WRAP_TAFFY=1 to route table rendering through egui_taffy for diagnostics if TableBuilder still misbehaves.

---

## 4. Testing Strategy
1. **Unit tests**
   - Column policy classifier (header text → policy).
   - Cache invalidation when width/clip/policy changes.
2. **Integration tests**
   - Headless render of regression table verifying: (a) galley.rows.len() > 1 for long text, (b) row metrics record heights.
   - Simulate column resize (call Column::resizable and send drag events) ensuring caches invalidate and ow_metrics recompute.
3. **Manual QA**
   - Regression markdown (narrow vs wide) with screenshots.
   - Column resizing/resizable toggles (if enabled).
   - Large document (>= 500 rows) for virtualization performance + cache stats.
   - Light/dark themes for text visibility.

---

## 5. Risks & Mitigations
| Risk | Mitigation |
| --- | --- |
| TableBuilder integration regresses selection or context menus | Keep legacy grid via --no-table-wrap until QA approves; add smoke tests |
| Row height cache gets out of sync | Mark row metrics dirty whenever any cell in the row rebuilds; recompute height lazily |
| Column policies need user customization | Keep heuristics but add CLI/Config in a follow-up | 
| Additional dependency surface | egui_extras already in tree; taffy fallback is behind debug flag |
| Non-table markdown performance | Unchanged path; TableBuilder code only runs for tables |

---

## 6. Rollout Plan
1. Implement TableBuilder-based renderer behind the existing flag; legacy grid remains accessible via --no-table-wrap.
2. QA burn-in: capture screenshots, cache stats, virtualization behavior on large docs.
3. Remove legacy grid path and repurpose --no-table-wrap as a debug toggle (or drop entirely) once stable.
4. Optional enhancements: persist column widths (TableBuilder column_resizing()), add user-facing settings.

---

Adopting TableBuilder and ecosystem patterns fixes the remaining wrapping issues, aligns us with upstream best practices, and simplifies future enhancements (column resizing, virtualization, row selection).

# High-Level Design: Table Column and Border Fixes

**Date:** 2025.11.14
**Author:** Claude
**Status:** Draft
**Related Documents:** 2025.11.14 - RSR - Table Rendering Research.md

---

## 1. Executive Summary

This HLD addresses two critical table rendering bugs in mdmdview:

1. **Column Width Bug:** Column widths are incorrect, appearing "off by one" where the Examples column is too narrow and Description column too wide
2. **Border Rendering Bug:** Table dividing lines appear in odd locations, sometimes overwriting text or showing only a single line for multi-column tables

The fixes maintain mdmdview's existing algorithmic strengths (grapheme-aware measurement, intelligent column classification, 3-tier width resolution) while addressing rendering issues in both the legacy Grid path and new TableBuilder path.

**Estimated Effort:** 2-3 days
**Risk Level:** Medium (changes core rendering logic)
**Backwards Compatibility:** Full (preserves existing API and behavior)

---

## 2. Problem Statement

### 2.1 Column Width Issue

**Symptom:** In the threat-model table (4 columns: Element, Symbol, Description, Examples), the column widths are incorrect:
- Examples column is too narrow (should be widest, using Remainder policy)
- Description column is too wide
- Visual appearance suggests columns may be "off by one"

**Current Test Case:**
```markdown
| Element          | Symbol        | Description                          | Examples                                            |
|------------------|---------------|--------------------------------------|-----------------------------------------------------|
| External Entity  | Rectangle     | Things outside your control          | Users, external systems, web sites                  |
| Process          | Circle        | Running code                         | Services, applications, functions                   |
| Data Flow        | Arrow         | Information movement                 | API calls, network traffic                          |
| Data Store       | Parallel lines| Data at rest                         | Databases, files, caches                            |
| Trust Boundary   | Dotted line   | Change in privilege/trust level      | Network boundaries, process isolation               |
```

**Expected Behavior:**
- Element (col 0): Fixed ~90-200px
- Symbol (col 1): Resizable ~98-133px
- Description (col 2): Resizable ~147-203px
- Examples (col 3): Remainder (takes all leftover space)

### 2.2 Border Rendering Issue

**Symptom:** Table dividing lines appear incorrectly:
- Sometimes a single vertical line for multi-column tables
- Lines may overwrite text
- Lines appear in odd locations

**Root Cause (Suspected):** egui_extras::TableBuilder provides no native cell dividers. The current implementation uses:
```rust
Frame::none()
    .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
    .show(ui, |ui| {
        Grid::new("md_table").striped(true).show(ui, |ui| { ... });
    });
```

This only draws an outer frame, not cell dividers.

---

## 3. Root Cause Analysis

### 3.1 Column Width Bug Analysis

**Investigated Code Paths:**

**Path 1: Legacy Grid Rendering** (`render_table_legacy`, line 3268-3316)
```rust
// Headers
for (ci, h) in headers.iter().enumerate() {
    let w = widths.get(ci).copied().unwrap_or(120.0);  // âœ“ Correct indexing
    ...
}

// Body
for (ri, row) in rows.iter().enumerate() {
    for (ci, cell) in row.iter().enumerate() {
        if ci < headers.len() {                       // âœ“ Bounds check
            let w = widths.get(ci).copied().unwrap_or(120.0);  // âœ“ Correct indexing
            ...
        }
    }
}
```

**Assessment:** Legacy path indexing appears correct.

**Path 2: TableBuilder Rendering** (`render_table_tablebuilder`, line 3318-3382)
```rust
// Column spec derivation
let column_stats = self.column_stats_for_table(table_id, headers, rows);
let ctx = TableColumnContext::new(headers, rows, &column_stats, self.font_sizes.body, table_id);
let mut column_specs = derive_column_specs(&ctx);  // â† Specs based on headers.len()
let row_max = rows.iter().map(|r| r.len()).max().unwrap_or(0);
let target_cols = column_specs.len().max(row_max).max(1);
while column_specs.len() < target_cols {
    column_specs.push(ColumnSpec::new(
        format!("Column {}", column_specs.len() + 1),
        ColumnPolicy::Remainder { clip: false },     // âš ï¸ ISSUE: Padding with Remainder!
    ));
}

// Header rendering
table.header(HEADER_HEIGHT, |mut header| {
    for ci in 0..column_specs.len() {                // â† Loop over ALL specs
        header.col(|ui| {
            let spans = headers.get(ci).map(|v| v.as_slice()).unwrap_or(&[]);  // â† May be empty!
            ...
        });
    }
})

// Body rendering
.body(|body| {
    body.heterogeneous_rows(row_heights.into_iter(), |mut row| {
        let idx = row.index();
        let row_cells = rows.get(idx);
        for ci in 0..column_specs.len() {            // â† Loop over ALL specs
            row.col(|ui| {
                let spans = row_cells
                    .and_then(|cells| cells.get(ci))
                    .map(|cell| cell.as_slice())
                    .unwrap_or(&[]);                  // â† May be empty!
                ...
            });
        }
    });
});
```

**CRITICAL BUG IDENTIFIED:**

Lines 3332-3339 pad `column_specs` to match `target_cols` by adding **Remainder policy columns**. This causes:

1. If a row has more cells than headers, padding columns are added
2. All padding columns use `ColumnPolicy::Remainder { clip: false }`
3. Multiple remainder columns compete for space, violating the "one remainder column" design
4. The intended remainder column (Examples) now shares space with padding columns
5. Column widths become unpredictable due to multiple remainder columns

**Example Scenario:**
- Headers: 4 columns (Element, Symbol, Description, Examples)
- One body row has 5 cells (ragged table)
- `target_cols` becomes 5
- A 5th column spec is added with Remainder policy
- Now we have TWO remainder columns (Examples + padding column 5)
- Examples column no longer gets full remainder space

**Additional Issue:** The loop `0..column_specs.len()` may iterate beyond `headers.len()`, rendering empty cells for missing headers.

### 3.2 Column Statistics Bug

**Potential Issue in `compute_column_stats`** (column_spec.rs:378-409):

```rust
let column_count = max(
    headers.len(),
    rows.iter().map(|row| row.len()).max().unwrap_or(0),
);
...
for (idx, header) in headers.iter().enumerate() {
    accumulate_stats_for_cell(header, &mut stats[idx]);  // âœ“ OK
}
...
for row in rows.iter() {
    for (idx, cell) in row.iter().enumerate().take(column_count) {
        accumulate_stats_for_cell(cell, &mut stats[idx]);  // âœ“ OK
    }
}
```

**Assessment:** Statistics collection appears correct. The `.take(column_count)` prevents out-of-bounds access.

### 3.3 Border Rendering Bug Analysis

**Current State:**

1. **Legacy Path:** Uses `Frame::none().stroke(...)` which only draws outer border
2. **TableBuilder Path:** Uses `.striped(true)` which only provides alternating row backgrounds
3. **No cell dividers** in either path

**Evidence from Research:**
- egui GitHub Issue #4783: "egui_extras: table cell dividers" (not implemented)
- egui GitHub Issue #4158: "egui_extras: vertical separator between columns" (not implemented)

**Suspected Cause of "Odd Lines":**

Without seeing the actual rendering bug, possible causes:
1. **Frame stroke rendering artifact:** The outer frame may be rendering incorrectly when the table is clipped or scrolled
2. **Grid spacing issues:** `egui::Grid` may be rendering its own lines (unlikely, as Grid doesn't have built-in borders)
3. **Previous manual painter attempts:** If there was prior code attempting to draw dividers, it may have bugs

**Hypothesis:** The "odd lines" are likely from the outer Frame stroke being partially visible or misaligned.

---

## 4. Proposed Solution

### 4.1 Fix Strategy Overview

**Phase 1: Fix Column Width Bug** (High Priority)
- Remove or fix the column spec padding logic
- Ensure only one remainder column per table
- Add debug logging for width resolution

**Phase 2: Implement Cell Dividers** (Medium Priority)
- Track cell rectangles during rendering
- Post-render paint vertical and horizontal divider lines
- Use egui painter API with specific coordinate ranges

**Phase 3: Testing and Validation** (Essential)
- Create comprehensive test cases
- Visual regression testing
- Performance profiling

### 4.2 Detailed Solution: Column Width Fix

#### 4.2.1 Root Cause: Multiple Remainder Columns

**Current Buggy Code** (markdown_renderer.rs:3332-3339):
```rust
let mut column_specs = derive_column_specs(&ctx);
let row_max = rows.iter().map(|r| r.len()).max().unwrap_or(0);
let target_cols = column_specs.len().max(row_max).max(1);
while column_specs.len() < target_cols {
    column_specs.push(ColumnSpec::new(
        format!("Column {}", column_specs.len() + 1),
        ColumnPolicy::Remainder { clip: false },  // âš ï¸ BUG: Multiple remainder columns!
    ));
}
```

**Fix Option 1: Use Auto Policy for Padding Columns**
```rust
let mut column_specs = derive_column_specs(&ctx);
let row_max = rows.iter().map(|r| r.len()).max().unwrap_or(0);
let target_cols = column_specs.len().max(row_max).max(1);

// Pad with Auto policy, not Remainder
while column_specs.len() < target_cols {
    column_specs.push(ColumnSpec::new(
        format!("Column {}", column_specs.len() + 1),
        ColumnPolicy::Auto,  // âœ“ FIX: Use Auto, not Remainder
        None,
    ));
}
```

**Rationale:**
- `Auto` policy allows natural content-based sizing
- Doesn't compete with the intended remainder column
- Handles ragged tables gracefully

**Fix Option 2: Use Resizable Policy for Padding Columns**
```rust
while column_specs.len() < target_cols {
    column_specs.push(ColumnSpec::new(
        format!("Column {}", column_specs.len() + 1),
        ColumnPolicy::Resizable {
            min: self.font_sizes.body * 7.0,
            preferred: self.font_sizes.body * 9.5,
            clip: false,
        },
        None,
    ));
}
```

**Rationale:**
- Matches the default policy from `classify_column` (line 330-334)
- Provides consistent behavior
- More predictable than Auto

**Recommended:** **Option 2 (Resizable)** for consistency with the classification logic.

#### 4.2.2 Header/Body Column Count Alignment

**Current Issue:** Loop iterates `0..column_specs.len()` but `headers.get(ci)` may return `None` for `ci >= headers.len()`.

**Current Handling:**
```rust
let spans = headers.get(ci).map(|v| v.as_slice()).unwrap_or(&[]);
```

This renders empty cells, which is correct behavior for ragged tables.

**Assessment:** No fix needed; current handling is correct.

#### 4.2.3 Add Debug Logging

**Purpose:** Diagnose width calculation issues during development and testing.

**Implementation:**
```rust
fn render_table_tablebuilder(
    &self,
    ui: &mut egui::Ui,
    headers: &[Vec<InlineSpan>],
    rows: &[Vec<Vec<InlineSpan>>],
) {
    // ... existing code ...

    let mut column_specs = derive_column_specs(&ctx);

    // DEBUG: Log column specs
    if cfg!(debug_assertions) {
        eprintln!("Table {} column specs:", table_id);
        for (i, spec) in column_specs.iter().enumerate() {
            eprintln!("  [{}] {}: {:?}", i, spec.ident, spec.policy);
        }
    }

    let row_max = rows.iter().map(|r| r.len()).max().unwrap_or(0);
    let target_cols = column_specs.len().max(row_max).max(1);

    // DEBUG: Log if padding needed
    if cfg!(debug_assertions) && column_specs.len() < target_cols {
        eprintln!("  Padding from {} to {} columns", column_specs.len(), target_cols);
    }

    // ... rest of function ...
}
```

**Rationale:**
- Only active in debug builds (no performance impact in release)
- Helps diagnose column policy assignments
- Reveals when padding occurs

### 4.3 Detailed Solution: Cell Divider Rendering

#### 4.3.1 Architecture

**Approach:** Manual post-render painting using egui::Painter

**Steps:**
1. During cell rendering, track rectangle positions
2. After table completes, paint divider lines
3. Use specific coordinate ranges (not `Rangef::EVERYTHING`)

**Data Structure:**
```rust
#[derive(Debug, Clone)]
struct TableRenderMetadata {
    cell_rects: Vec<Vec<egui::Rect>>,  // [row_idx][col_idx] -> Rect
    table_rect: egui::Rect,              // Overall table bounds
}
```

#### 4.3.2 Implementation Plan

**Step 1: Track Cell Rectangles**

Modify `render_overhauled_cell` to return the rendered rectangle:

```rust
fn render_overhauled_cell(
    &self,
    ui: &mut egui::Ui,
    spans: &[InlineSpan],
    width: f32,
    is_header: bool,
    row_idx: Option<usize>,
    col_idx: usize,
) -> (f32, egui::Rect) {  // âœ“ Return (height, rect)
    let response = ui.allocate_ui_with_layout(
        Vec2::new(width, 0.0),
        egui::Layout::top_down(egui::Align::LEFT),
        |ui| {
            // ... existing rendering logic ...
        },
    );

    let height = response.response.rect.height().max(fallback_height);
    let rect = response.response.rect;

    (height, rect)
}
```

**Step 2: Collect Rectangles During Rendering**

```rust
fn render_table_tablebuilder(
    &self,
    ui: &mut egui::Ui,
    headers: &[Vec<InlineSpan>],
    rows: &[Vec<Vec<InlineSpan>>],
) {
    // ... existing setup ...

    let mut cell_rects: Vec<Vec<egui::Rect>> = Vec::new();
    let mut header_rects: Vec<egui::Rect> = Vec::new();

    let table_response = table
        .header(HEADER_HEIGHT, |mut header| {
            for ci in 0..column_specs.len() {
                header.col(|ui| {
                    let width = ui.available_width().max(1.0);
                    let spans = headers.get(ci).map(|v| v.as_slice()).unwrap_or(&[]);
                    let (_height, rect) = self.render_overhauled_cell(ui, spans, width, true, None, ci);
                    header_rects.push(rect);
                });
            }
        })
        .body(|body| {
            body.heterogeneous_rows(row_heights.into_iter(), |mut row| {
                let idx = row.index();
                let row_cells = rows.get(idx);
                let mut row_rects: Vec<egui::Rect> = Vec::new();

                for ci in 0..column_specs.len() {
                    row.col(|ui| {
                        let width = ui.available_width().max(1.0);
                        let spans = row_cells
                            .and_then(|cells| cells.get(ci))
                            .map(|cell| cell.as_slice())
                            .unwrap_or(&[]);
                        let (height, rect) = self.render_overhauled_cell(ui, spans, width, false, Some(idx), ci);
                        row_rects.push(rect);
                        self.update_row_height(table_id, idx, height);
                    });
                }

                cell_rects.push(row_rects);
            });
        });

    // Step 3: Paint dividers (see next section)
    self.paint_table_dividers(ui, &header_rects, &cell_rects, table_response.response.rect);
}
```

**Step 3: Paint Dividers**

```rust
fn paint_table_dividers(
    &self,
    ui: &mut egui::Ui,
    header_rects: &[egui::Rect],
    cell_rects: &[Vec<egui::Rect>],
    table_rect: egui::Rect,
) {
    let painter = ui.painter();
    let divider_color = Color32::from_rgb(60, 60, 60);
    let divider_stroke = Stroke::new(1.0, divider_color);

    // Paint outer border
    painter.rect_stroke(table_rect, 0.0, divider_stroke);

    // Paint horizontal divider after header
    if !header_rects.is_empty() {
        let header_bottom = header_rects.iter()
            .map(|r| r.bottom())
            .max_by(|a, b| a.partial_cmp(b).unwrap())
            .unwrap_or(table_rect.top());
        painter.hline(
            table_rect.left()..=table_rect.right(),
            header_bottom,
            divider_stroke,
        );
    }

    // Paint horizontal dividers between rows
    for row_rects in cell_rects {
        if row_rects.is_empty() {
            continue;
        }
        let row_bottom = row_rects.iter()
            .map(|r| r.bottom())
            .max_by(|a, b| a.partial_cmp(b).unwrap())
            .unwrap_or(0.0);
        painter.hline(
            table_rect.left()..=table_rect.right(),
            row_bottom,
            divider_stroke,
        );
    }

    // Paint vertical dividers between columns
    if let Some(first_row) = cell_rects.first() {
        for (ci, _) in first_row.iter().enumerate() {
            if ci == 0 {
                continue;  // No divider before first column
            }

            // Find the left edge of column ci across all rows
            let x_positions: Vec<f32> = std::iter::once(header_rects.get(ci).map(|r| r.left()))
                .chain(cell_rects.iter().map(|row| row.get(ci).map(|r| r.left())))
                .flatten()
                .collect();

            if let Some(&x) = x_positions.first() {
                painter.vline(
                    x,
                    table_rect.top()..=table_rect.bottom(),
                    divider_stroke,
                );
            }
        }
    }
}
```

#### 4.3.3 Alternative: Simpler Grid-Based Dividers

For the **legacy path** (`render_table_legacy`), we can use a simpler approach:

```rust
fn render_table_legacy(
    &self,
    ui: &mut egui::Ui,
    headers: &[Vec<InlineSpan>],
    rows: &[Vec<Vec<InlineSpan>>],
    widths: &[f32],
) {
    let frame_rect = egui::Frame::none()
        .stroke(Stroke::new(1.0, Color32::from_rgb(60, 60, 60)))
        .show(ui, |ui| {
            egui::Grid::new("md_table")
                .striped(true)
                .spacing(egui::vec2(0.0, 0.0))  // âœ“ Remove spacing for clean dividers
                .show(ui, |ui| {
                    // ... existing cell rendering ...
                });
        });

    // Post-render: paint cell dividers manually
    // (Similar to paint_table_dividers above, but using Grid's implicit layout)
}
```

**Challenge:** Grid doesn't expose cell rectangles, making manual divider painting difficult.

**Recommendation:** Focus divider implementation on the **TableBuilder path** only, as that's the future direction.

---

## 5. Implementation Plan

### 5.1 Phase 1: Column Width Fix (Priority 1)

**Estimated Effort:** 4-6 hours

**Tasks:**
1. âœ… **Fix padding column policy** (30 min)
   - Change `ColumnPolicy::Remainder` to `ColumnPolicy::Resizable` in padding loop
   - File: `src/markdown_renderer.rs`, lines 3332-3339

2. âœ… **Add debug logging** (30 min)
   - Log column specs in `render_table_tablebuilder`
   - Log width resolution in `resolve_table_widths`
   - Conditional compilation: `cfg!(debug_assertions)`

3. âœ… **Write unit test for padding logic** (1 hour)
   - Test case: 4-header table with 5-cell row
   - Verify only one remainder column
   - File: `src/markdown_renderer.rs` (tests module)

4. âœ… **Integration test with threat-model table** (1 hour)
   - Load `examples/regressions/table-threat-model.md`
   - Verify Examples column gets remainder space
   - Visual inspection in debug build

5. âœ… **Code review and cleanup** (1 hour)
   - Remove dead code
   - Update comments
   - Run `cargo fmt` and `cargo clippy`

### 5.2 Phase 2: Cell Divider Implementation (Priority 2)

**Estimated Effort:** 8-12 hours

**Tasks:**
1. âœ… **Modify render_overhauled_cell return type** (1 hour)
   - Return `(f32, egui::Rect)` instead of just `f32`
   - Update all call sites
   - File: `src/markdown_renderer.rs`

2. âœ… **Track cell rectangles during rendering** (2 hours)
   - Collect header_rects and cell_rects
   - Store in local variables during table render

3. âœ… **Implement paint_table_dividers** (3 hours)
   - Paint outer border
   - Paint horizontal dividers (header separator, row separators)
   - Paint vertical dividers (column separators)
   - Handle edge cases (empty rows, ragged tables)

4. âœ… **Add configuration option** (1 hour)
   - Add `table_cell_dividers_enabled: bool` to config
   - Default: `true`
   - Allow users to disable if preferred

5. âœ… **Testing and refinement** (3 hours)
   - Test with various table layouts
   - Verify divider alignment
   - Check for performance impact
   - Visual regression testing

### 5.3 Phase 3: Testing and Validation (Priority 1)

**Estimated Effort:** 4-6 hours

**Tasks:**
1. âœ… **Create comprehensive test suite** (2 hours)
   - Test cases: equal columns, unequal content, emoji, many columns
   - Ragged tables (varying cell counts per row)
   - Single cell tables, empty tables
   - File: `src/markdown_renderer.rs` and `tests/` directory

2. âœ… **Performance profiling** (1 hour)
   - Benchmark large tables (100+ rows)
   - Compare legacy vs TableBuilder paths
   - Ensure divider painting doesn't degrade performance

3. âœ… **Visual regression testing** (2 hours)
   - Capture screenshots of known-good tables
   - Compare after implementation
   - Document expected appearance

4. âœ… **Documentation** (1 hour)
   - Update CLAUDE.md with new implementation details
   - Document configuration options
   - Add comments to complex sections

---

## 6. Testing Strategy

### 6.1 Unit Tests

**Test: Padding Column Policy**
```rust
#[test]
fn padding_columns_use_resizable_not_remainder() {
    let headers = vec![vec![span("A")], vec![span("B")]];
    let rows = vec![vec![
        vec![span("1")],
        vec![span("2")],
        vec![span("3")],  // Extra cell beyond headers
    ]];

    let stats = compute_column_stats(&headers, &rows, 32);
    let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);
    let mut specs = derive_column_specs(&ctx);

    // Simulate padding logic
    let target_cols = 3;
    while specs.len() < target_cols {
        specs.push(ColumnSpec::new(
            format!("Column {}", specs.len() + 1),
            ColumnPolicy::Resizable {
                min: 14.0 * 7.0,
                preferred: 14.0 * 9.5,
                clip: false,
            },
            None,
        ));
    }

    // Count remainder columns
    let remainder_count = specs.iter()
        .filter(|spec| matches!(spec.policy, ColumnPolicy::Remainder { .. }))
        .count();

    assert_eq!(remainder_count, 1, "Should have exactly one remainder column");
}
```

**Test: Width Resolution**
```rust
#[test]
fn resolve_widths_handles_one_remainder() {
    let mins = vec![50.0, 50.0, 50.0, 50.0];
    let desired = vec![80.0, 80.0, 100.0, 200.0];  // Last is remainder candidate
    let available = 500.0;

    let widths = MarkdownRenderer::resolve_table_widths(available, &mins, &desired);

    assert_eq!(widths.len(), 4);
    assert!(widths.iter().sum::<f32>() <= available + 0.5);
    assert!(widths[3] >= desired[3], "Remainder column should get desired width");
}
```

### 6.2 Integration Tests

**Test: Threat Model Table**
```markdown
<!-- File: tests/fixtures/table-threat-model.md -->
| Element          | Symbol        | Description                          | Examples                                            |
|------------------|---------------|--------------------------------------|-----------------------------------------------------|
| External Entity  | Rectangle     | Things outside your control          | Users, external systems, web sites                  |
| Process          | Circle        | Running code                         | Services, applications, functions                   |
| Data Flow        | Arrow         | Information movement                 | API calls, network traffic                          |
| Data Store       | Parallel lines| Data at rest                         | Databases, files, caches                            |
```

**Test Code:**
```rust
#[test]
fn threat_model_table_renders_correctly() {
    let md = std::fs::read_to_string("tests/fixtures/table-threat-model.md").unwrap();
    let renderer = MarkdownRenderer::new(FontSizes::default());

    // Parse and render (would need egui test harness)
    // Verify:
    // 1. 4 columns derived
    // 2. Examples column has Remainder policy
    // 3. Description column has Resizable policy
}
```

### 6.3 Visual Test Cases

**Test Case 1: Equal Columns**
```markdown
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |
```
Expected: Auto-sized columns, equal width

**Test Case 2: Unequal Content**
```markdown
| Short | This is a much longer header | X |
|-------|------------------------------|---|
| A     | Content here                 | Y |
```
Expected: Middle column wider, X column narrow

**Test Case 3: Emoji and Unicode**
```markdown
| Symbol | Description |
|--------|-------------|
| ðŸš€     | Rocket      |
| ä¸­æ–‡   | Chinese     |
```
Expected: Proper grapheme-aware sizing

**Test Case 4: Many Columns**
```markdown
| A | B | C | D | E | F | G | H |
|---|---|---|---|---|---|---|---|
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
```
Expected: All columns visible, dividers aligned

**Test Case 5: Ragged Table**
```markdown
| A | B |
|---|---|
| 1 | 2 | 3 | 4 |
```
Expected: 4 columns rendered (2 from headers, 2 padding), no crash

---

## 7. Risk Assessment

### 7.1 Risks and Mitigations

| Risk | Probability | Impact | Mitigation |
|------|------------|---------|------------|
| **Breaking existing tables** | Medium | High | Comprehensive test suite, visual regression testing |
| **Performance degradation** | Low | Medium | Profile before/after, use efficient painter calls |
| **Divider misalignment** | Medium | Medium | Careful rectangle tracking, extensive testing |
| **Regression in legacy path** | Low | Medium | Keep legacy path unchanged, focus on TableBuilder |
| **Off-by-one bugs in new code** | Medium | High | Debug logging, boundary testing, code review |

### 7.2 Rollback Strategy

**If Critical Bug Found:**
1. Add feature flag: `table_column_fixes_enabled: bool` (default `false`)
2. Gate all changes behind flag
3. Allow users to opt-in via config
4. Investigate and fix issues before enabling by default

**Configuration:**
```rust
pub struct AppConfig {
    table_column_fixes_enabled: bool,  // Default: true after testing
    table_cell_dividers_enabled: bool, // Default: true after testing
}
```

---

## 8. Success Criteria

### 8.1 Functional Requirements

âœ… **Column Width Fix:**
- [ ] Examples column receives full remainder space
- [ ] Description column has appropriate resizable width
- [ ] No more than one remainder column per table
- [ ] Padding columns use Resizable policy
- [ ] All columns visible without overflow

âœ… **Cell Dividers:**
- [ ] Outer table border renders correctly
- [ ] Horizontal dividers between rows
- [ ] Vertical dividers between columns
- [ ] Dividers align with cell boundaries
- [ ] No text overwriting

### 8.2 Non-Functional Requirements

âœ… **Performance:**
- [ ] No measurable performance degradation on 100-row tables
- [ ] Divider painting completes in < 1ms per table

âœ… **Compatibility:**
- [ ] Legacy Grid path continues to work
- [ ] Existing markdown files render correctly
- [ ] No breaking changes to public API

âœ… **Code Quality:**
- [ ] Zero compiler warnings
- [ ] `cargo clippy` passes with no warnings
- [ ] `cargo fmt` applied
- [ ] All tests pass
- [ ] Code review completed

---

## 9. Future Enhancements

### 9.1 Short-Term (Next Release)

- **GFM Alignment Rendering:** Respect left/center/right alignment from delimiter row
- **Column Resize Persistence:** Save user-adjusted column widths per table
- **Divider Styling Options:** Configurable divider color, width, style (solid/dashed)

### 9.2 Long-Term (Future Releases)

- **Interactive Column Resizing:** Drag column dividers to resize
- **Sort by Column:** Click headers to sort table rows
- **CSV Export:** Export table data to CSV format
- **Wait for egui Native Support:** When egui adds native cell dividers, migrate to that

---

## 10. Appendix

### 10.1 Code Locations

| Component | File | Lines |
|-----------|------|-------|
| TableBuilder render | `src/markdown_renderer.rs` | 3318-3382 |
| Legacy Grid render | `src/markdown_renderer.rs` | 3268-3316 |
| Width resolution | `src/markdown_renderer.rs` | 3586-3635 |
| Column classification | `src/table_support/column_spec.rs` | 270-335 |
| Column stats | `src/table_support/column_spec.rs` | 378-447 |
| derive_column_specs | `src/table_support/column_spec.rs` | 190-233 |

### 10.2 Related Issues

- **egui #4783:** Table cell dividers (not implemented)
- **egui #4158:** Vertical column separators (not implemented)

### 10.3 References

- **Research Document:** 2025.11.14 - RSR - Table Rendering Research.md
- **GFM Specification:** https://github.github.com/gfm/
- **egui TableBuilder:** https://docs.rs/egui_extras/latest/egui_extras/struct.TableBuilder.html
- **CSS Table Layout:** https://www.w3.org/TR/CSS2/tables.html

---

**End of High-Level Design**

# HLD: Data URI Image Support

**Date:** 2026-02-14
**Status:** Draft
**Author:** Claude (pair with Arthur)

## Problem Statement

Markdown documents can embed images inline using data URIs:

```markdown
![alt text](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAB...)
```

This is common in:
- Exported notebooks (Jupyter, Observable)
- Auto-generated documentation (rustdoc, Doxygen)
- Self-contained markdown files that need to work without external assets
- Copy-pasted content from web sources

mdmdview currently **recognizes** data URIs in `resolve_image_path()` (line 5604) but never
decodes them. The `data:` prefix causes the path to pass through unchanged, then falls to the
`File` branch in `get_or_load_image_texture()` where `path.exists()` fails on the URI string.
The image silently shows as a placeholder.

## Scope

**In scope:**
- Decode `data:image/<format>;base64,<payload>` URIs for all formats already supported by the
  `image` crate (PNG, JPEG, GIF, BMP, ICO, WebP) and SVG via `usvg`/`resvg`
- Apply the same size/pixel limits as disk-loaded images (`MAX_IMAGE_SIDE`, `MAX_IMAGE_PIXELS`,
  `MAX_IMAGE_BYTES` in `image_decode.rs`)
- Texture caching keyed on a content hash (not the raw URI — see Cache Key Strategy below)
- Proper error handling with placeholder display on decode failure

**Out of scope:**
- Non-base64 data URIs (e.g., `data:image/svg+xml,...` with raw URL-encoded SVG) — rare in
  markdown, can be added later
- Editing/round-tripping data URIs in Write mode (they pass through as-is, which is correct)
- Data URIs for non-image content (audio, video, application/*)

## Current Architecture

### Image Loading Pipeline

```
Markdown source
    │
    ▼
pulldown-cmark parser → InlineSpan::Image { src, alt, title }
    │
    ▼
render_inline_span() [line 2930]
    │
    ├── resolve_image_path(src)         → canonical path/URL string
    │       │
    │       ├── http:// or https://     → pass through (remote)
    │       ├── data:                   → pass through (★ current dead end)
    │       ├── absolute path           → pass through
    │       └── relative path           → join with base_dir
    │
    └── get_or_load_image_texture(ui, resolved)
            │
            ├── Cache hit?              → return cached texture
            ├── Pending?                → return None (loading)
            ├── Recent failure?         → return None (backoff)
            │
            └── Determine ImageLoadSource:
                ├── embedded_image_bytes() match → Embedded(&'static [u8])
                ├── is_remote                    → Remote(String)
                └── else                         → File(PathBuf)  ← data: lands here, fails
                        │
                        ▼
                enqueue_image_job(request)
                        │
                        ▼
                spawn_image_loader thread
                        │
                        ├── Embedded  → bytes_to_color_image_guess(bytes)
                        ├── File      → fs::read(path) → bytes_to_color_image_guess(bytes)
                        └── Remote    → ureq::get(url) → bytes_to_color_image_guess(bytes)
                                │
                                ▼
                        ImageLoadResult::Loaded { image, size, ... }
                                │
                                ▼
                        poll_image_results() → store_image_texture()
```

### Key Types

```rust
enum ImageLoadSource {
    Embedded(&'static [u8]),    // Compile-time embedded assets
    File(PathBuf),              // Disk files
    Remote(String),             // HTTP/HTTPS URLs
}

struct ImageLoadRequest {
    key: String,                // Cache key (resolved path/URL)
    source: ImageLoadSource,
}

enum ImageLoadResult {
    Loaded { key, image: ColorImage, size: [u32; 2], modified: Option<SystemTime> },
    Failed { key },
}
```

### Existing Limits (image_decode.rs)

| Constant           | Value      | Purpose                              |
|--------------------|------------|--------------------------------------|
| `MAX_IMAGE_SIDE`   | 4096 px    | Max width or height                  |
| `MAX_IMAGE_PIXELS` | 16.7 Mpx   | Max total pixel count (4096²)        |
| `MAX_IMAGE_BYTES`  | 64 MB      | Max raw file/buffer size             |

### Dependencies

The `base64` crate (v0.22.1) is already a **transitive dependency** via `syntect`, `ureq`, and
`usvg`. Adding it as a direct dependency introduces zero new code to compile.

## Proposed Design

### Approach: Synchronous Decode (No Worker Thread)

Data URI payloads are already in memory — there is no I/O to perform. The base64 decode and
image decode are pure computation. Sending the work to the image loader thread would add
unnecessary complexity (ownership of the `Vec<u8>` payload, a new `ImageLoadSource` variant)
for zero benefit.

**Decision:** Decode data URIs synchronously in `get_or_load_image_texture()`, bypassing the
async loading pipeline entirely. This matches how egui handles immediate-mode rendering — the
data is available now, so produce the texture now.

### Data URI Format

Per [RFC 2397](https://datatracker.ietf.org/doc/html/rfc2397):

```
data:[<mediatype>][;base64],<data>
```

We support the subset relevant to markdown images:

```
data:image/<subtype>;base64,<base64-encoded-bytes>
```

Where `<subtype>` can be `png`, `jpeg`, `gif`, `bmp`, `x-icon`, `webp`, `svg+xml`, etc. We
do **not** need to inspect the MIME type — `bytes_to_color_image_guess()` already uses magic
bytes to detect the format. The MIME type is informational only.

### Cache Key Strategy

**Problem:** The `ImageCache` stores keys as `String` in both a `HashMap` and a `VecDeque`
(for LRU ordering). `touch()` clones the key again. A 1 MB data URI would cost ~2-3 MB of
heap memory *just for the key*, and the cache's `total_bytes` eviction logic only counts
texture pixel memory (`w * h * 4`) — key bytes are invisible to it.

**Solution:** Use a short content hash as the cache key instead of the raw URI string.

```rust
fn data_uri_cache_key(uri: &str) -> String {
    use std::hash::{Hash, Hasher};
    let mut hasher = std::collections::hash_map::DefaultHasher::new();
    uri.hash(&mut hasher);
    format!("data-uri:{:016x}", hasher.finish())
}
```

This produces a fixed-size 25-character key like `data-uri:a1b2c3d4e5f6g7h8` regardless of
payload size. The tradeoff — hash collisions — is negligible: `DefaultHasher` (SipHash-1-3)
has a collision probability of ~1 in 2⁶⁴ per pair, and we'll never have more than 256 entries.

The full data URI is never stored in the cache. On cache lookup, we hash the URI again and
look up by hash key. Two identical URIs always produce the same hash. Two different URIs with
the same hash would shadow each other — but at 1-in-2⁶⁴ odds, this is theoretical.

### Base64 Whitespace Handling

**Problem:** `base64` 0.22's `STANDARD.decode()` is **strict** — it rejects payloads
containing whitespace (spaces, newlines, tabs). While pulldown-cmark won't introduce line
breaks inside an inline image URL `![](...)`, some markdown generators or copy-paste
operations could produce payloads with embedded whitespace.

**Solution:** Strip ASCII whitespace from the base64 payload before decoding. This is cheap
(single pass over the string) and makes the decoder tolerant of:
- Line-wrapped base64 (common in generated content)
- Trailing whitespace
- Copy-paste artifacts

```rust
let cleaned: String = payload.chars().filter(|c| !c.is_ascii_whitespace()).collect();
```

### Staleness Check

**Problem:** The current staleness logic at line 5637 checks:
```rust
let stale = if embedded.is_some() || is_remote {
    false
} else {
    Self::image_source_stale(entry.modified, path)
};
```

Data URIs are neither `embedded` nor `is_remote`, so they fall through to
`image_source_stale()`, which calls `path.exists()` on `"data:image/..."`. This returns
`false`, and since `modified` is `None`, `cached_modified.is_some()` returns `false` —
so the entry is **correctly** treated as non-stale. But this is accidental and fragile.

**Solution:** Add `is_data_uri` to the explicit non-stale check:

```rust
let is_data_uri = resolved_src.starts_with("data:");
// ...
let stale = if embedded.is_some() || is_remote || is_data_uri {
    false // Embedded, remote, and data URI images don't go stale
} else {
    Self::image_source_stale(entry.modified, path)
};
```

This makes the intent explicit and survives future refactoring of the staleness logic.

### Placeholder Text for Failed Data URIs

**Problem:** When an image fails to load and has no alt text, the placeholder at line 2982
renders `src.as_str()` as the label:

```rust
let label = if alt.is_empty() {
    src.as_str()   // ← for a 1 MB data URI, this is 1 MB of text
} else {
    alt.as_str()
};
ui.label(RichText::new(format!("{}\n{}", label, msg))...);
```

For a failed data URI with no alt text, egui would attempt to layout and render potentially
megabytes of base64 text. This could freeze the UI.

**Solution:** In the placeholder rendering code (`render_inline_span`, `InlineSpan::Image`
branch, line ~2982), truncate data URI `src` values:

```rust
let label = if alt.is_empty() {
    if src.starts_with("data:") {
        // Don't render megabytes of base64 as placeholder text
        "Embedded image (data URI)"
    } else {
        src.as_str()
    }
} else {
    alt.as_str()
};
```

This also produces a better user experience — `"Embedded image (data URI)"` is more
informative than a wall of `iVBORw0KGgo...`.

### Changes

#### 1. Add `base64` as a Direct Dependency

**File:** `Cargo.toml`

```toml
base64 = "0.22"
```

Already compiled as a transitive dep — this just makes the import explicit.

#### 2. Add Data URI Parsing Helper

**File:** `src/markdown_renderer.rs`

Add a standalone function (not a method) near the other image helpers:

```rust
/// Parse a `data:image/...;base64,...` URI and return the decoded bytes.
/// Returns `None` for non-base64 data URIs, non-image MIME types, or
/// decode failures.
fn decode_data_uri(uri: &str) -> Option<Vec<u8>> {
    // Must start with "data:"
    let rest = uri.strip_prefix("data:")?;

    // Find the comma separating metadata from payload
    let comma_pos = rest.find(',')?;
    let metadata = &rest[..comma_pos];
    let payload = &rest[comma_pos + 1..];

    // Must be base64-encoded (we don't support raw/percent-encoded data URIs)
    if !metadata.contains(";base64") {
        return None;
    }

    // Must be an image type (defense in depth — we only render images)
    let mime = metadata.split(';').next().unwrap_or("");
    if !mime.starts_with("image/") {
        return None;
    }

    // Reject empty payload early
    if payload.is_empty() {
        return None;
    }

    // Strip ASCII whitespace before decoding — base64 0.22 STANDARD engine
    // is strict and rejects embedded newlines/spaces. Some generators wrap
    // long base64 payloads across lines.
    let cleaned: String = payload
        .chars()
        .filter(|c| !c.is_ascii_whitespace())
        .collect();

    // Decode base64
    use base64::Engine;
    base64::engine::general_purpose::STANDARD
        .decode(&cleaned)
        .ok()
}
```

**Design choices:**
- Returns `Option<Vec<u8>>` — callers handle the None case as a failed image
- MIME type checked as defense-in-depth but not used for format detection (magic bytes are
  authoritative)
- Empty payload rejected before attempting decode
- Whitespace stripped before decode — `STANDARD.decode()` is strict about this
- No size limit on the base64 string here — the existing `MAX_IMAGE_BYTES` check in
  `bytes_to_color_image_guess()` / `raster_bytes_to_color_image_with_bg()` handles that after
  decode

#### 3. Modify `get_or_load_image_texture()`

**File:** `src/markdown_renderer.rs`, function `get_or_load_image_texture`

Add a new branch for data URIs **before** the existing `File` fallback. The data URI branch
decodes synchronously and stores the result in the texture cache immediately.

Current flow after cache miss / no pending / retry allowed:

```rust
let source = if let Some(bytes) = embedded {
    ImageLoadSource::Embedded(bytes)
} else if is_remote {
    ImageLoadSource::Remote(resolved_src.to_string())
} else {
    if !path.exists() {
        self.note_image_failure(resolved_src);
        return None;
    }
    ImageLoadSource::File(path.to_path_buf())
};
// ... enqueue_image_job ...
```

New flow — note that `resolved_src` is replaced by `cache_key` for all cache operations
when dealing with data URIs:

```rust
let is_data_uri = resolved_src.starts_with("data:");

// For data URIs, use a short hash as the cache key to avoid storing
// megabyte-sized strings in the HashMap and VecDeque.
let cache_key = if is_data_uri {
    data_uri_cache_key(resolved_src)
} else {
    resolved_src.to_string()
};
```

The staleness check (earlier in the function) gains `is_data_uri`:

```rust
let stale = if embedded.is_some() || is_remote || is_data_uri {
    false // Embedded, remote, and data URI images don't go stale
} else {
    Self::image_source_stale(entry.modified, path)
};
```

And the source-selection block:

```rust
let source = if let Some(bytes) = embedded {
    ImageLoadSource::Embedded(bytes)
} else if is_data_uri {
    // Data URIs are decoded synchronously — no I/O needed
    if let Some(bytes) = decode_data_uri(resolved_src) {
        match image_decode::bytes_to_color_image_guess(&bytes, None) {
            Some((image, w, h)) => {
                let texture = ui.ctx().load_texture(
                    format!("img:{cache_key}"),
                    image,
                    egui::TextureOptions::LINEAR,
                );
                self.store_image_texture(&cache_key, texture.clone(), [w, h], None);
                return Some((texture, w, h));
            }
            None => {
                self.note_image_failure(&cache_key);
                return None;
            }
        }
    } else {
        self.note_image_failure(&cache_key);
        return None;
    }
} else if is_remote {
    ImageLoadSource::Remote(resolved_src.to_string())
} else {
    if !path.exists() {
        self.note_image_failure(&cache_key);
        return None;
    }
    ImageLoadSource::File(path.to_path_buf())
};
```

**Complete line-by-line change map for `get_or_load_image_texture`:**

Every reference to `resolved_src` in cache/failure/pending operations must consistently use
`cache_key` instead. For non-data-URIs, `cache_key == resolved_src.to_string()`, so
behaviour is unchanged. For data URIs, `cache_key` is the 25-char hash.

| Line  | Current code                                    | New code                                     | Why                                  |
|-------|-------------------------------------------------|----------------------------------------------|--------------------------------------|
| 5621  | `_ui: &egui::Ui`                               | `ui: &egui::Ui`                             | Now used for `ui.ctx().load_texture` |
| 5624+ | (after `is_remote`)                             | Add `let is_data_uri = ...` and `let cache_key = ...` | Compute early, before any lookups    |
| 5636  | `cache.get(resolved_src)`                       | `cache.get(&cache_key)`                      | Lookup by hash for data URIs         |
| 5637  | `if embedded.is_some() \|\| is_remote`          | `if embedded.is_some() \|\| is_remote \|\| is_data_uri` | Explicit non-stale                   |
| 5645  | `cache.remove(resolved_src)`                    | `cache.remove(&cache_key)`                   | Remove by hash for data URIs         |
| 5649  | `image_pending...contains(resolved_src)`        | `image_pending...contains(cache_key.as_str())` | Consistent key (data URIs never pending, but safety) |
| 5653  | `should_retry_image(resolved_src)`              | `should_retry_image(&cache_key)`             | Failure backoff keyed by hash        |
| 5657+ | (source selection)                              | Add `is_data_uri` branch before `is_remote`  | Synchronous decode path              |
| 5663  | `note_image_failure(resolved_src)` (File path)  | `note_image_failure(&cache_key)`             | Consistent (same value for files)    |
| 5670  | `key: resolved_src.to_string()` (async request) | Unchanged — data URIs never reach here       | Async path unaffected                |
| 5676  | `insert(resolved_src.to_string())` (pending)    | Unchanged — data URIs never reach here       | Async path unaffected                |

**Key invariant:** `cache_key` is the *only* key used for `image_textures`, `image_failures`,
and `image_pending` lookups/inserts. `resolved_src` is only used for:
- Detecting `is_remote` and `is_data_uri` (prefix checks)
- Looking up `embedded_image_bytes()` (static asset match)
- Creating `Path::new()` for disk images
- Passing to `decode_data_uri()` (reads the actual payload)

**Note on `render_inline_span` (line 2974):** The placeholder code checks
`image_pending.borrow().contains(&resolved)` where `resolved` is the raw URI. For data URIs,
`image_pending` is never populated (synchronous path), so this check harmlessly returns
`false`. No change needed here.

#### 4. Update `resolve_image_path()` Comment

**File:** `src/markdown_renderer.rs`, line 5605

Change:
```rust
// Keep as-is; we don't fetch remote or parse data URIs yet
```
To:
```rust
// Keep as-is; remote URLs and data URIs don't need path resolution
```

#### 5. Remove the `_ui` Prefix on the `ui` Parameter

Currently `get_or_load_image_texture` has `_ui: &egui::Ui` because it doesn't use `ui`
directly. With data URI support, we call `ui.ctx().load_texture(...)`, so the underscore
prefix should be removed. (Avoids a compiler warning.)

### Caching Behavior

| Aspect              | Data URI images                              | Disk images              |
|---------------------|----------------------------------------------|--------------------------|
| Cache key           | `data-uri:<64-bit hash>` (25 chars)          | Resolved file path       |
| Staleness check     | Never stale (explicit `is_data_uri` guard)   | Checks file mtime        |
| Failure backoff     | Yes (same `image_failures` LRU cache)         | Yes                      |
| Memory impact       | Texture only (decoded bytes + URI are dropped)| Texture only             |
| GPU release on min. | Yes (existing `release_gpu_textures()`)       | Yes                      |
| Rebuild on restore  | Re-decode from URI (synchronous)              | Re-read from disk        |

**Key difference from disk/remote images:** The cache key is a content hash, not the raw
string. This prevents multi-megabyte data URI strings from bloating the `ImageCache`'s
`HashMap<String, _>` and `VecDeque<String>`. The raw URI is only held on the stack during
decode, then dropped.

### Size and Safety Limits

Data URI images pass through the same safety pipeline as all other images:

1. **Base64 decode** — `base64::decode()` returns `Err` for malformed input
2. **Raw byte size** — `MAX_IMAGE_BYTES` (64 MB) checked in `raster_bytes_to_color_image_with_bg()`
3. **Dimension check** — `raster_exceeds_limits()` enforces `MAX_IMAGE_SIDE` (4096) and
   `MAX_IMAGE_PIXELS` (16.7M)
4. **Format detection** — `image::load_from_memory()` or SVG parser rejects unrecognized data
5. **MIME filter** — `decode_data_uri()` requires `image/*` MIME type

Worst case memory: a 64 MB base64 payload decodes to ~48 MB of raw bytes, which could produce
a 4096×4096 RGBA texture (~67 MB GPU). This matches the existing worst case for disk images.

### Edge Cases

| Case                                        | Behavior                                  |
|---------------------------------------------|-------------------------------------------|
| `data:image/png;base64,` (empty payload)    | `decode_data_uri` returns `None` → placeholder |
| `data:image/png,<raw bytes>` (no base64)    | `decode_data_uri` returns `None` → placeholder |
| `data:text/plain;base64,...` (non-image)     | `decode_data_uri` returns `None` → placeholder |
| `data:image/svg+xml;base64,...`              | Decodes → `bytes_to_color_image_guess` SVG path |
| Invalid base64 characters                   | `base64::decode` returns `Err` → placeholder |
| Valid base64, invalid image bytes            | `bytes_to_color_image_guess` returns `None` → placeholder |
| Enormous payload (>64 MB decoded)            | `MAX_IMAGE_BYTES` rejects → placeholder   |
| Oversized dimensions (>4096 on either side)  | `raster_exceeds_limits` rejects → placeholder |
| Same data URI appears twice in document      | Second hit served from texture cache      |
| Data URI after F5 reload                     | Cache still valid (no staleness for data URIs) |
| Data URI after file edit + reload            | New parse produces new URI → fresh decode |
| Data URI in table cell                       | Works — same `render_inline_span` path    |
| Data URI with `\n` or whitespace in base64   | Whitespace stripped before decode; transparent to caller |
| Window minimize + restore                    | Texture released, re-decoded synchronously on next render |

### Performance Considerations

| Scenario                    | Impact                                    |
|-----------------------------|-------------------------------------------|
| First render of data URI    | Synchronous decode blocks the UI frame. A 1 MB PNG decodes in ~5-10 ms — imperceptible. |
| Large data URI (10+ MB)     | Could cause a brief frame skip (~50-100 ms). Acceptable — this is a one-time cost per image per session. |
| Many data URIs (10+)        | First frame may stutter if all decode simultaneously. Mitigated by egui's lazy layout — only visible images decode. |
| Subsequent renders          | Texture cache hit — zero overhead.        |
| Document with 100+ data URIs| Unusual but possible (notebooks). Memory bounded by `MAX_IMAGE_SIDE`/`MAX_IMAGE_PIXELS` per image. Cache LRU eviction prevents unbounded growth. |

**Alternative considered:** Offloading data URI decode to the worker thread via a new
`ImageLoadSource::DataUri(String)` variant. Rejected because:
- Adds a new enum variant and ownership complexity (the payload must be cloned into the String)
- Adds one frame of latency (enqueue → poll) for zero I/O benefit
- The decode is fast enough to run synchronously
- Keeps the change minimal and localized

## Files Changed

| File                              | Change                                         |
|-----------------------------------|-------------------------------------------------|
| `Cargo.toml`                     | Add `base64 = "0.22"` to `[dependencies]`      |
| `src/markdown_renderer.rs`       | Add `decode_data_uri()` function                |
| `src/markdown_renderer.rs`       | Add `data_uri_cache_key()` function             |
| `src/markdown_renderer.rs`       | Refactor `get_or_load_image_texture()` — see line-by-line table above |
| `src/markdown_renderer.rs`       | Truncate data URI `src` in placeholder text (line ~2982) |
| `src/markdown_renderer.rs`       | Update comment in `resolve_image_path()`        |
| `src/markdown_renderer.rs`       | Add unit tests (see below)                      |

No changes to `image_decode.rs`, `app.rs`, `main.rs`, or any other file.

## Test Plan

### Unit Tests for `decode_data_uri()`

| Test                                        | Input                                           | Expected            |
|---------------------------------------------|------------------------------------------------|---------------------|
| Valid PNG data URI                           | `data:image/png;base64,<valid png base64>`     | `Some(bytes)`       |
| Valid JPEG data URI                          | `data:image/jpeg;base64,<valid jpeg base64>`   | `Some(bytes)`       |
| Valid SVG data URI                           | `data:image/svg+xml;base64,<valid svg base64>` | `Some(bytes)`       |
| Empty payload                               | `data:image/png;base64,`                       | `None`              |
| Missing base64 marker                       | `data:image/png,<raw>`                         | `None`              |
| Non-image MIME                              | `data:text/plain;base64,AAAA`                  | `None`              |
| Invalid base64                              | `data:image/png;base64,!!!`                    | `None`              |
| Not a data URI                              | `https://example.com/img.png`                  | `None`              |
| Missing comma                               | `data:image/png;base64`                        | `None`              |
| No MIME type at all                         | `data:;base64,AAAA`                            | `None`              |
| Charset parameter present                   | `data:image/png;charset=utf-8;base64,<valid>`  | `Some(bytes)`       |
| Whitespace in payload                       | `data:image/png;base64,<valid with \n>`        | `Some(bytes)` (whitespace stripped) |
| Tabs and spaces in payload                  | `data:image/png;base64,<valid with \t and spaces>` | `Some(bytes)` |

### Unit Tests for `data_uri_cache_key()`

| Test                                        | Scenario                                        | Assertion                    |
|---------------------------------------------|------------------------------------------------|------------------------------|
| Deterministic                               | Same URI twice                                 | Same key returned            |
| Different URIs differ                       | Two different URIs                             | Different keys returned      |
| Starts with prefix                          | Any URI                                        | Key starts with `data-uri:`  |
| Fixed length                                | 1 KB URI vs 1 MB URI                          | Both keys are 25 chars       |

### Integration Tests for Texture Loading

| Test                                        | Scenario                                        | Assertion                    |
|---------------------------------------------|------------------------------------------------|------------------------------|
| Data URI produces texture                   | Small valid PNG as data URI                    | `get_or_load_image_texture` returns `Some` |
| Invalid data URI returns None               | Garbage base64 payload                         | Returns `None`, failure cache keyed by hash |
| Cached on second call                       | Call twice with same data URI                  | Second call is cache hit (via hash key) |
| Non-image MIME rejected                     | `data:text/html;base64,...`                    | Returns `None`               |
| Data URI not stale                          | Insert, then check staleness                   | `is_data_uri` guard returns non-stale |

### Unit Tests for Placeholder Text

| Test                                        | Scenario                                        | Assertion                    |
|---------------------------------------------|------------------------------------------------|------------------------------|
| Data URI placeholder truncated              | Failed data URI, no alt text                   | Placeholder shows "Embedded image (data URI)", not raw base64 |
| Data URI placeholder uses alt text           | Failed data URI, with alt text                 | Placeholder shows alt text   |
| File path placeholder unchanged             | Failed file image, no alt text                 | Placeholder shows file path (existing behaviour) |

### Existing Test Updates

| Test                                         | Required Change                                |
|----------------------------------------------|------------------------------------------------|
| `test_resolve_image_path_data_uri_and_remote_texture_reject` | Rename / update: data URIs no longer "reject" — they decode. Test that a valid data URI produces a texture. |

### Manual Testing

1. Open a markdown file containing a base64-encoded PNG image → verify it renders
2. Open a markdown file with an invalid data URI → verify placeholder appears
3. Zoom in/out → verify data URI images scale correctly
4. F5 reload → verify data URI images persist
5. Minimize and restore → verify images rebuild

## Risk Assessment

| Risk                                         | Likelihood | Impact | Mitigation                      |
|----------------------------------------------|------------|--------|---------------------------------|
| Large data URI blocks UI frame               | Low        | Low    | Existing size limits cap decode time; single-pass only |
| base64 crate version mismatch with transitive deps | None | None   | Already using 0.22 transitively |
| Cache key hash collision                     | Negligible | Low    | SipHash collision at 1-in-2⁶⁴; worst case = one image shadows another |
| Malformed data URI causes panic              | None       | None   | All decode paths return `Option`/`Result` |
| Whitespace in base64 payload                 | Low        | None   | Stripped before decode           |
| Placeholder renders raw data URI text         | Medium     | High   | Truncated to "Embedded image (data URI)" — see Placeholder section |

## Implementation Sequence

1. Add `base64` dependency to `Cargo.toml`
2. Add `decode_data_uri()` with unit tests — verify all edge cases pass (including whitespace)
3. Add `data_uri_cache_key()` with unit tests — verify determinism and fixed length
4. Refactor `get_or_load_image_texture()` per line-by-line table:
   a. Rename `_ui` → `ui`
   b. Compute `is_data_uri` and `cache_key` early
   c. Replace all `resolved_src` cache/failure/pending references with `&cache_key`
   d. Add `is_data_uri` to staleness guard
   e. Add data URI decode branch (synchronous, using `cache_key`)
5. Fix placeholder text in `render_inline_span` — truncate data URI `src` display
6. Update comment in `resolve_image_path()`
7. Update existing test `test_resolve_image_path_data_uri_and_remote_texture_reject`
8. Add integration tests for texture loading via data URI
9. Build debug + release, run full test suite
10. Manual verification with a test markdown file containing data URI images

# Implementation Plan: Light/Dark Mode Toggle

**Date:** 2026-02-09
**Design:** HLD V3 (`wrk_docs/2026.02.09 - HLD - Light Dark Mode Toggle V3.md`)

## Guiding Principles

- **TDD**: Write tests first, then implement to make them pass.
- **Each stage compiles and passes all tests** — no broken intermediate states.
- **Commit after each stage** — atomic, reviewable units of work.
- **Dark mode stays default** — every stage should look identical to today until Stage 5 wires up the toggle.

---

## Stage 1: ThemeColors Foundation

**Files:** `src/theme.rs` (NEW), `src/lib.rs`
**Goal:** Create the color palette module. Nothing uses it yet — zero visual change.

### Steps

1. **Create `src/theme.rs`** with:
   - File-level doc comment
   - `ThemeColors` struct (19 `pub` Color32 fields)
   - `const DARK` — exact current hardcoded values from HLD Section 5
   - `const LIGHT` — new light palette from HLD Section 5
   - `fn current(dark_mode: bool) -> &'static Self`
   - `fn syntect_theme(dark_mode: bool) -> &'static str`
   - `fn apply_dark_mode_visuals(ctx: &egui::Context, dark: bool)` — visuals helper

2. **Tests** (in `theme.rs`):
   - `test_current_returns_dark` — `current(true)` returns `&DARK`
   - `test_current_returns_light` — `current(false)` returns `&LIGHT`
   - `test_dark_palette_matches_hardcoded` — spot-check key DARK values match current code
   - `test_light_palette_differs` — LIGHT link color != DARK link color
   - `test_syntect_theme_dark` — returns `"base16-ocean.dark"`
   - `test_syntect_theme_light` — returns `"InspiredGitHub"`

3. **Register in `src/lib.rs`**:
   - `pub mod theme;`
   - `pub use theme::{ThemeColors, apply_dark_mode_visuals};`

### Validation
```
cargo test theme
cargo build
```

### Commit
`feat: add ThemeColors palette for light/dark mode support`

---

## Stage 2: Settings Persistence

**Files:** `src/window_state.rs`
**Goal:** AppSettings can store and round-trip `dark_mode`. Zero visual change.

### Steps

1. **Tests first** (add to existing test section in `window_state.rs`):
   - `test_dark_mode_default_is_true` — `AppSettings::default().dark_mode == true`
   - `test_settings_round_trip_dark_mode_true` — save `dark_mode=true`, load, verify
   - `test_settings_round_trip_dark_mode_false` — save `dark_mode=false`, load, verify
   - `test_settings_missing_dark_mode_defaults_true` — file with only `allow_remote_images=0`, dark_mode should be true
   - `test_settings_dark_mode_zero_is_false` — file with `dark_mode=0`, verify false

2. **Implement**:
   - Add `pub dark_mode: bool` to `AppSettings` struct
   - Replace `#[derive(Default)]` with manual `Default` impl (`dark_mode: true`)
   - `load_app_settings()`: add `if key.trim() == "dark_mode"` branch
   - `save_app_settings()`: add `writeln!(f, "dark_mode={}", settings.dark_mode as u8)`
   - `load_app_settings_registry()`: add `let dark_mode: u32 = key.get_value("DarkMode").unwrap_or(1);`
   - `save_app_settings_registry()`: add `key.set_value("DarkMode", &(settings.dark_mode as u32))`

3. **Fix existing test `AppSettings` constructors** — add `dark_mode: true` to every `AppSettings { ... }` literal in the file (~6 sites at lines 852, 872, 888, 915, etc.)

### Validation
```
cargo test window_state
cargo build
```

### Commit
`feat: add dark_mode field to AppSettings with persistence`

---

## Stage 3: Renderer Theme Colors

**Files:** `src/markdown_renderer.rs`
**Goal:** Renderer uses ThemeColors. dark_mode defaults true, so all colors identical — zero visual change.

### Steps

1. **Add field + setter** to `MarkdownRenderer`:
   - `dark_mode: bool` field (default `true` in `new()`)
   - `pub fn set_dark_mode(&mut self, dark: bool)` setter

2. **Tests first**:
   - `test_set_dark_mode` — verify setter changes field
   - `test_highlight_code_light_theme` — create renderer, `set_dark_mode(false)`, parse code block, verify highlight tokens differ from dark theme

3. **Replace color sites** (use `let tc = ThemeColors::current(ui.visuals().dark_mode);`):

   | Site | Lines | Replace with |
   |------|-------|-------------|
   | External link color | ~743, ~2905 | `tc.link` |
   | Internal link color | ~745, ~2907 | `tc.link_internal` |
   | Inline code bg/fg | ~872-879, ~2844-2852 | `tc.inline_code_bg`, `tc.inline_code_fg` |
   | Blockquote bg | ~2643 | `tc.blockquote_bg` |
   | Blockquote border | ~2647 | `tc.blockquote_border` |
   | Blockquote text | ~2658 | `tc.blockquote_text` |
   | Blockquote bar | ~2669 | `tc.blockquote_bar` |
   | Code block bg | ~2972, ~3902 | `tc.code_bg` |
   | Code block border | ~2973, ~3903 | `tc.code_border` |
   | Code label | ~2964, ~3911 | `tc.code_label` |
   | Code fallback text | ~3972 | `tc.code_fallback_text` |

4. **Switch syntect theme** (line ~5778):
   ```rust
   let theme = &self.theme_set.themes[ThemeColors::syntect_theme(self.dark_mode)];
   ```

5. **Add `use crate::ThemeColors;`** at top of file.

### Validation
```
cargo test markdown_renderer
cargo build
```

### Commit
`refactor: replace hardcoded colors with ThemeColors in markdown renderer`

---

## Stage 4: Mermaid Renderer Theme Colors

**Files:** `src/mermaid_renderer.rs`
**Goal:** Mermaid error/info boxes use ThemeColors. Zero visual change (dark defaults).

### Steps

1. **Add `use crate::ThemeColors;`**

2. **Replace 6 box patterns** at lines ~769, ~795, ~822, ~897, ~962, ~988:
   - Each: `let tc = ThemeColors::current(ui.visuals().dark_mode);`
   - `.fill(tc.box_bg)`, `.stroke(Stroke::new(1.0, tc.box_border))`
   - Title: `.color(tc.box_title)`, body: `.color(tc.box_body)`

### Validation
```
cargo test mermaid
cargo build
```

### Commit
`refactor: replace hardcoded colors with ThemeColors in mermaid renderer`

---

## Stage 5: App Integration — The Toggle

**Files:** `src/app.rs`, `src/main.rs`
**Goal:** Wire everything together. This is the stage where the feature becomes functional.

### Sub-steps

#### 5a. Replace `allow_remote_images` field with `settings: AppSettings`

1. Replace field declaration (line ~397): `allow_remote_images: bool` → `settings: AppSettings`
2. Update `new()` (line ~628): `allow_remote_images: settings.allow_remote_images` → `settings,`
3. Update `set_allow_remote_images` call (line ~637): `settings.allow_remote_images` → `app.settings.allow_remote_images` (already loaded)
4. Update all `self.allow_remote_images` → `self.settings.allow_remote_images` (8 references: lines ~397, ~628, ~637, ~1883, ~1894, ~1896, ~1899, and test ~7156)
5. Update `save_app_settings` calls (lines ~1883, ~1899): `AppSettings { allow_remote_images: self.allow_remote_images }` → `&self.settings`
6. **Build + test** after this sub-step — should be a pure refactor, no behavior change.

#### 5b. Add theme toggle infrastructure

1. Add `theme_toggle_requested: bool` field to struct, init `false`
2. Change `render_status_bar(&self, ctx)` → `render_status_bar(&mut self, ctx)` (line ~2115)
3. Add `apply_saved_theme()` method:
   ```rust
   pub fn apply_saved_theme(&self, ctx: &egui::Context) {
       apply_dark_mode_visuals(ctx, self.settings.dark_mode);
   }
   ```
4. Add `toggle_theme()` method (from HLD 4.7)
5. Add deferred handling in `update()` (after existing deferred actions, ~line 2464):
   ```rust
   if self.theme_toggle_requested {
       self.theme_toggle_requested = false;
       self.toggle_theme(ctx);
   }
   ```
6. Add `use crate::{apply_dark_mode_visuals, ...}` import

#### 5c. Add status bar button

In `render_status_bar()`, right-to-left section (first item = rightmost):
```rust
let tc = ThemeColors::current(self.settings.dark_mode);
let label = if self.settings.dark_mode { "Dark" } else { "Light" };
if ui.small_button(label).clicked() {
    self.theme_toggle_requested = true;
}
ui.separator();
```

Also replace status bar accent colors:
- Loading indicator (line ~2131) → `tc.status_loading`
- Queue count (line ~2140) → `tc.status_queue`
- Hint text (line ~2145) → `tc.status_hint`

#### 5d. Add keyboard shortcut

In `handle_shortcuts()`, add `Ctrl+Shift+T`:
```rust
if input.consume_shortcut(&egui::KeyboardShortcut::new(
    egui::Modifiers::CTRL | egui::Modifiers::SHIFT, egui::Key::T
)) {
    self.theme_toggle_requested = true;
}
```

#### 5e. Startup theme in main.rs

After `MarkdownViewerApp::new()` (line ~340):
```rust
if resolved_theme.is_none() {
    app.apply_saved_theme(&cc.egui_ctx);
}
```

#### 5f. Tests

- `test_toggle_theme` — verify settings.dark_mode flips
- `test_ctrl_shift_t_shortcut` — simulate key combo, verify toggle fires

### Validation
```
cargo test app
cargo test
cargo build
```

### Commit
`feat: add light/dark mode toggle with status bar button and Ctrl+Shift+T`

---

## Stage 6: Final Verification & Polish

**Goal:** Release build, visual testing, version bump.

### Steps

1. **Release build**:
   ```
   cargo build --release
   cargo clippy
   ```

2. **Manual visual testing**:
   - Launch app → verify dark mode (default)
   - Click "Dark" button → verify switch to light
   - Check: links, code blocks, blockquotes, inline code, syntax highlighting
   - Click "Light" button → verify switch back to dark
   - Verify: identical to original (no regression)
   - Press `Ctrl+Shift+T` → verify toggle works
   - Restart app → verify light mode persists
   - Open file with mermaid → verify error boxes themed
   - `mdscreensnap` both themes for comparison

3. **Version bump**: Minor increment in `Cargo.toml`

4. **LOC check**: `mdkloc`

### Commit
`chore: bump version for light/dark mode feature`

---

## Summary

| Stage | Files | Tests | Visual Change |
|-------|-------|-------|---------------|
| 1. ThemeColors | theme.rs, lib.rs | 6 new | None |
| 2. Settings | window_state.rs | 5 new | None |
| 3. Renderer colors | markdown_renderer.rs | 2 new | None |
| 4. Mermaid colors | mermaid_renderer.rs | 0 | None |
| 5. App toggle | app.rs, main.rs | 2 new | **Feature goes live** |
| 6. Verification | Cargo.toml | 0 | Polish |

**Total: 6 stages, 6 commits, ~15 new tests**

Key invariant: **Dark mode looks identical to today at every stage**. Light mode only becomes reachable when Stage 5 adds the toggle.

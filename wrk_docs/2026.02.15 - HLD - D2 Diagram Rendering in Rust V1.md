# HLD: D2 Diagram Rendering in Rust

**Date**: 2026-02-15
**Status**: Draft
**Author**: Claude (with Arthur)

## 1. Goal

Add native D2 diagram rendering to mdmdview as an embedded Rust implementation — no external binaries, no WASM blobs, single-binary distribution preserved. D2 code blocks in markdown (` ```d2 `) are parsed, laid out, and rendered to textures inline, matching the existing Mermaid and Pikchr pipelines.

## 2. Background and Motivation

mdmdview already renders two diagram languages:
- **Pikchr**: C library compiled at build time, manual positioning, tiny footprint
- **Mermaid**: JavaScript executed via embedded QuickJS, broad ecosystem

D2 fills a gap: **automatic layout of software architecture diagrams** with a clean, modern syntax. Its killer feature over Pikchr (manual positioning) and Mermaid (often ugly defaults) is that it produces professional hierarchical layouts automatically.

The reference D2 implementation is written in Go (~2M bytes of source, ~50-80K lines). No Rust port exists. A full reimplementation is infeasible; instead, we implement a **useful subset** using a hybrid approach:
- LLM-assisted translation where Go→Rust maps cleanly (parser)
- Design extraction and idiomatic Rust reimplementation where it doesn't (graph IR, layout)
- Differential testing against the Go `d2` CLI as the correctness oracle

## 3. Scope

### 3.1 In Scope (v1 Subset)

The v1 subset targets **~80% of real-world D2 usage** — architecture diagrams, flow charts, simple hierarchies. Features are classified by the D2 language specification:

#### Core Syntax (Must Have)
| Feature | D2 Syntax | Notes |
|---------|-----------|-------|
| Shape declarations | `server` | Default shape is rectangle |
| Explicit labels | `server: "My Server"` | Colon-separated |
| Connections | `a -> b`, `a -- b`, `a <-> b`, `a <- b` | All four arrow types |
| Connection labels | `a -> b: "sends data"` | Label on edge |
| Connection chaining | `a -> b -> c -> d` | Multiple edges in one statement |
| Containers | `group: { a; b }` or `group.a`, `group.b` | Nested shapes |
| Container labels | `group: "My Group" { ... }` | |
| Shape types | `x.shape: circle` | ~20 types (see §3.1.1) |
| Comments | `# line comment` | Single-line only for v1 |
| Semicolons | `a; b; c` | Statement separator |
| Quoted strings | `'literal'`, `"interpolatable"` | Both quote styles |

#### Shape Types (v1)
| Shape | Priority | Notes |
|-------|----------|-------|
| `rectangle` | Must have | Default |
| `square` | Must have | 1:1 aspect ratio |
| `circle` | Must have | |
| `oval` | Must have | |
| `diamond` | Must have | Decision nodes |
| `hexagon` | Must have | |
| `cylinder` | Must have | Database icon |
| `cloud` | Must have | External service |
| `person` | Nice to have | Stick figure |
| `package` | Nice to have | UML package |
| `queue` | Nice to have | Message queue |
| `page` | Nice to have | Document |
| `parallelogram` | Nice to have | I/O |
| `document` | Nice to have | |
| `step` | Nice to have | Process step |
| `callout` | Nice to have | |
| `stored_data` | Nice to have | |
| `text` | Must have | Label-only, no border |
| `code` | Nice to have | Monospace text block |

#### Styles (Must Have)
| Property | D2 Syntax | Notes |
|----------|-----------|-------|
| Fill color | `x.style.fill: "#ff0000"` | Hex colors |
| Stroke color | `x.style.stroke: blue` | Named + hex |
| Stroke width | `x.style.stroke-width: 3` | Pixels |
| Font size | `x.style.font-size: 16` | |
| Font color | `x.style.font-color: white` | |
| Bold/italic | `x.style.bold: true` | |
| Border radius | `x.style.border-radius: 8` | Rounded corners |
| Opacity | `x.style.opacity: 0.5` | |
| Multiple instances | `x.style.multiple: true` | Stacked shape effect |
| Shadow | `x.style.shadow: true` | Drop shadow |
| 3D effect | `x.style.3d: true` | Raised appearance |
| Stroke dash | `x.style.stroke-dash: 5` | Dashed lines |

#### Connection Styles
| Feature | D2 Syntax | Notes |
|---------|-----------|-------|
| Arrowhead types | `x -> y: { source-arrowhead: ... }` | See §3.1.2 |
| Animated edges | `(x -> y).style.animated: true` | Dash animation |
| Edge stroke | `(x -> y).style.stroke: red` | |
| Edge references | `(x -> y)[0].style.stroke: red` | Index-based |

#### Arrowhead Types (v1)
`arrow` (default), `triangle`, `diamond`, `circle`, `cf-one`, `cf-many`, `cf-one-required`, `cf-many-required`, `none`

#### Layout Directives
| Feature | D2 Syntax | Notes |
|---------|-----------|-------|
| Direction | `direction: right` | `up`, `down`, `left`, `right` |
| Near (shape proximity) | `x.near: y` | Layout hint |
| Width/height | `x.width: 200` | Explicit dimensions |

#### Reserved Keywords
`label`, `shape`, `icon`, `tooltip`, `link`, `near`, `width`, `height`, `direction`, `top`, `left`, `style`, `source-arrowhead`, `target-arrowhead`, `class`, `classes`, `vars`, `constraint`, `grid-rows`, `grid-columns`, `grid-gap`, `vertical-gap`, `horizontal-gap`

### 3.1.1 Explicitly Out of Scope (v1)

These features are deferred to future versions:

| Feature | Reason |
|---------|--------|
| Variables (`vars: { ... }`, `${var}`) | Adds compiler complexity |
| Globs (`*.style.fill: red`, `**`) | Pattern matching engine needed |
| Imports (`@filename`) | File resolution, cycle detection |
| Layers, scenarios, steps | Board composition system |
| Sequence diagrams (`shape: sequence_diagram`) | Entirely different layout algorithm |
| Grid diagrams (`grid-rows`, `grid-columns`) | Separate layout system |
| SQL tables (`shape: sql_table`) | Custom rendering |
| UML classes (`shape: class`) | Custom rendering with fields/methods |
| Block strings (`|...|`) | Parser complexity |
| Markdown in labels | Recursive rendering |
| LaTeX in labels | External dependency |
| Icons (`icon: ...`) | URL/asset resolution |
| Tooltips, links | Interactive features (SVG-only in D2) |
| Filters (`&shape`, `!&shape`) | IR complexity |
| Null/deletion (`x: null`) | Map merging semantics |
| Spread operator (`...@file`) | Import-dependent |
| Themes | Styling system |
| Multiple boards | Composition system |

### 3.2 Integration with mdmdview

D2 renders identically to Mermaid and Pikchr:
1. Markdown parser encounters ` ```d2 ` code block
2. D2 source text extracted
3. `mdmdview_d2::render_d2_to_svg(source)` called across crate boundary → returns SVG string
4. SVG rasterized via `usvg`/`resvg` (existing infrastructure, in main crate)
5. Raster image cached as egui texture (existing `LruCache`, in main crate)
6. Displayed inline in rendered markdown view

The crate boundary is clean: the D2 crate knows nothing about egui, textures, or caching. It takes a `&str` and returns an SVG `String`. All UI integration stays in the main crate's `markdown_renderer.rs`.

## 4. Architecture

### 4.1 High-Level Pipeline

```
D2 source text (from markdown code block)
    │
    ▼
┌─────────────────────────────────┐
│  Phase 1: PARSER                │
│  d2_parser::parse()             │
│  Input: &str                    │
│  Output: D2Ast (syntax tree)    │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  Phase 2: COMPILER              │
│  d2_compiler::compile()         │
│  Input: D2Ast                   │
│  Output: D2Graph                │
│  - Resolves reserved keywords   │
│  - Builds object hierarchy      │
│  - Creates edge objects         │
│  - Validates styles             │
│  - Sets default shapes          │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  Phase 3: TEXT MEASUREMENT      │
│  Compute node dimensions from   │
│  label text + shape type +      │
│  padding + user overrides       │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  Phase 4: LAYOUT                │
│  d2_layout::layout()            │
│  Input: D2Graph with dimensions │
│  Output: Positioned graph       │
│  - Sugiyama hierarchical layout │
│  - Node positioning             │
│  - Edge routing                 │
│  - Container fitting            │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  Phase 5: SVG RENDERING         │
│  d2_svg::render()               │
│  Input: Positioned D2Graph      │
│  Output: SVG string             │
│  - Shape drawing                │
│  - Edge paths (cubic Bezier)    │
│  - Labels                       │
│  - Arrowheads                   │
│  - Container backgrounds        │
└─────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────┐
│  Existing mdmdview pipeline     │
│  usvg parse → resvg render →   │
│  egui texture                   │
└─────────────────────────────────┘
```

### 4.2 Workspace and Crate Structure

D2 lives in a **separate crate** within a Cargo workspace. This provides:
- **Isolation**: D2 changes don't recompile all of mdmdview
- **Fast test cycles**: `cargo test -p mdmdview-d2` runs in seconds, not 8 minutes
- **Clean API boundary**: mdmdview calls one function across the crate boundary
- **Easy to discard**: Remove the workspace member if the experiment fails
- **Dependency isolation**: `petgraph` and `rust-sugiyama` only pulled in when the `d2` feature is enabled

Existing Pikchr and Mermaid renderers stay as modules in the main crate — they're small, stable, and coupled to mdmdview's texture/caching internals. D2 is different: large, experimental, with its own dependency tree.

```
mdmdview/                           # workspace root
├── Cargo.toml                      # [workspace] members = [".", "crates/d2"]
├── src/                            # existing mdmdview code (unchanged)
│   ├── main.rs
│   ├── app.rs
│   ├── markdown_renderer.rs        # calls mdmdview_d2::render_d2_to_svg()
│   ├── pikchr_renderer.rs          # stays here — small, stable
│   └── ...
└── crates/
    └── d2/                         # new crate: mdmdview-d2
        ├── Cargo.toml              # [dependencies] petgraph, rust-sugiyama
        └── src/
            ├── lib.rs              # Public API (see §4.2.1)
            ├── ast.rs              # AST node types
            ├── parser.rs           # Recursive-descent parser
            ├── compiler.rs         # AST → D2Graph compilation
            ├── graph.rs            # D2Graph, D2Object, D2Edge, Style, Attributes
            ├── layout.rs           # Sugiyama layout orchestration
            ├── layout_sugiyama.rs  # Sugiyama algorithm implementation
            ├── edge_routing.rs     # Edge path computation and curve generation
            ├── svg_render.rs       # SVG output generation
            ├── shapes.rs           # Shape definitions and path generators
            ├── geo.rs              # Geometry primitives (Point, Box, etc.)
            └── keywords.rs         # Reserved keyword definitions
```

#### 4.2.1 Crate Public API

The `mdmdview-d2` crate exposes a minimal public interface:

```rust
// crates/d2/src/lib.rs

/// Full pipeline: D2 source text → SVG string.
/// This is the primary entry point for mdmdview integration.
pub fn render_d2_to_svg(source: &str) -> Result<String, D2Error>;

/// Individual pipeline phases, exposed for testing and debugging.
pub fn parse(source: &str) -> Result<D2Map, ParseError>;
pub fn compile(ast: &D2Map) -> Result<D2Graph, CompileError>;
pub fn layout(graph: &mut D2Graph) -> Result<(), LayoutError>;
pub fn render_svg(graph: &D2Graph) -> String;
```

#### 4.2.2 Workspace Cargo.toml Configuration

Root `Cargo.toml`:
```toml
[workspace]
members = [".", "crates/d2"]

# Shared settings for all workspace members
[workspace.package]
edition = "2021"
```

Main crate `Cargo.toml` (additions):
```toml
[features]
d2 = ["dep:mdmdview-d2"]

[dependencies]
mdmdview-d2 = { path = "crates/d2", optional = true }
```

D2 crate `crates/d2/Cargo.toml`:
```toml
[package]
name = "mdmdview-d2"
version = "0.1.0"
edition.workspace = true

[dependencies]
petgraph = "0.8"
rust-sugiyama = "0.4"
anyhow = "1"
```

### 4.3 Key Data Structures

#### 4.3.1 AST (Phase 1 Output)

Mirrors D2's Go AST closely, adapted for Rust idioms:

```rust
/// Top-level map containing all declarations
pub struct D2Map {
    pub nodes: Vec<MapNode>,
    pub range: Range,
}

/// A node within a map
pub enum MapNode {
    Comment(Comment),
    Key(Key),
}

/// A key declaration (shape, edge, or property assignment)
pub struct Key {
    pub key: KeyPath,           // dotted path: "a.b.c"
    pub edges: Vec<Edge>,       // connection chain
    pub edge_index: Option<EdgeIndex>,  // (a -> b)[0]
    pub edge_key: Option<KeyPath>,      // property on edge reference
    pub primary: Option<ScalarValue>,   // label value
    pub value: Option<Value>,           // map, array, or scalar
    pub range: Range,
}

/// Dotted key path: "server.style.fill"
pub struct KeyPath {
    pub segments: Vec<StringValue>,
}

/// An edge between two keys
pub struct Edge {
    pub src: KeyPath,
    pub dst: KeyPath,
    pub src_arrow: bool,    // <-
    pub dst_arrow: bool,    // ->
    pub range: Range,
}

/// Values that can appear on the right side of ':'
pub enum Value {
    Scalar(ScalarValue),
    Map(D2Map),
    Array(Vec<Value>),
}

pub enum ScalarValue {
    Unquoted(String),
    SingleQuoted(String),
    DoubleQuoted(String),
    Number(f64),
    Boolean(bool),
    Null,
}

/// Source position tracking
pub struct Range {
    pub start: Position,
    pub end: Position,
}

pub struct Position {
    pub line: usize,    // 0-indexed
    pub column: usize,  // 0-indexed, byte offset
}
```

#### 4.3.2 Graph IR (Phase 2 Output)

Index-based arena design using petgraph as the backbone:

```rust
use petgraph::stable_graph::{StableDiGraph, NodeIndex, EdgeIndex};

/// The complete diagram graph
pub struct D2Graph {
    /// petgraph backing store
    pub graph: StableDiGraph<D2Object, D2EdgeData>,

    /// Root object (implicit top-level container)
    pub root: NodeIndex,

    /// All objects in tree order (for iteration)
    pub objects: Vec<NodeIndex>,

    /// All edges (connection order)
    pub edges: Vec<EdgeIndex>,

    /// Layout direction
    pub direction: Direction,
}

/// A shape/container in the diagram
pub struct D2Object {
    pub id: String,                 // fully qualified: "group.server"
    pub label: String,              // display text
    pub shape: ShapeType,           // rectangle, circle, etc.
    pub style: Style,               // visual properties
    pub attributes: Attributes,     // icon, tooltip, link, etc.

    // Hierarchy
    pub parent: Option<NodeIndex>,
    pub children: Vec<NodeIndex>,

    // Geometry (populated during layout)
    pub box_: Option<Rect>,         // position + size
    pub label_dimensions: Option<(f64, f64)>,  // measured text size
}

/// An edge/connection
pub struct D2EdgeData {
    pub src: NodeIndex,
    pub dst: NodeIndex,
    pub label: Option<String>,
    pub src_arrow: ArrowheadType,
    pub dst_arrow: ArrowheadType,
    pub style: Style,

    // Geometry (populated during layout)
    pub route: Vec<Point>,          // waypoints after routing
}

pub enum ShapeType {
    Rectangle, Square, Circle, Oval, Diamond, Hexagon,
    Cylinder, Cloud, Person, Package, Queue, Page,
    Parallelogram, Document, Step, Callout, StoredData,
    Text, Code,
}

pub struct Style {
    pub fill: Option<Color>,
    pub stroke: Option<Color>,
    pub stroke_width: Option<f64>,
    pub stroke_dash: Option<f64>,
    pub font_size: Option<f64>,
    pub font_color: Option<Color>,
    pub bold: bool,
    pub italic: bool,
    pub underline: bool,
    pub border_radius: Option<f64>,
    pub opacity: Option<f64>,
    pub shadow: bool,
    pub three_d: bool,
    pub multiple: bool,
    pub animated: bool,
    pub double_border: bool,
}

pub enum Direction {
    Down,   // TB - default
    Up,     // BT
    Right,  // LR
    Left,   // RL
}

pub enum ArrowheadType {
    Arrow,      // default ->
    Triangle,
    Diamond,
    FilledDiamond,
    Circle,
    FilledCircle,
    CfOne,
    CfMany,
    CfOneRequired,
    CfManyRequired,
    None,
}

/// Color representation
pub enum Color {
    Hex(u8, u8, u8),           // #rrggbb
    Named(String),             // "red", "blue", etc.
    HexAlpha(u8, u8, u8, u8), // #rrggbbaa
}
```

#### 4.3.3 Geometry Primitives

```rust
#[derive(Clone, Copy, Debug)]
pub struct Point {
    pub x: f64,
    pub y: f64,
}

#[derive(Clone, Copy, Debug)]
pub struct Rect {
    pub x: f64,      // top-left
    pub y: f64,
    pub width: f64,
    pub height: f64,
}
```

### 4.4 Phase Details

#### Phase 1: Parser

**Approach**: Hand-written recursive descent parser in Rust, closely following the structure of D2's Go parser (`d2parser/parse.go`, 1,891 lines).

**Why not a parser generator?** D2's syntax is context-sensitive (unquoted strings behave differently in keys vs values, edge operators are multi-character, and the parser needs multi-error recovery for editor tooling). The Go implementation is hand-written for the same reasons.

**Translation strategy**: The Go parser is the most amenable to LLM-assisted translation. It's mostly pure functions operating on a reader/lookahead buffer. Key mappings:
- Go `io.RuneReader` → Rust `std::str::Chars` with a peekable buffer
- Go `parser` struct → Rust `Parser` struct with identical fields
- Go slice of errors → Rust `Vec<D2Error>`
- Go `d2ast.MapNodeBox` (tagged union via struct) → Rust `enum MapNode`

**Error handling**: The parser collects multiple errors and continues, returning a partial AST. This matches D2 behavior and supports future LSP integration.

**Entry point**:
```rust
pub fn parse(source: &str) -> Result<D2Map, ParseError> {
    let mut parser = Parser::new(source);
    let map = parser.parse_map(true); // true = file-level map
    if parser.errors.is_empty() {
        Ok(map)
    } else {
        Err(ParseError { ast: Some(map), errors: parser.errors })
    }
}
```

#### Phase 2: Compiler

**Approach**: Reimplement from D2's Go design, idiomatic Rust.

The compiler walks the AST and builds the `D2Graph`:
1. **Collect declarations**: Walk all `Key` nodes, build object/edge lists
2. **Resolve hierarchy**: Dotted keys like `group.server` create parent-child relationships
3. **Apply reserved keywords**: `shape`, `label`, `style.*`, `direction`, `width`, `height`, `near`
4. **Validate**: Check shape types, style values, connection endpoints
5. **Set defaults**: Rectangle shape, default colors, etc.

Since v1 excludes variables, globs, imports, and layers, this compiler is significantly simpler than D2's full `d2ir` + `d2compiler` two-phase pipeline. We collapse both into a single pass.

#### Phase 3: Text Measurement

Before layout, each node needs pixel dimensions computed from its label text.

**Approach**: Use a simple heuristic based on character count and font size, similar to how D2 measures text. For v1, we don't need pixel-perfect measurements — the layout just needs reasonable width/height estimates.

```rust
fn measure_label(text: &str, font_size: f64) -> (f64, f64) {
    let char_width = font_size * 0.6;  // approximate monospace width
    let line_height = font_size * 1.4;
    let lines: Vec<&str> = text.lines().collect();
    let max_width = lines.iter()
        .map(|l| l.chars().count() as f64 * char_width)
        .fold(0.0f64, f64::max);
    let height = lines.len() as f64 * line_height;
    (max_width, height)
}
```

Node dimensions = label dimensions + shape padding + user overrides.

#### Phase 4: Layout

**This is the hardest phase.** The design follows three sub-phases:

##### 4a. Sugiyama Node Positioning

**Primary option**: Use `rust-sugiyama` (v0.4.0, Sep 2025, 196 commits).

`rust-sugiyama` is the most mature Rust Sugiyama implementation:
- Accepts node dimensions via `from_vertices_and_edges(&[(id, (width, height))], &[(src, dst)])`
- Implements cycle removal, rank assignment, crossing reduction (barycenter + weighted median), coordinate assignment (Brandes-Köpf)
- Returns positioned node coordinates per connected component
- Built on petgraph's `StableDiGraph`

**Fallback option**: If `rust-sugiyama` proves insufficient (e.g., for compound graphs), we implement our own Sugiyama on petgraph, using D2's Go dagre wrapper as the specification. The algorithm phases are well-documented:
1. **Cycle removal**: Greedy feedback arc set
2. **Rank assignment**: Network simplex (minimize total edge length)
3. **Ordering**: Barycenter method with iterative sweeps
4. **Coordinate assignment**: Brandes-Köpf four-alignment method

**Container handling**: D2 handles containers by recursively laying out each container's children as a sub-graph, then sizing the container to fit. Cross-container edges are routed after all positions are fixed. We replicate this recursive approach.

##### 4b. Edge Routing

**No existing Rust crate provides edge routing for hierarchical layouts.** Neither `dagre-rs`, `rust-sugiyama`, nor `layout-rs` (adequately) return edge paths. This matches D2's own architecture: even with full dagre.js, D2 writes ~200 lines of custom edge routing.

We implement edge routing from the D2 Go source as design specification:

1. **Straight waypoints**: Connect source center → destination center via rank-aligned waypoints
2. **Box clipping**: Clip edge endpoints to shape boundaries (rectangle intersection, ellipse intersection, etc.)
3. **Curve generation**: Convert waypoints to cubic Bézier curves:
   - First segment: control point at 80% along vector
   - Intermediate: control points at 20%, 50%, 80% positions
   - Produces smooth SVG `C` (curveto) commands
4. **Minimum segment length**: Extend short segments to prevent arrowhead rendering artifacts

```rust
fn route_edge(src: &Rect, dst: &Rect, waypoints: &[Point]) -> Vec<Point> {
    let clipped_start = clip_to_shape(src, waypoints[0], waypoints[1]);
    let clipped_end = clip_to_shape(dst, waypoints.last().unwrap(), waypoints[waypoints.len()-2]);
    // ... generate Bézier control points ...
}
```

##### 4c. Container Fitting

After layout, containers are fitted to their children:
1. Compute bounding box of all children
2. Add padding for container label
3. Check for label/icon overlap
4. Adjust container bounds

#### Phase 5: SVG Rendering

Generate SVG strings from positioned graph. This is straightforward string building:

```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 {w} {h}">
  <!-- Container backgrounds (rendered first, bottom layer) -->
  <rect x="{x}" y="{y}" width="{w}" height="{h}" rx="{r}"
        fill="{fill}" stroke="{stroke}" stroke-width="{sw}" />

  <!-- Edges (middle layer) -->
  <path d="M {x0} {y0} C {cx1} {cy1} {cx2} {cy2} {x1} {y1}"
        stroke="{color}" fill="none" stroke-width="{sw}" />

  <!-- Arrowheads -->
  <marker id="arrow-{id}" ...>
    <polygon points="..." fill="{color}" />
  </marker>

  <!-- Shapes (top layer) -->
  <rect ... />   <!-- rectangle -->
  <ellipse ... /> <!-- circle/oval -->
  <polygon ... /> <!-- diamond/hexagon -->

  <!-- Labels -->
  <text x="{x}" y="{y}" font-size="{fs}" fill="{color}">{label}</text>
</svg>
```

Shape-specific SVG generators are needed for each `ShapeType`. Prioritize rectangle, circle, diamond, cylinder as they cover most usage.

## 5. Implementation Strategy

### 5.1 Translation and Reimplementation Mix

| Component | Approach | Rationale |
|-----------|----------|-----------|
| **Parser** | LLM-assisted translation from Go | Most mechanical, maps cleanly |
| **AST types** | LLM-assisted translation | Direct type mapping |
| **Keywords** | Direct translation | Constants and enums |
| **Compiler** | Reimplementation from Go design | Ownership model differs, simpler for v1 subset |
| **Graph types** | Reimplementation (index-based) | Arena allocation decision drives design |
| **Layout** | Use `rust-sugiyama` + custom edge routing | Reuse existing algorithm work |
| **Edge routing** | Reimplementation from Go design | No existing Rust solution |
| **SVG renderer** | Written from scratch | Simple string building, mdmdview-specific |
| **Shape paths** | Written from scratch | SVG path generation per shape |

### 5.2 Phased Delivery

**Phase 1: Parser + AST** (~3-4 days)
- Implement all AST types
- Hand-written recursive descent parser
- Parse all v1 syntax features
- Unit tests against D2's test corpus (35 parser fixtures)
- Validate: parse → serialize → compare with D2 Go output

**Phase 2: Compiler + Graph** (~3-4 days)
- Implement D2Graph with petgraph backbone
- Single-pass AST → Graph compilation
- Reserved keyword handling
- Style validation
- Unit tests for compilation

**Phase 3: Layout** (~5-7 days)
- Integrate `rust-sugiyama` for node positioning
- Implement container recursive layout
- Implement edge routing with curve generation
- Text measurement heuristics
- This is the riskiest phase — budget extra time

**Phase 4: SVG Rendering** (~2-3 days)
- Shape-specific SVG generators
- Edge path rendering (Bézier curves)
- Arrowhead markers
- Label placement
- Container backgrounds
- Style application (colors, dashes, opacity, etc.)

**Phase 5: Integration + Polish** (~2-3 days)
- Set up workspace: root `Cargo.toml` with `[workspace]`, move nothing — main crate stays in place
- Create `crates/d2/` with its own `Cargo.toml`
- Add `d2` feature flag to main crate (default-enabled like `mermaid-embedded` and `pikchr`)
- Wire `markdown_renderer.rs` to call `mdmdview_d2::render_d2_to_svg()` behind `#[cfg(feature = "d2")]`
- LRU texture caching (reuse existing `LruCache` in main crate)
- Dark mode support (pass as parameter or detect in SVG colors)
- Zoom scaling
- Error display for malformed D2 input

### 5.3 Estimated Total: ~2-3 weeks

## 6. Testing Strategy

### 6.1 Differential Testing (Primary Oracle)

The Go `d2` CLI is the correctness oracle. For every test case:

```
                    ┌──────────┐
  test.d2 ───────►  │ d2 (Go)  │ ───► expected.svg
                    └──────────┘
                    ┌──────────┐
  test.d2 ───────►  │ Rust impl│ ───► actual.svg
                    └──────────┘
                         │
                    ┌──────────┐
                    │ Compare  │
                    └──────────┘
```

**Comparison method**: Rasterize both SVGs via `resvg` → PNG, then pixel-diff with tolerance. We already have the `resvg` pipeline.

Exact pixel matching is too strict (floating-point differences in positions, different SVG attribute ordering). Instead:
- Rasterize at fixed resolution (e.g., 2x scale)
- Compare pixel-by-pixel with tolerance (e.g., allow RGB diff ≤ 5 per channel)
- Report percentage of differing pixels
- Threshold: <2% pixel difference = PASS

### 6.2 Unit Tests

Each phase gets dedicated unit tests:

- **Parser**: Parse D2 snippets → assert AST structure. Harvest fixtures from D2's `testdata/d2parser/TestParse/` (35 golden files)
- **Compiler**: Compile AST → assert graph topology, object attributes, edge connections
- **Layout**: Fixed-input graphs → assert node positions within tolerance
- **SVG**: Render positioned graphs → validate SVG structure (well-formed XML, correct elements)

### 6.3 Test Corpus

Sources for test inputs:
1. **D2's own test fixtures**: `testdata/d2parser/`, `testdata/d2compiler/` (238 fixtures), `e2etests/stable/` (100+ visual regression tests)
2. **D2 documentation examples**: Extracted from d2lang.com tour pages
3. **Real-world D2 files**: Architecture diagrams from open-source projects
4. **Fuzzing**: Property-based tests for parser robustness

### 6.4 Regression Suite

Once the initial implementation passes differential tests, the expected SVGs become golden files for regression testing (no Go CLI dependency needed for CI).

## 7. Dependencies

### mdmdview-d2 Crate Dependencies

| Crate | Version | Purpose | Size Impact |
|-------|---------|---------|-------------|
| `rust-sugiyama` | 0.4.0 | Sugiyama layout algorithm | Small (pure Rust) |
| `petgraph` | 0.8.x | Graph data structure backbone | Indirect dep of rust-sugiyama |
| `anyhow` | 1.x | Error handling | Tiny |

These dependencies are **isolated to the D2 crate**. When the `d2` feature is disabled, they are not compiled or linked into the mdmdview binary.

### Main Crate Additions

| Crate | Version | Purpose |
|-------|---------|---------|
| `mdmdview-d2` | 0.1.0 (path) | D2 rendering (optional, behind `d2` feature flag) |

### Existing Dependencies (Reused by Main Crate)

| Crate | Purpose |
|-------|---------|
| `usvg` / `resvg` / `tiny-skia` | SVG → raster (already used for Pikchr, Mermaid) |

### No New Large Dependencies

No JS runtime, no WASM, no C libraries. The D2 crate is pure Rust. Total new dependency footprint is minimal — `rust-sugiyama` + `petgraph` are small, well-maintained crates.

## 8. Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| `rust-sugiyama` insufficient for compound graphs | Medium | High | Implement our own container-aware layout on petgraph; use D2 Go source as spec |
| Layout output differs significantly from D2 Go | High | Medium | Accept "close enough" rather than pixel-perfect; focus on correct topology |
| Parser edge cases in D2 syntax | Medium | Low | Start with common syntax, add edge cases iteratively guided by test failures |
| Edge routing produces ugly results | Medium | Medium | D2's own edge routing is well-documented in Go source; iterate with visual comparison |
| Performance on large diagrams | Low | Low | Most D2 diagrams are <100 nodes; layout is O(V²) at worst |
| Text measurement inaccuracy | Medium | Low | Heuristic is sufficient for layout; exact rendering done by SVG/resvg |

## 9. Future Expansion (Post-v1)

Rough priority order for features to add after v1 ships:

1. **Variables and substitution** (`vars: { }`, `${var}`) — most requested advanced feature
2. **Classes** (`classes: { }`) — style reuse, common in large diagrams
3. **Icons** (`icon: ...`) — visual richness
4. **Sequence diagrams** — separate layout algorithm, high value
5. **Grid diagrams** — separate layout algorithm
6. **Imports** (`@file`) — composition
7. **Globs** (`*.style.fill: red`) — bulk styling
8. **Layers/scenarios/steps** — board composition
9. **SQL tables / UML classes** — specialized shapes
10. **Block strings** — multi-line text
11. **Themes** — color scheme system

Each expansion can be tested differentially against the Go CLI, using the same oracle approach.

## 10. References

- [D2 GitHub Repository](https://github.com/terrastruct/d2) — Go source code
- [D2 Documentation](https://d2lang.com/) — Language tour and reference
- [D2 Cheat Sheet](https://terrastruct-site-assets.s3.us-west-1.amazonaws.com/documents/d2_cheat_sheet.pdf)
- [D2 DeepWiki Architecture](https://deepwiki.com/terrastruct/d2) — Architecture analysis
- [rust-sugiyama](https://crates.io/crates/rust-sugiyama) — Rust Sugiyama layout
- [dagre-rs](https://github.com/TangleGuard/dagre-rs) — Rust dagre (reference only; too incomplete)
- [layout-rs](https://github.com/nadavrot/layout) — Rust graph layout + SVG (reference)
- [petgraph](https://docs.rs/petgraph/) — Graph data structure library
- [Oxidizer Paper](https://arxiv.org/html/2412.08035) — LLM-based Go→Rust translation
- [dagre.js Wiki](https://github.com/dagrejs/dagre/wiki) — Original dagre algorithm documentation
- [Sugiyama Algorithm](https://en.wikipedia.org/wiki/Layered_graph_drawing) — Layered graph drawing theory

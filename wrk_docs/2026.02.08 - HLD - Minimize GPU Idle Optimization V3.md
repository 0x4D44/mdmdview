# HLD: Minimize GPU Idle Optimization (V3)

**Date:** 2026-02-08
**Status:** Draft
**Author:** Claude (pair with Arthur)
**Revision:** V3 — adds platform reliability analysis, confirms design viability

## Changes from V2

| # | V2 Concern | V3 Resolution |
|---|------------|---------------|
| 1 | Uncertainty about whether `update()` runs during minimize transition | Confirmed: YES on Windows, via `Focused(false)` → `request_redraw()` → `RedrawRequested` |
| 2 | Uncertainty about GPU texture deletion during 0x0 painting | Confirmed: `glDeleteTextures` runs unconditionally (no size check in egui-glow) |
| 3 | Missing platform reliability analysis | Added detailed event flow trace (Section: Platform Reliability) |

## Problem Statement

When mdmdview is minimized with a complex document loaded (e.g., `test_stress.md`), Windows
Task Manager reports **2.6% GPU utilization** despite zero CPU usage and zero frame rendering.
Arthur's other egui apps show **0.1% GPU** when minimized.

## Root Cause

OpenGL driver housekeeping on live texture objects plus GPU P-state elevation. With
`test_stress.md` fully scrolled, mdmdview holds ~30 GPU textures totaling ~37.5 MB:

| Category              | Count  | VRAM       | Notes                          |
|-----------------------|--------|------------|--------------------------------|
| Mermaid diagrams      | 8      | 34.4 MB    | 4.3 MB each (1200x900 RGBA8)  |
| Emoji textures        | ~20    | 320 KB     | 16 KB each (64x64 RGBA8)      |
| Font atlas            | 1      | 2.5 MB     | egui-managed, cannot release   |
| egui UI chrome        | 1      | 150 KB     | egui-managed, cannot release   |
| **Total**             | **~30**| **~37.5 MB** |                             |

A simple egui app has ~3 textures totaling ~2 MB, explaining the 0.1% baseline.

## Proposed Solution

Release application-managed GPU textures when the window transitions to minimized state.
On restore, textures rebuild lazily through the existing rendering pipeline.

### What to Release

| Cache                  | Owner                | Release?  | Rebuild Cost                  |
|------------------------|----------------------|-----------|-------------------------------|
| `mermaid_textures`     | `MermaidRenderer`    | **Yes**   | Fast: rasterize from SVG cache (~10-50ms/diagram) |
| `emoji_textures`       | `MarkdownRenderer`   | **Yes**   | Fast: decode embedded PNGs (~1ms/emoji) |
| `image_textures`       | `MarkdownRenderer`   | **Yes**   | Medium: re-decode from disk/cache |
| `mermaid_svg_cache`    | `MermaidRenderer`    | No        | Retain — needed for fast texture rebuild |
| `mermaid_errors`       | `MermaidRenderer`    | No        | Retain — prevents retry storms |
| Font atlas             | egui                 | No        | Framework-managed, no API to release |

## Platform Reliability Analysis

### Why Minimize Detection Works on Windows

eframe 0.27's event loop (`run.rs:85-210`) processes the `retain()` repaint check (line 185)
**after each individual event**, not just during `AboutToWait`. And `RedrawRequested` (line 94-100)
calls `run_ui_and_paint()` **directly**, bypassing the minimize filter in `retain()`.

On Windows, the minimize message sequence is:

```
WM_KILLFOCUS / WM_ACTIVATE(WA_INACTIVE)  →  Focused(false)
WM_SIZE(SIZE_MINIMIZED)                    →  Resized(0, 0)
WM_PAINT                                   →  RedrawRequested
```

The flow through eframe:

1. **`Focused(false)` arrives** (run.rs:128 → on_event)
   - egui-winit returns `EventResponse { repaint: true }` (egui-winit lib.rs:379-387)
   - glow_integration returns `EventResult::RepaintNext(window_id)` (line 831)
   - run.rs:165 inserts into `windows_next_repaint_times` with `Instant::now()`
   - run.rs:185 `retain()` runs: `window.is_minimized()` → **false** (not yet minimized)
   - run.rs:199 `window.request_redraw()` is called → posts `WM_PAINT`

2. **`Resized(0, 0)` arrives** (glow_integration.rs:764-773)
   - The `0 < width && 0 < height` guard prevents resize, but `repaint_asap` stays false
   - egui-winit still returns `repaint: true` → `RepaintNext`
   - run.rs:185 `retain()` runs: `window.is_minimized()` → **true** (now minimized)
   - run.rs:196-197 repaint discarded (returns false)

3. **`RedrawRequested` arrives** (from `WM_PAINT` posted in step 1)
   - run.rs:94-100 handles this **directly** — calls `run_ui_and_paint()`
   - **No minimize check** — `RedrawRequested` bypasses `retain()`
   - `begin_frame()` reads viewport state: `minimized == Some(true)` (updated in step 2)
   - `update()` runs → our detection fires → `release_gpu_textures()` called
   - Painting runs → `paint_and_update_textures()` processes free list
   - `glDeleteTextures()` executes (painter.rs:639-643) — **no size check**
   - GPU textures freed!

4. **After painting** (glow_integration.rs:720-725)
   - `window.is_minimized() == Some(true)` → 10ms sleep
   - No more repaints scheduled (all future requests discarded by `retain()`)

**Key insight**: The `Focused(false)` event always arrives BEFORE `Resized(0, 0)` on Windows.
When `retain()` runs after `Focused(false)`, the window is not yet minimized, so
`request_redraw()` succeeds. The resulting `RedrawRequested` is handled directly at run.rs:94-100
without a minimize check.

### Other Platforms

On Linux (X11/Wayland) and macOS, the event ordering may differ. The same principle applies:
if ANY event triggers `request_redraw()` before the minimize state is set, a transition frame
fires. If no transition frame fires (e.g., events arrive in a different order), the optimization
simply doesn't activate — behavior is identical to today (no regression).

### GPU Texture Deletion Confirmation

egui-glow's `paint_and_update_textures()` (painter.rs:356-374) runs unconditionally even at
0x0 window size. The `free_texture()` method (painter.rs:639-643) calls `gl.delete_texture()`
without any size check. The minimize handler in glow_integration.rs:720-725 only adds a 10ms
sleep — it does NOT skip painting.

## Detailed Design

### 1. State Tracking in `MarkdownViewerApp`

Add a single field to detect and track texture release state:

```rust
// In MarkdownViewerApp struct (app.rs)
/// Tracks whether GPU textures have been released (e.g., due to minimize).
gpu_textures_released: bool,
```

Initialize to `false` in the constructor.

### 2. Minimize/Restore Detection in `update_impl()`

At the top of `update_impl()`, after the startup frame logic:

```rust
// Detect minimize → release GPU textures
let is_minimized = ctx.input(|i| {
    i.viewport().minimized.unwrap_or(false)
});

if is_minimized && !self.gpu_textures_released && self.screenshot.is_none() {
    self.renderer.release_gpu_textures();
    self.gpu_textures_released = true;
}

if !is_minimized && self.gpu_textures_released {
    self.gpu_textures_released = false;
    ctx.request_repaint(); // Ensure full re-render to rebuild textures
}
```

**Design choice: `gpu_textures_released` vs `was_minimized`**

Using `gpu_textures_released` tracks the actual state we care about (whether textures need
rebuilding), not a proxy. If textures are released for any reason, the restore path always fires.

### 3. `TextureCache::clear()` (mermaid_renderer.rs)

The `TextureCache` struct (line ~470) has `entries: HashMap`, `order: VecDeque`, and
`current_bytes: usize` but no `clear()` method. Add one:

```rust
fn clear(&mut self) {
    self.entries.clear();
    self.order.clear();
    self.current_bytes = 0;
}
```

When `entries.clear()` runs, all `MermaidTextureEntry` values are dropped, which drops their
`TextureHandle` fields. egui's `TextureManager::free()` is called for each, adding the texture
IDs to the free list. The free list is processed during the painting phase of the same frame.

### 4. `ImageCache::clear()` (markdown_renderer.rs)

The `ImageCache` struct (line ~448) has `entries: HashMap`, `order: VecDeque`, and
`total_bytes: usize` but no `clear()` method. Add one:

```rust
fn clear(&mut self) {
    self.entries.clear();
    self.order.clear();
    self.total_bytes = 0;
}
```

### 5. `MermaidRenderer::release_gpu_textures()` (mermaid_renderer.rs)

```rust
/// Release GPU textures to reduce idle GPU usage.
/// SVG cache is retained so diagrams can be quickly re-rasterized on restore.
pub(crate) fn release_gpu_textures(&self) {
    #[cfg(feature = "mermaid-quickjs")]
    {
        self.mermaid_textures.borrow_mut().clear();
        // mermaid_svg_cache intentionally retained
        // mermaid_errors intentionally retained
        // mermaid_texture_errors intentionally retained
    }
}
```

### 6. `MarkdownRenderer::release_gpu_textures()` (markdown_renderer.rs)

```rust
/// Release GPU textures to reduce idle GPU usage (e.g., when minimized).
/// Textures rebuild lazily on next render. SVG/error caches retained for fast rebuilds.
pub fn release_gpu_textures(&self) {
    self.emoji_textures.borrow_mut().clear();
    self.image_textures.borrow_mut().clear();
    self.mermaid.release_gpu_textures();
}
```

### 7. Texture Rebuild on Restore

**No special rebuild logic needed.** The existing lazy-loading pipeline handles everything:

- **Mermaid diagrams**: `render_block()` checks `mermaid_textures` → miss → checks
  `mermaid_svg_cache` (still populated) → rasterizes SVG → uploads texture.

- **Emoji textures**: emoji rendering checks `emoji_textures` → miss → decodes
  embedded PNG → uploads texture.

- **Image textures**: image rendering checks `image_textures` → miss → enqueues async
  load → uploads on completion.

User-visible effect: brief placeholder flash settling within 3-5 frames (~100-200ms).

## Edge Cases

### Platform Doesn't Report Minimize State

If `viewport().minimized` returns `None`, `unwrap_or(false)` means we never release textures.
Conservative fallback — no change from today.

### Minimize During Active Mermaid Rendering

- Worker threads continue (CPU-only)
- Results queue in the bounded channel
- `release_gpu_textures()` clears the texture cache but NOT the channel
- On restore, `poll_mermaid_results()` drains the queue and creates fresh textures

### Screenshot Mode Guard

`self.screenshot.is_some()` prevents releasing textures during screenshot capture.

### Rapid Minimize/Restore Cycling

- Release: instant (drops TextureHandle references)
- Rebuild: ~200-500ms (from SVG/PNG cache)
- Thrashing is harmless: just brief visual flash per cycle

### No Document Loaded

No application textures exist. `clear()` on empty caches is a no-op.

## Expected Impact

### GPU Usage When Minimized

| Scenario                          | Before  | After   |
|-----------------------------------|---------|---------|
| test_stress.md, minimized         | 2.6%    | ~0.1%   |
| Simple document, minimized        | ~0.5%   | ~0.1%   |
| No document, minimized            | ~0.1%   | ~0.1%   |

### Restore Latency

| Content Type        | Rebuild Time  | Frames to Settle |
|---------------------|---------------|------------------|
| Mermaid diagrams    | 10-50ms each  | 2-5 frames       |
| Emoji               | ~1ms each     | 1 frame          |
| Images (from disk)  | 5-50ms each   | 2-3 frames       |
| Total (test_stress) | ~200-500ms    | 3-5 frames       |

### No Impact on Visible Windows

No texture release on visible-but-idle windows. No timeout mechanism. Only minimize
triggers release.

## Implementation Order

1. Add `TextureCache::clear()` to mermaid_renderer.rs
2. Add `ImageCache::clear()` to markdown_renderer.rs
3. Add `MermaidRenderer::release_gpu_textures()`
4. Add `MarkdownRenderer::release_gpu_textures()`
5. Add `gpu_textures_released` field to `MarkdownViewerApp`
6. Add minimize/restore detection in `update_impl()`
7. Write unit tests for `clear()` methods
8. Write unit tests for `release_gpu_textures()` methods
9. Manual verification with test_stress.md

## Testing Strategy

### Unit Tests

- `TextureCache::clear()` zeroes `current_bytes` and empties entries/order
- `ImageCache::clear()` zeroes `total_bytes` and empties entries/order
- `MermaidRenderer::release_gpu_textures()` clears texture cache but retains SVG cache
- `MarkdownRenderer::release_gpu_textures()` clears emoji + image + mermaid textures

### Manual Verification

1. `cargo build --release`
2. Open `test_stress.md`, scroll to bottom (trigger all mermaid renders)
3. Wait 10 seconds for settlement
4. Note GPU% in Task Manager (expected: ~2.6%)
5. Minimize window, wait 5 seconds
6. Check GPU% (expected: ~0.1%)
7. Restore — verify diagrams re-render within ~500ms
8. Verify GPU% returns to normal

## Alternatives Considered

### A. Idle Timeout (V1 Approach)

Release textures after N seconds of inactivity. **Rejected** because:
- eframe 0.27 discards all repaint requests when minimized
- The timeout code in `update_impl()` never executes while minimized
- Would require `update()` to run, which it doesn't after minimize
- Would also release textures on visible-but-idle windows (Arthur: "no flash")

### B. Focus-Loss Timeout

Release after losing focus for N seconds. **Rejected** because:
- Arthur: "no flashing on visible windows"
- Focus loss without minimize (Alt-Tab) should not trigger release

### C. Restore-Time Detection

Release and rebuild textures on the first frame after restore. **Rejected** because:
- Old textures freed and new textures created on the same frame
- GPU VRAM never actually decreases (freed then immediately re-allocated)
- No sustained GPU idle reduction while minimized

### D. Switch to wgpu Backend

Modern API with better idle management. **Rejected** — disproportionate effort.

### E. Platform-Specific Hook (WM_SYSCOMMAND)

Use `SetWindowSubclass` to catch `SC_MINIMIZE` directly. **Deferred** — the standard
eframe approach works on Windows; this complexity isn't needed.

## References

- eframe 0.27.2 source: `run.rs:85-210` (event loop with per-event retain check)
- eframe 0.27.2 source: `glow_integration.rs:764-773` (Resized 0x0 handling)
- egui-winit 0.27.2 source: `lib.rs:379-387` (Focused event → repaint: true)
- egui-glow 0.27.2 source: `painter.rs:639-643` (unconditional glDeleteTextures)
- [GPUs in the Task Manager — DirectX Developer Blog](https://devblogs.microsoft.com/directx/gpus-in-the-task-manager/)

# High-Level Design: Table Column and Border Fixes (Final Revision)

**Date:** 2025.11.14
**Author:** Claude
**Status:** Ready for Implementation
**Branch:** feat/table-column-fixes

**Revision History:**
- **Rev 1:** Incorrect root cause (image measurement in wrong code path)
- **Rev 2:** Added debug phase, still wrong code path analysis
- **Rev 3:** Corrected to TableBuilder path, identified padding bug
- **Rev 4 (Final):** **Critical discovery - padding bug doesn't affect reported table, root cause still unknown**

---

## 0. Executive Summary

### 0.1 Critical Finding

After exhaustive code review and analysis, discovered:

**❌ PREVIOUS REVISIONS WERE BASED ON FALSE ASSUMPTIONS**

1. **Padding column bug exists** but is **irrelevant to reported issue**
   - Bug only affects ragged tables (rows with more cells than headers)
   - Threat-model table has equal columns (4 headers, 4 cells per row)
   - Padding loop never executes for this table
   - **Bug is real, but not the cause of user's report**

2. **Root cause of column width issue is UNKNOWN**
   - User reported: Examples too narrow, Description too wide in threat-model table
   - Code analysis shows: Examples SHOULD get Remainder policy, Description Resizable
   - Column classification logic appears correct for this table
   - **We cannot diagnose without testing actual rendering**

3. **All previous designs proposed solutions to unconfirmed problems**
   - Rev 1-3 assumed bugs without verification
   - No testing performed to confirm issues exist
   - No measurement of actual vs. expected column widths

### 0.2 Honest Assessment

**What We Know:**
- ✅ Extensive column sizing work completed on feature branch
- ✅ Padding column bug exists (creates multiple Remainder columns for ragged tables)
- ✅ Cell dividers were implemented then rolled back due to "scroll issues"
- ✅ Threat-model table has 4 equal columns (no ragging)

**What We Don't Know:**
- ❓ Does the reported column width bug still exist with current uncommitted changes?
- ❓ If yes, what is the actual root cause?
- ❓ What were the "scroll issues" that caused divider rollback?
- ❓ Is table_wrap_overhaul actually enabled when user observed the bug?
- ❓ Does the existing column sizing work fix the reported issue?

**Honest Conclusion:** **WE MUST TEST BEFORE DESIGNING FIXES**

---

## 1. Revised Problem Statement

### 1.1 Reported Issue (Original)

**User Report:**
> "The table dividing lines sometimes appearing in odd location (e.g. overwriting text or there only be a single line in a table with multiple columns). The column widths not being correct (for example see the attached screenshot - the examples column should be wider and the description narrower (it's almost as if we're off by one when sizing the columns)"

**Test Case:** `examples/regressions/table-threat-model.md`

**Table Structure:**
```markdown
| Element | Symbol | Description | Examples |
|---------|--------|-------------|----------|
| ...     | ...    | ...         | ...      |
```
- 4 headers, 4 cells per row (equal, not ragged)
- No images in cells
- Text content varies by column

### 1.2 Confirmed Bugs (Code Review)

**BUG #1: Padding Column Policy**
- **Location:** `src/markdown_renderer.rs:3336`
- **Code:** `ColumnPolicy::Remainder { clip: false }`
- **Impact:** Creates multiple Remainder columns for ragged tables
- **Severity:** HIGH for ragged tables, **ZERO for threat-model table**
- **Status:** Confirmed by code inspection

**BUG #2: Missing Cell Dividers**
- **Location:** Rolled back from codebase (journal 19:30 ET)
- **Impact:** No cell dividers rendered, only striped rows
- **Cause:** "Scroll issues" (undocumented)
- **Severity:** MEDIUM (visual only, functionality works)
- **Status:** Known, requires investigation

### 1.3 Unconfirmed Issues (Requires Testing)

**ISSUE #1: Column Width Bug**
- **Reported:** Examples too narrow, Description too wide
- **Expected:** Examples widest (Remainder), Description moderate (Resizable)
- **Code Analysis:** Classification logic appears correct
- **Status:** **UNVERIFIED** - may be fixed, may be misreported, may be real

**ISSUE #2: Dividers "Overwriting Text"**
- **Reported:** Odd line locations, text overwriting
- **Current State:** No dividers at all (rolled back)
- **Status:** Cannot occur with current code (no dividers exist)

**ISSUE #3: "Single Line for Multi-Column"**
- **Reported:** Only one line for multi-column table
- **Current State:** Outer frame only (from legacy Frame::stroke)
- **Status:** May be describing current frame-only behavior

---

## 2. Analysis of Current State

### 2.1 Column Sizing Logic (Uncommitted)

**Flow:** `render_table_tablebuilder` → `derive_column_specs` → `classify_column`

**For Threat-Model Table:**

```rust
// Expected classification:
headers[0] = "Element"      → classify_column → Fixed (index 0 rule, line 320)
headers[1] = "Symbol"       → classify_column → Resizable (fallthrough, line 330)
headers[2] = "Description"  → classify_column → Resizable (pattern match, line 303)
headers[3] = "Examples"     → classify_column → Remainder (pattern match, line 313)

// Fallback check (lines 207-230):
// Since remainder_assigned = true (Examples matched), fallback doesn't run
```

**Expected Policies:**
- Element: `Fixed { width: ~109px at 14pt font, clip: true }`
- Symbol: `Resizable { min: ~98px, preferred: ~133px }`
- Description: `Resizable { min: ~147px, preferred: ~203px }`
- Examples: `Remainder { clip: false }` ← Should take all remaining space

**This Looks Correct!**

### 2.2 Padding Loop Analysis

**Code:**
```rust
let row_max = rows.iter().map(|r| r.len()).max().unwrap_or(0);  // row_max = 4
let target_cols = column_specs.len().max(row_max).max(1);       // target_cols = max(4, 4, 1) = 4
while column_specs.len() < target_cols {  // 4 < 4 → FALSE, loop never executes
    // This code never runs for threat-model table!
}
```

**Conclusion:** Padding bug does NOT affect threat-model table.

### 2.3 Rendering Flow

**Code:** Lines 3352-3381

```rust
.header(|mut header| {
    for ci in 0..column_specs.len() {  // ci = 0,1,2,3
        header.col(|ui| {
            let spans = headers.get(ci).unwrap_or(&[]);  // Gets correct header
            self.render_overhauled_cell(ui, spans, width, true, None, ci);
        });
    }
})
.body(|body| {
    for ci in 0..column_specs.len() {  // ci = 0,1,2,3
        row.col(|ui| {
            let spans = row_cells.get(ci).unwrap_or(&[]);  // Gets correct cell
            self.render_overhauled_cell(ui, spans, width, false, Some(idx), ci);
        });
    }
});
```

**Column spec index `ci` matches header/cell index correctly.** No off-by-one bug found.

### 2.4 Mystery: Why Would Examples Be Too Narrow?

**Possible Explanations:**

1. **egui Column::remainder() bug** - egui may have issues with remainder distribution
2. **Measurement stats interfering** - Content stats may be affecting width allocation
3. **Visual perception** - Examples IS getting remainder but looks narrow due to long content
4. **User's actual table different** - Maybe screenshot shows different table
5. **table_wrap_overhaul disabled** - Maybe using legacy path with different bugs
6. **Already fixed** - Current uncommitted changes may have fixed it
7. **Window too narrow** - Remainder space may be small in narrow window
8. **Font/DPI issue** - Scaling calculations may be wrong

**We cannot determine which without testing!**

---

## 3. Mandatory Phase 0: Debug and Verify

**BEFORE ANY CODE CHANGES, WE MUST:**

### 3.1 Test Current Implementation

**Step 1: Build Current Branch**
```bash
cargo build --release
```

**Step 2: Run with Threat-Model Table**
```bash
cargo run --release -- examples/regressions/table-threat-model.md
```

**Step 3: Add Debug Logging**

Temporary instrumentation (remove before commit):

```rust
// In render_table_tablebuilder, after derive_column_specs
if cfg!(debug_assertions) {
    eprintln!("\n=== TABLE DEBUG ===");
    eprintln!("Table ID: {}", table_id);
    eprintln!("Headers: {} columns", headers.len());
    eprintln!("Max row cells: {}", row_max);
    eprintln!("Target cols: {}", target_cols);
    eprintln!("\nColumn Specifications:");
    for (i, spec) in column_specs.iter().enumerate() {
        let header_text = headers.get(i)
            .map(|h| header_text(h))
            .unwrap_or_else(|| format!("(padding {})"));
        eprintln!("  [{}] {}: {:?}", i, header_text, spec.policy);
    }
    eprintln!("==================\n");
}
```

**Step 4: Capture Screenshots**
- Full window view
- Close-up of table
- Measure actual column widths (use screenshot tool with pixel ruler)

**Step 5: Document Findings**
- Do columns look correct or wrong?
- What are actual pixel widths?
- What did debug output show?
- Is table_wrap_overhaul enabled? (check status bar)

### 3.2 Test Ragged Table

Create test file `test-ragged.md`:
```markdown
| A | B |
|---|---|
| 1 | 2 | 3 | 4 |
| x | y |
```

Run and observe:
- Do padding columns appear?
- Do they use Remainder policy? (check debug output)
- How many Remainder columns total?

### 3.3 Test Divider Rollback

**Search Git History:**
```bash
git log --all --source --full-history -S "paint_table_dividers"
git log --all --oneline --grep="divider"
git log --all --oneline --grep="scroll"
```

**Find and review rolled-back code:**
- What was the implementation approach?
- What specific scroll behavior failed?
- Can we reproduce the issue?

### 3.4 Decision Matrix

**After testing, we'll know:**

| Finding | Action |
|---------|--------|
| Column widths ARE broken in current code | → Investigate root cause with debugger |
| Column widths ARE correct in current code | → Bug already fixed, document solution |
| Padding bug causes visible issues | → Fix padding bug (use Auto or Resizable) |
| Padding bug causes no issues | → Fix anyway for correctness, lower priority |
| Dividers are fixable | → Re-implement with fix |
| Dividers are egui limitation | → Document, file upstream issue |

---

## 4. Confirmed Fix: Padding Column Bug

**Regardless of testing outcome, this bug should be fixed for correctness.**

### 4.1 Current Buggy Code

```rust
while column_specs.len() < target_cols {
    column_specs.push(ColumnSpec::new(
        format!("Column {}", column_specs.len() + 1),
        ColumnPolicy::Remainder { clip: false },  // ❌ BUG: Multiple remainder!
        None,
    ));
}
```

### 4.2 Proposed Fix (Option A: Auto)

```rust
while column_specs.len() < target_cols {
    let padding_idx = column_specs.len();
    column_specs.push(ColumnSpec::new(
        format!("Padding {}", padding_idx + 1),
        ColumnPolicy::Auto,  // ✓ Let egui auto-size
        Some(format!("Auto-generated for ragged table")),
    ));
}
```

**Pros:**
- Simple, lets egui handle sizing
- No hardcoded widths

**Cons:**
- Empty cells may collapse to zero width
- Might look odd if cells truly empty

### 4.3 Proposed Fix (Option B: Small Resizable)

```rust
while column_specs.len() < target_cols {
    let padding_idx = column_specs.len();
    column_specs.push(ColumnSpec::new(
        format!("Padding {}", padding_idx + 1),
        ColumnPolicy::Resizable {
            min: px(self.font_sizes.body, 4.0),   // ~56px at 14pt
            preferred: px(self.font_sizes.body, 6.0),  // ~84px at 14pt
            clip: true,
        },
        Some(format!("Auto-generated column {}", padding_idx)),
    ));
}
```

**Pros:**
- Guaranteed minimum width
- DPI-aware via px() helper
- Consistent with other Resizable columns

**Cons:**
- Slightly more complex
- Arbitrary width choice

**Recommendation:** **Option B (Small Resizable)** - more predictable behavior

### 4.4 Debug Assertion

```rust
// After padding loop, verify single remainder
#[cfg(debug_assertions)]
{
    let remainder_count = column_specs
        .iter()
        .filter(|s| matches!(s.policy, ColumnPolicy::Remainder { .. }))
        .count();

    if remainder_count != 1 {
        eprintln!(
            "⚠️  WARNING: Table {} has {} Remainder columns (expected exactly 1)",
            table_id, remainder_count
        );
        eprintln!("     This violates the single-remainder design principle!");
        for (i, spec) in column_specs.iter().enumerate() {
            if matches!(spec.policy, ColumnPolicy::Remainder { .. }) {
                eprintln!("     - Column {}: {}", i, spec.ident);
            }
        }
    }
}
```

### 4.5 Test Coverage

**New Test:**
```rust
#[test]
fn ragged_table_single_remainder_enforced() {
    let headers = vec![vec![span("A")], vec![span("B")]];
    let rows = vec![
        vec![vec![span("1")], vec![span("2")], vec![span("3")], vec![span("4")]],  // 4 cells
        vec![vec![span("x")], vec![span("y")]],  // 2 cells
    ];

    let stats = compute_column_stats(&headers, &rows, 32);
    let ctx = TableColumnContext::new(&headers, &rows, &stats, 14.0, 0);

    // This simulates what render_table_tablebuilder does
    let mut column_specs = derive_column_specs(&ctx);
    let row_max = rows.iter().map(|r| r.len()).max().unwrap_or(0);
    let target_cols = column_specs.len().max(row_max).max(1);

    // Apply the fix
    while column_specs.len() < target_cols {
        let padding_idx = column_specs.len();
        column_specs.push(ColumnSpec::new(
            format!("Padding {}", padding_idx + 1),
            ColumnPolicy::Resizable {
                min: 14.0 * 4.0,
                preferred: 14.0 * 6.0,
                clip: true,
            },
            None,
        ));
    }

    assert_eq!(column_specs.len(), 4, "Should have 4 columns total");

    let remainder_count = column_specs
        .iter()
        .filter(|s| matches!(s.policy, ColumnPolicy::Remainder { .. }))
        .count();

    assert_eq!(remainder_count, 1, "Must have exactly one Remainder column");

    // Verify it's one of the original columns, not padding
    let remainder_indices: Vec<usize> = column_specs
        .iter()
        .enumerate()
        .filter(|(_, s)| matches!(s.policy, ColumnPolicy::Remainder { .. }))
        .map(|(i, _)| i)
        .collect();

    assert!(remainder_indices[0] < headers.len(), "Remainder should be in original columns");
}
```

---

## 5. Revised Implementation Plan

### Phase 0: Mandatory Verification (4-6 hours) ⚠️ BLOCKING

**Tasks:**
1. Build current branch
2. Test threat-model table, capture screenshots
3. Add debug logging, capture output
4. Test ragged table
5. Search git history for divider rollback details
6. Document all findings in verification report

**Deliverables:**
- Screenshots (current rendering)
- Debug output log
- Verification report answering:
  - Is column width bug still present?
  - What is actual vs. expected behavior?
  - What were divider scroll issues?

**Decision Point:** Proceed to Phase 1 only after Phase 0 complete.

### Phase 1: Fix Padding Column Bug (2-3 hours)

**Conditional:** Execute regardless of Phase 0 findings (bug exists either way)

**Tasks:**
1. Implement Option B (Small Resizable) for padding columns
2. Add debug assertion for single remainder
3. Add unit test for ragged tables
4. Test with ragged table markdown
5. Verify no impact on equal-column tables

**Deliverables:**
- Fixed code
- Passing test
- Verification that threat-model table unaffected

### Phase 2: Address Column Width Issue (variable)

**Conditional:** Depends on Phase 0 findings

**Scenario A: Bug Still Exists**
- Debug with instrumentation
- Use debugger to trace width allocation
- Check egui Column::remainder() behavior
- Identify and fix root cause
- Effort: 4-8 hours

**Scenario B: Bug Already Fixed**
- Document what fixed it
- Add regression test
- Update QA doc
- Effort: 1-2 hours

**Scenario C: Bug Never Existed**
- Document that user report was based on different state
- Confirm current behavior is correct
- Effort: 1 hour

### Phase 3: Address Divider Issue (variable)

**Conditional:** Depends on Phase 0 investigation

**Scenario A: Fixable Scroll Issue**
- Identify root cause from history
- Implement fix (proper clipping, layer, etc.)
- Re-implement dividers with fix
- Test thoroughly
- Effort: 6-10 hours

**Scenario B: egui Limitation**
- Document why dividers unavailable
- File upstream issue with egui
- Consider alternatives (thicker stripes, color coding)
- Update user docs
- Effort: 2-3 hours

**Scenario C: Defer**
- Document decision to defer
- Create tracking issue for future
- Focus on more important issues
- Effort: 1 hour

### Phase 4: Testing and Documentation (4-6 hours)

**Tasks:**
1. Comprehensive visual testing (multiple DPI, window sizes)
2. Performance testing (ensure no regressions)
3. Update QA doc with findings
4. Update CLAUDE.md with implementation details
5. Create before/after comparison

**Deliverables:**
- Test report
- Updated documentation
- Performance benchmarks

### Phase 5: Commit and PR (2-3 hours)

**Tasks:**
1. Remove debug instrumentation
2. Run `cargo fmt`, `cargo clippy`
3. Ensure all tests pass
4. Write clear commit messages
5. Create PR with comprehensive description

**Deliverables:**
- Clean commits
- PR with before/after evidence
- Review-ready code

---

## 6. Success Criteria

### 6.1 Phase 0 Must Complete

- [ ] Verification report written and reviewed
- [ ] Screenshots captured showing current behavior
- [ ] Debug output logged and analyzed
- [ ] Decision made on subsequent phases

### 6.2 Code Quality

- [ ] Padding column bug fixed
- [ ] Exactly one Remainder column per table (verified)
- [ ] Zero compiler warnings
- [ ] `cargo clippy` clean
- [ ] All tests pass
- [ ] Test coverage for ragged tables

### 6.3 Documentation

- [ ] Verification report complete
- [ ] QA doc updated
- [ ] CLAUDE.md updated
- [ ] If issues deferred, tracking issues filed

### 6.4 User-Facing

- [ ] Threat-model table renders correctly (or bug documented)
- [ ] Ragged tables handle gracefully
- [ ] No regressions in existing tables
- [ ] Performance within 5% of baseline

---

## 7. Key Learnings

### 7.1 Process Failures in Rev 1-3

1. **Assumed problems without verification**
2. **Analyzed wrong code paths**
3. **Didn't check for existing work**
4. **Jumped to solutions before understanding problems**
5. **Made claims without testing**

### 7.2 Correct Process (This Revision)

1. ✅ Checked current branch and uncommitted changes
2. ✅ Reviewed journals and existing designs
3. ✅ Traced actual execution paths
4. ✅ Verified which code affects which scenarios
5. ✅ Acknowledged unknowns honestly
6. ✅ Mandated testing before fixing
7. ✅ Separated confirmed vs. suspected issues

### 7.3 Engineering Principles

**"Test Before Fix"**
- Never assume a bug exists without reproduction
- Always verify current behavior before changing it
- Measure actual vs. expected quantitatively

**"Understand Before Change"**
- Trace execution paths
- Verify assumptions
- Document unknowns

**"Fix Only Confirmed Bugs"**
- Separate speculation from facts
- Fix known issues first
- Investigate unknowns separately

---

## 8. Risk Assessment

### 8.1 Risks

| Risk | Probability | Impact | Mitigation |
|------|------------|---------|------------|
| Column width bug doesn't exist | Medium | Low | Phase 0 testing reveals truth |
| Padding fix breaks something | Low | Medium | Comprehensive testing, small change |
| Dividers unfixable | Medium | Low | Alternative approaches documented |
| Performance regression | Low | Medium | Benchmarking required |
| Test results inconclusive | Medium | Medium | Add more instrumentation |

### 8.2 Unknowns

- Actual root cause of reported column width issue
- Nature of divider scroll issues
- Whether existing work already fixed reported issues

---

## 9. Open Questions for Phase 0

**Q1:** Does the column width bug still exist with current uncommitted code?
- **Method:** Visual inspection + measurement
- **Decision Impact:** High

**Q2:** If yes, what is the root cause?
- **Method:** Debug logging + debugger
- **Decision Impact:** Critical

**Q3:** What were the specific divider scroll issues?
- **Method:** Git history + code review
- **Decision Impact:** High

**Q4:** Is table_wrap_overhaul enabled when bug observed?
- **Method:** Check status bar, verify flag
- **Decision Impact:** Critical

**Q5:** Do padding columns with empty cells look acceptable?
- **Method:** Visual test with ragged table
- **Decision Impact:** Medium

---

## 10. Appendix

### 10.1 Code Locations

| Component | File | Lines | Notes |
|-----------|------|-------|-------|
| Main dispatcher | `src/markdown_renderer.rs` | 3215-3229 | Checks table_wrap_overhaul |
| TableBuilder render | `src/markdown_renderer.rs` | 3318-3382 | Active path |
| **Padding bug** | `src/markdown_renderer.rs` | **3333-3339** | **NEEDS FIX** |
| Column classification | `src/table_support/column_spec.rs` | 270-335 | Pattern matching |
| Fallback remainder | `src/table_support/column_spec.rs` | 207-230 | Stats-based selection |
| Column stats | `src/table_support/column_spec.rs` | 378-447 | Content analysis |

### 10.2 Test Files

| Purpose | Location | Status |
|---------|----------|--------|
| Reported issue | `examples/regressions/table-threat-model.md` | Exists |
| Ragged table test | Create as `test-ragged.md` | **TODO** |
| Unit tests | `src/table_support/column_spec.rs` | 480-587 (existing) |
| Ragged test | **Add to test suite** | **TODO** |

### 10.3 Related Documents

- Journal: `wrk_journals/2025.11.14 - JRN - Table Column Fixes.md`
- Original HLD: `wrk_docs/2025.11.14 - HLD - Table Column Fixes.md`
- Plan: `wrk_docs/2025.11.14 - PLN - Table Column Fixes.md`
- QA Doc: `docs/QA-table-wrap.md`

---

## 11. Final Recommendations

### 11.1 Immediate Actions (Next Session)

1. **Execute Phase 0 verification** (4-6 hours)
   - Build and test current implementation
   - Capture evidence
   - Write verification report

2. **Review verification report** (1 hour)
   - Stakeholder discussion
   - Decide on next phases

### 11.2 After Phase 0

**If Column Width Bug Exists:**
- Prioritize root cause investigation
- Use debugger and extensive logging
- May require deeper egui understanding

**If Bug Already Fixed:**
- Document solution
- Add regression tests
- Move to divider investigation

**If Bug Never Existed:**
- Document findings
- Close issue with explanation

### 11.3 Padding Bug Fix

**Execute regardless** - bug exists and should be fixed for correctness, even if low user impact.

### 11.4 Divider Investigation

**Defer until after column width resolution** - lower priority, visual-only impact.

---

**END OF FINAL DESIGN**

**Summary:**
This revision acknowledges that we DON'T know the root cause of the reported issue and mandates testing before any fixes. The padding column bug is real but doesn't affect the specific table in the user's report. We must verify actual behavior before proceeding with any implementation.

**Next Step:** Execute Phase 0 verification and create findings report before any code changes.

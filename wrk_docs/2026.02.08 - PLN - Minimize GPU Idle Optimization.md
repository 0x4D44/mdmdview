# Implementation Plan: Minimize GPU Idle Optimization

**Date:** 2026-02-08
**HLD:** `wrk_docs/2026.02.08 - HLD - Minimize GPU Idle Optimization V3.md`
**Version bump:** 1.5.1 → 1.5.2 (patch — internal optimization, no API change)

## Overview

Release application-managed GPU textures when the window is minimized. On restore,
textures rebuild lazily from retained SVG/PNG caches. Reduces GPU idle from ~2.6% to ~0.1%.

9 stages, each independently compilable and testable. Commit after each stage.

---

## Stage 1: `TextureCache::clear()` — mermaid_renderer.rs

**Goal:** Add a `clear()` method to `TextureCache` for releasing mermaid GPU textures.

**File:** `c:\language\mdmdview\src\mermaid_renderer.rs`

**Location:** Inside the `TextureCache` impl block (lines 480–557), feature-gated
under `#[cfg(feature = "mermaid-quickjs")]`.

**Code to add** (insert before the closing `}` of the impl block, ~line 557):

```rust
fn clear(&mut self) {
    self.entries.clear();
    self.order.clear();
    self.current_bytes = 0;
}
```

**Test to add** (in the `#[cfg(test)]` module at bottom of file):

```rust
#[test]
fn test_texture_cache_clear() {
    // Create a cache with entries, call clear(), verify all state is zeroed
}
```

Verify the test creates a `TextureCache`, inserts entries (using mock `TextureHandle` via
`ctx.load_texture()`), calls `clear()`, and asserts:
- `entries.is_empty()`
- `order.is_empty()`
- `current_bytes == 0`

**Note:** `TextureCache` tests require an egui context to create `TextureHandle` values.
Existing mermaid tests already create contexts — follow the same pattern.

**Validation:** `cargo test mermaid_renderer` + `cargo build`

---

## Stage 2: `ImageCache::clear()` — markdown_renderer.rs

**Goal:** Add a `clear()` method to `ImageCache` for releasing image GPU textures.

**File:** `c:\language\mdmdview\src\markdown_renderer.rs`

**Location:** Inside the `ImageCache` impl block (lines 459–530).

**Code to add** (insert before the closing `}` of the impl block, ~line 530):

```rust
fn clear(&mut self) {
    self.entries.clear();
    self.order.clear();
    self.total_bytes = 0;
}
```

**Test to add** (in the existing `#[cfg(test)]` module):

```rust
#[test]
fn test_image_cache_clear() {
    // Create an ImageCache, insert entries, call clear(), verify all state is zeroed
}
```

Verify the test inserts `ImageCacheEntry` values (which hold `TextureHandle`), calls
`clear()`, and asserts:
- `entries.is_empty()`
- `order.is_empty()`
- `total_bytes == 0`

**Validation:** `cargo test markdown_renderer` + `cargo build`

---

## Stage 3: `MermaidRenderer::release_gpu_textures()` — mermaid_renderer.rs

**Goal:** Add a public method to release mermaid GPU textures while retaining SVG/error caches.

**File:** `c:\language\mdmdview\src\mermaid_renderer.rs`

**Location:** Inside the `MermaidRenderer` impl block (lines 641–1494), feature-gated.
Add near the top of the impl block (after `new()` and before the rendering methods) for
discoverability. Alternatively, add after the last method (~line 1493).

**Code to add:**

```rust
/// Release GPU textures to reduce idle GPU usage.
/// SVG cache is retained so diagrams can be quickly re-rasterized on restore.
pub(crate) fn release_gpu_textures(&self) {
    self.mermaid_textures.borrow_mut().clear();
    // mermaid_svg_cache intentionally retained for fast rebuild
    // mermaid_errors intentionally retained to prevent retry storms
    // mermaid_texture_errors intentionally retained
}
```

The entire `MermaidRenderer` impl is already feature-gated, so no additional `#[cfg]` needed
on the method itself.

**Also add** a no-op implementation for when mermaid is disabled. Check if there's already a
`#[cfg(not(feature = "mermaid-quickjs"))]` impl block for `MermaidRenderer`. If so, add
`release_gpu_textures()` there too. If not, the method only exists when mermaid is enabled,
and the caller (`MarkdownRenderer::release_gpu_textures()`) must handle this.

**Test to add:**

```rust
#[test]
fn test_release_gpu_textures_preserves_svg_cache() {
    // Create MermaidRenderer, populate both texture and SVG caches
    // Call release_gpu_textures()
    // Assert: texture cache is empty
    // Assert: SVG cache is NOT empty
}
```

**Validation:** `cargo test mermaid_renderer` + `cargo build` + `cargo build --no-default-features`

---

## Stage 4: `MarkdownRenderer::release_gpu_textures()` — markdown_renderer.rs

**Goal:** Add a public method to release all application-managed GPU textures.

**File:** `c:\language\mdmdview\src\markdown_renderer.rs`

**Location:** Inside the `MarkdownRenderer` impl block (lines 603–5843). Add near the
existing cache methods: `clear_table_layout_cache()` (line 5436) and
`clear_image_failure_cache()` (line 5444).

**Code to add:**

```rust
/// Release GPU textures to reduce idle GPU usage (e.g., when minimized).
/// Textures rebuild lazily on next render. SVG/error caches retained for fast rebuilds.
pub fn release_gpu_textures(&self) {
    self.emoji_textures.borrow_mut().clear();
    self.image_textures.borrow_mut().clear();
    self.mermaid.release_gpu_textures();
}
```

**Test to add:**

```rust
#[test]
fn test_release_gpu_textures_clears_all_caches() {
    // Create MarkdownRenderer with an egui context
    // Populate emoji_textures, image_textures (and mermaid if feature enabled)
    // Call release_gpu_textures()
    // Assert: all texture caches are empty
}
```

**Validation:** `cargo test markdown_renderer` + `cargo build` + `cargo build --no-default-features`

---

## Stage 5: Add `gpu_textures_released` field — app.rs

**Goal:** Add state tracking field to `MarkdownViewerApp`.

**File:** `c:\language\mdmdview\src\app.rs`

**Struct field** — add after `startup_frame` (line 409), before the closing `}` at line 410:

```rust
/// Whether GPU textures have been released (e.g., due to window minimize).
/// When true, textures will rebuild lazily on the next visible render.
gpu_textures_released: bool,
```

**Constructor** — add initialization in `new()`, alongside `startup_frame: 0` (~line 636):

```rust
gpu_textures_released: false,
```

**No tests needed** for this stage — it's just a field addition. Compilation is the test.

**Validation:** `cargo build`

---

## Stage 6: Minimize/restore detection — app.rs

**Goal:** Add the core logic that detects minimize → releases textures, and detect
restore → triggers rebuild.

**File:** `c:\language\mdmdview\src\app.rs`

**Location:** In `update_impl()`, insert AFTER the startup frame logic (line 2360) and
BEFORE the debug repaint logging (line 2362). This placement ensures:
- Startup frames complete first (window visibility)
- Minimize detection runs before any rendering
- Screenshot guard prevents release during capture

**Code to add:**

```rust
// Detect minimize → release GPU textures to reduce idle GPU usage.
// On Windows, the Focused(false) event during minimize triggers a RedrawRequested
// that bypasses eframe's minimize filter, giving us this transition frame.
let is_minimized = ctx.input(|i| i.viewport().minimized.unwrap_or(false));

if is_minimized && !self.gpu_textures_released && self.screenshot.is_none() {
    self.renderer.release_gpu_textures();
    self.gpu_textures_released = true;
}

if !is_minimized && self.gpu_textures_released {
    self.gpu_textures_released = false;
    ctx.request_repaint(); // Ensure full re-render to rebuild textures
}
```

**Validation:** `cargo build` + `cargo test app`

---

## Stage 7: Version bump

**Goal:** Bump patch version for this optimization.

**File:** `c:\language\mdmdview\Cargo.toml`

**Change:** `version = "1.5.1"` → `version = "1.5.2"`

**Validation:** `cargo build`

---

## Stage 8: Full test suite + release build

**Goal:** Verify nothing is broken across the entire codebase.

**Commands:**

```bash
cargo test
cargo build --release
cargo build --release --no-default-features
```

All tests must pass. Both feature configurations must compile cleanly with zero warnings.

---

## Stage 9: Manual verification

**Goal:** Verify the optimization works end-to-end.

**Steps:**

1. `cargo build --release`
2. Run: `target\release\mdmdview.exe test_stress.md`
3. Scroll to bottom (trigger all 8 mermaid diagram renders)
4. Wait 10 seconds for everything to settle
5. Open Task Manager → Performance → GPU
6. Note GPU% (expected: ~2.6%)
7. Minimize mdmdview
8. Wait 5 seconds
9. Check GPU% (expected: ~0.1%)
10. Restore mdmdview
11. Verify all diagrams re-render (brief placeholder flash is expected, settles in ~200ms)
12. Check GPU% returns to normal visible-rendering level

**If GPU% doesn't drop after minimize:** The transition frame didn't fire. Add a
`println!` or log statement inside the `is_minimized` check to verify whether the
detection code runs. If it doesn't run, we'll need to investigate platform-specific
event ordering (see HLD: Platform Reliability Analysis).

---

## Dependency Graph

```
Stage 1 (TextureCache::clear)  ──┐
                                  ├── Stage 3 (MermaidRenderer::release_gpu_textures)
Stage 2 (ImageCache::clear)   ──┤                                                    ├── Stage 6 (minimize detection)
                                  ├── Stage 4 (MarkdownRenderer::release_gpu_textures)
                                  │
Stage 5 (gpu_textures_released)──┘

Stage 6 ── Stage 7 (version bump) ── Stage 8 (full tests) ── Stage 9 (manual verify)
```

Stages 1 and 2 are independent and can be done in parallel.
Stages 3 depends on 1. Stage 4 depends on 2 and 3.
Stage 6 depends on 4 and 5.
Stages 7–9 are sequential after 6.

---

## Risk Checklist

| Risk | Mitigation |
|------|------------|
| `borrow_mut()` panic on RefCell | All calls are in `update_impl()` before rendering; no overlapping borrows possible |
| Missing feature gate for `--no-default-features` build | Stage 3 handles the non-mermaid impl; Stage 8 verifies both configurations |
| Transition frame doesn't fire on some platform | Conservative fallback: `unwrap_or(false)` means no release, no regression |
| TextureHandle drop doesn't free GPU texture | Verified: egui's TextureManager frees on drop; painting processes the free list unconditionally |
| Texture rebuild flash on restore | Expected behavior (~200ms); documented in HLD as acceptable |
| Screenshot mode interference | Guarded by `self.screenshot.is_none()` check in Stage 6 |

---

## Estimated Scope

- **Lines added:** ~60 (implementation) + ~80 (tests) = ~140 total
- **Files modified:** 3 (`mermaid_renderer.rs`, `markdown_renderer.rs`, `app.rs`, `Cargo.toml`)
- **Risk level:** Low — additive changes only, no existing behavior modified

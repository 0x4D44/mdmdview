# HLD - Mermaid Renderer Completion Update

Date: 2025.12.30
Status: Draft

## Summary
The embedded Mermaid renderer (QuickJS plus resvg) is implemented but not the default build. Completion requires feature gating for Kroki, defaulting to embedded rendering, clearer capability handling, tests, regression coverage, and documentation/licensing updates.

## Progress Review (Current State)
- Renderer module is present with QuickJS path, worker pool, caching, and error handling in `src/mermaid_renderer.rs`.
- Markdown integration delegates Mermaid blocks via `MermaidRenderer::render_block` in `src/markdown_renderer.rs`.
- Build embeds `assets/vendor/mermaid.min.js` into `OUT_DIR/mermaid_js.rs` in `build.rs`.
- Embedded path is behind `mermaid-quickjs` feature; default build is still Kroki.
- Kroki rendering is controlled by `MDMDVIEW_ENABLE_KROKI` but always compiled.
- Regression case exists (`tests/regression/cases/008-mermaid.md`) with current references in `tests/regression/reference/008-mermaid`.
- README and samples still describe Mermaid as feature-gated.

## Gaps
1. Default features are empty; embedded rendering is not the default.
2. Kroki is always compiled; `ureq` is unconditional.
3. Capability handling does not report "embedded requested but not compiled".
4. QuickJS tests do not assert real render output.
5. Regression runner does not force embedded output or disable Kroki.
6. Mermaid license is not recorded alongside the vendor asset.

## Design Goals
- Offline embedded rendering is the default behavior.
- Network rendering remains optional and explicit.
- Renderer selection is deterministic and reports capability gaps.
- QuickJS path has regression and smoke coverage.
- Documentation and licensing reflect the embedded default.

## Proposed Changes

### Feature Model and Build Defaults
- Add `mermaid-embedded = ["mermaid-quickjs"]`.
- Add `mermaid-kroki = ["dep:ureq"]`.
- Set `[features] default = ["mermaid-embedded"]`.
- Make `ureq` optional; compile Kroki paths only under `mermaid-kroki`.

### Renderer Capability Detection
- Add compile-time capability flags: embedded_available, kroki_available.
- If `MDMDVIEW_MERMAID_RENDERER=embedded` but embedded is not compiled or JS missing:
  - Show a warning panel and fall back to source rendering (no Kroki fallback unless requested).
- If `MDMDVIEW_MERMAID_RENDERER=kroki` but Kroki is not compiled:
  - Show a warning panel and fall back to source rendering.
- Keep `off` behavior as-is with clear messaging.

### Embedded JS Asset Validation
- Add a feature-gated test that asserts `mermaid_embed::MERMAID_JS` is non-empty.
- If JS bytes are empty at runtime, show a clear warning and disable embedded rendering.

### Kroki Feature Gating
- Wrap Kroki workers, requests, and render paths in `#[cfg(feature = "mermaid-kroki")]`.
- Provide no-op stubs when `mermaid-kroki` is disabled (return source rendering with a message).

### Validation and Regression Coverage
- Add QuickJS tests (feature-gated) that render a flowchart, sequence diagram, and class/state diagram:
  - Assert non-empty SVG output.
  - Assert rasterization produces non-empty RGBA output with size bounds.
- Update regression runner to set:
  - `MDMDVIEW_MERMAID_RENDERER=embedded`
  - `MDMDVIEW_ENABLE_KROKI=0`
- Regenerate `tests/regression/reference/008-mermaid` with embedded output.

### Documentation and Licensing
- Add Mermaid license text under `assets/vendor/` or `THIRD_PARTY_NOTICES.md`.
- Update README to describe embedded as default and Kroki as optional.
- Update `src/sample_files.rs` and other docs to remove feature-gated language.

## Compatibility
- Keep `mermaid-quickjs` for compatibility; `mermaid-embedded` becomes the default alias.
- Keep env vars but treat them as no-ops when features are not compiled.

## Risks and Mitigations
- Binary size growth: document it and keep Kroki optional.
- Mermaid version drift: pin vendor version and document it.
- QuickJS reliability: add render smoke tests and timeouts.

## Open Questions
- Should missing Mermaid JS under embedded builds be a hard error?
- Do we want a UI selector for renderer choice, or keep env vars only?

# HLD - Table Rendering Bug Fixes

**Date:** 2025-11-28
**Author:** Claude
**Branch:** feat/table-dividers
**Related Files:** `src/markdown_renderer.rs`, `src/table_support/`

---

## 1. Executive Summary

This document describes two critical bugs in the table rendering code and their fixes:

1. **Bug #1: Dividers drawn at incorrect positions** - Dividers are painted using cell content widths (`ui.min_rect().width()`) instead of the actual column widths allocated by `TableBuilder`.

2. **Bug #2: Column widths captured at wrong phase** - Widths are collected during header rendering instead of using `TableBody::widths()` which provides the definitive column widths after layout.

Both bugs stem from a fundamental misunderstanding of the egui_extras TableBuilder API.

---

## 2. Root Cause Analysis

### 2.1 Current Implementation (Buggy)

In `render_table_tablebuilder()` (lines 3373-3390):

```rust
.header(header_height, |mut header| {
    for (ci, _) in column_specs.iter().enumerate() {
        header.col(|ui| {
            let width = ui.available_width().max(1.0);
            let spans = headers.get(ci).map(|v| v.as_slice()).unwrap_or(&[]);
            let _ = self.render_overhauled_cell(ui, spans, width, true, None, ci);
            // BUG: This captures the cell CONTENT width, not the column width
            column_widths[ci] = ui.min_rect().width();  // <-- WRONG
            // ...
        });
    }
})
```

### 2.2 Why This Is Wrong

| What the code does | What it should do |
|--------------------|-------------------|
| `ui.min_rect().width()` - Gets the bounding box of rendered content | `body.widths()` - Gets the actual column widths allocated by the table layout system |
| Captures during header rendering | Should capture from body after layout is complete |
| Content width may be smaller than column width (padding, minimum widths) | Column width is the definitive allocated space |

### 2.3 Visual Manifestation

When content is narrower than the column:
```
| Header |  Content  | <- Column width = 100px
     60px              <- Content width captured by min_rect()

Expected divider at x=100:  |
Actual divider at x=60:        |  <- Drawn inside the column!
```

When content is wider than the column (clipped):
```
| Header |  VeryLongContent | <- Column width = 100px, content clipped
        120px                   <- Content width (before clipping)

Expected divider at x=100:  |
Actual divider at x=120:       | <- Drawn past the column boundary!
```

---

## 3. Solution Design

### 3.1 Correct API Usage

According to [egui_extras documentation](https://docs.rs/egui_extras/latest/egui_extras/struct.TableBody.html):

```rust
impl<'a> TableBody<'a> {
    /// Return a vector containing all column widths for this table body.
    pub fn widths(&self) -> &[f32]
}
```

This returns the **actual allocated column widths** after the table layout algorithm runs.

### 3.2 Fix Strategy

1. **Remove width capture from header callback** - Header rendering should not collect widths.

2. **Capture widths inside body closure** - Call `body.widths().to_vec()` before `heterogeneous_rows()`.

3. **Store captured widths for divider painting** - Pass the correct widths to `paint_table_dividers()`.

### 3.3 Code Flow (Fixed)

```rust
.body(|body| {
    // CORRECT: Capture actual column widths before consuming body
    let actual_widths = body.widths().to_vec();

    body.heterogeneous_rows(row_heights.into_iter(), |mut row| {
        // ... row rendering ...
    });

    // actual_widths is now available for divider painting
})
```

### 3.4 Challenge: Closure Ownership

The `body` parameter is consumed by `heterogeneous_rows()`, so we must copy the widths before that call. The widths are available immediately when the body closure is entered because the table layout has already been computed.

---

## 4. Implementation Details

### 4.1 Changes to `render_table_tablebuilder()`

#### Before (lines 3365-3440):
```rust
let mut column_widths = vec![0.0f32; column_specs.len()];
// ...
.header(header_height, |mut header| {
    for (ci, _) in column_specs.iter().enumerate() {
        header.col(|ui| {
            // ...
            column_widths[ci] = ui.min_rect().width();  // BUG
        });
    }
})
.body(|body| {
    body.heterogeneous_rows(row_height_hints.into_iter(), |mut row| {
        // ...
    });
});
// Uses incorrect column_widths for divider painting
```

#### After:
```rust
// Column widths captured from body, not header
let column_widths: RefCell<Vec<f32>> = RefCell::new(vec![0.0f32; column_specs.len()]);

.header(header_height, |mut header| {
    for (ci, _) in column_specs.iter().enumerate() {
        header.col(|ui| {
            // ... render cell, but DON'T capture widths here
            Self::extend_table_rect(&mut table_rect, ui.min_rect());
        });
    }
})
.body(|body| {
    // CORRECT: Capture actual column widths at start of body
    *column_widths.borrow_mut() = body.widths().to_vec();

    body.heterogeneous_rows(row_height_hints.into_iter(), |mut row| {
        // ... row rendering unchanged ...
    });
});

// Now column_widths contains correct values
let widths = column_widths.into_inner();
```

### 4.2 Divider Painting Validation

In `paint_table_dividers()`:

```rust
fn paint_table_dividers(
    &self,
    painter: &Painter,
    visuals: &Visuals,
    rect: egui::Rect,      // Table bounding rect
    clip_rect: egui::Rect, // Clip to avoid drawing over scrollbars
    widths: &[f32],        // MUST be from body.widths(), not min_rect
) {
    // Draw vertical dividers between columns
    let mut x = rect.left();
    for width in widths.iter().take(widths.len().saturating_sub(1)) {
        x += *width;
        // Round to pixel boundary to avoid anti-aliasing artifacts
        let x_pos = (x.round() + 0.5).clamp(rect.left(), rect.right());
        painter.vline(x_pos, rect.y_range(), separator_stroke);
    }
    // Draw outer border
    painter.rect_stroke(rect, 0.0, border_stroke);
}
```

### 4.3 Table Rect Calculation

The `table_rect` should encompass the entire table. Currently it's built by extending with each cell's `min_rect()`. This is acceptable because we're union-ing all rects, but we should verify it includes padding.

**Alternative:** Use `body.max_rect()` if available for more accurate table bounds.

---

## 5. Additional Fixes

### 5.1 Column Width Allocation in Header

The header callback receives `ui.available_width()` which should match the allocated column width. We should verify:

```rust
header.col(|ui| {
    let width = ui.available_width();  // Should equal body.widths()[ci]
    // Use this width for rendering, it's already correct
});
```

### 5.2 Row Callback Width Consistency

Similarly, in the row callback:

```rust
row.col(|ui| {
    let width = ui.available_width();  // Should equal body.widths()[ci]
    // Already using this for rendering - CORRECT
});
```

The bug is only in what we **capture for divider painting**, not in rendering widths.

---

## 6. Test Strategy

### 6.1 Unit Tests

Add test for width capture correctness:

```rust
#[test]
fn test_table_divider_widths_match_column_allocation() {
    // Create a table with known column specs
    // Verify captured widths match expected allocations
}
```

### 6.2 Visual Regression Tests

Using `examples/regressions/table-wrap.md` and `table-threat-model.md`:

1. Verify dividers align with column boundaries
2. Test at different DPI settings (100%, 125%, 150%)
3. Test with varying content lengths

### 6.3 Edge Cases

- Empty cells
- Single column tables (no dividers needed)
- Tables wider than viewport (clipping)
- Very narrow columns (dividers should not overlap)

---

## 7. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| `body.widths()` not available before `heterogeneous_rows` | Low | High | API docs confirm it's available immediately |
| RefCell borrow issues in nested closures | Medium | Medium | Test thoroughly, use `borrow_mut` carefully |
| Table rect calculation still incorrect | Low | Low | Use `body.max_rect()` as fallback |
| Breaking change to divider appearance | Low | Low | This is a bug fix, appearance will improve |

---

## 8. References

- [egui_extras TableBody Documentation](https://docs.rs/egui_extras/latest/egui_extras/struct.TableBody.html)
- [GitHub Issue #4783 - Table cell dividers](https://github.com/emilk/egui/issues/4783)
- [GitHub Issue #4158 - Vertical separators](https://github.com/emilk/egui/issues/4158)
- Previous HLD: `wrk_docs/2025.11.14 - HLD - Table Dividers and Column Widths.md`

---

## 9. Appendix: egui_extras TableBody API

```rust
pub struct TableBody<'a> {
    layout: StripLayout<'a>,
    columns: &'a [Column],
    widths: &'a [f32],          // <-- The authoritative column widths
    max_used_widths: &'a mut [f32],
    // ... other fields
}

impl<'a> TableBody<'a> {
    /// Return a vector containing all column widths for this table body.
    ///
    /// This is primarily meant for use with `TableBody::heterogeneous_rows`
    /// in cases where row heights are expected to vary according to the
    /// width of one or more cells -- for example, if text is wrapped
    /// rather than clipped within the cell.
    pub fn widths(&self) -> &[f32] {
        self.widths
    }

    /// Returns the screen-space region occupied by the table body.
    pub fn max_rect(&self) -> Rect {
        self.layout.rect
    }
}
```

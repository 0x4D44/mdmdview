# HLD: Copy File to Clipboard & Open Containing Folder

**Date:** 2026-02-24
**Status:** Draft
**Author:** Arthur + Claude

## 1. Problem Statement

When a markdown file is open in mdmdview, there is no quick way to:

1. **Share the file** (e.g., paste it into Discord, Slack, or an email) without manually finding it in Explorer
2. **Navigate to its location on disk** to perform file management operations

Both of these are one-click operations in other applications (VS Code: "Copy Path" / "Reveal in Explorer"; browsers: "Open containing folder" for downloads).

## 2. Requirements

### 2.1 Copy File to Clipboard

1. Places the currently open **file** on the system clipboard, identical to right-clicking a file in Explorer and choosing "Copy"
2. After the operation, the user can paste the file into Discord, Slack, email, etc. and it uploads/attaches as a file (not as text)
3. Accessible from the File menu and (optionally) a keyboard shortcut
4. Disabled/greyed out when viewing a sample or when no file is open (samples are embedded strings with no disk file)
5. Visual feedback: brief status bar message confirming the copy (e.g., "Copied to clipboard")

### 2.2 Open Containing Folder

1. Opens the OS file manager with the current file selected/highlighted
2. Accessible from the File menu and (optionally) a keyboard shortcut
3. Disabled/greyed out when viewing a sample or when no file is open
4. Cross-platform: Explorer on Windows, Finder on macOS, xdg-open on Linux

### 2.3 Non-Requirements

- Copying the file *contents* as text is already handled by the context menu ("Copy as Markdown")
- No need to support copying multiple files (only one file can be open at a time)
- No "Copy file path to clipboard" (nice-to-have but not requested; could add later)

## 3. Technical Analysis

### 3.1 Copy File to Clipboard (CF_HDROP)

When Explorer copies a file, it places a `CF_HDROP` clipboard format containing a `DROPFILES` structure followed by null-terminated file paths. This is what applications like Discord check when handling paste: they look for `CF_HDROP` and, if present, treat the paste as a file upload.

#### 3.1.1 Windows Implementation (Primary Target)

The Win32 clipboard API sequence:

```
OpenClipboard(NULL)
EmptyClipboard()
GlobalAlloc(GMEM_MOVEABLE, size)    // allocate DROPFILES + path
GlobalLock(hMem)                     // fill in DROPFILES struct + file path
GlobalUnlock(hMem)
SetClipboardData(CF_HDROP, hMem)
CloseClipboard()
```

The `DROPFILES` structure:

```c
typedef struct _DROPFILES {
    DWORD pFiles;   // Offset to file list (= sizeof(DROPFILES) = 20)
    POINT pt;       // Drop point (unused, set to 0,0)
    BOOL  fNC;      // Non-client area flag (FALSE)
    BOOL  fWide;    // TRUE = Unicode paths (always use wide)
} DROPFILES;
```

Followed by a double-null-terminated list of wide (UTF-16LE) file paths.

**Dependency choice**: Use the `clipboard-win` crate which is already a transitive dependency (pulled in by `arboard` via egui). This provides safe Rust wrappers around the Win32 clipboard API including raw format support. Alternatively, we can call Win32 directly via `windows-sys` — but `clipboard-win` is lighter and already compiled.

Actually, let me reconsider. Looking at the transitive deps:

- `arboard 3.6.1` depends on `clipboard-win 5.4.1` (Windows only)
- `clipboard-win` is already compiled into the binary
- However, it's a *private* transitive dep — we shouldn't depend on transitive deps directly

**Recommended approach**: Add `clipboard-win` as an explicit `[target.'cfg(windows)'.dependencies]` entry. It's already being compiled anyway, so zero additional build cost. It provides `Clipboard::new()`, `set()` with raw formats, and the `CF_HDROP` constant.

Alternatively, use raw `windows-sys` calls (6 FFI calls). This avoids adding a direct dependency but requires more unsafe code.

**Decision**: Use `clipboard-win` directly. It's already compiled, purpose-built for this, and avoids manual `unsafe` FFI.

#### 3.1.2 macOS Implementation

macOS uses `NSPasteboard` with `NSFilenamesPboardType` (deprecated) or `NSPasteboardTypeFileURL`. The simplest approach:

```rust
use std::process::Command;
// Use osascript to set the clipboard
Command::new("osascript")
    .arg("-e")
    .arg(format!("set the clipboard to (POSIX file \"{}\")", path.display()))
    .output()
```

This is a one-liner that works reliably. No additional dependency needed.

#### 3.1.3 Linux Implementation

Linux clipboard file copy is less standardized. The `xclip` / `xsel` approach for file URIs:

```rust
use std::process::Command;
// Write file URI to clipboard with appropriate target
let uri = format!("file://{}", path.display());
Command::new("xclip")
    .args(["-selection", "clipboard", "-t", "text/uri-list"])
    .stdin(std::process::Stdio::piped())
    .spawn()
    // ... write uri to stdin
```

However, this requires `xclip` to be installed. Given mdmdview is primarily a Windows application and Linux/macOS are secondary targets, a reasonable approach is:

- **Windows**: Full `CF_HDROP` implementation (primary use case)
- **macOS**: `osascript` approach (zero deps, works reliably)
- **Linux**: `xclip` with `text/uri-list` target, with fallback to copying the file path as plain text if `xclip` is not available

### 3.2 Open Containing Folder

This is well-trodden ground with a simple per-platform command:

| Platform | Command | Behavior |
|----------|---------|----------|
| Windows  | `explorer /select,"C:\path\to\file.md"` | Opens Explorer with file highlighted |
| macOS    | `open -R /path/to/file.md` | Opens Finder with file highlighted |
| Linux    | `xdg-open /path/to/parent/` | Opens file manager on parent directory (no file selection — `xdg-open` doesn't support it universally) |

All use `std::process::Command` — no additional dependencies.

**Edge case**: The file may have been deleted/moved since it was opened. We should check `path.exists()` first and show an error if the file is gone, rather than launching Explorer pointing at nothing.

### 3.3 Existing Code Patterns

**Menu items** follow a consistent pattern in `render_file_menu_contents()` (app.rs:1661):
- `ui.horizontal()` wrapping a button + right-aligned shortcut label
- `app_action_triggered()` for testability
- `ui.add_enabled(bool, ...)` for conditional enable/disable
- `ui.close_menu()` after action

**Keyboard shortcuts** are registered in `handle_shortcuts()` (app.rs:1438):
- `i.consume_shortcut(&egui::KeyboardShortcut::new(Modifiers, Key))`
- Consistent pattern of checking then executing

**Status bar** already exists and shows transient messages (loading status, queue count, etc.).

**Platform-specific code** uses `#[cfg(target_os = "windows")]` / `#[cfg(target_os = "macos")]` / `#[cfg(not(any(...)))]` pattern (see app.rs:3313).

## 4. Design

### 4.1 New Functions

Add two new methods to `MarkdownViewerApp`:

```rust
/// Copy the currently open file to the system clipboard as a file
/// (like Explorer's Copy), so it can be pasted into Discord, email, etc.
fn copy_file_to_clipboard(&mut self) {
    let Some(path) = &self.current_file else { return };
    if !path.exists() {
        self.error_message = Some("File no longer exists on disk".into());
        return;
    }
    match clipboard_copy_file(path) {
        Ok(()) => self.error_message = Some("Copied to clipboard".into()),
        Err(e) => self.error_message = Some(format!("Failed to copy: {}", e)),
    }
}

/// Open the OS file manager with the current file's location.
fn open_containing_folder(&mut self) {
    let Some(path) = &self.current_file else { return };
    if !path.exists() {
        self.error_message = Some("File no longer exists on disk".into());
        return;
    }
    if let Err(e) = reveal_in_file_manager(path) {
        self.error_message = Some(format!("Failed to open folder: {}", e));
    }
}
```

### 4.2 Platform Abstraction

Two free functions, likely in a new module `src/shell_integration.rs` to keep platform-specific code contained (app.rs is already very large):

```rust
/// Place a file on the system clipboard as a file copy (like Explorer Copy).
pub fn clipboard_copy_file(path: &Path) -> anyhow::Result<()>;

/// Open the OS file manager and highlight/select the given file.
pub fn reveal_in_file_manager(path: &Path) -> anyhow::Result<()>;
```

#### 4.2.1 `clipboard_copy_file` — Windows

```rust
#[cfg(target_os = "windows")]
pub fn clipboard_copy_file(path: &Path) -> anyhow::Result<()> {
    use clipboard_win::{Clipboard, formats};
    use std::mem;

    // Canonicalize to get absolute path with \\?\ prefix stripped
    let abs_path = path.canonicalize()?;
    let path_str = abs_path.to_string_lossy();
    // Strip \\?\ prefix if present (Explorer doesn't use it)
    let clean_path = path_str.strip_prefix(r"\\?\").unwrap_or(&path_str);

    // Encode as UTF-16 with null terminator
    let wide: Vec<u16> = clean_path.encode_utf16()
        .chain(std::iter::once(0))  // null terminator for this path
        .chain(std::iter::once(0))  // second null = end of list
        .collect();

    // Build DROPFILES structure
    let dropfiles_size = 20u32; // sizeof(DROPFILES)
    let data_size = dropfiles_size as usize + wide.len() * 2;
    let mut buffer = vec![0u8; data_size];

    // DROPFILES header: pFiles=20, pt=(0,0), fNC=0, fWide=1
    buffer[0..4].copy_from_slice(&dropfiles_size.to_le_bytes());  // pFiles
    // pt.x, pt.y, fNC all zero (already zeroed)
    buffer[16..20].copy_from_slice(&1u32.to_le_bytes());          // fWide = TRUE

    // Copy wide string data after header
    let wide_bytes: &[u8] = unsafe {
        std::slice::from_raw_parts(wide.as_ptr() as *const u8, wide.len() * 2)
    };
    buffer[dropfiles_size as usize..].copy_from_slice(wide_bytes);

    // Set clipboard data with CF_HDROP format
    let _clip = Clipboard::new_attempts(10)
        .map_err(|e| anyhow::anyhow!("Failed to open clipboard: {}", e))?;
    clipboard_win::raw::empty()
        .map_err(|e| anyhow::anyhow!("Failed to empty clipboard: {}", e))?;
    clipboard_win::raw::set_without_clear(
        clipboard_win::formats::CF_HDROP,
        &buffer,
    ).map_err(|e| anyhow::anyhow!("Failed to set clipboard data: {}", e))?;

    Ok(())
}
```

#### 4.2.2 `clipboard_copy_file` — macOS

```rust
#[cfg(target_os = "macos")]
pub fn clipboard_copy_file(path: &Path) -> anyhow::Result<()> {
    let abs_path = path.canonicalize()?;
    let script = format!(
        "set the clipboard to (POSIX file \"{}\")",
        abs_path.display()
    );
    let output = std::process::Command::new("osascript")
        .arg("-e")
        .arg(&script)
        .output()?;
    if !output.status.success() {
        anyhow::bail!("osascript failed: {}", String::from_utf8_lossy(&output.stderr));
    }
    Ok(())
}
```

#### 4.2.3 `clipboard_copy_file` — Linux

```rust
#[cfg(not(any(target_os = "windows", target_os = "macos")))]
pub fn clipboard_copy_file(path: &Path) -> anyhow::Result<()> {
    let abs_path = path.canonicalize()?;
    let uri = format!("file://{}\n", abs_path.display());

    let mut child = std::process::Command::new("xclip")
        .args(["-selection", "clipboard", "-t", "text/uri-list"])
        .stdin(std::process::Stdio::piped())
        .spawn()
        .map_err(|_| anyhow::anyhow!(
            "xclip not found. Install with: sudo apt install xclip"
        ))?;

    if let Some(stdin) = child.stdin.as_mut() {
        use std::io::Write;
        stdin.write_all(uri.as_bytes())?;
    }
    child.wait()?;
    Ok(())
}
```

#### 4.2.4 `reveal_in_file_manager` — All Platforms

```rust
pub fn reveal_in_file_manager(path: &Path) -> anyhow::Result<()> {
    let abs_path = path.canonicalize()?;

    #[cfg(target_os = "windows")]
    {
        std::process::Command::new("explorer")
            .arg("/select,")
            .arg(&abs_path)
            .spawn()?;
    }

    #[cfg(target_os = "macos")]
    {
        std::process::Command::new("open")
            .arg("-R")
            .arg(&abs_path)
            .spawn()?;
    }

    #[cfg(not(any(target_os = "windows", target_os = "macos")))]
    {
        if let Some(parent) = abs_path.parent() {
            std::process::Command::new("xdg-open")
                .arg(parent)
                .spawn()?;
        }
    }

    Ok(())
}
```

### 4.3 Menu Integration

Add both items to `render_file_menu_contents()` between "Reload" and "Find...":

```
Open...          Ctrl+O
Save             Ctrl+S
Close            Ctrl+W
Reload           F5
─────────────────────────
Copy File                    ← NEW (enabled only when current_file is Some)
Open Folder                  ← NEW (enabled only when current_file is Some)
─────────────────────────
Find...          Ctrl+F
─────────────────────────
Samples  ▸
```

Rationale for placement: These are file-level operations, so they belong in the file operations group. They're between "Reload" (which acts on the current file) and "Find" (which acts on content). A separator before and after groups them visually.

Menu item code follows the existing pattern:

```rust
ui.separator();

ui.horizontal(|ui| {
    let enabled = self.current_file.is_some();
    let button = ui.add_enabled(
        enabled,
        egui::Button::new("Copy File"),
    );
    if app_action_triggered(button.clicked(), "menu_copy_file") {
        self.copy_file_to_clipboard();
        ui.close_menu();
    }
});

ui.horizontal(|ui| {
    let enabled = self.current_file.is_some();
    let button = ui.add_enabled(
        enabled,
        egui::Button::new("Open Folder"),
    );
    if app_action_triggered(button.clicked(), "menu_open_folder") {
        self.open_containing_folder();
        ui.close_menu();
    }
});

ui.separator();
```

### 4.4 Keyboard Shortcuts

None. These are occasional convenience operations — the menu is sufficient.

### 4.5 Status Bar Feedback

Reuse the existing status bar area. Set `error_message` for failures (already rendered in red). For success, set a brief transient message in the existing status bar text (e.g., "Copied to clipboard") — this can use the same `error_message` field since a success message replacing an error message is fine, or we can just let it be a non-error status line. The simplest approach: set `error_message = Some("Copied to clipboard".into())` — it shows in the status area and gets cleared on the next action. Good enough.

### 4.6 Context Menu

No context menu changes. Both operations are File menu only.

## 5. New Dependencies

| Dependency | Scope | Purpose | Cost |
|-----------|-------|---------|------|
| `clipboard-win` | `[target.'cfg(windows)'.dependencies]` | CF_HDROP clipboard format | Zero — already compiled as transitive dep of arboard |

No new dependencies on macOS/Linux (uses `std::process::Command` only).

## 6. New Files

| File | Purpose |
|------|---------|
| `src/shell_integration.rs` | Platform-specific `clipboard_copy_file()` and `reveal_in_file_manager()` functions |

This keeps the platform FFI / command-spawning logic out of app.rs (which is already ~6800+ lines).

## 7. Testing Strategy

### 7.1 Unit Tests (in `shell_integration.rs`)

- **`test_reveal_in_file_manager_nonexistent_path`**: Verify canonicalize fails gracefully for missing files
- **`test_clipboard_copy_file_nonexistent_path`**: Same for clipboard copy

### 7.2 Integration Tests (in `app.rs` test module)

Using the existing `app_action_triggered` test infrastructure:

- **`test_copy_file_menu_disabled_no_file`**: Verify menu item is disabled when `current_file` is None (sample loaded)
- **`test_copy_file_menu_enabled_with_file`**: Verify menu item is enabled when a file is loaded
- **`test_open_folder_menu_disabled_no_file`**: Same pattern for open folder
- **`test_open_folder_menu_enabled_with_file`**: Same pattern for open folder
- **`test_copy_file_sets_status_message`**: Verify `error_message` is set after copy action

### 7.3 Manual Testing

- Open a `.md` file, use File > Copy File, paste into Discord — verify file uploads
- Open a `.md` file, use File > Open Folder — verify Explorer opens with file selected
- Load a sample, verify both menu items are greyed out
- Close all files, verify both menu items are greyed out
- Open a file, delete it externally, then try both operations — verify error message

### 7.4 What We Don't Test

- Actual clipboard contents on CI (clipboard APIs require a desktop session)
- Actual Explorer/Finder launch (would spawn visible windows)
- These are covered by manual testing only

## 8. Implementation Plan

| Step | Description | Files |
|------|-------------|-------|
| 1 | Add `clipboard-win` to `Cargo.toml` (Windows dep) | `Cargo.toml` |
| 2 | Create `src/shell_integration.rs` with both functions | `src/shell_integration.rs` |
| 3 | Add `mod shell_integration;` to `lib.rs` or `main.rs` | `src/lib.rs` |
| 4 | Add menu items to `render_file_menu_contents()` | `src/app.rs` |
| 5 | Wire `copy_file_to_clipboard()` and `open_containing_folder()` methods | `src/app.rs` |
| 6 | Add unit + integration tests | `src/shell_integration.rs`, `src/app.rs` |
| 7 | Manual test on Windows | — |

Estimated scope: ~150-200 lines of new code across 3 files.

## 9. Resolved Questions

1. **Shortcut keys**: None — menu only. *(Decided 2026-02-24)*
2. **Status feedback**: Reuse existing `error_message` / status bar. *(Decided 2026-02-24)*
3. **Context menu**: File menu only, no context menu changes. *(Decided 2026-02-24)*

## 10. Risks

| Risk | Likelihood | Mitigation |
|------|-----------|------------|
| `clipboard-win` API changes between versions | Low | Pin version; it's a stable, mature crate |
| `CF_HDROP` not recognized by some apps | Low | This is the standard Windows file clipboard format since Win95 |
| `osascript` path quoting issues on macOS | Low | `canonicalize()` resolves symlinks; paths with quotes are unlikely for `.md` files |
| `xclip` not installed on Linux | Medium | Clear error message with install instructions |
| File deleted between menu click and action | Low | Pre-check with `path.exists()` and show error |

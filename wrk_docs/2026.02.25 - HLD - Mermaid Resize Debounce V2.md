# HLD: Mermaid Resize Debounce (V2)

**Date**: 2026-02-25
**Status**: Draft
**Scope**: `mermaid_renderer.rs` (primary), `markdown_renderer.rs` (minor)
**Previous**: V1 — initial design
**V2 changes**: Fixed 6 issues found during review (see [Review Notes](#review-notes-v1--v2) at end)

---

## Problem

Resizing the application window while Mermaid diagrams are visible causes severe UI sluggishness. The main thread feels blocked and the resize is hard to perform.

### Root Cause

There are two compounding problems:

**1. No debounce — every width bucket change fires a new render job**

`render_block()` runs every frame, once per visible Mermaid diagram. It computes a `width_bucket` (rounded to 32px steps) and a `texture_key` that embeds the bucket. When the window is resized, the bucket changes approximately every 32 pixels of drag. Each new bucket means a new `texture_key`, which misses the texture cache, which triggers a new QuickJS render + rasterize job.

A 400px resize drag across 4 visible diagrams produces ~48 render jobs (12 buckets x 4 diagrams). The 32px bucketing provides some quantization but no temporal debounce at all.

**2. Stale results are never discarded — all complete and upload to GPU**

Old render jobs for stale width buckets continue to completion. Each result causes a `ctx.load_texture()` call on the main thread in `poll_mermaid_results()`, uploading the RGBA buffer to the GPU. A 4096x4096 diagram is ~64MB of pixel data per upload. Multiple diagrams x multiple stale widths = many synchronous GPU uploads, each stalling the frame by 10-50ms.

The bounded queue (capacity 16) limits in-flight jobs, but during resize the queue stays perpetually full because new jobs are enqueued as fast as old ones complete.

### What the User Sees

1. Window resize becomes laggy/jerky (frame stalls from GPU uploads)
2. Diagrams flash "Rendering diagram locally..." even though textures at a slightly different width already exist in cache
3. After resize settles, diagrams re-render at the final width — unnecessary delay

---

## Current Architecture

### Key Constants

| Constant | Value | Purpose |
|----------|-------|---------|
| `MERMAID_WIDTH_BUCKET_STEP` | 32 | Width quantization (pixels) |
| `MAX_MERMAID_JOBS` | 4 | Worker thread count |
| Queue capacity | 16 | `MAX_MERMAID_JOBS * 4` |
| `MERMAID_TEXTURE_CACHE_CAPACITY` | 128 | LRU texture cache entries |
| `MERMAID_SVG_CACHE_CAPACITY` | 64 | LRU SVG cache entries |

### Key Data Types

```
texture_key = "mermaid:{svg_key:016x}:w{width_bucket}:s{scale_bucket}:bg{bg_hex}"
svg_key     = hash(theme_name + ":" + code)
```

`texture_key` uniquely identifies a rendered bitmap. It changes when *any* of: diagram code, theme, width bucket, scale, or background changes. `svg_key` identifies the semantic SVG content (code + theme) and is width-independent.

### Current Frame Flow

```
render_to_ui(ui, elements)
  │
  ├─ mermaid.begin_frame()          ← once per frame, resets frame_pending flag
  │
  └─ for each element:
       └─ render_mermaid_block(ui, code)
            └─ mermaid.render_block(ui, code, scale, font_size, theme)
                 │
                 ├─ compute svg_key, width_bucket, texture_key
                 │
                 ├─ poll_mermaid_results(ctx)   ← drains ALL results from channel
                 │    └─ for each result:
                 │         ctx.load_texture(rgba)  ← GPU upload, BLOCKS main thread
                 │         store in texture cache
                 │
                 ├─ if texture_key in texture_cache:
                 │    └─ display cached texture, RETURN
                 │
                 ├─ if svg_key in error_cache:
                 │    └─ display error, RETURN
                 │
                 ├─ if texture_key NOT in pending_set:
                 │    ├─ build MermaidRequest (with code or cached SVG)
                 │    └─ enqueue_mermaid_job(request)
                 │         ├─ Ok: add to pending_set, request_repaint
                 │         ├─ QueueFull: set waiting_for_slot flag
                 │         └─ Disconnected: show error
                 │
                 └─ show placeholder ("Rendering diagram locally...")
```

**Important**: `poll_mermaid_results` is called once per visible diagram per frame (inside `render_block`), not once per frame. Diagram #1 typically drains all pending results; diagrams #2-4 find an empty channel. This affects the staleness check — see [Mechanism B](#b-discard-stale-results-in-poll_mermaid_results).

### Worker Thread Flow

```
loop {
    job = job_rx.recv()           ← blocks until job available
    result = process_job(job)
    result_tx.send(result)        ← blocks until space in result channel
}

process_job(request):
    svg = request.svg OR render_svg(code)   ← QuickJS execution (slow)
    svg = apply_fixups(svg)                 ← string transforms
    (rgba, w, h) = rasterize_svg(svg, width_bucket, scale_bucket, bg)
    return MermaidResult { svg, rgba, size }
```

---

## Design

### Strategy

Two complementary changes:

**A. Debounce: suppress enqueue during resize; show stale texture as placeholder**
**B. Discard: skip GPU upload for results whose width bucket is stale**

### A. Debounce — Suppress Enqueue During Resize

#### Concept

Track when the width bucket changes. When it does, start a cooldown timer. During the cooldown, don't enqueue new render jobs — instead, display the *best available* cached texture (from a nearby width bucket) scaled to fit. Only enqueue the render once the cooldown expires (meaning the resize has settled).

This is a trailing-edge debounce: the timer resets every time the width changes, and fires once the width stabilizes for the debounce duration.

#### New State

Add to `MermaidRenderer`:

```rust
/// Per-diagram debounce state for resize-aware rendering.
/// Key: svg_key (u64). Tracks the last-enqueued width bucket
/// and the time when the width bucket last changed.
#[cfg(feature = "mermaid-quickjs")]
mermaid_width_debounce: RefCell<HashMap<u64, WidthDebounce>>,
```

```rust
#[cfg(feature = "mermaid-quickjs")]
struct WidthDebounce {
    /// The width bucket for which a render was last successfully enqueued.
    last_enqueued_bucket: u32,
    /// The width bucket observed on the most recent frame.
    /// Used to detect continuing resize (trailing-edge timer reset).
    last_seen_bucket: u32,
    /// When the width bucket last changed (i.e., last_seen_bucket was updated).
    /// None if the current bucket matches last_enqueued_bucket (no resize in progress).
    bucket_changed_at: Option<Instant>,
}
```

The `last_seen_bucket` field is critical for correct trailing-edge behavior: the timer resets whenever the width changes from one frame to the next, not just when it differs from `last_enqueued_bucket`. Without it, oscillating near a bucket boundary could prevent the debounce from ever firing.

#### New Constant

```rust
/// How long to wait after the last width bucket change before
/// enqueueing a re-render. Prevents flooding workers during resize.
const MERMAID_RESIZE_DEBOUNCE_MS: u64 = 150;
```

150ms is chosen because:
- Fast enough that diagrams update promptly after resize stops
- Slow enough to collapse a typical resize drag into 1-2 render requests
- Matches common UI debounce intervals (100-200ms range)

#### Modified Flow in `render_block`

After computing `svg_key`, `width_bucket`, `texture_key`:

```
1. poll_mermaid_results(ctx)  (unchanged position)

2. Check texture_key in cache → hit? display, RETURN (unchanged)

3. Check error cache → hit? display, RETURN (unchanged)

4. NEW: Debounce gate
   a. Look up WidthDebounce for this svg_key
   b. If no entry exists:
      → first render — no debounce, proceed to enqueue (step 5)
   c. If entry exists and width_bucket == last_enqueued_bucket:
      → bucket matches last enqueue — no resize in progress
      → clear bucket_changed_at (timer no longer needed)
      → proceed to enqueue (step 5)
   d. If entry exists and width_bucket != last_enqueued_bucket:
      → resize in progress — apply trailing-edge debounce:
      → if width_bucket != last_seen_bucket:
          update last_seen_bucket = width_bucket
          bucket_changed_at = Some(Instant::now())   ← reset timer
      → check if bucket_changed_at elapsed >= MERMAID_RESIZE_DEBOUNCE_MS:
        YES → debounce expired, proceed to enqueue (step 5)
        NO  → still in cooldown:
              • look up stale texture via mermaid_latest_texture[svg_key]
              • if found in texture cache: display it scaled, RETURN
              • if not found: show placeholder, RETURN
              • request_repaint_after(remaining debounce time)

5. Enqueue if not pending (existing logic, with debounce bookkeeping):
   On Ok(enqueued):
     - add to pending_set
     - create or update WidthDebounce entry:
         last_enqueued_bucket = width_bucket
         last_seen_bucket = width_bucket
         bucket_changed_at = None
     - request_repaint
   On QueueFull:
     - waiting_for_slot = true
     - do NOT create/update debounce entry
     - request_repaint
   On Disconnected:
     - show error (unchanged)
```

**Key V2 change**: The debounce entry is created/updated only on successful enqueue (step 5), not when first encountered (step 4b). This prevents a QueueFull on first render from creating a debounce entry that would incorrectly suppress future enqueue attempts.

#### Finding the Best Stale Texture

When debounce suppresses the enqueue, we need a texture to show. The texture cache is keyed by full `texture_key` (which includes `width_bucket`), so we can't do a direct lookup.

Maintain a secondary index:

```rust
/// Maps svg_key → the texture_key of the most recently stored texture.
/// Used during resize debounce to find a stale-but-displayable texture.
#[cfg(feature = "mermaid-quickjs")]
mermaid_latest_texture: RefCell<HashMap<u64, String>>,
```

Updated in `store_mermaid_texture`:
```rust
fn store_mermaid_texture(&self, key: &str, texture: TextureHandle, size: [u32; 2], svg_key: u64) {
    self.mermaid_textures.borrow_mut().insert(key.to_string(), MermaidTextureEntry { texture, size });
    self.mermaid_latest_texture.borrow_mut().insert(svg_key, key.to_string());
}
```

During debounce, look up `mermaid_latest_texture[svg_key]`, then look up that key in `mermaid_textures`. The existing display logic (lines 759-769) already handles textures wider than available width by scaling down. For textures narrower than available width, they display at their original size — which may leave empty space to the right during debounce. See [Accepted Limitations](#accepted-limitations).

**LRU eviction note**: The texture at the `mermaid_latest_texture` key can be evicted from the 128-entry LRU cache. If lookup fails, fall through to the placeholder. This is acceptable — see [Accepted Limitations](#accepted-limitations).

#### Debounce State Lifecycle

Clear `mermaid_width_debounce` and `mermaid_latest_texture` in:
- `clear_mermaid_cache()` — theme change, full cache invalidation
- `release_gpu_textures()` — window minimize/deactivation

Memory impact: ~108 bytes per unique diagram ever rendered. Even 1000 diagrams = ~108KB, negligible. Cleanup on cache clear prevents unbounded growth across sessions.

### B. Discard Stale Results in `poll_mermaid_results`

Even with debounce, some stale jobs may already be in the queue when debounce kicks in. We want to skip the expensive GPU upload for results whose width bucket no longer matches what's needed.

#### Concept

When processing a `MermaidResult`, check if the `width_bucket` encoded in the `texture_key` still matches what the UI currently needs. If it doesn't, cache the SVG (cheap) but skip the RGBA upload (expensive).

#### Tracking the "Wanted" Width Bucket

Add a per-diagram tracking map:

```rust
/// The width bucket that was most recently *requested* for each svg_key.
/// Updated every frame in render_block before the debounce gate.
/// Used by poll_mermaid_results to detect stale results.
#[cfg(feature = "mermaid-quickjs")]
mermaid_wanted_bucket: RefCell<HashMap<u64, u32>>,
```

In `render_block`, after computing `width_bucket` and before `poll_mermaid_results`:
```rust
self.mermaid_wanted_bucket.borrow_mut().insert(svg_key, width_bucket);
```

This is updated *every frame*, even during debounce (since we still compute the bucket, we just don't enqueue).

**Per-diagram polling subtlety**: `poll_mermaid_results` runs inside `render_block`, not in `begin_frame`. When diagram #1 drains results for diagram #3, diagram #3's `wanted_bucket` is from the **previous frame** (it hasn't been processed yet this frame). During resize, this means the wanted bucket is at most one bucket (32px) behind. Since stale results are typically from much older buckets, the one-frame lag doesn't cause correctness issues — at worst, one nearly-current result passes the staleness check and gets uploaded (a cheap near-miss).

#### Modified `poll_mermaid_results`

```rust
fn poll_mermaid_results(&self, ctx: &egui::Context) -> bool {
    let mut changed = false;
    while let Ok(result) = self.mermaid_result_rx.try_recv() {
        let MermaidResult { svg_key, texture_key, svg, rgba, size, error } = result;
        self.mermaid_pending.borrow_mut().remove(&texture_key);

        // Always cache the SVG — it's content-addressed and width-independent
        if let Some(svg) = svg {
            self.mermaid_svg_cache.borrow_mut().insert(svg_key, svg);
            self.mermaid_errors.borrow_mut().remove(&svg_key);
        }

        // NEW: Check if this result's width bucket is still wanted
        let stale = self.is_stale_result(&texture_key, svg_key);

        if stale {
            // Skip GPU upload — this width is no longer needed.
            // The SVG is already cached above, so re-render at the
            // correct width will be fast (skip QuickJS, just rasterize).
            changed = true;
            continue;
        }

        // Upload texture to GPU (existing logic, unchanged)
        if let Some(rgba) = rgba {
            if let Some((w, h)) = size {
                let img = egui::ColorImage::from_rgba_unmultiplied(
                    [w as usize, h as usize], &rgba
                );
                let tex = ctx.load_texture(
                    texture_key.clone(), img, egui::TextureOptions::LINEAR
                );
                self.store_mermaid_texture(&texture_key, tex, [w, h], svg_key);
                self.mermaid_texture_errors.borrow_mut().remove(&texture_key);
            }
        }

        if let Some(err) = error { /* unchanged */ }
        changed = true;
    }
    changed
}
```

#### Staleness Check

```rust
/// Returns true if the result's width bucket no longer matches
/// what the UI currently wants for this diagram.
fn is_stale_result(&self, texture_key: &str, svg_key: u64) -> bool {
    // Extract width_bucket from texture_key
    // Format: "mermaid:{hex}:w{bucket}:s{scale}:bg{hex}"
    let result_bucket = Self::parse_width_from_texture_key(texture_key);
    let wanted_bucket = self.mermaid_wanted_bucket.borrow().get(&svg_key).copied();
    match (result_bucket, wanted_bucket) {
        (Some(rb), Some(wb)) => rb != wb,
        _ => false, // Can't determine staleness, process normally
    }
}

/// Parse the width bucket from a texture key string.
fn parse_width_from_texture_key(key: &str) -> Option<u32> {
    // "mermaid:0123456789abcdef:w320:s100:bgffffffff"
    //                           ^^^^
    let w_start = key.find(":w")? + 2;
    let w_end = key[w_start..].find(':')? + w_start;
    key[w_start..w_end].parse().ok()
}
```

#### Wanted Bucket Lifecycle

Clear `mermaid_wanted_bucket` in:
- `clear_mermaid_cache()` — same as debounce maps
- `release_gpu_textures()` — same as debounce maps

---

## Interaction Between A and B

The two mechanisms work together but handle different phases:

| Phase | Debounce (A) | Discard (B) |
|-------|--------------|-------------|
| Resize starts, bucket changes | Suppresses new enqueues | N/A — no new results yet |
| Jobs already in queue when resize started | N/A — already enqueued | Skips GPU upload for stale widths |
| Resize settles, debounce expires | Enqueues at final width | Results at final width pass through |
| Initial render (no resize) | No-op (bucket matches) | No-op (nothing stale) |

Without A, the queue keeps filling with new jobs during resize. Without B, pre-existing jobs waste GPU bandwidth. Both are needed.

---

## Edge Cases

### First render of a diagram
No `WidthDebounce` entry exists → proceed directly to enqueue (step 5). If enqueue succeeds, debounce entry is created with the initial bucket. No debounce delay on first render.

### First render + QueueFull
No debounce entry exists → proceed to enqueue → QueueFull. No debounce entry is created (entry is only created on successful enqueue). Next frame: still no entry → retry enqueue. Repeat until queue has space. No debounce interference.

### Scale change (zoom) without width change
`scale_bucket` changes but `width_bucket` doesn't → `texture_key` changes, cache miss → debounce gate sees `width_bucket == last_enqueued_bucket` → proceeds to enqueue. Zoom is not affected by width debounce.

### Theme change
`clear_mermaid_cache()` clears textures, SVG cache, errors, AND the three new maps (`mermaid_width_debounce`, `mermaid_latest_texture`, `mermaid_wanted_bucket`). Diagrams re-render fresh from first-render path.

### Multiple diagrams visible
Each diagram has its own `svg_key` and therefore its own independent debounce state. They don't interfere with each other.

### Window maximize / snap (instant large resize)
Single bucket change → debounce timer starts → 150ms later, enqueue fires. The stale texture displays during the 150ms gap, which is fine because maximize is a single step, not a drag.

### Oscillation near a bucket boundary
User drags slowly near a 32px boundary, causing the width bucket to alternate between N and N+32:
- `last_seen_bucket` updates on each change → timer resets each time
- Debounce fires 150ms after the last change (trailing edge)
- During oscillation, the texture cache serves whichever bucket was previously rendered (cache hit at step 2)

### Debounce timer and `request_repaint_after`
During debounce, we call `ui.ctx().request_repaint_after(remaining)` so the frame loop wakes up when the timer expires. `request_repaint_after` is already used in the codebase (`app.rs:3134`), and egui coalesces overlapping repaint requests.

### `poll_mermaid_results` per-diagram ordering
`poll_mermaid_results` is called inside `render_block` (once per diagram per frame), not in `begin_frame`. Diagram #1 drains all results; when checking staleness for diagram #3's results, diagram #3's `wanted_bucket` is from the previous frame (one bucket behind at most during resize). This is a near-miss, not a correctness issue. See [Mechanism B](#tracking-the-wanted-width-bucket) for detailed analysis.

### Screenshot mode
Screenshot mode renders a single frame with fixed dimensions. No resize happens, so debounce never activates. No behavioral change.

### Debounce-expired enqueue hits QueueFull
After 150ms cooldown, the enqueue attempt may find the queue still full (workers processing older jobs). The debounce entry retains the old `last_enqueued_bucket`. Next frame: `width_bucket != last_enqueued_bucket` → checks timer → already expired → retries enqueue. This loops once per frame until the queue has space, matching current QueueFull retry behavior.

---

## Accepted Limitations

### Stale texture doesn't scale up during debounce
The current display logic (lines 762-766) scales textures down when wider than `available_width`, but shows them at original size when narrower. During debounce after making the window wider, the stale texture appears at its original width with empty space to the right. This is a cosmetic issue that lasts at most 150ms during active drag. Stretching the texture would look worse (blurry/distorted). Accepted.

### LRU eviction can invalidate `mermaid_latest_texture`
The `mermaid_latest_texture` index stores a texture key string, but the corresponding texture can be evicted from the 128-entry LRU cache under memory pressure. If lookup fails during debounce, the display falls through to the placeholder. This is rare in practice: with mechanism B discarding stale uploads, each diagram has ~1 cached texture during resize, so eviction only occurs with 100+ unique diagrams. When it does occur, the fallback to placeholder is the correct behavior for a memory-constrained situation. Accepted.

### One-frame staleness lag for cross-diagram results
When diagram #1 polls a result for diagram #3, the staleness check uses diagram #3's wanted bucket from the previous frame. A nearly-current result (previous-frame bucket) may pass the check and get uploaded. This is at most one unnecessary GPU upload per resize step per diagram — far better than the current behavior of uploading all stale results. Accepted.

---

## Files Changed

| File | Changes |
|------|---------|
| `src/mermaid_renderer.rs` | Add `WidthDebounce` struct, 3 new `RefCell<HashMap>` fields, debounce gate in `render_block`, staleness check in `poll_mermaid_results`, `parse_width_from_texture_key`, `mermaid_latest_texture` index, update `store_mermaid_texture` signature (+svg_key param), update `clear_mermaid_cache`, update `release_gpu_textures` |
| `src/markdown_renderer.rs` | No changes (clear_mermaid_cache signature unchanged) |

No changes to `app.rs`, `window_state.rs`, or any Python tools.

---

## Constants to Tune

| Constant | Proposed Value | Rationale |
|----------|---------------|-----------|
| `MERMAID_RESIZE_DEBOUNCE_MS` | 150 | Balances responsiveness vs. flood suppression |
| `MERMAID_WIDTH_BUCKET_STEP` | 32 (unchanged) | Still useful for cache reuse across small wiggles |

The debounce interval is the primary tuning knob. Lower values = more responsive but less flood suppression. 150ms should feel instant to users (resize lag is perceptible above ~300ms).

---

## Tests

### New Tests

1. **`test_debounce_suppresses_enqueue_during_resize`** — Render at width A, then width B within debounce window. Verify no new job enqueued for width B. Verify stale texture from width A is displayed.

2. **`test_debounce_fires_after_cooldown`** — Render at width A, change to width B, wait > debounce interval, render again. Verify job enqueued for width B.

3. **`test_debounce_resets_on_continued_resize`** — Change width A→B→C within debounce window. Verify debounce timer resets on B→C transition. Only one job fires (for width C) after final cooldown.

4. **`test_stale_result_skips_gpu_upload`** — Enqueue job at width A, change wanted bucket to B, deliver result for A. Verify no `load_texture` call, but SVG is cached.

5. **`test_stale_result_caches_svg`** — Same as above, verify SVG cache populated even though texture upload skipped.

6. **`test_first_render_no_debounce_delay`** — First render of a new diagram proceeds immediately without debounce.

7. **`test_first_render_queue_full_no_debounce_entry`** — First render with QueueFull: verify no WidthDebounce entry created. Next attempt should retry enqueue, not enter debounce.

8. **`test_theme_change_clears_debounce_state`** — Call `clear_mermaid_cache()`, verify debounce maps are empty.

9. **`test_parse_width_from_texture_key`** — Unit test for key parsing with various formats.

10. **`test_latest_texture_index_updated_on_store`** — Verify `mermaid_latest_texture` maps svg_key to most recent texture_key.

11. **`test_debounce_trailing_edge_timer_reset`** — Width changes A→B, then B→C before timer expires. Verify timer resets on B→C transition (trailing edge). Verify debounce fires 150ms after C, not 150ms after B.

12. **`test_release_gpu_textures_clears_debounce_state`** — Call `release_gpu_textures()`, verify debounce maps cleared.

### Modified Tests

Any test that calls `store_mermaid_texture` will need to pass the additional `svg_key` parameter.

---

## Alternatives Considered

### Increase width bucket step to 128px or 256px
Would reduce the number of re-renders during resize, but also means diagrams look noticeably wrong (up to 256px too wide/narrow) even after resize settles. Doesn't address the stale-result GPU upload problem. Rejected.

### Cancel in-flight jobs via a shared AtomicBool
Workers would check a "cancel" flag periodically during QuickJS execution. However, QuickJS doesn't support cooperative cancellation — `render_svg` is a single blocking call into the JS runtime. We'd need to interrupt from outside, which risks leaving the runtime in an invalid state. Rejected as too complex for the benefit.

### Drain and discard the entire job queue on resize
Replace the bounded channel with one that supports `drain()`. When width changes, drain all pending jobs. Simple but loses jobs for *other* diagrams that haven't changed width. Also doesn't help with jobs already being processed by workers. Rejected.

### Rate-limit `poll_mermaid_results` to 1 result per frame
Would spread GPU uploads across frames, reducing per-frame stalls. But still uploads stale textures. Could be combined with the discard mechanism as an additional refinement, but the discard alone is simpler and more effective. Deferred — can add later if needed.

### Move `poll_mermaid_results` to `begin_frame`
Would make polling truly once-per-frame (currently per-diagram), eliminating the cross-diagram staleness lag. Requires adding `ctx: &egui::Context` parameter to `begin_frame`. The improvement is marginal (one fewer stale upload per resize step) and the current per-diagram polling is correct enough. Deferred — can revisit if the one-frame lag proves problematic.

---

## Review Notes (V1 → V2)

Issues found during V1 review and their resolutions:

1. **`poll_mermaid_results` call pattern misdescribed**: V1 said it "runs at the start of render_block, before the per-diagram render loop". Actually runs inside `render_block`, once per visible diagram. Diagram #1 drains all results; others find empty channel. **Fixed**: Corrected frame flow diagram and added per-diagram polling analysis.

2. **Trailing-edge debounce needed `last_seen_bucket`**: V1's `WidthDebounce` only had `last_enqueued_bucket` + `bucket_changed_at`. Without tracking the previously-seen bucket, the timer wouldn't reset on width changes between uncached buckets (e.g., 352→384). **Fixed**: Added `last_seen_bucket` field. Timer resets when `width_bucket != last_seen_bucket`.

3. **QueueFull on first render created premature debounce entry**: V1 created the debounce entry when first encountered (step 3b), before knowing if enqueue would succeed. A QueueFull would leave a debounce entry that could suppress future enqueue attempts. **Fixed**: Entry created only on successful enqueue (step 5).

4. **Debounce map unbounded growth**: V1 mentioned clearing maps in `clear_mermaid_cache` but not in `release_gpu_textures`. Maps would accumulate entries across file changes. **Fixed**: Added cleanup in `release_gpu_textures`. Documented negligible memory impact (~108 bytes/diagram).

5. **LRU eviction invalidates `mermaid_latest_texture`**: V1 didn't address what happens when the texture at the indexed key is evicted from the LRU cache. **Fixed**: Documented as accepted limitation — falls through to placeholder, rare in practice due to mechanism B reducing cache churn.

6. **Stale texture doesn't scale up**: V1 didn't address that the existing display code (lines 762-766) only scales textures down, not up. During debounce after widening the window, the stale texture appears at original size. **Fixed**: Documented as accepted aesthetic limitation — stretching would look worse (blurry).
